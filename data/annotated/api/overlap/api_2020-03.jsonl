{"id": "3dXcWf", "name": "[sound] Aphrosilia", "author": "jeyko", "description": "banana ", "tags": ["sound", "music", "audio"], "likes": 8, "viewed": 585, "published": 3, "date": "1585685340", "time_retrieved": "2024-07-30T21:15:35.299547", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),2.1)*0.4;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*2.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    \n    fragColor.r *= 0.97 + dot(uvn,uvn)*0.6;\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    fragColor = pow(fragColor, vec4(0.4545));\n    \n\n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI acos(-1.)\n\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm (135./2.)\n\n#define tick (60./bpm)\n\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n#define OFFS (msr*1.)*0.\n\n//float[] probK = float[16](0.1,0.9,0.1,0.9,0.4,0.9,0.1,0.3,0.9,0.4,0.9,0.,0.9,0.1,0.4,0.5);\nfloat[] probK = float[16](0.9,0.1,0.1,0.2,0.,0.1,0.1,0.2,0.9,0.2,0.4,0.2,0.2,0.9,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](F,T,F,F,T,F,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\nbool[] pattG = bool[8](F,T,F,F,T,F,T,T);\n\n\nfloat[] offsH = float[8](0.02,0.1,0.1,0.02,0.29,0.1,0.0,0.02); \n\n\nfloat[] notesLB = float[8](2.,1.,0.,2.,0.,2.,0.,3.);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst float scale = -4.;\n\nconst vec4 cmin9 = vec4(0.,3.,10.,14.) + scale;\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.) + scale;\nconst vec4 cmin7 = vec4(0.,3.,7.,10.) + scale;\nconst vec4 cmin73 = vec4(0.,7.,10.,3.) + scale;\nconst vec4 cmin11 = vec4(0.,10.,14.,17.) + scale;\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.) + scale;\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.) + scale;\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.) + scale;\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.) + scale;\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.) + scale;\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.) + scale;\n\nconst int chordCnt = 8;\n\n\nvec4[] chords = vec4[chordCnt](\n    cmin7,\n    cmin73 + 3.,\n    cmaj14 + 1.,\n    cmaj7 - 4.,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 + 1.\n);\n\nvec4[] chordsbb = vec4[chordCnt](\n    cmin11,\n    cmaj14 + 2. - 7.,\n    cmin7 - 2.,\n    cmaj7 + 1.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\n", "buffer_a_code": "// thanks to wyatt for teaching me how to do buffer feedback stuff thru his tutorials\n// if you would like to do something similar, i recommend checking them out\n// the code here is rather messy\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    col = max(col, 0.);\n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d)+ (e)))\n    \n    vec2 puv = vec2(atan(uv.y,uv.x)/6.28, length(uv));\n    \n    puv.y += sin(puv.x*6.28*(7.) + uv.x*20. + iTime  + sin(uv.y*20. + iTime)*6. )*0.004;\n    \n    col += smoothstep(0.,0.01,-puv.y + 0.1);\n    \n    col *= pal(0.,1.5,vec3(0.1,.4,0.7), 1.5, 2. + iTime*2. + puv.y*200.);\n    \n    vec2 nc = fragCoord/iResolution.xy - 100.*(0. + length(puv.y)*2.)*normalize(uv)/iResolution.xy*iTimeDelta;\n\t    \n\tvec2 st = 1./iResolution.xy;\n    \n    vec2 lc = nc;\n    vec4 u = texture(iChannel1, lc + vec2(0,st.y) );\n    vec4 d = texture(iChannel1, lc + vec2(0,-st.y) );\n    vec4 l = texture(iChannel1, lc + vec2(-st.x,0) );\n    vec4 r = texture(iChannel1, lc + vec2(st.x,0) );\n    \n    vec2 ddb = (vec2( r.b - l.b, u.b - d.b));\n    vec2 dd = normalize(vec2( r.r - l.r, u.r - d.r));\n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    \n    dd *= rot(3.14/2.);\n    ddb *= rot(3.14/2. - 3. - sin(iTime)*0.5 - 0.1);\n    \n    nc += dd*st*0.1;\n    nc -= ddb*st*0.2;\n    \n    if(iFrame > 0)\n    \tcol = mix(col, texture(iChannel1, nc, 0.99).xyz, 0.996);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float gT;\n    float sc;\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nvec2 hash22(vec2 p)   \n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\nvec2 hash22a(vec2 p){\n    p *= 2000.;\n\treturn texture(iChannel0, vec2((p + 1./floor(p/256.)))/256.).xz;\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n\nvec2[8] N;\n\n\n\nvec2 kick(float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.000006);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp2(-t*80.1)*340. + 60.)*tt )*env;\n    \n    s = mix(s,sin(s*2.)*1., 0.5);\n    \n    \n    //bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattK[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\tinit;\n    \n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp2(-t*70.);\n    \n    vec2 n =lpnoise(t,10000.5);\n    vec2 nb =lpnoise(t,20000.5);\n    float f = 300.+ 500.*exp2(-t*80.)+ n.x*6.5 ;\n    \n    \n    s += sin(f*tt + n.x*0.25 + nb.x*0.5*exp(-t*20.))*env;\n    s += sin(f*tt*4. + n.x*0.25 + nb.x*4.2*exp(-t*10.))*pow(env, 0.8)*0.03;\n    \n    s += (n + nb)*0.05*exp(-t*12.);\n    \n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    nn += N[1]*0.9;\n    nn += N[5]*0.45;\n    nn += N[7]*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    \n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 32./8.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    \n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.9;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 6.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    if (gT > msr*2.)\n    \tbitreduction(s, 0.7);\n    s *= float(pattL[int(id.y)]);\n    \n    \n    s *= 1.;\n    ret;\n}\n\n\nvec2 leadb(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 32./2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 5.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    if (gT > msr*2.)\n    \tbitreduction(s, 0.7);\n    s *= 1. - att;\n    \n    \n    s *= 0.05;\n    ret;\n}\n\nvec2 leadc(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 32./2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 4.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    if (gT > msr*2.)\n    \tbitreduction(s, 0.7);\n    s *= 1. - att;\n    \n    \n    s *= 0.1;\n    ret;\n}\n\n\n\n\n\n\nvec2 tri(float t,float f){\n    return vec2(abs(fract(f*t) - 0.5));\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 1.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    if(gT < msr*6.){\n    \tsampleratereduction(t, (10./iSampleRate)*2.1);\n    \tsampleratereduction(t, (20./iSampleRate)*0.1);\n    } else if(gT < msr*8.){\n    \tsampleratereduction(t, (10./iSampleRate)*(2.1 + sin(t)));\n    \tsampleratereduction(t, (20./iSampleRate)*0.1);\n    }\n    \n    float env = exp(-t*0.04);\n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 4.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*0.2)*0.1 \n                 \n                 )*exp(-t*0.5)*0.4\n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 10.) *tt)*exp(-t*0.2)*0.\n                 )*exp(-t*0.5)*0.4\n            )*env;\n    \n    \n    s *= 1.;\n    \n    vec2 oS = s;\n    \n    if(gT < msr*4.){\n    \tbitreduction(s, (0.25));\n    }\n    \n    s = mix(oS, s, 0.8);\n    \n    \n    s = sin(s*2.5);\n    \n    s *= 0.7*0.6; // what is maths\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    sampleratereduction(t, 0.00003);\n    \n    vec2 nn = N[1];\n    nn += N[2]*0.9;\n    nn += N[7]*0.45;\n    \n    nn *= 0.01*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][1], 4.) *tt + nn.x*1.)*0.5;\n    s += sin( note(chords[id][1], 4.) *tt + nn.x*1.)*0.5;\n    float oct = 3.;\n    for(float i = 0.; i < 4. + min(iSampleRate, 0.); i++){\n        float a = (1. + i/2.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    //bitreduction(s, 0.01);\n    \n    s *= 0.03;\n    s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\n\n\nvec2 cguit(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    \n    float rb = bar/8.;\n    float env = exp(-mod(t, rb)*2.)*float(pattG[int(mod(floor(t/rb*2.), r*4.))]);\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    //sampleratereduction(t, (2./iSampleRate));\n    if(gT < msr*6.)\n    \tsampleratereduction(t, 0.0005);\n    \n    vec2 nn = N[0];\n    nn += N[1]*0.9;\n    nn += N[3]*0.45;\n    \n    nn *= 0.01*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*1.);\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*1.);\n    float oct = 3.;  \n    for(float i = 0.; i < 5. + min(iSampleRate, 0.); i++){\n        float a = (1. + i/1.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.75;\n    }\n    s *= env;\n    if(gT < msr*4.)\n    \tbitreduction(s, 0.4);\n    \n    s *= 0.04;\n    //s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats(float t){\n\tinit;\n\t\n    float r = hbeat;\n    t = mod(t + 0., r);\n    \n    float o = offsH[int(mod(floor(t/hbeat), 7.))]*r;\n    t -= o;\n    \n    \n    sampleratereduction(t, 0.0002);\n    vec2 nn = N[0] + N[1]  + N[2] + N[3]  ;\n    \n    float amt = 0.02;\n    float env = exp(-t*7.4);\n    //float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 3000. + exp(-t*60.)*100.)*tt +lpnoise(t, 2500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.5);\n    s *= 1.;\n    s *= min(floor(t) + 1., 1.);\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., beat);\n    \n\n    vec2 nn = N[0] + N[1]*0.87  + N[2]*0.6 + N[3]*0.5  ;\n    \n    float amt = 0.5;\n    float env = exp(-t*1.4);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +N[6].x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.75;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.4;\n    ret;\n}\n\nvec2 crash(float t){\n\tinit;\n\t\n    t = mod(t + 0., msr/2.);\n    \n    vec2 nn = N[1];\n    \n    float amt = 2.;\n    float env = exp(-t*0.1);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    s *= 0.9;\n    bitreduction(s, 0.9);\n    \n    s *= 0.04;\n    ret;\n}\n\nvec2 cReverb(float t){\n\tinit;\n    \n    if (gT > msr*2.)\n    \tsampleratereduction(t, (8.2*1./iSampleRate));\n    \n    \n    float iters = 100.;\n    float size = 150.;\n    \n    if(gT > msr *8.)\n        iters *= 4.;\n    \n    for(float i = 0.; i < iters + min(iSampleRate, 0.); i++ ){\n        float att = smoothstep(1.,0.9,i/iters);\n    \t//s += lead(t - size*i/iSampleRate + 10000.2*N[int(mod(i,7.))].x/iSampleRate )*(pow(sc,0.9))*att;\n        float m = size*i/iSampleRate + noise(i).x*100./iSampleRate;\n        s += lead(t + m )*(pow(sc,0.9))*att*0.1;\n    \tif (gT > msr*2.)\n\t\t\ts += cguit(t + m);\n        s += leadb(t + m);\n    \tif (gT > msr*2.)\n        \ts += hats(t + m)*(0.2 + pow(sc,1.4))*0.001;\n    }\n    s /= iters;\n    s *= 3.;\n    \n    if (gT > msr*2.)\n    \ts = mix(s,s * (pow(sc,0.9)), 0.5);\n    //bitreduction(s, 0.0001);\n    \n    ret;\n}\n\n\nvoid initKickPatt(float t){\n\t\n    float r = beat/4.;\n    \n    float id = floor(t/r);\n    \n    \n    for(int i = 0; i < 16 + min(int(iSampleRate),0); i++){\n        \n        vec4 r = r11(id + float(i));\n        \n    \tpattK[i] = r.x < probK[i];\n        \n    }\n}\n\n\nvoid initNoise(float t){\n\t\t\n    N[0] = lpnoise(t, 400.);\n    N[1] = lpnoise(t, 500.);\n    N[2] = lpnoise(t, 700.);\n    N[3] = lpnoise(t, 1000.);\n    N[4] = lpnoise(t, 1400.);\n    N[5] = lpnoise(t, 1900.);\n    N[6] = lpnoise(t, 2500.);\n    N[7] = lpnoise(t, 5500.); \n    \n}\nvec2 mainSound( in int samp, float t )\n{\n    t += OFFS;\n    gT = t;\n    //t += msr*4.;\n    vec2 s= vec2(0);\n    \n    initKickPatt(t);\n    initNoise(t);\n\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(0.2 + pow(sc,1.4))*0.01;\n    vec2 hb = hatsb(t);\n    \n    vec2 drums = k + sn*1. + ha*3. ;\n    //drums *= 0.5;\n    drums = sin(drums*1.2);\n    //drums = smoothify(drums, 0.2);\n    //vec2 hb= hatsb(t)*(pow(sc,4.4))*0.1;\n    vec2 bass = bass(t)*(pow(sc,2.4))*0.3;\n    vec2 c = chord(t)*(pow(sc,1.))*0.4;\n    vec2 cguit = cguit(t)*(pow(sc,1.))*0.5;\n    vec2 l = lead(t)*(pow(sc,0.9))*0.4;\n    vec2 lb = leadb(t)*(pow(sc,0.9))*0.4;\n    vec2 lc = leadc(t)*(pow(sc,0.9))*0.4;\n\tvec2 cr = crash(t);\n    \n    vec2 rev = cReverb(t);\n    //vec2 lb = leadb(t)*(pow(sc,0.9))*0.1;\n    //vec2 cr = crash(t)*(pow(sc,0.9))*0.1;\n    \n    \n    if(t < msr*2.){\n        if (t < beat){\n        \ts += cr*0.2;\n        }\n        \n        //s += cguit;\n        //s += bass;\n        //s += k;\n        s += lb*0.1;\n        //s += ha*2.;\n        //s += hb*0.1;\n\n        s += rev;\n\n        s += lb;\n    \n        if (t > msr*1.){\n            s += lb;\n            s += cguit*0.4;\n        \t//s += ha*2.;\n            \n        }\n        if (t > msr*1.75){\n        \ts += k;\n        }\n        \n    }else if (t < msr*4.){\n        s += c;\n        s += rev;\n        if (t > msr*4. - msr){\n        \ts += bass;\n            s += cr;\n        \ts += cguit;\n        }\n    } else {\n        s += bass;\n        s += drums;\n        s += rev;\n        s += cguit;\n        s += lc;\n    }\n    \n    s *= 0.2;\n    \n    s = mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), (0.1 + sin(t)*0.)*1.);\n    s = clamp(s,-1.,1.);\n    \n    return s;\n}", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 1107]], "test": "untested"}
{"id": "3dXyWX", "name": "[jmmut] wormhole flyer", "author": "jmmut", "description": "controls: WASDQE + dragging mouse left button\n\nthe wormhole is flipped in the WX direction (right and 4th D). the Y (up) and Z (backwards) get mirrored. ", "tags": ["raymarching", "wormhole"], "likes": 2, "viewed": 319, "published": 3, "date": "1585671719", "time_retrieved": "2024-07-30T21:15:36.363701", "image_code": "//jmmut: except for code coming from other people (which I noted and might have modified here), the license is http://www.wtfpl.net/\n\n\n// keyboard taken from: https://www.shadertoy.com/view/XdS3RV\n// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nvec4 ReadKey(int key, bool toggle) {\n\t//bool toggle = false;\n\tvec4 keyVal = textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 );\n\t//return (keyVal>.5)?true:false;\n    return keyVal;\n}\n\n// save/load code from IQ's shader (multipass): https://www.shadertoy.com/view/MddGzf\nvec4 _loadValue( in ivec2 re ) {\n    return texelFetch( iChannel0, re, 0 );\n    //return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//ugly hack here. couldn't make the float span the whole vec4\n\n//highp vec4 encode32(highp float f) {\n//    return vec4(f, 0., 0., 0.);\n//}\n//highp float decode32(highp vec4 rgba) {\n//    return rgba.x;\n//}\n\nvec4 _encode32(float f) {\n    return vec4(f, 0., 0., 0.);\n}\nfloat _decode32(vec4 rgba) {\n    return rgba.x;\n}\nfloat _loadDecoded(in int x, in int y) { return _decode32(_loadValue(ivec2(x, y))); }\n\n// --------- from rally simulator https://www.shadertoy.com/view/XdcGWS\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n// --------- from rally simulator\n\n\n// ----- start my load/store functions\nvec4 load(ivec2 address) {\n    return texelFetch(iChannel0, address, 0);\n}\n\nvoid store(out vec4 fragColor, vec4 value) {\n    fragColor = value;\n}\n\n// ----- end my load/store functions\n\n// based on\n// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nstruct Intersection { float _distance; vec3 color; };\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nIntersection unionOp(Intersection a, Intersection b) {\n    if (a._distance < b._distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\nIntersection substractionOp(Intersection a, Intersection b) {\n    if (a._distance > -b._distance) {\n        return Intersection(a._distance, a.color);\n    } else {\n        return Intersection(-b._distance, a.color);\n    }\n}\nIntersection intersectionOp(Intersection a, Intersection b ) {\n    return Intersection(max(a._distance, b._distance), a.color);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 H33(vec3 p) {\n    return texture(iChannel2, (p/40.).zy + vec2(0.5, 0.3), 0.).xyz;\n}\n\nvec3 getLightPos() {\n    vec3 lightPos = vec3(0, 10, -2);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n    return lightPos;\n}\n\nIntersection RayMarch(vec3, vec3, float);\n\nvec3 getSphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\n// colors\nvec3 orange = vec3(0.8, 0.4, 0.1);\nvec3 yellow = vec3(0.8, 0.7, 0.4);\nvec3 blue = vec3(0.1, 0.2, 0.9);\nvec3 green = vec3(0.1, 0.6, 0.2);\nvec3 purple = vec3(0.6, 0.2, 0.8);\nvec3 cyan = vec3(0.1, 0.6, 0.8);\nvec3 red = vec3(0.8, 0.1, 0.1);\nvec3 lightBlue = vec3(0.5, 0.5, 0.9);\nIntersection GetDist(vec3 p) {\n\tvec4 s1 = vec4(3, 5, -2, 1);\n\tvec4 s2 = vec4(-2, 5, -2, 1);\n    \n    Intersection sphere1Dist = Intersection(length(p-s1.xyz)-s1.w, orange);\n    Intersection sphere2Dist = Intersection(length(p-s2.xyz)-s2.w, orange);\n    \n    vec3 lightBulbPos = getLightPos() + vec3(0., .0, 0.);\n    Intersection lightBulbDist = Intersection(length(p - lightBulbPos)-0.4, yellow);\n    float hDistanceToPlaneBorder = max(p.x, p.z) - 20.;\n    Intersection planeDist = Intersection(hDistanceToPlaneBorder > 0. ?\n                                          sqrt(hDistanceToPlaneBorder*hDistanceToPlaneBorder + p.y*p.y)\n                                          : p.y, blue);\n    Intersection boxDist = Intersection(sdBox(p - vec3(3, 5, 2), vec3(1.)), green);\n    Intersection boxDist2 = Intersection(sdBox(p - vec3(-7, 5, -2), vec3(1.)), red);\n    Intersection lightBulbRemoval = Intersection(sdBox(p - lightBulbPos, vec3(.3, .1, .3)),yellow);\n    \n    Intersection d = Intersection(1e10, vec3(0));\n    d = unionOp(d, planeDist);\n    d = unionOp(d, Intersection(p.z + 20., purple));\n    d = unionOp(d, Intersection(p.x + 20., cyan));\n    d = unionOp(d, Intersection(20. - p.x, H33(p)));\n    d = unionOp(d, Intersection(20. - p.z, lightBlue));\n    d = unionOp(d, Intersection(40. - p.y, vec3(.1)));\n    d = unionOp(d, sphere1Dist);\n    d = unionOp(d, sphere2Dist);\n    d = unionOp(d, boxDist);\n    d = unionOp(d, boxDist2);\n    //d = unionOp(d, lightBulbDist);\n    //d = unionOp(d, lightBulbRemoval);\n    Intersection lightBulb = substractionOp(lightBulbRemoval, lightBulbDist);\n    d = unionOp(d, Intersection(1.*lightBulb._distance, lightBulb.color));\n    return d;\n}\n\nIntersection wormwholeX(vec3 p, vec3 rd, vec4 s1, vec4 s2) {\n    vec3 s1tos2 = s2.xyz - s1.xyz;\n    float mirrorDistance1 = 2.*(p.x - s1.x);\n    s1tos2.x -= mirrorDistance1;\n    vec3 n1 = getSphereNormal(p, s1.xyz);\n    vec3 newRD1 = abs(dot(n1, rd)) * 2. * n1 + rd;\n    newRD1.x *= -1.; // the wormhole is folded in dimensions xw\n    vec3 mirroredPoint1 = p + s1tos2 + newRD1*SURF_DIST*2.;\n    Intersection s1color = RayMarch(mirroredPoint1, newRD1, MAX_DIST); // note the color is a ray in the other sphere\n    Intersection sphere1Dist = Intersection(length(p-s1.xyz)-s1.w, s1color.color);\n    return sphere1Dist;\n}\n    \nIntersection GetDistRecursive(vec3 p, vec3 rd) {\n\tvec4 s1 = vec4(3, 5, -2, 1);\n\tvec4 s2 = vec4(-2, 5, -2, 1);\n    \n    Intersection sphere1Dist = wormwholeX(p, rd, s1, s2);\n    Intersection sphere2Dist = wormwholeX(p, rd, s2, s1);\n    vec3 lightBulbPos = getLightPos() + vec3(0., .0, 0.);\n    Intersection lightBulbDist = Intersection(length(p - lightBulbPos)-0.4, yellow);\n    \n    float hDistanceToPlaneBorder = max(p.x, p.z) - 20.;\n    Intersection planeDist = Intersection(hDistanceToPlaneBorder > 0. ?\n                                          sqrt(hDistanceToPlaneBorder*hDistanceToPlaneBorder + p.y*p.y) \n                                          : p.y, blue);\n    Intersection boxDist = Intersection(sdBox(p - vec3(3, 5, 2), vec3(1.)), green);\n    Intersection boxDist2 = Intersection(sdBox(p - vec3(-7, 5, -2), vec3(1.)), red);\n    Intersection lightBulbRemoval = Intersection(sdBox(p - lightBulbPos, vec3(.3, .1, .3)),yellow);\n    \n    Intersection d = Intersection(1e10, vec3(0));\n    d = unionOp(d, planeDist);\n    d = unionOp(d, Intersection(p.z + 20., purple));\n    d = unionOp(d, Intersection(p.x + 20., cyan));\n    d = unionOp(d, Intersection(20. - p.x, H33(p)));\n    d = unionOp(d, Intersection(20. - p.z, lightBlue));\n    d = unionOp(d, Intersection(40. - p.y, vec3(.1)));\n    d = unionOp(d, sphere1Dist);\n    d = unionOp(d, sphere2Dist);\n    d = unionOp(d, boxDist);\n    d = unionOp(d, boxDist2);\n    //d = unionOp(d, lightBulbDist);\n    //d = unionOp(d, lightBulbRemoval);\n    d = unionOp(d, substractionOp(lightBulbRemoval, lightBulbDist));\n    return d;\n}\n\nIntersection RayMarch(vec3 ro, vec3 rd, float maxDistance) {\n\tfloat dO=0.;\n    Intersection intersection;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        intersection = GetDist(p);\n        float dS = intersection._distance;\n        dO += dS;\n        if(dO>maxDistance || dS<SURF_DIST) break;\n    }\n    \n    return Intersection(dO, intersection.color);\n}\n\nIntersection RayMarchRecursive(vec3 ro, vec3 rd, float maxDistance) {\n\tfloat dO=0.;\n    Intersection intersection;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tp = ro + rd*dO;\n        intersection = GetDist(p);\n        float dS = intersection._distance;\n        dO += dS;\n        if(dO>maxDistance || dS<SURF_DIST) break;\n    }\n    intersection = GetDistRecursive(p, rd);\n    \n    return Intersection(dO, intersection.color);\n}\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p)._distance;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy)._distance,\n        GetDist(p-e.yxy)._distance,\n        GetDist(p-e.yyx)._distance);\n    \n    return normalize(n);\n}\n\n    \nIntersection GetLight(vec3 p) {\n    vec3 lightPos = getLightPos();\n    vec3 lightRay = normalize(lightPos-p);\n    float distanceToLight = length(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    // surfaces perpendicular to the light are more illuminated\n    // clamp to round negative values up to 0. \n    float diffuse = clamp(dot(n, lightRay), 0., 1.);\n    \n    // if there's some object between our point and the light, reduce the diffuse light\n    // the extra SURF_DIST is to not stop where we start and allow the ray to go out\n    //Intersection i = RayMarch(p+n*SURF_DIST*2., lightRay, distanceToLight + SURF_DIST*50.);\n    Intersection i = RayMarch(p+n*SURF_DIST*2., lightRay, min(MAX_DIST, distanceToLight + SURF_DIST*3.));\n    if(i._distance < distanceToLight) {\n        float transparency = .1; // 1==invisible, 0==opaque \n        diffuse *= transparency;\n    } else {\n        float transparency = .8; // 1==invisible, 0==opaque \n        diffuse *= transparency;\n    }\n    return Intersection(diffuse, i.color*diffuse);\n}\n\n\nmat4 loadMatrix() {\n    return mat4(load(ivec2(1,1)),\n                load(ivec2(2,1)),\n                load(ivec2(3,1)),\n                load(ivec2(4,1))\n                );\n}\n \nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy - .5)* 4.;\n    \n    vec4 cameraPosition = load(positionAddress);\n    vec4 originalRo = vec4(0., 5.1, 10., 1.);\n    vec3 ro = (cameraPosition + originalRo).xyz;\n    \n    \n    mat4 rotationMatrix = loadMatrix();\n    mat4 transposedRotationMatrix = transpose(rotationMatrix);\n    vec3 zAxisOfRotationMatrix = vec3(rotationMatrix[2][0], rotationMatrix[2][1], rotationMatrix[2][2]);\n    vec3 rd = normalize((vec4(uv.x, uv.y, -1, 1) * rotationMatrix).xyz);\n    \n    vec4 viewMode = ReadKey(Key_V, true);\n    if (viewMode.x == 0.) {\n        Intersection i = RayMarchRecursive(ro, rd, MAX_DIST);\n        \n        vec3 p = ro + rd * i._distance;\n        \n        if (true) {\n        \tIntersection diffuse = GetLight(p);\n            fragColor = vec4(mix(diffuse.color, i.color, 0.5), 1.0);\n        //fragColor = vec4(vec3(diffuse._distance), 1.0);\n        } else {\n        \tfragColor = vec4(i.color, 1.0);\n        }\n    } else {\n        vec2 grid = 7.*fragCoord/iResolution.y-1.;\n        ivec2 coord = ivec2(floor(grid));\n        \n        if (coord.x >= 0 && coord.x <= 3 && coord.y >= 0 && coord.y <=3) {\n            fragColor = vec4(rotationMatrix[coord.x][3 - coord.y], 0., 0., 0.)/3.;\n            fragColor.y = -fragColor.x;\n            //fragColor = vec4(fract(grid.x), fract(grid.y), 0.5, 1.);\n            //fragColor = vec4(float(coord.x)*0.5, float(coord.y)*0.125, 0.5, 1.);\n        } else if (coord == mouseAddress) {\n            vec4 mouse = load(coord);\n            if (fract(grid.x) < 0.25) {\n                fragColor = vec4(mouse.x, -mouse.x, 0., 0.);\n            } else if (fract(grid.x) < 0.5) {\n                fragColor = vec4(mouse.y, -mouse.y, 0., 0.);\n            } else if (fract(grid.x) < 0.75) {\n                fragColor = vec4(mouse.z, -mouse.z, 0., 0.);\n            } else {\n                vec4 v_key = ReadKey(Key_V, true);\n                fragColor = v_key;\n            }\n        } else if (coord.x == 5 && coord.y >= 1 && coord.y <= 3) {\n            vec4 cameraPosition = load(positionAddress);\n            fragColor = vec4(cameraPosition[3-coord.y], -cameraPosition[3-coord.y], 0., 0.)/3.;\n        } else if (coord.x == 7 && coord.y >= 1 && coord.y <= 3) {\n            fragColor = vec4(originalRo[3-coord.y], -originalRo[3-coord.y], 0., 0.)/3.;\n        } else if (coord.x == 8 && coord.y >= 1 && coord.y <= 3) {\n            fragColor = vec4(ro[3-coord.y], -ro[3-coord.y], 0., 0.)/3.;\n        } else {\n            fragColor = vec4(0.1, 0.2, 0.8, 1.);\n        }\n    }\n}\n\n\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//jmmut: except for code coming from other people (which I noted and might have modified here), the license is http://www.wtfpl.net/\n\n\nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = false;\n\tfloat keyVal = textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) {\n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\nfloat isInside( vec2 p, vec4 c ) {\n    vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5;\n    return -max(d.x,d.y);\n}\n\n\nvec4 _loadValue( in vec2 re )\n{\n    \n    return texelFetch( iChannel0, ivec2(re), 0 );\n    //return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvec4 _loadValue( in int x, in int y ) { return _loadValue(vec2(x, y)); }\n\n\n//ugly hack here. couldn't make the float span the whole vec4\nhighp vec4 _encode32(highp float f) {\n    return vec4(f, 0., 0., 0.);\n}\nhighp float _decode32(highp vec4 rgba) {\n    return rgba.x;\n}\nfloat _loadDecoded(in int x, in int y) { return _decode32(_loadValue(x, y)); }\nfloat _loadDecoded(in ivec2 re) { return _decode32(_loadValue(vec2(re))); }\n\nvoid _storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid _storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\n\n\n\n// --------- from rally simulator https://www.shadertoy.com/view/XdcGWS\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n// --------- from rally simulator\n\n// ----- start my load/store functions\nvec4 load(ivec2 address) {\n    return texelFetch(iChannel0, address, 0);\n}\n\nvoid store(out vec4 fragColor, vec4 value) {\n    fragColor = value;\n}\n\n// ----- end my load/store functions\n\nmat4 loadMatrix() {\n    return mat4(load(ivec2(1,1)),\n                load(ivec2(2,1)),\n                load(ivec2(3,1)),\n                load(ivec2(4,1))\n                );\n}\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat4 RotY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,  0, -s,  0,\t// matrices are transposed: this line is the first matrix column\n                0,  1,  0,  0,\n                s,  0,  c,  0,\n                0,  0,  0,  1\n               );\n}\nmat4 RotX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(1,  0,  0,  0,\n                0,  c,  s,  0,\n                0, -s,  c,  0,\n                0,  0,  0,  1\n               );\n}\nmat4 RotZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,  s,  0,  0,\n               -s,  c,  0,  0,\n                0,  0,  1,  0,\n                0,  0,  0,  1\n               );\n}\n\n\nvoid reset(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 thisPixelAddress = ivec2(fragCoord);\n    if (thisPixelAddress.y == 1) {\n        // we will only write state to addresses y==1 to simplify\n        mat4 identity = mat4  (1, 0, 0, 0,\n                               0, 1, 0, 0,\n                               0, 0, 1, 0,\n                               0, 0, 0, 1\n                               );\n    \n        if (thisPixelAddress.x >= 1 && thisPixelAddress.x <= 4 && thisPixelAddress.y == 1) {\n            store(fragColor, identity[thisPixelAddress.x-1]);\n        } else if (thisPixelAddress == mouseAddress) {\n            store(fragColor, vec4(0., 0., 0., 0.));\n        }\n    }\n}\nvoid updateRotationMatrix(out vec4 fragColor, vec2 mouse, mat4 rotationMatrix, ivec2 thisPixelAddress) {\n    float mouseSpeed = 0.75;\n    vec4 previousMouse = load(mouseAddress);\n    if (previousMouse.z > 0.) { // avoid jumping when clicking\n        vec2 mouseDiff = vec2(mouse - previousMouse.xy);\n        rotationMatrix = rotationMatrix * RotY(-mouseDiff.x * mouseSpeed); // yaw, external rotation\n        rotationMatrix = RotX(mouseDiff.y * mouseSpeed) * rotationMatrix; // pitch\n    }\n    vec4 column = rotationMatrix[thisPixelAddress.x-1];\n    store(fragColor, column);\n}\n\nvoid composeTransformations(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 thisPixelAddress = ivec2(fragCoord);\n    if (thisPixelAddress.y == 1) {\n        // we will only write state to addresses y==1 to simplify\n        \n        float movement = 0.;\n        mat4 rotationMatrix = loadMatrix();\n        \n        vec2 mouse = (iMouse.xy /iResolution.xy - .5) * 2.;\t// range [-1, 1]\n        \n        if (thisPixelAddress == mouseAddress) {\n            store(fragColor, vec4(mouse.x, mouse.y, iMouse.z, 0.));\n        } else if (thisPixelAddress == positionAddress) {\n            vec4 position = load(positionAddress);\n            float speed = 0.2;\n            float up      = ReadKey(Key_W)? speed : 0.;\n            float down    = ReadKey(Key_S)? speed : 0.;\n            float right   = ReadKey(Key_D)? speed : 0.;\n            float left    = ReadKey(Key_A)? speed : 0.;\n            float forward = ReadKey(Key_E)? speed : 0.;\n            float back    = ReadKey(Key_Q)? speed : 0.;\n            vec4 movement = vec4(right - left, up - down, back - forward, 1.);\n            store(fragColor, movement * rotationMatrix + position);\n        } else if (thisPixelAddress.x >= 1 && thisPixelAddress.x <= 4) {\n            updateRotationMatrix(fragColor, mouse, rotationMatrix, thisPixelAddress);\n        }\n        \n        // I will go crazy if I keep trying to remove this redundant code\n        else if (thisPixelAddress.x == 4) {\n            updateRotationMatrix(fragColor, mouse, rotationMatrix, thisPixelAddress);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        reset(fragColor, fragCoord);\n    } else {\n        composeTransformations(fragColor, fragCoord);\n        //reset(fragColor, fragCoord);\n    }\n}\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\n//const ivec2 directionAddress = ivec2(7, 1);\n\nvec4 initialCameraPosition = vec4(0., 5., 10., 0.); //vec3 pos, bool didIJustTeleport?\n\n// wormhole positions and sizes\nconst vec4 wh1 = vec4(3, 5, -2, 1); // vec3 pos, float size\nconst vec4 wh2 = vec4(-2, 5, -2, 1);\n\nvec3 getSphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\nvec3 mirrorDirection(vec3 direction, vec3 p, vec3 s1, vec3 s2) {\n    vec3 n1 = getSphereNormal(p, s1.xyz);\n    vec3 newDirection = -dot(n1, direction) * 2. * n1 + direction;\n    newDirection.x *= -1.; // the wormhole is folded in dimensions xw\n    return newDirection;\n}\n\nvec3 mirrorPoint(vec3 p, vec3 s1, vec3 s2) {\n    vec3 s1toP = p - s1;\n    vec3 s1toS2 = s2 - s1;\n    vec3 normalizedS1toS2 = normalize(s1toS2);\n    vec3 proyection = normalizedS1toS2 * dot(s1toP, normalizedS1toS2);\n    return p + s1toS2 - 2.*proyection;\n}*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyWX.jpg", "access": "api", "license": "wtfpl-2.0", "functions": [[1418, 1504, 1536, 1536, 1661], [1871, 1871, 1896, 1896, 1930], [1931, 1931, 1959, 1959, 1980], [1981, 1981, 2021, 2021, 2066], [2068, 2140, 2173, 2173, 2221], [2223, 2223, 2256, 2256, 2292], [2294, 2294, 2329, 2329, 2373], [2375, 2375, 2466, 2466, 2536], [2538, 2538, 2629, 2629, 2697], [2735, 2774, 2800, 2800, 2848], [2850, 2850, 2894, 2894, 2919], [3292, 3292, 3323, 3323, 3410], [3412, 3412, 3466, 3466, 3560], [3561, 3561, 3622, 3622, 3784], [3785, 3785, 3847, 3847, 3914], [3916, 3916, 3935, 3935, 4011], [4013, 4013, 4031, 4031, 4101], [4103, 4103, 4123, 4123, 4235], [4280, 4280, 4323, 4323, 4359], [4646, 4646, 4676, 4676, 6324], [6326, 6326, 6386, 6386, 6943], [6949, 6949, 6997, 6997, 8526], [8528, 8528, 8588, 8588, 8904], [8906, 8906, 8975, 8975, 9342], [9343, 9343, 9367, 9367, 9596], [9603, 9603, 9634, 9634, 10635], [10638, 10638, 10657, 10657, 10813], [10899, 10899, 10955, 10955, 13549]], "test": "untested"}
{"id": "3sXyDX", "name": "what the frac 1kb", "author": "gopher", "description": "shadertoy port of what the frac, presented at Geeks can dance 2012.\nhttps://www.pouet.net/prod.php?which=60091", "tags": ["1k"], "likes": 1, "viewed": 166, "published": 3, "date": "1585670124", "time_retrieved": "2024-07-30T21:15:37.115692", "image_code": "vec2 r(inout vec2 x,float y)\n{\n\treturn x=vec2(cos(y)*x.x-sin(y)*x.y,sin(y)*x.x+cos(y)*x.y);\n}\n\n// julia function\nfloat s(vec3 x,float y) \n{\n\tfloat R=y;//1.21;\n\tfor(int i=0;i<50;i++)\n    {\n        r(x.xy,R);\n        r(x.zx,R);\n        r(x.yz,R);\n        x=(abs(x-vec3(.7,.4,-2))+vec3(.7,.4,-2))*1.13+vec3(-1,.02,-.85);\n    }\n\treturn length(x)/455.0;\n}\n\nvoid mainImage(out vec4 O,vec2 c)\n{\n\tfloat z = (iTime+16.) * 1000.;\n    \n\tfloat d=0.;\n    float o=0.;\n    float p=0.;\n    float u=z/2056.;\n    float b=mod(u,4.)<3.?1.-mod(u,1.):0.;\n    float v=u< 8.?1.9:\n    \t\tu<16.?1.9+.05*b:\n    \t\tu<24.?-2.-b:\n    \t\tu<32.?.25-(u-24.)/32.:\n    \t\tu<40.?1.3-.1*b:\n    \t\t1.9+.05*b;\n\t\n    vec3 t=vec3(0.,0.,u<8.?16.-u*2.:5.+3.*sin(u));    \n    vec3 y=normalize(vec3(c/iResolution.xy-.5,-.5));\n    \n    r(t.xz,-u/2.);\n    r(t.yz,-u/2.);\n    r(y.xz,-u/2.);\n    r(y.yz,-u/2.);\n    \n\tfor(int i=0;i<150&&d<50.;i++)\n    {\n        b=p;\n        d+=p=s(t+d*y,v);\n        o+=exp(-abs(p-b));\n    }\n\tO = vec4(.8,.9,1.,0.)*.014*o;\n\n    return;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 93], [95, 113, 139, 139, 350], [352, 352, 387, 387, 1015]], "test": "untested"}
{"id": "tdscW2", "name": "Sci-fi mandelbulb", "author": "loicvdb", "description": "yet another mandelbulb - you may have seen this a while ago I just forgot to make it public\n\nuse the mouse to change the point of view", "tags": ["fractal", "volume", "mandelbulb", "volumetric", "bloom", "scattering", "pathtracing", "tonemapping"], "likes": 32, "viewed": 1108, "published": 3, "date": "1585669420", "time_retrieved": "2024-07-30T21:15:37.863691", "image_code": "vec3 ACESFilm(vec3 x) {\n    \n    // ACES system tone scale (RTT+ODT)\n    const float a = .0245786;\n    const float b = -.000090537;\n    const float c = .983729;\n    const float d = .4329510;\n    const float e = .238081;\n    x = (x*(x+a)+b) / (x*(x*c+d)+e);\n    \n    return x;\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.15 * iResolution.y, .0, fragCoord)*.3\n        \t\t  + bloom(.05 * iResolution.y, .0, fragCoord)*.2;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define Pi 3.14159265359\n\n#define VolumePrecision .35\n#define SceneRadius 1.5\n#define StepsSkipShadow 4\n#define MaxSteps 500\n#define MaxAbso .7\n#define MaxShadowAbso .7\n\n#define HASH( seed ) fract(cos(seed)*43758.5453)\n#define RANDOM HASH(seed++)\n#define RANDOM2D vec2(RANDOM, RANDOM)\n\nvec3 CamPos = vec3(.0, 0, -15.0);\nvec3 CamRot = vec3(.5, -.5, 0.);\nfloat CamFocalLength = 7.;\nfloat CamFocalDistance = 14.2;\nfloat CamAperture = .3;\n\nvec3 LightColor = vec3(3.);\nvec3 LightDir = normalize(vec3(-1, -.2, 0));\n\nfloat Power = 8.0;\n\nfloat Density = 500.0;\n\nfloat StepSize;\n\nfloat seed;\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nfloat maxV(vec3 v){\n    return v.x > v.y ? v.x > v.z ? v.x : v.z : v.y > v.z ? v.y : v.z;\n}\n\nvec3 randomDir(){\n    return vec3(1, 0, 0) * rotationMatrix(vec3(RANDOM2D*2.0*Pi, 0).xzy);\n}\n\nvec3 backgroundColor(vec3 dir){\n    return vec3(0.);\n}\n\nfloat distanceEstimation(vec3 pos, out vec3 volumeColor, out vec3 emissionColor) {\n    \n    vec3 basePos = vec3(0., .0, .0);\n    float scale = 1.;\n    \n    pos /= scale;\n    pos += basePos;\n    \n    volumeColor = vec3(.0);\n    emissionColor = vec3(0.);\n    \n    pos.yz = vec2(pos.z, pos.y);\n    \n    \n    float r = length(pos);\n    vec3 z = pos;\n    vec3 c = pos;\n\tfloat dr = 1.0, theta, phi;\n    vec3 orbitTrap = vec3(1.);\n\tfor (int i = 0; i < 8; i++) {\n\t\tr = length(z);\n\t\tif (r>SceneRadius) break;\n        orbitTrap = min(abs(z)*1.2, orbitTrap);\n\t\ttheta = acos(z.y/r);\n\t\tphi = atan(z.z,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tz = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + c;\n\t}\n    \n    float dist = 0.5*log(r)*r/dr*scale;\n    \n    volumeColor = (1.-orbitTrap)*.98;\n    emissionColor = vec3(orbitTrap.z < .0001 ? 20. : 0.);\n    \n\treturn dist;\n}\n\nvec3 directLight(vec3 pos){\n    \n    vec3 absorption = vec3(1.0);\n    vec3 volumeColor, emissionColor;\n    \n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos, volumeColor, emissionColor);\n        pos -= LightDir * max(dist, StepSize);\n        if(dist < StepSize) {\n            float abStep = StepSize * RANDOM;\n            pos -= LightDir * (abStep-StepSize);\n            if(dist < 0.0){\n                float absorbance = exp(-Density*abStep);\n                absorption *= absorbance;\n                if(maxV(absorption) < 1.0-MaxShadowAbso) break;\n            }\n        }\n        \n        if(length(pos) > SceneRadius) break;\n    }\n    return LightColor * max((absorption+MaxShadowAbso-1.0) / MaxShadowAbso, vec3(0));\n}\n\nvec3 pathTrace(vec3 rayPos, vec3 rayDir){\n    \n   \trayPos += rayDir * max(length(rayPos)-SceneRadius, 0.0);\n    \n    vec3 outColor = vec3(0.0);\n    vec3 absorption = vec3(1.0);\n    \n    vec3 volumeColor, emissionColor;\n    \n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(rayPos, volumeColor, emissionColor);\n        rayPos += rayDir * max(dist, StepSize);\n        if(dist < StepSize && length(rayPos) < SceneRadius) {\n            float abStep = StepSize * RANDOM;\n            rayPos += rayDir * (abStep-StepSize);\n            if(dist < 0.0){\n                \n                float absorbance = exp(-Density*abStep);\n                float transmittance = 1.0-absorbance;\n                \n                if(mod(float(i), float(StepsSkipShadow)) == 0.) emissionColor += float(StepsSkipShadow) * volumeColor * directLight(rayPos);\n                \n                outColor += absorption * transmittance * emissionColor;\n                \n                if(maxV(absorption) < 1.0-MaxAbso) break;\n                if(RANDOM > absorbance) {\n                    rayDir = randomDir();\n                    absorption *= volumeColor;\n                }\n            }\n        }\n        \n        if(length(rayPos) > SceneRadius && dot(rayDir, rayPos) > 0.0)\n            return outColor + backgroundColor(rayDir) * absorption;\n    }\n    \n    return outColor;\n}\n\n// n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation) {\n    \n    float side = sin(Pi / float(nbBlades));\n    vec2 tri = RANDOM2D;\n    if(tri.x-tri.y > 0.0) tri = vec2(tri.x-1.0, 1.0-tri.y);\n    tri *= vec2(side, -sqrt(1.0-side*side));\n    float angle = rotation + 2.*Pi*floor(RANDOM * float(nbBlades))/float(nbBlades);\n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\n//used to store values in the unused alpha channel of the buffer\nvoid setVector(int index, vec4 v, vec2 fragCoord, inout vec4 fragColor){\n    fragCoord -= vec2(.5);\n    if(fragCoord.y == float(index)){\n        if(fragCoord.x == 0.0) fragColor.a = v.x;\n        if(fragCoord.x == 1.0) fragColor.a = v.y;\n        if(fragCoord.x == 2.0) fragColor.a = v.z;\n        if(fragCoord.x == 3.0) fragColor.a = v.a;\n    }\n}\n\nvec4 getVector(int index){\n    return vec4(texelFetch(iChannel0, ivec2(0, index), 0).a,\n                texelFetch(iChannel0, ivec2(1, index), 0).a,\n                texelFetch(iChannel0, ivec2(2, index), 0).a,\n                texelFetch(iChannel0, ivec2(3, index), 0).a\n               );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    StepSize = min(1.0/(VolumePrecision*Density), SceneRadius/2.0);\n    \n    seed = sin(iTime) + cos(fragCoord.x) + sin(fragCoord.y);\n    \n    vec2 uv = (fragCoord+RANDOM2D-iResolution.xy/2.0) / iResolution.y;\n    \n    float samples = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    if(iFrame > 0) CamRot = getVector(1).xyz;\n    vec4 prevMouse = getVector(2);\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    bool mouseDragged = iMouse.z >= 0.0 && prevMouse.z >= 0.0 && iMouse != prevMouse;\n    \n    if(mouseDragged) CamRot.yx += (prevMouse.xy-iMouse.xy)/iResolution.y * 2.0;\n    \n    if(iFrame == 0 || mouseDragged){\n        fragColor = vec4(0.0);\n        samples = 0.0;\n    }\n    \n    setVector(1, vec4(CamRot, 0), fragCoord, fragColor);\n    setVector(2, iMouse, fragCoord, fragColor);\n    if(fragCoord-vec2(.5) == vec2(0)) fragColor.a = samples+1.0;\n    \n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(5, 0.0), 0.0);\n    vec3 rayDir = normalize(focalPoint-aperture);\n    \n    mat3 CamMatrix = rotationMatrix(CamRot);\n    CamPos *= CamMatrix;\n    rayDir *= CamMatrix;\n    aperture *= CamMatrix;\n    \n    fragColor.rgb = mix(fragColor.rgb,pathTrace(vec3(.0, .0, .0) + CamPos+aperture,rayDir),1.0/(samples+1.0));\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdscW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 68, 277], [279, 279, 336, 336, 641], [643, 643, 700, 700, 958]], "test": "untested"}
{"id": "tssyW2", "name": "Day 103", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics"], "likes": 12, "viewed": 390, "published": 3, "date": "1585659613", "time_retrieved": "2024-07-30T21:15:38.610694", "image_code": "// Fork of \"Day 102\" by jeyko. https://shadertoy.com/view/3dfcW2\n// 2020-03-31 09:25:47\n\n// Fork of \"Day 101\" by jeyko. https://shadertoy.com/view/WslyWS\n// 2020-03-30 07:59:19\n\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.0;\n    float chromAb = pow(length(uv - 0.5),1.5)*4.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    fragColor = max(fragColor, 0.);\n    //fragColor *= 1. - dot(uvn,uvn)*1.   ;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat xch(float d, float b){\n\treturn b < 0. ? 1.0 - d : d;\n}\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n\treturn max(p.x, p.y);\n}\n\nfloat sdBoxHalf(vec2 p, vec2 s, vec2 dir){\n    vec2 q = p;\n\tp = abs(p) - s;\n\tfloat d = max(p.x, p.y);\n    \n    d = max(d, -dot(q, dir) - 0.0045);\n    \n    return d;\n}\n\n\nconst float speed = 0.65;\nfloat[] scenes = float[3](1.*speed,1.5*speed, 0.6*speed); \n\nfloat S = 0.5;\nvec3 get( vec2 fragCoord  )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n    uv *= 2.;\n    float col = 0.;\n    \n    float d = 10e6;\n    \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n    \n    float pl;\n    \n    float t = iTime;\n    \n    //t += scenes[0];\n    //t += scenes[1] - 0.0;\n    //t += scenes[2] - 0.1;\n    uv *= rot(pi*0.25);\n    t = mod(t, scenes[0] + scenes[1] /* + scenes[2]*/  );\n    \n    float offsamt = 0.5;\n    float offs = -S*offsamt;\n    float offsB = S*(1. - offsamt);\n    \n    \n    if(t < scenes[0]){\n        //float env = ease(t/scenes[0], 2.);\n        float lsp = 1.5;\n        float env = ease(t/scenes[0]*lsp, 1., 1.24, 0.96, 10.);\n        \n        float mov = env * offs*0.;\n        mat2 r = rot(0.*pi);\n        bE = sdBox(uv, vec2(S));\n        \n        float h = 1.43;\n        uv *= rot(0.25*pi);\n        bA = sdBox( (uv - vec2(S/2.,S/2.)*h)*r , vec2(S*env)*0.7);\n        bB = sdBox((uv + vec2(S/2. ,S/2. )*h)*r, vec2(S*env)*0.7);\n        bC = sdBox((uv - vec2(S/2. ,-S/2. )*h)*r, vec2(S*env)*0.7);\n        bD = sdBox((uv + vec2(S/2. ,-S/2. )*h)*r, vec2(S*env)*0.7);\n        col = xch(col,bE);\n        col = xch(col,bA);\n        col = xch(col,bB);\n        col = xch(col,bC);\n        col = xch(col,bD);\n        \n        \n        uv *= rot(0.25*pi);\n        bE = sdBox(uv, vec2(S)*1.);\n        \n        if(t > scenes[0]/lsp*0.74)\n        \tcol -= step(0.,-bE);\n    \n    } else if(t < scenes[1] + scenes[0]){\n        t -= scenes[0];\n        \n        float lsp = 2.;\n        float env = ease(t/scenes[1]*lsp, 1., 1.04, 0.96, 10.);\n        \n        float envb = ease(t/scenes[1]*lsp*1.45, 6., 1.0, 0.93, 25.)*0.01*S;\n        \n        float mov = env * offs*0.;\n        mat2 r = rot(1.*pi*env);\n        bE = sdBox(uv, vec2(S));\n        \n        float h = 1.43;\n        uv *= rot(0.25*pi);\n        bA = sdBoxHalf( (uv - vec2(S/2. - envb,S/2.- envb)*h)*r , vec2(S)*(0.7 ), vec2(1.));\n        bB = sdBoxHalf((uv + vec2(S/2. - envb,S/2. - envb)*h)*r, vec2(S)*(0.7 ), vec2(-1.));\n        bC = sdBoxHalf((uv - vec2(S/2.- envb ,-S/2.+ envb )*h)*r, vec2(S)*(0.7 ), vec2(0.5,-0.5));\n        bD = sdBoxHalf((uv + vec2(S/2. - envb,-S/2.+ envb  )*h)*r, vec2(S)*(0.7), vec2(-0.5,0.5));\n        \n        \n        col += step(0.,-bA);\n        col += step(0.,-bB);\n        col += step(0.,-bC);\n        col += step(0.,-bD);\n        \n        if(t > scenes[1]/lsp*0.88){\n            t -= scenes[1]/lsp*0.88;\n            uv *= 1. +  ease(t*0.6 + 0.47, 70., 1.0, pi/1.6, 2000000000.)*0.05*mix(1., 0., smoothstep(0.,1.,t*4.));\n        \tuv *= rot(-0.25*pi);\n            col -= col;\n        \tcol += step(0.,-sdBox(uv, vec2(S)));\n        }        \t\n        \n        \n    }  \n    \n    return vec3(col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float aa = 5.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    col = clamp(col, 0., 1.);\n    col *= 0.999;\n    col = 1. - col;\n    \n    \n    \n    //col *= max((1. + 1.*cos(iTime*1.+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    //col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 270, 270, 1184]], "test": "untested"}
{"id": "tdsyW2", "name": "Hypercubic Honeycomb II", "author": "mla", "description": "A variant on [url]https://www.shadertoy.com/view/4sVcDG[/url] showing a plane section through a hypercubic lattice. See code for details.", "tags": ["honeycomb", "hypercubic"], "likes": 8, "viewed": 388, "published": 3, "date": "1585657827", "time_retrieved": "2024-07-30T21:15:39.370662", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2018, updated 2020, by Matthew Arcus\n//\n// Display a section through a hypercubic lattice in R4.\n// Earlier version: https://www.shadertoy.com/view/4sVcDG\n// Inspired by: https://www.shadertoy.com/view/Mts3Wl by TekF\n//\n// This just shows the point and edge intersections (by default - to\n// see the faces press 'f') which appear as spheres and\n// ellipsoids. When the section plane passes through a vertex, the\n// point sphere appears and the ellipsoids corresonding to the four\n// grid lines at that vertex all pass through each other. The colours\n// on the edge ellipsoids indicate the faces at that point (each face\n// appears as an elliptical cylinder in section).\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// f: show face intersections\n// i: apply inversion\n// p: show point intersections\n// q: R4 rotation\n// t: R4 translation\n// x: fold\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool doinvert = true;\nbool dofold = true;\nbool dofaces = false;\nbool dopoints = true;\nbool dotranslate = false;\nbool doquaternion = true;\n\nconst float maxdist = 20.0;\nvec3 laxis = normalize(vec3(0,0,1));\nvec3 raxis = normalize(vec3(1,2,3));\nfloat fwidth = 0.04;\nfloat ewidth = 0.08;\nfloat pwidth = 0.12;\nconst float precis = 0.001;\n\nconst vec3 Face0Color = vec3(1,0,0);\nconst vec3 Face1Color = vec3(0,1,0);\nconst vec3 Face2Color = vec3(0,0,1);\nconst vec3 Face3Color = vec3(1,1,0);\nconst vec3 Face4Color = vec3(1,0,1);\nconst vec3 Face5Color = vec3(0,1,1);\nconst vec3 EdgeColor = vec3(0.1,0.1,0.1);\nconst vec3 PointColor = vec3(1);\n\nconst float PI\t= 3.141592;\n\nint type = 0; // Set this if we hit a point.\nvec4 lquat,rquat; // Quaternions for R4 rotation.\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n//#define assert(x)\n\n// Quaternion multiplication\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvoid qinit() {\n  float t = iTime;\n  float ltheta = 0.1*t;\n  float rtheta = 0.065*t;\n  lquat = vec4(sin(ltheta)*laxis,cos(ltheta));\n  rquat = vec4(sin(rtheta)*raxis,cos(rtheta));\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec4 iproject(vec3 p3) {\n  float t = iTime;\n  vec4 p = vec4(p3,0);\n  if (dotranslate) {\n    p.w = sin(0.2*t);\n    //p.xw = rotate(p.xw,0.2*t); \n  }\n  if (doquaternion) {\n    p = qmul(p,rquat);\n    //p = qmul(lquat,p);\n  }\n  return p;\n}\n\nvec4 map(vec3 p, inout float scale) {\n  if (doinvert) {\n    float c = cos(0.25*iTime);\n    float r = 1.0/c;\n    float r2 = r*r;\n    p.x -= r-c;\n    float k = r2/dot(p,p);\n    p *= k;\n    scale *= k;\n    p.x += r-c;\n  }\n  vec4 p4 = iproject(p);\n  return p4;\n}\n\nfloat scene(vec4 pos4) {\n  float d = 1e8;\n  if (dofold) {\n    pos4 = fract(pos4);\n    pos4 = min(pos4,1.0-pos4);\n  }\n  type = 0;\n  // Distance from edges - these appear as points, usually\n  d = min(d,length(pos4.xyz) - ewidth);\n  d = min(d,length(pos4.yzw) - ewidth);\n  d = min(d,length(pos4.zwx) - ewidth);\n  d = min(d,length(pos4.wxy) - ewidth);\n  // Distance from faces - these appear as lines, usually\n  if (dofaces) {\n    d = min(d,length(pos4.xy) - fwidth);\n    d = min(d,length(pos4.yz) - fwidth);\n    d = min(d,length(pos4.zx) - fwidth);\n    d = min(d,length(pos4.xw) - fwidth);\n    d = min(d,length(pos4.yw) - fwidth);\n    d = min(d,length(pos4.zw) - fwidth);\n  }\n  if (dopoints) {\n    float k = length(pos4) - pwidth;\n    if (k < d) { type = 1; d = k; }\n  }\n  return d;\n}\n\nvec3 getColor(vec3 p3){\n  if (type == 1) return PointColor;\n  float k, d = 1e8;\n  vec4 p = map(p3,k);\n  if (dofold) {\n    p = fract(p);\n    p = min(p,1.0-p);\n  }\n  vec3 col = EdgeColor;\n  d = 1e8;\n  d = min(d,length(p.xyz) - ewidth);\n  d = min(d,length(p.yzw) - ewidth);\n  d = min(d,length(p.zwx) - ewidth);\n  d = min(d,length(p.wxy) - ewidth);\n  if (true) {\n    // Do the face colouring always, so they show up on the edges.\n    k = length(p.xy) - fwidth;\n    if (k < d) { d = k; col = Face0Color; }\n    k = length(p.yz) - fwidth;\n    if (k < d) { d = k; col = Face1Color; }\n    k = length(p.zx) - fwidth;\n    if (k < d) { d = k; col = Face2Color; }\n    k = length(p.xw) - fwidth;\n    if (k < d) { d = k; col = Face3Color; }\n    k = length(p.yw) - fwidth;\n    if (k < d) { d = k; col = Face4Color; }\n    k = length(p.zw) - fwidth;\n    if (k < d) { d = k; col = Face5Color; }\n  }\n  return col;\n}\n\nfloat de(vec3 p3) {\n  float scale = 1.0;\n  vec4 p = map(p3,scale);\n  float d = scene(p);\n  return d/scale;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n  vec2 e = vec2(t*precis, 0.0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.1;\n  for(int i = 0; i < 200; i++) {\n    //assert(i < 100);\n    float h = de(ro + rd * t);\n    if (h < t*precis) return t;\n    if (doinvert) h *= 0.5;\n    t += h;\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  //p.yz = rotate(p.yz,iTime * 0.125);\n  //p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nbool keypress(int code) {\n    return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dofaces = keypress(CHAR_F);\n  doinvert = keypress(CHAR_I);\n  dopoints = !keypress(CHAR_P);\n  doquaternion = !keypress(CHAR_Q);\n  dotranslate = !keypress(CHAR_T);\n  dofold = !keypress(CHAR_X);\n  qinit();\n  \n  vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n  vec3 bgcol = 0.5+(0.25-0.25*p.y)*vec3(1,1,0);\n  p *= 3.0;\n  vec3 ro = vec3(0,0,-2.5);\n  vec3 rd = vec3(p, 6.0);\n  vec3 li = vec3(0.5, 2.0, -1);\n  ro.z *= 1.0 + 0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n\n  ro = transform(ro);\n  rd = transform(rd);\n  li = transform(li);\n  rd = normalize(rd);\n  li = normalize(li);\n  vec3 col = bgcol;\n  float t = march(ro, rd);\n  if (t > 0.0) {\n    vec3 p = ro + t * rd;\n    vec3 n = calcNormal(p,t);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col = getColor(p) * (0.2+0.8*diffuse);\n    col = mix(col,bgcol,t/maxdist);\n  }\n  col = pow(col, vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1808, 1808, 1832, 1832, 1861], [1883, 1912, 1939, 1939, 2026], [2028, 2028, 2042, 2042, 2207], [2209, 2209, 2245, 2245, 2297], [2299, 2299, 2323, 2323, 2534], [2536, 2536, 2573, 2573, 2794], [2796, 2796, 2820, 2820, 3577], [3579, 3579, 3602, 3602, 4474], [4476, 4476, 4495, 4495, 4584], [4586, 4586, 4620, 4620, 4821], [4823, 4823, 4854, 4854, 5090], [5092, 5092, 5119, 5119, 5426], [5638, 5638, 5663, 5663, 5725], [5727, 5727, 5752, 5752, 5800], [5802, 5802, 5825, 5825, 5857], [5859, 5859, 5916, 5916, 6853]], "test": "untested"}
{"id": "WdfcD2", "name": "anotherContineousRandom", "author": "Arseny", "description": "lol", "tags": ["2d"], "likes": 1, "viewed": 276, "published": 3, "date": "1585645716", "time_retrieved": "2024-07-30T21:15:40.205430", "image_code": "float rand(float x){\n    x += 0.0007;\n    x += 1224.124;\n    x = floor(x / 0.001) * 0.001;\n    return fract(sin(x) * 43758.5453);\n}\n\nvec2 getNormal(float id){\n    float rnd = (rand(id) * 2. - 1.) * 0.78539816339 / 1.1;\n    return vec2(sin(rnd), cos(rnd));\n    float ctg = -cos(rnd)/sin(rnd);\n}\n\nvec4 getCub(float h, vec2 u, vec2 C, vec2 v){\n    float d = h;\n    float c = -u.x / u.y;\n    float b = (3. * C.y + v.x / v.y * C.x - 2. * c * C.x - 3. * d) / (C.x * C.x);\n    float a = (-v.x / v.y - c - 2. * b * C.x) / (3. * C.x * C.x);\n    return vec4(d, c, b, a);\n}\n\nfloat getContRnd(float uvx){\n    float ans = 0.;\n    \n    //float x = uv.x;\n    //vec2 lv = uv;\n    float k = 1.;\n    float x = uvx;\n    \n    float id = (floor(x * k) + 0.5) / k;\n    vec4 cB = getCub(0., getNormal(id), vec2(2., 0.), getNormal(id + 1. / k));\n    x = fract(x * k) * 2. - 1.;\n    vec4 pw = vec4(1., x, x * x, x * x * x);\n    ans = (uvx >= id) ? dot(pw, cB) : ans;\n    cB = getCub(0., getNormal(id), vec2(-2., 0.), getNormal(id - 1. / k));\n    ans = (uvx <= id) ? dot(pw, cB) : ans;\n    return ans;\n}\n\nfloat N21(vec2 uv){\n    return getContRnd(uv.x - 2.521) * getContRnd(uv.y + 124.131);\n}\n\n/*vec3 grad(){\n    \n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    uv.x += iTime / 2.;\n    uv.x += 10.;\n    //uv.x = mod(uv.x, 100.);\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    col = vec3(smoothstep(-0.01, 0.01, getContRnd(uv.x) - uv.y));\n    col.x *= (getContRnd(uv.x) + 0.5) * 1.5;\n    col.y *= (getContRnd(uv.x + 163.) + 0.5) * 1.5;\n    col.z *= (getContRnd(uv.x + 2256.) + 0.5) * 1.5;\n    //col = vec3(smoothstep(0., 0.1, abs(lv.x)));\n    //col *= vec3(id);\n    \n    //x = lv.x;\n    //cB = getCub(0., vec2(0.4, 0.4), vec2(-1., 0.), vec2(-0.2, 0.4));\n    //col = vec3(sign(dot(pw, cB) - uv.y));\n    \n    //col *= id;\n\n    // Output to screen\n    //col *= grad(uv.x);\n    //col = (abs(uv.y) < 0.01) ? vec3(0., 1., 0.) : col;\n    //col = (abs(uv.y - 1.) < 0.01) ? vec3(0., 1., 0.) : col;\n    col = vec3((N21(uv * 2.) + 0.02) * 10.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 131], [133, 133, 158, 158, 293], [295, 295, 340, 340, 562], [564, 564, 592, 592, 1077], [1079, 1079, 1098, 1098, 1166], [1193, 1193, 1250, 1250, 2148]], "test": "untested"}
{"id": "tdsyDj", "name": "multiscale diffusion", "author": "FabriceNeyret2", "description": "see [url]https://shadertoy.com/view/wslyDj[/url] for parameters.", "tags": ["simulation", "epidemia"], "likes": 27, "viewed": 685, "published": 3, "date": "1585636155", "time_retrieved": "2024-07-30T21:15:40.963403", "image_code": "// inspired from https://shadertoy.com/view/wslyDj\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = pow( T(U).xxxx , vec4(3,1.5,1,0));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if (iFrame==0) { \n        O-=O; \n        if (floor(U) == floor(R/2.) )  O.x = 1.; // initial infection : 1\n      //if ( hash(U) < Init ) O.x = 1.;          // initial infection : random people\n        return; }\n    \n    O = T(U);                                    // recover previous state\n    \n    if ( O.x > eps ) { O.x *= .98; return; }     // already contaminated \n    float n = 0.;                                // local propagation with probability #Contag\n\n    for ( int k=0; k<9; k++ ) \n        if( T(U+vec2(k%3,k/3)-1.).x > eps ) n++;\n    if ( hash(U+iTime) < n*Contag ) O.x = 1.;    // contaminated\n    \n        // next-town propagation with probability #Contag\n    if ( hash(U-iTime) < Travel ) \n        if( T(U+Dist*(2.*hash2(U+iTime)-1.)).x > eps )\n            O.x = 1.;                            // contaminated\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Contag = .1,      // probability of local transmission per step\n           ContagG = .1,      // probability of transmission for next-town travelers\n              Init = .0004,   // initial infection\n            Travel = .001,    // next-town travelers proportion\n              Dist = 50.,\n               eps = 1e-2;\n     \n#define R          iResolution.xy\n#define T(U)       texelFetch(iChannel0,ivec2(mod(U,R)),0)\n#define hash(p)  ( 1. - fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) )\n#define hash2(p) ( 1. - fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) )\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 90, 90, 135]], "test": "untested"}
{"id": "wslyDj", "name": "multiscale epidemia simulation 3", "author": "FabriceNeyret2", "description": "Letting people go to next town.\n\nPlay with parameters in #Common :\n- epidemia propagates locally at rate #Contag\n- a proportion #Travel of people travel to the nearby areas  ( and might have a higher #ContagG )\n- Step: to slow down simulation", "tags": ["simulation", "forestfire", "epidemia"], "likes": 5, "viewed": 426, "published": 3, "date": "1585635588", "time_retrieved": "2024-07-30T21:15:41.838065", "image_code": "// variant of https://shadertoy.com/view/wdlyDj\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if (iFrame==0) { \n        O-=O; \n        if (floor(U) == floor(R/2.) )  O.x = 1.; // initial infection : 1\n      //if ( hash(U) < Init ) O.x = 1.;          // initial infection : random people\n        return; }\n    \n    O = T(U);                                    // recover previous state\n    \n    if ( iFrame % Step > 0 ) return;             // 1 step delay at a time\n    if ( O.x > 0. ) { O.x *= .95; return; }      // already contaminated \n    float n = 0.;                                // local propagation with probability #Contag\n\n    for ( int k=0; k<9; k++ ) \n        if( T(U+vec2(k%3,k/3)-1.).x > 0. ) n++;\n    if ( hash(U+iTime) < n*Contag ) O.x = 1., O.z = .3;  // contaminated\n    \n        // next-town propagation with probability #Contag\n    if ( hash(U-iTime) < Travel ) \n        if( T(U+Dist*(2.*hash2(U+iTime)-1.)).x > 0. )\n            O.x = 1., O.y = 1.;                  // contaminated\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Contag = .1,      // probability of local transmission per step\n           ContagG = .1,      // probability of transmission for next-town travelers\n              Init = .0004,   // initial infection\n            Travel = .001,    // next-town travelers proportion\n              Dist = 50.;\nconst int     Step = 7 ;      // time step\n     \n#define R          iResolution.xy\n#define T(U)       texelFetch(iChannel0,ivec2(mod(U,R)),0)\n#define hash(p)  ( 1. - fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) )\n#define hash2(p) ( 1. - fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) )\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 103]], "test": "untested"}
{"id": "wdlyDj", "name": "multiscale epidemia simulation 2", "author": "FabriceNeyret2", "description": "Play with parameters in #Common :\n- epidemia propagates locally at rate #Contag per step.\n- a proportion #Travel of people travel to the distant areas ( and might have a higher #ContagG )\n- Step: delay between time steps, to slow down simulation.", "tags": ["simulation", "epidemia"], "likes": 2, "viewed": 311, "published": 3, "date": "1585634670", "time_retrieved": "2024-07-30T21:15:42.597035", "image_code": "// variant of https://shadertoy.com/view/tdXcW2\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if (iFrame==0) { \n        O-=O; \n        if (floor(U) == floor(R/2.) )  O.x = 1.; // initial infection : 1\n      //if ( hash(U) < Init ) O.x = 1.;          // initial infection : random people\n        return; }\n    \n    O = T(U);                                    // recover previous state\n    \n    if ( iFrame % Step > 0 ) return;             // 1 step delay at a time\n    if ( O.x > 0. ) { O.x *= .95; return; }      // already contaminated \n    float n = 0.;                                // local propagation with probability #Contag\n\n    for ( int k=0; k<9; k++ ) \n        if( T(U+vec2(k%3,k/3)-1.).x > 0. ) n++;\n    if ( hash(U+iTime) < n*Contag ) O.x = 1., O.z = .3;  // contaminated\n    \n        // long distance propagation with probability #Contag\n    if ( hash(U-iTime) < Travel ) \n        if( T(R*(hash2(U+iTime))).x > 0. )\n            O.x = 1., O.y = 1.; // contaminated\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Contag = .1,      // probability of local transmission per step\n           ContagG = .1,      // probability of transmission for long distance travelers\n              Init = .0004,   // initial infection\n            Travel = .0003;   // long distance travelers proportion\nconst int     Step = 7 ;      // time step\n     \n#define R          iResolution.xy\n#define T(U)       texelFetch(iChannel0,ivec2(mod(U,R)),0)\n#define hash(p)  ( 1. - fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) )\n#define hash2(p) ( 1. - fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) )\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 103]], "test": "untested"}
{"id": "wdlyWj", "name": "Teal Voronoi Fog", "author": "grinchdubs", "description": "Spacy 3D Voronoi noise makes foggy feelings.", "tags": ["noise", "raymarch", "fog", "3dvoronoi"], "likes": 13, "viewed": 603, "published": 3, "date": "1585625378", "time_retrieved": "2024-07-30T21:15:43.477681", "image_code": "// Fork of \"3D voronoi fog\" by jasondecode. https://shadertoy.com/view/XlXBWj\n// 2020-03-31 03:27:56\n\n/*\n3D Voronoi fogness.\n\nAuthor: Tim Gerritsen <tim@mannetje.org>\nDate: December 2017\n\n*/\n\n#define MAX_MARCH_STEPS 16\n#define MARCH_STEP_SIZE 0.2\n\n#define NOISE_AMPLITUDE 0.75\n\n#define FBM_ITERATIONS 3\n#define FBM_AMPLITUDE_GAIN .8\n#define FBM_FREQUENCY_GAIN 1.9\n\n// 2*tan(radians(45)/2)\n#define FOV45 0.82842693331417825056778150945139\n\nvec3 UvToWorld(vec2 uv) { return normalize(vec3((uv-0.5) * iResolution.xy, -iResolution.y / FOV45)); }\nvec3 Hash3( vec3 p ) { return fract(sin(vec3( dot(p,vec3(127.1,311.7,786.6)), dot(p,vec3(269.5,183.3,455.8)), dot(p,vec3(419.2,371.9,948.6))))*43758.5453); }\nfloat Voronoi(vec3 p)\n{\n\tvec3 n = floor(p);\n\tvec3 f = fract(p);\n\n\tfloat shortestDistance = 1.0;\n\tfor (int x = -1; x < 1; x++) {\n\t\tfor (int y = -1; y < 1; y++) {\n\t\t\tfor (int z = -1; z < 1; z++) {\n\t\t\t\tvec3 o = vec3(x,y,z);\n\t\t\t\tvec3 r = (o - f) + 1.0 + sin(Hash3(n + o)*50.0)*0.2;\n\t\t\t\tfloat d = dot(r,r);\n\t\t\t\tif (d < shortestDistance) {\n\t\t\t\t\tshortestDistance = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shortestDistance;\n}\n\nfloat FractalVoronoi(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat f = 0.8, a = 0.5;\n\tmat2 m = mat2(1, 0.6, -0.6, 0.8);\n\tfor (int i = 0; i < FBM_ITERATIONS; i++) {\n\t\tn += Voronoi(p * f) * a;\n\t\tf *= FBM_FREQUENCY_GAIN;\n\t\ta *= FBM_AMPLITUDE_GAIN;\n\t\tp.xy = m * p.xy;\n\t}\n\treturn n;\n}\n\nvec2 March(vec3 origin, vec3 direction)\n{\n\tfloat depth = MARCH_STEP_SIZE;\n\tfloat d = 0.0;\n\tfor (int i = 0; i < MAX_MARCH_STEPS; i++) {\n\t\tvec3 p = origin + direction * depth;\n\t\td = FractalVoronoi(p) * NOISE_AMPLITUDE;\n\t\tdepth += max(MARCH_STEP_SIZE, d);\n\t}\n\treturn vec2(depth, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res = iResolution.xy;\n\tvec2 uv = (fragCoord.xy / res);\n\n\tvec3 direction = UvToWorld(uv);\n\tvec3 origin = vec3(0.0, -iTime*0.2, 0.0);\n\tvec2 data = March(origin, direction);\n    \n\tvec4 color = vec4(.5, 0.615733, 0.555, 1) * data.y * data.x * 0.7;\n        fragColor = mix(color, vec4(1,.2,1,1), max(0.0, 0.4-data.y));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 439, 464, 464, 541], [542, 542, 564, 564, 699], [700, 700, 723, 723, 1106], [1108, 1108, 1138, 1138, 1374], [1376, 1376, 1417, 1417, 1657], [1659, 1659, 1716, 1716, 2038]], "test": "untested"}
{"id": "3sscDj", "name": "What am I looking at?", "author": "BigETI", "description": "What do you see there?", "tags": ["trippy"], "likes": 4, "viewed": 332, "published": 3, "date": "1585609512", "time_retrieved": "2024-07-30T21:15:44.224684", "image_code": "const float beginZoomFactor = 20.0f;\n\nconst float endZoomFactor = 100.0f;\n\nconst float quarterPi = 0.78539816339f;\n\nconst float pi = 3.14159265359f;\n\nconst float doublePi = 6.28318530718f;\n\nconst float turnsPerSecond = 2.0f;\n\nconst vec2 movementSpeed = vec2(-200.0f, -200.0f);\n\nconst float zoomSpeed = 0.03125f;\n\nconst float spacing = 8.0f;\n\nconst float seperation = 32.0f;\n\nconst vec3 positions[] = vec3[]\n(\n    vec3(0.0f, 0.0f, 0.0f),\n    vec3(0.0f, spacing, 0.0f),\n    vec3(0.0f, -spacing, 0.0f),\n    vec3(spacing, 0.0f, 0.0f),\n    vec3(-spacing, 0.0f, 0.0f),\n    vec3(spacing * cos(quarterPi), spacing * sin(quarterPi), 0.0f),\n    vec3(-spacing * cos(quarterPi), spacing * sin(quarterPi), 0.0f),\n    vec3(spacing * cos(quarterPi), -spacing * sin(quarterPi), 0.0f),\n    vec3(-spacing * cos(quarterPi), -spacing * sin(quarterPi), 0.0f)\n);\n    \nvec4 AlphaBlend(const in vec4 bottom, const in vec4 top)\n{\n    float alpha = top.a + bottom.a * (1.0f - top.a);\n    return vec4((top.rgb * top.a + bottom.rgb * bottom.a * (1.0f - top.a)) / alpha, alpha);\n}\n\nvec4 Sphere(const in vec3 position, const in vec4 innerColor, const in vec4 outerColor, const in vec2 uv)\n{\n    vec4 ret = vec4(0.0f);\n    vec2 offset_uv = uv - position.xy;\n    if ((offset_uv.x * offset_uv.x) + (offset_uv.y * offset_uv.y) < 1.0f)\n    {\n        float view_dot_normal = dot(vec3(0.0f, 0.0f, 1.0f), vec3(offset_uv.x, offset_uv.y, sqrt(1.0f - (offset_uv.x * offset_uv.x) - (offset_uv.y * offset_uv.y))));\n        ret = clamp((innerColor * view_dot_normal) + (outerColor * (1.0f - view_dot_normal)), 0.0f, 1.0f);\n    }\n    return ret;\n}\n\nvec4 Spheres(const in vec4 backgroundColor, const in vec4 innerColor, const in vec4 outerColor, const in vec2 uv, const in bool revert)\n{\n    vec4 ret = backgroundColor;\n    for (int index = 0; index < positions.length(); index++)\n    {\n        float theta = iTime * doublePi * (revert ? -turnsPerSecond : turnsPerSecond);\n        float cos_theta = cos(theta);\n        float sin_theta = sin(theta);\n        vec3 position = vec3((positions[index].x * cos_theta) - (positions[index].y * sin_theta), (positions[index].x * sin_theta) + (positions[index].y * cos_theta), positions[index].z);\n        ret = AlphaBlend(ret, Sphere(position, innerColor, outerColor, mod(uv + (seperation * 0.5f), seperation) - (seperation * 0.5f)));\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 color = vec4(0.125f, 0.125f, 0.25f, 1.0f);\n    vec2 uv = ((fragCoord - iMouse.xy - (iResolution.xy * 0.5f)) * mix(endZoomFactor, beginZoomFactor, (cos(iTime * doublePi * zoomSpeed) * 0.5f) + 0.5f) / iResolution.y) + vec2(movementSpeed.x * cos(iTime), movementSpeed.y * sin(iTime));\n    color = Spheres(color, vec4(1.0f, 0.75f, 0.75f, 0.75f), vec4(1.0f, 0.25f, 0.25f, 0.75f), uv, false);\n    color = Spheres(color, vec4(0.75f, 1.0f, 0.75f, 0.75f), vec4(0.25f, 1.0f, 0.25f, 0.75f), uv + vec2(seperation * 0.5f, seperation * 0.5f), false);\n    color = Spheres(color, vec4(0.75f, 1.0f, 0.75f, 0.75f), vec4(0.25f, 1.0f, 0.25f, 0.75f), uv + vec2(0.0f, seperation * 0.5f), true);\n    color = Spheres(color, vec4(0.75f, 0.75f, 1.0f, 0.75f), vec4(0.25f, 0.25f, 1.0f, 0.75f), uv + vec2(seperation * 0.5f, 0.0f), true);\n    fragColor = vec4(color.xyz, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2354, 2354, 2409, 2409, 3268]], "test": "untested"}
{"id": "WsfcWj", "name": "electrogel 14", "author": "haptix", "description": "electrogel 14", "tags": ["electrogel14"], "likes": 8, "viewed": 522, "published": 3, "date": "1585602980", "time_retrieved": "2024-07-30T21:15:44.974678", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nfloat smAdd(float m1, float m2, float k)\n{\n    float h = clamp(.5 + .5*(m2 - m1)/k, 0., 1.);\n    return mix(m2, m1, h) - k*h*(1. - h);\n}\n\nfloat bump(vec3 p, float offs)\n{\n    return .25*sin(p.x*3.4 + (iTime + offs)*.73) *\n        \t   cos(p.y*3.7 + (iTime + offs)*.81) *\n        \t  (sin(p.z*4.0 + (iTime + offs)*.83) + cos(p.z*2.9 + (iTime + offs)*.57));\n}\n\nvec2 sph(vec3 p, float s, float offs, float matId)\n{\n    return vec2(length(p + bump(p, offs)) - s, matId);\n}\n\nvec2 map(vec3 p)\n{   \n    float matId1 = 0.;\n    float matId2 = 1.;\n    float dist = 1.1*sin(iTime*.7) + 3.;\n    vec2 m1 = sph(vec3(p.x + dist/2., p.y, p.z), 1.5, 133., matId1);\n    vec2 m2 = sph(vec3(p.x - dist/2., p.y, p.z), 1.5, 0., matId2);\n    float matmix = mix(matId1, matId2, abs(m2.x - m1.x));\n    vec2 m = vec2(smAdd(m1.x, m2.x, .6), matmix);\n    glo += .1 / (1.5 + m.x*m.x*5000.);\n    return m;\n}\n\nfloat sss(vec3 p, vec3 l, float d)\n{\n\treturn smoothstep(0., 1., map(p + l*d).x/d);\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 10.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .0001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x * .2;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = -1.;\n\treturn t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 ro = vec3(cos(.15*iTime),\n                   sin(-.15*iTime),\n                   -3.5);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(.07, .07, -10.);\n    vec3 lightPos2 = vec3(-5.07, -5.07, -12);\n  \tvec3 lightPos3 = vec3(5.07, -5.07, -12);\n    \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = .7 * vec3(sin(.151*((iTime+180.) + 44.)),\n                       \t\tsin(.227*((iTime+180.) + 55.)),\n                       \t\tsin(.317*((iTime+180.) + 79.))) + 1.35;\n\n    if (t.y > -1.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        vec3 lightDir2 = normalize(lightPos2 - hit);\n        vec3 lightDir3 = normalize(lightPos3 - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n\n        vec3 l = -lightDir;\n        float sub = 0.;\n        float steps = 750.;\n\n        for(float i = 1.; i < steps; i++)\n        {\n            float dist = i*2. / steps;\n            sub += sss(hit, l, dist);\n        }\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 100.);\n        float spec2 = pow(max(dot(rd, reflect(norm, lightDir2)), 0.), 80.);\n        float spec3 = pow(max(dot(rd, reflect(norm, lightDir3)), 0.), 45.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n\n        vec3 col = .3 * colRot * (t.y + .3);\n        col += sub * colRot * .006;\n        col *= .15 * ao;\n        col += .65 * diff * (colRot.yzx/(t.y*6.));\n        col += .7 * spec * vec3(1., 1., 1.);\n        col += .7 * spec2 * vec3(1., 1., 1.);\n        col += .9 * spec3 * vec3(1., 1., 1.);\n        \n        col += glo*.01*colRot.xzy*(t.y);\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*.01*colRot.yzx*t.y, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 81, 81, 175], [177, 177, 209, 209, 394], [396, 396, 448, 448, 505], [507, 507, 525, 525, 914], [916, 916, 952, 952, 1000], [1002, 1002, 1029, 1029, 1263], [1265, 1265, 1320, 1320, 3598]], "test": "untested"}
{"id": "WdsyWj", "name": " The Live Coders Conference - 2", "author": "mrange", "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.", "tags": ["3d", "fbm", "raymarcher", "tlc"], "likes": 5, "viewed": 487, "published": 3, "date": "1585597203", "time_retrieved": "2024-07-30T21:15:45.734646", "image_code": "// Created by mrange/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Unported License.\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  https://iquilezles.org/articles/distfunctions2d\n// pmin from IQ's blog on smooth minimum functions:\n//  https://iquilezles.org/articles/smin\n\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  5.0\n#define MAX_BOUNCES     5\n#define MAX_RAY_MARCHES 65\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define AA              0\n\n#define TTIME           (TAU*iTime)\n\n#define SCA(a) vec2(sin(a), cos(a))\n\nconst vec2 sca          = SCA(PI*4.5/6.0);\nconst vec3 lightPos1    = 100.0*vec3(-1.0, 0.0, 0.0);\nconst vec3 lightCol1    = vec3(0.63, 0.63, 1.0);\nconst vec3 spokeColor   = vec3(0.5, 0.5, 1.0);\nconst vec3 meepleColor  = vec3(0.8);\nconst vec3 bgColor      = vec3(0.1, 0.1, 0.25);\n\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat maxComp(vec3 p) {\n  return max(p.x,max(p.y,p.z));\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nfloat cylinder(vec3 p, float ra, float rb, float h) {\n  h -= rb;\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat box(vec3 p, vec3 b, float r) {\n  b -= r;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat torus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k ) - rb;\n}\n\nfloat spokes(vec3 p, float s) {\n  vec2 pp = toPolar(p.xz);\n  pp.y += TTIME/14.0;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p.xz = toRect(pp.xy);\n  float ds = box(p, s*vec3(0.075, 0.125, 0.5), s*0.04);\n  return ds;\n}\n\nfloat arcs(vec3 p, float s) {\n  p.xyz = p.zxy*vec3(1.0, -1.0, 1.0);\n  p.z += -0.25;\n  float d1 = torus(p, sca, 0.275*s, 0.025*s);\n  float d2 = torus(p, sca, 0.18*s, 0.025*s);\n  return min(d1, d2);\n}\n\nfloat meeple(vec3 p, float s) {\n  p.xyz = p.zxy*vec3(1.0, -1.0, 1.0);\n  float dh = box(p - s*vec3(0.0, -0.035, 0.125), s*vec3(0.07, 0.1, 0.05), s*0.065);\n  float dc = box(p - s*vec3(0.0, -0.22, 0.125), s*vec3(0.15, 0.04, 0.075), s*0.05);\n\n  return pmin(dh, dc, s*0.115);\n}\n\nfloat intersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a,r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\nfloat differenceRound(float a, float b, float r) {\n  return intersectionRound(a, -b, r);\n}\n\nfloat theLiveCoder(vec3 p, float s, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  float dr = cylinder(p, 0.375*0.5*s, 0.075*s, 0.125*s);\n  float ds = spokes(p, s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n\n  float nda = (da - 0.0125*s);\n  float ndm = (dm - 0.0125*s);\n  float nd  = min(nda, ndm);\n\n  float d = dr;\n  d = min(d, ds);\n  float dw = d;\n  d = differenceRound(d, nd, 0.02);\n  d = min(d, da);\n  d = min(d, dm);\n\n  oda = da;\n  odm = dm;\n\n  vec2 pp = toPolar(p.xz);\n\n  vec3 acol = saturate(spokeColor + 0.5*vec3(1.0, 0.0, 0.0)*sin(-TTIME/7.0 + PI*pp.x + 0.5) +  0.5*vec3(0.0, 1.0, 0.0)*sin(-TTIME/6.0 + 1.0*pp.y + 0.0));\n\n  if (d == da) {\n    col = acol;\n    trans = 0.70;\n  } else if (d == dm) {\n    col = meepleColor;\n    trans = 0.70;\n  } else if (d != dw) {\n    col = acol;\n    trans = 0.5;\n  } else {\n    col = vec3(0.25, 0.25, 0.5);\n    trans = 0.5;\n  }\n\n  ref = 0.25;\n  absorb = mix(vec3(1.0), vec3(-5.0), col*col);\n\n  return d;\n}\n\nfloat distanceField(in vec3 p, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  p.xy = p.yx*vec2(-1.0, 1.0);\n\n  float d = theLiveCoder(p, 2.0, oda, odm, col, ref, trans, absorb);\n\n  return d;\n}\n\nvec3 getSkyColor(vec3 rayDir) {\n  vec3 lightDir1 = normalize(lightPos1);\n\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  vec3 final     = 0.1*lightCol1;\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n\n  vec3 light = 1.0*lightCol1;\n\n  final += light*pow(ld1, 20.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3 eps = vec3(.0001,0.0,0.0);\n  vec3 col;\n  float oda;\n  float odm;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.xyy, oda, odm, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.yxy, oda, odm, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.yyx, oda, odm, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  float t = mint;\n  float distance;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, oda, odm, col, ref, trans, absorb);\n    distance = dmod*distance_;\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n\n  if (distance > TOLERANCE) return MAX_RAY_LENGTH;\n\n  return t;\n}\n\nvec3 postProcess(in vec3 col, in vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 1.5*vec3(1.0, 3.0, 1.0);\n\n  vec3 final  = vec3(0.0);\n\n  vec3 ragg   = vec3(1.0);\n\n  float tdist = 0.0;\n\n  float refraction = 1.3;\n\n  bool inside = false;\n\n  const float mint    = 0.05;\n  const float minstep = 0.00025;\n\n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.01) break;\n    float dmod  = inside ? -1.0 : 1.0;\n    vec3 absorb ;\n    float oda   ;\n    float odm   ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, oda, odm, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n\n    if (t < MAX_RAY_LENGTH) {\n      nor = normal(pos);\n    } else {\n      final += ragg*getSkyColor(rd);\n      break;\n    }\n\n    float fresnel = pow(1.0 - abs(dot(nor, rd)), 2.0);\n\n    ref = mix(ref, 1.0, fresnel);\n    trans = mix(trans, 0.0, fresnel);\n\n    float mref = refraction;\n\n    if (inside) {\n      nor = -nor;\n      mref = 1.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3  lv  = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n\n    float dif = max(dot(nor,ld),0.0);\n    float occ = 1.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*occ;\n\n    vec3 lr   = vec3(0.0);\n\n    float lin = mix(0.2, 1.0, l);\n\n    vec3 sky  = getSkyColor(refl);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n    mcol += 0.5*spokeColor*tanh(1.0/(20.0*(max(oda, 0.05))));\n    mcol += meepleColor*0.35*tanh(1.0/(100.0*(pow(max(odm, 0.025), 1.5))));\n\n    vec3 beer = vec3(1.0, 1.0, 1.0);\n\n    if (inside) {\n      beer = exp(-absorb*t);\n    }\n\n    final      += (1.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.0)) {\n        rd = refl;\n    } else {\n      rd = refr;\n      inside = !inside;\n    }\n  }\n\n  return final;\n}\n\nvec3 getSample(in vec2 p) {\n  vec3 ro  = vec3(2.5, 0.0, 0.0) + 0.5*vec3(0.0, sin(TTIME/33.0), cos(TTIME/36.0));;\n\n  vec3 la  = vec3(0.0) + 0.125*vec3(0.0, sin(TTIME/30.0), cos(TTIME/27.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\n\nfloat box2(vec2 p, vec2 b, float r) {\n  b -= r;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float db = box2(p, vec2(0.88), 0.3);\n\n  if (db > 0.0) {\n    float m = smoothstep(0.1, 0.105, db);\n    fragColor = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(bgColor, 1.0), m);\n    return;\n  }\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  for(int y = 0; y < 2; ++y)\n  {\n    for(int x = 0; x < 2; ++x)\n    {\n      col += getSample(p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 4.0;\n#endif\n  col = postProcess(col, p);\n  float bb = smoothstep(0.005, 0.125, abs(db));\n  col = mix(vec3(0.125), col, pow(bb, 0.350));\n  float wb = smoothstep(0.0, 0.005, abs(db));\n  col = mix(vec3(1.0), col, wb);\n  col = mix(bgColor, col, smoothstep(0.0, 16.0, iTime*iTime));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1141, 1141, 1163, 1163, 1207], [1209, 1209, 1230, 1230, 1275], [1277, 1277, 1316, 1316, 1441], [1443, 1443, 1482, 1482, 1558], [1560, 1560, 1583, 1583, 1617], [1619, 1619, 1647, 1647, 1676], [1677, 1677, 1705, 1705, 1734], [1736, 1736, 1789, 1789, 1917], [1919, 1919, 1955, 1955, 2056], [2058, 2058, 2120, 2120, 2267], [2269, 2269, 2300, 2300, 2486], [2488, 2488, 2517, 2517, 2686], [2688, 2688, 2719, 2719, 2960], [2962, 2962, 3014, 3014, 3102], [3104, 3104, 3154, 3154, 3194], [3196, 3196, 3326, 3326, 4202], [4204, 4204, 4329, 4329, 4445], [4447, 4447, 4478, 4478, 4943], [4945, 4945, 4971, 4971, 5536], [5538, 5538, 5729, 5729, 6103], [6105, 6105, 6147, 6147, 6295], [6297, 6297, 6334, 6334, 8255], [8257, 8257, 8284, 8284, 8668], [8671, 8671, 8708, 8708, 8798], [8800, 8800, 8855, 8855, 9712]], "test": "untested"}
{"id": "wsfyD2", "name": "planar distortions", "author": "sh1boot", "description": "rotating the colour components and then distorting some planes and rotating them back.\n\nThe spatial distortion is static, but the way human perception weights different colour planes gives the appearance of movement as planes rotate through colour space.", "tags": ["colourspace"], "likes": 3, "viewed": 447, "published": 3, "date": "1585594207", "time_retrieved": "2024-07-30T21:15:46.482646", "image_code": "vec4 fwd(vec4 c) {\n    float t0 = iTime * 1.02;\n    float t1 = iTime * 1.333;\n    float t2 = iTime * 1.21;\n\n    c.xy = c.xy * mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n    c.yz = c.yz * mat2(cos(t1), -sin(t1), sin(t1), cos(t1));\n    c.zx = c.zx * mat2(cos(t2), -sin(t2), sin(t2), cos(t2));\n    return c;\n}\n\nvec4 bwd(vec4 c) {\n    float t0 = -iTime * 1.02;\n    float t1 = -iTime * 1.333;\n    float t2 = -iTime * 1.21;\n\n    c.zx = c.zx * mat2(cos(t2), -sin(t2), sin(t2), cos(t2));\n    c.yz = c.yz * mat2(cos(t1), -sin(t1), sin(t1), cos(t1));\n    c.xy = c.xy * mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float f0 = 0.0;\n    float f1 = 0.0;\n    float f2 = 0.0;\n    float w = 0.003;\n\n    vec4 col0 = texture(iChannel0, uv, f0);\n    vec4 col1 = texture(iChannel0, uv + vec2(0.0,sin(uv.x*40.0)*w), f1);\n    vec4 col2 = texture(iChannel0, uv + vec2(sin(uv.y*30.0)*w,0.0), f2);\n    col0 = fwd(col0);\n    col1 = fwd(col1);\n    col2 = fwd(col2);\n    vec4 col = vec4(col0.x, col1.y, col2.z, 1.0);\n    col = bwd(col);\n\n    fragColor = col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 306], [308, 308, 326, 326, 617], [619, 619, 676, 676, 1148]], "test": "untested"}
{"id": "tdfyD2", "name": "Animal Crossing xBR 4x", "author": "yuchengzhong", "description": "Animal Crossing\nBase on\nhttps://github.com/libretro/common-shaders/blob/master/xbrz/shaders/4xbrz.cg", "tags": ["pixel", "pixelated", "xbr", "animalcrossing"], "likes": 17, "viewed": 1042, "published": 3, "date": "1585593227", "time_retrieved": "2024-07-30T21:15:47.538822", "image_code": "//Base on\n//https://github.com/libretro/common-shaders/blob/master/xbrz/shaders/4xbrz.cg\n\n#define LUMINANCE_WEIGHT 1.0\n#define EQUAL_COLOR_TOLERANCE 20.0/255.0\n#define DOMINANT_DIRECTION_THRESHOLD 2.6\n#define STEEP_DIRECTION_THRESHOLD 4.6\nfloat DistYCbCr(const vec3 pixA, const vec3 pixB)\n{\n\tconst vec3 w = vec3(0.2627, 0.6780, 0.0593);\n\tconst float scaleB = 0.5 / (1.0 - w.b);\n\tconst float scaleR = 0.5 / (1.0 - w.r);\n\tvec3 diff = pixA - pixB;\n\tfloat Y = dot(diff, w);\n\tfloat Cb = scaleB * (diff.b - Y);\n\tfloat Cr = scaleR * (diff.r - Y);\n\t\t\n\treturn sqrt( ((LUMINANCE_WEIGHT * Y) * (LUMINANCE_WEIGHT * Y)) + (Cb * Cb) + (Cr * Cr) );\n}\n\t\nbool IsPixEqual(const vec3 pixA, const vec3 pixB)\n{\n\treturn (DistYCbCr(pixA, pixB) < EQUAL_COLOR_TOLERANCE);\n}\nfloat reduce(const vec3 color)\n{\n\treturn dot(color, vec3(65536.0, 256.0, 1.0));\n}\t\nbool IsBlendingNeeded(const int blend0,const int blend1,const int blend2,const int blend3)\n{\n\t//return any(!(blend == int4(BLEND_NONE,BLEND_NONE,BLEND_NONE,BLEND_NONE)));\n    return blend0 != 0||blend1 != 0||blend2 != 0||blend3 != 0;\n}\n\t\n\t//---------------------------------------\n\t// Input Pixel Mapping:  --|21|22|23|--\n\t//                       19|06|07|08|09\n\t//                       18|05|00|01|10\n\t//                       17|04|03|02|11\n\t//                       --|15|14|13|--\n\t//\n\t// Output Pixel Mapping:  06|07|08|09\n\t//                        05|00|01|10\n\t//                        04|03|02|11\n\t//                        15|14|13|12\n\n\n/* FRAGMENT SHADER */\nvec3 four_xBRZ(vec2 texture_size,vec2 texCoord)\n{\n\n\tvec2 f = fract(texCoord*texture_size);\n\n\t//---------------------------------------\n\t// Input Pixel Mapping:  20|21|22|23|24\n\t//                       19|06|07|08|09\n\t//                       18|05|00|01|10\n\t//                       17|04|03|02|11\n\t//                       16|15|14|13|12\n    float dx = 1.0/texture_size.x;\n    float dy = 1.0/texture_size.y;\n    vec4 t1 = texCoord.xxxy + vec4( -dx, 0, dx,-2.0*dy); // A1 B1 C1\n\tvec4 t2 = texCoord.xxxy + vec4( -dx, 0, dx, -dy); // A B C\n\tvec4 t3 = texCoord.xxxy + vec4( -dx, 0, dx, 0); // D E F\n\tvec4 t4 = texCoord.xxxy + vec4( -dx, 0, dx, dy); // G H I\n\tvec4 t5 = texCoord.xxxy + vec4( -dx, 0, dx, 2.0*dy); // G5 H5 I5\n\tvec4 t6 = texCoord.xyyy + vec4(-2.0*dx,-dy, 0, dy); // A0 D0 G0\n\tvec4 t7 = texCoord.xyyy + vec4( 2.0*dx,-dy, 0, dy); // C4 F4 I4\n\tvec3 src[25];\n  \n\tsrc[21] = texture(iChannel0, floor(t1.xw*texture_size)/texture_size).rgb;\n\tsrc[22] = texture(iChannel0, floor(t1.yw*texture_size)/texture_size).rgb;\n\tsrc[23] = texture(iChannel0, floor(t1.zw*texture_size)/texture_size).rgb;\n\tsrc[ 6] = texture(iChannel0, floor(t2.xw*texture_size)/texture_size).rgb;\n\tsrc[ 7] = texture(iChannel0, floor(t2.yw*texture_size)/texture_size).rgb;\n\tsrc[ 8] = texture(iChannel0, floor(t2.zw*texture_size)/texture_size).rgb;\n\tsrc[ 5] = texture(iChannel0, floor(t3.xw*texture_size)/texture_size).rgb;\n\tsrc[ 0] = texture(iChannel0, floor(t3.yw*texture_size)/texture_size).rgb;\n\tsrc[ 1] = texture(iChannel0, floor(t3.zw*texture_size)/texture_size).rgb;\n\tsrc[ 4] = texture(iChannel0, floor(t4.xw*texture_size)/texture_size).rgb;\n\tsrc[ 3] = texture(iChannel0, floor(t4.yw*texture_size)/texture_size).rgb;\n\tsrc[ 2] = texture(iChannel0, floor(t4.zw*texture_size)/texture_size).rgb;\n\tsrc[15] = texture(iChannel0, floor(t5.xw*texture_size)/texture_size).rgb;\n\tsrc[14] = texture(iChannel0, floor(t5.yw*texture_size)/texture_size).rgb;\n\tsrc[13] = texture(iChannel0, floor(t5.zw*texture_size)/texture_size).rgb;\n\tsrc[19] = texture(iChannel0, floor(t6.xy*texture_size)/texture_size).rgb;\n\tsrc[18] = texture(iChannel0, floor(t6.xz*texture_size)/texture_size).rgb;\n\tsrc[17] = texture(iChannel0, floor(t6.xw*texture_size)/texture_size).rgb;\n\tsrc[ 9] = texture(iChannel0, floor(t7.xy*texture_size)/texture_size).rgb;\n\tsrc[10] = texture(iChannel0, floor(t7.xz*texture_size)/texture_size).rgb;\n\tsrc[11] = texture(iChannel0, floor(t7.xw*texture_size)/texture_size).rgb;\n\n\t\tfloat v[9];\n\t\tv[0] = reduce(src[0]);\n\t\tv[1] = reduce(src[1]);\n\t\tv[2] = reduce(src[2]);\n\t\tv[3] = reduce(src[3]);\n\t\tv[4] = reduce(src[4]);\n\t\tv[5] = reduce(src[5]);\n\t\tv[6] = reduce(src[6]);\n\t\tv[7] = reduce(src[7]);\n\t\tv[8] = reduce(src[8]);\n\t\t\n\t\tint blendResult0 = 0;\n\t\tint blendResult1 = 1;\n\t\tint blendResult2 = 2;\n\t\tint blendResult3 = 3;\n\t\t\n\t\t// Preprocess corners\n\t\t// Pixel Tap Mapping: --|--|--|--|--\n\t\t//                    --|--|07|08|--\n\t\t//                    --|05|00|01|10\n\t\t//                    --|04|03|02|11\n\t\t//                    --|--|14|13|--\n\t\t\n\t\t// Corner (1, 1)\n\t\tif ( !((v[0] == v[1] && v[3] == v[2]) || (v[0] == v[3] && v[1] == v[2])) )\n\t\t{\n\t\t\tfloat dist_03_01 = DistYCbCr(src[ 4], src[ 0]) + DistYCbCr(src[ 0], src[ 8]) + DistYCbCr(src[14], src[ 2]) + DistYCbCr(src[ 2], src[10]) + (4.0 * DistYCbCr(src[ 3], src[ 1]));\n\t\t\tfloat dist_00_02 = DistYCbCr(src[ 5], src[ 3]) + DistYCbCr(src[ 3], src[13]) + DistYCbCr(src[ 7], src[ 1]) + DistYCbCr(src[ 1], src[11]) + (4.0 * DistYCbCr(src[ 0], src[ 2]));\n\t\t\tbool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_03_01) < dist_00_02;\n\t\t\tblendResult2 = ((dist_03_01 < dist_00_02) && (v[0] != v[1]) && (v[0] != v[3])) ? ((dominantGradient) ? 2 : 1) : 0;\n\t\t}\n\t\t\n\t\t\n\t\t// Pixel Tap Mapping: --|--|--|--|--\n\t\t//                    --|06|07|--|--\n\t\t//                    18|05|00|01|--\n\t\t//                    17|04|03|02|--\n\t\t//                    --|15|14|--|--\n\t\t// Corner (0, 1)\n\t\tif ( !((v[5] == v[0] && v[4] == v[3]) || (v[5] == v[4] && v[0] == v[3])) )\n\t\t{\n\t\t\tfloat dist_04_00 = DistYCbCr(src[17], src[ 5]) + DistYCbCr(src[ 5], src[ 7]) + DistYCbCr(src[15], src[ 3]) + DistYCbCr(src[ 3], src[ 1]) + (4.0 * DistYCbCr(src[ 4], src[ 0]));\n\t\t\tfloat dist_05_03 = DistYCbCr(src[18], src[ 4]) + DistYCbCr(src[ 4], src[14]) + DistYCbCr(src[ 6], src[ 0]) + DistYCbCr(src[ 0], src[ 2]) + (4.0 * DistYCbCr(src[ 5], src[ 3]));\n\t\t\tbool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_05_03) < dist_04_00;\n\t\t\tblendResult3 = ((dist_04_00 > dist_05_03) && (v[0] != v[5]) && (v[0] != v[3])) ? ((dominantGradient) ? 2 : 1) : 0;\n\t\t}\n\t\t\n\t\t// Pixel Tap Mapping: --|--|22|23|--\n\t\t//                    --|06|07|08|09\n\t\t//                    --|05|00|01|10\n\t\t//                    --|--|03|02|--\n\t\t//                    --|--|--|--|--\n\t\t// Corner (1, 0)\n\t\tif ( !((v[7] == v[8] && v[0] == v[1]) || (v[7] == v[0] && v[8] == v[1])) )\n\t\t{\n\t\t\tfloat dist_00_08 = DistYCbCr(src[ 5], src[ 7]) + DistYCbCr(src[ 7], src[23]) + DistYCbCr(src[ 3], src[ 1]) + DistYCbCr(src[ 1], src[ 9]) + (4.0 * DistYCbCr(src[ 0], src[ 8]));\n\t\t\tfloat dist_07_01 = DistYCbCr(src[ 6], src[ 0]) + DistYCbCr(src[ 0], src[ 2]) + DistYCbCr(src[22], src[ 8]) + DistYCbCr(src[ 8], src[10]) + (4.0 * DistYCbCr(src[ 7], src[ 1]));\n\t\t\tbool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_07_01) < dist_00_08;\n\t\t\tblendResult1 = ((dist_00_08 > dist_07_01) && (v[0] != v[7]) && (v[0] != v[1])) ? ((dominantGradient) ? 2 : 1) : 0;\n\t\t}\n\t\t\n\t\t// Pixel Tap Mapping: --|21|22|--|--\n\t\t//                    19|06|07|08|--\n\t\t//                    18|05|00|01|--\n\t\t//                    --|04|03|--|--\n\t\t//                    --|--|--|--|--\n\t\t// Corner (0, 0)\n\t\tif ( !((v[6] == v[7] && v[5] == v[0]) || (v[6] == v[5] && v[7] == v[0])) )\n\t\t{\n\t\t\tfloat dist_05_07 = DistYCbCr(src[18], src[ 6]) + DistYCbCr(src[ 6], src[22]) + DistYCbCr(src[ 4], src[ 0]) + DistYCbCr(src[ 0], src[ 8]) + (4.0 * DistYCbCr(src[ 5], src[ 7]));\n\t\t\tfloat dist_06_00 = DistYCbCr(src[19], src[ 5]) + DistYCbCr(src[ 5], src[ 3]) + DistYCbCr(src[21], src[ 7]) + DistYCbCr(src[ 7], src[ 1]) + (4.0 * DistYCbCr(src[ 6], src[ 0]));\n\t\t\tbool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_05_07) < dist_06_00;\n\t\t\tblendResult0 = ((dist_05_07 < dist_06_00) && (v[0] != v[5]) && (v[0] != v[7])) ? ((dominantGradient) ? 2 : 1) : 0;\n\t\t}\n\t\t\n\t\tvec3 dst[16];\n\t\tdst[ 0] = src[0];\n\t\tdst[ 1] = src[0];\n\t\tdst[ 2] = src[0];\n\t\tdst[ 3] = src[0];\n\t\tdst[ 4] = src[0];\n\t\tdst[ 5] = src[0];\n\t\tdst[ 6] = src[0];\n\t\tdst[ 7] = src[0];\n\t\tdst[ 8] = src[0];\n\t\tdst[ 9] = src[0];\n\t\tdst[10] = src[0];\n\t\tdst[11] = src[0];\n\t\tdst[12] = src[0];\n\t\tdst[13] = src[0];\n\t\tdst[14] = src[0];\n\t\tdst[15] = src[0];\n\t\t\n\t\t// Scale pixel\n\t\tif (IsBlendingNeeded(blendResult0,blendResult1,blendResult2,blendResult3))\n\t\t{\n\t\t\tfloat dist_01_04 = DistYCbCr(src[1], src[4]);\n\t\t\tfloat dist_03_08 = DistYCbCr(src[3], src[8]);\n\t\t\tbool haveShallowLine = (STEEP_DIRECTION_THRESHOLD * dist_01_04 <= dist_03_08) && (v[0] != v[4]) && (v[5] != v[4]);\n\t\t\tbool haveSteepLine   = (STEEP_DIRECTION_THRESHOLD * dist_03_08 <= dist_01_04) && (v[0] != v[8]) && (v[7] != v[8]);\n\t\t\tbool needBlend = (blendResult2 != 0);\n\t\t\tbool doLineBlend = (  blendResult2 >= 2 ||\n\t\t\t\t\t\t\t   !((blendResult1 != 0 && !IsPixEqual(src[0], src[4])) ||\n\t\t\t\t\t\t\t\t (blendResult3 != 0 && !IsPixEqual(src[0], src[8])) ||\n\t\t\t\t\t\t\t\t (IsPixEqual(src[4], src[3]) && IsPixEqual(src[3], src[2]) && IsPixEqual(src[2], src[1]) && IsPixEqual(src[1], src[8]) && !IsPixEqual(src[0], src[2])) ) );\n\t\t\t\n\t\t\tvec3 blendPix = ( DistYCbCr(src[0], src[1]) <= DistYCbCr(src[0], src[3]) ) ? src[1] : src[3];\n\t\t\tdst[ 2] = mix(dst[ 2], blendPix, (needBlend && doLineBlend) ? ((haveShallowLine) ? ((haveSteepLine) ? 1.0/3.0 : 0.25) : ((haveSteepLine) ? 0.25 : 0.00)) : 0.00);\n\t\t\tdst[ 9] = mix(dst[ 9], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.25 : 0.00);\n\t\t\tdst[10] = mix(dst[10], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.75 : 0.00);\n\t\t\tdst[11] = mix(dst[11], blendPix, (needBlend) ? ((doLineBlend) ? ((haveSteepLine) ? 1.00 : ((haveShallowLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[12] = mix(dst[12], blendPix, (needBlend) ? ((doLineBlend) ? 1.00 : 0.6848532563) : 0.00);\n\t\t\tdst[13] = mix(dst[13], blendPix, (needBlend) ? ((doLineBlend) ? ((haveShallowLine) ? 1.00 : ((haveSteepLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[14] = mix(dst[14], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.75 : 0.00);\n\t\t\tdst[15] = mix(dst[15], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.25 : 0.00);\n\t\t\t\n\t\t\t\n\t\t\tdist_01_04 = DistYCbCr(src[7], src[2]);\n\t\t\tdist_03_08 = DistYCbCr(src[1], src[6]);\n\t\t\thaveShallowLine = (STEEP_DIRECTION_THRESHOLD * dist_01_04 <= dist_03_08) && (v[0] != v[2]) && (v[3] != v[2]);\n\t\t\thaveSteepLine   = (STEEP_DIRECTION_THRESHOLD * dist_03_08 <= dist_01_04) && (v[0] != v[6]) && (v[5] != v[6]);\n\t\t\tneedBlend = (blendResult1 != 0);\n\t\t\tdoLineBlend = (  blendResult1 >= 2 ||\n\t\t\t\t\t\t  !((blendResult0 != 0 && !IsPixEqual(src[0], src[2])) ||\n\t\t\t\t\t\t\t(blendResult2 != 0 && !IsPixEqual(src[0], src[6])) ||\n\t\t\t\t\t\t\t(IsPixEqual(src[2], src[1]) && IsPixEqual(src[1], src[8]) && IsPixEqual(src[8], src[7]) && IsPixEqual(src[7], src[6]) && !IsPixEqual(src[0], src[8])) ) );\n\t\t\t\n\t\t\tblendPix = ( DistYCbCr(src[0], src[7]) <= DistYCbCr(src[0], src[1]) ) ? src[7] : src[1];\n\t\t\tdst[ 1] = mix(dst[ 1], blendPix, (needBlend && doLineBlend) ? ((haveShallowLine) ? ((haveSteepLine) ? 1.0/3.0 : 0.25) : ((haveSteepLine) ? 0.25 : 0.00)) : 0.00);\n\t\t\tdst[ 6] = mix(dst[ 6], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.25 : 0.00);\n\t\t\tdst[ 7] = mix(dst[ 7], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.75 : 0.00);\n\t\t\tdst[ 8] = mix(dst[ 8], blendPix, (needBlend) ? ((doLineBlend) ? ((haveSteepLine) ? 1.00 : ((haveShallowLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[ 9] = mix(dst[ 9], blendPix, (needBlend) ? ((doLineBlend) ? 1.00 : 0.6848532563) : 0.00);\n\t\t\tdst[10] = mix(dst[10], blendPix, (needBlend) ? ((doLineBlend) ? ((haveShallowLine) ? 1.00 : ((haveSteepLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[11] = mix(dst[11], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.75 : 0.00);\n\t\t\tdst[12] = mix(dst[12], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.25 : 0.00);\n\t\t\t\n\t\t\t\n\t\t\tdist_01_04 = DistYCbCr(src[5], src[8]);\n\t\t\tdist_03_08 = DistYCbCr(src[7], src[4]);\n\t\t\thaveShallowLine = (STEEP_DIRECTION_THRESHOLD * dist_01_04 <= dist_03_08) && (v[0] != v[8]) && (v[1] != v[8]);\n\t\t\thaveSteepLine   = (STEEP_DIRECTION_THRESHOLD * dist_03_08 <= dist_01_04) && (v[0] != v[4]) && (v[3] != v[4]);\n\t\t\tneedBlend = (blendResult0 != 0);\n\t\t\tdoLineBlend = (  blendResult0 >= 2 ||\n\t\t\t\t\t\t  !((blendResult3 != 0 && !IsPixEqual(src[0], src[8])) ||\n\t\t\t\t\t\t\t(blendResult1 != 0 && !IsPixEqual(src[0], src[4])) ||\n\t\t\t\t\t\t\t(IsPixEqual(src[8], src[7]) && IsPixEqual(src[7], src[6]) && IsPixEqual(src[6], src[5]) && IsPixEqual(src[5], src[4]) && !IsPixEqual(src[0], src[6])) ) );\n\t\t\t\n\t\t\tblendPix = ( DistYCbCr(src[0], src[5]) <= DistYCbCr(src[0], src[7]) ) ? src[5] : src[7];\n\t\t\tdst[ 0] = mix(dst[ 0], blendPix, (needBlend && doLineBlend) ? ((haveShallowLine) ? ((haveSteepLine) ? 1.0/3.0 : 0.25) : ((haveSteepLine) ? 0.25 : 0.00)) : 0.00);\n\t\t\tdst[15] = mix(dst[15], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.25 : 0.00);\n\t\t\tdst[ 4] = mix(dst[ 4], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.75 : 0.00);\n\t\t\tdst[ 5] = mix(dst[ 5], blendPix, (needBlend) ? ((doLineBlend) ? ((haveSteepLine) ? 1.00 : ((haveShallowLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[ 6] = mix(dst[ 6], blendPix, (needBlend) ? ((doLineBlend) ? 1.00 : 0.6848532563) : 0.00);\n\t\t\tdst[ 7] = mix(dst[ 7], blendPix, (needBlend) ? ((doLineBlend) ? ((haveShallowLine) ? 1.00 : ((haveSteepLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[ 8] = mix(dst[ 8], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.75 : 0.00);\n\t\t\tdst[ 9] = mix(dst[ 9], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.25 : 0.00);\n\t\t\t\n\t\t\t\n\t\t\tdist_01_04 = DistYCbCr(src[3], src[6]);\n\t\t\tdist_03_08 = DistYCbCr(src[5], src[2]);\n\t\t\thaveShallowLine = (STEEP_DIRECTION_THRESHOLD * dist_01_04 <= dist_03_08) && (v[0] != v[6]) && (v[7] != v[6]);\n\t\t\thaveSteepLine   = (STEEP_DIRECTION_THRESHOLD * dist_03_08 <= dist_01_04) && (v[0] != v[2]) && (v[1] != v[2]);\n\t\t\tneedBlend = (blendResult3 != 0);\n\t\t\tdoLineBlend = (  blendResult3 >= 2 ||\n\t\t\t\t\t\t  !((blendResult2 != 0 && !IsPixEqual(src[0], src[6])) ||\n\t\t\t\t\t\t\t(blendResult0 != 0 && !IsPixEqual(src[0], src[2])) ||\n\t\t\t\t\t\t\t(IsPixEqual(src[6], src[5]) && IsPixEqual(src[5], src[4]) && IsPixEqual(src[4], src[3]) && IsPixEqual(src[3], src[2]) && !IsPixEqual(src[0], src[4])) ) );\n\t\t\t\n\t\t\tblendPix = ( DistYCbCr(src[0], src[3]) <= DistYCbCr(src[0], src[5]) ) ? src[3] : src[5];\n\t\t\tdst[ 3] = mix(dst[ 3], blendPix, (needBlend && doLineBlend) ? ((haveShallowLine) ? ((haveSteepLine) ? 1.0/3.0 : 0.25) : ((haveSteepLine) ? 0.25 : 0.00)) : 0.00);\n\t\t\tdst[12] = mix(dst[12], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.25 : 0.00);\n\t\t\tdst[13] = mix(dst[13], blendPix, (needBlend && doLineBlend && haveSteepLine) ? 0.75 : 0.00);\n\t\t\tdst[14] = mix(dst[14], blendPix, (needBlend) ? ((doLineBlend) ? ((haveSteepLine) ? 1.00 : ((haveShallowLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[15] = mix(dst[15], blendPix, (needBlend) ? ((doLineBlend) ? 1.00 : 0.6848532563) : 0.00);\n\t\t\tdst[ 4] = mix(dst[ 4], blendPix, (needBlend) ? ((doLineBlend) ? ((haveShallowLine) ? 1.00 : ((haveSteepLine) ? 0.75 : 0.50)) : 0.08677704501) : 0.00);\n\t\t\tdst[ 5] = mix(dst[ 5], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.75 : 0.00);\n\t\t\tdst[ 6] = mix(dst[ 6], blendPix, (needBlend && doLineBlend && haveShallowLine) ? 0.25 : 0.00);\n\t\t}\n\t\t\n\t\tvec3 res = mix( mix( mix( mix(dst[ 6], dst[ 7], step(0.25, f.x)), mix(dst[ 8], dst[ 9], step(0.75, f.x)), step(0.50, f.x)),\n\t\t                             mix( mix(dst[ 5], dst[ 0], step(0.25, f.x)), mix(dst[ 1], dst[10], step(0.75, f.x)), step(0.50, f.x)), step(0.25, f.y)),\n\t\t                        mix( mix( mix(dst[ 4], dst[ 3], step(0.25, f.x)), mix(dst[ 2], dst[11], step(0.75, f.x)), step(0.50, f.x)),\n\t\t                             mix( mix(dst[15], dst[14], step(0.25, f.x)), mix(dst[13], dst[12], step(0.75, f.x)), step(0.50, f.x)), step(0.75, f.y)),\n\t\t                                                                                                                                    step(0.50, f.y));\n\n\n\t\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col1 = four_xBRZ(vec2(256.0,32.0),vec2(-0.042,0.0)+ uv*vec2(0.25,1.0)+vec2(floor(iTime*8.0)*0.156+0.064*floor(iTime*8.0/6.0),0.0));\n    vec3 col2 = texture(iChannel0,vec2(-0.042,0.0)+ uv*vec2(0.25,1.0)+vec2(floor(iTime*8.0)*0.156+0.064*floor(iTime*8.0/6.0),0.0)).xyz;\n    float split = 0.5+0.5*sin(iTime);\n    fragColor = vec4(uv.x>0.18&&uv.x<0.82?(uv.x>split?uv.x<split+0.01?vec3(0.0,0.0,0.0):col2:col1):vec3(1.0),1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 290, 290, 635], [638, 638, 689, 689, 748], [749, 749, 781, 781, 830], [832, 832, 924, 1002, 1067], [1480, 1502, 1551, 1551, 15935], [15937, 15937, 15994, 15994, 16467]], "test": "untested"}
{"id": "tdXyRS", "name": "Reverse Blackhole Raymarching", "author": "FrickHazard", "description": "Weird idea for shader using gradients of certain primitives to bend the ray during march.  Very prone to artifacts, still seemed to have an relatively interesting effect though.  Next attempt would be to factor out the anti convergence for analytic solu.", "tags": ["raymarch", "warp"], "likes": 6, "viewed": 540, "published": 3, "date": "1585590440", "time_retrieved": "2024-07-30T21:15:48.296796", "image_code": "#define PI 3.1415926535\n\n\n#define CONVERGENCE 0.001f\n// low values = higher time in black hole objects\n// next idea would be to more anylitcally do this\n#define DARK_ANTI_CONVERGENCE 0.05f\n// change this to lessen the effect, increasing produces less artifacts\n// 1 is where the pull/push of the black hole is equal to the ray\n#define VIEW_RAY_WEIGHT 4.0f\n#define ITERATIONS 120u\n// toggle between normal and reverse black holes\n// because of the anti convergence 0 is buggy, need to revisit\n#define PUSH 1\n#define GRID_SIZE 7.5\n// colors\nvec3 paloffset = vec3(16., 8., 16.3);\nvec3 palRep = vec3(8., 4., 6.);\n// anim\nvec3 mainSeq = vec3(0);\nvec3  darkSceneSeq = vec3(0);\n\nvoid setAnimations()\n{\n\tmainSeq.x = smoothstep(0., 4., mod(iTime, 40.)) - smoothstep(8., 12., mod(iTime, 40.));\n    mainSeq.y = smoothstep(0., 4., mod(iTime + 20., 40.)) - smoothstep(8., 12., mod(iTime + 20., 40.));\n    mainSeq.z = smoothstep(18., 20., mod(iTime, 40.)) - smoothstep(38., 40., mod(iTime, 40.));\n\n    darkSceneSeq.x = mod(iTime/16., 4.);\n  \tdarkSceneSeq.y = mod(iTime -2., 1.) * (mod(iTime, 16.) > 15. ? 1. : 0.);\n    darkSceneSeq.z = smoothstep(12., 13., mod(iTime - 2., 16.)) - smoothstep(15., 16., mod(iTime- 2., 16.));\n\n    paloffset += vec3(iTime) * 0.4;\n    palRep += vec3(0.5 + 0.5 *sin(iTime * PI * 0.01), 0.5 + 0.5 *cos(iTime * PI * 0.01), 0.5 + 0.5 *sin(iTime * PI * 0.01 + 40.));\n}\n\n// Camera code, shamelessly copied from https://www.shadertoy.com/view/4s3SRN\nvec3 cp[16];\nvoid setCamPath(){\n    const float sl = GRID_SIZE;\n    const float yBump = GRID_SIZE/2.;\n    cp[0] = vec3(0, yBump, sl);\n    cp[1] = vec3(0, yBump, 2. * sl);\n    cp[2] = vec3(sl, yBump, 2.* sl);\n    cp[3] = vec3(2.*sl, yBump,2.* sl);\n    cp[4] = vec3(2.*sl, yBump, sl);\t\n    cp[5] = vec3(2.*sl, yBump, 0);\t\n    cp[6] = vec3(sl, yBump, 0);\n    cp[7] = vec3(0, yBump, 0);\n    \n\tcp[8] = vec3(0, yBump, sl);\n    cp[9] = vec3(0, yBump, 2. * sl);\n    cp[10] = vec3(sl, yBump, 2.* sl);\n    cp[11] = vec3(2.*sl, yBump,2.* sl);\n    cp[12] = vec3(2.*sl, yBump, sl);\t\n    cp[13] = vec3(2.*sl, yBump, 0.);\t\n    cp[14] = vec3(sl, yBump, 0.);\n    cp[15] = vec3(0., yBump, 0.);\n    // for(int i =0; i < 16; i++)cp[i] += vec3(GRID_SIZE/2. + 2., 0., GRID_SIZE/2. + 2.);\n}\nvec3 Catmull(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n    return (((-p0 + p1*3. - p2*3. + p3)*t*t*t + (p0*2. - p1*5. + p2*4. - p3)*t*t + (-p0 + p2)*t + p1*2.)*.5);\n}\nvec3 camPath(float t){    \n    const int aNum = 16;    \n    t = fract(t/float(aNum))*float(aNum);\t// Repeat every 16 time units.\n    // Segment number. Range: [0, 15], in this case.\n    float segNum = floor(t);\n    // Segment portion. Analogous to how far we are alone the individual line segment. Range: [0, 1].\n    float segTime = t - segNum; \n    if (segNum == 0.) return Catmull(cp[aNum-1], cp[0], cp[1], cp[2], segTime);     \n    for(int i=1; i<aNum-2; i++){\n        if (segNum == float(i)) return Catmull(cp[i-1], cp[i], cp[i+1], cp[i+2], segTime); \n    }    \n    if (segNum == float(aNum-2)) return Catmull(cp[aNum-3], cp[aNum-2], cp[aNum-1], cp[0], segTime); \n    if (segNum == float(aNum-1)) return Catmull(cp[aNum-2], cp[aNum-1], cp[0], cp[1], segTime);\n    return vec3(0);\n}\n\n// Signed distance functions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// gradients\n// prefer exact gradients for cleaner effect\n// also good exercise to do this\n\nvec3 grdBox(vec3 p, vec3 b)\n{             \n    vec3 q = abs(p) - b;\n    float t = length(max(q, 0.));\n    \n    // asymptotic limit; cant use step since infintiy can win in 0 * (1/0)\n    float lambda = (t == 0. ? 0. : (1./t));\n \t\n    float dx = step(0., q.x) * q.x * sign(p.x) * lambda +\n        \t\tstep(q.x, 0.) * step(max(q.z, q.y), q.x) * sign(p.x);\n    float dy = step(0., q.y) * q.y * sign(p.y) * lambda +\n        \t\tstep(q.y, 0.) * step(max(q.x, q.z), q.y) * sign(p.y);\n    float dz = step(0., q.z) * q.z * sign(p.z) * lambda +\n        \t\tstep(q.z, 0.) * step(max(q.x, q.y), q.z) * sign(p.z);\n    \n    return vec3(\n    \tdx,\n        dy,\n        dz\n    );\n}\n\nvec3 grdTorus(vec3 p, vec2 t)\n{\n    float xzLength = length(p.xz);\n    \n    vec2 q = vec2(xzLength-t.x,p.y);\n    \n  \tfloat sdTorus = length(q)-t.y;\n    \n    float d = (1./sdTorus) * (xzLength-t.x) * (1./xzLength);\n    \n    return vec3(\n    \td * p.x,\n        (1./sdTorus) * p.y,\n        d * p.z\n    );\n}\n\nvec3 grdSphere(vec3 p)\n{\n    float b = length(p);\n    return vec3(\n    \t(p.x)/b,\n        (p.y)/b,\n        (p.z)/b\n    );\n}\n\nvec3 grdCappedCylinder( vec3 p, float h, float r )\n{\n    //  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    // return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n    float lengthXZ = length(p.xz);\n    vec2 d = abs(vec2(lengthXZ,p.y)) - vec2(h,r);  \n    \n    float outerDistance = length(max(d,0.0));\n    \n    // asymptotic limit; cant use step since infintiy can win in 0 * (1/0)\n    float lambda = (outerDistance == 0. ? 0. : (1./outerDistance));\n    \n    float zeta = lambda * d.x  * 1./lengthXZ;\n    \n    float dx = step(d.x, 0.) * step(d.y, d.x) * sign(lengthXZ) * 1./lengthXZ * p.x +\n               step(0., d.x) * zeta * p.x;\n                                \n    float dz = step(d.x, 0.) * step(d.y, d.x) * 1./lengthXZ * p.z +\n               step(0., d.x) * zeta * p.z; \n                                \n    float dy = step(d.y, 0.) * step(d.x, d.y) * sign(p.y) +\n               step(0., d.y) * (d.y * sign(p.y)) * lambda;\n    \n    return vec3(\n    \tdx,\n    \tdy,\n    \tdz \n    );  \n    \n}\n\nfloat distanceToDarkScene(vec3 p, out vec3 gradient)\n{    \n    float animation = 2. * mainSeq.x + 1.;\n    float c = GRID_SIZE;\n    vec3 q = mod(p +vec3(3.5,3.5,3.5) +0.5*c,c)-0.5*c;\n    \n    vec3 b = vec3(1., animation, 1.);\n   \n    float dstS = sdSphere(q, 1.);\n    vec3 grdS = grdSphere(q);\n\n    float dstB = sdBox(q, b);\n    vec3 grdB = grdBox(q, b);\n    \n    float dstC = sdCappedCylinder(q, 0.6, 2.);\n    vec3 grdC = grdCappedCylinder(q, 0.6, 2.);\n    \n    float dstT = sdTorus(q, vec2(1., 0.6));\n    vec3 grdT = grdTorus(q, vec2(1., 0.6));\n    \n    float dist;\n    if (darkSceneSeq.x <1.)\n    { \n        gradient = grdS;\n        dist = mix(dstS, dstB, darkSceneSeq.y);\n    }    \n    else if (darkSceneSeq.x < 2.)\n    {\n        gradient = grdB;\n        dist = mix(dstB, dstC, darkSceneSeq.y);\n    }\n    else if (darkSceneSeq.x < 3.)\n    {\n        gradient = grdC;\n        dist = mix(dstC, dstT, darkSceneSeq.y);\n    }\n    else\n    { \n        gradient = grdT;\n        dist = mix(dstT, dstS, darkSceneSeq.y);\n    }\n       \n    return max(dist, DARK_ANTI_CONVERGENCE);\n}\n\nfloat distanceToScene(vec3 p)\n{   \n    vec2 animation = vec2(6.5 *mainSeq.x + 1., mainSeq.x + 1. );\n\tfloat c = GRID_SIZE;\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n\n    float dstT = min(sdTorus(q, vec2(2.5, 0.5)), sdTorus(q, vec2(0.01, 1.5 + 0.5 *sin(iTime)))) ;\n    float dstC = sdCappedCylinder(q, 2., 1.);\n    float dstS = sdSphere(q, 1.);\n    float dstB1 = sdBox(q, vec3(animation.x, 1., 1.)); \n    float dstB2 = sdBox(q, vec3(1., 1., animation.x)); \n    \n    return mix(\n           mix(dstS, min(dstB1, dstB2), mainSeq.x),\n           mix(dstC, dstT, mainSeq.y),\n    mainSeq.z);\n      \n}\n\nvec3 distortRay (vec3 ray, float darkDist, vec3 gradient)\n{\n    float animation = (darkSceneSeq.z * 0.7) + 0.3;   \n    \n    float radiusShrinker = 1./(DARK_ANTI_CONVERGENCE * DARK_ANTI_CONVERGENCE);\n    \n    float inverseOfSquaresLaw =  1./(darkDist * darkDist * radiusShrinker);\n    \n    #if PUSH\n    \tvec3 g = gradient;\n    #else\n        vec3 g = -gradient;\n    #endif\n    \n    vec3 combined = normalize(VIEW_RAY_WEIGHT * ray * animation + (1.- animation) * g * inverseOfSquaresLaw );\n    return combined;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n  \n    setAnimations();\n    float speed = iTime*0.35 + 8.;\n    //speed = 0.;\n    \n    // Initiate the camera path spline points. Kind of wasteful not making this global, but I wanted\n    // it self contained... for better or worse. I'm not really sure what the GPU would prefer.\n    setCamPath();\n\t// Camera Setup.\n    vec3 ro = camPath(speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(speed + .5);  // \"Look At\" position.\n    vec3 lp = camPath(speed + .5) + vec3(0, .25, 0);     \n    float FOV = 1.57; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n    // Unit direction ray.\n    vec3 ray = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n\n    vec3 start = ro;\n    \n    vec3 p = start;\n   \t\n    bool backdropHit = false;\n    float travel = 0.;\n\n    uint last_i = 0u;\n    for (uint i = 0u; i < ITERATIONS; i++)\n    {\n        float sceneDist = distanceToScene(p);\n        \n        vec3 darkGradient;\n        float darkDist = distanceToDarkScene(p, darkGradient);\n        \n        if (sceneDist < CONVERGENCE){ last_i = i; break;}\n        \n\t\tfloat marchDist = min(sceneDist, darkDist);\n        \n        travel += marchDist;\n        \n        ray = distortRay(ray, darkDist, darkGradient);\n        p += ray * marchDist;\n        \n        if (i == ITERATIONS - 1u){ backdropHit = true; }\n    }\n    \n    float r = 0.5 + 0.5 * sin((p.x/palRep.x) - paloffset.x);\n    float g = 0.5 + 0.5 * sin((p.x/palRep.y) - paloffset.y);\n    float b = 0.5 + 0.5 * sin((p.x/palRep.z) - paloffset.z);\n   \n    \n    vec3 color = vec3(r, g, b) * min(20./travel, 1.);\n    \n    fragColor = vec4(color - float(last_i) / float(ITERATIONS), 1.0);\n    \n    if (backdropHit)\n    {\n        fragColor = vec4(0.,0. ,0., 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[672, 672, 694, 694, 1379], [1472, 1472, 1490, 1490, 2226], [2227, 2227, 2285, 2285, 2397], [2398, 2398, 2420, 2420, 3183], [3185, 3214, 3245, 3245, 3332], [3334, 3334, 3367, 3367, 3432], [3434, 3434, 3469, 3469, 3493], [3495, 3495, 3547, 3547, 3654], [3748, 3748, 3777, 3777, 4405], [4407, 4407, 4438, 4438, 4709], [4711, 4711, 4735, 4735, 4833], [4835, 4835, 4887, 5003, 5840], [5842, 5842, 5896, 5896, 6914], [6916, 6916, 6947, 6947, 7500], [7502, 7502, 7561, 7561, 8015], [8017, 8017, 8074, 8074, 9954]], "test": "untested"}
{"id": "tdXcW2", "name": "multiscale epidemia simulation", "author": "FabriceNeyret2", "description": "Play with parameters in #Common :\n- epidemia propagates locally at rate #Contag per step.\n- a proportion #Travel of people travel to the distant areas per step ( and might have a higher #ContagG )\n- Step: delay between time steps, to slow down simulation.", "tags": ["simulation", "epidemia"], "likes": 4, "viewed": 332, "published": 3, "date": "1585587746", "time_retrieved": "2024-07-30T21:15:49.050780", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if (iFrame==0) { \n        O-=O; \n        if (floor(U) == floor(R/2.) )  O.x = 1.; // initial infection : 1\n      //if ( hash(U) < Init ) O.x = 1.;          // initial infection : random people\n        return; }\n    \n    O = T(U);                                    // recover previous state\n    \n    if ( iFrame % Step > 0 ) return;             // 1 step delay at a time\n    if ( O.x > 0. ) { O.x *= .95; return; }      // already contaminated \n    float n = 0.;                                // local propagation with probability #Contag\n\n    for ( int k=0; k<9; k++ ) \n        if( T(U+vec2(k%3,k/3)-1.).x > 0. ) n++;\n    if ( hash(U+iTime) < n*Contag ) O.x = 1., O.z = .3;  // contaminated\n    \n    if ( ivec2(U)%Glob != ivec2(Glob)/2 ) return;\n    n = 0.;                                      // long distance propagation with probability #Contag\n    for ( int k=0; k<9; k++ ) \n        if( T(U+float(Glob)*(vec2(k%3,k/3)-1.)).x > 0. ) n++;\n    if ( hash(U+iTime) < n*ContagG ) O.x = 1., O.y = 1.; // contaminated\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Contag = .1,      // probability of local transmission per step\n           ContagG = .1,      // probability of transmission for long distance travelers\n              Init = .0004,   // initial infection\n            Travel = .0001;   // long distance travelers proportion\nconst int     Step = 7 ,      // time step\n              Glob = int(1./sqrt(Travel)); // long distance modeled as a coarse grid\n     \n#define R          iResolution.xy\n#define T(U)       texelFetch(iChannel0,ivec2(mod(U,R)),0)\n#define hash(p)  ( 1. - fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) )\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 54]], "test": "untested"}
{"id": "wsXyW2", "name": "Moebius Gears 2", "author": "dr2", "description": "Another impossible gear design", "tags": ["illusion", "escher", "gear", "moebius"], "likes": 23, "viewed": 476, "published": 3, "date": "1585583898", "time_retrieved": "2024-07-30T21:15:49.807756", "image_code": "// \"Moebius Gears 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm3 (vec3 p);\n\nvec3 ltDir, qHit;\nfloat dstFar, tCur;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat MobiusGDf (vec3 p, float r, vec2 b, float ns, float da, float dMin)\n{\n  vec3 q;\n  float d, a, t, rc;\n  rc = 0.02;\n  t = 0.15 * tCur + 0.5 * pi * da / ns;\n  p.yz = vec2 (- p.z, p.y);\n  q = vec3 (Rot2D (vec2 (length (p.xz) - r, p.y), 1.5 * atan (p.z, p.x)), 0.).xzy;\n  d = PrRoundBox2Df (q.xz, b, rc);\n  q = p;\n  q.xz = Rot2D (q.xz, t);\n  a = 2. * pi * (floor (ns * atan (q.z, - q.x) / (2. * pi)) + 0.5) / ns;\n  q.xz = Rot2D (q.xz, a);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 1.5 * (a + t));\n  q.x = abs (q.x) - b.y;\n  d = max (d, - PrRoundBox2Df (q.xz, vec2 (0.3 * b.y, 0.55 * pi * r / ns), rc));\n  DMINQ (1);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, mobRad;\n  dMin = dstFar;\n  mobRad = 2.5;\n  q = p;\n  q.x -= mobRad + 0.37;\n  dMin = MobiusGDf (q, mobRad, vec2 (0.2, 0.4), 64., 1., dMin);\n  q = p;\n  q.x += mobRad + 0.37;\n  q.x = - q.x;\n  dMin = min (dMin, MobiusGDf (q, mobRad, vec2 (0.2, 0.4), 64., -1., dMin));\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = 20. * dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk)) / bSize;\n  }\n  return qBlk;\n}\n\nfloat BgCol (vec3 ro, vec3 rd, float scl)\n{\n  vec2 q;\n  q = smoothstep (0.03, 0.1, abs (mod (16. * scl * BlkHit (ro, rd) + 0.5, 1.) - 0.5));\n  return 1. - min (q.x, q.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, vDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vDotL = max (dot (vn, ltDir), 0.);\n    vDotL *= vDotL;\n    col = vec3 (0.85, 0.85, 0.8) * (0.3 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.7 * vDotL * vDotL) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    col *= 0.8 + 0.2 * Fbm3 (128. * qHit);\n    col = mix (col, vec3 (1.) * BgCol (ro, reflect (rd, vn), 0.5), 0.015);\n  } else col = vec3 (0.1, 0.1, 0.2) * BgCol (ro, rd, 4.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi * sin (0.01 * pi * tCur);\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  dstFar = 50.;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -22.);\n  zmFac = 6.;\n  ltDir = vuMat * normalize (vec3 (0.2, 0.2, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[449, 449, 524, 524, 1074], [1076, 1076, 1098, 1098, 1408], [1410, 1410, 1443, 1443, 1620], [1622, 1622, 1643, 1643, 1891], [1893, 1893, 1925, 1925, 2416], [2418, 2418, 2461, 2461, 2590], [2592, 2592, 2627, 2627, 3196], [3213, 3213, 3269, 3269, 4288], [4290, 4290, 4337, 4337, 4384], [4386, 4386, 4408, 4408, 4446], [4448, 4448, 4470, 4470, 4508], [4510, 4510, 4540, 4540, 4653], [4655, 4655, 4691, 4691, 4897], [4931, 4931, 4955, 4955, 5074], [5076, 5076, 5101, 5101, 5326], [5328, 5328, 5349, 5349, 5504]], "test": "untested"}
{"id": "wdfyDj", "name": "Sierpinski Octahedron Tutorial", "author": "mla", "description": "Wireframe Octahedron, with start of the Sierpinski triangulation. Practice for the main exercise, which is doing this one dimension up. Written in 'tutorial' style to help me understand what is going on (and I hope others find this useful). Mouse rotates.", "tags": ["tutorial", "sierpinski", "octahedron"], "likes": 11, "viewed": 411, "published": 3, "date": "1585579410", "time_retrieved": "2024-07-30T21:15:50.737271", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Sierpinski Octahedron Tutorial\n//\n// Matthew Arcus, 2020.\n//\n// Draw a wire frame octahedron, with the first couple of layers of the\n// Sierpinski triangulation applied to the sides. In itself, this isn't\n// all that exciting, but it leads on nicely to the next step, which\n// is to move up a dimension.\n//\n// I've tried to make this something of a tutorial with more explanation\n// of what is going on than usual and I've used a lot of forward\n// declarations so the code can be read somewhat top down. I hope some\n// people find that useful. I haven't gone into much detail about\n// lighting etc. as we aren't doing anything very clever here and the\n// basic stuff is well covered elsewhere.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// First we must declare some global variables - we don't want to\n// overuse these, but they are useful for setting global configuration\n// etc. One useful purpose is for simple runtime checks - it's hard\n// knowing what is going on in a shader, so some way of reporting\n// conditions to the user is very handy.\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n//#define assert(x) // Uncomment this to remove assertions\n\n// Various configurables - their meaning will become clear later.\n//#define SPHERICAL // Uncomment to project to sphere\nvec3 light = vec3(0,2,1); // Position of light\nfloat eradius = 0.03; // Radius of an edge\nfloat pradius = 0.06; // Radius of a vertex sphere\nfloat eyedist = 2.5; // Eye is at (0,0,eyedist);\nfloat PI = 3.1415927; // A useful constant - don't need more figures than this\nint level = 2; // How many Sierpinski subdivisions <= 2 to do.\n\n// Raymarching configuration.\nint maxsteps = 50;\nfloat precis = 1e-2; \n\nbool dorotate = true;\n\nvec3 screencolor(vec2 z);\n\n// The main function called by Shadertoy.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  // mainImage just sets fragColor to the rgba value for the given\n  // screen coordinate. In fact, Shadertoy always sets the w or a\n  // coordinate of the colour to 1, so we will do most of our work\n  // with vec3 colours.\n\n  // It's useful for the shader to mainly work with \"normalized\"\n  // dimensions rather than actual pixel dimensions - a common\n  // convention is to normalize to [-1,1] vertically and [-a,a]\n  // horizontally, where a is the screen aspect ratio (so horizontal\n  // and vertical scales are the same). I tend to call this 'z' as we\n  // often want to treat it as a complex number, but some might prefer\n  // 'uv', or 'p'.\n\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n  // The maincolor function declared earlier actually does the work.\n  vec3 col = screencolor(z);\n\n  // Check nothing has gone wrong.\n  if (alert) col.r = 1.0;\n\n  // Set the final fragment colour.\n  fragColor = vec4(col,1);\n}\n\nvec3 raycolor(vec3 q, vec3 r);\nvec3 transformframe(vec3);\n\nvec3 screencolor(vec2 z) {\n  // z is a normalized screen coordinate, return the colour for that\n  // coordinate.\n\n  // We are doing a 3d scene, so we need to set things up with a\n  // camera and a \"projection screen\". There are various ways of doing\n  // this, for this shader where the main interest is around the\n  // origin, this simple setup will do - imagine a device with a \n  // rectangular grid as in Albrecht Dürer's woodcut:\n  // https://www.metmuseum.org/art/collection/search/366555 - the grid\n  // is at a fixed position from the eye, and the whole device can be\n  // moved around as a unit to view the scene from different\n  // positions (for example, by rotating under mouse control).\n\n  // The initial location of the virtual eye or camera.\n  vec3 eye = vec3(0,0,eyedist);\n\n  // The direction of a ray from the eye to a point on the virtual\n  // screen - the screen goes from -1 to +1 vertically, so we have a\n  // vertical viewing angle of 2*atan(0.5) = 53 degrees.\n    vec3 ray = vec3(z,-2);\n\n  // Now we follow that ray into the scene and see what generates the\n  // light that comes down that ray in the opposite direction.\n\n  // First, apply a transformation to both eye and ray to allow viewing the\n  // scene from different directions. Also transform the light, so the\n  // effect will be that we are rotating the scene before us.\n  eye = transformframe(eye);\n  ray = transformframe(ray);\n  light = transformframe(light);\n  \n  // Calculations are easier if the ray has unit length. Do this after\n  // rotating as sin and cos can introduce small inaccuracies.\n  ray = normalize(ray);\n\n  // Now raycolor will follow the ray from eye and return the colour\n  // to display for that ray.\n  vec3 col = raycolor(eye,ray);\n  col = pow(col,vec3(0.4545)); // Gamma correction - see elsewhere\n  return col;\n}\n\nfloat getdistance(vec3 q, vec3 r, out int type);\nvec3 getnormal(vec3 p);\n\nvec3 getbasecolor(int type) {\n  assert(type >= 0);\n  if (type == 0) return vec3(0.75,1,0.75);\n  if (type == 1) return vec3(0.2);\n  return vec3(1,0,1);\n}\n\nvec3 getbackground(vec3 r) {\n  //return r; // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  // The scene is represented by a surface, We follow the ray and find\n  // if it intersects the surface - if so, apply some simple lighting\n  // to the colour at the intersection point. 'type' is set to an\n  // integer indicating what has been hit.\n  int type = -1;\n  float t = getdistance(q,r,type);\n\n  // getdistance returns -ve for no intersection, so return background\n  // colour for that direction.\n  if (t < 0.0) return getbackground(r);\n\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n\n  // and the normal at that point.\n  vec3 normal = getnormal(p);\n\n  // Apply lighting. This is a basic \"Lambertian\" model.\n  vec3 lightdir = normalize(light-p);\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  return color;\n}\n\n// We have got to raymarching at last. Much has been written\n// elsewhere on how this works, which I won't repeat here, the general\n// idea is that de(p) gives an estimate of the minimum distance to\n// the surface, so we can safely move that far along the ray without\n// hitting the surface, and then repeat the procedure. Our scene is\n// just spheres and cylinders, with nothing fancy going on so\n// something very simple will do here.\n\n// Note that the DE function also returns the type of object hit\n// (basically, what colour it should be) - for a complex DE function\n// it might be more efficient to have separate functions, one that\n// just returns the distance, and one that just returns the type that\n// can be called separately at the end to determine the colour (we\n// could write it as a single function though, used in two places and\n// rely on the code optimizer to inline and remove any useless\n// calculations from each use).\n\nfloat de(vec3 p, out int type); // The distance estimator\n\nfloat getdistance(vec3 q, vec3 r, out int type) {\n  // Octahedron is mostly radius <= 1 and eyedist is distance of eye from\n  // origin, so this should cover the entire scene.\n  float maxdist = eyedist + 2.0;\n  float t = 0.0;\n  for (int i = 0; i < maxsteps; i++) {\n    //assert(i < 20); // Assertions are useful for seeing what's going on.\n    vec3 p = q+t*r;\n    float d = de(p,type);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r);\nfloat dist(vec3 p, vec3 q);\n\n// The de function for our octahedron. The octahedron, with vertices\n// at (1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1) has mirror\n// symmetries in the 3 planes, x=0, y=0, z=0, so de(p) = de(abs(p))\n// and setting p = abs(p) in fact maps all faces of the octahedron to\n// the one at (1,0,0),(0,1,0),(0,0,1) (or, maps p to p' where the\n// distance from p to the octahedron is the same as the distance from\n// p' to that single face).\n//\n// Additionally, there are symmetries in the diagonal planes x=y,\n// etc. so de(p) = de(p.yxz), ie. we can swap any pairs of\n// coordinates, so we can map p -> p1 with p1.x >= p1.y >= p1.z and\n// the effect of this is to map the entire triangular face into a\n// small right angled triangle at (0,0,0),(1,0,0) and 0.5*(1,1,0),\n// (the 'fundamental region' for the set of symmetries).\n//\n// Note that points on the face all have coordinates (a,b,c) with\n// a+b+c = 1 and 0 <= a,b,c <= 1. (In fact, the actual coordinates of\n// the points in the face are the same as their barycentric or\n// trilinear coordinates, making calculations very easy).\n\n// So, to actually draw something: we have a triangle ABC, though we\n// are mainly working in a small sector around A. From the triangle\n// ABC, the only vertex in the sector is A, the only line is AB, so if\n// we draw just these, we see a complete octahedron, the rest is\n// filled in by our mirror symmetries.\n\n// For the Sierpinski construction, we want to draw the inner\n// triangle, which goes between the midpoints of the sides. Again,\n// because we are working in a small sector around A, we just need to\n// draw the midpoint of AB and part of the line from there to the\n// midpoint of BC, or, as in the code, set A1,B1,C1 to be the vertices\n// of the new \"corner triangle\" around A, so A1 = A, B1 = midpoint of\n// AB, C1 = midpoint of AC, and then we just need to draw point B1 and\n// the line from B1 to C1.\n//\n// Finally, we want to draw the centre triangle of that smaller corner\n// triangle, so find the midpoints of its sides (AB1 etc.) and draw\n// lines between them - again, we just need points AB1 and BC1 and\n// the lines from AB1 to CA1 and from AB1 to BC1. It's easy to see\n// what is needed by commenting out the 'p = abs(p)' line so just one\n// triangular face is displayed (and drawing a picture on a piece of\n// paper always helps).\n\nfloat de(vec3 p, out int type) {\n  p = abs(p); // Map to single face - skip this to see single face.\n  // Sort the coordinates to map to fundamental region.\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.y < p.z) p.yz = p.zy;\n  if (p.x < p.y) p.xy = p.yx;\n  // Check we are sorted.\n  assert(p.x >= p.y);\n  assert(p.y >= p.z);\n  // 3 corners of the original triangle.\n  vec3 A = vec3(1,0,0);\n  vec3 B = vec3(0,1,0);\n  vec3 C = vec3(0,0,1);\n  // The 3 corners of the smaller corner triangle.\n  vec3 A1 = A;\n  vec3 B1 = 0.5*(A+B);\n  vec3 C1 = 0.5*(A+C);\n  // Midpoints of the sides of the smaller triangle.\n  vec3 AB1 = 0.5*(A1+B1);\n  vec3 BC1 = 0.5*(B1+C1);\n  vec3 CA1 = 0.5*(C1+A1);\n\n  // Some points are outside our fundamental region, but\n  // the line segments are going in the right direction.\n  float d = 1e8, d0 = d;\n  for(;;) {\n    d = min(d,segment(p,A,B)-eradius);\n    if (level == 0) break;\n    d = min(d,segment(p,B1,C1)-eradius);\n    if (level == 1) break;\n    d = min(d,segment(p,AB1,CA1)-eradius);\n    d = min(d,segment(p,AB1,BC1)-eradius);\n    break;\n  }\n  if (d < d0) type = 0; d0 = d;\n\n  for(;;) {\n    d = min(d,dist(p,A)-pradius);\n    if (level == 0) break;\n    d = min(d,dist(p,B1)-pradius);\n    if (level == 1) break;\n    d = min(d,dist(p,AB1)-pradius);\n    d = min(d,dist(p,BC1)-pradius);\n    break;\n  }\n  if (d < d0) type = 1; d0 = d;\n\n  return d;\n}\n\n// We need to define just how to measure distances to the scene.\n#if defined SPHERICAL\n// Project the scene points (ie. q and r here) onto the unit sphere\n// before measuring distances.\nfloat dist(vec3 p, vec3 q) {\n  return distance(p,normalize(q));\n}\n\n// For segment, also project p onto sphere, then find the closest\n// point to the segment on the sphere, and take the Euclidean distance\n// to that point.\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  vec3 p1 = normalize(p);\n  q = normalize(q);\n  r = normalize(r);\n  // Map p to the plane defined by q and r:\n  // p = aq + br + x, where q.x = r.x = 0 so:\n  // p.q = aq.q + br.q and:\n  // p.r = aq.r + br.r\n  // Solve by inverting a 2x2 matrix.\n  mat2 m = inverse(mat2(dot(q,q),dot(q,r),dot(q,r),dot(r,r)));\n  vec2 ab = m*vec2(dot(p1,q),dot(p1,r));\n  ab = max(ab,0.0);\n  // p1 is in plane of q,r, on hypersphere\n  p1 = normalize(ab[0]*q + ab[1]*r);\n  // And return the distance to the closest point.\n  return distance(p,p1);\n}\n#else\n// The usual Euclidean distances:\nfloat dist(vec3 p, vec3 q) {\n  return distance(p,q);\n}\n\n// Find the distance from p to the segment between q and r.\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  // Rebase to origin at q  \n  p -= q; r -= q;\n  // t*r is orthogonal projection of p onto qr.\n  float t = clamp(dot(p,r)/dot(r,r), 0.0, 1.0);\n  return distance(p,t*r);\n}\n#endif\n\n// Finish off with some fairly standard utility functions.\n\n// Get the normal of the surface at point p.\nfloat de(vec3 p) { int type; return de(p,type); }\nvec3 getnormal(vec3 p) {\n  float eps = 0.001;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,-iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1199, 1199, 1220, 1220, 1246], [1882, 1924, 1975, 2621, 2906], [2967, 2967, 2993, 3724, 4788], [4864, 4864, 4893, 4893, 5016], [5018, 5018, 5046, 5077, 5129], [5131, 5131, 5162, 5412, 5999], [7002, 7002, 7051, 7177, 7515], [9928, 9928, 9960, 9960, 11289], [12701, 12746, 12764, 12764, 12795], [12796, 12796, 12820, 12820, 13034], [13036, 13067, 13097, 13097, 13142], [13144, 13182, 13211, 13211, 13604]], "test": "untested"}
{"id": "3dXyWj", "name": "Simplex Noise Rotation", "author": "nickcody", "description": "Simplex noise applied to two rotating layers", "tags": ["glsl", "simplexnoise"], "likes": 8, "viewed": 710, "published": 3, "date": "1585572514", "time_retrieved": "2024-07-30T21:15:51.583009", "image_code": "const float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\n// Change these parameters for different effects\n//\nfloat u_rotated_scale = 0.006;\nfloat u_primary_scale = 0.003;\nfloat u_rot_left_divisor = -109.0;\nfloat u_rot_right_divisor = 49.0;\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// simpled by guowei\n// https://github.com/guoweish/glsl-noise-simplex\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(\n        0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n        -0.577350269189626,  // -1.0 + 2.0 * C.x\n        0.024390243902439\n    ); // 1.0 / 41.0\n\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nvec2 rotateOrigin(vec2 v, vec2 center, float a) {\n    vec2 t = v - center;\n    vec2 r = rotate(t, a);\n    return r + center;\n}\n\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n\n    vec2 rotated_resolution = vec2(1024) * u_rotated_scale;\n    vec2 primary_resolution = vec2(1024) * u_primary_scale;\n\n    vec2 rotated_fragCoord = gl_FragCoord.xy * u_rotated_scale;\n    vec2 primary_fragCoord = gl_FragCoord.xy * u_primary_scale;\n\n    vec2 rotated_center = rotated_resolution.xy/2.0;\n    vec2 primary_center = primary_resolution.xy/2.0;\n\n    vec2 coord0 = primary_fragCoord+primary_center;\n    vec2 coord1 = rotateOrigin(rotated_fragCoord, rotated_center, iTime/u_rot_left_divisor);\n    vec2 coord2 = rotateOrigin(rotated_fragCoord, rotated_center, iTime/u_rot_right_divisor);\n\n    float n0 = snoise(coord0);\n    float n1 = snoise(coord1);\n    float n2 = snoise(coord2);\n    float c = (n1 + n2)/2.0;\n\n    float n = snoise(coord0 * c);\n\n    float r = n;\n    float g = n;\n    float b = n;\n    vec3 color = vec3(r, g, b);\n    vec3 final_color = color;\n\n    out_color = vec4(final_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[760, 760, 781, 781, 832], [834, 834, 855, 855, 906], [908, 908, 930, 930, 969], [971, 971, 993, 993, 2555], [2557, 2557, 2587, 2587, 2683], [2685, 2685, 2734, 2734, 2811], [2814, 2814, 2866, 2866, 3854]], "test": "untested"}
{"id": "3dscWS", "name": "AR Marker Animation", "author": "Onnowhere", "description": "A little AR marker indicator animation. Use your mouse to drag the object.", "tags": ["animation", "marker"], "likes": 2, "viewed": 377, "published": 3, "date": "1585568291", "time_retrieved": "2024-07-30T21:15:52.410796", "image_code": "// The MIT License\n// Copyright © 2020 Onnowhere\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n// Functions sourced from Inigo Quilez\n// Source: https://www.shadertoy.com/view/Xds3zN\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n//------------------------------------------------------------------\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1, d2);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    float offset = iTime/20.0;\n    float count = 8.0;\n    float height = 0.4;\n    float spacing = height/count;\n    vec3 box_size = vec3(0.25, 0.0, 0.25);\n    float roundness = 0.005;\n    float cutout_size = 0.225;\n    float accel = 10.0;\n    \n    float d = 1000.0;\n    float dbox;\n    for (float i = 0.0; i < count; i++) {\n        float up = mod(offset+spacing*i, height);\n        dbox = sdRoundBox(pos-vec3(0.0,up*up*up*up*accel,0.0), box_size, roundness);\n        d = opU(d, dbox);\n    }\n    float dx = sdBox(pos-vec3(0.0,0.0,0.0), vec3(cutout_size, 10.0, cutout_size));\n    float dx_top = sdRoundBox(pos-vec3(0.0,height,0.0), vec3(0.25, 0.1, 0.25), 0.05);\n    //float dx_bottom = sdRoundBox(pos-vec3(0.0,0.0,0.0), vec3(0.25, -0.1, 0.25), 0.05);\n    \n    float d_sphere = sdSphere(pos-vec3(0.0,(cos(iTime)/5.0+1.0)*(height-0.1),0.0), 0.09);\n    \n    d = opSmoothSubtraction(dx, d, 0.01);\n    d = opSmoothSubtraction(dx_top, d, 0.175);\n    //d = opSmoothSubtraction(dx_bottom, d, 0.1);\n    \n    d = opU(d_sphere, d);\n    \n    vec2 res = vec2(d, 3.0);\n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.2 + 0.18*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        //col = vec3(0.2);\n        col = 0.2 + 0.18*sin( m*2.0 + vec3(0.0,0.5,1.0) );\n        col = vec3(0.1,0.35,0.4);\n        col *= 1.5;\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n\t\tlig = normalize( vec3(0.0, -1.0, 0.0) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        amb *= 3.0;\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        dom *= 15.0;\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        fre *= 35.0;\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n        lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 7.00*spe*vec3(1.10,0.90,0.70);\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 1.5*cos(0.1*time + 6.0*mo.x), 0.25 + 2.0*(1.0-mo.y), 1.5*sin(0.1*time + 6.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        float _Zoom = 2.5;\n        float _FOV = 70.0;\n        float degToRad = 3.141592653589793238462643383279/180.0;\n        vec3 rd = ca * normalize( vec3(p*tan(degToRad * (_FOV / 2.0)),_Zoom) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        \n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dscWS.jpg", "access": "api", "license": "mit", "functions": [[1339, 1339, 1374, 1374, 1400], [1402, 1402, 1433, 1433, 1524], [1526, 1526, 1571, 1571, 1662], [1735, 1735, 1787, 1787, 1886], [1888, 1888, 1946, 1946, 2046], [2048, 2048, 2107, 2107, 2206], [2208, 2208, 2238, 2238, 2271], [2273, 2273, 2306, 2306, 2329], [2501, 2501, 2526, 2526, 3597], [3599, 3647, 3698, 3698, 3903], [3932, 3932, 3972, 3972, 4570], [4573, 4618, 4696, 4719, 5110], [5112, 5158, 5190, 5190, 5721], [5723, 5723, 5765, 5765, 6081], [6083, 6083, 6122, 6122, 7935], [7937, 7937, 7989, 7989, 8166]], "test": "ok"}
{"id": "3sXyD2", "name": "Day 102 - version 2", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics"], "likes": 18, "viewed": 408, "published": 3, "date": "1585560436", "time_retrieved": "2024-07-30T21:15:53.246562", "image_code": "// Fork of \"Day 102\" by jeyko. https://shadertoy.com/view/3dfcW2\n// 2020-03-30 09:07:28\n\n// Fork of \"Day 101\" by jeyko. https://shadertoy.com/view/WslyWS\n// 2020-03-30 07:59:19\n\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.0;\n    float chromAb = pow(length(uv - 0.5),1.5)*2.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    \n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat xch(float d, float b){\n\treturn b < 0. ? 1.2 - d : d;\n}\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n\treturn max(p.x, p.y);\n}\n\n\nconst float speed = 0.6;\nfloat[] scenes = float[3](1.*speed,1.5*speed, 1.21*speed); \n\nfloat S = 0.3;\nvec3 get( vec2 fragCoord  )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n    uv *= 2.;\n    float col = 0.;\n    \n    float d = 10e6;\n    \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n    \n    float pl;\n    \n    float t = iTime;\n    \n    //t += scenes[0];\n    //t += scenes[1] - 0.1;\n    t += scenes[2] - 0.1;\n    \n    uv *= rot(pi*0.25);\n    t = mod(t, scenes[0] + scenes[1]   );\n    \n    float offsamt = 0.5;\n    float offs = -S*offsamt;\n    float offsB = S*(1. - offsamt);\n    \n    if(t < scenes[0]){\n        float env = ease(t/scenes[0], 2.);\n        \n        float mov = env * offs;\n        bA = sdBox(uv - vec2(0.+S + mov,S + mov), vec2(S*1.));\n        bB = sdBox(uv + vec2(0.+S + mov,S + mov), vec2(S*1.));\n        bC = sdBox(uv - vec2(0.-S - mov,S + mov), vec2(S*1.));\n        bD = sdBox(uv + vec2(0.-S - mov,S + mov), vec2(S));\n        bE = sdBox(uv, vec2(-offs*(0. + env*1.)));\n        col = xch(col,bA);\n        col = xch(col,bB);\n        col = xch(col,bC);\n        col = xch(col,bD);\n        col = xch(col,bE);\n    \n    } else if(t < scenes[1] + scenes[0]){\n        t -= scenes[0];\n        float env = ease(t/scenes[1], 4.);\n        \n        float mov = -env * offs*8.;\n        float movb = -env * offs*1.;\n        float offsS = 0.*-offs;\n        \n        \n        bA = sdBox(uv - vec2(0.+S + offsS + mov,S+ offsS + mov), vec2(offsB));\n        bB = sdBox(uv + vec2(0.+S + offsS + mov,S+ offsS + mov), vec2(offsB));\n        bC = sdBox(uv - vec2(0.-S - offsS - mov,S+ offsS + mov), vec2(offsB));\n        bD = sdBox(uv + vec2(0.-S - offsS - mov,S+ offsS + mov), vec2(offsB));\n        \n        uv *= rot(0.5*pi*env);\n        bE = sdBox(uv, vec2(-offs + movb*3.));\n        col = xch(col,bA);\n        col = xch(col,bB);\n        col = xch(col,bC);\n        col = xch(col,bD);\n        col = xch(col,bE);\n        \n    }  else if(t < scenes[1] + scenes[0] + scenes[2]){\n        t -= scenes[0] + scenes[1];\n        float env = ease(t/scenes[2], 4.);\n        \n        float mov = env * offs*2.;\n        uv *= rot(0.5*pi*env);\n        bA = sdBox(uv, vec2(offsB*2. - mov));\n        col = xch(col,bA);\n        \n            \n    } \n    \n    \n    \n    //col += smoothstep(0.00,3./iResolution.y,-d);\n    \n    return vec3(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    float aa = 6.;\n    \n    for(float i =0.; i < aa*aa   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    \n    col = max(col, 0.);\n\tcol = pow(col, vec3(0.4545));\n    \n    col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 270, 270, 1187]], "test": "untested"}
{"id": "WdXyD2", "name": "Universal with white", "author": "gjy_1992", "description": "universal transition effect with a white gap", "tags": ["2d", "transition"], "likes": 5, "viewed": 337, "published": 3, "date": "1585559684", "time_retrieved": "2024-07-30T21:15:54.090306", "image_code": "vec4 rule(vec2 coord)\n{\n    vec2 uv2 = coord-vec2(0.5,0.5);\n    float angle = atan(uv2.y, uv2.x);\n    float c = angle/2.0/3.1416+0.5;\n    return vec4(c,c,c,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 src = texture(iChannel0, uv);\n    vec4 dst = texture(iChannel1, uv);\n    vec4 white = vec4(1.0);\n    float rule = rule(uv).g;\n    float progress = mod(iTime,10.0)/10.0;\n    //control the mix range\n    float vague=0.1;\n    //control how much percent the white part occupies\n    float delay=1.0;\n    float phase=progress*(1.0+vague+delay);\n\tfloat p0=smoothstep(rule, rule+vague, phase);\n    //float p1=smoothstep(rule+delay, rule+vague+delay, phase);\n    float p1=smoothstep(rule+delay, rule+vague+delay, phase);\n    //if(p0<1.0)\n\t//    fragColor=mix(src, white, p0);\n    //else\n    //    fragColor=mix(white, dst, p1);\n    fragColor=src*(1.0-p0)+white*(p0-p1)+dst*p1;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 161], [163, 163, 220, 270, 985]], "test": "untested"}
{"id": "3dfcW2", "name": "Day 102", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics"], "likes": 15, "viewed": 400, "published": 3, "date": "1585557829", "time_retrieved": "2024-07-30T21:15:54.948012", "image_code": "// Fork of \"Day 101\" by jeyko. https://shadertoy.com/view/WslyWS\n// 2020-03-30 07:59:19\n\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.0;\n    float chromAb = pow(length(uv - 0.5),1.5)*2.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor = 1. - fragColor;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat xch(float d, float b){\n\treturn b < 0. ? 1.5 - d : d;\n}\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n\treturn max(p.x, p.y);\n}\n\n\nconst float speed = 0.65;\nfloat[] scenes = float[3](0.6*speed,1.*speed, 1.11*speed); \n\nfloat S = 0.3;\nvec3 get( vec2 fragCoord  )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n    uv *= 2.;\n    float col = 0.;\n    \n    float d = 10e6;\n    \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n    \n    float pl;\n    \n    float t = iTime;\n    \n    //t += scenes[0];\n    t += scenes[1] - 0.1;\n    //t += scenes[2] - 0.1;\n    \n    uv *= rot(pi*0.25);\n    t = mod(t, scenes[0] + scenes[1] + scenes[2]  );\n    \n    float offsamt = 0.5;\n    float offs = -S*offsamt;\n    float offsB = S*(1. - offsamt);\n    \n    if(t < scenes[0]){\n        //float env = ease(t/scenes[0], 2.);\n        float env = ease(t/scenes[0], 1., 1.14, 0.96, 10.);\n        \n        float mov = env * offs;\n        bA = sdBox(uv - vec2(0.+S + mov,S + mov), vec2(S*1.));\n        bB = sdBox(uv + vec2(0.+S + mov,S + mov), vec2(S*1.));\n        bC = sdBox(uv - vec2(0.-S - mov,S + mov), vec2(S*1.));\n        bD = sdBox(uv + vec2(0.-S - mov,S + mov), vec2(S));\n        bE = sdBox(uv, vec2(-offs*(0. + env*1.)));\n        col = xch(col,bA);\n        col = xch(col,bB);\n        col = xch(col,bC);\n        col = xch(col,bD);\n        col = xch(col,bE);\n    \n    } else if(t < scenes[1] + scenes[0]){\n        t -= scenes[0];\n        float env = ease(t/scenes[1], 4.);\n        \n        float mov = env * offs*1.;\n        float offsS = 0.*-offs;\n        bA = sdBox(uv - vec2(0.+S + offsS + mov,S+ offsS + mov), vec2(offsB));\n        bB = sdBox(uv + vec2(0.+S + offsS + mov,S+ offsS + mov), vec2(offsB));\n        bC = sdBox(uv - vec2(0.-S - offsS - mov,S+ offsS + mov), vec2(offsB));\n        bD = sdBox(uv + vec2(0.-S - offsS - mov,S+ offsS + mov), vec2(offsB));\n        bE = sdBox(uv, vec2(-offs + mov));\n        col = xch(col,bA);\n        col = xch(col,bB);\n        col = xch(col,bC);\n        col = xch(col,bD);\n        col = xch(col,bE);\n        \n    }  else if(t < scenes[1] + scenes[0] + scenes[2]){\n        t -= scenes[0] + scenes[1];\n        float env = ease(t/scenes[2]*1.25, 4.);\n        \n        float mov = env * offs*2.;\n        uv *= rot(0.5*pi*env);\n        bA = sdBox(uv, vec2(offsB*2. - mov));\n        col = xch(col,bA);\n        \n            \n    } \n    \n    \n    \n    //col += smoothstep(0.00,3./iResolution.y,-d);\n    \n    return vec3(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    float aa = 5.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    col = max(col, 0.);\n    \n    col = clamp(col, 0., 1.);\n    col *= 0.996;\n    col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 181, 181, 1127]], "test": "untested"}
{"id": "WsXcW2", "name": "maze_solver_0", "author": "balkhan", "description": "Stolen this from here : \nhttps://www.youtube.com/watch?v=GULy4vtkw6w\nhttps://gist.github.com/Chlumsky/44d0dbecd6f263ddc8636e99fe267934\nmaze stolen from here : \nhttps://www.shadertoy.com/view/4scGWf", "tags": ["maze", "stolen", "mazesolving"], "likes": 4, "viewed": 361, "published": 3, "date": "1585556416", "time_retrieved": "2024-07-30T21:15:55.697010", "image_code": "\n/*\nBuffer A contain maze solving\nBuffer B contain the maze\nBuffer image visualize it\noriginal code credited in shader description\n*/\n\n//#define _3D // ugly mapping on a torus\n\nvec4 visualize(vec2 pos);\nvec2 q;\n\nfloat map(vec3 p)\n{\n    q = vec2(length(p.xy)-3., p.z);\n    float ataxy = atan(p.x, p.y)/6.28+.5;\n    float ataqxy = atan(q.x, q.y)/6.28+.5;\n    vec2 tcdtorus = vec2(\n        ataqxy\n        ,\n        ataxy\n        );\n    vec4 textorus = texture(iChannel1, tcdtorus).xyzw;\n    \n    float lq = length(q)-2.7;\n    \n    if( lq < 0.051)\n    {\n//        lq += step(textorus.z, .5)*.125;\n    }\n    \n    return (lq)*1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = f/R;\n    vec2 u = (f - R*.5)/R;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec4 bgd = texture(iChannel1, uv);\n    vec3 vcol = visualize(uv).xyz;\n    col = col;//vec3(max(col.x, col.y));\n    col = max(col, 1.-bgd.xyz*1.);\n    col = (vcol.z > .0 ? vcol : col);\n\n    #ifdef _3D\n    vec3 ro = vec3(.0,.0, -25.);\n    vec3 rd = normalize(vec3(u, 2.));\n    vec3 p;\n    vec2 d;\n    float hit = .0;\n    float t = iTime*.25+1.57;\n    float tt = 1.57*.0;//t*.5 -1.57*.0;\n    float ttt = -3.;\n//    rd.yz = vec2(cos(ttt)*rd.y+sin(ttt)*rd.z, cos(ttt)*rd.z-sin(ttt)*rd.y);\n    for(float a = .0; a < 200.; a++)\n    {\n        p = ro + rd * d.y;\n        p.xz = vec2(cos(t)*p.x+sin(t)*p.z, cos(t)*p.z-sin(t)*p.x);\n//        p.yz = vec2(cos(tt)*p.y+sin(tt)*p.z, cos(tt)*p.z-sin(tt)*p.y);\n        d.x = map(p);\n        d.y += d.x;\n        if (d.x < 0.001)\n        {\n            hit = 1.;\n            break;\n        }\n    }\n    col = hit*vec3(1.)*1.;\n    float ataxy = atan(p.x, p.y)/6.28+.5;\n    if (isinf(ataxy) || isnan(ataxy))\n        ataxy = 0.;\n    float ataqxy = atan(q.x, q.y)/6.28+.5;\n    if (isinf(ataqxy) || isnan(ataqxy))\n        ataqxy = 0.;\n    vec2 tcdtorus = vec2(\n        ataqxy\n        ,\n        ataxy\n        );\n    vec3 textorus = texture(iChannel0, tcdtorus).xyz;\n    vec4 bgdt = texture(iChannel1, tcdtorus);\n    vec3 vcolt = visualize(tcdtorus).xyz;\n    textorus = max(textorus, 1.-bgdt.xyz*1.);\n    textorus = (vcolt.z > .0 ? vcolt : textorus);\n    col *= textorus.xyz;\n    #endif\n    fragColor = vec4(col*1.,1.0);\n}\n\nfloat tolerance = 0.0001;\nfloat smoothness = 0.00001;\nvec4 pathColor = vec4(.0, .0, 1.0, 1.0);\n\nvec4 visualize(vec2 pos) {\n    vec4 background = texture(iChannel1, pos);\n    vec4 solution = texture(iChannel0, pos);\n    float pathOpacity = 0.0;\n    if (solution.b > 0.0) \n    {\n        // Evaluate difference from shortest path length\n        float pathDistance = solution.b - 1.0*solution.r*solution.g;\n        pathOpacity = step(pathDistance, .000101);///pathDistance;//smoothstep(tolerance+smoothness, tolerance-smoothness, pathDistance);\n    }\n    return pathOpacity*pathColor;//mix(background, pathColor, pathOpacity);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define TAU 6.283185307\n#define DIRECTIONS 4.\n\nvec4 solver(sampler2D self, vec2 pos, float timeDelta) {\n    vec4 local = texture(self, pos);\n    // Update shortest path length\n    local.z = max(local.z, local.x*local.y);\n    // Evaluate neighboring maxima\n    vec4 neighborMax = vec4(0.0);\n    for (float i = 0.; i < DIRECTIONS; ++i)\n    {\n        float a = TAU*(i)/(DIRECTIONS);\n        vec2 neighborPos = pos + (1./iResolution.xy)*vec2(sin(a), cos(a));\n        vec4 neighbor = texture(self, neighborPos);\n        neighbor.rgb *= neighbor.a;\n        neighborMax = max(neighborMax, neighbor);\n    }\n    // Attenuate wave\n    neighborMax.rg *= 4095.0/4096.0;\n    // Update local values\n    local.rgb = max(local.rgb, neighborMax.rgb*local.a);\n    return local;\n}\n\nvec4 initialState(vec2 pos) {\n    vec4 inputt = texture(iChannel1, pos);\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    // Detect starting point\n    if (inputt.g > 0.5 && inputt.r + inputt.b < 1.0)\n        color.g = 1.0;\n    // Detect end point\n    if (inputt.r > 0.5 && inputt.g + inputt.b < 1.0)\n        color.r = 1.0;\n    // Detect boundary\n    if (inputt.r < 0.5 && inputt.g < 0.5 && inputt.b < 0.5)\n        color.a = 0.0;\n    return color;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    if (iFrame < 10)\n//    o = texture(iChannel1, f/iResolution.xy);\n    o = initialState(f/iResolution.xy);\n    else\n    o = solver(iChannel0, f/iResolution.xy, iTimeDelta);\n    o = clamp(o, 0., 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 O,  vec2 U )\n{\n    vec2 u = (U - iResolution.xy*.5)/iResolution.xy;\n    vec2 v = (U )/iResolution.xy;\n    float maze = .251/ fract(.001+   sin(1e6*length (ceil(U/=9.))) < 0.  ? U.x : U.y );\n    O = vec4(0.);\n    O.xyz += maze;\n\n    O.y += step(length(v-vec2(.23*.0+7.5/9., -.35*.0+1.*(1./9.))), .0051)*1.;\n    O.x += step(length(v-vec2(.25, .33)), .0051)*1.;\n//    O=1.-O;\n//    O.y += step(length(u-vec2(.2485, -.230)), .00251)*1.;\n//    O.x += step(length(u-vec2(.21, .24)), .0051)*1.;\n    O.w = 1.;\n//        O.w -= step(.5, maze);\n}\n", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 231, 231, 625], [627, 627, 676, 676, 2244], [2342, 2342, 2368, 2368, 2870]], "test": "untested"}
{"id": "3sfyW2", "name": "Moebius Gears", "author": "dr2", "description": "Escher in motion - impossible?", "tags": ["escher", "wheel", "gear", "impossible", "kinematics"], "likes": 26, "viewed": 419, "published": 3, "date": "1585554800", "time_retrieved": "2024-07-30T21:15:56.461964", "image_code": "// \"Moebius Gears\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm3 (vec3 p);\n\nmat3 vuMat;\nvec3 ltDir, qHit;\nfloat dstFar, tCur;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat MobiusTDf (vec3 p, float r, float b, float ns, float da, float dMin)\n{\n  vec3 q;\n  float d, a, t;\n  p.xy = vec2 (- p.y, p.x);\n  q = vec3 (Rot2D (vec2 (length (p.xz) - r, p.y), 0.5 * atan (p.z, p.x)), 0.).xzy;\n  d = PrRoundBox2Df (q.xz, vec2 (b), 0.05);\n  DMINQ (1);\n  t = 0.15 * tCur + 0.5 * pi * da / ns;\n  q = p;\n  q.xz = Rot2D (q.xz, t);\n  a = 2. * pi * (floor (ns * atan (q.z, - q.x) / (2. * pi)) + 0.5) / ns;\n  q.xz = Rot2D (q.xz, a);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 0.5 * (a + t));\n  d = SmoothMin (d, PrRoundBoxDf (q, vec3 (0.6 * b, 2.1 * b, 0.35 * (pi * r / ns)), 0.05), 0.2);\n  DMINQ (1);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, mobRad;\n  dMin = dstFar;\n  mobRad = 2.5;\n  q = p;\n  q.x -= mobRad + 0.55;\n  dMin = MobiusTDf (q.zxy, mobRad, 0.3, 24., 1., dMin);\n  q = p;\n  q.x += mobRad + 0.55;\n  q.x = - q.x;\n  dMin = min (dMin, MobiusTDf (q.zxy, mobRad, 0.3, 24., -1., dMin));\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.01, -0.01);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = 20. * dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk)) / bSize;\n  }\n  return qBlk;\n}\n\nfloat BgCol (vec3 ro, vec3 rd, float scl)\n{\n  vec2 q;\n  q = smoothstep (0.03, 0.1, abs (mod (16. * scl * BlkHit (ro, rd) + 0.5, 1.) - 0.5));\n  return 1. - min (q.x, q.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, vDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vDotL = max (dot (vn, ltDir), 0.);\n    vDotL *= vDotL;\n    col = vec3 (0.85, 0.85, 0.9) * (0.3 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.7 * vDotL * vDotL) +\n       0.2 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    col *= 0.8 + 0.2 * Fbm3 (64. * qHit);\n    col = mix (col, vec3 (1.) * BgCol (ro, reflect (rd, vn), 1.), 0.03);\n  } else col = vec3 (0.1) * BgCol (ro, rd, 2.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi * sin (0.01 * pi * tCur);\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  dstFar = 50.;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -22.);\n  zmFac = 6.;\n  ltDir = vuMat * normalize (vec3 (0.2, 0.2, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfyW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[550, 550, 626, 626, 1172], [1174, 1174, 1196, 1196, 1490], [1492, 1492, 1525, 1525, 1701], [1703, 1703, 1724, 1724, 1970], [1972, 1972, 2004, 2004, 2495], [2497, 2497, 2540, 2540, 2669], [2671, 2671, 2706, 2706, 3262], [3279, 3279, 3335, 3335, 4340], [4342, 4342, 4388, 4388, 4435], [4437, 4437, 4484, 4484, 4531], [4533, 4533, 4555, 4555, 4593], [4595, 4595, 4617, 4617, 4655], [4657, 4657, 4702, 4702, 4805], [4807, 4807, 4837, 4837, 4950], [4952, 4952, 4988, 4988, 5194], [5228, 5228, 5252, 5252, 5371], [5373, 5373, 5398, 5398, 5623], [5625, 5625, 5646, 5646, 5801]], "test": "untested"}
{"id": "WdXyDj", "name": "water marble", "author": "brechrt", "description": "made with domain wrapping of noise", "tags": ["noise", "water", "marble"], "likes": 10, "viewed": 541, "published": 3, "date": "1585549406", "time_retrieved": "2024-07-30T21:15:57.210962", "image_code": "uint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { \n    return hash( v.x ^ hash(v.y)); \n}\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\nfloat random( vec2  v ) { \n    return floatConstruct(hash(floatBitsToUint(v)));\n}\n\nfloat noise(vec2 uv){\n\tvec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat noise( vec2 uv, float detail){\n\tfloat n = 0.;\n    float m = 0.;\n\n    for(float i = 0.; i < detail; i++){\n    \tfloat x = pow(2., i);\n        float y = 1./x;\n        \n        n += noise(uv*x+y)*y;\n        m += y;\n    }\n    \n    return n/m;\n    \n}\nmat2 rot(float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    uv *= 15.;\n \t\n    \n    float n = noise(uv,7.);\n    uv *= rot(n+iTime*.01)*n;\n    \n    vec3 col = mix(vec3(0.,0.,.1),vec3(0.,1.,1.),noise(uv+iTime*vec2(0.,.6), 2.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 152], [153, 153, 175, 175, 214], [216, 216, 248, 248, 668], [669, 669, 694, 694, 750], [752, 752, 773, 773, 1287], [1289, 1289, 1325, 1325, 1539], [1540, 1540, 1558, 1558, 1631], [1633, 1633, 1690, 1690, 1982]], "test": "untested"}
{"id": "tssyDS", "name": "Graph Network", "author": "wyatt", "description": "network", "tags": ["graph"], "likes": 28, "viewed": 690, "published": 3, "date": "1585536354", "time_retrieved": "2024-07-30T21:15:58.087618", "image_code": "Main {\n\tQ = vec4(0);\n    for (int x = -2; x<=2; x++)\n        for (int y = -2; y<=2; y++) {\n        \tvec4 d = D(U+vec2(x,y));\n            vec4 a = A(d.xy), b = A(d.zw);\n            Q += .05*exp(-0.1*vec4(1,3,10,1)*(length(a.xy-b.xy)*(.2+sg(U,a.xy,b.xy))));\n        }\n    //Q = B(U)/R.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define O 6.\n#define shape(U) (round((U)/O)*O)\n#define N 11\n\nvec2 force (vec4 a, vec4 b) {\n    vec2 r = b.xy-a.xy, v = b.zw-a.zw;\n    float l = length(r);\n    if (l < 1e-4) return vec2(0);\n    vec2 f = vec2(0);\n    if (l!=0.){\n    f += (1.-dot(a.zw,b.zw))*r/max(1.,l*l*l);\n    f -= 8.*r/max(1.,l*l*l*l*l);\n    }\n   \t\n    if (length(f)>1.) return normalize(f);\n    return f;\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\nfloat ssg (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    l -= .75;\n    if (l>0.) return l;\n    else return -1e4+length(b-a);\n\n}\nfloat line (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    float i = max(dot(p-a,b-a)/dot(b-a,b-a),0.);\n\tfloat l = (length(p-a-(b-a)*i));\n\tl -= .75;\n    if (l>0.) return l;\n    else return -1e4+abs(length(a-b)-0.5*length(p-a));\n}", "buffer_a_code": "Main {\n    vec2 u = shape(U);\n    if (u.x+O>=R.x||u.y+O>=R.y||u.x<O||u.y<O||length(U-u)>1.) discard;\n    Q = A(u);\n    vec2 f = vec2(0);\n    for (int x=-2;x<2; x++) {\n        for (int y=-2;y<2; y++) {\n            vec4 b = B(u+vec2(x,y));\n            f += (\n                force(Q,A(b.xy))+\n                force(Q,A(b.zw)));\n        }\n\t}\n    f /= 16.;\n    Q.zw += f;\n    if (length(Q.xy-0.5*R)>2.) Q.zw -= 0.001*normalize(Q.xy-0.5*R);\n    Q.xy += f+Q.zw*sqrt(1./(1.+dot(Q.zw,Q.zw)));\n    if (iMouse.z>0.) Q.zw += (Q.xy-iMouse.xy)/dot(Q.xy-iMouse.xy,Q.xy-iMouse.xy);\n    if (Q.x<5.) {Q.x=5.;Q.z = .1+abs(Q.z);}\n    if (R.x-Q.x<5.) {Q.x=R.x-5.;Q.z =-.1-abs(Q.z);}\n    if (Q.y<5.) {Q.y=5.;Q.w = .1+abs(Q.w);}\n    if (R.y-Q.y<5.) {Q.y=R.y-5.;Q.w =-.1-abs(Q.w);}\n    if (iFrame < 50) {\n    \tQ = vec4(u+0.5*O,0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X (inout vec4 Q, inout vec2 r, vec4 a, vec2 U, vec2 u, vec4 n) {\n\tfloat l = line(a.xy+U-u,a.xy,A(n.xy).xy),\n          ll = line(a.xy+U-u,a.xy,A(n.zw).xy);\n    if (l<r.x){\n        r = vec2(l,r.x);\n        Q=vec4(n.xy,Q.xy);\n    } else if (l<r.y) {\n    \tr.y = l;\n        Q.zw = n.xy;\n    }\n    if (ll<r.x){\n    \tr = vec2(ll,r.x);\n        Q=vec4(n.zw,Q.xy);\n    } else if (ll<r.y) {\n    \tr.y = ll;\n        Q.zw = n.zw;\n    }\n}\nMain {\n    vec2 u = shape(U);\n    vec4 a = A(u);\n\tQ = B(U);\n    vec2 r = vec2(line(a.xy+U-u,a.xy,A(Q.xy).xy)\n                 ,line(a.xy+U-u,a.xy,A(Q.zw).xy));\n    \n    X(Q,r,a,U,u,B(Q.xy));\n    X(Q,r,a,U,u,B(Q.zw));\n    X(Q,r,a,U,u,B(Q.xy+U-u));\n    X(Q,r,a,U,u,B(Q.zw+U-u));\n    X(Q,r,a,U,u,B(Q.zw+U-u));\n    X(Q,r,a,U,u,D(A(Q.xy).xy));\n    X(Q,r,a,U,u,D(A(Q.zw).xy));\n    X(Q,r,a,U,u,B(U+vec2(0,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,0)));\n    X(Q,r,a,U,u,B(U-vec2(0,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,0)));\n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,-1)));\n    X(Q,r,a,U,u,B(U-vec2(1,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,-1)));\n    X(Q,r,a,U,u,vec4(U-O*vec2(1,0),U+O*vec2(1,0)));\n    X(Q,r,a,U,u,vec4(U-O*vec2(0,1),U+O*vec2(0,1)));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void X (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = ssg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = ssg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q = n;\n}\nMain {\n\tQ = C(U);\n    if (iFrame%N==0) Q = vec4(shape(U),B(U).xy);\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tX(Q,U,C(U+vec2(0,k)));\n    \tX(Q,U,C(U+vec2(k,0)));\n    \tX(Q,U,C(U-vec2(0,k)));\n    \tX(Q,U,C(U-vec2(k,0)));\n    }\n\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void X (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = ssg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = ssg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q = n;\n}\nMain {\n    Q = D(U);\n    X(Q,U,D(U+vec2(0,1)));\n    X(Q,U,D(U+vec2(1,0)));\n    X(Q,U,D(U-vec2(0,1)));\n    X(Q,U,D(U-vec2(1,0)));\n    \n    X(Q,U,D(U+vec2(1,1)));\n    X(Q,U,D(U+vec2(1,-1)));\n    X(Q,U,D(U-vec2(1,1)));\n    X(Q,U,D(U-vec2(1,-1)));\n    \n    X(Q,U,D(U+vec2(0,4)));\n    X(Q,U,D(U+vec2(4,0)));\n    X(Q,U,D(U-vec2(0,4)));\n    X(Q,U,D(U-vec2(4,0)));\n    \n    X(Q,U,C(U));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wslcWB", "name": "Fourier Transform Fluid", "author": "wyatt", "description": "Thanks to Rory for teaching me how to do this!", "tags": ["fourier"], "likes": 14, "viewed": 522, "published": 3, "date": "1585524539", "time_retrieved": "2024-07-30T21:15:58.842599", "image_code": "// Fork of \"Fourier Transform Wave\" by wyatt. https://shadertoy.com/view/wdXyWS\n// 2020-03-29 21:12:56\n\n// Fork of \"Fourier Transform Schrodinger\" by wyatt. https://shadertoy.com/view/ttcGzH\n// 2020-03-28 22:24:07\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 a = A(U);\n    Q =abs(vec4(a.ywww));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n        Q = vec4(0);\n        vec2 w = 2.*pi*(U-0.5)/R;\n        for (float i = 0.; i < R.y; i++) {\n            vec4 a = A(vec2(U.x,i));\n            Q.xy += a.xy*e(w.y*i)/R.y;\n            Q.zw += a.zw*e(w.y*i)/R.y;\n        }\n        Q *= mod(U.x+U.y,2.)*2.-1.;\n    vec2 u=U;\n    u -= 0.25*B(u).xz;\n    u -= 0.25*B(u).xz;\n    u -= 0.25*B(u).xz;\n    u -= 0.25*B(u).xz;\n    Q.yw = B(u).yw;\n    if (length(U-iMouse.xy)<10.&&iMouse.z>0.) Q =vec4(5,sin(.37*iTime),0,cos(iTime));\n    if (iFrame < 1) {\n        Q = vec4(0);\n        if (length(U-0.5*R)<30.) Q.zyw = vec3(10,1,1);\n    }\n    if (U.x<5.||U.y<5.||R.x-U.x<5.||R.y-U.y<5.)Q.xz*=0.;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R (iResolution.xy)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define pi 3.14159265359\nmat2 e (float t) {\n    float c = cos(t),s = sin(t);\n\treturn mat2(c,-s,s,c);\n}", "buffer_b_code": "vec4 T(vec2 U) {return B(U-B(U).xz+vec2(0.5,0));}\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.x; i++) {\n        vec4 a = T(vec2(i,U.y));\n        Q.xy += vec2(a.x,0)*e(-(w.x-pi)*i);\n        Q.zw += vec2(a.z,0)*e(-(w.x-pi)*i);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R-pi;\n    for (float i = 0.; i < R.y; i++) {\n        vec4 a = A(vec2(U.x,i));\n        Q.xy += a.xy*e(-(w.y)*i);\n        Q.zw += a.zw*e(-(w.y)*i);\n    }\n    if (dot(w,w)>0.) {\n    \tQ.xz -= w*dot(Q.xz,w)/dot(w,w);\n    \tQ.yw -= w*dot(Q.yw,w)/dot(w,w);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.x; i++) {\n        vec4 a = A(vec2(i,U.y));\n        Q.xy += a.xy*e(w.x*i)/R.x;\n        Q.zw += a.zw*e(w.x*i)/R.x;\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 256, 256, 303]], "test": "untested"}
{"id": "tsfcDS", "name": "Dynamic graph accel-structure", "author": "michael0884", "description": "A graph sorting acceleration structure designed to work efficiently with ray marching and physics, has a O(1) complexity for physics and marching(assuming previous closest object is known). From unsorted the sorting speed is O(Nlog(N)), dynamically O(N).", "tags": ["marching", "particles", "objects"], "likes": 4, "viewed": 404, "published": 3, "date": "1585522826", "time_retrieved": "2024-07-30T21:15:59.597581", "image_code": "//Graph is in Buf A, graph traversal is in Buf B\n//You can pause the simulation by setting dt in Common to 0.\n//Change the number of particles by changing N in Common\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nlinks getGraphLinks(int id, int R)\n{ \n    links L;\n    for(int j = 0; j < linkN/4; j++)\n    {\n        vec4 side0 = texel(ch0, i2xy(ivec3(id, j, 1)));\n        for(int i = j*4; i < j*4 + 4; i++)\n        {\n            L.ids[i] = int(side0[i%4]);\n        }   \n    }\n    return L;\n}\n\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat getNd(vec2 p, int id)\n{\n    float d = 1e10;\n    vec4 pp = getParticlePos(id);\n    links nb = getGraphLinks(id, 0);\n    for(int i = 0; i<12; i++)\n    {\n        if(nb.ids[i] >= 0) d = min(d, sdSegment(p, getParticlePos(nb.ids[i]).xy, pp.xy));\n    }\n    return d;\n}\n\nfloat getGraph(vec2 p)\n{\n    float d = 1e10;\n   \n    \td = min(d, getNd(p, (iFrame/30)%tot_n));\n\treturn gauss(d, 1.);\n}\n\nvec2 findPath(vec2 p, vec2 pos, int initguess)\n{\n    int cid = initguess; //closest id\n    vec2 cxy = getParticlePos(cid).xy;\n    float cd = distance(p,cxy); //best distance\n    float d = 1e10;\n    for(int i = 0; i < 30; i++) \n    {\n        int prev_best = cid;\n        vec2 prev_p = cxy;\n        links nb = getGraphLinks(cid, 0);\n        for(int i = 0; i < linkN; i++)\n        {\n            if(nb.ids[i]<0) continue;\n            vec2 pp = getParticlePos(nb.ids[i]).xy;\n            float td = distance(p, pp);\n            if(td < cd) \n            {\n                cd = td;\n                cxy = pp;\n                cid = nb.ids[i];\n            }\n        }\n        d = min(d, sdSegment(pos, prev_p, cxy));\n        if(cid == prev_best) break; //found closest(or impossible to find a better one)\n    }\n    \n    return vec2(gauss(d, 1.), cid);\n}\n\nfloat bisectd(vec2 p, vec2 a, vec2 b)\n{\n    float dd = distance(b,a);\n    return dot(p - a, b - a)/dd - dd*0.5;\n}\n\nfloat bdist(vec2 p, int id)\n{\n    links nbl = getGraphLinks(id, 0);\n    vec2 p0 = getParticlePos(id).xy;\n    float d = 1e10;\n    for(int j = 0; j <8; j++)\n    {\n        if(nbl.ids[j]<0) continue;\n        vec2 pp = getParticlePos(nbl.ids[j]).xy;\n       \td = min(d, bisectd(p, pp, p0));\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    //float gd = getGraph(pos);\n    vec2 path = findPath(iMouse.xy, pos, 0);\n    float e = max(bdist(pos, int(path.y)), 0.);\n    fragColor = sin(0.3*vec4(1,2,3,4)*(e + path.x)) + texel(ch1, pos).zzzz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(8,8)\n#define sN ivec2(3,2)\n#define dt 0.2\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define linkN 12\n\nstruct links\n{\n    int ids[linkN];\n};", "buffer_a_code": "//particle and particle neighbor directional graph buffer \n\nmat4 getParticle(int id);\nvec4 getParticlePos(int id);\nlinks getGraphLinks(int id, int R)\n{ \n    links L;\n    for(int j = 0; j < linkN/4; j++)\n    {\n        vec4 side0 = texel(ch0, i2xy(ivec3(id, j, 1)));\n        for(int i = j*4; i < j*4 + 4; i++)\n        {\n            L.ids[i] = int(side0[i%4]);\n        }   \n    }\n    return L;\n}\nvec4 save(in mat4 data, int i);\nmat4 data; vec4 d; vec4 ppos; int ID;\nfloat avgR; \nfloat dist2p(vec2 p, int id);\nvoid sort(int idtemp, int R);\nvoid sortlinks(in links nb, int R);\nvoid sortneighbors(int id, int R);\nvoid sortrandom(int id, int R);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n    \n    ivec3 sid = xy2i(p);\n    ID = sid.x;\n   \tif(sid.z == 0) //particle computation\n    {\n        data = getParticle(ID);\n \n        vec2 F = vec2(0,-0.003);\n\n        data[0].zw += F*dt;\n        data[0].xy += data[0].zw*dt;\n\n        //border conditions\n        if(size.x - data[0].x < 2.) data[0].z = -abs(data[0].z);\n        if(data[0].x < 2.) data[0].z = abs(data[0].z);\n        if(size.y - data[0].y < 2.) data[0].w = -abs(data[0].w);\n        if(data[0].y < 2.) data[0].w = abs(data[0].w);\n        \n        if(iFrame<1) //initial condition\n        {\n            data[0].xy = size*hash22(pos);\n            data[0].zw = 2.*(hash22(PI*pos) - 0.5);\n        } \n    }\n    else //graph computation\n    {\n        ppos = getParticlePos(ID);\n        \n        d = vec4(1e6);\n        data = mat4(vec4(-1),vec4(-1),vec4(-1),vec4(-1));\n        \n        links nb = getGraphLinks(ID, sid.y);\n        \n        avgR = 0.; float NN = 0.;\n        for(int i = min(0,iFrame); i < 8; i++)\n        {\t\n            if(nb.ids[i] >= 0) \n            {\n                NN++;\n        \t\tavgR += dist2p(ppos.xy, nb.ids[i]);    \n            }\n        }\n        avgR /= NN;\n        \n        sortlinks(nb, sid.y);\n        \n        for(int i = min(0,iFrame); i < linkN; i++)\n        \tsortneighbors(nb.ids[i], sid.y);\n        \n        sortrandom(sid.x, sid.y);\n    }\n    U = save(data, sid.y);\n}\n\nmat4 getParticle(int id)\n{\n    mat4 da;\n    for(int i = 0; i < sN.x; i++) da[i] = texel(ch0, i2xy(ivec3(id, i, 0))); \n    return da;\n}\n\nvec4 save(in mat4 da, int i)\n{\n    return da[i];\n}\n\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat dist2p(vec2 p, int id)\n{\n    return distance(getParticlePos(id).xy,p);\n}\n\nvoid sort(int idtemp, int R) //sort closest particles in 8 directions\n{\n    if(idtemp == ID || idtemp < 0 || any(equal(data[R], vec4(idtemp)))) return; //particle already sorted\n    vec4 px = getParticlePos(idtemp);\n    vec4 dx = px - ppos;\n    \n    if(R < 2) //closest\n    {\n        int dir = int(4.*((atan(dx.y, dx.x)+PI)/PI)); \n        int diri = dir%4;\n        int dirR = dir/4;\n        float nd = length(dx.xy);\n        if(dirR == R && nd < d[diri])\n        {\n            d[diri] = nd;\n            data[R][diri] = float(idtemp);\n        }\n    } \n    else // far particles\n    {\n        int dir = int(2.*((atan(dx.y, dx.x)+PI)/PI)); \n        int diri = dir%4;\n        int dirR = R;\n        float nd = abs(length(dx.xy) - exp2(float(R))*2.*avgR);\n        if(dirR == R && nd < d[diri])\n        {\n            d[diri] = nd;\n            data[R][diri] = float(idtemp);\n        }\n    }\n    \n  \n}\n\nvoid sortlinks(in links nb, int R)\n{\n    for(int i = min(0, iFrame); i<linkN; i++) sort(nb.ids[i], R);\n}\n\nvoid sortneighbors(int id, int R)\n{\n    links nb = getGraphLinks(id, R);\n    sortlinks(nb, R);\n}\n\nvoid sortrandom(int id, int R)\n{\n    for(int i = 0; i<12; i++) sort((12*iFrame+ID+i)%tot_n, R);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//prev closest particle buffer\n\nlinks getGraphLinks(int id, int R)\n{ \n    links L;\n    for(int j = 0; j < linkN/4; j++)\n    {\n        vec4 side0 = texel(ch0, i2xy(ivec3(id, j, 1)));\n        for(int i = j*4; i < j*4 + 4; i++)\n        {\n            L.ids[i] = int(side0[i%4]);\n        }   \n    }\n    return L;\n}\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat distanceTC(vec2 a, vec2 b)\n{\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nvec3 findClosestObj(vec2 p, int initguess)\n{\n    ivec4 cid = ivec4(initguess, ivec3(-1)); //closest id\n    vec2 cxy = getParticlePos(cid.x).xy;\n    vec4 cd = vec4(distance(p,cxy), vec3(1e10)); //best distance\n    bool found = false;\n    links nb;\n    for(int i = 0; i < 12; i++) \n    {\n        int prev_best = cid.x;\n        vec2 prev_p = cxy;\n        nb = getGraphLinks(cid.x, 0);\n        float safeR = 1e10; //safe radius - if point is inside of it - definitely closest\n        for(int i = 0; i < linkN; i++)\n        {\n            if(nb.ids[i]<0) continue;\n            vec2 pp = getParticlePos(nb.ids[i]).xy;\n            float td = distance(p, pp);\n           \tfloat sR = 0.5*distance(prev_p, pp);\n            if(safeR > sR) safeR = sR;\n            if(td < cd.x) \n            {\n                cd = vec4(td, cd.xyz);\n                cxy = pp;\n                cid = ivec4(nb.ids[i], cid.xyz);\n            }\n            else if(td < cd.y)\n            {\n                cd.yzw = vec3(td, cd.yz);\n                cid.yzw = ivec3(nb.ids[i], cid.yz);\n            }\n            else if(td < cd.z)\n            {\n                cd.zw = vec2(td, cd.z);\n                cid.zw = ivec2(nb.ids[i], cid.z);\n            }\n            else if(td < cd.w)\n            {\n                cd.w = td;\n                cid.w = nb.ids[i];\n            }\n        }\n        //found closest(or impossible to find a better one)\n        if(cid.x == prev_best) \n        {\n            if(cd.x < safeR) found = true;\n            break;\n        }    \n    }\n    \n    if(!found)\n    //check second best\n    for(int j = 1; j < 4; j++)\n    {\n        nb = getGraphLinks(cid[j], 0);\n        for(int i = 0; i < linkN; i++)\n        {\n            if(nb.ids[i]<0) continue;\n            vec2 pp = getParticlePos(nb.ids[i]).xy;\n            float td = distance(p, pp);\n            if(td < cd.x) \n            {\n                cd.x = td;\n                cxy = pp;\n                cid.x = nb.ids[i];\n            }\n        }\n    }\n   \n    return vec3(cxy, cid.x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    int cid = 0;//int(texel(ch1, pos).x); //use prev data - makes it super fast\n    if(iFrame < 1) cid =0;\n    vec3 co = findClosestObj(pos, cid);\n    U.x = co.z;\n    U.y = distance(pos,co.xy);\n    U.z = exp(-0.03*U.y);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 199, 199, 233], [235, 235, 287, 287, 406], [408, 408, 444, 444, 685], [687, 687, 716, 716, 765], [767, 767, 796, 796, 1035], [1037, 1037, 1061, 1061, 1155], [1157, 1157, 1205, 1205, 1999], [2001, 2001, 2040, 2040, 2114], [2116, 2116, 2145, 2145, 2422], [2424, 2424, 2475, 2507, 2678]], "test": "untested"}
{"id": "tdsyR2", "name": "Swarovski Piglet", "author": "xjorma", "description": "Mesh from:\nhttps://opengameart.org/content/lowpoly-animated-farm-animal-pack", "tags": ["raytracing", "reflection", "refraction", "beer", "gem", "crystal", "facet", "pig", "beerlambert", "piglet", "faceted"], "likes": 30, "viewed": 1416, "published": 3, "date": "1585522010", "time_retrieved": "2024-07-30T21:16:00.541058", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n//#define AA\n#define GAMMA 1\n\n\n// https://iquilezles.org/articles/intersectors\nbool boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 roo = ro - cen;\n    if( abs(roo.x)<rad.x && abs(roo.y)<rad.y && abs(roo.z)<rad.z ) return true;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\treturn ( tN < tF && tF > 0.0);\n}\n\n\n// https://iquilezles.org/articles/intersectors\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n#define ZERO_NOLOOP min(0,iFrame)\n\nbool intersectMesh( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, int exclude, out int faceId)\n{\n   if( !boxIntersect( ro, rd, bboxCtr, bboxSiz ) )\n        return false;\n        \n    bool\tres = false;\n    float\ttmin = tmax;\n    for( int i=ZERO_NOLOOP; i < numVertices / 3; i++ )\n    {\n\t\t// get the triangle        \n        vec3 v0 = getVertex(uint(i*3));\n        vec3 v1 = getVertex(uint(i*3 + 2));\n        vec3 v2 = getVertex(uint(i*3 + 1));\n\n        int id = i * 2;\n        if(id != exclude)\n        {\n            vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n            if( h.x > 0. && h.x < tmin)\n            {\n                tmin = h.x;\n                oNor = normalize(cross(v1 - v0, v2 - v0));;\n                oDis = tmin;\n                faceId = id;\n                res = true;\n            }\n        }\n        \n        // Mirror X  \n        \n        id = i * 2 + 1;\n        if(id != exclude)\n        {\n            v0.x *= -1.;\n            v1.x *= -1.;\n            v2.x *= -1.;\n            vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n            if( h.x > 0. && h.x < tmin)\n            {\n                tmin = h.x;\n                oNor = normalize(cross(v2 - v0, v1 - v0));;\n                oDis = tmin;\n                faceId = id;\n                res = true;\n            }\n        }\n        \n    }\n    \n    return res;\n}\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    #if GAMMA\n    \tcol = pow(col, vec3(2.2));\n    #endif\n    return col;\n}\n\n\n#define MAX_BOUNCES 10\n#define ABSORB\t\tvec3(0, 5, 0)\n\nvec3 Render(in vec3 ro, in vec3 rd, in float dist)\n{\n    float sgn = 1.;\n    float cref = 0.7;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.99;\n    vec3  absorb = ABSORB;\n    int\t  exclude = -1;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        vec3\tn;\n        float \td;\n        if(!intersectMesh(ro, rd, 15., d, n, exclude, exclude))\n        {\n            col += rel * getSkyColor(rd);\n            return col;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * d);\n        vec3 p = ro + rd * d;\n        n *= sgn;\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd, 14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n \n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro, rd, 12.);\n        \n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// export from Houdini using this python script\n/*\nimport sys\n\nnode = hou.pwd()\ngeo = node.geometry()\n\nprims = geo.prims()\n\nvertices = []\n\nbbox =  geo.boundingBox();\nmaxPos = bbox.maxvec()\nminPos = bbox.minvec()\n\nfor prim in prims:\n    points = prim.points()\n    for point in points:\n        pos = point.position()\n        vertices.append(pos)\n        \noutput = \"const int numVertices = \" + str(len(vertices)) + \";\\n\\n\"  \n\noutput = output + \"const uint vertices[\" + str(len(vertices)) + \"] = uint[](\"\n\nfor i in range(len(vertices)):\n    if i % 12 == 0 :\n        output = output + \"\\n\"\n    vert = vertices[i]\n    x = int(round(1023 * (vert.x() - minPos.x()) / (maxPos.x() - minPos.x())))\n    y = int(round(1023 * (vert.y() - minPos.y()) / (maxPos.y() - minPos.y())))\n    z = int(round(1023 * (vert.z() - minPos.z()) / (maxPos.z() - minPos.z())))\n    v = (x << 20) + (y << 10) + z\n    output = output + str(v).rjust(10,\" \") + \"U\"\n    if i != len(vertices) - 1 :\n        output = output + \",\"\n\noutput = output + \" );\\n\\n\"\n\noutput = output + \"vec3 getVertex( uint id )\\n{\\n\\tuint d = vertices[id];\\n\\tvec3 v = vec3(ivec3(d >> 20, d >> 10, d)&1023) / 1023.0;\\n\\t\"\noutput = output + \"return v * vec3(\" + str(maxPos.x() - minPos.x()) + \", \" + str(maxPos.y() - minPos.y()) + \", \" + str(maxPos.z() - minPos.z()) + \") + vec3(\" + str(minPos.x()) + \", \" + str(minPos.y()) + \", \" + str(minPos.z()) + \");\\n}\\n\\n\"\n\nbbox.enlargeToContain(hou.Vector3(-bbox.maxvec().x(), bbox.center().y(), bbox.center().z()))\noutput = output + \"const vec3 bboxSiz = vec3(\" + str(bbox.sizevec().x() / 2.) + \", \" + str(bbox.sizevec().y() / 2.) + \", \" + str(bbox.sizevec().z() / 2.) + \");\\n\"\noutput = output + \"const vec3 bboxCtr = vec3(\" + str(bbox.center().x()) + \", \" + str(bbox.center().y()) + \", \" + str(bbox.center().z()) + \");\\n\"\n\n\nprint(output)\n*/\n\n\nconst int numVertices = 843;\n\nconst uint vertices[843] = uint[](\n    315732U, 759517524U, 732299537U, 759517524U, 852052304U, 839540001U, 852052304U, 666853697U, 718198016U, 666853697U,   1036610U,   1032449U,\n 676298155U,   1047979U,   1036610U, 595515963U, 677284481U,    977537U, 901337518U, 676298155U, 666853697U, 799369646U, 901337518U, 852052304U,\n    322990U, 799369646U, 759517524U, 718198016U, 916197626U, 988461325U, 732299537U, 645281997U,    378059U, 732299537U, 661952734U, 691317895U,\n   1032449U,    982177U, 701384865U, 701384865U,    982177U,    889968U, 689311855U,1068931204U, 920118396U, 677284481U, 668892873U,    965321U,\n 985038081U, 861184222U, 661952734U, 685585524U, 950857857U, 701384865U, 827884092U, 909646466U, 677284481U, 697699911U, 763732599U, 909646466U,\n    365129U,    366203U, 763732599U, 985038081U, 988461325U,1073384569U, 703063151U, 920118396U, 910858349U,    515171U,    383087U, 689311855U,\n 100326486U, 105576508U,    682046U,    378059U, 645281997U, 689311855U, 909646466U, 893979330U, 668892873U,    363144U,    363218U, 631609034U,\n 893979330U, 637081347U, 371019545U, 631609034U, 476439293U, 637081347U, 668892873U, 371019545U,    885530U,    363218U,    366330U, 476439293U,\n    384826U,    388965U, 470181733U, 476711726U, 417005402U, 372030303U, 372053823U, 372030303U,    849759U,    388965U,    391027U, 460747642U,\n    496607U, 258450391U, 306654156U, 417005402U, 555392898U, 529277827U, 470181733U, 460747642U, 464146320U, 464146320U, 322497475U, 355183507U,\n 306654156U, 254317528U, 322497475U, 322497475U, 254317528U,    589794U, 258450391U, 254258154U, 250124268U,    496607U,    498675U, 254258154U,\n 254317528U, 250124268U,    590838U, 306654156U, 258450391U, 254317528U, 988461325U, 916197626U, 950857857U, 985038081U,1068931204U, 910472328U,\n 920118396U,1073384569U, 910858349U,1068931204U,1073384569U, 920118396U,1073384569U, 950857857U, 910858349U, 692760672U, 910858349U, 950857857U,\n 839540001U, 988461325U, 985038081U, 631609034U, 960864955U, 866362047U, 861184222U, 856928426U, 686008490U, 661952734U, 686008490U, 677623929U,\n 689311855U, 691317895U, 910472328U, 476439293U, 417746750U, 476711726U, 645281997U, 691317895U, 689311855U, 637081347U, 476711726U, 372053823U,\n 677623929U, 637719675U, 927128699U, 861184222U, 910472328U, 880001145U,    366330U,    384826U, 417746750U, 371019545U, 372053823U,    871231U,\n 880001145U, 927128699U, 893577385U, 686008490U, 648208553U, 637719675U, 856928426U, 893577385U, 648208553U, 638770832U, 693150364U, 880845468U,\n 916197626U, 718198016U, 701384865U, 763732599U, 944057991U, 984044172U,    366203U,    363144U, 567644808U, 944057991U, 960864955U,1000852155U,\n 893979330U,1000852155U, 960864955U, 909646466U, 984044172U,1000852155U, 950857857U, 916197626U, 701384865U, 631609034U, 695444159U, 683912846U,\n 944057991U, 886288014U, 866362047U, 944057991U, 763732599U, 683912846U, 763732599U, 567644808U, 683912846U, 100326486U, 692760672U, 685585524U,\n 389466014U, 306654156U, 464146320U,    420760U,    443335U, 306654156U, 460747642U, 389466014U, 464146320U, 322497475U, 464146320U, 306654156U,\n    391027U,    420760U, 389466014U,    611273U,    803734U, 355183507U, 886288014U, 929225360U, 900912830U, 695444159U, 654498494U, 638770832U,\n    849759U, 184314770U, 525051779U, 365710193U, 417005402U, 464146320U, 365710193U, 355183507U,    803734U, 417746750U, 470181733U, 417005402U,\n 250124268U, 253252595U,    570367U, 253252595U, 254258154U,    498675U, 253252595U, 250124268U, 254258154U,    322990U,    365129U, 697699911U,\n 799369646U, 697699911U, 827884092U, 901337518U, 827884092U, 595515963U, 676298155U, 595515963U,   1001019U, 691317895U, 677623929U, 880001145U,\n 866362047U, 900912830U, 654498494U, 637719675U, 698391691U, 858823820U, 927128699U, 858823820U, 855681197U, 893577385U, 855681197U, 652257453U,\n 648208553U, 652257453U, 698391691U, 683912846U, 638770832U, 929225360U, 929225360U, 880845468U, 890284734U, 900912830U, 890284734U, 686860990U,\n 654498494U, 686860990U, 693150364U, 555392898U, 533336997U, 596318155U, 184314770U, 349947835U, 530237388U, 372030303U, 529277827U, 184314770U,\n 365710193U, 525051779U, 555392898U, 596318155U, 530237388U, 349947835U, 533336997U, 530237388U, 596318155U, 529277827U, 596318155U, 349947835U,\n 525051779U, 530237388U, 533336997U,    753728U,    771112U, 118196249U, 703063151U, 692760672U, 100326486U,    749658U,    753728U, 105576508U,\n 105576508U, 118196249U,    728078U,    771112U,    845848U, 115135499U, 118196249U, 115135499U,    824320U, 115135499U, 123589654U,    917514U,\n    845848U,    884767U, 123589654U, 123589654U, 127808561U,    954413U,    884767U,    903217U, 127808561U,    903217U,    888897U, 144567367U,\n 127808561U, 144567367U,    937034U,    888897U,    849998U, 138220630U, 144567367U, 138220630U,    869470U, 138220630U, 143417425U,    807002U,\n    849998U,    820297U, 143417425U,    820297U,    812095U, 146544702U, 143417425U, 146544702U,    772162U, 146544702U, 124534832U,    788529U,\n    812095U,    816178U, 124534832U,    803888U,    788529U, 124534832U,    816178U,    803888U, 124534832U, 652257453U, 653264050U, 673186965U,\n 858823820U, 882902166U, 854590642U, 855681197U, 854590642U, 653264050U, 653264050U, 854590642U, 882902166U, 890284734U, 889193155U, 687866563U,\n 687866563U, 889193155U, 907019941U, 880845468U, 907019941U, 889193155U, 698391691U, 673186965U, 882902166U, 686860990U, 687866563U, 673187494U,\n 693150364U, 673187494U, 907019941U, 907019941U, 880845468U, 693150364U, 673187494U, 693150364U, 686860990U, 882902166U, 858823820U, 698391691U,\n 889193155U, 890284734U, 880845468U, 907019941U, 673187494U, 687866563U, 687866563U, 686860990U, 890284734U, 882902166U, 673186965U, 653264050U,\n 653264050U, 652257453U, 855681197U, 854590642U, 855681197U, 858823820U, 673186965U, 698391691U, 652257453U, 124534832U, 146544702U,    812095U,\n    788529U,    772162U, 146544702U,    772162U,    807002U, 143417425U, 146544702U, 143417425U,    820297U, 143417425U, 138220630U,    849998U,\n    807002U,    869470U, 138220630U,    869470U,    937034U, 144567367U, 138220630U, 144567367U,    888897U,    937034U,    954413U, 127808561U,\n 144567367U, 127808561U,    903217U, 127808561U, 123589654U,    884767U,    954413U,    917514U, 123589654U, 123589654U, 115135499U,    845848U,\n    917514U,    824320U, 115135499U,    824320U,    728078U, 118196249U, 115135499U, 118196249U,    771112U,    728078U,    682046U, 105576508U,\n 105576508U, 100326486U,    749658U,    671831U,    515171U, 100326486U,    515171U, 703063151U, 100326486U, 118196249U, 105576508U,    753728U,\n 533336997U, 555392898U, 525051779U, 349947835U, 184314770U, 529277827U, 555392898U, 417005402U, 365710193U, 184314770U,    849759U, 372030303U,\n 530237388U, 525051779U, 184314770U, 596318155U, 529277827U, 555392898U, 693150364U, 638770832U, 654498494U, 686860990U, 654498494U, 900912830U,\n 890284734U, 900912830U, 929225360U, 929225360U, 886288014U, 683912846U, 698391691U, 637719675U, 648208553U, 652257453U, 648208553U, 893577385U,\n 855681197U, 893577385U, 927128699U, 858823820U, 927128699U, 637719675U, 654498494U, 695444159U, 866362047U, 880001145U, 910472328U, 691317895U,\n   1001019U,   1047979U, 676298155U, 595515963U, 676298155U, 901337518U, 827884092U, 901337518U, 799369646U, 697699911U, 799369646U,    322990U,\n    498675U,    570367U, 253252595U,    570367U,    590838U, 250124268U, 417005402U, 476711726U, 417746750U,    803734U,    849759U, 365710193U,\n 464146320U, 355183507U, 365710193U, 525051779U, 365710193U,    849759U, 638770832U, 683912846U, 695444159U, 900912830U, 866362047U, 886288014U,\n 355183507U, 322497475U,    611273U, 389466014U, 460747642U,    391027U, 306654156U, 389466014U,    420760U,    889968U,    749658U, 685585524U,\n    749658U, 100326486U, 685585524U, 683912846U, 886288014U, 944057991U, 866362047U, 960864955U, 944057991U, 683912846U, 567644808U, 631609034U,\n1000852155U, 893979330U, 909646466U, 960864955U, 631609034U, 893979330U,1000852155U, 984044172U, 944057991U, 567644808U, 763732599U,    366203U,\n 984044172U, 909646466U, 763732599U, 880845468U, 929225360U, 638770832U, 648208553U, 686008490U, 856928426U, 637719675U, 677623929U, 686008490U,\n 893577385U, 856928426U, 880001145U,    871231U,    885530U, 371019545U, 417746750U, 476439293U,    366330U, 880001145U, 856928426U, 861184222U,\n 927128699U, 880001145U, 677623929U, 372053823U, 371019545U, 637081347U, 476711726U, 637081347U, 476439293U, 910472328U,1068931204U, 689311855U,\n 677623929U, 691317895U, 661952734U, 686008490U, 661952734U, 861184222U, 866362047U, 695444159U, 631609034U, 985038081U, 732299537U, 839540001U,\n 950857857U, 685585524U, 692760672U, 910472328U, 861184222U, 985038081U, 950857857U,1073384569U, 988461325U,    590838U,    589794U, 254317528U,\n 254258154U, 258450391U,    496607U, 250124268U, 254317528U, 258450391U,    589794U,    611273U, 322497475U, 464146320U, 417005402U, 470181733U,\n 529277827U, 372030303U, 417005402U, 306654156U,    443335U,    496607U, 460747642U, 470181733U,    388965U,    849759U,    871231U, 372053823U,\n 372030303U, 372053823U, 476711726U, 470181733U, 417746750U,    384826U, 476439293U, 631609034U,    363218U,    885530U,    965321U, 668892873U,\n 637081347U, 893979330U, 631609034U, 371019545U, 668892873U, 893979330U, 631609034U, 567644808U,    363144U, 668892873U, 677284481U, 909646466U,\n 689311855U,    383087U,    378059U,    682046U,    671831U, 100326486U, 689311855U, 703063151U,    515171U, 910858349U, 692760672U, 703063151U,\n1073384569U,1068931204U, 985038081U, 763732599U, 697699911U,    365129U, 909646466U, 827884092U, 697699911U, 677284481U, 595515963U, 827884092U,\n 661952734U, 732299537U, 985038081U,    965321U,    977537U, 677284481U, 920118396U, 703063151U, 689311855U,    889968U, 685585524U, 701384865U,\n 701384865U, 718198016U,   1032449U, 691317895U, 645281997U, 732299537U,    378059U,    375057U, 732299537U, 988461325U, 839540001U, 718198016U,\n 759517524U,    315732U,    322990U, 852052304U, 759517524U, 799369646U, 666853697U, 852052304U, 901337518U,    977537U,   1001019U, 595515963U,\n   1036610U, 666853697U, 676298155U,   1032449U, 718198016U, 666853697U, 718198016U, 839540001U, 852052304U, 839540001U, 732299537U, 759517524U,\n 732299537U,    375057U,    315732U );\n\nvec3 getVertex( uint id )\n{\n\tuint d = vertices[id];\n\tvec3 v = vec3(ivec3(d >> 20, d >> 10, d)&1023) / 1023.0;\n\treturn v * vec3(0.337168395519, 0.915008187294, 1.95409280062) + vec3(0.0, -0.500852227211, -0.908407986164);\n}\n\nconst vec3 bboxSiz = vec3(0.337168395519, 0.457504093647, 0.977046400309);\nconst vec3 bboxCtr = vec3(0.0, -0.043348133564, 0.0686384141445);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyR2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[145, 193, 265, 265, 605], [608, 656, 737, 737, 1096], [1133, 1133, 1250, 1250, 2488], [2491, 2491, 2518, 2518, 2636], [2693, 2693, 2745, 2745, 4022], [4026, 4026, 4104, 4104, 4173], [4175, 4175, 4217, 4217, 4381], [4384, 4384, 4428, 4428, 4527], [4529, 4529, 4569, 4569, 4639]], "test": "untested"}
{"id": "tsfcDB", "name": "Circuit[Experiment]", "author": "Arseny", "description": "procedural", "tags": ["procedural", "2d"], "likes": 5, "viewed": 321, "published": 3, "date": "1585518482", "time_retrieved": "2024-07-30T21:16:01.301026", "image_code": "float N21(vec2 p) {\n   \treturn fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat getValue(vec2 id){\n   \treturn N21(id);\n}\n\nvec2 getMax(vec2 id){\n    vec2 ans = id;\n    for (float i = -1.; i < 2.; i++){\n        for (float j = -1.; j < 2.; j++){\n            ans = (getValue(id + vec2(i, j)) > getValue(ans)) ? id + vec2(i, j) : ans;\n        }\n    }\n    return ans;\n}\n\nvec2 upperbound(vec2 id){\n    vec2 ans = getMax(id);\n    for (float i = -1.; i < 2.; i++){\n        for (float j = -1.; j < 2.; j++){\n            float f = getValue(id + vec2(i, j));\n            ans = (f < getValue(ans) && f > getValue(id)) ? id + vec2(i, j) : ans;\n        }\n    }\n    return ans;\n}\n\nvec2 to(vec2 id){\n    /*if (fract(iTime) < 0.5){\n    \treturn getMax(id);\n    }*/\n    return upperbound(id);\n}\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 gradient(float t){\n   \treturn mix(vec3(255., 237., 0.) / 256., vec3(0., 168., 107.) / 256., t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    \n    uv += vec2(iTime, iTime) / 20.;\n\n    vec2 id = floor(uv * 10.);\n    vec2 lv = (fract(uv * 10.) - 0.5) * 2.; // -1 to 1\n    \n    vec3 col = vec3(getValue(id));\n    \n\tcol = vec3(((to(id) - id) + vec2(1.)) * 0.5, 0);\n    col = vec3(\n        smoothstep(\n            0.,\n            0.1,\n            sdCapsule(\n                lv, \n                vec2(0, 0), \n                to(id) - id, \n                0.1\n            )\n        )\n    );\n    \n    for (float i = -1.; i < 2.; i++){\n        for (float j = -1.; j < 2.; j++){\n            vec2 v = id + vec2(i, j);\n            if (length(to(v) - id) < 0.01){\n                col = min(\n                    col, \n                \tvec3(\n                    \tsmoothstep(\n                            0.,\n                            0.1,\n                            sdCapsule(\n                                lv, \n                                vec2(0, 0), \n                                v - id,\n                                0.1\n                            )\n                        )\n                    )\n                );\n            }\n        }\n    }\n    \n    if (max(1. - abs(lv.x), 1. - abs(lv.y)) < 0.3){\n        col = vec3(\n            smoothstep(\n                0.,\n                0.1,\n                sdCapsule(\n                    lv, \n                    vec2(0, 0), \n                    to(id) - id, \n                    0.1\n                )\n            )\n        );\n        vec2 xd = (id + floor((lv - 1.) / 2. + 0.5));\n        for (float i = 0.; i < 1.9; i++){\n        for (float j = 0.; j < 1.9; j++){\n            vec2 v = xd + vec2(i, j);\n            vec2 opsit = xd + vec2(1. - i, 1. - j);\n            if (length(to(v) - opsit) < 0.01){\n                col = \n                \tvec3(\n                    \tsmoothstep(\n                            0.,\n                            0.1,\n                            sdCapsule(\n                                lv, \n                                vec2(0, 0), \n                                v - opsit,\n                                0.1\n                            )\n                        )\n                    );\n            }\n        }\n        }\n        fragColor = vec4(xd / 5., 0., 0.);\n        //fragColor = col;\n        //col = gradient(col.x);\n        //fragColor = vec4(col,1.0);\n        //return;\n    }\n    \n    //col.xy += id / 10.;\n    //col *= vec3(82., 204., 0.) / 256.;\n    col = gradient(col.x);\n    //col *= vec3(((to(id) - id) + vec2(1.)) * 0.5, 0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 70], [72, 72, 96, 96, 118], [120, 120, 141, 141, 361], [363, 363, 388, 388, 661], [663, 663, 680, 743, 772], [774, 774, 826, 826, 947], [949, 949, 972, 972, 1051], [1053, 1053, 1110, 1110, 3705]], "test": "untested"}
{"id": "3dsyWB", "name": "Love Is In The Air", "author": "dr2", "description": "Balloon time (mouseable)", "tags": ["fire", "heart", "balloon"], "likes": 10, "viewed": 461, "published": 3, "date": "1585491371", "time_retrieved": "2024-07-30T21:16:02.062989", "image_code": "// \"Love Is In The Air\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 Hashv3v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nvec3 obDisp, obRnd, sunDir, qHit;\nvec2 cId;\nfloat dstFar, tCur, bGrid, balRad, obRot, flmCylRad, flmCylLen;\nint idObj;\nbool cOcc, balFlm;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid ObjState ()\n{\n  float r, s;\n  r = length (cId);\n  obRnd = Hashv3v2 (cId + 17.17);\n  obDisp.xz = bGrid * (cId + 0.5);\n  if (r > 0.) obDisp.xz += Rot2D (vec2 ((0.45 * bGrid - balRad) * (0.2 + 0.8 * obRnd.x), 0.),\n     2. * pi * (0.2 * obRnd.z * tCur + obRnd.x));\n  else obDisp.xz += 0.45 * bGrid - balRad;\n  s = sin (2. * pi * (0.05 * obRnd.y * tCur + obRnd.x));\n  obDisp.y = 12. + 6. * s;\n  obRot = 0.1 * pi * (obRnd.z - 0.5) * tCur;\n  balFlm = (s < 0.);\n  cOcc = (r == 0. || obRnd.x > 0.7);\n}\n\nfloat FlmDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    q = p - vec3 (0., -0.8 * balRad, 0.);\n    d = PrCylDf (q.xzy, flmCylRad + 0.3 * q.y / flmCylLen, flmCylLen);\n    d = max (d, - q.y - 0.5 * flmCylLen);\n    DMINQ (0);\n  }\n  return dMin;\n}\n\nfloat FlmRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = FlmDf (p);\n    s = (bGrid * (cId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (min (s.x, s.y)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    p.xz = Rot2D (p.xz, obRot);\n    q = p;\n    d = max (PrSphDf (q, balRad), - PrSphDf (q, 0.98 * balRad));\n    d = max (d, - PrCylDf (q.xzy - vec3 (0., 0., - balRad), 0.3 * balRad, 0.1 * balRad));\n    DMINQ (1);\n    q = p;\n    d = PrCylDf (q.xzy - vec3 (0., 0., -1.42 * balRad), 0.05 * balRad, 0.13 * balRad);\n    d = max (d, - PrCylDf (q.xzy- vec3 (0., 0., 0.02 * balRad), 0.03 * balRad, 0.13 * balRad));\n    DMINQ (2);\n    q = p;\n    d = PrCylDf (q.xzy - vec3 (0., 0., -1.5 * balRad), 0.2 * balRad, 0.07 * balRad);\n    d = max (d, - PrCylDf (q.xzy - vec3 (0., 0., -1.48 * balRad), 0.18 * balRad, 0.07 * balRad));\n    DMINQ (3);\n    q = p;\n    q.xz = abs (q.xz) - 0.25 * balRad;\n    q.y -= -1.15 * balRad;\n    q.yz = Rot2D (q.yz, -0.35);\n    q.xy = Rot2D (q.xy, 0.35);\n    d = PrCylDf (q.xzy, 0.005 * balRad, 0.35 * balRad);\n    DMINQ (4);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (bGrid * (cId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (min (s.x, s.y)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 FlmCol (vec3 p, vec3 rd)\n{\n  vec3 q, qq;\n  float a, f, dr;\n  a = 0.;\n  p.y -= - flmCylLen;\n  dr = 0.05 / flmCylRad;\n  for (int j = 0; j < 20; j ++) {\n    p += dr * rd;\n    q = 15. * p / flmCylLen;\n    q.y -= 40. * tCur;\n    qq.y = Noisefv3 (q + 0.1 * vec3 (sin (tCur)));\n    qq.x = Noisefv3 (q + vec3 (qq.y));\n    qq.z = Noisefv3 (q + vec3 (qq.x));\n    q = p + 0.25 * (1. - 3. * p.y / flmCylLen) * (qq - 0.5);\n    f = 0.45 * q.y - 2.5 * length (q.xz);\n    f = clamp (sign (f) * f * f, 0., 1.) * (3. - 0.9 * q.y);\n    a += f;\n  }\n  return clamp (a * vec3 (1., 0.5, 0.3), 0., 1.);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, p, c1, c2;\n  float ds, fd, att, attSum, sd;\n  c1 = vec3 (0.3, 0.2, 0.1);\n  c2 = vec3 (0.1, 0.3, 0.);\n  if (rd.y > -0.003 && rd.y < 0.01 + 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = 0.5 * (c1 + c2);\n  } else if (rd.y < 0.) {\n    p = ro - (ro.y / rd.y) * rd;\n    p.xz -= 0.2 * tCur;\n    col = mix (c1, c2, Fbm2 (0.5 * p.xz)) * (1. - 0.1 * Noisefv2 (17. * p.xz));\n    col = mix (col, 0.5 * (c1 + c2), smoothstep (-0.1, 0., rd.y));\n  } else {\n    p = ((200. - ro.y) / rd.y) * rd;\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz = p.xz * fd + 0.1 * tCur;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    for (float j = 0.; j < 4.; j ++) {\n      attSum += Fbm2 (p.xz + (1. + j * ds) * fd * sunDir.xz);\n    }\n    attSum *= 0.3;\n    att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    col = mix (vec3 (0.5, 0.75, 1.), mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1),\n       0.25 + 0.75 * sd), exp (-2. * (3. - sd) * max (rd.y - 0.1, 0.))) +\n       0.3 * (vec3 (1., 0.8, 0.7) * pow (sd, 1024.) + vec3 (1., 0.4, 0.2) * pow (sd, 256.));\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, colFlm, qHitFlm, u;\n  float dstObj, dstFlm, s, h;\n  bool inSun, inFlm;\n  dstFlm = FlmRay (ro, rd);\n  if (dstFlm >= dstFar) balFlm = false;\n  qHitFlm = qHit;\n  inFlm = balFlm;\n  dstObj = ObjRay (ro, rd);\n  inSun = true;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj != 1) balFlm = false;\n    if (idObj == 1) {\n      h = 0.1 + 0.8 * obRnd.z;\n      u = qHit / (0.3 * balRad);\n      col = mix (HsvToRgb (vec3 (h + 0.5, 0.8, 0.8)), HsvToRgb (vec3 (h, 0.7, 0.8)),\n         smoothstep (0., 0.02, abs (abs (u.y) - 1.7) - 0.07));\n      u.xz = Rot2D (u.xz, pi / 24.);\n      u.xz = Rot2D (u.xz, 2. * pi * (floor (6. * atan (u.x, u.z) / (2. * pi) + 0.5) / 6.));\n      col = mix (vec3 (1., 0., 0.), col, smoothstep (0., 0.01, length (Rot2D (vec2 (abs (u.x) - 0.3, u.y),\n          pi / 6.) * vec2 (2., 1.)) - 1.));\n      if (length (qHit) < 0.99 * balRad) {\n        col *= 0.2;\n        if (balFlm) col += 0.1 * vec3 (1., 0.5, 0.);\n        inSun = false;\n      } else {\n        if (length (qHit) > 0.99 * balRad) vn.xz = Rot2D (vn.xz, 0.1 * pi *\n           sin (pi * (0.5 - mod (24. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5), 1.))));\n      }\n    } else if (idObj == 2) {\n      vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (12. * (atan (qHit.x, qHit.z) /\n         (2. * pi) + 0.5), 1.))));\n      col = vec3 (0.6);\n    } else if (idObj == 3) {\n      vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (32. * (atan (qHit.x, qHit.z) /\n         (2. * pi) + 0.5), 1.))));\n      col = vec3 (0.6, 0.3, 0.);\n    } else if (idObj == 4) {\n      col = vec3 (0.3);\n    }\n    if (inSun) col = col * (0.3 + 0.3 * max (- dot (vn, normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n       0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n       0.05 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  } else {\n    col = BgCol (ro, rd);\n    balFlm = false;\n  }\n  if (dstFlm < min (dstFar, dstObj)) {\n    if (inFlm) {\n      colFlm = FlmCol (qHitFlm, rd);\n      col = mix (col, colFlm, 0.6 * length (colFlm));\n    }\n  }\n  if (balFlm) {\n    qHit.xz = Rot2D (qHit.xz, - obRot);\n    qHit.y += 0.5 * balRad;\n    col = mix (col, vec3 (1., 0.5, 0.),\n       0.4 * pow (clamp (dot (normalize (qHit), - rd), 0., 1.), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az, h;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  dstFar = 150.;\n  bGrid = 6.;\n  balRad = 2.;\n  flmCylRad = 0.4;\n  flmCylLen = 2.;\n  h = 12. + 4. * sin (2. * pi * 0.02 * tCur);\n  az = 0.3 * pi + 2. * pi * mod (0.003 * tCur, 1.);\n  el = -0.005 * pi * (h - 12.);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (vec2 (-0.49 * bGrid), h).xzy;\n  rd = vuMat * normalize (vec3 (uv, 4.5));\n  sunDir = normalize (vec3 (1., 0.2, -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec3 (0., cHashVA2.xy)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyWB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[736, 736, 754, 754, 1233], [1235, 1235, 1257, 1257, 1523], [1525, 1525, 1558, 1558, 2147], [2149, 2149, 2171, 2171, 3109], [3111, 3111, 3144, 3144, 3733], [3735, 3735, 3756, 3756, 4011], [4013, 4013, 4044, 4044, 4598], [4600, 4600, 4631, 4631, 5965], [5967, 5967, 6002, 6002, 8294], [8296, 8296, 8352, 8352, 9155], [9157, 9157, 9190, 9190, 9217], [9219, 9219, 9261, 9261, 9312], [9314, 9314, 9371, 9371, 9454], [9456, 9456, 9492, 9492, 9698], [9700, 9700, 9730, 9730, 9843], [9845, 9845, 9869, 9869, 9986], [10020, 10020, 10044, 10044, 10097], [10099, 10099, 10123, 10123, 10235], [10237, 10237, 10261, 10261, 10373], [10375, 10375, 10399, 10399, 10518], [10520, 10520, 10545, 10545, 10691], [10693, 10693, 10718, 10718, 10904], [10906, 10906, 10931, 10931, 11156], [11158, 11158, 11180, 11180, 11334], [11336, 11336, 11357, 11357, 11496]], "test": "untested"}
{"id": "WssyWS", "name": "Apollonian Sphere II", "author": "mla", "description": "Another Apollonian sphere - now with transparency and duals, as well as a nice glowing colour scheme.", "tags": ["sphere", "apollonian"], "likes": 13, "viewed": 549, "published": 3, "date": "1585485966", "time_retrieved": "2024-07-30T21:16:02.822957", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Project an Apollonian gasket onto a sphere.\n//\n// Now with transparent sphere and glowing Apollonian.\n//\n// Since (reverse) stereographic projection preserves circles (it's an inversion)\n// we can use it to project a planar Apollonian gasket onto a sphere.\n//\n// The gasket is generated from an n-sided prism and the resulting pattern is\n// based on the dual double ended n-sided pyramid (or vice-versa if dual mode\n// is selected).\n//\n// <mouse>: apply a Mobius transform to the sphere\n// <up>/<down>: move in and out\n// <left>/<right>: change number of circles\n// b: show background\n// c: color cycle\n// r: autorotation\n// s: show sphere\n// t: transparency\n// i: invert with mouse or rotate\n// x: special case for tetrahedron (dual mode only)\n// d: show dual polyhedron\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float AA = 2.0;\nconst int maxiterations = 50;\n\nint NCIRCLES = 4;      // 3 or more\nbool dobackground = false;\nbool docolorcycle = false;\nbool domonochrome = false;\nbool dorotate = true;\nbool dosphere = true;\nbool dotransparent = true;\nbool dodual = true;\nbool dotetrahedron = false;\n\nconst float PI = 3.14159265;\n\nvoid assert(bool b);\nvec3 hsv2rgb(vec3 c);\nvec3 transform(in vec3 p);\n\n// If z is inside the circle, invert to the outside.\n// s is 1 or -1, and sets sense of \"inside\"\nbool checkinverse(inout vec2 z, vec3 circle, float s, inout float mindist2) {\n  vec2 c = circle.xy;  // Centre of circle\n  float r2 = circle.z; // Radius squared\n  vec2 p = z-c;\n  float p2 = dot(p,p);\n  float d2 = s*p2 - s*r2;\n  if (d2 > 0.0) {\n    d2 /= r2;\n    if (s < 0.0) d2 = 1.0/d2;\n    mindist2 = min(d2/r2,mindist2);\n    return false;\n  }\n  z = p*r2/p2 + c;\n  return true;\n}\n\nbool checkinverse(inout vec2 z, vec3 circle, float s) {\n  float mindist = 1e8;\n  return checkinverse(z,circle,s,mindist);\n}\n\n// A ring of circles, centred on the unit circle, with\n// incircle and outcircle. No outcircle for tetrahedron.\nbool checkcircles0(inout vec2 z, inout float mindist2) {\n  float theta = PI/float(NCIRCLES);\n  float r = 1.0/cos(theta);\n  float s = tan(theta);\n  vec3 c1 = vec3(0,0,pow(r-s,2.0));\n  vec3 c2 = vec3(0,0,pow(r+s,2.0));\n  if (checkinverse(z,c1,1.0,mindist2)) return true;\n  if (!dotetrahedron && checkinverse(z,c2,-1.0,mindist2)) return true;\n  for (int i = 0; i < NCIRCLES; i++) {\n    float t = 2.0*float(i)*theta-0.5*PI;\n    vec3 c = vec3(r*cos(t), r*sin(t), s*s);\n    if (checkinverse(z,c,1.0,mindist2)) return true;\n  }\n  return false;\n}\n\n// Two rings of circles, touching along the unit circle.\nbool checkcircles1(inout vec2 z, inout float mindist2) {\n  float theta = PI/float(NCIRCLES);\n  float K = sin(theta);\n  float r = K/(1.0+K);\n  float s = K/(1.0-K);\n  for (int i = 0; i < NCIRCLES; i++) {\n    float t = 2.0*float(i)*theta;\n    vec2 c = vec2(cos(t),sin(t));\n    vec3 c0 = vec3((1.0-r)*c,r*r);\n    if (checkinverse(z,c0,1.0,mindist2)) return true;\n    vec3 c1 = vec3((1.0+s)*c, s*s);\n    if (checkinverse(z,c1,1.0,mindist2)) return true;\n  }\n  return false;\n}\n\nbool checkcircles(inout vec2 z, inout float mindist2) {\n  if (dodual) return checkcircles0(z,mindist2);\n  else return checkcircles1(z,mindist2);\n}\n\n// r*(1+sqrt(2)) = 1 => r = 1/(1+sqrt(2))\nvec4 gasket(vec2 z){\n  // 3 circles can either be a tetrahedron, with some\n  // special casing, or a triangular prism (with dual\n  // a double triangular pyramid).\n  if (dotetrahedron) z /= 2.0; // Scale for tetrahedron.\n  for (int n = 0; n < maxiterations; n++){\n    float mindist2 = 1e8;\n    if (!checkcircles(z,mindist2)) return vec4(z,n,mindist2);\n  }\n  return vec4(z,maxiterations,0.0);\n}\n\nfloat framethreshold = 0.0;\nvec3 gasketcolor(vec2 z) {\n  vec4 data = gasket(z);\n  if (framethreshold > 0.0 && data.z < framethreshold) return vec3(0);\n  float t = docolorcycle ? 0.05*iTime : 0.0;\n  float h = data.z/float(maxiterations);\n  float v = max(2.0,data.z)/(0.3*float(maxiterations));\n  vec3 col = hsv2rgb(vec3(t+h,1,smoothstep(0.0,1.0,v)));\n  //float d = 1.0/(sqrt(data.w)+1.0);\n  //float d = sqrt(data.w);\n  //col *= smoothstep(0.0,0.1,d);\n  return col;\n}\n\n// R3 inversion in sphere, centre q, square radius r2.\nvec3 invert(vec3 p, vec3 q, float r2) {\n  p -= q;\n  p *= r2/dot(p,p);\n  p += q;\n  return p;\n}\n\nvec3 stereographic0(vec3 p) {\n  return invert(p,vec3(0,0,-1),2.0);\n}\n\n// Invert in sphere radius sqrt(2), centre (0,0,-1)\n// is stereographic projection from the unit sphere\n// to z=0 (and its inverse).\nvec2 stereographic(vec3 p) {\n#if 0\n  float k = 1.0/(1.0-p.z);\n  vec2 z = k*p.xy;\n  //assert(distance(istereographic(z),p) < 1e-4);\n  return z;\n#else\n  return stereographic0(p).xy;\n#endif\n}\n\nvec3 istereographic(vec2 z) {\n#if 0\n  float k = 2.0/(dot(z,z)+1.0);\n  vec3 p = vec3(k*z,1.0-k);\n  //assert(distance(stereographic(p),z) < 1e-4);\n  return p;\n#else\n  return stereographic0(vec3(z,0));\n#endif\n}\n\nbool doinversion = true;\nvec3 getspherecolor(vec3 p) {\n  p = transform(p); // autorotation\n  // Apply inversion to sphere.\n  if (true) {\n    vec3 q = vec3(0);\n    if (doinversion && iMouse.x > 0.0) {\n      vec3 m = vec3((2.0*iMouse.xy-iResolution.xy)/iResolution.y,0);\n      q = vec3(m.xyz);\n    }\n    // Any point is the centre of a sphere orthogonal to the\n    // unit sphere, inverting in which leaves the unit sphere\n    // invariant. Any point inverts to another point on the\n    // line to the sphere centre, so just find other\n    // intersection of ray p to r with unit sphere.\n    // |p + kr|^2 = 1 where r = q-p\n    // (p.p + 2kp.r + k^2(r.r)) = 1\n    // 2p.r + k(r.r) = 0 since p.p = 1 & dividing by k\n    vec3 r = q-p;\n    float k = -2.0*dot(p,r)/dot(r,r);\n    p += k*r;\n  }\n  // And stereographic projection from (0,0,1) to plane z = 0\n  return gasketcolor(stereographic(p));\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  vec3 p;       // centre\n  float r;      // radius\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit[2]) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // Formula for x^2 + 2Bx + C = 0\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t0,t1;\n  if (B >= 0.0) {\n    t0 = -B-D; t1 = C/t0;\n  } else {\n    t1 = -B+D; t0 = C/t1;\n  }\n  hit[0] = Hit(t0,(q+t0*d-p)/r);\n  hit[1] = Hit(t1,(q+t1*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit[2]) {\n  Sphere s = Sphere(vec3(0),1.0);\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\n\nvec3 solve(Ray r,vec2 uv) {\n  Hit hit[2];\n  vec3 c = vec3(0);\n  if (!dosphere || !intersectScene(r,hit)) {\n    if (dobackground) {\n      vec3 p = istereographic(uv);\n      c = getspherecolor(p);\n      c *= dosphere ? 0.2 : 0.8;\n    }\n  } else {\n    for (int ix = 0; ix < 2; ix++) {\n      int i = dotransparent ? 1-ix : ix;\n        if (hit[i].t < 0.0) continue;\n      vec3 n = hit[i].n;\n      if (dot(r.d,n) > 0.0) n *= -1.0; // ???\n      vec3 basecolor = getspherecolor(hit[i].n);\n      if (basecolor == vec3(0)) continue;\n      vec3 color = vec3(0);\n      float ambient = 0.5;\n      float diffuse = 0.8;\n      color += basecolor*ambient;\n      color += basecolor*diffuse*max(0.0,dot(light,n));\n      float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n      vec3 speccolor = basecolor; //vec3(1);\n      color += 1.0*specular*speccolor;\n      if (!dotransparent) return color;\n      c = mix(c,color,0.7);\n    }\n  }\n  return c;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_O = 79;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (!doinversion && iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nbool check = false;\nvoid assert(bool b) { if (!b) check = true; }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dodual = key(CHAR_D);\n  dobackground = key(CHAR_B);\n  docolorcycle = !key(CHAR_C);\n  dorotate = !key(CHAR_R);\n  dosphere = !key(CHAR_S);\n  dotransparent = !key(CHAR_T);\n  doinversion = key(CHAR_I);\n  NCIRCLES = max(3,4+keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  dotetrahedron = key(CHAR_X) && dodual && NCIRCLES == 3;\n  //framethreshold = float(max(0,keycount(KEY_PAGE_UP)-keycount(KEY_PAGE_DOWN)));\n\n  light = vec3(0.5,1.0,1.0);\n  light = normalize(light);\n\n  vec3 p = vec3(0,0,6);\n  p.z *= exp(-0.1*float(keycount(KEY_UP)-keycount(KEY_DOWN)));\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,-6);\n      r = normalize(r);\n      col += solve(Ray(p,r),uv);\n    }\n  }\n  fragColor = vec4(pow(col/(AA*AA),vec3(0.4545)),1);\n  if (check) fragColor = vec4(1,0,0,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1335, 1432, 1509, 1509, 1814], [1816, 1816, 1871, 1871, 1939], [1941, 2053, 2109, 2109, 2591], [2593, 2650, 2706, 2706, 3120], [3122, 3122, 3177, 3177, 3268], [3270, 3312, 3332, 3475, 3705], [3735, 3735, 3761, 3761, 4172], [4174, 4229, 4268, 4268, 4322], [4324, 4324, 4353, 4353, 4392], [4394, 4527, 4555, 4555, 4715], [4717, 4717, 4746, 4746, 4924], [4951, 4951, 4980, 4980, 5816], [6060, 6060, 6117, 6117, 6583], [6585, 6585, 6629, 6629, 6736], [6751, 6751, 6778, 6778, 7689], [8195, 8195, 8215, 8215, 8275], [8277, 8277, 8302, 8302, 8350], [8352, 8352, 8375, 8375, 8407], [8409, 8504, 8531, 8531, 8707], [8709, 8709, 8739, 8739, 8791], [8793, 8793, 8820, 8820, 9165], [9187, 9187, 9208, 9208, 9232], [9234, 9234, 9286, 9286, 10199]], "test": "untested"}
{"id": "WslyWS", "name": "Day 101", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics"], "likes": 19, "viewed": 429, "published": 3, "date": "1585476827", "time_retrieved": "2024-07-30T21:16:03.600877", "image_code": "// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.0;\n    float chromAb = pow(length(uv - 0.5),1.5)*2.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    \n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\n// inigo quilez\nfloat sdTri(  vec2 p, float s )\n{\n    //p.y -= s*0.75;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nconst float speed = 0.8;\nfloat[] scenes = float[2](1.*speed,1.2*speed); \n\nfloat S = 0.3;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n    uv *= 2.;\n    vec3 col = vec3(0);\n    \n    float d = 10e6;\n    \n    float triA;\n    float triB;\n    float triC;\n    float triD;\n    \n    float t = iTime;\n    \n    t = mod(t, scenes[0] + scenes[1]  );\n    \n    if(t < scenes[0]){\n        float env = ease(t/scenes[0], 2.);\n        \n\t    triA = sdTri(uv*rot(pi*1.), S);\n\n        \n        triB = sdTri(uv, 0. + env*S*2.);\n        d = min(d, triA) ;\n\n\n        d = max(d, -triB);\n        d = min(d, max(triB, -triA)) ;\n        \n    \n    } else if(t < scenes[1] + scenes[0]){\n        t -= scenes[0];\n        float env = ease(t/scenes[1], 2.)*4.;\n        float envb = ease(t/scenes[1], 4.)*1.;\n        \n        float offs = 1.155;\n            \n        triC = sdTri(uv - vec2(S*1. + env,0. - S*offs/2. - env*0.5), S);\n        triD = sdTri(uv - vec2(-S*1. - env,0. - S*offs/2. - env*0.5), S);\n        \n        uv -= vec2(0.,S*offs - S*offs*envb);\n        uv *= rot(pi*envb);\n        \n        triB = sdTri(uv, S);\n        \n        d = min(d, triB);\n        d = min(d, triC);\n        d = min(d, triD);\n    } \n    \n    \n    \n    col += smoothstep(0.00,3./iResolution.y,-d);\n    \n    col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 92, 92, 1009]], "test": "untested"}
{"id": "tsfyWB", "name": "Tom's Donut", "author": "tmulgrew", "description": "A donut.", "tags": ["sdf", "donuts"], "likes": 7, "viewed": 470, "published": 3, "date": "1585467291", "time_retrieved": "2024-07-30T21:16:04.536376", "image_code": "// A little SDF ray-marching \"framework\".\n// Much of the techniques are copied from IQ's demos and articles.\n\n#define AA 1\n#define ZERO (min(iFrame,0))\n// Pinched from \"Happy Jumping\"\n//#define DEBUGSTEPS\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst float tmin = 0.01;\t\t\t\t\t\t\t\t// Ray minimum distance\nconst float tmax = 15.0;\t\t\t\t\t\t\t\t\nconst int raySteps = 100;\t\t\t\t\t\t\t\t// Max iterations when resolving a ray\nconst int shadowSteps = 50;\t\t\t\t\t\t\t\t// Max iterations when resolving a shadow ray\nconst float limit = 0.0005;\t\t\t\t\t\t\t\t// Convergence to surface limit when ray tracing\nconst float screenDist = 0.5;\t\t\t\t\t\t\t// Screen distance as a fraction of screen width\nconst vec3 light = normalize(vec3(-1.0, -0.75, -0.52));\t// Light direction\nconst float ambient = 0.3;\t\t\t\t\t\t\t\t// Ambient light\nconst int bounces = 2;\t\t\t\t\t\t\t\t\t// Max reflection bounces (actually bounces + 1, as includes initial ray)\nconst int shadowBounces = 1;\t\t\t\t\t\t\t// Bounces during which shadow rays are cast.\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Data structures\n\nstruct lightingParams {\n \tfloat diffuse;\n    float specular;\n    float shiny;\n};\n\nstruct material {\n    vec3 col;\t\t\t\t\t\t\t\t\t\t\t// Surface colour\n    lightingParams lighting;\n    float reflective;\t\t\t\t\t\t\t\t\t// Reflectiveness. 0 = not reflective. 1 = completely reflective (e.g. mirror).\n};\n    \nstruct rayInfo {\n    vec3 origin;\n    vec3 dir;\n};\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Functions (implemented at the bottom)\n    \n// Get camera ray for specified pixel\nrayInfo getRay(in vec2 fragCoord);\n\n// Get VR ray\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir);\n\n// Get sample point.\n// Format is vec4:\n//\tx,y\t\t= Material parameter (e.g. uv)\n//\tz\t\t= Distance to nearest surface\n//\tw\t\t= Material index (will be passed to getMaterial())\nvec4 map(in vec3 p);\n\n// Get material properties by index\nmaterial getMaterial(float index, vec2 uv, vec3 p);\n\n// Get colour for ray that misses\nvec3 getRayMissCol(in rayInfo ray);\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Trig\n\nconst float PI = 3.14159265;\n\nvec3 rotatex(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y - sin(a) * p.z,\n                cos(a) * p.z + sin(a) * p.y);\n}\n\nvec3 rotatey(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotatez(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 euler) {\n \treturn rotatey(rotatex(rotatez(p, euler.z), euler.x), euler.y);   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Helper functions\n\nbool checkerboard(in vec2 p) {\n\tfloat x = mod(p.x, 2.0);\n    if (x < 0.0) x += 2.0;\n    float y = mod(p.y, 2.0);\n    if (y < 0.0) y += 2.0;\n    return (x < 1.0) == (y < 1.0);\n}\n\n// Pinched from: https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Combining shapes\n//\n// Sample format is vec3:\n//\tx,y\t\t= Material parameter (e.g. texture coordinates)\n//\tz\t\t= Distance\n\n// Union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2) { \n    return p1.z < p2.z ? p1 : p2;\n}\n\n// Smoothed union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2, float k) {\n    return vec3(p1.z < p2.z ? p1.xy : p2.xy, sminCubic(p1.z, p2.z, k));\n}\n\n// Subtract shape p2 from p1\nvec3 carve(in vec3 p1, in vec3 p2) { \n    return p1.z > -p2.z ? p1 : vec3(p2.xy, -p2.z);\n}\n\nvec3 carve(in vec3 p1, in vec3 p2, float k) {\n \treturn vec3(p1.z > -p2.z ? p1.xy : p2.xy, -sminCubic(-p1.z, p2.z, k));   \n}\n\n// Intersection of two shapes\nvec3 intersect(in vec3 p1, in vec3 p2) { \n    return p1.z > p2.z ? p1 : p2;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Shape primitives\n\nvec3 sphere(in vec3 p, float rad) { \n    return vec3(atan(p.x, p.y) * rad, atan(length(p.xy), p.z) * rad, length(p) - rad); \n}\nvec3 box(in vec3 p, in vec3 size) {\n    vec3 o = abs(p) - size;\t\t\t\t\t\t// Distance inside/outside each side\n    float d = max(o.x, max(o.y, o.z));   \t\t// Negative distance to nearest wall if inside box\n    if (d > 0.0) {\t\t\t\t\t\t\t\t// Refine distance if outside box\n\t    vec3 n = min(o, vec3(0));\t\t\t\t// Clamp to box boundaries to get nearest point. (Could be edge/corner).\n        d = length(o - n);\n    }\n    vec3 a = abs(o);\t\t\t\t\t\t\t// Nearest wall determines texture coordinates\n    vec2 uv = a.x < a.y && a.x < a.z ? p.yz\t\t\n    \t\t: a.y < a.z \t\t\t ? p.xz\n            :                          p.xy;\n    return vec3(uv, d);\n}\nvec3 planeBottom(in vec3 p, float y)\t\t\t\t{ return vec3(p.xz, y-p.y); }\nvec3 planeTop(in vec3 p, float y) \t\t\t\t\t{ return vec3(p.xz, p.y-y); }\nvec3 cylinder(in vec3 p, float radius, float height) { \n    vec3 tube = vec3(atan(p.x, p.z) * radius, p.y, length(p.xz) - radius);\n    vec3 top = planeTop(p, height);\n    vec3 bottom = planeBottom(p, -height);\n    return intersect(tube, intersect(top, bottom));\n}\nvec3 torus(in vec3 p, float radius, float thickness) { \n    vec2 circleOffs = vec2(length(p.xz) - radius, p.y);\n    return vec3(atan(p.x, p.z) * radius, atan(circleOffs.x, circleOffs.y) * thickness, length(circleOffs) - thickness);\n}\nvec3 line(in vec3 p, in vec3 from, in vec3 to, float thickness) {\n\t\n    vec3 d = to - from;\n    vec3 n = normalize(d);\n    float l = length(d);\n    \n    float proj = dot(p - from, n);\n    proj = clamp(proj, 0.0, l);\n    vec3 pt = from + n * proj;\n    return vec3(0, 0, length(p - pt) - thickness);    \n}\n\n// Creating and combining full sample including material index\nvec4 makes(in vec3 d, float material) {\n    // Like a distance sample, but with w = material index.\n    // Specifically:\n    //\tx,y\t= material parameter (e.g. texture coord)\n    //\tz\t= distance\n    //\tw\t= material index\n \treturn vec4(d, material);   \n}\n\nvec4 merges(in vec4 result, in vec3 d, float material) {\n \treturn d.z < result.z ? makes(d, material) : result;\n}\n\nvec4 merge(in vec4 result, in vec4 d) {\n \treturn d.z < result.z ? d : result;   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Rendering\n\n// Calculate ray direction for a given pixel\nvec3 screenRay(in vec2 s) {\n    s -= iResolution.xy / 2.0;\n    return vec3(s / (screenDist * iResolution.x), 1);\n}\n\n// Simple lighting\nfloat shading(in vec3 e, in vec3 n, in lightingParams p) {\n    \n    // Diffuse term\n    float d = dot(n, -light) * p.diffuse;\n    \n    // Specular term\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), p.shiny) * p.specular;\n\n    return max(d + s, 0.0);\n}\n\n// Calculate normal at a point\nvec3 normal(in vec3 p, float t) {\n    \n\t// Calculate pixel size at point distance. \n    // This will be the distance of the normal samples from the original point.\n    float s = 0.1 / t;\n    \n    // Sample relative distance along each axis\n    float d = map(p).z;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        map(p + vec3(s,0,0)).z - d,\n        map(p + vec3(0,s,0)).z - d,\n        map(p + vec3(0,0,s)).z - d);\n    \n    return normalize(r);\n}\n\n// Cast regular ray\nvec4 raycast(in vec3 from, in vec3 dir) {\n    \n    float t = tmin;\n    vec4 d;\n    int i;\n    for (i = 0; i < raySteps && t < tmax; i++) {\n        vec3 p = from + dir * t;\n        d = map(p);\n        if (abs(d.z) <= limit * t) {\n            d.z = t;\n#ifdef DEBUGSTEPS\n            d.x = float(i) / float(raySteps);\n#endif            \n            return d;\n        }\n        t += d.z;\n    }    \n    \n    // Avoid flicker when polygons are edgewise to the camera.\n    // In this case the ray cannot quite find the surface and runs out of steps.\n    // Just return the last sample point.\n    if (t < tmax) {\n#ifdef DEBUGSTEPS\n        d.x = float(i) / float(raySteps);\n#endif            \n        d.z = t;\n        return d;\n    }\n    \n#ifdef DEBUGSTEPS\n    return vec4(float(i) / float(raySteps),0,-1.0,0);\n#else    \n    return vec4(0,0,-1.0,0);\n#endif    \n}\n\n// Cast shadow ray\nfloat shadow(in vec3 from, in vec3 dir, float k) {\n    float res = 1.0;\n    float t = tmin;    \n    for (int i = 0; i < shadowSteps && t < tmax; i++) {\n     \tvec3 p = from + dir * t;\n        float d = map(p).z;\n        if (d <= 0.0)\n            return 0.0;\n        res = min(res, k*d/t);\n        t += d;\n    }\n    \n    return res;\n}\n\nvec3 drawPixel(in rayInfo ray) {\n    ray.dir = normalize(ray.dir);\n\n    // Sum up reflection bounces    \n    vec3 sumCol = vec3(0);\n    float alpha = 1.0;\n    for (int bounce = 0; alpha > 0.0002; bounce++) {\n    \n\t    // Ray cast\n\t    vec4 r = bounce < bounces \n            ? raycast(ray.origin, ray.dir) \n            : vec4(0,0,-1,0);\t\t\t\t\t// Last ray always misses\n    \n#ifdef DEBUGSTEPS        \n        sumCol = vec3(r.x*16.0 - floor(r.x*16.0), r.x*4.0 - floor(r.x*4.0), r.x);\n        break;\n#endif        \n        \n        // Distance is returned in r.z\n\t    // Miss?\n\t    if (r.z == -1.0)\n\t    {\n            vec3 missCol = getRayMissCol(ray);\n            sumCol += missCol * alpha;\n\t        break;\n\t    }\n        \n\t    // Position and normal\n\t    vec3 p = ray.origin + r.z * ray.dir;\n\t    vec3 n = normal(p, r.z);\n\n        // Get material info\n        material mat = getMaterial(r.w, r.xy, p);\n        \n        // Apply lighting\n        float i = shading(ray.dir, n, mat.lighting);\n        if (i > 0.0 && bounce < shadowBounces) \n            i *= shadow(p, -light, 16.0);    \n        i = clamp(i + ambient, 0.0, 1.0);\n        mat.col *= i;\n\n        // Add to sum of colours\n        mat.col *= (1.0 - mat.reflective);\n        sumCol += mat.col * alpha;\n        alpha *= mat.reflective;\n        \n        // Calculate reflection vector\n        ray.origin = p;\n        ray.dir = normalize(reflect(ray.dir, n));\n    }    \n    \n    return sumCol;\n}\n\n// Main entrypoints\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA > 1    \n    vec3 col = vec3(0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n\t    rayInfo ray = getRay(fragCoord + vec2(m,n) / vec2(AA));\n\t    col += drawPixel(ray) / (float(AA) * float(AA));\n\t    fragColor = vec4(col, 1);\n    }\n#else    \n    rayInfo ray = getRay(fragCoord);\n    vec3 col = drawPixel(ray) / (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n#endif    \n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) \n{\n \trayInfo ray = getVRRay(fragCoord, fragRayOri, fragRayDir);\n    vec3 col = drawPixel(ray);\n    fragColor = vec4(col, 1);\n}\n\n//-----------------------------------------------------------------------------------------------------------------------------------\n\nconst vec3 camCentre = vec3(0, .4, 0);\nconst vec3 camOffs = vec3(0, 0, -3.5);\n\nrayInfo getRay(in vec2 fragCoord) {    \n\n    // Get base ray\n    rayInfo ray;\n\tray.origin = camOffs;\n    ray.dir = screenRay(fragCoord);\n    \n    // Apply camera rotation\n    float camY = iTime * .2 + 0.9;\n    float camX = sin(iTime*.1)*.35 + .6;\n    \n    //camX = (1. - iMouse.y / iResolution.y) * PI/2.;\n    //camY = iMouse.x / iResolution.x * PI*2.;\n    \n    ray.origin = camCentre + rotatey(rotatex(ray.origin, camX), camY);\n    ray.dir = rotatey(rotatex(ray.dir, camX), camY);\n    \n    return ray;\n}\n\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) {\n \trayInfo ray;\n    ray.origin = rotatey(fragRayOri * 40.0 + vec3(0,28,10), PI*0.5);\n    ray.dir = rotatey(fragRayDir, PI*0.5);\n    return ray;\n}\n\nvec3 getRayMissCol(in rayInfo ray) {\n\treturn texture(iChannel0, ray.dir).xyz;    \n}\n\n// Material types.\n// Returned by map(). Then passed into getMaterial() to get colour, lighting etc.\nconst float groundMat = 0.;\nconst float donutMat = 1.;\nconst float icingMat = 2.;\nconst float candyMat = 3.;\n\n// Lookup material colour etc\nmaterial getMaterial(float matType, vec2 uv, vec3 p) {\n    \n    // Set defaults\n    material mat;\n    mat.col = vec3(0.8);\n    mat.lighting.diffuse = 0.8;\n    mat.lighting.specular = 0.6;\n    mat.lighting.shiny = 64.0;\n    mat.reflective = 0.0001;\n    \n    if (matType < groundMat + 1.) {\n        int u = int(uv.x + 1000.);\n        int v = int(uv.y + 1000.);\n        if ((u & 1) == (v & 1))\n            mat.col = vec3(.3,.3,.4);\n       \telse\n            mat.col = vec3(0,.025,.1);\n        mat.reflective = 0.1;\n    }\n    else if (matType < donutMat + 1.) {\n        mat.col = vec3(1,.6,.3) * .8;\n    }\n    else if (matType < icingMat + 1.) {\n     \tmat.col = vec3(.9,.8,1);\n        mat.reflective = 0.02;\n    }\n    else if (matType < candyMat + 1.) {\n\t\tfloat f = fract(matType) * 2.*PI * 3.;\n        mat.col = min(vec3(sin(f), sin(f+.666*PI), sin(f+1.333*PI)) * 1.5 + vec3(.6), vec3(1));\n        mat.reflective = 0.075;\n    }\n    \n    return mat;\n}\n\nvec4 donut(in vec3 p) {\n    p.y-=.45;\n    float ang = atan(p.x, p.z);\n    float d = length(p.xz);\n\n\t// Base    \n    vec3 base = torus(p, 1., .45);\n\n    // Icing\n    vec3 icingTorus = torus(p, 1., .48);\n    float waveFactor = (d > 1. ? 1. : .5);\n    float wave = sin(ang * 12. * waveFactor) * .062 \n               + sin(ang * 34. * waveFactor + .7) * 0.027\n               + sin(ang * 42. * waveFactor + 1.7) * 0.015;\n        \n    vec3 icingWave = vec3(0, 0, p.y - (wave + .03));    \n    vec3 icing = carve(icingTorus, icingWave, .2);\n    \n    // Candy\n    const float candySpacing = 2.*PI / 11.;\n    float candyAng = round(ang / candySpacing) * candySpacing;\n    \n    vec3 candyPos = vec3(sin(candyAng), .51, cos(candyAng)) * 1.;\n    vec3 candyp = p - candyPos;\n    candyp.y *= 3.;\n    vec3 candyShape = sphere(candyp, 0.15);\n    candyShape.z /= 3.;\n    vec4 candy = makes(candyShape, candyMat + fract(candyAng/(2.*PI)));\n    \n    \n    // Candy icing indentation\n    vec3 indentPos = candyPos + vec3(sin(candyAng * 7.)*.01,0,sin(candyAng * 11.)*.01);\n    indentPos.y -= 0.1;\n    vec3 indentp = p - indentPos;\n    indentp.y *= 2.5;\n    vec3 icingIndent = sphere(indentp, 0.2);\n    icingIndent.z /= 2.5;\n    icing = combine(icing, icingIndent, .07);\n    icing = carve(icing, candyShape, 0.05);\n\n    // Table surface objects\n    p.y += .45;\n\n    // Fallen candy\n    vec3 fallCandyp = p - vec3(-.5, 0.05, 1.6);\n    fallCandyp.y *= 3.;\n    vec3 fallCandy = sphere(fallCandyp, 0.15);\n    fallCandy.z /= 3.;\n    \n    // Icing blobs\n    p.y *= 2.;\n    vec3 blob1 = sphere(p - vec3(1.5, 0, 0), 0.25);\n    vec3 blob2 = sphere(p - vec3(1.7,0,.45), 0.175);\n    vec3 blob3 = sphere(p - vec3(1.9,0,-.35), 0.1);\n    vec3 blob = combine(combine(blob1, blob2, .5), blob3);\n    blob.z /= 2.;\n   \n    vec4 r = makes(base, donutMat);\n    r = merges(r, icing, icingMat);\n    if (candyAng != 0.) r = merge(r, candy);\n    r = merges(r, blob, icingMat);\n    r = merges(r, fallCandy, candyMat + 0.0);\n\treturn r;    \n}\n\n\nvec4 map(in vec3 p) {\t\n    \n    // Find signed distance sample\n    // x,y = uv\n    // z   = distance\n    // w   = material\n    vec4 r;\n    \n    // Ground plane\n    vec3 ground = cylinder(p - vec3(0, -.05, 0), 5., .05);\n    r = makes(ground, groundMat);\n    \n    vec4 dn = donut(p);\n    r = merge(r, dn);\n    \n    return r;\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2450, 2450, 2484, 2484, 2595], [2597, 2597, 2631, 2631, 2742], [2744, 2744, 2778, 2778, 2889], [2891, 2891, 2930, 2930, 3001], [3158, 3158, 3188, 3188, 3334], [3336, 3390, 3436, 3436, 3522], [3781, 3804, 3842, 3842, 3879], [3881, 3913, 3960, 3960, 4034], [4036, 4065, 4101, 4101, 4155], [4157, 4157, 4202, 4202, 4280], [4282, 4312, 4352, 4352, 4389], [4546, 4546, 4581, 4581, 4672], [4673, 4673, 4708, 4708, 5292], [5293, 5293, 5334, 5334, 5362], [5363, 5363, 5403, 5403, 5431], [5432, 5432, 5486, 5486, 5695], [5696, 5696, 5750, 5750, 5929], [5930, 5930, 5995, 5995, 6233], [6235, 6298, 6337, 6517, 6550], [6552, 6552, 6608, 6608, 6665], [6667, 6667, 6706, 6706, 6749], [6899, 6944, 6971, 6971, 7058], [7060, 7079, 7137, 7162, 7357], [7359, 7390, 7423, 7553, 7858], [7860, 7880, 7921, 7921, 8732], [8734, 8753, 8803, 8803, 9085], [9087, 9087, 9119, 9119, 10533], [11025, 11025, 11118, 11118, 11242], [11458, 11458, 11493, 11518, 11962], [11964, 11964, 12041, 12041, 12186], [12188, 12188, 12224, 12224, 12271], [12484, 12514, 12568, 12593, 13460], [13462, 13462, 13485, 13485, 15453], [15456, 15456, 15477, 15578, 15780]], "test": "untested"}
{"id": "WdlcRf", "name": "I'm having a ball", "author": "Plento", "description": "Actually I'm really really bored.", "tags": ["3d", "blur"], "likes": 9, "viewed": 436, "published": 3, "date": "1585462087", "time_retrieved": "2024-07-30T21:16:05.286371", "image_code": "// Plento\nvec2 R;\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - .5*R.xy)/R.y;\n    vec2 uv2 = u / R;\n    \n    vec3 col = texture(iChannel0, uv2).xyz;\n    vec3 sum = vec3(0);\n    \n    vec2 tuv = vec2(uv2.x-.5, uv2.y - .5);\n    vec2 dTuv = tuv*.21/float(8);\n    \n    uv2 += dTuv*(hash(uv.xy + fract(iTime)) );\n    \n    for(float i = 0.; i < 8.; i++){\n     \tvec3 temp = texture(iChannel0, uv2).xyz;  \n        sum += temp;\n        uv2 -= dTuv;\n    }\n    sum /= 8.;\n    col = mix(col, sum, length(uv*1.6));\n    \n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 R;\n\n#define A iTime*.5\n#define B cos(iTime*.75)*.5\n\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float d = 0.0, t = 0.;\n    vec3 rp=vec3(0);\n\n    for(int i = 0; i < 60; i++){\n        rp = ro + rd*t;\n        d = length(rp) - 1.9;\n        if(abs(d) <= 0.02)break;\n        if(t >= 20.){t = 20.; break;}\n        t += d * .75;\n    }\n\treturn t;\n}\n\nvec3 bg(vec3 rd){\n    vec2 id = floor(rd.xy*10.);\n    float chk = mod(id.x + id.y, 2.);\n    \n    return hash32(id+floor(iTime*2.)) * chk;\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 n, float t){\n    vec3 ld = vec3(0., .6, -.75);\n    \n\tfloat dif = max(dot(ld, n), 0.0);\n    p.xy*=rot(-iTime*.5);\n    \n    p.x -= A;\n    p.y -= B;\n    \n    vec2 id = floor(p.xy*5.);\n    float chk = mod(id.x + id.y, 2.);\n    vec3 mat = vec3(0.8) * (chk+.1);\n    \n    return mix( mat * dif, bg(rd), step(20., t));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - .5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0., .0, -5.);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec3 col = vec3(0);\n    \n    float t = march(ro, rd);\n    vec3 p = ro + rd*t;\n    vec3 norm = normalize(p);\n    \n    rd.x += A;\n    rd.y += B;\n    \n    col = color(p,rd, norm, t);\n     \n    f = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 39, 39, 94], [95, 95, 135, 135, 653]], "test": "untested"}
{"id": "WsXcDB", "name": "Snow Storm", "author": "natethegreat2525", "description": "Simple parallax snow effect made by transforming a simple noise texture from another buffer. To see Buffer A, change the 1 on line 3 to a 0.", "tags": ["particles", "snow"], "likes": 19, "viewed": 794, "published": 3, "date": "1585452729", "time_retrieved": "2024-07-30T21:16:06.040355", "image_code": "#define TIME_SCALE .1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 1\n    vec4 col=vec4(0.);\n    vec2 relCoord = fragCoord;\n    float idst = 1.;\n    for (int i = 0; i < 20; i++) {\n        idst = mod(float(i+1)/20. - iTime*TIME_SCALE, 1.) + .2;\n        relCoord =(fragCoord-iResolution.xy*.5)*(idst*idst) + iResolution.xy*.5;\n        float day = relCoord.y - floor(relCoord.y);\n        float offsX = mod(relCoord.x, 20.);\n        ivec2 pos = ivec2(int(relCoord.x/20.)+i*int(iResolution.y/20.), relCoord.y);\n        vec4 tex = texelFetch(iChannel0, pos, 0);\n        float da = sin(tex.g + relCoord.y*(.03+sin((float(i)+iTime*TIME_SCALE)*3.14*1.61)*0.01)+float(i)*32.32)*10.*.9 + 10.;\n        if (abs(da-offsX) < .5) {\n            if (tex.x > 0.) {\n                float dx = (da-offsX)*2.;\n            \tfloat dy = 2.*(day - .5);\n                float dist = (clamp(length(vec2(dx,dy)),0.5,1.)-.5)*2.;\n                col += 1.-dist;\n            }\n        }\n    }\n    col = max(col, vec4(0.5));\n    fragColor = vec4(col.xyz,1.0);\n#else\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 1) {\n        if (snoise(vec3(fragCoord.x*17.435, fragCoord.y*37.32+1000., 2.4+sin(fragCoord.y*1.)*5.3)) > .5) {\n            fragColor = vec4(1);\n            fragColor.g = snoise(vec3(fragCoord.y*75.34, fragCoord.x*98.4, 6.+sin(iTime)*5.3))*3.14+6.28;\n        }\n        return;\n    }\n    if (fragCoord.y > iResolution.y-1.) {\n        if (snoise(vec3(fragCoord.x*17.435, iTime*37.32+1000., 2.4+sin(iTime*1.)*5.3)) > .5) {\n            fragColor = vec4(1);\n            fragColor.g = snoise(vec3(iTime*75.34, fragCoord.x*98.4, 6.+sin(iTime)*5.3))*3.14+6.28;\n        }\n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,1), 0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WsfcDB", "name": "Bubble Sort", "author": "Plento", "description": "Bubble sort. Pretty much useless but it's fun to look at. It doesn't seem work so well with high speed value settings. Also gets screwed up with different  refresh rates. ", "tags": ["2d", "sort"], "likes": 6, "viewed": 355, "published": 3, "date": "1585440402", "time_retrieved": "2024-07-30T21:16:06.788355", "image_code": "// Plento\nconst int nBars = 35;\nfloat speed = 60.; \nconst float unq = 600.;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n\n    vec2 uv = u / iResolution.xy;\n    \n    vec4 b = texture(iChannel0, uv);\n    \n    vec3 col = vec3(step(b.w/unq, -1.*(uv.y-1.)));\n    float sch = mod(floor(iTime*speed), float(nBars));\n    \n    float id = floor(uv.x * float(nBars));\n    if(id == sch)col *= vec3(1.0, 0., 0.);\n    \n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int nBars = 35;\nfloat speed = 60.; \nconst float unq = 600.;\nvec2 R;\nfloat read(float offset){\n \treturn texture(iChannel0, vec2(offset + 0.001, 0.)).w;\n}\n\nfloat rnd(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = u / R;\n    \n    vec4 b = texture(iChannel0, uv);\n    \n    float cID = mod(floor(iTime*speed), float(nBars));\n    float ratio = 1. / float(nBars);\n    \n    float rs0 = cID * ratio ; \n    float rs1 = (cID + 1.) * ratio ; \n    \n    float i0 = read(rs0);\n    float i1 = read(rs1);\n    \n\tif(i0 < i1){\n\t\tif(uv.x > rs0 && uv.x < rs0 + ratio)\n\t\t\tb.w = i1;\n        else if(uv.x > rs1 && uv.x < rs1 + ratio)\n        \tb.w = i0;\n    } \n    \n    b = vec4(i0, i1, b.z, b.w);\n    \n    float id = floor(uv.x * float(nBars));\n    if(iFrame < 2)b = vec4(floor(rnd(id + 23.34)*unq));\n   \n    f = b;    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 117, 117, 427]], "test": "untested"}
{"id": "wdXyWS", "name": "Fourier Transform Wave", "author": "wyatt", "description": "Click to interact", "tags": ["fourier"], "likes": 9, "viewed": 450, "published": 3, "date": "1585434376", "time_retrieved": "2024-07-30T21:16:07.541342", "image_code": "// Fork of \"Fourier Transform Schrodinger\" by wyatt. https://shadertoy.com/view/ttcGzH\n// 2020-03-28 22:24:07\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 a = A(U);\n    Q = -.5+vec4(a.z,0.5*(a.w+a.z),a.w,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 init (vec2 U) {\n\treturn 1.+vec2(cos(U.x),sin(U.x))*exp(-.01*dot(U-0.5*R,U-0.5*R));\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.y; i++) {\n        if (iFrame < 10) Q.xy += init(vec2(U.x,i)).xy*e(-(w.y-pi)*i);\n        else Q.xy += A(vec2(U.x,i)).zw*e(-(w.y-pi)*i);\n        Q.zw += B(vec2(U.x,i)).zw*e(w.y*i)/R.y;\n    }\n\tQ.zw *= mod(U.x+U.y,2.)*2.-1.;\n    if (length(U-iMouse.xy)<1.&&iMouse.z>0.) Q.zw *= e(1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R (iResolution.xy)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define pi 3.14159265359\nmat2 e (float t) {\n    float c = cos(t),s = sin(t);\n\treturn mat2(c,-s,s,c);\n}", "buffer_b_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.x; i++) {\n        Q.xy += A(vec2(i,U.y)).xy*e(-(w.x-pi)*i);\n        Q.zw += B(vec2(i,U.y)).xy*e(w.x*i)/R.x;\n    }\n    w -= pi;\n    Q.xy *= e(length(w));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 152, 152, 216]], "test": "untested"}
{"id": "3tVXWK", "name": "Basic voronoi with borders", "author": "maksy", "description": "Voronoi patterns according to\nhttps://www.youtube.com/watch?v=l-07BXzNdPw\nhttps://cyangamedev.wordpress.com/2019/07/16/voronoi/", "tags": ["voronoi"], "likes": 5, "viewed": 387, "published": 3, "date": "1585433868", "time_retrieved": "2024-07-30T21:16:08.303305", "image_code": "#define S smoothstep\n\nvec2 N22(vec2 p) {\n\tvec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \t\n    // normalize coordinates ranging from -1. to 1 and fix aspect ratio\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    uv*=4.;\n    \n    // divides the screen into a grid\n    // the id of a grid cell. X and y go from -4 to 4.\n    vec2 id = floor(uv); \n    \n    // inner coordinates of a grid cell\n    vec2 gv = fract(uv);\n    \n    // ####################################\n    // # First pass\n    // ####################################\n       \n    // index of the voronoi cell containing the shading point\n    vec2 cellIndex = vec2(0.);\n    \n    // the center of the voronoi cell\n    vec2 center = vec2(0.0);\n    \n    // Distance to the center\n    float minDist = 8.;  \n    \n    // the grid cell with the closest point\n    vec2 closestGridCell = vec2(0.);\n    \n    // finds which cell contains the closest point to the shading point. \n    // Only 9 cells in the grid must looped through.\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 n = 0.5+sin(N22(id+offset) * iTime)*0.5;\n            \n            float d = length(offset+n - gv);\n            if (d < minDist) {\n                center = offset+n - gv;\n                cellIndex = id+offset;\n                minDist = d;\n                closestGridCell = offset;\n            }\n        }\n    }\n    \n    // ####################################\n    // # Second pass\n    // ####################################\n    \n    // calculates distance to the closest border\n    \n    // performs neighbor search centered at the closest cell instead of\n    // the cell that contains the shading point\n    float borderDist = 8.0;\n    for (float y = -2.; y <= 2.; y++) {\n       for (float x = -2.; x <= 2.; x++) {\n            \n           vec2 offset = closestGridCell + vec2(x, y);\n           vec2 n = 0.5+sin(N22(id+offset)*iTime)*0.5;\n           \n           vec2 r = offset + n - gv;\n           \n           // skip the same cell\n           if (dot(center-r, center-r) > .01) {            \n           \tborderDist = min(borderDist, dot(0.5*(center+r),normalize(r-center)));\n           }\n        }\n     }\n    \n    vec3 col = vec3(minDist);\n       \n    if (cellIndex.x > 3.) {\n    \tcol = vec3(0.70, 0.62, 0.85);\n    }\n    \n    else if (cellIndex.x > -1.) {\n        col = vec3(0.99, 0.64, 0.66);\n    }\n    \n    else if (cellIndex.x > -5.) {\n        col = vec3(0.47, 0.87, 0.47);\n    }\n    \n     else if (cellIndex.x > -9.) {\n        col = vec3(0.46, 0.62, 0.80);\n    }\n    \n    // edges  \n    col = mix(vec3(0.2, 0.2, 0.2), col, S(0.01, 0.06, borderDist));\n    \n    // isolines\n    col -= abs(sin(100.0*minDist))*0.1;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 163], [165, 165, 222, 297, 2927]], "test": "untested"}
{"id": "3sXyWS", "name": "Leonardo Polyhedra", "author": "mla", "description": "Archimedean polyhedra & duals given the Leonardo treatment.\n\nThe duals are nicer (change over with 'd' key). 't' allows either auto cycling or polyhedron selection with <left>, <right>. Other controls see code.\n\nRecompile to change angles P,Q,R.", "tags": ["dual", "polyhedra", "leonardo"], "likes": 20, "viewed": 399, "published": 3, "date": "1585433512", "time_retrieved": "2024-07-30T21:16:09.351502", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Matthew Arcus, 2020\n//\n// Leonardo Polyhedra - Archimedean Polyhedra & Duals.\n//\n// Controls:\n// <mouse>: rotation\n// <up>/<down>: move in/out\n// <page up>/<page down>: cycle through polyhedra (if 't' pressed)\n// <left>/<right>: change width of Leonardo frame\n// d: show dual or normal polyhedron\n// f: show fundamental region\n// x: swap Q and R angles\n// s: soft shadow\n// t: cycle through polyhedra\n// a: ambient occlusion\n// r: autorotation\n// c: slice at x = 0\n// l: leonardo effect\n// e: show all dual edges\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The fundamental triangle:\n// (2,2,x): prism\n// (2,3,3): tetrahedron\n// (2,3,4): cube\n// (2,3,5): icosahedron\n\nint P = 2, Q = 3, R = 5;\n\n// Number of iterations of folding loop\n// 5 iterations is enough to get up to (2 3 5) or (2 2 10)\nint NFOLDS = 5;\n\nfloat AA = 1.0;\n\nfloat lwidth = 0.04; // Width of Leonardo frame\nbool dorotate = true;\nbool doleonardo = true;\nbool dodualfaces = false;\nbool dofaces = false;\nbool swap = false;\nbool region = true;\nbool slice = true;\n\nconst vec3 Face0Color = vec3(0.8,0,0);\nconst vec3 Face1Color = vec3(0.8,0.7,0);\nconst vec3 Face2Color = vec3(0.1,0,0.6);\nconst vec3 SnubColor = vec3(0,0.5,0.0);\nconst vec3 DualColor0 = vec3(0.7,0.7,0.1);\nconst vec3 DualColor1 = vec3(0.1,0.1,0.1);\n\nvec3 colors[] = vec3[]\n  (Face0Color,\n   Face1Color,\n   Face2Color,\n   SnubColor,\n   DualColor0,\n   DualColor1,\n   vec3(1));\n\nconst float PI\t= 3.14159265359;\nconst float TWOPI = 2.0 * PI;\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\n// Approximate equality. Used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat edgedistance(vec3 pos, vec3 X) {\n  //assert(eq(length(X),1.0));  // Use dot(X,X)?\n  return length(pos-dot(pos,X)*X);\n}\n\nfloat raydistance(vec3 pos, vec3 q, vec3 r) {\n  float s = max(0.0, dot(pos-q,r));\n  return distance(pos,q+s*r);\n}\n\n// Perpendicular distance from p to segment ab\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat linedist(vec3 pos, vec3 a, vec3 b) {\n  vec3 pa = pos - a;\n  vec3 ba = b - a;\n  float h = dot(pa, ba) / dot(ba, ba);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a,max(b,c));\n}\n\nfloat min3(float a, float b, float c) {\n  return min(a,min(b,c));\n}\n\n// Geometric globals\n\n// A,B,C are the mirror planes\n// a,b,c are triangle corners or trihedron edge vectors or face normals\nvec3 A,B,C,a,b,c;\nvec3 tri2bary;\n\n// Could use a matrix here\nvec3 applybary(vec3 bary, vec3 p, vec3 q, vec3 r) {\n  return bary.x*p+bary.y*q+bary.z*r;\n}\n\nvec3 refla(vec3 p) { return p - 2.0*dot(p,A)*A; } // Fold about A plane\nvec3 reflb(vec3 p) { return p - 2.0*dot(p,B)*B; } // Fold about B plane\nvec3 reflc(vec3 p) { return p - 2.0*dot(p,C)*C; } // Fold about C plane\n\n// Planes are represented as vec4s: (a,b,c,d) where p = (x,y,z) is\n// in plane just when (x,y,z,-1).(a,b,c,d) = 0\n\n// For our vec4 plane representations\nvec4 refla(vec4 p) { return vec4(refla(p.xyz),p.w); }\nvec4 reflb(vec4 p) { return vec4(reflb(p.xyz),p.w); }\nvec4 reflc(vec4 p) { return vec4(reflc(p.xyz),p.w); }\n\nvoid init() {\n  if (swap) {\n    int t = Q; Q = R; R = t;\n  }\n  // Setup folding planes\n  float p = PI/float(P);\n  float q = PI/float(Q);\n  float r = PI/float(R);\n  A = vec3(1,0,0);\n  // A.B = -cos(p)\n  B = vec3(-cos(p),sin(p),0);\n  // A.C = -cos(r)\n  float x = -cos(r);\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  float y = -(cos(p)*cos(r)+cos(q))/sin(p);\n  // |C| = 1\n  float z = sqrt(1.0-x*x-y*y);\n  C = vec3(x,y,z);\n  a = cross(B,C);\n  b = cross(C,A);\n  c = cross(A,B);\n  // Weights to convert trilinear (distance from region planes) to barycentric\n  // (weighted sum of triangle vertices).\n  tri2bary = vec3(length(a),length(b),length(c));\n  a = normalize(a);\n  b = normalize(b);\n  c = normalize(c);\n}\n\n// Could use an ivec3 and count different types of flip\nvec3 fold(vec3 pos, out int flips) {\n  // We want to know the number of actual reflections made\n  // so keep track of that in flips.\n  flips = 0;\n  for (int i = 0; i < NFOLDS; i++) {\n    float k = dot(pos,A);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*A;\n    k = dot(pos,B);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*B;\n    k = dot(pos,C);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*C;\n  }\n  return pos;\n}\n\nvec3 fold(vec3 pos) {\n  int flips;\n  return fold(pos,flips);\n}\n\n  // p is the \"triangle point\"\n// pa,pb,pc is its reflection in the 3 walls\nvec3 p,pa,pb,pc;\n\n// These vec4s represent planes, xyz is a normal,\n// w is -ve distance from the origin, so we can find\n// distance of p from plane q with dot(vec4(p,1),q):\n//\n// aplane, bplane, cplane are the face planes\n// adjacent regions (across planes A,B,C respectively).\n\nvec4 aplane, bplane, cplane;\n\nvoid initp(vec3 tri) {\n  p = applybary(tri2bary*tri,a,b,c);\n  if (true) {\n    float scale = min3(edgedistance(p,A),\n                       edgedistance(p,B),\n                       edgedistance(p,C));\n    p /= scale;\n  }\n  aplane = vec4(a,dot(p,a)); // Face planes\n  bplane = vec4(b,dot(p,b));\n  cplane = vec4(c,dot(p,c));\n  pa = refla(p);\n  pb = reflb(p);\n  pc = reflc(p);\n}\n\nvec3 aa,bb,cc;\nvec3 a0,a1,b0,b1,c0,c1;\nvec3 paa,pbb,pcc;\nvec3 ab,ac,ba,bc,ca,cb;\n\nvoid scenesetup() {\n  aa = a/dot(p,a);\n  bb = b/dot(p,b);\n  cc = c/dot(p,c);\n\n  a0 = refla(reflb(p));\n  a1 = refla(reflc(p));\n  b0 = reflb(reflc(p));\n  b1 = reflb(refla(p));\n  c0 = reflc(refla(p));\n  c1 = reflc(reflb(p));\n\n  paa = normalize(pa); //pa/dot(pa,pa);\n  pbb = normalize(pb); //pb/dot(pb,pb);\n  pcc = normalize(pc); //pc/dot(pc,pc);\n\n#if 1\n  // These vectors give a cut at right angles to the\n  // face, rather than the edge planes.\n  ba = normalize(cross(a,cross(a,b)));\n  ca = normalize(cross(a,cross(a,c)));\n  ab = normalize(cross(b,cross(b,a)));\n  cb = normalize(cross(b,cross(b,c)));\n  ac = normalize(cross(c,cross(c,a)));\n  bc = normalize(cross(c,cross(c,b)));\n#else\n  ba = normalize(a-b);\n  ca = normalize(a-c);\n  ab = normalize(b-a);\n  cb = normalize(b-c);\n  ac = normalize(c-a);\n  bc = normalize(c-b);\n#endif  \n}\n\nfloat leonardo(float d, float da, float dba, float dca) {\n  float d1 = da; \n  d1 = max(d1,-da-lwidth); // The inner plane - now we have a 'plate'\n  d1 = max(d1,max(-dba,-dca)); // A single face\n  d = min(d,max(d1,dba-lwidth));\n  d = min(d,max(d1,dca-lwidth));\n  return d;\n}\n\nfloat faces(vec3 pos) {\n  vec4 pos4 = vec4(pos,-1);\n  // Signed distance from 3 planes\n  float d = 1e8;\n  float da = dot(pos4,aplane); // The main plane\n  float db = dot(pos4,bplane);\n  float dc = dot(pos4,cplane);\n  if (!doleonardo) return max(da,max(db,dc));\n  float dba = dot(pos-p,ba), dca = dot(pos-p,ca);\n  d = leonardo(d,da,dba,dca);\n  float dcb = dot(pos-p,cb), dab = dot(pos-p,ab);\n  d = leonardo(d,db,dcb,dab);\n  float dac = dot(pos-p,ac), dbc = dot(pos-p,bc);\n  d = leonardo(d,dc,dac,dbc);\n  return d;\n}\n\nvec3 triplanar(vec3 p, vec3 n, sampler2D samp) {\n  vec3 texX = texture(samp, p.zy).xyz;\n  vec3 texY = texture(samp, p.xz).xyz;\n  vec3 texZ = texture(samp, p.xy).xyz;\n  return texX * n.x + texY * n.y + texZ * n.z;\n}\n\nfloat colorfaces(vec3 pos, vec3 n, inout vec3 col) {\n  vec4 pos4 = vec4(pos,-1);\n  // Distance from 3 planes\n  float d0, d = -1e8;\n  d0 = dot(pos4,aplane);\n  if (d0 > d) { d = d0; col = colors[0]; }\n  d0 = dot(pos4,bplane);\n  if (d0 > d) { d = d0; col = colors[1]; }\n  d0 = dot(pos4,cplane);\n  if (d0 > d) { d = d0; col = colors[2]; }\n  n = fold(n);\n  //col *= length(triplanar(pos,n,iChannel2).rgb);\n  col = triplanar(pos,n,iChannel2).rgb;\n  //col *= length(texture(iChannel2,pos.xy).rgb);\n  return d;\n}\n\nvoid colorfaces0(vec3 pos, inout float d, inout int col) {\n  vec4 pos4 = vec4(pos,-1);\n  // Distance from 3 planes\n  if (abs(dot(pos4,aplane)) < 1e-4) col = 0;\n  if (abs(dot(pos4,bplane)) < 1e-4) col = 1;\n  if (abs(dot(pos4,cplane)) < 1e-4) col = 2;\n  col = 3;\n}\n\nbool alledges = true;\n\nfloat dualfaces(vec3 pos) {\n  //assert(eq(length(p),1.0));\n  float r = 1.0/length(p);\n  float d = 1e8; // Nice 'n' easy, p defines surface\n  float d0 = dot(pos,p)-r;\n  if (!doleonardo) return d0;\n  // The 'Leonardo look' - clip by a plane parallel to faceplane\n  // This should really be a plane orthogonal to dual face.\n  float eps = 1e-3;\n#if 0\n  vec3 xplane = normalize(cross(p,cross(p,A)));\n  vec3 yplane = normalize(cross(p,cross(p,B)));\n  vec3 zplane = normalize(cross(p,cross(p,C)));\n#else\n  vec3 xplane = A;\n  vec3 yplane = B;\n  vec3 zplane = C;\n#endif\n  if (alledges || dot(p,A) > eps) d = min(d,max(d0,dot(pos,xplane)-lwidth));\n  if (alledges || dot(p,B) > eps) d = min(d,max(d0,dot(pos,yplane)-lwidth));\n  if (alledges || dot(p,C) > eps) d = min(d,max(d0,dot(pos,zplane)-lwidth));\n  d = max(d,-d0-lwidth);\n  return d;\n}\n\nfloat colordualfaces(vec3 pos, vec3 n, bool parity, inout vec3 col) {\n  n = fold(n);\n  col = triplanar(pos,n,iChannel2);\n  //col = texture(iChannel2,pos.xy).rgb;\n  return dualfaces(pos);\n}\n\nfloat scene(vec3 pos) {\n  float d = 1e8;\n  if (dodualfaces) d = min(d,dualfaces(pos));\n  if (dofaces) d = min(d,faces(pos));\n  return d;\n}\n\nfloat colorscene(vec3 pos, vec3 n, bool parity, out vec3 col) {\n  float d = 1e8, d0;\n  vec3 col0;\n  if (dodualfaces) {\n    d0 = colordualfaces(pos,n,parity,col0);\n    if (d0 < d) { d = d0; col = col0; }\n  }\n  if (dofaces) {\n    d0 = colorfaces(pos,n,col0);\n    if (d0 < d) { d = d0; col = col0; }\n  }\n  return d;\n}\n\nfloat polyhedron(vec3 pos) {\n  vec3 pos0 = pos;\n  pos = fold(pos);\n  float d = 1e8;\n  d = min(d,scene(pos));\n  if (region) {\n    d = max(d,dot(pos0,A));\n    d = max(d,dot(pos0,B));\n    d = max(d,dot(pos0,C));\n  }\n  return d;\n}\n\nvec3 getColor(vec3 pos,vec3 n){\n  vec3 pos0 = pos;\n  int flips;\n  pos = fold(pos,flips);\n  vec3 col = vec3(0,0,1);\n  float d = colorscene(pos,n,flips%2==0,col);\n  if (region) {\n    float d0 = d;\n    d = max(d,dot(pos0,A));\n    d = max(d,dot(pos0,B));\n    d = max(d,dot(pos0,C));\n    if (d != d0) col = colors[6];\n  }\n  return col;\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p) {\n  float d = polyhedron(p);\n  if (slice) d = max(d,p.x);\n  return d;\n}\n\n// We should be able to do this analytically from the plane hit.\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                        map(p + e.yxy) - map(p - e.yxy),\n                        map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat maxdist = 5.0;\nfloat march(in vec3 ro, in vec3 rd) {\n  const float precis = 0.001;\n  float t = 0.1;\n  float res = -1.0;\n  for (int i = 0; i < 100; i++) {\n    if (t > maxdist) return -1.0;\n    float h = map(ro+rd*t);\n    h = min(h,0.5);\n    t += 0.8*h;\n    if (h < precis) break;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 circuit[] = vec3[]\n  (vec3(1,1,1),vec3(1,1,1),vec3(1,0,0),vec3(1,0,0),\n   vec3(1,1,0),vec3(1,1,0),vec3(0,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,1,1),vec3(0,0,1),vec3(0,0,1),\n   vec3(1,0,1),vec3(1,0,1),vec3(1,0,0),vec3(1,0,0));\n\nconst int nsteps = circuit.length();\n\nvec3 gettri(float t) {\n  int i = int(floor(t))%nsteps;\n  return mix(circuit[i],circuit[(i+1)%nsteps],mod(t,1.0));\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\n// softshadow from iq.\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax, float w) {\n  float t = mint;\n  float res = 1.0;\n  for (int i = 0; i < 200; i++) {\n    float h = map(ro + t*rd);\n    res = min(res, h/(w*t));\n    t += clamp(h, 0.01*t, max(0.5,0.1*t));\n    if (res < -1.0 || t > tmax) break;\n  }\n  res = max(res,-1.0); // clamp to [-1,1]\n  res = 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n  return res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float t ){\n  float dd, hr, totao = 0.0;\n  float sca = 1.0;\n  vec3 aopos; \n  for( int aoi=0; aoi<5; aoi++ ) {\n    hr = 0.005 + 0.05*float(aoi);\n    aopos =  nor * hr + pos;\n    totao += -(map(aopos)-hr)*sca;\n    sca *= 0.75;\n  }\n  return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  bool doao = !key(CHAR_A);\n  bool doshadow = !key(CHAR_S);\n  doleonardo = !key(CHAR_L);\n  dorotate = !key(CHAR_R);\n  dodualfaces = !key(CHAR_D);\n  dofaces = !dodualfaces;\n  swap = key(CHAR_X);\n  region = key(CHAR_F);\n  slice = key(CHAR_C);\n  alledges = key(CHAR_E);\n  vec2 p = fragCoord.xy / iResolution.xy;\n  float camera = 3.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));  \n  lwidth *= exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)));\n  maxdist = camera + 2.0;\n  vec3 ro = vec3(0.0, 0.0, -camera);\n  ro = transform(ro);\n  vec3 li = normalize(vec3(0.5, 2.8, -3.0));\n  li = transform(li);\n  li = normalize(li);\n  init();\n  int tindex = keycount(KEY_PAGE_UP)-keycount(KEY_PAGE_DOWN);\n  vec3 tri = !key(CHAR_T) ? gettri(0.25*iTime) : circuit[mymod(2*tindex,nsteps)];\n  initp(tri);\n  scenesetup();\n  vec3 aacol = vec3(0);\n  vec3 bgcol = vec3(0.2 - 0.2*p.y);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 p = (2.0*(fragCoord+vec2(i,j)/AA) - iResolution.xy)/iResolution.y;\n      vec3 col = bgcol;\n      vec3 rd = vec3(p, 3.0);\n      rd = transform(rd);\n      rd = normalize(rd);\n      float t = march(ro, rd);\n      if (t > 0.0) {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n        float ambient = 0.2;\n        float ao = !doao ? 1.0 : calcAO(pos,n,t);\n        float softshadow = !doshadow ? 1.0 : softshadow(pos,li,0.1,4.0,0.01);\n        float diffuse = clamp(dot(n, li), 0.0, 1.0);\n        col = getColor(pos,n) * (ambient*ao+diffuse*softshadow);\n        //col = mix(col,bgcol,0.4*t/maxdist);\n      }\n      aacol += col;\n    }\n  }\n  aacol = pow(aacol/(AA*AA), vec3(0.4545));\n  if (alert) aacol.x = 1.0;\n  fragColor = vec4(aacol, 1.0);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1615, 1615, 1639, 1639, 1668], [1670, 1722, 1749, 1749, 1777], [1779, 1779, 1817, 1866, 1903], [1905, 1905, 1950, 1950, 2018], [2020, 2067, 2106, 2106, 2247], [2249, 2249, 2291, 2291, 2417], [2419, 2419, 2458, 2458, 2486], [2488, 2488, 2527, 2527, 2555], [2716, 2743, 2794, 2794, 2833], [2835, 2835, 2855, 2855, 2884], [2885, 2907, 2927, 2927, 2956], [2957, 2979, 2999, 2999, 3028], [3167, 3205, 3225, 3225, 3258], [3259, 3259, 3279, 3279, 3312], [3313, 3313, 3333, 3333, 3366], [3368, 3368, 3381, 3381, 4076], [4078, 4134, 4170, 4266, 4570], [4572, 4572, 4593, 4593, 4634], [5022, 5022, 5044, 5044, 5397], [5481, 5481, 5500, 5500, 6312], [6314, 6314, 6371, 6371, 6587], [6589, 6589, 6612, 6612, 7103], [7105, 7105, 7153, 7153, 7319], [7321, 7321, 7373, 7373, 7825], [7827, 7827, 7885, 7885, 8089], [8114, 8114, 8141, 8172, 8944], [8946, 8946, 9015, 9015, 9134], [9136, 9136, 9159, 9159, 9274], [9276, 9276, 9339, 9339, 9590], [9592, 9592, 9620, 9620, 9818], [9820, 9820, 9851, 9851, 10152], [10154, 10252, 10288, 10288, 10340], [10342, 10342, 10364, 10364, 10434], [10436, 10501, 10529, 10529, 10739], [10762, 10762, 10799, 10799, 11043], [11045, 11045, 11072, 11072, 11401], [11675, 11675, 11697, 11697, 11790], [12365, 12365, 12385, 12385, 12445], [12447, 12447, 12472, 12472, 12520], [12522, 12522, 12545, 12545, 12577], [12579, 12602, 12671, 12671, 13003], [13005, 13005, 13055, 13055, 13319], [13321, 13321, 13346, 13386, 13441], [13443, 13443, 13500, 13500, 15227]], "test": "untested"}
{"id": "wtVXR3", "name": "GCD as random", "author": "Arseny", "description": "GCD", "tags": ["2d"], "likes": 2, "viewed": 268, "published": 3, "date": "1585428327", "time_retrieved": "2024-07-30T21:16:10.222174", "image_code": "// \"ShaderToy Tutorial - Value Noise\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/zXsWftRdsvU\n\nfloat gcd(vec2 p){\n    p = abs(p);\n    float eps = 1.;\n    for (float i = 0.; i < 1000. && p.x > eps; i++){\n        p.y = mod(p.y, p.x);\n        p.xy = p.yx;\n    }\n    return p.x / eps;\n}\n\nfloat N21(vec2 p) {\n    //return fract(sin(p.x*100.+p.y*6574.)*5647.);\n    return gcd(p);\n}\n\nfloat SmoothNoise(vec2 uv) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    \n    // don't make octaves exactly twice as small\n    // this way the pattern will look more random and repeat less\n    c += SmoothNoise(uv*8.2)*.5;\n    c += SmoothNoise(uv*16.7)*.25;\n    c += SmoothNoise(uv*32.4)*.125;\n    c += SmoothNoise(uv*64.5)*.0625;\n    \n    c /= 2.;\n    \n    return c;\n}\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x*a.y, a.y * a.z));\n}\n\nfloat slow_voronoi(vec2 uv, float t){\n    float m = 0.;\n    float minDist = 100.;\n    for (float i = 0.; i < 50.; i++){\n        vec2 n = N22(vec2(i + 1.));\n        vec2 p = sin(n * t);\n\n        float d = length(uv - p);\n        m += smoothstep(.02, .01, d);\n\n        if (d < minDist){\n            minDist = d;\n        }\n    }\n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n\n    //uv += iTime*.1;\n    \n    float t = iTime * 0.2 + 10.;\n    \n    vec3 col = vec3(0);\n    \n    col = vec3(SmoothNoise2(uv * 5.));\n    \n    //col = vec3(polargreed(uv));\n    \n    //col = vec3(minDist);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVXR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[268, 268, 286, 286, 455], [457, 457, 476, 527, 548], [550, 550, 578, 578, 897], [899, 899, 928, 928, 1262], [1264, 1264, 1281, 1281, 1413], [1415, 1415, 1452, 1452, 1762], [1764, 1764, 1821, 1821, 2136]], "test": "untested"}
{"id": "3sXcDS", "name": "Blue's Glitchy Wormhole", "author": "BlueVelvetCake", "description": "An experimental wormhole where the exit is a white hole.\nDoesn't work exactly as intended, but is still cool.", "tags": ["pbr"], "likes": 1, "viewed": 336, "published": 3, "date": "1585422751", "time_retrieved": "2024-07-30T21:16:10.973166", "image_code": "vec3 cameraPos = vec3(5, 0, 0);\nfloat dist = 45.;\nfloat ang = 0.;\nfloat fov = 1.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfCoords = fragCoord - (iResolution.xy / 2.); // UV Coordinates centered on zero\n    vec2 normalUv = halfCoords / iResolution.yy; \n    \n    ang = iMouse.x / 100.;\n    dist = iMouse.y / 5.;\n    \n    if (iMouse.xy == vec2(0)) { dist = 30.; }\n    \n    vec3 orbitPos = vec3(-cos(ang) * dist, dist / 3., -sin(ang) * dist);\n    \n    vec3 startPos = cameraPos + orbitPos; // Starting position and starting velocity\n    vec3 startVel = toSphere(normalUv.x * fov + ang, normalUv.y * fov - 0.3);\n    \n    traceResult mainResult = trace(startPos, startVel); // Pass to trace function\n\n    fragColor = mainResult.hitColor; // Output to screen\n}", "image_inputs": [], "common_code": "struct traceResult { vec3 hitPos; vec4 hitColor; };\n\nvec3 bSpherePos = vec3(5, 0, 0);\nvec3 wSpherePos = vec3(-5, 0, 0);\n    \ntraceResult trace( vec3 startPos, vec3 startVel )\n{\n    \n \tvec3 pos = startPos;\n    vec3 vel = startVel;\n    vec4 color = vec4(vec3(0), 1);\n    float life = 0.;\n    \n    while( life < 500. )\n    {\n        \n        bSpherePos = vec3(cos(iTime), 0, sin(iTime))\n        \n        float bSphereDist = max(distance(pos, bSpherePos), 0.01);\n        float wSphereDist = max(distance(pos, wSpherePos), 0.01);\n        float planeDist = pos.y + 10.;\n        \n        float minDist = min(min(bSphereDist, wSphereDist), planeDist);\n        \n        pos += vel * (minDist / 2.);\n        life += 1.;\n        \n        vec3 bForce = normalize( bSpherePos - pos ) * 0.05 / pow( length( bSpherePos - pos ), 2. );\n        vec3 wForce = normalize( wSpherePos - pos ) * 0.05 / pow( length( wSpherePos - pos ), 2. );\n        vel = normalize(vel + bForce + wForce * minDist);\n\n        if( planeDist < 0.01 )\n        {    \n            \n            color = vec4(1);\n            \n        \tif( mod(pos.x, 8.) > 4. && mod(pos.z, 8.) > 4. )\n            {\n                color = vec4(vec3(0), 1);\n                \n                if( pos.x > 0. ){ color = vec4(vec3(1, 0, 0), 1); }\n                \n            }\n        }  \n        else if ( bSphereDist <= 0.1 )\n        {\n         \n            vec3 relative = pos - bSpherePos;\n            pos = wSpherePos + relative;\n            \n        }\n        else if ( length(pos) > 300. ) {\n            \n            color = vec4(vec3(0.3), 1); \n            break;\n        \n        }\n            \n    }\n    \n    return traceResult( pos, color );\n    \n}\n\nvec3 toSphere( float azimuth, float inclination )\n{\n    return vec3(\n        cos(inclination) * cos(azimuth),\n        sin(inclination),\n        cos(inclination) * sin(azimuth)\n  );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 140, 140, 784]], "test": "untested"}
{"id": "WdXyWS", "name": "Blue's Gravitational Lensing", "author": "BlueVelvetCake", "description": "My first ray-marching shader! Sorry for my bad coding.\nRays that go near the black hole exhibit a force proportional to the inverse square of their distance from it.\nRays can get stuck inside of the black hole and expire, making the event horizon visible.", "tags": ["pbr"], "likes": 2, "viewed": 431, "published": 3, "date": "1585418682", "time_retrieved": "2024-07-30T21:16:11.737123", "image_code": "vec3 cameraPos = vec3(0, 0, 0);\nfloat dist = 45.;\nfloat ang = 0.;\nfloat fov = 1.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfCoords = fragCoord - (iResolution.xy / 2.); // UV Coordinates centered on zero\n    vec2 normalUv = halfCoords / iResolution.yy; \n    \n    ang = iMouse.x / 100.;\n    dist = iMouse.y / 5.;\n    \n    if (iMouse.xy == vec2(0)) { dist = 30.; }\n    \n    vec3 orbitPos = vec3(-cos(ang) * dist, dist / 3., -sin(ang) * dist);\n    \n    vec3 startPos = cameraPos + orbitPos; // Starting position and starting velocity\n    vec3 startVel = toSphere(normalUv.x * fov + ang, normalUv.y * fov - 0.3);\n    \n    traceResult mainResult = trace(startPos, startVel); // Pass to trace function\n\n    fragColor = mainResult.hitColor; // Output to screen\n}", "image_inputs": [], "common_code": "struct traceResult { vec3 hitPos; vec4 hitColor; };\n\nvec3 spherePos = vec3(0, 0, 0);\n    \ntraceResult trace( vec3 startPos, vec3 startVel )\n{\n    \n \tvec3 pos = startPos;\n    vec3 vel = startVel;\n    vec4 color = vec4(vec3(0), 1);\n    float life = 0.;\n    \n    while( life < 500. )\n    {\n        \n        float sphereDist = max(distance(pos, spherePos) - 1., 0.1);\n        float planeDist = pos.y + 10.;\n        \n        float minDist = min(sphereDist, planeDist);\n        \n        pos += vel * (minDist);\n        life += 1.;\n        \n        vec3 force = normalize( spherePos - pos ) * 0.5 / pow( length(spherePos - pos), 2. );\n        vel = normalize(vel + force * minDist);\n\n        if( planeDist < 0.01 )\n        {    \n            \n            color = vec4(1);\n            \n        \tif( mod(pos.x, 8.) > 4. && mod(pos.z, 8.) > 4. )\n            {\n                color = vec4(vec3(0), 1);\n            }\n        }  \n        else if ( length(pos) > 300. ) {\n            \n            color = vec4(vec3(0.5, 0.4, 1), 1); \n            break;\n        \n        }\n    }\n    \n    return traceResult( pos, color );\n    \n}\n\nvec3 toSphere( float azimuth, float inclination )\n{\n    return vec3(\n        cos(inclination) * cos(azimuth),\n        sin(inclination),\n        cos(inclination) * sin(azimuth)\n  );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 140, 140, 784]], "test": "untested"}
{"id": "tssyRM", "name": "Kunai[MyFirstRayMarching]", "author": "Arseny", "description": "Kunai", "tags": ["raymarching"], "likes": 4, "viewed": 325, "published": 3, "date": "1585415724", "time_retrieved": "2024-07-30T21:16:12.631731", "image_code": "// template copied form inigo quilez - iq/2019\n\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n\n\n#define AA 2\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdOct(in vec3 p){\n    //vec3 n = normalize(vec3(1. / 3.));\n    return dot(vec3(0.57735), abs(p)) - 0.057735;\n    //return dot(vec3(1.), p) - r;\n}\n\nfloat sdTransOct(in vec3 p, in float a, in float b, in float h){\n    vec3 n = normalize(cross(vec3(a, 0, 0) - vec3(0, 0, b), vec3(0, h, 0) - vec3(0, 0, b)));\n    return dot(n, abs(p)) - a * n.x;\n}\n\nfloat sdKunaiSpear(in vec3 p, in float fl, in float bl, in float w, in float h, in float sh){\n    p.xy = abs(p.xy);\n    vec3 A = vec3(0, h, sh);\n    vec3 B = vec3(0, 0, fl);\n    vec3 C = vec3(w, 0, 0);\n    vec3 n = normalize(cross(B - A, C - A));\n    //float d1 = dot(n, p) - fl * n.z;\n    //float d1 = (p.z < fl) ? dot(n, p) - fl * n.z : 0.;\n    float d1 = dot(n, p) - fl * n.z;\n    vec3 D = vec3(0, 0, -bl);\n    n = normalize(cross(C - A, D - A));\n    //d1 = (p.z > -bl) ? max(d1, dot(n, p) + bl * n.z) : d1;\n    d1 = max(d1, dot(n, p) + bl * n.z);\n    d1 = (p.z < sh && p.z > -0.1) ? mix(d1, smin(d1, length(p.xy), 0.04), (sh - p.z) / bl) : d1;\n    return d1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdKunaiHandle(in vec3 p, in float k, in float w, in float r){\n    p.yz = p.zy;\n    float y = p.y;\n    p.y = (y>0.&&y< k * w)?fract(p.y / w) * w - w / 2.:y - w / 2.;\n    p.y = (y>k * w)?y-k * w - w / 2.:p.y;\n    //if (y < 0.) return y;\n    return sdTorus(p, vec2(r, w));\n}\n\nfloat sdKunai(in vec3 p, in float fl, in float bl, in float w, in float h, in float sh){\n    float d = sdKunaiHandle(-p + vec3(0, 0, 0.01), 20., 0.01, 0.02);\n    d = min(d, sdKunaiSpear(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    d = min(d, sdTorus(p + vec3(0, 0, 0.25), vec2(0.04, 0.02)));\n    //d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    return d;\n}\n\n//float sdTransOct(in vec3 p, in vec3\n\nvec4 map( in vec3 p, float time )\n{\n    //float d = sdOct( p * 1.1) / 1.1;\n    //float d = sdTransOct(p, 0.1, 0.3, 0.1);\n    //float d = sdKunai(p, 0.4, 0.1, 0.1, 0.03, 0.05);\n    //float d = sdTorus(p, vec2(0.2, 0.1));\n    //float d = sdKunaiHandle(-p + vec3(0, 0, 0.01), 20., 0.01, 0.02);\n    float d = sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05);\n    //d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    d = min(d, length(p.xy));\n    //float d = sdSphere( p, 0.1 );\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    float tmax = 2.0;\n    float t    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 10.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        if( h.x<0.0001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/30.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        vec3 ro = ta + vec3( 0.5*cos(an), 0.5, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            col = 0.5 + 0.5*nor;\n        }\n        \n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 156, 156, 249], [251, 251, 292, 292, 318], [320, 320, 343, 384, 471], [473, 473, 537, 537, 669], [671, 671, 764, 764, 1335], [1337, 1337, 1370, 1370, 1435], [1437, 1437, 1504, 1504, 1714], [1716, 1716, 1804, 1804, 2109], [2150, 2150, 2185, 2440, 2681], [2711, 2711, 2758, 2758, 2967], [2969, 2969, 3026, 3026, 3291], [3293, 3293, 3368, 3368, 3679], [3681, 3681, 3738, 3738, 3999], [4001, 4001, 4053, 4053, 4230]], "test": "untested"}
{"id": "wslcRs", "name": "First Shader openroomxyz", "author": "openroomxyz", "description": "I am learning a lot to follow", "tags": ["learning"], "likes": 1, "viewed": 339, "published": 3, "date": "1585402328", "time_retrieved": "2024-07-30T21:16:13.404665", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,sin(uv.x * 100.0),4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 310]], "test": "untested"}
{"id": "tdlyRs", "name": "Day 100", "author": "jeyko", "description": "potato!!!!!!", "tags": ["mdtmjvm"], "likes": 11, "viewed": 418, "published": 3, "date": "1585402008", "time_retrieved": "2024-07-30T21:16:14.508713", "image_code": "// hyperbolic tiling from this tutorial http://roy.red/folding-tilings-.html#folding-tilings \n// spiral zoom from Shane\n// aa from Fabrice \n\n// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),2.1)*0.4;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*2.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    \n    fragColor.r *= 0.97 + dot(uvn,uvn)*0.6;\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    fragColor = pow(fragColor, vec4(0.4545));\n    \n    //fragColor.g *= 1. + uv.x*0.01;\n    //fragColor.g *= 1. + uv.t*0.05;\n    \n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI acos(-1.)\n\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm 170.\n\n#define tick (60./bpm)\n\n#define beat tick\n#define bar  beat*4.\n#define hbar  bar/2.\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n\n\n\n", "buffer_a_code": "\n\n\n\nvoid fold(inout vec2 p, vec2 dir,inout int n){\n    float dt = dot(p,dir);\n    if (dt<0.) {\n        p-=2.*dt*dir;\n        n++;\n    }\n}\nvec2 cInverse(vec2 z, vec2 center, float radius){\n    z -= center;\n    return z*radius*radius/dot(z,z) + center;\n}\nvoid fold_circle(inout vec2 z, vec2 c, float r, inout int n) {\n    if (distance(z,c)>r) return;\n    z = cInverse(z,c,r);\n    n++;\n}\nvec3 drawCircle(vec2 z,vec2 c,float r) {\n    return vec3(smoothstep(distance(z,c)-r,.01,0.));\n}\nvoid doFolds(inout vec2 z,vec2 c,float r,inout int n) {              \n    fold(z,vec2(1,0),n);\n    fold(z,vec2(0,1.),n);\n    fold_circle(z,c,r,n);\n}\nfloat xor(float a, float b){return float(int(a) | int(b));}\n\n// Standard spiral zoom.\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase){\n\t\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\t//return vec2(a*n + log(d)*spiral, -log(d)*zoom + a) + phase;\n    // Equivalent to the line above. Fabrice tidied it up. I'd imagine the grouped\n    // operations might make it a little quicker, but don't quote me on that. :)\n    return mat2(n, 2, spiral,-zoom)*vec2(a, log(d)) + phase;\n\n}\n\nvec3 color(vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 3.4;\n    int n=0;\n    vec2 invCent=vec2(1.); float invRad=1.39 - length(uv)*0.2;\n    vec3 color = vec3(1);\n    \n    uv = spiralZoom(uv, vec2(-.1), 4., 3.14159*.1,0.9, vec2(-4, 4)*iTime*.125);\n\n    \n    vec2 suv = uv;\n    float md = 1.;\n    vec2 id = floor(uv/md);\n    uv = mod(uv, md) - md*0.5;\n    \n    \n    //uv = sin(uv*4.);\n    for(int i = 0; i < 1; i++){\n    \tuv = abs(uv);\n        \n        uv -= 0.6 + sin(uv.y*10. + length(uv)*9. + iTime*2.4)*0.3;\n        uv -= 0.0 + sin(uv.y*10. + length(uv)*1. + iTime*0.4)*0.1;\n    \n    }\n    \n    color = vec3(1);\n    for (float i=0.;i<14.+ min(float(iFrame),0.);i++) {\n        \n        vec2 uu = uv;\n        uu.x *= .1;\n        uu.y *= 1.;\n        if(mod(i, 4.) == 0.)\n        \tcolor *= xor(uu.x, uu.y)*20.5 - 50.;\n        doFolds(uv,invCent,invRad,n);\n    }\n    color = clamp(color, 0., 1.);\n    //color *= hsv2rgb(vec3(fract(float(n)/4.)/2.4,1.,1.-float(n)/60.));\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    float aa = 7.;\n    \n    for(float i =0.; i < aa*aa + float(min(iFrame,0)); i++){\n    \tcol += color(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    \n    col = max(col, 0.);\n\t//col = pow(col, vec3(0.4545));\n    \n    col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n/*\n\n\nvoid fold(inout vec2 p, vec2 dir,inout int n){\n    float dt = dot(p,dir);\n    if (dt<0.) {\n        p-=2.*dt*dir;\n        n++;\n    }\n}\nvec2 cInverse(vec2 z, vec2 center, float radius){\n    z -= center;\n    return z*radius*radius/dot(z,z) + center;\n}\nvoid fold_circle(inout vec2 z, vec2 c, float r, inout int n) {\n    if (distance(z,c)>r) return;\n    z = cInverse(z,c,r);\n    n++;\n}\nvec3 drawCircle(vec2 z,vec2 c,float r) {\n    return vec3(smoothstep(distance(z,c)-r,.01,0.));\n}\nvoid doFolds(inout vec2 z,vec2 c,float r,inout int n) {              \n    fold(z,vec2(1,0),n);\n    fold(z,vec2(0,1.),n);\n    fold_circle(z,c,r,n);\n}\nfloat xor(float a, float b){return float(int(a) ^ int(b));}\n\n// Standard spiral zoom.\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase){\n\t\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\t//return vec2(a*n + log(d)*spiral, -log(d)*zoom + a) + phase;\n    // Equivalent to the line above. Fabrice tidied it up. I'd imagine the grouped\n    // operations might make it a little quicker, but don't quote me on that. :)\n    return mat2(n, 2, spiral,-zoom)*vec2(a, log(d)) + phase;\n\n}\n\nvec3 color(vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 1. - dot(uv,uv)*0.2;\n    uv *= 3.4;\n    int n=0;\n    vec2 invCent=vec2(1.); float invRad=1.41;\n    vec3 color = vec3(1);\n    \n    uv = spiralZoom(uv, vec2(-.3), 4., 3.14159*.2,0.9, vec2(-4, 4)*iTime*.125);\n\n    \n    vec2 suv = uv;\n    float md = 1.;\n    vec2 id = floor(uv/md);\n    uv = mod(uv, md) - md*0.5;\n    \n    \n    for(int i = 0; i < 1; i++){\n    \tuv = abs(uv);\n        \n        uv -= 0.6 + sin(uv.y*10. + length(uv)*9. + iTime*2.4)*0.3;\n        uv -= 0.0 + sin(uv.y*10. + length(uv)*1. + iTime*0.4)*0.1;\n    \n    }\n    \n    color = vec3(1);\n    for (float i=0.;i<14.+ min(float(iFrame),0.);i++) {\n        \n        vec2 uu = uv;\n        uu.x *= 1.;\n        uu.y *= 1.;\n        if(mod(i, 3.) == 0.)\n        \tcolor *= xor(uu.x, uu.y)*20.5 - 10.;\n        doFolds(uv,invCent,invRad,n);\n    }\n    color = clamp(color, 0., 1.);\n    \n    //color *= hsv2rgb(vec3(fract(float(n)/4.)/2.4,1.,1.-float(n)/60.));\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    float aa = 4.;\n    \n    for(float i =0.; i < aa*aa + float(min(iFrame,0)); i++){\n    \tcol += color(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    \n    col = max(col, 0.);\n    \n    \n\t//col = pow(col, vec3(0.4545));\n    \n    col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n*/\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n#define OFFS (msr*2. + bar*8.*1.*6./8.)*0.\n\nfloat[] probK = float[16](0.1,0.9,0.1,0.9,0.4,0.9,0.1,0.3,0.9,0.4,0.9,0.,0.9,0.1,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,T,F,T,T,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\n\n\nbool[] pattBa = bool[8](T,T,F,T,F,T,F,T);\nbool[] pattB = bool[8](T,T,T,T,T,T,T,T);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst vec4 cmin9 = vec4(0.,3.,7.,14.);\nconst vec4 cmin7 = vec4(0.,3.,7.,10.);\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.);\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.);\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.);\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.);\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.);\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.);\n\nconst int chordCnt = 8;\n\nvec4[] chords = vec4[chordCnt](\n    cmaj7f15,\n    cmin9 + 2.,\n    cmaj7f15 - 2.,\n    cmaj7 + 3.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/amt)*amt\n\n\nvec2 kick(float t, inout float sc){\n\tinit;\n\t\n    //sampleratereduction(t, 0.00001);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp2(-t*80.1)*340. + 30.)*tt )*env;\n    \n    s = mix(s,sin(s*3.)*1., 0.9);\n    \n    \n    bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattK[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snarea(float t){\n\n    init;\n    \n    \n    sampleratereduction(t, 0.00001);\n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 5000.)*0.9;\n    nn += lpnoise(t, 16500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*30.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (300./1. + exp(-t*14.)*1100.  )*tt;\n    s += sin( f + nn.x*0.2)*env;\n    s += sin( f*2.5 + nn.y*4.6)*pow(env, 0.8)*0.7;\n    s += sin( pow(f, 1.01)*4. )*env*0.3;\n    \n    \n    \n    s += sin( f*1.5 )*env*0.1;\n    s *= 0.2;\n    bitreduction(s, 0.001);\n    //s += sin( f*2. )*env*0.1;\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\nvec2 snare(float t){\n\tinit;\n    \n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*70.);\n    \n    vec2 n =lpnoise(t,2000.5);\n    vec2 nb =lpnoise(t,22000.5);\n    float f = 300.+ 300.*exp2(-t*26.)+ n.x*4.5 ;\n    \n    \n    s += sin(f*tt + n.x*0.25 + nb.x*0.2*exp(-t*20.))*env;\n    s += sin(f*tt*4. + n.x*0.25 + nb.x*4.2*exp(-t*10.))*pow(env, 0.8)*0.03;\n    \n    s += (n + nb)*0.04*exp(-t*19.);\n    \n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    //sampleratereduction(t, 0.0004);\n    sampleratereduction(t, 0.00002);\n    float to;\n    vec2 nn = lpnoise(t, 600.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 32./4.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float amt = 1.;\n    float env = exp(-t*2.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    float oct = 4.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*0.4)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    //s += sin(f + sin(2000.*tt)*exp(-t*20.))*env;\n    \n    bitreduction(s, 0.008);\n    s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    //sampleratereduction(t, 0.001);\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 32. / 2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float env = exp(-t*9.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 2.) *tt + \n             \t+sin(note(n, 4.) *tt)*exp(-t*4.)*0.9\n                 \n                 )*exp(-t*9.)*1. \n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*4.)*0.1 \n                 \n                 )*exp(-t*9.)*1.5\n            )*env;\n    \n    \n    s *= 1.;\n    \n    \n    //bitreduction(s, 0.3);\n    //s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    sampleratereduction(t, 0.00004);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 8500.)*0.45;\n    \n    nn *= 0.05*sin(t);\n    float m = 1.;\n    float width = 10.;\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*4.);\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*4.);\n    float oct = 3.;\n    for(float i = 0.; i < 8. + min(t, 0.); i++){\n        float a = (1. + i/2.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    bitreduction(s, 0.4);\n    \n    s *= 0.03;\n    s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat*0.5);\n    \n    sampleratereduction(t, 0.00005);\n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 1500.)*0.4;\n    \n    float amt = 0.2;\n    float env = exp(-t*95.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.4);\n    s *= 0.5;\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*2.4);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((9000. )*tt)*exp(-t*2.)*0.5 \n        + ( 2250. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.75;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.7;\n    ret;\n}\nvoid initKickPatt(float t){\n\t\n    float r = beat/4.;\n    \n    float id = floor(t/r);\n    \n    \n    for(int i = 0; i < 16; i++){\n        \n        vec4 r = r11(id + float(i));\n        \n    \tpattK[i] = r.x < probK[i];\n        \n    }\n}\nvec2 mainSound( in int samp, float t )\n{\n    t += OFFS;\n    //t += msr*4.;\n    vec2 s= vec2(0);\n    \n    initKickPatt(t);\n    \n    float sc;\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(pow(sc,4.4))*0.2;\n    vec2 hb= hatsb(t)*(pow(sc,4.4))*0.1;\n    vec2 bass = bass(t)*(pow(sc,1.4))*0.4;\n    vec2 c = chord(t)*(pow(sc,1.5))*0.5;\n    vec2 l = lead(t)*(pow(sc,0.9))*0.1;\n    \n    \n    if(t < msr){\n    \ts += l;\n        s += c;\n    \n    } else if (t < msr*2.){\n    \ts += l;\n        s += hb;\n        if(t > msr*1.75){\n        \ts += k;\n        \ts -= hb;\n        \ts -= ha;\n        }\n        \n    } else {\n    \n        s += k;\n        s += sn;\n        s += ha;\n        s += hb;\n        s += bass;\n        s += l;\n        s += c;\n    }\n    \n    s *= 0.4;\n    \n    s = mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), (0.5 + sin(t)*0.)*1.);\n    s = clamp(s,-1.,1.);\n    \n    //s *= smoothstep(0.,1.,t*0.5);\n    return s;\n}", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 230, 230, 1356]], "test": "untested"}
{"id": "3ssczs", "name": "The Live Coders Conference - 1", "author": "mrange", "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.", "tags": ["2d", "fbm", "tlc"], "likes": 11, "viewed": 432, "published": 3, "date": "1585381413", "time_retrieved": "2024-07-30T21:16:15.267684", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  https://iquilezles.org/articles/distfunctions2d\n// pmin from IQ's blog on smooth minimum functions:\n//  https://iquilezles.org/articles/smin\n// Lightning based on \"Sparkle sparkle little lightning\":\n//  https://www.shadertoy.com/view/3sXSD2\n\n#define PI     3.141592654\n#define TAU    (2.0*PI)\n#define SCA(a) vec2(sin(a), cos(a))\n#define TTIME  (iTime*TAU)\n#define PERIOD 600.0\n\nconst float a1 = PI/2.0;\nconst float a2 = PI*4.5/6.0;\n\nconst vec2 sca1 = SCA(a1);\nconst vec2 sca2 = SCA(a2);\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  return (aggr * 0.5) + 0.5;    \n}\n\nvec3 lightning(vec2 pos, float offset) {\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*SCA(PI/2.0 + TTIME/PERIOD);\n    \n  for (int i = 0; i < 3; i++) {\n    float btime = TTIME*85.0/PERIOD + float(i);\n    float rtime = TTIME*75.0/PERIOD + float(i) + 10.0;\n    float d1 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 3.0, rtime)));\n    float d2 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 2.0, btime)));\n    col += vec3(d1 * vec3(0.1, 0.3, 0.8));\n    col += vec3(d2 * vec3(0.7, 0.3, 0.5));\n  }\n    \n  return col;\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat arc(vec2 p, vec2 sca, vec2 scb, float ra, float rb) {\n  p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n  p.x = abs(p.x);\n  float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n  return sqrt(dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k) - rb;\n}\n\nfloat spokes(vec2 p, float s) {\n  vec2 pp = toPolar(p);\n  pp.y += TTIME*40.0/PERIOD;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  float ds = box(p, s*vec2(0.075, 0.5), s*vec4(0.04));\n  return ds;\n}\n\nfloat arcs(vec2 p, float s) {\n  \n  float d1 = arc(p, sca1, sca2, s*0.275, s*0.025);\n  float d2 = arc(p, sca1, sca2, s*0.18, s*0.025);\n  \n  return min(d1, d2);\n}\n\nfloat meeple(vec2 p, float s) {\n  float dh = box(p - s*vec2(0.0, -0.035), s*vec2(0.07, 0.1), s*vec4(0.065));\n  float dc = box(p - s*vec2(0.0, -0.22), s*vec2(0.15, 0.04), s*vec4(0.05, 0.02, 0.05, 0.02));\n  \n  return pmin(dh, dc, s*0.115);\n}\n\nfloat theLiveCoders(vec2 p, float s) {\n  float ds = spokes(p, s);\n  float dc = circle(p, 0.375*s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n  \n  float d = ds;\n  d = min(d, dc);\n  d = max(d, -da);\n  d = max(d, -dm);\n  \n  return d;\n}\n\nfloat df(vec2 p) {\n  float d = theLiveCoders(p, 1.0 - 0.5*cos(TTIME*7.0/PERIOD));\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=vec3(1.0 - tanh(pow(length(p/1.5), 5.0)));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  vec2 op = p;\n\n  p *= 1.0;\n\n  float d = df(p);\n  \n  const vec3  background   = vec3(0.0)/vec3(255.0);\n\n  vec3 col = background;\n\n  float borderStep = 0.0075;\n \n  vec3 baseCol = vec3(1.0);\n  vec4 logoCol = vec4(baseCol, 1.0)*smoothstep(-borderStep, 0.0, -d);\n  \n  if (d >= 0.0) {\n    vec2 pp = toPolar(p);\n    float funky = 0.7*pow((0.5 - 0.5*cos(TTIME/PERIOD)), 4.0);\n    pp.x *= 1./(pow(length(p) + funky, 15.0) + 1.0);\n    p = toRect(pp);\n    col += lightning(p, (pow(abs(d), 0.25 + 0.125*sin(0.5*iTime + p.x + p.y))));\n  }\n  col = clamp(col, 0.0, 1.0);\n\n  col *= 1.0 - logoCol.xyz;\n\n  col = postProcess(col, q, op);\n  col *= smoothstep(0.0, 16.0, iTime*iTime);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssczs.jpg", "access": "api", "license": "gpl-3.0", "functions": [[1581, 1581, 1600, 1600, 1723], [1725, 1725, 1746, 1746, 2173], [2175, 2175, 2206, 2206, 2553], [2555, 2555, 2595, 2595, 3078], [3080, 3080, 3119, 3119, 3244], [3246, 3246, 3268, 3268, 3312], [3314, 3314, 3335, 3335, 3380], [3382, 3382, 3421, 3421, 3497], [3499, 3499, 3530, 3530, 3556], [3558, 3558, 3593, 3593, 3742], [3744, 3744, 3803, 3803, 3990], [3992, 3992, 4023, 4023, 4206], [4208, 4208, 4237, 4237, 4368], [4370, 4370, 4401, 4401, 4609], [4611, 4611, 4649, 4649, 4853], [4855, 4855, 4873, 4873, 4950], [4952, 4952, 4997, 4997, 5197], [5199, 5199, 5254, 5254, 6051]], "test": "untested"}
{"id": "Wdsyzs", "name": "shortest inversion (105 chars)", "author": "FabriceNeyret2", "description": "regolfing 2017' \"shortest inversion\" (120 chars) [url]https://shadertoy.com/view/4dBczt[/url]", "tags": ["inversion", "short", "onetweet", "golf"], "likes": 9, "viewed": 345, "published": 3, "date": "1585376259", "time_retrieved": "2024-07-30T21:16:16.074526", "image_code": "// regolfing 2017' \"shortest inversion\" (120 chars) https://shadertoy.com/view/4dBczt\n\n\n// -3 by Xor , -1 by Greg , -1 by Fab\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O.xyz = iResolution;\n    U = sin(O.y/.08/dot( U += U-O.xy, U) * U );\n    U /= fwidth( U*=U.y );  \n    O = .5 + U.xxxx;\n}\n\n\n\n\n\n// 119 chars  ( marsh 2020 )  used to be 105 in its deprecaded #define mainImage form\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         U = u+u - R;\n    U = sin( R.y/.08*  U/dot(U,U) );\n    U /= fwidth( U*=U.y );\n\tO += .5 + U.x;\n}\n\n\n\n\n\n// -1 by coyote\n/*\n#define mainImage(O,u)               \\\n    vec2 R = iResolution.xy,         \\\n         U = u+u - R;                \\\n    U = sin( R.y/.08*  U/dot(U,U) ); \\\n    U /= fwidth( U*=U.y );           \\\n\tO += .5 + U.x                   /*\n\n\n\n\n\n// -- 106 chars\n\n#define mainImage(O,u)               \\\n    vec2 R = iResolution.xy,         \\\n         U = u+u - R;                \\\n    U = sin( R.y/.08*  U/dot(U,U) ); \\\n    U *= U.y;                        \\\n\tO += .5 +  U.x / fwidth(U.x)    /*\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdsyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 126, 162, 162, 287]], "test": "untested"}
{"id": "Wdlyzs", "name": "Encoding", "author": "scry", "description": "moving up? or down? or neither? :D", "tags": ["2d", "pattern"], "likes": 3, "viewed": 271, "published": 3, "date": "1585371784", "time_retrieved": "2024-07-30T21:16:16.821529", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iResolution.x > 1900.) {\n        uv *= 4.;\n    }\n    float time = iTime;\n    float c = length(vec2(uv.x+cos(time)*0.1,uv.y+sin(time)*0.1)-0.5);\n    c -= time*0.04;\n    //c*= sin(time*0.1)*100.;\n    c*= sin(time*0.01);\n    c += sin(uv.x*13.+time*0.1)*cos(uv.y*13.+time*0.1)*3.;\n    uv.x -= time*0.002*sin(time*0.4);\n    c += sin(uv.x*81.+time*0.1)*cos(uv.y*29.+time*0.1)*0.9;\n    uv.xy -= time*0.01*sin(time*0.03);\n    c += sin(uv.x*420.+time*0.1)*cos(uv.y*90.+time*0.4)*0.8;\n    uv.y += time*0.02*sin(time*0.05);\n    c += sin(uv.x*40.+time*0.1)*cos(uv.y*189.+time*0.4)*0.4;\n    c = sin(c*3.-time*26.)+time*0.1;\n    vec3 col = vec3(sin(c*2.),sin(c+0.1),cos(c))*0.5+0.5;\n    col = mix(col,sin(time*0.4)*texture(iChannel0,mix(col.rg*0.1,uv*0.5,0.9)).rgb,0.2);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdlyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 894]], "test": "untested"}
{"id": "WdscRs", "name": "pseudo3d attempt", "author": "scry", "description": "hmmmm yep I need to do more research...", "tags": ["2d", "3d", "pseudo3d"], "likes": 3, "viewed": 304, "published": 3, "date": "1585370248", "time_retrieved": "2024-07-30T21:16:17.581497", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 col = vec3(0.);\n    uv.y = abs(uv.y-0.5);\n    \n    uv.x -= 0.5;\n    uv.x = abs(uv.x);\n    //uv.y = 1./(uv.y+0.25);\n    uv.y = ((-uv.y*4.5)-0.5);\n    uv.y += 0.5;\n    uv.y *= .1;\n    uv.y -= 0.5;\n    uv.x *= 0.15;\n    uv.x -= uv.x/(uv.y+0.5);\n    uv.y += iTime*0.15;\n    uv.y *= 0.35;\n    \n    col = vec3(mod(uv*10.,1.),0.);\n    col = texture(iChannel0,col.rg).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 501]], "test": "untested"}
{"id": "WdscRl", "name": "Voronoi edge mesh simulation", "author": "michael0884", "description": "using the tracked Voronoi edges as a mesh for a simulation", "tags": ["voronoi"], "likes": 7, "viewed": 612, "published": 3, "date": "1585357548", "time_retrieved": "2024-07-30T21:16:18.592793", "image_code": "// Fork of \"Voronoi edge tracking III\" by michael0884. https://shadertoy.com/view/wdsczB\n// 2020-03-28 00:37:58\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nedges gete(ivec2 p)\n{\n    edges e;\n    ivec4 A = floatBitsToInt(texel(ch2, p));\n    for(int i = 0; i < 4; i++)\n    {\n        e.ids[i] = A[i]%tot_n;\n        e.ids[i+4] = A[i]/tot_n;\n    }\n    return e;\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nbool loadparticles(in edges e, inout vec2[8] xy)\n{\n    for(int i = 0; i < 8; i++)\n    {\n        if(e.ids[i] < 0) return false;\n        xy[i] = getParticle(e.ids[i]).xy;\n    }\n    return true;\n}\n\nvec2 getCC(inout edges e, inout vec2[8] xy, int i) //get circumcenter\n{\n    int j = bitreverse3(i);\n    ivec2 par = getParents(j);\n    ivec2 id = ivec2((par.x + j)%8,(par.y + j)%8); \n  \n    if(any(equal(ivec3(e.ids[j],e.ids[id.x],e.ids[id.y]),\n                 ivec3(e.ids[id.x],e.ids[id.y],e.ids[j])))) return vec2(0.);\n    \n    //get the circumcenter for this branch of the binary tree\n    vec2 cc = circumcenter(xy[j], xy[id.x], xy[id.y]);\n \treturn cc; \n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 load(ivec2 p)\n{\n    return texel(ch3, p);\n}\n\nvec3 getEdgeDistance(ivec2 p, vec2 pos)\n{\n    edges e = gete(p);\n    vec2 xy[8];\n    if(!loadparticles(e, xy)) return vec3(1e10);\n    vec4 edge0 = vec4(getCC(e, xy, 2),getCC(e, xy, 3));\n    vec4 side1 = vec4(getCC(e, xy, 4),getCC(e, xy, 5));\n    vec4 side2 = vec4(getCC(e, xy, 6),getCC(e, xy, 7));\n    float d = sdSegment(pos, edge0.xy, edge0.zw);\n    vec2 data0 = load(ivec2(mix(edge0.xy, edge0.zw, 0.5))).zw;\n    d = min(d, sdSegment(pos, edge0.xy, side1.xy));\n    d = min(d, sdSegment(pos, edge0.xy, side2.xy));\n    \n    vec2 n = vec2(1.,-1)*(edge0.wz - edge0.yx);\n    float tnormal = 0.5 - 0.5*clamp( dot(pos - edge0.xy, n) /\n                           dot(n, n), -1., 1.); \n    \n    vec2 data1 = 0.333*(load(ivec2(mix(edge0.xy, side1.xy, 0.5))).zw + \n        \t\t load(ivec2(mix(edge0.xy, side2.xy, 0.5))).zw +\n        \t\t data0);\n        \t \n    d = min(d, sdSegment(pos, edge0.zw, side1.zw));\n    d = min(d, sdSegment(pos, edge0.zw, side2.zw));\n    vec2 data2 = 0.333*(load(ivec2(mix(edge0.zw, side1.zw, 0.5))).zw +\n        \t\t        load(ivec2(mix(edge0.zw, side2.zw, 0.5))).zw +\n                        data0);\n    \n    float t = clamp( dot(pos - edge0.xy, edge0.zw - edge0.xy) /\n                     dot(edge0.zw - edge0.xy, edge0.zw - edge0.xy), 0., 1.);\n    vec2 data =  data1*clamp(1. - 2.*t, 0., 1.) +\n                   data2*clamp(2.*t - 1., 0., 1.) + \n                   data0*clamp(1. - abs(2.*t - 1.), 0., 1.);\n    return vec3(d, data);\n}\n\n#define scale 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec4 mouse = iMouse;\n    if(mouse.z == 0.) mouse.xy = size*0.5 - size*scale*0.5;\n    pos = pos*scale + mouse.xy;\n    ivec2 p = ivec2(pos);\n   \n  \tvec3 ce = getEdgeDistance(p, pos);\n    float D = gauss(ce.x*ce.x*ce.x,0.2);\n    fragColor =  D*(0.5 + sin(vec4(2,2,3,4)*ce.z));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(80,80)\n#define dt 0.5\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\n\nconst int tot_n = N.x*N.y;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<2*(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nvec2 circumcenter(vec2 x, vec2 y, vec2 z)\n{\n    vec2 xy = y - x;\n    vec2 xz = z - x;\n    vec2 a = 0.5*(x+y);\n    vec2 b = 0.5*(x+z);\n    vec2 d = vec2(dot(xy,a), dot(xz,b));\n    float det = determinant(mat2(xy, xz));\n    return vec2(determinant(mat2(d.x, xy.y, d.y, xz.y)),determinant(mat2(xy.x, d.x, xz.x, d.y)))/det;\n}\n\nstruct edges\n{\n    int ids[8];\n};\n    \n    \n//reverse the order of 3 bits\nint bitreverse3(int i)\n{\n    return ((i&1)<<2) +\n            (i&2) +\n           ((i&4)>>2);    \n}\n\nivec2 getParents(int i)\n{\n    if(i%2 == 0) return ivec2(-2,2);\n    return ivec2(-1,1);\n}\n    ", "buffer_a_code": "//particle buffer\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return -1./(1.+0.05*d);\n}\n\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    return normalize(p1-p0)*F(distance(p1,p0));\n}\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    if(p.x > N.x || p.y > N.y) discard;\n    \n    pos = floor(pos);\n    \n    //this pixel value\n    U = texel(ch1, pos);\n    int id = xy2i(p);\n\n    //neighbors\n    ivec4 cp = get(ivec2(U.xy));\n    vec4 p1 = getParticle(cp.y);\n    vec4 p2 = getParticle(cp.z);\n    vec4 p3 = getParticle(cp.w);\n\n    vec2 F = Fv(U.xy, p1.xy) +\n             Fv(U.xy, p2.xy) +\n             Fv(U.xy, p3.xy);\n\n    ivec4 mnb = get(ivec2(iMouse.xy));\n\n    if(any(equal(ivec2(id),mnb.xy)) && iMouse.z>0.)\n    {\n        F += 0.0*(iMouse.xy - iMouse.zw); \n    }\n\n    U.xy += F*dt;\n\n    if(size.x - U.x < 2.) U.x = size.x - 2.;\n    if(U.x < 2.) U.x = 2.;\n    if(size.y - U.y < 2.) U.y = size.y - 2.;\n    if(U.y < 2.) U.y = 2.;\n\n    //this pixel value\n    if(iFrame<1)\n    {\n        U.xy = size*hash22(pos);\n        U.zw = 2.*(hash22(3.14159*pos) - 0.5);\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    loop(8)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    loop(4)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//2nd order edge tracking\nvec2 xy[8];     \nedges E;\nint n;\n\nivec4 GET(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nedges get(ivec2 p)\n{\n    edges e;\n    ivec4 A = floatBitsToInt(texel(ch2, p));\n    for(int i = 0; i < 4; i++)\n    {\n        e.ids[i] = A[i]%tot_n;\n        e.ids[i+4] = A[i]/tot_n;\n    }\n    return e;\n}\n\nvec4 save()\n{\n    return intBitsToFloat(ivec4(E.ids[0],E.ids[1],E.ids[2],E.ids[3]) + \n                          ivec4(E.ids[4],E.ids[5],E.ids[6],E.ids[7])*tot_n);\n}\n\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nbool isSame(ivec3 a, ivec3 b) //is the id triplet the same\n{\n    return any(equal(a.xxx,b)) && any(equal(a.yyy,b)) && any(equal(a.zzz,b));\n}\n\nbool isEdgeParticle(int id, vec2 pxy, ivec2 id2, vec4 nbxy)\n{\n    //edge point guess\n    vec2 cc = circumcenter(nbxy.xy, nbxy.zw, pxy);\n    //check the voronoi diagram at the guess\n    if(cc.x > size.x-1. || cc.y > size.y-1. || cc.x < 0. || cc.y < 0.) return false;\n    ivec4 t = GET(ivec2(cc));\n    //the first 3 closest particles at the edge point pretty much always are the particles that produce the edge\n    return isSame(t.xyz, ivec3(id2, id));\n}\n\n\n\n//edge store\nbool store(int utemp)\n{\n\tvec4 part = getParticle(utemp);\n    for(int i = 0; i < 8; i++)\n    {\n        if(E.ids[i] == utemp) return false;\n    }\n    \n    int j; int complete = 2; bool found = false;\n\tfor(int i = min(2, iFrame+2); i < 8; i++)\n    {\n        j = bitreverse3(i);\n        if(E.ids[j] >= 0) \n        {\n            complete++;\n            continue;\n        }\n        ivec2 par = getParents(j);\n        ivec2 id = ivec2((par.x + j)%8,(par.y + j)%8); \n        ivec2 pid = ivec2(E.ids[id.x],E.ids[id.y]);\n        vec4 pxy = vec4(xy[id.x],xy[id.y]);\n        if(isEdgeParticle(utemp, part.xy, pid, pxy)) {\n         \tfound = true;\n            break;\n        }\n    }\n    \n    if(found)\n   \tfor(int i = 0; i < 8; i++)\n    {\n        if(i==j)\n        {\n            E.ids[j] = utemp;\n            xy[j] = part.xy;\n        }\n    }  \n    \n    return complete > 7;\n}\n\nbool storepos(ivec2 p)\n{\n    ivec4 nb = GET(p);\n    loop(4)\n    {\n        if(store(nb[i])) return true;\n    }\n    return false;\n}\n\nbool storeE(in edges e)\n{\n    loop(8)\n    {\n    \tif(store(e.ids[i])) return true;\n    }\n    return false;\n}\n\nbool storeedge(ivec2 p)\n{\n   edges e = get(p);\n   return storeE(e);\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    \n    ivec2 p = ivec2(pos);\n\n    for(int i = 0; i < 8; i++)\n    {\n        xy[i] = vec2(1e10);\n        E.ids[i] = -1;\n    }\n    \n    //set parents of the binary tree;\n    ivec4 closest = GET(p);\n    E.ids[0] = closest.x;\n    E.ids[4] = closest.y;\n    xy[0] = getParticle(closest.x).xy;\n    xy[4] = getParticle(closest.y).xy;\n    \n    //jump flood sorting \n    \n    //prev edge \n    edges e = get(p);\n    \n    bool complete = false;\n    \n    complete = complete||storepos(p);\n    complete = complete||storeE(e); //resort this position\n    \n    loop(4)\n    {\n        if(complete) break;\n        complete = complete||storeedge(p+cross_distribution(i));\n        if(complete) break;\n        complete = complete||store(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    loop(8)\n    {\n        if(complete) break;\n        complete = complete||storepos(p+cross_distribution(i));\n    }\n    \n    if(!complete)\n    {\n        E = e;\n    }\n    \n    U = save();\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//edge data tracker/sim - flows and stuff\n\nvec4 data;\nvec2 pos;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n\nbool loadparticles(in edges e, inout vec2[8] xy)\n{\n    for(int i = 0; i < 8; i++)\n    {\n        if(e.ids[i] < 0) return false;\n        xy[i] = getParticle(e.ids[i]).xy;\n    }\n    return true;\n}\n\nvec2 getCC(inout edges e, inout vec2[8] xy, int i) //get circumcenter\n{\n    int j = bitreverse3(i);\n    ivec2 par = getParents(j);\n    ivec2 id = ivec2((par.x + j)%8,(par.y + j)%8); \n  \n    if(any(equal(ivec3(e.ids[j],e.ids[id.x],e.ids[id.y]),\n                 ivec3(e.ids[id.x],e.ids[id.y],e.ids[j])))) return vec2(0.);\n    \n    //get the circumcenter for this branch of the binary tree\n    vec2 cc = circumcenter(xy[j], xy[id.x], xy[id.y]);\n \treturn cc; \n}\n\nedges gete(ivec2 p)\n{\n    edges e;\n    ivec4 A = floatBitsToInt(texel(ch2, p));\n    for(int i = 0; i < 4; i++)\n    {\n        e.ids[i] = A[i]%tot_n;\n        e.ids[i+4] = A[i]/tot_n;\n    }\n    return e;\n}\n\nvec4 load(ivec2 p)\n{\n    return texel(ch3, p);\n}\n\nvec2 getEdgeCenter(ivec2 p)\n{\n    edges e = gete(p);\n    vec2 xy[8];\n    if(!loadparticles(e, xy)) return vec2(1e10);\n    return mix(getCC(e, xy, 2),getCC(e, xy, 3), 0.5);\n}\n\nbool isValid(inout vec2 cc)\n{\n    vec2 ec = getEdgeCenter(ivec2(cc));\n    if(distance(ec, cc) > 1.) return false;\n    cc = ec;\n    return true;\n}\n\nvoid sort(vec2 ncc, vec2 d)\n{\n    if(isValid(ncc))\n    {\n        if(distance(ncc.xy, pos) < distance(data.xy, pos))\n        {\n            data.xy = ncc.xy;\n            data.zw = d;\n        }\n    } \n}\n    \nvoid sortpos(ivec2 p)\n{\n    vec4 nb = load(p);\n    sort(nb.xy, nb.zw);\n}\n\nvoid update(ivec2 p)\n{    \n    loop(4)\n    {\n        ivec4 rand = hash(ivec4(p, iFrame, i));\n        ivec2 cp = ivec2(rand.x%int(size.x),rand.y%int(size.y));\n        vec2 ec = getEdgeCenter(cp);\n        sort(ec, vec2(10,0)*exp(-0.002*dot(ec - size*0.5,ec - size*0.5)));    \n    }\n}\n\nvoid data_correction(ivec2 p)\n{\n    float lvl = 0.;\n    vec4 nb0;\n    loop(4) \n    {\n        vec4 nb = load(p+cross_distribution(i));\n        if(distance(data.xy, nb.xy) < 2. && //is the same EC\n           distance(data.zw, nb.zw) > 1e-2) //data is different\n        {\n            nb0 = nb;\n            lvl++;\n        }\n    }; \n    if(lvl > 2.) data=nb0; //if most neighbors are different\n}\n\nmat4x2 getEdgeData(ivec2 p)\n{\n    mat4x2 nec;\n    edges e = gete(p);\n    vec2 xy[8];\n    if(!loadparticles(e, xy)) return mat4x2(0.);\n    vec4 edge0 = vec4(getCC(e, xy, 2),getCC(e, xy, 3));\n    vec4 side1 = vec4(getCC(e, xy, 4),getCC(e, xy, 5));\n    vec4 side2 = vec4(getCC(e, xy, 6),getCC(e, xy, 7));\n\n    nec[0] = mix(edge0.xy, side1.xy, 0.5);\n    nec[1] = mix(edge0.zw, side1.zw, 0.5);\n    nec[2] = mix(edge0.xy, side2.xy, 0.5);\n    nec[3] = mix(edge0.zw, side2.zw, 0.5);\n    \n    mat4x2 ndata;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        ndata[i] = load(ivec2(nec[i])).zw;\n    }\n    \n    return ndata;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    pos = coord;\n    ivec2 p = ivec2(pos);\n    \n    //sort\n    data = vec4(0.);\n    sortpos(p);\n    update(p);\n    loop(8) sortpos(p+cross_distribution(i)); \n    data_correction(p);\n    \n    //simulation\n    //get neighbors\n    mat4x2 ndata = getEdgeData(ivec2(data.xy)); \n    \n    //wave eq\n    if(iFrame > 100)\n    {\n        float laplacian = -data.z;\n        loop(4) laplacian += ndata[i].x*0.25;\n\n        data.w = data.w*0.999 + 0.12*laplacian;\n        data.z = data.z*0.99 + data.w*0.12;\n    }\n        \n    fragColor = data;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 144, 144, 178], [180, 180, 200, 200, 244], [246, 246, 267, 267, 448], [450, 450, 476, 476, 511], [1168, 1168, 1220, 1220, 1339], [1341, 1341, 1361, 1361, 1389], [1391, 1391, 1432, 1432, 2844], [2865, 2865, 2916, 2916, 3196]], "test": "untested"}
{"id": "3dsyRl", "name": "Multi Color Fluid Simulation", "author": "aiekick", "description": "Multi Color Fluid Simulation", "tags": ["simulation", "fluid", "color", "shaded", "multi", "navierstoke"], "likes": 29, "viewed": 1022, "published": 3, "date": "1585355261", "time_retrieved": "2024-07-30T21:16:19.478425", "image_code": "// Created by Stephane Cuillerdier - Aiekick - 2020 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// BUF A,B (pingpong x2) x,y : particle pos / z : pressure\n// BUF C,D (pingpong x2) rgb : ink\n// the calc functions and simu params are in the Common tab\n\n#define BUMP 1.0\n#define COLOR_COEF 1.0\n#define DIFF_COEF 0.4\n#define SPEC_POWER 16.0\n#define SPEC_COEF 0.4\n\nvoid mainImage( out vec4 fragColor, in vec2 g )\n{\n    vec3 s = iResolution;\n    \n    vec2 uv = g/s.xy;\n    vec2 uvc = (g-s.xy*0.5)/s.y;\n    \n    // normal\n    float eps = 2.0/min(s.x, s.y);\n\tvec4 f = texture(iChannel0, uv); // ink\n\tvec4 fx = (texture(iChannel0, uv + vec2(eps,0))-f)/eps;\n\tvec4 fy = (texture(iChannel0, uv + vec2(0,eps))-f)/eps;\n\tvec3 nr = normalize( vec3(0., 0., 1) + vec3(fx.r, fy.r, 1.) * BUMP );           \n\tvec3 ng = normalize( vec3(0., 0., 1) + vec3(fx.g, fy.g, 1.) * BUMP );           \n\tvec3 nb = normalize( vec3(0., 0., 1) + vec3(fx.b, fy.b, 1.) * BUMP );           \n\tvec3 n = normalize(nr+ng+nb);\n    \n    float pr = texture(iChannel1, uv).z; // pressure waves\n\t\n    // custom brdf, pressure is used for perturb normal in a cheap way for showing waves\n\tvec3 rd = normalize(vec3(uvc, -1.)); vec3 ld = vec3(0,0,1);\n    float diff = max(dot(n + pr * 2., ld), 0.);  \n\tfloat spec = pow(max(dot(reflect(ld, n + pr * 0.15), rd), 0.),SPEC_POWER); \n\tvec3 col = f.rgb * COLOR_COEF + diff * DIFF_COEF + spec * SPEC_COEF;\n\t\n    fragColor = vec4(col, 1.0);\n\tfragColor = pow(fragColor, vec4(1.5));\n\tfragColor = clamp(fragColor, 0., 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 g )\n{\n\tfragColor = CalcPositionPressure(iChannel0, g, iResolution, iFrame);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 g )\n{\n\tfragColor = CalcPositionPressure(iChannel0, g, iResolution, iFrame);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 g )\n{\n    fragColor = CalcInk(iChannel0, iChannel1, g, iResolution, iFrame);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 g )\n{\n    fragColor = CalcInk(iChannel0, iChannel1, g, iResolution, iFrame);\n}\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define emitForce 0.1\n#define emitPosRadius 0.45\n#define emitSize 0.01\n#define countEmitters 4\n#define visozity 1.0\n#define emitAngleOffset 0.0\n#define colorHash vec4(5,3,2,2)\n\n// interesting result with :\n// emitForce => 1.0\n// countEmitters => 100\n// emitAngleOffset => 1.5\n\nvec4 CalcPositionPressure(sampler2D pre, vec2 g, vec3 s, int fr)\n{\n    vec4 res = vec4(0);\n    \n    vec2 uv = g/s.xy;\n    vec2 uvc = (g-s.xy*0.5)/s.y;\n    \n    vec3 ts = 1./s;\n    ts.z = 0.0;\n    vec4 cur = texture(pre, uv);\n\tvec4 a = texture(pre, uv + ts.xz);\n\tvec4 b = texture(pre, uv + ts.zy);\n\tvec4 c = texture(pre, uv - ts.xz);\n\tvec4 d = texture(pre, uv - ts.zy);\n\tres = texture(pre, uv - cur.xy * ts.xy);\n\tvec2 gradPressure = vec2(a.z - c.z, b.z - d.z);\n\tfloat pres = (a.z + b.z + c.z + d.z) * 0.25f;\n\tfloat dive = 0.05 * (c.x - a.x + d.y - b.y);\n\tres.z = pres - dive; // pressure\n\tres.xy += gradPressure.xy * visozity; // particle pos\n\t\n    float an = 0.0, st = 6.28318 / float(countEmitters);\n    for (int i = 0; i < countEmitters;i++)\n    {\n        vec2 pos = vec2(cos(an),sin(an)) * emitPosRadius;\n        if (length(uvc-pos) < emitSize)\n\t\t{\n\t\t\tres.xy = res.xy * (1.0f - emitForce) - \n                emitForce * vec2(cos(an + emitAngleOffset),sin(an + emitAngleOffset));\n\t\t}\n        an += st;\n    }\n    \t\n\tif (uv.x <= ts.x || uv.y <= ts.y || uv.x >= 1.0f - ts.x || uv.y >= 1.0f - ts.y)\n\t\tres = vec4(0); //walls\n    \n    if (fr < 1)\n\t\tres = vec4(0);  // init\n    \n    return res;\n}\n\nvec4 CalcInk(sampler2D ink, sampler2D pre, vec2 g, vec3 s, int fr)\n{\n    vec4 res = vec4(0);\n    \n    vec2 uv = g/s.xy;\n    vec2 uvc = (g-s.xy*0.5)/s.y;\n    \n    vec2 ts = 1./s.xy;\n    vec4 cur = texture(pre, uv); // posX,posY,pre,notUsed\n\tres = texture(ink, uv - cur.xy * ts); // movement pos xy\n\t\n    float an = 0.0, st = 6.28318 / float(countEmitters);\n    for (int i = 0; i < countEmitters;i++)\n    {\n        vec2 dir = vec2(cos(an),sin(an));\n        vec2 pos = dir * emitPosRadius;\n        if (length(uvc-pos) < emitSize)\n\t\t{  \n            res = sin((float(i) + colorHash.a) * colorHash) * 0.5 + 0.5;\n        }\n        an += st;\n    }\n\t\n\tif (fr < 1) \n\t\tres = vec4(0); // init\n    \n    return res;\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyRl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[423, 423, 472, 472, 1572]], "test": "untested"}
{"id": "tsXcRX", "name": "lasergrid", "author": "benhardy", "description": "just a laser grid", "tags": ["raymarching", "lasers"], "likes": 2, "viewed": 362, "published": 3, "date": "1585350908", "time_retrieved": "2024-07-30T21:16:20.379019", "image_code": "#define MAX_DIST 100.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n#define STEP_RATIO 0.5\n\n\n#define NORMAL_DELTA 0.001\nvec2 measure(vec3 point) {\n    vec3 v = vec3(mod(point.x+5.0, 10.0)-5.0, point.y, mod(point.z+5.0, 10.0)-5.0);\n    float h = length(v.xy) - 0.1;\n    float j = length(v.zy) - 0.1;\n    float m = blend(h, j, 0.4);\n    float n = length(point.xz) - 0.1;\n    float r = blend(m, n, 0.4);\n    return vec2(r, 1.0);\n}\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(sin(iTime*0.11)*10.0+15.0,\n                    sin(iTime*0.05)*10.0+14.0,\n                    cos(iTime*0.13)*10.0-15.0);\n    vec3 look_at = vec3(0,0,0);\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n\n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    float current_dist = 0.0;\n    float best_dist = MAX_DIST;\n    for(int steps =0;steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        if (current_dist < best_dist) {\n            best_dist = current_dist;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    if (who == 0){\n        float glow = clamp(1.0 - best_dist, 0.0, 1.0);\n        vec3 pink = vec3(1.0, 0.6, 0.5);\n        fragColor = vec4(glow * pink, 1.0);\n        return;\n    }\n\tvec3 hit = where;\n    vec4 the_paint = vec4(1,1,1,1); //paint(current, where);\n    vec3 to_light = normalize(vec3(-10,5,-1));\n    //float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = 1.0;\n    float ambient = the_paint.w;\n    float lighting = ambient + (1.0-ambient); // \n   //     * (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = light_fade *(the_paint.xyz * lighting)\n        + fog_color * (1.0-light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n//\tcoloring += shadow*vec3(specular, specular, specular);\n    fragColor = vec4(coloring,1.0);\n}", "image_inputs": [], "common_code": "#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 145, 145, 426], [428, 428, 464, 464, 806], [808, 808, 865, 865, 2828]], "test": "untested"}
{"id": "wsfczl", "name": "[jmmut] flyer", "author": "jmmut", "description": "experimenting with storing state (camera rotation matrix) across frames\ncontrols: WASDQE + mouse.\n", "tags": ["raymarching"], "likes": 1, "viewed": 290, "published": 3, "date": "1585346344", "time_retrieved": "2024-07-30T21:16:21.373359", "image_code": "//jmmut: except for code coming from other people (which I noted and might have modified here), the license is http://www.wtfpl.net/\n\n\n// keyboard taken from: https://www.shadertoy.com/view/XdS3RV\n// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nvec4 ReadKey(int key, bool toggle) {\n\t//bool toggle = false;\n\tvec4 keyVal = textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 );\n\t//return (keyVal>.5)?true:false;\n    return keyVal;\n}\n\n// save/load code from IQ's shader (multipass): https://www.shadertoy.com/view/MddGzf\nvec4 _loadValue( in ivec2 re ) {\n    return texelFetch( iChannel0, re, 0 );\n    //return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//ugly hack here. couldn't make the float span the whole vec4\n\n//highp vec4 encode32(highp float f) {\n//    return vec4(f, 0., 0., 0.);\n//}\n//highp float decode32(highp vec4 rgba) {\n//    return rgba.x;\n//}\n\nvec4 _encode32(float f) {\n    return vec4(f, 0., 0., 0.);\n}\nfloat _decode32(vec4 rgba) {\n    return rgba.x;\n}\nfloat _loadDecoded(in int x, in int y) { return _decode32(_loadValue(ivec2(x, y))); }\n\n// --------- from rally simulator https://www.shadertoy.com/view/XdcGWS\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n// --------- from rally simulator\n\n\n// ----- start my load/store functions\nvec4 load(ivec2 address) {\n    return texelFetch(iChannel0, address, 0);\n}\n\nvoid store(out vec4 fragColor, vec4 value) {\n    fragColor = value;\n}\n\n// ----- end my load/store functions\n\n// based on\n// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nstruct Intersection { float distance; vec3 color; };\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nIntersection unionOp(Intersection a, Intersection b) {\n    if (a.distance < b.distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nIntersection GetDist(vec3 p) {\n\tvec4 s = vec4(-1, 1, 0, 1);\n    \n    Intersection sphereDist = Intersection(length(p-s.xyz)-s.w, vec3(0.8, 0.4, 0.1));\n    vec3 lightBulbPos = p-vec3(0, 5.5, -2);\n    lightBulbPos.xz -= vec2(sin(iTime), cos(iTime))*3.;\n    Intersection lightBulbDist = Intersection(length(lightBulbPos)-0.4,vec3(0.8, 0.7, 0.4));\n    Intersection planeDist = Intersection(p.y, vec3(0.1, 0.2, 0.9));\n    Intersection boxDist = Intersection(sdBox(p - vec3(1, 1, 0), vec3(.5, .5, .5)), vec3(0.1, 0.6, 0.2));\n    \n    Intersection d = Intersection(1e10, vec3(0));\n    d = unionOp(d, planeDist);\n    d = unionOp(d, sphereDist);\n    d = unionOp(d, lightBulbDist);\n    d = unionOp(d, boxDist);\n    return d;\n}\n\n\nIntersection RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    Intersection intersection;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        intersection = GetDist(p);\n        float dS = intersection.distance;\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return Intersection(dO, intersection.color);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).distance;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).distance,\n        GetDist(p-e.yxy).distance,\n        GetDist(p-e.yyx).distance);\n    \n    return normalize(n);\n}\n\nIntersection GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, -2);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n    vec3 lightRay = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    // surfaces perpendicular to the light are more illuminated\n    float diffuse = clamp(dot(n, lightRay), 0., 1.);\n    \n    // if there's some object between our point and the light, reduce the diffuse light\n    Intersection i = RayMarch(p+n*SURF_DIST*2., lightRay);\n    if(i.distance < length(lightPos-p)) {\n        diffuse *= .1;\n    }\n    \n    return Intersection(diffuse, i.color);\n}\n\n\nmat4 loadMatrix() {\n    return mat4(load(ivec2(1,1)),\n                load(ivec2(2,1)),\n                load(ivec2(3,1)),\n                load(ivec2(4,1))\n                );\n}\n\nvec3 getKeyboardMovement() {\n    vec3 pos = vec3(0, 0, 0);\n    /*\n    pos.y += loadDecoded(0, 0);\n    pos.y -= loadDecoded(1, 1);\n    pos.x += loadDecoded(2, 2);\n    pos.x -= loadDecoded(3, 3);\n    pos.z += loadDecoded(4, 4);\n    pos.z -= loadDecoded(5, 5);\n*/\n    return pos;\n}\n    \nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy - .5)* 4.;\n    \n    vec4 cameraPosition = load(positionAddress);\n    vec4 originalRo = vec4(0., 1.1, 10., 1.);\n    vec3 ro = (cameraPosition + originalRo).xyz;\n    \n    \n    mat4 rotationMatrix = loadMatrix();\n    mat4 transposedRotationMatrix = transpose(rotationMatrix);\n    vec3 zAxisOfRotationMatrix = vec3(rotationMatrix[2][0], rotationMatrix[2][1], rotationMatrix[2][2]);\n    vec3 rd = normalize((vec4(uv.x, uv.y, -1, 1) * rotationMatrix).xyz);\n    \n    vec4 viewMode = ReadKey(Key_V, true);\n    if (viewMode.x == 0.) {\n        Intersection i = RayMarch(ro, rd);\n        \n        vec3 p = ro + rd * i.distance;\n        \n        Intersection diffuse = GetLight(p);\n        \n        //fragColor = vec4(diffuse.color, 1.0);\n        fragColor = vec4(vec3(diffuse.distance), 1.0);\n    } else {\n        vec2 grid = 7.*fragCoord/iResolution.y-1.;\n        ivec2 coord = ivec2(floor(grid));\n        \n        if (coord.x >= 0 && coord.x <= 3 && coord.y >= 0 && coord.y <=3) {\n            fragColor = vec4(rotationMatrix[coord.x][3 - coord.y], 0., 0., 0.)/3.;\n            fragColor.y = -fragColor.x;\n            //fragColor = vec4(fract(grid.x), fract(grid.y), 0.5, 1.);\n            //fragColor = vec4(float(coord.x)*0.5, float(coord.y)*0.125, 0.5, 1.);\n        } else if (coord == mouseAddress) {\n            vec4 mouse = load(coord);\n            if (fract(grid.x) < 0.25) {\n                fragColor = vec4(mouse.x, -mouse.x, 0., 0.);\n            } else if (fract(grid.x) < 0.5) {\n                fragColor = vec4(mouse.y, -mouse.y, 0., 0.);\n            } else if (fract(grid.x) < 0.75) {\n                fragColor = vec4(mouse.z, -mouse.z, 0., 0.);\n            } else {\n                vec4 v_key = ReadKey(Key_V, true);\n                fragColor = v_key;\n            }\n        } else if (coord.x == 5 && coord.y >= 1 && coord.y <= 3) {\n            vec4 cameraPosition = load(positionAddress);\n            fragColor = vec4(cameraPosition[3-coord.y], -cameraPosition[3-coord.y], 0., 0.)/3.;\n        } else if (coord.x == 7 && coord.y >= 1 && coord.y <= 3) {\n            fragColor = vec4(originalRo[3-coord.y], -originalRo[3-coord.y], 0., 0.)/3.;\n        } else if (coord.x == 8 && coord.y >= 1 && coord.y <= 3) {\n            fragColor = vec4(ro[3-coord.y], -ro[3-coord.y], 0., 0.)/3.;\n        } else {\n            fragColor = vec4(0.1, 0.2, 0.8, 1.);\n        }\n    }\n}\n\n\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//jmmut: except for code coming from other people (which I noted and might have modified here), the license is http://www.wtfpl.net/\n\n\nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = false;\n\tfloat keyVal = textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) {\n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\nfloat isInside( vec2 p, vec4 c ) {\n    vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5;\n    return -max(d.x,d.y);\n}\n\n\nvec4 _loadValue( in vec2 re )\n{\n    \n    return texelFetch( iChannel0, ivec2(re), 0 );\n    //return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvec4 _loadValue( in int x, in int y ) { return _loadValue(vec2(x, y)); }\n\n\n//ugly hack here. couldn't make the float span the whole vec4\nhighp vec4 _encode32(highp float f) {\n    return vec4(f, 0., 0., 0.);\n}\nhighp float _decode32(highp vec4 rgba) {\n    return rgba.x;\n}\nfloat _loadDecoded(in int x, in int y) { return _decode32(_loadValue(x, y)); }\nfloat _loadDecoded(in ivec2 re) { return _decode32(_loadValue(vec2(re))); }\n\nvoid _storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid _storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\n\n\n\n// --------- from rally simulator https://www.shadertoy.com/view/XdcGWS\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n// --------- from rally simulator\n\n// ----- start my load/store functions\nvec4 load(ivec2 address) {\n    return texelFetch(iChannel0, address, 0);\n}\n\nvoid store(out vec4 fragColor, vec4 value) {\n    fragColor = value;\n}\n\n// ----- end my load/store functions\n\nmat4 loadMatrix() {\n    return mat4(load(ivec2(1,1)),\n                load(ivec2(2,1)),\n                load(ivec2(3,1)),\n                load(ivec2(4,1))\n                );\n}\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat4 RotY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,  0, -s,  0,\t// matrices are transposed: this line is the first matrix column\n                0,  1,  0,  0,\n                s,  0,  c,  0,\n                0,  0,  0,  1\n               );\n}\nmat4 RotX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(1,  0,  0,  0,\n                0,  c,  s,  0,\n                0, -s,  c,  0,\n                0,  0,  0,  1\n               );\n}\nmat4 RotZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,  s,  0,  0,\n               -s,  c,  0,  0,\n                0,  0,  1,  0,\n                0,  0,  0,  1\n               );\n}\n\n\nvoid reset(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 thisPixelAddress = ivec2(fragCoord);\n    if (thisPixelAddress.y == 1) {\n        // we will only write state to addresses y==1 to simplify\n        mat4 identity = mat4  (1, 0, 0, 0,\n                               0, 1, 0, 0,\n                               0, 0, 1, 0,\n                               0, 0, 0, 1\n                               );\n    \n        if (thisPixelAddress.x >= 1 && thisPixelAddress.x <= 4 && thisPixelAddress.y == 1) {\n            store(fragColor, identity[thisPixelAddress.x-1]);\n        } else if (thisPixelAddress == mouseAddress) {\n            store(fragColor, vec4(0., 0., 0., 0.));\n        }\n    }\n}\nvoid updateRotationMatrix(out vec4 fragColor, vec2 mouse, mat4 rotationMatrix, ivec2 thisPixelAddress) {\n    float mouseSpeed = 0.75;\n    vec4 previousMouse = load(mouseAddress);\n    if (previousMouse.z > 0.) { // avoid jumping when clicking\n        vec2 mouseDiff = vec2(mouse - previousMouse.xy);\n        rotationMatrix = rotationMatrix * RotY(-mouseDiff.x * mouseSpeed); // yaw, external rotation\n        rotationMatrix = RotX(mouseDiff.y * mouseSpeed) * rotationMatrix; // pitch\n    }\n    vec4 column = rotationMatrix[thisPixelAddress.x-1];\n    store(fragColor, column);\n}\n\nvoid composeTransformations(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 thisPixelAddress = ivec2(fragCoord);\n    if (thisPixelAddress.y == 1) {\n        // we will only write state to addresses y==1 to simplify\n        \n        float movement = 0.;\n        mat4 rotationMatrix = loadMatrix();\n        \n        vec2 mouse = (iMouse.xy /iResolution.xy - .5) * 2.;\t// range [-1, 1]\n        \n        if (thisPixelAddress == mouseAddress) {\n            store(fragColor, vec4(mouse.x, mouse.y, iMouse.z, 0.));\n        } else if (thisPixelAddress == positionAddress) {\n            vec4 position = load(positionAddress);\n            float speed = 0.2;\n            float up      = ReadKey(Key_W)? speed : 0.;\n            float down    = ReadKey(Key_S)? speed : 0.;\n            float right   = ReadKey(Key_D)? speed : 0.;\n            float left    = ReadKey(Key_A)? speed : 0.;\n            float forward = ReadKey(Key_E)? speed : 0.;\n            float back    = ReadKey(Key_Q)? speed : 0.;\n            vec4 movement = vec4(right - left, up - down, back - forward, 1.);\n            store(fragColor, movement * rotationMatrix + position);\n        } else if (thisPixelAddress.x >= 1 && thisPixelAddress.x <= 4) {\n            updateRotationMatrix(fragColor, mouse, rotationMatrix, thisPixelAddress);\n        }\n        \n        // I will go crazy if I keep trying to remove this redundant code\n        else if (thisPixelAddress.x == 4) {\n            updateRotationMatrix(fragColor, mouse, rotationMatrix, thisPixelAddress);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        reset(fragColor, fragCoord);\n    } else {\n        composeTransformations(fragColor, fragCoord);\n        //reset(fragColor, fragCoord);\n    }\n}\n\n\n\n\n\n\n\n\n\n    \n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfczl.jpg", "access": "api", "license": "wtfpl-2.0", "functions": [[1418, 1504, 1536, 1536, 1661], [1871, 1871, 1896, 1896, 1930], [1931, 1931, 1959, 1959, 1980], [1981, 1981, 2021, 2021, 2066], [2068, 2140, 2173, 2173, 2221], [2223, 2223, 2256, 2256, 2292], [2294, 2294, 2329, 2329, 2373], [2375, 2375, 2466, 2466, 2536], [2538, 2538, 2629, 2629, 2697], [2735, 2774, 2800, 2800, 2848], [2850, 2850, 2894, 2894, 2919], [3291, 3291, 3322, 3322, 3409], [3411, 3411, 3465, 3465, 3557], [3559, 3559, 3578, 3578, 3654], [3656, 3656, 3686, 3686, 4372], [4375, 4375, 4416, 4416, 4728], [4730, 4730, 4754, 4754, 4979], [4981, 4981, 5012, 5012, 5565], [5568, 5568, 5587, 5587, 5743], [5745, 5745, 5773, 5773, 6023], [6112, 6112, 6168, 6168, 8638]], "test": "untested"}
{"id": "wdsczB", "name": "Voronoi edge tracking III", "author": "michael0884", "description": "Tracking edges and neighbor edges. Loop hack to accelerate compilation times.\n", "tags": ["voronoi"], "likes": 5, "viewed": 557, "published": 3, "date": "1585338404", "time_retrieved": "2024-07-30T21:16:22.299882", "image_code": "float gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nedges gete(ivec2 p)\n{\n    edges e;\n    ivec4 A = floatBitsToInt(texel(ch2, p));\n    for(int i = 0; i < 4; i++)\n    {\n        e.ids[i] = A[i]%tot_n;\n        e.ids[i+4] = A[i]/tot_n;\n    }\n    return e;\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nbool loadparticles(in edges e, inout vec2[8] xy)\n{\n    for(int i = 0; i < 8; i++)\n    {\n        if(e.ids[i] < 0) return false;\n        xy[i] = getParticle(e.ids[i]).xy;\n    }\n    return true;\n}\n\nvec2 getCC(inout edges e, inout vec2[8] xy, int i) //get circumcenter\n{\n    int j = bitreverse3(i);\n    ivec2 par = getParents(j);\n    ivec2 id = ivec2((par.x + j)%8,(par.y + j)%8); \n    //get the circumcenter for this branch of the binary tree\n    if(any(equal(ivec3(e.ids[j],e.ids[id.x],e.ids[id.y]),\n                 ivec3(e.ids[id.x],e.ids[id.y],e.ids[j])))) return vec2(0.);\n    vec2 cc = circumcenter(xy[j], xy[id.x], xy[id.y]);\n \treturn cc; \n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat getEdgeDistance(ivec2 p, vec2 pos)\n{\n    edges e = gete(p);\n    vec2 xy[8];\n    if(!loadparticles(e, xy)) return 1e10;\n    vec4 edge0 = vec4(getCC(e, xy, 2),getCC(e, xy, 3));\n    vec4 side1 = vec4(getCC(e, xy, 4),getCC(e, xy, 5));\n    vec4 side2 = vec4(getCC(e, xy, 6),getCC(e, xy, 7));\n    float d = sdSegment(pos, edge0.xy, edge0.zw);\n    d = min(d, sdSegment(pos, edge0.xy, side1.xy));\n    d = min(d, sdSegment(pos, edge0.zw, side1.zw));\n    d = min(d, sdSegment(pos, edge0.xy, side2.xy));\n    d = min(d, sdSegment(pos, edge0.zw, side2.zw));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec4 mouse = iMouse;\n    if(mouse.z == 0.) mouse.xy = size*0.5;\n    pos = pos*0.15 + mouse.xy;\n    ivec2 p = ivec2(pos);\n    //get closest edge \n \t//edges e = gete(p);\n    //float D = float(e.ids[3]);\n    float D = gauss(getEdgeDistance(p, pos), 0.5);\n    float M = 2.*gauss(getEdgeDistance(ivec2(mouse.xy + 0.075*size), pos), 1.);\n    fragColor = 0.5 + 0.5*sin(vec4(1,3,1,4)*D + vec4(3,2,1,4)*M);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(64,64)\n#define dt 0.3\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\n\nconst int tot_n = N.x*N.y;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nvec2 circumcenter(vec2 x, vec2 y, vec2 z)\n{\n    vec2 xy = y - x;\n    vec2 xz = z - x;\n    vec2 a = 0.5*(x+y);\n    vec2 b = 0.5*(x+z);\n    vec2 d = vec2(dot(xy,a), dot(xz,b));\n    float det = determinant(mat2(xy, xz));\n    return vec2(determinant(mat2(d.x, xy.y, d.y, xz.y)),determinant(mat2(xy.x, d.x, xz.x, d.y)))/det;\n}\n\nstruct edges\n{\n    int ids[8];\n};\n    \n    \n//reverse the order of 3 bits\nint bitreverse3(int i)\n{\n    return ((i&1)<<2) +\n            (i&2) +\n           ((i&4)>>2);    \n}\n\nivec2 getParents(int i)\n{\n    if(i%2 == 0) return ivec2(-2,2);\n    return ivec2(-1,1);\n}\n    ", "buffer_a_code": "//particle buffer\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return -1./(1.+0.05*d);\n}\n\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    return normalize(p1-p0)*F(distance(p1,p0));\n}\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    if(p.x > N.x || p.y > N.y) discard;\n    \n    pos = floor(pos);\n    \n    //this pixel value\n    U = texel(ch1, pos);\n    int id = xy2i(p);\n\n    //neighbors\n    ivec4 cp = get(ivec2(U.xy));\n    vec4 p1 = getParticle(cp.y);\n    vec4 p2 = getParticle(cp.z);\n    vec4 p3 = getParticle(cp.w);\n\n    vec2 F = Fv(U.xy, p1.xy) +\n             Fv(U.xy, p2.xy) +\n             Fv(U.xy, p3.xy);\n\n    ivec4 mnb = get(ivec2(iMouse.xy));\n\n    if(any(equal(ivec2(id),mnb.xy)) && iMouse.z>0.)\n    {\n        F += 0.0*(iMouse.xy - iMouse.zw); \n    }\n\n    U.xy += F*dt;\n\n    if(size.x - U.x < 2.) U.x = size.x - 2.;\n    if(U.x < 2.) U.x = 2.;\n    if(size.y - U.y < 2.) U.y = size.y - 2.;\n    if(U.y < 2.) U.y = 2.;\n\n    //this pixel value\n    if(iFrame<1)\n    {\n        U.xy = size*hash22(pos);\n        U.zw = 2.*(hash22(3.14159*pos) - 0.5);\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    loop(8)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    loop(4)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//2nd order edge tracking\nvec2 xy[8];     \nedges E;\nint n;\n\nivec4 GET(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nedges get(ivec2 p)\n{\n    edges e;\n    ivec4 A = floatBitsToInt(texel(ch2, p));\n    for(int i = 0; i < 4; i++)\n    {\n        e.ids[i] = A[i]%tot_n;\n        e.ids[i+4] = A[i]/tot_n;\n    }\n    return e;\n}\n\nvec4 save()\n{\n    return intBitsToFloat(ivec4(E.ids[0],E.ids[1],E.ids[2],E.ids[3]) + \n                          ivec4(E.ids[4],E.ids[5],E.ids[6],E.ids[7])*tot_n);\n}\n\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nbool isSame(ivec3 a, ivec3 b) //is the id triplet the same\n{\n    return any(equal(a.xxx,b)) && any(equal(a.yyy,b)) && any(equal(a.zzz,b));\n}\n\nbool isEdgeParticle(int id, vec2 pxy, ivec2 id2, vec4 nbxy)\n{\n    //edge point guess\n    vec2 cc = circumcenter(nbxy.xy, nbxy.zw, pxy);\n    //check the voronoi diagram at the guess\n    if(cc.x > size.x-1. || cc.y > size.y-1. || cc.x < 0. || cc.y < 0.) return false;\n    ivec4 t = GET(ivec2(cc));\n    //the first 3 closest particles at the edge point pretty much always are the particles that produce the edge\n    return isSame(t.xyz, ivec3(id2, id));\n}\n\n\n\n//edge store\nvoid store(int utemp)\n{\n\tvec4 part = getParticle(utemp);\n    for(int i = 0; i < 8; i++)\n    {\n        if(E.ids[i] == utemp) return;\n    }\n    int j; bool found = false;\n\tloop(8)\n    {\n        j = bitreverse3(i);\n        if(E.ids[j] >= 0) continue;\n        ivec2 par = getParents(j);\n        ivec2 id = ivec2((par.x + j)%8,(par.y + j)%8); \n        ivec2 pid = ivec2(E.ids[id.x],E.ids[id.y]);\n        vec4 pxy = vec4(xy[id.x],xy[id.y]);\n        if(isEdgeParticle(utemp, part.xy, pid, pxy)) {\n         \tfound = true;\n            break;\n        }\n    }\n    \n    if(found)\n   \tfor(int i = 0; i < 8; i++)\n    {\n        if(i==j)\n        {\n            E.ids[j] = utemp;\n            xy[j] = part.xy;\n        }\n    }  \n}\n\nvoid storepos(ivec2 p)\n{\n    ivec4 nb = GET(p);\n    loop(4)\n    {\n        store(nb[i]);\n    }\n  \n}\n\nvoid storeE(in edges e)\n{\n    loop(8)\n    {\n        store(e.ids[i]);\n    }\n}\n\nvoid storeedge(ivec2 p)\n{\n   edges e = get(p);\n   storeE(e);\n}\n\nbool isUndef()\n{\n    loop(8)\n    {\n        if(E.ids[i] < 0) return true;\n    }\n    return false;\n}\n\n\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    \n    ivec2 p = ivec2(pos);\n\n    for(int i = 0; i < 8; i++)\n    {\n        xy[i] = vec2(1e10);\n        E.ids[i] = -1;\n    }\n    \n    //set parents of the binary tree;\n    ivec4 closest = GET(p);\n    E.ids[0] = closest.x;\n    E.ids[4] = closest.y;\n    xy[0] = getParticle(closest.x).xy;\n    xy[4] = getParticle(closest.y).xy;\n    \n    //jump flood sorting \n    \n    //prev edge \n    edges e = get(p);\n    \n    storeE(e); //resort this position\n    storepos(p);\n    \n    loop(4)\n    {\n        storeedge(p+cross_distribution(i));\n        store(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    loop(12)\n    {\n        storepos(p+cross_distribution(i));\n    }\n    \n    if(isUndef())\n    {\n        E = e;\n \t\tfor(int i = 0; i < 8; i++)\n    \t{\n            E.ids[i] = (E.ids[i] < 0)?i:E.ids[i];\n        }\n    }\n    \n    U = save();\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 65], [67, 67, 87, 87, 131], [133, 133, 154, 154, 335], [337, 337, 363, 363, 398], [1047, 1047, 1099, 1099, 1218], [1220, 1220, 1262, 1262, 1786], [1788, 1788, 1839, 1839, 2243]], "test": "untested"}
{"id": "tdfyRl", "name": "Day 99", "author": "jeyko", "description": "potato!!!!!!", "tags": ["mdtmjvm"], "likes": 59, "viewed": 1274, "published": 3, "date": "1585332389", "time_retrieved": "2024-07-30T21:16:23.405925", "image_code": "// All geodesic reflection functions and are from tdhooper! shadertoy.com/view/4tG3zW\n// They are in common tab! \n\n// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.04;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*2.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor.b *= 0.97 + dot(uvn,uvn)*0.1;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    fragColor = pow(fragColor, vec4(0.4545));\n    \n    fragColor.b *= 1. + uv.x*0.2;\n    fragColor.g *= 1. + uv.t*0.05;\n    \n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI acos(-1.)\n\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm 140.\n\n#define tick (60./bpm)\n\n#define beat tick\n#define bar  beat*4.\n#define hbar  bar/2.\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\nint Type=5;\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);\n}\n\nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\n\n\n\nvec3 pIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n\n        float d = .5;\n        \n        vec3 p1 = bToC(A, B, C, vec3(1.-d, .0, d));\n        vec3 p2 = bToC(A, B, C, vec3(1.-d, d, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n    \n    return pca;\n}\n\n\n\n\n", "buffer_a_code": "\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\nfloat kick;\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy) + f.xy;\n\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, pow(f.z, 0.05) );\n}\nvec3 glow = vec3(0);\n\nvec3 ro;\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec2 map(vec3 p, float t){\n\tvec2 d = vec2(10e6);\n\n    \n    vec3 q = p;\n    \n    \n   \tvec3 n = pIcosahedron(p, int(1.));\n    n = pIcosahedron(p, int(1.));\n    \n    float dP = length(p.yx) - 0.01;\n    \n    p.x -= 0.12;\n    \n    n = pIcosahedron(p, int(2.));\n    \n\t\n    \n    p.z = log(p.z + 0.) - iTime*0.44;\n    \n    p.z = sin(0.5*p.z*6.28) - 0.5;\n    \n    float modD = 1.;\n    \n    float id = floor(p.z/modD);\n    \n    //p.z = pmod(p.z, modD);\n    \n    //p.z -= 0.1;\n    \n    p.x *= log(p.y)*1.;\n    //p.xz *= rot(-1.4);\n    p.x -= 0.1;\n    p.xz *= rot(-1.4);\n    \n    //p.x -= 0.4;\n    //p.y -= 0.4;\n    \n    //d.x =  length(p) - 0.44;\n    \n    \n    \n    float dc = length(p.z) - 0.06;\n    \n    \n    \n    //dc = max(dc, -abs(p.x) + 0.09);\n    dc = max(dc, -abs(p.x) + 0.7);\n    //dc = max(dc, -abs(p.y) + 0.14);\n    //dc = max(dc, -abs(p.y) + 0.44);\n    d.x =  min(d.x, dc);\n    \n    \n    d.x = abs(d.x) + 0.001;\n    \n    //vec3 c = pal(0.1, 0.5, vec3(0.9,0.2,0.1), 0.6,4.7 + t*6. + iTime + p.z*0.2);\n    //vec3 c = pal(0.4, 0.5, vec3(0.9,0.2,0.05), 1.4, t*2. + iTime + p.z*0.2);\n    vec3 c = pal(0.4, 0.5, vec3(1.4,0.9,0.3), 1.4, t*2. + iTime + p.z*0.2);\n    c = max(c, 0.);\n    vec3 ga = 0.0007/(0.1 + d.x*d.x*d.x*d.x*d.x*20000000000.) * c;\n    \n    vec3 gb = 0.0004/(0.1 + d.x*d.x*d.x*d.x*d.x*2000.) * pal(0.6,0.1, vec3(0.7,0.2,0.5),0.67,0.2);\n    \n    //glow += mix(ga,gb, smoothstep(0.,1.,length(ga)*400.));\n    glow += ga;\n    \n    d.x =  min(d.x, abs(dP) + 0.01);\n    float at = pow(abs(sin(q.z - iTime + n.y)), 200.)*smoothstep(0.,1.,length(q.z)*0.4);\n    //glow  += 0.001/(0.006 + dP*dP*dP*100.) * pal(0.5,0.5, vec3(0.7,0.2,0.5),0.67,0.2)*at;\n    \n    d.x *= 0.6;\n    \n    return d;\n}\nfloat it = 0.;\nfloat dith = 0.;\nvec2 march(vec3 ro, vec3 rd,inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n    \n    t = 0.; hit = false; p = ro;\n    \n    for(it = 0.; it < 110. + min(float(iFrame), 0.) ; it++){\n    \td = map(p,t);\n     \td.x += 0.01*pow(smoothstep(1.,0.,t*0.2), 2.5);\n        d.x *= dith;\n        t += d.x;\n    \tp = ro + rd*t;\n    }\n    \n    \n\treturn d;\n}  \n\nvec3 getRd(vec3 ro,vec3 lookAt,vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + (right*uv.x + up *uv.y)*0.8);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    initIcosahedron();\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    dith = mix(0.9,1.,texture(iChannel0, 4000.*(uv + 0.5 + iTime*0.05)/256.).x);\n    uv *= 1. + dot(uv,uv)*0.2;\n    vec3 col = vec3(0);\n\n    \n    vec3 ro = vec3(0);\n    \n    \n    float sp = 0.3;\n    \n    float tt = iTime*sp ;\n    ro = vec3(cos(tt+ iMouse.x/iResolution.x*2.),sin(tt+ iMouse.y/iResolution.x*2.)*1.6,sin(tt+ iMouse.x/iResolution.x*2.))*(4.1);\n    \n    vec3 lookAt = vec3(0);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    bool hit; float t; vec3 p;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    \n    \n    \n    glow = smoothstep(0.,1.,glow*1.);\n    //glow = smoothstep(0.,1.,glow*1.);\n    col += glow;\n    \n    \n    //col -= smoothstep(0.,1.,it*0.0009)*0.8;\n    //col -= pow(smoothstep(0.,1.,it*0.0045), 10.)*2.4;\n    \n    \n    //col = mix(col, vec3(0.,0.1,0.2)*0.2,pow(smoothstep(0.,1.,t*0.2), 2.));\n    //col = mix(col, vec3(0.1,0.,0.1)*0.002,pow(smoothstep(0.,1.,t*0.1), 1.));\n    \n    \n    col = max(col, 0.);\n    col *= 9.;\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n\nfloat[] probK = float[16](0.9,0.1,0.9,0.2,0.4,0.9,0.1,0.9,0.2,0.4,0.9,0.,0.9,0.1,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,T,F,T,T,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\n\n\nbool[] pattBa = bool[8](T,T,F,T,F,T,F,T);\nbool[] pattB = bool[8](T,T,T,T,T,T,T,T);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst vec4 cmin9 = vec4(0.,3.,7.,14.);\nconst vec4 cmin7 = vec4(0.,3.,7.,10.);\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.);\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.);\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.);\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.);\n\nvec4[] chords = vec4[4](\n    cmaj7f15,\n    cmaj7 - 4.,\n    cmin9 - 7.,\n    cmaj9 - 4.\n);\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/amt)*amt\n\n\nvec2 kick(float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.00002);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp(-t*20.1)*240. + 30.)*tt )*env;\n    \n    s = mix(s,sin(s*3.)*1., 0.3);\n    \n    \n    bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattK[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\n    init;\n    \n    \n    //sampleratereduction(t, 0.00001);\n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 5000.)*0.9;\n    nn += lpnoise(t, 16500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*30.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (300./1. + exp(-t*14.)*1100.  )*tt;\n    s += sin( f + nn.x*0.2)*env;\n    s += sin( f*2.5 + nn.y*4.6)*pow(env, 0.8)*0.7;\n    s += sin( pow(f, 1.01)*4. )*env*0.3;\n    \n    \n    \n    s += sin( f*1.5 )*env*0.1;\n    s *= 0.2;\n    //bitreduction(s, 0.001);\n    //s += sin( f*2. )*env*0.1;\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    sampleratereduction(t, 0.00002);\n    float to;\n    vec2 nn = lpnoise(t, 600.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float amt = 1.;\n    float env = exp(-t*10.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*0.4)*env;\n    s -= sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    //s += sin(f + sin(2000.*tt)*exp(-t*20.))*env;\n    \n    \n    \n    \n    //bitreduction(s, 0.0);\n    s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    //sampleratereduction(t, 0.001);\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 32. / 2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float env = exp(-t*9.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 2.) *tt + \n             \t+sin(note(n, 4.) *tt)*exp(-t*1.)*0.4\n                 \n                 )*exp(-t*9.)*1. \n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*1.)*0.1 \n                 \n                 )*exp(-t*9.)*1.5\n            )*env;\n    \n    \n    s *= 1.;\n    \n    \n    //bitreduction(s, 0.3);\n    //s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    sampleratereduction(t, 0.00001);\n    float r = bar;\n    t = mod(t,r*4.);\n    int id = int(floor(t/r));\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 4500.)*0.45;\n    \n    nn *= 0.1*sin(t);\n    float m = 1.;\n    float width = 10.;\n    s += sin( note(chords[id].x, 3.) *tt + nn.x);\n    s += sin( note(chords[id].y, 3.) *tt + nn.x);\n    for(float i = 0.; i < 4.; i++){\n        float a = (1. + i/4.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, 4.) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, 4.) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    //bitreduction(s, 0.04);\n    \n    s *= 0.03;\n    s = sin(s*2.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat*0.5);\n    \n    sampleratereduction(t, 0.00005);\n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 1500.)*0.4;\n    \n    float amt = 0.2;\n    float env = exp(-t*15.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.8);\n    s *= 0.5;\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*10.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.35;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.7;\n    ret;\n}\nvoid initKickPatt(float t){\n\t\n    float r = beat/4.;\n    \n    float id = floor(t/r);\n    \n    \n    for(int i = 0; i < 16; i++){\n        \n        vec4 r = r11(id + float(i));\n        \n    \tpattK[i] = r.x < probK[i];\n        \n    }\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    //t += msr*4.;\n    vec2 s= vec2(0);\n    \n    initKickPatt(t);\n    \n    float sc;\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(pow(sc,4.4))*0.2;\n    vec2 hb= hatsb(t)*(pow(sc,4.4))*0.1;\n    vec2 bass = bass(t)*(pow(sc,1.4))*0.4;\n    vec2 c = chord(t)*(pow(sc,2.8))*0.7;\n    vec2 l = lead(t)*(pow(sc,1.))*0.25;\n    \n    \n    if(t < msr){\n        t = mod(t,msr);\n    \ts += c;\n        \n        if(t > bar){\n    \t\ts += bass;\t\n        }\n        if(t > bar + beat){\n        \ts += l;\n        }\n        if(t > beat*14.){\n    \t\ts += k;\n        }\n    } else if (t < msr*2.){\n    \ts += k;\n    \ts += sn;\n        s += ha;\n        s += c;\n        s += bass;\t\n        //s += l;\n    } else if (t < msr*4.){\n        t = mod(t,msr);\n    \ts += k;\n    \ts += sn;\n        s += ha;\n        s += hb;\n        s += c;\n        s += bass;\t\n        if(t > msr*3.5){\n        \ts -= c;\n        \ts += l;\n        }\n    } else {\n        t -= msr*4.;\n    \ts += k;\n    \ts += sn;\n        s += ha;\n        s += hb;\n        s += c;\n        s += bass;\t\n        //s -= c;\n        s += l;\n    \tbitreduction(s, (0.01 + smoothstep(0.,1.,t*0.01)));\n    }\n    \n    s *= 0.1;\n    \n    s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), (0.3 + sin(t)*0.2)*0.);\n    s = clamp(s,-1.,1.);\n    \n    //s *= smoothstep(0.,1.,t*0.5);\n    return s;\n}", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 204, 204, 1385]], "test": "untested"}
{"id": "Wdfczs", "name": "First Ray Marcher", "author": "brechrt", "description": "my first ray marcher", "tags": ["raymarching"], "likes": 1, "viewed": 344, "published": 3, "date": "1585321520", "time_retrieved": "2024-07-30T21:16:24.300532", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat getDist(vec3 p){\n\tvec4 s = vec4(0., 1., 6., 1.);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    float d = min(sphereDist, planeDist);\n    \n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n\tfloat dO = 0.;\n        \n  \tfor(int i = 0; i < MAX_STEPS; i++){    \t\n   \t\tvec3 p = ro + rd*dO;\n        float ds = getDist(p);\n        dO += ds;\n        if(ds < SURF_DIST || dO > MAX_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 getNormal(vec3 p){\n\tvec2 e = vec2(.01, .0);\n    float d = getDist(p);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat getLight(vec3 p){\n \tvec3 lightPos = vec3(0., 5., 6.);\n    lightPos.xz += vec2(cos(iTime), sin(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    float diff = clamp(dot(l, n), 0., 1.);\n    \n    float d = rayMarch(p+n*SURF_DIST*2., l);\n    if(d < length(p-lightPos)) diff*= .1;\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro =  vec3(0., 1., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    float d = rayMarch(ro, rd);\n \tvec3 p = ro + rd*d;\n    \n    col = vec3(getLight(p));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdfczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 89, 89, 255], [257, 257, 290, 290, 513], [514, 514, 537, 537, 723], [725, 725, 748, 748, 1055], [1057, 1057, 1114, 1114, 1435]], "test": "untested"}
{"id": "wsscRX", "name": "voronoi noise", "author": "jorgemoag", "description": "voronoi", "tags": ["voronoi", "noise"], "likes": 3, "viewed": 312, "published": 3, "date": "1585319516", "time_retrieved": "2024-07-30T21:16:25.204117", "image_code": "vec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(54312.1031, -9137.1030, 6148.0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return -1.0 + 2.0 * fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 map(vec2 uv)\n{\n    float c = 0.;\n    float t = 0.2 * iTime + 100.0;\n    \n    float md = 100.;\n        \n    for (float id = 0.; id < 50.; ++id)\n    {        \n        vec2 h = hash22(vec2(id));\n        vec2 p = (0.5 * sin(h * t) + 0.25 * sin(2. * h * t)) / 0.75;\n        \n        float d = length(p - uv);\n        \n        float c1 = 1. - smoothstep(0.0, 0.075, d);\n        \n        c += c1;\n        \n        md = min(d, md);        \n    }\n    \n    return vec2(c, md);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.xy;\n\t\n    vec2 m = map(uv);\n    \n    float eps = 0.001;\n    vec3 norm = normalize(vec3(map(uv + vec2(eps, 0.)).y - m.y,\n                \tmap(uv + vec2(0., eps)).y - m.y,\n                    -eps));\n    \n    vec3 dift = vec3(0.3176, 0.4765, 0.506) * max(0., dot(vec3(sin(iTime), 0.9, 0.1), norm));\n    vec3 difb = vec3(0.988, 0.839, 0.545) * max(0., dot(vec3(cos(iTime), -0.6, 0.1), norm));\n    \n    vec3 diff = (0.5 * m.y) * (dift + difb);\n    \n    fragColor = vec4(diff + 0.2 * m.x + vec3(m.y), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsscRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 181], [183, 183, 202, 202, 656], [658, 658, 715, 715, 1281]], "test": "untested"}
{"id": "3sXcRl", "name": "Linked Rings 2", "author": "dr2", "description": "Several Moebius strips (an update of the original)", "tags": ["moebius"], "likes": 16, "viewed": 366, "published": 3, "date": "1585301660", "time_retrieved": "2024-07-30T21:16:26.075786", "image_code": "// \"Linked Rings 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nmat3 vuMat;\nvec3 ltDir;\nfloat dstFar, tCur, mobRad;\nconst float pi = 3.14159;\n\nfloat MobiusTDf (vec3 p, float r, float b, float rc, float ns)\n{\n  vec3 q;\n  float d, a, na, aq;\n  p.xz = Rot2D (p.xz, 0.2 * tCur);\n  q = vec3 (length (p.xz) - r, 0., p.y);\n  a = atan (p.z, p.x);\n  q.xz = Rot2D (q.xz, 0.5 * a);\n  d = length (max (abs (q.xz) - b, 0.)) - rc;\n  q = p;\n  na = floor (ns * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / ns;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 0.5 * aq);\n  d = min (d, PrBoxDf (q, vec3 (1.2, 1.2, 0.33) * b));\n  return 0.7 * d;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, a, aq, na;\n  p.xz = Rot2D (p.xz, 0.25 * pi);\n  q = p;\n  q.z = abs (q.z) - 1.4 * mobRad;\n  d = MobiusTDf (q, mobRad, 0.5, 0.01, 24.);\n  q = p;\n  q.y = abs (q.y) - 1.4 * mobRad;\n  d = min (d, MobiusTDf (q.xzy, mobRad, 0.5, 0.01, 24.));\n  q = p;\n  d = min (d, MobiusTDf (q.zxy, mobRad, 0.5, 0.01, 24.));\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd = rd * vuMat;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (0.05 * tCur + rd.xy / rd.z);\n  return mix (mix (vec3 (0., 0., 0.6), vec3 (1.), 1.4 * Fbm2 (2. * u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ror, rdr, vn, col;\n  float dstObj, dstObjR, reflFac;\n  dstObj = ObjRay (ro, rd);\n  reflFac = 1.;\n  if (dstObj < dstFar) {\n    ror = ro + dstObj * rd;\n    rdr = reflect (rd, ObjNf (ror));\n    ror += 0.01 * rdr;\n    dstObjR = ObjRay (ror, rdr);\n    if (dstObjR < dstFar) {\n      dstObj = dstObjR;\n      ro = ror;\n      rd = rdr;\n      reflFac = 0.7;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    col = vec3 (0.3, 0.3, 0.6) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    col = reflFac * mix (col, BgCol (reflect (rd, vn)), 0.5);\n  } else col = 0.7 * BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.05 * tCur;\n    el -= 0.2 * pi * cos (0.05 * tCur);\n  }\n  dstFar = 50.;\n  mobRad = 2.5;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 2.8));\n  ro = vuMat * vec3 (0., 0., -20.);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXcRl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[321, 321, 385, 385, 835], [837, 837, 859, 859, 1195], [1197, 1197, 1230, 1230, 1407], [1409, 1409, 1430, 1430, 1678], [1680, 1680, 1702, 1702, 2010], [2012, 2012, 2047, 2047, 2748], [2750, 2750, 2806, 2806, 3445], [3447, 3447, 3479, 3479, 3574], [3576, 3576, 3606, 3606, 3719], [3721, 3721, 3757, 3757, 3963], [3997, 3997, 4021, 4021, 4133], [4135, 4135, 4160, 4160, 4346], [4348, 4348, 4369, 4369, 4524]], "test": "untested"}
{"id": "tdsyRf", "name": "chromaspiral", "author": "scry", "description": "it is what it is", "tags": ["2d"], "likes": 8, "viewed": 568, "published": 3, "date": "1585277108", "time_retrieved": "2024-07-30T21:16:26.823786", "image_code": "#define iTime iTime*0.05\n\nvec2 rotate2d(vec2 uv, float a) {\n    uv -= 0.5;\n    uv *= mat2(sin(a),cos(a),-cos(a),sin(a));\n    uv += 0.5;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n    float loop = 30.*0.1;\n    float it = abs(mod(iTime+loop,loop*2.)-loop);\n    float a = it*it*it*length(uv-0.5);\n    for (int i=0;i<6;i++) {\n        \n        float fi = float(i);\n        uv -= 0.5+fi*0.005;\n        uv += vec2(sin(iTime*3.+fi*15.),cos(iTime*2.+fi*15.))*cos(iTime*0.1);\n        uv += 0.5-fi*0.005;\n        uv = rotate2d(uv,-iTime+length(uv-0.5));\n    }\n    uv *= 0.5;\n    float sint = cos(iTime*1.5)*20.;\n    col.r += sin(uv.x*11.+sint)+sin(uv.y*90.);\n    uv += 0.1;\n    uv += iTime*0.01;\n    col.g += sin(uv.x*11.+sint)+sin(uv.y*99.);\n    uv += 0.1;\n    uv -= iTime*0.012;\n    col.b += sin(uv.x*11.+sint)+sin(uv.y*91.);\n    col = sin(col*1.4);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 59, 59, 152], [154, 154, 211, 211, 972]], "test": "untested"}
{"id": "3dsczf", "name": "muhvoronoi", "author": "Mogster", "description": "describe your shader", "tags": ["voronoi"], "likes": 5, "viewed": 288, "published": 3, "date": "1585263511", "time_retrieved": "2024-07-30T21:16:27.573781", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 5.0;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n            \n            point += (point - iMouse.xy) * 100.0;\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n           \n        }\n    }\n\n    // Draw the min distance (distance field)\n    //color += m_dist;\n\n    // Draw cell center\n    color += 1.0;\n\n\n    // Draw grid\n    //color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n    // Show isolines\n\n        color = color * mix(0.0, 1.0, cos(m_dist * 100.0)) - mix(1.0, 0.5, m_dist * 1.) * step(0.1, cos(50.0 *m_dist));\n        color.r *= mix(0.0, 1.0, m_dist * 1.5);\n    if (m_dist >= 1.0) color = vec3(0.0);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 176, 176, 1619]], "test": "untested"}
{"id": "3dfczN", "name": "大龙猫 - Quicky#028", "author": "totetmatt", "description": "My first tunnel, thanks to Flopine last stream for the code.", "tags": ["quicky"], "likes": 18, "viewed": 556, "published": 3, "date": "1585257838", "time_retrieved": "2024-07-30T21:16:28.432485", "image_code": "#define hr vec2(1.,sqrt(3.))\n\nvec4 hexagrid(vec2 uv,float detail){\n    uv*=detail;\n    vec2 ga = mod(uv,hr)-hr*.5;\n    vec2 gb = mod(uv-hr*0.5,hr) - hr*.5;\n    vec2 guv = (dot(ga,ga) < dot(gb,gb)) ? ga : gb;\n    vec2 gid = uv - guv;\n    return vec4(guv,gid);\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nfloat trigrid(vec2 uv) {\n   return sign(fract(uv.x+0.5*uv.y)-fract(uv.y));\n}\n\n\nfloat cyl(vec3 p, float r, float h){\n \n    return max(length(p.xy)-r,abs(p.z)-h);\n}\n#define pTime floor(iTime*.01) + pow(fract(iTime*.01),.9)\n#define qTime floor(-iTime*2.) + pow(fract(-iTime*2.),1.5)\nfloat tunnel(vec3 p){\n        p.x += texture(iChannel0,p.xz*.01+vec2(0.,pTime)).x*4.;\n        p.y += texture(iChannel0,p.yz*.01+vec2(0.,pTime)).y*2.;\n         \n       return -cyl(p+vec3(cos(p.z*.1)*2.,sin(p.z*.1)*2.,0.),10.-p.z*.1,1000000.);\n}\n\nfloat box(vec3 p, vec3 c){\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\nfloat SDF(vec3 p) {\n    vec3 pp = p;\n    p.xz *= r(3.141592*.5);\n \n    pp.xy*=r((iTime*.02+pp.z*.05));\n    return tunnel(pp);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n   \n    vec3 ro  = vec3(.001,.001,-3.),\n    rd = normalize(vec3(uv,1.)),\n    p=ro,\n    col = vec3(0.);\n    \n    \n    \n    float shad = 0.;\n    for(float i=0.;i<256.;i++){\n         \n       float d = SDF(p);\n       if(d <0.001){\n        shad = i/64.;\n        break;\n       }\n       p += d*rd*1.1;\n    }\n    \n    vec4 h = hexagrid(uv,5.);\n    vec2 hg = h.xy;\n    vec2 hid = h.zw;\n  \n    col = vec3(shad);\n      vec3 mm = mix(vec3(cos(iTime),.5,.9),vec3(.9,sin(iTime),.1),sin(iTime*.5)*.5+.5);\n    \n    \n      float q = abs(tan( (qTime+p.z*.1)*.25));\n     col = mix(vec3(.1),vec3(mm.r*q,mm.g*q,mm.b*q),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 66, 66, 260], [261, 261, 277, 277, 335], [336, 336, 360, 360, 412], [415, 415, 451, 451, 498], [616, 616, 637, 637, 859], [861, 861, 887, 887, 972], [973, 973, 992, 992, 1100], [1103, 1103, 1158, 1158, 1858]], "test": "untested"}
{"id": "WslyzX", "name": "Impossible Ring", "author": "yx", "description": "Just a quick doodle :)\n\nInspired by the works of Matt Taylor https://www.instagram.com/emty01/", "tags": ["escher", "impossible"], "likes": 136, "viewed": 4218, "published": 3, "date": "1585251961", "time_retrieved": "2024-07-30T21:16:29.266256", "image_code": "#define pi (acos(-1.))\n#define tau (pi*2.)\n\nmat2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - (b-r);\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0)-r;\n}\n\nfloat sdRect( vec2 p, vec2 b, float r )\n{\n    vec2 d = abs(p) - (b-r);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-r;\n}\n\nfloat scene(vec3 p)\n{\n    float flip = step(gl_FragCoord.x,iResolution.x*.5)*2.-1.;\n    float time = flip*iTime;\n    \n    p.yz *= rotate(pi*.25*flip);\n    \n    vec3 a = vec3(\n\t\tlength(p.xz),\n        p.y,\n        atan(p.x,p.z)\n\t);\n    \n    a.z = fract((a.z/tau)*8.+time)-.5;\n    a.x -= 1.;\n    a.xy = abs(a.xy)-.25;\n    \n    float r = .02;\n    float d = min(\n        sdBox(a,vec3(.2,.2,.4),r),\n        sdRect(a.xy,vec2(.15),r)\n    );\n    return d;\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n\tvec3 color = vec3(.2,.1,.9);\n\n    float t=0.;\n    float k=0.;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t);\n        t += k;\n        if (abs(k) < .001)\n            break;\n    }\n\n    if (abs(k) < .001)\n    {\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001, 0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n\n        float A = .1;\n        float B = scene(h+n*A);\n        float fakeAO = clamp(B/A,0.,1.);\n        fakeAO = pow(fakeAO,.6)*.5+.5;\n\n        float light = 0.;\n        vec3 lightDir = normalize(vec3(1,4,-4));\n        \n        // wrap diffuse\n        light += dot(n,lightDir)*.7+.3;\n\t\t\n        // specular\n        vec3 H = normalize(lightDir+dir);\n\t\tfloat NdotH = dot(n, H);\n\t\tlight += pow(max(NdotH,0.), 3.)*30.;\n\n        return light * fakeAO * color;\n    }\n    \n    float gradient = pow(.8,dot(cam.xy,cam.xy));\n    return mix(color,vec3(1),gradient);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(uv*3.,-5.);\n    vec3 dir = vec3(0,0,1);\n\n    out_color.rgb = pow(trace(cam,dir),vec3(.45));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 66, 66, 139], [141, 141, 181, 181, 278], [280, 280, 321, 321, 409], [411, 411, 432, 432, 859], [861, 861, 893, 893, 1907], [1909, 1909, 1961, 1961, 2167]], "test": "untested"}
{"id": "WsscRX", "name": "C64 Simon's Basic Rings", "author": "ssdsa", "description": "Draws black-and-white concentric rings around 11 random points. \nInspired by https://www.forum64.de/index.php?thread/100980-basic-programme-wirbleibenzuhause/&postID=1501752#post1501752", "tags": ["rings", "c64"], "likes": 3, "viewed": 537, "published": 3, "date": "1585249038", "time_retrieved": "2024-07-30T21:16:30.051157", "image_code": "vec2 randompoint( in float anim, in float n )\n{\n    vec2 ab = vec2(sin(anim*0.01+n*n)+sin(anim*0.039)+cos(anim*0.0071),\n                   cos(anim*0.011+n/17.0)+sin(anim*0.036+n*1.3)+cos(anim*0.0078));\n    return vec2(1.25*sin(n*1.7+ab.x), cos(n+ab.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n    \n    float r =  length(uv - randompoint(iTime,  0.0));\n    r = min(r, length(uv - randompoint(iTime,  1.0)));\n    r = min(r, length(uv - randompoint(iTime,  2.0)));\n    r = min(r, length(uv - randompoint(iTime,  3.0)));\n    r = min(r, length(uv - randompoint(iTime,  4.0)));\n    r = min(r, length(uv - randompoint(iTime,  5.0)));\n    r = min(r, length(uv - randompoint(iTime,  6.0)));\n    r = min(r, length(uv - randompoint(iTime,  7.0)));\n    r = min(r, length(uv - randompoint(iTime,  8.0)));\n    r = min(r, length(uv - randompoint(iTime,  9.0)));\n    r = min(r, length(uv - randompoint(iTime, 10.0)));\n    \n    float width = 6.0 / 200.0;\n    r = mod(r,width)/width;\n    r = 2.0*abs(r-0.5);\n    r = clamp(r, 0.25, 0.75);\n    r = ((r - 0.5) / 0.25) + 0.5;\n    float col = clamp( r, 0.0, 1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsscRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 256], [258, 258, 315, 315, 1260]], "test": "untested"}
{"id": "3slyRX", "name": "[TWITCH] FM-2030's messenger", "author": "evvvvil", "description": "FM-2030's messenger - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["terrain", "demoscene", "space", "beam", "glow", "robot", "scifi", "mountain", "spaceship", "structure", "industrial", "twitch", "improv"], "likes": 66, "viewed": 5196, "published": 3, "date": "1585248672", "time_retrieved": "2024-07-30T21:16:30.813120", "image_code": "// FM-2030's messenger - Result of an improvised live code session on Twitch\n// Thankx to crundle for the help and haptix for suggestions\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"I have a deep nostalgia for the future.\" - FM-2030\n\nvec2 z,v,e=vec2(.00035,-.00035); float t,tt,b,bb,g,gg;vec3 np,bp,pp,cp,dp,po,no,al,ld;//global vars. About as exciting as vegans talking about sausages.\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function. Box is the only primitve I hang out with, I find the others have too many angles and seem to have a multi-faced agenda.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like a midget wrestler covered in Mapple syrup.\nfloat smin(float a,float b,float h){ float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;} //Smooth min function, because sometimes brutality isn't the answer. Put that in your pipe and smoke it, Mr Officer.\nfloat noi(vec3 p){ //Noise function stolen from Virgill who, like me, doesn't understand it. But, unlike me, Virgill can play the tuba.\n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);;\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);  \n}\nvec2 fb( vec3 p, float s ) // fb \"fucking bit\" function make a base geometry which we use to make spaceship and central structures using more complex positions defined in mp\n{ //fb just does a bunch blue hollow boxes inside eachother with a white edge on top + a couple of black bars going through to symbolise the lack of middle class cyclists incarcerated for crimes against fun. Stay boring, Dave, I'm watching you.\n  vec2 h,t=vec2(bo(p,vec3(5,5,2)),s); //Dumb fucking blue boxes (could also be said about Chelsea Football Club's fans)\n  t.x=max(t.x,-bo(p,vec3(3.5,3.5,2))); //Dig a hole in them blue boxes, and just like with Chelsea Football Club - less is more\n  t.x=abs(t.x)-.3; //Onion skin blue boxes for more geom\n  t.x=max(t.x,bo(p,vec3(10,10,1)));//Cut front & back of box to reveal onion edges. In reality onions are boring and have no edges, I suspect they listen to Coldplay or Muse. Yeah, Dave, I'm still watching you!\n  h=vec2(bo(p,vec3(5,5,2)),6); //Dumb fucking white boxes (could also be said about Tottenham Football Club's fans)\n  h.x=max(h.x,-bo(p,vec3(3.5,3.5,2))); //Dig hole in white boxes, make it hollow, just like Tottenham FC's trophy cabinet.\n  h.x=abs(h.x)-.1; //Onion skin the fucking white boxes for more geom\n  h.x=max(h.x,bo(p,vec3(10,10,1.4))); //Cut front & back of box to reveal onion edges. Onions are like Tottenham FC's style of football: they make people cry.\n  t=t.x<h.x?t:h; //Merge blue and white geom while retaining material ID\n  h=vec2(length(abs(p.xz)-vec2(2,0))-.2,3); //Black prison bars, to symbolise the meta-physical struggle of half eaten sausages.\n  t=t.x<h.x?t:h; return t; //Pack into a colourful sausage and hand it over to the feds...\n}\nvec2 mp( vec3 p )\n{ \n  bp=p+vec3(0,0,tt*10.);\n  np=p+noi(bp*.05)*15.+noi(bp*.5)*1.+noi(bp*4.)*.1+noi(bp*0.01)*20.; \n  vec2 h,t=vec2(np.y+20.,5); //TERRAIN\n  t.x=smin(t.x,0.75*(length(abs(np.xy-vec2(0,10.+sin(p.x*.1)*10.))-vec2(65,0))-(18.+sin(np.z*.1+tt)*10.)),15.); //LEFT TERRAIN CYLINDER\n  t.x*=0.5;  \n  pp=p+vec3(10,15,0);\n  pp.x+=sin(p.z*.02+tt/5.)*7.+sin(p.z*.001+20.+tt/100.)*4.; //ROAD POSITON\n  bp=abs(pp);bp.xy*=r2(-.785);\n  h=vec2(bo(bp-vec3(0,6,0),vec3(2,0.5,1000)),6); //ROAd WHITE\n  t=t.x<h.x?t:h;\n  h=vec2(bo(bp-vec3(0,6.2,0),vec3(1.,.8,1000)),3); //ROAd BLACK\n  t=t.x<h.x?t:h;  \n  cp=pp-dp; //SPACESHIP POSITON\n  cp.xy*=r2(sin(tt*.4)*.5);  \n  h=vec2(length(cp.xy)-(max(-1.,.3+cp.z*.03)),6); \n  h.x=max(h.x,bo(cp+vec3(0,0,25),vec3(10,10,30)));\n  g+=0.1/(0.1*h.x*h.x*(20.-abs(sin(abs(cp.z*.1)-tt*3.))*19.7));\n  t=t.x<h.x?t:h;\n  cp*=1.3;\n  for(int i=0;i<3;i++){ //SPACESHIP KIFS\n    cp=abs(cp)-vec3(-2,0.5,4); \n    cp.xy*=r2(2.0);     \n    cp.xz*=r2(.8+sin(cp.z*.1)*.2);     \n    cp.yz*=r2(-.8+sin(cp.z*.1)*.2);     \n  } \n  h=fb(cp,8.); h.x*=0.5;  t=t.x<h.x?t:h; //SPACESHIP  \n  pp.z=mod(pp.z+tt*10.,40.)-20.; //CENTRAL STRUCTURE POSITION  \n  pp=abs(pp)-vec3(0,20,0);  \n  for(int i=0;i<3;i++){ //CENTRAL STRUCTURE KIFS\n    pp=abs(pp)-vec3(4.2,3,0); \n    pp.xy*=r2(.785); \n    pp.x-=2.;\n  }  \n  h=fb(pp.zyx,7.); t=t.x<h.x?t:h; //CENTRAL STRUCTURE\n  h=vec2(0.5*bo(abs(pp.zxy)-vec3(7,0,0),vec3(0.1,0.1,1000)),6); //GLOWY LINES CENTRAL STRUCTURE\n  g+=0.2/(0.1*h.x*h.x*(50.+sin(np.y*np.z*.001+tt*3.)*48.)); t=t.x<h.x?t:h;\n  t=t.x<h.x?t:h; return t; // Add central structure and return the whole shit\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>250.) break; //Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>250.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime+3.,62.82);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  dp=vec3(sin(tt*.4)*4.,20.+sin(tt*.4)*2.,-200.+mod(tt*30.,471.2388));\n  vec3 ro=mix(dp-vec3(10,20.+sin(tt*.4)*5.,40),vec3(17,-5,0),ceil(sin(tt*.4))),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(dp-vec3(10,15,0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.4,-.3)); //ld=light direction\n  co=fo=vec3(.1,.1,.15)-length(uv)*.1-rd.y*.1;//background is dark blueish with vignette and subtle vertical gradient based on ray direction y axis. \n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you at your best man speech.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(.4,.0,.1),vec3(.7,.1,.1),cos(bp.y*.08)*.5+.5); //al=albedo=base color, by default it's a gradient between red and darker red. \n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    if(z.y>6.) al=clamp(mix(vec3(.0,.1,.4),vec3(.4,.0,.1),sin(np.y*.1+2.)*.5+.5)+(z.y>7.?0.:abs(ceil(cos(pp.x*1.6-1.1))-ceil(cos(pp.x*1.6-1.3)))),0.,1.);\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.); //Sp=specular, stolen from Shane\n    co=mix(sp+mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.4)+.2)*(dif),fo,min(fr,.3)); //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.0000007*t*t*t)); //Fog soften things, but it won't stop your mother from being unimpressed by your current girlfriend\n  }\n  fo=mix(vec3(.1,.2,.4),vec3(.1,.1,.5),0.5+0.5*sin(np.y*.1-tt*2.));//Glow colour is actual a grdient to make it more intresting\n  fragColor = vec4(pow(co+g*0.15*mix(fo.xyz,fo.zyx,clamp(sin(tt*.5),-.5,.5)+.5),vec3(.55)),1);// Naive gamma correction and glow applied at the end. Glow switches from blue to red hues - nice idea by Haptix - cheers broski\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 458, 482, 482, 523], [524, 670, 687, 687, 730], [731, 820, 856, 856, 922], [923, 1040, 1058, 1175, 1398], [1399, 1399, 1574, 1817, 3096], [3097, 3097, 3116, 3116, 4706], [4707, 4707, 4789, 4789, 5557], [5647, 5647, 5776, 5776, 8681]], "test": "untested"}
{"id": "wdXczX", "name": "Day 98", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 17, "viewed": 634, "published": 3, "date": "1585240924", "time_retrieved": "2024-07-30T21:16:31.947088", "image_code": "\n\n// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.04;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*1.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor.b *= 0.97 + dot(uvn,uvn)*0.4;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.6);\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    //fragColor.b *= 1. + uv.x*0.02;\n    //fragColor.g *= 1. + uv.t*0.05;\n    \n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 ));\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat xor(float a, float b){\n\treturn float(int(a)^ int(b));\n}\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n    return max(p.y,p.x);\n}\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    n += valueNoise(uv*800.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    n = max(n, 0.);\n    return n;\n}\nvec3 get( vec2 fragCoord )\n{\n    vec2 p =( fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 col = vec3(0);\n    \n    \n    p *= 1. - dot(p,p)*0.05 ;\n    \n    \n    vec2 b = p;\n    float d = 10e6;\n    \n    p *= 1.;\n    \n    p = vec2(9.*atan(p.x,p.y)/6.14, length(p));\n    \n    p.y = log(p.y)*1. - iTime*1. + valueNoise(vec2(iTime),4.).x*1.;\n    vec2 j = p;\n    \n    float id = floor(p.y);\n    vec4 n = noise(id);\n    p.xy *= rot(0. + sin(p.y)*0.);\n    \n    //vec2 id =\n    b *= 1.5;\n    //p = cos(p*(1. - exp(-length(b)*length(b)*1000.)*0.2));\n    p = cos(p*(1. - exp(-length(b)*length(b)*1000.)*0.));\n    \n    for(float i = 0.; i < 9.         ; i++){\n    \t\tp = abs(p);\n        \n        \tfloat sc = (5. + n.y*6.);\n        \tvec2 q = p;\n        \n        \tfloat x = xor(q.y*sc,q.x*sc);\n        \tp *= 1. - x*(0.06 - sin(n.y*4.)*0.02);\n        \tp -= 0.02 + n.y*0.045;\n        \tp *= rot(0.125*3.14);\n        {\n        if(mod(i, 2.) == 0.)\n    \t\td = min(d, sdBox(p, vec2(0.04 + x*0.005)));\n        else\n    \t\td = max(d, -sdBox(p, vec2(0.02 + x*0.005))); \n        \n        }\n    }\n\n    \n    col += smoothstep(0.001,0.,d);\n    \n    \n    float f = smoothstep(0.,1.,fbm(j*80.).x);\n    \n    f = pow(f, 6.)*2.4;\n    if(col.x < 0.4)\n        col += f*6.5;\n    \n    \n    col -= f;\n    \n    \n    \n    //col += fbm(p).x*10.;\n    //col.r += sin(id)*3.5;\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    float aa = 5.;\n    \n    for(float i =0.; i < aa*aa   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    \n    col = max(col, 0.);\n\tcol = pow(col, vec3(0.4545));\n    \n    col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm 140.\n\n#define tick (60./bpm)\n\n#define beat tick\n#define bar  beat*4.\n#define hbar  bar/2.\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n#define S vec2 s = vec2(0);\n#define E return s;\n#define T true\n#define F false\n\n\nbool[] pattA = bool[16](T,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,T,F,T,T,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\n\n\nbool[] pattBa = bool[8](T,T,F,T,F,T,F,T);\nbool[] pattB = bool[8](T,T,T,T,T,T,T,T);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst vec4 cmin9 = vec4(0.,3.,7.,14.);\nconst vec4 cmin7 = vec4(0.,3.,7.,10.);\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.);\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.);\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.);\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.);\n\nvec4[] chords = vec4[4](\n    cmin7maj,\n    cmin7 + 1.,\n    cmaj9 - 2.,\n    cmaj7f15 - 3.\n);\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/amt)*amt\n\n\nvec2 kick (float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.00002);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp(-t*20.1)*240. + 30.)*tt )*env;\n    \n    s = mix(s,sin(s*3.)*1., 0.3);\n    \n    \n    bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattA[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\n    init;\n    \n    \n    sampleratereduction(t, 0.00001);\n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 9500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*26.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (240./1. + exp(-t*26.)*1500.  )*tt;\n    s += sin( f )*env;\n    \n    \n    \n    \n    s += sin( f*1.5 )*env*0.1;\n    bitreduction(s, 0.001);\n    s += sin( f*2. )*env*0.1;\n    //s += sin( f*1.5 )*env*0.1;\n    //s += amt*sin( f + nn*0.9*smoothstep(0.,1.,t*20.) )*env;\n    //s -= amt*sin( f )*env;\n    \n    \n    //s += sign(s)*pow(abs(s), vec2(2.))*0.9;\n    //s += amt*sin( f*4. + nn.x*exp(-t*10.))*env*env*0.2;\n    //s *= 1.6;\n    //s *= 0.39;\n    //s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.1);\n    \n\t//s = sin(s*1.5);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\n\nvec2 snarea(float t){\n\n    init;\n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 3500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*16.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (440./1.5 + exp(-t*50.)*1400.  )*tt;\n    s += sin( f )*env;\n    //s += sin( f*2.25 )*env*0.1;\n    //s += sin( f*1.5 )*env*0.1;\n    s += amt*sin( f + nn*0.9*smoothstep(0.,1.,t*20.) )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    //s += sign(s)*pow(abs(s), vec2(2.))*0.9;\n    s += amt*sin( f*4. + nn.x*exp(-t*10.))*env*env*0.2;\n    //s *= 1.6;\n    s *= 0.39;\n    //s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.1);\n\ts = sin(s*1.5);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    sampleratereduction(t, 0.001);\n    float to;\n    vec2 nn = lpnoise(t, 600.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float amt = 1.;\n    float env = exp(-t*10.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*0.4)*env;\n    s -= sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    //s += sin(f + sin(2000.*tt)*exp(-t*20.))*env;\n    \n    \n    \n    \n    bitreduction(s, 0.5);\n    s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    sampleratereduction(t, 0.001);\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 32. / 2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float env = exp(-t*9.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 2.) *tt + \n             \t+sin(note(n, 4.) *tt)*exp(-t*1.)*0.1 \n                 \n                 )*exp(-t*9.)*1. \n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*1.)*0.1 \n                 \n                 )*exp(-t*9.)*1.5\n            )*env;\n    \n    \n    s *= 1.;\n    \n    \n    bitreduction(s, 0.3);\n    //s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    sampleratereduction(t, 0.0005);\n    float r = bar;\n    t = mod(t,r*4.);\n    int id = int(floor(t/r));\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 4500.)*0.45;\n    \n    nn *= 0.1*sin(t);\n    float m = 1.;\n    float width = 2.;\n    for(float i = 0.; i < 9.; i++){\n        float a = (1. + i/4.);\n    \ts.x += sin( note(chords[id].x, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, 4.) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, 4.) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    bitreduction(s, 0.5);\n    \n    s *= 0.04;\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat*0.5);\n    \n    sampleratereduction(t, 0.00005);\n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 1500.)*0.4;\n    \n    float amt = 0.7;\n    float env = exp(-t*15.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.5);\n    s *= 0.7;\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*5.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.35;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.7;\n    ret;\n}\n\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s= vec2(0);\n    \n    \n    float sc;\n    s += kick(t,sc)*1.;\n    s += snare(t);\n    s += hats(t)*(pow(sc,4.4))*0.2;\n    s += hatsb(t)*(pow(sc,4.4))*0.2;\n    s += chord(t)*(pow(sc,1.8))*0.9;\n    s += lead(t)*(pow(sc,1.))*0.25;\n    \n    if(t > beat*16. &&  (  t < beat*(16. + 8.) || t > beat*(16. + 12.) )  )\n    \ts += bass(t)*(pow(sc,1.))*0.75;\n    //s += lead(t)*0.4;\n    s *= 0.7;\n    \n    s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.3 + sin(t)*0.2);\n    s = clamp(s,-1.,1.);\n    \n    //s *= smoothstep(0.,1.,t*0.5);\n    return s;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 91, 1274]], "test": "untested"}
{"id": "3dsyRX", "name": "Olinarhia", "author": "jeyko", "description": "potato", "tags": ["sound", "music", "mdtmjvm", "algobeat"], "likes": 7, "viewed": 426, "published": 3, "date": "1585239736", "time_retrieved": "2024-07-30T21:16:33.071083", "image_code": "\n// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n\n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),3.1)*3.93;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*2.3;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor.b *= 0.97 + dot(uvn,uvn)*1.9;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.4);\n    \n    fragColor.r *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.9;\n    \n    \n    //fragColor.b *= 1. + uv.x*0.02;\n    //fragColor.g *= 1. + uv.t*0.05;\n    \n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 ));\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm 140.\n\n#define tick (60./bpm)\n\n#define beat tick\n#define bar  beat*4.\n#define hbar  bar/2.\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n#define S vec2 s = vec2(0);\n#define E return s;\n#define T true\n#define F false\n\n\nbool[] pattA = bool[16](T,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,T,F,T,T,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\n\n\nbool[] pattBa = bool[8](T,T,F,T,F,T,F,T);\nbool[] pattB = bool[8](T,T,T,T,T,T,T,T);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst vec4 cmin9 = vec4(0.,3.,7.,14.);\nconst vec4 cmin7 = vec4(0.,3.,7.,10.);\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.);\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.);\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.);\n\nvec4[] chords = vec4[4](\n    cmin9,\n    cmin7 + 2.,\n    cmaj9 - 5.,\n    cmaj7f15 - 2.\n);\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/amt)*amt\n\n\nvec2 kick (float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.00002);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp(-t*20.1)*240. + 30.)*tt )*env;\n    \n    s = mix(s,sin(s*3.)*1., 0.3);\n    \n    \n    bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattA[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\n    init;\n    \n    \n    sampleratereduction(t, 0.00001);\n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 9500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*26.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (240./1. + exp(-t*26.)*1500.  )*tt;\n    s += sin( f )*env;\n    \n    \n    \n    \n    s += sin( f*1.5 )*env*0.1;\n    bitreduction(s, 0.001);\n    s += sin( f*2. )*env*0.1;\n    //s += sin( f*1.5 )*env*0.1;\n    //s += amt*sin( f + nn*0.9*smoothstep(0.,1.,t*20.) )*env;\n    //s -= amt*sin( f )*env;\n    \n    \n    //s += sign(s)*pow(abs(s), vec2(2.))*0.9;\n    //s += amt*sin( f*4. + nn.x*exp(-t*10.))*env*env*0.2;\n    //s *= 1.6;\n    //s *= 0.39;\n    //s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.1);\n    \n\t//s = sin(s*1.5);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\n\nvec2 snarea(float t){\n\n    init;\n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 3500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*16.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (440./1.5 + exp(-t*50.)*1400.  )*tt;\n    s += sin( f )*env;\n    //s += sin( f*2.25 )*env*0.1;\n    //s += sin( f*1.5 )*env*0.1;\n    s += amt*sin( f + nn*0.9*smoothstep(0.,1.,t*20.) )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    //s += sign(s)*pow(abs(s), vec2(2.))*0.9;\n    s += amt*sin( f*4. + nn.x*exp(-t*10.))*env*env*0.2;\n    //s *= 1.6;\n    s *= 0.39;\n    //s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.1);\n\ts = sin(s*1.5);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = lpnoise(t, 600.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float amt = 0.4;\n    float env = exp(-t*10.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*0.4)*env;\n    s -= sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    //s += sin(f + sin(2000.*tt)*exp(-t*20.))*env;\n    \n    \n    float bitreduction = 0.3 + sin(6.28*to/beat)*0.0;\n    s = mix(s,sign(s) * floor(abs(s)/bitreduction)*bitreduction, 0.1 + smoothstep(0.,1.,t*2.)*0.7);\n    \n    \n    s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 32. / 4.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float env = exp(-t*9.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 2.) *tt + \n             \t+sin(note(n, 4.) *tt)*exp(-t*1.)*0.1 \n                 \n                 )*exp(-t*9.)*1. \n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*1.)*0.1 \n                 \n                 )*exp(-t*9.)*1.5\n            )*env;\n    \n    \n    s *= 1.;\n    \n    \n    //s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    sampleratereduction(t, 0.0001);\n    float r = bar;\n    t = mod(t,r*4.);\n    int id = int(floor(t/r));\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 4500.)*0.45;\n    \n    nn *= 0.1*sin(t);\n    float m = 1.;\n    float width = 2.;\n    for(float i = 0.; i < 9.; i++){\n        float a = (1. + i/3.);\n    \ts.x += sin( note(chords[id].x, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, 4.) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, 4.) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    bitreduction(s, 0.001);\n    \n    s *= 0.04;\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat*0.5);\n    \n    sampleratereduction(t, 0.00005);\n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 1500.)*0.4;\n    \n    float amt = 0.7;\n    float env = exp(-t*15.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.5);\n    s *= 0.7;\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*5.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.35;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.7;\n    ret;\n}\n\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s= vec2(0);\n    \n    \n    float sc;\n    s += kick(t,sc)*1.;\n    s += snare(t);\n    s += hats(t)*(pow(sc,4.4))*0.1;\n    s += chord(t)*(pow(sc,1.8))*0.45;\n    s += lead(t)*(pow(sc,1.))*0.25;\n    s += bass(t)*(pow(sc,1.))*0.5;\n    //s += lead(t)*0.4;\n    s *= 0.7;\n    \n    s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.2 + sin(t)*0.);\n    s = clamp(s,-1.,1.);\n    \n    //s *= smoothstep(0.,1.,t*0.5);\n    return s;\n}", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"Day 94\" by jeyko. https://shadertoy.com/view/WsXcDM\n// 2020-03-22 08:59:44\n\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    \n    \n    n += valueNoise(uv*500.,0.1);\n    //n += valueNoise(uv*1000., 0.1)*0.5;\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    \n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    \n    \n    n = max(n, 0.);\n    return n;\n}\n\n\nvec3 get(vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 uvn = uv;\n    uv *= 1. - dot(uv,uv)*0.3;\n    \n    uv *= 2. + valueNoise(vec2(iTime), 0.2).x*1.5;\n   \n    vec3 col = vec3(0);\n    \n    \n    \n    for(int i = 0; i<3; i++){\n        if(uv.x < uv.y){uv.xy = uv.yx;}\n        uv *= rot(0.5);\n        uv.x -= 0.9;\n        \n    }\n    \n    float m = 1.;\n    for(float i = 0.; i< 1.; i++){\n        //uv = uv.yx;\n    \tfloat dpp = dot(uv,uv);\n        dpp = clamp(dpp, 0.1,1.);\n\t\t\n        vec2 z1 = vec2(0.4);\n        vec2 z2 = vec2(-0.1);\n\t\tz1 = uv - z1; uv -= z2;        \n    \tuv = mat2(z1, z1.y, -z1.x)*(uv*1. + 1.*vec2(-0.1, 0.7))/ dpp; \n        \n        uv -= vec2(0.1,0.);\n    }\n    \n    uv = sin(uv*3.14*(0.6));\n    \n    float dC = log(length(uv) + 90.)+ iTime*0.001;\n    \n    \n    float modD = 0.00099;\n    float id = floor(dC/modD);\n    dC = pmod(dC, modD);\n    \n    \n    vec3 c = pal(0.5,0.5,vec3(0.1,0.6,0.9), 0.6 + sin(id*0.4)*0.4, id*0.9 + iTime*0.5);\n    \n    c = max(c, 0.);\n    c = smoothstep(0.,1.,c);\n    col += c;\n    \n    \n    \n    //col -= fbm(uv).x*0.001;\n    //col += fbm(uv + 4.).x*0.001;\n    \n    \n    col = pow(col, vec3(1. + dot(uvn,uvn)));\n    \n    col *= 1.  - dot(uvn,uvn);\n        \n    //col += smoothstep(0.01);\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    // float(min(iFrame,0)) hack for faster compilation (stops loop unrolling)\n    for(float i =0.; i < 9. + float(min(iFrame,0)); i++){\n    \tcol += get(fragCoord + vec2(mod(i,3.),floor(i/3.))*0.25);\n    }\n    col /= 9.;\n    \n\tcol = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 90, 90, 1270]], "test": "untested"}
{"id": "tsXyz8", "name": "[TWITCH] Lion Snek Murph", "author": "evvvvil", "description": "Lion Snek Murph - Razult of imprivosed live kidding seshun an Twatch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "space", "particles", "snake", "beam", "glow", "robot", "scifi", "morph", "face", "spaceship", "industrial", "twitch", "lion", "improv", "transformer"], "likes": 17, "viewed": 803, "published": 3, "date": "1585237889", "time_retrieved": "2024-07-30T21:16:34.092352", "image_code": "// Lion Snek Murph - Razult of imprivosed live kidding seshun an Twatch\n// Thankx to alkama for the \"draw a cat\" suggestion\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Those who don't like football don't know the joy of the people\" - Victor Hugo\n\nvec2 z,e=vec2(.00035,-.00035); float b,t,tt,g,g2,bb,at; vec3 np,bp,pp,po,no,al,ld;//global vars. About as exciting as Football players discussing their taste in music\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function. Hey, did you know you shouldn't put people in a box? (Unless they fucking fit)\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like how acceptance speeches should be in Hollywood. Yeah Leo, it's pretty easy to lecture people from your Ivory tower.\nvec2 fb( vec3 p, float s, float m, float b ) // fb \"fucking bit\" function make a base geometry which we use to make robot faces and outter geometry using more complex positions defined in mp\n{ //fb just does a simple triple outlined box, really. Nothing is simple when you dip into triple brews though: try Triple Karmeliet beer and then we'll talk about how shit Budweiser is.\n  vec2 h,t=vec2(bo(p,vec3(5,1,1.-b)),5);// Purple gradient box, you gotta start with the first stone and yes it is facing Mecca.\n  h=vec2(bo(p,vec3(2.8,0.7,1.2-b)),6);// White box, because everybody loves the northern european socio political model, despite what the hippies in France are wearing or what the old greek ladies are drawing in the sand. (Reference to \"Diogo Diogenes vs AlexanderDaGreat 2\" - UFC Fight Night 666)\n  t=t.x<h.x?t:h; //Merge purple and white geometries while retaining material ID. Sounds like social segregation to me, but who am I kidding? I'm the one buying expensive craft beers helping hipsters achieve \"The Great Gentrification Swindle\"\n  h=vec2(bo(abs(p)-vec3(1,0,0),vec3(0.5,s,0.8-b)),m); //Small rectangles popping out of purple geometry, nice little added detail, like having a wifi connection on your sex toy\n  t=t.x<h.x?t:h; //Merge small rectangles and the rest while retaining material ID\n  h=vec2(bo(p,vec3(2.8,0.2,1.5-2.*sin(p.x*.1))),3); //Black box over white box, because white and black does a killer contrast. Yeah like killer whales or Newcastle United's home kit (not quite as deadly in attack since Alan Shearer left to swim in a pool of boring punditry)\n  t=t.x<h.x?t:h; //Merge black box and the rest while retaining material ID\n  t.x*=0.7; return t; //Tweak distance field to avoid artifact and return the whole shit\n}\nvec2 mp( vec3 p )\n{ \n  p.xy*=r2(.3);//tilt the whole fucking scene a bit forward, make it more menacing, like a cross armed BTP officers fining skateboarders in the Corporation of London\n  np=bp=pp=p; bp.xy+=vec2(3,12); bp.xy*=r2(5.5-sin(tt)*.2);pp.x=mod(pp.x+tt*5.,20.)-10.; //Setup new positions np, bp and pp used in kifs below and then  passed to fb to generate more geometries\n  at=min(0.,(length(p+vec3(sin(tt*.5)*50.,-sin(p.y*.5+tt*5.)*5.,0))-30.)/30.); //spherical field displacement reverse attractor bullshit, name it whatever you wish, I'm way too busy counting the grains of rice in this bag.\n  np.xy*=r2(mix(0.,0.8,bb)); //rotate shit to switch faces using bb variable\n  for(int i=0;i<4;i++){ //main kifs loop cloning, pushing, pulling rotating each iteration, bit like a sex club but without the overweight bouncer trying to slot himself in.\n    np=abs(np)-vec3(2,1.5-at*3.,1.6-at*5.); //abs sysmtery to push out and create more geometry each iteration, influenced by sphreical attractor above so we can push it bulbous. \"A squid eating dough in a polyethylene bag is fast and bulbous, got me?\"\n    np.xz*=r2(.785*float(i)-cos(p.y*.3)*.1+at*.2); //rotate bit more each iteration and influenced by attractor and cos\n    np.xy*=r2(.785*float(i)/2.); //rotate bit more each iteration along another axis to make it more face like\n    np.xz+=cos(p.y*.4+1.5); // this tweaks face into cheekbones and shit like that. Man I have no idea I do these things under the influence and now I'm sober so none of this makes sense. I have no idea how you tea-total nerds do it.\n    if(i<3){ //Bp is for the chin / jaw and we need less iteration this if makes sure of that, politely but with the kind of vigour that you would't wanna fuck with, especially if you are just a piece of code.\n      bp=abs(bp)-vec3(1.5,0,1.-at*7.); //another boring kifs bullshit to make more geometry out of nothing, once again eluding everyone as to my lack of Math understanding and lack of giving a fuck about it.\n      bp.xz*=r2(.785*float(i)-cos(p.y*.3)*.1); //Are we doing this again? Christ it seems as wasteful as giving ice creams to children. Yeah yeah you guessed it we rotate tiny bit each iter...\n      bp.xy*=r2(.785*float(i)/2.); //This line of code cures Cancer, solves the conflicts in the Middle East and gives you a 4 hour erection. Not really, it's just same as above, bit of rotation each iter.\n      bp.xz+=cos(p.y*.4+1.5); //again we curve things out into face-like-roundness\n    }\n    pp=abs(pp)-vec3(5,5.5,0);//Fucking hell one more kifs? One trick poney bullshit right there. Well fuck it I just needed one more kif for the structure at bottom and top\n    pp.yz*=r2(0.45);//Rather dull simple shit here brohs...\n    pp.xz*=r2(0.1); //...I've seen more exciting stuff happen at a funeral\n  }  \n  vec2 h,t=fb(np,1.2,3.,0.); //Now we have all the new positions, we call fucking bit function with the more complex position np to create faces\n  h=fb(bp,3.+sin(bp.z*.5)*2.,6.,0.); t=t.x<h.x?t:h;//Then we call again fucking bit this time with bp complex position to create the bottom jaw\n  h=fb(pp,30.,6.,0.); t=t.x<h.x?t:h; //Finally we call fucking bit a third time with pp complex position to create structure above and bellow\n  h=vec2(length(abs(p-vec3(7,1,0))-vec3(0,0,5.-at*15.))-(1.2+sin(p.y+1.)+at*2.5),6);  //EYES - Because when the grim reaper rings the bell, I wanna be able to stare at the cruel bastard.\n  h.x=min(h.x,length(abs(p.yz)-vec2(20.,0.))-0.5); // GLOWY TUBES above and bellow robot face. Everything looks better with glow sticks even overweight cyber-goth ravers.\n  h.x*=0.3;  g+=(0.1-at*5.)/(0.1+h.x*h.x*(20.-abs(sin(p.x*.2+tt*3.))*18.)); t=t.x<h.x?t:h; //Make tubes glow and sweep da beam along z axis, doesn't quite solve the disparity between the rich and the poor in middle class England but it does brithen up this scene.\n  h=vec2(length(cos(p*.5+np*.2-vec3(tt*5.0,0,0))),6);  //PARTICLES: Everybody loves glitter, makes turds look more polished and makes Boris Johnson social policies slightly less ugly to look at.\n  h.x=max(h.x,length(p.xz)-(5.+sin(p.y*.1)*20.)); // Ah yes nice fucking bounding trick here broski, nothing clever but this limits the particles to sphere above head rather than them being everywhere.\n  h.x*=0.6;  g+=0.1/(0.1+h.x*h.x*400.); t=t.x<h.x?t:h;  //Simple Balkhan glow on the particles (Thankx to Balkhan for the distance glow trick that I rinse just about every week, cheers Balkhan, you da man)\n  h=vec2(0.7*(length(p-vec3(3,-3,0))-5.5+at*10.),3);t=t.x<h.x?t:h; // MIDDLE BALL Helps hide mess in middle of face, tones down geometry, adds simple focal point to composition. In other words: if you can't beat them, join them.\n  pp=p+vec3(-6.5,-5,0);  //Building a new position pp to make the cat ears\n  pp.xz=abs(pp.xz)-vec2(0,8.-at*15.);  //Fuck yeah Einstein! A cat has two ears, so we abs symetry the fucker to have two ears instead of one.\n  pp.yz*=r2(0.75); pp.xz*=r2(0.75); //Rotate both ears almost 45 degree in both axis\n  b=abs(sin(p.y*.1+3.))*1.7; // Taper the ears with this \"b\" variable. Wishful thinking: also use \"b\" variable to taper my wife's nagging.\n  h=vec2(bo(pp,vec3(2.-b,10,3.-b)),5);  //CAT EARS, A feline ain't nothing without cat ears. This also applies to demoscener and shader queen Flopine, who also looks good with cat ears.\n  h.x=abs(h.x)-.3; //Onion skin the fucking ears to get edges and create ear holes (not to be confused with bum holes)\n  pp.xz*=r2(.7); //Seems like one more rotate, why? Not sure many synapses have been vaporized since the making of this shader. Ah yes this rotates the plane that cuts off the ears to reveal the onion skin edges. There, not such a wasteman afterall.\n  h.x=max(h.x,pp.x-0.6);h.x*=0.6; //Cut ears with plane to reveal the onion skin edges, then tweak distance field to avoid artifact due to spherical attractor\n  t=t.x<h.x?t:h; return t; // Add cat ears and return the whole shit\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>120.) break; //Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>120.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.8318);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  bb=0.5+clamp(sin(tt*.5),-.5,.5);\n  vec3 ro=mix(vec3(1),vec3(1,-1,-1),ceil(sin(tt*.2)))*vec3(30.+sin(tt*.2)*4.,sin(tt*.1)*3.,cos(tt*.2)*15.),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.2,-.3)); //ld=light direction\n  co=fo=vec3(.0,.05,.1)*(1.5-length(uv)-.5);//background is blueish with vignette and subtle vertical gradient based on ray direction y axis. It's dark like the heart of people from Norwich.\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, just like me stumbling home after 7 pints\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=vec3(.4-sin(po.y*.5)*.2,.1,.2); //al=albedo=base color, by default it's a gradient between purple and dark blue. \n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.); //Sp=specular, stolen from Shane, below you will find: mix(vec3(.8),vec3(1),abs(rd))*al is a sick trick by crundle to tweak colour depending on ray direction\n    co=mix(sp+al*(a(.1)*a(.5)+.2)*(dif+s(2.)*.55),fo,min(fr,.5)); //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.00002*t*t*t)); //Fog soften things, but it won't stop Sophie's dildo battery from running out.\n  }\n  fragColor = vec4(pow(co+g*0.2*mix(vec3(.4,.3,.2),vec3(1,.4,.2),-at),vec3(.5)),1);// Naive gamma correction and glow applied at the end. Glow has a mix of colours to make it more interesting.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 485, 509, 509, 550], [551, 656, 673, 673, 716], [717, 879, 1071, 1256, 2629], [2630, 2630, 2649, 2649, 8535], [8536, 8536, 8618, 8618, 9386], [9476, 9476, 9605, 9605, 12287]], "test": "untested"}
{"id": "wsfyzX", "name": "sheatShader1", "author": "JohnPower71", "description": "just a description idk what to say", "tags": ["beginner"], "likes": 2, "viewed": 258, "published": 3, "date": "1585224898", "time_retrieved": "2024-07-30T21:16:35.010896", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \t\n  \tvec2 normCoord = fragCoord.xy / iResolution.xy;\n    \n\t//normCoord.y = 1.0 - normCoord.y;\n    \n    vec4 texColor = texture(iChannel0,normCoord);//Get the pixel at xy from iChannel0\n\tvec4 alterColor = texture(iChannel1,normCoord);//Get the pixel at xy from iChannel0\n    \n    vec4 color;\n    if(texColor.g > texColor.r && texColor.g > texColor.b){\n        color = alterColor;\n    }else{\n        color = texColor;\n    }\n    \n    //texColor.r *= abs(sin(iTime));\n    //texColor.g *= abs(cos(iTime));\n    //texColor.b *= abs(sin(iTime) * cos(iTime));\n    \n    //float mid = color.r + color.g + color.b;\n    //mid = mid / 3.0;\n    \n    fragColor = color;\n    fragColor.x = normCoord.x;\n\n    //fragColor = texColor;\n    //fragColor = vec4(mid,mid,mid,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 816]], "test": "untested"}
{"id": "wsfcRX", "name": "Corona Time", "author": "dr2", "description": "Clock includes days since WHO declared Global Public Health Emergency  (hope the [local] day counter never overflows)", "tags": ["clock", "pandemic"], "likes": 9, "viewed": 532, "published": 3, "date": "1585223343", "time_retrieved": "2024-07-30T21:16:36.221659", "image_code": "// \"Corona Time\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txFnt iChannel0\n\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 HsvToRgb (vec3 c);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvoid DTimeSet (vec4 d);\nint GetTxChar (int _nc);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, vnCylIn;\nvec2 fntSize, qnFnt, qnTxt;\nfloat dstFar, tCur, rngBlk, bCylRad, bCylHt, dCylIn, dCylOut;\nint idTxt;\nconst float pi = 3.14159;\n\nvoid CylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, ai, b, w, ws, srdy;\n  dCylIn = dstFar;\n  dCylOut = dstFar;\n  vnCylIn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      ai =  1. / a;\n      dCylIn = (- b - ws) * ai;\n      dCylOut = (- b + ws) * ai;\n    }\n    if (a > 0.) s = ro + dCylIn * rd;\n    else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylIn.xz = s.xz / bCylRad;\n    else if (srdy * ro.y < - bCylHt) {\n      dCylIn = - (srdy * ro.y + bCylHt) / abs (rd.y);\n      if (length (ro.xz + dCylIn * rd.xz) < bCylRad) vnCylIn.y = - srdy;\n      else dCylIn = dstFar;\n    } else dCylIn = dstFar;\n    if (dCylIn < dstFar) {\n      if (a > 0.) s = ro + dCylOut * rd;\n      else s.y = bCylHt;\n      if (abs (s.y) > bCylHt && srdy * ro.y < bCylHt)\n         dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n    }\n  }\n}\n\nfloat FontTexDf (vec2 p)\n{\n  vec3 tx;\n  ivec2 ip;\n  float d;\n  int ic;\n  ic = 0;\n  ip = ivec2 (floor (p));\n  if (ip.x == 0 && ip.y == 0) ic = GetTxChar (idTxt);\n  if (ic != 0) {\n    tx = texture (txFnt, mod ((vec2 (mod (float (ic), 16.),\n       15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n    qnFnt = vec2 (tx.r, - tx.g);\n    d = tx.b + 1. / 256.;\n  } else d = 1.;\n  return d;\n}\n\nvec3 RdNZero (vec3 rd)\n{\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  return rd;\n}\n\nfloat ObjRayT (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 srd, h;\n  float dHit, dLim, d;\n  RdNZero (rd);\n  srd = - sign (rd.xy);\n  rdi = 1. / abs (rd.xyz);\n  dHit = 0.;\n  dLim = rngBlk;\n  ro.xy /= fntSize.x;\n  rd.xy /= fntSize.x;\n  ro.xy += 0.5;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    h = rdi.xy * fract (srd * p.xy);\n    d = max (min (fntSize.x, 1.) * FontTexDf (p.xy), abs (p.z) - 0.5 * fntSize.y);\n    dHit += min (d, 0.01 + fntSize.x * min (h.x, h.y));\n    if (d < 0.0001 || dHit > dLim) break;\n  }\n  if (d >= 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  RdNZero (rd);\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    rngBlk = df - dn;\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float cRad;\n  cRad = 0.04;\n  q = p;\n  q.y = abs (q.y) - bCylHt + cRad;\n  return PrTorusDf (q.xzy, cRad, bCylRad - cRad);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 10. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return StarPat (rd, 12.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, qtTxt, tro, trd, trdd, q, qt, ds;\n  float dstTxt, dstBlk, dstObj, db, d, ang, angTxt, angRot, aTw, rad;\n  int idT;\n  fntSize = vec2 (1.7, 0.6);\n  dstTxt = dstFar;\n  tro = ro;\n  trd = rd;\n  rad = 6.;\n  bCylRad = rad + 0.4 * fntSize.x;\n  bCylHt = 1.4 * fntSize.y;\n  dstObj = ObjRay (ro, rd);\n  CylHit (ro, rd);\n  if (dCylIn < dstFar) {\n    angRot = 0.05 * pi * tCur;\n    aTw = angRot;\n    tro.xz = Rot2D (tro.xz, angRot);\n    trd.xz = Rot2D (trd.xz, angRot);\n    for (float k = 0.; k < 42.; k ++) {\n      idTxt = int (k);\n      ang = 2. * pi * (1. - k / 42.);\n      qt = - rad * vec3 (sin (ang + vec2 (0., 0.5 * pi)), 0.).xzy;\n      q = tro - qt;\n      q.xz = Rot2D (q.xz, ang);\n      q.yz = Rot2D (q.yz, ang + aTw);\n      trdd = trd;\n      trdd.xz = Rot2D (trdd.xz, ang);\n      trdd.yz = Rot2D (trdd.yz, ang + aTw);\n      db = BlkHit (q, trdd, fntSize.xxy * vec3 (0.5, 0.55, 0.55));\n      if (db < dstFar) {\n        d = db + ObjRayT (q + db * trdd, trdd);\n        if (d < dstTxt) {\n          dstTxt = d;\n          qtTxt = qt;\n          angTxt = ang;\n          qnTxt = qnFnt;\n          idT = idTxt;\n        }\n      }\n    }\n  }\n  if (min (dstTxt, dstObj) < dstFar) {\n    if (dstTxt < dstObj) {\n      tro += dstTxt * trd;\n      ds = tro - qtTxt;\n      ds.xz = Rot2D (ds.xz, angTxt);\n      ds.yz = Rot2D (ds.yz, angTxt + aTw);\n      col = HsvToRgb (vec3 (mod (0.05 * tCur + ((idT > 25) ? 0.5 : 0.), 1.), 1., 1.));\n      if (abs (ds.z) < 0.49 * fntSize.y) {\n        vn = normalize (vec3 (qnTxt, 0.00001));\n        col = mix (col, vec3 (1.), 0.7);\n      } else {\n        vn = vec3 (0., 0., sign (ds.z));\n      }\n      vn.yz = Rot2D (vn.yz, - angTxt - aTw);\n      vn.xz = Rot2D (vn.xz, - angRot - angTxt);\n      col = col * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n      col = mix (col, BgCol (reflect (rd, vn)), 0.7 - 0.5 * abs (dot (rd, vn)));\n    } else if (dstObj < dstFar) {\n      vn = ObjNf (ro + dstObj * rd);\n      col = vec3 (0.5, 0.5, 0.6) * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    }\n  } else col = BgCol (rd);\n  if (dCylIn < dstFar) {\n    col = mix (col,  vec3 (1.) * (0.2 + 0.8 * max (dot (ltDir, vnCylIn), 0.) +\n       0.5 * pow (max (dot (normalize (ltDir - rd), vnCylIn), 0.), 32.)), 0.2);\n    col = mix (col, BgCol (reflect (rd, vnCylIn)), 0.8 * pow (1. - abs (dot (rd, vnCylIn)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.06 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., -0.3, -15.);\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n  dstFar = 100.;\n  DTimeSet (dateCur);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define C(c) c\n\n#define _SP    C(0x20)\n#define _EXCL  C(0x21)\n#define _QUOT  C(0x22)\n#define _NUM   C(0x23)\n#define _DOLLR C(0x24)\n#define _PCENT C(0x25)\n#define _AMP   C(0x26)\n#define _SQUOT C(0x27)\n#define _LPAR  C(0x28)\n#define _RPAR  C(0x29)\n#define _AST   C(0x2A)\n#define _PLUS  C(0x2B)\n#define _COMMA C(0x2C)\n#define _MINUS C(0x2D)\n#define _PER   C(0x2E)\n#define _SLASH C(0x2F)\n#define _0     C(0x30)\n#define _1     C(0x31)\n#define _2     C(0x32)\n#define _3     C(0x33)\n#define _4     C(0x34)\n#define _5     C(0x35)\n#define _6     C(0x36)\n#define _7     C(0x37)\n#define _8     C(0x38)\n#define _9     C(0x39)\n#define _COLON C(0x3A)\n#define _SEMI  C(0x3B)\n#define _LT    C(0x3C)\n#define _EQUAL C(0x3D)\n#define _GT    C(0x3E)\n#define _QUEST C(0x3F)\n#define _AT    C(0x40)\n#define _A     C(0x41)\n#define _B     C(0x42)\n#define _C     C(0x43)\n#define _D     C(0x44)\n#define _E     C(0x45)\n#define _F     C(0x46)\n#define _G     C(0x47)\n#define _H     C(0x48)\n#define _I     C(0x49)\n#define _J     C(0x4A)\n#define _K     C(0x4B)\n#define _L     C(0x4C)\n#define _M     C(0x4D)\n#define _N     C(0x4E)\n#define _O     C(0x4F)\n#define _P     C(0x50)\n#define _Q     C(0x51)\n#define _R     C(0x52)\n#define _S     C(0x53)\n#define _T     C(0x54)\n#define _U     C(0x55)\n#define _V     C(0x56)\n#define _W     C(0x57)\n#define _X     C(0x58)\n#define _Y     C(0x59)\n#define _Z     C(0x5A)\n#define _LSQB  C(0x5B)\n#define _BSLSH C(0x5C)\n#define _RSQB  C(0x5D)\n#define _CARET C(0x5E)\n#define _USCOR C(0x5F)\n#define _GRAVE C(0x60)\n#define _a     C(0x61)\n#define _b     C(0x62)\n#define _c     C(0x63)\n#define _d     C(0x64)\n#define _e     C(0x65)\n#define _f     C(0x66)\n#define _g     C(0x67)\n#define _h     C(0x68)\n#define _i     C(0x69)\n#define _j     C(0x6A)\n#define _k     C(0x6B)\n#define _l     C(0x6C)\n#define _m     C(0x6D)\n#define _n     C(0x6E)\n#define _o     C(0x6F)\n#define _p     C(0x70)\n#define _q     C(0x71)\n#define _r     C(0x72)\n#define _s     C(0x73)\n#define _t     C(0x74)\n#define _u     C(0x75)\n#define _v     C(0x76)\n#define _w     C(0x77)\n#define _x     C(0x78)\n#define _y     C(0x79)\n#define _z     C(0x7A)\n#define _LBRC  C(0x7B)\n#define _VBAR  C(0x7C)\n#define _RBRC  C(0x7D)\n#define _TILDE C(0x7E)\n\nivec3 MName (int i)\n{\n  ivec3 m;\n  if      (i == 0)  m = ivec3 (_J, _a, _n);\n  else if (i == 1)  m = ivec3 (_F, _e, _b);\n  else if (i == 2)  m = ivec3 (_M, _a, _r);\n  else if (i == 3)  m = ivec3 (_A, _p, _r);\n  else if (i == 4)  m = ivec3 (_M, _a, _y);\n  else if (i == 5)  m = ivec3 (_J, _u, _n);\n  else if (i == 6)  m = ivec3 (_J, _u, _l);\n  else if (i == 7)  m = ivec3 (_A, _u, _g);\n  else if (i == 8)  m = ivec3 (_S, _e, _p);\n  else if (i == 9)  m = ivec3 (_O, _c, _t);\n  else if (i == 10) m = ivec3 (_N, _o, _v);\n  else if (i == 11) m = ivec3 (_D, _e, _c);\n  return m;\n}\n\nivec3 DName (int i)\n{\n  ivec3 d;\n  if      (i == 0)  d = ivec3 (_S, _u, _n);\n  else if (i == 1)  d = ivec3 (_M, _o, _n);\n  else if (i == 2)  d = ivec3 (_T, _u, _e);\n  else if (i == 3)  d = ivec3 (_W, _e, _d);\n  else if (i == 4)  d = ivec3 (_T, _h, _u);\n  else if (i == 5)  d = ivec3 (_F, _r, _i);\n  else if (i == 6)  d = ivec3 (_S, _a, _t);\n  return d;\n}\n\nint DWk (ivec3 ymd) // \"Zeller's congruence\"\n{\n  ivec2 cy;\n  int s;\n  ymd.y += 1;\n  if (ymd.y <= 2) {\n    ymd.x -= 1;\n    ymd.y += 12;\n  }\n  cy.x = ymd.x / 100;\n  cy.y = ymd.x - 100 * cy.x;\n  s = ymd.z + 13 * (ymd.y + 1) / 5 + cy.y + cy.y / 4 + cy.x / 4 + 5 * cy.x;\n  s -= 7 * (s / 7) - 6;\n  s -= 7 * (s / 7);\n  return s;\n}\n\nint DElaps (ivec3 ymd) // Days from 1970-01-01 (http://howardhinnant.github.io/date_algorithms.html)\n{\n  int era, yoe, doy, doe;\n  if (ymd.y <= 2) -- ymd.x;\n  era = (ymd.x >= 0 ? ymd.x : ymd.x - 399) / 400;\n  yoe = (ymd.x - era * 400);\n  doy = (153 * (ymd.y + ((ymd.y > 2) ? -3 : 9)) + 2) / 5 + ymd.z - 1;  // [0-365]\n  doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;  // [0-146096]\n  return era * 146097 - 719468 + doe;\n}\n\n#define DIG2(v) _0 + ivec2 (vec2 (floor ((v) / 10.), mod ((v), 10.)))\n#define T(c) _ic = (_nc -- == 0) ? (c) : _ic;\n#define T2(v) T(v.x) T(v.y)\n#define T3(v) T(v.x) T(v.y) T(v.z)\n\nivec3 inm[2];\nivec2 idt[6], icn[2];\n\nvoid DTimeSet (vec4 d)\n{\n  float nd;\n  int yr, mo, da;\n  idt[0] = DIG2 (floor (d.x / 100.));\n  idt[1] = DIG2 (mod (d.x, 100.));\n  idt[2] = DIG2 (d.z);\n  idt[3] = DIG2 (floor (d.w / 3600.));\n  idt[4] = DIG2 (floor (mod (d.w, 3600.) / 60.));\n  idt[5] = DIG2 (floor (mod (d.w, 60.)));\n  inm[0] = MName (int (d.y));\n  inm[1] = DName (DWk (ivec3 (d.xyz)));\n  nd = mod (float (DElaps (ivec3 (d.x, d.y + 1., d.z)) - DElaps (ivec3 (2020, 1, 30))), 1e4);\n  icn[0] = DIG2 (floor (nd / 100.));\n  icn[1] = DIG2 (mod (nd, 100.));\n}\n\nint GetTxChar (int _nc)\n{\n  int _ic;\n  _ic = 0;\n  T(_SP) T3(inm[1]) T(_SP) T2(idt[2]) T(_MINUS) T3(inm[0]) T(_MINUS)\n  T2(idt[0]) T2(idt[1]) T(_SP) T2(idt[3]) T(_COLON) T2(idt[4]) T(_COLON) T2(idt[5])\n  T(_SP) T(_C) T(_o) T(_r) T(_o) T(_n) T(_a) T(_SP) T(_D) T(_a) T(_y) T(_COLON)\n  T2(icn[0]) T2(icn[1]) T(_SP)\n  return _ic;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcRX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[646, 646, 678, 678, 1618], [1620, 1620, 1646, 1646, 2029], [2031, 2031, 2055, 2055, 2166], [2168, 2168, 2202, 2202, 2744], [2746, 2746, 2791, 2791, 3054], [3056, 3056, 3078, 3078, 3213], [3215, 3215, 3248, 3248, 3424], [3426, 3426, 3447, 3447, 3697], [3699, 3699, 3734, 3734, 4188], [4190, 4190, 4212, 4212, 4242], [4244, 4244, 4279, 4279, 6773], [6775, 6775, 6831, 6831, 7455], [7457, 7457, 7503, 7503, 7560], [7562, 7562, 7586, 7586, 7703], [7705, 7705, 7727, 7727, 7765], [7767, 7767, 7789, 7789, 7827], [7829, 7829, 7874, 7874, 7977], [7979, 7979, 8036, 8036, 8119], [8121, 8121, 8157, 8157, 8363], [8365, 8365, 8395, 8395, 8508], [10712, 10712, 10733, 10733, 11286], [11288, 11288, 11309, 11309, 11642], [11644, 11644, 11690, 11690, 11967], [11969, 11969, 12071, 12071, 12388], [12607, 12607, 12631, 12631, 13125], [13488, 13488, 13512, 13512, 13624], [13626, 13626, 13651, 13651, 13837], [13839, 13839, 13860, 13860, 14015]], "test": "untested"}
{"id": "3sfcRj", "name": "Sierpinski Sphere", "author": "mla", "description": "A Sierpinski Sphere. See code header for various control keys.", "tags": ["sphere", "sierpinski"], "likes": 20, "viewed": 423, "published": 3, "date": "1585216716", "time_retrieved": "2024-07-30T21:16:37.113276", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Sierpinski Gasket on a sphere, with some randomization.\n//\n// <mouse>: rotation\n// <up>/<down>: move in/out\n// <page up>/<page down>: color change probability\n// <left>/<right>: triangle division depth\n// c: color\n// g: display gasket only\n// r: autorotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float AA = 2.0;\nbool dorotate = true;\nbool gasketonly = false;\nbool docolor = true;\nint depth = 10; // Levels of triangle\nfloat pcolorchange = 0.25; // Probability of color change at a given level\n\nconst float PI = 3.14159265;\n\nvoid assert(bool b);\nvec3 hsv2rgb(vec3 c);\nvec3 transform(in vec3 p);\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuint randseed = 1U;\nuint xorshift() {\n  // Xorshift*32\n  // From George Marsaglia: http://www.jstatsoft.org/v08/i14/paper\n  randseed ^= randseed << 13;\n  randseed ^= randseed >> 17;\n  randseed ^= randseed << 5;\n  return randseed;\n}\n\nfloat rand() {\n  return float(xorshift())/pow(2.0,32.0);\n}\n\nvec3 getspherecolor(vec3 p) {\n  uint index = uint(p.x<0.0)+(uint(p.y<0.0)<<1)+(uint(p.z<0.0)<<2);\n  p = abs(p);\n  p /= dot(p,vec3(1));\n  vec2 z = p.xy;\n  float E = 10.0;\n  float t = 0.5*iTime;\n  uint epoch = uint((t+0.5*E+1.0)/(E+2.0));\n  t = mod(t,E+2.0)-1.0;\n  t = max(t,0.0);\n  if (t > 0.5*E) t = max(0.5*E,t-1.0);\n  t = min(t,E-t); // t < 0.5*E\n  randseed = ihash(epoch^index+1U); // 0 hashes to 0!\n  vec3 col = hsv2rgb(vec3(rand(),0.8,1));\n  for (int i = 0; i < depth; i++) {\n    int j;\n    if  (z.x > 0.5) { j = 0; z = 2.0*vec2(z.x-0.5,z.y); }\n    else if (z.y > 0.5) { j = 1; z = 2.0*vec2(z.x,z.y-0.5); }\n    else if (z.x + z.y < 0.5) { j = 2; z = 2.0*z; }\n    else { j = 3; z = 0.5-z; }\n    if (i > 0 && j == 3 && (gasketonly || rand() < 2.0*t/E)) return vec3(0);\n    index = (index << 2) + uint(j);\n    randseed = ihash(epoch^index+1U); // 0 hashes to 0!\n    if (rand() < pcolorchange) col = hsv2rgb(vec3(rand(),0.8,1));\n  }\n  return docolor ? col : vec3(0.8);\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  vec3 p;       // centre\n  float r;      // radius\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit[2]) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // Formula for x^2 + 2Bx + C = 0\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t0,t1;\n  if (B >= 0.0) {\n    t0 = -B-D; t1 = C/t0;\n  } else {\n    t1 = -B+D; t0 = C/t1;\n  }\n  hit[0] = Hit(t0,(q+t0*d-p)/r);\n  hit[1] = Hit(t1,-(q+t1*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit[2]) {\n  Sphere s = Sphere(vec3(0),1.0);\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 solve(Ray r,vec2 uv) {\n  Hit hit[2];\n  vec3 c = vec3(0);\n  if (intersectScene(r,hit)) {\n    for (int i = 0; i < 2; i++) {\n      vec3 n = hit[i].n;\n      assert(dot(r.d,n) <= 0.0);\n      vec3 basecolor = getspherecolor(hit[i].n);\n      if (basecolor == vec3(0)) continue;\n      vec3 color = vec3(0);\n      float ambient = 0.5;\n      float diffuse = 0.5;\n      color += basecolor*ambient;\n      color += basecolor*diffuse*max(0.0,dot(light,n));\n      float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n      vec3 speccolor = basecolor; //vec3(1);\n      color += 1.0*specular*speccolor;\n      if (i == 1) color *= 0.25;\n      return color;\n    }\n  }\n  return c;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_O = 79;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nbool check = false;\nvoid assert(bool b) { if (!b) check = true; }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dorotate = !key(CHAR_R);\n  pcolorchange *= exp(-0.1*float(keycount(KEY_PAGE_UP)-keycount(KEY_PAGE_DOWN)));\n  depth = max(0,8+keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  gasketonly = key(CHAR_G);\n  docolor = !key(CHAR_C);\n  light = vec3(0.5,1.0,-1.0);\n  light = normalize(light);\n  light = transform(light);\n  vec3 p = vec3(0,0,-6);\n  p.z *= exp(-0.1*float(keycount(KEY_UP)-keycount(KEY_DOWN)));\n  p = transform(p);\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,6);\n      r = transform(r);\n      r = normalize(r);\n      col += solve(Ray(p,r),uv);\n    }\n  }\n  fragColor = vec4(pow(col/(AA*AA),vec3(0.4545)),1);\n  if (check) fragColor = vec4(1,0,0,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[736, 800, 820, 820, 934], [956, 956, 973, 1057, 1167], [1169, 1169, 1183, 1183, 1227], [1229, 1229, 1258, 1258, 2200], [2444, 2444, 2501, 2501, 2968], [2970, 2970, 3014, 3014, 3121], [3136, 3231, 3258, 3258, 3434], [3436, 3436, 3463, 3463, 4112], [4641, 4641, 4661, 4661, 4721], [4723, 4723, 4748, 4748, 4796], [4798, 4798, 4821, 4821, 4853], [4855, 4855, 4885, 4885, 4937], [4939, 4939, 4966, 4966, 5295], [5317, 5317, 5338, 5338, 5362], [5364, 5364, 5416, 5416, 6220]], "test": "untested"}
{"id": "3sfczf", "name": "Base warp fBM cineshader", "author": "trinketMage", "description": "Test for Cine shader \nps: https://cineshader.com/view/3sfczf", "tags": ["fbm"], "likes": 42, "viewed": 18770, "published": 3, "date": "1585215888", "time_retrieved": "2024-07-30T21:16:37.964998", "image_code": "\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.02;\n    f += 0.1250*noise( p ); p = m*p*2.02;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.9*q );\n\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.0*o );\n\n\tron = vec4( o, n );\n\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    float f = func(p, on);\n\n\tvec4 col = vec4(vec3(f), (1./f )* .125);\n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Base warp fBM\",\n\t\"description\": \"Noise\",\n\t\"model\": \"\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 78, 78, 107], [109, 109, 131, 131, 327], [329, 329, 351, 351, 610], [612, 612, 635, 635, 682], [684, 684, 707, 707, 766], [768, 768, 804, 804, 1105], [1107, 1107, 1164, 1164, 1375]], "test": "untested"}
{"id": "3dXyzX", "name": "Noise Wiggles", "author": "brechrt", "description": "wiggles made with perlin noise", "tags": ["noise", "perlin"], "likes": 3, "viewed": 307, "published": 3, "date": "1585205603", "time_retrieved": "2024-07-30T21:16:38.720976", "image_code": "uint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { \n    return hash( v.x ^ hash(v.y)); \n}\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\nfloat random( vec2  v ) { \n    return floatConstruct(hash(floatBitsToUint(v)));\n}\n\nfloat noise(vec2 uv){\n\tvec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rot(float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    uv *= 20.;\n    \n    uv *= rot(noise(uv+15.) + iTime*.4);\n    float n = noise(uv+15.);\n    \n    vec3 col1 = vec3(0.950,0.181,0.291);\n    vec3 col2 = vec3(0.136,0.016,0.140);\n\tcol = mix(col1, col2, n); \n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 152], [153, 153, 175, 175, 214], [216, 216, 248, 248, 668], [669, 669, 694, 694, 750], [752, 752, 773, 773, 1287], [1289, 1289, 1307, 1307, 1380], [1382, 1382, 1439, 1439, 1768]], "test": "untested"}
{"id": "3dfyRX", "name": "chrysalis", "author": "haptix", "description": "chrysalis", "tags": ["chrysalis"], "likes": 0, "viewed": 221, "published": 3, "date": "1585198795", "time_retrieved": "2024-07-30T21:16:39.569707", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot (float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 box(vec3 p, vec3 b, float matId)\n{\n    vec3 q = abs(p) - b;\n    return vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.), matId);\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = iTime + 65.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        p.xy *= rot(.061*t);\n        \n        p = abs(p) - vec3(.05*cos(t*.21) + .31,\n                          .05*sin(t*.27) + .35,\n                          .05*sin(t*.37) + .37);\n        \n        p.yz *= rot(.043*t);\n    }\n    \n    return p;\n}\n\nvec2 add(vec2 m1, vec2 m2)\n{\n    return m1.x < m2.x ? m1 : m2;\n}\n\nvec2 map(vec3 p)\n{   \n    p = kif(p);\n    \n    vec2 m1 = box(p, vec3(.07, .8, 1.), 1.);\n    p.x -= .25;\n    vec2 m2 = box(p, vec3(.06, .75, .85), 2.);\n    p.x += .5;\n    vec2 m3 = box(p, vec3(.06, .75, .85), 3.);\n    vec2 m = add(m1, m2);\n    m = add(m, m3);\n    glo += .1 / (.1 + m1.x*m1.x*m1.x*2500.);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 15.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 384; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .00001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(.6*cos(-.1*iTime),\n                   .91*sin(-.1*iTime),\n                   -7.);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(1.5, 1.5, -30.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(sin(.317*(iTime + 44.)),\n                       sin(.151*(iTime + 55.)),\n                       sin(.227*(iTime + 79.))) + 1.2;\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 200.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n\n        vec3 col = .1 * colRot;\n        if(t.y == 2.)\n        \tcolRot = vec3(.2);\n        else if(t.y == 3.)\n            colRot = vec3(.5);\n        \n        col *= .12 * ao;\n        col += .35 * diff * colRot.yzx;\n        col += 1. * spec * vec3(1., 1., 1.);\n        col += glo*.008*colRot;\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*.008*colRot.zyx, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 61, 61, 121], [123, 123, 162, 162, 268], [270, 270, 288, 288, 609], [611, 611, 639, 639, 675], [677, 677, 695, 695, 996], [998, 998, 1025, 1025, 1254], [1256, 1256, 1313, 1313, 2937]], "test": "untested"}
{"id": "tdscz2", "name": "waves of confusion", "author": "scry", "description": "It just keeps going! looks nice in fullscreen :)", "tags": ["2d", "trippy"], "likes": 7, "viewed": 377, "published": 3, "date": "1585190712", "time_retrieved": "2024-07-30T21:16:40.440379", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uvb = uv;\n    float time = iTime+70.;\n    vec3 bak = texture(iChannel0,uv).rgb;\n    uv += vec2(sin(time*0.011),cos(time*0.011))*0.03;\n    uv *= sin(time*0.01+ sin((sin(uv.x*5.-time*0.01) + sin(uv.y*4.+time*0.01)) )*0.1);\n    uv += vec2(sin(time*0.013),cos(time*0.013))*0.1;\n    uv *= sin(time*0.008);\n    uv += bak.rg*0.15*sin(uv*8.+time*0.01);\n    //uv.x += time*0.001;\n    uv += uv.yx*0.015*sin(uv*8.+time*0.008);\n    uv = uv+sin(uv*50.+time*0.05)*0.01;\n    vec3 col = vec3(0.);\n    col += sin(uv.x*10.+time*0.01);\n    col += cos(uv.y*5.+time*0.02);\n    col = vec3(sin(col.r*3.+time*0.02),cos(col.b*2.+time*0.05),sin(col.g-time*0.01));\n    col = sin((uv.x+uv.y)*3.+time*0.005)*col*0.2;\n    col = sin(uv.x*300.+col*20.);\n    col *= uv.y;\n    col += sin(uv.x*100.+time*0.3)+1.;\n    col += sin(uv.y*4.+time*0.1);\n    uv.y += sin(uv.x*20.+time*0.04)*0.1+sin(uv.x*70.)*0.1;\n    col = sin(col*0.9)*sin(uv.y*8.);\n    col = sin(col)*0.5+0.5;\n    float bw = (col.r+col.b+col.g)/3.;\n    \n    col = mix(col,vec3(sin(bw*2.5+time*0.01),sin(bw*3.+time*0.02),sin(bw*0.1+time*0.008)),sin(time*0.01)*0.5+0.9);\n    \n    col += sin(uvb.y*9.+time*-0.1+sin(uv.y*40.1*sin(uv.x-time*0.01)))*sin(uv.y+time*0.05);\n    uv = mix(uv,uvb,sin(((uv.x*-10.)-sin(uvb.y*20.)*0.5+0.5)+uv.y*9.+time*0.3));\n    col *= sin((uv.x*2.+uv.y)*120.)*0.1+1.;\n    col *= 0.5;\n    col = mix(col,bak,0.985);\n    //col += clamp(sin(uv.x*uv.y*0.1+3.4),1.,0.1);\n    //col = mod(col,3.);\n    //col /= sin(sin(uv.y+time*0.001+col*0.05)*200.+time*0.1);\n    float tt = time*10.;\n    vec2 ux = uvb;\n    ux *= 10.01;\n    //ux = mix(ux,uv*0.01,0.2);\n    vec3 pal = vec3(sin(ux.x+tt*0.025)*0.5+0.5,sin(ux.x+tt*0.02)*0.5+0.5,sin(ux.x+tt*0.04)*0.5+0.5);\n    uv += vec2(sin(time*0.02),cos(time*0.02))*0.01;\n    bak = texture(iChannel0,mix(uv.xy,ux*0.1,0.4)).rgb;\n    //col = pal;\n    col = mix(col,pal,0.005);\n    col = mix(col,bak,0.01);\n    fragColor = vec4(col,0.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdscz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 146]], "test": "untested"}
{"id": "wsscR2", "name": "Neighbor bound tracking ", "author": "michael0884", "description": "Sorting the closest particles in axis directions in particle space only, no texture needed.", "tags": ["particles", "aabb", "sort"], "likes": 6, "viewed": 379, "published": 3, "date": "1585187737", "time_retrieved": "2024-07-30T21:16:41.286118", "image_code": "ivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    ivec4 nb = get(ivec2(pos));\n \tvec4 p0 = getParticle(nb.x);\n   \n    ivec4 nbm = get(ivec2(iMouse.xy));\n    ivec4 nbb = getb(nbm.x);\n    \n    float d = 0.;\n    for(int i = 0; i<4; i++)\n    {\n        vec4 pi = getParticle(nbb[i]);\n        d += exp(-distance(pos,pi.xy));\n    }\n    \n    float d0 = 0.;\n    for(int i = 0; i<4; i++)\n    {\n        vec4 pi = getParticle(nb[i]);\n        d0 += 0.24*exp(-0.3*distance(pos,pi.xy));\n    }\n    \n    fragColor = 1.2*sin(vec4(1,1,3,4)*d0 +\n                            5.*vec4(4,3,2,1)*d);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(256,128)\n#define dt 0.25\n\n\nconst int tot_n = N.x*N.y;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}", "buffer_a_code": "//particle buffer\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 Fv(vec2 p0, int pid)\n{\n    if(pid < 0) return vec2(0); \n   \tvec2 p1 = getParticle(pid).xy;\n    return normalize(p1-p0)*F(distance(p1,p0));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U.xy, cp.x) +\n            \t Fv(U.xy, cp.y) +\n            \t Fv(U.xy, cp.z) +\n                 Fv(U.xy, cp.w) + \n            \t vec2(0,-0.003);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 2.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw = U.zw*0.999 + F*dt;\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//sorting closest 4 particles in axis directions that make a bounding box\n//only in particle space, texture buffer not needed\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid) return;\n       \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = get(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    for(int i = 0; i < 8; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    sortneighbor(id); \n    ivec4 nb = get(id);\n    for(int i = 0; i < 4; i++)\n    {\n        sortneighbor(nb[i]); \n    }\n    \n    \n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    for(int i = 0; i < 8; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    U = save(u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsscR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 64], [66, 66, 86, 86, 137], [139, 139, 165, 165, 200], [202, 202, 253, 253, 783]], "test": "untested"}
{"id": "tdXyR2", "name": "Day 987", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 17, "viewed": 438, "published": 3, "date": "1585174979", "time_retrieved": "2024-07-30T21:16:42.216630", "image_code": "// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),1.8)*0.06;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*3.3;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.9);\n    \n    fragColor.gb *= 0.95  - smoothstep(0.,1.,dot(uvn,uvn))*0.1;\n    \n    fragColor.b *= 1. + uv.x*0.02;\n    fragColor.g *= 1. + uv.t*0.05;\n    \n    fragColor = max(fragColor, 0.);\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*0.1));\n    fragColor *= 1. - dot(uvn,uvn)*0.9    ;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm 140.\n\n#define tick (60./bpm)\n\n#define beat tick\n#define bar  beat*4.\n#define hbar  bar/2.\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n#define S vec2 s = vec2(0);\n#define E return s;\n#define T true\n#define F false\n\n\nbool[] pattA = bool[8](T,F,T,T,F,T,F,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\n\n\nbool[] pattBa = bool[8](T,T,F,T,F,T,F,T);\nbool[] pattB = bool[8](T,F,T,T,F,T,F,T);\nint[] notesB = int[8](0,5,2,1,0,1,3,4);\n\nvec4[] chords = vec4[4](\n    vec4(0.,3.,7.,10.),\n    vec4(0. + 2.,3. + 2.,7. + 2.,10. + 2.),\n    vec4(0. - 2.,3. - 2.,7. - 2.,10. - 2.),\n    vec4(0.+3.,5.+3.,7.+3. - 12.,10. )\n);\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\nvec2 kick (float t, inout float sc){\n\tinit;\n\t\n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp(-t*15.1)*200. + 40.)*tt )*env;\n    \n    s = mix(s,sin(s*3.)*1., 0.3);\n    \n    \n    float bitreduction = 0.04;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattA[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\n\n\nvec2 snare(float t){\n\n    init;\n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 3500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*16.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (440./1.5 + exp(-t*50.)*1400.  )*tt;\n    s += sin( f )*env;\n    //s += sin( f*2.25 )*env*0.1;\n    //s += sin( f*1.5 )*env*0.1;\n    s += amt*sin( f + nn*0.9*smoothstep(0.,1.,t*20.) )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    //s += sign(s)*pow(abs(s), vec2(2.))*0.9;\n    s += amt*sin( f*4. + nn.x*exp(-t*10.))*env*env*0.2;\n    //s *= 1.6;\n    s *= 0.39;\n    //s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.1);\n\ts = sin(s*1.5);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = lpnoise(t, 600.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float amt = 0.4;\n    float env = exp(-t*10.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*0.4)*env;\n    s -= sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    //s += sin(f + sin(2000.*tt)*exp(-t*20.))*env;\n    \n    \n    float bitreduction = 0.3 + sin(6.28*to/beat)*0.0;\n    s = mix(s,sign(s) * floor(abs(s)/bitreduction)*bitreduction, 0.1 + smoothstep(0.,1.,t*2.)*0.7);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\n\nvec2 chord(float t){\n\tinit;\n    \n    float r = bar;\n    t = mod(t,r*4.);\n    int id = int(floor(t/r));\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 4500.)*0.45;\n    \n    nn *= 0.1*sin(t);\n    float m = 1.;\n    for(float i = 0.; i < 5.; i++){\n        float a = (1. + i/2.);\n    \ts += sin( note(chords[id].x, 4.) *tt*a + nn)*m;\n    \ts += sin( note(chords[id].y, 4.) *tt*a + nn)*m;\n    \ts += sin( note(chords[id].z, 4.) *tt*a + nn)*m;\n    \ts += sin( note(chords[id].w, 4.) *tt*a + nn)*m;\n    \tm *= 0.5;\n    }\n    \n    \n    s *= 0.04;\n    //s = sin(s);\n\tret;\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float ttt = t;\n    float r = bar;\n    t = mod(t,r*4.);\n    \n    float bt = mod(t,beat*2.);\n    ivec2 id = ivec2(int(floor(t/r)),int(floor(bt/(beat/4.))));\n    \n    //t = mod(t, beat*2.);\n    \n    bt = mod(bt, beat/4.);\n    t = bt;\n    float env = exp(-t*1.);\n    float n = note(chords[id.x][id.y],1.);\n    s += sin(n*tt \n             + sin(n*2.*tt)*exp(-bt*9.)*0.6\n             + sin(n*4.*tt)*exp(-bt*10.)*1.\n            \n            )*env;\n    \n    \n    \n    s *= float(pattB[id.y]);\n    \n    \n    \n    float bitreduction = 0.04;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    //s += sin(200.*tt + exp(-t*3.1)*200.)*exp(-t*3.7)*(1. - exp(-t*1.4));\n    \n    \n    ret;\n}\n\nvec2 hats (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat*0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*15.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*5.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.35;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.7;\n    ret;\n}\n\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s= vec2(0);\n    \n    \n    float sc;\n    s += kick(t,sc)*1.;\n    s += bass(t)*0.4*pow(sc, 1.4);\n    s += snare(t);\n    s += chord(t)*sc;\n    s += hats(t)*0.06*(0.2 + pow(sc, 2.)*0.8)*0.4;\n    s += hatsb(t)*0.06*(0.2 + pow(sc, 1.)*0.8)*0.7;\n    s += lead(t)*0.4;\n    s *= 0.8;\n    \n    s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.2 + sin(t)*0.2);\n    s = clamp(s,-1.,1.);\n    \n    s *= smoothstep(0.,1.,t*0.5);\n    return s;\n}", "sound_inputs": [], "buffer_a_code": "\n\n// Fork of \"Day 98\" by jeyko. https://shadertoy.com/view/tdXyR2\n// 2020-03-25 16:38:38\n\n// Fork of \"Day 97\" by jeyko. https://shadertoy.com/view/tslyRB\n// 2020-03-25 10:51:05\n\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime*1.6)\n\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    n += valueNoise(uv*800.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    n = max(n, 0.);\n    return n;\n}\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nfloat xor(vec2 p){\n    ivec2 q = ivec2(p);\n\treturn float(q.x^q.y);\n}\n\nvec3 get(vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n\tvec2 uvn = uv;\n    //uv *= 1. - dot(uv,uv)*0.3;\n    \n    uv *= 1. - dot(uv,uv)*0.3 + valueNoise(vec2(iTime),0.2).x*0.4;\n    //vec3 aa =pal(0.5,0.55,vec3(0.1,0.7,0.9), 0.6 + sin(id*0.4 + iTime)*.4, id*0.9 + iTime*0.5 - dot(uvn,uvn)*.5);\n    \n    vec2 p = uv;\n    \n    \n    \n    \n    float its = 2.;\n    for(float i = 0.; i < its; i++){\n        //p = abs(p);\n        float dpp = dot(p,p);\n        dpp = clamp(dpp, 0.1,1.);\n    \tp = (p)/dpp;\n        p = clamp(p, -5.,1.7);\n    \tp = vec2(2.*atan(p.y, p.x)/6.28, length(p));\n        if(i == 0.)\n        \tp *= xor(abs(p)*2.)*0.25;\n        if(p.x < 0. && p.y > 0. && i == 1. && false)\n            p.xy = p.yx;\n    }\n    \n    \n    p.y = 0.05*log(p.y) + (iTime)*0.004;\n    \n    \n    float modD = 0.01;\n    vec2 id = floor(p/modD);\n    \n\n    col += mod(id.x, 2.);\n    col += mod(id.y, 2.);\n    \n    \n    col = max(col, 0.);\n    col = mix(col,smoothstep(0.,1.,col), 0.8);\n    \n    col -= fbm(uvn).x*0.01;\n    col += fbm(uv + 4.).x*0.01;\n    \n    col = max(col, 0.);\n    col = pow(col, vec3(1. + dot(uvn,uvn)*0.4) );\n    \n    col *= 1. - dot(uvn,uvn);\n    \n    return col;\n}\n    \n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(float i =0.; i < 9. + float(min(iFrame,0)); i++){\n    \tcol += get(fragCoord + vec2(mod(i,3.),floor(i/3.))*0.25);\n    }\n    col /= 9.;\n    \n    col = max(col, 0.);\n\tcol = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 89, 89, 1222]], "test": "untested"}
{"id": "tdfyRB", "name": "Expanding oil", "author": "BynaryCobweb", "description": "Simple noise experiment, to go along some music I made", "tags": ["noise", "colors", "warp", "oil"], "likes": 1, "viewed": 253, "published": 3, "date": "1585174630", "time_retrieved": "2024-07-30T21:16:43.110241", "image_code": "\n\nfloat rand3(vec3 v) {\n    return fract(sin(dot(v + vec3(-8.5123, 23.2156, 0.0), vec3(12.9898, 6.233, 0.84261))) * 47583.5453123);\n}\n\n\nfloat noise3(in vec3 uvx) {\n    vec3 f = fract(uvx);\n    vec3 i = floor(uvx);\n    \n    float a1 = rand3(i);\n    float b1 = rand3(i + vec3(0.0, 1.0, 0.0));\n    float c1 = rand3(i + vec3(1.0, 0.0, 0.0));\n    float d1 = rand3(i + vec3(1.0, 1.0, 0.0));\n    float a2 = rand3(i + vec3(0.0, 0.0, 1.0));\n    float b2 = rand3(i + vec3(0.0, 1.0, 1.0));\n    float c2 = rand3(i + vec3(1.0, 0.0, 1.0));\n    float d2 = rand3(i + vec3(1.0, 1.0, 1.0));\n    \n    vec3 u = -2. * f * f * f + 3. * f * f;\n    \n    float a = mix(a1, a2, u.z);\n    float b = mix(b1, b2, u.z);\n    float c = mix(c1, c2, u.z);\n    float d = mix(d1, d2, u.z);\n    \n    return mix(mix(a, b, u.y), mix(c, d, u.y), u.x);\n}\n\nfloat fbm3(in vec3 uvx) {\n    float sum = 0.0;\n    float amp = 0.0;\n    float persistence = 0.7;\n    vec3 stz = uvx;\n    \n    for (int i = 0; i < 8; ++i) {\n        amp = amp / persistence + noise3(stz);\n        sum = sum / persistence + 1.;\n        stz *= 2.;\n    }\n    return amp / sum;\n}\n\n\nvec3 drawBubble(vec2 center, float radius, vec2 uv, vec3 col) {\n    float d = distance(center, uv);\n    float a = smoothstep(radius * 0.9, radius, d) * 0.9 + 0.1;\n    a *= 1.0 - step(radius, d);\n    col = mix(col, vec3(1.0), a);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 center = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    float d = distance(uv, center);\n\tvec3 uvt = vec3(uv, iTime * 0.005);\n    \n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // col = drawBubble(vec2(0.2, 0.3), 0.05, uv, col);\n    vec3 col = vec3(fbm3(uvt), fbm3(uvt.yzx), fbm3(uvt.zxy));\n    \n    float crit = fbm3(col);\n    col *= smoothstep(0.4, 0.5, crit) * (1. - smoothstep(0.5, 0.6, crit));\n    \n    float tx = iTime * 1.0;\n    tx += sin(tx) * 1.5;\n    tx *= 0.04;\n    float grow = 1.0 - smoothstep(tx - 0.05, tx + 0.05, d * 2.0 + fbm3(uvt) * 4.0 - 1.8);\n    \n    vec3 uvt2 = vec3(uv, iTime * 0.05);\n    vec3 lake = vec3(fbm3(uvt2), fbm3(uvt2 + vec3(1.0)), fbm3(uvt2 + vec3(2.0)));\n    lake = vec3(fbm3(lake), fbm3(lake + vec3(1.0)), fbm3(lake + vec3(2.0)));\n    lake = vec3(fbm3(lake) * vec3(0.2, 0.2, 0.4)) * vec3(0.0);\n    \n    col = mix(lake, col, grow);\n    // col *= smoothstep(0.4, 0.6, fbm3(uvt));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 23, 133], [136, 136, 163, 163, 813], [815, 815, 840, 840, 1104], [1107, 1107, 1170, 1170, 1353], [1356, 1356, 1413, 1463, 2536]], "test": "untested"}
{"id": "3dlcRj", "name": "Virus simulation", "author": "robobo1221", "description": "simulation of a spreading virus over a total amount of time. \n\nPlease do make improvements if you want to!", "tags": ["simulation", "disease", "virus", "infection"], "likes": 0, "viewed": 407, "published": 3, "date": "1585154730", "time_retrieved": "2024-07-30T21:16:44.033772", "image_code": "const float spreadRate = 0.3;\t// How much the virus spreads per day\nconst float recoverRate = 0.04;\t// How much each person recovers per day\nconst int peopleCount = 30;\t\t// Total amount of people\nconst int timeLength = 120;\t\t// Length in days\n\nfloat hash(float n){return fract(sin(n) * 43758.5453123);}\n\nvoid calculateVirusValues(inout float values[timeLength]) {\n    float healthPerson[peopleCount];\n    int isInfected[peopleCount];\n    int hasBeenInfected[peopleCount];\n    \n    for (int i = 0; i < peopleCount; i++) {\n\t\thealthPerson[i] = 1.0;\n        isInfected[i] = 0;\n    }\n    \n    healthPerson[0] = 0.0;\n    isInfected[0] = 1;\n    hasBeenInfected[0] = 1;\n        \n    for (int i = 0; i < timeLength; i++) {\n        values[i] = 0.0;\n        \n        for (int j = 0; j < peopleCount; j++) {\n            if (isInfected[j] == 0) {\n            \tcontinue;    \n            }\n            \n            float getInfected = clamp(floor(hash(float(i+j)) + spreadRate), 0.0, 1.);\n            \n            if (isInfected[j] == 1) {\n\t\t\t\thealthPerson[j] += recoverRate;\n                hasBeenInfected[j] = 1;\n                \n                int nextPersonId = int(hash(float(i-j*255)) * float(peopleCount));\n                \n                if (hasBeenInfected[nextPersonId] == 0) {\n                    healthPerson[nextPersonId] = 1.0 - getInfected;\n                    isInfected[nextPersonId] = int(getInfected);\n                }\n            } \n            \n            if (healthPerson[j] >= 1.0) {\n\t\t\t\thealthPerson[j] = 1.0;\n                \n                isInfected[j] = 0;\n            }\n        }\n        \n        for (int j = 0; j < peopleCount; j++) {\n\t\t\tvalues[i] += float(isInfected[j]);\n        }\n    }\n}\n\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2, float pixelSize) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n\n  if ( a >= c || b >=  c ) return 0.0;\n\n  float p = (a + b + c) * 0.5;\n\n  // median to (p1, p2) vector\n  float h = 2. / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  return 1.0 - smoothstep(pixelSize, pixelSize * 2., h);\n}\n\nfloat graphValues(vec2 uv, float pixelSize) {\n\tvec2 xy = vec2(timeLength, peopleCount);\n    float values[timeLength];\n    calculateVirusValues(values);\n    \n    float result = 0.0;\n    \n    for (int i = 0; i < timeLength; ++i) {\n        float nextPeopleValue = values[(i + 1) % timeLength];\n        float nextTimeValue = float(i + 1);\n        \n        float peopleValue = values[i];\n        float timeValue = float(i);\n        \n        peopleValue = peopleValue;\n        nextPeopleValue = nextPeopleValue;\n        \n        if (i == timeLength-1) {\n\t\t\tnextPeopleValue = peopleValue;\n        }\n        \n\t\tresult = max(result, drawLine(uv, vec2(timeValue, peopleValue) / xy, vec2(nextTimeValue, nextPeopleValue) / xy, pixelSize));\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float pixelSize = 1.0 / min(iResolution.x, iResolution.y);\n    float graph = graphValues(uv, pixelSize);\n\n    // Time varying pixel color\n    vec3 col = vec3(graph);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 264, 264, 302], [304, 304, 363, 363, 1712], [1714, 1714, 1774, 1774, 2107], [2109, 2109, 2154, 2154, 2868], [2870, 2870, 2927, 2977, 3250]], "test": "untested"}
{"id": "WdlcRj", "name": "PUMA CLYDE CONCEPT", "author": "yasuo", "description": "footwear design experiment. j.cole+clyde = j.clyde", "tags": ["puma"], "likes": 42, "viewed": 2870, "published": 3, "date": "1585152860", "time_retrieved": "2024-07-30T21:16:45.083964", "image_code": "#define PI 3.141592653589793\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define SHDOW_COL vec3(0.5)\n#define MODE 2\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\nfloat fbm(vec2 uv){\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\nmat2 bend(float p, float k) {\n    float c = cos(k*p);\n    float s = sin(k*p);\n    mat2  m = mat2(c,-s,s,c);\n    return m;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvec3 outsole(vec2 p, vec3 col, vec3 bcol) {\n    vec2 pref = p;\n    float d = sdBox(p,vec2(0.7,0.03))-0.02;\n    float shadow = sdBox(p-vec2(0.0,0.01),vec2(0.7,0.03))-0.02;\n    col = mix(col,SHDOW_COL,S(shadow,-0.02));\n    col = mix(col,bcol,S(d,0.0));\n    \n    p.x = mod(p.x,0.01)-0.005;\n    float d2 = sdBox(p+vec2(0.0,0.01),vec2(0.0005,0.03));\n    p = pref;\n    \n    d2 = max((p.x+0.3),d2);\n    d2 = max(-(p.x+0.71),d2);\n    \n    float mask = dot(p,vec2(0.15,0.1))+0.07;\n    d2 = max(mask,d2);\n    \n    col = mix(col,vec3(0.9),S(d2,0.0));\n    \n    float n = fbm(p*50.0+20.0)*1.5;\n    d = sdBox((p+vec2(-0.1,0.01))*n*1.7,vec2(0.6,0.03));\n    mask = dot(p,vec2(0.15,0.1))+0.066;\n    d = max(-mask,d);\n    d = max(p.x-0.7,d);\n    d = max(-p.y-0.05,d);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    // stitch\n    d = sdBox(p-vec2(0.0,0.035),vec2(0.7,0.001));\n    mask = smoothstep(0.04,0.05,mod(p.x,0.1)-0.05);\n    d = max(mask,d);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    return col;\n}\n\nfloat lateralSideBase(vec2 p) {\n    vec2 pref = p;\n    float d = sdBox(p,vec2(0.5,0.15));\n    p*=Rot(radians(-3.0));\n    \n    float blend = smoothstep(-1.0,0.00,p.x)*(1.0-smoothstep(0.00,1.0,p.x));\n    p.y *= mix(2.11,0.73,blend);\n    float d2 = sdBox((p-vec2(0.0,0.11)),vec2(0.52,0.15));\n    p = pref;\n    p.y*=1.08;\n    float d3 = length(p-vec2(-0.445,-0.02))-0.2;\n    d = min(d,d2);\n    d = min(d3,d);\n    d = max(-p.y,d);\n    return d;\n}\n\nvec3 shoelaceGuard(vec2 p, vec3 col, vec3 bcol) {\n    float mask = dot(p,vec2(-0.03,0.08))-0.023;\n    float d = lateralSideBase(p);\n    d = max(-mask*2.5,d);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nvec3 lateralSide(vec2 p, vec3 col, vec3 bcol, vec3 bcol2, vec3 bcol3) {\n    vec2 pref = p;\n    p.x*=0.99;\n    p.y*=0.93;\n    float d = lateralSideBase(p-vec2(0.0,0.002)); // shadow\n    col = mix(col,SHDOW_COL,S(d,-0.01));\n    p = pref;\n    p.y*=0.95;\n    d = lateralSideBase(p);\n    col = mix(col,bcol,S(d,0.0));\n    col = shoelaceGuard(p-vec2(0.0,-0.005),col,SHDOW_COL); // shadow\n    col = shoelaceGuard(p,col,bcol2);\n    \n    // shoelace hole\n    d = length(p-vec2(-0.05,0.315))-0.015;\n    col = mix(col,bcol3,S(d,0.0));\n    \n    return col;\n}\n    \nvec3 toeCap(vec2 p, vec3 col, vec3 bcol) {\n    vec2 pref = p;\n    float blend = smoothstep(-1.0,0.15,p.x)*(1.0-smoothstep(0.15,1.0,p.x));\n    p.y *= mix(5.0,0.8,blend);\n    float d = sdRoundedBox(p,vec2(0.2,0.1),vec4(0.0,0.0,0.1,0.0));\n    d = max(-p.y-0.03,d);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nfloat heelCounterbase(vec2 p) {\n    mat2  m = bend(p.y,0.6);\n    p = m*p.xy;\n    p.x*=0.95;\n    \n    vec2 pref = p;\n    float d =  sdBox(p,vec2(0.1,0.2))-0.03;\n    p.y*=0.5;\n    float mask = length(p-vec2(-0.07,0.222))-0.2;\n    d = max(-mask,d);\n    p = pref;\n    p*=Rot(radians(-20.0));\n    p.x*=1.7;\n    p.y*=0.75;\n    mask = length((p-vec2(-0.14,-0.05)))-0.2;\n    d = max(-mask,d);\n    \n    p = pref;\n    p*=Rot(radians(8.0));\n    p.x*=1.7;\n    d = max((length((p-vec2(0.14,0.027)))-0.21),d);\n    \n    return d;\n}\n\nvec3 heelCounter(vec2 p, vec3 col, vec3 bcol, vec3 bcol2) {\n    vec2 pref = p;\n    float d =  heelCounterbase (p+vec2(0.01,0.005)); // shadow\n    col = mix(col,SHDOW_COL,S(d,-0.01));\n    d =  heelCounterbase (p);\n    col = mix(col,bcol2,S(d,0.0));\n    d =  heelCounterbase (p);\n    float d2 =  sdBox((p-vec2(0.138,0.12))*Rot(radians(-12.0)),vec2(0.002,0.06))-0.017;\n    d = max(-d2,d);\n    col = mix(col,SHDOW_COL,S(d,-0.01));\n    d2 =  sdBox((p-vec2(0.13,0.12))*Rot(radians(-12.0)),vec2(0.002,0.06))-0.017;\n    d = max(-d2,d);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nvec3 shoetongue(vec2 p, vec3 col, vec3 bcol, vec3 bcol2) {\n    float d = sdBox(p*Rot(radians(-24.5)),vec2(0.38,0.05))-0.05;\n    col = mix(col,bcol,S(d,0.0));\n    d =  sdBox((p-vec2(0.231,0.202))*Rot(radians(-25.0)),vec2(0.1,0.001))-0.008;\n    col = mix(col,SHDOW_COL,S(d,-0.005));\n\td =  sdBox((p-vec2(0.23,0.21))*Rot(radians(-25.0)),vec2(0.1,0.001))-0.008;\n    col = mix(col,bcol2,S(d,0.0));\n    return col;\n}\n\nfloat shoelaseBase(vec2 p) {\n    vec2 pref = p;\n    float deg = 66.0;\n    p*=Rot(radians(deg));\n    p.y = mod(p.y,0.09)-0.045;\n    float d = sdBox(p*Rot(radians(-10.0)),vec2(0.022,0.002))-0.013;\n    p = pref;\n    p*=Rot(radians(deg));\n    d = max(-p.y-0.45,d);\n    d = max(p.y-0.08,d);\n    return d;\n}\n\nfloat shoelaseHole(vec2 p) {\n    vec2 pref = p;\n    float deg = 66.0;\n    p*=Rot(radians(deg));\n    p.y = mod(p.y,0.09)-0.045;\n    float d = length(p)-0.02;\n    p = pref;\n    p*=Rot(radians(deg));\n    d = max(-p.y-0.45,d);\n    d = max(p.y-0.08,d);\n    return d;\n}\n\nvec3 shoelace(vec2 p, vec3 col, vec3 bcol) {\n    vec2 pref = p;\n    \n    float sh = shoelaseHole(p-vec2(0.011,-0.02));\n    col = mix(col,vec3(0.0),S(sh,0.0));\n    \n    float d = shoelaseBase(p-vec2(-0.003,-0.007)); // shadow\n    col = mix(col,SHDOW_COL,S(d,-0.005));\n    d = shoelaseBase(p);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nfloat stripeBase(vec2 p) {\n    vec2 pref = p;\n    \n    p.x*=0.7;\n    float d = length(p-vec2(0.0,0.0))-0.14;\n    float d2 = length(p-vec2(0.22,-0.1))-0.22;\n    \n    d = max(-p.y-0.02,max(-d2,d ));\n    p = pref;\n    \n    mat2  m = bend(p.y,-0.6);\n    p = m*p.xy;\n    \n    float sc = mix(0.07,2.5,smoothstep(-1.0,1.0,p.x));\n    p.y*=sc;\n    float d3 = sdBox((p-vec2(0.3,0.24))*Rot(radians(-19.0)), vec2(0.335,0.041));\n    d = min(d,d3);\n    \n    return d;\n}\n\nvec3 stripe(vec2 p, vec3 col, vec3 bcol){\n    vec2 pref = p;\n    mat2  m = bend(p.y,0.7);\n    p = m*p.xy;\n    p*=0.87;\n    float d = stripeBase(p-vec2(0.005,-0.015)); // shadow\n    col = mix(col,SHDOW_COL,S(d,-0.02));\n    \n    p = pref;\n    p = m*p.xy;\n    d = stripeBase(p);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nfloat stitchBase(vec2 p, float size) {\n    float d = sdBox(p,vec2(size,0.0001))*1.3;\n    float mask = smoothstep(0.01,0.03,mod(p.x,0.03)-0.015);\n    d = max(mask,d);\n    return d;\n}\n\nvec3 stitch(vec2 p, vec3 col, vec3 bcol, vec3 bcol2, vec3 bcol3) {\n    vec2 pref = p;\n    float d = stitchBase((p-vec2(0.2,-0.03))*Rot(radians(40.0)), 0.07);\n    col = mix(col,bcol,S(d,0.0));\n    d = stitchBase((p-vec2(0.27,-0.19))*Rot(radians(100.0)), 0.06);\n    col = mix(col,bcol,S(d,0.0));\n    d = stitchBase((p-vec2(-0.07,-0.045))*Rot(radians(-21.6)), 0.38);\n    col = mix(col,bcol,S(d,0.0));\n    \n    d = stitchBase((p-vec2(-0.37,-0.22))*Rot(radians(105.0)), 0.04);\n    col = mix(col,bcol,S(d,0.0));\n    \n    d = stitchBase((p-vec2(-0.43,-0.22))*Rot(radians(105.0)), 0.03);\n    col = mix(col,bcol,S(d,0.0));\n    \n    // stitch for stripe\n    mat2  m = bend(p.y,0.7);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(0.32,-0.063))*Rot(radians(-9.0)), 0.28);\n    col = mix(col,bcol2,S(d,0.0));\n    p = pref;\n    \n    m = bend(p.y,-2.8);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(-0.15,-0.092))*Rot(radians(9.0)), 0.146);\n    col = mix(col,bcol2,S(d,0.0));\n    p = pref;\n    \n    m = bend(p.y,0.7);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(0.38,-0.076))*Rot(radians(-11.0)), 0.23);\n    col = mix(col,bcol2,S(d,0.0));\n    p = pref;\n    \n    m = bend(p.y,-2.0);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(0.0,-0.193))*Rot(radians(-15.0)), 0.1);\n    col = mix(col,bcol2,S(d,0.0));\n    p = pref;\n    \n    // stitch for heelcounter\n    p = pref;\n    m = bend(p.y,1.0);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(0.67,-0.04))*Rot(radians(32.0)), 0.07);\n    col = mix(col,bcol3,S(d,0.0));\n    return col;\n}\n\nvec3 floorShadow(vec2 p, vec3 col, float size) {\n    p.y*=30.0;\n    float d = length(p)-size;\n    col = mix(col,vec3(0.3),S(d,-0.4));\n    return col;\n}\n\nvec3 stripeMaterial(vec2 p, vec3 col) {\n    vec2 pref = p;\n    float sc = 6.0;\n    p*=sc;\n    float size = 0.01;\n    p.x = mod(p.x,0.2)-0.1;\n    p.y = mod(p.y,0.14)-0.07;\n    float d =  sdBox(p,vec2(size))-0.03;\n    col = mix(col,col*1.2,S(d,0.0));\n    p = pref;\n    p*=sc;\n    p.x+=0.1;\n    p.y+=0.07;\n\tp.x = mod(p.x,0.2)-0.1;\n    p.y = mod(p.y,0.14)-0.07;\n    d =  sdBox(p,vec2(size))-0.03;\n    col = mix(col,col*1.2,S(d,0.0));\n    return col;\n}\n\nvec3 lateralsideMaterial(vec2 p, vec3 col, vec3 col2) {\n    p*= 2.5;\n    p.x-=iTime*0.1;\n    float size = 0.096;\n    float mrg = 4.0;\n    p.x = mod(p.x,size*mrg)-((size*mrg)*0.5);\n    p.y = mod(p.y,size*mrg)-((size*mrg)*0.5);\n    float d = sdBox(p,vec2(0.1));\n    col = mix(col,col2,S(d,-0.01));\n    p.x = mod(p.x,size*mrg)-((size*mrg)*0.5);\n    p.y = mod(p.y,size*mrg)-((size*mrg)*0.5);\n    d = sdBox(p,vec2(0.1));\n    col = mix(col,col2,S(d,-0.01));\n    return col;\n}\n\nfloat charJ(vec2 p) {\n    float d = sdBox(p-vec2(0.02,0.0),vec2(0.02,0.1));\n    float d2 = sdBox(p-vec2(-0.04,-0.06),vec2(0.04,0.04));\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(-0.02,-0.01),vec2(0.02,0.05));\n    d = max(-d2,d);\n    return d;\n}\nfloat charC(vec2 p) {\n    float d = sdBox(p,vec2(0.06,0.1));\n    float d2 = sdBox(p-vec2(0.03,0.00),vec2(0.05,0.06));\n    d = max(-d2,d);\n    return d;\n}\nfloat charL(vec2 p) {\n    float d = sdBox(p,vec2(0.06,0.1));\n    float d2 = sdBox(p-vec2(0.03,0.03),vec2(0.05,0.09));\n    d = max(-d2,d);\n    return d;\n}\nfloat charY(vec2 p) {\n    float d = sdBox(p-vec2(0.00,0.05),vec2(0.06,0.05));\n    float d2 = sdBox(p-vec2(0.00,-0.05),vec2(0.02,0.05));\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(0.00,0.08),vec2(0.02,0.05));\n    d = max(-d2,d);\n    return d;\n}\nfloat charD(vec2 p) {\n    float d = sdBox(p-vec2(-0.025,0.00),vec2(0.045,0.1));\n    float d2 = sdBox(p-vec2(0.02,0.00),vec2(0.05,0.06));\n    d = max(-d2,d);\n    d2 = sdBox(p-vec2(0.04,0.02),vec2(0.02,0.08));\n    d = min(d,d2);\n    return d;\n}\nfloat charE(vec2 p) {\n    float d = sdBox(p,vec2(0.06,0.1));\n    float d2 = sdBox(p-vec2(0.03,0.00),vec2(0.05,0.06));\n    d = max(-d2,d);\n    d2 = sdBox(p,vec2(0.04,0.02));\n    d = min(d,d2);\n    return d;\n}\nvec3 logo(vec2 p, float size, vec3 col, vec3 bcol) {\n    p*=size;\n    mat2  m = mat2(1.0,-0.4,0.0,1.0); // sknew\n    p*=m;\n    \n    float j = charJ(p-vec2(-0.4,0.0));\n    float dt = sdBox(p-vec2(-0.31,0.0),vec2(0.02));\n    float c = charC(p-vec2(-0.2,0.0));\n    float l = charL(p-vec2(-0.05,0.0));\n    float y = charY(p-vec2(0.08,0.0));\n    float d = charD(p-vec2(0.24,0.0));\n    float e = charE(p-vec2(0.39,0.0));\n    \n    float res = min(j,min(dt,min(c,min(l,min(y,min(d,e))))));\n    col = mix(col,bcol,S(res,-0.01));\n    return col;\n}\n\nvec3 pumaClyde(vec2 p, vec3 col) {\n    float n = noise2d(p*20.0+200.0);\n    \n    vec3 wh = vec3(251.0/255.0,251.0/255.0,235.0/255.0);\n    \n    vec3 toeandtongueCol = vec3(n)*0.2;\n    col = shoetongue(p-vec2(-0.05,-0.055),col,toeandtongueCol,wh*0.9);\n    col = toeCap(p-vec2(-0.51,-0.235),col,toeandtongueCol);\n    \n    vec3 shoelaceGuardCol = (vec3(17.0/255.0,74.0/255.0,159.0/255.0)*0.95)-vec3(n)*0.03;\n    vec3 lateralBaseCol = vec3(17.0/255.0,74.0/255.0,159.0/255.0)-vec3(n)*0.03;\n    lateralBaseCol = lateralsideMaterial(p,vec3(17.0/255.0,74.0/255.0,159.0/255.0),wh)-vec3(n)*0.1;\n    vec3 shoelaceHoleCol = vec3(0.0);\n    col = lateralSide(p-vec2(0.19,-0.25),col,lateralBaseCol,shoelaceGuardCol,shoelaceHoleCol);\n    \n    vec3 stripeBaseCol = stripeMaterial(p,vec3(252.0/255.0,120.0/255.0,6.0/255.0));\n    col = stripe(p-vec2(0.0,-0.24),col,stripeBaseCol);\n    \n    vec3 heelBaseCol = vec3(n)*0.2;\n    vec3 heelPatchCol = vec3(252.0/255.0,120.0/255.0,6.0/255.0);\n    col = heelCounter(p-vec2(0.592,-0.07),col,heelBaseCol,heelPatchCol);\n    \n    col = logo((p-vec2(0.2,0.0))*Rot(radians(-22.0)),4.0,col, vec3(1.0,0.843,0.0));\n    \n    vec3 stitchCol = vec3(0.0);\n    vec3 stitchCol2 = vec3(0.0);\n    vec3 stitchCol3 = vec3(0.4);\n    col = stitch(p, col,stitchCol,stitchCol2,stitchCol3);\n    \n    vec3 outBaseCol = wh;\n    col = outsole(p-vec2(0.0,-0.3),col,outBaseCol);\n    \n    vec3 shoelaceCol = vec3(17.0/255.0,74.0/255.0,159.0/255.0)*1.5;\n    col = shoelace(p-vec2(0.0,0.055),col,shoelaceCol);\n    \n    return col;\n}\n\nvec3 background(vec2 p, float t) {\n    float d = -p.y-0.4;\n    vec3 col = mix(vec3(0.7),vec3(0.65),S(d,0.0));\n    \n    vec3 wh = vec3(251.0/255.0,251.0/255.0,235.0/255.0);\n    vec3 mat = lateralsideMaterial(p,vec3(17.0/255.0,74.0/255.0,159.0/255.0),wh)*0.5;\n    float n = fbm(p*(10.0)+20.0)*1.3;\n    d = length((p-vec2(-0.4,0.0))*n)-0.1;\n    col = mix(col,mat,S(d,0.0));\n    n = fbm(p*5.0+10.0)*1.5;\n    d = length((p-vec2(0.5,0.2))*n)-0.1;\n    col = mix(col,mat,S(d,0.0));\n    \n    p.x-=t;\n    p.x = mod(p.x,0.5)-0.25;\n    col = logo(p-vec2(0.0,-0.3),2.2,col, vec3(0.6));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*0.1;\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 pref = p;\n    vec3 col = background(p,t);\n    \n    vec3 logomat = stripeMaterial(p,vec3(252.0/255.0,120.0/255.0,6.0/255.0));\n    col = logo(p-vec2(-0.395,0.395),1.8,col, vec3(0.5));\n    col = logo(p-vec2(-0.4,0.4),1.8,col, logomat);\n    \n    p*=1.2;\n    #if MODE == 2\n    p.x+=t;\n    p.x = mod(p.x,5.4)-2.7;\n\tp.x = abs(p.x);\n    p.x*=-1.0;\n    p.x+=1.8;\n    col = pumaClyde((p-vec2(-0.05,0.1))*Rot(radians(-15.0)),col);\n    p = pref;\n    p*=1.2;\n    p.x+=t;\n    p.x = mod(p.x,5.4)-2.7;\n    col = pumaClyde(p-vec2(0.0,-0.1),col);\n    col = floorShadow(p-vec2(0.0,-0.55),col,0.6);\n    #elif  MODE == 1\n    col = pumaClyde((p-vec2(-0.05,0.1))*Rot(radians(-15.0)),col);\n    #elif  MODE == 0\n    col = pumaClyde(p,col);\n    #endif\n    \n    p = pref;\n    \n    p*=1.2;\n    #if MODE == 2\n    p.x+=t;\n    p.x = mod(p.x,5.4)-2.7;\n    p.x = abs(p.x);\n    p.x*=-1.0;\n    p.x+=1.9;\n    col = floorShadow(p-vec2(-0.55,-0.55),col,0.3);\n    #elif  MODE == 1\n    col = floorShadow(p-vec2(-0.65,-0.55),col,0.3);\n    #elif  MODE == 0\n    col = floorShadow(p-vec2(0.0,-0.55),col,0.6);\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 380, 400, 400, 534], [535, 535, 562, 562, 1065], [1066, 1066, 1085, 1085, 1347], [1349, 1349, 1378, 1378, 1472], [1474, 1525, 1562, 1562, 1642], [1644, 1695, 1750, 1750, 1907], [1909, 1909, 1952, 1952, 2901], [2903, 2903, 2934, 2934, 3344], [3346, 3346, 3395, 3395, 3555], [3557, 3557, 3628, 3628, 4103], [4109, 4109, 4151, 4151, 4422], [4424, 4424, 4455, 4455, 4940], [4942, 4942, 5001, 5001, 5521], [5523, 5523, 5581, 5581, 5932], [5934, 5934, 5962, 5962, 6235], [6237, 6237, 6265, 6265, 6500], [6502, 6502, 6546, 6546, 6845], [6847, 6847, 6873, 6873, 7302], [7304, 7304, 7345, 7345, 7631], [7633, 7633, 7671, 7671, 7814], [7816, 7816, 7882, 7882, 9315], [9317, 9317, 9365, 9365, 9468], [9470, 9470, 9509, 9509, 9917], [9919, 9919, 9974, 9974, 10388], [10390, 10390, 10411, 10411, 10632], [10633, 10633, 10654, 10654, 10786], [10787, 10787, 10808, 10808, 10940], [10941, 10941, 10962, 10962, 11182], [11183, 11183, 11204, 11204, 11425], [11426, 11426, 11447, 11447, 11633], [11634, 11634, 11686, 11686, 12171], [12173, 12173, 12207, 12207, 13696], [13698, 13698, 13732, 13732, 14293], [14295, 14295, 14352, 14352, 15558]], "test": "untested"}
{"id": "wdfcR2", "name": "Twisters in the mist", "author": "Roninkoi", "description": "Classic demo effect. Maybe a bit distorted :)", "tags": ["demo", "twister"], "likes": 5, "viewed": 337, "published": 3, "date": "1585148436", "time_retrieved": "2024-07-30T21:16:46.010486", "image_code": "vec3 col1 = vec3(1.0, 0.4, 0.0);\nvec3 col2 = vec3(0.5, 1.0, 0.0);\nvec3 col3 = vec3(0.0, 0.8, 1.0);\nvec3 col4 = vec3(0.7, 0.0, 1.0);\n\nvec3 sk;\n\nfloat yb(float y0, float y1, float y)\n{\n    //return y0 < y && y1 > y ? min(1.1, smoothstep(y0, y1, y)*1.0 + 0.7) : 0.;\n    float ss = (smoothstep(y1, (y0 + y1)*0.5, y) * smoothstep(y0, (y0 + y1) * 0.5, y))*0.5;\n    return y0 < y && y1 > y ? min(1.1, sqrt(sqrt(sqrt(ss)))*1.2 + ss) : 0.;\n}\n\nfloat st(float y0, float a, float d, float y)\n{\n    return yb(y0 + sin(a) * d - cos(a) * d, \n              y0 + sin(a) * d + cos(a) * d, y);\n}\n\nvec3 twister(vec3 color, float y0, float a, float d, float y, float z)\n{\n    float f = min(1., exp(-z * 0.00065));\n    \n    vec3 col = mix(color, col1, st(y0, a, d, y));\n    \n    a += 1.570;\n    col = mix(col, col2, st(y0, a, d, y));\n    \n    a += 1.570;\n    col = mix(col, col3, st(y0, a, d, y));\n    \n    a += 1.570;\n    col = mix(col, col4, st(y0, a, d, y));\n    \n    return sk * (1. - f) + col * f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= 0.5;\n    \n    float sy = sin(uv.y+1.57);\n    sk = vec3(sy*sy * 0.3 + (1. - sy) * 0.9, sy*sy*0.7, sy*1.5);\n    vec3 col = sk;\n    \n    float s = iTime * 5.;\n    \n    for (int i = 40 + int(s); i >= int(s); --i) {\n        float ri = float(i);\n        \n    \tfloat a = sin(iTime * (cos(ri) + 1.1));\n    \tfloat ax = uv.y * 7. * sin(iTime * cos(ri));\n        \n        float z = (ri - s) * 10.;\n        \n        if (z < 0.)\n            continue;\n        \n        float x = ((cos(ri * 0.87) + sin(ri * 0.87)) * 45.7);\n        \n        if (x < 10. && x > 0.)\n            x += 12.;\n        \n        if (x > -10. && x < 0.)\n            x -= 12.;\n            \n    \tcol = twister(col, x / z, a + ax + cos(ri), 3. / max(abs(z), 1.), uv.x, z);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 182, 262, 432], [434, 434, 481, 481, 576], [578, 578, 650, 650, 982], [984, 984, 1039, 1039, 1864]], "test": "untested"}
{"id": "wdfcz2", "name": "countach sdf", "author": "flockaroo", "description": "legendary lamborghini countach. ...with all best wishes to italy!\nvery rudimentary shading now ...thought i'd post it before windows compile times explode (and debug-colors are not completely without charm now and then...)", "tags": ["sdf", "car", "lamborghini", "countach"], "likes": 27, "viewed": 777, "published": 3, "date": "1585147415", "time_retrieved": "2024-07-30T21:16:47.055692", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// lamborghini countach\n\n// new/old model of countach (basically just the tires differ for now)\n//#define NEW_MODEL\n//#define WIREFRAME\n//#define CUBEMAP\n\n#define RandTex iChannel0\n\n#define Res (iResolution.xy)\n\n#define iMouseData vec4(0)\n\nconst vec3 BodySize=vec3(1.8,4.14,1.0);\n\n////////////////////////\n//// quaternions, sdf's, helper funcs\n////////////////////////\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang,vec3 v) { return vec3(ROTM(ang)*v.xy,v.z); }\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    //p.z+=cos(ang*100.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.122*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n\n    float d=1000.;\n    float dmain=distCyl(p,r+sh-.005,w-.005)-.005;\n    d=min(d,dmain);\n\n    //d=max(d,-(distCyl(p-vec3(0,0,w*.5),r-sh*.5-.005,w*.05-.005)-.005));\n    float d2=length(p-vec3(0,0,+w*.03+r*1.5))-r*1.5;\n    d2=-smin_(-d2,-(distCyl(p-vec3(0,0,w*.5),r-sh*1.2-.005,w*1.-.005)-.005),.005);\n    d=-smin(-d,d2,.01);\n\n    float mang,ang;\n    float ang0 = atan(p.y,p.x);\n    float dang;\n#ifdef NEW_MODEL\n    dang=PI2/5.;\n#else\n    dang=PI2/15.;\n#endif\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    // rim holes\n#ifdef NEW_MODEL\n    d=max(d,-distCyl(p-vec3(r*.53*cos(ang-vec2(0,PIH)),0.),.17*r,w*1.3));\n#else\n    d=max(d,-distBox(rotZ(-ang,p-vec3(r*.64*cos(ang-vec2(0,PIH)),0.)),vec3(.17*r,.17*r,w*1.3)*.52));\n#endif\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    // screw holes\n    d2=distCyl(p-vec3(r*.28*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    d=max(d,-d2);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.03-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel1,dir.yzx);\n#endif\n    vec3 sun = normalize(vec3(1,1,1));\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\nfloat distCar(vec3 p)\n{\n    vec3 p1,p2;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    // torus\n    float d=10000.,d2;\n    p=p0-vec3(-p.y*.01,0,0);\n    vec3 p01=p;\n    float yfall=min((p.y+0.0)*abs(p.y+0.0),0.);\n    float yfall2=(p.y>.0?2.5:7.)*min((-abs(p.y)+1.2)*abs(-abs(p.y)+1.2),0.);\n    yfall=mix(yfall,yfall2,step(0.,-p.z));\n    //yfall=0.;\n    // ----------- 1 ------------------ side phase\n    d2=dot(p-.51*BodySize*vec3(.5,0,1.+.15*yfall)-(.2+.2*p.y)*max(0.,p.x-.92+p.y*.03)*vec3(0,0,1),normalize(vec3(.8,0,1.-.9*yfall)));\n    d=min(d,d2);\n    \n    // ----------- 3 ------------------\n    vec3 n=normalize(vec3(0,1,2.5));\n    float dpx=max(p.x*1.-1.,-.5);\n    float dpy=max(p.y-.78+.65*dpx,0.);\n    p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*(1.-exp(-dpy/.2)-dpy*.8);\n    //vec3 p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*min(1.-dpy*.2,1.);\n    // ----------- 2 ------------------ front cut\n    d2=dot(p2-.5*BodySize*vec3(0,1,1)-vec3(0,0,-.75),normalize(vec3(0,1,2.5)));\n    d=-smin_(-d,-d2,.06*exp(-(p.y-1.1)*(p.y-1.1)*3.));\n    //d=-smin(-d,-d2,.13*clamp(1.-(p.y-1.)*(p.y-1.)*1.2,0.,1.));\n    //d=-min(-d,-d2);\n    \n    // -------------------------------- main box ---- done after cuts to get sharp contour line on sides (no smin there)\n    d2=distBoxR(p+vec3(min(+.35*p.z*p.z,.1),0,0),\n                vec3(BodySize.xz,100).xzy*.5*vec3(exp(-(step(0.,p.y)*2.+2.)*p.y*p.y*p.y*p.y/500.),1,1.+.15*yfall),\n                max(.02,-1.*p.z-.07*p.y));\n    d=max(d,d2);\n    \n    // ----------- 4 ------------------ engine cover\n    p-=vec3(0,-1.65,.48);\n    vec3 bs=vec3(BodySize.x*.25*1.1-p.y*.17+p.z*.4,1,.3);\n    d2=distBoxR(p+vec3(0,0,-p.y*.14),bs,.02);\n    d=max(d,-d2);\n    float pry=clamp(floor(p.y/.22+.5),1.,4.)*.22;\n    d2=distBoxR(p+vec3(0,-pry,.01-p.y*.14),bs-vec3(.06,.92,0),.02);\n    d=max(d,-d2);\n\n    d2=abs(p0.y)-BodySize.y*.5;\n    d2+=.005*exp(-(length(vec2(max(d+.03,0.),d2)))/.0025);\n    d=-smin_(-d,-d2,.01);\n    \n    d2=distBox(p01-vec3(0,-1.1,.3),vec3(.47,.5,.5));\n    d+=.004*exp(-abs(d2)/.004);\n\n    // ------------------------------- side air hole\n    p=p0-vec3(.9,-.35,.04);\n    float sn=(.6-.4*sin(p.y*6.));\n    d2=distBox(p,vec3(.2*sn,.5,.23*sn)*.5-.02)-.02;\n    d=max(d,-d2);\n\n    // ------------------------------- upper air hole\n    p=p01-vec3(.67,-.627,.35);\n    d2=distBoxR(p,vec3(.32,.45,.25)*.5,.02-p.y*.15);\n    //d=max(d,-d2);\n    float d3=dot(p,normalize(vec3(.58,-.5,1.)));\n    float lw=.028+p.x*.028;\n    d3=(fract(d3/lw)-.5)*lw;\n    d3=abs(d3)-lw*.3;\n    d3=max(d2,-d3);\n    //d2=max(d2,-d3);\n    d3=max(d3,(d+.01-p.y*.045));\n    d=max(d,-d2);\n    d=min(d,d3);\n\n    // make hollow (6cm thick)\n    //d=abs(d+.03)-.03;\n    \n    // ------------------------------ door\n    //   --- front win border\n    d2=dot(p01-vec3(.475,.19,0),normalize(vec3(2.,-1,0)));\n    //   --- inner border\n    d2=min(d2, dot(p01-vec3(.475,.19,0),normalize(vec3(1,0,0))) );\n    d3 = d2;\n    p=p01-vec3(.475,-.4,0);\n    float s=step(0.,-(p0.z-.2))*((p0.z-.2)*(p0.z-.2)-.25*(p0.z-.2));\n    p.y=p.y-s;\n    //   --- front door border\n    float dr=dot(p,normalize(vec3(0,1,0)));\n    d2=min(d2, dr );\n    p.y=p.y+2.*s-1.35;\n    float d4=10000.;\n    //   --- rear door border\n    d4=min(d4, dot(p,normalize(vec3(0,-1,0))) );\n    //   --- floor door border\n    d4=min( d4, dot(p01-vec3(0,0,-.22),normalize(vec3(0,0,1))) );\n    //d+=.005*exp2(-length(vec2(d2-.0,d))/.0025);\n    d2=min(d2,d4);\n    d+=.003*exp2(-abs(d2)/.003);\n    \n    // ------------------------------ side window\n    d4=min(d4, dot(p01-vec3(.87,0,0),normalize(vec3(-1,0,0))) );\n    d2=min(d2,d4);\n    d3-=.22;\n    //d3=min(d3,min(d4,dr)-.04);\n    //d3-=.22;\n    d+=.005*exp2(-length(vec2(min(d2-.04,0.),d))/.0025);\n    if(d3<min(d4,dr)-.04)\n    //d+=.003*exp2(-d3*d3/.003/.003);\n    d=min(d,length(vec2(d3,d))-.003);\n\n    // ------------------------------- front lights\n    p=p0-vec3(.65,1.6,0);\n    d2=distBox(p,vec3(.32-step(0.,p.x)*.25*p.y,.16,.2)*.5);\n    //d=max(d,-sqrt(d*d+d2*d2)+.005);\n    d+=.003*exp(-abs(d2)/.003);\n    p=p0-vec3(.63,1.85,0);\n    d2=distBox(p,vec3(.29-step(0.,p.x)*.45*p.y,.16,.34)*.5);\n    d=max(d,-d2);\n\n    // ------------------------------ wheels\n    p1=BodySize*.5*vec3(1, .59,-.65);\n    p2=BodySize*.5*vec3(1,-.63,-.65);\n    d=max(d,-distCylR((p0-p1).yzx,.35,.85,.05));\n    //d=max(d,-distCylR((p0-p2).yzx,.35,.8,.05));\n    d=max(d,-distBoxR(rotZ(0.4,(p0-p2).yzx),vec3(.37,.28,.45)+.015,.2-(p0-p2).y*.2));\n    //d=min(d,distCylR((p0-p1-vec3(-.18,0,.04)).yzx,.31,.27,.08));\n    //d=min(d,distCylR((p0-p2-vec3(-.145,0,.04)).yzx,.31,.27,.08));\n    //return distWheelDim(pos,345.,35.,15.,10.,2.7);\n\n    //d=min(d,distWheelDim((p0-p2-vec3(-.13,0,.04)).yzx,215.,70.,14.,20.,1.));\n    //d=min(d,distWheelDim((p0-p1-vec3(-.16,0,.04)).yzx,205.,70.,14.,20.,1.));\n\n#ifndef NEW_MODEL    \n    float wheelDimRear [] = float[](215.,70.,14.,15.,1.);\n    float wheelDimFront[] = float[](205.,70.,14.,15.,1.);\n    vec3 pfront = p1+vec3(-.16,0,.04);\n    vec3 prear  = p2+vec3(-.13,0,.04);\n#else\n    float wheelDimRear [] = float[](345.,35.,15.,12.,2.7);\n    float wheelDimFront[] = float[](205.,50.,15.,12.,1.);\n    vec3 pfront = p1+vec3(-.15,0,.04);\n    vec3 prear  = p2+vec3(-.19,0,.04);\n#endif\n    \n    bool front = p0.y>0.;\n    p=p0-(front?pfront:prear);\n    d=min(d,\n        distWheelDim(p.yzx,\n                     front?wheelDimFront[0]:wheelDimRear[0],\n                     front?wheelDimFront[1]:wheelDimRear[1],\n                     front?wheelDimFront[2]:wheelDimRear[2],\n                     front?wheelDimFront[3]:wheelDimRear[3],\n                     front?wheelDimFront[4]:wheelDimRear[4])\n         );\n         \n    //d=min(d,distWheelDim((p0-p2-vec3(-.19,0,.04)).yzx,345.,35.,15.,10.,2.7));\n    //d=min(d,distWheelDim((p0-p1-vec3(-.15,0,.04)).yzx,205.,50.,15.,10.,1.));\n    //d=max(d,-(length(p0-p1*vec3(1,-1,1))-.37));\n    \n    //p=p0-vec3(p.y*.02,0,0);\n    \n    /*d=min(d,length(p0.xy-floor(p0.xy+.5))-.01);\n    d=min(d,length(p0.yz-floor(p0.yz+.5))-.01);\n    d=min(d,length(p0.zx-floor(p0.zx+.5))-.01);*/\n    \n    //d2=length(vec2(length(p.xy)-2.5,p.z))-.01;\n    //d=min(d,d2);\n    return d;\n}\n\nbool carEnabled;\n\nfloat dist(vec3 p)\n{\n    float d=10000.;\n    \n    // ----------------------------- car\n    if(carEnabled)\n        d=min(d,distCar(p));\n    \n    // ----------------------------- floor\n    d=min(d,(p.z+.6));\n\n    return d;  \n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if (d<eps) return 1.;\n    }\n    return 0.;\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(0,0,-1.5)+vec3(sc,0));\n    pos=vec3(0,0,4.5*exp(-iMouseData.z/3000.));\n    float ph = iMouse.x/Res.x*10.;\n    float th = iMouse.y/Res.y*10.;\n    if (iMouse.x<1.) { ph=-iTime*.3; th=1.3; }\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n}\n\nfloat fermi(float x) { return 1./(1.+exp(-x)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    carEnabled=intersectBox(pos-vec3(0,0,-.05),dir,BodySize+vec3(0,0,.1));\n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    carEnabled=true;\n    vec3 left=normalize(cross(vec3(0,0,1),dir));\n    vec3 up  =normalize(cross(left,dir));\n    vec3 g=getGrad(pos,.003);\n    #ifdef WIREFRAME\n    vec3 gl=getGrad(pos-dir*.00+left*.004,.003);\n    vec3 gu=getGrad(pos-dir*.00+up*.004,.003);\n    #endif\n    float lg=length(g);\n    vec3 n=g/(lg+.000001);\n    float ao=1., ao2;\n    float p=.5;\n    float fp=exp2(p*1.5);\n    for(int i=0;i<10;i++)\n    {\n        float f=1.*exp2(-float(i)*p);\n        ao2=clamp(dist(pos+n*f)/dist(pos+n*f*fp)*fp,0.,1.);\n        //ao=min(ao,ao2);\n        //ao+=ao2;\n        ao*=ao2/**.7+.3*/;\n    }\n    //ao=exp2(ao);\n    fragColor.xyz=n*.3+.5;\n    //fragColor.xyz=vec3(0);\n    vec3 R=reflect(dir,n);\n    vec4 refl=myenv(vec3(0),R,1.);\n    float fres=1.-abs(dot(R,n));\n    fres*=fres*fres;\n    fres=.1+.7*fres;\n    // not the proper way to multipy refl with ao, but looked strange with strong reflections even in wheelcase\n    fragColor=mix(fragColor,refl*(ao*.35+.65),fres);\n    //fragColor.xyz=vec3(.9);\n    fragColor.xyz*=ao*.3+.7;\n    float d=length(pos-pos0);\n    fragColor=mix(fragColor,myenv(vec3(0),dir,1.),1.-exp(-d/100.));\n\n    #ifdef WIREFRAME    \n    //fragColor.y+=.5*dot(fwidth(g),fwidth(g));\n    fragColor.y+=length(gl+gu-g-g)*.25;\n    float tile=.2;\n    vec3 frp=sin(pos/tile*PI2*.5);\n    vec3 w3=fwidth(frp)*.5;\n    vec3 w2=w3*w3;\n    fragColor.y+=clamp(1.5-.15*length(pos),0.,1.)*.25*(exp(-frp.x*frp.x/w2.x)+exp(-frp.y*frp.y/w2.y)+exp(-frp.z*frp.z/w2.z));\n    #endif\n    \n    fragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfcz2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[653, 653, 682, 682, 717], [719, 719, 752, 820, 978], [980, 980, 1006, 1091, 1122], [1124, 1124, 1155, 1155, 1246], [1248, 1248, 1291, 1291, 1359], [1361, 1361, 1389, 1389, 1490], [1492, 1492, 1529, 1529, 1604], [1606, 1629, 1668, 1668, 1766], [1768, 1768, 1817, 1817, 1857], [1859, 1859, 1902, 1902, 2009], [2011, 2011, 2064, 2064, 2181], [2183, 2183, 2226, 2226, 2278], [2280, 2316, 2357, 2357, 2443], [2445, 2480, 2522, 2522, 2615], [2617, 2667, 2734, 2734, 3375], [3377, 3377, 3461, 3461, 4524], [4526, 4526, 4632, 4632, 4932], [4935, 4935, 4983, 4983, 5366], [5368, 5368, 5394, 5394, 5630], [5716, 5762, 5809, 5809, 6710], [12806, 12806, 12826, 12826, 13030], [13032, 13032, 13066, 13066, 13190], [13192, 13192, 13231, 13231, 13386], [13388, 13388, 13444, 13444, 13803], [13805, 13805, 13827, 13827, 13853], [13855, 13855, 13912, 13912, 15591]], "test": "untested"}
{"id": "tsXcR2", "name": "PetriDiffusion", "author": "etch4sketch", "description": "reaction diffusion adapted from https://forum.processing.org/two/discussion/22385/reaction-diffusion-using-glsl-works-different-from-normal", "tags": ["diffusion"], "likes": 4, "viewed": 376, "published": 3, "date": "1585138592", "time_retrieved": "2024-07-30T21:16:47.894449", "image_code": "\nfloat circle(in vec2 _uv, in float _aspect){\n    float dist = length(vec2(_uv.x * _aspect, _uv.y) - vec2(0.5 * _aspect, 0.5));\n\treturn dist;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    //get the pixel value for thisVal from buffer\n    vec2 conc = texture(iChannel0, uv).xy;\n    \n    vec3 white = vec3(1.0);\n\n    vec3 whiteness = conc.x * white;\n    vec3 blackness = conc.y * white;\n    \n    vec3 color = whiteness - blackness;\n    \n    color.x += 0.125;\n    \n    \n    float circ = smoothstep(0.675, 0.695, 1.0 - circle(uv, aspect));\n    \n    float circ2 = smoothstep(0.69, 0.695, 1.0 - circle(uv, aspect)) - smoothstep(0.70, 0.7050, 1.0 - circle(uv, aspect));\n      \n    float circ3 = smoothstep(1.0 - 0.68,1.0 - 0.67,circle(uv, aspect));\n        \n    \n    color *= circ;\n    color -= 0.2 * circ2;\n    \n    color += circ3;   \n    \n    \n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//laplacian filter\nvec2 laplacian(in vec2 uv)\n{\n    \n    vec2 AB = (texture(iChannel0, uv)).xy ;\n    vec2 pixel = vec2(0.001);\n    vec2 laplace = -1.0 * AB;\n    \n    //slight noise added to the filter sides\n    float sideWeight = 0.2;// * (0.98 + random(uv ) / 25.0 );\n    float cornerWeight = 0.05;\n    \n    laplace += texture(iChannel0, uv + pixel * vec2(0, -1)).xy * cornerWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(-1, 0)).xy * cornerWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(1, 0)).xy * cornerWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(0, 1)).xy * cornerWeight;\n    \n    \n    laplace += texture(iChannel0, uv + pixel * vec2(-1, -1)).xy * sideWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(1, -1)).xy * sideWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(-1, 1)).xy * sideWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(1, 1)).xy * sideWeight;\n    \n    return laplace;\n    \n}\n\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float DA = 1.0;\n    float DB = 0.5;\n    float feed = 0.03;\n    float kill = 0.062;\n    float dt = 1.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n       \n    float A = texture(iChannel0, uv).x ;\n    float B = texture(iChannel0, uv).y ;  \n    vec2 laplaceAB = laplacian(uv);\n    float laplaceA = laplaceAB.x;\n    float laplaceB = laplaceAB.y;\n    \n    \n    float jitter = (random(uv * iTime) - 0.5) * 0.05 ;\n    \n    //kill *= 0.5 + random(uv);\n        \n    float nA = A + ((DA*laplaceA) - (A*B)*B + (feed*(1.0 - A)))*dt + jitter ;\n    float nB = B + ((DB*laplaceB) + (A*B)*B - ((kill + feed)*B))*dt;\n    \n    \n    //need to seed the pixels on first frame\n    if(iFrame > 2) fragColor = vec4(clamp(nA, 0.0, 1.0), clamp(nB, 0.0, 1.0), 0.0, 1.0);\n    else {\n        \n        float rand = noise(uv * 100.0);\n        \n        float binary = step(0.04, rand);\n        \n        fragColor = vec4(vec3(0.5 + binary/2.0, 0.5 - binary/2.0, 0.0), 1.0);\n        //if(random(uv) > 0.05) fragColor = vec4(vec3(1.0, 0.0, 0.0), 1.0);\n        //else fragColor = vec4(vec3(0.5, 0.5, 0.0), 1.0);   \n        \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 45, 45, 143], [147, 147, 203, 203, 1075]], "test": "untested"}
{"id": "tsfyRj", "name": "Schwarz-Christoffel Mapping", "author": "mla", "description": "Herbert Müller's method for inverse Schwarz-Christoffel mapping for regular polygons.\n\n[url]http://herbert-mueller.info/uploads/3/5/2/3/35235984/circletopolygon.pdf[/url]\n\nMouse moves inversion point.\n", "tags": ["mapping", "conformal", "schwarzchristoffel"], "likes": 22, "viewed": 760, "published": 3, "date": "1585134465", "time_retrieved": "2024-07-30T21:16:48.847900", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Herbert Müller's method for inverse Schwarz-Christoffel mapping for\n// regular polygons.\n//\n// Matthew Arcus, 2020.\n//\n// The Schwarz-Christoffel mapping:\n//\n// https://en.wikipedia.org/wiki/Schwarz%E2%80%93Christoffel_mapping\n//\n// maps the unit circle (or half-plane) to any polygon in the complex plane.\n// Here we construct the inverse mapping for a regular polygon using a\n// method due to Herbert Müller:\n//\n// http://herbert-mueller.info/uploads/3/5/2/3/35235984/circletopolygon.pdf\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\n\nvec2 expi(float x) {\n  return normalize(vec2(cos(x),sin(x)));\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,\n              z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return z*vec2(1,-1)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\n// The Lanczos approximation, should only be good for z >= 0.5,\n// but we get the right answers anyway.\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993; // Unnecessary precision\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\n// Original Octave/Matlab code for main function:\n// w=z(inZ).*( 1-cn(1)*h+(-cn(2)+(K+1)*cn(1)^2)*h.^2+\n// (-cn(3)+(3*K+2)*(cn(1)*cn(2)-(K+1)/2*cn(1)^3))*h.^3+\n// (-cn(4)+(2*K+1)*(2*cn(1)*cn(3)+cn(2)^2-(4*K+3)*(cn(1)^2*cn(2)-(K+1)/3*cn(1)^4)))*h.^4+\n// (-cn(5)+(5*K+2)*(cn(1)*cn(4)+cn(2)*cn(3)+(5*K+3)*(-.5*cn(1)^2*cn(3)-.5*cn(1)*cn(2)^2+\n//   (5*K+4)*(cn(1)^3*cn(2)/6-(K+1)*cn(1)^5/24))))*h.^5./(1+h/C^K) );\n\nvec2 inversesc(vec2 z, int K) {\n  \n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K); // Series Coefficients\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K); // Scale factor\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  // Pixel specific code starts here\n  z *= C; // Scale polygon to have diameter 1\n  vec2 h = cpow(z,int(K));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 rotate(vec2 p, in float t) {\n  return cmul(expi(t),p);\n}\n\nvec2 map(vec2 screenpos) {\n  float scale = 1.0;\n  vec2 p = (2.0*screenpos.xy-iResolution.xy)/iResolution.y;\n  p *= scale;\n  p = p.yx;\n  return p;\n}\n\nvec3 getcolor(vec2 z, int K) {\n  if (iMouse.x > 0.0) {\n    vec2 c = map(iMouse.xy);\n    float t = (1.0-dot(c,c))/dot(z-c,z-c);\n    z = t*z-(1.0+t)*c;\n    z /= dot(z,z); // Keeps chirality\n  }\n  // And a rotation (also a Mobius transformation)\n  z = rotate(z,0.5*iTime);\n\n  float r = length(z);\n  float px = 0.5*fwidth(z.x);\n  float theta = atan(z.y,z.x);\n  vec3 col = hsv2rgb(theta/(2.0*PI),1.0,1.0);\n  float A = 4.0;\n  float B = 2.0*float(K);\n  float a = -log(r)*A;\n  float ds = 0.07;\n  if (a <= 6.0+ds) {\n    a = fract(a);\n    float b = fract(theta/PI*B);\n    float d = min(min(a,1.0-a),min(b,1.0-b));\n    col *= mix(0.2,1.0,smoothstep(-ds-px,ds+px,d));\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = map(fragCoord.xy);\n  vec3 col = vec3(0.5);\n  int K = (3+int(0.2*iTime)%7);\n  // Check if point in polygon\n  bool inpoly = true;\n  {\n    float theta = PI/float(K);\n    vec2 n = vec2(cos(theta),sin(theta));\n    for (int i = 0; i < K; i++) {\n      vec2 w = rotate(z,2.0*float(i)*theta);\n      w.x -= 1.0;\n      if (dot(w,n) > 0.0) inpoly = false;\n    }\n  }\n  bool incircle = length(z) < 1.0;\n  z = inversesc(z,K);\n  col = getcolor(z,K);\n  if (!incircle) col *= 0.75;\n  if (!inpoly) col *= 0.75;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 722, 722, 861], [863, 863, 895, 895, 1000], [1003, 1003, 1023, 1023, 1066], [1068, 1068, 1095, 1095, 1160], [1162, 1162, 1181, 1181, 1215], [1217, 1217, 1244, 1244, 1272], [1877, 1898, 1925, 1925, 1968], [2380, 2380, 2411, 2411, 3430], [3432, 3432, 3473, 3473, 3649], [3651, 3651, 3684, 3684, 3712], [3714, 3714, 3740, 3740, 3861], [3863, 3863, 3893, 3893, 4538], [4540, 4540, 4597, 4597, 5129]], "test": "untested"}
{"id": "3dfcz2", "name": "French Kif", "author": "haptix", "description": "Thanks to evvvvil_ and alkama", "tags": ["raymarching", "kif"], "likes": 2, "viewed": 378, "published": 3, "date": "1585128214", "time_retrieved": "2024-07-30T21:16:49.873159", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot(float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 hexPris(vec3 p, vec2 h, float matId)\n{\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n    p = abs(p);\n    p.xy -= 2.*min(dot(k.xy, p.xy), 0.)*k.xy;\n    vec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x), p.z - h.y);\n    return vec2(min(max(d.x,d.y), 0.) + length(max(d, 0.)), matId);\n}\n\nvec3 kif(vec3 p)\n{\n    for(int i = 0; i < 6; i++)\n    {\n        p = abs(p) - vec3(.05*cos((iTime + 76.)*.21) + .31,\n                          -.05*sin((iTime + 287.)*.23) + .35,\n                          .05*sin((iTime + 150.)*.25) + .37);\n        p.xz *= rot(.031*(iTime + 483.));\n        p.zy *= rot(.043*(iTime + 985.));\n        p.xy *= rot(.053*(iTime + 115.));\n    }\n    \n    return p;\n}\n\nvec2 map(vec3 p)\n{   \n    p = kif(p);\n    \n    float len = 20.;\n    p.z -= len/2.;\n    vec2 m1 = hexPris(p, vec2(.025, len), 1.);\n    p.x -= .03;\n    vec2 m2 = hexPris(p, vec2(.01, len), 2.);\n    vec2 m = m1.x < m2.x ? m1 : m2;\n    glo += .1 / (.1 + m.x*m.x*m.x*2500.);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 40.;\n\tvec2 h,t= vec2(.001);\n\tfor(int i = 0; i < 384; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .00001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(1.5*cos(-.2*iTime),\n                   1.5*sin(-.2*iTime),\n                   -3.5);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(.5, 1.5, -15.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(sin(.317*(iTime + 44.)),\n                       sin(.151*(iTime + 55.)),\n                       sin(.227*(iTime + 79.))) + 1.25;\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 85.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n\n        vec3 col = .23 * colRot;\n        col *= .1 * ao;\n        col += .5 * diff * colRot.yzx;\n        col += .8 * spec * vec3(1., 1., 1.);\n        \n        col += glo*.008*colRot;\n        \n        if(t.y == 2.)\n            col = col.zxy;\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*.008*colRot.zyx, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 60, 60, 120], [122, 122, 165, 165, 445], [447, 447, 465, 465, 839], [841, 841, 859, 859, 1126], [1128, 1128, 1155, 1155, 1385], [1387, 1387, 1444, 1444, 3018]], "test": "untested"}
{"id": "tsfcRj", "name": "Tux is Worried", "author": "dr2", "description": "Even penguins get the blues", "tags": ["amiga", "droste", "penguin", "pc", "recurrence"], "likes": 15, "viewed": 388, "published": 3, "date": "1585127401", "time_retrieved": "2024-07-30T21:16:51.035053", "image_code": "// \"Tux is Worried\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n The Amiga - probably the best PC of its era (and absolutely virus-free);\n Tux would have loved it.\n (Based on \"Amiga Recursion\")\n*/\n\n#define AA  0   // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvoid PxInit ();\nvoid PxBgn (vec2 p);\nfloat PxText (vec2 p, int txt);\nfloat PxChar (vec2 p, vec4 c);\n\nmat3 vuMat;\nvec3 ltDir, pPos;\nvec2 sSize, cSpace;\nfloat dstFar, tCur, sMidHt, fAng, szFac, pRot;\nint idObj, nRec;\nconst int nRecMax = 5;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat TuxDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dh;\n  p /= szFac;\n  dMin /= szFac;\n  q = p;\n  d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n  q.y -= 1.5;\n  dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n  DMIN (11);\n  q = p;\n  q.yz -= vec2 (1.6, -0.6);\n  d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n  DMIN (12);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = PrSphDf (q, 0.15);\n  DMIN (13);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.6, -1.05);\n  q.yz = Rot2D (q.yz, -0.5 * pi);\n  q.y -= -0.6;\n  d = PrCylDf (q.xzy, 0.12, 0.7);\n  DMIN (14);\n  q -= vec3 (0.1, -0.67, -0.4);\n  q.xz = Rot2D (q.xz, -0.07 * pi);\n  d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, -0.3 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  DMIN (15);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.3, -0.2);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n  d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n  DMIN (16);\n  return dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.35;\n  d = PrRoundBoxDf (q, vec3 (1., 0.16, 0.7), 0.01);\n  q = p - vec3 (0.7, 0.4, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.17, 0.01, 0.2)));\n  q.y -= -0.02;\n  d = max (d, - PrBoxDf (q, vec3 (0.08, 0.08, 0.03)));\n  q.y -= 0.01;\n  d = max (d, - PrBoxDf (q, vec3 (0.045, 0.05, 0.05)));\n  q = p;\n  q.yz -= vec2 (0.3, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (1.1, 0.01, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 0.4;\n  q.yz -= vec2 (0.35, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.01, 0.17, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 1.;\n  q.yz -= vec2 (0.35, 0.05);\n  d = max (d, - PrBoxDf (q, vec3 (0.02, 0.007, 0.7)));\n  DMIN (1);\n  q = p;\n  q.x = abs (q.x) - 0.95;\n  q.y -= 0.09;\n  q.x -= 0.02 * q.y;\n  d = PrRoundBoxDf (q, vec3 (0.025 + 0.02 * q.y, 0.09, 0.6), 0.005);\n  q = p;\n  q -= vec3 (-0.05, 0.09, 0.3);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.9, 0.09, 0.02), 0.005));\n  DMIN (2);\n  q = p;\n  q.yz -= vec2 (0.55, 0.05);\n  q.xz = abs (q.xz) - vec2 (0.55, 0.4);\n  d = PrCylDf (q.xzy, 0.05, 0.05);\n  DMIN (3);\n  q = p;\n  q.yz -= vec2 (0.71 + sSize.y, -0.45);\n  d = 0.9 * max (PrRoundBoxDf (q, vec3 (sSize.x + 0.16, sSize.y + 0.12, 0.13), 0.03),\n     - PrRoundBox2Df (q.xy, sSize + 0.01, 0.03));\n  DMIN (4);\n  q = p - vec3 (0.7, 0.4, -0.55);\n  d = PrBoxDf (q, vec3 (0.16, 0.008, 0.16));\n  DMIN (5);\n  q = p;\n  h = sSize.y + 0.05 - 0.1 * (q.z - 0.05);\n  q.yz -= vec2 (0.6 + h, 0.05);\n  d = 0.9 * PrRoundBoxDf (q, vec3 (sSize.x + 0.12, h, 0.6), 0.03);\n  DMIN (6);\n  q = p - pPos;\n  q.xz = Rot2D (q.xz, pRot);\n  dMin = TuxDf (q, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nfloat ChqPat (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  if (2. * floor (ip.y / 2.) != ip.y) p.x += 0.5;\n  p = smoothstep (0., 0.1, abs (fract (p + 0.5) - 0.5));\n  return 0.98 + 0.02 * p.x * p.y;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 q;\n  float d;\n  if (rd.y >= 0.) col = vec3 (0.2, 0.3, 0.6) + 0.2 * pow (1. - rd.y, 5.);\n  else {\n    d = - ro.y / rd.y;\n    q = ro.xz + d * rd.xz;\n    col = mix (ChqPat (2. * q) * vec3 (0.8, 0.8, 0.9) * (0.8 + 0.2 * Fbm2 (128. * q)),\n       vec3 (0.4, 0.5, 0.8), 1. - min (1., exp2 (2. - 8. * d / dstFar)));\n    col *= 0.9 + 0.1 * smoothstep (0.25, 0.4, length (q - pPos.xz));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro)\n{\n  vec4 col4;\n  vec3 col, rd, roh, vn, q;\n  vec2 sb;\n  float dstObj, ao;\n  bool isBg, isScrn;\n  isBg = false;\n  isScrn = true;\n  for (int k = VAR_ZERO; k <= nRecMax; k ++) {\n    rd = normalize (vec3 (ro.xy, 7.));\n    if (k == 0) ro.xy = vec2 (0.);\n    ro.z -= 20. * sSize.y;\n    rd = vuMat * rd;\n    ro = vuMat * ro;\n    ro.y += sMidHt;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj >= dstFar) isBg = true;\n    else {\n      ro += dstObj * rd;\n      roh = ro;\n      if (idObj != 6) isScrn = false;\n      else {\n        ro.y -= sMidHt;\n        sb = abs (ro.xy) - sSize;\n        isScrn = (max (sb.x, sb.y) < 0. && ro.z < -0.5 && k < nRec);\n      } \n    }\n    if (! isScrn || isBg || k == nRec) break;\n  }\n  if (isBg) {\n    col = BgCol (ro, rd);\n    if (rd.y < 0.) {\n      roh = ro - (ro.y / rd.y) * rd;\n      if (length (roh.xz) < 2.) col *= ObjAO (roh, vec3 (0., 1., 0.));\n    }\n  } else {\n    col4 = vec4 (0.8, 0.81, 0.79, 0.);\n    PxInit ();\n    if (idObj < 11) {\n      if (idObj == 1) {\n        if (ro.z < -0.65) {\n          col4.rgb *= 1.2;\n          sb = ro.xy - vec2 (-0.82, 0.42);\n          sb.x -= 0.2 * sb.y;\n          if (PxText (sb * 260., 1) > 0.) col4 = vec4 (0.1);\n          else if (PxText ((ro.xy - vec2 (-0.75, 0.21)) * 240., 2) > 0.)\n             col4 = vec4 (0.1, 0.1, 0.8, 0.3);\n          else if (abs (abs (ro.x) - 0.9) < 0.02 && abs (ro.y - 0.3) < 0.008)\n             col4 = (ro.x < 0.) ? vec4 (0., 1., 0., -1.) : ((mod (0.33 * tCur, 1.) < 0.3) ?\n             vec4 (1., 0., 0., -1.) : vec4 (0.4, 0.4, 0.4, 0.1));\n        }\n      } else if (idObj == 2) {\n        col4 *= 0.9;\n      } else if (idObj == 3) {\n        col4.rgb = vec3 (0.4, 0.3, 0.1);\n      } else if (idObj == 4) {\n        if (ro.z < -0.45) col4 *= 1.2;\n        if (ro.z < -0.6 && abs (ro.x) < sSize.x + 0.15 &&\n           abs (ro.y - sMidHt) < sSize.y + 0.11) col4 *= 0.8;\n      } else if (idObj == 5) {\n        col4.rgb = vec3 (0.1);\n      } else if (idObj == 6) {\n        if (length (ro.yz - vec2 (-0.4, -0.05)) < 0.15 &&\n           mod (ro.y + 0.4 - 0.01, 0.04) < 0.02) col4 *= 0.4;\n        else if (ro.z < -0.5) {\n          col4 = vec4 (0.1);\n          sb = (ro.xy - vec2 (0., 0.6 * sSize.y)) * 340.;\n          if (PxText (sb, 0) > 0.) col4 = vec4 (1., 0., 0., -1.);\n          else if (mod (tCur, 1.) < 0.5) {\n            ro.xy = (abs (sb - vec2 (0., -1.5) * cSpace) - vec2 (29., 7.) * cSpace);\n            if (max (ro.x, ro.y) < 1.25 &&\n               (min (abs (ro.x), abs (ro.y)) < 1.25)) col4 = vec4 (1., 0., 0., -1.);\n          }\n        }\n      }\n    } else {\n      if (idObj == 11) {\n        q = ro - pPos; \n        q.xz = Rot2D (q.xz, pRot);\n        col4 = (q.z < -0.6 * szFac || q.z < 0. && length (vec2 (abs (q.x) - 0.3 * szFac,\n           q.y - 2. * szFac)) < 0.2 * szFac) ? vec4 (0.9, 0.9, 0.9, 0.2) : vec4 (0.1, 0.1, 0.3, 0.1);\n      } else if (idObj == 12) col4 = vec4 (1., 0.8, 0.2, 0.2);\n      else if (idObj == 13) col4 = vec4 (0., 0.3, 0., 0.2);\n      else if (idObj == 14) col4 = vec4 (0.8, 0.8, 0., 0.1);\n      else if (idObj == 15) col4 = vec4 (0.9, 0.9, 0., 0.1);\n      else if (idObj == 16) col4 = vec4 (0.15, 0.15, 0.2, 0.1);\n    }\n    if (! isScrn) {\n      if (col4.a >= 0.) {\n        vn = ObjNf (roh);\n        ao = ObjAO (roh, vn);\n        if (idObj < 11) vn = VaryNf (128. * roh, vn, 0.2);\n        col = col4.rgb * (0.2 + 0.1 * max (0., - dot (vn, normalize (vec3 (ltDir.xz, 0.).xzy))) +\n           0.8 * ao * (max (0., dot (vn, ltDir)))) +\n           ao * col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      } else col = col4.rgb;\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ut;\n  float el, az, zmFac, sr, ds;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  ut = abs (uv) - vec2 (1.33, 1.);\n  if (max (ut.x, ut.y) > 0.003) col = vec3 (0.82);\n  else {\n    dstFar = 60.;\n    ltDir = normalize (vec3 (1., 3., -1.));\n    ds = SmoothBump (0.2, 0.8, 0.1, mod (0.043 * tCur, 1.));\n    az = -0.15 * pi * (2. * floor (mod (0.043 * tCur + 0.5, 2.)) - 1.) * (1. - ds);\n    el = -0.01 * pi * (1. - ds);\n    if (mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += 0.7 * pi * mPtr.y;\n    }\n    az = clamp (az, -0.4 * pi, 0.4 * pi);\n    vuMat = StdVuMat (clamp (el, -0.4 * pi, 0.01 * pi), az);\n    sSize = 0.55 * vec2 (1.33, 1.);\n    sMidHt = 1.26;\n    pPos = vec3 (0.3, 0.35, -2.);\n    pRot = 1.3 * az;\n    szFac = 0.25;\n    fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n       sin (16. * pi * tCur);\n    nRec = int ((1. - abs (2. * mod (0.1 * tCur, 1.) - 1.)) * float (nRecMax + 1));\n    zmFac = 12. * sSize.y * ds;\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      col += (1. / naa) * ShowScene (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n Text derived from 8x12 Font shader by Flyguy (Mt2GWD)\n Glyph bitmaps generated from 8x12 font sheet\n   http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\n#define g_spc  0\n#define g_exc  1\n#define g_quo  2\n#define g_hsh  3\n#define g_dol  4\n#define g_pct  5\n#define g_amp  6\n#define g_apo  7\n#define g_lbr  8\n#define g_rbr  9\n#define g_ast 10\n#define g_crs 11\n#define g_com 12\n#define g_dsh 13\n#define g_per 14\n#define g_lsl 15\n#define g_0   16\n#define g_1   17\n#define g_2   18\n#define g_3   19\n#define g_4   20\n#define g_5   21\n#define g_6   22\n#define g_7   23\n#define g_8   24\n#define g_9   25\n#define g_col 26\n#define g_scl 27\n#define g_les 28\n#define g_equ 29\n#define g_grt 30\n#define g_que 31\n#define g_ats 32\n#define g_A   33\n#define g_B   34\n#define g_C   35\n#define g_D   36\n#define g_E   37\n#define g_F   38\n#define g_G   39\n#define g_H   40\n#define g_I   41\n#define g_J   42\n#define g_K   43\n#define g_L   44\n#define g_M   45\n#define g_N   46\n#define g_O   47\n#define g_P   48\n#define g_Q   49\n#define g_R   50\n#define g_S   51\n#define g_T   52\n#define g_U   53\n#define g_V   54\n#define g_W   55\n#define g_X   56\n#define g_Y   57\n#define g_Z   58\n#define g_lsb 59\n#define g_rsl 60\n#define g_rsb 61\n#define g_pow 62\n#define g_usc 63\n#define g_a   64\n#define g_b   65\n#define g_c   66\n#define g_d   67\n#define g_e   68\n#define g_f   69\n#define g_g   70\n#define g_h   71\n#define g_i   72\n#define g_j   73\n#define g_k   74\n#define g_l   75\n#define g_m   76\n#define g_n   77\n#define g_o   78\n#define g_p   79\n#define g_q   80\n#define g_r   81\n#define g_s   82\n#define g_t   83\n#define g_u   84\n#define g_v   85\n#define g_w   86\n#define g_x   87\n#define g_y   88\n#define g_z   89\n#define g_lpa 90\n#define g_bar 91\n#define g_rpa 92\n#define g_tid 93\n#define g_lar 94\n\n#define C(g) s += PxChar (p, glph[g]);\n\n#define _spc C(g_spc)  \n#define _exc C(g_exc)\n#define _quo C(g_quo)\n#define _hsh C(g_hsh) \n#define _dol C(g_dol) \n#define _pct C(g_pct) \n#define _amp C(g_amp) \n#define _apo C(g_apo) \n#define _lbr C(g_lbr) \n#define _rbr C(g_rbr) \n#define _ast C(g_ast) \n#define _crs C(g_crs) \n#define _com C(g_com) \n#define _dsh C(g_dsh) \n#define _per C(g_per) \n#define _lsl C(g_lsl) \n#define _0   C(g_0) \n#define _1   C(g_1) \n#define _2   C(g_2) \n#define _3   C(g_3) \n#define _4   C(g_4) \n#define _5   C(g_5) \n#define _6   C(g_6) \n#define _7   C(g_7) \n#define _8   C(g_8) \n#define _9   C(g_9) \n#define _col C(g_col) \n#define _scl C(g_scl) \n#define _les C(g_les) \n#define _equ C(g_equ) \n#define _grt C(g_grt) \n#define _que C(g_que) \n#define _ats C(g_ats) \n#define _A   C(g_A) \n#define _B   C(g_B) \n#define _C   C(g_C) \n#define _D   C(g_D) \n#define _E   C(g_E) \n#define _F   C(g_F) \n#define _G   C(g_G) \n#define _H   C(g_H) \n#define _I   C(g_I) \n#define _J   C(g_J) \n#define _K   C(g_K) \n#define _L   C(g_L) \n#define _M   C(g_M) \n#define _N   C(g_N) \n#define _O   C(g_O) \n#define _P   C(g_P) \n#define _Q   C(g_Q) \n#define _R   C(g_R) \n#define _S   C(g_S) \n#define _T   C(g_T) \n#define _U   C(g_U) \n#define _V   C(g_V) \n#define _W   C(g_W) \n#define _X   C(g_X) \n#define _Y   C(g_Y) \n#define _Z   C(g_Z) \n#define _lsb C(g_lsb) \n#define _rsl C(g_rsl) \n#define _rsb C(g_rsb) \n#define _pow C(g_pow) \n#define _usc C(g_usc) \n#define _a   C(g_a) \n#define _b   C(g_b) \n#define _c   C(g_c) \n#define _d   C(g_d) \n#define _e   C(g_e) \n#define _f   C(g_f) \n#define _g   C(g_g) \n#define _h   C(g_h) \n#define _i   C(g_i) \n#define _j   C(g_j) \n#define _k   C(g_k) \n#define _l   C(g_l) \n#define _m   C(g_m) \n#define _n   C(g_n) \n#define _o   C(g_o) \n#define _p   C(g_p) \n#define _q   C(g_q) \n#define _r   C(g_r) \n#define _s   C(g_s) \n#define _t   C(g_t) \n#define _u   C(g_u) \n#define _v   C(g_v) \n#define _w   C(g_w) \n#define _x   C(g_x) \n#define _y   C(g_y) \n#define _z   C(g_z) \n#define _lpa C(g_lpa) \n#define _bar C(g_bar) \n#define _rpa C(g_rpa) \n#define _tid C(g_tid) \n#define _lar C(g_lar) \n\nvec4 glph[95];\nvec2 cPos;\n\nfloat PxChar (vec2 p, vec4 c)\n{\n  vec2 cb;\n  float pOn, b;\n  p = floor (p - cPos);\n  if (min (p.x, p.y) >= 0. && max (p.x - 8., p.y - 12.) < 0.) {\n    b = 8. * (p.y + 1.) - (p.x + 1.);\n    if (b < 48.) cb = (b < 24.) ? vec2 (c.w, b) : vec2 (c.z, b - 24.);\n    else cb = (b < 72.) ? vec2 (c.y, b - 48.) : vec2 (c.x, b - 72.);\n    pOn = mod (floor (cb.x / exp2 (cb.y)), 2.);\n  } else pOn = 0.;\n  cPos.x += cSpace.x;\n  return pOn;\n}\n\nvoid PxBgn (vec2 p)\n{\n  cPos = floor (p * cSpace);\n}\n\nfloat PxText (vec2 p, int txt)\n{\n  float s;\n  s = 0.;\n  if (txt == 0) {\n    PxBgn (- vec2 (27., -1.));\n    _S _o _f _t _w _a _r _e _spc _F _a _i _l _u _r _e _per _spc _P _r _e _s _s _spc \n    _l _e _f _t _spc _m _o _u _s _e _spc _b _u _t _t _o _n _spc _t _o _spc \n    _c _o _n _t _i _n _u _e _per\n    PxBgn (- vec2 (17., 1.));\n    _G _u _r _u _spc _M _e _d _i _t _a _t _i _o _n _spc _hsh\n    _8 _2 _0 _1 _0 _0 _0 _3 _per _D _E _A _D _B _E _E _F\n    PxBgn (- vec2 (7., 5.));\n    _B _e _w _a _r _e _exc _spc _C _O _R _O _N _A _exc _exc \n  } else if (txt == 1) {\n    PxBgn (- vec2 (2., 0.));\n    _A _M _I _G _A\n  } else if (txt == 2) {\n    PxBgn (- vec2 (4., 0.));\n    _C _o _m _m _o _d _o _r _e\n   }\n  return s;\n}\n\nvoid PxInit ()\n{\n  glph[g_spc] = vec4 (0x000000, 0x000000, 0x000000, 0x000000);\n  glph[g_exc] = vec4 (0x003078, 0x787830, 0x300030, 0x300000);\n  glph[g_quo] = vec4 (0x006666, 0x662400, 0x000000, 0x000000);\n  glph[g_hsh] = vec4 (0x006C6C, 0xFE6C6C, 0x6CFE6C, 0x6C0000);\n  glph[g_dol] = vec4 (0x30307C, 0xC0C078, 0x0C0CF8, 0x303000);\n  glph[g_pct] = vec4 (0x000000, 0xC4CC18, 0x3060CC, 0x8C0000);\n  glph[g_amp] = vec4 (0x0070D8, 0xD870FA, 0xDECCDC, 0x760000);\n  glph[g_apo] = vec4 (0x003030, 0x306000, 0x000000, 0x000000);\n  glph[g_lbr] = vec4 (0x000C18, 0x306060, 0x603018, 0x0C0000);\n  glph[g_rbr] = vec4 (0x006030, 0x180C0C, 0x0C1830, 0x600000);\n  glph[g_ast] = vec4 (0x000000, 0x663CFF, 0x3C6600, 0x000000);\n  glph[g_crs] = vec4 (0x000000, 0x18187E, 0x181800, 0x000000);\n  glph[g_com] = vec4 (0x000000, 0x000000, 0x000038, 0x386000);\n  glph[g_dsh] = vec4 (0x000000, 0x0000FE, 0x000000, 0x000000);\n  glph[g_per] = vec4 (0x000000, 0x000000, 0x000038, 0x380000);\n  glph[g_lsl] = vec4 (0x000002, 0x060C18, 0x3060C0, 0x800000);\n  glph[g_0]   = vec4 (0x007CC6, 0xD6D6D6, 0xD6D6C6, 0x7C0000);\n  glph[g_1]   = vec4 (0x001030, 0xF03030, 0x303030, 0xFC0000);\n  glph[g_2]   = vec4 (0x0078CC, 0xCC0C18, 0x3060CC, 0xFC0000);\n  glph[g_3]   = vec4 (0x0078CC, 0x0C0C38, 0x0C0CCC, 0x780000);\n  glph[g_4]   = vec4 (0x000C1C, 0x3C6CCC, 0xFE0C0C, 0x1E0000);\n  glph[g_5]   = vec4 (0x00FCC0, 0xC0C0F8, 0x0C0CCC, 0x780000);\n  glph[g_6]   = vec4 (0x003860, 0xC0C0F8, 0xCCCCCC, 0x780000);\n  glph[g_7]   = vec4 (0x00FEC6, 0xC6060C, 0x183030, 0x300000);\n  glph[g_8]   = vec4 (0x0078CC, 0xCCEC78, 0xDCCCCC, 0x780000);\n  glph[g_9]   = vec4 (0x0078CC, 0xCCCC7C, 0x181830, 0x700000);\n  glph[g_col] = vec4 (0x000000, 0x383800, 0x003838, 0x000000);\n  glph[g_scl] = vec4 (0x000000, 0x383800, 0x003838, 0x183000);\n  glph[g_les] = vec4 (0x000C18, 0x3060C0, 0x603018, 0x0C0000);\n  glph[g_equ] = vec4 (0x000000, 0x007E00, 0x7E0000, 0x000000);\n  glph[g_grt] = vec4 (0x006030, 0x180C06, 0x0C1830, 0x600000);\n  glph[g_que] = vec4 (0x0078CC, 0x0C1830, 0x300030, 0x300000);\n  glph[g_ats] = vec4 (0x007CC6, 0xC6DEDE, 0xDEC0C0, 0x7C0000);\n  glph[g_A]   = vec4 (0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\n  glph[g_B]   = vec4 (0x00FC66, 0x66667C, 0x666666, 0xFC0000);\n  glph[g_C]   = vec4 (0x003C66, 0xC6C0C0, 0xC0C666, 0x3C0000);\n  glph[g_D]   = vec4 (0x00F86C, 0x666666, 0x66666C, 0xF80000);\n  glph[g_E]   = vec4 (0x00FE62, 0x60647C, 0x646062, 0xFE0000);\n  glph[g_F]   = vec4 (0x00FE66, 0x62647C, 0x646060, 0xF00000);\n  glph[g_G]   = vec4 (0x003C66, 0xC6C0C0, 0xCEC666, 0x3E0000);\n  glph[g_H]   = vec4 (0x00CCCC, 0xCCCCFC, 0xCCCCCC, 0xCC0000);\n  glph[g_I]   = vec4 (0x007830, 0x303030, 0x303030, 0x780000);\n  glph[g_J]   = vec4 (0x001E0C, 0x0C0C0C, 0xCCCCCC, 0x780000);\n  glph[g_K]   = vec4 (0x00E666, 0x6C6C78, 0x6C6C66, 0xE60000);\n  glph[g_L]   = vec4 (0x00F060, 0x606060, 0x626666, 0xFE0000);\n  glph[g_M]   = vec4 (0x00C6EE, 0xFEFED6, 0xC6C6C6, 0xC60000);\n  glph[g_N]   = vec4 (0x00C6C6, 0xE6F6FE, 0xDECEC6, 0xC60000);\n  glph[g_O]   = vec4 (0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\n  glph[g_P]   = vec4 (0x00FC66, 0x66667C, 0x606060, 0xF00000);\n  glph[g_Q]   = vec4 (0x00386C, 0xC6C6C6, 0xCEDE7C, 0x0C1E00);\n  glph[g_R]   = vec4 (0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\n  glph[g_S]   = vec4 (0x0078CC, 0xCCC070, 0x18CCCC, 0x780000);\n  glph[g_T]   = vec4 (0x00FCB4, 0x303030, 0x303030, 0x780000);\n  glph[g_U]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCCCC, 0x780000);\n  glph[g_V]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCC78, 0x300000);\n  glph[g_W]   = vec4 (0x00C6C6, 0xC6C6D6, 0xD66C6C, 0x6C0000);\n  glph[g_X]   = vec4 (0x00CCCC, 0xCC7830, 0x78CCCC, 0xCC0000);\n  glph[g_Y]   = vec4 (0x00CCCC, 0xCCCC78, 0x303030, 0x780000);\n  glph[g_Z]   = vec4 (0x00FECE, 0x981830, 0x6062C6, 0xFE0000);\n  glph[g_lsb] = vec4 (0x003C30, 0x303030, 0x303030, 0x3C0000);\n  glph[g_rsl] = vec4 (0x000080, 0xC06030, 0x180C06, 0x020000);\n  glph[g_rsb] = vec4 (0x003C0C, 0x0C0C0C, 0x0C0C0C, 0x3C0000);\n  glph[g_pow] = vec4 (0x10386C, 0xC60000, 0x000000, 0x000000);\n  glph[g_usc] = vec4 (0x000000, 0x000000, 0x000000, 0x00FF00);\n  glph[g_a]   = vec4 (0x000000, 0x00780C, 0x7CCCCC, 0x760000);\n  glph[g_b]   = vec4 (0x00E060, 0x607C66, 0x666666, 0xDC0000);\n  glph[g_c]   = vec4 (0x000000, 0x0078CC, 0xC0C0CC, 0x780000);\n  glph[g_d]   = vec4 (0x001C0C, 0x0C7CCC, 0xCCCCCC, 0x760000);\n  glph[g_e]   = vec4 (0x000000, 0x0078CC, 0xFCC0CC, 0x780000);\n  glph[g_f]   = vec4 (0x00386C, 0x6060F8, 0x606060, 0xF00000);\n  glph[g_g]   = vec4 (0x000000, 0x0076CC, 0xCCCC7C, 0x0CCC78);\n  glph[g_h]   = vec4 (0x00E060, 0x606C76, 0x666666, 0xE60000);\n  glph[g_i]   = vec4 (0x001818, 0x007818, 0x181818, 0x7E0000);\n  glph[g_j]   = vec4 (0x000C0C, 0x003C0C, 0x0C0C0C, 0xCCCC78);\n  glph[g_k]   = vec4 (0x00E060, 0x60666C, 0x786C66, 0xE60000);\n  glph[g_l]   = vec4 (0x007818, 0x181818, 0x181818, 0x7E0000);\n  glph[g_m]   = vec4 (0x000000, 0x00FCD6, 0xD6D6D6, 0xC60000);\n  glph[g_n]   = vec4 (0x000000, 0x00F8CC, 0xCCCCCC, 0xCC0000);\n  glph[g_o]   = vec4 (0x000000, 0x0078CC, 0xCCCCCC, 0x780000);\n  glph[g_p]   = vec4 (0x000000, 0x00DC66, 0x666666, 0x7C60F0);\n  glph[g_q]   = vec4 (0x000000, 0x0076CC, 0xCCCCCC, 0x7C0C1E);\n  glph[g_r]   = vec4 (0x000000, 0x00EC6E, 0x766060, 0xF00000);\n  glph[g_s]   = vec4 (0x000000, 0x0078CC, 0x6018CC, 0x780000);\n  glph[g_t]   = vec4 (0x000020, 0x60FC60, 0x60606C, 0x380000);\n  glph[g_u]   = vec4 (0x000000, 0x00CCCC, 0xCCCCCC, 0x760000);\n  glph[g_v]   = vec4 (0x000000, 0x00CCCC, 0xCCCC78, 0x300000);\n  glph[g_w]   = vec4 (0x000000, 0x00C6C6, 0xD6D66C, 0x6C0000);\n  glph[g_x]   = vec4 (0x000000, 0x00C66C, 0x38386C, 0xC60000);\n  glph[g_y]   = vec4 (0x000000, 0x006666, 0x66663C, 0x0C18F0);\n  glph[g_z]   = vec4 (0x000000, 0x00FC8C, 0x1860C4, 0xFC0000);\n  glph[g_lpa] = vec4 (0x001C30, 0x3060C0, 0x603030, 0x1C0000);\n  glph[g_bar] = vec4 (0x001818, 0x181800, 0x181818, 0x180000);\n  glph[g_rpa] = vec4 (0x00E030, 0x30180C, 0x183030, 0xE00000);\n  glph[g_tid] = vec4 (0x0073DA, 0xCE0000, 0x000000, 0x000000);\n  glph[g_lar] = vec4 (0x000000, 0x10386C, 0xC6C6FE, 0x000000);\n  cSpace = vec2 (8., 13.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1122, 1122, 1156, 1156, 2457], [2459, 2459, 2481, 2481, 4095], [4097, 4097, 4130, 4130, 4313], [4315, 4315, 4336, 4336, 4591], [4593, 4593, 4625, 4625, 4828], [4830, 4830, 4853, 4853, 5025], [5027, 5027, 5058, 5058, 5474], [5476, 5476, 5502, 5502, 9104], [9106, 9106, 9162, 9162, 10736], [10738, 10738, 10770, 10770, 10870], [10872, 10872, 10918, 10918, 10965], [10967, 10967, 11014, 11014, 11061], [11063, 11063, 11096, 11096, 11123], [11125, 11125, 11167, 11167, 11218], [11220, 11220, 11255, 11255, 11317], [11319, 11319, 11364, 11364, 11467], [11469, 11469, 11505, 11505, 11711], [11713, 11713, 11743, 11743, 11856], [11858, 11858, 11915, 11915, 11998], [12032, 12032, 12056, 12056, 12168], [12170, 12170, 12195, 12195, 12381], [12383, 12383, 12404, 12404, 12559], [12561, 12561, 12590, 12590, 12802], [12804, 12804, 12843, 12843, 13023], [16961, 16961, 16992, 16992, 17390], [17392, 17392, 17413, 17413, 17444], [18159, 18159, 18175, 18175, 24189]], "test": "untested"}
{"id": "tslcW4", "name": "Spiral hypnosis - 2", "author": "nbardy", "description": "A spiral I've been experimenting with to create a milky way", "tags": ["sdf", "spiral", "hypno", "hypnosis", "cineshader"], "likes": 17, "viewed": 7714, "published": 3, "date": "1585106236", "time_retrieved": "2024-07-30T21:16:51.918690", "image_code": "const float a=1.0;\nconst float b=.1759;\nconst float PI=3.14159265359;\n\nfloat spiralSDF(vec2 p,vec2 c){\n    // t = theta\n    p = p - c;\n    float t=atan(p.y, p.x) + iTime*8.0;\n    // t=(t+PI)/(2.*PI);\n    float r=length(p.xy);\n    \n    float n=(log(r/a)/b-t)/(2.*PI);\n\n    // Cap the spiral\n    // float nm = (log(0.11)/b-t)/(2.0*PI);\n    // n = min(n,nm);\n    // return (n+1.0)/100.0;\n    float upper_r=a*exp(b*(t+2.*PI*ceil(n)));\n    float lower_r=a*exp(b*(t+2.*PI*floor(n)));\n    // float lower_r = 0.0;\n    \n    return min(abs(upper_r-r),abs(r-lower_r));\n}\n\nvoid mainImage(out vec4 O,vec2 I)\n{\n    vec2 R=iResolution.xy;\n    vec2 uv=(2.*I-R)/R.y;\n    vec2 c = vec2(0.0,0.0);\n    \n    // Uncomment for more swirl\n    // vec2 c = vec2(0.7*sin(iTime*1.3), 0.3*sin(iTime)*2.0);\n    float r = length(uv);\n    float d = spiralSDF(uv,vec2(c));\n\n    // Alter distance for a satisfying visual\n     float v = pow(d, 1.32) / 0.23;\n    O.rgb=vec3(v);\n    //O.rgb = O.rgb*1.0/r;\n    // O.xy=uv;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 102, 119, 559], [561, 561, 596, 596, 986]], "test": "untested"}
{"id": "3sfcR2", "name": "pag-Simple Chromatic Aberration", "author": "h3r3x3", "description": "Simple image filter.", "tags": ["postprocessingeffect"], "likes": 3, "viewed": 603, "published": 3, "date": "1585103305", "time_retrieved": "2024-07-30T21:16:52.683644", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ChromaticAberration = 0.0 / 10.0 + 8.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    vec2 coords = (uv - 0.5) * 2.0;\n    float coordDot = dot (coords, coords);\n    \n    vec2 precompute = ChromaticAberration * coordDot * coords;\n    vec2 uvR = uv - texel.xy * precompute;\n    vec2 uvB = uv + texel.xy * precompute;\n    \n    vec4 color;\n    color.r = texture(iChannel0, uvR).r;\n    color.g = texture(iChannel0, uv).g;\n    color.b = texture(iChannel0, uvB).b;\n    color.a = 1.;\n\tfragColor = color;\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 610]], "test": "untested"}
{"id": "WdfcR2", "name": "pag-Cartoon/ComicBook FX", "author": "h3r3x3", "description": "Uses Sobel edge detection, bilateral filtering, and halftone to achieve cartoon or comic book style rendering", "tags": ["sobel", "cartoon", "edgedetection", "halftone", "comic", "comicbook", "bilateral"], "likes": 7, "viewed": 677, "published": 3, "date": "1585103187", "time_retrieved": "2024-07-30T21:16:53.455581", "image_code": "// Fork of \"Cartoon/ComicBook FX\" by snakebyteme2. https://shadertoy.com/view/XtSfW1\n// 2020-03-25 02:25:40\n// change textureSize to iChannelResolution\n\n\n#define DOTSIZE 1.48\n#define D2R(d) radians(d)\n#define MIN_S 4.0\n#define MAX_S 4.0\n#define SPEED 0.0\n\n#define SST 0.888\n#define SSQ 0.288\n\n#define ORIGIN (0.5 * iResolution.xy)\nfloat R;\nfloat S;\n\nvec4 rgb2cmyki(in vec3 c)\n{\n\tfloat k = max(max(c.r, c.g), c.b);\n\treturn min(vec4(c.rgb / k, k), 1.0);\n}\n\nvec3 cmyki2rgb(in vec4 c)\n{\n\treturn c.rgb * c.a;\n}\n\nvec2 px2uv(in vec2 px)\n{\n\treturn vec2(px / iResolution.xy);\n}\n\nvec2 grid(in vec2 px)\n{\n\treturn px - mod(px,S);\n}\n\nvec4 ss(in vec4 v)\n{\n\treturn smoothstep(SST-SSQ, SST+SSQ, v);\n}\n\nvec4 halftone(in vec2 fc,in mat2 m)\n{\n\tvec2 smp = (grid(m*fc) + 0.5*S) * m;\n\tfloat s = min(length(fc-smp) / (DOTSIZE*0.5*S), 1.0);\n    vec3 texc = texture(iChannel0, px2uv(smp+ORIGIN)).rgb;\n    texc = pow(texc, vec3(2.2)); // Gamma decode.\n\tvec4 c = rgb2cmyki(texc);\n\treturn c+s;\n}\n\nmat2 rotm(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\nvec4 halftone( in vec2 fragCoord )\n{\n    vec4 fragColor = vec4(1.0);\n    R = SPEED*0.333*iTime;\n    S = MIN_S + (MAX_S-MIN_S) * (0.5 - 0.5*cos(SPEED*iTime));\n    \n\tif (iMouse.z > 0.5)\n\t{\n\t\tS = MIN_S + (MAX_S-MIN_S) * 2.0*abs(iMouse.x-ORIGIN.x) / iResolution.x;\n\t\tR = D2R(180.0 * (iMouse.y-ORIGIN.y) / iResolution.y);\n\t}\n\t\n\tvec2 fc = fragCoord.xy - ORIGIN;\n\t\n\tmat2 mc = rotm(R + D2R(15.0));\n\tmat2 mm = rotm(R + D2R(75.0));\n\tmat2 my = rotm(R);\n\tmat2 mk = rotm(R + D2R(45.0));\n\t\n\tfloat k = halftone(fc, mk).a;\n\tvec3 c = cmyki2rgb(ss(vec4(\n\t\thalftone(fc, mc).r,\n\t\thalftone(fc, mm).g,\n\t\thalftone(fc, my).b,\n\t\thalftone(fc, mk).a\n\t)));\n    \n    c = pow(c, vec3(1.0/2.2)); // Gamma encode.\n\tfragColor = vec4(c, 1.0);\n    return fragColor;\n}\n\n// Bilateral Filter for Younger. starea.\n// URL: https://www.shadertoy.com/view/XtVGWG\n// Press mouse for comparison.\n// Filter forked from mrharicot: https://www.shadertoy.com/view/4dfGDH \n// Skin detection forked from carlolsson's Skin Detection https://www.shadertoy.com/view/MlfSzn#\n// With performance improvement by athlete\n#define SIGMA 10.0\n#define BSIGMA 0.1\n#define MSIZE 15\n//#define USE_CONSTANT_KERNEL\n//#define SKIN_DETECTION\n\nconst bool GAMMA_CORRECTION = false; \nfloat kernel[MSIZE];\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * x * x/ (sigma * sigma)) / sigma;\n}\n\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v,v) / (sigma * sigma)) / sigma;\n}\n\nfloat normalizeColorChannel(in float value, in float min, in float max) {\n    return (value - min)/(max-min);\n}\n\nvec4 bilateral( in vec2 fragCoord ) {\n\tvec4 fragColor = vec4(1.0);\n    vec3 c = texture(iChannel0, (fragCoord.xy / iResolution.xy)).rgb;\n    const int kSize = (MSIZE - 1) / 2;\n    vec3 final_colour = vec3(0.0);\n    float Z = 0.0;\n    \n#ifdef USE_CONSTANT_KERNEL\n    // unfortunately, WebGL 1.0 does not support constant arrays...\n    kernel[0] = kernel[14] = 0.031225216;\n    kernel[1] = kernel[13] = 0.033322271;\n    kernel[2] = kernel[12] = 0.035206333;\n    kernel[3] = kernel[11] = 0.036826804;\n    kernel[4] = kernel[10] = 0.038138565;\n    kernel[5] = kernel[9]  = 0.039104044;\n    kernel[6] = kernel[8]  = 0.039695028;\n    kernel[7] = 0.039894000;\n    float bZ = 0.2506642602897679;\n#else\n\t//create the 1-D kernel\n\tfor (int j = 0; j <= kSize; ++j) {\n\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), SIGMA);\n\t}\n    float bZ = 1.0 / normpdf(0.0, BSIGMA);\n#endif\n    \n\n    vec3 cc;\n    float factor;\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            cc = texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n            factor = normpdf3(cc-c, BSIGMA) * bZ * kernel[kSize+j] * kernel[kSize+i];\n            Z += factor;\n            if (GAMMA_CORRECTION) {\n            \tfinal_colour += factor * pow(cc, vec3(2.2));\n            } else {\n            \tfinal_colour += factor * cc;\n            }\n        }\n    }\n    \n    if (GAMMA_CORRECTION) {\n    \tfragColor = vec4(pow(final_colour / Z, vec3(1.0/2.2)), 1.0);\n    } else {\n    \tfragColor = vec4(final_colour / Z, 1.0);\n    }\n    \n    bool isSkin = true; \n    \n#ifdef SKIN_DETECTION\n    isSkin = false; \n    vec4 rgb = fragColor * 255.0;\n    vec4 ycbcr = rgb;\n    ycbcr.x = 16.0 + rgb.x*0.257 + rgb.y*0.504 + rgb.z*0.098;\n    ycbcr.y = 128.0 - rgb.x*0.148 - rgb.y*0.291 + rgb.z*0.439;\n    ycbcr.z = 128.0 + rgb.x*0.439 - rgb.y*0.368 - rgb.z*0.071;\n    if (ycbcr.y > 100.0 && ycbcr.y < 118.0 &&\n        ycbcr.z > 121.0 && ycbcr.z < 161.0) {\n     \tisSkin = true; \n    }\n#endif\n\n    if (iMouse.z > 0.0 || !isSkin) {\n        fragColor = vec4(texture(iChannel0, fragCoord.xy / iResolution.xy).xyz, 1.0); \n    }\n    return fragColor;\n}\n\n\nvec2 res;\nvec2 inv_res;\n\n\nfloat luminance(vec4 color_in) {\n\treturn 0.25 * color_in.r + 0.5 * color_in.g + 0.25 * color_in.b;\n}\n\nfloat luminance(sampler2D texture_in, vec2 uv, float bias) {\n\tvec4 sample_color = texture(texture_in, uv, bias);\n\treturn luminance(sample_color);\n}\n\nfloat luminance(sampler2D texture_in, vec2 uv) {\n\treturn luminance(texture_in, uv, 0.0);\n}\n\n\nconst mat3 YCoCr_mat = mat3(\n\t1./4., 1./2., 1./4.,\n    -1./4., 1./2., -1./4.,\n    1./2., 0.0, -1./2.\n);\n\nvec3 YCoCr(vec3 color_in) {\n\treturn YCoCr_mat * color_in;\n}\n\nvec3 YCoCr(sampler2D texture_in, vec2 uv) {\n\treturn YCoCr(texture(texture_in, uv).xyz);\n}\n    \n\nconst mat3 sx = mat3( \n    1.0, 2.0, 1.0, \n    0.0, 0.0, 0.0, \n   -1.0, -2.0, -1.0 \n);\nconst mat3 sy = mat3( \n    1.0, 0.0, -1.0, \n    2.0, 0.0, -2.0, \n    1.0, 0.0, -1.0 \n);\n\n\nfloat calc_sobel_res(mat3 I) {\n\tfloat gx = dot(sx[0], I[0]) + dot(sx[1], I[1]) + dot(sx[2], I[2]); \n\tfloat gy = dot(sy[0], I[0]) + dot(sy[1], I[1]) + dot(sy[2], I[2]);\n\n\treturn sqrt(pow(gx, 2.0)+pow(gy, 2.0));\n}\n\n\n// Sobel\n// Based on https://computergraphics.stackexchange.com/questions/3646/opengl-glsl-sobel-edge-detection-filter\nvec3 sobel(vec2 uv) {\n    mat3 Y;\n    mat3 Co;\n    mat3 Cr;\n    \n    vec3 temp; \n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n        \tvec2 pos = uv + vec2(float(i-1) * inv_res.x, float(j-1) * inv_res.y);\n            temp = YCoCr(iChannel0, pos);\n            Y[i][j] = temp.x;\n            Co[i][j] = temp.y;\n            Cr[i][j] = temp.z;\n\t    }\n\t}\n    \n\treturn vec3(calc_sobel_res(Y), calc_sobel_res(Co), calc_sobel_res(Cr));\n}\n\n//toggle between cartoon and comic mode\n#define COMIC\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 fillColor = bilateral(fragCoord);\n    vec4 halftoneColor = halftone(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_mirror_x = vec2(uv.x, uv.y);\n    inv_res = vec2(1.) / iChannelResolution[0].xy;\n    \n\t//fragColor = vec4(vec3(YCoCr(iChannel0, uv_mirror_x).xyz), 1.0);\n    //fragColor = vec4((texture(iChannel0, uv_mirror_x).xyz + sobel(uv_mirror_x))/2., 1.0);\n    vec3 sobe_edge = sobel(uv_mirror_x);\n    fragColor = vec4(sobe_edge, 1.0);\n    \n    fragColor = vec4(vec3(clamp((sobe_edge.x + sobe_edge.y + sobe_edge.z)/3., 0.0, 1.0)), 1.0);\n    if (fragColor.x < 0.05) {\n        fragColor = vec4(0.0);\n    } \n#ifdef COMIC\n    vec3 outlineColor = fragColor.xyz;\n    fragColor.xyz = (halftoneColor.xyz + fillColor.xyz) / 2.0;\n    fragColor.xyz -= outlineColor;\n    \n#else\n    fragColor = (fillColor - fragColor);\n#endif\n    \n    \n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 350, 377, 377, 453], [455, 455, 482, 482, 505], [507, 507, 531, 531, 568], [570, 570, 593, 593, 619], [621, 621, 641, 641, 684], [686, 686, 723, 723, 967], [969, 969, 992, 992, 1070], [1072, 1072, 1108, 1108, 1804], [2307, 2307, 2350, 2350, 2414], [2416, 2416, 2459, 2459, 2527], [2529, 2529, 2602, 2602, 2640], [2642, 2642, 2679, 2679, 4828], [4857, 4857, 4889, 4889, 4957], [4959, 4959, 5019, 5019, 5106], [5108, 5108, 5156, 5156, 5198], [5306, 5306, 5333, 5333, 5365], [5367, 5367, 5410, 5410, 5456], [5640, 5640, 5670, 5670, 5851], [5854, 5973, 5994, 5994, 6420], [6478, 6478, 6535, 6535, 7391]], "test": "untested"}
{"id": "WsXcR2", "name": "PAG-RGB Shift Glitch", "author": "h3r3x3", "description": " ", "tags": ["rgb", "postprocess", "glitch", "shift", "twitchy"], "likes": 4, "viewed": 301, "published": 3, "date": "1585102784", "time_retrieved": "2024-07-30T21:16:54.507767", "image_code": "/*\n * MIT License\n * Copyright © Etienne 'Eethe' Orlhac\n * 07/08/2015\n *\n * Permission is hereby granted, free of charge, to any person obtaining \n * a copy of this software and associated documentation files (the “Software”), \n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the Software \n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n * \n * The Software is provided “as is”, without warranty of any kind, \n * express or implied, including but not limited to the warranties of merchantability, \n * fitness for a particular purpose and noninfringement. In no event shall the authors \n * or copyright holders be liable for any claim, damages or other liability, whether in an \n * action of contract, tort or otherwise, arising from, out of or in connection with \n * the software or the use or other dealings in the Software.\n */\n\n#define AMPLITUDE 0.1\n#define SPEED 0.1\n\nvec4 rgbShift( in vec2 p , in vec4 shift) {\n    shift *= 2.0*shift.w - 1.0;\n    vec2 rs = vec2(shift.x,-shift.y);\n    vec2 gs = vec2(shift.y,-shift.z);\n    vec2 bs = vec2(shift.z,-shift.x);\n    \n    float r = texture(iChannel0, p+rs, 0.0).x;\n    float g = texture(iChannel0, p+gs, 0.0).y;\n    float b = texture(iChannel0, p+bs, 0.0).z;\n    \n    return vec4(r,g,b,1.0);\n}\n\nvec4 noise( in vec2 p ) {\n    return texture(iChannel1, p, 0.0);\n}\n\nvec4 vec4pow( in vec4 v, in float p ) {\n    // Don't touch alpha (w), we use it to choose the direction of the shift\n    // and we don't want it to go in one direction more often than the other\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),v.w); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec4 c = vec4(0.0,0.0,0.0,1.0);\n    \n    // Elevating shift values to some high power (between 8 and 16 looks good)\n    // helps make the stuttering look more sudden\n    vec4 shift = vec4pow(noise(vec2(SPEED*iTime,2.0*SPEED*iTime/25.0 )),8.0)\n        \t\t*vec4(AMPLITUDE,AMPLITUDE,AMPLITUDE,1.0);;\n    \n    c += rgbShift(p, shift);\n    \n\tfragColor = c;\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcR2.jpg", "access": "api", "license": "mit", "functions": [[1207, 1207, 1250, 1250, 1577], [1579, 1579, 1604, 1604, 1645], [1647, 1647, 1686, 1840, 1898], [1900, 1900, 1957, 1957, 2355]], "test": "untested"}
{"id": "3dXcR2", "name": "PAG_20151110_VHS", "author": "h3r3x3", "description": "wip", "tags": ["filter"], "likes": 5, "viewed": 588, "published": 3, "date": "1585102367", "time_retrieved": "2024-07-30T21:16:55.504104", "image_code": "// Fork of \"20151110_VHS\" by FMS_Cat. https://shadertoy.com/view/XtBXDt\n// 2020-03-25 02:11:48\n\n#define time iTime\n#define resolution ( iResolution.xy )\n#define iChannel0 iChannel0\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n\n#define PI 3.14159265\n\nvec3 tex2D( sampler2D _tex, vec2 _p ){\n  vec3 col = texture( _tex, _p ).xyz;\n  if ( 0.5 < abs( _p.x - 0.5 ) ) {\n    col = vec3( 0.1 );\n  }\n  return col;\n}\n\nfloat hash( vec2 _v ){\n  return fract( sin( dot( _v, vec2( 89.44, 19.36 ) ) ) * 22189.22 );\n}\n\nfloat iHash( vec2 _v, vec2 _r ){\n  float h00 = hash( vec2( floor( _v * _r + vec2( 0.0, 0.0 ) ) / _r ) );\n  float h10 = hash( vec2( floor( _v * _r + vec2( 1.0, 0.0 ) ) / _r ) );\n  float h01 = hash( vec2( floor( _v * _r + vec2( 0.0, 1.0 ) ) / _r ) );\n  float h11 = hash( vec2( floor( _v * _r + vec2( 1.0, 1.0 ) ) / _r ) );\n  vec2 ip = vec2( smoothstep( vec2( 0.0, 0.0 ), vec2( 1.0, 1.0 ), mod( _v*_r, 1. ) ) );\n  return ( h00 * ( 1. - ip.x ) + h10 * ip.x ) * ( 1. - ip.y ) + ( h01 * ( 1. - ip.x ) + h11 * ip.x ) * ip.y;\n}\n\nfloat noise( vec2 _v ){\n  float sum = 0.;\n  for( int i=1; i<9; i++ )\n  {\n    sum += iHash( _v + vec2( i ), vec2( 2. * pow( 2., float( i ) ) ) ) / pow( 2., float( i ) );\n  }\n  return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 uvn = uv;\n  vec3 col = vec3( 0.0 );\n\n  // tape wave\n  uvn.x += ( noise( vec2( uvn.y, time ) ) - 0.5 )* 0.005;\n  uvn.x += ( noise( vec2( uvn.y * 100.0, time * 10.0 ) ) - 0.5 ) * 0.01;\n\n  // tape crease\n  float tcPhase = clamp( ( sin( uvn.y * 8.0 - time * PI * 1.2 ) - 0.92 ) * noise( vec2( time ) ), 0.0, 0.01 ) * 10.0;\n  float tcNoise = max( noise( vec2( uvn.y * 100.0, time * 10.0 ) ) - 0.5, 0.0 );\n  uvn.x = uvn.x - tcNoise * tcPhase;\n\n  // switching noise\n  float snPhase = smoothstep( 0.03, 0.0, uvn.y );\n  uvn.y += snPhase * 0.3;\n  uvn.x += snPhase * ( ( noise( vec2( uv.y * 100.0, time * 10.0 ) ) - 0.5 ) * 0.2 );\n    \n  col = tex2D( iChannel0, uvn );\n  col *= 1.0 - tcPhase;\n  col = mix(\n    col,\n    col.yzx,\n    snPhase\n  );\n\n  // bloom\n  for( float x = -4.0; x < 2.5; x += 1.0 ){\n    col.xyz += vec3(\n      tex2D( iChannel0, uvn + vec2( x - 0.0, 0.0 ) * 7E-3 ).x,\n      tex2D( iChannel0, uvn + vec2( x - 2.0, 0.0 ) * 7E-3 ).y,\n      tex2D( iChannel0, uvn + vec2( x - 4.0, 0.0 ) * 7E-3 ).z\n    ) * 0.1;\n  }\n  col *= 0.6;\n\n  // ac beat\n  col *= 1.0 + clamp( noise( vec2( 0.0, uv.y + time * 0.2 ) ) * 0.6 - 0.25, 0.0, 0.1 );\n\n  gl_FragColor = vec4( col, 1.0 );\n}\n\n#undef gl_FragCoord\n#undef gl_FragColor", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 305, 305, 421], [423, 423, 445, 445, 516], [518, 518, 550, 550, 1037], [1039, 1039, 1062, 1062, 1227], [1229, 1229, 1285, 1285, 2504]], "test": "untested"}
{"id": "tslyRB", "name": "Day 97", "author": "jeyko", "description": "potato", "tags": ["motion", "logpolar", "mdtmjvm"], "likes": 14, "viewed": 488, "published": 3, "date": "1585087145", "time_retrieved": "2024-07-30T21:16:56.456557", "image_code": "#define pmod(p,x) mod(p,x) - 0.5*x\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime*1.6)\n\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    n += valueNoise(uv*800.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    n = max(n, 0.);\n    return n;\n}\n#define pi acos(-1.)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nvec3 get(vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 uvn = uv;\n    uv *= 1. - dot(uv,uv)*0.3;\n    \n    uv *= 4.;\n    \n    float rang = 0.2;\n    \n    uv -= rang*0.5;\n    uv.x += iMouse.x/iResolution.y*rang;\n    uv.y += iMouse.y/iResolution.y*rang;\n    \n\n    vec3 col = vec3(0);\n\n    vec2 p = uv;\n    \n    \n    float un = 1.;\n    float T = iTime*1.;\n    float fa; \n    float its = 1.;\n    \n    float xx;\n    float yy;\n    for(float i = 0.; i < its; i++){\n        \n        float dpp = dot(p, p);\n        dpp = clamp(dpp, 0.04,0.6);\n        \n        p = (p + 0.)/dpp;\n        \n        \n        float yy=abs(sin(p.y*40. + T/1.));\n        float xx=abs(sin(p.x*40. + T/1.));\n        \n        if(i == its -1.)\n    \t\tfa = exp(-min(yy,xx)*6.)*un;\n        \n        float f = sin(iTime*0.125*pi);\n        float ff = sin(iTime*0.125*pi + pi/2.);\n        \n        p.x -= xx = pow(abs(f),2.5 )*sign(f)*3.5;\n        p *= 1. + pow(fract(abs(ff)),5.)*0.6;\n        float tt = iTime*0.25;\n        float ft = mod(tt, 2.);\n        tt = floor(tt);\n        ft = pow(smoothstep(0.,1.,pow(ft, 1.5) - 0.4), 2.25);\n        p.xy *= rot((tt + ft)*pi*1.);\n        p = clamp(p,-4.,4.);\n        \n        \n    }\n    \n    \n    float modD = 0.04 - smoothstep(0.,1.,iTime*0.005)*0.0;\n\n    p = mix(p,sin(p*11.14 + T*1.), smoothstep(0.,1.,0. +smoothstep(0.,1.,dot(uvn,uvn)*0.9 )*0.4)*0.1);\n\n    float i = log(length(((p.xy)/modD)) + 70.) + iTime*0.05;\n    \n    float id = floor(i*30.);\n    vec3 aa =pal(0.5,0.55,vec3(0.1,0.7,0.9), 0.6 + sin(id*0.4 + iTime)*.4, id*0.9 + iTime*0.5 - dot(uvn,uvn)*.5);\n    \n    aa = max(aa, 0.);\n    col += aa;\n    col = max(col, 0.);\n    col = mix(col,smoothstep(0.,1.,col), 0.8);\n    \n    col -= fbm(uvn).x*0.01;\n    col += fbm(uv + 4.).x*0.01;\n    \n    col = max(col, 0.);\n    col = pow(col, vec3(1. + dot(uvn,uvn)*0.4) + pow(fa, 1.)*0.2);\n    \n    col *= 1. - dot(uvn,uvn);\n    \n    return col;\n}\n    \n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(float i =0.; i < 9. + float(min(iFrame,0)); i++){\n    \tcol += get(fragCoord + vec2(mod(i,3.),floor(i/3.))*0.25);\n    }\n    col /= 9.;\n    \n    col = max(col, 0.);\n\tcol = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 199, 199, 728], [729, 729, 747, 747, 947], [1021, 1021, 1048, 1048, 2956], [2969, 2969, 3026, 3026, 3295]], "test": "untested"}
{"id": "wssczB", "name": "Curl transition", "author": "WAHa_06x36", "description": "A quick test for a transition effect.", "tags": ["transition"], "likes": 13, "viewed": 718, "published": 3, "date": "1585082214", "time_retrieved": "2024-07-30T21:16:57.221512", "image_code": "float triangle(float x) {\n    return 1.0 - abs(fract(x) - 0.5) * 2.0;\n}\n\nfloat smootherstep(float x) {\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat endPosition(float radius, float offset, float rollPosition) {\n    float rollLength = radius * 3.141592 / 2.0;\n    float onRoll = min(offset + 1.0 - rollPosition, rollLength);\n\treturn rollPosition + radius * sin(onRoll / radius);\n}\n\nfloat findRollPosition(float radius, float offset) {\n    float lower = 1.0 - radius;\n    float upper = 1.0;\n\n    float mid = 0.0;\n    for(int i = 0; i < 16; i++) {\n        mid = (upper + lower) / 2.0;\n        float position = endPosition(radius, offset, mid);\n        if(position > 1.0) {\n            upper = mid;\n        } else {\n            lower = mid;\n        }\n    }\n    return mid;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord/iResolution.xy;\n   \tfloat t = iTime / 5.0;\n    float offset = smootherstep(triangle(t));\n\n    float radius = 0.2;\n    float flatLength = 1.0 - radius;\n    float rollLength = radius * 3.141592 / 2.0;\n    float fullLength = flatLength + rollLength;\n\n    offset *= fullLength;\n\n    float rollPosition = findRollPosition(radius, offset);\n\n    vec2 uv = p;\n\tfloat shadow;\n    \n    if(p.x < rollPosition) {\n        uv.x -= offset;\n        shadow = 1.0;\n    } else {\n        float a = asin((p.x - rollPosition) / radius);\n   \t    uv.x = a * radius - offset + rollPosition;\n\t\tuv.y = (p.y - 0.5) / (0.2 * cos(a) + 0.8) + 0.5;\n        shadow = 0.5 * cos(a) + 0.5;\n    }\n\n    vec4 col = texture(iChannel0, uv);\n    col *= step(-uv.x, 0.0);\n    col *= step(-uv.y, 0.0);\n    col *= step(uv.y, 1.0);\n    col *= shadow;\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 71], [73, 73, 102, 102, 158], [160, 160, 227, 227, 396], [398, 398, 450, 450, 787], [789, 789, 844, 844, 1700]], "test": "untested"}
{"id": "tdsyzB", "name": "Sampling Projected Spherical Cap", "author": "koiava", "description": "\"Sampling Projected Spherical Caps in Real Time\"\nhttp://momentsingraphics.de/I3D2019.html\nComparing different sampling strategies:\nLeft - Area sampling\nMiddle- Solid Angle sampling\nRight - Projected solid Angle sampling", "tags": ["light", "sampling", "solidangle", "optimal"], "likes": 23, "viewed": 963, "published": 3, "date": "1585076049", "time_retrieved": "2024-07-30T21:16:58.427288", "image_code": "#define PIXEL_SAMPLES \t\t1\t\t\t//Increase for higher quality(better AA)\n#define LIGHT_SAMPLES\t\t1\t\t\t//Increase for higher quality\n\n#define GAMMA \t\t\t\t2.2\t\t\t//\n#define SHADOWS\t\t\t//shadows are broken for PSA\n#define SHOW_LIGHT\n#define LIGHT_CLIPPING\n#define STRATIFIED_SAMPLING\nconst vec3 backgroundColor = vec3( 0.0 );\n\n#define SAMPLE_TOTAL_AREA\t\t0\n#define SAMPLE_SA\t\t\t\t1\n#define SAMPLE_PSA\t\t\t\t2\n#define SAMPLE_NONE\t\t\t\t3\nint samplingTechnique;\nfloat split1;\nfloat split2;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(abs(a-(b))<eps)\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n    \n\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int material_id_;\n};\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_TRIANGLE\t4\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n    \nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n};\n    \n// ************ SCENE ***************\nObject objects[7];\nCamera camera;\n//***********************************\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//radius\n    obj.params_[1] = minY;\t\t\t//min z\n    obj.params_[2] = maxX;\t\t\t//max z\n    obj.params_[3] = maxY;\t\t\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createTriangle(mat4 transform, vec2 v1, vec2 v2, vec2 v3, int mtl, out Object obj) {\n    obj.type_ = OBJ_TRIANGLE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = v1.x;\t\t\t\n    obj.params_[1] = v1.y;\t\t\t\n    obj.params_[2] = v2.x;\t\t\t\n    obj.params_[3] = v2.y;\t\t\t\n    obj.params_[4] = v3.x;\t\t\n    obj.params_[5] = v3.y;\t\t\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\nvoid initScene() {\n    float time = iTime;\n    \n    //init lights\n    float r = 0.1;\n    \n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float z = -1.0;\n    mat4 trans = createCS(\tvec3(-0.2, -0.401 + (1.0 + sin(iTime)*1.7), z),\n                          \tvec3(0.0, 0.0, 1.0),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n    createSphere(trans, 0.6, MTL_LIGHT, objects[0] );\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, MTL_DIFFUSE, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -7.0, 10.0, 2.0, MTL_DIFFUSE, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, MTL_DIFFUSE, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.5, 0.0, -2.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( -1.3, -0.15, -3.0, 1.0 ));\n\n    createSphere(trans, 0.6, MTL_DIFFUSE, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.25), MTL_DIFFUSE, objects[6]);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool rayIntersectsTriangle(in Ray ray, vec3 v0, vec3 v1, vec3 v2, in bool forShadowTest, out float t, out SurfaceHitInfo isect){\n    vec3 p = ray.origin;\n    vec3 d = ray.dir;\n    \n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tif (a > -0.00001 && a < 0.00001)\n\t\treturn false;\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tif (u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\n\tif (v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\t//uv = vec2(u, v);\n\t\n\tif (t > 0.00001) // ray intersection\n\t\treturn true;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n        isect.uv_.x = isect.position_.x;\n        isect.uv_.y = isect.position_.y;\n    }\n\n\t// this means that there is a line intersection\n\t// but not a ray intersection\n\treturn false;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_TRIANGLE ) {\n        vec3 v1 = vec3(obj.params_[0], obj.params_[1], 0.0);\n        vec3 v2 = vec3(obj.params_[2], obj.params_[3], 0.0);\n        vec3 v3 = vec3(obj.params_[4], obj.params_[5], 0.0);\n        hitResult = rayIntersectsTriangle(rayLocal, v1, v2, v3, forShadowTest, t, currentHit);\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.material_id_ = obj.mtl_id_;\n\n        if( dot( ray.dir, hit.normal_ ) > 0.0 )\n            hit.normal_ *= -1.0;\n        \n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n#ifdef SHOW_LIGHT\n    CHECK_OBJ( objects[0] );\n#else\n    if(forShadowTest) {\n    \tCHECK_OBJ( objects[0] );\n    }\n#endif\n    CHECK_OBJ( objects[1] );\n    CHECK_OBJ( objects[2] );\n    CHECK_OBJ( objects[3] );\n    CHECK_OBJ( objects[4] );\n    CHECK_OBJ( objects[5] );\n    CHECK_OBJ( objects[6] );\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformPointWitinTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in float Xi1, in float Xi2 ) {\n    Xi1 = sqrt(Xi1);\n    return (1.0-Xi1)*v1 + Xi1*(1.0-Xi2)*v2 + Xi1*Xi2*v3;\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(iTime*0.154)*2.0, 2.0 + sin(iTime*0.3)*2.0, cameraZ + sin(iTime*0.8) );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( sin(iTime*0.4)*0.3, -1.2, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool intersectPlane(vec3 plane_n, vec3 plane_p, vec3 ray_o, vec3 ray_d, out float t) { \n    // assuming vectors are all normalized\n    float denom = dot(plane_n, ray_d); \n    if (abs(denom) > 1e-7) { \n        vec3 vec = plane_p - ray_o; \n        t = dot(vec, plane_n) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nvec2 angular_to_cartesian(float phi) {\n    return vec2(cos(phi), sin(phi));\n}\n\nfloat cartesian_to_angular(vec2 w) {\n\treturn atan(float(-w.y), float(-w.x)) + PI;\n}\n\nvoid sampleSphereArea(vec3 pos, vec3 normal, vec2 xi, out vec3 dir, out float pdf) {\n    float pdfA;\n    float d2;\n    float aCosThere;\n    \n    float rad = objects[0].params_[0];\n    float rad2 = objects[0].params_[1];\n    \n    vec3 n = randomDirection(xi.x, xi.y);\n    vec3 p = n*rad;\n    pdfA = 1.0/(4.0*PI*rad2);\n\n    dir = p - pos;\n    d2 = dot(dir,dir);\n    dir /= sqrt(d2);\n    aCosThere = max(0.0,dot(-dir,n));\n\n    pdf = PdfAtoW( pdfA, d2, aCosThere );\n}\n\nvoid sampleSphereSolidAngle(vec3 pos, vec3 normal, vec2 xi, out vec3 dir, out float pdf) {\n\tfloat rad = objects[0].params_[0];\n    float rad2 = objects[0].params_[1];\n    \n    vec3 w = -pos;\t\t\t//direction to light center\n    float dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n\n    if(dc > rad) {\n        float sin_theta_max_2 = rad2 / dc_2;\n        float cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n        float cos_theta = mix( cos_theta_max, 1.0, xi.x );\n        float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n        float sin_theta = sqrt(sin_theta_2);\n        dir = uniformDirectionWithinCone( w, TWO_PI*xi.y, sin_theta, cos_theta );\n        pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n    } else {\n        dir = vec3(0.0);\n        pdf = 0.0;\n    }\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.material_id_ == MTL_LIGHT );\n}\n\n\nvec3 Radiance( in Ray ray, float Xi ) {\n    vec3 L = vec3(4.0);\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 Wo = ray.dir*(-1.0);\n    SurfaceHitInfo hit;\n    float dist = 1000.0;\n\n    if( raySceneIntersection( ray, 0.0, false, hit, dist ) ) {\n        if( hit.material_id_ == MTL_LIGHT ) {\n            Lo = L;\n        } else {\n            float rad = objects[0].params_[0];\n            //convert position to object space\n            vec3 lp = toVec3( objects[0].transform_inv_*vec4(hit.position_, 1.0) );\n            vec3 ln = toVec3( objects[0].transform_inv_*vec4(hit.normal_, 0.0) );\n            ProjectedSphericalCap cap;\n            \n            if(samplingTechnique == SAMPLE_PSA){\n                prepareProjectedSphericalCapSampling(cap, ln, -lp, rad);\n            }\n            \n            for(int i=0; i<LIGHT_SAMPLES; i++){\n                vec3 Wi;\n                vec3 lwi;\n                float pdfWi;\n                \n            \tvec2 xi = vec2(rnd(), rnd());\n#ifdef STRATIFIED_SAMPLING\n                float strataSize = 1.0 / float(LIGHT_SAMPLES);\n                xi.y = strataSize * (float(i) + xi.y);\n#endif\n                \n                if(samplingTechnique == SAMPLE_TOTAL_AREA){\n                    sampleSphereArea(lp, ln, xi, lwi, pdfWi);\n                } else if(samplingTechnique == SAMPLE_SA){\n                    sampleSphereSolidAngle(lp, ln, xi, lwi, pdfWi);\n                } else {\n                    // Spherical cap sampling from : http://momentsingraphics.de/I3D2019.html\n                    // Method samples projected spherical cap which has 4 cases:\n                    // 1 - entirely above the horizon\n                    // 2 - mostly above (intersecting horizon)\n                    // 3 - mostly below (intersecting horizon)\n                    // 4 - entirely below the horizon\n                    // problem simplifies to a partial elipse sampling. for more details read paper :)\n                    lwi = sampleProjectedSphericalCap(pdfWi, cap, xi);\n                    pdfWi *= dot(lwi, ln);\n                \t\n                }\n                \n                //convert dir to world space\n    \t\t\tWi = toVec3( objects[0].transform_*vec4(lwi, 0.0));\n                \n\n                float dotNWi = dot( lwi, ln );\n                if ( (pdfWi > EPSILON) && (dotNWi > 0.0) ) {\n                    bool visible = true;\n#ifdef SHADOWS\n                    Ray shadowRay = Ray( hit.position_ + hit.normal_*EPSILON, Wi );\n                    if ( !isLightVisible( shadowRay ) ) {\n                        visible = false;\n                    }\n#endif\n                    if(visible) {\n                        float brdf_pdf;\n\n                        vec3 brdf = vec3(1.0/PI);\n\t\t\t\t\t\tvec3 Li = L/pdfWi;\n                        Lo += (brdf*Li*abs(dotNWi));\n                    }\n                }\n            }\n            Lo *= 1.0/float(LIGHT_SAMPLES);\n            \n        }\n    }\n        \n    return Lo;\n}\n\nvoid initSamplingTechnique(float p) {\n    float k = iMouse.x/iResolution.x;\n    if(iMouse.z<0.0 || iMouse.x==0.0) {\n      \tsplit1 = 0.0;\n        split2 = 0.0;  \n    } else {\n        split1 = iMouse.x*k;\n        split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    }\n    \n    if(p < split1-1.0) {\n        samplingTechnique = SAMPLE_TOTAL_AREA;\n    } else if((p > split1+1.0) && (p < split2-1.0)) {\n        samplingTechnique = SAMPLE_SA;\n    } else if(p > split2+1.0){\n        samplingTechnique = SAMPLE_PSA;\n    } else {\n        samplingTechnique = SAMPLE_NONE;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    initSamplingTechnique(fragCoord.x);\n\n    if(samplingTechnique == SAMPLE_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        float fov = radians(45.0);\n        initCamera( vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, -1.0, 0.0 ),\n                    vec3( 0.0, 1.0, 0.0 ),\n                    fov\n                    );\n\n        initScene();\n\n        vec3 accumulatedColor = vec3( 0.0 );\n        float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n        float strataSize = oneOverSPP;\n        Ray ray;\n\n        for( int si=0; si<PIXEL_SAMPLES; ++si ){\n            updateCamera( si );\n\n            vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n            ray = genRay( screenCoord, rnd(), rnd() );\n\n            if( length( ray.dir ) < 0.2 ) {\n                accumulatedColor = vec3( 0.0 );\n            } else {\n                accumulatedColor += Radiance( ray, strataSize*( float(si) + rnd() ) );\n            }\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*oneOverSPP;\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}", "image_inputs": [], "common_code": "// Copyright (c) 2019, Christoph Peters\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Karlsruhe Institute of Technology nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n#define M_PI 3.14159265\n#define M_PI2 (3.14159265*2.0)\n\n#define mad(v1, v2, v3) (v1*v2+v3)\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat lerp(float a, float b, float p) { return a + (b - a) * p; }\n\n/*! This structure carries intermediate results that only need to be computed \n\tonce per spherical cap for sampling proportional to projected solid angle. \n\tOnce it is available, the sampling is relatively fast. Dependent on the \n\tgeometric configuration, some of the entries have undefined values. Each \n\tentry has a corresponding comment referring to the following cases:\n\t- Case 1: The spherical cap is entirely above the horizon.\n\t- Case 2: The spherical cap intersects the horizon but has its center above \n\t\tthe horizon.\n\t- Case 3: The spherical cap intersects the horizon but has its center below \n\t\tthe horizon.*/\nstruct ProjectedSphericalCap{\n\t/*! These three vectors define an orthonormal, positively oriented frame \n\t\tin which the spherical cap has its center at y-coordinate zero.\n\t\t\\note Available in cases 1, 2, 3.*/\n\tvec3 tangent;\n\tvec3 bitangent;\n\tvec3 normal;\n\t/*! The normalized vector towards the center of the spherical cap.\n\t\t\\note Available in cases 1, 2 and 3 but only used by \n\t\t\t\tcomputeProjectedSphericalCapSampleDensity().*/\n\tvec3 normalizedCenter;\n\t/*! The boundary of the spherical cap is a circle. This vector stores half \n\t\tthe extent of its axis-aligned bounding box along x and y. By \n\t\tconvention, the x-extent is negative if and only if the center of the \n\t\tspherical cap is below the horizon.\n\t\t\\note Available in cases 1, 2 and 3.*/\n\tvec2 circleHalfExtent;\n\t/*! The reciprocal of what would go into circleHalfExtent.z if it existed.\n\t\t\\note Available in case 3.*/\n\tfloat invCircleHalfExtentZ;\n\t/*! The x-coordinate of the center of the circle bounding the spherical \n\t\tcap. The y-coordinate is zero due to the choice of the local \n\t\tcoordinate-frame.\n\t\t\\note Available in cases 1 and 2.*/\n\tfloat circleCenterX;\n\t/*! Minus the z-coordinate of the center of the circle bounding the \n\t\tspherical cap, divided by half its extent along z.\n\t\t\\note Available in case 3. Then this is positive.*/\n\tfloat centerOverHalfExtentZ;\n\t/*! The distance between the origin and the plane of the circle bounding \n\t\tthe spherical cap.\n\t\t\\note Available in cases 1, 2 and 3 but only used by \n\t\t\t\tcomputeProjectedSphericalCapSampleDensity().*/\n\tfloat planeOriginDistance;\n\t/*! The plane of the circle bounding the spherical cap intersects the \n\t\tx-axis at this coordinate. It is <1.0f iff the cap is partially below \n\t\tthe horizon.\n\t\t\\note Available in cases 1, 2 and 3.*/\n\tfloat diskCutX;\n\t/*! 1.0f-diskCutX*diskCutX. This is the square of the y-coordinate of the \n\t\tlocation where the plane intersects the horizon.\n\t\t\\note Available in case 3.*/\n\tfloat squaredDiskCutY;\n\t/*! The factor by which sample points need to be scaled along the z-axis to \n\t\twarp them into the spherical cap.\n\t\t\\note Available in case 3.*/\n\tfloat scaleZ;\n\t/*! In cases 1 and 2, this is the constant sampled density, i.e. the \n\t\treciprocal of the projected solid angle. In case 3, it is a constant \n\t\tfactor that is pulled out of the computation of the probability density \n\t\tfunction. It is exactly 0.0f if the spherical cap is entirely below \n\t\tthe horizon.\n\t\t\\note Available in cases 1, 2 and 3.*/\n\tfloat densityFactor;\n\t/*! The threshold for the random number at which we need to transition from \n\t\tsampling of the cut ellipse to sampling of the cut disk. In other \n\t\twords, it is the ratio of these two areas.\n\t\t\\note Available in case 2.*/\n\tfloat cutEllipseAreaRatio;\n\t/*! The factor needed to turn a random number into a normalized area (i.e. \n\t\tfrom 0 to pi) for the cut ellipse.\n\t\t\\note Available in case 2.*/\n\tfloat randomToCutEllipseAreaFactor;\n\t/*! The factor needed to turn a random number into the area to the right of \n\t\tthe point on the cut disk that is sampled.\n\t\t\\note Available in cases 2 and 3.*/\n\tfloat randomToCutDiskAreaFactor;\n\t/*! The projected solid angle of the spherical cap. Exactly 0.0f if it is \n\t\tentirely below the horizon. Uncomment the appropriate lines in \n\t\tprepareProjectedSphericalCapSampling() if you need this. It only incurs \n\t\tan additional cost in case 3.\n\t\t\\note Available in cases 1, 2 and 3 if uncommented.*/\n\t//float projectedSolidAngle;\n};\n\n\n/*! This structure carries intermediate results that only need to be computed \n\tonce per spherical cap for sampling proportional to solid angle.*/\nstruct SphericalCap{\n\t/*! These three vectors define an orthonormal, positively oriented frame \n\t\tin which the normal points towards the center of the spherical cap and \n\t\tthe other two directions are arbitrary.*/\n\tvec3 tangent,bitangent,normal;\n\t/*! The minimal dot product between normal and a point inside the spherical\t\n\t\tcap. This is an efficient way to express the opening angle of the cap.*/\n\tfloat minimalDot;\n\t/*! The solid angle of the spherical cap in steradians.*/\n\tfloat solidAngle;\n};\n\n\n/*! Returns the signed area enclosed by the unit disk between x=0 and \n\tx=MaximalX.*/\nfloat getCutDiskArea(float maximalX){\n\treturn mad(sqrt(mad(-maximalX,maximalX,1.0f)),maximalX,asin(maximalX));\n}\n\n\n/*! Implements the inverse of getCutDiskArea().\n   \\note This implementation factors the inverse function into a part with a \n\t\t singularity and a quintic polynomial. The worst-case error is around \n\t\t 4e-6.*/\nfloat getAreaDiskCut(float area){\n\tfloat absArea=min(0.5f*M_PI,abs(area));\n\tfloat polynomial=mad(mad(mad(mad(mad(absArea,-0.0079908617f,0.0238255409f),absArea,-0.0283903598f),absArea,0.0198450184f),absArea,-0.0574433620f),absArea,0.7400712465f);\n\tfloat result=1.0f-polynomial*pow(0.5f*M_PI-absArea,2.0f/3.0f);\n\treturn (area<0.0f)?(-result):result;\n}\n\n\n/*!\tPrepares all intermediate values to sample a spherical cap proportional to \n\tprojected solid angle. The surface normal and sphere center are given in \n\tthe same space, the sphere center is relative to the surface point for \n\twhich samples are taken. The surface normal has to be normalized.\n\t\\note For directional lights sphereCenter should be a normalized direction \n\t\t\tvector towards the light source and sphereRadius should be \n\t\t\tsin(0.5f*alpha) where alpha is the angle spanned by the light \n\t\t\tsource.*/\nvoid prepareProjectedSphericalCapSampling(out ProjectedSphericalCap cap, vec3 surfaceNormal,vec3 sphereCenter,float sphereRadius){\n\tfloat invCenterDistance= 1.0 / sqrt(dot(sphereCenter,sphereCenter));\n\t// Construct a tangent frame where the normal is aligned with the positive \n\t// z-axis and the projection of the sphere center onto the surface tangent \n\t// plane is aligned with the positive x-axis.\n\tcap.normal=surfaceNormal;\n\tcap.normalizedCenter=invCenterDistance*sphereCenter;\n\tfloat normalizedCenterZ = dot(cap.normal,cap.normalizedCenter);\n\tcap.tangent = mad(-normalizedCenterZ,cap.normal,cap.normalizedCenter);\n\tfloat invTangentLength = 1.0 / sqrt(dot(cap.tangent,cap.tangent));\n\tcap.tangent*=invTangentLength;\n\tfloat normalizedCenterX=dot(cap.tangent,cap.normalizedCenter);\n\tcap.bitangent=cross(cap.normal,cap.tangent);\n\t// Compute the radius of the circle that bounds the spherical cap. It \n\t// agrees with half the diameter of the ellipse, which is also the extent \n\t// along y.\n\tcap.circleHalfExtent.y=sphereRadius*invCenterDistance;\n\t// Compute the width of the ellipse (extent along x). Negative if the \n\t// sphere center is below the horizon.\n\tcap.circleHalfExtent.x=cap.circleHalfExtent.y*normalizedCenterZ;\n\t// Compute the location of the center of the ellipse along the x-axis\n\tcap.planeOriginDistance=sqrt(mad(-cap.circleHalfExtent.y,cap.circleHalfExtent.y,1.0f));\n\tcap.circleCenterX=cap.planeOriginDistance*normalizedCenterX;\n\t// Compute where the plane of the circle bounding the spherical cap \n\t// intersects the x-axis\n\tcap.diskCutX=cap.planeOriginDistance*invTangentLength;\n\t// Case 1: The spherical cap is entirely above the horizon or maybe\n\t// case 4: The spherical cap is entirely below the horizon and thus empty\n\tif(cap.diskCutX>=1.0f){\n\t\t// The projected solid angle is an ellipse\n\t\tfloat projectedSolidAngle=M_PI*cap.circleHalfExtent.x*cap.circleHalfExtent.y;\n\t\t//cap.projectedSolidAngle=projectedSolidAngle;\n\t\tcap.densityFactor=max(0.0f,1.0f/projectedSolidAngle);\n\t\t// Set irrelevant variables to bogus values\n\t\tcap.invCircleHalfExtentZ=cap.centerOverHalfExtentZ=cap.scaleZ=cap.squaredDiskCutY=cap.cutEllipseAreaRatio=cap.randomToCutEllipseAreaFactor=cap.randomToCutDiskAreaFactor=0.0f;\n\t}\n\t// Cases 2 and 3, the spherical cap intersects the horizon\n\telse{\n\t\t// The area of the cut disk is needed for case 2 and 3\n\t\tfloat cutDiskArea=0.5f*M_PI-getCutDiskArea(cap.diskCutX);\n\t\t// Case 3, the spherical cap intersects the horizon but its center is \n\t\t// below the horizon\n\n\t\tif(cap.circleHalfExtent.x<=0.0f){\n\t\t\tfloat circleCenterZ=normalizedCenterZ*cap.planeOriginDistance;\n\t\t\tfloat circleHalfExtentZ=cap.circleHalfExtent.y*normalizedCenterX;\n\t\t\tfloat circleMaxZ=circleCenterZ+circleHalfExtentZ;\n\t\t\tcap.invCircleHalfExtentZ=1.0f/circleHalfExtentZ;\n\t\t\tcap.centerOverHalfExtentZ=-circleCenterZ*cap.invCircleHalfExtentZ;\n\t\t\tcap.squaredDiskCutY=saturate(mad(-cap.diskCutX,cap.diskCutX,1.0f));\n\t\t\tcap.scaleZ=circleMaxZ*(1.0 / sqrt(cap.squaredDiskCutY));\n\t\t\tcap.densityFactor=cap.squaredDiskCutY/(circleMaxZ*circleMaxZ*cutDiskArea);\n\t\t\tcap.randomToCutDiskAreaFactor=cutDiskArea;\n\t\t\t// Set irrelevant variables to bogus values\n\t\t\tcap.cutEllipseAreaRatio=cap.randomToCutEllipseAreaFactor=0.0f;\n\t\t\t// Optionally compute the projected solid angle. We do not need it for \n\t\t\t// sampling but it may be useful in some contexts.\n\t\t\t//float ellipseCutRatioX=-saturate(-(cap.diskCutX-cap.circleCenterX)/cap.circleHalfExtent.x);\n\t\t\t//float normalizedEllipseArea=0.5f*M_PI+getCutDiskArea(ellipseCutRatioX);\n\t\t\t//cap.projectedSolidAngle=cap.circleHalfExtent.x*cap.circleHalfExtent.y*normalizedEllipseArea+cutDiskArea;\n\t\t}\n\t\t// Case 2, the spherical cap intersects the horizon but its center is \n\t\t// above the horizon\n\t\telse{\n\t\t\t// Compute the area of the cut ellipse and the total projected solid \n\t\t\t// angle\n\t\t\tfloat ellipseCutRatioX = saturate((cap.diskCutX-cap.circleCenterX)/cap.circleHalfExtent.x);\n\t\t\tfloat normalizedEllipseArea=0.5f*M_PI+getCutDiskArea(ellipseCutRatioX);\n\t\t\tfloat cutEllipseArea=cap.circleHalfExtent.x*cap.circleHalfExtent.y*normalizedEllipseArea;\n\t\t\tfloat projectedSolidAngle=cutEllipseArea+cutDiskArea;\n\t\t\t//cap.projectedSolidAngle=projectedSolidAngle;\n\t\t\tcap.densityFactor=1.0f/projectedSolidAngle;\n\t\t\t// Prepare the decision which cut disk will be sampled\n\t\t\tcap.cutEllipseAreaRatio=cutEllipseArea*cap.densityFactor;\n\t\t\tcap.randomToCutEllipseAreaFactor=normalizedEllipseArea/cap.cutEllipseAreaRatio;\n\t\t\tcap.randomToCutDiskAreaFactor=cutDiskArea/(1.0f-cap.cutEllipseAreaRatio);\n\t\t\t// Set irrelevant variables to bogus values\n\t\t\tcap.invCircleHalfExtentZ=cap.centerOverHalfExtentZ=cap.scaleZ=cap.squaredDiskCutY=0.0f;\n\t\t}\n\t}\n\t// For points inside the light source, we treat the projected spherical cap \n\t// as empty\n\tcap.densityFactor=(cap.circleHalfExtent.y>=1.0f)?0.0f:cap.densityFactor;\n\t//cap.projectedSolidAngle=(cap.circleHalfExtent.y>=1.0f)?0.0f:cap.projectedSolidAngle;\n}\n\n\n/*! \\return true iff the given projected spherical cap is empty.*/\nbool isProjectedSphericalCapEmpty(ProjectedSphericalCap cap){\n\treturn cap.densityFactor<=0.0f;\n}\n\n\n/*! Given the output of prepareProjectedSphericalCapSampling(), this function \n\tmaps given random numbers in the range from 0 to 1 to a normalized \n\tdirection vector providing a sample of the spherical cap in the original \n\tspace (used for arguments of prepareSphericalCapSampling()). If the input \n\trandom numbers are independent and uniform, the distribution of the output \n\trandom variables has the probability density function outDensity with \n\trespect to the planar Lebesgue measure. The density is constant (i.e. \n\tindependent of the random numbers) unless the sphere center is below the \n\thorizon. Otherwise the ratio between maximum and minimum is bounded by \n\tsqrt(2).*/\n    vec3 sampleProjectedSphericalCap(out float outDensity,ProjectedSphericalCap cap, vec2 randomNumbers){\n\tfloat area;\n\tbool sampleEllipse;\n\t// If the sphere center is below the horizon, we want to sample the cut \n\t// unit disk\n\tif(cap.circleHalfExtent.x<=0.0f){\n\t\tarea=mad(randomNumbers.x,-cap.randomToCutDiskAreaFactor,cap.randomToCutDiskAreaFactor);\n\t}\n\t// If the sphere center is above the horizon but the sphere intersects it, \n\t// we need to decide whether we want to sample the cut unit disk or the cut \n\t// ellipse\n\telse if(cap.diskCutX<1.0f){\n\t\tsampleEllipse=(randomNumbers.x<cap.cutEllipseAreaRatio);\n\t\tarea=sampleEllipse?\n\t\t\t(randomNumbers.x*cap.randomToCutEllipseAreaFactor):\n\t\t\tmad(randomNumbers.x,-cap.randomToCutDiskAreaFactor,cap.randomToCutDiskAreaFactor);\n\t}\n\t// If the sphere is entirely above the horizon, we sample the ellipse\n\telse{\n\t\tarea=M_PI*randomNumbers.x;\n\t}\n\t// Sample the cut disk\n\tvec3 disk;\n\tdisk.x=getAreaDiskCut(area-0.5f*M_PI);\n\tdisk.y=sqrt(mad(-disk.x,disk.x,1.0f))*mad(randomNumbers.y,2.0f,-1.0f);\n\t// If the sphere center is below the horizon, we need to warp the samples \n\t// further and compute the density\n\tvec3 local;\n\toutDensity=cap.densityFactor;\n        \n\tif(cap.circleHalfExtent.x<=0.0f){\n\t\tdisk.x=-disk.x;\n\t\tdisk.z=sqrt(saturate(mad(-disk.x,disk.x,mad(-disk.y,disk.y,1.0f))));\n\t\t// Scale down along Z to get the appropriate maximal Z\n\t\tlocal.z=disk.z*cap.scaleZ;\n\t\t// Scale down along Y to account for the different shape of the cut disk\n\t\tfloat zQuotient=mad(local.z,cap.invCircleHalfExtentZ,cap.centerOverHalfExtentZ);\n\t\tfloat scaleY=cap.circleHalfExtent.y*sqrt(max(0.0f,mad(-zQuotient,zQuotient,1.0f)/mad(-disk.z,disk.z,cap.squaredDiskCutY)));\n\t\tlocal.y=disk.y*scaleY;\n\t\t// Turn it into a normalized vector to get X\n\t\tlocal.x=sqrt(saturate(mad(-local.y,local.y,mad(-local.z,local.z,1.0f))));\n\t\t// Compute the proper density\n\t\toutDensity*=local.x/(disk.x*scaleY);\n\t}\n\t// If the sphere center is above the horizon but the sphere intersects it, \n\t// we may be sampling the cut disk\n\telse if(cap.diskCutX<1.0f && !sampleEllipse){\n\t\tlocal.x=-disk.x;\n\t\tlocal.y=disk.y;\n\t\tlocal.z=sqrt(saturate(mad(-local.x,local.x,mad(-local.y,local.y,1.0f))));\n\t}\n\t// Otherwise we are sampling the ellipse (either the cut ellipse or the \n\t// entire ellipse, it does not make a difference here)\n\telse{\n\t\tlocal.x=mad(disk.x,cap.circleHalfExtent.x,cap.circleCenterX);\n\t\tlocal.y=cap.circleHalfExtent.y*disk.y;\n\t\tlocal.z=sqrt(saturate(mad(-local.x,local.x,mad(-local.y,local.y,1.0f))));\n\t}\n\t// Go back to the original coordinate frame\n\treturn local.x*cap.tangent+local.y*cap.bitangent+local.z*cap.normal;\n}\n\n\n/*! Given a normalized direction and a projected spherical cap, this function \n\treturns the probability density for sampleProjectedSphericalCap() returning \n\tthe given direction. In particular, it returns 0 if the given direction is \n\tnot within the spherical cap and the upper hemisphere. This functionality \n\tis useful for multiple importance sampling when the given direction has \n\tbeen produced by a different sampling technique.\n\t\\note As for sampleProjectedSphericalCap() the returned density is defined \n\t\t\twith respect to the projected solid angle measure. If you want a \n\t\t\tdensity with respect to the solid angle measure, you have to \n\t\t\tmultiply by dot(cap.normal,sampledDirection).*/\nfloat computeProjectedSphericalCapSampleDensity(vec3 sampledDirection,ProjectedSphericalCap cap){\n\t// Early out if the sample is not in the spherical cap\n\tif(dot(cap.normalizedCenter,sampledDirection)<cap.planeOriginDistance){\n\t\treturn 0.0f;\n\t}\n\t// Early out if the sample is in the lower hemisphere\n\tvec3 local;\n\tlocal.z=dot(cap.normal,sampledDirection);\n\tif(local.z<0.0f){\n\t\treturn 0.0f;\n\t}\n\t// If the sphere center is below the horizon, things are a little \n\t// complicated\n\tif(cap.circleHalfExtent.x<=0.0f){\n\t\tlocal.x=dot(cap.tangent,sampledDirection);\n\t\tlocal.y=dot(cap.bitangent,sampledDirection);\n\t\t// Reconstruct the scaling along the y-axis\n\t\tvec3 disk;\n\t\tdisk.z=local.z/cap.scaleZ;\n\t\tfloat zQuotient=mad(local.z,cap.invCircleHalfExtentZ,cap.centerOverHalfExtentZ);\n\t\tfloat scaleY=cap.circleHalfExtent.y*sqrt(max(0.0f,mad(-zQuotient,zQuotient,1.0f)/mad(-disk.z,disk.z,cap.squaredDiskCutY)));\n\t\t// Get the whole point in the disk that would have been sampled to \n\t\t// produce this sample\n\t\tdisk.y=local.y/scaleY;\n\t\tdisk.x=sqrt(saturate(mad(-disk.y,disk.y,mad(-disk.z,disk.z,1.0f))));\n\t\t// Compute the density\n\t\treturn cap.densityFactor*local.x/(disk.x*scaleY);\n\t}\n\telse{\n\t\t// Otherwise the density is constant and has already been computed\n\t\treturn cap.densityFactor;\n\t}\n}\n\n\n/*!\tPrepares all intermediate values to sample a spherical cap proportional to \n\tsolid angle. The sphere center is given relative to the surface point for \n\twhich samples are taken.*/\nvoid prepareSphericalCapSampling(out SphericalCap cap, vec3 sphereCenter,float sphereRadius){\n\tfloat invCenterDistance = 1.0 / sqrt(dot(sphereCenter,sphereCenter));\n\t// Construct a coordinate frame where z is aligned with the vector to the \n\t// sphere center\n\tcap.normal = invCenterDistance*sphereCenter;\n\tcap.tangent = normalize(cross(cap.normal,vec3(0.0f,1.0f,0.0f)));\n\tcap.bitangent=cross(cap.normal,cap.tangent);\n\t// Compute the radius of the circle that bounds the spherical cap\n\tfloat maximalRadius=sphereRadius*invCenterDistance;\n\tcap.minimalDot=sqrt(saturate(mad(-maximalRadius,maximalRadius,1.0f)));\n\tcap.solidAngle=mad(-cap.minimalDot,M_PI2,M_PI2);\n}\n\n\n/*! Maps independent, uniform random numbers from 0 to 1 to world space samples \n\tin the given spherical cap. Samples are distributed in proportion to solid \n\tangle.\n\t\\param cap The output of prepareProjectedSphericalCapSampling().\n\t\\return The sampled direction in world space.*/\n\tvec3 sampleSphericalCap(SphericalCap cap, vec2 randomNumbers){\n\tvec3 local;\n\tlocal.z = lerp(cap.minimalDot,1.0f,randomNumbers.x);\n\t// Complete to a point on the sphere\n\tfloat radius=sqrt(saturate(mad(-local.z,local.z,1.0f)));\n\tlocal.x=radius*cos(M_PI2*randomNumbers.y);\n\tlocal.y=radius*sin(M_PI2*randomNumbers.y);\n\t// Now turn that into a world space sample\n\treturn local.x*cap.tangent+local.y*cap.bitangent+local.z*cap.normal;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[838, 935, 948, 948, 991], [1031, 1149, 1209, 1209, 1302], [1304, 1355, 1415, 1415, 1555], [1632, 1632, 1655, 1655, 1745], [1747, 1747, 1874, 1874, 1982], [1984, 1984, 2154, 2154, 2285], [2287, 2287, 2318, 2318, 2469], [2471, 2510, 2541, 2541, 2927], [3612, 3650, 3741, 3741, 4177], [4179, 4179, 4286, 4286, 4653], [4655, 4655, 4744, 4744, 5065], [5067, 5067, 5136, 5136, 5503], [5505, 5505, 5616, 5616, 5983], [5985, 5985, 6024, 6024, 6217], [6219, 6219, 6237, 6237, 8276], [8278, 8357, 8433, 8433, 8723], [8725, 8725, 8899, 8899, 11302], [11304, 11304, 11432, 11432, 12360], [12362, 12362, 12490, 12490, 13372], [13375, 13375, 13544, 13544, 14169], [14171, 14171, 14339, 14339, 15617], [15619, 15619, 15772, 15772, 17725], [17971, 17971, 18100, 18100, 18460], [18543, 18625, 18703, 18703, 18811], [18813, 18813, 18911, 18911, 18991], [18993, 18993, 19083, 19083, 19233], [19235, 19235, 19282, 19282, 19524], [19526, 19526, 19581, 19581, 19835], [19837, 19837, 19912, 19912, 20055], [20057, 20057, 20133, 20133, 20252], [20254, 20254, 20306, 20306, 20434], [20436, 20508, 20653, 20653, 20907], [21552, 21552, 21609, 21609, 21859], [21861, 21861, 21947, 21991, 22196], [22198, 22198, 22236, 22236, 22275], [22277, 22277, 22313, 22313, 22360], [22362, 22362, 22446, 22446, 22825], [22827, 22827, 22917, 22917, 23671], [23673, 23673, 23711, 23711, 23893], [26844, 26844, 26881, 26881, 27411]], "test": "untested"}
{"id": "tsscRB", "name": "Dying light", "author": "rrrzzz", "description": ".", "tags": ["shadow", "light", "minimalism"], "likes": 3, "viewed": 249, "published": 3, "date": "1585075024", "time_retrieved": "2024-07-30T21:16:59.433597", "image_code": "#define PI 3.1415926535897932384626433832795\n#define TWO_PI 6.283185307179586476925286766559\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.x;     \n    //0.02 - 0.4\n\n    \n    float stp = smoothstep(0.0, 1.0, mod(iTime / 20.0 , 2.0));\n    float dis = (1.0 - stp) * 0.38 + 0.009;\n    \n\n   //if (dis < 0.01) dis = 0.01;\n\n    \n    float currentDegree = TWO_PI * mod(iTime/4.0, 1.0);\n    float x = cos(currentDegree) * dis;\n    float y = sin(currentDegree) * dis;\n    \n    //0.7 - 20.0\n    stp = smoothstep(0.0, 1.0, mod(iTime / 40.0 , 1.0));\n    float lght = stp * 20.3 + 0.7;\n    float pct = pow(distance(st,vec2(0.4)), distance(st,vec2(x + 0.4, y + 0.4))*lght);\n\n    \n    vec3 color = vec3(pct);\n    float m = smoothstep(0.0, 0.01, stp);\n\tcolor = vec3(mix(1.0, pct, m));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsscRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 149, 149, 852]], "test": "untested"}
{"id": "wdlyzS", "name": "Cellular 0.3", "author": "etch4sketch", "description": "added a petri dish", "tags": ["distancefield"], "likes": 2, "viewed": 430, "published": 3, "date": "1585067961", "time_retrieved": "2024-07-30T21:17:00.287314", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Scale\n    st *= 30.0;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    \n    \n    vec2 point = random(i_st);\n    \n          \n    float m_dist = 0.80;  // minimum distance\n   \n    //loop over neighbour for nearest\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime/1.5 + 6.99999 * point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, sqrt(dist));\n        }\n    }\n    \n    //tweak lighting\n    \n    m_dist += 0.1;\n    \n    //urgh at this hard coding\n      \n    float circ = smoothstep(0.675, 0.695, 1.0 - circle(uv, aspect));\n    \n    float circ2 = smoothstep(0.69, 0.695, 1.0 - circle(uv, aspect)) - smoothstep(0.70, 0.7050, 1.0 - circle(uv, aspect));\n      \n    float circ3 = smoothstep(1.0 - 0.68,1.0 - 0.67,circle(uv, aspect));\n\n    \n    vec3 color = vec3(m_dist + 0.05,m_dist, m_dist);\n    \n    \n    color *= circ;\n    color -= 0.2 * circ2;\n    \n    color += circ3;   \n        \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "vec2 random (in vec2 _st) {\n    _st = vec2(dot(_st, vec2(12.9898,78.233)), dot(_st, vec2(13.9898,124.233)));\n    return fract(sin(_st)* 43758.5453123);\n}\n\n\n\nfloat circle(in vec2 _uv, in float _aspect){\n    float dist = length(vec2(_uv.x * _aspect, _uv.y) - vec2(0.5 * _aspect, 0.5));\n\treturn dist;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1656]], "test": "untested"}
{"id": "tdlcRS", "name": "\"That's all folks\" effect", "author": "GabrielFelix", "description": "Looney tunes effect", "tags": ["begginer", "looneytunes"], "likes": 3, "viewed": 337, "published": 3, "date": "1585061501", "time_retrieved": "2024-07-30T21:17:01.145021", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float distance = length(uv);\n    float radius = tan(iTime);\n    \n    float result = smoothstep(radius, radius + 1.5, distance);\n    \n    // Output to screen\n    fragColor = vec4(0, 0, tan(result * iTime) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 425]], "test": "untested"}
{"id": "WssyzB", "name": "SpeedyLines", "author": "GabrielFelix", "description": "trigonometric functions are awesome", "tags": ["beginner", "lines", "red"], "likes": 1, "viewed": 267, "published": 3, "date": "1585057194", "time_retrieved": "2024-07-30T21:17:02.071544", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n \n    // Output to screen\n    fragColor = vec4(tan(iTime * uv.y), 0., 0., 1.0);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 238]], "test": "untested"}
{"id": "3dscRS", "name": "Starfield165", "author": "brechrt", "description": "starfield", "tags": ["starfield"], "likes": 5, "viewed": 401, "published": 3, "date": "1585056933", "time_retrieved": "2024-07-30T21:17:02.946206", "image_code": "uint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { \n    return hash( v.x ^ hash(v.y)); \n}\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\nfloat random( vec2  v ) { \n    return floatConstruct(hash(floatBitsToUint(v)));\n}\nmat2 rot(float a){\n\tfloat s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat star(vec2 uv, float flar){\n\tfloat d = length(uv);\n    float m = .05/d;\n    m *= m;\n    \n    float ray = max(0., 1.-abs(uv.x*uv.y*5000.));\n    m += ray*flar;\n    \n    uv *= rot(atan(1.));\n    ray = max(0., 1.-abs(uv.x*uv.y*5000.));\n    m += ray*flar;\n    \n    m *= smoothstep(1., .2, d);\n\n    return m;\n}\nvec3 starLayer(vec2 uv){\n\tvec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    vec3 col = vec3(0);\n    \n    for(float x = -1.; x <= 1.; x++){\n        for(float y = -1.; y <= 1.; y++){\n            vec2 off = vec2(x, y);\n\t    \tvec2 roff = vec2(random(id+off), random(id+off+vec2(243.23, 882.23)));\n            float size = fract(random(id+off)*68321.7829);\n    \t\tfloat star = star(gv-off-roff, smoothstep(.7, 1., size)*.5);\n            \n            vec3 color = sin(vec3(.2, .3, .8)*fract(size*3219.329)*214767.)*.5+.5;\n            color *= vec3(1., .5, 1.+size);\n            col += star*size*size*color;\n    \t\t\n        }\n    }\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n   \tfloat t = iTime*.1;\n    vec3 col = vec3(0);\n    float maxLayer = 7.;\n    \n    uv *= rot(t);\n    for(float i = 0.; i < 1.; i += 1./maxLayer){\n        float depth = fract(i+t);\n        \n        float scale= mix(10., 5., depth);\n        float fade = depth*smoothstep(1., .8, depth);\n    \tcol += starLayer(uv*scale+i*274.23)*fade;\t\n    }\n    \n   \n    \n    \n    \n    //if(gv.x > .98 || gv.y > .98) col = vec3(1., 0., 0.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dscRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 152], [153, 153, 175, 175, 214], [216, 216, 248, 248, 668], [669, 669, 694, 694, 750], [751, 751, 769, 769, 847], [849, 849, 881, 881, 1158], [1159, 1159, 1183, 1183, 1804], [1805, 1805, 1862, 1862, 2377]], "test": "untested"}
{"id": "WslyzB", "name": "Something go wrongv2", "author": "Arseny", "description": "3d", "tags": ["raymarching"], "likes": 2, "viewed": 329, "published": 3, "date": "1585056375", "time_retrieved": "2024-07-30T21:17:03.946531", "image_code": "// template copied form inigo quilez - iq/2019\n\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n\n\n#define AA 2\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdOct(in vec3 p){\n    //vec3 n = normalize(vec3(1. / 3.));\n    return dot(vec3(0.57735), abs(p)) - 0.057735;\n    //return dot(vec3(1.), p) - r;\n}\n\nfloat sdTransOct(in vec3 p, in float a, in float b, in float h){\n    vec3 n = normalize(cross(vec3(a, 0, 0) - vec3(0, 0, b), vec3(0, h, 0) - vec3(0, 0, b)));\n    return dot(n, abs(p)) - a * n.x;\n}\n\nfloat sdKunai(in vec3 p, in float fl, in float bl, in float w, in float h, in float sh){\n    p.xy = abs(p.xy);\n    vec3 A = vec3(0, h, sh);\n    vec3 B = vec3(0, 0, fl);\n    vec3 C = vec3(w, 0, 0);\n    vec3 n = normalize(cross(B - A, C - A));\n    //float d1 = dot(n, p) - fl * n.z;\n    //float d1 = (p.z < fl) ? dot(n, p) - fl * n.z : 0.;\n    float d1 = dot(n, p) - fl * n.z;\n    vec3 D = vec3(0, 0, -bl);\n    n = normalize(cross(C - A, D - A));\n    //d1 = (p.z > -bl) ? max(d1, dot(n, p) + bl * n.z) : d1;\n    d1 = max(d1, dot(n, p) + bl * n.z);\n    d1 = (p.z < sh) ? mix(smin(d1, length(p.xy), 0.04), d1, p.z - sh) : d1;\n    return d1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdKunaiHandle(in vec3 p, in float k, in float w, in float r){\n    p.yz = p.zy;\n    float y = p.y;\n    p.y = (y>0.&&y< k * w)?fract(p.y / w) * w - w / 2.:y - w / 2.;\n    p.y = (y>k * w)?y-k * w - w / 2.:p.y;\n    //if (y < 0.) return y;\n    return sdTorus(p, vec2(r, w));\n}\n\n//float sdTransOct(in vec3 p, in vec3\n\nvec4 map( in vec3 p, float time )\n{\n    //float d = sdOct( p * 1.1) / 1.1;\n    //float d = sdTransOct(p, 0.1, 0.3, 0.1);\n    //float d = sdKunai(p, 0.4, 0.1, 0.1, 0.03, 0.05);\n    //float d = sdTorus(p, vec2(0.2, 0.1));\n    float d = sdKunaiHandle(-p + vec3(0, 0, 0.01), 20., 0.01, 0.02);\n    d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    //d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    d = min(d, length(p.xy));\n    //float d = sdSphere( p, 0.1 );\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    float tmax = 2.0;\n    float t    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 10.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        if( h.x<0.0001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/30.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        vec3 ro = ta + vec3( 0.5*cos(an), 0.5, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            col = 0.5 + 0.5*nor;\n        }\n        \n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 156, 156, 249], [251, 251, 292, 292, 318], [320, 320, 343, 384, 471], [473, 473, 537, 537, 669], [671, 671, 759, 759, 1309], [1311, 1311, 1344, 1344, 1409], [1411, 1411, 1478, 1478, 1688], [1729, 1729, 1764, 1948, 2260], [2290, 2290, 2337, 2337, 2546], [2548, 2548, 2605, 2605, 2870], [2872, 2872, 2947, 2947, 3258], [3260, 3260, 3317, 3317, 3578], [3580, 3580, 3632, 3632, 3809]], "test": "untested"}
{"id": "WsscRB", "name": "Nine Point Conic", "author": "mla", "description": "We've had the nine point circle: [url]https://www.shadertoy.com/view/tsfcDr[/url], this is the nine point conic, described by Maxime Bôcher in 1892. Also see the eleven point conic: [url]https://www.shadertoy.com/view/lt2BD3[/url].\n\nMouse selects P.", "tags": ["conic", "ninepoint"], "likes": 8, "viewed": 342, "published": 3, "date": "1585052569", "time_retrieved": "2024-07-30T21:17:04.873053", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Nine Point Conic\n// Matthew Arcus, 2020.\n//\n// Given a triangle ABC and a point P, can draw a conic between:\n// The midpoints of the triangle sides\n// The midpoints of the lines from P to each vertex\n// The points where these lines cut the sides of the triangle\n//\n// Mouse controls position of P.\n//\n// First described by Maxime Bôcher in 1892.\n//\n// The conic changes from ellipse to hyperbola when it crosses one of\n// the extended triangle sides, and becomes a circles when P coincides\n// with the orthocentre (intersection of altitudes - the cyan lines).\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// The midpoint between p and q (also conjugate with point at infinity)\nvec3 midpoint(vec3 p, vec3 q) {\n  return p*q.z + p.z*q;\n}\n\nfloat distance2(vec3 p, vec3 q) {\n  p /= p.z; q /= q.z;\n  return abs(dot(p-q,p-q));\n}\n\n// Perpendicular bisector (a line)\nvec3 bisector(vec3 p,vec3 q) {\n  // (p-r).(p-r) = (q-r).(q-r) // r equidistant from p and q\n  // pp - 2pr + rr = qq - 2qr + rr\n  // pp - qq = 2pr - 2qr\n  // 2r.(p-q) = pp - qq\n  p /= p.z; q /= q.z;\n  return vec3(2.0*(p.xy-q.xy),dot(q,q)-dot(p,p));\n}\n\n// Drop perpendicular from p onto line q.\nvec3 perpendicular(vec3 p, vec3 q) {\n  // (p + kq.xy).q = 0\n  // p.q + k(q.yx).q = 0\n  float k = dot(p,q)/dot(q.xy,q.xy);\n  return p - k*vec3(q.xy,0);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 solve(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  vec3 p4a = p*p4;\n  float a = p4a.x, b = p4a.y, c = p4a.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  mat3 res = transpose(p)*m*p;\n  return res;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z; // normalize\n  vec3 pa = p-q;\n  vec3 ba = r-q;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  float d = length(pa-h*ba);\n  return d;\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nfloat circle(vec3 p, vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return conic(p,mat3(1,0,-q.x,\n                      0,1,-q.y,\n                     -q.x,-q.y,dot(q.xy,q.xy)-r2));\n}\n\nfloat quad(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n  float t = 1e8;\n  t = min(t,segment(p,a,b));\n  t = min(t,segment(p,b,c));\n  t = min(t,segment(p,c,d));\n  t = min(t,segment(p,d,a));\n  return t;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvoid getmin(inout float d, inout int index, int i, float t) {\n  if (t < d) { d = t; index = i; }\n}\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,0,1),\n         vec3(0,0.8,0),\n         vec3(0,1,1),\n         vec3(0.8),\n         vec3(1,0,1),\n         vec3(1,1,1)\n         );\n\nvec3 getcol(int i) {\n  return colors[i];\n}\n\nvec3 diagram(vec3 p, vec3 P) {\n  vec3 pcol = vec3(0.3);\n  float lwidth = 0.005;\n  float dwidth = 1.5*fwidth(p.x/p.z);\n  float pwidth = 0.03;\n  // The triangle (P is parameter)\n  vec3 A = vec3(1.0,1.0,1), B = vec3(-1.5,-0.5,1), C = vec3(1,-1,1);\n  vec3 AB = join(A,B), BC = join(B,C), CA = join(C,A);\n  vec3 PA = join(P,A), PB = join(P,B), PC = join(P,C);\n  vec3 mBC = midpoint(B,C), mCA = midpoint(C,A), mAB = midpoint(A,B);\n  vec3 mPA = midpoint(P,A), mPB = midpoint(P,B), mPC = midpoint(P,C);\n  vec3 aA = join(PA,BC), aB = join(PB,CA), aC = join(PC,AB);\n  vec3 pA = perpendicular(A,BC);\n  vec3 pB = perpendicular(B,CA);\n  vec3 pC = perpendicular(C,AB);\n  vec3 H = join(join(A,pA),join(B,pB));\n  mat3 X = solve(mAB,mBC,mCA,mPA,mPB);\n\n  vec3 bA = bisector(A,B);\n  vec3 bB = bisector(B,C);\n  // Intersect at the circumcentre\n  vec3 O = join(bA,bB);\n  // centre of the circumcircle.\n  vec4 C1 = vec4(O,distance2(O,A));\n  \n  float d = 1e8;\n  int index = -1;\n  getmin(d,index,0,line(p,AB));\n  getmin(d,index,0,line(p,BC));\n  getmin(d,index,0,line(p,CA));\n\n  getmin(d,index,1,line(p,PA));\n  getmin(d,index,1,line(p,PB));\n  getmin(d,index,1,line(p,PC));\n\n  getmin(d,index,4,line(p,A,pA));\n  getmin(d,index,4,line(p,B,pB));\n  getmin(d,index,4,line(p,C,pC));\n\n  if (false) {\n    getmin(d,index,3,quad(p,mAB,mCA,mPC,mPB));\n    getmin(d,index,3,quad(p,mBC,mAB,mPA,mPC));\n    getmin(d,index,3,quad(p,mCA,mBC,mPB,mPA));\n  }\n  getmin(d,index,2,conic(p,X));\n  getmin(d,index,5,circle(p,C1));\n\n  vec3 col = vec3(1,1,0.8);  \n  col = mix(0.9*getcol(index),col,smoothstep(lwidth,lwidth+dwidth,d));\n  d = 1e8;\n  getmin(d,index,0,point(p,P));\n\n  getmin(d,index,0,point(p,A));\n  getmin(d,index,0,point(p,B));\n  getmin(d,index,0,point(p,C));\n\n  getmin(d,index,0,point(p,mBC));\n  getmin(d,index,0,point(p,mCA));\n  getmin(d,index,0,point(p,mAB));\n\n  getmin(d,index,0,point(p,mPA));\n  getmin(d,index,0,point(p,mPB));\n  getmin(d,index,0,point(p,mPC));\n  \n  getmin(d,index,0,point(p,aA));\n  getmin(d,index,0,point(p,aB));\n  getmin(d,index,0,point(p,aC));\n\n  getmin(d,index,0,point(p,H));\n  \n  col = mix(pcol,col,smoothstep(pwidth,pwidth+dwidth,d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 2.0;\n  vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1.0);\n  vec3 P = iMouse.x <= 0.0 ? vec3(-0.1,-0.1,1)\n    : vec3(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y,1);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsscRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1245, 1365, 1392, 1392, 1415], [1417, 1489, 1520, 1520, 1546], [1548, 1548, 1581, 1581, 1633], [1635, 1670, 1700, 1845, 1919], [1921, 1963, 1999, 2047, 2115], [2117, 2305, 2356, 2463, 2753], [2755, 2866, 2923, 2988, 3344], [3531, 3531, 3560, 3560, 3643], [3645, 3645, 3673, 3673, 3718], [3720, 3720, 3756, 3756, 3786], [3788, 3788, 3827, 3827, 3999], [4001, 4001, 4030, 4030, 4162], [4164, 4164, 4194, 4264, 4430], [4432, 4432, 4484, 4484, 4631], [4817, 4817, 4878, 4878, 4915], [5121, 5121, 5141, 5141, 5163], [5165, 5165, 5195, 5195, 7302], [7304, 7304, 7357, 7357, 7638]], "test": "untested"}
{"id": "tsfyRB", "name": "Light interaction with interface", "author": "Zavie", "description": "Inspired by Fabrice Neyret's https://www.shadertoy.com/view/4sSBRd\nThis shader demonstrates how light reflection and refraction stem from wave interference.\n\nClick and drag to change the direction of the incoming wave.", "tags": ["reflection", "refraction", "interference", "photon", "huygens", "wavepropagation"], "likes": 23, "viewed": 10664, "published": 3, "date": "1585049250", "time_retrieved": "2024-07-30T21:17:06.002036", "image_code": "/*\n\nThis shader illustrates how an electromagnetic wave reflects\nand refracts at an interface. It was used as an illustration\nin the talk at Revision 2020, \"Implementing a Physically\nBased Shading without locking yourself in\" :\n\nhttps://bit.ly/2IZqYET\n\nThe directions of the reflected and refracted waves are not\nhard coded, but instead a consequence of the interferences\nat the interface.\n\nThe shader is inspired by Fabrice Neyret's\nhttps://www.shadertoy.com/view/4sSBRd\n\n--\nZavie\n\n*/\n\n\n// Settings:\n#define SHOW_INCIDENT_WAVE 1\n#define SHOW_REFLECTED_WAVE 1\n#define SHOW_TRANSMITTED_WAVE 1\n\n#define NUMBER_OF_SAMPLES 256\n#define WAVE_LENGTH 32 // Wave length, in pixels\n#define ENABLE_ROUGHNESS 1\n#define ENABLE_DISTANCE_ATTENUATION 1 // Not sure which is correct. :-/\n#define ENABLE_WAVE_HIGHLIGHTING 0 // Doesn't work yet.\n\n// Index of refraction of both media:\n#define N1 1.0\n#define N2 1.5\n\n// Color to distinguish the two media:\n#define bgColor vec3(0.05, 0.2, 0.4)\n#define matColor vec3(0.4, 0.2, 0.05)\n\n// Colors to distinguish incident, reflected and\n// transmitted waves:\n#define iColor vec3(1.0, 0.8, 0.6)\n#define rColor vec3(1.0, 0.2, 0.1)\n#define tColor vec3(1.0, 0.7, 0.0)\n\n#define PI acos(-1.)\n\n// ---8<---------------------------------------------------------\n// Implementation starts here.\n\nfloat getHeight(float x)\n{\n    float a = texture(iChannel0, vec2(x+0.5, 0.)).r;\n#if ENABLE_ROUGHNESS\n    float roughness = smoothstep(1., 0., abs(x * 2. - 1.));\n    roughness *= roughness;\n#else\n    float roughness = 0.;\n#endif\n    float h = ((a-0.5)*0.2*roughness + 0.5);\n    return h * iResolution.y/iResolution.x;\n}\n\nfloat getWave(float d, float t, float waveLength, float speed, float phase)\n{\n    float x = (d - t*speed + phase);\n#if ENABLE_WAVE_HIGHLIGHTING\n    float intensity = pow(fract(x), 5.);\n#else\n    float intensity = 1.;\n#endif\n    return sin(2. * PI * x / waveLength) * intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n\n    float height = getHeight(uv.x);\n    float fAbove = smoothstep(-0.001, 0.001, uv.y-height);\n    bool isAbove = (fAbove > 0.5);\n    float t = iTime * 50. / iResolution.x;\n\n    // Incoming wave:\n    vec2 sourceDirection = iMouse.xy / iResolution.xy - vec2(0.5, 0.);\n    vec2 sourcePosition = 0.5 + 100. * normalize(sourceDirection);\n    float iWave = 0.;\n#if SHOW_INCIDENT_WAVE\n    if (isAbove)\n    {\n    \tfloat iWaveLength = float(WAVE_LENGTH) / iResolution.x / N1;\n    \tiWave += getWave(length(uv - sourcePosition), t, iWaveLength, 1./N1, 0.) * fAbove;\n    }\n#endif\n\n    // Reflected and transmitted waves:\n    float rWave = 0.;\n    float tWave = 0.;\n    for (int i = 0; i < NUMBER_OF_SAMPLES; ++i)\n    {\n        float x = float(i) / max(1., float(NUMBER_OF_SAMPLES-1));\n        float y = getHeight(x);\n\n        vec2 p = vec2(x, y);\n        float di = length(p - sourcePosition) * N1;\n        float drt = length(uv - p);\n\n#if ENABLE_DISTANCE_ATTENUATION\n\t    float attenuation = drt;\n#else\n    \tfloat attenuation = 0.1;\n#endif\n\n#if SHOW_REFLECTED_WAVE\n        if (isAbove)\n        {\n\t        float rWaveLength = float(WAVE_LENGTH) / iResolution.x / N1;\n            rWave += getWave(drt, t, rWaveLength, 1./N1, di/N1) * fAbove / attenuation;\n        }\n#endif\n#if SHOW_TRANSMITTED_WAVE\n        if (!isAbove)\n        {\n    \t    float tWaveLength = float(WAVE_LENGTH) / iResolution.x / N2;\n\t        tWave += getWave(drt, t, tWaveLength, 1./N2, di/N2) * (1.-fAbove) / attenuation;\n        }\n#endif\n    }\n    rWave /= float(NUMBER_OF_SAMPLES);\n    tWave /= float(NUMBER_OF_SAMPLES);\n\n    vec3 color = mix(matColor, bgColor, fAbove);\n    color = mix(color, iColor, clamp(iWave, 0., 1.));\n    color = mix(color, rColor, clamp(rWave, 0., 1.));\n    color = mix(color, tColor, clamp(tWave, 0., 1.));\n\n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1309, 1309, 1335, 1335, 1627], [1629, 1629, 1706, 1706, 1908], [1910, 1910, 1967, 2017, 3970]], "test": "untested"}
{"id": "WdsyRS", "name": "Sunset2 with Ocean Sound", "author": "mrmcsoftware", "description": "After seeing a tutorial video by Inigo Quilez years ago I was inspired to modify his sunset shader (covered in the tutorial) to add swaying palm fronds.  I used a shadertoy-like program I wrote in order to do it.  So, years later here it is in shadertoy.", "tags": ["procedural", "2d", "sound", "sunset", "ocean", "painting", "palmtree", "asmr", "vacation", "swaying"], "likes": 2, "viewed": 387, "published": 3, "date": "1585036924", "time_retrieved": "2024-07-30T21:17:06.773971", "image_code": "// Original image code by inigo quilez - iq ( https://www.shadertoy.com/view/XssSRX )\n//     but modified by me (Mark Craig) to add swaying palm fronds and ocean sound\n// Inigo's comment header:    \n   // Created by inigo quilez - iq/2014\n   // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   // The final product of some live coding improv. The process is live narrated in this \n   // video: https://www.youtube.com/watch?v=0ifChJ0nJfM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = p - vec2(0.33,0.7);\n\t\t\n\tvec3 col = mix( vec3(1.0,0.3,0.0), vec3(1.0,0.8,0.3), sqrt(p.y) );\n\t\n\t// was: float r = 0.2 + 0.1*cos( atan(q.y,q.x)*10.0 + 20.0*q.x + 1.0);  // my change:\n    \tfloat r = 0.2 + 0.1*cos( atan(q.y,q.x)*10.0 + (20.0+(sin(iTime*2.0)*2.0))*q.x + 1.0);\n\n\tcol *= smoothstep( r, r+0.01, length( q ) );\n\n\tr = 0.015;\n\tr += 0.002*sin(120.0*q.y);\n\tr += exp(-40.0*p.y);\n    col *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x-0.25*sin(2.0*q.y))))*(1.0-smoothstep(0.0,0.1,q.y));\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "// ocean sound by reinder https://www.shadertoy.com/view/4tjGRh\n//----------------------------------------------------------------------\n//\n//----------------------------------------------------------------------\n// Wind function by Dave Hoskins https://www.shadertoy.com/view/4ssXW2\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nvec2 Hash( vec2 p) {\n    return vec2( hash(p.x), hash(p.y) );\n}\n\n//--------------------------------------------------------------------------\nvec2 Noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n//--------------------------------------------------------------------------\nvec2 FBM( vec2 p ) {\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 2.32;\n\tf += 0.2500  * Noise(p); p = p * 2.23;\n\tf += 0.1250  * Noise(p); p = p * 2.31;\n    f += 0.0625  * Noise(p); p = p * 2.28;\n    f += 0.03125 * Noise(p);\n    return f;\n}\n\n//--------------------------------------------------------------------------\nvec2 Wind(float n) {\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\n    \n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\n    \n\treturn noise;\n}\n\n//----------------------------------------------------------------------\n\n\n\nvec2 mainSound( in int samp,float time) {\n    //16 - 38\n //   time -= 7.5;\n    time *= .7;\n    float vol = 1.-smoothstep(6.,8.5, time);\n    vol += smoothstep(16.5,20., time);\n    vol *= 1.-smoothstep(23.5,25.5, time);\n    vol += smoothstep(47.5,51.5, time);\n    vol = vol*.8+.2;\n    \n\treturn Wind(time*.05) * vol;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyRS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[478, 478, 535, 535, 1103]], "test": "untested"}
{"id": "wsXczB", "name": "Thunderlight", "author": "wyatt", "description": "Lightning simulation", "tags": ["lightning"], "likes": 47, "viewed": 1229, "published": 3, "date": "1585027280", "time_retrieved": "2024-07-30T21:17:08.124361", "image_code": "// Fork of \"Physarum testy test\" by wyatt. https://shadertoy.com/view/wsXyzB\n// 2020-03-24 05:18:34\n\nMain {\n    vec4 b = B(U), a = A(U);\n\tQ = b.zzzz;\n    //Q = vec4(1)*smoothstep(1.,0.,length(U-a.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(mod((U),R)),0)\n#define B(U) texture(iChannel1,U/R)\n#define C(U) texture(iChannel2,U/R)\n#define D(U) texture(iChannel3,U/R)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define T(U) A((U)-dt*A(U).xy)\n#define NeighborhoodT vec4 n = T(U+vec2(0,1)), e = T(U+vec2(1,0)), s = T(U-vec2(0,1)), w = T(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define grd 0.25*vec2(e.z-w.z,n.z-s.z)\n#define grdw 0.25*vec2(e.w-w.w,n.w-s.w)\n#define div 0.25*(e.x-w.x+n.y-s.y)\n#define ro(a) mat2(cos(a),sin(-a),sin(a),cos(a))\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\n//Dave H\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy)*2.-1.;\n}", "buffer_a_code": "void X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = A(U+r);\n\tif (sg(U,n.xy,n.zw)<sg(U,Q.xy,Q.zw)) Q=n;\n}\nvoid X (inout vec4 Q, vec2 U, float r) {\n\t X(Q,U,vec2(r,0));\n     X(Q,U,vec2(0,r));\n     X(Q,U,vec2(0,-r));\n     X(Q,U,vec2(-r,0));\n}\nMain {\n\tQ = A(U);\n    X(Q,U,1.);\n    X(Q,U,2.);\n    X(Q,U,3.);\n    float b = B(Q.xy).z;\n    vec2 v = (Q.xy-Q.zw)+C(Q.xy).xy+1.*hash23(vec3(Q.xy,iFrame));\n    for (int x = -3; x<=3;x++) {\n    \tfor (int y = -3; y<=3; y++) {\n    \t\tvec4 n = A(Q.xy+vec2(x,y));\n            vec2 r = n.xy-Q.xy;\n            float l = length(r);\n            if (l>0.) v -= .1*r/l/l;\n    \t}\t\n    }\n\t\n\t//if (Q.x<3.){v.x=abs(v.x);}\n    if (Q.y<3.){v.y=abs(v.y);}\n    if (R.x-Q.x<3.){v.x=-abs(v.x);}\n    if (R.y-Q.y<3.){v.y=-abs(v.y);}\n    if (iMouse.z>0.)v -= normalize(Q.xy-iMouse.xy);\n    v.x += 0.01;\n\tif (length(v)>0.) v = 2.*normalize(v);\n    Q = vec4(\n        Q.xy+v,Q.xy\n    );\n    if (abs(U.y-0.5*R.y)<10.&&R.x-U.x<1.) {\n\t\tQ.xy = vec2(R.x,U.y);\n        Q.zw = Q.xy+vec2(1,0);\n\t}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = A(U)*0.99;\n    vec4 a = B(U);\n    Neighborhood;\n    Q.w = m.w;\n    Q = mix(Q,vec4(a.xy-a.zw,Q.z+1e-1,Q.w+1e-1),exp(-1.*sg(U,a.xy,a.zw)));\n\n    Init Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Neighborhood;\n    vec4 b = B(U);\n    Q.xy = 3.*m.xy+2.*grd;\n    Q.z = div;\n    Init Q = vec4(0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdXyzB", "name": "Analytical spheres", "author": "CensoredUsername", "description": "Simple demo of some analytically raytraced spheres.", "tags": ["raytracing", "phong"], "likes": 2, "viewed": 382, "published": 3, "date": "1585016526", "time_retrieved": "2024-07-30T21:17:09.114713", "image_code": "// analytical raytracing speres with phong shading and reflections\n// this is written for clarity, not for performance.\n\nconst float INFINITY = 1e20;\nconst float PI = 3.1415;\n\n// sphere locations. radius is equal to z\nconst uint SPHERE_COUNT = 10u;\nvec4 spheres[SPHERE_COUNT] = vec4[](\n    vec4(0.0, 0.0, -100.0, 100.0),\n    vec4(0.0, 0.0, 0.8, 0.8),\n    vec4(1.0, 1.0, 0.4, 0.4),\n    vec4(1.0, -1.0, 0.4, 0.4),\n    vec4(-1.0, 1.0, 0.4, 0.4),\n    vec4(-1.0, -1.0, 0.4, 0.4),\n    vec4(1.5, 0.0, 0.1, 0.1),\n    vec4(0.0, 1.5, 0.1, 0.1),\n    vec4(-1.5, 0.0, 0.1, 0.1),\n    vec4(0.0, -1.5, 0.1, 0.1)\n);\n\n// ambient, diffuse, specular, RGB\nvec3 AMBIENT = vec3(0.001);\nvec3 DIFFUSE = vec3(0.95, 0.95, 0.8) * 0.5;\nvec3 SPECULAR = vec3(0.95, 0.95, 0.8);\nfloat SHININESS = 500.;\nvec3 REFLECT = vec3(0.5);\n\n// light, RGB. light is an isentropic light as I'm lazy.\nvec3 LIGHT = vec3(1.0);\nvec3 LIGHT_DIR = normalize(vec3(0.0, -1.0, -0.5)); \n\n// random function\nfloat rand(float seed){\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\n\n// testing stuff: slightly, randomly distrubs a direction vector\nvec3 disturb(vec3 dir) {\n    vec3 noise = vec3(rand(dir.x), rand(dir.y), rand(dir.z));\n    return normalize(dir + 0.1 * noise);\n}\n\n// calculate analytic collision with the geometry.\nvec3 collide(vec3 origin, vec3 dir, out float depth) {\n    depth = INFINITY;\n    uint match;\n\n    // try colliding with the spheres, keeping the lowest depth entry\n    for (uint i = 0u; i < SPHERE_COUNT; i++) {\n        // early-z, just by projected center distance\n        vec3 s = spheres[i].xyz - origin;\n        float t = dot(dir, s);\n        if (t > depth || t < 0.0) {\n            continue;\n        }\n\n        // collision test\n        vec3 d = (dir * t - s);\n        if (length(d) > spheres[i].w) {\n            continue;\n        }\n        \n        // store any useful data for the actual collision calc\n        depth = t;\n        match = i;\n    }\n    if (depth == INFINITY) {\n        return vec3(0.);\n    }\n\n    // math\n    vec3 s = spheres[match].xyz - origin;\n    float t = depth;\n    vec3 d = (dir * t - s);\n    // this line is numerically a bit unstable due to the subtraction of two large numgers which can be close together\n    vec3 r = d - dir * sqrt(spheres[match].w * spheres[match].w - dot(d, d));\n\n    // surface normal and final depth\n    depth = length(s + r);\n    return normalize(r);\n}\n\nvec3 light_ray(vec3 orig, vec3 dir, out vec3 hit, out vec3 hit_norm) {\n    // hit something\n    float depth;\n    hit_norm = collide(orig, dir, depth);\n    hit = orig + depth * dir;\n\n    // shadow\n    float shadow_depth;\n    collide(hit, -LIGHT_DIR, shadow_depth);\n    \n    // lighting\n    vec3 light = vec3(0.0);\n    if (depth < 1e9) {\n        light += AMBIENT;\n        if (shadow_depth > 1e9) {\n            light += DIFFUSE * dot(-LIGHT_DIR, hit_norm);\n            light += SPECULAR * pow(max(0.0, dot(reflect(-LIGHT_DIR, hit_norm), dir)), SHININESS);\n        }\n    }\n    return light * LIGHT;\n}\n\nvec3 camera;\nvec3 camera_dir;\nvec3 camera_up;\nconst float AR = 1.4;\n\n// this part is identical for every pixel\nvoid setup() {\n    camera = vec3(5.0 * cos(iTime * 0.1), 5.0 * sin(iTime * 0.1), 2.);\n    camera_dir = normalize(vec3(0., 0., 1.) - camera);\n    camera_up = vec3(0., 0., 1.);\n    \n    \n    LIGHT_DIR = normalize(vec3(cos(iTime), -sin(iTime), -0.5)); \n    \n    for (uint i = 1u; i < SPHERE_COUNT; i++) {\n        spheres[i].z += 0.5 * cos(float(i) * 456.0 + iTime) + 0.5;\n    }\n}\n\nvec3 calcpixel(vec2 uv) {\n    // setup ray dir, norm vector >\n    vec3 camera_x = normalize(cross(camera_dir, camera_up));\n    // setup ray dir, norm vector ^\n    vec3 camera_y = normalize(cross(camera_x, camera_dir));\n    // final ray dir\n    vec3 ray_dir = normalize(camera_dir * AR + camera_x * uv.x + camera_y * uv.y);\n    \n    // cast ray\n    vec3 hit, hit_norm;\n    vec3 light = light_ray(camera, ray_dir, hit, hit_norm);\n    \n    // cast reflection ray\n    vec3 reflect_dir = reflect(ray_dir, hit_norm);\n    disturb(reflect_dir);\n    vec3 reflect_hit, reflect_norm;\n    vec3 reflection = light_ray(hit, reflect_dir, reflect_hit, reflect_norm);\n    \n    // cast reflection reflection ray\n    vec3 rreflect_dir = reflect(reflect_dir, reflect_norm);\n    disturb(rreflect_dir);\n    vec3 rreflect_hit, rreflect_norm;\n    vec3 rreflection = light_ray(reflect_hit, rreflect_dir, rreflect_hit, rreflect_norm);\n    \n    // I'm bored and my fps is still too high\n    vec3 rrreflect_dir = reflect(rreflect_dir, rreflect_norm);\n    disturb(rrreflect_dir);\n    vec3 rrreflect_hit, rrreflect_norm;\n    vec3 rrreflection = light_ray(rreflect_hit, rrreflect_dir, rrreflect_hit, rrreflect_norm);\n    \n\n    // assemble\n    return light + (reflection + (rreflection + rrreflection * REFLECT) * REFLECT) * REFLECT;\n}\n\nconst uint AA = 2u;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup scene parameters\n    setup();\n    \n    \n    vec3 color = vec3(0.);\n    for (uint i = 0u; i < AA; i++) {\n        for (uint j = 0u; j < AA; j++) {\n            // setup screen coord system. up = (0, 1), down = (0, -1), right = (AR, 0), left = (-AR, 0)\n            vec2 coord = fragCoord + vec2(i, j) / float(AA);\n            vec2 uv = (coord - iResolution.xy * 0.5) / iResolution.y;\n\n            color += calcpixel(uv);\n        }\n    }\n    color /= float(AA * AA);\n    \n    // gamma correct and write to output\n    fragColor = vec4(pow(color, vec3(1. / 2.2)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[931, 950, 973, 973, 1027], [1029, 1094, 1118, 1118, 1223], [1225, 1276, 1330, 1330, 2382], [2384, 2384, 2454, 2475, 2980], [3051, 3093, 3107, 3107, 3469], [3471, 3471, 3496, 3532, 4774], [4797, 4797, 4854, 4884, 5431]], "test": "untested"}
{"id": "tdfcRS", "name": "Day 96", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 15, "viewed": 495, "published": 3, "date": "1585000959", "time_retrieved": "2024-07-30T21:17:09.971422", "image_code": "// Fork of \"Day 95\" by jeyko. https://shadertoy.com/view/wssyDM\n// 2020-03-23 18:49:46\n\n// Fork of \"Day 94\" by jeyko. https://shadertoy.com/view/tdXcWM\n// 2020-03-23 10:08:54\n\n// thx to evvvvil and nusan for some of the techniques here\n// radial blur and chromatic abberation in this buffer\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),3.)*0.1;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),2.)*4.3;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*85.; \n    //fragColor.r *= 1. + uv.x*0.8;\n    //fragColor.g *= 1. + uv.y*0.7;\n    //fragColor.b *= 1. + uv.y*0.7;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.4);\n    //1fragColor *= 18.;\n    \n    \n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*0.2));\n    fragColor *= 1. - dot(uvn,uvn)*0.9\n        ;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define dmin(a,b) a.x<b.x ? a : b\n\n#define pi (acos(-1.))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n#define pmod(p,x) mod(p,x) - 0.5*x\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvec3 glow = vec3(0);\nvec3 glowb = vec3(0);\nvec3 att = vec3(1);\nfloat side = 1.;\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return length(max(p,0.0)) + min(max(p.x, max(p.y,p.z)),0.);\n}\n\n\nvec2 o(vec3 p){\n    vec2 d = vec2(10e7);\n    \n    //p.xy *= rot(0.25*pi);\n    p = abs(p);\n    float dBox = sdBox(p, vec3(0.1,0.5,0.7));\n    p.x -= 1.75;\n    float dBoxb = sdBox(p, vec3(0.08,0.8,.5));\n    \n    p = abs(p);\n    p.y -= 1.45;\n    \n    p.xy *= rot(0.5*pi);\n    float dBoxc = sdBox(p, vec3(0.16, 0.15,6.5));\n    \n    \n    p.y -= 0.4;\n    p.z -= 0.7;\n    p = abs(p);\n    \n    p.x -= 0.05;\n    p.z -= 0.15;\n    float dBoxg = max(p.x,p.z);\n\t\n    d = dmin(d, vec2(dBox, 5.));\n    d = dmin(d, vec2(dBoxb, 21.));\n    d = dmin(d, vec2(dBoxc, 7.));;\n    d = dmin(d, vec2(dBoxg, 21.));\n    \n    return d;\n}\nfloat mmmm;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\n    vec3 q = p;\n    float wave = pow(abs(sin(q.z*0.2+iTime*1.5)), 200.);\n    float waveb = pow(abs(sin( 0.75*(q.z*0.2+iTime))), 400.);\n    float modD = 32.;\n    \n    p.xz -= modD*0.5;\n    vec2 id = floor(p.xz/modD);\n    p.xz = pmod(p.xz,modD);\n    p.z -= modD*0.2;\n    \n    \n    float mt = sin(iTime*1. + id.x + sin(id.y)*0.4 + id.y*0.4);\n    mmmm = pow(abs(mt), 0.125)*sign(mt)*0.2;\n    \n    vec3 cc = vec3(0.7 + mmmm*2.,.9,0.9);\n    for(float i = 0.; i< 5.; i++){\n\n        if(i < 3.)\n        \tif(p.x < p.z) {p.xz = p.zx;}\n\n    \tp = abs(p);        \n        p.xy *= rot(0.25*pi);\n        p.x -= 1.5 ;\n        p.t -= 3.5  ;\n        p.z -= 4.5;\n        if(i == 3.){\n            vec3 z = p;\n            z += 0.4;\n            z = abs(z);\n            z -= waveb*0.2;\n            z = abs(z);\n            float dp = max(z.x,z.y) - 0.05;\n            d = dmin(d, vec2(abs(dp) + 0.01, 0.));\n            dp = max(dp, 0.);\n            vec3 ccc = pal(1.,1.,vec3(0.8,2.2,2.5),0.5,0.5 + iTime + q.z);\n            \n            \n            //glowb += 0.001/(0.001 + dp*dp*6.)*ccc*att;\n            //glowb += 0.155/(0.40 + dp*dp*dp*dp*(10000. - wave*10000.))*ccc*att;\n            //glowb += 0.155/(0.40 + dp*dp*dp*dp*(10000. - 5000.))*ccc*att;\n            glowb += 0.155/(1.80 + dp*dp*dp*dp*(10000. - 5000.))*ccc*att;\n            //glowb += 0.001/(0.001 + dp*dp*6.)*pal(0.5,0.5,vec3(0.87,0.4,0.5), 0.5,3.5 + 1.*iTime)*att;\n        \n        }\n        \n    }\n    \n    \n    float md = 0.23;\n    vec3 h = p;\n    h = pmod(h, md);\n    float dpg = sdBox(h,vec3(md*0.1));\n    //d = dmin(d, vec2(abs(dpg) + 0.2, 0.));\n    dpg = max(dpg, 0.);\n    //glowb += 0.001/(0.01 + dpg*dpg*20.)*pal(0.5,0.5,vec3(0.87,0.4,0.5), 0.5,3.5 + 0.*iTime)*att*wave;\n    glowb += 0.001/(0.01 + dpg*dpg*20.)*pal(0.5,0.5,vec3(0.87,0.4,0.5), 0.5,3.5 + 0.*iTime)*att*wave;\n    \n    \n    \n    \n    //p.x += 2.;\n    //p.x -= sin(iTime);\n    \n    vec2 dO = o(p);\n    \n    float dBall = length(p) - 0.1;\n    \n    d = dmin(d, dO);\n    \n    q = abs(q);\n    q.y -=6.;\n    \n    //d = dmin(d, vec2(abs(q.y) - 0.1, 21.));\n    d.x *= 1.;\n    d.x *= 0.7;\n    glow += exp(-max(d.x, 0.)*10.)*att*2.;\n    \n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = map(ro);\n    \n    if(d.x < 0.3)\n        ro += rd*0.05;\n    \n    hit = false; t = 0.; p = ro;\n    \n    for(float i = 0.; i< 150.; i++){\n    \td = map(p);\n        d.x *= side;\n        if(d.x < 0.0001){\n        \thit = true;\n        }\n        if(t > 40.){\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getRd(vec3 ro,vec3 lookAt,vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + (right*uv.x + up*uv.y)*0.6);\n}\nvec3 getRdIso(inout vec3 ro,vec3 lookAt,vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    \n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    ro += (right*uv.x + up*uv.y)*6.;\n\treturn dir;\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0.);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\nvec3 getNormala(vec3 p){\n\tvec2 t = vec2(0.0004,0.);\n\treturn normalize(-vec3(\n    \tmap(p - t.xyy).x - map(p + t.xyy).x ,\n    \tmap(p - t.yxy).x - map(p + t.yxy).x ,\n    \tmap(p - t.yyx).x - map(p + t.yyx).x \n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 uvn = uv;\n    uv *= 1. + dot(uv,uv)*0.7;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.xy += vec2(cos(iTime*0.6), sin(iTime*0.5)*0.1)*0.4;\n    \n    \n    float mp = 0.5;\n    ro.xy -= mp;\n    ro.x += iMouse.x/iResolution.y*mp;\n    ro.y += iMouse.y/iResolution.y*mp;\n    \n    ro.z -= 10.;\n    ro.z += iTime*5.;\n    \n    vec3 lookAt = vec3(0,0,ro.z + 3.3);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xy *= rot(-cos(iTime*0.75)*0.1);\n    \n    \n    vec3 p; float t; bool hit; float tA;\n\tfloat tF;\n    side = sign(map(ro).x);\n    vec2 d;\n    int iters = 1;\n    float fres;\n    for(int i = 0; i < iters; i++){\n        d = march(ro, rd, p, t, hit);\n        \n        if(i == 0) \n            tF = t;\n        tA = max(t, tA);\n        if(hit){\n\t\t\tvec3 n = getNormal(p)*side;\n\t\t\tvec3 l = normalize(vec3(1));\n            \n            float diff = max(dot(n,l), 0.);\n            float spec = pow(max(dot(reflect(l, -rd),n),0.), 20.);\n            fres = pow(1. - max(dot(n,-rd), 0.), 5.);\n            #define ao(j) clamp(map(p + n*j).x/j, 0., 1.)\n            #define sss(j) smoothstep(0., 1.,map(p + l*j).x/j)\n            \n            \n            float a = ao(0.4)*ao(0.1)*ao(0.2);\n            //a = max(a, 0.4);\n    \t\t\t\t        \n            vec3 lCol = vec3(0.4,0.7,1.);\n            if(d.y > 10.){\n                vec3 refl = (spec*0.05*vec3(0.2,0.1,0.4) + pow(fres, 1.)*0.09*pal(1.,1.,vec3(0.8,2.2,2.5),0.5,0.5 + dot(n, -rd) *30. + iTime))*att;\n               \n                col += refl*0.1;\n                att *= vec3(0.4,0.5,0.6)*0.1;\n            } else if(d.y > 5.){\n                \n                vec3 refl = (pow(fres, 1.) + 0.005)*0.09*pal(1.,1.,vec3(0.8,2.2,2.5),0.5,0.5 + dot(n, -rd) *30. + iTime)*att;\n                col += refl*a;\n                ro = p;\n            \tbreak;\n            } else {\n                vec3 refl = pow(fres, 1.)*2.5*pal(1.,1.,vec3(1.8,2.2,2.5),0.5,0.5 + dot(n, -rd) *0.6 + sin(iTime)*0.1 + 3.4)*att;\n                col += 6.*refl*((0.10 + diff*1.*fres)*att + spec*0.4*lCol)*att*a;\n            \tbreak;\n            }\n            #define FOG vec3(0.05 + mmmm*0.,0.10,0.28)*0.04\n            if (i == iters - 1){\n    \t\t\tcol = mix(col, FOG*att, smoothstep(0.,1.,tA*0.015));\n            }\n\n        }\n    \n    }\n    col = mix(col, FOG*0.06, pow(smoothstep(0.,1.,tF*0.025 + pow(fres,7.)*2. - 0.0), 1.4));\n    \n    \n    col += glowb*0.002;\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 350, 350, 1487]], "test": "untested"}
{"id": "WdXczB", "name": "metallic tunnel edit", "author": "veggie", "description": "just practicing", "tags": ["tunnel", "metallic"], "likes": 6, "viewed": 402, "published": 3, "date": "1584992151", "time_retrieved": "2024-07-30T21:17:10.919886", "image_code": "/*\n\n    Abstract Terrain Objects\n    ------------------------\n    \n\tRendering some abstract geometry onto some terrain in a basic sci-fi tone.\n\n\tThis was inspired by one of Mike Winkelmann's images, which I've included \n\ta link to below. The original image is nicer -- partly due to the fact that\n\tI'm restricted by realtime constraints, and possibly, because I have the\n\tartistic vision of a programmer. :D\n\t\n\tMike Winkelmann is the guy behind the amazing sci-fi flavored Beeple imagery \n\tthat appears in various corners of the internet. For anyone not familiar \n\twith his work, it's well worth the look. Shau has been putting up a few \n\tBeeple inspired shaders lately, which reminded me that I'd been meaning to\n\tdo the same.\n\n\tMost of this is pretty standard stuff: Render some sky, terrain, and some \n\tobjects, with an extra reflective pass on the objects to make them shiny.\n\tI went to the trouble to blend materials when the shiny objects were near \n\tthe terrain. That involved a little bit of fiddly mixing, which complicated \n\tthe code a little, but nothing that anyone here couldn't handle. :)\n\n\n\tOriginal Image:\n\n\t// Putting abstract geometry on terrain is a weird but common concept \n\t// amongst the graphics community, and this is a beautiful example.\n\tTRIOMETRIC - Beeple\n\thttps://twitter.com/beeple/status/848029629973749760\n\n\n\tExamples:\n// ORIGNAL SHADER https://www.shadertoy.com/view/ttXGWH I'm just practicing :)\n\n\t// One of Shau's Beeple inspired shaders.\n\tData Surge - shau\n\thttps://www.shadertoy.com/view/3dSXzm\n\n\t// Cool and qwirky. I love the rendering style.\n\t[SH16B] valley flight  - Bananaft\n\thttps://www.shadertoy.com/view/XldGR7\n\n\t// I like the rendering style of this also.\n\tRayCraft - jolle\n\thttps://www.shadertoy.com/view/tslGRX\n\n\t// Another one of Shau's. Fun to watch.\n\tXANNN - shau\n\thttps://www.shadertoy.com/view/llSfzR\n\n*/\n\n// Maximum ray distance. Analogous to the far plane.\n#define FAR 100. \n\n// More correct third pass: The reflection off the reflected surface is less\n// noticeable, so we're saving some computing power and faking it, which means\n// this is not on by default. However, if your computer can afford it, this is \n// a better option.\n//#define THIRD_PASS\n\n\n// Scene object ID. Either the Terrain object (0) or the chrome object (0).\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    //return sin( p*6.2831853 + iTime ); \n    \n}\n\n\n// Fabrice's consice, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float t){ \n\n    //return vec2(0);\n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec2(s*4., 0.);\n    \n    float a = sin(t*.11);\n    float b = cos(t*.14);\n    return vec2((a*2./2. - b*1.5/2.), b*1.7/4. + a*1.5/4.);\n    \n    //return vec2(sin(t*.15)*2.4, cos(t*.25)*1.7*.5); \n}\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(113., 57., 27.);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    //p = p*p*(3. - 2.*p);\n    p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; //p *= p*(3. - p*2.);  \n    \n    p *= p*p*(p*p*6. - p*15. + 10.); \n    \n    return dot(mat2(fract(sin(mod(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)), 6.2831853))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\nfloat fbmCam(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267; }\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec2 tri(in vec2 x){return abs(x - floor(x) - .5);} // Triangle function.\nvec2 triS(in vec2 x){return cos(x*0.2831853)*.05 + .25;} // Smooth version.\n\n// Height function layers. \nfloat h1(vec2 p){ return dot(tri(p + tri(p.yx*.1 + .0)), vec2(1)); }\nfloat h1Low(vec2 p){ return dot(triS(p + triS(p.yx*.1 + .05)), vec2(1)); }\n\n// Terrain height function. Just a few layers.\nfloat h(vec2 p) {\n    \n    float ret = 0., m = 1., a = 1., s = 0.;\n    \n    //for(int i=0; i<1; i++) {\n    \n        ret += a*h1Low(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(1.57/3.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    //}\n    \n    for(int i=1; i<5; i++) {\n        ret += a*h1(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(1.57/3.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    }\n    \n    ret /= s;\n    \n    return ret*.25 + ret*ret*ret*.75;\n\n}\n\n// The camera height function, which is a smoother version of the terrain function.\nfloat hLow(vec2 p) {\n    \n    float ret = 0., m = 1.1, a = 1.1, s = 01.;\n    for(int i=0; i<2; i++){\n        \n        ret += a*h1Low(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(2.7/2.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.5;\n        s += a;\n        a *= .7;\n    }\n    \n    ret /= s;\n    \n    return ret*.05 + ret*ret*ret*.75;\n\n}\n\n// Surface function.\nfloat surfaceFunc(vec3 q){\n    \n    // Height.\n    float sf = h(q.xz/20.);\n    \n    // Experimental way to dig out a trench.\n    sf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n    \n    return (.5 - sf)*5.;\n}\n\n// Surface function for the camera.\nfloat surfaceFuncCam(vec3 q){\n    \n    // Height.\n    float sf = hLow(q.xz/40.);\n    \n    // Experimental way to dig out a trench.\n    sf -= smax(.4 - q.x*q.x*.8, 0., 2.)*.02;\n    \n    return (.5 - sf)*3.;\n}\n\n// Toroidal distance function... Technically, a lot of these are just\n// bounds, so not exactly correct, which means shadows, glow, and other\n// things can be effected. However, they're cheaper, and you can't really\n// tell here.\nfloat distT(vec2 p){\n    \n    // Try some of the others, if you get bored enough. :)\n    \n    //return max(abs(p.x)*.866025 + p.y*.5, -p.y); // Triangle.\n    //return length(p); // Circle.\n    \n    p = abs(p);\n    return (p.x + p.y)*.7071; // Diamond.\n    //return max(p.x, p.y); // Square.\n    //return max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n    //return max((p.x + p.y)*.7071 - .4, max(p.x, p.y)); // Octagon.\n    \n}\n\n// Poloidal distance function. As mentioned above these are technically\n// bounds, but they work well enough.\nfloat distP(vec2 p){\n    \n    //return length(p); // Circle.\n    \n    p = abs(p);\n    return max((p.x + p.y)*.7071 - .26, max(p.x, p.y)); // Beveled square.\n    //return max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n    //return max(p.x, p.y); // Square.\n    \n}\n\n// Global scale, to space out the chrome objects.\nconst vec3 sc = vec3(60, 4, .725);\n\nfloat objects(vec3 p){\n    \n    \n    p.xz += sc.xz/2.;\n    \n    vec3 ip = floor(p/sc)*sc;\n    \n \n    // Repeating objects across the terrain in Z direction.\n    p.xz = vec2(p.x, p.z - ip.z) - sc.xz*.5; // Equivalent to: mod(p.xz, sc) - sc*.5;\n    // Repeating objects across the terrain in the X and Z directions.\n    //p.xz = (p.xz - ip.xz) - sc.xz*.5; // vec2(p.x, mod(p.z, sc.y)) - sc*.5;\n    \n    \n    // Obtaining the surface height at the center of the grid. This height is used\n    // to shift the object to the approximate top of the terrain.\n    float sf = surfaceFunc(ip);\n    \n    // Add the grid height to the object's Y position.\n    p.y += sf - 3.;\n    \n    // Use the object's Z position to rotate it about the XY plane. This effect looks\n    // better on a flat terrain.\n    p.xy = r2(sc.z/6. - ip.z/6.)*p.xy;\n    // Random XZ rotation, just to show it can be done.\n    //p.xz = r2((hash(ip.z) - .5)/2.)*p.xz;\n    \n    \n    const float sz = 5.;\n    const float th = .35;\n    \n    // Toroidal angle. \n    //float a = atan(p.y, p.x);\n    \n    // Toroidal distance -- The large radius part.\n    p.xy = vec2(distT(p.xy) - sz, p.z);\n    // Windows logo warp. :)\n    //p.xy = vec2(distT(p.xy) - sz + sin(a*4.)*.125, p.z);\n    \n    // Mobius-like twisting: Twisting the toroidal axis one full revolution\n    // about the poloidal plane... Yeah, it confuses me too. :) Be sure to\n    // uncomment the \"atan\" bit above.\n    //p.xz = r2(a)*p.xz;\n    \n    \n    // Poloidal distance. The smaller radius part. \n    float obj = distP(p.xz) - th/2.;\n    \n     \n    // Return the cell object.\n    return obj;\n    \n}\n\n\n// The distance function. Just some geometric objects and some terrain.\nfloat map(vec3 p){\n    \n    // Wrap everything around the path.\n    p.xy -= path(p.z);\n    \n    // The surface function. Essentially, the bumps we add to the terrain.\n    float sf = surfaceFunc(p);\n    \n    // The terrain, which we're lowering a bit.\n    float terr = p.y + .0 + sf;\n\n    // The chrome objects. \n    float obj = objects(p);\n    \n    // Store the terrain and object IDs, for sorting later.\n    objID = vec4(terr, obj, 0, 0);\n    \n    // Return the minimum distance.\n    return min(terr, obj);\n    \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break;\n        \n        t += d*.866; // Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<56; i++){\n\n        d = map(ro + rd*t);//*rDir;\n        \n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break;\n        \n        t += d*.9;\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// Bump function. \nfloat bumpSurf3D( in vec3 p, float t){\n    \n    \n    float c, c0 = 0., c1 = 0.;\n    \n    //float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    //const float bordW = .0;\n    \n    \n    // Terrain.\n    if(svObjID == 0.){// || abs(bordTx0Tx1)<bordW) {\n        \n        c0 = fbm(p.xz*8.);\n        \n        c0 = (1. - c0)/3.;\n    }\n    /*\n    // Metallic objects. The original image has a metallic bump, \n    // but I wanted to keep it smooth.\n    if(svObjID == 1.){// || abs(bordTx0Tx1)<bordW) {\n    \n        \n        c1 = (n3D(p*6.)*.66 + n3D(p*12.)*.34);\n        c1 = smoothstep(0., .1, n3D(p*3.) - .65)*c1/12.;\n        \n        //c1 = (1. - smoothstep(.05, .3, c1))/4.;\n        \n    }\n    */\n    // Used to fade the bump when objects are near one another, but\n    // I feel it's a little bit of overkill, for this particular example.\n    //c = mix(c0, c1, step(oSvObjID.y, oSvObjID.x));\n    //c = mix(c0, c1, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n    \n    c = c0;\n    \n    // Fading the bump out over distance.\n    return c/(1. + t*t*3.);\n    \n}\n\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor, float t){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p, t);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, t),\n                      bumpSurf3D(p - e.yxy, t),\n                      bumpSurf3D(p - e.yyx, t)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy, t) - bumpSurf3D(p + e.xyy, t),\n                     bumpSurf3D(p - e.yxy, t) - bumpSurf3D(p + e.yxy, t),\n                     bumpSurf3D(p - e.yyx, t) - bumpSurf3D(p + e.yyx, t))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .05, .5); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .2, 1.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 lp){\n\n    // Gradient blues, and red, or something.\n    vec3 sky = max(mix(vec3(0, .0, .0), vec3(.7, .9, 1.5), rd.y + .0), 0.)/3.; \n    \n    // Last minute contrast.\n    sky = pow(sky, vec3(1.25))*.75;\n    \n    // Horizon strip.\n    sky = mix(sky, vec3(0, .0, .0), (1. - smoothstep(-.1, .25, rd.y))*.2);\n    \n    \n\t// Blending in the sun.\n    float sun = max(dot(normalize(lp - ro), rd), 0.);\n    //sky = mix(sky, vec3(.5, 1, .5), pow(sun, 6.)*.5);\n    sky = mix(sky, vec3(0, .0, .0)*.65, pow(sun, 0.04));\n    sky = mix(sky, vec3(1, 1., 1.)*.9, pow(sun, .75));\n\n\n    // Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.0;\n    rd = normalize(rd);\n\n    // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float tt = (SC - ro.y - .65)/(rd.y + .025); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + tt*rd).xz; // UV coordinates.\n\n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n    if(tt>0.) {\n\n        float cl = fbm(.5*uv/SC);\n\n        // White clouds.\n        sky =  mix(sky, vec3(1)*vec3(0, .0, .0), smoothstep(.03, .95, cl)*\n                   smoothstep(.475, .575, rd.y*.75 + .75)*.5); \n        // Fake dark shadow. Subtle, but kind of worth doing. :)\n        sky =  mix(sky, vec3(0), smoothstep(.0, .95, cl)*fbm(7.*uv/SC)*\n                   smoothstep(.475, .575, rd.y*.5 + .5)*.1);\n\n    }\n\n    // Speckles. Not science based, but it looks intering.\n    vec3 p = (ro + rd*FAR)/1. + vec3(0, 0, iTime);\n    float st = n3D(p)*.6 + n3D(p*2.)*.4;\n    st = smoothstep(.1, .9, st - .0);\n    sky = mix(sky, vec3(.01, .0, 0.), (2. - sqrt(st))*.05);\n    \n    // The sky color.\n    return sky;\n\n}\n\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    // Object texture color.\n\n    // Contorting the texture coordinates to math the contorted scene.\n    //vec3 txP = p - vec3(path(p.z), 0.);\n    p = p - vec3(path(p.z), 0.);\n\n    // Texture value, and individual texture values.\n    vec3 tx, tx0, tx1;\n    \n    float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    const float bordW = .05;\n    \n     \n    // If we hit the terrain, or hit the region near the terrain, color\n    // it up.\n    if(svObjID==0. || abs(bordTx0Tx1)<bordW){\n        \n        // Noisy color mixing. Tweaked until it looked right.\n        vec2 q = p.xz;\n\n        float c = n2D(q)*.5 + n2D(q*3.)*.3 + n2D(q*9.)*.1;\n        c = c*c*.7 + sFract(c*4., 12.)*.3;\n        c = c*.9 + .2;\n        tx0 = mix(vec3(1, .3, .2), vec3(1, .35, .25), n2D(q*6.));\n        tx0 *= c;\n\n        float c2 = n2D(q*2.)*.6 + n2D(q*40.)*.34;\n        c2 = smoothstep(.1, .6, c2*c2);\n\n\n        tx0 = mix(tx0*vec3(.1, .8, .65).zyx, tx0, abs(n));\n        tx0 = mix(tx0, vec3(0), c2*.4);\n\n        //tx0 *= mix(vec3(1.2, .8, .6), vec3(1.2, .8, .6).yxz, -n.y*.5 + .5);\n\n        \n        /*\n        // Extra shadowing. A bit much, in this case.\n \t\t\n\t\t// Matches the terrain height function.\n        float sf = h(p.xz/20.);\n    \n        // Experimental way to dig out a trench.\n    \tsf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n        \n        tx0 *= smoothstep(-.1, .5, sf) + .5;\n        */\n        \n    }\n     \n    // If the ray hits the metallic object, or close to it, color it dark.\n    // The shininess is provided with the relective color. I used to get \n    // this wrong all the time. :)\n    if(svObjID==1. || abs(bordTx0Tx1)<bordW) tx1 = vec3(.08, .1, .12);\n    \n    \n    // Return the color, which is either the terrain color, the shiny object color,\n    // or if we're in the vicinity of both, make it a mixture of the two.\n    tx = mix(tx0, tx1, smoothstep(-bordW, bordW, bordTx0Tx1));\n   \n    \n    return tx; // Return the object color.\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float edge, float crv, float ao, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = .75/(2. + lDist*0.001 + lDist*lDist*0.0001);\n\n        // Standard diffuse term.\n        float diff = max(dot(ld, sn), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 2.);\n        float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n        \n        // Ramp up the diffuse value on the shiny geometric object. It's a cheap\n        // trick to make things look shiny.\n        if(svObjID==1.) diff *= diff*1.;\n\n        // Coloring the object, accoring to object ID,.        \n        vec3 objCol = getObjectColor(sp, sn);\n\n        \n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + .35 + fres*fres*0. + vec3(.2, .7, 1)*spec);\n        \n        \n        // Attenuation only. To save cycles, the shadows and ambient occlusion\n        // from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n    \n    // Get the sky color.  \n    vec3 sky = getSky(ro, rd, lp);\n    \n    // Smoothly blend it in, according to the FAR plane distance. Basically, we want it\n    // to fade in strongly as we hit the horizon.\n    sceneCol = mix(sceneCol, sky, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc.\n \n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = .05, occ = 0.;\n    for(int i=0; i<5; i++){\n    \n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 4., iTime*5.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.1, 0, .5);  // \"Look At\" position.\n    \n    \n    // Light position. Set in up in the sky above the horizon -- out near the far plane.\n    vec3 lp = ro + vec3(0, -1.5, 120);\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path, which is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n    // Using a smoother version of the terrain function to move the camera up and down.\n    // Alternatively, you could thread it through some Bezier points... if you're not\n    // lazy, like me. :D\n    ro.y -= surfaceFuncCam(ro.xyz);\n    lk.y -= surfaceFuncCam(lk.xyz);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.1459/2.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Warped unit direction vector, for a warped lens effect.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)* .05));\n    \n    \n    // Edge and curvature variables. Not used here.\n    float edge = 0., crv = 3.;\n\n    \n    // FIRST PASS.\n    //\n    float t = trace(ro, rd); // Trace.\n\n    // Save the object IDs after the first pass.\n    svObjID = objID.x<objID.y? 0. : 1.;\n    oSvObjID = objID;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Retrieving the normal at the hit point, plus the edge and curvature values.\n    //vec3 sn = getNormal(sp, edge, crv);\n    vec3 sn = getNormal(sp);\n    \n    // Function based bump mapping. the final value is a fade off with\n    // respect to distance.\n    sn = doBumpMap(sp, sn, .2, t/FAR);\n    \n\n    \n    // Fresnel. Handy for all kinds of aesthetic purposes. Not used here.\n    //float fr = clamp(1. + dot(rd, sn), 0., 1.);\n    \n    // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n    // right without them.\n    float sh = softShadow(sp + sn*.012, lp, 2., t); // Set to \"1.,\" if you can do without them.\n    float ao = calculateAO(sp, sn);\n    sh = (sh + ao*.3)*ao;\n    \n\n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, sp, rd, sn, lp, edge, crv, ao, t);\n\n    \n   \n    // SECOND PASS\n    \n    // Reflected and refracted rays.\n    vec3 refl = reflect(rd, sn); // Standard reflection.\n    //vec3 refr = refract(rd, sn, 1./1.33); // Water refraction. Note the inverted index.\n    \n    // We're branching off from the same spot in two directions, so we'll use this so as\n    // not to interfere with the original surface point vector, \"sp.\" It was a style\n    // choice on my part, but there are other ways.\n    vec3 refSp; \n    \n    // REFLECTED PASS\n    //\n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that.\n    \n    \n    // Making thing complicated for myself, and anyone trying to read this, just so I\n    // can blend the terrain into the object... In my defence, the unblended dirt doesn't\n    // quite look right sitting against the object. :)\n    float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    const float bordW = .075; // Blend border width... Kind of.\n    \n    // If the ray hits the chrome geometric object, or the ground nearby, perform a\n    // reflective pass.\n    if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n\n        // The ray is edged off the surface, as required, but note that it has to be enough\n        // to avoid conflict with the break condition in the \"reflected\" trace algorithm.\n        t = traceRef(sp + refl*.002, refl);\n\n        // Save the object IDs after the second pass.\n        svObjID = objID.x<objID.y? 0. : 1.;\n    \toSvObjID = objID;\n\n\n        // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n        refSp = sp + refl*t;\n\n        // Retrieving the normal at the reflected hit point.\n        sn = getNormal(refSp);\n        \n        // Color at the reflected hit point.\n        vec3 reflColor = doColor(sp, refSp, refl, sn, lp, edge, crv, 1., t);\n        sceneColor = mix(sceneColor, sceneColor + reflColor*1.33, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n        //sceneColor = sceneColor + reflColor*1.33;\n        //sceneColor = sceneColor*.35 + mix(reflColor, sceneColor, fr*fr*.66 + .34)*2.5;\n        \n        \n        #ifndef THIRD_PASS\n        // Very cheap third pass: It'd be nice to put a proper third pass in, but we're \n        // pushing our luck as it is, so we'll make do with a makeshift sky reflection.\n      \n        //if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n        if(svObjID == 1. && t<FAR){\n            \n            refl = reflect(refl, sn);\n            vec3 sky = getSky(ro, refl, lp);\n            sceneColor = mix(sceneColor, sceneColor*.7 + sceneColor*sky*5.*vec3(1.15, 1, .85), smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n      \n            //sceneColor = sceneColor + tpCol*sky*4.;\n            //sceneColor = sceneColor*.7 + tpCol;\n            //sceneColor = sceneColor*.35 + mix(reflColor, sceneColor, fr*fr*.66 + .34)*2.5;\n            \n        }\n        #endif\n    \n    }\n    \n    /*\n\t// Really bad cheap reflection pass. Only here for debug purposes. \n    //if(svObjID==1. && t<FAR){\n    if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n        \n         vec3 sky = getSky(sp, refl, lp);\n         sceneColor = mix(sceneColor, sceneColor + sceneColor*sky*20., smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n      \n    }\n    */\n    \n    #ifdef THIRD_PASS\n    // More correct third pass: Since it's just a reflection off a reflection of one\n    // object, we're not using it by default, but it's there if you want it.\n    if(svObjID == 1. && t<FAR){\n        \n        refl = reflect(refl, sn);\n        \n        t = traceRef(refSp + refl*.002, refl);\n\n        // Save the object IDs after the third pass.\n        svObjID = objID.x<objID.y? 0. : 1.;\n    \toSvObjID = objID;\n        \n\n        // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n        refSp = refSp + refl*t;\n\n        // Retrieving the normal at the reflected hit point.\n        sn = getNormal(refSp);//*rDir;\n        //edge = 0.;\n\n        \n        // Color at the reflected hit point.\n        vec3 reflColor = doColor(sp, refSp, refl, sn, lp, edge, crv, 1., t);\n        sceneColor = mix(sceneColor, sceneColor + reflColor*.33, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n     \n        //sceneColor = sceneColor + reflColor*1.25; \n    }\n    #endif\n     \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway.\n    sceneColor *= sh;\n    \n    \n    \n   \n    // POSTPROCESSING\n    // Interesting red to blueish mix.\n    //sceneColor = mix(sceneColor, pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)), uv.y);\n    //sceneColor = pow(max(sceneColor, 0.), vec3(1.25))*1.33; // Adding a bit of contrast.\n    //sceneColor *= mix(vec3(1.2, 1, .9).yxz, vec3(1.2, 1, .9).zyx, -rd.y*.5 + .5);\n    \n    /*\n    vec2 u2 = uv*r2(3.14159/6.);\n    float overlay = 1. + .35*sin(u2.x*3.14159*iResolution.y/1.5);\n    overlay *= 1. + .35*sin(u2.y*3.14159*iResolution.y/1.5); \n    sceneColor *= overlay*1.1;\n    */\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*.5 + .5;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    // pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(max(sceneColor, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2386, 2408, 2429, 2778, 3281], [3284, 3449, 3469, 3469, 3527], [3529, 3629, 3651, 3743, 3922], [3924, 3950, 3982, 3982, 4046], [4049, 4117, 4135, 4135, 4486], [4489, 4538, 4576, 4576, 4671], [4676, 4900, 4919, 4919, 5188], [5190, 5268, 5286, 5286, 5359], [5360, 5360, 5381, 5381, 5420], [5422, 5620, 5640, 5640, 5671], [5672, 5694, 5715, 5715, 5750], [5771, 5799, 5816, 5816, 5867], [5868, 5868, 5888, 5888, 5942], [5944, 5991, 6008, 6008, 6570], [6572, 6656, 6676, 6676, 7014], [7016, 7037, 7063, 7083, 7239], [7241, 7277, 7306, 7326, 7484], [7486, 7716, 7736, 7904, 8139], [8141, 8251, 8271, 8311, 8510], [8598, 8598, 8620, 8620, 10213], [10216, 10288, 10306, 10351, 10802], [10805, 10838, 10868, 10868, 11136], [11138, 11548, 11581, 11581, 11805], [11809, 11828, 11866, 11866, 12875], [12878, 13069, 13135, 13236, 14251], [14255, 14556, 14609, 14726, 16007], [16010, 16110, 16137, 16137, 16294], [16298, 16298, 16337, 16384, 18075], [18078, 18148, 18184, 18332, 20127], [20129, 20267, 20382, 20438, 22286], [22288, 22440, 22485, 22485, 22732], [22735, 22735, 22791, 22819, 31325]], "test": "untested"}
{"id": "3sXyzB", "name": "Aurorus", "author": "falldeaf", "description": "Copy of Nimitz's shader with only two changes, removed slowly panning horizontally effect and hard-coded an x and y mouse value for a sky only view. (and commented out reflection) \n\nI made these changes to use with my Lively Wallpaper desktop bg system", "tags": ["aurorus"], "likes": 5, "viewed": 655, "published": 3, "date": "1584988841", "time_retrieved": "2024-07-30T21:17:11.681849", "image_code": "// Auroras by nimitz 2017 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\t\n\tThere are two main hurdles I encountered rendering this effect. \n\tFirst, the nature of the texture that needs to be generated to get a believable effect\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\n\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\n\tthe rest of the effect. Which is always the case for auroras.\n\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\n\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\n\tdirection. But this was not required for this demo and would be trivial to fix.\n*/\n\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = triNoise2d(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n//-----------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    vec2 mo = iResolution.xy+1.4;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    //rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        /*\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n\t\t*/\n    }\n    \n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyzB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1537, 1537, 1558, 1558, 1610], [1664, 1664, 1686, 1686, 1728], [1729, 1729, 1750, 1750, 1800], [1802, 1802, 1842, 1842, 2250], [2252, 2252, 2276, 2276, 2341], [2342, 2342, 2373, 2373, 3311], [3377, 3377, 3401, 3401, 3592], [3594, 3594, 3617, 3617, 4039], [4041, 4041, 4062, 4062, 4236], [4301, 4301, 4358, 4358, 5453]], "test": "untested"}
{"id": "tdsyW4", "name": "Kummer Surface III", "author": "mla", "description": "Once again, the Kummer quartic surfaces, this time drawn with an SDF, also with soft shadows & other refinements.\n\nMouse moves things around, also various key controls (see code).", "tags": ["sdf", "quartic", "kummer"], "likes": 8, "viewed": 405, "published": 3, "date": "1584977086", "time_retrieved": "2024-07-30T21:17:12.731044", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Kummer Surfaces, raymarched using the implicit equation as SDF,\n// adjusted by the analytic gradient.\n//\n// Matthew Arcus, 2020.\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <pageup>/<pagedown>: select surface parameter (or allow to vary).\n// <left>/<right>: fog distance or clip radius\n// c: clip at clipradius sphere\n// f: fog\n// l: light transform\n// r: autorotation\n// s: soft shadows\n// x: clip at x-plane\n//\n// https://mathworld.wolfram.com/KummerSurface.html//\n//\n// The Kummer surfaces are a family of surfaces, parametrized on 'mu'.\n// For mu^2 = 1/3, the surface is a (double) sphere and for mu^2\n// = 1, Steiner's Roman Surface; for mu^2 > 1, the surface becomes\n// infinite, assuming various forms as mu^2 increases. All the\n// surfaces have tetrahedral symmetry.\n//\n// Style somewhat inspired by Man Ray's photographs of mathematical\n// models, taken in the 1930's (at the suggestion of Max Ernst):\n//\n// http://photographmag.com/reviews/man-ray-human-equations-a-journey-from-mathematics-to-shakespeare/\n//\n// (the lead photo is in fact of the Kummer surface, with a different projection).\n//\n// The soft shadows can be a little flaky (eg. if the light ray becomes part of\n// the object) and slow things down a bit, but the raymarching works ok\n// out to about mu2 = exp(26.0), with a camera distance of exp(14.0).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat AA = 2.0; // 1.0 for slow machines\n\n// Man Ray chiaroscuro\nconst vec3 bgcol = vec3(0.01);\nconst vec3 tropecol = vec3(0);\nconst vec3 basecol = vec3(1);\nconst vec3 clipcol = 0.1*basecol;\nvec3 light = vec3(4,1,1);\nfloat ambient = 0.05;\n\nint maxsteps = 200;\nfloat maxdist = 25.0;\nfloat precis = 0.00001;\nfloat time = 0.0;\n\nbool dorotate = true; // Autorotate\nbool doclipradius = false;\nfloat clipradius = 2.5;\nbool doclipx = false;\n\n// The Kummer Surface. https://mathworld.wolfram.com/KummerSurface.html\nfloat mu2 = 1.0;\nvec4 kummer4(vec3 pos) {\n  // Return derivative in xyz, function value in w.\n  float x = pos.x, y = pos.y, z = pos.z, w = 1.0;\n  float K = 1.414213562;\n  float p = w-z-K*x;\n  float q = w-z+K*x;\n  float r = w+z+K*y;\n  float s = w+z-K*y;\n  float t = x*x+y*y+z*z-mu2*w*w;\n  float lambda = (3.0*mu2-1.0)/(3.0-mu2);\n  float dx = 4.0*t*x - lambda*K*r*s*(p-q);\n  float dy = 4.0*t*y - lambda*K*p*q*(s-r);\n  float dz = 4.0*t*z - lambda*(-q*r*s-p*r*s+p*q*s+p*q*r);\n  float k = t*t - lambda*p*q*r*s;\n  return vec4(dx,dy,dz,k);\n\n}\n\n// Store sign of implicit function at ray origin here - if negative\n// then we are 'inside' surface and DE and normals must be reversed.\nfloat rosign = 1.0;\n\nfloat eval(vec3 p, out vec3 n, out int type) {\n  vec4 t = kummer4(p);\n  n = t.xyz;\n  float d = t.w/length(n); // Scaled distance\n  type = 0;\n  if (doclipradius) {\n    float d1 = length(p)-clipradius;\n    if (d1 > d) { type = 1; n = p; d = d1; }\n  }\n  if (doclipx) {\n    float d1 = -p.x;\n    if (d1 > d) { type = 2; n = vec3(-1,0,0); d = d1; }\n  }\n  n *= rosign;\n  return rosign*d;\n}\n\nfloat eval(vec3 p) { int type; vec3 n; return eval(p,n,type); }\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.1;\n  for(int i = 0; i < maxsteps; i++) {\n    //assert(i < 50);\n    vec3 p = ro + t*rd;\n    float d = eval(p);\n    if (abs(d) < t*precis) break;\n    // Longer distance estimates can be inaccurate,\n    // so clamp to avoid overstepping.\n    d = min(d,max(0.5,0.1*t));\n    t += d;\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.xz = -rotate(p.xz,time*0.15);\n    //p.yz = rotate(p.yz,0.25*PI);\n    //p.yz = rotate(p.yz,time*0.125);\n  }\n  return p;\n}\n\n// softshadow from iq.\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax, float w) {\n  float t = mint;\n  float res = 1.0;\n  for (int i = 0; i < 200; i++) {\n    float h = eval(ro + t*rd);\n    res = min(res, h/(w*t));\n    t += clamp(h, 0.01*t, max(0.5,0.1*t));\n    if (res < -1.0 || t > tmax) break;\n  }\n  res = max(res,-1.0); // clamp to [-1,1]\n  res = 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n  return res;\n}\n\nfloat getmu2(int n) {\n  int noptions = 6, i = 0;\n  n = mymod(n,noptions);\n  if (n == i++) return 0.33334 + 2.5*(1.0-cos(0.2*time));\n  if (n == i++) return 1.0;\n  if (n == i++) return 2.0;\n  if (n == i++) return 12.0;\n  if (n == i++) return 100.0;\n  if (n == i++) return 0.33334 + exp(0.1*time)-1.0;\n  return 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  time = iTime;\n  // Interesting values of mu2 start at 1/3.\n  mu2 = getmu2(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP));\n  dorotate = !key(CHAR_R);\n  doclipradius = key(CHAR_C);\n  doclipx = key(CHAR_X);\n  float dscale = exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)));\n  maxdist *= dscale;\n  clipradius *= dscale;\n  float camera = 4.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  maxdist = max(maxdist,2.0*camera); // Ensure maxdist is sensible.\n  vec3 ro = vec3(0,0,-camera);\n  ro = transform(ro);\n  rosign = sign(eval(ro)); // Get sign at ray origin\n  if (!key(CHAR_L)) light = transform(light);\n  vec3 aacol = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 rd = vec3(uv,2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      float t = march(ro,rd);\n      vec3 col = bgcol;\n      if (t > 0.0 && t < maxdist) {\n        vec3 p = ro+t*rd;\n        int type; vec3 n;\n        eval(p,n,type);\n        // Sharp edge between clip region and surface means\n        // sometimes we get the wrong normal.\n        if (type == 0 && dot(n,rd) > 1e-2) {\n          type = 1; n = p;\n        }\n        n = normalize(n);\n        if (type != 0) {\n          col = clipcol;\n        } else {\n          col = basecol;\n          //p.xy = abs(p.xy); // Exploit this symmetry? Or general tetrahedral symmetry?\n          // Draw some lines\n          float d = 1e8;\n          // Planes through edge and centre of opposite edge of tetrahedron.\n          float K = sqrt(2.0);\n          // Vertices of base tetrahedron\n          vec3 v0 = vec3(K,0,-1);\n          vec3 v1 = vec3(-K,0,-1);\n          vec3 v2 = vec3(0,K,1);\n          vec3 v3 = vec3(0,-K,1);\n          // 6 edges, sphere (radius mu) intersects each edge in 2 places, eg:\n          //|kv0 + (1-k)v1)| = mu\n          //|k(v0-v1)+v1| = mu\n          //(k(v0-v1)+v1).(k(v0-v1)+v1) = mu2 =\n          // k2(v0-v1).(v0-v1)+2k(v0-v1).v1+v1.v1 -mu2 = 0\n          // A = (v0-v1).(v0-v1)\n          // B = (v0-v1).v1\n          // C = v1.v1-mu2\n          // This can probably be simplified\n          float A = dot(v0-v1,v0-v1); // v0.v0 - 2v0.v1 + v1.v1\n          float B = dot(v0-v1,v1);    // v0.v1 - v1.v1\n          float C = dot(v1,v1)-mu2;   // v1.v1 - mu2\n          float D = B*B-A*C;\n          if (D >= 0.0) {\n            D = sqrt(D);\n            float k = -(B+D)/A;\n            vec3 v01 = k*v0+(1.0-k)*v1;\n            vec3 v10 = k*v1+(1.0-k)*v0;\n            vec3 v02 = k*v0+(1.0-k)*v2;\n            vec3 v20 = k*v2+(1.0-k)*v0;\n            vec3 v03 = k*v0+(1.0-k)*v3;\n            vec3 v30 = k*v3+(1.0-k)*v0;\n\n            vec3 v12 = k*v1+(1.0-k)*v2;\n            vec3 v21 = k*v2+(1.0-k)*v1;\n            vec3 v13 = k*v1+(1.0-k)*v3;\n            vec3 v31 = k*v3+(1.0-k)*v1;\n            vec3 v23 = k*v2+(1.0-k)*v3;\n            vec3 v32 = k*v3+(1.0-k)*v2;\n\n            d = min(d,planedist(p,v01,v02,v13)); // v23 also in plane\n            d = min(d,planedist(p,v01,v03,v12)); // v32 also in plane\n            d = min(d,planedist(p,v02,v03,v21)); // etc.\n\n            d = min(d,planedist(p,v10,v12,v03));\n            d = min(d,planedist(p,v10,v13,v02));\n            d = min(d,planedist(p,v12,v13,v20));\n\n            d = min(d,planedist(p,v20,v21,v03));\n            d = min(d,planedist(p,v20,v23,v01));\n            d = min(d,planedist(p,v21,v23,v10));\n\n            d = min(d,planedist(p,v30,v31,v02));\n            d = min(d,planedist(p,v30,v32,v01));\n            d = min(d,planedist(p,v31,v32,v10));\n          }\n          d = min(d,planedist(p,v0,v1,v2));\n          d = min(d,planedist(p,v0,v1,v3));\n          d = min(d,planedist(p,v0,v2,v3));\n          d = min(d,planedist(p,v1,v2,v3));\n          col = mix(tropecol,col,0.1+0.9*smoothstep(0.0,0.0005,d/t));\n        }\n        //vec3 lightdir = normalize(light); // Light at infinity\n        vec3 lightdir = normalize(light-p);\n        float diffuse = (1.0-ambient)*max(0.0,dot(n,lightdir));\n        if (key(CHAR_S)) diffuse *= softshadow(p,lightdir,0.01,4.0*max(1.0,length(p)),0.1);\n        col *= ambient+diffuse;\n        float fog = key(CHAR_F) ? 0.0 : t/maxdist;\n        col = mix(col,bgcol,fog);\n      }\n      aacol += col;\n    }\n  }\n  aacol /= float(AA*AA);\n  aacol = pow(aacol,vec3(0.4545));\n  fragColor = vec4(aacol,1);\n  if (check) fragColor.r = 1.0;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\nbool check = false;\nvoid assert(bool b) {\n  if (!b) check = true;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n// Distance of p from plane through q,r,s.\nfloat planedist(vec3 p, vec3 q, vec3 r, vec3 s) {\n  vec3 n = normalize(cross(q-r,q-s));\n  return abs(dot(p-q,n));\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2037, 2037, 2061, 2113, 2555], [2715, 2715, 2761, 2761, 3097], [3099, 3099, 3119, 3119, 3162], [3164, 3164, 3195, 3195, 3544], [3546, 3546, 3573, 3573, 3935], [3937, 3960, 4029, 4029, 4362], [4364, 4364, 4385, 4385, 4678], [4680, 4680, 4732, 4732, 9123]], "test": "untested"}
{"id": "WsXyRS", "name": "Continue to float", "author": "gambhiro", "description": "Abstract raymarching", "tags": ["abstract"], "likes": 2, "viewed": 337, "published": 3, "date": "1584976239", "time_retrieved": "2024-07-30T21:17:13.551849", "image_code": "#define i_time iTime\n#define i_resolution iResolution\n\nvec2 scene, eps = vec2(.00035, -.00035);\nfloat td; // travel dist\nfloat tt; // global time\nfloat attr;\n\nmat2 rot2(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return max(max(q.x, q.y), q.z);\n}\n\nfloat boxes(vec3 p) {\n  vec3 q = p;\n\n  q *= 0.6;\n  q.xz *= rot2(sin(p.y*0.5)*0.4);\n\n  q.x = mod(q.x + tt*.5, 3.0);\n\n  float d = box(abs(q) - vec3(1.5, 10.0, .8), vec3(.3, 10.0, .3));\n  return d;\n}\n\nvec2 map(vec3 p) {\n\n  // reverse sphere\n  attr = max(0.0, (6.0 - (length(p) - 6.0)));\n\n  vec2 res = vec2(boxes(p - vec3(.0, .0, 8.)), 5.0);\n\n  // background sphere\n  vec2 o = vec2(length(p - vec3(.0, .0, 20.))-10.0 + sin((p.x+tt*2.5)*5.0)*.1, 15.0);\n\n  res = (res.x < o.x) ? res : o;\n\n  p += vec3(0, -.5, -2);\n  p *= 0.9;\n\n  // A\n  vec3 q = p;\n\n  float ttt = tt - 1.5;\n  for (int i=0; i<2; i++) {\n    q = abs(q) - vec3(0.3*attr, 0.2, 3);\n    q.xy *= rot2(attr*(0.1+sin(ttt)*.2));\n    q.xz *= rot2(attr*0.2+sin(ttt+1.0)*.2);\n  }\n\n  q.z = mod(q.z, 2.5);\n  o = vec2(box(q - vec3(.0, 4, 0.), vec3(.5, .5, 10)), 10);\n\n  res = (res.x < o.x) ? res : o;\n\n  // B\n\n  q = p;\n  attr = max(0.0, (4.0 - (length(p) - 4.0)));\n\n  ttt += .5;\n  for (int i=0; i<2; i++) {\n    q = abs(q) - vec3(0.3*attr, 0.2, 3);\n    q.xy *= rot2(attr*(0.1+sin(ttt)*.3));\n    q.xz *= rot2(attr*0.2+sin(ttt+1.0)*.3);\n  }\n\n  q.z = mod(q.z, 2.5);\n  o = vec2(box(q - vec3(.0, 3, 0.), vec3(.5, .5, 10)), 10);\n\n  res = (res.x < o.x) ? res : o;\n\n  q *= 0.6;\n  q.y -= 0.2;\n  o = vec2(box(q - vec3(.1, 2.5, .0), vec3(.6, .6, 10)), 10);\n\n  res = (res.x < o.x) ? res : o;\n\n  q *= 0.6;\n  q.y -= 0.2;\n  o = vec2(box(q - vec3(.1, 2, .0), vec3(.7, .7, 10)), 10);\n\n  res = (res.x < o.x) ? res : o;\n\n  return res;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n  vec2 h, t = vec2(0.1);\n  for (int i=0; i<128; i++) {\n    h = map(ro+rd*t.x);\n    if (h.x < .0001 || t.x > 100.0) break;\n    t.x += h.x*0.6;\n    t.y = h.y;\n  }\n  if (t.x > 100.0) t.x = 0.0;\n  return t;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec2 uv = vec2(frag_coord.x / i_resolution.x, frag_coord.y / i_resolution.y);\n  uv -= 0.5;\n  uv /= vec2(i_resolution.y / i_resolution.x, 1);\n\n  tt = mod(i_time*.5, 100.0);\n\n  // ===============\n\n  vec3 ro = vec3(0, 2, -10);\n  vec3 rd = normalize(vec3(uv,0.5));\n\n  vec3 ld = normalize(vec3(.3, .5, -.5));\n\n  vec3 fog = vec3(0.9) * (1.0 - (length(uv)-0.2));\n  vec3 col = fog;\n\n  scene = trace(ro, rd);\n\n  td = scene.x;\n  if (td > 0.0) {\n    vec3 pp = ro+rd*td;\n    vec3 nor = normalize(eps.xyy*map(pp+eps.xyy).x +\n                         eps.yyx*map(pp+eps.yyx).x +\n                         eps.xyx*map(pp+eps.xyx).x +\n                         eps.xxx*map(pp+eps.xxx).x);\n\n    vec3 b0 = vec3(.1, .5, .8);\n    vec3 b1 = vec3(0.7, .8, .8);\n    vec3 base = mix(b0, b1, attr);\n\n    float foggy;\n\n    if (scene.y == 5.0) {\n      foggy = -.00001*td*td*td;\n    }\n\n    if (scene.y == 10.0) {\n      foggy = -.0000005*td*td*td;\n    }\n\n    if (scene.y == 15.0) {\n      foggy = -.00005*td*td*td;\n      base = vec3(0, 1, 0);\n    }\n\n    float diff = max(0.0, dot(nor, ld));\n\n    float aor = td/30.;\n    float ao = exp2(-2.*pow(max(0.,1.-map(pp+nor*aor).x/aor),2.));\n\n    float fr = pow(1.+dot(nor,rd),2.);\n\n    vec3 sss = vec3(0.5)*smoothstep(0.,1.,map(pp+ld*0.4).x/0.4);\n\n    col = base*(0.9*ao+0.2)*(diff+sss);\n    col = mix(col, b0, min(fr, 0.2));\n\n    col = mix(col, fog, 1.0-exp(foggy));\n  }\n\n\n  col = pow(col, vec3(1.8)); // stronger colours\n  col = vec3(1.0) - exp(-col * 3.0); // exposure hdr\n  col = pow(col, vec3(.45)); // gamma\n\n  frag_color = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 179, 179, 229], [231, 231, 258, 258, 317], [319, 319, 340, 340, 515], [517, 517, 535, 556, 1778], [1780, 1780, 1810, 1810, 2015], [2017, 2017, 2074, 2074, 3632]], "test": "untested"}
{"id": "tdlcD7", "name": "Book of Chopped Surfaces", "author": "dr2", "description": " Surfaces of repeatedly distorted and fragmented cubes (leading to dust);\n alternating monotone and color (representing distance field Laplacian,\n or curvature); mouse overrides autopaging.\n", "tags": ["fractal"], "likes": 10, "viewed": 399, "published": 3, "date": "1584971974", "time_retrieved": "2024-07-30T21:17:14.365673", "image_code": "// \"Book of Chopped Surfaces\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDirEx, ltDir, qHit, pgSize;\nfloat tCur, dstFarEx, dstFar, tpBook, phsTurn, idPage;\nint idObj, nIt;\nconst float pi = 3.14159;\n\nconst int nPage = 14;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 SMap (vec3 p, float t)\n{\n  float f;\n  f = 2.;\n  t = 10. + 5. * sin  (0.1 * 2. * pi * t);\n  for (int k = 0; k < 12; k ++) {\n    if (k >= nIt) break;\n    p += 0.4 * sin (1.7 * p.yzx / f + f * t);\n    f *= 0.75;\n  }\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 blbRad;\n  float d, t;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.1 * tCur);\n  t = 0.5 * tCur;\n  blbRad = vec2 (1.1 + 0.31 * sin (t + 1.31), 1. + 0.41 * sin (1.7 * (t + 1.31)));\n  d = SmoothMin (PrBoxDf (SMap (q - vec3 (0.7, 0., 0.), 1.11 * t + 0.7), vec3 (blbRad.x)),\n     PrBoxDf (SMap (q - vec3 (-0.7, 0., 0.), 1.3 * t), vec3 (blbRad.y)), 0.2);\n  return 0.25 * d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float lp, s;\n  e = vec2 (0.01, -0.01);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  lp = (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x); // (laplacian: see \"Cheap curvature\" by nimitz)\n  return vec4 (normalize (2. * v.yzw - s), lp);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, nl4;\n  vec3 col, vn;\n  float dstObj, lp, nDotL;\n  nIt = 5 + int (0.5 * (idPage - 1.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    nl4 = ObjNfL (ro);\n    vn = nl4.xyz;\n    lp = nl4.w;\n    col = (mod (idPage, 2.) == 0.) ?\n       col = HsvToRgb (vec3 (0.35 * (1. - clamp (0.3 * lp, -1., 1.)), 0.8, 1.)) :\n       vec3 (0.9) * (1. - step (10., lp));\n    nDotL = max (dot (vn, ltDir), 0.);\n    nDotL *= nDotL;\n    col = col * (0.2 + 0.8 * nDotL * nDotL +\n       0.2 * pow (max (dot (normalize (vn - rd), vn), 0.), 32.));\n    rd = reflect (rd, vn);\n  } else {\n    col = vec3 (0.5, 0.5, 0.55);\n  }\n  return clamp (col, 0., 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az, zmFac;\n  el = -0.15 * pi;\n  az = 0.2 * pi * sin (0.05 * pi * tCur);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -40.);\n  dstFar = 100.;\n  zmFac = 8.;\n  rd = vuMat * normalize (vec3 (fCoord, zmFac));\n  ltDir = normalize (vec3 (0., 1., -1.));\n  fCol = clamp (ShowScene (ro, rd), 0., 1.);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 3.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.z / nRing;\n  bc = q.z;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = 0; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (2.5, 0.011, 2.5);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = HsvToRgb (vec3 (floor (0.5 * (idPage - 1.)) / float (nPage / 2), 0.7, 1.));\n      s = pgSize.xz - abs (qHit.xz);\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      } else {\n        col4 = vec4 (c, 0.2);\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = tCur;\n  az = 0.;\n  el = -0.5 * pi;\n  if (mPtr.z > 0.) {\n    tpBook = - clamp (1.05 * mPtr.x + 0.5, 0., 1.);\n    el += pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (1., 0., -18.);\n  ro = vuMat * ro;\n  zmFac = 7.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (vec2 (- uv.x, uv.y) + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (1.)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[682, 682, 711, 711, 913], [915, 915, 937, 937, 1312], [1314, 1314, 1347, 1347, 1524], [1526, 1526, 1548, 1548, 1931], [1933, 1933, 1968, 1968, 2640], [2642, 2642, 2678, 2678, 2884], [2886, 2886, 2932, 2932, 3279], [3281, 3281, 3305, 3305, 4180], [4182, 4182, 4217, 4217, 4398], [4400, 4400, 4423, 4423, 4626], [4628, 4628, 4667, 4667, 4891], [6579, 6579, 6635, 6635, 7693], [7695, 7695, 7727, 7727, 7827], [7829, 7829, 7875, 7875, 7922], [7924, 7924, 7970, 7970, 8027], [8029, 8029, 8053, 8053, 8170], [8172, 8172, 8217, 8217, 8320], [8322, 8322, 8379, 8379, 8462], [8464, 8464, 8494, 8494, 8607]], "test": "untested"}
{"id": "tslcWM", "name": "JFA Rasterization", "author": "wyatt", "description": " it's not perfect, but hey rasterization of a buttload of triangles in shadertoy :D\n\n", "tags": ["rasterization", "jfa"], "likes": 10, "viewed": 589, "published": 3, "date": "1584946654", "time_retrieved": "2024-07-30T21:17:15.293193", "image_code": "// Fork of \"JFA Triangles\" by wyatt. https://shadertoy.com/view/WsscWN\n// 2020-03-23 06:23:32\n\n// Fork of \"JFA Caustic\" by wyatt. https://shadertoy.com/view/wdsyDH\n// 2020-03-21 19:07:23\nvec4 fractal (vec2 U) {\n\tU = 4.*U-2.+vec2(.5,-.3);\n    vec2 z = U;\n    for (float i = 0.; i < 20.;i++) {\n    \tz = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)-U;\n        if (length(z)>4.) return 0.5+0.5*sin(vec4(1,2,3,4)+.1*i);\n    }\n    return vec4(1);\n        \n}\nvec3 norm (float i) {\n\tvec2 u = unpack(i);\n    vec4\n        q = A(shape(u)),\n        n = A(shape(u+vec2(0,O.y))),\n        e = A(shape(u+vec2(O.x,0))),\n        s = A(shape(u-vec2(0,O.y))),\n        w = A(shape(u-vec2(O.x,0)));\n    return normalize(vec3(\n        length(e-q)-length(w-q),\n        length(n-q)-length(s-q),\n        1\n    ));\n}\nvec3 color (float i) {\n    vec2 u = unpack(i);\n\treturn vec3(u/R,1);\n}\nvec4 Qout (vec2 u) {\n    vec2 U = gl_FragCoord.xy;\n    vec4 Q = vec4(0);\n\tvec4 b = B(u);\n    vec3 a = P(b.x).xyz;\n    vec3 aa = P(b.y).xyz;\n    vec3 aaa = P(b.z).xyz;\n    vec3 c = color(b.x);\n    vec3 cc = color(b.y);\n    vec3 ccc = color(b.z);\n    \n    vec3 n = norm(b.x);\n    vec3 nn = norm(b.y);\n    vec3 nnn = norm(b.z);\n    vec3 by = bary(U,a.xy,aa.xy,aaa.xy);\n    Q.xyz = (by.x*c+by.y*cc+by.z*ccc);\n    Q = fractal(Q.xy);\n    Q.xyz *= 0.5+0.5*(by.x*n+by.y*nn+by.z*nnn).x;\n    if (triangle(U,b)>1.) Q = 0.5+0.1*D(U);\n    Q.w = 1.;\n    return Q;\n}\nMain {\n    Q  = Qout(unpack(C(U).w));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(mod((U),R)),0)\n#define B(U) texelFetch(iChannel1,ivec2(mod((U),R)),0)\n#define C(U) texelFetch(iChannel2,ivec2(mod((U),R)),0)\n#define D(U) texelFetch(iChannel3,ivec2(mod((U),R)),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define T(U) A((U)-dt*A(U).xy)\n#define NeighborhoodT vec4 n = T(U+vec2(0,1)), e = T(U+vec2(1,0)), s = T(U-vec2(0,1)), w = T(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define grd 0.25*vec2(e.z-w.z,n.z-s.z)\n#define div 0.25*(e.x-w.x+n.y-s.y)\n#define ro(a) mat2(cos(a),sin(-a),sin(a),cos(a))\n#define I 11\n#define O vec2(6.,3.)\n#define pi2 6.28318530718\n//#define shape(U) round(mod((U),R)/O)*O\n#define shape(U) (round(clamp((U),vec2(30),R-vec2(30,5))/O)*O)\n\n//Dave H :\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} \nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nvec2 cc (vec2 a, vec2 b, vec2 c) {\n    vec2 ab = 0.5*(a+b), ac = 0.5*(a+c);\n\tfloat m1 = (a.x-b.x)/(b.y-a.y), m2 = (a.x-c.x)/(c.y-a.y);\n    float b1 = ab.y-m1*ab.x, b2 = ac.y-m2*ac.x;\n    float x = (b1-b2)/(m2-m1);\n    return vec2(x,m1*x+b1);\n}\n\nfloat ssg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn sign(dot(p-a,(b-a).yx*vec2(1,-1)))*length(p-a-(b-a)*i);\n}\nfloat tri (vec2 U, vec4 a, vec4 aa, vec4 aaa) {\n    if (length(a.xy-aaa.xy)<1e-3||length(aa.xy-aaa.xy)<1e-3||length(a.xy-aa.xy)<1e-3) return 1e3;\n    float ab = ssg(U,a.xy,aa.xy),\n          bc = ssg(U,aa.xy,aaa.xy),\n          ca = ssg(U,aaa.xy,a.xy),\n          l = min(abs(ab),min(abs(bc),abs(ca))),\n          s = (ab<0.&&bc<0.&&ca<0.)||(ab>0.&&bc>0.&&ca>0.)?-1.:1.;\n\tif (s*l>=0.) return l*s;\n   \tab=abs(ab)*sg(aaa.xy,a.xy,aa.xy);\n    bc=abs(bc)*sg(a.xy,aa.xy,aaa.xy);\n    ca=abs(ca)*sg(aa.xy,aaa.xy,a.xy);\n    float depth = -(ab*aaa.z+bc*a.z+ca*aa.z);\n    return depth;\n}\n#define F(rr,l,ll) (7e-2*(rr)/(l)*((l)-(ll))*exp(-.02*(ll)))\nvec3 bary (vec2 p, vec2 a, vec2 aa, vec2 aaa) {\n    return vec3(\n        sg(p,aa,aaa)/sg(a,aa,aaa),\n        sg(p,aaa,a)/sg(aa,aaa,a),\n    \tsg(p,a,aa)/sg(aaa,a,aa)\n    );\n}\n//#define pack(u) float(packUnorm2x16((u).xy/R))\n//#define unpack(i) (unpackUnorm2x16(uint(i))*R)\n#define pack(u) ((u).x+(u).y*R.x)\n#define unpack(i) vec2(mod((i),R.x),(i)/R.x)\n#define get(i) A(unpack(i))\n#define perspect(q) vec4((q.xy-0.5*R)*2./(3.+q.z/R.y)+0.5*R,R.x-q.z,1)\n#define P(i) perspect(get(i))\n#define triangle(U,w) tri((U), P((w).x), P((w).y),P((w).z))\n", "buffer_a_code": "vec3 force (vec2 U, vec2 r, vec4 q) {\n\tvec2 v = shape(U+O*r);\n    vec4 n = A(v);\n    vec3 rr = n.xyz-q.xyz;\n    float l = length(rr);\n    float ll = length(v-U);\n    if (l>0.)\n        return F(rr,l,ll);\n    return vec3(0);\n}\nMain {\n    \n    Q = A(U);\n    vec4 q = Q;\n    for (int x = -5; x<=5; x++) {\n        Q.xyz += force(U,vec2(x,0),q);\n        Q.xyz += force(U,vec2(0,x),q);\n    }\n    Q += D(U);\n    Init Q = vec4(shape(U),0,1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    if (iFrame<1) {\n      \t\n        vec2 o = O;\n        int z = int(U.x+R.x*U.y)%7;\n        if (z==1||z==3) o = -o;\n        vec2 a = shape(U);\n        vec2 aa = shape(U+vec2(o.x,0));\n        vec2 aaa = shape(U+vec2(0,o.y));\n        Q = vec4(\n            pack(a.xy),\n            pack(aa.xy),\n            pack(aaa.xy),\n            1\n        );\n        \n        \n    } else Q = B(U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Hierarchical Sort\nvoid comp (inout vec4 Q, inout vec4 r, float l, float i) {\n\tif (l<r.x) {\n        Q.yz = Q.xy;\n        r.yz = r.xy;\n        Q.x = i;\n        r.x = l;\n    } else if (l<r.y&&l>r.x) {\n        Q.z = Q.y;\n        r.z = r.y;\n        Q.y = i;\n        r.y = l;\n    } else if (l<r.z&&l>r.y) {\n        Q.z = i;\n        r.z = l;\n    }\n}\nvoid X (inout vec4 Q, inout vec4 r, vec2 U, vec2 u) {\n        vec4 b,c;float l,i;\n        if (iFrame%I==0) {\n            i = pack(U+u); \n            b = B(U+u);\n            l = triangle(U,b);\n            comp(Q,r,l,i);\n            i = Q.w; \n            b = B(unpack(Q.w));\n            l = triangle(U,b);\n            comp(Q,r,l,i);\n        } else {\n            c = C(U+u);\n            b = B(unpack(c.x));\n            i = c.x;\n            l = triangle(U,b);\n            comp(Q,r,l,i);\n            b = B(unpack(c.y));\n            i = c.y;\n            l = triangle(U,b);\n            comp(Q,r,l,i);\n            b = B(unpack(c.z));\n            i = c.z;\n            l = triangle(U,b);\n            comp(Q,r,l,i);\n        }\n    \t\n}\nvoid Y(inout vec4 Q, inout vec4 r, vec2 U, vec2 u) {\n\tfloat i, l; vec4 c, b;\n    c = C(U+u);\n    b = B(unpack(c.x));\n    i = c.x;\n    l = triangle(U,b);\n    if (l<r.w) {\n    \tr.w = l;\n        Q.w = i;\n    }\n    b = B(unpack(c.w));\n    i = c.w;\n    l = triangle(U,b);\n    if (l<r.w) {\n    \tr.w = l;\n        Q.w = i;\n    }\n    \n}\nMain {\n    Q = C(U);\n    vec4 r = vec4(\n        triangle(U,B(unpack(Q.x))),\n        triangle(U,B(unpack(Q.y))),\n        triangle(U,B(unpack(Q.z))),\n        triangle(U,B(unpack(Q.w)))\n    );\n    if ((iFrame+int(U.x+R.x*U.y))%2==0&&iFrame%I==0) {\n    \tQ = vec4(1e9);\n    \tr = vec4(1e9);\n\t}\n    float k = exp2(float(-1+I-(iFrame%I)));\n    X(Q,r,U,vec2(0,k));\n    X(Q,r,U,vec2(k,0));\n    X(Q,r,U,vec2(0,-k));\n    X(Q,r,U,vec2(-k,0));\n    Y(Q,r,U,vec2(0,1));\n    Y(Q,r,U,vec2(1,0));\n    Y(Q,r,U,vec2(0,-1));\n    Y(Q,r,U,vec2(-1,0));\n    Y(Q,r,U,vec2(0,0));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec3 force (vec2 U, vec2 r, vec4 q) {\n\tvec2 v = shape(U+O*r);\n    vec4 n = A(v);\n    vec3 rr = n.xyz-q.xyz;\n    float l = length(rr);\n    float ll = length(v-U);\n    if (l>0.)\n        return F(rr,l,ll);\n    return vec3(0);\n}\nMain {\n    U = shape(U);\n\tQ = D(U);\n    vec4 q = A(U);\n    float m = (U.y<20.*R.y)?5.:1.;\n    for (int x = -5; x<=5; x++) {\n        Q.xyz += force(U,vec2(x,0),q)/m;\n        Q.xyz += force(U,vec2(0,x),q)/m;\n    }\n    Q.y -= m*6e-3;\n    Q.xyz *= 0.999;\n    \n    if (U.y>R.y-20.) {\n        Q.xyz *= 0.5;\n    \tU = shape(U);\n    \tvec4 p = vec4(U,0,0);\n        p.x = 0.8*(p.x-0.5*R.x)+0.5*R.x;\n       p.y += 20.;\n        float a = 0.5*sin(6e-3*float(iFrame));\n        \n        p.x -= 0.5*R.x;\n        p.xz *= ro(pi2*a);\n        p.x += 0.5*R.x;\n        if (iMouse.z>0.) {\n            p.xy += iMouse.xy/R*200.-100.;\n            Q.xyz *= 0.5;\n        }\n        Q.xyz += (p.xyz-q.xyz);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 187, 210, 210, 439], [440, 440, 461, 461, 777], [778, 778, 800, 800, 847], [848, 848, 868, 868, 1399]], "test": "untested"}
{"id": "WdfcDM", "name": "SPH Fluid Sim", "author": "natethegreat2525", "description": "SPH implementation using buffers for storage\n\nSpace - Add particles\nMouse - attract particles\n\nBuffer A - pressure calculations\nBuffer B - pressure force and viscosity force\nBuffer C - particle overlap avoidance\nBuffer B - force/velocity integration ", "tags": ["simulation", "fluid", "particle", "sph"], "likes": 18, "viewed": 1048, "published": 3, "date": "1584933080", "time_retrieved": "2024-07-30T21:17:16.346377", "image_code": "#define dotrad 10\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < 10. || fragCoord.x < 10. || fragCoord.x > iResolution.x-10. || fragCoord.y > iResolution.y-10.) {\n        return;\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float thickness = 0.;\n    float thickness_r = 0.;\n    float thickness_d = 0.;\n    vec2 vel;\n    float count = 0.;\n    // Output to screen\n    for (int i = -dotrad; i < dotrad; i++) {\n        for (int j = -dotrad; j < dotrad; j++) {\n            vec4 tex = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(i,j), 0);\n            if (tex.x == 0.) {\n                continue;\n            }\n            float str = length(vec2(i,j));\n            float str_r = length(vec2(float(i)+1.,j));\n            float str_d = length(vec2(i,float(j)+1.));\n\n    \t\tthickness += 1./(str*str);\n    \t\tthickness_r += 1./(str_r*str_r);\n    \t\tthickness_d += 1./(str_d*str_d);\n            vel += tex.zw;\n            count++;\n        }\n    }\n    float thickness_base = clamp(thickness, 0., .5)*2.;\n    thickness_r = clamp(thickness_r, 0., .5)*2.;\n    thickness_d = clamp(thickness_d, 0., .5)*2.;\n    vec2 thickness_grad = (vec2(thickness_r, thickness_d)-thickness_base);\n    vec4 bg = texture(iChannel1, uv-thickness_grad*.1);\n    vec3 base_color = vec3(vel*.2/max(1.,count) + .5,1);\n    fragColor = vec4(mix(bg.rgb,base_color,thickness > 0.1 ? .5 : 0.), 1);\n\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n// on this buffer x = pressure, y = pressure_near\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 curVec = ivec2(fragCoord);\n    vec4 self_tex = texelFetch(iChannel0, curVec, 0);\n  \t\n    if (self_tex.x > 0.) {\n        float dens = 0.;\n        float dens_near = 0.;\n        for (int i = -RAD; i <= RAD; i++) {\n            for (int j = -RAD; j <= RAD; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                ivec2 ij = ivec2(i,j);\n                vec4 tex = texelFetch(iChannel0, curVec+ij, 0);\n\n                if (tex.x > 0.) {\n                    vec2 dp = tex.xy - self_tex.xy;\n                    float len = length(dp);\n                    if (len < r) {\n                        float q = 1.-len/r;\n                        float q_sq = q*q;\n                        dens += q_sq;\n                        dens_near += q*q_sq;\n                    }\n                }\n            }\n    \t}\n        float pressure = k*(dens-rest_dens);\n        float pressure_near = k_near*dens_near;\n        fragColor = vec4(pressure, pressure_near, 0, 0);\n    }\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\n// on this buffer x = force X, y = force Y\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 curVec = ivec2(fragCoord);\n    vec4 cur_tex = texelFetch(iChannel0, curVec, 0);\n  \tfragColor = vec4(0);\n    if (cur_tex.x > 0.) {\n        float dens = 0.;\n        float dens_near = 0.;\n       \tvec4 self_vals = texelFetch(iChannel1, curVec, 0);\n\n        for (int i = -RAD; i <= RAD; i++) {\n            for (int j = -RAD; j <= RAD; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                ivec2 ij = ivec2(i,j);\n                vec4 tex = texelFetch(iChannel0, curVec+ij, 0);\n\t\t\t\tvec4 neighbor_vals = texelFetch(iChannel1, curVec+ij, 0);\n                if (tex.x > 0.) {\n                    vec2 dp = cur_tex.xy-tex.xy;\n                    float len = length(dp);\n                    if (len < r) {\n                        float q = 1.-len/r;\n                        float dm = q*(self_vals.x + neighbor_vals.x + (self_vals.y + neighbor_vals.y)*q);\n                        vec2 visc = (tex.zw-cur_tex.zw) * q * VISC;\n                        fragColor.xy += dm*dp/len + visc;\n                    }\n                    //relative drag\n                    //fragColor.xy += tex.zw*.01 - cur_tex.zw*.01;\n                }\n            }\n    \t}\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\n// on this buffer x,y = position of first duplicated particle, z,w = position of second duplicated particle\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 curVec = ivec2(fragCoord);\n    bool hasPoint = false;\n    bool hasPoint2 = false;\n    for (int i = -MAX_V; i <= MAX_V; i++) {\n        for (int j = -MAX_V; j <= MAX_V; j++) {\n            ivec2 ij = ivec2(i,j);\n            vec4 tex = texelFetch(iChannel0, curVec+ij, 0);\n\t\t\tvec4 force = texelFetch(iChannel1, curVec+ij, 0);\n            tex.zw += force.xy;\n            if (tex.x != 0. && int(tex.z+tex.x) == curVec.x && int(tex.w+tex.y) == curVec.y) {\n                if (hasPoint) {\n                    if (hasPoint2) {\n                        //third point\n                        fragColor.zw = vec2(float(i+curVec.x), float(j+curVec.y));\n                    } else {\n                        //second point\n                        fragColor.xy = vec2(float(i+curVec.x), float(j+curVec.y));\n                    }\n                \thasPoint2 = true;\n                }\n                hasPoint = true;\n            }\n        }\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RAD 10\n#define k .01\n#define k_near .1\n#define rest_dens 5.\n#define r 10.\n#define VISC 0.01\n\n#define G -.05\n#define MAX_V 5\n#define MAX_Vd 5.", "buffer_d_code": "\n// modified version of\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nfloat rand(vec3 co)\n{\n    float a = 12.9898;\n    float b = 78.233;\n    float d = 283.8574;\n    float c = 43758.5453;\n    float dt= dot(co ,vec3(a,b,d));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n// on this buffer xy = particle position, zw = particle velocity\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hasPoint = false;\n    ivec2 curVec = ivec2(fragCoord);\n    for (int i = -MAX_V; i <= MAX_V; i++) {\n        for (int j = -MAX_V; j <= MAX_V; j++) {\n            ivec2 ij = ivec2(i,j);\n            vec4 tex = texelFetch(iChannel0, curVec+ij, 0);\n\t\t\tvec4 force = texelFetch(iChannel1, curVec+ij, 0);\n            if (iMouse.z > 0.) {\n                vec2 diff = iMouse.xy - fragCoord.xy;\n                float len = length(diff);\n                if (len < 150.) {\n                    force.xy += .2*normalize(diff);\n                }\n            }\n            tex.zw += force.xy;\n            tex.z = min(max(tex.z, -MAX_Vd),MAX_Vd);\n            tex.w = min(max(tex.w, -MAX_Vd),MAX_Vd);\n            if (!hasPoint && tex.x != 0. && int(tex.z+tex.x) == curVec.x && int(tex.w+tex.y) == curVec.y) {\n                fragColor = tex + vec4(tex.zw,0,G);\n                hasPoint = true;\n            }\n        }\n    }\n    if (!hasPoint) {\n\t\tvec4 dedup = texelFetch(iChannel2, curVec+ivec2(1,0), 0);\n        if (dedup.x != 0. || dedup.y != 0.) {\n            vec4 tex = texelFetch(iChannel0, ivec2(int(dedup.x),int(dedup.y)), 0);\n            vec4 force = texelFetch(iChannel1, ivec2(int(dedup.x),int(dedup.y)), 0);\n            tex.zw += force.xy;\n            tex.z = min(max(tex.z, -MAX_Vd),MAX_Vd);\n            tex.w = min(max(tex.w, -MAX_Vd*.9),MAX_Vd*.9);\n            fragColor = tex + vec4(tex.zw,0,G);\n        }\n    }\n    if (fragCoord.y < 20.) {\n        fragColor.w += 0.15*(20.-fragCoord.y);\n    }\n    if (fragCoord.x < 20.) {\n    \tfragColor.z += 0.15*(20.-fragCoord.x);\n    }\n    if (fragCoord.x > iResolution.x-20.) {\n    \tfragColor.z -= 0.15*(fragCoord.x + 20. - iResolution.x);\n    }\n    if (fragCoord.y > iResolution.y-20.) {\n    \tfragColor.w -= 0.15*(fragCoord.y + 20. - iResolution.y);\n    }\n    if (iFrame == 2) {\n        if (curVec.x < 200 && curVec.x > 50 && curVec.y > 50 && (curVec.x + curVec.y) % 3 == 1 && curVec.y % 3 == 1 ) {\n            fragColor = vec4(fragCoord.xy,0,0);\n        }\n    }\n    if (texelFetch(iChannel3, ivec2(32,0), 0).x > 0.5 && rand(vec3(iTime,fragCoord)) > .995 && fragCoord.x < 150. && fragCoord.x > 50. && fragCoord.y > 400.) {\n        fragColor = vec4(fragCoord.xy, 0,0);\n    }\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 76, 1399]], "test": "untested"}
{"id": "tdXcWM", "name": "Day 94", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 54, "viewed": 3905, "published": 3, "date": "1584916040", "time_retrieved": "2024-07-30T21:17:17.111332", "image_code": "// thx to evvvvil and nusan for some of the techniques here\n// radial blur and chromatic abberation in this buffer\n// The whole thing is built around a incorrectly written rot() function xd\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),4.)*0.1;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*0.8;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    vec2 dir = normalize(uvn);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= dir*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*45.; \n    //fragColor.r *= 1. + uv.x*0.8;\n    //fragColor.g *= 1. + uv.y*0.7;\n    //fragColor.b *= 1. + uv.y*0.7;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.4);\n    //1fragColor *= 18.;\n    \n    \n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.));\n    //fragColor *= 1. - dot(uvn,uvn)*0.6;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define dmin(a,b) a.x<b.x ? a : b\n\n// first rot is broken!!\n#define rot(x) mat2(cos(x),sin(x),sin(x),cos(x)) \n#define rotgood(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pmod(p,x) mod(p,x) - 0.5*x\n\n\nvec3 glow = vec3(0);\nvec3 glowb = vec3(0);\nvec3 att = vec3(1);\nfloat side = 1.;\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return length(max(p,0.0)) + min(max(p.x, max(p.y,p.z)),0.);\n}\n#define pi (acos(-1.))\n\n\nvec2 o(vec3 p){\n    vec2 d = vec2(10e7);\n    \n    //p.xy *= rot(0.25*pi);\n    p = abs(p);\n    float dBox = sdBox(p, vec3(0.1,0.5,0.7));\n    p.x -= .45;\n    float dBoxb = sdBox(p, vec3(0.08,0.8,0.5));\n    \n    p = abs(p);\n    \n    p.y -= 0.45;\n    float dBoxc = sdBox(p, vec3(0.16));\n    \n    p.y -= 0.4;\n    p.z -= 0.7;\n    p = abs(p);\n    \n    p.x -= 0.05;\n    p.z -= 0.15;\n    float dBoxg = max(p.x,p.z);\n\t\n    d = dmin(d, vec2(dBox, 5.));\n    d = dmin(d, vec2(dBoxb, 21.));\n    d = dmin(d, vec2(dBoxc, 9.));;\n    d = dmin(d, vec2(dBoxg, 21.));\n    \n    return d;\n}\nfloat mmmm;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\n    \n    vec3 q = p;\n    float modD = 9.;\n    \n    vec2 id = floor(p.xz/modD);\n    p.xz = pmod(p.xz,modD);\n    \n    \n    float mt = sin(iTime*2. + id.x + sin(id.y)*0.4 + id.y*0.4);\n    mmmm = pow(abs(mt), 0.5)*sign(mt)*0.2;\n    \n    //glowb += exp(-length(p)*5.)*2.*vec3(0.3,0.9,0.9);\n    \n    vec3 cc = vec3(0.7 + mmmm*2.,.9,0.9);\n    glowb += exp(-length(p)*(5. - mmmm))*2.*cc*att;\n    \n    \n    for(float i = 0.; i< 4.; i++){\n    \tp = abs(p);\n        p.xy *= rot((0.5)*pi);\n        p.x -= 0.8+ mmmm;\n        p.t -= 1.5 ;\n        p.zy *= rot(0.25*pi);\n        p.z -= 1.;\n        //p.xz *= rot(0.5*pi);\n        \n    }\n    \n    //p.x -= sin(iTime);\n    \n    vec2 dO = o(p);\n    \n    float dBall = length(p) - 0.1;\n    \n    d = dmin(d, dO);\n    \n    q = abs(q);\n    q.y -=6.;\n    \n    d = dmin(d, vec2(abs(q.y) - 0.1, 21.));\n    d.x *= 0.6;\n    \n    glow += exp(-max(d.x, 0.)*10.)*att*2.;\n    \n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = map(ro);\n    \n    if(d.x < 0.2)\n        ro += rd*0.08;\n    \n    hit = false; t = 0.; p = ro;\n    \n    for(float i = 0.; i< 180.; i++){\n    \td = map(p);\n        d.x *= side;\n        if(d.x < 0.00007){\n        \thit = true;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getRd(vec3 ro,vec3 lookAt,vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + (right*uv.x + up*uv.y)*0.8);\n}\nvec3 getNormala(vec3 p){\n\tvec2 t = vec2(0.001,0.);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0.);\n\treturn normalize(-vec3(\n    \tmap(p - t.xyy).x - map(p + t.xyy).x ,\n    \tmap(p - t.yxy).x - map(p + t.yxy).x ,\n    \tmap(p - t.yyx).x - map(p + t.yyx).x \n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 uvn = uv;\n    uv *= 1. + dot(uv,uv)*0.4;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.xy += vec2(cos(iTime*0.6), sin(iTime*0.5)*0.1)*3.;\n    \n    ro.z += iTime*10.;\n    \n    vec3 lookAt = vec3(0,0,ro.z + 1.5);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xy *= rotgood(-cos(iTime)*0.1);\n    \n    vec3 p; float t; bool hit; float tA;\n\tfloat tF;\n    side = sign(map(ro).x);\n    vec2 d;\n    int iters = 2;\n    for(int i = 0; i < iters + min(iFrame, 0); i++){\n        d = march(ro, rd, p, t, hit);\n        \n        if(i == 0) \n            tF = t;\n        tA = max(t, tA);\n        if(hit){\n\t\t\tvec3 n = getNormal(p)*side;\n\t\t\tvec3 l = normalize(vec3(1));\n            \n            float diff = max(dot(n,l), 0.);\n            float spec = pow(max(dot(reflect(l, -rd),n),0.), 20.);\n            float fres = pow(1. - max(dot(n,-rd), 0.), 5.);\n            #define ao(j) clamp(map(p + n*j).x/j, 0., 1.)\n            #define sss(j) smoothstep(0., 1.,map(p + l*j).x/j)\n            float a = ao(0.4)*ao(0.1)*ao(0.1);\n    \t\t\t\t        \n            vec3 lCol = vec3(0.3,0.7,1.);\n            if(d.y > 10.){\n                col += 0.04*(pow(fres, 1.)*lCol + glow*0.0002 + lCol*spec*0.8)*att*a;\n                ro = p;\n                //rd = refract(rd, n, 0.99);\n                //side *= -1.;\n                rd = reflect(rd, n);\n                att *= vec3(0.6,0.5,0.6)*0.4;\n            } else if(d.y > 5.){\n                //col += vec3(0.7,0.7,0.4)*att*(a  + glow*0.0004 + sss(0.2 ));\n                col += vec3(0.7,0.7,0.4)*att*fres*4.*(glow*0.0004 );\n                //rd = reflect(rd, n);\n                ro = p;\n                //rd = refract(rd, n, 0.95);\n                //side *= -1.;\n                //att *= 0.8;\n            \tbreak;\n            } else {\n            \tcol += vec3(0.4,0.2,0.1)*((0.10 + diff*1.*fres)*att + spec*0.4*lCol)*a*att;\n            \tbreak;\n            }\n            \n            //#define FOG vec3(0.25,0.14,0.32)*0.06\n            //#define FOG vec3(0.15,0.14,0.28)*0.06\n            #define FOG vec3(0.15 + mmmm*0.2,0.10,0.28)*0.04\n            if (i == iters - 1){\n    \t\t\tcol = mix(col, FOG*att, smoothstep(0.,1.,tA*0.015));\n            \n            }\n\n        }\n    \n    }\n    \n    \n    col += glowb*0.002;\n    \n    col = mix(col, FOG*0.06, pow(smoothstep(0.,1.,tF*0.015), 1.4));\n    //col = mix(col, FOG*0.06, pow(smoothstep(1.,0.,exp(-(abs(p.y) - 5.)*20.)), 1.4));\n    \n    //col = mix(col, vec3(0.1,0.54,0.512)*0.06, smoothstep(0.,1.,tA*0.03));\n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 249, 249, 1398]], "test": "untested"}
{"id": "3dsyDM", "name": " Coronavirus remix jam", "author": "kromlet", "description": "You must tag 10 peopl to remix or else you'll catch coronavirus.\nIn particular,  you can make use of the coronavirus SDF on line 51, `virus`, \n- char stiles & max bittker & chirag davé\n\nRemixed from: https://www.shadertoy.com/view/3sfcWN", "tags": ["2d", "sdf", "jam", "coronavirus", "covid19"], "likes": 3, "viewed": 321, "published": 3, "date": "1584914626", "time_retrieved": "2024-07-30T21:17:17.929146", "image_code": "//    _____ _      _       _____ _               _\n//   / ____(_)    | |     / ____| |             | |\n//  | (___  _  ___| | __ | (___ | |__   __ _  __| | ___ _ __\n//   \\___ \\| |/ __| |/ /  \\___ \\| '_ \\ / _` |/ _` |/ _ \\ '__|\n//   ____) | | (__|   <   ____) | | | | (_| | (_| |  __/ |\n//  |_____/|_|\\___|_|\\_\\ |_____/|_| |_|\\__,_|\\__,_|\\___|_|\n//  🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠\n//\n// Coronavirus Shader Demo Chain Mail\n//\n// Mutate this shader and \"retransmit\" it!\n// Be sure to tag \"coronavirus\"\n\n#define PI 3.1415926538\n#define TAU 6.2831853076\n#define spokes 5.0\n\n// THESE ARE SOME HELPER FUNCTIONS :-)\n\n// smooth minimum\nfloat smin(float a, float b, float k) {\n  float res = exp2(-k * a) + exp2(-k * b);\n  return -log2(res) / k;\n}\n\n// rotate a in input vec2 around its origin;\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\n// how far a point p is from the line segment from a to b\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\n////// END OF HELPER FUNCTIONS!\n\n// Draws a cool virus!\nfloat virus(vec2 input_pos, vec2 offset, float rotation, float scale) {\n\n  // prepare the coordinates based on the input transformations.\n  vec2 pos = rotate(input_pos + offset, rotation) / scale;\n  float angle = atan(pos.y, pos.x);\n\n  // this forms the middle blobby part of the virus:\n  float sphere = (length(pos) - 0.6); // the base\n  float wave = (pow(abs(sin(angle * spokes)), 6.) *\n                0.31); // goes up and down around the circle\n  float body = sphere - wave + (sin(sin(angle * 40.)) * 0.005);\n\n  // These are the lil round nubs of the crown\n  float repeatedAngle = floor((angle + .666) * spokes / PI) / spokes * PI;\n  repeatedAngle += -.31;\n\n  float boopRadius = 0.15;\n  boopRadius += sin(repeatedAngle*8. +iTime *4.) * 0.004;\n  float angleSweep = TAU / 100.;\n\n  float startAngle = repeatedAngle - angleSweep;\n  float endAngle = repeatedAngle + angleSweep;\n\n  vec2 dotStart = vec2(cos(startAngle), sin(startAngle)) * boopRadius;\n  vec2 dotEnd = vec2(cos(endAngle), sin(endAngle)) * boopRadius;\n  float crown = sdSegment(pos, dotStart, dotEnd) - (0.25 * sin(iTime));\n\n  // Combine the nubs and body with smoothing\n  return smin(crown, body, 40.0);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 uv = (fragCoord / iResolution.xy - 0.5) *\n            2.0; // (0,0) is in the center of the screen\n\n  uv.x *= iResolution.x /\n          iResolution.y; // sadly the screen is not square, we must fix uv ratio\n\n  // Background color\n  vec3 col = vec3(1.000, 0.891, 0.674);\n\n    \n    for(int i = 0; i < 10; i++) {\n        vec2 offset = vec2(-1.25 + float(i)*0.25, 0.3 + sin(iTime * 3. + float(i)/3.));\n        float rotation = sin(iTime);\n        float scale = 0.25;\n        float v = virus(uv, offset, rotation, scale);\n         if (v < 0.13 * abs(sin(iTime/3.))) {\n\n        // green inside\n        col *= vec3(0.600, 0.7567, 0.429);\n        col *= 1.0 + (uv.y + 0.5) * 0.2;\n\n      } else if (v < 0.24) {\n        // pink border\n        col = vec3(0.800, 0.567, 0.629);\n      }\n    }\n\n  col.yz -= length(pow(abs(uv), vec2(4.0)) * vec2(0.025 * abs(cos(iTime)) + 0.01)); // add the red\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[666, 684, 723, 723, 793], [795, 840, 870, 870, 958], [960, 1018, 1068, 1068, 1192], [1227, 1250, 1321, 1387, 2419], [2420, 2420, 2475, 2475, 3417]], "test": "untested"}
{"id": "WdlcWM", "name": "Gray Scott Reaction Diffusion 2", "author": "Eybor", "description": "An better implementation of Gray Scott Model of Reaction Diffusion. You can reinitialize the shader by pressing space, or draw on it with your mouse.", "tags": ["2d", "reactiondiffusion", "multipass"], "likes": 1, "viewed": 672, "published": 3, "date": "1584914191", "time_retrieved": "2024-07-30T21:17:18.764911", "image_code": "// I used hash function from https://www.shadertoy.com/view/XdGfRR\n\n// An better implementation of Gray Scott Model of Reaction Diffusion.\n// You can reinitialize the shader by pressing space, or draw on it with your mouse.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float f = 8.*texture(iChannel0, uv).r;\n\n\tfloat iPos = floor(f);\n    float fPos = fract(f);\n    \n    vec3 c1 = hash31(iPos-1.);\n    vec3 c2 = hash31(iPos);\n\n    vec3 color = mix(c1, c2, fPos);\n    \n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash functions from https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//vec4 params = vec4(.04,.06,.2,.1);\n//vec4 params = vec4(.02,.05,.2,.1);\nvec4 params = vec4(.02,.05,.1,.05);\n\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(texture(iChannel0, vec2(0.)).w == 0. || texture(iChannel2,  vec2(0.126953125, .25)).x > 0.)\n   \t{\n        if(fragCoord.x > iResolution.x/4. && fragCoord.x < 3.*iResolution.x/4. &&\n           fragCoord.y > iResolution.y/4. && fragCoord.y < 3.*iResolution.y/4.)\n        {\n            fragColor.xyz = vec3(.5);\n        }\n        else\n        { \n            fragColor.xyz = vec3(1.);\n        }\n        fragColor.w = 1.; \n    }\n\telse\n    {       \n        vec3 laplacian =    texture(iChannel0, (fragCoord-vec2(0., 1.))/iResolution.xy).rgb +\n                            texture(iChannel0, (fragCoord-vec2(1., 0.))/iResolution.xy).rgb -\n                         4.*texture(iChannel0, fragCoord/iResolution.xy).rgb +\n            \t\t\t \ttexture(iChannel0, (fragCoord+vec2(1., 0.))/iResolution.xy).rgb +\n            \t\t\t \ttexture(iChannel0, (fragCoord+vec2(0., 1.))/iResolution.xy).rgb;\n                \n        vec3 vu = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n        vec3 vv = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n        \n        vec3 newColor = vu + params.z*laplacian+params.x*(1.-vu)-vu*vv*vv;\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 mousePos = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n            vec2 pos = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n            vec2 v = pos-mousePos;\n\n            float d = sqrt(dot(v, v));\n            \n            newColor = mix(newColor, vec3(.5), step(d, .05));\n        }\n        \n        fragColor = vec4(newColor, 1.);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(texture(iChannel1, vec2(0.)).w == 0. || texture(iChannel2,  vec2(0.126953125, .25)).x > 0.)\n   \t{\n        if(fragCoord.x > iResolution.x/4. && fragCoord.x < 3.*iResolution.x/4. &&\n           fragCoord.y > iResolution.y/4. && fragCoord.y < 3.*iResolution.y/4.)\n        {\n            fragColor.xyz = vec3(.25);\n        }\n        else\n        {\n            fragColor.xyz = vec3(0.);\n        }\n        fragColor.w = 1.;\n    }\n    else\n    {\n        vec3 laplacian =    texture(iChannel1, (fragCoord-vec2(0., 1.))/iResolution.xy).rgb +\n                            texture(iChannel1, (fragCoord-vec2(1., 0.))/iResolution.xy).rgb -\n                         4.*texture(iChannel1, fragCoord/iResolution.xy).rgb +\n            \t\t\t \ttexture(iChannel1, (fragCoord+vec2(1., 0.))/iResolution.xy).rgb +\n            \t\t\t \ttexture(iChannel1, (fragCoord+vec2(0., 1.))/iResolution.xy).rgb;\n\n        vec3 vu = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n        vec3 vv = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n        \n        vec3 newColor = vv + params.w*laplacian-(params.x+params.y)*vv+vu*vv*vv;\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 mousePos = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n            vec2 pos = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n            vec2 v = pos-mousePos;\n\n            float d = sqrt(dot(v, v));\n            \n            newColor = mix(newColor, vec3(.25), step(d, .05));\n        }\n        \n        fragColor = vec4(newColor, 1.);\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 282, 282, 562]], "test": "untested"}
{"id": "WdlyDM", "name": "Endless Voronoi", "author": "jerky", "description": "Mouse to zoom.\n1,2,3: toggle layers\nP: toggle points\nD: toggle debug rings", "tags": ["2d", "voronoi", "zoom", "endless"], "likes": 12, "viewed": 353, "published": 3, "date": "1584912116", "time_retrieved": "2024-07-30T21:17:19.647551", "image_code": "// This is free and unencumbered software released into the public domain.\n// https://unlicense.org/UNLICENSE\n\n#define RANK_1           6\n#define RANK_2           7\n#define RANK_3           9\n#define ZOOM_SPEED_1     2.\n#define ZOOM_SPEED_2     3.\n#define ZOOM_SPEED_3     5.\n#define ROTATE_SPEED_1  10.\n#define ROTATE_SPEED_2  -5.\n#define ROTATE_SPEED_3   3.\n#define SATURATION_1     1.0\n#define SATURATION_2     0.5\n#define SATURATION_3     0.75\n#define POINT_SIZE       0.0002\n\n/* library */\n\nconst float PI = radians(180.f);\nconst float TAU = radians(360.f);\n\nfloat length2(vec2 p) { return p.x * p.x + p.y * p.y; }\nint idiv(int a, int b) { return (a + (a > 0 ? b - 1 : 0)) / b; }\n\nvec3 hsv2rgb(float h, float s, float v) {\n    h = fract(h) * 6.;\n    float c = v * s;\n    float x = c * (1. - abs(mod(h, 2.) - 1.));\n    float m = v - c;\n    switch (int(h)) {\n        case 6:\n        case 0: return m + vec3(c, x, 0);\n        case 1: return m + vec3(x, c, 0);\n        case 2: return m + vec3(0, c, x);\n        case 3: return m + vec3(0, x, c);\n        case 4: return m + vec3(x, 0, c);\n        case 5: return m + vec3(c, 0, x);\n    }\n}\n\nbool keyToggle(int key) {\n    return texelFetch(iChannel0, ivec2(key, 2), 0).x > 0.;\n}\n\n/* voronoi */\n\nfloat res_d = 1./0.;\nvec3 res_color = vec3(0, 0, 0);\nvec2 p;\nint debug_rings = 0;\n\nvoid add_point(vec2 pos, vec3 color) {\n    float distance_from_center = length2(p);\n    float d = length2(pos - p.xy);\n    if (res_d < d)\n        return;\n    res_d = d;\n    res_color = !keyToggle(80/*p*/) && d < distance_from_center * POINT_SIZE\n        ? color * 0.8\n        : color * atan(distance_from_center / d / 2.) / PI * 2.;\n}\n\n// This function adds an infinity number of nested rings to the Voronoi Diagram.\n// The ring is a group of points at the same radius. Each ring consists of\n// `rank` points.\n//\n// The trick is, for each pixel, this function is checking only three possible\n// points: one in the ring above, one in the ring bellow, and one in two rings\n// bellow.\nvoid endless(int rank, float zoom, float rotation, float sat) {\n    if (rank <= 2) return;\n    float ring_dist = (1. + sin(PI / float(rank))) / cos(PI / float(rank));\n    zoom *= float(rank);\n\n    int center_ring = int(floor(log(length2(p)) / 2. / log(ring_dist) - zoom));\n    float alpha = (atan(p.y, p.x) / TAU - rotation) * float(rank);\n    float alpha1 = floor(alpha + 0.5) / float(rank);\n    float alpha2 = floor(alpha) / float(rank);\n\n    debug_rings += center_ring;\n    for (int ring = center_ring - 1; ring <= center_ring + 1; ring++) {\n        float shift = float(abs(ring) % 2) / 2. / float(rank);\n        float color_shift = float(idiv(3 * ring, 2)) / float(rank);\n        float d = abs(ring) % 2 == 0 ? alpha1 : alpha2;\n        float t = (rotation + shift + d) * TAU;\n        vec2 pos = pow(ring_dist, float(ring) + zoom) * vec2(cos(t), sin(t));\n        add_point(pos, hsv2rgb(d + color_shift, sat, 1.));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    p.xy = (fragCoord.xy - iResolution.xy / 2.) * pow(2., 20. * iMouse.x / iResolution.x);\n    float rot = iTime / 1000.;\n    float zoom = iTime / 100.;\n\n    if (!keyToggle(49/*1*/))\n        endless(RANK_1, zoom * ZOOM_SPEED_1, rot * ROTATE_SPEED_1, SATURATION_1);\n    if (!keyToggle(50/*2*/))\n        endless(RANK_2, zoom * ZOOM_SPEED_2, rot * ROTATE_SPEED_2, SATURATION_2);\n    if (keyToggle(51/*3*/))\n        endless(RANK_3, zoom * ZOOM_SPEED_3, rot * ROTATE_SPEED_3, SATURATION_3);\n\n    float debug_shade = keyToggle(68/*d*/) ? float(debug_rings % 2) / 4. + 0.5 : 1.;\n\n    fragColor = vec4(res_color, 1.) * debug_shade;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyDM.jpg", "access": "api", "license": "public-domain", "functions": [[564, 564, 587, 587, 619], [620, 620, 644, 644, 684], [686, 686, 727, 727, 1137], [1139, 1139, 1164, 1164, 1225], [1325, 1325, 1363, 1363, 1659], [1661, 2007, 2070, 2070, 2931], [2933, 2933, 2988, 2988, 3614]], "test": "untested"}
{"id": "tdXyDM", "name": "Apollonian Sphere", "author": "mla", "description": "Another sphere; this one has an Apollonian gasket on it.", "tags": ["sphere", "apollonian", "polyhedron"], "likes": 9, "viewed": 379, "published": 3, "date": "1584895216", "time_retrieved": "2024-07-30T21:17:20.466362", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Project an Apollonian gasket onto a sphere.\n//\n// Since (reverse) stereographic projection preserves circles (it's an inversion)\n// we can use it to project a planar Apollonian gasket onto a sphere.\n//\n// The gasket is generated from an n-sided prism and the resulting pattern is\n// based on the dual double ended n-sided pyramid (except for n = 3 where\n// both patterns are tetrahedra).\n//\n// <mouse>: apply a Mobius transform to the sphere\n// <up>/<down>: move in and out\n// <left>/<right>: change number of circles\n// b: show background\n// c: color cycle\n// r: autorotation\n// s: show sphere\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float AA = 2.0;\nconst int maxiterations = 50;\n\nint NCIRCLES = 5;      // 3 or more\nbool dobackground = true;\nbool docolorcycle = false;\nbool dorotate = true;\nbool dosphere = true;\n\nbool dotetrahedron = false;\n\nconst float PI = 3.14159265;\n\nvec3 hsv2rgb(vec3 c);\nvec3 transform(in vec3 p);\n\n// If z is inside the circle, invert to the outside.\n// s is 1 or -1, and sets sense of \"inside\"\nbool checkinverse(inout vec2 z, vec3 circle, float s) {\n  vec2 c = circle.xy;  // Centre of circle\n  float r2 = circle.z; // Radius squared\n  vec2 p = z-c;\n  float p2 = dot(p,p);\n  if (s*p2 > s*r2) return false;\n  z = p*r2/p2 + c;\n  return true;\n}\n\n// A ring of circles, centred on the unit circle, with\n// incircle and outcircle. No outcircle for tetrahedron.\nbool checkcircles(inout vec2 z) {\n  float theta = PI/float(NCIRCLES);\n  float r = 1.0/cos(theta);\n  float s = tan(theta);\n  vec3 c1 = vec3(0,0,pow(r-s,2.0));\n  vec3 c2 = vec3(0,0,pow(r+s,2.0));\n  if (checkinverse(z,c1,1.0)) return true;\n  if (!dotetrahedron && checkinverse(z,c2,-1.0)) return true;\n  for (int i = 0; i < NCIRCLES; i++) {\n    float t = 2.0*float(i)*theta-0.5*PI;\n    vec3 c = vec3(r*cos(t), r*sin(t), s*s);\n    if (checkinverse(z,c,1.0)) return true;\n  }\n  return false;\n}\n\n// r*(1+sqrt(2)) = 1 => r = 1/(1+sqrt(2))\nvec3 gasket(vec2 z){\n  // 3 circles can either be a tetrahedron, with some\n  // special casing, or a triangular prism (with dual\n  // a double triangular pyramid).\n  if (dotetrahedron) z /= 2.0; // Scale for tetrahedron.\n  for(int n = 0; n < maxiterations; n++){\n    if (!checkcircles(z)) return vec3(z,n);\n  }\n  return vec3(z,maxiterations);\n}\n\nvec3 gasketcolor(vec2 z) {\n  vec3 data = gasket(z);\n  float threshold = 9.0;\n  float t = docolorcycle ? 0.1*iTime : 0.0;\n  return hsv2rgb(vec3(t+data.z/float(maxiterations),1,1));\n}\n\n// R3 inversion in sphere, centre q, square radius r2.\nvec3 invert(vec3 p, vec3 q, float r2) {\n  p -= q;\n  p *= r2/dot(p,p);\n  p += q;\n  return p;\n}\n\nvec3 stereographic0(vec3 p) {\n  return invert(p,vec3(0,0,-1),2.0);\n}\n\n// Invert in sphere radius sqrt(2), centre (0,0,-1)\n// is stereographic projection from the unit sphere\n// to z=0 (and its inverse).\nvec2 stereographic(vec3 p) {\n  return stereographic0(p).xy;\n}\n\nvec3 istereographic(vec2 z) {\n  return stereographic0(vec3(z,0));\n}\n\nvec3 getspherecolor(vec3 p) {\n  // Apply inversion to sphere.\n  if (true) {\n    vec3 q = vec3(0);\n    if (iMouse.x > 0.0) {\n      vec3 m = vec3((2.0*iMouse.xy-iResolution.xy)/iResolution.y,0);\n      q = vec3(m.xyz);\n    }\n    // Any point is the centre of a sphere orthogonal to the\n    // unit sphere, inverting in which leaves the unit sphere\n    // invariant. Any point inverts to another point on the\n    // line to the sphere centre, so just find other\n    // intersection of ray p to r with unit sphere.\n    // |p + kr|^2 = 1 where r = q-p\n    // (p.p + 2kp.r + k^2(r.r)) = 1\n    // 2p.r + k(r.r) = 0 since p.p = 1 & dividing by k\n    vec3 r = q-p;\n    float k = -2.0*dot(p,r)/dot(r,r);\n    p += k*r;\n  }\n  p = transform(p); // autorotation\n  // And stereographic projection from (0,0,1) to plane z = 0\n  return gasketcolor(stereographic(p));\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  vec3 p;       // centre\n  float r;      // radius\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit[2]) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // Formula for x^2 + 2Bx + C = 0\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t0,t1;\n  if (B >= 0.0) {\n    t0 = -B-D; t1 = C/t0;\n  } else {\n    t1 = -B+D; t0 = C/t1;\n  }\n  hit[0] = Hit(t0,(q+t0*d-p)/r);\n  hit[1] = Hit(t1,(q+t1*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit[2]) {\n  Sphere s = Sphere(vec3(0),1.0);\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\n\nvec3 solve(Ray r,vec2 uv) {\n  Hit hit[2];\n  vec3 c = vec3(0);\n  if (!dosphere || !intersectScene(r,hit)) {\n    if (dobackground) {\n      vec3 p = istereographic(uv);\n      c = getspherecolor(p);\n      c *= dosphere ? 0.2 : 0.8;\n    }\n  } else {\n    for (int i = 0; i < 2; i++) {\n      vec3 n = hit[i].n;\n      if (dot(r.d,n) > 0.0) n *= -1.0;\n      vec3 basecolor = getspherecolor(hit[i].n);\n      if (basecolor == vec3(0)) continue;\n      vec3 color = vec3(0);\n      float ambient = 0.5;\n      float diffuse = 0.5;\n      color += basecolor*ambient;\n      color += basecolor*diffuse*max(0.0,dot(light,n));\n      float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n      vec3 speccolor = basecolor; //vec3(1);\n      color += 0.5*specular*speccolor;\n      return color;\n    }\n  }\n  return c;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (false && iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dobackground = !key(CHAR_B);\n  docolorcycle = key(CHAR_C);\n  dorotate = !key(CHAR_R);\n  dosphere = !key(CHAR_S);\n  NCIRCLES = max(3,5+keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  dotetrahedron = NCIRCLES == 3;\n\n  light = vec3(0.5,1.0,1.0);\n  light = normalize(light);\n\n  vec3 p = vec3(0,0,6);\n  p.z *= exp(-0.1*float(keycount(KEY_UP)-keycount(KEY_DOWN)));\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,-6);\n      r = normalize(r);\n      col += solve(Ray(p,r),uv);\n    }\n  }\n  fragColor = vec4(pow(col/(AA*AA),vec3(0.4545)),1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1063, 1160, 1215, 1215, 1407], [1409, 1521, 1554, 1554, 2009], [2011, 2053, 2073, 2216, 2397], [2399, 2399, 2425, 2425, 2580], [2582, 2637, 2676, 2676, 2730], [2732, 2732, 2761, 2761, 2800], [2802, 2935, 2963, 2963, 2996], [2998, 2998, 3027, 3027, 3065], [3067, 3067, 3096, 3128, 3917], [4161, 4161, 4218, 4218, 4684], [4686, 4686, 4730, 4730, 4837], [4852, 4852, 4879, 4879, 5653], [5871, 5871, 5891, 5891, 5951], [5953, 5953, 5978, 5978, 6026], [6028, 6028, 6051, 6051, 6083], [6085, 6180, 6207, 6207, 6383], [6385, 6385, 6415, 6415, 6467], [6469, 6469, 6496, 6496, 6834], [6836, 6836, 6888, 6888, 7569]], "test": "untested"}
{"id": "tsfcWN", "name": "泰森多边形 Voronoi", "author": "ywqy", "description": "泰森多边形", "tags": ["voronoi"], "likes": 2, "viewed": 288, "published": 3, "date": "1584892892", "time_retrieved": "2024-07-30T21:17:21.244282", "image_code": "//learn from https://thebookofshaders.com/12/?lan=ch\n//Then learn from https://iquilezles.org/articles/voronoilines\n\n#define ANIMATE\n\nvec2 random2( vec2 p ) {\n    return fract(sin(\n        vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)))\n    )*43758.5453);\n}\n\nvec3 voronoi(in vec2 uv) {\n    \n\t//整数小数分离\n    //Tile the space\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    \n    //----------------------------------\n    // 通道一：常规网格噪声\n    // first pass: regular vornoi\n    //----------------------------------\n    \n    //最短向量，最近邻居\n    vec2 minVector, nearNeighbor;\n    \n    //最短距离\n    float minDistance = 8.0;\n    \n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n        \t//当前邻居\n            //Neigbor place in the grid\n            vec2 curNeighbor = vec2(float(x), float(y));\n            \n            //获取邻居的随机点\n            //Random position from current + neighbor place in the grid\n            vec2 neighborPoint = random2(i_uv + curNeighbor);\n            \n            #ifdef ANIMATE\n            neighborPoint = 0.5 + .5*sin(iTime + 3.14159 * neighborPoint);\n            #endif\n            \n            //像素点到邻居随机点的距离\n            //Vector from the pixel to point\n            vec2 curVector = curNeighbor + neighborPoint - f_uv;\n            \n            //计算长度\n            //calculate distance\n            float curDistance = dot(curVector, curVector);\n            \n            //滤出最短距离，邻居，向量\n            if(curDistance < minDistance) {\n            \tminDistance = curDistance;\n                minVector = curVector;\n                nearNeighbor = curNeighbor;\n            }\n        }\n    }\n    \n    //----------------------------------\n    // 通道二：边界距离\n    // second pass: distance to borders\n    //----------------------------------\n    \n    minDistance = 8.0;\n    for (int y = -2; y <= 2; y++) {\n        for (int x = -2; x <= 2; x++) { \n        \t//最近邻居的邻居\n            //Neighbor'Neighbor\n            vec2 curNeighbor = nearNeighbor + vec2(float(x), float(y));\n            \n            vec2 neighborPoint = random2(i_uv + curNeighbor);\n            \n            #ifdef ANIMATE\n            neighborPoint = 0.5 + .5*sin(iTime + 3.14159 * neighborPoint);\n            #endif\n            \n            vec2 curVector = curNeighbor + neighborPoint - f_uv;\n            \n            //排除自相交\n            if(dot(minVector - curVector, minVector - curVector)>0.00001)\n            \t//像素在最近点和次近点的比值\n                minDistance = min(minDistance, \n                         dot(0.5 * (minVector + curVector),\n                             normalize(curVector - minVector)\n                            ));\n            \n        }\n    }\n    \n    return vec3(minDistance, minVector);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xx;\n    \n    vec3 c = voronoi( 8.0*uv );\n\n    //画等值线\n    //Show isolines\n    vec3 addColor= vec3(0.3, .6, 0.6);\n    vec3 color = c.x * (.5 + .5*sin(32.0*c.x))*vec3(1.0);\n    \n    //画边界\n    //Draw broders\n    color = mix(addColor, color, smoothstep(.04, .07, c.x));\n    \n    //画细胞中心\n    //Draw cell center\n    float dd = length(c.yz);\n\tcolor = mix(addColor, color, smoothstep(0.0, 0.12, dd) );\n    color += addColor * (1.0-smoothstep( 0.0, 0.04, dd));\n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 158, 158, 279], [281, 281, 307, 355, 2922], [2925, 2925, 2982, 2982, 3543]], "test": "untested"}
{"id": "wdlcWN", "name": "buggy video", "author": "ManuManu", "description": "You need to tune your TV set...\n\n\nstarted from Iq's green keying effect :\nhttps://www.shadertoy.com/view/XsfGzn", "tags": ["2d", "chroma", "chroma", "greenscreen", "chromakey", "matte", "compositing", "despillbuggyeffect"], "likes": 4, "viewed": 445, "published": 3, "date": "1584879705", "time_retrieved": "2024-07-30T21:17:22.023199", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define METHOD 2  // try method 1 and method 2\n\n\n// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    // changing offset magnitude over time :\n    float maxMag = 1./50.;\n    float timeFreqFactor = 2.;\n    float timeNoiseFactor = 1.2;\n    float sinPower = 6.;\n    float noiseTimeFactor = 10.;\n    float offsetMag = maxMag * pow( sin(iTime*timeFreqFactor + timeNoiseFactor*noise( vec2(0.,iTime*noiseTimeFactor) ) ), sinPower );\n    //offsetMag = maxMag;\n    \n    // changing offset pos over time :\n    float timeChgFreq = .1;\n    float nbDifferentPos = 10.;\n    float timeChgFactor = 1.;\n    float timeChg = mod ( floor( iTime / timeChgFreq ), nbDifferentPos) * timeChgFactor;\n    //float timeChg = ( iTime - mod( iTime, timeChgFreq)) / timeChgFreq * 0.01;\n    //float timeChg = fract( iTime / timeChgFreq ) * 0.01;\n    //timeChg = 0.;\n    \n    float freqFact = 50.;\n    //float xoffset = hash( vec2(.0, q.y + timeChg) ).x * offsetMag;\n    float xoffset = noise( vec2(0., freqFact*(q.y + timeChg)) ) * offsetMag;\n    \n    \n    vec2 q_offset = vec2(q.x + xoffset, q.y);\n    \n    vec3 bg = texture( iChannel0, q ).xyz;\n\tvec3 fg = texture( iChannel1, q_offset ).xyz;\n\t\n    \n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    \n#if METHOD==1\n    \n\tfloat ll = length( fg );\n    fg.g = min( fg.g, maxrb*0.8 );\n    fg = ll*normalize(fg);\n\n#else    \n\n    float dg = fg.g; \n    fg.g = min( fg.g, maxrb*0.8 ); \n    fg += dg - fg.g;\n\n#endif\n\n    fragColor = vec4( mix(fg, bg, k), 1.0 );\n}\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlcWN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[175, 203, 224, 224, 343], [345, 345, 371, 371, 829], [831, 831, 851, 851, 1081], [1083, 1083, 1140, 1140, 2604]], "test": "untested"}
{"id": "3sfyD7", "name": "my sha_1", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 7, "viewed": 376, "published": 3, "date": "1584877085", "time_retrieved": "2024-07-30T21:17:22.853978", "image_code": "mat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Xor(float a, float b){\n return a*(1.-b)+   b*(1.-a);\n}\n\nfloat HexDist(vec2 p){\n\tp = abs(p);\n    float c= dot(p,normalize(vec2(1,1.73)));\n    c=max(c,p.x);   \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.465*iResolution.xy)/iResolution.y;\n\n    uv*=Rot(3.1415926535/3.);\n    vec3 col = vec3(0);\n    float d=HexDist(uv);\n    uv*=10.;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float m=0.1;\n    float c=0.1;\n    float t = iTime;\n    \n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n    \t\tvec2 offs = vec2(x,y);\n            float d=HexDist(gv+offs);\n            float dist=length(id-offs)*.3;\n            float r = mix(.3,1.5,sin(dist-t)*.5+.5);\n            c=Xor(c,smoothstep(r,r*0.95,d));\n    \t}\n    }\n    col+=c;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 77], [79, 79, 107, 107, 139], [141, 141, 163, 163, 258], [260, 260, 317, 317, 932]], "test": "untested"}
{"id": "WsfcW7", "name": "Compass and Straightedge", "author": "eiffie", "description": "A challenge for the home quarantined. Draw the regular polygons with a compass and straight edge.", "tags": ["compass"], "likes": 13, "viewed": 381, "published": 3, "date": "1584875787", "time_retrieved": "2024-07-30T21:17:23.736619", "image_code": "//Compass and Straight Edge by eiffie\n//a day into home quarantine and I'm bored enough to try creating\n//the regular polygons using a compass and straight edge\n//i got to 9... almost :)\n//there is no math here just a recreation of the chalk scribbles\n#define tym iTime\n#define rez iResolution.xy\n#define tau 6.283\n\nfloat hash(vec2 v){return fract(sin(dot(v,vec2(117.0,113.3)))*4036.123);}\nvec2 norm(float a){return vec2(cos(a),sin(a));}\nvec3 compass(vec2 v, vec2 c, float r){\n  v-=c;\n  return vec3(10.0,0.3*length(v),abs(length(v)-r));\n}\nvec3 edge(vec2 v, vec2 a, vec2 b){\n  vec2 p=b-a;a=v-a;p*=clamp(dot(a,p)/dot(p,p),0.0,1.0);\n  return vec3(distance(a,p),0.3*min(length(a),length(v-b)),10.0);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 p=2.0*(2.0*U.xy-rez)/rez.x;\n  float rnd=hash(U)*0.8+0.2;\n  vec3 blue=vec3(0.5,0.6,0.7),red=vec3(0.9,0.6,0.5),green=vec3(0.6,0.7,0.5),col=vec3(10.0);\n  float time=mod(tym*0.4,6.5);//time=6.1;\n  if(time<1.0){//isosceles triangle\n    for(int i=0;i<3;i++){\n      float a=tau*float(i)/3.0+tau/12.0;\n      col=min(col,compass(p,norm(a)*0.285,0.5));\n      a+=tau/2.0;\n      col=min(col,edge(p,norm(a)*0.58,norm(a+tau/3.0)*0.58));\n    }\n  }else if(time<2.0){//square\n    for(int i=0;i<3;i++){\n      float a=tau*float(i)/3.0+tau/12.0;\n      col=min(col,compass(p,norm(a)*0.285,0.5));\n    }\n    col=min(col,edge(p,vec2(0.0,-1.0),vec2(0.0,0.75)));\n    p.y+=0.285;\n    for(int i=0;i<4;i++){\n      float a=tau*float(i)/4.0;\n      col=min(col,edge(p,norm(a)*0.5,norm(a+tau/4.0)*0.5));\n    }\n  }else if(time<3.0){//pentagon\n    p.x+=0.25;\n    for(int i=0;i<3;i++){\n      float a=tau*float(i)/3.0+tau/12.0;\n      col=min(col,compass(p,norm(a)*0.285,0.5));\n    }\n    col=min(col,edge(p,vec2(0.0,-1.0),vec2(0.0,0.75)));\n    col=min(col,edge(p,norm(tau/12.0),-norm(tau/12.0)));\n    col=min(col,edge(p,vec2(0.0),norm(-tau/12.0)*0.58));\n    p-=norm(tau/12.0)*0.285;\n    for(int i=0;i<5;i++){\n      float a=tau*float(i)/5.0;\n      col=min(col,compass(p,norm(a)*0.5,0.58));\n      a+=tau/10.0;\n      col=min(col,edge(p,norm(a)*0.9,norm(a+tau/5.0)*0.9));\n    }\n  }else if(time<4.0){//hexagon\n    col=compass(p,vec2(0.0),0.5);\n    for(int i=0;i<6;i++){\n      float a=tau*float(i)/6.0;\n      col=min(col,compass(p,norm(a)*0.5,0.5));\n      a+=tau/12.0;\n      col=min(col,edge(p,norm(a)*0.87,norm(a+tau/6.0)*0.87));\n    }\n  }else if(time<5.0){//heptagon\n    col=compass(p,vec2(0.0),0.5);\n    col=min(col,compass(p,vec2(-0.5,0.0),0.5));\n    col=min(col,edge(p,vec2(0.0),vec2(-0.5,0.0)));\n    col=min(col,edge(p,vec2(-0.25,-0.44),vec2(-0.25,0.44)));\n    for(int i=0;i<7;i++){\n      float a=tau*float(i)/7.0;a+=tau/19.7;\n      col=min(col,compass(p,norm(a)*0.5,0.44));\n      a+=tau/14.0;\n      col=min(col,edge(p,norm(a)*0.84,norm(a+tau/7.0)*0.84));\n    }\n  }else if(time<6.0){//octagon\n    col=compass(p,vec2(0.5,0.0),1.0);\n    col=min(col,compass(p,vec2(-0.5,0.0),1.0));\n    col=min(col,edge(p,vec2(0.5,0.0),vec2(-0.5,0.0)));\n    col=min(col,edge(p,vec2(0.0,-0.88),vec2(0.0,0.88)));\n    col=min(col,compass(p,vec2(0.0,0.0),0.5));\n    for(int i=0;i<4;i++){\n      float a=tau*float(i)/4.0;\n      col=min(col,compass(p,norm(a)*0.5,0.7));\n      a+=tau/8.0;\n      col=min(col,edge(p,vec2(0.0),norm(a)*0.95));\n    }\n    for(int i=0;i<8;i++){\n      float a=tau*float(i)/8.0;\n      col=min(col,edge(p,norm(a)*0.5,norm(a+tau/8.0)*0.5));\n    }\n  }else{//9gon\n    col=compass(p,vec2(0.5,0.0),1.0);\n    col=min(col,compass(p,vec2(-0.5,0.0),1.0));\n    col=min(col,edge(p,vec2(0.5,0.0),vec2(-0.5,0.0)));\n    col=min(col,edge(p,vec2(0.0,-0.88),vec2(0.0,0.88)));\n    col=min(col,compass(p,vec2(0.0,0.0),0.5));\n    col=min(col,compass(p,vec2(0.5,0.0),0.7));\n    p.x-=0.5;\n    for(int i=0;i<9;i++){\n      float a=tau*float(i)/9.0;\n      col=min(col,compass(p,norm(a),0.7));\n      a+=tau/9.0;\n      col=min(col,edge(p,norm(a),norm(a+tau/9.0)));\n    }\n  }\n  col=smoothstep(vec3(3.0/rez.y),vec3(0.0),col)*0.85+vec3(0.0,0.0,0.15);\n  O=vec4(rnd*(red*col.r+green*col.g+blue*col.b),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 316, 335, 335, 389], [390, 390, 409, 409, 437], [438, 438, 476, 476, 538], [539, 539, 573, 573, 697], [698, 698, 736, 736, 3978]], "test": "untested"}
{"id": "WsXyW7", "name": "my sha_0", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 3, "viewed": 278, "published": 3, "date": "1584870315", "time_retrieved": "2024-07-30T21:17:24.901503", "image_code": "float Xor(float a, float b){\n return a*(1.-b)+   b*(1.-a);\n}\nfloat HexDist(vec2 p){\n\tp = abs(p);\n    float c= dot(p,normalize(vec2(1,1.73)));\n    c=max(c,p.x);   \n    return c;\n}\n\nvec4 HexCoords(vec2 uv){\n    vec2 r=vec2(1.,1.73);\n    vec2 h=r*.5;\n    vec2 a=mod(uv,r)-h;\n    vec2 b=mod(uv-h,r)-h;\n    \n    vec2 gv;\n    if (length(a)<length(b)) {\n     gv=a;   \n    } else {\n        gv=b;\n    }\n    \n    float x=atan(gv.x,gv.y);\n    float y=.5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x,y,id.x,id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.47*iResolution.xy)/iResolution.y;\n\t\n    vec3 col = vec3(0);\n    \n    uv*=10.;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float m=0.1;\n    float t = iTime;\n    \n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            vec4 hc=HexCoords(uv+100.);\n    \t\tfloat c=smoothstep(.02,.1,tan(hc.x+(t*.5+.5)));\n            \n    \t\tvec2 offs = vec2(x,y);\n            float d=length(gv+offs);\n            float dist=length(id-offs)*.3;\n            float r = mix(.3,1.5,sin(dist-t)*.5+.5);\n            m=Xor(m,smoothstep(.2,.2,c));\n    \t}\n    }\n    \n    \n    \n    col+=m;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 60], [61, 61, 83, 83, 178], [180, 180, 204, 204, 510], [512, 512, 569, 569, 1235]], "test": "untested"}
{"id": "tdlcWN", "name": "every other pixel is a line", "author": "TinyTexel", "description": "Oskar Stålberg's (@OskSta) \"every-other-pixel-is-a-line\"- texture sampling approach.\nhttps://twitter.com/OskSta/status/1241096929490149376", "tags": ["shader"], "likes": 6, "viewed": 492, "published": 3, "date": "1584838791", "time_retrieved": "2024-07-30T21:17:25.675434", "image_code": "/*\n\n*/\n\nvec2 WarpCoord0(float p, float s)\n{\n    bool c = fract(p * 0.5 - 0.25) < 0.5;\n    \n    if(c) s = 1.0 - s;\n    \n    float p0 = floor(p - 0.5);\n    float l0 =      (p - 0.5) - p0;\n    \n    if(l0 < s)\n    {\n        l0 *= 0.5 / s;\n    }\n    else\n    {\n        p0 += 1.0;\n        l0 = (l0 - s) / (1.0 - s) * 0.5 + 0.5; \n    }\n    \n    if(c) l0 += 1.0;\n\n    l0 = fract(l0 + 0.5);\n    \n    return vec2(p0, l0);\n}\n\nvec2 WarpCoord(vec2 uv, float s)\n{\n    vec2 u = WarpCoord0(uv.x, s);\n    vec2 v = WarpCoord0(uv.y, s);\n    \n    return vec2(u.x + u.y, v.x + v.y);\n}\n\nfloat WarpCoordI0(float p, float s)\n{\n    if(fract(p * 0.5 - 0.25) < 0.5) \n        s = 1.0 - s;\n    \n    float p0 = floor(p - 0.5);\n    float l0 =      (p - 0.5) - p0;\n    \n    if(l0 > s) p0 += 1.0;\n    \n    return p0;\n}\n\nvec2 WarpCoordI(vec2 uv, float s)\n{\n    return vec2(WarpCoordI0(uv.x, s), WarpCoordI0(uv.y, s));\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\tvec2 tex = uv0 / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 p = uv0.xy*0.02;\n    \n    float s = 0.25;\n    s = sin(float(iTime))*0.75*0.5+0.5;\n    \n    if(tex.x < 0.5)\n    {\n        vec2 wc = WarpCoord0(p.x, s);\n        \n        if(tex.y < 0.5)\n            col = vec3(wc.x) * 0.1;\n        else\n            col = vec3(wc.y);\n    }\n    else\n    {\n    \tif(tex.y > 0.5)\n    \tcol = textureLod(iChannel0, WarpCoord(p, s)/64.0, 1.0).rgb;\n    \telse\n    \tcol = texelFetch(iChannel0, ivec2(WarpCoordI(p, s)), 0).rgb;\n    }\n    \n\toutCol = vec4(col, 1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 8, 43, 43, 413], [415, 415, 449, 449, 563], [565, 565, 602, 602, 785], [787, 787, 822, 822, 885], [888, 888, 936, 936, 1525]], "test": "untested"}
{"id": "tdlyW4", "name": "Spiral Distance Function", "author": "nbardy", "description": "A spiral I've been experimenting with to create a milky way", "tags": ["spiralsdf"], "likes": 4, "viewed": 392, "published": 3, "date": "1584826939", "time_retrieved": "2024-07-30T21:17:26.447370", "image_code": "const float a=1.0;\nconst float b=.1759;\nconst float PI=3.14159265359;\n\nfloat spiralSDF(vec2 p,vec2 c){\n    // t = theta\n    p = p - c;\n    float t=atan(p.y, p.x) + iTime*8.0;\n    // t=(t+PI)/(2.*PI);\n    float r=length(p.xy);\n    \n    float n=(log(r/a)/b-t)/(2.*PI);\n\n    // Cap the spiral\n    // float nm = (log(0.11)/b-t)/(2.0*PI);\n    // n = min(n,nm);\n    // return (n+1.0)/100.0;\n    float upper_r=a*exp(b*(t+2.*PI*ceil(n)));\n    float lower_r=a*exp(b*(t+2.*PI*floor(n)));\n    // float lower_r = 0.0;\n    \n    return min(abs(upper_r-r),abs(r-lower_r));\n}\n\nvoid mainImage(out vec4 O,vec2 I)\n{\n    vec2 R=iResolution.xy;\n    vec2 uv=(2.*I-R)/R.y;\n    // vec2 c = vec2(sin(iTime)/1.7, cos(iTime)/1.7);\n    vec2 c = vec2(0.7*sin(iTime*1.3), 0.3*sin(iTime)*2.0);\n     float r=length(uv);\n    float d = spiralSDF(uv,vec2(c));\n    float v = d;\n    // Alter distance for prettier visualizat\n    O.rgb=vec3(v);\n    // O.rgb = O.rgb*1.0/r;\n    // O.xy=uv;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 102, 119, 559], [561, 561, 596, 596, 952]], "test": "untested"}
{"id": "3slyDN", "name": "Weird line thing", "author": "michael0884", "description": "Connecting points from the spherical Fibonacci sequence", "tags": ["hmmm"], "likes": 24, "viewed": 589, "published": 3, "date": "1584821748", "time_retrieved": "2024-07-30T21:17:27.334997", "image_code": "#define M_PI 3.141592653\n\nconst float PHI = 0.5*(sqrt(5.) + 1.); \n\nvec2 fibonacci_lattice(int i, int N)\n{\n    return vec2((float(i)+0.5)/float(N), mod(float(i)/PHI, 1.)); \n}\n\nvec3 fibonacci_sphere(int i, int N)\n{\n    vec2 xy = fibonacci_lattice(i, N);\n    vec2 pt = vec2(2.*M_PI*xy.y, acos(2.*xy.x - 1.) - M_PI*0.5);\n    return vec3(cos(pt.x)*cos(pt.y), sin(pt.x)*cos(pt.y), sin(pt.y)); \n}\n\nmat4 getPerspective(float fov, float aspect, float n, float f)\n{   \n    float scale = tan(fov * M_PI / 360.) * n; \n    float r = aspect * scale, l = -r; \n    float t = scale, b = -t; \n\n\t\n    return mat4(2. * n / (r - l), 0, 0, 0,\n                0, 2. * n / (t - b), 0, 0,\n                (r + l) / (r - l), (t + b) / (t - b), -(f + n) / (f - n), -1,\n                0, 0, -2. * f * n / (f - n), 0);\n}\n\nmat4 getRot(vec2 a)\n{\n    \n   mat4 theta_rot = mat4(1, 0, 0, 0,\n                         0, cos(a.y), sin(a.y), 0,\n                         0, -sin(a.y), cos(a.y), 0,\n                         0, 0, 0, 1); \n        \n   mat4 phi_rot = mat4(cos(a.x), sin(a.x), 0, 0,\n        \t\t       -sin(a.x), cos(a.x), 0, 0,\n        \t\t        0, 0, 1, 0,\n                      \t0, 0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nmat4 getModel(vec3 dx)\n{\n   return transpose(mat4(1, 0, 0, dx.x,\n        \t   0, 1, 0, dx.y,\n               0, 0, 1, dx.z,\n               0, 0, 0, 1)); ;\n}\n\nvec3 toScreen(vec4 X)\n{\n    return vec3(iResolution.xy*(0.5*X.xy/X.w + 0.5), X.z);\n}\n\nfloat POINT(vec2 pos, float R, vec4 X)\n{\n    R *= iResolution.x;\n    vec3 spos = toScreen(X);\n    return exp(-distance(pos, spos.xy)*spos.z/R);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat interpolate(float val, vec2 p0, vec2 p1) \n{\n    return mix(p0.y, p1.y, (val-p0.x)/(p1.x-p0.x));\n}\n\nfloat interpolate3(vec2 val, vec3 p0, vec3 p1) \n{\n    return mix(p0.z, p1.z, clamp(dot(p1.xy - p0.xy, val - p0.xy)/dot(p1.xy - p0.xy,p1.xy - p0.xy), 0.,1.));\n}\n\nfloat LINE(vec2 pos, float R, vec4 X, vec4 Y)\n{\n    R *= iResolution.x;\n    vec3 spos0 = toScreen(X);\n    vec3 spos1 = toScreen(Y);\n    float d = sdSegment(pos, spos0.xy, spos1.xy)/R;\n    float depth = interpolate3(pos, spos0, spos1);\n    return exp(-d*depth-0.4*depth)+0.03*exp(-d*depth*0.05);\n}\n\n\n//a rainbow colormap from Matlab\n\nfloat base(float x) \n{\n    if ( x <= -0.75 ) return 0.0;\n    else if ( x <= -0.25 ) return interpolate( x, vec2(-0.75, 0.0), vec2(-0.25, 1.) );\n    else if ( x <= 0.25 ) return 1.0;\n    else if ( x <= 0.75 ) return interpolate( x, vec2(0.25, 1.0), vec2(0.75, 0.0) );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n \tivec2 p = ivec2(pos.xy);\n    \n    int N = iFrame%128;\n    fragColor.xyz = vec3(0.);\n    \n    mat4 perspec = getPerspective(60., iResolution.x/iResolution.y, 0.001, 10.);\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*M_PI, M_PI):vec2(iTime, M_PI*0.5+0.5*sin(iTime));\n    mat4 rot = getRot(angles);\n    mat4 sh = getModel(vec3(0.,0.,-2.));\n    vec4 pd = perspec*sh*rot*vec4(fibonacci_sphere(0, N), 1.);\n    vec4 d;\n    //rasterizer\n    for(int i = 1; i < N; i++)\n    {\n        d = perspec*sh*rot*vec4(fibonacci_sphere(i, N), 1.);\n        \n        fragColor.xyz += 2.*jet_range(sin(0.1*float(i)), -1.25, 1.25)*(LINE(pos, 0.002, d, pd)+0.33*POINT(pos, 0.03, d));     \n    \tpd = d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 212, 212, 389], [391, 391, 455, 455, 792], [794, 794, 815, 815, 1210], [1212, 1212, 1236, 1236, 1366], [1368, 1368, 1391, 1391, 1452], [1454, 1454, 1494, 1494, 1599], [1601, 1601, 1653, 1653, 1772], [1774, 1774, 1823, 1823, 1877], [1879, 1879, 1928, 1928, 2038], [2040, 2040, 2087, 2087, 2336], [2373, 2373, 2395, 2395, 2662], [2664, 2664, 2692, 2692, 2748], [2750, 2750, 2793, 2793, 2854], [2857, 2857, 2908, 2908, 3616]], "test": "untested"}
{"id": "WdlyDN", "name": "heartfelt for desktop bg", "author": "falldeaf", "description": "Playing with BigWIngs shader to create a custom desktop BG", "tags": ["rain", "desktopbg"], "likes": 31, "viewed": 1395, "published": 3, "date": "1584821522", "time_retrieved": "2024-07-30T21:17:28.199685", "image_code": "// Heartfelt - by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// I revisited the rain effect I did for another shader. This one is better in multiple ways:\n// 1. The glass gets foggy.\n// 2. Drops cut trails in the fog on the glass.\n// 3. The amount of rain is adjustable (with Mouse.y)\n\n// To have full control over the rain, uncomment the HAS_HEART define \n\n// A video of the effect can be found here:\n// https://www.youtube.com/watch?v=uiF5Tlw22PI&feature=youtu.be\n\n// Music - Alone In The Dark - Vadim Kiselev\n// https://soundcloud.com/ahmed-gado-1/sad-piano-alone-in-the-dark\n// Rain sounds:\n// https://soundcloud.com/elirtmusic/sleeping-sound-rain-and-thunder-1-hours\n\n#define S(a, b, t) smoothstep(a, b, t)\n//#define CHEAP_NORMALS\n//#define HAS_HEART\n#define USE_POST_PROCESSING\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\n\nvec2 DropLayer2(vec2 uv, float t) {\n    vec2 UV = uv;\n    \n    uv.y += t*0.75;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    float wiggle = sin(y+sin(y));\n    x += wiggle*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    float d = length((st-p)*a.yx);\n    \n    float mainDrop = S(.4, .0, d);\n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    float trail = S(.23*r, .15*r*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront*r*r;\n    \n    y = UV.y;\n    float trail2 = S(.2*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(.3, 0., dd);\n    float m = mainDrop+droplets*r*trailFront;\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*.7;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n    return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = StaticDrops(uv, t)*l0; \n    vec2 m1 = DropLayer2(uv, t)*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n    float c = s+m1.x+m2.x;\n    c = S(.3, 1., c);\n    \n    return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    vec3 M = iMouse.xyz/iResolution.xyz;\n    float T = iTime+M.x*2.;\n   \n    float t = T*.2;\n    \n    float rainAmount = 1.0;//iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;\n    \n    float story = 0.;\n    float heart = 0.;\n    \n\n    //float zoom = -cos(T*.2);\n    //uv *= .7+zoom*.3;\n    //#endif\n    //UV = (UV-.5)*(.9+zoom*.1)+.5;\n    \n    float staticDrops = S(-.5, 1., rainAmount)*2.;\n    float layer1 = S(.25, .75, rainAmount);\n    float layer2 = S(.0, .5, rainAmount);\n    \n    \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n   #ifdef CHEAP_NORMALS\n    \tvec2 n = vec2(dFdx(c.x), dFdy(c.x));// cheap normals (3x cheaper, but 2 times shittier ;))\n    #else\n    \tvec2 e = vec2(.001, 0.);\n    \tfloat cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n    \tfloat cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n    \tvec2 n = vec2(cx-c.x, cy-c.x);\t\t// expensive normals\n    #endif\n    \n    float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n    \n    \n    #ifdef USE_POST_PROCESSING\n    //t = (T+3.)*.5;\t\t\t\t\t\t\t\t\t\t// make time sync with first lightnoing\n    //float colFade = sin(t*.2)*.5+.5+story;\n    //col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\n    //float fade = S(0., 10., T);\t\t\t\t\t\t\t// fade in at the start\n    col *= vec3(.8, .6, .9);\n    //float lightning = sin(t*sin(t*10.))/6.;\t\t\t\t// lighting flicker\n    //lightning *= pow(max(0., sin(t+sin(t))), 10.);\t\t// lightning flash\n    //col *= 1.+lightning*mix(1., .1, story*story);\t// composite lightning\n    col *= .8-dot(UV-=.5, UV);\t\t\t\t\t\t\t// vignette\n    \n    //col *= fade;\t\t\t\t\t\t\t\t\t\t// composite start and end fade\n    #endif\n    \n    //col = vec3(heart);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyDN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[924, 924, 943, 969, 1141], [1143, 1143, 1162, 1162, 1250], [1251, 1251, 1269, 1269, 1315], [1317, 1317, 1346, 1346, 1381], [1384, 1384, 1419, 1419, 2571], [2573, 2573, 2610, 2610, 2886], [2888, 2888, 2948, 2948, 3167], [3169, 3169, 3226, 3226, 5147]], "test": "untested"}
{"id": "WdscWN", "name": "Gneiss", "author": "jarble", "description": "This procedural texture looks somewhat like gneiss.", "tags": ["fractal"], "likes": 1, "viewed": 250, "published": 3, "date": "1584819928", "time_retrieved": "2024-07-30T21:17:29.475275", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    //float i = 1.0;\n    for(float i = 1.0; i < mag; i++){\n    \tfragCoord += vec2(sin(fragCoord.y/(100.0*i))*10.0,sin(fragCoord.x/(100.0*mag*i))*10.0)*mag*mag;\n    }\n    \n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint savanna_biome(inout int color1, ivec4 neighbors){\n    int GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int YELLOW = 3;\n    int FOREST_GREEN = 4;\n    return (color1 == GREEN && is_next_to(GRAY,neighbors))\n    \t? YELLOW\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n    \t? FOREST_GREEN\n    :(color1 == GRAY)\n        ? GREEN\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    : color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 = \n    \tsavanna_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\n\n\nint savanna_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,SAVANNA_BIOME);\n}\n\nint savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag;\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n    //choose the biome here\n\tint biome = savanna_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 803, 840, 896, 1044], [1050, 1050, 1105, 1126, 1339], [1341, 1341, 1400, 1400, 1605], [1608, 1608, 1651, 1651, 1787], [1789, 1789, 1823, 1823, 1852], [1854, 1854, 1880, 1880, 3237], [3240, 3240, 3293, 3293, 3741], [3743, 3743, 3799, 3799, 3853], [3855, 3855, 3930, 3930, 4267], [4555, 4555, 4612, 4612, 4847]], "test": "untested"}
{"id": "WslyW4", "name": "XIII — sat.sketch #8", "author": "szczm_", "description": "I played XIII last Friday and wanted to remake the iconic look. Based off of my deferred rendering sketch. took a few hours. Kinda nailed it, I know :'", "tags": ["celshading", "outline", "toon", "comic", "frame", "comicbook", "deferred", "gbuffer", "xiii"], "likes": 16, "viewed": 695, "published": 3, "date": "1584817249", "time_retrieved": "2024-07-30T21:17:30.601264", "image_code": "/*************************************************************************************\n\n XIII — saturday sketch #8\n  — Matthias Scherba (@szczm_)\n\n\n So I played XIII last Friday and wanted to remake the iconic look.\n Based off of my deferred rendering sketch. took a few hours.\n Kinda nailed it, I know :'\n\n Not much more to add here, everything is nicely commented.\n if you have any questions hit me up on Twitter or ask in comments (:\n\n https://twitter.com/szczm_\n\n*************************************************************************************/\n\n// Image tab: Final render and frame\n\n\n#define LIT_BUFFER (iChannel0)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    time = iTime;\n    \n    vec2 coord = fragCoord / iResolution.xy;\n\n    \n    fragColor = texture(LIT_BUFFER, coord);\n    \n    \n    vec4 region = getRegion();\n    \n    // If not the active region,\n    if (!(coord.x > region.x && coord.x < region.z && coord.y > region.y && coord.y < region.w))\n    {\n        // tint ice blue.\n        fragColor = mix(fragColor, vec4(0.6, 0.9, 1.0, 1.0), 0.4);\n    }\n    \n    // Draw frames\n    for (int i = 0; i < 5; i++)\n    {\n        vec4 region = getRegion(i);\n        \n        if (coord.x > region.x && coord.x < region.z && coord.y > region.y && coord.y < region.w)\n        {\n            vec2 ep = vec2(1.0, iResolution.x / iResolution.y);\n            vec4 epp = ep.xyxy * vec4(1.0, 1.0, -1.0, -1.0);\n            \n            vec4 frame = region + epp * 0.03;\n            \n            // One\n            if (coord.x < frame.x || coord.x > frame.z || coord.y < frame.y || coord.y > frame.w)\n            {\n                fragColor = vec4(0.0);\n            }\n            \n            frame -= epp * 0.005;\n            \n            // Two\n            if (coord.x < frame.x || coord.x > frame.z || coord.y < frame.y || coord.y > frame.w)\n            {\n                fragColor = vec4(1.0);\n            }\n            \n            frame -= epp * 0.01;\n            \n            // Three.\n            if (coord.x < frame.x || coord.x > frame.z || coord.y < frame.y || coord.y > frame.w)\n            {\n                fragColor = vec4(0.0);\n            }\n            \n            return;\n        }\n    }    \n}\n\n#undef LIT_BUFFER", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "precision highp float;\n\n\n// Constants\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n\nconst int MAX_STEPS = 200;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 30.0;\nconst float EPSILON = 1e-4;\n\nconst float MIN_DIST_SHADOW = 0.0;\nconst float MAX_DIST_SHADOW = 5.5;\n\nconst vec3 CAMERA_TARGET = vec3(0.0, -0.8, 0.0);\nconst float CAMERA_FOV = 60.0;\n\nconst vec3 LIGHT_CAMERA_TARGET = vec3(0.0, -0.5, 0.0);\nconst float LIGHT_CAMERA_SIZE = 2.3;\n\nconst float MAX_ROUGHNESS = 60.0;\n\n\n// Need to set time in buffers - iTime is undefined in the Common tab\nfloat time;\n\n\n// Distance functions\n\nfloat torusSDF(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat planeSDF(vec3 p, vec3 n)\n{\n    return length(p) * dot(normalize(p), n);\n}\n\nfloat capsuleSDF(vec3 p, float h, float r)\n{\n\tp.y -= clamp(p.y, 0.0, h);\n\treturn length(p) - r;\n}\n\n\n// Gotta fix those for my drivers\n#define TAU 6.28318530718\nfloat sinf(float arg) { return sin(mod(arg, TAU)); }\nfloat cosf(float arg) { return cos(mod(arg, TAU)); }\n\n\n// Rotations\n\nvec3 rotX(vec3 p, float angle) {\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cosf(angle), -sinf(angle)),\n        vec3(1.0, sinf(angle), cosf(angle))\n    ) * p;\n}\n      \nvec3 rotY(vec3 p, float angle) {\n    return mat3(\n        vec3(cosf(angle), 0.0, sinf(angle)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sinf(angle), 0.0, cosf(angle))\n    ) * p;\n}\n      \nvec3 rotZ(vec3 p, float angle) {\n    return mat3(\n        vec3(cosf(angle), -sinf(angle), 0.0),\n        vec3(sinf(angle), cosf(angle), 0.0),\n        vec3(1.0, 0.0, 1.0)\n    ) * p;\n}\n\n\n// Structs\n\nstruct Material\n{\n    vec3 albedo;\n    float id;\n};\n\nstruct Hit\n{\n    float dist;\n    int id;\n};\n    \n\n// Tracing stuff\n    \nHit minHit(Hit a, Hit b)\n{\n    if (a.dist < b.dist)\n        return a;\n    \n    return b;\n}\n\nHit sceneSDF(vec3 p)\n{\n    p -= vec3(-0.3, -0.2, 0.2);\n    Hit scene = Hit(planeSDF(p + vec3(1.5), vec3(0.0, 1.0, 0.0)), 1);\n    \n    scene = minHit(scene, Hit(sphereSDF(p - vec3(-0.5, 0.2, 0.0), 0.7), 2));\n    scene = minHit(scene, Hit(torusSDF(p - vec3(0.5, -0.4, 1.1), vec2(0.45, 0.3)), 3));\n    scene = minHit(scene, Hit(capsuleSDF(p - vec3(1.1, -0.2, -0.7), 0.7, 0.5), 4));\n    \n    return scene;\n}\n\nHit shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    Hit finalHit = Hit(start, -1);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        Hit hit = sceneSDF(eye + finalHit.dist * marchingDirection);\n        \n        finalHit.dist += hit.dist;\n        finalHit.id = hit.id;\n        \n        if (hit.dist < EPSILON) {\n\t\t\tbreak;\n        }\n        \n        if (finalHit.dist >= end) {\n            finalHit = Hit(end, -1);\n            break;\n        }\n    }\n    \n    return finalHit;\n}\n\nvec3 getEye()\n{\n    return rotY(vec3(2.5, 2.5, 2.0), -time * TAU * 0.05);\n}\n\n\n\nvec4 getRegion(int i)\n{\n    const vec4[5] regions = vec4[]\n    (\n        vec4(0.0, 0.0, 0.2, 1.0),\n        vec4(0.2, 0.0, 0.4, 0.2),\n        vec4(0.4, 0.0, 1.0, 0.2),\n        vec4(0.8, 0.2, 1.0, 1.0),\n        vec4(0.2, 0.2, 0.8, 1.0)\n    );\n    \n    return regions[i];\n}\n\nvec4 getRegion()\n{\n    int i = int(mod(time + 4.0, 5.0));\n    \n    return getRegion(i);\n}\n\n\n// Math stuff\n\n// vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(CAMERA_FOV) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n// Light stuff\n\nconst float a = 0.95;\n\nfloat h()\n{\n    return clamp(0.0, 1.0, (mod(time - a * 0.5, 1.0) - (1.0 - a)) / a);\n}\n\nfloat g(float x)\n{\n    return floor(mod(x, 4.0)) * 0.2;\n}\n\nvec3 lightPosition()\n{\n    vec3 dir = vec3(0.0, 2.0, 0.0);\n    \n    dir = rotX(dir, -0.15 * TAU);\n    \n    float t = -0.4 + mix(g(time - a * 0.5), g(time + a * 0.5), smoothstep(0.0, 1.0, h()));\n    \n    dir = rotY(dir, t * TAU);\n    \n    return dir;\n}\n\n// This is a directional light - the direction is the same for each world position\nvec3 lightDirection()\n{\n    return -normalize(lightPosition());\n}\n\nvec3 lightColor()\n{\n    return vec3(1.0, 1.0, 0.9);\n}\n\nmat4 lightToWorldMatrix()\n{\n    return viewMatrix(lightPosition(), LIGHT_CAMERA_TARGET, UP);\n}\n\nvec3 worldPointToLightPoint(vec3 worldPoint, out float lightDist)\n{\n    vec3 lightDir = lightDirection();\n    vec3 lightPos = lightPosition();\n    \n    // Plane SDF allows easy distance calculation to ortographic plane.\n    // -lightPos = lightDir * length(lightPos)\n    lightDist = planeSDF(worldPoint, -lightPos);\n\n    mat4 worldToLight = inverse(lightToWorldMatrix());\n    \n    // Quick maths\n    vec3 lightPoint = worldPoint + lightDist * lightDir;\n\tlightPoint = (worldToLight * vec4(lightPoint, 0.0)).xyz;\n    lightPoint = (lightPoint + LIGHT_CAMERA_SIZE) / (2.0 * LIGHT_CAMERA_SIZE);\n    \n    return lightPoint;\n}\n\n\n// Packing/encoding stuff\n\nfloat map(in float val, in float startIn, in float endIn, in float startOut, in float endOut)\n{\n    float norm = (val - startIn) / (endIn - startIn);\n    return norm * (endOut - startOut) + startOut;\n}\n\nvec3 quantize(vec3 value, float steps)\n{\n    return floor(value * steps) / steps;\n}\n\nfloat packVec3(vec3 vec, float steps)\n{\n    vec3 quantized = quantize(vec, steps);\n    \n    float x = quantized.x * steps * steps;\n    float y = quantized.y * steps;\n    float z = quantized.z;\n    \n    return (x + y + z) / (steps * steps);\n}\n\nvec3 unpackVec3(float packed, float steps)\n{\n    vec3 vec = vec3(0.0);\n    \n    vec.x = fract(packed);\n    vec.y = fract(packed * steps);\n    vec.z = fract(packed * steps * steps);\n    \n    return vec;\n}\n\nvoid packGbuffer(out vec4 packed, in float depth, in vec3 normal, in Material material)\n{\n    packed = vec4(0.0);\n    \n    // values equal to 1.0 are clipped, so have to lower them a bit\n    packed.r = packVec3(normal * 0.49 + 0.49, 256.0);\n    packed.g = packVec3(material.albedo * 0.999, 256.0);\n    packed.b = packVec3(vec3(float(material.id) / 5.0), 5.0);\n    packed.a = map(depth, MIN_DIST, MAX_DIST, 0.0, 1.0);\n}\n\nvoid unpackGbuffer(in vec4 packed, out float depth, out vec3 normal, out Material material)\n{\n    vec3 matParams = unpackVec3(packed.b, 100.0);\n    \n    depth = map(packed.a, 0.0, 1.0, MIN_DIST, MAX_DIST);\n    normal = 2.0 * unpackVec3(packed.r, 256.0) - 1.0;\n\n    material.id = matParams.r * 5.0;\n    \n    material.albedo = unpackVec3(packed.g, 256.0);\n}\n\nvoid packShadow(out vec4 packed, in float depth)\n{\n    packed = vec4(map(depth, MIN_DIST_SHADOW, MAX_DIST_SHADOW, 0.0, 1.0));\n}\n\nvoid unpackShadow(in vec4 packed, out float depth)\n{\n    depth = map(packed.r, 0.0, 1.0, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n}", "buffer_a_code": "// Buffer A: Render the G buffer.\n\n// This tab has knowledge of materials, no other tab does.\n\n\nMaterial materials[4] = Material[]\n(\n    //            albedo          id\n    Material(vec3(0.6),           0.0), // floor\n    Material(vec3(0.9, 0.3, 0.0), 1.0), // sphere\n    Material(vec3(0.5, 1.0, 0.0), 2.0), // torus\n    Material(vec3(0.5, 0.2, 1.0), 3.0)  // capsule\n);\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    time = iTime;\n    \n\tvec3 viewDir = rayDirection(iResolution.xy, fragCoord);\n    \n    vec3 eye = getEye();\n    mat4 viewToWorld = viewMatrix(eye, CAMERA_TARGET, UP);\n    vec3 worldDir = (viewToWorld * viewDir.xyzz).xyz;\n    \n    Hit hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    Material material;\n        \n    if (hit.id > 0)\n    {    \n        vec3 normal = normal(eye + hit.dist * worldDir);\n        Material material = materials[hit.id - 1];\n        \n\t\tpackGbuffer(fragColor, hit.dist, normal, material);\n    }\n\n}", "buffer_a_inputs": [], "buffer_b_code": "// Buffer B: Render the shadow buffer.\n\n// This is an ortographic camera oriented around the center.\n// Parameters chosen for best quality.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    \n    vec2 coord = (-1.0 + 2.0 * fragCoord / iResolution.xy) * LIGHT_CAMERA_SIZE;\n    \n    vec3 eye = lightPosition();\n    vec3 viewDir = vec3(0.0, 0.0, -1.0);\n    \n    mat4 lightToWorld = lightToWorldMatrix();\n    \n    // Identical direction, changed position, it's an ortographical projection 🎶 (bad raps I know)\n    eye += (lightToWorld * vec4(coord.x, coord.y, 0.0, 0.0)).xyz;\n    \n    vec3 worldDir = (lightToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    Hit hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n\n    packShadow(fragColor, hit.dist);\n}", "buffer_b_inputs": [], "buffer_c_code": "// Buffer C: Render the scene.\n\n// This tab knows how to light the scene, no other tab does.\n\n\n#define G_BUFFER (iChannel0)\n#define SHADOW_BUFFER (iChannel1)\n#define THIS_BUFFER (iChannel2)\n\n\nvec3 lighting(in vec3 position, in vec3 normal, in vec3 viewDir, in Material material, in float shadow)\n{\n    vec3 lightDir = lightDirection();\n    vec3 lightCol = lightColor();\n    \n    // Diffuse\n    float ndotl = dot(normal, -lightDir);\n    float diffuseStep = step(0.01, ndotl); // toon shading\n    \n    // Final terms\n    float ambient = 0.05;\n    float diffuse = diffuseStep * shadow;\n    \n    return (ambient * material.albedo + mix(material.albedo, lightCol, diffuse * 0.5)) * lightCol;\n}\n\nfloat shadow(in vec3 position)\n{\n    float lightDist;\n\tvec3 lightPoint = worldPointToLightPoint(position, lightDist);\n    \n    float shadowDist;\n    unpackShadow(texture(SHADOW_BUFFER, lightPoint.xy), shadowDist);\n    \n    // Compare real distance to light with distance captured by the light \"camera\".\n    // If they differ, this means that something is on the way.\n    // This means one thing.\n    // Shadow.\n    // (Mapping.)\n    float shadow = shadowDist - lightDist;\n    shadow = step(0.0, shadow);\n\n    if (clamp(lightPoint.x, 0.0, 1.0) != lightPoint.x\n     || clamp(lightPoint.y, 0.0, 1.0) != lightPoint.y\n     || shadowDist >= MAX_DIST_SHADOW - 1.0)\n        shadow = 1.0;\n    \n    return shadow;\n}\n\nfloat outline(in vec2 coord, in float id)\n{\n    float depth;\n    vec3 normal;\n    Material material;\n\n    \n\tfloat shouldOutline = 0.0;\n    \n    // Check circular neighbourhood\n    for (float i = 0.0; i < TAU; i += TAU / 10.0)\n    {\n        vec2 offset = vec2(cos(i), sin(i) * iResolution.x / iResolution.y) * 0.002;\n\t    unpackGbuffer(texture(G_BUFFER, coord + offset), depth, normal, material);\n        \n        if (id != material.id)\n        {\n            shouldOutline = 1.0;\n        }\n    }\n    \n    return shouldOutline;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    time = iTime;\n    \n    vec2 coord = fragCoord / iResolution.xy;\n    \n    vec4 region = getRegion();\n    \n    // If not the current region and not the first frame,\n    if (!(coord.x > region.x && coord.x < region.z && coord.y > region.y && coord.y < region.w) && iFrame > 0)\n    {\n        // Return previous frame's texel\n        fragColor = texture(THIS_BUFFER, coord);\n    }\n    else\n    {\n        vec3 viewDir = rayDirection(iResolution.xy, fragCoord);\n\n        vec3 eye = getEye();\n        mat4 viewToWorld = viewMatrix(eye, CAMERA_TARGET, UP);\n        vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n        float depth;\n        vec3 normal;\n        Material material;\n\n        unpackGbuffer(texture(G_BUFFER, coord), depth, normal, material);\n\n\n        vec3 position = eye + depth * worldDir;\n\n        float shadow = shadow(position);\n\n        fragColor.rgb = lighting(position, normal, worldDir, material, shadow);\n\t\tfragColor.a = 1.0;\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), outline(coord, material.id));\n    }\n}\n\n#undef G_BUFFER\n#undef SHADOW_BUFFER\n#undef THIS_BUFFER", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[631, 631, 688, 688, 2231]], "test": "untested"}
{"id": "WslcW4", "name": "Uniform spherical sampling ", "author": "michael0884", "description": "Messing with projection matrices and Fibonacci samplings", "tags": ["hmmm"], "likes": 15, "viewed": 567, "published": 3, "date": "1584808604", "time_retrieved": "2024-07-30T21:17:31.523797", "image_code": "#define M_PI 3.141592653\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 fibonacci_lattice(int i, int N)\n{\n    return vec2((float(i)+0.5)/float(N), mod(float(i)/PHI, 1.)); \n}\n\nvec3 fibonacci_sphere(int i, int N)\n{\n    vec2 xy = fibonacci_lattice(i, N);\n    vec2 pt = vec2(2.*M_PI*xy.y, acos(2.*xy.x - 1.) - M_PI*0.5);\n    return vec3(cos(pt.x)*cos(pt.y), sin(pt.x)*cos(pt.y), sin(pt.y)); \n}\n\nmat4 getPerspective(float fov, float aspect, float n, float f)\n{   \n    float scale = tan(fov * M_PI / 360.) * n; \n    float r = aspect * scale, l = -r; \n    float t = scale, b = -t; \n\n\t\n    return mat4(2. * n / (r - l), 0, 0, 0,\n                0, 2. * n / (t - b), 0, 0,\n                (r + l) / (r - l), (t + b) / (t - b), -(f + n) / (f - n), -1,\n                0, 0, -2. * f * n / (f - n), 0);\n}\n\nmat4 getRot(vec2 a)\n{\n    \n   mat4 theta_rot = mat4(1, 0, 0, 0,\n                         0, cos(a.y), sin(a.y), 0,\n                         0, -sin(a.y), cos(a.y), 0,\n                         0, 0, 0, 1); \n        \n   mat4 phi_rot = mat4(cos(a.x), sin(a.x), 0, 0,\n        \t\t       -sin(a.x), cos(a.x), 0, 0,\n        \t\t        0, 0, 1, 0,\n                      \t0, 0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nmat4 getModel(vec3 dx)\n{\n   return transpose(mat4(1, 0, 0, dx.x,\n        \t   0, 1, 0, dx.y,\n               0, 0, 1, dx.z,\n               0, 0, 0, 1)); ;\n}\n\nvec3 toScreen(vec4 X)\n{\n    return vec3(0.5*X.xy/X.w + 0.5, X.z);\n}\n\nfloat POINT(vec2 pos, float R, vec4 X)\n{\n    vec3 spos = toScreen(X);\n    return exp(-distance(pos, iResolution.xy*spos.xy)*spos.z/R);\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return mix(y0, y1, (val-x0)/(x1-x0));\n}\n\nfloat base(float x) \n{\n    if ( x <= -0.75 ) return 0.0;\n    else if ( x <= -0.25 ) return interpolate( x, 0.0, -0.75, 1.0, -0.25 );\n    else if ( x <= 0.25 ) return 1.0;\n    else if ( x <= 0.75 ) return interpolate( x, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n \tivec2 p = ivec2(pos.xy);\n    \n    int N = 128;\n    fragColor.xyz = vec3(0.);\n    \n    mat4 perspec = getPerspective(60., iResolution.x/iResolution.y, 0.001, 10.);\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*M_PI, M_PI):vec2(iTime, M_PI*0.5);\n    mat4 rot = getRot(angles);\n    mat4 sh = getModel(vec3(0.,0.,-2.5));\n    int R = 32;\n    int a = (R*(500/10))%N;\n    //rasterizer\n    for(int i = 0; i < N; i++)\n    {\n        int id = i;\n        vec3 d = fibonacci_sphere(id, N);\n        vec4 X = vec4(d, 1.);\n        vec4 XCAM = perspec*sh*rot*X;\n        \n        fragColor.xyz += 2.*jet_range(float(i), float(0), float(N))*POINT(pos, 10., XCAM);     \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 211, 211, 388], [390, 390, 454, 454, 791], [793, 793, 814, 814, 1209], [1211, 1211, 1235, 1235, 1365], [1367, 1367, 1390, 1390, 1434], [1436, 1436, 1476, 1476, 1572], [1574, 1607, 1678, 1678, 1722], [1724, 1724, 1746, 1746, 1990], [1992, 1992, 2020, 2020, 2076], [2078, 2078, 2121, 2121, 2182], [2185, 2185, 2236, 2236, 2917]], "test": "untested"}
{"id": "tdXyDN", "name": "Tetrahedra SDF tessellation", "author": "flockaroo", "description": "tessellation test ...nothing fast and fancy ...more of educaional value i guess ;-)\n...geometry and more detailed info here: [url]https://www.shaderoo.org/?shader=zh8I1X[/url]\n", "tags": ["tetrahedra", "tessellation", "marchingcubes"], "likes": 15, "viewed": 771, "published": 3, "date": "1584807633", "time_retrieved": "2024-07-30T21:17:32.710624", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Tetrahedra tessellation\n\n// also check original on shaderoo:\n//  https://www.shaderoo.org/?shader=zh8I1X\n//  ...for geometry and more detailed info\n\n\n// check Buff_A for actual algorithm...\n\n//##IMG##...stripped inline images away for size ( check on https://www.shaderoo.org/?shader=zh8I1X )\n\n// Volume -> cubes -> tetrahedra -> cut by distance field\n\n// scan the volume in small cubic cells (like marchin cubes)\n// ...subdivide every cube into tetrahedra (simpler to cut that cubes) \n// ...cut tetrahedra by distance (simpler to cut that cubes)\n// ...create cutting triangles\n\n// you can also export the object by pressing (Geom->.OBJ) button\n\n#define Res vec2(iResolution.xy)\n\nvoid march(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if (d<eps) break;\n    }\n}\n\nuniform float showRaymarch;\n\n// do some raymarching here for comparison to original distance field\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord, Res, iMouse, iTime);\n    march(pos,dir);\n    vec3 g=getGrad(pos,.001);\n    vec3 n=normalize(g);\n    vec3 colM=n*.5+.5;\n    if(length(g)<.0001) colM=vec3(0);\n    vec3 colG=texture(iChannel0,fragCoord/Res).xyz;\n    \n    fragColor.xyz=mix(colG,colM+.5-.5*showRaymarch,0.3);\n    fragColor.w=1.;\n    //fragColor+=.3*texture(iChannel1,fragCoord/Res);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Tetrahedra tessellation\n\n// the first pixel in Buff_A stores:\n// pixel.x.....actual number of processed tatrahedron\n// pixel.y.....actual number of triangles\n\n// ...the following TetraPerPass*4 pixels in Buff_A are used for finding new \n// tatrahedra which contain distance field 0-passes\n// (4 pixels per tetrahedron)\n\n// ...the pixels after TetraPerPass*4 are the final triangles (3 pixels per triangle) \n\n// 2 modes: 12 or 5 tetrahedra per cube cell\n#define TETRA_PER_CUBE 5\n//#define TETRA_PER_CUBE 12\n\n// enable this to start searching triangles in different regions of the volume\n// otherwise volume would just be stepped through sequentially from 0,0,0 to 1,1,1\n#define MULTI_SEARCHPOINTS\n\n//#include Include_A.glsl\n//#include Include_B.glsl\n\n#define Res0 vec2(textureSize(iChannel0,0))\n\nint getPixelIdx(vec2 c)\n{\n    ivec2 res=textureSize(iChannel0,0);\n    return int(c.x)+int(c.y)*res.x;\n}\n\n\n// check cut plane through tetrahedron\n//##IMG##...stripped inline images away for size ( check on https://www.shaderoo.org/?shader=zh8I1X )\nvoid checkTetra(vec3 p[4], int vidx, inout vec3 v)\n{\n    vec3 t[4]; int ti=0;\n    t[0]=vec3(0);t[1]=vec3(0);t[2]=vec3(0);t[3]=vec3(0);\n    //{0,1, 1,2, 2,0, 0,3, 1,3, 2,3}\n    int idxn[4];\n    int idxp[4];\n    for(int i=0;i<6;i++)\n    {\n        int i1=i%3;\n        int i2=(i+1)%3; if(i>=3) i2=3;\n        float d1=dist(p[i1]), d2=dist(p[i2]);\n        \n        // if one point has negative and the other positive distance\n        if(d1*d2<0.) { \n            \n            // store index of negative/positive distance point\n            idxn[ti] = (d1<0.) ? i1 : i2 ;\n            idxp[ti] = (d1<0.) ? i2 : i1 ;\n            \n            // simple mix...\n            t[ti] = mix(p[i1],p[i2],abs(d1/(d1-d2)));\n            //t[ti]=mix(p[i1],p[i2],0.);\n            \n            // ...refine by marching to dist=0\n            vec3 dir = normalize(p[i2]-p[i1])*sign(d1);\n            for(int j=0;j<8;j++) t[ti] += dist(t[ti])*dir;\n            \n            ti++; \n        }\n    }\n    \n    //FIXME 4th point needs to be checked specially - which 2 other points of tri?\n    if(t[3]!=vec3(0)) // FIXME: !=vec3(0) is not the best detection \n    {\n        #ifdef QUADSTRIP_ORDER\n        // quadstrip order:\n        // p1- to p1+,    p1- to p2+,    p2- to p1+,    p2- to p2+\n        int idx[4] = int[4](0,1,2,3);\n        for(int i=1;i<4;i++) if(idxn[i]==idxn[0] && idxp[i]!=idxp[0]) { idx[1]=i; break; }\n        for(int i=1;i<4;i++) if(idxn[i]!=idxn[0] && idxp[i]==idxp[0]) { idx[2]=i; break; }\n        for(int i=1;i<4;i++) if(idxn[i]!=idxn[0] && idxp[i]!=idxp[0]) { idx[3]=i; break; }\n        #else\n        // quad order:\n        // p1- to p1+,    p1- to p2+,    p2- to p2+,    p2- to p1+\n        int idx[4] = int[4](0,1,2,3);\n        for(int i=1;i<4;i++) if(idxn[i]==idxn[0] && idxp[i]!=idxp[0]) { idx[1]=i; break; }\n        for(int i=1;i<4;i++) if(idxn[i]!=idxn[0] && idxp[i]!=idxp[0]) { idx[2]=i; break; }\n        for(int i=1;i<4;i++) if(idxn[i]!=idxn[0] && idxp[i]==idxp[0]) { idx[3]=i; break; }\n        vec3 n = cross(t[idx[1]]-t[idx[0]],t[idx[2]]-t[idx[0]]);\n        if (dot(n,getGrad(t[idx[0]],.01))<=0.) { vidx=3-vidx; } \n        #endif\n        v=t[idx[vidx]];\n    }\n    else\n    {\n        vec3 n = cross(t[1]-t[0],t[2]-t[0]);\n        if (dot(n,getGrad(t[0],.01))<=0.) { vec3 d=t[2];t[2]=t[1];t[1]=d; } \n        v=t[vidx];\n        //v=vec3(0);\n    }\n}\n\n\n\n//##IMG##...stripped inline images away for size ( check on https://www.shaderoo.org/?shader=zh8I1X )\nvoid checkTetra12(int cIdx, int tIdx, int vIdx, ivec3 cnum, vec3 csize, inout vec3 vert)\n{\n    // this is just a trick to start searching triangles in different regions of the volume\n    // otherwise volume would just be stepped through sequentially from 0,0,0 to 1,1,1\n    #ifdef MULTI_SEARCHPOINTS\n    int subdiv=8;\n    int cl=(cnum.x*cnum.y*cnum.z)/subdiv;\n    cIdx=(cIdx%subdiv)*cl+cIdx/subdiv;\n    #endif\n    \n    ivec3 cIdx3=ivec3(cIdx%cnum.x,(cIdx/cnum.x)%cnum.y,(cIdx/(cnum.x*cnum.y))%cnum.z);\n    vec3 p[4];\n    vec3 cm=csize*vec3(cIdx3-cnum/2);\n    p[3]=cm;\n    for(int i=0;i<3;i++)\n    {\n        p[i]=(vec3(i%2,i/2,0)-.5)*csize;\n        if (tIdx%2==1) p[i].xy*=-1.;\n        //if (tIdx>=6) p[i].zx*=-1.;\n        if ((tIdx/2)%3==1) p[i]=p[i].zxy;\n        if ((tIdx/2)%3==2) p[i]=p[i].yzx;\n        if (tIdx>=6) p[i]*=-1.;\n        //if (tIdx/2>3) p[i]=p[i].zxy;\n        //if (tIdx/2>4) p[i]=p[i].zxy;\n        p[i]+=cm;\n    }\n    //if(tIdx==11)\n    checkTetra(p,vIdx,vert);\n}\n\n//##IMG##...stripped inline images away for size ( check on https://www.shaderoo.org/?shader=zh8I1X )\n// beware: those cells have to be flipped every other cell to fit together (see cellPar below)\nvoid checkTetra5(int cIdx, int tIdx, int vIdx, ivec3 cnum, vec3 csize, inout vec3 vert)\n{\n    // this is just a trick to start searching triangles in different regions of the volume\n    // otherwise volume would just be stepped through sequentially from 0,0,0 to 1,1,1\n    #ifdef MULTI_SEARCHPOINTS\n    int subdiv=8;\n    int cl=(cnum.x*cnum.y*cnum.z)/subdiv;\n    cIdx=(cIdx%subdiv)*cl+cIdx/subdiv;\n    #endif\n    \n    ivec3 cIdx3=ivec3(cIdx%cnum.x,(cIdx/cnum.x)%cnum.y,(cIdx/(cnum.x*cnum.y))%cnum.z);\n    int cellPar=(cIdx3.x+cIdx3.y+cIdx3.z)&1;\n    vec3 p[4];\n    vec3 cm=csize*vec3(cIdx3-cnum/2);\n    \n    // center tetrahedron\n    for(int i=0;i<4;i++) \n        p[i]=cm+.5*csize*vec3(vec2(i&1)*2.-1.,1)*vec3(1,vec2((i/2)&1)*2.-1.)*vec3(float(cellPar)*2.-1.,1,1);\n\n    if(tIdx<4)  // for edge tatrahedra just mirror one edge point\n        p[tIdx]=-(p[tIdx]-cm)+cm;\n        \n    //if(tIdx==11)\n    checkTetra(p,vIdx,vert);\n}\n\nint sortInTriangles(int pixIdx, int triCnt, inout vec4 c)\n{\n    int pix_ti=(pixIdx-sort0)/3-triCnt;\n    int pix_vi=(pixIdx-sort0)%3;\n    int ti=-1;\n    for(int i=0;i<TetraPerPass;i++)\n    {\n        vec3 p[4];\n        p[3]=getPixel(march0+i*4+3).xyz;\n        p[2]=getPixel(march0+i*4+2).xyz;\n        p[1]=getPixel(march0+i*4+1).xyz;\n        p[0]=getPixel(march0+i*4+0).xyz;\n        if(p[0]!=vec3(0))\n        {\n            ti++;\n            if (pix_ti==ti) { c=vec4(p[pix_vi],1); }\n            if(p[3]!=vec3(0))\n            {\n                ti++;\n                if (pix_ti==ti) { c=vec4(p[(pix_vi+2)%4],1); }\n            }\n        }\n    }\n    return ti+1;\n}\n\n//##IMG##...stripped inline images away for size ( check on https://www.shaderoo.org/?shader=zh8I1X )\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    // store actual cell index in ll pixel\n    vec3 fullSize=vec3(2.5,5.,1.8);\n    vec3 csize=vec3(.085);\n    ivec3 cnum=ivec3(fullSize/csize);\n    int tetraCnt=int(getPixel(0).x);\n    int triCnt=int(getPixel(0).y);\n    // 4 pixels per tetrahedron\n    ivec2 res=textureSize(iChannel0,0);\n    int pixIdx=getPixelIdx(fragCoord);\n    fragColor=getPixel(pixIdx);\n    if ( tetraCnt>(cnum.x*cnum.y*cnum.z)*TETRA_PER_CUBE && iFrame!=0 ) return;\n\n//##IMG##...stripped inline images away for size ( check on https://www.shaderoo.org/?shader=zh8I1X )\n    // check all cells in volume\n    if(pixIdx-march0>=0 && pixIdx-march0<TetraPerPass*4)\n    {\n        int pIdx=pixIdx-march0+tetraCnt*4;\n        int cellIdx =(pIdx/4)/TETRA_PER_CUBE;\n        int tetraIdx=(pIdx/4)%TETRA_PER_CUBE;\n        int vertIdx =pIdx%4;\n        vec3 vert=vec3(0);\n        #if TETRA_PER_CUBE == 12\n        checkTetra12(cellIdx,tetraIdx,vertIdx,cnum,csize,vert);\n        #endif\n        #if TETRA_PER_CUBE == 5\n        checkTetra5(cellIdx,tetraIdx,vertIdx,cnum,csize,vert);\n        #endif\n        fragColor=vec4(vert,1);\n    }\n    \n    // store triangles in upper buffer region (blue in above image)\n    //#ifdef SORT_IN_TRIANGLES\n    if(pixIdx-sort0>=triCnt*3 && pixIdx-sort0<(triCnt+TetraPerPass*2)*3)\n    {\n        fragColor=getPixel(pixIdx);\n        sortInTriangles(pixIdx,triCnt,fragColor);\n        //fragColor=col;\n    }\n    //#endif\n    \n    // store temporary tetrahedra in first buffer region (green in above image)\n    if(pixIdx==0) \n    {\n        int tcnt=sortInTriangles(pixIdx,triCnt,fragColor);\n        // store counters in 1st pixel (red in above image)\n        fragColor=vec4(tetraCnt+TetraPerPass,triCnt+tcnt,0,1);\n    }\n    if(iFrame==0) fragColor=vec4(0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// rendering triangles from Buffer A\n\n// ...not really fast or useful to raymarch triangles\n// ...but maybe it serves some \"educational\" purpose (at least for myself ;-)\n\n#define TriPerFrame 10\n\n#define Res vec2(iResolution.xy)\n\nint tcnt=0;\n\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat triDist(vec3 p)\n{\n    float d=10000.;\n    int triNum=int(getPixel(0).y);\n    for(int i=0;i<TriPerFrame;i++)\n    {\n        int i3=-i*3;\n        i3+=sort0+((iFrame*TriPerFrame)%triNum)*3;\n        vec3 v1=getPixel(i3+0).xyz+vec3(1,0,1)*.0;\n        vec3 v2=getPixel(i3+1).xyz+vec3(0,1,1)*.0;\n        vec3 v3=getPixel(i3+2).xyz;\n        d=min(d,udTriangle(p,v1,v2,v3));\n    }\n    return d;\n}\n\nvec3 getTriGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=triDist(p);\n    return vec3(triDist(p+d.xyy)-d0,triDist(p+d.yxy)-d0,triDist(p+d.yyx)-d0)/eps; \n}\n\nvoid march(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n        float d=triDist(pos);\n        pos+=dir*d*.9;\n        if (d<eps) break;\n    }\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 pix0=texelFetch(iChannel1,ivec2(0,0),0);\n    int tcnt=int(pix0.y);\n    if(iMouse.xy!=pix0.xy) \n    {\n     \ttcnt=0;\n        fragColor=vec4(0,0,0,100000);\n    }\n    else\n    {\n    \tvec3 pos,dir, pos0;\n    \tgetTrafo(pos,dir,fragCoord, Res, iMouse, iTime);\n        pos0=pos;\n    \tmarch(pos,dir);\n    \tvec3 g=getTriGrad(pos,.02);\n    \tvec3 n=normalize(g);\n    \tvec3 colM=n*.5+.5;\n        //colM+=vec3(0,0,1);\n    \tif(length(g)<.0001) colM=vec3(0);\n\t\tvec4 newCol=vec4(colM,length(pos-pos0));\n        vec4 oldCol=texture(iChannel1,fragCoord/Res);\n        fragColor=(newCol.w<oldCol.w)?newCol:oldCol;\n        //fragColor=newCol;\n     \ttcnt+=TriPerFrame;\n    }\n    if(iFrame<10) \n    {\n     \ttcnt=0;\n        fragColor=vec4(0,0,0,100000);\n    }\n    if(ivec2(fragCoord)==ivec2(0))\n    \tfragColor = vec4(iMouse.xy,tcnt,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// some of iq's SDF-primitives\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dist2( vec3 p)\n{\n    //return length(p)-1.;\n    return length(vec2(length(p.xy)-1.,p.z))-.35;\n}\n\nconst vec3 BodySize=vec3(1.8,4.14,1.0);\n\nfloat dist(vec3 p)\n{\n    p.x=abs(p.x);\n    vec3 p0=p;\n    // torus\n    float d=10000.,d2;\n    p=p0-vec3(-p.y*.02,0,0);\n    float yfall=min((p.y+0.0)*abs(p.y+0.0),0.);\n    float yfall2=(p.y>.0?2.5:7.)*min((-abs(p.y)+1.2)*abs(-abs(p.y)+1.2),0.);\n    yfall=mix(yfall,yfall2,step(0.,-p.z));\n    d2=distBoxR(p,vec3(BodySize.xz,100).xzy*.5*vec3(exp(-abs(p.y)*p.y*p.y*p.y*p.y/500.),1,1.+.15*yfall),max(.02,-1.*p.z-.07*p.y));\n    d=min(d,d2);\n    d2=dot(p-.5*BodySize*vec3(.55,0,1.+.15*yfall),normalize(vec3(.8,0,1.-.9*yfall)));\n    d=max(d,d2);\n    \n    // hood\n    vec3 n=normalize(vec3(0,1,2.5));\n    float dpx=max(p.x-1.,-.5);\n    float dpy=max(p.y-.9+.4*dpx,0.);\n    vec3 p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*(1.-exp(-dpy/.2)-dpy*.8);\n    //vec3 p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*min(1.-dpy*.2,1.);\n    d2=dot(p2-.5*BodySize*vec3(0,1,1)-vec3(0,0,-.75),normalize(vec3(0,1,2.5)));\n    d=max(d,d2);\n    \n    p-=vec3(0,-1.6,.5);\n    d2=distBoxR(p+vec3(0,0,-p.y*.12),vec3(BodySize.x*.25*1.1-p.y*.2+p.z*.4,1,.3),.02);\n    d=max(d,-d2);\n\n    d2=abs(p0.y)-BodySize.y*.5;\n    d=-smin_(-d,-d2,.01);\n\n    vec3 p1;\n    p1=BodySize*.5*vec3(1, .59,-.65);\n    p2=BodySize*.5*vec3(1,-.63,-.65);\n    d=max(d,-distCylR((p0-p1).yzx,.35,.8,.05));\n    d=max(d,-distCylR((p0-p2).yzx,.35,.8,.05));\n    d=min(d,distCylR((p0-p1-vec3(-.17,0,.04)).yzx,.31,.27,.08));\n    d=min(d,distCylR((p0-p2-vec3(-.12,0,.04)).yzx,.31,.27,.08));\n    //d=max(d,-(length(p0-p1*vec3(1,-1,1))-.37));\n\n    p=p0-vec3(p.y*.02,0,0);\n    \n    //d2=length(vec2(length(p.xy)-2.5,p.z))-.01;\n    //d=min(d,d2);\n    return d;\n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\n// the first pixels in Buff_A stores the number of triangles\n// the first TetraPerPass*4 pixels in Buff_A are used for finding new trinagles\n// (4 pixels per tetrahedron)\n// the pixels after TetraPerPass*4 are just triangles (3 pixels per triangle) \nconst int TetraPerPass=256;\nconst int march0=1;\nconst int sort0=TetraPerPass*4+march0;\n\n#define getPixel(pixidx) texelFetch(iChannel0,ivec2((pixidx)%textureSize(iChannel0,0).x,(pixidx)/textureSize(iChannel0,0).x),0)\n\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nfloat tanFOVh=.6;\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc, bool inv, vec2 Res, vec4 iMouse, float iTime)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(0,0,-1./tanFOVh)+vec3(sc,0));\n    \n    float ph = iMouse.x/Res.x*10.;\n    if (iMouse.x<.5) ph=2.13;\n    float th = iMouse.y/Res.y*10.+1.4;\n    float camDist=5./**exp(-iMouseData.z/5000.)*/;\n    //th=0.;\n\n    if(inv)\n    {\n        pos=vec3(0,0,camDist);\n        pos.yz=ROTM(th)*pos.yz;\n        dir.yz=ROTM(th)*dir.yz;\n        pos.xy=ROTM(ph)*pos.xy;\n        dir.xy=ROTM(ph)*dir.xy;\n    }\n    else\n    {\n        pos.xy=ROTM(-ph)*pos.xy;\n        pos.yz=ROTM(-th)*pos.yz;\n        pos.z-=camDist;\n    }\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc, vec2 Res, vec4 iMouse, float iTime)\n{\n    getTrafo(pos, dir, fc, true, Res, iMouse, iTime);\n}\n\nvoid getTrafo(inout vec3 pos, vec2 Res, vec4 iMouse, float iTime)\n{\n    vec3 dir;\n    getTrafo(pos, dir, vec2(0), false, Res, iMouse, iTime);\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyDN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[819, 819, 857, 857, 993], [1095, 1095, 1152, 1152, 1549]], "test": "untested"}
{"id": "wsXyW4", "name": "Day 93", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 12, "viewed": 423, "published": 3, "date": "1584786557", "time_retrieved": "2024-07-30T21:17:33.687013", "image_code": "\n// Pallete from Inigo Quilez\n// pModPolar from hg-sdf library\n// Antialiasing thx to Fabrice Neyret\n\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define PI acos(-1.)\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    \n    \n    n += valueNoise(uv*500.,0.1);\n    //n += valueNoise(uv*1000., 0.1)*0.5;\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    \n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    \n    \n    n = max(n, 0.);\n    return n;\n}\n\nvec3 get(vec2 fragCoord){\n\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y ;\n\n    vec3 col = vec3(0);\n    \n    vec2 uvn = uv;\n    \n    float mm = 4.;\n    uvn *= rot(-PI*mm*0.5);\n    \n    // random IFS stuff\n    for(int i = 0; i < 26; i++){\n    \tuvn = abs(uvn);\n        uvn -= 0.25;\n    \tuvn.y += 0.299991;\n        if(uvn.x < 0.){\n        \tuvn.x -= 1.*uvn.y;\n        }\n        if(uvn.y < 0.){\n        \t//uvn.y -= 1.*uvn.y;\n        }\n        uvn *= rot(0.5 *PI);\n    }\n    \n    float j = pModPolar(uvn, mm);\n    float modD = 0.05;\n    vec2 id = vec2(j,floor(uvn.x/modD));\n    uvn.x = pmod(uvn.x, modD);\n    \n    vec3 c = pal(0.5,0.5,vec3(1.,0.7,0.5), 0.6 + id.x, id.y + iTime*0.5);\n    \n    c = max(c, 0.);\n    \n    col += c;\n    col -= fbm(uv).x*0.1;\n    col += fbm(uv + 4.).x*0.1;\n    \n    \n    \n    // vignette\n    col = pow(col, vec3(1. + dot(uv,uv)*0.1));\n    col *=1. -  dot(uv,uv)*0.7;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    // float(min(iFrame,0)) hack for faster compilation (stops loop unrolling)\n    for(float i =0.; i < 9. + float(min(iFrame,0)); i++){\n    \tcol += get(fragCoord + vec2(mod(i,3.),floor(i/3.))*0.1);\n    }\n    col /= 9.;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 313, 313, 703], [704, 704, 737, 737, 1266], [1267, 1267, 1285, 1285, 1552], [1554, 1554, 1579, 1579, 2475], [2477, 2477, 2534, 2534, 2826]], "test": "untested"}
{"id": "tdXyW4", "name": "tinykaboom tutorial", "author": "haqreu", "description": "Check this page to see what is under the hood: https://github.com/ssloy/tinykaboom/wiki", "tags": ["procedural", "3d", "raymarching", "sdf", "tutorial", "animation"], "likes": 9, "viewed": 1029, "published": 3, "date": "1584782781", "time_retrieved": "2024-07-30T21:17:34.549707", "image_code": "uint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    if (x>=32u || y>=18u) return false;\n    uint id = x + (17u-y)*32u;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nconst float sphere_radius   = 1.5;\nconst float noise_amplitude = 1.0;\n\nfloat hash(const float n) {\n    float x = sin(n)*43758.5453;\n    return x-floor(x);\n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = x - p;\n    f = f * dot(f, vec3(3.0,3.0,3.0)-2.0*f);\n    float n = dot(p, vec3(1.0, 57.0, 113.0));\n    return mix(mix(mix(hash(n +  0.0), hash(n +  1.0), clamp(f.x,0.,1.)),\n                   mix(hash(n + 57.0), hash(n + 58.0), clamp(f.x,0.,1.)),\n                   clamp(f.y,0.,1.)),\n               mix(mix(hash(n + 113.0), hash(n + 114.0), clamp(f.x,0.,1.)),\n                   mix(hash(n + 170.0), hash(n + 171.0), clamp(f.x,0.,1.)),\n                   clamp(f.y,0.,1.)),\n               clamp(f.z,0.,1.));\n}\n\nvec3 rotate(in vec3 v) {\n    return vec3(dot(v, vec3( 0.0,  0.8,   0.6)),\n                dot(v, vec3(-0.8,  0.36, -0.48)),\n                dot(v, vec3(-0.6, -0.48,  0.64)));\n}\n\nfloat fractal_brownian_motion(in vec3 x) {\n    vec3 p = rotate(x);\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.32;\n    f += 0.2500*noise(p); p = p*3.03;\n    f += 0.1250*noise(p); p = p*2.61;\n    f += 0.0625*noise(p);\n    return f/0.9375;    \n}\n\nvec3 palette_fire(in float d) {\n    const vec3 yellow   = vec3(2.7, 2.3, 2.0); // note that the color is \"hot\", i.e. has components >1\n    const vec3 orange   = vec3(2.0, 1.6, 0.0);\n    const vec3 red      = vec3(1.5, 0.0, 0.0);\n    const vec3 darkgray = vec3(0.2, 0.2, 0.2);\n    const vec3 gray     = vec3(0.4, 0.4, 0.4);\n    float x = max(0.0, min(1.0, d));\n    if (x<.25f)\n        return mix(gray, darkgray, x*4.f);\n    else if (x<.5f)\n        return mix(darkgray, red, x*4.f-1.f);\n    else if (x<.75f)\n        return mix(red, orange, x*4.f-2.f);\n    return mix(orange, yellow, x*4.f-3.f);\n}\n\nfloat signed_distance(in vec3 p) {\n    float displacement = -fractal_brownian_motion(p*3.4 + vec3(0.1, 0.1, 0.1)*iTime)*noise_amplitude;\n    return length(p) - (sphere_radius + displacement) * (0.1 + 0.9*sin(mod(iTime*(2./3.1416), 3.1416/2.)));\n}\n\nbool sphere_trace(in vec3 orig, in vec3 dir, out vec3 pos) {\n    if (dot(orig,orig) - dot(orig,dir)*dot(orig,dir) > sphere_radius*sphere_radius)\n        return false;\n    pos = orig;\n    for(int i = 0; i < 128; i++) {\n        float d = signed_distance(pos);\n        if (d < 0.0) return true;\n        pos = pos + dir*max(d*0.1, 0.01);\n    }\n    return false;\n}\n\nvec3 distance_field_normal(in vec3 pos) {\n    const float eps = 0.1;\n    float d  = signed_distance(pos);\n    float nx = signed_distance(pos + vec3(eps, 0.0, 0.0)) - d;\n    float ny = signed_distance(pos + vec3(0.0, eps, 0.0)) - d;\n    float nz = signed_distance(pos + vec3(0.0, 0.0, eps)) - d;\n    return normalize(vec3(nx, ny, nz));\n}\n\nvec3 rotate_camera(in vec3 orig, in vec3 dir, in vec3 target) {\n    vec3 zAxis = normalize(orig - target);\n    vec3 xAxis = normalize(cross(vec3(0., 1., 0.), zAxis));\n\tvec3 yAxis = normalize(cross(zAxis, xAxis));\n   \tmat4 transform = mat4(vec4(xAxis, 0.), vec4(yAxis, 0.), vec4(zAxis, 0.), vec4(orig, 1.));\n    return (transform * vec4(dir, 0.)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    const float fov = 3.1416 / 3.;\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y*tan(fov/2.); \n\n    vec3 orig = vec3(-sin(iTime)*3., 0., cos(iTime)*3.);\n    vec3 dir = normalize(vec3(uv, -1));\n\tdir = rotate_camera(orig, dir, vec3(0.));\n\n    vec3 hit;\n    if(sphere_trace(orig, dir, hit)) {\n        float noise_level = (sphere_radius - length(hit))/noise_amplitude;\n        vec3 light_dir = normalize((vec3(10.0, 10.0, 10.0) - hit));\n        float light_intensity = max(0.4, dot(light_dir, distance_field_normal(hit)));\n        fragColor = vec4(palette_fire(2.0*(-0.2+noise_level))*light_intensity, 1.0);\n    } else\n        fragColor = texture(iChannel0, dir);\n    vec2 coord = fragCoord/iResolution.xy*vec2(32u, 18u)*6.;\n    if (jfig(uint(coord.x), uint(coord.y)))\n        fragColor.xyz += vec3(.5);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 213, 213, 347], [420, 420, 447, 447, 505], [507, 507, 531, 531, 1077], [1079, 1079, 1103, 1103, 1255], [1257, 1257, 1299, 1299, 1509], [1511, 1511, 1542, 1542, 2105], [2107, 2107, 2141, 2141, 2353], [2355, 2355, 2415, 2415, 2714], [2716, 2716, 2757, 2757, 3052], [3054, 3054, 3117, 3117, 3406], [3408, 3408, 3465, 3465, 4285]], "test": "untested"}
{"id": "wdXyW4", "name": "Mercator Spiral", "author": "mla", "description": "Here's a variation on [url]https://www.shadertoy.com/view/3dlyD8[/url] that adds a bit of twist to the sliding tiles pattern. Other angles should be possible, need to work out the details. Interesting that it looks like a Mobius tranformation.", "tags": ["spiral", "loxodrome", "mercator"], "likes": 17, "viewed": 488, "published": 3, "date": "1584780936", "time_retrieved": "2024-07-30T21:17:35.600896", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Spherical texturing with Mercator projection.\n//\n// Adding a spiral (a loxodrome in fact, a curve of constant compass bearing.\n//\n// Matthew Arcus, 2020.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 tiling(vec2 p) {\n  p *= 8.0;\n  p = mod(p,2.0)-1.0;\n  if (p.x*p.y < 0.0) p = p.yx;\n  p = 1.0-2.0*abs(abs(p)-0.5);\n  float t = 0.5*iTime;\n  vec2 n = vec2(sin(t),cos(t));\n  vec2 m = vec2(-n.y,n.x);\n  float d = dot(p,n), e = dot(p,m);\n  float k = min(abs(d),abs(e));\n  if (d < 0.0) k = min(k,abs(p.x-1.0));\n  if (e < 0.0) k = min(k,abs(p.y-1.0));\n  return smoothstep(0.025,0.05,k)*vec3(0.5,0.5,0);\n}\n\nvec3 mirror(vec2 uv) {\n  uv.y -= 0.1*iTime;\n  uv = mod(uv,2.0);\n  uv = min(uv,2.0-uv);\n  return texture(iChannel1,uv).rgb;\n}\n\nvec3 slider(vec2 uv) {\n  uv *= 4.0;\n   float t = 0.25*PI;\n  uv = rotate(uv,t);\n    uv /= cos(t);\n vec2 iv = floor(uv);\n  if (true) {\n    // Slide around a little\n    float t = 0.3*iTime;\n    if (mod(t,2.0) < 1.0) {\n      uv.x += floor(mod(iv.y,2.0))*fract(t);\n    } else {\n      uv.y += floor(mod(iv.x,2.0))*fract(t);\n    }\n  }\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 col = texture(iChannel0,uv).rgb;\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint IHash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 indexed(vec2 uv) {\n  uv *= 8.0;\n  uv.y += iTime;\n  ivec2 iv = ivec2(floor(uv));\n  float rnd = float(IHash((uint(iv.x)<<16) ^ uint(iv.y)))/pow(2.0,32.0);\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 col = hsv2rgb(vec3(rnd,1,1));\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nconst int ncolors = 4;\nvec3 getColor(int i, vec2 uv) {\n  return slider(uv);\n  i = i%ncolors;\n  if (i == 0) return slider(uv);\n  if (i == 1) return tiling(uv);\n  if (i == 2) return indexed(uv);\n  if (i == 3) return mirror(uv);\n  return vec3(1,0,0);\n}\n\nvec3 getColor(vec3 p) {\n  float x = atan(p.x,p.z);       // Longitude\n  float y = asin(p.y/length(p)); // Latitude\n  y = log(tan(0.25*PI+0.5*y));   // Mercator\n  vec2 uv = vec2(x,y);\n  uv /= PI;\n  float period = 10.0;\n  float t = mod(iTime,float(ncolors)*period);\n  int i = int(t/period);\n  t = mod(t,period);\n  return mix(getColor(i,uv),getColor(i+1,uv),smoothstep(period-1.0,period,t));\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  float r;      // radius\n  vec3 p;       // centre\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, (q+t*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  Sphere s = Sphere(1.0, vec3(0));\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec3(0);\n  } else {\n    vec3 n = hit.n;\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = getColor(hit.n);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),10.0);\n    color += 0.5*specular*vec3(1);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return color;\n  }\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (true) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1.0,-1.0));\n  light = transform(light);\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 p = vec3(0,0,-6);\n      vec3 r = vec3(uv,6);\n      p = transform(p);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      col += solve(Ray(p,r));\n    }\n  }\n  fragColor = vec4(pow(col/(AA*AA),vec3(0.4545)),1);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 383, 383, 435], [437, 437, 458, 458, 837], [839, 839, 861, 861, 963], [965, 965, 987, 987, 1474], [1476, 1476, 1498, 1498, 1674], [1676, 1740, 1760, 1760, 1874], [1876, 1876, 1899, 1899, 2212], [2237, 2237, 2268, 2268, 2463], [2465, 2465, 2488, 2488, 2855], [3099, 3099, 3153, 3153, 3638], [3640, 3640, 3681, 3681, 3789], [3834, 3834, 3853, 3853, 4271], [4273, 4273, 4300, 4300, 4627], [4629, 4629, 4686, 4686, 5242]], "test": "untested"}
{"id": "3sfcDN", "name": "Cubic B-Spline", "author": "TinyTexel", "description": "https://en.wikipedia.org/wiki/B-spline", "tags": ["spline"], "likes": 2, "viewed": 211, "published": 3, "date": "1584777680", "time_retrieved": "2024-07-30T21:17:36.482539", "image_code": "// The MIT License\n// Copyright © 2020 Mirko Salm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n\nfloat BSpline(float x)\n{\n    bool s = x < 0.0;\n    \n    x = abs(x);\n\n    bool c = x < 1.0;\n    \n    if(!c) x = 2.0 - x;\n    \n    float x2 = x  * x;\n    float x3 = x2 * x;\n\t\n    float r = x3 * (1.0/6.0);\n    \n    if(c) r = r * 3.0 - x2 + 2.0/3.0;\n    \n    return r;\n}\n\nvec2 BSplineC1(float x)\n{\n    bool s = x < 0.0;\n    \n    x = abs(x);\n\n    bool c = x < 1.0;\n    \n    if(!c) x = 2.0 - x;\n    \n    float x2 = x  * x;\n    float x3 = x2 * x;\n\t\n    vec2 r = vec2(x3, x2) * vec2(1.0/6.0, 0.5);\n    \n    if(c) r = r * 3.0 + vec2(-x2 + 2.0/3.0, -2.0*x);\n    \n    if(c == s) r.y = -r.y;\n    \n    return r;//x: value | y: derivative\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.5;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.5;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n    col = mix(col, vec3(0.0, 0.5, 1.0), Graph(BSplineC1(tex.x).y - tex.y, 0.5));       \n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(BSplineC1(tex.x).x - tex.y, 0.5)); \n    //col = mix(col, vec3(1.0, 0.0, 1.0), Graph(BSplineC1(tex.x-2.0).x+BSplineC1(tex.x-1.0).x+BSplineC1(tex.x).x+BSplineC1(tex.x+1.0).x - tex.y, 0.5)); \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcDN.jpg", "access": "api", "license": "mit", "functions": [[1295, 1295, 1316, 1316, 1328], [1329, 1329, 1350, 1350, 1364], [1365, 1365, 1386, 1386, 1408], [1410, 1410, 1438, 1438, 1464], [1465, 1465, 1491, 1491, 1523], [1524, 1524, 1550, 1550, 1582], [1583, 1583, 1609, 1609, 1641], [1643, 1643, 1667, 1667, 1708], [1709, 1709, 1736, 1736, 1785], [1788, 1788, 1812, 1812, 1840], [1842, 1842, 1873, 1873, 1927], [1930, 1930, 1960, 1960, 1982], [1983, 1983, 2014, 2014, 2046], [2048, 2048, 2078, 2078, 2171], [2173, 2173, 2204, 2204, 2295], [2297, 2297, 2336, 2336, 2494], [2496, 2496, 2520, 2520, 2762], [2764, 2764, 2789, 2789, 3122], [3124, 3124, 3172, 3172, 4107]], "test": "untested"}
{"id": "3sfcWN", "name": "Coronavirus remix jam", "author": "maxbittker", "description": "☣️🦠 😷\n\nWhile we're stuck at home avoiding becoming a transmission vector, let's transmit some `vec3`s 😈.\n\nTo participate, remix this shader! \n\nIn particular,  you can make use of the coronavirus SDF on line 51, `virus`, \n\n- char stiles & max bittker\n\n", "tags": ["2d", "sdf", "jam", "coronavirus", "covid19"], "likes": 4, "viewed": 380, "published": 3, "date": "1584766150", "time_retrieved": "2024-07-30T21:17:37.330273", "image_code": "//    _____ _      _       _____ _               _\n//   / ____(_)    | |     / ____| |             | |\n//  | (___  _  ___| | __ | (___ | |__   __ _  __| | ___ _ __\n//   \\___ \\| |/ __| |/ /  \\___ \\| '_ \\ / _` |/ _` |/ _ \\ '__|\n//   ____) | | (__|   <   ____) | | | | (_| | (_| |  __/ |\n//  |_____/|_|\\___|_|\\_\\ |_____/|_| |_|\\__,_|\\__,_|\\___|_|\n//  🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠\n//\n// Coronavirus Shader Demo Chain Mail\n//\n// Mutate this shader and \"retransmit\" it!\n// Be sure to tag \"coronavirus\"\n\n#define PI 3.1415926538\n#define TAU 6.2831853076\n#define spokes 5.0\n\n// THESE ARE SOME HELPER FUNCTIONS :-)\n\n// smooth minimum\nfloat smin(float a, float b, float k) {\n  float res = exp2(-k * a) + exp2(-k * b);\n  return -log2(res) / k;\n}\n\n// rotate a in input vec2 around its origin;\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\n// how far a point p is from the line segment from a to b\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\n////// END OF HELPER FUNCTIONS!\n\n// Draws a cool virus!\nfloat virus(vec2 input_pos, vec2 offset, float rotation, float scale) {\n\n  // prepare the coordinates based on the input transformations.\n  vec2 pos = rotate(input_pos + offset, rotation) / scale;\n  float angle = atan(pos.y, pos.x);\n\n  // this forms the middle blobby part of the virus:\n  float sphere = (length(pos) - 0.6); // the base\n  float wave = (pow(sin(angle * spokes), 6.) *\n                0.31); // goes up and down around the circle\n  float body = sphere - wave + (sin(sin(angle * 40.)) * 0.005);\n\n  // These are the lil round nubs of the crown\n  float repeatedAngle = floor((angle + .666) * spokes / PI) / spokes * PI;\n  repeatedAngle += -.31;\n\n  float boopRadius = 0.9;\n  boopRadius += sin(repeatedAngle*8. +iTime *4.) * 0.004;\n  float angleSweep = TAU / 100.;\n\n  float startAngle = repeatedAngle - angleSweep;\n  float endAngle = repeatedAngle + angleSweep;\n\n  vec2 dotStart = vec2(cos(startAngle), sin(startAngle)) * boopRadius;\n  vec2 dotEnd = vec2(cos(endAngle), sin(endAngle)) * boopRadius;\n  float crown = sdSegment(pos, dotStart, dotEnd) - 0.1;\n\n  // Combine the nubs and body with smoothing\n  return smin(crown, body, 40.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 uv = (fragCoord / iResolution.xy - 0.5) *\n            2.0; // (0,0) is in the center of the screen\n\n  uv.x *= iResolution.x /\n          iResolution.y; // sadly the screen is not square, we must fix uv ratio\n\n  // Background color\n  vec3 col = vec3(1.000, 0.891, 0.674);\n\n  // First Virus:\n  vec2 offset = vec2(0.2, 0.3 + sin(iTime * 3.) * 0.1);\n  float rotation = sin(iTime * 3.) * 0.4 - iTime * 0.2;\n  float scale = 0.5 + sin(iTime * 4.) * 0.01;\n\n  float virus1 = virus(uv, offset, rotation, scale);\n\n  // threshhold our SDF gradient to make color regions.\n\n  if (virus1 < 0.0) {\n\n    // green inside\n    col *= vec3(0.500, 0.7567, 0.429);\n    col *= 1.0 + (uv.y + 0.5) * 0.2;\n\n  } else if (virus1 < 0.04) {\n    // pink border\n    col = vec3(0.800, 0.567, 0.629);\n  }\n\n  // Second Virus:\n  offset = vec2(-0.3, -0.33 + sin(iTime * 6.) * 0.05);\n  rotation = iTime * 2.;\n  scale = 0.4;\n\n  float virus2 = virus(uv, offset, rotation, scale);\n\n  if (virus2 < 0.0) {\n    // green inside\n    col *= vec3(0.200, 0.467, 0.329);\n    col *= 1.0 + (uv.y + 0.5) * 0.2;\n  } else if (virus2 < 0.04) {\n    // pink border\n    col = vec3(0.800, 0.567, 0.629);\n  }\n\n  col.yz -= length(pow(uv, vec2(4.0)) * vec2(0.015)); // add the red\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[666, 684, 723, 723, 793], [795, 840, 870, 870, 958], [960, 1018, 1068, 1068, 1192], [1227, 1250, 1321, 1387, 2397], [2399, 2399, 2454, 2454, 3732]], "test": "untested"}
{"id": "3sXcWN", "name": "网格噪声（CellularNoise）", "author": "ywqy", "description": "网格噪声", "tags": ["cellularnoise"], "likes": 3, "viewed": 297, "published": 3, "date": "1584762228", "time_retrieved": "2024-07-30T21:17:38.209921", "image_code": "//learn from https://thebookofshaders.com/12/?lan=ch\n\nvec2 random2( vec2 p ) {\n    return fract(sin(\n        vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)))\n    )*43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //缩放\n    //scale\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    uv *= 3.0;\n    \n    //整数小数分离\n    //Tile the space\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    \n    //最小距离\n    //minimun distance\n    float m_dist = 2.0;\n    \n    //次小距离\n    float sem_dist = 2.0;\n    \n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n        \t//相邻网格\n            //Neigbor place in the grid\n            vec2 neighbor = vec2(float(x), float(y));\n            \n            //获取相邻网格的随机值\n            //Random position from current + neighbor place in the grid\n            vec2 point = random2(i_uv + neighbor);\n            \n            //动画\n            //Animate\n            point = vec2(0.5) + .5 * sin(iTime + 3.14159 * point);\n            \n            //当前像素到相邻随机的向量\n            //Vector between the pixel and point\n            vec2 diff = f_uv - (neighbor + point);\n            \n            //距离\n            //distance to the point\n            float dist = length(diff);\n            \n            //最小距离\n            //keep the close distance\n            if(m_dist > dist) {\n            \tsem_dist = m_dist;\n                m_dist = dist;\n            }\n            \n        }\n    }\n    //画距离深度\n    //distance field\n    vec3 color = vec3(m_dist / 2.0);\n    \n    //画细胞中心\n    //Draw cell center\n    color += vec3(1. - step(.02, m_dist));\n    \n    //画等值线\n    //Show isolines\n    color -= step(.5, abs(sin(30.0 * m_dist)) ) *0.2;\n    \n    //画边界\n    //Draw broders\n    if(abs(sem_dist - m_dist)< .08)\n    color = vec3(0.6);\n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 78, 78, 199], [203, 203, 260, 290, 2001]], "test": "untested"}
{"id": "tltGWf", "name": "HOPPENS TRäDGåRD", "author": "toomuchvoltage", "description": "Data Airlines/Dubmood inspired Swedish style 64k intro, bringing you an important message in March 2020! :)\nMark's music was a perfect fit and made it all come together!\nMake sure to re-play the music and rewind back!\n\n#define HIRES_IMAGE 1 on ANGLE/D3D", "tags": ["sdf", "intro", "art", "64k", "graffiti", "0ld", "sko0l"], "likes": 7, "viewed": 552, "published": 3, "date": "1584758991", "time_retrieved": "2024-07-30T21:17:39.522411", "image_code": "/***********************************************************\n\n   Informal demo collab with Mark Sparling! ;) featuring one of his dailies: Gardeon of Hope\n   The style was inspired by DataAirlines/Dubmood's work for Razor1911. Tried to make it very Swedish. ;)\n   Song by: Mark Sparling\n   Graffiti encoded by a new version of shadertoy-utils: https://github.com/toomuchvoltage/shadertoy-utils\n   Using SDF font technique/texture by otaviogood: https://www.shadertoy.com/view/llcXRl\n   3D Simplex FBM by nikat: https://www.shadertoy.com/view/XsX3zB\n   All your SDF are belong to iq ;): https://iquilezles.org/articles/distfunctions\n\n   Everything else covered under the MIT license:\n\n   Copyright (c) 2019 Baktash Abdollah-shamshir-saz.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit us up! :)\n\n   Baktash:\n       Twitter: twitter.com/toomuchvoltage\n       Facebook: fb.com/toomuchvoltage\n       YouTube: youtube.com/toomuchvoltage\n       Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n       Website: www.toomuchvoltage.com\n\n   Mark:\n       Twitter: https://twitter.com/Markymark665\n       SoundCloud: https://soundcloud.com/marksparling\n       YouTube: https://www.youtube.com/channel/UCPw7S3ZvjuPnc2-KCIxZYbw\n       Spotify: https://open.spotify.com/artist/512N8AirvONRHLLZg5cjC0\n       Website: http://marksparling.ca/\n\n************************************************************/\n\n//#define HIRES_IMAGE 1\n\n#define M_PI 3.1415926535\n#define DRAW_DISTANCE 15.0\n\n// Ideally we'd use unpackUnorm4x8(), but this is not available\nvec4 unpackVec4(uint inp)\n{\n\tfloat R = float (inp >> 24) / 255.0;\n\tinp &= uint(0x00FFFFFF);\n\tfloat G = float (inp >> 16) / 255.0;\n\tinp &= uint(0x0000FFFF);\n\tfloat B = float (inp >> 8) / 255.0;\n\tinp &= uint(0x000000FF);\n\tfloat A = float (inp) / 255.0;\n\treturn vec4 (R,G,B,A);\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat parkingFloor(vec3 p)\n{\n    return p.y + 2.0;\n}\n\nfloat parkingCeil(vec3 p)\n{\n    p += vec3 (0.0, 0.0, 1.0);\n    return sdBox(p, vec3 (6.0, 0.05, 6.0));\n}\n\nfloat parkingWall1(vec3 p)\n{\n\tp += vec3 (-8.0, 0.0, 0.0);\n    return sdBox(p, vec3 (6.0, 6.0, 12.0));\n}\n\nfloat parkingWall2(vec3 p)\n{\n\tp += vec3 (12.0, 0.0, 0.0);\n    return sdBox(p, vec3 (6.0, 6.0, 12.0));\n}\n\nfloat parkingWall3(vec3 p)\n{\n\tp += vec3 (0.0, 5.0, -15.0);\n    return sdBox(p, vec3 (12.0, 6.0, 6.0));\n}\n\nconst uint textArr0[73] = uint[](3503345872u,2474807741u,3233992856u,3233992924u,2563817666u,3516236437u,2207360976u,2676609176u,2563801733u,2207555217u,2493419984u,2661258448u,2228258007u,2559804831u,2241825232u,2442580098u,3504248211u,2190579111u,2463142352u,2509673877u,2156253332u,2207358416u,2660356251u,2627195028u,2207614623u,2512113886u,2446360725u,2207880400u,2476642692u,2559037589u,2681249429u,2575533189u,3504248212u,2660866212u,2527056027u,2627506640u,2677572816u,2312148355u,2630911391u,3734341279u,2676142800u,2224592773u,3500115152u,3498418057u,3184560530u,3499852433u,3499400849u,2224787890u,3734537105u,2442699984u,3498285982u,3218120580u,2575733124u,2679623839u,2530251935u,2228257439u,2530252184u,2642714271u,2446360721u,2228262046u,2211485080u,2190841984u,2443038869u,2576913282u,2228262814u,2660799381u,2508554649u,2225328350u,2211482001u,3499464337u,3498345887u,2190841988u,3503346069u);\n// Otavio Good's sampler for Shadertoy fonts\nvec4 SampleFontTex0(vec2 uv)\n{\n\tvec2 fl = floor(uv + 0.5);\n\tif (fl.y == 0.0) {\n\t\tint charIndex = int(fl.x + 3.0);\n\t\tint arrIndex = (charIndex / 4) % 73;\n\t\tuint wordFetch = textArr0[arrIndex];\n\t\tuint charFetch = (wordFetch >> ((charIndex % 4) * 8)) & 0x000000FFu;\n\t\tfloat charX = float (int (charFetch & 0x0000000Fu)     );\n\t\tfloat charY = float (int (charFetch & 0x000000F0u) >> 4);\n\t\tfl = vec2(charX, charY);\n\t}\n\tuv = fl + fract(uv+0.5)-0.5;\n\treturn texture(iChannel2, (uv+0.5)*(1.0/16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001) - 0.5;\n}\n\nfloat text(vec3 p)\n{\n    p -= vec3 (-1.5 + iTime, 0.0, 7.0);\n    p.x = -p.x;\n    p.y += sin(iTime + p.x);\n    float letterDistField = (SampleFontTex0(p.xy).w - 0.0390625);\n    float cropBox = sdBox(p, vec3(1000000.0, 0.5, 0.25));\n    return max(letterDistField, cropBox);\n}\n\nfloat scene (vec3 p)\n{\n    float parkingWalls = min (min (parkingWall1 (p), parkingWall2 (p)), min (parkingWall3 (p), text (p)));\n\treturn min (min (parkingFloor(p), parkingCeil(p)), parkingWalls);\n}\n\n#ifdef HIRES_IMAGE\n\n#define IMG0_WIDTH 200\n#define IMG0_HEIGHT 69\nuint shaderBuf0[3450] = uint[](0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,72111188u,1275331584u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,139481096u,67371008u,67108864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,134743049u,1364262912u,134742016u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,134483213u,89456640u,72091648u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1028u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,67702034u,1380798720u,543744u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,282956u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,544077u,134217728u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,67703319u,454185293u,281608u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,5068117u,1291845632u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,72439129u,1426587648u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,67965467u,455038545u,1359217740u,134217728u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,5594461u,1498219520u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1297440161u,1565589504u,0u,0u,0u,0u,0u,0u,0u,0u,151258116u,0u,0u,0u,8u,856603u,455024474u,1364263940u,134742016u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,72721062u,2723499268u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8u,1436395174u,2706965504u,0u,0u,0u,0u,0u,0u,0u,2390u,1447888900u,134480900u,0u,0u,8u,857631u,1667440415u,1599164749u,139545604u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,140093094u,2795657553u,1208221696u,1032u,134480900u,0u,0u,0u,0u,2313u,151520260u,264277u,2712317610u,2790851584u,0u,0u,0u,0u,0u,0u,0u,5069470u,2589347153u,290540808u,1212679168u,0u,4u,67966507u,1582456607u,455022157u,1292391761u,67108864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,139829926u,2795674969u,1431391565u,1208505689u,1499026760u,67108864u,0u,0u,0u,72174929u,1364282701u,67392929u,2863575726u,2791114752u,0u,0u,0u,0u,0u,0u,4u,1520672341u,2661177946u,1515869786u,1359218696u,67108864u,4u,68034158u,285215062u,454761306u,290261077u,1426587648u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1213571754u,2863310498u,2639878489u,1499047590u,2795674969u,1359478784u,0u,0u,4u,1297176154u,1515870806u,1499047594u,2997793454u,2791114752u,0u,0u,0u,0u,0u,0u,2394u,2723829159u,2728304286u,1583242842u,1515867392u,67371008u,1032u,85075562u,150994944u,224008987u,454430029u,1364546824u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,139829930u,4008618662u,2728567458u,2728832690u,2997791398u,2723761412u,0u,0u,73u,1364630174u,2661194398u,2796466866u,2874909358u,2791114752u,0u,0u,0u,0u,0u,0u,611998u,1359237534u,2728633247u,2745394019u,1431394897u,67372032u,2056u,152184426u,67108864u,3350u,521886486u,151540053u,1359478784u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,140093098u,4076007146u,2863311530u,2863329010u,4075991726u,2862766413u,0u,0u,2125u,1453237155u,2745148327u,3002529455u,1532450730u,2791132160u,0u,0u,0u,0u,0u,0u,89216585u,67392931u,2745410467u,2812781415u,1733362769u,1359236100u,19464u,219556454u,67109888u,0u,219552539u,1511064584u,1364545800u,134479872u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1213834926u,4076073975u,4075745006u,4008637171u,4076007086u,2930400597u,67108864u,0u,280913u,2594088871u,2812782507u,4227528543u,1465341854u,2858241280u,0u,0u,0u,0u,0u,4u,1297155414u,1453238179u,2745411495u,2812782503u,1738689792u,1364019280u,84235272u,236597090u,67109892u,262144u,67112278u,454759949u,67372104u,1275592704u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1297983214u,4076075003u,4092785650u,4075746295u,4159959790u,2930156121u,1291845632u,0u,609622u,2661525415u,2745673715u,4227572567u,1465340758u,2795327744u,0u,67634180u,0u,0u,0u,4u,1296914010u,2745410399u,2678564775u,2812782503u,2812518921u,140117076u,1347461124u,304033561u,0u,3333u,0u,223746843u,374424644u,1280114688u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,1302506222u,4076074926u,1213310702u,4075484147u,4092850930u,4003897949u,1359216640u,0u,71913882u,2661525415u,2812520439u,4227290967u,1465867090u,2728546560u,0u,67718408u,67108864u,0u,0u,0u,1297504947u,1666931551u,2812782503u,2812782503u,2812520350u,5854536u,2762516488u,371405593u,0u,4626u,0u,4635u,527125828u,1280640000u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,1302506222u,4076073894u,67371089u,2868047603u,4092850930u,4004160157u,1493696512u,4u,156063386u,2678302627u,2745693183u,4221784919u,1529553750u,1520851200u,9u,1229540684u,134479872u,0u,0u,0u,156872439u,1604559783u,2812782503u,2813044305u,1520936871u,1443471872u,1555344396u,438514449u,0u,3675u,150994944u,1307u,594762308u,1218250752u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8u,1302506222u,4076072682u,1207960580u,77197042u,4160222194u,4071270050u,1565590528u,4u,1297177246u,2745672611u,2745957375u,4149695319u,590293851u,1453762129u,18769u,1364283732u,1275592704u,0u,0u,0u,1369879219u,2812520359u,2812782503u,2807452066u,1498785703u,2806881873u,145796105u,455553805u,22697u,1275332891u,1443693572u,26u,590571077u,1151421696u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8u,77769386u,4008635118u,2634287266u,2639353254u,4076600311u,4092504742u,2723742720u,1101u,1364631202u,2678039463u,2880175103u,2874626907u,724512551u,1470279334u,1364023898u,1515870809u,1414334464u,0u,0u,81u,1571465891u,2812781479u,2812783518u,155821995u,2879804839u,2812414370u,10593545u,455553809u,1431875768u,3043844450u,526012937u,67371026u,523202377u,1151751424u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1028u,140093098u,4008372906u,134521578u,3941771861u,1437267967u,4227002026u,2795636736u,19793u,1452973731u,2745411495u,2745957371u,1532188515u,791622447u,1532735154u,2862522018u,2728304285u,1498238208u,0u,0u,2133u,1566728867u,2812782503u,2812694792u,161654699u,2880152145u,2812761438u,1359237133u,455027554u,2780084345u,1965648238u,858729314u,218104845u,455570257u,1151687936u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,139566758u,2795937032u,77196010u,3942383607u,2795347378u,4227329774u,2863290628u,611674u,2661197402u,2728567454u,2662333359u,1465079591u,791884591u,660318198u,2997003171u,2745409442u,1565610240u,0u,0u,1109u,1565612703u,2678302631u,1510212612u,2661703271u,1718052356u,1369941769u,2650800146u,454762343u,157902949u,1763514653u,791622519u,1778648069u,455291742u,1151181312u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,138959266u,2638808068u,1374350058u,3942121471u,4155398477u,2801267370u,2863571460u,545110u,2661526362u,1225345353u,1370684327u,1465080615u,725038895u,660037627u,4155220899u,2745410466u,2723566848u,1024u,0u,8u,1571181833u,1453303642u,67372113u,2879810351u,791621466u,5941082u,2656108557u,1511725855u,521803277u,202378252u,505882411u,1801256964u,438251366u,1146201600u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,67654993u,67372109u,3941264106u,3874750463u,4222506590u,156889842u,4008618500u,67371081u,1520673711u,1426325508u,145948583u,1465327399u,724775723u,1666668539u,4222330791u,2812519331u,2728024576u,2304u,0u,545113u,1570942638u,1426675358u,67372118u,2818274095u,791621478u,71936935u,1298024781u,151852570u,521871135u,454694413u,157229855u,593102848u,303770479u,1229233412u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,67634176u,1369572518u,3941263074u,3874420735u,4217266975u,1594708462u,4008637000u,1296826372u,5069483u,4015916036u,1437006835u,1532436259u,657402663u,1599560699u,4154959783u,2812519331u,2812190208u,4617u,4u,1364828838u,2930963378u,4155134289u,1582105604u,2733881135u,791621419u,352364455u,1515563767u,4155417165u,152196703u,521871135u,454760986u,442108164u,152773491u,1430539524u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,263172u,134217817u,2857213422u,3940999914u,3941529599u,2858623779u,1666253981u,4008899148u,2640141657u,1359478789u,1521460744u,2868902835u,2740328991u,589768483u,1532471295u,2862852007u,2812781475u,2812781132u,67442194u,262229u,2728831658u,2863575031u,4159943586u,1297436932u,1454111595u,791358251u,1644208807u,2740582387u,2952001527u,2857782533u,223762975u,522133343u,1528170756u,68887347u,1581533444u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,67373060u,285094u,1498786538u,3869436650u,3941530615u,1646733095u,1577320456u,4008899153u,2638826058u,1448761681u,67413678u,4160747423u,1465340507u,522395423u,1465364407u,1801936478u,2661525415u,2812782245u,134501910u,151275942u,2930682538u,2880417711u,2880435119u,2857979213u,77771695u,724249387u,1661836967u,2812211030u,1246386859u,4092831314u,84148233u,303175195u,454762267u,370876203u,1715749892u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,67372036u,1297964369u,1442312102u,2733042410u,3937336226u,1730882407u,151257092u,3941527125u,1497957890u,33687118u,1447886929u,4227838883u,2606192466u,387389271u,1398273967u,657405811u,1582998183u,2813241680u,67393047u,369383858u,2998120367u,3019092979u,4092833775u,4088374857u,72460215u,1663247126u,84496798u,2745084751u,185273870u,1386674163u,2651390034u,454761054u,1448500063u,521871139u,1715749892u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1028u,67373145u,2723829257u,3002592162u,3958370287u,4026267494u,858993506u,1028u,2867786325u,1493762562u,33949186u,33950293u,4294684579u,2677757783u,1377245015u,1470364519u,1798519607u,795040427u,2947176784u,134499611u,454208247u,4155765683u,4092852211u,4092851123u,2884891562u,1292148467u,2870942217u,168690769u,1296671315u,252644946u,1381063090u,4222224649u,454764339u,1801393682u,307649311u,1648952324u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1032u,139567778u,1515868834u,4226787055u,4092851187u,4093356663u,993489677u,1028u,3874419281u,2718237186u,33686018u,101123750u,4294420391u,2745146199u,1465078611u,1404022281u,1432514159u,723738287u,2947241384u,2684372310u,458665975u,4160223223u,4160223155u,2931030007u,4155486195u,2924300710u,2874871310u,320277922u,1515345503u,257036817u,286265424u,2784670285u,287518515u,572201759u,526062089u,285213700u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,76u,1504075358u,1650329847u,4154912751u,4092851195u,4227294771u,859006468u,263245u,3936770393u,2701525506u,33686018u,101124015u,4289700771u,2745409439u,1532449623u,1475826948u,67372041u,358489454u,2947522736u,2958312517u,1381412851u,4160223223u,4159959982u,3014042291u,4160204719u,4155377997u,2723305047u,387668638u,2740342367u,1376587865u,2931276727u,2997268150u,1365144431u,791093019u,1528520530u,543748u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,262144u,284062u,2724292198u,1649779451u,2884629491u,4092851191u,4222249771u,728700164u,67372121u,2634548381u,2724088326u,101057026u,101387187u,4222067619u,2745672607u,2677757783u,2813461508u,67372036u,224554871u,1650306220u,2896710729u,1230678771u,4093114359u,4093114291u,1583309581u,2729703343u,2951980548u,1369415518u,151870115u,2740605526u,1443651003u,3216998271u,2143271602u,4133052006u,1931352603u,521869142u,151538692u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,67371012u,1365157470u,1583787621u,1493743607u,4025742323u,4092851195u,4217793383u,1734804484u,67389529u,1566131366u,4070987342u,185273090u,185290747u,4154695583u,2745411491u,2677775267u,4154852356u,67372036u,1785687867u,2070849964u,2896996424u,1145919151u,3019372535u,4160205730u,454760192u,5352179u,2880417702u,89301577u,630439u,1599229518u,1498790527u,2139062207u,3212558014u,3136724314u,1784046426u,1582717466u,369951748u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,67391838u,2795920935u,661085605u,1499069427u,4092851187u,4092851191u,2942461803u,2942437469u,2864118719u,4289613226u,4071272102u,1313803023u,252402683u,4087587747u,2745411567u,2745412530u,2857174020u,71582729u,1719091007u,1060861617u,2964369576u,1279614562u,3019372535u,4159961003u,522133248u,67372198u,4088112883u,2651128832u,5679015u,1358958090u,1370668927u,3216767991u,2862768494u,3137076130u,1163550563u,1572055642u,303106308u,67108864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1230874282u,2791976751u,1800734881u,78574327u,4160222195u,4092851195u,2792074082u,1504376831u,4290756479u,3075583739u,4159631090u,2924892943u,252683263u,2946737059u,2745410475u,2879869188u,1145324612u,1229541734u,2000371519u,1060845430u,2914037936u,2835916386u,1655961587u,3019111347u,589259525u,67371012u,2796529570u,2874212352u,1437310473u,2569u,1442315199u,4227595178u,1427510797u,1370422267u,2785631911u,2863836847u,1578240256u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,85u,2729093730u,1865889651u,1493435396u,1370420983u,4160222195u,4093114363u,1583260338u,4227858367u,3212803963u,1571749887u,4226984690u,4075970130u,324250619u,2879628195u,2745410467u,4020633669u,1166361925u,1432250223u,1869310839u,2071672631u,1941089712u,4105000367u,2791222191u,2947545083u,1730621205u,67108868u,78293918u,2812740941u,1514995712u,67718665u,2800983726u,4227331925u,1512250135u,369992187u,4221962658u,2801490342u,1733956105u,67108864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,547238u,2863292975u,859009885u,67372036u,2712532730u,4160223223u,4160223150u,2801269759u,4294950783u,2071690094u,1858076671u,4294421158u,4008637086u,1313778427u,2812519331u,2745673643u,2812691589u,2236174942u,2880154531u,2745147299u,1735619443u,1936945070u,2985602141u,3014352482u,2880435195u,1798255462u,263168u,72723363u,2662029833u,1516198486u,223235662u,2935201442u,2729356817u,589504287u,436798549u,3069946445u,2796464798u,2875612694u,218366976u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1302242994u,2858822447u,791896580u,67372036u,2729047546u,4210554871u,4160224170u,4227596287u,4290229170u,2930419289u,2931539967u,4294683298u,2796220151u,2723263223u,2812519331u,2745147290u,2862761033u,1448828771u,2678039463u,2812500895u,2678024047u,1869836143u,1789833649u,2712907610u,1587785715u,3077257075u,134480896u,145597095u,2661787401u,168776535u,1532644873u,2733613573u,2728875610u,656877351u,150995972u,1303116714u,1302243921u,2812502626u,1494287364u,67371008u,0u,0u,0u,263168u,0u,0u,0u,0u,0u,81u,2729112494u,1646996267u,728105988u,67109977u,1498788341u,4143446007u,4093115306u,4294966263u,4075745006u,4008616686u,3936792315u,4294963954u,4160223154u,1431417587u,2745409435u,2593804877u,2925151318u,1599839131u,2610648658u,1470079835u,1398251427u,1802465135u,1801938605u,2980687535u,1515870891u,4218107703u,1644430340u,72963495u,2740627286u,22173523u,1397969755u,1448232261u,1146791775u,1449274215u,263172u,84913147u,2857215492u,2812782506u,1785091332u,67109892u,67108864u,0u,1032u,1364547925u,218103808u,0u,0u,0u,4u,20902u,2935224162u,724249387u,1796276228u,67372194u,67394805u,4076271607u,4093114286u,4227329774u,4008636138u,3936283374u,4008636138u,4160749567u,4227331925u,1431173107u,2745147290u,1447644759u,3009037722u,2677775259u,2610602577u,1297241943u,1397970843u,2678812527u,1869309799u,2863509934u,2941672278u,2952227635u,1863122944u,145947302u,2807735131u,89038751u,2678040406u,1465339478u,1380275807u,1667126874u,263168u,17238959u,4221740548u,2662067179u,2926733909u,72421641u,67437828u,1028u,1280397653u,2712250793u,1700333568u,0u,0u,0u,0u,72197807u,4093356647u,656877351u,1644168196u,67372194u,67111080u,2985752311u,4160222126u,4008636142u,4008635114u,2577329902u,4008701934u,3941859327u,4227309146u,1298004915u,2740605262u,1381454679u,3009039771u,2610404251u,2526958852u,280914u,1465340755u,1465624427u,1869572967u,1734847149u,2857458445u,2817765163u,727843840u,150404786u,2812497242u,1292197791u,2745934495u,2673563218u,1465009498u,589521758u,1375731712u,17171279u,2951915012u,1521201135u,2947708594u,1359830558u,437324036u,151587149u,1212433476u,1218030002u,2930336081u,67108864u,0u,0u,0u,78032883u,4160445991u,589504291u,1426063360u,282017u,1108u,4054691314u,4159941363u,4008636142u,4075989589u,156888814u,4076073967u,4008375039u,4221983309u,2790390694u,1297240915u,1397970778u,1588221595u,2610404251u,2588738564u,72439044u,89019991u,1465342823u,1802201959u,1734829922u,1364873817u,2812802983u,656890368u,73266862u,2728630870u,348763u,2745148327u,2745411414u,1599557206u,656876319u,1600082436u,395011u,1404281348u,1588572143u,4025726907u,2987137579u,656810509u,265554u,1380533573u,1145324621u,2712251813u,1493958656u,0u,0u,0u,1504637943u,4160704871u,589242207u,218365952u,566962u,2852668484u,2425920937u,4076055283u,4008637098u,2723767911u,1599491494u,4008965107u,4092587763u,2992001437u,4221761442u,89282391u,1448235610u,2678237083u,2526452566u,145337941u,1570571268u,67372041u,1381455703u,1600612199u,1734563414u,1527929257u,2863377399u,1730355990u,282960u,2594414495u,2651128841u,1314562983u,2813046609u,2673826638u,1465326367u,522150751u,1443169543u,123099549u,1303378931u,4092851131u,3148745062u,791621414u,67371013u,307976018u,1162167364u,1145591201u,2841729292u,0u,0u,77u,2796550135u,4227834462u,1595611995u,1443104853u,2868379647u,4222768521u,2307492168u,1436986103u,4088027490u,2004562731u,593449301u,2649420787u,4092850158u,1504332040u,1571990024u,71914066u,1520409499u,2610866082u,2593804548u,1291234909u,1565590532u,67372113u,1431916882u,1465607010u,1448500054u,224026470u,2846796459u,4083622687u,302253060u,1453563807u,2941583361u,168166998u,2863551907u,2745410125u,1386192735u,1532697435u,1600083462u,123098610u,2644114423u,4092851191u,3149882897u,1932997423u,1577322500u,1370169115u,458377541u,1162101828u,1369548129u,1426587648u,0u,93u,2868115447u,4160747353u,1364875938u,2863919965u,2868116475u,4227594154u,2795345229u,1208242598u,1427794735u,859519795u,1868210922u,3936527090u,4092850158u,1235655245u,1296652966u,2723567190u,1448582043u,2610337447u,2722956364u,2779619746u,1493435396u,1436723882u,2930682461u,1431724886u,1528170842u,1734566755u,2863245738u,2880398111u,521536772u,1369939871u,2879259986u,84281095u,101077594u,2656436224u,1453828011u,2880137059u,1528519515u,1448758771u,4065176315u,4159960051u,3077989973u,506671919u,1873391969u,1505389083u,454761302u,1313162308u,1145327005u,2774356228u,0u,1186u,2868115447u,4160487419u,4227595259u,4227595259u,2796221431u,4160223223u,4093029806u,2639877457u,1377773355u,792149815u,1649825438u,4008371870u,2868376563u,1369087899u,2610666399u,2728895391u,2677775254u,2526517082u,1292151290u,2908595805u,72179114u,2935421942u,2863031654u,2930466582u,223502259u,2942808931u,2942806697u,2930420643u,371137293u,1369677722u,2812413338u,2740322566u,101123846u,1029u,1453302695u,2741480367u,2943051615u,1582631582u,4154889723u,4227002094u,4005263982u,153497391u,1874263806u,2773814619u,454761243u,458641989u,1145324612u,1369530713u,134217728u,19874u,2868115447u,4160224251u,4227595251u,4227332087u,4222266099u,4160223223u,4160485025u,1420121160u,1297227559u,791882594u,286399318u,2666456738u,2728588275u,2790102682u,2610666399u,2677710503u,2660931222u,2593805828u,71871909u,1638048417u,1436986102u,4222789209u,1566747243u,1582696708u,73031603u,2942527263u,1532978086u,2846796455u,2745064026u,2661523359u,2812149846u,2678301521u,66821u,89562787u,2745410399u,1600366250u,2863048614u,2718781001u,1436978594u,4076336115u,4093099903u,1846373163u,728693502u,2902983685u,1511725851u,454761306u,1313162564u,1145609637u,1561133056u,20898u,2868115447u,4160223223u,4160223143u,4160223223u,4160467622u,4093114359u,3009237161u,2914103961u,1162695199u,593714692u,1186583u,1448799978u,2728566254u,4087764297u,1297504926u,2677709466u,2728567462u,2589000708u,1571987873u,2795939498u,2858266282u,1499028902u,2858637841u,151258116u,67127642u,459516767u,1733715811u,2863245994u,2812782499u,2677972634u,2660892754u,2745410471u,2723218436u,1431983702u,1292436737u,84215040u,328866u,1426063360u,1391699529u,4160748531u,4092835711u,2137087595u,656894886u,1476920324u,68556571u,454761243u,458903109u,1166362965u,2774338816u,20898u,2863637339u,2812784479u,2880416671u,4160223219u,4160224247u,2796726877u,72217333u,4188909042u,2722711890u,1443955712u,1186587u,391600814u,2795414173u,2868113130u,2728285444u,1230067354u,2593828603u,2567177297u,2778835630u,4076009202u,2857980249u,1571468135u,1511131401u,134481924u,71582976u,224356127u,458905183u,1600563886u,2863113118u,2593805910u,1448476676u,1453564835u,2885093380u,1145328034u,2795937378u,656628228u,285098u,67372036u,111932237u,2801795063u,4092785339u,2138708322u,1650349577u,67373326u,303175451u,454761243u,454761302u,1296385093u,1302419716u,20898u,2795414359u,1403213651u,1470324638u,2801005555u,4092852210u,2718172164u,41721u,4193889702u,2946994501u,1224999940u,68294427u,454170458u,2930152866u,2645226479u,3869701106u,2790327300u,88953165u,1229193305u,2796204795u,4155137365u,1432183206u,3064683286u,151258116u,67372036u,71648260u,67458591u,1667192401u,1583572650u,2863046234u,1448497485u,1364000768u,5677987u,2818286080u,1216712174u,4092521050u,723986202u,586329u,67372036u,5698462u,1308360699u,4159960055u,3212801557u,269225234u,370875163u,454761243u,454761243u,454761243u,1532381573u,1145591049u,20830u,2723826263u,1330859855u,1532189607u,2662313906u,2997508360u,139829913u,1207960737u,4126537390u,2645535642u,1141113860u,1185563u,454496791u,1521133133u,2644945651u,4024888311u,4159874564u,67372036u,1145655718u,2935403174u,1431657890u,2728833719u,1666910468u,67372036u,134744068u,1145390080u,67372050u,1595611990u,1444306530u,2846203221u,1296632073u,67389777u,1432003491u,2817782272u,1145668766u,4092261278u,1730882347u,161676121u,67371008u,306926u,1219166203u,4159960051u,3145695158u,2925614687u,522133275u,454761243u,454761243u,454761243u,454777678u,1145326852u,19801u,2728549030u,2740080471u,1531945886u,2729355938u,1426326605u,2733304554u,3936243020u,2969172730u,2996742895u,2790327300u,1186587u,454760210u,391555750u,2649640366u,4024952563u,4159959880u,67372036u,77178538u,2790873433u,2712053414u,2868294495u,454427652u,67372301u,370810394u,509746718u,505026065u,290873115u,454778719u,1654742353u,1224999940u,67718481u,1448779427u,2745957205u,4491657u,3937072110u,1428892463u,581893030u,134479872u,40695u,1498807291u,4159961079u,4223664127u,4294965158u,1511989023u,521870107u,454760214u,370563678u,1583524450u,1296040960u,2129u,1503830698u,2879824478u,2728568482u,2791132416u,67654045u,2644682474u,3941264034u,2851141114u,4160202406u,2947242500u,1186587u,454761243u,387406502u,2929853525u,3941328875u,4159960994u,67372109u,2728811865u,1499027801u,1431937373u,4143669019u,454167834u,505816875u,724249387u,858991403u,656876322u,505025042u,370613019u,1583176012u,0u,9u,1297177246u,2745695146u,18501u,2443375603u,2719887151u,800325623u,1426325504u,18931u,2785323767u,4160487423u,4294967295u,4294967295u,2858295071u,522149731u,1650351706u,1515870810u,1515869714u,150994944u,1097u,1364811354u,1520607914u,2795937365u,134217728u,4739413u,2509872802u,2800413418u,4008815794u,4160223146u,2662313890u,151853851u,454761243u,454766442u,1376933376u,2729110507u,4093114351u,1448479057u,1364482208u,2784404041u,1437120251u,4289666843u,454450735u,724249387u,724248363u,791094047u,521804306u,303174162u,303437334u,1515803724u,0u,0u,72177050u,2729112490u,1140850760u,1150676718u,3998821167u,863239163u,4155155037u,1431391658u,4065172978u,4093377531u,4227595259u,4294967291u,4221460058u,1448499797u,1359808777u,67371008u,0u,0u,4u,1213289813u,1515869525u,1292108800u,0u,4u,1297175961u,2661459622u,4004639149u,2868377587u,2942217135u,2874215771u,454761243u,454766447u,387406596u,78049263u,4093114351u,1532449550u,1302703280u,2964453978u,1297199871u,4284947227u,454761003u,723986211u,589242147u,656349974u,370283021u,151587081u,219288082u,375279884u,0u,0u,64u,1145324868u,1140850756u,1146200746u,3937015083u,791655415u,4092851187u,4160221938u,4092505842u,4075745006u,4076008182u,4223384571u,4159853977u,134480896u,0u,0u,0u,0u,0u,264196u,134479872u,1024u,0u,0u,280913u,1364827550u,2729028013u,2846011311u,2947505834u,2880133645u,1528503067u,454765423u,370613001u,5613299u,4093114355u,2806909711u,252599725u,2964369910u,1314499327u,4289666843u,454761255u,522132251u,454762279u,656086546u,307301637u,67108864u,84479250u,307647756u,0u,0u,0u,1078215748u,1145307136u,1145916838u,2867502686u,791621483u,1515280797u,2728830630u,2863048358u,2728567458u,2796203762u,4076272635u,4160220753u,2634286080u,0u,0u,0u,0u,0u,4u,67108864u,0u,0u,0u,0u,72175957u,1503765925u,2846465454u,4025742242u,2796531618u,156900123u,454765427u,370891533u,286195u,4160223219u,4015130127u,252645206u,1521070326u,2925460479u,4294667039u,522132251u,454761243u,454763303u,504780373u,1359544320u,0u,329997u,303126797u,67108864u,0u,0u,4211780u,1141112832u,4801873u,2729093717u,1646996267u,723719689u,151848025u,4087743560u,1145324612u,1145325905u,2644946674u,4076271526u,1369245696u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8u,1297438813u,2644615769u,2796269555u,2795941807u,2785630751u,455043955u,1443974477u,1571203827u,4160222123u,2740129551u,252644107u,258191021u,4138138623u,4294966191u,1662983967u,454761243u,454762014u,1516132685u,67108864u,0u,1033u,218977617u,67108864u,0u,0u,0u,0u,279620u,1436722858u,1365388075u,724248355u,525729954u,4087742532u,1145324612u,1145062468u,1145325653u,2729112306u,2639026440u,67108864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,281680u,1431936413u,1436723882u,2947195567u,2880131414u,1583242914u,2868115447u,4160222195u,2942787355u,387125002u,185273099u,190014378u,2935487487u,4294967291u,3076988703u,454761239u,303439390u,1565591552u,0u,0u,5u,151867729u,67108864u,0u,0u,0u,0u,1024u,1146462886u,2790087271u,723986215u,1661557239u,4070966272u,1141112832u,1028u,71320644u,1145675182u,3998304337u,134217728u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1032u,1280397653u,1498504870u,2863573662u,2947525465u,2800941047u,4160223223u,3014353759u,454759958u,370280970u,168430091u,185291430u,2868639739u,4227595259u,4223118171u,454694418u,370809109u,150994944u,0u,0u,0u,67702097u,134217728u,0u,0u,0u,0u,0u,4478370u,2795918605u,1583506010u,161675255u,4070704128u,67372032u,1028u,67109892u,1145324621u,2728806724u,1275330560u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,67373129u,1297174873u,2728831658u,2662330287u,4160486391u,4155485027u,1595611931u,370546194u,285803781u,84216330u,168495698u,1655877290u,2930946738u,2998054566u,1511396949u,1494551812u,0u,0u,0u,0u,264461u,134217728u,0u,0u,0u,0u,0u,18517u,2661722713u,67372113u,2935749623u,2929525760u,262144u,0u,1028u,67388484u,1146179908u,1141374976u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,67389444u,1364894374u,2858003375u,4088638307u,1528503067u,387388950u,303172869u,0u,261u,101321226u,1381934502u,1587980961u,2729092774u,1582388561u,218629120u,0u,0u,0u,0u,1033u,134217728u,0u,0u,0u,0u,0u,72u,1503831722u,2723784439u,4160224247u,2991653888u,0u,0u,0u,1032u,1145323584u,263168u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,5068126u,2728810846u,1595611931u,454761238u,370283025u,151257088u,0u,5u,84215306u,168712541u,1431657817u,1297176921u,1431373828u,67108864u,0u,0u,0u,0u,0u,134479872u,0u,0u,0u,0u,0u,0u,1297719978u,2935157490u,4076337074u,2856584192u,67108864u,0u,0u,0u,67372036u,263168u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,2385u,1520608858u,454761243u,370545170u,302844160u,0u,0u,0u,84214017u,84495701u,1359564040u,2125u,1275593728u,0u,0u,0u,0u,0u,0u,67371008u,0u,0u,0u,0u,0u,0u,5069218u,2796202670u,2930946730u,1363410948u,0u,0u,0u,0u,1028u,67372032u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8u,1364828762u,370611734u,303172873u,67108864u,0u,0u,0u,261u,83951620u,67108864u,4u,67371008u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,2133u,2644682406u,2795938381u,1141112836u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,139549202u,370545165u,151257088u,0u,0u,0u,0u,0u,0u,4u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,72175957u,1431127108u,1141112832u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,545105u,218694656u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,67372036u,67372036u,67371008u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1028u,4u,67371008u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,263172u,67372036u,67108864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,263172u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,67372036u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u);\n\nvec4 image0Blit(in vec2 uv)\n{\n\tuv = uv * vec2 (1.000, 1.000) - vec2 (0.000, 0.000);\n\n\tif (uv.x < 0.0 || uv.x > 1.0) return vec4(0.0);\n\tif (uv.y < 0.0 || uv.y > 1.0) return vec4(0.0);\n\n\tint vi = int ((1.0 - uv.y) * float (IMG0_HEIGHT));\n\tint ui = int (uv.x * float (IMG0_WIDTH));\n\tuint fetchedSample = shaderBuf0[vi*(IMG0_WIDTH/4) + (ui/4)];\n\tvec4 unpacked4Pixels = unpackVec4 (fetchedSample);\n    uint pixVal;\n    if (ui % 4 == 0) pixVal = uint (unpacked4Pixels.x * 255.0);\n    else if (ui % 4 == 1) pixVal = uint (unpacked4Pixels.y * 255.0);\n    else if (ui % 4 == 2) pixVal = uint (unpacked4Pixels.z * 255.0);\n    else pixVal = uint (unpacked4Pixels.a * 255.0);\n\treturn vec4 (float (pixVal & 3u) * 0.333333, float ((pixVal & 60u) >> 2) * 0.06666667, float ((pixVal & 192u) >> 6) * 0.333333, 1.0);\n}\n\n#else\n\n#define IMG0_WIDTH 100\n#define IMG0_HEIGHT 35\nuint shaderBuf0[875] = uint[](0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,2132u,67108864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,2057u,1358973952u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4718592u,0u,0u,0u,0u,0u,524288u,0u,0u,0u,0u,0u,0u,263186u,307036236u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,144525312u,0u,0u,0u,0u,0u,1297962240u,0u,0u,0u,0u,0u,0u,263191u,526011652u,134217728u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1303028301u,0u,0u,0u,4u,67108868u,2712314112u,0u,0u,0u,86u,1443367176u,67108864u,263454u,1579359053u,1280376832u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1369876125u,1431391581u,2639594496u,0u,18773u,1431374241u,2998051328u,0u,0u,0u,304030u,2723830362u,1359217664u,264495u,67705631u,306992388u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1370157738u,2795939570u,2997789256u,0u,284319u,2661200630u,1604756992u,0u,0u,0u,156893274u,2745410407u,1431373828u,527663u,13u,454757708u,1359216640u,0u,0u,0u,0u,0u,0u,0u,0u,1370158075u,4159958771u,4092504669u,0u,5349031u,2813067175u,1398253060u,1028u,0u,0u,1364023971u,2745673639u,2802078028u,89134698u,0u,858902u,155470848u,0u,0u,0u,0u,0u,0u,0u,0u,1504637943u,77787891u,4092783266u,134217728u,156672935u,2750675791u,1599579656u,2380u,67108864u,0u,1303273311u,2812783522u,2745649485u,2891455274u,86u,22u,725898496u,0u,0u,0u,0u,0u,0u,0u,0u,1437529074u,67391914u,4227329702u,1493172228u,1369351075u,2818549583u,790863521u,5330517u,1275068416u,0u,2712904615u,2813023646u,1520934485u,1482171174u,11292698u,1375731721u,794137864u,0u,0u,0u,0u,0u,0u,0u,4u,1303047846u,15396518u,2650536938u,2852388949u,2594087847u,2818528091u,859002870u,2795676574u,1426325504u,77u,1587521447u,2718193063u,2874517333u,135077671u,2763813221u,862914564u,593924433u,0u,0u,0u,0u,0u,0u,0u,0u,77483264u,2733305599u,4149061362u,3998285901u,2745567493u,2667007779u,859265963u,4087588771u,2655846404u,8u,2723762851u,651051u,791037095u,1426067995u,454430984u,573269504u,456344661u,0u,0u,0u,0u,0u,0u,0u,4u,67392853u,4008110847u,2854425245u,4082979080u,156936704u,2717864735u,724259759u,2947000227u,2807103505u,22950u,2935467605u,1359015795u,791872747u,1442050722u,1376918303u,454777344u,238242121u,0u,0u,0u,0u,0u,0u,0u,1028u,73226734u,3807046395u,590023936u,4154611018u,1380797854u,4289681238u,522146807u,661036711u,2879717403u,5878442u,2947526643u,2785562039u,657132962u,2728873635u,4020372489u,370875162u,371676484u,0u,0u,0u,0u,0u,0u,0u,263249u,1577973670u,4025481134u,929759232u,4070985986u,33687049u,4289174359u,1397971887u,725559198u,3008888918u,317978611u,4092851187u,4088333482u,1728973389u,1298074382u,228700680u,456351510u,437932288u,0u,0u,0u,0u,0u,0u,0u,564578u,1583542255u,4093115179u,923860996u,3864353026u,33686363u,4221805471u,1465102088u,67639914u,2879956032u,1459091447u,4159940262u,4159959817u,1582765918u,1599540821u,2998055602u,1433348891u,454427656u,0u,0u,0u,0u,0u,0u,1028u,1499621034u,1291579379u,4093095463u,1795181657u,2723279446u,117835687u,2946474919u,2611196416u,67136059u,1856811160u,1168570359u,4155448073u,1236266922u,1230307499u,1443517887u,2143271866u,4200487519u,1583025412u,0u,0u,0u,0u,0u,0u,20906u,1781472848u,1509685235u,4093338214u,2801205183u,2800939762u,2718895031u,2879628199u,3947971648u,1230665535u,1064808948u,1415751671u,4093059862u,44967u,2717949525u,436923u,4294071570u,1660900699u,2997491204u,0u,0u,0u,0u,0u,0u,77508203u,929693696u,2851796983u,4159941371u,4290739058u,3003121574u,4071230202u,2745410467u,2923465046u,2880152479u,1870099310u,4104498014u,2885380915u,19883u,2806863698u,1292564378u,2925340451u,156367769u,2862787354u,150994944u,0u,0u,0u,0u,8u,2800953135u,788529229u,1442183927u,4155441143u,4092521122u,3937927086u,4076293627u,2745145934u,2856935327u,2606406555u,1402957683u,1806347694u,1520612155u,218125474u,2677998935u,1465014853u,1365122667u,1787u,2572527530u,1778909188u,0u,67655001u,67108864u,0u,1198u,4218038059u,285212757u,5831159u,4155700206u,4025113075u,4025151231u,4216999423u,2589086291u,2857540507u,2588475474u,1398233963u,1869047725u,2651778927u,654335486u,2740322723u,2812500822u,1381115743u,150995207u,4216104687u,3010858270u,352584717u,1229231533u,2925068288u,0u,41719u,4279639839u,67110062u,1430296737u,4092784362u,2791446173u,4076072691u,2857217710u,89610070u,2728367958u,1431919876u,610899u,1667720026u,308128499u,1729757273u,2745126149u,1386475422u,2672958235u,525995266u,1402576631u,4022055445u,858390528u,1448232256u,1302439249u,0u,586743u,4289092194u,2795959039u,4289108301u,1218534951u,993731486u,3869964275u,1498240350u,1431739291u,2544064008u,2913357060u,1504094813u,1516181078u,1667738282u,4015986176u,2661263877u,100815446u,1509972903u,2808308571u,1386388983u,4092772185u,708011617u,2854427478u,1228949661u,1627914240u,5877751u,4227858427u,4227575470u,4160486318u,1565281827u,862851351u,2800133879u,1435933595u,2745409430u,2588738737u,2711769586u,4155155050u,1577650543u,2875678566u,2913689434u,2661263177u,2807169282u,156671839u,1520872039u,1493871253u,4226741119u,1429172222u,1476401947u,458639680u,1218793728u,5942947u,2947264419u,4160224247u,2930133421u,4121857358u,436209947u,312910494u,4087519825u,1381146355u,1291889066u,4071531097u,2712295945u,67371077u,375610202u,1722723235u,2656475648u,2661806848u,1234869841u,436797602u,40601u,4160484027u,2119769685u,67702299u,454762326u,1162124557u,5874259u,1393252255u,2884873821u,1297154137u,4256344730u,2331u,387163801u,2733894647u,4060610564u,1079620270u,2656656818u,1795751940u,67388420u,876374u,1516415322u,1296648457u,1369699161u,1083570086u,724257006u,247u,1442837491u,2138463510u,522132251u,454761243u,525484045u,5087910u,2807783334u,2790326353u,2800676505u,2969236394u,2869429531u,454497190u,2857234407u,4155375620u,2644662613u,1570963295u,369957406u,657141547u,656284182u,454778197u,9u,1386129403u,4497143u,1580429311u,134217894u,1375205371u,4294967295u,1579097955u,1582979674u,1583219968u,20821u,1587434760u,72u,1369024234u,4054971383u,2800702742u,454761267u,252271087u,4160182030u,1437119906u,1358870295u,455552807u,589506331u,370280713u,303454800u,0u,4805013u,18926u,3928110075u,4159613610u,2867787767u,4160487423u,4132768009u,67108864u,0u,4u,67108864u,0u,281941u,2712249770u,4087803806u,303765299u,319946922u,4160462603u,257599993u,1459355423u,455023387u,455547478u,1291845632u,67965525u,0u,64u,1140868429u,4003277615u,508645717u,4065152333u,1301916406u,4226438400u,0u,0u,0u,0u,0u,0u,139484573u,2733877931u,2719096678u,2728850163u,2942506763u,185274282u,3003121663u,1729829659u,371349832u,0u,265557u,0u,0u,0u,1370117415u,724244125u,4076879872u,64u,1374854481u,67108864u,0u,0u,0u,0u,0u,2125u,1364830886u,2880173823u,4222575387u,387322117u,101321554u,2998073334u,4205450838u,1494286336u,0u,1037u,67108864u,0u,0u,5614229u,151889663u,2852127744u,4u,71342404u,134217728u,0u,0u,0u,0u,0u,0u,19870u,2795661087u,387389202u,150994944u,67078u,1319197345u,1436636425u,67108864u,0u,0u,134217728u,0u,0u,22958u,2868378619u,2634022912u,0u,263232u,67371008u,0u,0u,0u,0u,0u,0u,4u,1516115735u,369952000u,0u,1u,84411396u,263168u,0u,0u,0u,0u,0u,0u,85u,2796203682u,1073741824u,0u,4u,67108864u,0u,0u,0u,0u,0u,0u,0u,72684041u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,67651584u,67108864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1028u,0u,0u,0u,0u,0u);\n\nvec4 image0Blit(in vec2 uv)\n{\n\tuv = uv * vec2 (1.000, 1.000) - vec2 (0.000, 0.000);\n\n\tif (uv.x < 0.0 || uv.x > 1.0) return vec4(0.0);\n\tif (uv.y < 0.0 || uv.y > 1.0) return vec4(0.0);\n\n\tint vi = int ((1.0 - uv.y) * float (IMG0_HEIGHT));\n\tint ui = int (uv.x * float (IMG0_WIDTH));\n\tuint fetchedSample = shaderBuf0[vi*(IMG0_WIDTH/4) + (ui/4)];\n\tvec4 unpacked4Pixels = unpackVec4 (fetchedSample);\n    uint pixVal;\n    if (ui % 4 == 0) pixVal = uint (unpacked4Pixels.x * 255.0);\n    else if (ui % 4 == 1) pixVal = uint (unpacked4Pixels.y * 255.0);\n    else if (ui % 4 == 2) pixVal = uint (unpacked4Pixels.z * 255.0);\n    else pixVal = uint (unpacked4Pixels.a * 255.0);\n\treturn vec4 (float (pixVal & 3u) * 0.333333, float ((pixVal & 60u) >> 2) * 0.06666667, float ((pixVal & 192u) >> 6) * 0.333333, 1.0);\n}\n\n#endif\n\nconst vec3 minGraffitiPt = vec3 (-5.0, -1.5, 8.9);\nconst vec3 maxGraffitiPt = vec3 ( 1.0,  0.5, 10.0);\nconst vec3 invGraffitiDims = 1.0 / (maxGraffitiPt - minGraffitiPt);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float distAway = 3.0;\n    vec3 curEye = vec3 (-1.0 + sin(iTime * 0.5), -1.0, distAway);\n    float sinTime = sin(iTime * 0.5) * 0.2;\n    vec3 sampleLook = vec3 (sin(sinTime), 0.0, cos(sinTime));\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    if ( dot (up, vec3 (0.0, 1.0, 0.0)) < 0.0 ) up = -up;\n    \n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n    vec4 finalColor = vec4 (0.0);\n    float drawDistSq = DRAW_DISTANCE*DRAW_DISTANCE;\n\n    for (float jj = min(0.0,iTime); jj != 100.0; jj += 1.0)\n    {\n        float curDist = scene (samplePt);\n        if (abs(curDist) < 0.001)\n        {\n            float gradD = 0.0001;\n            float gradX = scene (samplePt + vec3 ( gradD, 0.0, 0.0)) - scene (samplePt - vec3 ( gradD, 0.0, 0.0));\n            float gradY = scene (samplePt + vec3 ( 0.0, gradD, 0.0)) - scene (samplePt - vec3 ( 0.0, gradD, 0.0));\n            float gradZ = scene (samplePt + vec3 ( 0.0, 0.0, gradD)) - scene (samplePt - vec3 ( 0.0, 0.0, gradD));\n\n            vec3 ourNorm = normalize (vec3 (gradX, gradY, gradZ));\n            vec3 toEyeNorm = normalize (curEye - samplePt);\n            vec3 graffitiFetch, concreteFetch, color;\n            float concreteAmt = 1.0;\n\n            if ( clamp (samplePt, minGraffitiPt, maxGraffitiPt) == samplePt )\n            {\n                vec3 uvSampler = (samplePt - minGraffitiPt) * invGraffitiDims;\n                uvSampler.x = 1.0 - uvSampler.x;\n                graffitiFetch = image0Blit(uvSampler.xy).rgb;\n                if ( any(greaterThan(graffitiFetch.rgb, vec3 (0.4))) ) concreteAmt = 0.0;\n                graffitiFetch = pow (graffitiFetch * 2.0, vec3 (2.2));\n            }\n            if ( abs(ourNorm.y) > 0.001 )\n                concreteFetch = texture (iChannel1, samplePt.xz).rgb;\n            else if ( abs(ourNorm.z) > 0.001 )\n                concreteFetch = texture (iChannel1, samplePt.xy).rgb;\n            else\n                concreteFetch = texture (iChannel1, samplePt.yz).rgb;\n            color = mix (graffitiFetch, concreteFetch, concreteAmt);\n            color *= simplex3d_fractal(samplePt) * 0.6 + 0.4;\n\n            float AOTerm = 0.0;\n            AOTerm += max (scene (samplePt + 1.0 * ourNorm), 0.0);\n            AOTerm += max (scene (samplePt + 2.0 * ourNorm), 0.0) * 0.5;\n            AOTerm += max (scene (samplePt + 3.0 * ourNorm), 0.0) * 0.3333;\n            AOTerm += max (scene (samplePt + 4.0 * ourNorm), 0.0) * 0.25;\n            AOTerm += max (scene (samplePt + 5.0 * ourNorm), 0.0) * 0.2;\n            AOTerm += max (scene (samplePt + 6.0 * ourNorm), 0.0) * 0.166666;\n            AOTerm += max (scene (samplePt + 7.0 * ourNorm), 0.0) * 0.142857;\n            AOTerm += max (scene (samplePt + 8.0 * ourNorm), 0.0) * 0.125;\n            AOTerm += max (scene (samplePt + 9.0 * ourNorm), 0.0) * 0.111111;\n            AOTerm *= 0.1111111;\n            color *= AOTerm;\n            \n            finalColor = vec4(pow(color, vec3(1.0/2.2)), 1.0); // Gamma correct before output\n            break ;\n        }\n        samplePt += curDist*sampleDir;\n        vec3 samplePtToEye = samplePt - curEye;\n        if ( dot (samplePtToEye,samplePtToEye) > drawDistSq )\n        {\n\t\t    finalColor = vec4(texture (iChannel3, sampleDir).rgb, 1.0);\n            break ;\n        }\n    }\n\n    fragColor = finalColor;\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21548, "src": "https://soundcloud.com/user-322280034/garden-of-hope-mark-sparling", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltGWf.jpg", "access": "api", "license": "mit", "functions": [[2507, 2571, 2598, 2598, 2847], [2849, 2922, 2944, 2944, 3117], [3224, 3247, 3272, 3525, 4442], [4712, 4779, 4812, 4812, 4959], [4961, 4961, 4990, 4990, 5081], [5083, 5083, 5111, 5111, 5135], [5137, 5137, 5164, 5164, 5241], [5243, 5243, 5271, 5271, 5346], [5348, 5348, 5376, 5376, 5451], [5453, 5453, 5481, 5481, 5557], [6470, 6515, 6545, 6545, 7057], [7059, 7059, 7079, 7079, 7332], [7334, 7334, 7356, 7356, 7532], [44216, 44216, 44273, 44273, 47785]], "test": "untested"}
{"id": "WsXyW4", "name": "pruebaatd", "author": "jpupper", "description": "Esto es para probar entrar a tD", "tags": ["tdtouchcommunication"], "likes": 0, "viewed": 252, "published": 3, "date": "1584744664", "time_retrieved": "2024-07-30T21:17:40.443948", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    \n    float e = sin(iTime+uv.y*100.0);\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    \n    \n    // Output to screen\n    fragColor = vec4(e,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 353]], "test": "untested"}
{"id": "3dlcDH", "name": "Day 92", "author": "jeyko", "description": "poto", "tags": ["mdmtjvm"], "likes": 9, "viewed": 396, "published": 3, "date": "1584741593", "time_retrieved": "2024-07-30T21:17:41.347532", "image_code": "// Fork of \"Day 86\" by jeyko. https://shadertoy.com/view/wslcz8\n// 2020-03-20 15:03:42\n\n// Fork of \"Day 85\" by jeyko. https://shadertoy.com/view/WdfczH\n// 2020-03-14 09:43:07\n\n// Fork of \"Day 84\" by jeyko. https://shadertoy.com/view/Wssczn\n// 2020-03-13 10:52:05\n\n// radial blur and chromatic abberation in this buffer\n// thx iq for pallette and hg-sdf for polarMod\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),4.)*0.1;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*0.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*14.; \n    fragColor.r *= 1. + uv.x*0.8;\n    fragColor.g *= 1. + uv.y*0.7;\n    fragColor.b *= 1. + uv.y*0.7;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.1);\n    //1fragColor *= 18.;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.8));\n    fragColor *= 1. - dot(uvn,uvn)*0.6;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime + 3.6 + 5.)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define aa(j) clamp(map(p + n*j).x/j, 0.,1.)\n\nconst float speed = 4.5;\nvec3 att = vec3(1);\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0,vec2(floor(t)/256.)),texture(iChannel0,vec2(floor(t) + 1.)/256.), smoothstep(0.,1.,fract(t)));\n}\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat iii;\nfloat sdRhombus(vec3 p, vec3 s){\n\t\n    \n    p = abs(p) - s;\n    \n    float d = max(p.z, max(p.x, p.y));\n    \n    \n    d = max(d, dot(p.yx + s.yx*0.5, normalize(vec2(1.))));\n    d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1.))));\n    //d = max(d - s.x*0., -dot(p.z,p.x));\n    //d \n    \n    \n    return d;\n}\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 s )\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\n    #define modD vec3(1.5,2.5,0.9)\nfloat sdThangiPong(vec3 p){\n    float mmm = sin(iTime);\n\n    mmm = sign(mmm)*pow(abs(mmm), 5.);\n    \n    p.y -= iTime + iii + sin(iTime + iii);\n    p.y = pmod(p.y, modD.y);\n    \n    \n    p.xz *= rot(mmm*PI); \n    p.xz = abs(p.xz);\n    float d = sdRhombus(p , vec3(0.12));\n    \n    glow += max(0.5/(0.08+ d*d*4.)*vec3(0.1,0.43,0.3)*att, 0.);\n    \n    p.y -= 0.4;\n    p.xz *= rot(0.25*PI);\n    \n    float n = fOpUnionStairs(d, sdRhombus(p - vec3(0,0.0 + 0.0,0), vec3(0.1)), 0.2,4.);\n    d = min(d, n);\n    //fOpUnionStairs\n    return d;\n}\nfloat gg;\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    vec3 f = p;\n    \n    //vec3 n = p;\n    vec3 q = p;\n    \n    iii = pModPolar(q.xz, 3.);\n    \n    \n    vec3 u = q;\n    q.x-= 2.4;\n    \n    float dd = -q.x ;\n    \n    q = abs(q);\n    \n    \n    q.z -= 1.4;\n    \n    float ddC = max(abs(q.x),abs(q.z)) - 1.;\n    \n    vec3 v = q;\n    \n    dd = fOpUnionStairs(ddC, dd, 0.7,5.);\n    \n    \n    \n    vec3 h = q;\n    vec3 z = q;\n    \n    \n    h.y = pmod(h.y, modD.y*1.5);\n    q = pmod(q, modD*1.5);\n    \n    \n    \n    \n    u = abs(q);\n    float dW = min( min(\n        \t\t\tmax(u.z, u.y),\n        \t\t\tmax(u.x, u.y)\n                ),        \t\t\tmax(u.x, u.z)) - 0.04 ;\n    \n    \n    dd = fOpUnionStairs(dd, dW, 0.6,4.);\n    \n    \n    h.x -= 8.;\n    \n    float ddb = max(abs(q.z),abs(q.y)) - 0.1;\n    \n    \n    vec3 j = h;\n    h = abs(h);\n    h.xz -= vec2(0.8,0.0);\n    float ddc = max((h.z),(h.x));\n    //j.y -= modD.y*0.25;\n    j.x += 8.8;\n    \n    j = abs(j);\n    j.x -= 2.74;\n    j.y -= 0.2;\n    j = abs(j);\n    j -= vec3(2.8,0.25, 0.02);\n    \n    float ddm = max(j.z,max(j.x, j.y));\n    \n    j.x -= 0.1;\n    j.yx *= rot(0.4);\n    j.xz *= rot(-0.4);\n    j -= vec3(2.5,0., 0.02);\n    float ddz = max(j.z,max(j.x, j.y));\n    d = dmin(d, vec2(ddz, 14.));\n    d = dmin(d, vec2(ddm, 14.));\n    \n    //ddc = min(ddC);\n    \n    ddb = abs(ddb) + 0.005;\n    \n    ddb = max(ddb, z.z - 1.);\n    \n    //ddb = max(ddb, h.z - 1.);\n    \n    ddc = fOpUnionStairs(abs(dd+ 7.) - 0.1 , ddc, 1.,5.);\n\n    \n    vec3 idp = floor(z/modD);\n    \n    float mgmg = pow(abs(sin(h.x*0.05 + iTime*0.6 + sin(idp.z*2.) + idp.y*0.01)), 200.);\n    glow += 0.08/(0.001 + ddb*ddb*0.7)*(mgmg*6. + 0.008)*vec3(0.2,0.3,0.4)*att;\n    //dd = fOpUnionStairs(ddb, dd, 0.2,3.);\n    //dd = fOpUnionStairs(ddb, dd, 0.2,3.);\n    \n    \n    \n    float dF = p.y + 0.4;\n    \n    d = dmin(d, vec2(ddb, 1.));\n    d = dmin(d, vec2(-dd, 10.));\n    \n    \n    d = dmin(d, vec2(ddc, 1.));\n\n\n    \n    vec3 c = vec3(1);\n\td.x *= 0.6;\n    return d;\n}\nfloat dith;\n\nfloat side;\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = map(p);\n\n    \n    if(d.x < 0.3)\n        ro += rd*0.3;\n    p = ro; t = 0.; hit = false;\n    for(int i = 0; i < 140; i++){\n    \td = map(p);\n        d.x *= dith * side;\n        \n    \t//glow += exp(-d.x*20.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir ));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.0004,0);  \n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\n#define mx (2.*iMouse.x/iResolution.x)\n#define my (0.6*iMouse.y/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //\n\t//uv *= 1. - dot(uv,uv)*0.2;\n    uv.xy *= rot(sin((iTime*0.7 - 3.6))*0.3);\n    uv *= 1. + dot(uv,uv)*1.5;\n    \n    \n    vec3 col = vec3(0);\n\n    dith = mix(0.76,1., texture(iChannel0, 20.*uv*256.).x);\n    vec3 ro = vec3(0);\n    \n    ro.y += iTime*speed;\n    ro.y -= 0.57 - my;\n    \n    float n = pow(valueNoise(iTime*1.).x, 2.);\n    \n    \n    ro.y += sin(n);\n    float nb = valueNoise(iTime*1./4.).x;\n    float zoom = 7.4 + n*1.;\n    n *= 1.;\n    ro.xz += vec2(sin( nb*6.14*1.5 + mx),cos( nb*6.14*1.5 + mx))*zoom;\n    \n    vec3 lookAt = vec3(0,ro.y + sin(iTime)*0.05,0.);\n    lookAt.y += -0.5 + valueNoise(iTime*1./2.).x;\n    vec3 rd = getRd(ro, lookAt, uv);\n    //rd.yz *= rot(iTime);\n    \n    vec3 p; float t = 0.; bool hit;\n    float tA = 0.; side = 1.;\n    \n    for(int i = 0; i < 3; i ++){\n    \tvec2 d = march(ro, rd, p, t, hit);\n    \tvec3 n = getNormal(p)*side;\n        \n        vec3 ld = normalize(vec3(1));\n        \n        ld.xz *= rot(iTime);\n        ld.yz *= rot(iTime*0.6);\n        vec3 h = normalize(ld - rd);\n        \n        float diff = max(dot(n, ld), 0.);\n        float spec = pow(max(dot(n, h), 0.), 70.);\n        float fres = pow(1. - max(dot(n, -rd), 0.), 5.);\n        \n        //col += fres*0.04*vec3(0,0.5,1);\n        //col += diff*fres*0.03*vec3(0.8,0.2,0.7);\n        \n        col += spec*0.05*vec3(1,1.2,1.7)*att*0.3;\n        tA = max(tA,t);\n        \n        if(hit){\n            if (d.y == 10.){\n\n                col += aa(0.8)*pow(fres, 1.6)*0.2*vec3(0.7,0.9,1)*diff*att;\n                ro = p + n*0.1;\n                att *= vec3(0.7 ,0.9,1.)*(0.6 );\n\n                side *= -1.;\n                rd = refract(rd, n,0.9);\n                //rd = reflect(rd, n);\n            }else {\n                //col += fres*0.5*vec3(0.5,0.7,0.8)*0.3*att;\n                //float aaa = aa(0.5)*aa(0.1)*aa(0.7)*20.;\n                float aaa = aa(0.9)*aa(0.6)*1.;\n                //aaa = 0.3;\n                col += min(pow(fres, 1.), 0.04)*0.7*vec3(0.5,0.7,0.8)*att*aaa;\n                //col += spec*0.5*vec3(0.5,0.7,0.4)*0.3*att;\n                break;\n            }\n        \n        }\n    }\n    \n    \n    //col = mix(col, vec3(0.4,0.4,0.7)*0.3*att, pow(smoothstep(0.,1.,tA*0.013), 1.6));\n\n        \n    col += max(glow, 0.)*0.004;\n    //col = mix(col, vec3(0.2,0.7,0.8)*0.02, pow(smoothstep(0.,1.,tA*0.031), 1.));\n    col = mix(col, 0.14*vec3(0.1 + sin(iTime/2.)*0.3,0.7 + sin(iTime)*0.2,0.6 + sin(iTime)*0.1)*0.02*(min(att + 0.2, 1.)), pow(smoothstep(0.,1.,tA*0.041), 1.));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 368, 425, 425, 1537]], "test": "untested"}
{"id": "wdsyDH", "name": "JFA Caustic", "author": "wyatt", "description": "Using a clever sorting algorithm to render a caustic. \nHere is another cool use of the JFA algorithm :\n[url]https://www.shadertoy.com/view/ldV3Wc[/url]", "tags": ["jfa"], "likes": 37, "viewed": 780, "published": 3, "date": "1584739494", "time_retrieved": "2024-07-30T21:17:42.135425", "image_code": "Main {\n\tif (iFrame%I<I-1) discard;\n    Q = A(U);\n    Q *= sqrt(Q);\n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define T(U) A((U)-dt*A(U).xy)\n#define NeighborhoodT vec4 n = T(U+vec2(0,1)), e = T(U+vec2(1,0)), s = T(U-vec2(0,1)), w = T(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define grd 0.25*vec2(e.z-w.z,n.z-s.z)\n#define div 0.25*(e.x-w.x+n.y-s.y)\n#define dt (iFrame<500?1.:0.1)\n#define I 4\n//Dave H :\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} ", "buffer_a_code": "Main {\n\t// Fluid:\nif (iFrame%2==0) {\n    Q = T(U);\n    NeighborhoodT;\n    Q.xy -= dt*grd;\n    Init Q = vec4(0);\n    Border Q.xy *= 0.;\n} else {\n    Q = A(U);\n    Neighborhood;\n    Q.z -= dt*div;\n}\n\tvec2 mo = 0.5*R;\n    if (iMouse.z>0.) mo = iMouse.xy;\n    Q = mix(Q,vec4(0.5*sin(dt*2.*iTime)*\n            vec2(sin(dt*iTime),0),\n            Q.z,\n            1.\n        ),\n     exp(-.2*length(U-mo)));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Translate Coordinate by gradient of pressure\n// Strength of translation determined by wavelength\nMain {\n    if (iFrame%I==0) {\n        Neighborhood;\n        Q.xyz = hash33(vec3(U,iFrame));\n        Q.xy = U+Q.xy*2.-1.;\n        Q.xy += 3e3*grd*(1.+Q.z);\n    } else Q = B(U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Hierarchical Sort\nvoid X (inout vec4 Q, inout vec4 r, vec2 U, vec2 u) {\n        vec4 b,c;vec2 i; float l;\n        if (iFrame%I==0) {\n            i = U+u; \n            b = B(i);\n            l = length(b.xy-U);\n            if (l<r.x) {\n                Q.xy = i;\n                r.x = l;\n            } else if (l<r.y) {\n                Q.zw = i;\n                r.y = l;\n            }\n        } else {\n            c = C(U+u);\n            b = B(c.xy);\n            vec4 bb = B(Q.xy);\n            i = c.xy;\n            l = length(b.xy-U);\n            if (l<r.x) {\n                Q.xy = i;\n                r.x = l;\n            } else if (l<r.y) {\n                Q.zw = i;\n                r.y = l;\n            }\n            b = B(c.zw);\n            bb = B(Q.xy);\n            i = c.zw;\n            l = length(b.xy-U);\n            if (l<r.x) {\n                Q.xy = i;\n                r.x = l;\n            } else if (l<r.y) {\n                Q.zw = i;\n                r.y = l;\n            }\n        }\n    \t\n}\nMain {\n    Q = vec4(1e9);\n    vec4 r = vec4(1e9);\n    if (iFrame%I>0) {\n    \tQ = C(U);\n        r = vec4(\n        \tlength(U-B(Q.xy).xy),\n        \tlength(U-B(Q.zw).xy),\n            0,0\n        );\n    }\n    float k = exp2(float(I-(iFrame%I)));\n    X(Q,r,U,vec2(0,k));\n    X(Q,r,U,vec2(k,0));\n    X(Q,r,U,vec2(0,-k));\n    X(Q,r,U,vec2(-k,0));\n    \n    X(Q,r,U,vec2(k,k));\n    X(Q,r,U,vec2(-k,k));\n    X(Q,r,U,vec2(k,-k));\n    X(Q,r,U,vec2(-k,-k));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Draw Photons to the screen\nvec4 P (vec2 U, vec3 p) {\n\treturn 0.0033/(1.+dot(U-p.xy,U-p.xy))*max(cos(p.z*6.2+vec4(1,2,3,4)),0.);\n}\nMain {\n    \n    Q = D(U);\n    if (iFrame%I==0) Q *= 0.9;\n    for (int x = -3; x <=3; x++) {\n        for (int y = -3; y<=3; y++) {\n            vec2 u = U+vec2(x,y);\n        \tvec4 c = C(u);\n            vec4 b = B(c.xy);\n            Q += P(U,b.xyz);\n            b = B(c.zw);\n            Q += P(U,b.xyz);\n            b = B(u);\n            Q += P(U,b.xyz);\n        }\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WdsyWH", "name": "fibrillation / propag automata", "author": "FabriceNeyret2", "description": "spontaneous sync.\n\n- cell transmit influx only if receptive (and alive)\n- after impulsed, has refractory delay #delay\n- some cells get randomly excited with low proba #freq\n  but only in the blue zone left to #p\n- mouse paint to kill cells in some areas", "tags": ["automata", "forestfire", "cardiacfibrillation", "synchronisation"], "likes": 4, "viewed": 426, "published": 3, "date": "1584728066", "time_retrieved": "2024-07-30T21:17:42.982162", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T(U); O.x /= delay;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// O.x : cell excitation state (time to be excitable again). \n// O.y : alive state (0 = alive)\n// O.z : shows spontaneous excitation (at low proba) area\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( iFrame == 0 ) {    // init\n        O = vec4(0);\n        if ( U.x < p*R.x /* && hash(U) > 1. - delay * freq */ ) \n            O.x = ceil( delay * hash(U+.5) ), O.z = .3;\n        return; \n    }\n    \n    O = T(U);                                                    // previous state\n    \n    if ( O.y == 0. )                                             // cell alive\n      if ( O.x == 0.)                                            // excitable cell\n        if ( U.x < p*R.x && hash(U+iTime) > 1.-freq )            // spontaneous impulse\n            O.x = delay;\n        else \n            for ( int k=0; k<9; k++ ) {                          // if excitation front in neighborhood, propagates  \n                vec2 D = vec2(k%3,k/3)-1.;\n                if( iFrame%2 < 1 || D.x*D. y== 0. )              // slows diagonal\n                if ( T(U + D).x == delay ) { O.x = delay; return; } \n            }\n      else O.x--;                                                // refractory period\n    \n    if ( iMouse.z > 0. && length(iMouse.xy-U) < 20. ) O.y = 1., O.x = 0.; // paint necrose\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define delay 60.       // refractory delay before cell get re-excitable ( per frame )\n#define freq   0.0003   // proba of spontaneous excitation ( per cell per frame )\n#define p      .8       // spontaneous excitation only for cell.x < p ( normalized coords)\n\n#define R iResolution.xy\n\n  #define T(U)     texelFetch( iChannel0,ivec2(U) , 0 )\n//#define T(U)     texelFetch( iChannel0,ivec2(U) % ivec2(R) , 0 )  // cyclical world variant\n  #define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 68]], "test": "untested"}
{"id": "3dlyD8", "name": "Mercator Projection", "author": "mla", "description": "Rather than use the Mercator projection to conformally map a sphere to a plane, we can do it backwards to map a plane pattern conformally onto a sphere. Display cycles through 4 patterns. Mouse rotates.", "tags": ["spherical", "mercator"], "likes": 24, "viewed": 679, "published": 3, "date": "1584708577", "time_retrieved": "2024-07-30T21:17:43.827900", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Spherical texturing with Mercator projection.\n//\n// Matthew Arcus, 2020.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 tiling(vec2 p) {\n  p *= 8.0;\n  p = mod(p,2.0)-1.0;\n  if (p.x*p.y < 0.0) p = p.yx;\n  p = 1.0-2.0*abs(abs(p)-0.5);\n  float t = 0.5*iTime;\n  vec2 n = vec2(sin(t),cos(t));\n  vec2 m = vec2(-n.y,n.x);\n  float d = dot(p,n), e = dot(p,m);\n  float k = min(abs(d),abs(e));\n  if (d < 0.0) k = min(k,abs(p.x-1.0));\n  if (e < 0.0) k = min(k,abs(p.y-1.0));\n  return smoothstep(0.025,0.05,k)*vec3(0.5,0.5,0);\n}\n\nvec3 mirror(vec2 uv) {\n  uv.y -= 0.1*iTime;\n  uv = mod(uv,2.0);\n  uv = min(uv,2.0-uv);\n  return texture(iChannel1,uv).rgb;\n}\n\nvec3 slider(vec2 uv) {\n  uv *= 4.0;\n  vec2 iv = floor(uv);\n  if (true) {\n    // Slide around a little\n    float t = 0.3*iTime;\n    if (mod(t,2.0) < 1.0) {\n      uv.x += floor(mod(iv.y,2.0))*fract(t);\n    } else {\n      uv.y += floor(mod(iv.x,2.0))*fract(t);\n    }\n  }\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 col = texture(iChannel0,uv).rgb;\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint IHash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 indexed(vec2 uv) {\n  uv *= 8.0;\n  uv.y += iTime;\n  ivec2 iv = ivec2(floor(uv));\n  float rnd = float(IHash((uint(iv.x)<<16) ^ uint(iv.y)))/pow(2.0,32.0);\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 col = hsv2rgb(vec3(rnd,1,1));\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nconst int ncolors = 4;\nvec3 getColor(int i, vec2 uv) {\n  //return indexed(uv);\n  i = i%ncolors;\n  if (i == 0) return slider(uv);\n  if (i == 1) return tiling(uv);\n  if (i == 2) return indexed(uv);\n  if (i == 3) return mirror(uv);\n  return vec3(1,0,0);\n}\n\nvec3 getColor(vec3 p) {\n  float x = atan(p.x,p.z);       // Longitude\n  float y = asin(p.y/length(p)); // Latitude\n  y = log(tan(0.25*PI+0.5*y));   // Mercator\n  vec2 uv = vec2(x,y);\n  uv /= PI;\n  float period = 10.0;\n  float t = mod(iTime,float(ncolors)*period);\n  int i = int(t/period);\n  t = mod(t,period);\n  return mix(getColor(i,uv),getColor(i+1,uv),smoothstep(period-1.0,period,t));\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  float r;      // radius\n  vec3 p;       // centre\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, (q+t*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  Sphere s = Sphere(1.0, vec3(0));\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec3(0);\n  } else {\n    vec3 n = hit.n;\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = getColor(hit.n);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n    color += 0.5*specular*vec3(1.0,1.0,1.0);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return color;\n  }\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (true) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1.0,-1.0));\n  light = transform(light);\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 p = vec3(0,0,-6);\n      vec3 r = vec3(uv,6);\n      p = transform(p);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      col += solve(Ray(p,r));\n    }\n  }\n  fragColor = vec4(pow(col/(AA*AA),vec3(0.4545)),1);\n}\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 302, 302, 354], [356, 356, 377, 377, 756], [758, 758, 780, 780, 882], [884, 884, 906, 906, 1333], [1335, 1335, 1357, 1357, 1533], [1535, 1599, 1619, 1619, 1733], [1735, 1735, 1758, 1758, 2071], [2096, 2096, 2127, 2151, 2325], [2327, 2327, 2350, 2350, 2717], [2961, 2961, 3015, 3015, 3500], [3502, 3502, 3543, 3543, 3651], [3696, 3696, 3715, 3715, 4142], [4144, 4144, 4171, 4171, 4498], [4500, 4500, 4557, 4557, 5113]], "test": "untested"}
{"id": "WdlyWH", "name": "Buildoids", "author": "leon", "description": "Shader made for the Cookie Collective live stream (2020/03/19) [url]https://www.twitch.tv/videos/570598632[/url]\nAdded dithering and mouse control for the Shadertoy version.", "tags": ["kifs", "city", "building"], "likes": 13, "viewed": 670, "published": 3, "date": "1584706573", "time_retrieved": "2024-07-30T21:17:44.765393", "image_code": "// Shader made for the Cookie Collective live stream (2020/03/19)\n// https://www.twitch.tv/videos/570598632\n// Added dithering and mouse control for the Shadertoy version.\n\n// Leon Denise aka ponk from Cookie Collective\n// Made in 2020/03/19 with the work of the Shadertoy community\n\nconst float iterations = 7.;\n\nvec2 mouse;\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nvec3 lookat (vec3 eye, vec3 at, vec2 uv, float fov) {\n  vec3 forward = normalize(at-eye);\n  vec3 right = normalize(cross(forward, vec3(0,1,0)));\n  vec3 up = normalize(cross(right, forward));\n  return normalize(forward * fov + right * uv.x + up * uv.y);\n}\n\nfloat map (vec3 pos) {\n  float scene = 1.0;\n  float range = 2.0;\n  float a = 1.0;\n  float falloff = 1.2 + mouse.x * 0.6;\n  for (float index = iterations; index > 0.; --index) {\n    pos.xz *= rot(iTime*.05);\n    pos = abs(pos)-range*a;\n    scene = min(scene, max(pos.x,max(pos.y,pos.z)));\n    a /= falloff;\n  }\n  scene = max(-scene,0.);\n  return scene;\n}\n\nvec3 getNormal (vec3 p) {\n  vec2 e = vec2(0.0001,0);\n  return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(0,0.,-2);\n    vec3 ray = lookat(eye, vec3(0.,sin(iTime*.2)*.5,0), uv, .5);\n    mouse = (iMouse.xy / iResolution.xy);\n    float total = 0.0;\n    float shade = 0.0;\n    float dither = random(uv);\n    const float count = 100.;\n    for (float index = count; index > 0.; --index) {\n        float dist = map(eye+ray*total);\n        if (dist < 0.001) {\n            shade = index/count;\n            break;\n        }\n        dist *= .9 + 0.1 * dither;\n        total += dist;\n    }\n    vec3 color = vec3(shade);\n    vec3 normal = getNormal(eye+ray*total);\n    color = vec3(.3)*clamp(dot(normal, normalize(vec3(0,1,-1))),0.,1.);\n    color += vec3(.9)*pow(clamp(dot(normal, -ray),0.,1.), 8.);\n    color *= shade;\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 326, 353, 353, 421], [422, 422, 442, 442, 492], [493, 493, 546, 546, 747], [749, 749, 771, 771, 1102], [1104, 1104, 1129, 1129, 1265], [1267, 1267, 1324, 1324, 2137]], "test": "untested"}
{"id": "wsXyD8", "name": "jFIG2020 contest announcement", "author": "haqreu", "description": "If you live in France or if you speak french, send us your shaders and win a high-end NVidia Quadro GPU! \nThe rendering contest is organized by the jFIG2020 conference that will be held in november 2020:\nhttps://jfig2020.sciencesconf.org/", "tags": ["procedural", "3d", "raytracing", "tutorial", "rendering", "challenge", "contest", "jfig2020"], "likes": 7, "viewed": 1654, "published": 3, "date": "1584694477", "time_retrieved": "2024-07-30T21:17:45.752753", "image_code": "#define BUNW 6\n#define BUNH 6\n#define BUND 4\n#define BUNVOXSIZE 0.1\nuint[] bunny_bitfield = uint[]( 0xc30d0418u, 0x37dff3e0u, 0x7df71e0cu, 0x004183c3u, 0x00000400u );\nbool bunny(in int cubeID) {\n    if (cubeID<0 || cubeID>=BUNW*BUNH*BUND) return false;\n    return 0u != (bunny_bitfield[cubeID/32] & (1u << (cubeID&31)));\n}\n\n#define JFIGW 32u\n#define JFIGH 18u\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nstruct Ray {\n\tvec3 origin;\n    vec3 dir;\n};\n\nstruct Box {\n    vec3 center;\n    vec3 halfsize;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nLight[] lights = Light[]( Light(vec3(-15,10,10), vec3(1,1,1)) );\n    \nbool box_ray_intersect(in Box box, in Ray ray, out vec3 point, out vec3 normal) {\n\tfor (int d=0; d<3; d++) {\n    \tif (abs(ray.dir[d])<1e-5) continue; \n\t\tfloat side = (ray.dir[d] > 0. ? -1.0 : 1.0);\n        float dist = (box.center[d] + side*box.halfsize[d] - ray.origin[d]) / ray.dir[d];\n\t\tif (dist < 0.) continue;\n        point = ray.origin + ray.dir*dist;\n        int i1 = (d+1)%3;\n        int i2 = (d+2)%3;\n        if (point[i1]>box.center[i1]-box.halfsize[i1] && point[i1]<box.center[i1]+box.halfsize[i1] &&\n        \tpoint[i2]>box.center[i2]-box.halfsize[i2] && point[i2]<box.center[i2]+box.halfsize[i2]) {\n            normal = vec3(0);\n            normal[d] = side;\n            return true;\n        }\n\t}\n    return false;\n}\n\nvec3 hs2rgb(vec2 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 colorFromIndex(float index) {\n    return hs2rgb(vec2(fract((index * 12.0)), index));\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// anti-unroll trick to help the compiler\n#define Z min(0,iFrame)\n\nbool bunny_ray_intersect(in Ray ray, out vec3 point, out vec3 normal, out vec3 color) {\n    float bunny_dist = 1e10;\n    vec3 p = vec3(0), n = vec3(0);\n    for (int i=Z; i<BUNW; i++) {\n    \tfor (int j=Z; j<BUNH; j++) {\n    \t\tfor (int k=Z; k<BUND; k++) {\n                int cellID = i+j*BUNW+k*BUNW*BUNH;\n\t\t\t\tif (!bunny(cellID)) continue;\n                Box box = Box(vec3(i-BUNW/2,j-BUNH/2,-k+BUND/2)*BUNVOXSIZE+vec3(.5,.5,-.5)*BUNVOXSIZE, vec3(1.,1.,1.)*BUNVOXSIZE*.45);\n                if (box_ray_intersect(box, ray, p, n) && length(p-ray.origin) < bunny_dist) {\n                    bunny_dist = length(p-ray.origin);\n                    point = p;\n                    normal = n;\n                    color = colorFromIndex(float(int(hash(uint(cellID)))%144)/144.);\n                }\n    \t\t}\n    \t}\n    }\n\treturn bunny_dist < 1e3;\n}\n\nvec3 cast_ray(in Ray ray) {\n    vec3 p = vec3(0), n = vec3(0), c = vec3(0);\n    if (!bunny_ray_intersect(ray, p, n, c))\n        return texture(iChannel0, ray.dir).xyz;\n    \n   \tvec3 diffuse_light = vec3(0.);\n    for (int i=0; i<lights.length(); i++) {\n       \tvec3 light_dir = normalize(lights[i].position - p);\n        vec3 shadow_orig = dot(light_dir, n) < 0. ? p - n*1e-3 : p + n*1e-3;\n\t    vec3 shadp, shadn, shadc;\n        if (bunny_ray_intersect(Ray(shadow_orig, light_dir), shadp, shadn, shadc)) {\n            continue;\n        }\n       \tdiffuse_light  += lights[i].color * max(0., dot(light_dir, n));\n    }\n   \n    return c*(vec3(.7,.7,.7) + diffuse_light);\n}\n\nvec3 rotateCamera(in vec3 orig, in vec3 dir, in vec3 target) {\n    vec3 zAxis = normalize(orig - target);\n    vec3 xAxis = normalize(cross(vec3(0., 1., 0.), zAxis));\n\tvec3 yAxis = normalize(cross(zAxis, xAxis));\n   \tmat4 transform = mat4(vec4(xAxis, 0.), vec4(yAxis, 0.), vec4(zAxis, 0.), vec4(orig, 1.));\n    return (transform * vec4(dir, 0.)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    const float fov = 3.1416 / 4.;\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y*tan(fov/2.); \n\n    vec3 orig = vec3(-sin(iTime/4.), 0., cos(iTime/4.));\n    vec3 dir = normalize(vec3(uv, -1));\n\tdir = rotateCamera(orig, dir, vec3(0.));\n    \n    vec3 col = cast_ray(Ray(orig, dir));\n    float m = max(col.x, max(col.y, col.z));\n    if (m>1.) col = col / m;\n    \n    vec2 coord = fragCoord/iResolution.xy*vec2(JFIGW, JFIGH);\n    if (jfig(uint(coord.x), uint(coord.y)))\n        col += vec3(.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 194, 194, 322], [540, 540, 573, 573, 713], [937, 937, 1018, 1018, 1665], [1667, 1667, 1688, 1688, 1851], [1853, 1853, 1887, 1887, 1944], [1946, 2017, 2038, 2038, 2169], [2238, 2238, 2325, 2325, 3075], [3077, 3077, 3104, 3104, 3744], [3746, 3746, 3808, 3808, 4097], [4099, 4099, 4156, 4156, 4698]], "test": "untested"}
{"id": "tsXyW8", "name": "PathTracerDemo", "author": "kstyler", "description": "I used https://raytracing.github.io/books/RayTracingInOneWeekend.html to help me learn path tracing", "tags": ["raytracing", "raymarching", "pathtracing", "pathtracing", "pathtracer"], "likes": 8, "viewed": 649, "published": 3, "date": "1584692530", "time_retrieved": "2024-07-30T21:17:46.614449", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor /= fragColor.w;\n    fragColor *= 2.5;\n    fragColor /= fragColor+1.;\n    fragColor = pow(fragColor, vec4(.45));\n    fragColor = smoothstep(0.,1.,fragColor);\n    fragColor.rgb = mix(vec3(0,.03,.05),vec3(1,1,1),fragColor.rgb);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int matID = 0;\nmat2 rotate(float a){\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nfloat hash21(vec2 p){\n\treturn(fract(sin(p.x*22.+p.y*421.)*999.));\n}\nvec3 randInSphere(vec2 seed){\n\tvec3 p;\n    int i = 0;\n    do {\n        p = 2.0*vec3(hash21(float(i)*seed+fract(iTime)*22.),hash21(float(i)+seed+fract(iTime)*43.),\n                     hash21(seed-float(i)+fract(iTime+float(i))*97.)) - vec3(1,1,1);\n    } while (dot(p,p) >= 1.0 && i++ < 500);\n    return p;\n}\nfloat sdfSphere(vec3 p){\n\treturn length(p)-(sin(p.y*sin(p.x*2.)*3.)*1.3)-1.;\n}\n\nfloat sdfPlane(vec3 p){\n    return p.y +1.5;\n}\nfloat map(vec3 p){\n\n    float sphere = sdfSphere(p);\n    float plane = sdfPlane(p);\n    float best = min(sphere,plane);\n    if(best == sphere){matID = 2;}\n    if(best == plane){matID=3;}\n    return best;\n}\nvec3 normal(vec3 p){\n    vec2 e= vec2(0,0.001);\n\treturn normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                          map(p+e.xyx)-map(p-e.xyx),\n                          map(p+e.xxy)-map(p-e.xxy)));\n}\nvec3 march(vec3 ro, vec3 rd){\n    float total = 0.;\n    float dist = 0.;\n    for(int i = 0; i<300; i++){\n        dist = map(ro+rd*total);\n        total+=dist;\n        if(dist < 0.01){\n        \tbreak;\n        }\n    }\n    if(dist>0.01){\n    \tmatID = 1;\n    }\n   \n    return (ro+rd*total);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(0,0,-6);\n    vec3 rd = normalize(vec3(uv+hash21(uv)/iResolution.y*0.5,1));\n    vec3 col = vec3(0);\n    vec3 accum = vec3(1);\n    \n    for(int i = 0; i<4;i++){\n    \n\n        col = (march(ro,rd));\n\t\t\n        if(matID == 1){\n            \n           col =  1.-vec3(0.1,0.1,0.1);\n           accum*=col;\n            \n        }\n        if(matID ==2){\n            \n           vec3 n = normal(col);\n           rd = randInSphere(uv)+n;\n           ro = col+rd*0.1;\n            \n        }\n        if(matID ==3){\n            vec3 n = normal(col);\n            rd = randInSphere(uv)+n;\n            ro = col+rd*0.1;\n        }\n        \n    }\n   \n    fragColor += vec4(1.-accum,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 358]], "test": "untested"}
{"id": "tslyDr", "name": "Raymarch Water", "author": "natethegreat2525", "description": "Implementation of raymarching with diffraction and reflection at 2 or 4 levels deep. 4 level depth based on LOD4 flag.\n\nOnly part not from scratch is the perlin noise. Credits in the code.", "tags": ["raymarching", "reflection", "refraction", "water"], "likes": 3, "viewed": 644, "published": 3, "date": "1584691286", "time_retrieved": "2024-07-30T21:17:47.450215", "image_code": "#define LOD4 ////////////////////////// UNCOMMENT THIS LINE FOR FULL DETAIL (Compile time is ~180s)\n#define MAX_STEPS 200\n#define MAX_DIST 100.0\n#define SURF 0.01\n#define EP 0.001\n#define PI 3.14159\n#define MIN_C(a, b) a.x < b.x ? a : b\n#define MIN_C4(a, b, c, d) a.x < b.x ? (a.x < c.x ? (a.x < d.x ? a : d) : (c.x < d.x ? c : d)) : (b.x < c.x ? (b.x < d.x ? b : d) : (c.x < d.x ? c : d))\n#define MIN_C3(a, b, c) a.x < b.x ? (a.x < c.x ? a : c) : (b.x < c.x ? b : c)\n#define MAX_C(a, b) a.x > b.x ? a : b\n\nmat2 rot(float a) {\n    float x = sin(a);\n    float y = cos(a);\n    return mat2(y, x, -x, y);\n}\n\nfloat sdLens(vec3 p) {\n    float l1 = length(p-vec3(0,0,1.7))-2.;\n    float l2 = length(p+vec3(0,0,1.7))-2.;\n    if (l1 < -0.002 && l2 < -0.002) {\n        return min(-l1-0.004, -l2-0.004);\n    }\n    return max(l1, l2);\n}\n\n//Rect with proper internal distances\nfloat sdRectInternal(vec3 p, vec3 s) {\n    float a = 0.002;\n    if (abs(p.x) < s.x-a && abs(p.y) < s.y-a && abs(p.z) < s.z-a) {\n        s-=a*2.;\n        return min(s.x-abs(p.x), min(s.y-abs(p.y), s.z-abs(p.z)));\n    }\n    return max(max(p.x-s.x, p.y-s.y), max(max(p.z-s.z, -p.x-s.x), max(-p.y-s.y, -p.z-s.z)));\n}\n\nfloat sdRect(vec3 p, vec3 s) {\n    return max(max(p.x-s.x, p.y-s.y), max(max(p.z-s.z, -p.x-s.x), max(-p.y-s.y, -p.z-s.z)));\n}\n\n\nfloat sdEllipse(vec3 p, vec3 s) {\n    float len = length(p/s)-1.;\n    return len*min(s.x,min(s.y,s.z));\n}\n\nfloat pseudoHash(float v) {\n    return mod(sin(35693.14159*v)*147.34+147.34, 2.)-1.;\n}\n\nfloat pseudoHash(vec3 v) {\n    return pseudoHash(v.x + pseudoHash(v.z));\n    return pseudoHash(v.z + pseudoHash(v.y + pseudoHash(v.x)));\n}\n\n\nfloat sdPlaneBumpy(vec3 p) {\n    float b = 0.05*snoise(vec3(p.x,iTime,p.z));\n    return abs(p.y-b)-.002;\n}\n\nvec2 getDist(vec3 p) {\n    float sphere = length(p-vec3(2,0,-2)) - 1.;\n    float plane = sdPlaneBumpy(p-vec3(0,0,0));\n    vec3 cubePos = p - vec3(-2, 1, -1);\n    cubePos.xy *= rot(PI/7.);\n    cubePos.yz *= rot(PI/8.);\n    float cube = sdRectInternal(cubePos, vec3(1));\n    vec3 cubePos2 = p - vec3(2,0,1);\n    cubePos2.xy *= rot(-PI/7.);\n    float cube2 = sdRectInternal(cubePos2, vec3(.1, 2, .1));\n    float container = sdRect(p-vec3(0), vec3(4,1,4));\n    float lens = sdLens(p-vec3(0,1,2));\n    vec2 lens_c = vec2(lens, 3);\n    vec2 water_c = vec2(max(plane, container), 0);\n    vec2 cube_c = vec2(min(cube, cube2), 1);\n    vec2 sphere_c = vec2(sphere, 2);\n    return MIN_C4(cube_c, water_c, sphere_c, lens_c);\n}\n\nvec2 getRayDist(vec3 rp, vec3 rd) {\n    float d = 0.;\n    vec3 p = rp;\n    vec2 ret;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        p = rp + rd*d;\n        ret = getDist(p);\n        d += ret.x;\n        if(ret.x <= SURF || d > MAX_DIST) break;\n    }\n    ret.x = d;\n    return ret;\n}\n\nvec3 getNorm(vec3 p) {\n    float c = getDist(p).x;\n    vec2 ep = vec2(EP,0);\n    vec3 norm;\n    vec3 eps[3] = vec3[3](ep.xyy, ep.yxy, ep.yyx);\n    for (int i = min(0,iFrame); i < 3; i++) {\n        norm[i] = getDist(p+eps[i]).x-c;\n    }\n    //vec3 norm = vec3(getDist(p+ep.xyy).x-c, getDist(p+ep.yxy).x-c, getDist(p+ep.yyx).x-c);\n    return normalize(norm);\n}\n\nvec3 reflectRay(vec3 ray, vec3 norm) {\n    float d = dot(ray, norm);\n    vec3 side = ray - d*norm;\n    return -d*norm + side;\n}\n\nvec3 lookupColor(float v) {\n    if (v == 3.) {\n        return vec3(1); //lens\n    }\n    if (v == 2.) {\n        return vec3(.5, 1, .5); //ball\n    }\n    if (v == 1.) {\n        return vec3(1, 0, 0); //box\n    }\n    return vec3(0.3, 0.5, 1); //water\n}\n\n// x: reflectivity, y: transparency, z: refractive index\nvec3 lookupReflectivity(float v) {\n    if (v == 3.) {\n        return vec3(0.0, 0.5, 1.1);\n    }\n    if (v == 2.) {\n        return vec3(0.5, 0.0, 1.0);\n    }\n    if (v == 1.) {\n        return vec3(0.0, 0.3, 1.1);\n    }\n    return vec3(0.3, 0.3, 1.4);\n}\n\nvec3 getColor4(vec3 rp, vec3 rd) {\n    vec2 ref_ray = getRayDist(rp, rd);\n    float refD = ref_ray.x;\n    vec3 refP = rp + rd*refD;\n    vec3 refCol = vec3(0);\n    if (refD > 99.) {\n        return vec3(0);\n    }\n    float refShade = clamp(dot(vec3(0,1,0), getNorm(refP)), .3, 1.);\n    refCol = refShade*lookupColor(ref_ray.y);\n    return refCol;\n}\n\nvec3 getColor3(vec3 rp, vec3 rd) {\n    vec2 first_ray = getRayDist(rp, rd);\n    float d = first_ray.x;\n    vec3 p = rp + rd*d;\n    vec3 norm = getNorm(p);\n    \n    float shade = clamp(dot(vec3(0,1,0), norm), .3, 1.);\n    \n    if (d > 99.) {\n        return vec3(0);\n    }\n    vec3 ret = shade*lookupColor(first_ray.y);\n    \n    vec3 props = lookupReflectivity(first_ray.y);\n    float reflectivity = props.x;\n    float transparency = props.y;\n    float refractivity = props.z;\n    vec3 refl_dir = reflectRay(rd,norm);\n    vec3 refl_rp = rp + rd*(d-SURF*2.);\n    \n\tvec3 refr_dir = refract(rd,norm,1.0/refractivity);\n    float dotnorm = dot(norm, rd);\n    vec3 refr_rp = rp + rd*(d-SURF*4./dotnorm);\n    \n    vec3 refrCol;\n    vec3 refCol;\n    for (int i = 0; i < 2; i++) {\n        vec3 p, d;\n        if (i == 0) {\n            p = refr_rp;\n            d = refr_dir;\n        } else {\n            p = refl_rp;\n            d = refl_dir;\n        }\n    \tvec3 col = getColor4(p, d);\n        if (i == 0) {\n\t\t\trefrCol = col;\n        } else {\n            refCol = col;\n        }\n    }\n    ret = ret * (1.-reflectivity-transparency) + refCol * reflectivity + refrCol * transparency;\n    return ret;\n}\n\n#ifdef LOD4\nvec3 getColor2(vec3 rp, vec3 rd) {\n    vec2 first_ray = getRayDist(rp, rd);\n    float d = first_ray.x;\n    vec3 p = rp + rd*d;\n    vec3 norm = getNorm(p);\n    \n    float shade = clamp(dot(vec3(0,1,0), norm), .3, 1.);\n    \n    if (d > 99.) {\n        return vec3(0);\n    }\n    vec3 ret = shade*lookupColor(first_ray.y);\n    \n    vec3 props = lookupReflectivity(first_ray.y);\n    float reflectivity = props.x;\n    float transparency = props.y;\n    float refractivity = props.z;\n    vec3 refl_dir = reflectRay(rd,norm);\n    vec3 refl_rp = rp + rd*(d-SURF*2.);\n    \n\tvec3 refr_dir = refract(rd,norm,refractivity);\n    float dotnorm = dot(norm, rd);\n    vec3 refr_rp = rp + rd*(d-SURF*4./dotnorm);\n    \n    vec3 refrCol;\n    vec3 refCol;\n    for (int i = 0; i < 2; i++) {\n        vec3 p, d;\n        if (i == 0) {\n            p = refr_rp;\n            d = refr_dir;\n        } else {\n            p = refl_rp;\n            d = refl_dir;\n        }\n    \tvec3 col = getColor3(p, d);\n        if (i == 0) {\n\t\t\trefrCol = col;\n        } else {\n            refCol = col;\n        }\n    }\n    ret = ret * (1.-reflectivity-transparency) + refCol * reflectivity + refrCol * transparency;\n    return ret;\n}\n\nvec3 getColor(vec3 rp, vec3 rd) {\n    vec2 first_ray = getRayDist(rp, rd);\n    float d = first_ray.x;\n    vec3 p = rp + rd*d;\n    vec3 norm = getNorm(p);\n    \n    float shade = clamp(dot(vec3(0,1,0), norm), .3, 1.);\n    \n    if (d > 99.) {\n        return vec3(0);\n    }\n    vec3 ret = shade*lookupColor(first_ray.y);\n    \n    vec3 props = lookupReflectivity(first_ray.y);\n    float reflectivity = props.x;\n    float transparency = props.y;\n    float refractivity = props.z;\n    vec3 refl_dir = reflectRay(rd,norm);\n    vec3 refl_rp = rp + rd*(d-SURF*2.);\n    \n\tvec3 refr_dir = refract(rd,norm,1.0/refractivity);\n    float dotnorm = dot(norm, rd);\n    vec3 refr_rp = rp + rd*(d-SURF*4./dotnorm);\n    \n    vec3 refrCol;\n    vec3 refCol;\n    for (int i = 0; i < 2; i++) {\n        vec3 p, d;\n        if (i == 0) {\n            p = refr_rp;\n            d = refr_dir;\n        } else {\n            p = refl_rp;\n            d = refl_dir;\n        }\n    \tvec3 col = getColor2(p, d);\n        if (i == 0) {\n\t\t\trefrCol = col;\n        } else {\n            refCol = col;\n        }\n    }\n    ret = ret * (1.-reflectivity-transparency) + refCol * reflectivity + refrCol * transparency;\n    return ret;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/(iResolution.x);\n\n    vec3 rp = vec3(0,2,-8.);\n    rp.xz = vec2(sin(iTime)*8., -cos(iTime)*8.);\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    rd.xz *= rot(-iTime);\n#ifdef LOD4\n    vec3 col = getColor(rp, rd);\n#else\n    vec3 col = getColor3(rp, rd);\n#endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[507, 507, 526, 526, 602], [604, 604, 626, 626, 824], [826, 864, 902, 902, 1176], [1178, 1178, 1208, 1208, 1303], [1306, 1306, 1339, 1339, 1411], [1413, 1413, 1440, 1440, 1499], [1501, 1501, 1527, 1527, 1639], [1642, 1642, 1670, 1670, 1748], [1750, 1750, 1772, 1772, 2464], [2466, 2466, 2501, 2501, 2748], [2750, 2750, 2772, 2772, 3108], [3110, 3110, 3148, 3148, 3237], [3239, 3239, 3266, 3266, 3487], [3489, 3546, 3580, 3580, 3797], [3799, 3799, 3833, 3833, 4145], [4147, 4147, 4181, 4181, 5333], [7725, 7725, 7782, 7782, 8119]], "test": "untested"}
{"id": "wlVSDK", "name": "Danger Noodle", "author": "BigWIngs", "description": "Watch fullscreen with sound. Use mouse to look around.", "tags": ["raymarching", "snake", "animal", "jungle", "viper"], "likes": 225, "viewed": 15792, "published": 3, "date": "1584688580", "time_retrieved": "2024-07-30T21:17:48.562243", "image_code": "// \"Danger Noodle\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Ever since I did a snake scale effect as one of my first ShaderToys\n// I have been wanting to do a snake, so here it is.\n//\n// Watch full screen with sound!\n\n#define MAX_STEPS 200\n#define MAX_DIST 60.\n#define SURF_DIST .01\n\n#define CAM_MOVE 1.\n\n#define S smoothstep\n\n#define MAT_TONGUE 1.\n#define MAT_HEAD 2.\n#define MAT_BODY 3.\n#define MAT_EYE 4.\n\n// From Dave Hoskins\nvec2 Hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.1031, 324.1030));\n    p += dot(p, p+33.33);\n    return fract(p.x*p.y);\n}\n\nfloat sabs(float x,float k) {\n    float a = (.5/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec4 s) {\n\tfloat t = dot(s.xyz-ro, rd);\n    vec3 p = ro + rd * t;\n    \n    float y = length(s.xyz-p);\n    \n    vec2 o = vec2(MAX_DIST,MAX_DIST);\n    \n    if(y<s.w) {\n    \tfloat x = sqrt(s.w*s.w-y*y);\n        o.x = t-x;\n        o.y = t+x;\n    }\n    \n    return o;\n}\n\n// From IQ\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n\treturn smin(a, b, -k);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdSph(vec3 p, vec3 pos, vec3 squash, float r) {\n    squash = 1./squash;\n\tp = (p-pos)*squash;\n    return (length(p)-r)/max(squash.x, max(squash.y, squash.z));\n}\n\n\nvec4 Scales(vec2 uv, float overlap, float skew, float point, float blur) {\n    \n    vec2 gv = fract(uv*5.)-.5;\n    vec2 id = floor(uv*5.);\n    \n    float m = 0.;\n    \n    gv.y = sabs(gv.y,point);\n    \n    float w = .5+overlap;\n    vec2 p1 = (gv+vec2(overlap,-gv.x*skew))*vec2(1,1.8);\n    float a1 = atan(p1.x-w, p1.y);\n    \n    float waveAmp = .02;\n    float waves = 10.;\n    float w1 = sin(a1*waves);\n    float s1 = S(w, w*blur, length(p1)+w1*waveAmp);\n    s1 +=  w1*.1*s1;\n    s1 *= mix(1., .5-gv.x, overlap*2.);\n    \n    gv.x -= 1.;\n    vec2 p2 = (gv+vec2(overlap,-gv.x*skew))*vec2(1,1.8);\n    float a2 = atan(p2.x-w, p2.y);\n    float w2 = sin(a2*waves);\n    float s2 = S(w, w*blur, length(p2)+w2*waveAmp);\n    s2 += w2*.1*s2;\n    \n    s2 *= mix(1., .5-gv.x, overlap*2.);\n    \n    if(s1>s2) {\n    \tm += s1;\n        m -= dot(p1,p1);\n    } else {\n        m += s2;\n        m -= dot(p2,p2);\n        id.x += 1.;\n    }\n\n    return vec4(1.-m, 0., id);\n}\n\nvec4 ScaleTex(vec2 uv, float overlap, float skew, float point, float blur) {\n\n    uv *= 2.;\n    vec4 s1 = Scales(uv, overlap, skew, point, blur);\n    vec4 s2 = Scales(uv+.1, overlap, skew, point, blur);\n    s2.zw -= .5;\n    \n    return s1.x<s2.x ? s1 : s2;\n}\n\n\nvec3 sdBody(vec3 p) {\n    float t = iTime*.3;\n    float neckFade = S(3., 10., p.z);\n   \n    p.x += sin(p.z*.15-t)*neckFade*4.;\n    p.y += sin(p.z*.1-t)*neckFade;\n    \n    vec2 st = vec2(atan(p.x, p.y), p.z);\n    \n    float body = length(p.xy)-(.86+S(2., 15., p.z)*.6-p.z*.01);\n    body = max(.8-p.z, body);   \n    \n    vec4 scales = vec4(0);\n    if(body<.1) {\n        vec2 uv = vec2(-st.y*.25, st.x/6.2832+.5);\n        float a = sin(st.x+1.57)*.5+.5;\n        float fade = a;\n        a = S(.1, .4, a);\n\n        uv.y = 1.-abs(uv.y*2.-1.);\n        uv.y *= (uv.y-.2)*.4;\n        scales = ScaleTex(uv*1.3, .3*a, .3*a, .01, .8);\n        body += scales.x*.02*(fade+.2);\n    }\n    \n    body += S(-.4, -.9, p.y)*.2;\t// flatten bottom\n    return vec3(body, scales.zw);\n}\n\nfloat GetHeadScales(vec3 p, vec3 eye, vec3 mouth, float md) {    \n    float t = iTime;\n  \n    float jitter = .5;\n    jitter *= S(.1, .3, abs(md));\n    jitter *= S(1.2, .5, p.z);\n    \n    p.z += .5;\n    p.z *= .5;\n    \n    p.yz *= Rot(.6);\n    float y = atan(p.y, p.x);\n    vec2 gv = vec2(p.z*5., y*3.);\n\n    vec2 id = floor(gv);\n    \n    gv = fract(gv)-.5;\n    \n    float d=MAX_DIST;\n    for(float y=-1.; y<=1.; y++) {\n        for(float x=-1.; x<=1.; x++) {\n            vec2 offs = vec2(x, y);\n\n            vec2 n = Hash22(id+offs);\n            vec2 p = offs+sin(n*6.2831)*jitter;\n            p -= gv;\n            \n            float cd = dot(p,p);\n            if(cd<d) d = cd;\n        }\n    }\n    \n    d += sin(d*20.)*.02;    \n    d *= S(.0, .5, length(p.xy)-.1);\n    return d*.06;\n}\n\nfloat sdHead(vec3 p) {    \n    p.x = abs(p.x*.9);\n    float d = sdSph(p, vec3(0,-.05,.154), vec3(1,1,1.986),1.14); \n    d = smax(d, length(p-vec3(0,7.89,.38))-8.7, .2);\n    d = smax(d, length(p-vec3(0,-7.71,1.37))-8.7, .15); // top\n    \n    d = smax(d, 8.85-length(p-vec3(9.16,-1.0,-3.51)), .2);\t// cheeks\n    \n    vec3 ep = p-vec3(.54,.265,-.82);\n    float eye = length(ep)-.35;\n    float brows = S(.1, .8, p.y-(p.z+.9)*.5);\n    brows *= brows*brows;\n    brows *= S(.3, -.2, eye);\n   \td -= brows*.5;\n    d += S(.1, -.2, eye)*.1;\n    \n    vec2 mp = p.yz-vec2(3.76+S(-.71, -.14, p.z)*(p.z+.5)*.2, -.71); \n    float mouth = length(mp)-4.24;\n    d += S(.03,.0,abs(mouth))*S(.59,.0, p.z)*.03;\n    \n   \td += GetHeadScales(p, ep, mp.xyy, mouth);\n    \n    d = min(d, eye);\n    \n    float nostril = length(p.zy-vec2(-1.9-p.x*p.x, .15))-.05;\n    d = smax(d, -nostril,.05);\n    return d;\n}\n\nfloat sdTongue(vec3 p) {\n\tfloat t = iTime*3.;\n   \n    float inOut = S(.7, .8, sin(t*.5));\n    \n    if(p.z>-2.||inOut==0.) return MAX_DIST;\t\t// early out\n    \n    float zigzag = (abs(fract(t*2.)-.5)-.25)*4.; // flicker\n    float tl = 2.5;\t// length\n    \n    p+=vec3(0,0.27,2);\n    p.z *= -1.;\n    float z = p.z;\n    p.yz *= Rot(z*.4*zigzag);\n    p.z -= inOut*tl;\n    \n    float width = S(0., -1., p.z);\n    float fork = 1.-width;\n    \n    float r = mix(.05, .02, fork);\n\t\n    p.x = sabs(p.x, .05*width*width);\n    p.x -= r+.01;\n    p.x -= fork*.2*inOut;\n\n    return length(p-vec3(0,0,clamp(p.z, -tl, 0.)))-r;\n}\n\nfloat GetDist(vec3 P) {\n    \n    vec3 p = P;\n    p.xz *= Rot(sin(iTime*.3)*.1*S(1., 0., p.z));\n    float d = sdTongue(p)*.7;\n    d = min(d, sdHead(p));\n    d = smin(d, sdBody(P).x, .13);\n    \n    return d;\n}\n\nvec3 GetMat(vec3 p) {    \n    float d = MAX_DIST;\n    \n    float tongue = sdTongue(p)*.7;\n    float head = sdHead(p);\n    vec3 body = sdBody(p);\n    \n    float closest = min(tongue, min(head, body.x));\n    if(closest == tongue) {\n        return vec3(MAT_TONGUE, 0, 0);\n    } else if(closest==head) {\n        p.x = abs(p.x*.9);\n        vec3 ep = p-vec3(.54,.265,-.82);\n        float eye = length(ep)-.35;\n        if(eye<SURF_DIST)\n        \treturn vec3(MAT_EYE, ep.yz);\n        else\n            return vec3(MAT_BODY, 0, 0);\n            \n    }else if(closest==body.x) {\n        return vec3(MAT_BODY, body.yz);\n    }\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n// From Nimitz\nvec4 GetNormalAndCurvature(in vec3 p, float eps) {\n    vec2 e = vec2(-1., 1.)*eps;   \n    float t1 = GetDist(p + e.yxx), t2 = GetDist(p + e.xxy);\n    float t3 = GetDist(p + e.xyx), t4 = GetDist(p + e.yyy);\n\n    float c = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*GetDist(p));\n    vec3 n = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    \n    return vec4(n, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvec4 Material(vec3 ro, vec3 rd, float d) {\n    vec3 p = ro + rd * d;\n    vec4 n = GetNormalAndCurvature(p, mix(.01, .03, S(8., 20., d)));\n\n    p.xz *= Rot(sin(iTime*.3)*.1*S(1., 0., p.z));\n    vec3 mat = GetMat(p);\n    \n    vec3 col = vec3(n.y*.5+.5);  \t// diffuse\n\tcol *= 1.-max(0., .3-n.w);\t\t// curvature shadow\n    \n    vec3 h = normalize(-rd + vec3(1,1,1));\n    float spe = pow(clamp(dot(h, n.xyz), 0.0, 1.0), 32.0);\n\t\n    vec3 ref = reflect(rd, n.xyz);\n    vec3 r = texture(iChannel0, ref).rgb;\n    \n    if(mat.x==MAT_EYE) {\n        vec2 sph = RaySphere(\n            vec3(abs(p.x*.9),p.yz), \n            vec3(-abs(rd.x), rd.yz), \n            vec4(.3,.265,-.82, .52)\n        );\n\n        vec3 sp = p+rd*sph.x;\n        mat.yz = sp.yz-vec2(.265,-.82)+.05;\n\n        float t = iTime*.2;\n        vec2 p1 = sin(floor(t)*vec2(20., 31.));\n        vec2 p2 = sin(floor(t+1.)*vec2(20., 31.));\n        p1 = mix(p1, p2, S(.45, .5, fract(t)));\n        mat.yz += p1*vec2(.01, .03)*1.;\n        float a = atan(mat.y, mat.z);\n\n        float d = abs(mat.z)+mat.y*mat.y;\n        col *= vec3(1,1,.1);\n        col += S(.1, .0, length(mat.yz*vec2(1,2))-.1)*.1;\n        \n        float z = S(.7, 1., rd.z*rd.z)*.05;\n        col *= S(.02-z, .03+z, d);\n        \n        vec3 gp = vec3(a, mat.yz)*20.;\n        float gyroid = (abs(dot(sin(gp), cos(gp.zxy))));\n        col *= 1.+gyroid*.1;\n        \n        col += r*r*r*.3;\n        col += pow(spe, 6.);\n    } else if(mat.x==MAT_BODY) {\n        float x = mat.y;\n        float y = mat.z;\n        float wave = S(2., 0., abs(y-2.+sin(x*.5)*1.));\n        wave *= S(2., 3., p.z);\n        \n        float t = iTime*.3;\n        float neckFade = S(3., 10., p.z);\n        p.y += sin(p.z*.1-t)*neckFade;\n        \n        vec3 baseCol = mix(vec3(1., 1., .2), vec3(.3, .8, .1), S(-.55, -.1, p.y));\n        col *= mix(baseCol, vec3(.2,.4,.2)*.5, wave);\n        col += spe*pow(1.-abs(n.w), 5.)*.3;\n        \n        r = texture(iChannel1, ref).rgb;\n        col += r*r*.05;\n    } else if(mat.x==MAT_TONGUE) {\n    \tcol *= vec3(.4, .1, .2);\n        col += pow(min(1., spe*5.), 5.);\n    }\n    \n    return vec4(col, 1);\n}\n\nvec3 Render(vec2 uv, vec2 m, float t) {\n    vec3 ro = vec3(0, 0, -3)*(8.+sin(t*.2)*2.*CAM_MOVE);\n    ro.yz *= Rot(-m.y*3.14+sin(t*.03)*CAM_MOVE*.2);\n    ro.xz *= Rot(-m.x*6.2831*2.+sin(t*.05)*CAM_MOVE);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0,sin(t*.11)), 6.);\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 col = vec3(0);\n    \n    vec2 env = RaySphere(ro, rd, vec4(0,0,0,20));\n    \n    if(d<MAX_DIST) {\n        vec4 snake = Material(ro, rd, d);\n    \tsnake.rgb *= S(60., 10., d);\n        col = mix(col, snake.rgb, snake.a);\n    } else {\n    \tcol = (rd.y*.5+.5)*vec3(.4, 1.,.2);\n        col *= texture(iChannel0, rd).rgb;\n        col *= 1.-S(.8, 1., rd.z);\n        \n        if(env.y>0.)\t// vines behind\n            col *= S(0., 1.1, sdGyroid(ro + env.y*rd, .4, .1, .0))*.5+.5;\n    }\n    \n    if(env.x>0.)\t// vines in front\n        col *= S(0., .25, sdGyroid(ro + env.x*rd, .25, .1, .0));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;    \n    if(m.x<-.49 && m.y<-.49) m*=0.;\n    \n    vec3 col = Render(uv, m, iTime);\n    \n    col *= 1.5;\t\t\t\t\t\t// exposure adjustment\n    col = pow(col, vec3(.4545));\t// gamma correction\n    col *= 1.-dot(uv,uv)*.3;\t\t// vignette\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21528, "src": "https://soundcloud.com/extasis_demencial/jungle-sounds", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}, {"id": 21529, "src": "https://soundcloud.com/liam-seagrave/pandemic-prologue-slow-strings-suspense-music-original-horror-piano-composition", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVSDK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[622, 643, 664, 664, 797], [799, 799, 821, 821, 916], [918, 918, 947, 947, 1026], [1028, 1028, 1070, 1070, 1325], [1327, 1338, 1379, 1379, 1470], [1472, 1472, 1511, 1511, 1537], [1539, 1539, 1558, 1558, 1634], [1636, 1636, 1702, 1702, 1781], [1783, 1783, 1836, 1836, 1948], [1951, 1951, 2025, 2025, 2900], [2902, 2902, 2978, 2978, 3160], [3163, 3163, 3184, 3184, 3923], [3925, 3925, 3986, 3986, 4708], [4710, 4710, 4732, 4732, 5589], [5591, 5591, 5615, 5615, 6200], [6202, 6202, 6225, 6225, 6409], [6411, 6411, 6432, 6432, 7025], [7028, 7028, 7062, 7062, 7273], [7275, 7290, 7340, 7340, 7653], [7655, 7655, 7705, 7705, 7896], [7899, 7899, 7941, 7941, 10021], [10023, 10023, 10062, 10062, 10942], [10945, 10945, 11002, 11002, 11377]], "test": "untested"}
{"id": "wsXcDH", "name": "2D COVID-19", "author": "charstiles", "description": ">: )", "tags": ["2d", "simple", "sdf", "coronavirus", "covid19"], "likes": 2, "viewed": 378, "published": 3, "date": "1584675226", "time_retrieved": "2024-07-30T21:17:49.440892", "image_code": "#define spokes 4.0\n\n\n//helper fns I got these from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// exponential smooth min (k = 32); from IQ\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\nvec2 pow2D(vec2 p,float e){\n\treturn vec2(pow(abs(p.x),e), pow(abs(p.y),e));\n\n}\n\n\n//these are the lil red nubs \n\nfloat crownBoops(vec2 pos){\n\n\tfloat sphereDiff = 0.9- (length(pos) - 0.1);\n\n\tfloat sphere = (length(pos) - 0.83);\n    \n \tfloat angle=atan(pos.y, pos.x); \n    \n    float boop = sphere- (pow( abs(sin(angle*spokes)),3.)* 0.331);\n    \n    boop += noise(angle*60.)*0.09; // make the end a lil noisy\n    \n    return  max(boop, sphereDiff); // take the difference so we only get the top part of the sin wave\n}\n\nfloat virus(vec2 pos){\n\n\tfloat sphere = (length(pos) - 0.63 );// the base\n    \n \tfloat angle=atan(pos.y, pos.x); // angle around the circle\n    float wave = (pow( abs(sin(angle*spokes)),6.)* 0.31); // goes up and down around the circle\n    return sphere- wave + (noise(sin(angle*2.)) * 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (fragCoord/iResolution.xy - 0.5)   *2.0; // (0,0) is in the center of the screen\n    \n    uv *=1.5; // idk make it a lil smaller\n    \n\tuv.x *= iResolution.x/iResolution.y; // sadly the screen is not square, we must fix uv ratio\n    \n    float shape1 = crownBoops(uv);\n    float shape2 = virus(uv);\n  \n    vec3 col = vec3(smin(shape1,shape2,8.0 )); // smooth min the top nubs and the rest of the virus\n    \n    col = ceil(col); // everthing is an SDF which is a gradient but we want hard lines so we ceiling the coloe \n    \n\tcol = vec3(1)-col; // make it white on black \n    \n    col.yz -= length(pow2D(uv,4.0) * vec2(0.5)); // add the red\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 117, 137, 137, 204], [206, 206, 226, 226, 435], [437, 437, 457, 457, 495], [497, 497, 518, 518, 608], [610, 654, 695, 695, 769], [772, 772, 799, 799, 850], [884, 884, 911, 911, 1286], [1288, 1288, 1310, 1310, 1581], [1583, 1583, 1640, 1640, 2353]], "test": "untested"}
{"id": "WdlyWn", "name": "infinity mirror", "author": "xjorma", "description": "infinity mirror", "tags": ["reflection", "cube", "sphere", "ball", "mirror", "infinity", "elevator"], "likes": 15, "viewed": 669, "published": 3, "date": "1584660423", "time_retrieved": "2024-07-30T21:17:50.188893", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y,q.z)), 0.);\n}\n\nmat3 mo;\n\nfloat mapCube(vec3 p)\n{\n    p = mo * p * 2.;\n    float\tradius = 0.45;\n    vec3\tv = vec3(1,1,1);\n    vec3\tq = mod(p + v / 2., v) - v / 2.0;\n\tfloat\tds = sdSphere(q, radius);\n    float\tdb = sdBox(p, vec3(1. + radius));\n    return max(ds, db) / 2.;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(vec3 p)\n{\t\n    return min(mapCube(p), -sdRoundBox( p, vec3(1.6), 0.3 ));    \n}\n\n#define EPS  0.0001\n\nvec3 calcNormal(vec3 pos)\n{\n\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, out float t, out float d, in float maxd)\n{\n    t = 0.;\n    d = 0.;\n    vec3 cp = ro;\n    for(int i=0;i<90;++i)\n    {\n        d = map(cp);\n        t += d;\n        cp = ro+rd*t;\n        if (d < .001 || d > maxd)\n            break;\n    }\n}\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    return texture(iChannel0,rd).rgb;\n}\n\nvec3 lastRecur(vec3 ro,vec3 rd)\n{\n    return getSkyColor(rd);\n}\n\n#define GEN_RENDER(NAME,DIST,RECUR) \t\t\t\t\t\t\t\t\t\t\\\nvec3 NAME(vec3 ro,vec3 rd)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    float\tt,d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    rayMarch(ro, rd, t, d, DIST);\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 p = ro + rd * t;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 n = calcNormal(p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    if (d < .001)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\t\t\t\t\t\\\n        vec3 d = mix(vec3(1), vec3(0.82, 0.45, 0.20), fresnel);\t\t\t\t\\\n        vec3 ref = reflect(rd, n);\t\t\t\t\t\t\t\t\t\t\t\\\n        color = d * RECUR(p + ref * 0.2 , ref);\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        color = getSkyColor(rd);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    return color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\n\nGEN_RENDER(render4,  4., lastRecur)\nGEN_RENDER(render3,  4., render4)\nGEN_RENDER(render2,  4., render3)\nGEN_RENDER(render1,  4., render2)\nGEN_RENDER(render ,  4., render1)\n\n    \nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    mat3 ma = setCamera(vec3(0), vec3(0,1,-1));\n    \n\tro.y+=iTime;\n\t\n    fragColor = vec4(render(ma*ro/3.,ma*rd) ,1);\n}\n\n\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.1;\n    float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n    vec3 ro = 1.8 * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n    vec3 ta = vec3(0);\n    mat3 ca = setCamera( ro, ta );\n    \n    // Objet\n    mo = fromEuler(vec3(0.25, 0.2, 0.27) * iTime);\n\n    \n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = render(ro, rd);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.8);\n\n\tfragColor = vec4(tot, 1.0 );\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyWn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[162, 162, 197, 197, 220], [222, 222, 251, 251, 337], [349, 349, 372, 372, 595], [597, 597, 642, 642, 733], [735, 735, 754, 754, 823], [846, 846, 873, 873, 1037], [1039, 1039, 1113, 1113, 1307], [1309, 1309, 1364, 1364, 1460], [1463, 1463, 1490, 1490, 1530], [1532, 1532, 1565, 1565, 1595], [2558, 2558, 2600, 2600, 2764], [2766, 2766, 2810, 2810, 2909], [2911, 2911, 2951, 2951, 3021], [3023, 3023, 3101, 3101, 3221], [3225, 3225, 3251, 3251, 3603]], "test": "untested"}
{"id": "tdlyWr", "name": "Lagrangian Mechanics", "author": "mla", "description": "Lagrangian mechanics for a double pendulum, with numerical solution of the Euler-Lagrange equation.\n\n#define ORBIT in common to see elliptical orbit.\n\nShader based on [url]https://github.com/matthewarcus/lagrange[/url]", "tags": ["mechanics", "lagrangian"], "likes": 26, "viewed": 634, "published": 3, "date": "1584640460", "time_retrieved": "2024-07-30T21:17:51.019671", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Lagrangian Mechanics\n//\n// Matthew Arcus, 2020\n//\n// Double pendulum, simulated by direct numeric solution of Euler-Lagrange\n// equations.\n//\n// Uncomment #define of ORBIT in Common to see elliptical orbit.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 uv = 2.0*fragCoord.xy/iResolution.y;\n  vec3 col = vec3(1);\n  float colwidth = 0.025;\n\n  if (uv.x < 5.0*colwidth) {\n    vec4 ev = texelFetch(iChannel1,ivec2(0,2),0);\n    float etot = dot(ev,vec4(1));\n    bool incolumn = false;\n    if (uv.x < 1.0*colwidth) incolumn = uv.y < etot;\n    else if (uv.x < 2.0*colwidth) incolumn = uv.y < 0.5+ev.x/etot;\n    else if (uv.x < 3.0*colwidth) incolumn = uv.y < 0.5+ev.y/etot;\n    else if (uv.x < 4.0*colwidth) incolumn = uv.y < 0.5+ev.z/etot;\n    else incolumn = uv.y < 0.5+ev.w/etot;\n    if (incolumn) col = vec3(0);\n  } else {\n    vec4 dv = texelFetch(iChannel1,ivec2(fragCoord),0);\n    col = vec3(smoothstep(0.0,0.01,dv.x));\n    // Proper screen coordinates\n    uv -= iResolution.xy/iResolution.y;\n    uv *= scale;\n    // Get pv values\n    vec4 pv = texelFetch(iChannel1,ivec2(0,0),0);\n    // and coordinates\n    vec4 coords = getcoords(pv.xy,pv.zw);\n    vec2 p0 = vec2(0), p1 = coords.zw, p2 = coords.xy;\n    float d = min(segment(uv,p0,p1),segment(uv,p1,p2));\n    col = mix(vec3(0),col,smoothstep(0.0,0.01,d));\n    d = min(distance(uv,p0),min(distance(uv,p1),distance(uv,p2)));\n    col = mix(vec3(1,0,0),col,smoothstep(0.02,0.03,d));\n  }\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x), j = int(uv.y); // Texel coordinates\n  t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state     \n  if (i == 0 && j == 0) {\n    if (iFrame == 0) {\n      t = initpv;\n    } else {\n      // Get last p,v and last time..\n      vec4 pv = texelFetch(iChannel1,ivec2(0,0),0);\n      vec4 tv = texelFetch(iChannel1,ivec2(0,1),0);\n      // .. and update\n      t = lagrange(pv.xy,pv.zw,iTime-tv.x);\n    }\n  } else if (i == 0 && j == 1) {\n    // Store last time and screen resolution\n    t = vec4(iTime,0,iResolution.xy);\n  } else if (i == 0 && j == 2) {\n    // Output energy values.\n    vec4 pv = texelFetch(iChannel1,ivec2(0,0),0);\n    t = E(pv.xy,pv.zw);\n  } else if (iFrame == 0 || texelFetch(iChannel1,ivec2(0,1),0).zw != iResolution.xy) {\n    // If first frame or screensize has changed, reset min distance.\n    t = vec4(1e8);\n  } else {\n    // Otherwise, update minimum distance to current coords\n    uv = (2.0*uv-iResolution.xy)/iResolution.y;\n    uv *= scale;\n    vec4 pv = texelFetch(iChannel1,ivec2(0,0),0);\n    vec4 coords = getcoords(pv.xy,pv.zw);\n    t.x = min(t.x,distance(uv,coords.xy));\n    t.y = min(t.y,distance(uv,coords.zw));\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define ORBIT //Uncomment for an elliptical orbit.\n//#define QUALITY  //Uncomment for more accuracy, slower compilation\nconst float PI = 3.14159;\nconst float scale = 1.1;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;;\n}\n\nfloat point(vec2 p, vec2 q) {\n  return distance(p,q);\n}\n\nfloat segment(vec2 p, vec2 q, vec2 r) {\n  vec2 pa = p-q;\n  vec2 ba = r-q;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  float d = length(pa-h*ba);\n  return d;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// The Maths\n////////////////////////////////////////////////////////////////////////////////\n\n// The energy function for the Lagrangian\nvec4 E(vec2 p, vec2 v);\n\nfloat L(vec2 p, vec2 v) {\n  vec4 e = E(p,v);\n  float ke0 = e.x,ke1 = e.y,pe0 = e.z,pe1 = e.w;\n  return (ke0+ke1)-(pe0+pe1);\n}\n\n// Using Richardson & fixed step Runge-Kutta gives reasonable\n// accuracy, but slower compilation.\n// Variable step RK doesn't always help.\n#if defined QUALITY\n#define pdiffLp pdiffLp1\n#define pdiffLv pdiffLv1\n#define derivs derivs1\n#else\n#define pdiffLp pdiffLp0\n#define pdiffLv pdiffLv0\n#define derivs derivs0\n#endif\n#define step rk4\n//#define step rk4var\n//#define step single\n\n// Basic partial differentiation wrt p.\nfloat pdiffLp0(vec2 p, vec2 v, int i,float eps) {\n  float pi = p[i];\n  p[i] = pi-eps;\n  float x0 = L(p,v);\n  p[i] = pi+eps;\n  float x1 = L(p,v);\n  p[i] = pi;\n  return (x1-x0)/(2.0*eps);\n}\n\nfloat pdiffLv0(vec2 p, vec2 v, int i,float eps) {\n  float vi = v[i];\n  v[i] = vi-eps;\n  float x0 = L(p,v);\n  v[i] = vi+eps;\n  float x1 = L(p,v);\n  v[i] = vi;\n  return (x1-x0)/(2.0*eps);\n}\n\n// Richardson extrapolation\nfloat pdiffLv1(vec2 p, vec2 v,int i,float eps) {\n  float d1 = pdiffLv0(p,v,i,eps);\n  float d2 = pdiffLv0(p,v,i,2.0*eps);\n  return d1+(d1-d2)/3.0;\n}\n\nfloat pdiffLp1(vec2 p, vec2 v,int i,float eps) {\n  float d1 = pdiffLp0(p,v,i,eps);\n  float d2 = pdiffLp0(p,v,i,2.0*eps);\n  return d1+(d1-d2)/3.0;\n}\n\n// NB: this modifies parameters p and v\nvoid evaluate(inout vec2 p, inout vec2 v, float eps);\n\n// Time derivatives\nvoid derivs0(vec2 p, vec2 v, out vec2 dp, out vec2 dv, float eps) {\n  vec2 p1 = p, v1 = v;\n  vec2 p2 = p, v2 = v;\n  evaluate(p1,v1,eps);\n  evaluate(p2,v2,-eps);\n  dp[0] = (p1[0]-p2[0])/(2.0*eps);\n  dp[1] = (p1[1]-p2[1])/(2.0*eps);\n  dv[0] = (v1[0]-v2[0])/(2.0*eps);\n  dv[1] = (v1[1]-v2[1])/(2.0*eps);\n}\n\n// It's that Richardson again.\n// https://en.wikipedia.org/wiki/Lewis_Fry_Richardson\nvoid derivs1(vec2 p, vec2 v, out vec2 dp, out vec2 dv, float eps) {\n  vec2 p1,p2,v1,v2;\n  derivs0(p,v,p1,v1,eps);\n  derivs0(p,v,p2,v2,2.0*eps);\n  dp[0] = p1[0] + (p1[0]-p2[0])/3.0;\n  dp[1] = p1[1] + (p1[1]-p2[1])/3.0;\n  dv[0] = v1[0] + (v1[0]-v2[0])/3.0;\n  dv[1] = v1[1] + (v1[1]-v2[1])/3.0;\n}\n\n// d(df/dxj)/dxi - components of Hessian (Jacobian for PDs).\nfloat hessian(int i,int j,vec2 p,vec2 v,float eps) {\n  //return pdiffHess(function(a) { return pdiff(f,a,j,eps);}, a,i,eps);\n  float vi = v[i];\n  v[i] = vi-eps;\n  float x0 = pdiffLv(p,v,j,eps);\n  v[i] = vi+eps;\n  float x1 = pdiffLv(p,v,j,eps);\n  v[i] = vi;\n  return (x1-x0)/(2.0*eps);\n}\n\n// Vector of partial derivs\nvec2 pdiffsLp(vec2 p,vec2 v,float eps) {\n  return vec2(pdiffLp(p,v,0,eps),pdiffLp(p,v,1,eps));\n}\n\nvec2 pdiffsLv(vec2 p,vec2 v,float eps) {\n  return vec2(pdiffLv(p,v,0,eps),pdiffLv(p,v,1,eps));\n}\n\nvoid single(inout vec2 p, inout vec2 v, float dt, float eps) {\n  vec2 dp,dv;\n  derivs(p,v,dp,dv,eps);\n  p[0] += dt*dp[0];\n  p[1] += dt*dp[1];\n  v[0] += dt*dv[0];\n  v[1] += dt*dv[1];\n}\n\nvoid rk4(inout vec2 p, inout vec2 v, float dt, float eps) {\n  vec2 p1, v1,p2,v2,p3,v3,p4,v4;\n  derivs(p,v,p1,v1,eps);\n  derivs(p+0.5*dt*p1,\n         v+0.5*dt*v1,\n         p2,v2,eps);\n  derivs(p+0.5*dt*p2,\n         v+0.5*dt*v2,\n         p3,v3,eps);\n  derivs(p+dt*p3,\n         v+dt*v3,\n         p4,v4,eps);\n  p[0] += dt*(p1[0] + 2.0*p2[0] + 2.0*p3[0] + p4[0])/6.0;\n  p[1] += dt*(p1[1] + 2.0*p2[1] + 2.0*p3[1] + p4[1])/6.0;\n  v[0] += dt*(v1[0] + 2.0*v2[0] + 2.0*v3[0] + v4[0])/6.0;\n  v[1] += dt*(v1[1] + 2.0*v2[1] + 2.0*v3[1] + v4[1])/6.0;\n}\n\n// Variable step Runge-Kutta.\nint steps = 1;\nvoid rk4var(inout vec2 p,inout vec2 v,float dt, float eps) {\n  while (true) {\n    vec2 p1 = p, v1 = v, p2 = p, v2 = v;\n    rk4(p1,v1,dt/float(steps),eps);\n    rk4(p2,v2,dt/float(2*steps),eps);\n    vec2 p3 = p2,v3 = v2;\n    rk4(p3,v3,dt/float(2*steps),eps);\n    //Sum the squares of the errors\n    vec2 errorvec = v3-v1;\n    float error = dot(errorvec,errorvec);\n    if (error > 1e-5 && steps < 100) {\n      steps *= 2;\n    } else if (error < 1e-7 && steps > 1) {\n      steps /= 2;\n      //p = p2; v = v2; // FIXME: this is wrong!\n      rk4(p,v,dt/float(steps),eps); // Recalculate for smaller step\n      break;\n    } else {\n      p = p3; v = v3;\n      break;\n    }\n  }\n  for (int i = 1; i < steps; i++) {\n    rk4(p,v,dt/float(steps),eps);\n  }\n}\n\n// NB: this modifies parameters p and v\nvoid evaluate(inout vec2 p, inout vec2 v, float eps) {\n  //var pp = pdiffs(function(p) { return L(p,v,t) }, p,eps);\n  //var pv = pdiffs(function(v) { return L(p,v,t) }, v,eps);\n  //p0 = p; v0 = v;\n  vec2 pp = pdiffsLp(p,v,eps);\n  vec2 pv = pdiffsLv(p,v,eps);\n  p[0] += v[0]*eps;\n  p[1] += v[1]*eps;\n  // Compute new values of pv (apply Euler-Lagrange)\n  pv[0] += pp[0]*eps;\n  pv[1] += pp[1]*eps;\n  // pv is PD of L at t+eps\n  // Now find new v' st pdiff(Lp,v') = pv\n  // Initial guess is v, use Hessian to refine guess\n  // F(v') = F(v+dv) = F(v) + (JF)(dv), here F is the partial\n  // derivatives of L at v.\n  // Then v' = v + dv where dv = inv(JF)(F(v')-F(v))\n  // Doing this step 2 or 3 times seems to be enough\n  // I'm surprised it works at all really.\n  for (int k = 0; k < 3; k++) {\n    vec2 pv2 = pdiffsLv(p,v,eps);\n    vec2 t = pv-pv2;\n    float a = hessian(0,0,p,v,eps);\n    float b = hessian(0,1,p,v,eps);\n    float c = b; // Symmetry\n    float d = hessian(1,1,p,v,eps);\n    float det = a*d - b*c; // If det is too small, we'll just diverge here\n    v[0] += (d*t[0] - b*t[1])/det;\n    v[1] += (-c*t[0] + a*t[1])/det;\n  }\n}\n\n#if !defined ORBIT\n// Lagrangian for Double Pendulum\nfloat G = 1.0; // Gravity\nfloat M0 = 1.0, M1 = 1.0; // Bob weight\nfloat R0 = 0.5, R1 = 0.618; // Pendulum section length.\nvec4 initpv = vec4(0.5*PI,0.5*PI,0.01,0);\n\nvec4 E(vec2 p, vec2 v) {\n  float y0,y1,ke0,ke1,pe0,pe1;\n  vec2 v0,v1;\n  y0 = R0*sin(p[0]);\n  y1 = y0 + R1*sin(p[1]);\n  v0 = vec2(-R0*sin(p[0])*v[0], R0*cos(p[0])*v[0]);\n  v1 = vec2(-R1*sin(p[1])*v[1], R1*cos(p[1])*v[1]);\n  ke0 = 0.5*M0*(dot(v0,v0));\n  ke1 = 0.5*M1*(dot(v0+v1,v0+v1));\n  pe0 = G*M0*y0;\n  pe1 = G*M1*y1;\n  return vec4(ke0,ke1,pe0,pe1);\n}\n\n// Convert into euclidean coordinates.\nvec4 getcoords(vec2 p,vec2 v) {\n  float x0,y0,x1,y1;\n  x0 = R0*cos(p[0]);\n  y0 = R0*sin(p[0]);\n  x1 = x0 + R1*cos(p[1]);\n  y1 = y0 + R1*sin(p[1]);\n  return vec4(x1,y1,x0,y0);\n}\n#else\n// OrbitPolar\nfloat G = 2.0; // Gravity\nvec4 initpv = vec4(1,0,0,1);\nvec4 E(vec2 p, vec2 v) {\n  float m = 1.0;\n  float r = p[0];\n  float rv = v[0];\n  float thetav = v[1];\n  float ke = m*0.5*(rv*rv + r*thetav*r*thetav);\n  float pe = 3.0-m*G/r;\n  return vec4(ke,0,pe,0);\n}\nvec4 getcoords(vec2 p, vec2 v) {\n  return vec4(p[0]*sin(p[1]), p[0]*cos(p[1]),0,0);\n}\n#endif\n\nfloat maxstep = 5e-3;\nvec4 lagrange0(vec2 p, vec2 v,float dt) {\n  float eps = 5e-3;\n  while(dt > 0.0) {\n    //var f = function(p,v,t,eps) { Lagrange.evaluate(system.L,p,v,t,eps); }\n    float delta = min(maxstep,dt);\n    step(p,v,delta,eps);\n    dt -= delta;\n  }\n  return vec4(p,v);\n}\nvec4 lagrange(vec2 p, vec2 v,float dt) {\n  step(p,v,dt,5e-3);\n  return vec4(p,v);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[379, 379, 431, 431, 1683]], "test": "untested"}
{"id": "3dfcDH", "name": "Complex Grid Mapping", "author": "encryptedmaze", "description": "Graphs the inverse of complex functions.", "tags": ["grid", "graph", "complexnumbers"], "likes": 3, "viewed": 457, "published": 3, "date": "1584637564", "time_retrieved": "2024-07-30T21:17:51.853442", "image_code": "const float PI = 3.1415926535897932384626433832795;\nvec2 cmul (vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);\n}\nvec2 cexp (vec2 z) {\n\treturn exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\nvec2 clog (vec2 z) {\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\nvec2 cpow (vec2 z, vec2 a) {\n\treturn cexp(cmul(a, clog(z)));\n}\nfloat animate() {\n\treturn -1.0f * cos((iTime) / 5.0f) * 0.996f + 1.004f;\n}\n// Any complex-valued function. The inverse of this function is graphed.\nvec2 transformation (vec2 uv) {\n\tvec2 ret = cpow(uv, vec2(animate(), 0.0f));\n    // vec2 pos = (vec2(iMouse.xy / iResolution.xy) - vec2(0.5f)) * 2.5f;\n    // vec2 ret = cpow(uv, cexp(pos));\n    // vec2 ret = vec2(uv.x + sin(uv.y + iTime * 0.05f) * 0.5f, uv.y + sin(uv.x + iTime * 0.1f) * 0.5f);\n\treturn ret;\n}\n// Compute gradient vector (this is used to keep line width consistent)\nvec2 gradient (vec2 uv, vec2 delta) {\n\treturn (transformation(uv + delta) - transformation(uv)) / delta;\n}\n// Creates smooth line edges\nvec2 smoothstep2d (float lineWidth, vec2 pos) {\n\tvec2 ret;\n\tret.x = smoothstep(-lineWidth, 0.0f, pos.x) - smoothstep(0.0f, lineWidth, pos.x);\n\tret.y = smoothstep(-lineWidth, 0.0f, pos.y) - smoothstep(0.0f, lineWidth, pos.y);\n\treturn ret;\n}\n// mod of each element in a vec2\nvec2 mod2d (vec2 a, vec2 b) {\n\treturn vec2(mod(a.x, b.x), mod(a.y, b.y));\n}\n// Draws the grid using an input \"UV\" vector\nvec3 drawGrid(vec2 uv, float lineWidth) {\n\tfloat modulator = 0.25f;\n\t\n\t// Compute \"Distortion\" to prevent variable line width\n\tlineWidth *= length(gradient(uv, vec2(0.0005f)));\n\t\n    // \"Transformed Vector\"\n    // take the input \"uv\" vector an apply a function to it\n    vec2 tv = transformation(uv) + vec2(modulator / 2.0f);\n    \n    // Some modular arithmetic to draw multiple lines\n\tvec2 gv = vec2(floor(tv.x / modulator), floor(tv.y / modulator));\n   \tvec2 mv = mod(tv, vec2(modulator));\n\tvec2 line = smoothstep2d(lineWidth, mv - vec2(modulator / 2.0f));\n\t\n\t// 3blue1brown style line colors\n\tvec3 col = vec3(0.0f, 0.15f, 0.2f) * length(line);\n    if (mod(gv.x, 2.0f) == 0.0f) col = max(col, vec3(0.0f, 0.6f, 0.8f) * vec3(line.x));\n\tif (mod(gv.y, 2.0f) == 0.0f) col = max(col, vec3(0.0f, 0.6f, 0.8f) * vec3(line.y));\n\tif (gv.x == 0.0f) col = max(col, vec3(line.x));\n\tif (gv.y == 0.0f) col = max(col, vec3(line.y));\n\t\n\treturn col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat lineWidth = 0.015f;\n\tint sampleCount = 3;\n\tfloat sampleSize = 0.001f;\n    // Get \"input\" uv vector\n\tvec2 uv = (fragCoord - 0.5f * iResolution.xy) / (iResolution.y) * vec2(5.0f, -5.0f);\n\tvec3 col = drawGrid(uv, lineWidth);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 80, 80, 142], [143, 143, 163, 163, 210], [211, 211, 231, 231, 279], [280, 280, 308, 308, 342], [343, 343, 360, 360, 417], [418, 491, 522, 522, 800], [801, 873, 910, 910, 979], [980, 1009, 1056, 1056, 1248], [1249, 1282, 1311, 1311, 1357], [1358, 1403, 1444, 1444, 2337], [2338, 2338, 2393, 2393, 2656]], "test": "untested"}
{"id": "WsXcWH", "name": "Voronoi edge tracking II", "author": "michael0884", "description": "Tracking 4 closest particles and the 2 side particles which make a voronoi edge. Allows for advanced voronoi stuff: interpolation and physics. Also as it turns out edge tracking implicitly also holds the Delaunay triangulation.", "tags": ["particles"], "likes": 13, "viewed": 868, "published": 3, "date": "1584628968", "time_retrieved": "2024-07-30T21:17:52.996386", "image_code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-17 19:00:53\n\n\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 grad(ivec2 p)\n{\n    ivec4 sp = get(p);\n    ivec4 spx = get(p+ivec2(1,0));\n    ivec4 spy = get(p+ivec2(0,1));\n    return tanh(100.*(abs(vec4(spx - sp)) + abs(vec4(spy - sp))));\n}\n\nivec4 getve(ivec2 p)\n{\n    return floatBitsToInt(texel(ch2, p));\n}\n\nfloat edge_distance(vec2 spos, vec2 pos)\n{\n    ivec2 p = ivec2(spos);\n   \n    ivec4 ve = getve(p);//edge side particles\n    \n    //if invalid\n    if(any(equal(ve.xy, ve.zw)) || any(equal(ivec4(-1), ve))) return 1e10;\n   \n    vec4 p0 = getParticle(ve.z);\n    vec4 p1 = getParticle(ve.w);\n   \n    vec4 pe0 = getParticle(ve.x);\n    vec4 pe1 = getParticle(ve.y);\n    \n    vec2 edge0 = circumcenter(p0.xy, p1.xy, pe0.xy);\n    vec2 edge1 = circumcenter(p0.xy, p1.xy, pe1.xy);\n   \n    return sdSegment(pos, edge0, edge1);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec4 getEdge(ivec2 p, out ivec4 nb, out mat4 edgep)\n{\n    nb = getve(p);//edge side particles\n   \n    vec4 p0 = getParticle(nb.z);\n    vec4 p1 = getParticle(nb.w);\n    edgep[0] = p0;\n    edgep[1] = p1;\n   \n    vec4 pe0 = getParticle(nb.x);\n    vec4 pe1 = getParticle(nb.y);\n    edgep[2] = pe0;\n    edgep[3] = pe1;\n    \n    vec2 edge0 = circumcenter(p0.xy, p1.xy, pe0.xy);\n    vec2 edge1 = circumcenter(p0.xy, p1.xy, pe1.xy);\n\treturn vec4(edge0, edge1);\n}\n\n//I dont like this code hmm\nvec2 find_next_point(ivec2 nb, vec2 c0, vec2 c1, vec2 cc)\n{\n    vec2 p; \n    ivec4 cp;\n    vec2 dx = normalize(mix(c0,c1,0.5) - cc);\n    vec2 dy = normalize(c0 - cc);\n    for(float y = 0.; y < 2.; y++)\n    {\n        for(float x = 1.; x < 4.; x++)\n        {\n            p = cc + dx*x + dy*y;\n            cp = getve(ivec2(p+1.));\n            if(all(equal(cp.zw,nb.xy)) ) break;\n        }\n        if(all(equal(cp.zw,nb.xy)) ) break;\n    }\n    return p;\n}\n\nint exclude(ivec2 ij, int i)\n{\n    return (i == ij.x)?ij.y:ij.x;\n}\n\nfloat sample_border(vec2 spos, vec2 pos)\n{\n    ivec2 p = ivec2(spos);\n    \n    ivec4 cp = getve(p).zwzw;//closest particles \n    vec4 p0 = getParticle(cp.x);\n\n    \n    ivec4 nb; mat4 edgep;\n    int prev = -1; int next = -1;\n    float de = 1e10;\n    for(int i = 0; i < 10; i++) //loop around\n    {\n    \tvec4 edge = getEdge(p, nb, edgep);\n        de = min(de,sdSegment(pos, edge.xy, edge.zw));\n        \n        //go to next edge\n        next = nb.y;\n        prev = exclude(nb.zw, cp.x);\n        //p = ivec2(round( edge.zw + 2.*normalize(0.5*(p0.xy + getParticle(next).xy) - edge.zw) ));\n        p = ivec2(find_next_point(ivec2(cp.x, prev), p0.xy, edgep[3].xy, edge.zw));\n        de = min(de, length(edgep[3].xy - pos));\n                \n        if(next == cp.y || next == cp.x) break;\n    }\n    return de;\n}\n\n/*float sample_neighbors(vec2 spos, vec2 pos)\n{\n    ivec2 p = ivec2(spos);\n    \n    ivec4 cp = getve(p);//closest particles \n\n    \n    ivec4 nb; mat4 edgep;\n    int prev = -1; int next = -1;\n    float de = 1e10;\n    for(int i = 0; i < 10; i++) //loop around\n    {\n    \tvec4 edge = getEdge(p, nb, edgep);\n        de = min(de,sdSegment(pos, edge.xy, edge.zw));\n        \n        //go to next edge\n        next = nb.y;\n        prev = exclude(nb.zw, cp.x);\n        //p = ivec2(round( edge.zw + 2.*normalize(0.5*(p0.xy + getParticle(next).xy) - edge.zw) ));\n        p = ivec2(find_next_point(ivec2(cp.x, prev), p0.xy, edgep[3].xy, edge.zw));\n        de = min(de, length(edgep[3].xy - pos));\n                \n        if(next == cp.y || next == cp.x) break;\n    }\n    return de;\n}*/\n\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{   \n    float i0 = gauss(sample_border(iMouse.xy, pos), prad);\n    float i = gauss(edge_distance(pos, pos), prad/5.);\n    ivec4 cp = getve(ivec2(pos));\n    col.xyz = 1.5*(sin(2.*vec3(3,2,1)*i0 + i*vec3(1,1,1.5))) + 0.25*(0.5 + 0.5*sin(vec3(1,2,3)*float(cp.x))); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return -1./(1.+0.05*d);\n}\n\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    return normalize(p1-p0)*F(distance(p1,p0));\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        \n        //neighbors\n   \t\tivec4 cp = get(ivec2(U.xy));\n   \t    vec4 p1 = getParticle(cp.y);\n   \t    vec4 p2 = getParticle(cp.z);\n   \t    vec4 p3 = getParticle(cp.w);\n        \n        vec2 F = Fv(U.xy, p1.xy) +\n            \t Fv(U.xy, p2.xy) +\n            \t Fv(U.xy, p3.xy);\n        \n        \n        ivec4 mnb = get(ivec2(iMouse.xy));\n        \n\t\tif(any(equal(ivec2(id),mnb.xy)) && iMouse.z>0.)\n        {\n            F += 0.0*(iMouse.xy - iMouse.zw); \n        }\n        \n        U.xy += F*dt;\n        \n        if(size.x - U.x < 2.) U.x = size.x - 2.;\n        if(U.x < 2.) U.x = 2.;\n        if(size.y - U.y < 2.) U.y = size.y - 2.;\n        if(U.y < 2.) U.y = 2.;\n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(32,32)\n#define dt 0.5\n#define prad 2.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(fake, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}\n\nvec2 circumcenter(vec2 x, vec2 y, vec2 z)\n{\n    vec2 xy = y - x;\n    vec2 xz = z - x;\n    vec2 a = 0.5*(x+y);\n    vec2 b = 0.5*(x+z);\n    vec2 d = vec2(dot(xy,a), dot(xz,b));\n    float det = determinant(mat2(xy, xz));\n    return vec2(determinant(mat2(d.x, xy.y, d.y, xz.y)),determinant(mat2(xy.x, d.x, xz.x, d.y)))/det;\n}", "buffer_b_code": "//4th order voronoi diagram \n\nivec4 u; //ids\nvec4 d; //distances\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+0.5;\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        //insert\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        //insert\n        d = vec4(d.x, dtemp, d.yz);\n        u = ivec4(u.x, utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        //insert\n        d = vec4(d.xy, dtemp, d.z);\n        u = ivec4(u.xy, utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        //insert\n        d = vec4(d.xyz, dtemp);\n        u = ivec4(u.xyz, utemp);\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(t.x, p);\n    sort(t.y, p);\n    sort(t.z, p);\n    sort(t.w, p);\n}\n\nvoid randupd(ivec2 p)\n{\n    for(int i = 0; i < 4; i++)\n    {\n    \t//go through the entire array sudorandomly\n    \tint t = ((iFrame + p.x + p.y*int(iResolution.x))^(1<<(3*i)))%tot_n;\n    \tsort(t, p);    \n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 3);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //particle indecies \n    u = ivec4(1);\n    d = vec4(1e10); \n   \n    update(p);\n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//voronoi edge tracking\n\n//neighbors \nvec4 nbxy; //positions\nivec2 nbu; //ids\n\n//side particles\nvec2 d;\nivec2 u;\n\nbool isSame(ivec3 a, ivec3 b) //is the id triplet the same\n{\n    return any(equal(a.xxx,b)) && any(equal(a.yyy,b)) && any(equal(a.zzz,b));\n}\n\nbool isEdgeParticle(int id, vec2 pxy)\n{\n    //edge point guess\n    vec2 cc = circumcenter(nbxy.xy, nbxy.zw, pxy);\n    //check the voronoi diagram at the guess\n    if(cc.x < 0. || cc.y < 0. || cc.x > size.x || cc.y > size.y) return false;\n    ivec4 t = get(ivec2(cc));\n    //the first 3 closest particles at the edge point pretty much always are the particles that produce the edge\n    return isSame(t.xyz, ivec3(nbu.xy, id));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nivec4 getve(ivec2 p)\n{\n    return floatBitsToInt(texel(ch2, p));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p);\n    if(any(equal(ivec2(utemp),nbu)) || utemp == -1) return; //if particle is in the edge pair\n    vec4 partic = getParticle(utemp);\n    float dtemp = distance(partic.xy, pos);\n    if(isEdgeParticle(utemp, partic.xy))\n    {\n        //sorting\n        if(d.x >= dtemp)\n        {\n            if(d.x == dtemp) return;\n            //insert\n            d = vec2(dtemp, d.x);\n            u = ivec2(utemp, u.x);\n        }\n        else if(d.y >= dtemp)\n        {\n            if(d.y == dtemp) return;\n            //insert\n            d = vec2(d.x, dtemp);\n            u = ivec2(u.x, utemp);\n        }   \n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(t.x, p);\n    sort(t.y, p);\n    sort(t.z, p);\n    sort(t.w, p);\n    ivec4 tt = getve(p+dx);\n    sort(tt.x, p);\n    sort(tt.y, p);\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 1);\n    updrad(p, 2);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    ivec4 t = get(p);\n    \n    nbu = t.xy; //edge pair\n    nbxy = vec4(getParticle(t.x).xy,getParticle(t.y).xy);\n   \n    //particle indecies\n    ivec4 prev = getve(p); \n    u = ivec2(-1);\n    d = vec2(1e10); \n   \n    update(p);\n    \n    if(any(equal(u,ivec2(-1)))) //if not found the edge use the old data\n    {\n        u = prev.xy;\n        if(any(equal(nbu, prev.xx))) u.x = prev.z;\n        if(any(equal(nbu, prev.yy))) u.y = prev.w;\n    }\n    \n    U = vec4(intBitsToFloat(u), intBitsToFloat(nbu));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 141, 141, 176], [178, 178, 218, 218, 264], [266, 266, 297, 297, 331], [333, 333, 385, 385, 504], [506, 506, 526, 526, 688], [690, 690, 712, 712, 756], [758, 758, 800, 800, 1274], [1276, 1276, 1343, 1343, 1908], [1910, 1910, 1963, 1963, 2364], [2366, 2394, 2453, 2453, 2845], [2847, 2847, 2877, 2877, 2913], [2915, 2915, 2957, 2957, 3720], [4499, 4499, 4544, 4544, 4808]], "test": "untested"}
{"id": "3sXcD8", "name": "Straigth = rotating paths ", "author": "davidjonsson", "description": "Showing similarities of rotation and straight motion of particles. Red particles are moving on straight paths with the same speed outwardly from one point. Green particles are just rotating around a common center with similar angular velocity.", "tags": ["curved", "paths", "straigth"], "likes": 3, "viewed": 356, "published": 3, "date": "1584621486", "time_retrieved": "2024-07-30T21:17:53.756355", "image_code": "/*\n\tShowing that {rotation around one point} and {translation from one point} can appear similar.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float twoPi = 8. * atan(1.);\n\n    float radius = .005;\n    float speed = .2;\n    int numberOfParticles = 35;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float proportions = iResolution.x / iResolution.y;\n\n    vec3 col;\n \tvec2 placeTranslation, placeRotation;\n    float translation, rotation;\n    float dist;\n    for (int particle = 0; particle < numberOfParticles; particle++) {\n        float particleQuota = float(particle) / float(numberOfParticles);\n        placeTranslation.x = 1. * mod(speed * iTime + particleQuota, 1.) * cos(twoPi * (particleQuota));\n        placeTranslation.y = proportions * 1. * (mod(speed * iTime + particleQuota, 1.)) * sin(twoPi * (particleQuota));\n        placeTranslation *= .25;\n        placeTranslation += vec2(.25, .5);\n        dist = length(uv.xy - placeTranslation);\n        translation += smoothstep(radius, radius - .005, dist);   \t\n        placeRotation.x = cos(twoPi * (-speed * iTime + particleQuota));\n        placeRotation.y = proportions * sin(twoPi * (-speed * iTime + particleQuota));\n        placeRotation *= .25 * particleQuota;\n        placeRotation += vec2(.75, .5);\n        dist = length(uv.xy - placeRotation);\n        rotation += smoothstep(radius, radius - .005, dist);   \t\n    }\n    col.r = translation;\n    col.g = rotation;\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXcD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 160, 1485]], "test": "untested"}
{"id": "WsfcW8", "name": "Health Check", "author": "dr2", "description": "Fast android virus check (mouseable)", "tags": ["robot", "android", "virus"], "likes": 13, "viewed": 399, "published": 3, "date": "1584616425", "time_retrieved": "2024-07-30T21:17:54.775629", "image_code": "// \"Health Check\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float s);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 HexGrid (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, ltDir, vnCylOut;\nfloat dstFar, tCur, bCylRad, bCylHt, dCylOut, tPhs, wDisp, gGap;\nint idObj;\nconst int idBod = 1, idEye = 2, idCen = 3, idCenIn = 4, idCor = 5, idCorLt = 6, idDoor = 7;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat RobDf (vec3 p)\n{\n  vec3 q;\n  float dMin, rAngH, rAngL, rAngA, d, ah, s;\n  s = sin (2. * pi * mod (0.5 * tPhs, 1.));\n  rAngH = -0.7 * s;\n  rAngA = 1.1 * s;\n  rAngL = 0.5 * s;\n  dMin = dstFar;\n  p.y -= 0.25;\n  q = p; \n  q.y -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.y - 0.2);\n  q = p; \n  q.y -= 1.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.9, 0.28, 0.75));\n  q = p;  \n  q.x = abs (q.x) - 1.05; \n  q.y -= 2.;\n  q.yz = Rot2D (q.yz, rAngA * sign (p.x));\n  q.y -= -0.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;\n  ah = rAngH;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.3;\n  q.y -= 3.1;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  q.y -= 0.25;\n  d = min (d, PrRoundCylDf (q.xzy, 0.06, 0.04, 0.3));\n  q = p;\n  q.x = q.x - 0.4;  \n  q.y -= 0.95;\n  q.yz = Rot2D (q.yz, - rAngL);\n  q.y -= -0.65;\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  q = p;\n  q.x = - q.x - 0.4;  \n  q.y -= 0.95;\n  q.yz = Rot2D (q.yz, rAngL);\n  q.y -= -0.65;\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  DMINQ (idBod);\n  q = p;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x); \n  q -= vec3 (0.4, 2.7, 0.7);  \n  d = PrSphDf (q, 0.15);\n  DMINQ (idEye);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, r, a, aa, s;\n  dMin = dstFar;\n  q = p;\n  r = length (p.xz);\n  q.xz = Rot2D (p.xz, pi / 6.);\n  aa = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  a = floor (3. * aa + 0.5);\n  q.xz = Rot2D (q.xz, 2. * pi * a / 3.);\n  qq = q;\n  s = sign (a + 0.01);\n  q.x = (a >= 0.) ? mod (q.x + wDisp * s + a * gGap, 2. * gGap) - gGap :\n     mod (q.x + wDisp * s + 0.5 * gGap, gGap) - 0.5 * gGap;\n  q.xz = Rot2D (q.xz, - pi * s / 2.);\n  dMin = min (dMin, max (RobDf (q), r - bCylRad));\n  q = qq;\n  q.x += bCylRad;\n  q.y -= 2.4;\n  d = PrRoundBoxDf (q, vec3 (1., 2.4, 4.), 0.05);\n  DMINQ (idDoor);\n  q = qq;\n  q.y -= 1.9;\n  d = length (q.yz) - 2.4;\n  q = p;\n  q.y -= 2.4;\n  d = max (PrRoundCylDf (q.xzy, 5., 0.05, 2.4), - d);\n  DMINQ (idCen);\n  d = PrRoundCylDf (q.xzy, 3., 0.03, 2.4);\n  DMINQ (idCenIn);\n  q.y -= 2.7;\n  d = PrRoundCylDf (q.xzy, 3., 0.1, 0.3);\n  DMINQ (idCor);\n  q.y -= 0.6;\n  q.xz = Rot2D (p.xz, 2. * pi * floor (12. * aa + 1.5) / 12.);\n  q.x += 3.;\n  d = PrSphDf (q, 0.4);\n  DMINQ (idCorLt);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.04 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.25 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, qh, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV, sh;\n  float ga = 2.39996; // = pi * (3 - sqrt(5))\n  InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = ro.y / bCylHt - 1.;\n    hhy = abs (hy) - 0.4;\n    aa = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (60. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = vec3 (0.4, 0.5, 0.6) * (0.8 + 0.2 * cos (0.1 * 2. * pi * tCur));\n      else col = vec3 (0.4, 0.5, 0.3) * (0.5 + 0.5 * max (dot (vn, ltDir), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.7, 0.8, 0.7);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        rg = ShStagGrid (16. * vec2 (12. * aa, hy));\n        col *= rg.y;\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.4 + 0.6 * max (dot (vn, ltDir), 0.)) +\n         0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    qw = Rot2D (ro.xz, pi / 6.);\n    qw = Rot2D (qw, 2. * pi * (floor (3. * ((length (qw) > 0.) ? atan (qw.y, - qw.x) /\n       (2. * pi) : 0.) + 0.5) / 3.));\n    if (abs (qw.y) > 2.) {\n      b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n      qh = HexGrid (ro.zx);\n      f = max (length (qh.xy) - 0.5, 0.) * b;\n      vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n      vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n      vn = VaryNf (64. * ro, vn, 0.2 * b);\n      col = vec3 (0.72, 0.75, 0.72) * (1. - 0.1 * b * Noisefv2 (128. * ro.xz)) *\n         (1. - min (0.2 * b * (1. - smoothstep (0.03, 0.06, qh.z)), 0.1));\n    } else {\n      vn = vec3 (0., 1., 0.);\n      col = vec3 (0.65, 0.65, 0.6) * (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.02, mod (qw.y, 1.)));\n    }\n    col *= 0.1 + 0.9 * smoothstep (4., 5., length (ro.xz));\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.1 * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    ro += dCylOut * rd;\n    f = 0.;\n    qw = ro.xz / bCylRad;\n    for (float n = float (VAR_ZERO); n < 128.; n ++) f += 1. - smoothstep (0.02, 0.025,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col = mix (vec3 (0.2, 0.2, 0.4), vec3 (1., 1., 0.7), f);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, tCyc, r;\n  gGap = 4.;\n  tCyc = 4.;\n  tPhs = mod (tCur, tCyc);\n  wDisp = 2. * (gGap / tCyc) * tCur;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    r = length (ro.xz);\n    if (idObj == idBod) col4 = (ro.z < 0.) ? vec4 (0.7, 0.7, 0.8, 0.1) : \n       ((ro.x < 0.) ? vec4 (0.8, 0.2, 0.2, 0.1) : vec4 (0.2, 0.8, 0.2, 0.1));\n    else if (idObj == idEye) col4 = (ro.z < 0.) ? vec4 (0.9, 0.9, 1., -1.) : \n       ((ro.x < 0.) ? vec4 (1., 0.3, 0.3, -1.) : vec4 (0.3, 1., 0.3, -1.));\n    else if (idObj == idCen) col4 = vec4 (0.6, 0.6, 0.8, 0.1) * (0.9 + 0.1 *\n       SmoothBump (0.1, 0.9, 0.02, mod (60. * atan (ro.z, - ro.x) / (2. * pi), 1.))) *\n       (0.5 + 0.5 * smoothstep (3., 3.5, r));\n    else if (idObj == idCenIn) col4 = vec4 (1., 1., 0.5, 0.) *\n       step (0.45, abs (mod (2. * tCur / tCyc + 0.45, 1.) - 0.5));\n    else if (idObj == idDoor) col4 = ((ro.z < 0.) ? vec4 (1., 1., 1., 0.1) : \n       ((ro.x < 0.) ? vec4 (1., 0., 0., 0.1) : vec4 (0., 1., 0., 0.1))) *\n       (0.3 + 0.5 * smoothstep (2.9, 3., length (qHit.yz + vec2 (1., 0.))));\n    else if (idObj == idCor) col4 = (floor (mod (2. * tCur / tCyc + 0.25, 2.)) == 0.) ?\n       vec4 (1., 0.5, 0.5, 0.1) : vec4 (0.5, 1., 0.5, 0.1);\n    else if (idObj == idCorLt) col4 = (floor (mod (2. * tCur / tCyc + 0.25, 2.)) == 0.) ?\n       vec4 (1., 0., 0., -1.) * (0.7 + 0.3 * sin (8. * pi * tCur)) : vec4 (0., 1., 0., -1.);\n    col = (col4.a >= 0.) ? col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.) : col4.rgb * (0.7 - 0.3 * dot (rd, vn));\n    if (idObj == idBod) col += 0.2 * BgCol (ro, reflect (rd, vn));\n    if (ro.y < 4.5 && idObj != idCenIn) col *= 0.1 + 0.9 * smoothstep (4., 5., r);\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bCylRad = 48.;\n  bCylHt = 12.;\n  az = 0.67 * pi + (1.2/16.) * pi * (floor (0.2 * tCur) +\n     smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 3., -0.99 * bCylRad);\n  zmFac = 2.8;\n  dstFar = 2. * bCylRad;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcW8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[854, 854, 876, 876, 2023], [2025, 2025, 2047, 2047, 3089], [3091, 3091, 3124, 3124, 3308], [3310, 3310, 3331, 3331, 3586], [3588, 3588, 3625, 3625, 3854], [3856, 3856, 3890, 3890, 4411], [4413, 4413, 4439, 4439, 4790], [4792, 4792, 4823, 4823, 8326], [8328, 8328, 8363, 8363, 10238], [10240, 10240, 10296, 10296, 11454], [11456, 11456, 11502, 11502, 11549], [11551, 11551, 11584, 11584, 11611], [11613, 11613, 11670, 11670, 11834], [11836, 11836, 11860, 11860, 12090], [12092, 12092, 12116, 12116, 12176], [12178, 12178, 12201, 12201, 12334], [12336, 12336, 12372, 12372, 12578], [12580, 12580, 12610, 12610, 12723], [12725, 12725, 12782, 12782, 12865], [12899, 12899, 12923, 12923, 12960], [12962, 12962, 12986, 12986, 13098], [13100, 13100, 13125, 13125, 13311], [13313, 13313, 13342, 13342, 13554], [13556, 13556, 13595, 13595, 13775]], "test": "untested"}
{"id": "3dXyW8", "name": "attempt at perspective mapping", "author": "adimineman", "description": "it should be able to map out perspecitve errors\ntodo: add a way to move points without having to recompile every time!", "tags": ["perspective"], "likes": 0, "viewed": 324, "published": 3, "date": "1584611770", "time_retrieved": "2024-07-30T21:17:55.847763", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 lu=vec2(0,1),ru= vec2(1,1),ll=vec2(0,0),rl=vec2(1,0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n\tif(iMouse.z>.5) col=texture(iChannel0,uv).xyz*step(.02,length(uv-lu))*step(.02,length(uv-ru))*step(.02,length(uv-ll))*step(.02,length(uv-rl));\n\telse col=texture(iChannel0,mix(mix(ll,rl,vec2(uv.x)),mix(lu,ru,vec2(uv.x)),vec2(uv.y))).xyz;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 444]], "test": "untested"}
{"id": "tslcDr", "name": "Sands of Time", "author": "wyatt", "description": "Using a line network to sum many many interactions", "tags": ["particles", "triangulation"], "likes": 7, "viewed": 447, "published": 3, "date": "1584609713", "time_retrieved": "2024-07-30T21:17:56.613714", "image_code": "// Fork of \"Destructible*\" by wyatt. https://shadertoy.com/view/tdXyRH\n// 2020-03-19 08:09:45\n\n// Fork of \"Destructible \" by wyatt. https://shadertoy.com/view/3lKSDV\n// 2020-03-13 18:10:34\n\n// Fork of \"Foam Simulation\" by wyatt. https://shadertoy.com/view/tlyXDG\n// 2020-03-08 02:50:08\n\n// Fork of \"Triangulated Actors****\" by wyatt. https://shadertoy.com/view/ttGXDG\n// 2020-03-06 04:21:54\nvec4 color (float i) {\n    return 1.+0.*abs(sin(.1*length(shape(co(i)))*vec4(1,2,3,4)));\n}\nMain \n\tvec4 b = B(U);\n\tvec4 a = A(b.x), aa = A(b.y), aaa = A(b.z), aaaa = A(b.z);\n\tvec2 r = a.xy-aa.xy, r1 = a.xy-aaa.xy, r2 = a.xy-aaaa.xy;\n\tfloat l = length(r), l1 = length(r1), l2 = length(r2);\n\tvec4 c = color(b.x),c1 = color(b.y),c2 = color(b.z),c3 = color(b.w);\n\tQ = mix (c,c1,dot(r,U-aa.xy)/dot(r,r));\n\tQ = .3*(\n        c1*exp(-2.*sg(U,a.xy,aa.xy))+\n        c2*exp(-2.*sg(U,a.xy,aaa.xy))+\n        c3*exp(-2.*sg(U,a.xy,aaaa.xy))\n    );\n\tfloat d = 1.;\n\tQ = .3*Q+1.*(\n        c1*exp(-d*length(U-a.xy))+\n        c1*exp(-d*length(U-aa.xy))+\n        c2*exp(-d*length(U-aaa.xy))+\n        c3*exp(-d*length(U-aaaa.xy))\n    );\n\tQ *= 2.*sin(vec4(1,2,3,4)+B(U)/R.x/R.y);\n\t//Q += .1*(D(U)+C(U));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define co(i) vec2(mod(i,R.x),i/R.x)\n#define id(U) (floor((U).x)+floor((U).y)*R.x)\n#define A(i) texelFetch(iChannel0,ivec2(co(i)),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U) { U = gl_FragCoord.xy;\n#define Init if (iFrame < 1) \n#define init  (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n\n#define O 6.\n#define W round(0.9*R.y/O)\n#define shape(u) round((u)/O)*O\n\nvec2 force (vec4 a, vec4 b) {\n    vec2 r = b.xy-a.xy, v = b.zw-a.zw;\n    float l = length(r);\n    if (l < 1e-4) return vec2(0);\n    vec2 f = vec2(0);\n    if (l!=0.){\n    f += 10.*(1.-dot(a.zw,b.zw))*r/max(1.,l*l*l);\n    f -= 600.*r/max(1.,l*l*l*l*l*l);\n    }\n   \n    if (length(f)>5.) return 5.*normalize(f);\n    return f;\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i))+1e-3*length(p-b);\n}float line (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n\tl -= .5;\n    if (l>0.) return l;\n    else return -1e4+abs(length(a-b)-length(a-p));\n}", "buffer_a_code": "// Information Storage\nMain \n\tvec2 u = shape(U);\n\tfloat i = id(U);\n    Q = A(i);\n    vec2 f = vec2(0);\n\tfloat n = 0., n1 = 0.;\n\tfor (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++){\n        vec4 b = B(Q.xy+vec2(x,y));\n       \tvec4 t = A(b.x);\n        if (abs(b.x-i)<1e-9){\n    \t\tf += C(Q.xy+vec2(x,y)).xy;\n        }\n        else f += force(Q,t);\n        \n    }\n\tf = f/49.;//+vec2(0,-8e-4);\n\tQ.zw += f;\n\tQ.xy += .1*f+Q.zw*(1./sqrt(1.+dot(Q.zw,Q.zw)));\n\t\n\tif (iMouse.z>0.&&length(Q.xy-iMouse.xy)>0.)\n\tQ.zw += -(Q.xy-iMouse.xy)/dot(Q.xy-iMouse.xy,Q.xy-iMouse.xy);\n\tif (length(Q.zw)>1.) Q.zw = 1.*normalize(Q.zw);\n\t\n\t\n\tif (Q.x<0.){Q.z=abs(Q.z);}\n    if (Q.y<0.){Q.w=abs(Q.w);}\n    if (R.x-Q.x<0.){Q.z=-abs(Q.z);}\n    if (R.y-Q.y<0.){Q.w=-abs(Q.w);}\n\tif (iFrame < 6)\n    {\n    \t\n        Q = vec4(u,0.,0.);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// SORT TRIANGULATION\nvoid Y (inout vec4 Q, inout vec4 a, inout vec4 aa, inout vec4 aaa, inout vec4 aaaa, float i, vec2 U) {\n\tvec4 n = A(i);\n    float ln = length(n.xy-U),\n          la = length(a.xy-U);\n    if (ln<la) {\n    \tQ.x = i;\n        a = n;\n    }\n    float pn = sg(U,a.xy,n.xy),\n          pa = sg(U,a.xy,aa.xy);\n    if (pn<=pa){\n        aa = n;\n        Q.y = i;\n        pa = pn;\n    }\n    float sn = pn,\n          sa = sg(U,a.xy,aaa.xy);\n    if (sn<sa&&sn>pa) {\n    \taaa = n;\n        Q.z = i;\n        sa=sn;\n    }\n    float tn = sn,\n          ta = sg(U,a.xy,aaaa.xy);\n    if (tn<ta&&tn>sa) {\n    \taaaa = n;\n        Q.z = i;\n    }\n}\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 aa, inout vec4 aaa, inout vec4 aaaa,  vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    Y(Q,a,aa,aaa,aaaa,b.x,U);\n    Y(Q,a,aa,aaa,aaaa,b.y,U);\n    Y(Q,a,aa,aaa,aaaa,b.z,U);\n    Y(Q,a,aa,aaa,aaaa,b.w,U);\n}\nvoid Xl (inout vec4 Q, inout vec4 a, inout vec4 aa, inout vec4 aaa, inout vec4 aaaa, vec2 U, float r) {\n\t X(Q,a,aa,aaa,aaaa,U,vec2(r,r));\n     X(Q,a,aa,aaa,aaaa,U,vec2(r,-r));\n     X(Q,a,aa,aaa,aaaa,U,vec2(-r,r));\n     X(Q,a,aa,aaa,aaaa,U,vec2(-r,-r));\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 aa, inout vec4 aaa, inout vec4 aaaa, vec2 U, float r) {\n\n\t X(Q,a,aa,aaa,aaaa,U,vec2(r,0));\n     X(Q,a,aa,aaa,aaaa,U,vec2(0,r));\n     X(Q,a,aa,aaa,aaaa,U,vec2(0,-r));\n     X(Q,a,aa,aaa,aaaa,U,vec2(-r,0));\n}\nMain \n\tQ = B(U);\n    vec4 a = A(Q.x), aa= A(Q.y), aaa = A(Q.z), aaaa = A(Q.w);\n    Xr(Q,a,aa,aaa,aaaa,U,1.);\n    Xr(Q,a,aa,aaa,aaaa,U,4.);\n    //Xr(Q,a,aa,aaa,aaaa,U,9.);\n    Init {\n        Q.w = Q.z = Q.y = Q.x = float(id(shape(U)));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// COMPUTE FORCE FIELD\nMain \n\tvec4 b = B(U);\n\tvec4 a = A(b.x), aa = A(b.y), aaa = A(b.z), aaaa = A(b.z);\n\tQ=vec4(0);\n\tQ.xy +=  force(a,aa);\n\tQ.xy +=  force(a,aaa);\n\tQ.xy +=  force(a,aaaa);\n    Q/=3.;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 391, 413, 413, 481]], "test": "untested"}
{"id": "wdscWn", "name": "getting started on Shadertoy", "author": "LoneCactusMotel", "description": "An intersection of two spheres with noise and sine displacement.", "tags": ["raymarching"], "likes": 3, "viewed": 344, "published": 3, "date": "1584594487", "time_retrieved": "2024-07-30T21:17:57.803533", "image_code": "vec3 estimate_normal(vec3 p);\nvec4 phong_shading(vec3 p, vec3 n, vec3 l, vec3 v, vec3 c);\nfloat noise(vec3 p);\n\n// return value encodes color in xyz/rgb and distance in w/a components.\nvec4 opSmoothIntersection(vec4 d1, vec4 d2, float k);\n\nvec4 sdf_sin_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color);\nvec4 sdf_noisy_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color);\n\nvec4 sdf_scene(vec3 probe)\n{\n    return opSmoothIntersection(sdf_sin_sphere(vec3(0.0, sin(0.7*iTime), -8.200), 1.0, probe, vec3(0.0, 1.0, .8)),\n                                sdf_noisy_sphere(vec3(sin(iTime), 0.0, -8.200), 0.8000, probe, vec3(1.0, 1.0, 0.4)),\n                                0.5);\n}\n\n\n// Fragment function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2((fragCoord.x - 0.5*iResolution.x)/iResolution.y , (fragCoord.y - 0.5*iResolution.y)/iResolution.y);\n\n\tfloat eps = 0.0015;\n\tvec3 light = vec3(-3.0+3.0*sin(iTime), 4.0+3.0*sin(1.3*iTime), 8.0);\n\tvec3 camera = vec3(0.0, 0.0, 4.0);\n\tvec3 pixel = vec3(uv, 0.0);\n\tvec3 ray = normalize(pixel-camera);\n\tvec3 probe = camera;\n\tvec4 dist = vec4(0.0, 0.0, 0.0, 2.0*eps);\n    \n    const float min_z = -20.0;\n    const int max_iterations = 500;\n\n    int final_its = max_iterations;\n    \n\tfor(int its=max_iterations; its>0; its-=1)\n\t{\n\t    final_its = its-1;\n\n\t\tdist = sdf_scene(probe);\n\t\tprobe = probe + (dist.w * ray);\n        if(dist.w <= eps || probe.z <= min_z)\n        {\n            break;\n        }\n\t}\n\n\tif (dist.w <= eps)\n\t{\n\t\tvec3 normal = estimate_normal(probe);\n\t\tvec3 color = dist.rgb;\n\t\tfragColor = phong_shading(probe, normal, light, camera, color);\n\t}\n\telse if(final_its <= 0)\n\t{\n\t\tfragColor = vec4(1, 1, 0, 1);\n\t}\n\telse if(probe.z <= min_z)\n\t{\n\t\tfragColor = vec4(0, 0, 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(1, 1, 1, 1);\n\t}\n}\n\n\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip;\n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\nfloat sin_displacement(vec3 p, float frequency)\n{\n\treturn sin(frequency*p.x)*sin(frequency*p.y)*sin(frequency*p.z);\n}\n\n\n// smooth intersection (IQ) with added color blend\nvec4 opSmoothIntersection(vec4 d1, vec4 d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nvec4 sdf_sin_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color)\n{\n\treturn vec4(color, distance(probe, sphere_center) - sphere_radius + 0.05*sin_displacement(probe, 20.0));\n}\n\nvec4 sdf_noisy_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color)\n{\n\tvec3 nrml = normalize(probe-sphere_center);\n\treturn vec4(color, distance(probe, sphere_center) - sphere_radius - 0.5*noise(2.6*(nrml+vec3(0.2*iTime, 0.2*iTime, iTime))));\n}\n\n\n\nvec3 estimate_normal(vec3 p) {\n\tfloat eps = 0.001;\n    return normalize(vec3(\n        sdf_scene(vec3(p.x + eps, p.y, p.z)).w - sdf_scene(vec3(p.x - eps, p.y, p.z)).w,\n        sdf_scene(vec3(p.x, p.y + eps, p.z)).w - sdf_scene(vec3(p.x, p.y - eps, p.z)).w,\n        sdf_scene(vec3(p.x, p.y, p.z + eps)).w - sdf_scene(vec3(p.x, p.y, p.z - eps)).w\n    ));\n}\n\n\n// p: point on surface\n// n: surface normal at p\n// l: position of light source\n// v: position of viewer\n// c: diffuse color\nvec4 phong_shading(vec3 p, vec3 n, vec3 l, vec3 v, vec3 c)\n{\n\tvec3 light = normalize(l);\n\tvec3 r     = reflect(light, n);\n\tvec3 view  = normalize(v-p);\n\tfloat diffuse  = max(0.0, dot(light, n));\n\tfloat specular = max(0.0, dot(-r, view));\n\tvec3 color = diffuse * c + pow(specular, 40.0) * vec3(1, 1, 1);\n\treturn vec4(color, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdscWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 415, 443, 443, 715], [718, 739, 794, 794, 1840], [1844, 1870, 1891, 1891, 2138], [2140, 2140, 2189, 2189, 2257], [2260, 2311, 2365, 2365, 2468], [2471, 2471, 2557, 2557, 2665], [2667, 2667, 2755, 2755, 2929], [2933, 2933, 2963, 2963, 3286], [3289, 3414, 3474, 3474, 3742]], "test": "untested"}
{"id": "3dlcWr", "name": "Day 90", "author": "jeyko", "description": "poto", "tags": ["mdmtjvm"], "likes": 9, "viewed": 1212, "published": 3, "date": "1584565703", "time_retrieved": "2024-07-30T21:17:58.866690", "image_code": "// Fork of \"Day 85\" by jeyko. https://shadertoy.com/view/WdfczH\n// 2020-03-18 17:38:02\n\n// Fork of \"Day 84\" by jeyko. https://shadertoy.com/view/Wssczn\n// 2020-03-13 10:52:05\n\n// radial blur and chromatic abberation in this buffer\n// SNOWFLAKES FROM LSDLIVE \n// hg-sdf library used\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),4.)*0.7;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),3.)*10.04;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*26.5; \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.9);\n    //1fragColor *= 18.;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*0.4));\n    fragColor *= 1. - dot(uvn,uvn)*0.6;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define mx (iMouse.x/iResolution.y)\n#define iTime (iTime + 3.6 + mx)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvec3 att = vec3(1);\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0,vec2(floor(t)/256.)),texture(iChannel0,vec2(floor(t) + 1.)/256.), smoothstep(0.,1.,fract(t)));\n}\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n\n\nfloat sdRhombus(vec3 p, vec3 s){\n\t\n    \n    p = abs(p) - s;\n    \n    float d = max(p.z, max(p.x, p.y));\n    \n    \n    d = max(d, dot(p.yx + s.yx*0.5, normalize(vec2(1.))));\n    d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1.))));\n    //d = max(d - s.x*0., -dot(p.z,p.x));\n    //d \n    \n    \n    return d;\n}\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nfloat sdBox( vec3 p, vec3 s )\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\n\n    \nvec3 modD = vec3(4.,3,4);\nfloat iii;\nfloat sdThangiPong(vec3 p){\n    \n    p /= 4.;\n    float mmm = sin(iTime);\n\n    mmm = sign(mmm)*pow(abs(mmm), 5.);\n    \n    \n    float tt = iTime*4.;\n    //p.y -= tt + sin(iii*1.) + sin(tt + sin(iii*1.)*1.);\n    p.y -= tt + sin(iii)*6.;\n    //p.y -= iTime + sin(iTime );\n    p.y = pmod(p.y, modD.y*1.4);\n    \n    \n    p.xz *= rot(mmm*PI); \n    p.xz = abs(p.xz);\n    float d = sdRhombus(p , vec3(0.12));\n    \n    //glow += 0.5/(0.08+ d*d*4.)*vec3(0.1,0.43,0.3)*att;\n    //glow += 0.5/(0.08+ d*d*20.)*vec3(0.4,0.3,0.1)*att;\n    glow += 0.5/(0.08+ d*d*20.)*vec3(0.1,0.2,0.1)*att;\n    \n    p.y -= 0.4;\n    p.xz *= rot(0.25*PI);\n    \n    float n = fOpUnionStairs(d, sdRhombus(p - vec3(0,0.0 + 0.0,0), vec3(0.1)), 0.2,4.);\n    d = min(d, n);\n    //fOpUnionStairs\n    return d*4.;\n}\n\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n\n    vec3 c = vec3(1);\n    \n    \n    p -= modD*0.5;\n    vec3 v = p;\n    \n    vec3 b = v; // thx lsdlive for snow fx\n    p.y = pmod(p.y,4.);\n    \n    \n    pModPolar(p.xz, 6.);\n    p = abs(p);\n    p.x += 1.;\n    p.y -= 0.2;\n    p.yz *= rot(0.);\n    p.xz *= rot(-0.2);\n    \n    /*\n    p.x -= 0.6;\n    p = abs(p);\n    p.xz *= rot(0.3);\n    p.x += 2.5;\n    p = abs(p);\n    p.xz *= rot(-0.3);\n\t*/\n    //pModPolar(p.yz , 5.);\n    \n    vec3 u = p;\n    \n    float sM = 4.;\n    \n    //p.x -= sM;\n    p.x = pmod(p.x, 4.);\n    \n    float dB = sdBox(p, vec3(0.3,0.1,0.1));\n    \n    float mmm = pow(abs(sin(iTime + v.y*0.1)), 9.);\n    \n    v.xz *= rot(0.5 + v.y*0.3);\n    iii = pModPolar(v.xz, 7.);\n    \n    v.x -= mmm*1.5;\n    \n    v.x -= 1.5;\n    \n    float dOa = length(v.xz) - 0.5;\n    \n    vec2 ss = vec2(0.04,0.4);\n    float dOt = max(max(abs(v.x) - ss.x, abs(v.z)- ss.y),-dOa);\n    \n    dOa = abs(dOa) + 0.009;\n    \n    float dT = sdThangiPong(v);\n    \n    v.x -= 10.;\n\n\n\n    d = dmin(d, vec2(dT, 2.));\n    \n    //d = dmin(d, vec2(dOa, 2.));\n    \n    \n    dOt = abs(dOt) + 0.01;\n    d = dmin(d, vec2(dOt, 2.));\n    \n    //glow -= 0.1/(0.1 + dOt*dOt*30.)*vec3(0.,0.2,0.1);\n    glow -= 0.01/(0.1 + dOa*dOa*10.)*vec3(0.6,0.2,0.1);\n    \n    vec3 j = p;\n    vec3 k = p;\n    vec3 q = p;\n\n    j.y = pmod(j.y, modD.y*1.);\n    \n    \n    for(int i = 0; i <4; i++){\n    \tj = abs(j);\n        j.xy *= rot(0.3);\n        j.xz *= rot(0.1);\n        j -= 0.4;\n    }\n    j.y -= 0.2;\n    float dA = sdBox(j, vec3(0.1,0.1,0.5));\n    float dAb = sdBox(k, vec3(0.2,0.2,0.2));\n    dA = max(dA, -u.x + 6.);\n    dAb = max(dAb, -u.x + 6.);\n    \n    dA = abs(dA) + 0.02;\n    dAb = abs(dAb) + 0.02;\n    d = dmin(d, vec2(dA, 2.));    \n    d = dmin(d, vec2(dAb, 2.));    \n    \n    q = abs(q) - vec3(0.15);\n    \n    //float mmmm = pow(abs(sin(b.z*0.5 + sin(b.y + iTime*3.8)*1.+ sin(b.x + iTime*3.5)*4.5 + iTime*4.)), 4.);\n    float mmmm = pow(abs(sin(b.z*0.1 + sin(b.y*0.1 + iTime*0.15)*1.+ sin(b.x*0.1 + iTime*0.12)*4.5 + iTime*0.1)), 8.);\n    //glow += 0.1/(0.1 + dA*dA*(20000. - pow(mmmm, 2000.)*18000.))*vec3(0.4,0.4,0.7);\n    //glow += 0.0004/(0.1 + dA*dA*80.)*vec3(0.2,0.4,0.7);\n    //glow += 0.004/(0.1 + dAb*dAb*(60. - mmm*59.))*vec3(0.2,0.4,0.7)*3.*mmmm;\n    //glow -= 0.004/(0.1 + dAb*dAb*(60. - mmmm*59.))*vec3(0.1,0.3,0.14)*4.*(1. - mmmm);\n    glow -= 0.004/(0.1 + dAb*dAb*(60. - mmmm*59.))*vec3(0.3,0.3,0.14)*4.*(mmmm);\n    \n    \n    float dP = min(\n        \t\t\tmin(\n                        max(q.x, q.y),\n                        max(q.x, q.z)\n                       ),\n                        max(q.y, q.z)\n                  );\n    \n    \n    float dCc = sdBox(q, vec3(0.1));\n    \n    dCc = max(dCc, -u.x + 6.);\n    \n    \n    dP = max(dP, -u.x + 6.);\n    \n    d = dmin(d, vec2(dCc, 2.));\n    \n    d = dmin(d, vec2(dP, 2.));\n    \n    \n    \n    \n  // tochange v\n    \n    \n    b.x += sin(b.z*0.2)*4.;\n    b.y += sin(b.x*0.2 + iTime*0.2)*2.;\n    b.z += sin(b.x*0.25 + iTime*0.1)*2.;\n    \n    b.yx += iTime*25.;\n    \n    b = pmod(b, 5.);\n    \n    float dS = length(b) - 0.01;\n    \n    \n    dS = abs(dS) + 0.01;\n    \n    \n    //glow += 0.9/(0.1 + dS*dS*200.)*vec3(0.6,0.2,0.5);\n    vec3 gg = 0.1/(0.01 + dS*dS*5000.)*vec3(0.6,0.5,0.5);\n    vec3 ggb = 0.3/(0.1 + dS*dS*dS*10000.)*vec3(0.6,0.5,0.5);\n    glow -= ggb*8.7 ;\n    \n    d = dmin(d, vec2(dS, 3.));\n\td.x *= 0.6;\n    return d;\n}\nfloat dith;\nint its = 0;\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n\n    p = ro; t = 0.; hit = false;\n    for(its = 0; its < 120 + min(0, iFrame)   ; its++){\n    \td = map(p);\n        d.x *= dith;\n        \n    \t//glow += exp(-d.x*20.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir ));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + (right*uv.x + up*uv.y)*0.8);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //\n    \n    vec4 nb = valueNoise(iTime*1./3.);\n\t//uv *= 1. - dot(uv,uv)*0.2;\n    uv *= 1. - dot(uv,uv)*0.1 - nb.x*0.2;\n    \n    \n    \n    uv.xy *= rot(sin((iTime*0.6 - 3.6))*0.4);\n    \n    vec3 col = vec3(0);\n\n    dith = mix(0.86,1., texture(iChannel0, 20.*uv*256.).x);\n    vec3 ro = vec3(0);\n    \n    \n    //float n = pow(valueNoise(iTime*1.).x, 2.);\n    float zoom = 12. ;\n    //ro.xz += vec2(sin(iTime*0.5),cos(iTime*0.5))*zoom;\n    ro.xz += vec2(sin( nb.x*6.14*1.5),cos( nb.x*6.14*1.5))*zoom;\n    \n    ro.y += modD.y*0.5;\n    \n    vec3 lookAt = vec3(0,ro.y + nb.y*1.5,0.);\n    lookAt.y += -0.5 + valueNoise(iTime*1./2.).x;\n    vec3 rd = getRd(ro, lookAt, uv);\n    //rd.yz *= rot(iTime);\n    \n    vec3 p; float t; bool hit;\n    float side = 1.;\n    float tA;\n    \n    for(int i = 0; i < 1; i ++){\n    \tvec2 d = march(ro, rd, p, t, hit);\n    \tvec3 n = getNormal(p);\n        \n        vec3 ld = normalize(vec3(p.x,0.1,p.z));\n        vec3 h = normalize(ld - rd);\n        \n        float diff = max(dot(n, ld), 0.);\n        float spec = pow(max(dot(n, -h), 0.), 20.);\n        float fres = pow(1. - max(dot(n, -rd), 0.), 5.);\n        \n        //col += fres*0.04*vec3(0,0.5,1);\n        //col += diff*fres*0.03*vec3(0.8,0.2,0.7)*0.1;\n        if(hit){\n            #define ao(j) clamp(map(p + n*j).x/j,0.,1.)\n            \n            float aaa = ao(0.1)*ao(0.3);\n        \tcol += pow(fres, 1.)*0.3*vec3(0.3,0.2,0.4)*0.1*aaa;\n        \tcol += diff*pow(fres, 0.4)*0.02*vec3(0.2,0.12,0.1)*0.1*aaa;\n    \t\t//col -= float(its)*0.001;\n        \n        }\n        \n        //col += spec*0.06*vec3(0.3,0.1,0.1)*1.;\n        \n        if (d.y == 6.){\n        \n        }\n        tA = t;\n    }\n        \n    \n    \n    //col = mix(col, vec3(0.04,0.06,0.17)*0.01, pow(smoothstep(0.,1.,tA*0.013), 1.6));\n    //col = mix(col, vec3(0.3,0.06,0.17)*0.01, pow(smoothstep(0.,1.,tA*0.013), 1.6));\n    \n    col = max(col, 0.);\n    col = mix(col, vec3(0.3,0.3,0.17)*0.01, pow(smoothstep(0.,1.,tA*0.013), 1.6));\n    col = mix(col, vec3(0.3,0.2,0.17)*0.04, pow(smoothstep(0.,1.,-p.y*0.113 + 0.0 + pow(nb.x, 2.)), 1.6));\n    col += glow*0.006;\n\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 341, 341, 1404]], "test": "untested"}
{"id": "3slcDn", "name": "orange planet", "author": "makesmi", "description": "This is coded in a bus traveling to Helsinki. Shader programming = creativity + math.", "tags": ["raytracing", "metaballs", "sphere"], "likes": 11, "viewed": 402, "published": 3, "date": "1584558540", "time_retrieved": "2024-07-30T21:17:59.702456", "image_code": "// sphere radius 2.0, camera distance 4.0\n// camera distance from screen 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord-0.5*iResolution.xy)/iResolution.y*2.0;\n\tfloat time = iTime + 26.0;\n    float squareSum = dot(pixel, pixel);\n    float d = (8. - sqrt(16. - squareSum*20.)) / (squareSum + 4.);\n    float isSphere = step(0.0, d);\n    vec3 worldPosition = vec3(d * pixel.xy, d*2. - 4.);\n    \n\tfloat sum = 0.;\n  \tfor(float i = 0.; i < 22.; i++){\n        float angle1 = 2. * cos(i + 0.2 + time*0.11) + 3. * sin(i * 5.7 + 5.);\n        float angle2 = sin(i*3.5 + 3. + time*0.4) + 2. * sin(i * 1.4 + 1.);\n        vec3 direction = vec3(cos(angle1)*sin(angle2), cos(angle2), sin(angle1)+cos(angle2*1.5));\n        vec3 distance = normalize(worldPosition) - normalize(direction);\n        sum += 1.0 / dot(distance, distance);\n  \t}    \n    \n    float outer = smoothstep(7.5, 6.0, abs(sum - 39.0));\n    float inner = smoothstep(16.0, 10.0, abs(sum - 105.));\n    float strong = outer + inner;\n    float fadeout = 1.-smoothstep(-0.5, -1.6, worldPosition.z);  \n    float smoothing = smoothstep(-0.75, -1.0, worldPosition.z);\n    float color = min(isSphere, (fadeout+max(strong, 0.13))*smoothing);    \n    fragColor = vec4(1.,1.-color*0.5,1.-color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slcDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 135, 135, 1284]], "test": "untested"}
{"id": "tsfcDr", "name": "Nine Point Circle and Euler Line", "author": "mla", "description": "The Nine Point Circle and Euler Line", "tags": ["circle", "eulerline", "ninepoint"], "likes": 7, "viewed": 386, "published": 3, "date": "1584549679", "time_retrieved": "2024-07-30T21:18:00.588088", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Nine Point Circle & Euler Line\n// Matthew Arcus, 2020.\n//\n// The feet of the altitudes, the midpoints between the orthocentre and the\n// vertices, and the midpoints of the sides, all lie on a circle.\n//\n// The centre of the nine-point circle, the circumcentre, the centroid and\n// the orthocentre are collinear and lie on the Euler line.\n//\n// Mouse controls vertex P of the triangle\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// The midpoint between p and q (also conjugate with point at infinity)\nvec3 midpoint(vec3 p, vec3 q) {\n  return p*q.z + p.z*q;\n}\n\nfloat distance2(vec3 p, vec3 q) {\n  p /= p.z; q /= q.z;\n  return abs(dot(p-q,p-q));\n}\n\n// Perpendicular bisector (a line)\nvec3 bisector(vec3 p,vec3 q) {\n  // (p-r).(p-r) = (q-r).(q-r) // r equidistant from p and q\n  // pp - 2pr + rr = qq - 2qr + rr\n  // pp - qq = 2pr - 2qr\n  // 2r.(p-q) = pp - qq\n  p /= p.z; q /= q.z;\n  return vec3(2.0*(p.xy-q.xy),dot(q,q)-dot(p,p));\n}\n\n// Drop perpendicular from p onto line q.\nvec3 perpendicular(vec3 p, vec3 q) {\n  // (p + kq.xy).q = 0\n  // p.q + k(q.yx).q = 0\n  float k = dot(p,q)/dot(q.xy,q.xy);\n  return p - k*vec3(q.xy,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z; // normalize\n  vec3 pa = p-q;\n  vec3 ba = r-q;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  float d = length(pa-h*ba);\n  return d;\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nfloat circle(vec3 p, vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return conic(p,mat3(1,0,-q.x,\n                      0,1,-q.y,\n                     -q.x,-q.y,dot(q.xy,q.xy)-r2));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvoid getmin(inout float d, inout int index, int i, float t) {\n  if (t < d) { d = t; index = i; }\n}\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,0,1),\n         vec3(0,1,0),\n         vec3(0,1,1),\n         vec3(0.8),\n         vec3(1,0,1),\n         vec3(1,1,1)\n         );\n\nvec3 getcol(int i) {\n  return colors[i];\n}\n\nvec3 diagram(vec3 p, vec3 P) {\n  vec3 pcol = vec3(0.3);\n  float lwidth = 0.005;\n  float dwidth = 1.5*fwidth(p.x/p.z);\n  float pwidth = 0.03;\n  // The triangle (P is parameter)\n  vec3 Q = vec3(-1.5,-0.5,1);\n  vec3 R = vec3(1,-1,1);\n  // Bisectors of the sides\n  vec3 bP = bisector(Q,R);\n  vec3 bQ = bisector(R,P);\n  vec3 bR = bisector(P,Q);\n  // Intersect at the circumcentre\n  vec3 O = join(bP,bQ);\n  // centre of the circumcircle.\n  vec4 C1 = vec4(O,distance2(O,P));\n  // The sides of the triangle\n  vec3 sP = join(Q,R);\n  vec3 sQ = join(R,P);\n  vec3 sR = join(P,Q);\n  // The altitudes\n  vec3 aP = perpendicular(P,sP);\n  vec3 aQ = perpendicular(Q,sQ);\n  vec3 aR = perpendicular(R,sR);\n  // orthocentre (intersection of altitudes).\n  vec3 H = join(join(P,aP),join(Q,aQ));\n  // The nine point centre..\n  vec3 C = join(bisector(aP,aQ),bisector(aQ,aR));\n  // ..and circle\n  vec4 C2 = vec4(C,distance2(C,aP));\n  // G is the centroid\n  vec3 mP = midpoint(Q,R); // Midpoint of side\n  vec3 mQ = midpoint(R,P);\n  vec3 mR = midpoint(P,Q);\n  vec3 G = join(join(P,mP),join(Q,mQ));\n\n  float d = 1e8;\n  int index = -1;\n  // Sides\n  getmin(d,index,0,line(p,P,Q));\n  getmin(d,index,0,line(p,Q,R));\n  getmin(d,index,0,line(p,P,R));\n  // Bisectors\n  getmin(d,index,1,line(p,bP));\n  getmin(d,index,1,line(p,bQ));\n  getmin(d,index,1,line(p,bR));\n  // Circumcircle and nine-point circle\n  getmin(d,index,2,circle(p,C1));\n  getmin(d,index,2,circle(p,C2));\n  // The altitudes\n  getmin(d,index,3,line(p,P,aP));\n  getmin(d,index,3,line(p,Q,aQ));\n  getmin(d,index,3,line(p,R,aR));\n  // The lines intersecting at the centroid\n  getmin(d,index,4,line(p,P,mP));\n  getmin(d,index,4,line(p,Q,mQ));\n  getmin(d,index,4,line(p,R,mR));\n\n  // The Euler line\n  getmin(d,index,5,segment(p,H,O));\n\n#if 0\n  // Orthic triangle\n  getmin(d,index,6,segment(p,aP,aQ));\n  getmin(d,index,6,segment(p,aQ,aR));\n  getmin(d,index,6,segment(p,aR,aP));\n#endif\n\n  //vec3 bgcolor = 0.1*vec3(0.75,0.25,1); //vec3(1,1,0.8);\n  vec3 col = vec3(1,1,0.8);  \n  col = mix(0.9*getcol(index),col,smoothstep(lwidth,lwidth+dwidth,d));\n  d = 1e8;\n  getmin(d,index,0,point(p,O));\n  getmin(d,index,0,point(p,H));\n\n  getmin(d,index,0,point(p,P));\n  getmin(d,index,0,point(p,Q));\n  getmin(d,index,0,point(p,R));\n\n  getmin(d,index,0,point(p,aP));\n  getmin(d,index,0,point(p,aQ));\n  getmin(d,index,0,point(p,aR));\n\n  getmin(d,index,0,point(p,join(sP,bP)));\n  getmin(d,index,0,point(p,join(sQ,bQ)));\n  getmin(d,index,0,point(p,join(sR,bR)));\n\n  getmin(d,index,0,point(p,midpoint(P,H)));\n  getmin(d,index,0,point(p,midpoint(Q,H)));\n  getmin(d,index,0,point(p,midpoint(R,H)));\n  \n  getmin(d,index,0,point(p,C));\n  getmin(d,index,0,point(p,G));\n\n  col = mix(pcol,col,smoothstep(pwidth,pwidth+dwidth,d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1.5;\n  vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1.0);\n  vec3 P = iMouse.x <= 0.0 ? vec3(1,1,1)\n    : vec3(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y,1.0);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1068, 1188, 1215, 1215, 1238], [1240, 1312, 1343, 1343, 1369], [1371, 1371, 1404, 1404, 1456], [1458, 1493, 1523, 1668, 1742], [1744, 1786, 1822, 1870, 1938], [2125, 2125, 2154, 2154, 2237], [2239, 2239, 2267, 2267, 2312], [2314, 2314, 2350, 2350, 2380], [2382, 2382, 2421, 2421, 2593], [2595, 2595, 2624, 2624, 2756], [2758, 2758, 2788, 2858, 3024], [3210, 3210, 3271, 3271, 3308], [3512, 3512, 3532, 3532, 3554], [3556, 3556, 3586, 3586, 6298], [6300, 6300, 6353, 6353, 6630]], "test": "untested"}
{"id": "wtKSWc", "name": "AA4-Shaders", "author": "puajklejos", "description": "AA4-Shaders", "tags": ["practica"], "likes": 2, "viewed": 272, "published": 3, "date": "1584533325", "time_retrieved": "2024-07-30T21:18:01.966403", "image_code": "#ifndef CFG_NO_POSTPROD\n\nconst float kToneMapA =.15;\nconst float kToneMapB =.50;\nconst float kToneMapC =.10;\nconst float kToneMapD =.20;\nconst float kToneMapE =.02;\nconst float kToneMapF =.30;\nconst float kToneMapW =2.0;\n\n//  Operador de Tonemapping \"Filmic\".\n//\tEntradas:\tx - Color en el espacio RGB HDR.\n//\tSalida:\t\tColor resultante en el espacio RGB LDR.\nvec4 tonemap(vec4 x)\n{\n   return ( (x * (kToneMapA * x + kToneMapC * kToneMapB) + kToneMapD * kToneMapE)  /\n            (x * (kToneMapA * x + kToneMapB            ) + kToneMapD * kToneMapF)) -\n            kToneMapE / kToneMapF;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv  = fragCoord.xy / iResolution.xy;\n    \n    //PIXELADO\n    uv = floor(uv * 250.0) / 250.0;  //Hemos establecido que la imagen total hayan 250 pixeles.\n    \n    //NOISE\n    float strength = 10.0;\n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 10.0);\n    vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n    \n    vec2 qv  = uv * 2. - 1.;\n    vec4 col = texture(iChannel0, uv);\n\tcol = tonemap(col) / tonemap(kToneMapW + .05 * textureLod(iChannel0, vec2(.5), 9.)); // Tonemapping.\n    col = col* (1./ pow(1. + pow(sqrt(dot(qv, qv)) * .3, 3.), 150.)); // Vignetting.\n    col = pow(col, vec4(1./2.2)); // Corrección Gamma.    \n    \n\tfragColor = col + grain;\n    \n    //fragColor = col;\n}\n\n#else\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n#endif//CFG_NO_POSTPROD", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//==============================================================================\n//\tFUNCIONES DE DISTANCIA\n//==============================================================================\n\n//\tPrimitivas de ejemplo.\n//\tOtras primitivas disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://www.pouet.net/topic.php?which=7931&page=1\nfloat sdPlaneY(vec3 p) { return p.y; }\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdBox   (vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//\tOperadores de ejemplo.\n//\tOtros operadores disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://mercury.sexy/hg_sdf/\nfloat opUnion       (float d1, float d2) { return min( d1, d2); }\nfloat opIntersection(float d1, float d2) { return max( d1, d2); }\nfloat opSubstraction(float d1, float d2) { return max(-d1, d2); }\nvec3  opRepetition  (vec3 pos, vec3 frq) { return mod(pos, frq) - 0.5 * frq; } \n\n//  Smooth minimum (polynomial smin())\n//  Ver https://iquilezles.org/articles/smin para más información.\nfloat opBlend(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n//==============================================================================\n//\tESCENA\n//==============================================================================\n\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2 mapScene(vec3 pos)\n{\n    float t = iTime * 2.;\n    vec2  a = vec2(kFarPlaneDist, 0), b = a;\n    \n    // Creamos una caja para contener la escena.\n    b = vec2(opSubstraction(sdBox(pos, vec3(10)), sdBox(pos, vec3(100))), 0); MIN(a, b);\n    \n\t// Calculamos la distancia a 3 esferas unidas entre ellas de forma suave, una centrada y dos orbitando alrededor.\n\tfloat p0= opBlend(sdSphere(pos, 1.), sdSphere(pos + 2. * vec3(sin(t*.11), cos(t*.24), cos(t*.33)), 1.), 0.5);\n    p0 = opBlend(p0, sdSphere(pos + 1.5 * vec3(cos(t*.21), cos(t*.23), sin(t*.45)), 1.), 0.5);\n\n    // Restamos a dichas esferas un dominio de repetición de cubos en XY e YZ.\n    float p1= sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(5, 5, .015));\n    p1 = opUnion(p1, sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(.015, 5, 5)));\n\tb  = vec2(opIntersection(p0, p1), 1); MIN(a, b);\n    \n\treturn a;\n}\n\n//==============================================================================\n//\tTRAZADO DE RAYOS\n//==============================================================================\n\n//\tcastRay() traza un rayo con origen en \"ro\" en dirección \"rd\" desde el plano cercano kNearPlaneDist \n//  hasta encontrar una superficie contra la que chocar o hasta superar la distancia del plano lejano kFarPlaneDist.\n//\tEl rayo se mueve en pasos discretos hasta un máximo de kMaxSteps (lo que sirve para determinar la precisión).\n//\tEl rayo se desplaza a lo largo de un dominio de distancia: dada una posición en mundo (la del rayo), preguntamos\n//\ta la función mapScene(), que representa la escena, cuál es la distancia al objeto más cercano. Avanzamos entonces\n//\ten la dirección del rayo dicha distancia, y volvemos a preguntar hasta que se dé alguna de las condiciones\n//\tanteriormente indicadas.\n//\tEntradas:\tro - Origen del rayo.\n//\t\t\t\trd - Dirección del rayo.\n//\tSalida:\t\tvec4(totalDistance, lastStepDistance, materialID, steps). \n#ifndef CFG_USING_ENHANCED_RAYMARCHING\nvec4 castRay(vec3 ro, vec3 rd)\n{\n    float  t   = kNearPlaneDist;\n    vec2   res = vec2(kFarPlaneDist, 0);\n    int    i   = 0;\n    for (; i < kMaxSteps; ++i)\n    {\n\t    res    = mapScene(ro + rd * t);\n        if ((res.x < kEpsilon) || (t > kFarPlaneDist))\n            break;\n        t += res.x;\n    }\n    return vec4(t, res.xy, i);\n}\n#else// CFG_USING_ENHANCED_RAYMARCHING\nvec2  gTexelSize  ; // Pixel size   (screen domain).\nfloat gTexelRadius; // Pixel radius (screen domain).\n\nvec4 castRay(vec3 ro, vec3 rd)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n    \n    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;\n    vec2  res = vec2(kFarPlaneDist, 0);\n\tint   i   = kMaxSteps;\n    for (; (i >= 0) && (t < kFarPlaneDist); --i)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {//\tError detectado, deja de aplicar la optimización \"over-relaxation raymarching\".\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {// Actualiza el error.\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break; // Aplica \"screen-space aware intersection point selection\".\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, kMaxSteps - i);\n}\n#endif//CFG_USING_ENHANCED_RAYMARCHING\n\n//==============================================================================\n//\tUTILIDADES\n//==============================================================================\n\n//\tCalcula el sombreado para la superficie. Para ello, traza un rayo desde la superficie hasta la luz, y determina\n//\tsi es posible llegar hasta la luz sin encontrar otra superficie antes. Si es posible llegar hasta la luz, el\n//\tpunto estará iluminado. En caso contrario, el punto estará sombreado.\n//\tAdemás, para cada paso del rayo computa la distancia mínima al objeto más cercano y utiliza ese valor para calcular\n//\tla penumbra.\n//\tMás información sobre el algoritmo en https://iquilezles.org/articles/rmshadows\n//\tEntradas:\tro   - Posición en mundo de la superficie.\n//\t\t\t\trd   - Dirección desde \"ro\" hasta la luz para la cual queremos calcular el sombreado.\n//\t\t\t\ttmin - Distancia desde \"ro\" hasta el inicio del rayo (evita arterfactos por precisión de flotante).\n//\t\t\t\ttmax - Distancia entre \"ro\" y la luz (permite descartar cuando llegamos a la luz).\n//\t\t\t\tk    - Factor de penumbra (cuanto más mayor, la sombra es más dura).\n//\tSalida: \tFactor de sombreado (0 para sombreado, 1 para iluminado, valores intermedios representan penumbra).\n#ifndef\tCFG_NO_SHADOWS\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float ph  = 1e20;\n    for( float t = tmin; t < tmax;)\n    {\n        float h = mapScene(ro + rd*t).x;\n        if( h < 0.001)\n            return 0.;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h - y*y);\n        res = min(res, k*d / max(0.0,t - y));\n        ph  = h;\n        t  += h;\n    }\n    return res;\n}\n#else\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) { return 1.0; }\n#endif//CFG_NO_SHADOWS\n\n//\tCalcula la oclusión ambiental de la superficie. Para ello, muestrea a distintas distancias desde la posición en \n//\tmundo para la superficie, y calcula la oclusión ambiental aplicando un filtro de paso bajo: los valores de\n//  distancia obtenidos más cercanos a la superficie tienen más peso, y a medida que nos alejamos tienen menos.\n//\tEl proceso que se sigue es el siguiente:\n//\t\t- Para cada iteración, calcula una posición en mundo alejada de la superficie 1/N del total de muestras.\n//\t\t- Calcula la distancia desde esa posición a la superficie más cercana.\n//\t\t- Cuanto más cercana sea esa distancia a la distancia original entre la superficie de entrada y la calculada\n//\t\t  en la iteración actual, menos oclusión hay.\n//\tEntradas:\tpos\t- Posición en mundo para la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\tSalida:\t\tFactor de oclusión (0 para totalmente ocluido, 1 para totalmente visible).\n#ifndef CFG_NO_AO\nfloat computeAO(vec3 pos, vec3 nor)\n{\n\tfloat  occ = 0.0;\n    float  sca = 1.0;\n    for( int i = 0; i < 5; ++i)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3  aopos = nor * hr + pos;\n        float dd = mapScene(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);    \n}\n#else\nfloat computeAO(vec3 pos, vec3 nor) { return 1.0; }\n#endif//CFG_NO_AO\n\n//  Calcula la normal de la superficie en \"pos\" mediante derivación del gradiente de la función de distancia.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\tSalida:\t\tVector normal de la superficie.\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(kEpsilon, 0, 0);\n\treturn normalize(vec3(mapScene(pos + epsilon.xyy).x - mapScene(pos - epsilon.xyy).x, mapScene(pos + epsilon.yxy).x - mapScene(pos - epsilon.yxy).x, \n        mapScene(pos + epsilon.yyx).x - mapScene(pos - epsilon.yyx).x));\n}\n\n//\tcomputeCameraMatrix() calcula la matriz de cámara.\n//\tEntradas:\tro - Posición de la cámara (eye).\n//\t\t\t\tta - Posición en mundo a la que mira la cámara (lookAt).\n//\t\t\t\tcr - Rotación del vector front, de 0 a 2*π radianes.\n//\tSalida:\t\tMatriz de cámara.\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n//\tMateriales, luces y colores.\nvec3[] gMaterials  = vec3[](vec3(1, 0, 0), vec3( 1, 1,.9));\nvec3[] gLightPos   = vec3[](vec3(4, 4, 4), vec3(-4, 4,-4));\nvec3[] gLightCol   = vec3[](vec3(1,.9,.5), vec3(.5,.9, 1));\nvec3   gAmbientCol = vec3(.1,.2,.3);\n\n//\tcomputeShading() calcula la iluminación con difusa de Lambert y especular de Blinn-Phong.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\t\t\t\tviewVector - Vector vista.\n//\t\t\t\tmatID      - Índice de material en gMaterials.\n//\t\t\t\tlightID    - Índice de luz en gLightPos y gLightCol.\n//  Salida:\t\tColor resultante.\nvec3 computeShading(vec3 pos, vec3 nor, vec3 viewVector, int matID, int lightID)\n{\n    //VARIABLES\n    float rough = 0.1;\n    float fres = 0.25;\n    float metalic = 0.0;    \n    \n\tvec3  col = vec3(0);\n    vec3 halfVec  = normalize(viewVector + normalize(gLightPos[lightID] - pos));\n\tcol = col + gLightCol[lightID] * gMaterials[matID] * clamp(dot(nor, normalize(gLightPos[lightID] - pos)), 0., 1.); // Cálculo de difusa.\n    //col = col + gLightCol[lightID] * gMaterials[matID] * clamp(dot(nor, -viewVector), 0., 1.); // Cálculo de difusa.\n\t//col = col + gLightCol[lightID] * pow(clamp(dot(nor, halfVec), 0., 1.), 5.); // Cálculo de especular.\n    \n\t//FRESNEL\n    //float FRESNEL = pow((fres + (1.0 - fres) * (1.0 - dot(nor,-viewVector))), 5.0); \n    float FRESNEL = fres + (1.0 - fres) * pow((1.0 - dot(viewVector, halfVec)), 5.0f);\n    \n    //G-GGX(v)  NO SE USA\n    //float roughCuadrado = pow(rough, 2.f);\n    //float NV = 2.0 * dot(nor, viewVector);\n    //float NVCuadrado = NV * NV;\n    //float G_GGX =  NV / (dot(nor, viewVector) + sqrt(roughCuadrado + (1.f - roughCuadrado) * pow(dot(nor,viewVector),2.0)));\n    \n    //G-implicit\n    float G_implicit = (dot(nor, gLightPos[lightID])) * (dot(nor,viewVector));\n    \n    //D-GGX(m)\n    float alphaPow = pow(rough,2.0); \n  \tfloat divisor = kPi * pow((((pow(dot(nor,halfVec),2.0)) * ((alphaPow - 1.0))) + 1.0),2.0); \n    float D_GGX = (alphaPow / divisor); \n    \n    /*float alphaPow = pow(rough, 2.0); \n  \tfloat divisor = kPi * pow((((pow(dot(nor,halfVec),2.0)) * ((alphaPow - 1.0))) + 1.0), 2.0); \n    float D_GGX = (alphaPow / divisor); */\n    \n    //BRDF\n    float MulFGD = (FRESNEL * G_implicit * D_GGX) / (4.f);\n    vec3 BRDF = col + gLightCol[lightID] * MulFGD;\n    \n    //return col;\n    return BRDF;\n}\n\n\n//==============================================================================\n//\tENTRYPOINT\n//==============================================================================\n\n//  Función principal.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Coordenadas UV en el rango [0,1].\n\tvec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // Coordenadas UV en el rango [0,1] con Aspect Ratio aplicado.\n    \n    vec3 pos, nor, col; // Posición, normal, color.\n    vec4 res; // Resultados del trazado de rayos.\n\n\t// Configura la cámara.\n    vec3 ro = vec3(sin(iTime * .35) * (4. + sin(iTime)), 1, cos(iTime * .35) * (3. + cos(iTime)));\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    \n    // Traza el rayo y calcula la posición en mundo de la superficie impactada.\n    res = castRay(ro, rd);\n    pos = ro + rd * res.x;    \n    \n#\tifdef   CFG_USING_DISCONTINUITY_REDUCTION\n  \t// Aplica la optimización \"discontinuity reduction\" para mejorar la adaptación del espacio esférico al de pantalla.\n    float coneSize  = tan(kPi / 6.) / (iResolution.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {\n        pos    -= rd *    (error - mapScene(pos).x);\n        error   = coneSize * length(ro  - pos);\n    }\n#\tendif//\tCFG_USING_DISCONTINUITY_REDUCTION\n\n    // Calcula la normal.\n    nor = computeNormal(pos);\n    \n    // Para cada luz, computa la iluminación y el sombreado.\n    for (int i = 0; i < gLightPos.length(); ++i)\n    {\n\t\tcol+= computeShading(pos, nor, rd, int(res.z), i) * computeSoftShadow(pos, normalize(gLightPos[i] - pos), .025, length(gLightPos[i] - pos), 25.);\n    }\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    col = col + gAmbientCol * gMaterials[int(res.z)] * mix(computeAO(pos, nor), 1., dot(col, W));\n\n#   ifdef   CFG_SHOW_WORLDPOS\n    col = pos;\n#   endif// CFG_SHOW_WORLDPOS\n\n#   ifdef   CFG_SHOW_NORMALS\n    col = nor;\n#   endif// CFG_SHOW_NORMALS\n\n#   ifdef   CFG_SHOW_STEPS\n    col = mix(vec3(0, 1, 0), vec3(1, 0, 0), res.w / float(kMaxSteps));\n#   endif// CFG_SHOW_STEPS\n\n#   ifdef   CFG_SHOW_DISTANCE\n    col = vec3(res.x / (kFarPlaneDist - kNearPlaneDist));\n#   endif// CFG_SHOW_DISTANCE\n    \n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "#ifndef CFG_NO_POSTPROD\n//\tFXAA (autor: Mudlord).\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2  p         = fragCoord.xy/iResolution.xy;\n    vec2  pp        = 1.0 / iResolution.xy;\n    vec4  color     = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3  luma      = vec3(0.299, 0.587, 0.114);\n    float lumaNW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.,-1.)) * pp).xyz, luma);\n    float lumaNE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1.,-1.)) * pp).xyz, luma);\n    float lumaSW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1., 1.)) * pp).xyz, luma);\n    float lumaSE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1., 1.)) * pp).xyz, luma);\n    float lumaM     = dot(color.xyz, luma);\n    float lumaMin   = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax   = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2  dir       = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * (1.0/8.0)), (1.0/128.0));\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0), max(vec2(-8.0, -8.0), dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1. / 3. -.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2. / 3. -.5)).xyz\n    );\n    vec3 rgbB = rgbA * 0.5 + 0.25 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir *-.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * .5).xyz\n    );\n\n    float lumaB = dot(rgbB, luma);\n    fragColor = vec4((lumaB < lumaMin) || (lumaB > lumaMax) ? rgbA : rgbB, color.w);\n}\n#else\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n#endif//CFG_NO_POSTPROD", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//==============================================================================\n//\tCONFIGURACIÓN\n//==============================================================================\n\n//\tCFG_USING_ENHANCED_RAYMARCHING utiliza una versión mejorada del algoritmo de trazado de rayos, que implementa\n//\tlas optimizaciones \"over-relaxation raymarching\" y \"screen-space aware intersection point selection\" descritas en\n//\tel paper \"Enhanced Sphere Tracing\" de Benjamin Kelinert et al. (http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf).\n\t#define CFG_USING_ENHANCED_RAYMARCHING\n\n//  CFG_USING_DISCONTINUITY_REDUCTION corrige el patrón esférico derivado de la discontinuidad entre el espacio de\n//\tpantalla (proyección 2D) y el espacio de mundo (posición del rayo y distancia a la superficie). Dicha discontinuidad\n//  aparece debido a la proyección del espacio esférico (que tiene profundidad) en el espacio de pantalla.\n//\tEl algoritmo está descrito en el mismo paper \"Enhanced Sphere Tracing\" indicado anteriormente.\n  \t#define CFG_USING_DISCONTINUITY_REDUCTION\n\n//#define CFG_SHOW_WORLDPOS\t// Descomentar para mostrar posiciones en mundo.\n//#define CFG_SHOW_NORMALS\t// Descomentar para mostrar normales.\n//#define CFG_SHOW_STEPS\t// Descomentar para mostrar pasos del Raymarcher.\n//#define CFG_SHOW_DISTANCE\t// Descomentar para mostrar distancias.\n//#define CFG_NO_SHADOWS    // Descomentar para desactivar las sombras.\n//#define CFG_NO_AO         // Descomentar para desactivar la oclusión ambiental.\n//#define CFG_NO_POSTPROD\t// Descomentar para desactivar los FX de post-producción.\n\nconst float kNearPlaneDist =   0.1;\t// Distancia al plano cercano.\nconst float kFarPlaneDist  =  50.0;\t// Distancia al plano lejano.\nconst float kEpsilon       = 0.001;\t// Valor de epsilon para comparaciones de distancia.\nconst float kPi\t\t\t   = 3.14159265359;\nconst int   kMaxSteps      =    64;\t// Número máximo de pasos del trazado de rayos.\nconst int   kMaxLightSteps =    16; // Número máximo de pasos del trazado de rayos de iluminación. ", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3sXyDr", "name": "#riff180320", "author": "nabr", "description": "bandcamp: [url]https://tolka-nabroski.bandcamp.com/track/axb[/url]", "tags": ["sound"], "likes": 31, "viewed": 594, "published": 3, "date": "1584525621", "time_retrieved": "2024-07-30T21:18:02.963737", "image_code": "// -----------------------------------------------------\n// #riff180320 by nabr\n// https://www.shadertoy.com/view/3sXyDr\n// License Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)\n// https://creativecommons.org/licenses/by-nc/4.0/\n// -----------------------------------------------------\n// -----------------------------------------------------\n// bandcamp:\n// name your price, type ZER0$ for free download\n// https://tolka-nabroski.bandcamp.com/track/axb\n// -----------------------------------------------------\n\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R = iResolution.xy;\n    vec3 col = vec3(1), d = vec3((U - .5 * R) / min(R.x, R.y), .5);\n    vec3 p = d.z / dot(vec3(0, -3, 4), -d) * d, n = p;\n    for (float t = 0.; t < 7.; ++t){\n        n = 80. * p - vec3(cos(.5 * iTime - t - n.x) + cos(t + n.y),\n                           iTime + sin(.5 * iTime + t - n.y) + cos(t - n.x), iTime);\n        n.xy = floor(cos(t) * n.xy + sin(t) * vec2(n.y, -n.x));\n    }\n    if(abs(d.x)<.45)\n    col = cos(vec3(0, 1, 1.57) + dot(vec3(-3, 6, 18), .05 * n)) * .35 + .5;\n    O.xyz = .2 * float(int(U) & 2 - int(U.y) & 2)\n            * smoothstep(10. / min(R.x, R.y), 0., .25 - length(d.xy * d.xy)) \n        \t+ (dot(vec3(.435, .25, .74), col) * vec3(col));\n}", "image_inputs": [], "sound_code": "// -----------------------------------------------------\n// #riff180320 by nabr\n// https://www.shadertoy.com/view/3sXyDr\n// License Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)\n// https://creativecommons.org/licenses/by-nc/4.0/\n// -----------------------------------------------------\n// -----------------------------------------------------\n// bandcamp:\n// name your price, type ZER0$ for free download\n// https://tolka-nabroski.bandcamp.com/track/axb\n// -----------------------------------------------------\n\n\n#define tau 4.*acos(0.)\n#define dB(_x) pow(10.,float(_x)/20.)\nfloat intfract(int s,float n);\n\nfloat rnd(float t)\n{\n    float x = t * 5623.123456;\n    return fract(x * fract(t + x));\n}\n\nvec2 drums(float t)\n{\n    // kick\n    float ft = fract(2. * t);\n    float dr = .2 * sin(471. * ft * exp(-ft * 5.))\n             + .6 * sin(691. * ft * exp(-ft * 2.));\n    // avoid click quadratic envelope\n    float a = min(sqrt(sqrt(1. - ft)), 25. * ft);\n    dr *= (a*a*a*a); //pow(a, 4.);\n\n    dr *= float(int[](1, 0, 0, 1, 1, 0, 0, 0)[int(2. * t) % 8]);\n\n    // snare\n    float s = rnd(t) +\n              (.5 * sin(tau * t * 240.)\n                         + sin(tau * t * 300.)) * exp(-ft * 3.);\n    s *= float(int[](0, 0, 1, 0)[int(2. * t) % 4]);\n    // attack decay\n    s *= atan(1. - ft, 100. * ft);\n\n    return .4 * vec2(s, .8 * s) + .5 * dr;\n}\n\nfloat eflute(float t)\n{\n    t = mod(t, 4.);\n    float m0 = 0., m1 = 0.;\n    float p[] = float[](554., 834., 834., 693.);\n\n    float ap = p[int(t) % 4];\n\n    m0 = abs(.125 - cos(.25 * sin(2. * ap * t * tau) + sin(ap * t * tau)));\n    m0 *= min(1., 25. * fract(4. * t)) * max(0., 1. - fract(4. * t));\n\n    m1 = .5 * (sin(ap * t * tau) + sin(2. * ap * t * tau));\n    return m1 + m0;\n}\n\nfloat synth(float hz, int samp)\n{\n    float y = 0., w = 0., a = 0., b = 0., s0 = 0., s1 = 0.;\n\n    s0 = sin(tau * intfract(samp, iSampleRate / hz));\n\n    s1 = s0 * sin(tau * intfract(samp, iSampleRate / (2. * hz)));\n\n    // playing around with one pole filter\n    w = tau * clamp(.5 * s1 + sin(s0 * 12. ), -.1, .4);\n    a = (1. - sin(w)) / cos(w);\n    b = (1. + a) * .5;\n    y = (b * s0 + a * s0);\n\n    return y;\n}\n\nvec2 mSound(int samp)\n{\n\n    //drums and melody work w/ usual float precision err, it's ok.\n    float t = (float(samp) / iSampleRate);\n\n    // -------- MELODY\n    float mld = eflute(t);\n    vec2 rev=vec2(1);\n    /*float sum=0.,amp=1.,ivR=0.008376;\n    for(float _ii=0.;(_ii<=1.);_ii+=ivR){ //120\n        float rvrnd=fract(120.*sin(_ii*1000.));\n        amp=exp2(-_ii*((ivR+_ii)+rvrnd));\n        rev+=(vec2(eflute(t+6.225*amp),eflute(t+3.5*amp)));\n        sum+=amp;\n    };rev/=sum;*/\n    //song works with less delay on the instrument\n    //updated on 12.05.2020 in favor of size&speed\n    float[12]ha=float[](.99926,.95837,1.00841,.82124,.86099,1.04333,.71246,.53604,.98669,.43196,.44877,.74675);\n    for(int j=0;j<2;++j)\n    for(int i=0;i<12;++i)\n    rev+=vec2(eflute(t+6.225*ha[i]),eflute(t+3.5*ha[i]));\n    rev*=.042;\n    // -------- DRUMS\n    vec2 dr = drums(t);\n    if(samp > 44100*45)\n        dr += drums(.25 + t);\n\n    // -------- SYNTH\n    vec2 v = vec2(0);\n    int nd = 0, nl = 0;\n\n    int x[] = int[](0, 0, 0, 138, 0, 0,0, 78, 0, 0, 175, 0,0, 0, 0, 0, 174, 0,261, 279, 0, 0, 554,0, 0, 0, 313, 69, 0,0, 349, 0, 0, 0, 234, 0, 415, 0, 0, 207, 0,0, 0, 0, 0, 0, 558);\n    x[0] = int[](349, 311)[int(t*.125) % 2];\n    x[12] = int[](92, 116, 138, 58)[int(t*.25) % 4];\n    x[45] = 2*x[12];\n\n    // delay time\n    int dt[]= int[](2971, 823, 607, 523, 457);\n\n    for (int i = 1; i <=x.length(); ++i)\n    {\n        if(samp > 44100*40)\n            nd =  abs(int(t*4.)%8-i/10);\n\n        nl = (i-nd)%x.length();\n\n        v.x += (synth(float(x[nl]), (dt[i%4]*2 ) + samp));\n        v.y += (synth(float(x[nl]), (dt[i%3]/2 ) + samp));\n\n    };\n    v*= (1./float(x.length()));\n\n    // fade in\n    v *= min(1., t/20.);\n\n    // stereo image l/r pan\n    const float angle = .436332;\n    const float sqh2 =  .707106;\n    vec2 r = vec2(cos(angle) + sin(angle), cos(angle) - sin(angle)) * v.x * sqh2;\n    vec2 l = vec2(cos(angle) - sin(angle), cos(angle) + sin(angle)) * v.y * sqh2;\n\n    // -------- out\n    if (samp > 44100 * 60)\n    return dB(-5) * vec2(r.x + l.x, l.y + r.y)\n         + dB(-5.) * dr\n         + dB(-12) * (dB(-5) * rev + dB(-8) * mld);\n\n    return dB(-4.6) * vec2(r.x + l.x, l.y + r.y)\n         + dB(-3) * dr;\n}\n\nfloat intfract(int s,float n)\n{\n    //Explanation and copyright : shadertoy.com/view/4ltfRN\n    int sn=int(n),a=s%sn,b=(s/sn);\n    const float MAXF=float(uint(-1))+1.;\n    return fract((float(a)/n)+float((uint(b)*uint(MAXF*float(sn)/n)))/MAXF);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    // see ttg comment 2020-12-10\n    //int block = int((iBlockOffset+0.5)*iSampleRate/(512.*512.));\n    //int s = 512*512*block + 512*int(gl_FragCoord.y) + int(gl_FragCoord.x);\n    return mSound(samp);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyDr.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[543, 543, 582, 582, 1279]], "test": "untested"}
{"id": "ttyXRy", "name": "Testing The Mandelbrot Set", "author": "abhinavneelam", "description": "trying to create the Mandelbrot Set", "tags": ["mandelbrot"], "likes": 1, "viewed": 274, "published": 3, "date": "1584513728", "time_retrieved": "2024-07-30T21:18:03.718718", "image_code": "#define COLOR_RED vec4(1.0f,0.0f,0.0f,1.0f)\n#define COLOR_GREEN vec4(0.0f,1.0f,0.0f,1.0f)\n#define COLOR_BLUE vec4(0.0f,0.0f,1.0f,1.0f)\n\n#define COLOR_YELLOW vec4(1.0f,1.0f,0.0f,1.0f)\n#define COLOR_LBLUE vec4(0.0f,1.0f,1.0f,1.0f)\n#define COLOR_PINK vec4(1.0f,0.0f,1.0f,1.0f)\n\n#define COLOR_BLACK vec4(0.0f,0.0f,0.0f,1.0f)\n#define COLOR_WHITE vec4(1.0f,1.0f,1.0f,1.0f)\n\n#define W iResolution.x\n#define H iResolution.y\n#define WH iResolution.xy\n\nvec4 out_color;\nvec2 in_coord;\n\nconst int iter_c = 80;\n\nconst vec4 background = COLOR_BLACK;\n\nvoid drawRect(in vec2 pos, in vec4 color, in vec2 size)\n{\n    if(in_coord.x >= pos.x && (in_coord.x) <= pos.x + size.x && in_coord.y >= pos.y && (in_coord.y) < pos.y + size.y)\n        out_color = color;\n}\n\nvec2 multiplyComplex(vec2 a, vec2 b)\n{\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec4 pipeColor(float value)\n{\n\t//0.25,0.50,0.75,1.0f\n\tvec4 ret = COLOR_BLACK;\n    \n    ret = vec4(value);\n    \n    ret.y=0.0f;\n    ret.z=0.0f;\n        \n    return ret;\n    \n    if(value > 0.75f)\n    {\n        value -= 0.75f;\n        \n      \tret = vec4(1.0f, 1.0f, value, 1.0f);\n    }else if(value > 0.5f)\n    {\n     \tvalue -= 0.5f;\n        \n        ret = vec4(1.0f, value, 0.0f, 1.0f);\n    }else if(value > 0.25f)\n    {\n     \tvalue -= 0.25f;\n        \n        ret = vec4(value, 0.0f, 0.0f, 1.0f);\n    }\n    \n    //ret=vec4(1.0f)-ret;\n    return ret;\n}\n\nfloat convertWindowToLinearCoord(float x, float y, float norm)\n{\n    float length = distance(x,y);\n    \n    return norm * length + x;\n}\n\nfloat invert(float t)\n{\n \treturn 1.0f/t;   \n}\n\nfloat lockdown(float x, float c)\n{\n    return -5.0f * pow(0.5,x) + c;\n}\n\nfloat slowdown(float x)\n{\n \treturn 16.0 + 2.0f * log(x);\n}\n\nvoid drawMandelBrot()\n{\n\tvec2 norm_coord = (in_coord.xy/WH - vec2(0.5)) * vec2(2.0f);\n    \n    float scalingFactor = 0.05f;\n    \n    vec4 vp = vec4(-2,1,-1,1);\n    vec2 point = vec2(-0.75,-0.1);\n    \n    point=vec2(-0.761574,-0.0847596);\n    point=vec2(0.42884,-0.231345);\n    \n    vec4 vpnorm = vec4(distance(point.x,vp.x), distance(point.x,vp.y),\n                       distance(point.y,vp.z),distance(point.y,vp.w));\n\n    vec4 ratios = vpnorm;\n    \n    //debugging\n    float fakeTime = 20.0f;\n    fakeTime = slowdown(iTime);\n    \n    ratios = ratios * (scalingFactor * fakeTime);    \n    \n    vp = vec4(vp.x + ratios.x, vp.y - ratios.y, vp.z + ratios.z, vp.w - ratios.w);\n    \n    if(vp.x > point.x)\n        vp.x=lockdown(vp.x, point.x);\n    \n    if(vp.y < point.x)\n        vp.y=lockdown(vp.y, point.x);\n    \n    if(vp.z > point.y)\n        vp.z=lockdown(vp.z, point.y);\n    \n    if(vp.w < point.y)\n        vp.w=lockdown(vp.w, point.y);\n    \n    norm_coord.x = convertWindowToLinearCoord(vp.x, vp.y, in_coord.x/W);\n    norm_coord.y = convertWindowToLinearCoord(vp.z, vp.w, in_coord.y/H);\n    \n    float scalar = 3.0f;\n    \n    vec2 value = vec2(0);\n    int index=0;\n    for(int i=0;i<iter_c;++i)\n    {\n        value = multiplyComplex(value,value) + norm_coord;\n        \n        if(length(value) > 2.0f)\n        {\n            out_color = COLOR_WHITE * pipeColor(float(i)/float(iter_c));\n            return;\n        }\n        index=i;\n    }\n    out_color = COLOR_BLACK;\n}\n\nvoid drawMain()\n{\n\tdrawMandelBrot();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    in_coord = fragCoord-vec2(0.5);\n    drawMain();\n    fragColor = out_color;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 537, 594, 594, 741], [743, 743, 781, 781, 843], [845, 845, 874, 897, 1395], [1397, 1397, 1461, 1461, 1532], [1534, 1534, 1557, 1557, 1579], [1581, 1581, 1615, 1615, 1652], [1654, 1654, 1679, 1679, 1712], [1714, 1714, 1737, 1737, 3185], [3187, 3187, 3204, 3204, 3225], [3227, 3227, 3284, 3284, 3365]], "test": "untested"}
{"id": "3sfcDn", "name": "just a reflection", "author": "scry", "description": "spin off of https://www.shadertoy.com/view/wdXcz7\nWatch until 120 seconds at least! :) Beyond that it will just reverse loop, line 10 determines when it loops\nTrippy!", "tags": ["reflexion", "sphere", "fog", "reproduction"], "likes": 4, "viewed": 489, "published": 3, "date": "1584506202", "time_retrieved": "2024-07-30T21:18:04.867646", "image_code": "// Created by David Gallardo - xjorma/2020\n// Modified by scry\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n#define loop 120.\n#define mTime abs(mod(iTime+loop,loop*2.)-loop)\n#define iTime mTime*mTime*0.005\nconst float period = 21.;\nconst float scale = 0.;\n\nfloat alt(vec3 p)\n{\n    return (sin(p.x / period) + sin(p.z / period)) * scale;\n}\n\n\nfloat rand(vec3 n)\n{ \n    return fract(sin(dot(n, vec3(12.9898, 4.1414,14.6313))) * 43758.5453);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 p)\n{\n    //float ud = 12.45;\n    float ud = 3.8;\n    ud += sin(iTime*2.9)*0.006;\n    ud *= sin(((iTime+19.5)*0.01)-0.1);\n    vec3 v = vec3(ud,ud,ud);\n    vec3 i = floor((p + v / 2.) / v );\n    vec3 o = vec3(0, alt(i), 0);\n    vec3 q = mod(p + o + v / 2., v) - v / 2.0;\n    float r = step(abs(i.y), 15.5);\n    return sdSphere(q, r * 1.1);\n}\n\n\n#define EPS  0.001\n\nvec3 calcNormal(vec3 pos)\n{\n\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, out float t, out float d, in float maxd)\n{\n    t = 0.;\n    d = 0.;\n    vec3 cp = ro;\n    for(int i=0;i<200;++i)\n    {\n        d = map(cp);\n        t += d;\n        cp = ro+rd*t;\n        if (d < .001 || d > maxd || abs(cp.y) > 35.)\n            break;\n    }\n}\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 c1 = mix(vec3(0.), vec3(0,0,1), (sign(rd.y) + 1.) / 2.); \n    vec3 c2 = mix(vec3(1), c1, abs(rd.y));\n    return c2; \n}\n\nvec3 lastRecur(vec3 ro,vec3 rd)\n{\n    return getSkyColor(ro);\n}\n\n#define GEN_RENDER(NAME,DIST,RECUR) \t\t\t\t\t\t\t\t\t\t\\\nvec3 NAME(vec3 ro,vec3 rd)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    float\tt,d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    rayMarch(ro, rd, t, d, DIST);\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 p = ro + rd * t;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 n = calcNormal(p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    if (d < .001)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        float fresnel = 1. - dot(n, -rd);\t\t\t\t\t\t\t\t\t\\\n        /*vec3 d = mix(vec3(1), vec3(0.82, 0.45, 0.20), fresnel);*/\t\t\t\\\n        vec3 d = mix(vec3(1), vec3(sin((iTime+48.)*0.01)*0.9, cos((iTime)*0.06)*0.6, sin((iTime+32.)*0.008)*0.9), fresnel);\t\t\t\t\\\n        vec3 ref = reflect(rd, n);\t\t\t\t\t\t\t\t\t\t\t\\\n        color = d * RECUR(p + ref * 0.4 , ref);\t\t\t\t\t\t\t\t\\\n        color = applyFog(color, t / DIST, getSkyColor(rd));\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        color = getSkyColor(rd);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    return color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\nGEN_RENDER(render4,  1., lastRecur)\nGEN_RENDER(render3,  1., render4)\nGEN_RENDER(render2,  1., render3)\nGEN_RENDER(render1, 15., render2)\nGEN_RENDER(render , 50., render1)\n    \nmat3 buildLookAtMatrix( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    mat3 ma = buildLookAtMatrix(vec3(0), vec3(0,1,-1));\n    \n\tro.y+=iTime;\n\t\n    fragColor = vec4(render(ma*ro/3.,ma*rd) ,1);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    \n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA        \n        //float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        //float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) + radians(90.);\n        //float theta\t= radians(30.);\n        //float phi\t= radians(90.);\n        float theta\t= radians(30.+iTime*0.009);\n        float phi\t= radians(90.+iTime*0.011);\n        //vec3 ro = 2.7*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ro = iTime*0.5*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3(0, -0.2, 0);\n        mat3 ca = buildLookAtMatrix( ro, ta );\n\t\t\n        vec3 rd =  ca*normalize(vec3(p,2.0));\n        \n        //ro.z +=iTime*0.1;\n        //ro.x += 5.+iTime;  \n\n        \n        vec3 col = render(ro ,rd);\n\t\tvec2 uv = fragCoord.xy/iResolution.xy;\n        vec3 ran = vec3(rand(vec3(rand(uv.xyy),rand(uv.xyx+10.4),iTime)));\n        vec3 ccol = col;\n        col -= 0.75;\n        col *= 11.5;\n        col += 20.95;\n        col *= 0.21;\n        col = mod(col,0.5);\n        //col -= 0.5;\n        col *= 1.5;\n        col = mix(col,ccol,0.3);\n        //col = (ran*0.6)-(col*0.03);\n        //col = mix(col,ran,0.9);\n        //col += rand(uv.xyx+iTime)*0.4;\n        //if (abs(sin((iTime*0.02)+0.1)) > uv.x) {col.r = 1.;}\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.3);\n    \n\tfragColor = vec4( pow(tot, vec3(1.5)), 1.0 );    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcDn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[329, 329, 348, 348, 410], [413, 413, 433, 433, 511], [513, 513, 548, 548, 572], [574, 574, 593, 617, 928], [951, 951, 978, 978, 1142], [1144, 1144, 1218, 1218, 1432], [1434, 1434, 1489, 1489, 1585], [1587, 1587, 1614, 1614, 1742], [1744, 1744, 1777, 1777, 1807], [2955, 2955, 3005, 3005, 3169], [3171, 3171, 3215, 3215, 3314], [3316, 3316, 3356, 3356, 3426], [3428, 3428, 3506, 3506, 3634]], "test": "untested"}
{"id": "3sXyDn", "name": "isolator", "author": "lennyjpg", "description": "fafasddfasdfa", "tags": ["asfasfas"], "likes": 1, "viewed": 268, "published": 3, "date": "1584504644", "time_retrieved": "2024-07-30T21:18:05.731337", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -.9 * (fragCoord - .5* iResolution.xy ) /iResolution.x;    \n    float t = iTime * 0.7;\n    float r = fract(t*2.0);    \n    bool s = fract(t) > 0.5;\n    float k = s ? uv.x : uv.y;\n    k -= r - 0.5;\n    if(k > 0.0){\n        discard;\n    }\n    // k = sin(k*2.0);\n    k = fract(k*7.0)*1.2;\n    k = ceil(k-0.7);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 405]], "test": "untested"}
{"id": "wdXcz7", "name": "wavy sphere", "author": "xjorma", "description": "Inspired by https://www.facebook.com/pages/category/Artist/FrenerDesign-1884642275082005/", "tags": ["reflexion", "sphere", "fog", "reproduction", "cineshader"], "likes": 9, "viewed": 9376, "published": 3, "date": "1584486812", "time_retrieved": "2024-07-30T21:18:06.573086", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define NO_UNROLL_ZERO min(0, iFrame)\n\nconst float period = 10.;\nconst float scale = 5.;\n\nfloat alt(vec3 p)\n{\n    return (sin(p.x / period) + sin(p.z / period)) * scale;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 p)\n{\n    vec3 v = vec3(3,22,3);\n    vec3 i = floor((p + v / 2.) / v );\n    vec3 o = vec3(0, alt(i), 0);\n    vec3 q = mod(p + o + v / 2., v) - v / 2.0;\n    float r = step(abs(i.y), 1.5);\n    return sdSphere(q, r * 1.1);\n}\n\n\n#define EPS  0.001\n\nvec3 calcNormal(vec3 pos)\n{\n\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, out float t, out float d, in float maxd)\n{\n    t = 0.;\n    d = 0.;\n    vec3 cp = ro;\n    for(int i=0;i<200;++i)\n    {\n        d = map(cp);\n        t += d;\n        cp = ro+rd*t;\n        if (d < .001 || d > maxd || abs(cp.y) > 35.)\n            break;\n    }\n}\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 c1 = mix(vec3(0.), vec3(0,0,1), (sign(rd.y) + 1.) / 2.); \n    vec3 c2 = mix(vec3(1), c1, abs(rd.y));\n    return c2; \n}\n\nvec3 lastRecur(vec3 ro,vec3 rd)\n{\n    return getSkyColor(rd);\n}\n\n#define GEN_RENDER(NAME,DIST,RECUR) \t\t\t\t\t\t\t\t\t\t\\\nvec3 NAME(vec3 ro,vec3 rd)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    float\tt,d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    rayMarch(ro, rd, t, d, DIST);\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 p = ro + rd * t;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 n = calcNormal(p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    if (d < .001)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\t\t\t\t\t\\\n        vec3 d = mix(vec3(1), vec3(0.82, 0.45, 0.20), fresnel);\t\t\t\t\\\n        vec3 ref = reflect(rd, n);\t\t\t\t\t\t\t\t\t\t\t\\\n        color = d * RECUR(p + ref * 0.4 , ref);\t\t\t\t\t\t\t\t\\\n        color = applyFog(color, t / DIST, getSkyColor(rd));\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        color = getSkyColor(rd);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    return color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\nGEN_RENDER(render4,  1., lastRecur)\nGEN_RENDER(render3,  1., render4)\nGEN_RENDER(render2,  1., render3)\nGEN_RENDER(render1, 15., render2)\nGEN_RENDER(render , 50., render1)\n    \nmat3 buildLookAtMatrix( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    mat3 ma = buildLookAtMatrix(vec3(0), vec3(0,1,-1));\n    \n\tro.y+=iTime;\n\t\n    fragColor = vec4(render(ma*ro/3.,ma*rd) ,1);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    \n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n = NO_UNROLL_ZERO; n < 4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA        \n        //float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        //float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) + radians(90.);\n        float theta\t= radians(30.);\n        float phi\t= radians(90.);\n        vec3 ro = 2.7*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3(0, -0.2, 0);\n        mat3 ca = buildLookAtMatrix( ro, ta );\n\t\t\n        vec3 rd =  ca*normalize(vec3(p,2.0));\n        \n        ro.z +=iTime*4.;\n        ro.x += 5.;  \n\n        \n        vec3 col = render(ro ,rd);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.3);\n    \n\tfragColor = vec4( pow(tot, vec3(1.5)), 1.0 );    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXcz7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[251, 251, 270, 270, 332], [334, 334, 369, 369, 393], [395, 395, 414, 414, 630], [653, 653, 680, 680, 844], [846, 846, 920, 920, 1134], [1136, 1136, 1191, 1191, 1287], [1289, 1289, 1316, 1316, 1444], [1446, 1446, 1479, 1479, 1509], [2536, 2536, 2586, 2586, 2750], [2752, 2752, 2796, 2796, 2895], [2897, 2897, 2937, 2937, 3007], [3009, 3009, 3087, 3087, 3215]], "test": "untested"}
{"id": "tdlczM", "name": "Metagrid", "author": "haptix", "description": "Playing with an updated marching/lighting setup", "tags": ["raymarching"], "likes": 3, "viewed": 273, "published": 3, "date": "1584479828", "time_retrieved": "2024-07-30T21:18:07.474675", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat3 rotateY(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n    );\n}\n\nmat3 rotateZ(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, s, 0.,\n        -s, c, 0.,\n        0., 0., 1.\n    );\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat map(vec3 p)\n{   \n   \tp = rotateZ(.15 * iTime) * rotateY(.17 * iTime) * p;\n    p += -.4 * vec3(cos(abs(p.x)*15. + 1.3*iTime),\n                    sin(p.y*15. + iTime),\n                    cos(abs(p.z)*15. + 1.5*iTime) * sin(p.x*p.y*12. + 1.7*iTime) * 2.2);\n    float m = sphere(p, .4*sin(.43*iTime) + .6);\n    glo += .18 / (.18 + m*m);\n    return m;\n}\n\nfloat tr(vec3 ro, vec3 rd)\n{\n\tfloat  h,t = .1;\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t) * .1;\n\t\tif(h < .001 || t > 120.)\n\t\t\tbreak;\n\t\tt += h;\n  \t}\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(0., 0., -2.5);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(-2., -2., -15.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .05);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tfloat t = tr(ro, rd);\n\n    vec3 colRot = sin(vec3(.151, .227, .317) * iTime) + 1.2;\n    \n    if (t < 120.)\n    {\n        vec3 hit = ro + rd*t;\n        vec3 lightDir = normalize(lightPos - hit);\n        \n        vec3 norm = normalize(map(hit) - vec3(map(hit - eps.yxx),\n                              map(hit - eps.xyx),\n                              map(hit - eps.xxy)));\n        \n        \n        float diff = max(.2, dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 50.);\n        float ao = clamp(map(t + norm*.5) / .5, 0., 1.);\n\n        vec3 col =  .2*colRot * .2*ao;\n        col += .3 * diff * colRot.yzx;\n        col += .5 * spec * vec3(1., 1., 1.);\n\n        col += glo*.0105 * colRot.yxz;\n        fragColor = vec4(col, 1.);        \n    }\n    else\n    \tfragColor = vec4(glo*.0105*colRot.yzx, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 64, 64, 194], [196, 196, 221, 221, 351], [353, 353, 391, 391, 426], [428, 428, 447, 447, 784], [786, 786, 814, 814, 957], [959, 959, 1016, 1016, 2343]], "test": "untested"}
{"id": "wssyz7", "name": "Voronoi edge tracking", "author": "michael0884", "description": "Tracking 4 closest particles and the 2 side particles which make a voronoi edge. Allows for advanced voronoi stuff: interpolation and physics.", "tags": ["particles"], "likes": 9, "viewed": 496, "published": 3, "date": "1584477888", "time_retrieved": "2024-07-30T21:18:08.407182", "image_code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-17 19:00:53\n\n\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 grad(ivec2 p)\n{\n    ivec4 sp = get(p);\n    ivec4 spx = get(p+ivec2(1,0));\n    ivec4 spy = get(p+ivec2(0,1));\n    return tanh(100.*(abs(vec4(spx - sp)) + abs(vec4(spy - sp))));\n}\n\nivec2 getve(ivec2 p)\n{\n    return floatBitsToInt(texel(ch2, p).xy);\n}\n\nfloat edge_distance(vec2 spos, vec2 pos)\n{\n    ivec2 p = ivec2(spos);\n    ivec4 sp = get(p);\n   \n    vec4 p0 = getParticle(sp.x);\n    vec4 p1 = getParticle(sp.y);\n\n    ivec2 ve = getve(p);//edge side particles\n    vec4 pe0 = getParticle(ve.x);\n    vec4 pe1 = getParticle(ve.y);\n    \n    vec2 edge0 = circumcenter(p0.xy, p1.xy, pe0.xy);\n    vec2 edge1 = circumcenter(p0.xy, p1.xy, pe1.xy);\n   \n    return (!any(equal(ivec2(-1), ve)))?sdSegment(pos, edge0, edge1):1e10;\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{   \n    float i0 = gauss(edge_distance(iMouse.xy, pos), prad);\n    float i = gauss(edge_distance(pos, pos), prad/5.);\n    ivec4 sp = get(ivec2(pos));\n    \n    col.xyz = 1.5*(sin(2.*vec3(3,2,1)*i0 + i*vec3(1,2,3))) + (0.5+ 0.5*sin(vec3(3,4,5)*float(sp.x))); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nfloat F(float d)\n{\n    return 0.;\n}\n\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    return normalize(p1-p0)*F(distance(p1,p0));\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n        \n        vec2 F = vec2(0.);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F = normalize(iMouse.xy - U.xy)/(d+2.);\n        }\n        \n        U.zw += dt*F;\n        U.xy += U.zw*dt;\n        \n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(10,10)\n#define dt 0.05\n#define prad 5.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(fake, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}\n\nvec2 circumcenter(vec2 x, vec2 y, vec2 z)\n{\n    vec2 xy = y - x;\n    vec2 xz = z - x;\n    vec2 a = 0.5*(x+y);\n    vec2 b = 0.5*(x+z);\n    vec2 d = vec2(dot(xy,a), dot(xz,b));\n    float det = determinant(mat2(xy, xz));\n    return vec2(determinant(mat2(d.x, xy.y, d.y, xz.y)),determinant(mat2(xy.x, d.x, xz.x, d.y)))/det;\n}", "buffer_b_code": "//4th order voronoi diagram \n\nivec4 u; //ids\nvec4 d; //distances\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+0.5;\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        //insert\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        //insert\n        d = vec4(d.x, dtemp, d.yz);\n        u = ivec4(u.x, utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        //insert\n        d = vec4(d.xy, dtemp, d.z);\n        u = ivec4(u.xy, utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        //insert\n        d = vec4(d.xyz, dtemp);\n        u = ivec4(u.xyz, utemp);\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(t.x, p);\n    sort(t.y, p);\n    sort(t.z, p);\n    sort(t.w, p);\n}\n\nvoid randupd(ivec2 p)\n{\n    for(int i = 0; i < 4; i++)\n    {\n    \t//go through the entire array sudorandomly\n    \tint t = ((iFrame + p.x + p.y*int(iResolution.x))^(1<<(3*i)))%tot_n;\n    \tsort(t, p);    \n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 3);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //particle indecies \n    u = ivec4(1);\n    d = vec4(1e10); \n   \n    update(p);\n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//voronoi edge tracking\n\n//neighbors \nvec4 nbxy; //positions\nivec2 nbu; //ids\n\n//side particles\nvec2 d;\nivec2 u;\nvec2 data; //track data on the edge points, use the voronoi diagram as a mesh for example idk\n\nbool isSame(ivec3 a, ivec3 b) //is the id triplet the same\n{\n    return any(equal(a.xxx,b)) && any(equal(a.yyy,b)) && any(equal(a.zzz,b));\n}\n\nbool isEdgeParticle(int id, vec2 pxy)\n{\n    //edge point guess\n    vec2 cc = circumcenter(nbxy.xy, nbxy.zw, pxy);\n    //check the voronoi diagram at the guess\n    if(cc.x < 0. || cc.y < 0. || cc.x > size.x || cc.y > size.y) return false;\n    ivec4 t = get(ivec2(cc));\n    //the first 3 closest particles at the edge point pretty much always are the particles that produce the edge\n    return isSame(t.xyz, ivec3(nbu.xy, id));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nivec2 getve(ivec2 p)\n{\n    return floatBitsToInt(texel(ch2, p).xy);\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p);\n    if(any(equal(ivec2(utemp),nbu))) return; //if particle is in the edge pair\n    vec4 partic = getParticle(utemp);\n    float dtemp = distance(partic.xy, pos);\n    if(isEdgeParticle(utemp, partic.xy))\n    {\n        //sorting\n        if(d.x >= dtemp)\n        {\n            if(d.x == dtemp) return;\n            //insert\n            d = vec2(dtemp, d.x);\n            u = ivec2(utemp, u.x);\n        }\n        else if(d.y >= dtemp)\n        {\n            if(d.y == dtemp) return;\n            //insert\n            d = vec2(d.x, dtemp);\n            u = ivec2(u.x, utemp);\n        }   \n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(t.x, p);\n    sort(t.y, p);\n    sort(t.z, p);\n    sort(t.w, p);\n    ivec2 tt = getve(p+dx);\n    sort(tt.x, p);\n    sort(tt.y, p);\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 3);\n    updrad(p, 5);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //particle indecies \n    u = ivec2(-1);\n    d = vec2(1e10); \n   \n    ivec4 t = get(p);\n    nbu = t.xy; //edge pair\n    nbxy = vec4(getParticle(t.x).xy,getParticle(t.y).xy);\n    \n    update(p);\n    \n    U = vec4(intBitsToFloat(u), data);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 141, 141, 176], [178, 178, 218, 218, 264], [266, 266, 297, 297, 331], [333, 333, 385, 385, 504], [506, 506, 526, 526, 688], [690, 690, 712, 712, 759], [761, 761, 803, 803, 1230], [1232, 1232, 1277, 1277, 1536]], "test": "untested"}
{"id": "3slyz7", "name": "Mountains somewhere in space", "author": "artemvang", "description": "Just mountains", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "mountains"], "likes": 4, "viewed": 323, "published": 3, "date": "1584474715", "time_retrieved": "2024-07-30T21:18:09.282841", "image_code": "const int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.00001;\n\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    float a = random(i + vec2(0,0));\n    float b = random(i + vec2(1,0));\n    float c = random(i + vec2(0,1));\n    float d = random(i + vec2(1,1));\n\n    return a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y;\n}\n\nfloat fbm(vec2 st, int octaves) {\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for (int i=0; i<octaves; i++) {\n        float n = noise(st);\n        a += b*n;\n        b *= s;\n        st *= f;\n    }\n\treturn a;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    return samplePoint.y + fbm(samplePoint.xz, 6);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float dist = 0.001;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + dist * marchingDirection;\n        float d = sceneSDF(pos);\n        if (d < EPSILON) {\n            break;\n        }\n        \n        dist += d*0.4;\n        \n        if (dist >= MAX_DIST) {\n            dist = MAX_DIST;\n            break;\n        }\n    }\n    \n    return dist;\n}\n\n\nfloat softShadow(vec3 eye, vec3 marchingDirection, float max_dist, float w) {\n    float dist = 0.001;\n    float s = 1.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + dist * marchingDirection;\n        float d = sceneSDF(pos);\n        s = min( s, 0.5+0.5*d/(w*dist) );\n        if( s < 0.0 ) break;\n        dist += d*0.4;   \n    }\n    \n    s = max(s,0.0);\n    \n    return s*s*(3.0-2.0*s);\n}\n   \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    const float h = 0.0001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1)) - 1.0);\n        n += e * sceneSDF(p + e * h);\n    }\n    return normalize(n);\n}\n\n\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n\nvec3 phongIllumination(vec3 eye, vec3 worldDir, float dist) {\n    const vec3 ambientLight = vec3(0.5);\n    vec3 color = ambientLight * 0.2;\n    \n    vec3 diffuseColor = vec3(41., 31., 2.) / 255.;\n    \n\tconst vec3 lightPos = vec3(-10000.0, 10000.0, 0.0);\n    const float lightIntensity = 0.6;\n    \n    vec3 p = eye + worldDir * dist;\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    \n    float dotLN = dot(L, N);\n    \n    if (dotLN < 0.0) {\n        return color;\n    }\n    \n    diffuseColor = mix(vec3(0.8), diffuseColor, max(N.y, 0.0));\n    \n    float top = sigmoid((p.y + 0.4) * 20.);\n    diffuseColor = mix(diffuseColor, vec3(1.5), top);\n    \n    float shadowMul = softShadow(lightPos, normalize(p - lightPos), length(lightPos - p), .5);\n    color = mix(lightIntensity * (diffuseColor * dotLN), color, shadowMul);\n    return color;\n}\n\nvec3 applyFog(vec3 rgb, vec3 rayOri, vec3 rayDir, float dist) {\n    float fogAmount = 1.0-exp(-dist * .03);\n    vec3  fogColor  = vec3(0.7,0.7,0.65);\n    vec3 foggedColor = mix(rgb, fogColor, fogAmount);\n    \n    float y_dist = max((rayOri + rayDir * dist).y + 1.0, 0.);\n    fogAmount = exp(-y_dist * 5. );\n    foggedColor = mix(foggedColor, vec3(0.7,0.7,0.7), fogAmount);\n    \n    return foggedColor;\n}\n\n\nmat3 viewMatrix(vec3 eye, vec3 lookAt, vec3 up) {\n    vec3 f = normalize(lookAt);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse;\n    if(length(iMouse.xy) >= 1.0) mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.xy;\n    else mouse = vec2(0.0);\n    \n\tvec3 viewDir = rayDirection(90.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, .1, iTime * 0.5);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(mouse.x * 3.14 * 4., mouse.y * 3.14 * 4., -1.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = normalize(viewToWorld * viewDir);\n    \n    float dist = shortestDistanceToSurface(eye, worldDir);\n    \n    if (dist >= MAX_DIST - EPSILON) {\n        fragColor = vec4(.7, .7, .65, 1.);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 color = phongIllumination(eye, worldDir, dist);\n    \n    //color = applyFog(color, eye, worldDir, dist);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 150, 150, 223], [226, 226, 248, 248, 573], [575, 575, 608, 608, 819], [822, 822, 856, 856, 909], [912, 912, 979, 979, 1355], [1358, 1358, 1435, 1435, 1776], [1782, 1782, 1847, 1847, 1979], [1982, 1982, 2011, 2011, 2305], [2308, 2308, 2332, 2332, 2368], [2371, 2371, 2432, 2432, 3236], [3238, 3238, 3301, 3301, 3641], [3644, 3644, 3693, 3693, 3818], [3820, 3820, 3877, 3877, 4672]], "test": "untested"}
{"id": "tdlcR7", "name": "Day 89", "author": "jeyko", "description": "poto", "tags": ["mdmtjvm"], "likes": 7, "viewed": 417, "published": 3, "date": "1584469760", "time_retrieved": "2024-07-30T21:18:10.134564", "image_code": "// Fork of \"Day 89\" by jeyko. https://shadertoy.com/view/wslyzM\n// 2020-03-17 17:21:08\n\n// Fork of \"Day 88\" by jeyko. https://shadertoy.com/view/3sXyz7\n// 2020-03-17 15:46:42\n\n// Fork of \"Day 85\" by jeyko. https://shadertoy.com/view/WdfczH\n// 2020-03-16 09:19:14\n\n// Fork of \"Day 84\" by jeyko. https://shadertoy.com/view/Wssczn\n// 2020-03-13 10:52:05\n\n// radial blur and chromatic abberation in this buffer\n// thx iq for pallette, mercury for hg-sdf, balkhan for glow\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),3.4)*0.1;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*1.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.98;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*5.5; \n    \n    fragColor *= 40.;\n    \n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.34);\n    //fragColor *= 1.;\n    fragColor = max(fragColor, 0.);\n    \n    fragColor *= 1.7;\n    fragColor.g *= 1.1;\n    fragColor.r *= 0.95 + uvn.x*0.7;\n    fragColor.g *= 0.95 + uvn.y*0.3;\n    fragColor = pow(fragColor, vec4(0.6545 + dot(uvn,uvn)*1.6));\n\t\n    //fragColor *= 1. - dot(uvn,uvn)*0.7;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime + 14.6)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvec3 att = vec3(1);\n\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0,vec2(floor(t)/256.)),texture(iChannel0,vec2(floor(t) + 1.)/256.), smoothstep(0.,1.,fract(t)));\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(vec2 t){\n    //t *= 1.4;\n    vec2 fr = fract(t);\n    //t *= 4.;\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,fr.x));\n}\n\nfloat sdRhombus(vec3 p, vec3 s){\n    p = abs(p) - s;\n    \n    float d = max(p.z, max(p.x, p.y));\n    \n    d = max(d, dot(p.yx + s.yx*0.5, normalize(vec2(1.))));\n    d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1.))));\n    return d;\n}\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\nfloat sdBox( vec3 p, vec3 s )\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\n\n\nvec3 modD = vec3(4.,4.,4.);\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    \n    \n    p.x += sin(p.x*0.1 + p.y*4. + p.z)*0.2;\n    //p.y += sin(p.x + p.y + p.z)*0.1;\n    \n    //p.x += exp(length(p.y)*0.2)*0.1;\n    \n    vec3 q = p;\n    \n    q.yz = pmod(q.yz, modD.yz);\n    \n    vec3 u = q;\n    \n    vec3 j;\n    vec3 m;\n    \n    for(int i = 0; i < 5;i ++){\n        \n        if(i == 3)\n            j = q;\n    \tq = abs(q);\n    \tif ( q.x < q.y ) { q.xy = q.yx; }\n\t    if ( q.x < q.z ) { q.xz = q.zx; }\n    \tif ( q.y < q.z ) { q.yz = q.zy; }\n        \n        //pModPolar(q.xz, 3.); \n        q.xz *= rot(-0.3);\n        q.yz *= rot(0.25*PI);\n        q.x -= 0.8 + sin(iTime)*0.;\n    \n    \tq.x += 0.24;\n\n    }\n    \n    q.x += 0.4;\n    \n    \n    float dB = sdBox(q, vec3(0.6,0.2,0.1)*0.8);\n    float dBb = length(u) - 0.3;\n    \n    dBb = abs(dBb) + 0.07;\n    d = dmin(d, vec2(dBb,5.));\n    //glow += exp(-abs(dBb)*abs(dBb)*  200.)*5.;\n    \n    //q = abs(q) + 0.01;\n    float dW = -q.x + 0.8;\n    \n    //dW = max(q.x, -q.z + 0.041);\n    \n    \n    //dW = max(dW, -q.x + 0.2);\n    //d = dmin(d, vec2(dB, 10.));\n    d = dmin(d, vec2(dW, 10.));\n    \n    j.y -= 0.1;\n    d = dmin(d, vec2(1. - sdBox(j, vec3(0.14)), 11.));\n    \n    m = abs(m);\n    \n    m.z -= 0.;\n    \n    //float dddd = abs(1.3 - sdBox(m, vec3(0.31,0.9,0.03))) + 0.01;\n    \n    p.y -= 6.;\n    \n    \n    float diam = 0.3;\n    //float dddd = length(p.xy) - diam + 3.*smoothstep(0.,1.,p.y*20.);\n    //float dddd = length(p.xy) - diam + 3.*smoothstep(0.,1.,abs(p.z - iTime)*0.01);\n    float dddd = length(p.xy) - diam + 3.*smoothstep(0.,1.,abs(p.z - iTime + sin(iTime)*2.)*0.03);\n    \n    \n    \n    d = dmin(d, vec2(abs(dddd) + 0.01, 15.));\n    //glow += exp(-dddd*10.)*0.06;\n    \n    vec4 n =valueNoise(p.z);\n    \n    glow += 0.14/(0.01 + dddd*dddd*(1. + n.y*20.))*vec3(0.1,0.1,0.1 + n.x)*att;\n    \n    \n    \n    \n\td.x *= 0.8;\n    return d;\n}\nfloat dith;\nfloat side = 1.;\nint it;\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n    \n\tvec2 d = map(ro);\n\td.x *= side;\n    if(d.x < 0.01)\n        ro += rd*0.04;\n    \n    p = ro; t = 0.; hit = false;\n    \n    \n    for(it = 0; it < 90 + min(0,iFrame)    ; it++){\n    \td = map(p);\n        d.x *= side;\n        d.x *= dith;\n    \t//glow += exp(-d.x*20.);\n        if(d.x < 0.00001){\n        \thit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir ));\n\tvec3 up = normalize(cross(dir, right));\n    float fov = 0.7;\n    return normalize(dir + (right*uv.x + up*uv.y)*fov);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //\n\t//uv *= 1. - dot(uv,uv)*0.2;\n    uv *= 1. - dot(uv,uv)*0.3;\n    \n    vec4 n = pow(valueNoise(iTime*1.), vec4(2.));\n    \n    \n    uv.xy *= rot(iTime*0.1 + PI*0.78 + sin((iTime - 3.6))*0.2 + n.y*0.25);\n    \n    vec3 col = vec3(0);\n\n    dith = mix(0.95,1., texture(iChannel0, 20.*uv*256. + iTime).x);\n    vec3 ro = vec3(0);\n    \n    \n    float nb = valueNoise(iTime*1./2.).x;\n    float zoom = 5. + n.x*1.;\n    //ro.xz += vec2(sin( 0. + iTime),cos(0. + iTime))*zoom;\n    \n    ro.z += iTime*1.;\n    \n    //ro.y += iTime*modD.y;\n    ro.y += 0.6 + sin(iTime)*0.;\n    \n    vec3 lookAt = vec3(0,ro.y + 1.8,ro.z + 3.);\n    \n    \n    lookAt.y += iMouse.y/iResolution.y*0.05;\n    lookAt.x -= iMouse.x/iResolution.y*0.05 - 0.025;\n    lookAt.y += -0. + valueNoise(iTime*1./2.).x*0.5;\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    rd.xz *= rot(0.1);\n    \n    vec3 p; float t; bool hit;\n    float tA = 0.;\n    float tF = 0.;\n    \n    for(int i = 0; i < 3; i ++){\n    \tvec2 d = march(ro, rd, p, t, hit);\n    \tvec3 n = getNormal(p)*side;\n        \n        vec3 ld = normalize(vec3(1));\n        vec3 h = normalize(ld - rd);\n        \n        float diff = max(dot(n, ld), 0.);\n        float spec = pow(max(dot(n, -h), 0.), 20.);\n        float fres = pow(1. - max(dot(n, -rd), 0.14), 5.);\n      \t\n        if(i == 0)\n            tF = t;\n        \n        tA = max(tA, t);\n        if(hit){\n            if(d.y == 10.){\n\n                fres = max(fres, 0.1);\n\n                if(i == 5)\n                    col += glow*0.001;\n\t\t\t\t\n                #define ao(j) clamp(map(p + n*j).x/j, 0., 1.) \n                col += pow(fres, 3.3)*0.1*pal(1.,1.,vec3(0.8,2.2,2.5),0.5,0.5 + dot(n, -rd) *20. + iTime)*att*ao(0.1);\n                att *= vec3(0.2,0.3,0.4)*1.8;\n\n\n                side *= -1.;\n                ro = p;\n                rd = reflect(rd,n);\n                rd = refract(rd,n, 0.98);\n\n            } else if(d.y == 11.){\n\n                fres = max(fres, 0.1);\n\t\t\t\t\n                if(i == 5)\n                    col += glow*0.001;\n\n                //glow *= att;\n                \n                vec3 a = pow(fres, 1.3)*0.014*pal(1.,1.,vec3(0.8,2.2,2.5),0.5,0.5 + dot(n, -rd) *10. + iTime)*att;\n                \n                //a *= ao(0.1)*ao(0.7);\n                a *= ao(0.1);\n                col += a;\n                \n                \n                att *= vec3(0.2,0.3,0.4)*0.1;\n\n                break;\n\t\t\t\t\n            }\n        \n        } else {\n            //att = att - att + 1.;\n        }\n    }\n\n    \n    //col = mix(col, vec3(0.4,0.1,0.1)*0.03, pow(smoothstep(0.,1.,tA*0.013), 1.6)*att);    \n    //col = mix(col, vec3(0.4,0.1,0.1)*0.006, pow(smoothstep(0.,1.,tF*0.03), 1.6));       \n    //col = mix(col, vec3(0.41,0.1,0.1)*0.002, pow(smoothstep(0.,1.,tA*0.03), 1.6));\n    col = mix(col, vec3(0.41,0.1,0.1)*0.0014, pow(smoothstep(0.,1.,tF*0.03), 1.));\n\n    \n    //col = mix(col, glow*0.01, smoothstep(0.,1.,length(glow)*0.004));\n    col -= glow*0.00002;\n    \n    col = min(col, 0.0032);\n    //col = max(col, 0.01);\n    //col += glow*0.0004;\n    \n    //col -= float(it)*0.00009;    \n    //col = mix(col, vec3(0.4,0.4,0.7)*0.1, pow(smoothstep(0.,1.,tA*0.143), 1.6));\n\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[470, 470, 527, 527, 1753]], "test": "untested"}
{"id": "wdsyzM", "name": "Menger Interactive Explorer(v.1)", "author": "quizcanners", "description": "A shader that helps explore ray marched object using familiar controls (WASD + MOUSE + QE (UP/DOWN)) \nBaked Ambient | Collision | Ray Intersection ", "tags": ["raymarching", "template"], "likes": 10, "viewed": 478, "published": 3, "date": "1584469616", "time_retrieved": "2024-07-30T21:18:11.282495", "image_code": "// Fork of \"Interactive Explorer (v.0)\" by quizcanners. https://shadertoy.com/view/wtKSzd\n// 2020-03-17 16:42:23\n// Next version: https://www.shadertoy.com/view/WsscWr  (v.2)\n\nvec4 loadValue( in ivec2 dataIndex )\n{\n    return texelFetch( iChannel0, dataIndex, 0 );\n}\n\nvec4 Volume(vec3 pos){\n\tfloat hmix;\n                 \n    vec4 bakeUV = SampleVolume(pos, GetVolumeHSlices(iResolution.y), hmix);\n             \n    return mix( texture(iChannel0, bakeUV.xy), texture(iChannel0, bakeUV.zw), hmix);\n}\n\nvec3 getFishEye(vec2 uv, float level) {\n    \n    float len = length(uv);\n    float a = len * level;\n    vec3 fishUV = vec3(uv / len * sin(a), cos(a));\n    \n    vec3 camForward = \t\tloadValue(CAM_FORWARD).xyz;\n    vec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0))); \n    vec3 camUp = normalize(cross(camRight, camForward));\n    \n    return (fishUV.x * camRight) + (fishUV.y * camUp) + (fishUV.z * camForward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cameraPosition = loadValue(CAM_POS_PRSST).xyz;\n\tvec3 rayDirection = getFishEye(uv,  1.5);\n    \n    vec2 rayCast = GetRaycastDist(cameraPosition, rayDirection);\n\n    vec3 col = vec3(0);\n    \n    float dist = max(0.,rayCast.x);\n    \n    if (dist<MAX_DIST) {\n\n      \n        float steps;\n        \n        float mxDist = \n           \n        #ifdef DEBUG\n            rayCast.y;\n        #else \n         \tMAX_DIST;\n        #endif\n        \n        GetRayMarchDist(cameraPosition, rayDirection, mxDist, dist, steps);\n        \n        steps /= 30.; // DEBUG\n\n         if(dist<mxDist) {\n            vec3 hitPos = cameraPosition + rayDirection * dist;\n            vec3 n = GetNormal(hitPos, dist);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.6;\n            col += dif;  \n             \n            #ifdef DEBUG\n             col.r =  steps; \n            #endif\n             \n             vec3 safeHitPos = hitPos + n * 0.0001*dist  ; // To start other calculations not trom inside the object\n             \n             float shadow = Shadow(safeHitPos, lightSource_0.xyz, SHADOW_RADIUS, lightSource_0.w);\n\n             vec4 baked = Volume(safeHitPos + n*VOLUME_SCALE * .3);\n             \n             col.rgb *= (shadow * lightSource_0_Color + baked.b * skyColor);\n             \n         \t  col.rgb = max(vec3(0.), col.rgb);\n             col = pow(col, vec3(.4545));\t// gamma correction\n             vec3 mixed = col.gbr + col.brg;\n\n            col.rgb += mixed*mixed *  .2;\n             \n         } else {\n              col.rgb = \n             #ifdef DEBUG\n                 vec3(steps,0.,0.);\n             #else\n             \t SkyBox(rayDirection);\n             #endif\n         }\n\n    \n   } else {\n    \tcol.rgb = SkyBox(rayDirection); \n   }\n    \n   \n    // Volumetric lights \n     \n    const float VOL_STEPS = 16.;\n    \n    const float VOL_STEP_SIZE = 2. * VOLUME_SCALE/ VOL_STEPS;\n    \n    const float FOG_DENSITY = .1/VOL_STEPS;\n    \n    vec4 ambientLight = vec4(0., 0., 0., FOG_DENSITY);\n    \n    float volDist = VOL_STEP_SIZE;\n    \n    for (float i=0.; i<VOL_STEPS; i+=1.)\n    {\n    \tvec3 volumePosition = cameraPosition + rayDirection * volDist;\n        \n        vec3 volCol = Volume(volumePosition).rgb;\n        \n        float addStep = VOL_STEP_SIZE * (1. + i/VOL_STEPS);\n        \n        float smoothAdd = smoothstep(dist, dist-addStep, volDist);\n       \n        float adding = FOG_DENSITY * smoothAdd;\n        \n        ambientLight.rgb += volCol * adding / ambientLight.a;\n      \n        ambientLight.a += adding;\n        \n        volDist += VOL_STEP_SIZE * (1. + i/VOL_STEPS); \n        \n        i+= (1. - smoothAdd) * 100.;\n    }\n    \n    ambientLight.a = min(1., ambientLight.a);\n  \n    ambientLight.rgb =  \n        lightSource_0_Color.rgb *  (lightSource_0.w * 0.3 * smoothstep(0., 10., ambientLight.r)) +\n        skyColor * ambientLight.b\n        ;\n    \n    col.rgb = mix(col.rgb, ambientLight.rgb , ambientLight.a);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// CONFIGS\n\n#define MAX_STEPS 30\n#define MAX_DIST 500.\n#define SURF_DIST .001\n//#define DEBUG\n#define MARCH_VOLUME_SHADOW\n//___ MOVEMENT\nconst float PLAYER_SPEED = .6;\nconst float PLAYER_RUN_SPEED = 1.;\nconst float MOUSE_SENSITIVITY = 3.;\nconst float PLAYER_SIZE = .1;\nconst float SLOWDOWN_RANGE = 5.;\n\nconst vec4 SCENE_OFFSET = vec4(0.,0.,20.,0.);\n\n//__ RENDERING\nconst float  SHADOW_RADIUS = 6.;\n\nvec3 skyColor= vec3(.1,.1, .7);\nvec3 eqColor = vec3(.5,.4,.4);\nvec3 floorColor = vec3(.1,.3,.1);\n\nvec3 SkyBox(vec3 rayDirection)\n{\n    return  floorColor * max(0., -rayDirection.y)\n        +   eqColor * (1.-abs(rayDirection.y)) \n        +\tskyColor * (max(0., rayDirection.y));\n}\n\n\n// *************** PERSISTANCE\n\nconst ivec2 CAM_POS_PRSST       \t= ivec2(1, 1);\nconst ivec2 CAM_ROT_PRSST       \t= ivec2(3, 1);\nconst ivec2 CAM_MOUSE_PREV_PRSST    = ivec2(7, 1);\nconst ivec2 CAM_ROTATION_PRSST      = ivec2(9, 1);\nconst ivec2 CAM_FORWARD       \t\t= ivec2(11, 1);\nconst ivec2 GAME_STATE       \t\t= ivec2(13, 1);\n\nconst float PRSST_MAX_Y = 2.;\n\n\n\n// ************** MATH\n\nfloat sharpstep(float a, float b, float x){\n    return (x-a)/(b-a);\n}\n\nvec2 Rot(vec2 uv, float angle){\n\tfloat si = sin(angle);\n\tfloat co = cos(angle);\n    return vec2(co * uv.x - si* uv.y, si * uv.x + co * uv.y);\n}\n\n// ************** VOLUME\n\nconst float VOLUME_SCALE = 10.;\nconst vec4 VOLUME_POSITION_N_SIZE = vec4(0, -40., 0, 1./VOLUME_SCALE) + SCENE_OFFSET; // w = 1/size\nconst float VOLUME_HEIGHT = 16.;\nconst float DE_VOL_HEIGHT = 1./VOLUME_HEIGHT;\n\n\nvec4 GetVolumeHSlices(float resolutionY)\n{\n  float sliceWidth = (resolutionY - VOLUME_HEIGHT * 2.) * DE_VOL_HEIGHT;       \n  return vec4(VOLUME_HEIGHT, sliceWidth* .5, 1./sliceWidth, DE_VOL_HEIGHT);\n}\n\nvec4 SampleVolume(vec3 worldPos, vec4 VOLUME_H_SLICES, out float hmix) {\n\n    vec4 outputUV = vec4(0.);\n    \n\tvec3 bsPos = (worldPos.xyz - VOLUME_POSITION_N_SIZE.xyz) * VOLUME_POSITION_N_SIZE.w;\n\n\tbsPos.xz = clamp((bsPos.xz + VOLUME_H_SLICES.y)* VOLUME_H_SLICES.z, 0., 1.)*VOLUME_H_SLICES.w;\n\tfloat h = min(max(0., bsPos.y), VOLUME_H_SLICES.x*VOLUME_H_SLICES.x - 1.);\n\n\tfloat sectorY = floor(h * VOLUME_H_SLICES.w);\n\tfloat sectorX = floor(h - sectorY * VOLUME_H_SLICES.x);\n\n    vec2 uv_low = vec2(sectorX, sectorY) * VOLUME_H_SLICES.w;\n    \n\tvec2 sector = clamp(uv_low, 0., 1.)+ bsPos.xz;\n\n    outputUV.xy = sector;\n\n\th += 1.;\n\n\tsectorY = floor(h * VOLUME_H_SLICES.w);\n\tsectorX = floor(h - sectorY * VOLUME_H_SLICES.x);\n\n\tsector = clamp(vec2(sectorX, sectorY)*VOLUME_H_SLICES.w, 0., 1.) + bsPos.xz;\n\n    outputUV.zw = sector;\n\n\thmix = fract(h); \n\n\treturn outputUV;\n}\n\n// **************  RAYMARCHING\n\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat smAdd(float d1, float d2, float smth)\n{\n\tfloat h = max(smth - abs(d1 - d2), 0.0) / (smth + 0.0001);\n\treturn min(d1, d2) - h * h*h*smth*(1.0 / 6.0);\n}\n\nfloat smMinus(float d1, float d2, float k) {\n\n\tfloat h = clamp((1. - (d2 + d1) / (k + 0.0001))*0.5, 0.,1.);\n\n\treturn mix(d1, -d2, h) + k * h * (1. - h);\n}\n\nfloat Minus(float d1, float d2){\n\treturn max(d1, -d2);\n}\n\n// ****************** SHAPES\n\nfloat sdSphere(vec4 sphere, vec3 pos) {\n\treturn length(pos-sphere.xyz)-sphere.w; \n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat distToBox(in vec2 pos, in vec2 boxMin, in vec2 boxMax, in float expand)\n{\n    boxMin -= vec2(expand,expand);\n    boxMax += vec2(expand,expand);\n    float bMax = max(pos.x - boxMax.x, pos.y - boxMax.y);\n    float bMin = max(boxMin.x - pos.x, boxMin.y - pos.y);\n    return max(bMax, bMin);\n}\n\n\n// ****************** RAY CASTING\n\nfloat planeLineIntersect(vec3 o,vec3 d,vec3 pn,vec3 pp)\n{\n    return dot(pp-o,pn)/dot(d,pn);\n}\n\n// Box:             https://www.shadertoy.com/view/ld23DV\nvoid iBox( in vec3 ro, in vec3 m, in vec3 boxSize, inout vec2 nearestCast) \n{ \n    \n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\n    float isNear = step(tN, tF) * step(0., tF) * step(tN, nearestCast.x);\n\n    nearestCast = mix(nearestCast, vec2(tN, tF), isNear);\n}\n\nvoid IntersectSphere(vec3 rayOrigin, vec3 rayDirection, vec3 pos, float radius, inout vec2 nearestCast)\n{\n    float t = max(0.,dot(pos - rayOrigin, rayDirection));\n    vec3 p = rayOrigin + rayDirection * t;\n    float y = length(pos - p);\n    \n    float hit = step(y, radius);\n    \n    float x = sqrt(mix(1., radius * radius - y * y,  hit));\n\n    float isNearest = hit * step(t-x, nearestCast.x);\n\n    nearestCast = mix(nearestCast, vec2(t-x,t+x), isNearest);\n}\n\n\n// ***************** TEST SCENE\n\n\nconst vec4 lightSource_0 = vec4(30., 50., 60., 20.) + SCENE_OFFSET;\n\nconst vec3 lightSource_0_Color = vec3(.8, .8, .1);\n\nconst vec4 Sphere_0 = vec4(1., 7., 20., 15) + SCENE_OFFSET;\nconst vec4 Sphere_1 = vec4(55., -40., 30., 30) + SCENE_OFFSET;\n\nconst vec4 MinusSphere_0 = vec4(55., -30., 30., 55) + SCENE_OFFSET;\nconst vec4 Box_0 = \t\t\tvec4(55., -40., 30., 50) + SCENE_OFFSET;\n\nconst vec4 Box_1 = \t\t\tvec4(-50., 64., 0., 50) + SCENE_OFFSET;\n\nvec2 GetRaycastDist(vec3 rayPos, vec3 rayDir)\n{\n    vec2 nearestCast = vec2(MAX_DIST+1.,MAX_DIST+1.);\n    \n    IntersectSphere(rayPos, rayDir, Sphere_0.xyz , Sphere_0.w, nearestCast);\n\n    vec3 precalculateBox = sign(rayDir)/max(abs(rayDir), 1e-8);\n    \n    iBox(rayPos - Box_0.xyz, precalculateBox, vec3(Box_0.w), nearestCast);\n \tiBox(rayPos - Box_1.xyz, precalculateBox, vec3(Box_1.w), nearestCast);\n    \n    return nearestCast;\n}\n\n\nfloat GetDist(vec3 p) {\n    \n\n    float minDist = sdBox(p - Box_0.xyz, vec3(Box_0.w));\n\n    minDist = min(minDist, sdBox(p - Box_1.xyz, vec3(Box_1.w)));\n    \n    minDist = Minus(minDist, sdSphere(MinusSphere_0,p));\n    \n    const int MENGER_ITERATIONS = 2;\n    float scale = .1;\n \tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tminDist = max(minDist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n    \n     minDist = smAdd(minDist, sdSphere(Sphere_0, p), 6.);\n    \n     minDist = min(minDist, sdSphere(Sphere_1, p));\n    \n    return minDist;\n}\n\nvec3 GetNormal(vec3 p, float dist ) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat Shadow(vec3 p, vec3 pos, float radius, float lightPower)\n{\n\tvec3 rayDir = normalize(pos - p);\n\tfloat maxDist = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * maxDist;\n\t\n    float minStep = radius * 0.15;\n    \n\t// distance traveled\n\tfloat dt =minStep;\n\n    float sd = 0.;\n    \n    float fullShadow = 0.;\n    \n\tfor (float i = 0.; i < 32.; i+=1.)\n\t{\t\t\t\t\n\t\tsd = GetDist(p + rayDir * dt);\n\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(minStep, abs(sd));\n\t\t\n        fullShadow = step(sd, -radius);\n        \n        i+= (fullShadow + step(maxDist,dt))* 100.;\n\t}\n\n\tlf = clamp((lf*maxDist + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\n\treturn lf * lightPower / maxDist ;\n}\n\n\n\nvoid GetRayMarchDist(vec3 rayPos, vec3 rayDir, float maxDist, inout float dist, out float steps){\n    \n    steps = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayPos + rayDir*dist;\n        float dS = GetDist(p);\n        dist += dS;\n        #ifdef DEBUG\n        steps += 1.; // DEBUG\n        #endif\n        if(dist>maxDist || abs(dS)<SURF_DIST*(1.+dist)\n          )\n        { \n            break;\n        }\n    }\n   \n}\n\n\n\n", "buffer_a_code": "\n// This buffer handles camera movement and volume baking\n// ASCII: https://www.ascii-code.com/\n\nconst float KEY_E            = 69.5 / 256.0;\nconst float KEY_Q            = 81.5 / 256.0;\nconst float KEY_W            = 87.5 / 256.0;\nconst float KEY_A            = 65.5 / 256.0;\nconst float KEY_S            = 83.5 / 256.0;\nconst float KEY_D            = 68.5 / 256.0;\nconst float KEY_LEFT         = 37.5 / 256.0;\nconst float KEY_UP           = 38.5 / 256.0;\nconst float KEY_RIGHT        = 39.5 / 256.0;\nconst float KEY_DOWN         = 40.5 / 256.0;\nconst float KEY_SHIFT        = 16.5 / 256.0;\nconst float KEY_SPACE \t     = 32.5 / 256.0;\n\nbool inStoreArea( in ivec2 dataIndex, in ivec2 fragCoord)\n{\n  return ( dataIndex.x==fragCoord.x && dataIndex.y==fragCoord.y);\n}\n\nbool inStoreRange( in ivec2 dataIndex1, in ivec2 dataIndex2, in ivec2 fragCoord)\n{\n  return ( dataIndex1.x<=fragCoord.x && dataIndex1.y<=fragCoord.y && dataIndex2.x>=fragCoord.x && dataIndex2.y>=fragCoord.y);\n}\n\nvoid storeValue( in ivec2 dataIndex, in vec4 data, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = inStoreArea(dataIndex, fragCoord) ? data : fragColor;\n}\n\nvec4 loadValue( in ivec2 dataIndex )\n{\n    return texelFetch( iChannel0, dataIndex, 0 );\n}\n\nvec3 volumeUVtoWorld(vec2 uv, vec4 VOLUME_H_SLICES) {\n\n\tfloat hy = floor(uv.y*VOLUME_H_SLICES.x);\n\tfloat hx = floor(uv.x*VOLUME_H_SLICES.x);\n\n\tvec2 xz = uv * VOLUME_H_SLICES.x;\n\n\txz.x -= hx;\n\txz.y -= hy;\n\n\txz = (xz*2. - 1.) *VOLUME_H_SLICES.y;\n\t\n\tfloat h = hy * VOLUME_H_SLICES.x + hx;\n\n\tvec3 bsPos = vec3(xz.x, h, xz.y) / VOLUME_POSITION_N_SIZE.w;\n\n\tvec3 worldPos = VOLUME_POSITION_N_SIZE.xyz + bsPos;\n\n\treturn worldPos;\n}\n\nvec3 hash33(vec3 pos)\n{\n\tpos = fract(pos * vec3(.1234, .5678, .923));\n    pos += dot(pos, pos.yxz+23.45);\n    return fract((pos.xxy + pos.yxx)*pos.zyx);\n\n}\n\nvec4 Quat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    return normalize(vec4(axis * sin(angle), cos(angle)));\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + (q.w * t) + cross(q.xyz, t);\n}\n\nvec4 QxQ(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = (q1.w * q2.w) - dot(q1.xyz, q2.xyz);\n    res.xyz = (q1.w * q2.xyz) + (q2.w * q1.xyz) + cross(q1.xyz, q2.xyz);\n    return normalize(res);\n}\n\nvec2 GetMouseDelta()\n{\n        vec4 mousePrevious = loadValue( CAM_MOUSE_PREV_PRSST);\n        float downPrevious = mousePrevious.z; \n        float down = clamp(iMouse.z * 800., 0. , 1.);\n        return down * downPrevious *  (iMouse.xy/iResolution.xy-mousePrevious.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    if (fragCoord.y<=PRSST_MAX_Y) {\n        \n      fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        \n       ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n        \n       #define WRITE_INDEX(data) inStoreArea(data, ifragCoord)  \n       #define PRSST_RANGE(data1, data2) inStoreRange(data1, data2, ifragCoord)  \n        \n        \n        vec4 gameState = loadValue(GAME_STATE);\n        \n        if (gameState.x == 0.)\n        {\n        \n            if (WRITE_INDEX(CAM_FORWARD)){\n             \tfragColor = vec4(vec3(0.,0.,1.), 0.0);\n                return;\n            }\n            \n            if (WRITE_INDEX(GAME_STATE)){\n             \tfragColor = vec4(1., 0., 0. , 0.0);\n                return;\n            }\n            \n            if (WRITE_INDEX(CAM_ROTATION_PRSST))\n       \t\t{\n                fragColor = vec4(0., 0., 0., 1.0);\n                return;\n            }\n            \n            discard;\n        }\n        \n        // Camera persistance: \n        \n        if (WRITE_INDEX(CAM_FORWARD)) {\n            \n             vec4 lastQuat    = loadValue(CAM_ROTATION_PRSST);\n            vec2 mouseDelta  = GetMouseDelta() * MOUSE_SENSITIVITY;\n\n            vec3 forward = loadValue(CAM_FORWARD).xyz;\n            vec3 right   = normalize(cross(forward, vec3(0.,1.,0.)));\n            vec3 up      = normalize(cross(right, forward));\n\n            lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n            lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n            fragColor = lastQuat;\n            \n            fragColor = vec4(Rotate(lastQuat, vec3(0.,0.,1.)), 0.0);\n            \n       } else  if (WRITE_INDEX(CAM_ROTATION_PRSST)) {\n            \n            vec4 lastQuat    = loadValue(CAM_ROTATION_PRSST);\n            vec2 mouseDelta  = GetMouseDelta() * MOUSE_SENSITIVITY;\n\n            vec3 forward = loadValue(CAM_FORWARD).xyz;\n            vec3 right   = normalize(cross(forward, vec3(0.,1.,0.)));\n            vec3 up      = normalize(cross(right, forward));\n\n            lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n            lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n            fragColor = lastQuat;\n           \n       } else  if (WRITE_INDEX(CAM_MOUSE_PREV_PRSST)) {\n           \n           vec4 mousePrevious = loadValue( CAM_MOUSE_PREV_PRSST);\n           mousePrevious.xy = iMouse.xy/iResolution.xy;\n           mousePrevious.z = clamp(iMouse.z * 800., 0. , 1.);\n           fragColor = mousePrevious;\n           \n           \n       } else if (WRITE_INDEX(CAM_POS_PRSST)) {\n           \n \t\t\tvec4 camera = loadValue(CAM_POS_PRSST);\n  \n           \n             vec3 off;\n\n            off.x -=  texture( iChannel1, vec2(KEY_A,0)).x;\n            off.x +=  texture( iChannel1, vec2(KEY_D,0)).x;\n            off.z +=  texture( iChannel1, vec2(KEY_W,0)).x;\n            off.z -=  texture( iChannel1, vec2(KEY_S,0)).x;\n            off.y +=  texture( iChannel1, vec2(KEY_E,0)).x;\n            off.y -=  texture( iChannel1, vec2(KEY_Q,0)).x;\n\n            if (length(off)>0.0001){\n                \n                off = normalize(off);\n                \n                vec3 camForward = \tloadValue(CAM_FORWARD).xyz;\n    \t\t\tvec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0))); \n\n                vec3 add = camForward * off.z + camRight * off.x;\n             \n                float run = texture( iChannel1, vec2(KEY_SHIFT,0)).x;\n                \n                float dist = min(1., GetDist(camera.xyz) / SLOWDOWN_RANGE);\n                \n                camera.xyz += (vec3(add.x,0.,add.z) + vec3(0., 1., 0.) * off.y) * max(0.1, dist)  * mix(PLAYER_SPEED, PLAYER_RUN_SPEED, run);\n            \n                if (dist<PLAYER_SIZE)\n                {\n                    camera.xyz += GetNormal(camera.xyz, 1.) * (PLAYER_SIZE - dist);\n                }\n            }\n            \n            \n            fragColor = camera;\n       }\n    } else {\n\n        // Ambient Light Baking\n        \n        vec2 uv = fragCoord/iResolution.xy;\n \n        fragColor = texture(iChannel0, uv);\n                \n        vec3 pos = volumeUVtoWorld(uv, GetVolumeHSlices(iResolution.y));\n\n        vec3 randomDirection = normalize(hash33(pos + iTime));\n        \n        pos += randomDirection* VOLUME_SCALE * 0.5;\n        \n        float dist = GetDist(pos);\n        \n        if (dist<0.)\n            return;\n        \n        vec3 addColor = vec3(0.);\n        \n        // SKY LIGHT\n        \n        vec2 rayCast = GetRaycastDist(pos, randomDirection);\n        \n        if (rayCast.x + 1. > MAX_DIST) \n        {\n        \taddColor.b = (randomDirection.y + 1.) * 0.5;  //SkyBox(randomDirection);\n        }\n        \n        // LIGHT POINT\n        \n        vec3 toLight = lightSource_0.xyz- pos;\n        float len = length(toLight);\n        \n        #ifdef MARCH_VOLUME_SHADOW\n        \tfloat visible =  Shadow(pos, lightSource_0.xyz, SHADOW_RADIUS, MAX_DIST);\n        #else\n         \tvec2 lightPointRay = GetRaycastDist(pos, normalize(toLight));\n        \tfloat visible = step(0., dist) * step(length(toLight), lightPointRay.x + 0.01);\n        #endif\n        \n       \n        addColor.r += visible;\n      \n        \n        //addColor += lightSource_0_Color.rgb *  ( lightSource_0.w * visible * 1000. / (len*len + 1.));\n\n        // STORING\n        \n        fragColor.a += 1.;\n        \n        float newPortion = 1./ (fragColor.a);\n        \n        fragColor.a = min(100., fragColor.a);\n        \n        fragColor.rgb = mix(fragColor.rgb, addColor, newPortion);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 214, 214, 266], [268, 268, 290, 290, 498], [500, 500, 539, 539, 924]], "test": "untested"}
{"id": "tdsyzM", "name": "Clebsch & Cayley Cubics with SDF", "author": "mla", "description": "Clebsch (and other) cubics, this one uses an SDF based on the implicit equation. It seems to go well with the foggy look from [url]https://www.shadertoy.com/view/tdlcRN[/url]\n\nSee also: [url]https://www.shadertoy.com/view/llKfDc[/url].", "tags": ["sdf", "cubic", "clebsch", "cayley"], "likes": 10, "viewed": 346, "published": 3, "date": "1584466037", "time_retrieved": "2024-07-30T21:18:12.122249", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Clebsch & other Cubics, raymarched using the implicit equation as SDF,\n// adjusted by the analytic gradient.\n//\n// Matthew Arcus, 2020.\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <left>/<right>: fog distance\n// <page up>/<page down>: select Clebsch, Caley or morphing Cubic.\n// f: fog\n// l: light transform\n// r: autorotation\n//\n// A projective transform as in https://www.shadertoy.com/view/llKfDc would\n// be nice, but doesn't interact nicely with the SDF approach.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\nconst int maxsteps = 100;\nconst float precis = 0.001;\nconst float AA = 2.0;\n\nfloat maxdist = 10.0;\nbool dorotate = true; // Autorotate\n\nbool check = false;\nvoid assert(bool b) {\n  if (!b) check = true;\n}\n\nfloat K = 1.0;\n// Cubic implicit equation, adjusted for gradient.\nfloat getdist(vec3 p) {\n   // x^3+y^3+z^3-K*w^3 = t^3 where w = 1, t = x+y+z+w\n   float t = dot(p,vec3(1))+1.0;\n   float ds = 2.0*length(p*p-t*t); // length of gradient\n  return (dot(p*p,p)+K-t*t*t)/ds;\n}\n\n// Gradient as a separate function.\nvec3 cgrad(vec3 p) {\n  float t = dot(p,vec3(1))+1.0;\n  return 2.0*(p*p-t*t);\n}\n\nfloat rosign;   // sign of implict equation at ray origin\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.1;\n  for(int i = 0; i < maxsteps; i++) {\n    //assert(i < 50);\n    vec3 p = ro + t*rd;\n    float d = rosign*getdist(p);\n    // Longer distance estimates are inaccurate,\n    // so clamp to avoid overstepping.\n    d = min(d,0.5);\n    t += d;\n    if (t < 0.0 || t > maxdist || abs(d) < t*precis) break;\n  }\n  return t;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return v * mix( vec3(1.0), rgb, s);\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\n// Perpendicular distance to line given by origin and direction\nfloat line(vec3 p, vec3 origin, vec3 dir) {\n  p -= origin;\n  float t = dot(p,dir);\n  return distance(p,t*dir);\n}\n\n#if 1\n// Calculate the parameters for the last 12 lines.\n// I can't find my notes about how all this works.\nfloat beval(float a, float A, float B, float z, float w) {\n  return -0.5*(2.0*a*a*z + A + B)/(w*w - a*a);\n}\n\nfloat feval(float a, float A, float B, float z, float w) {\n  float b = beval(a,A,B,z,w);\n  float t = 2.0*(b*b*(-a + w) + a*z*z) + A - B;\n  return t;\n}\n\nvec2 lineparams(float z, float w) {\n  float A = (K*8.0 + z*z*z + w*w*w - 1.0)/3.0;\n  float B =  z*z*w-z*w*w;\n  float eps = 1e-2;\n  float x0 = abs(w) + eps, f0 = feval(x0,A,B,z,w);\n  float x1 = x0 + eps, f1 = feval(x1,A,B,z,w);\n  // Start from abs(w) search for a bracketing interval\n  while (f1 < 0.0) {\n    float t = 2.0*x1 - x0;\n    x0 = x1; f0 = f1;\n    x1 = t; f1 = feval(x1,A,B,z,w);\n  }\n  // And apply bisection.\n  // Secant method doesn't help much here.\n  for (int i = 0; i < 10; i++) {\n    float x2 = (x0+x1)/2.0;\n    float f2 = feval(x2,A,B,z,w);\n    if (f2 < 0.0) {\n      x0 = x2; f0 = f2;\n    } else {\n      x1 = x2; f1 = f2;\n    }\n  }\n  float a = (x0+x1)/2.0;\n  return vec2(a,beval(a,A,B,z,w));\n}\n\n// Find the squared distance to the line in R3 but using\n// P4 coordinates.\nvoid tryline(vec4 p, vec4 q, vec4 r, int color,\n             inout float d2best) {\n  // Rotate lines in P4 so they project to correct\n  // position in R3 before calculating distance.\n#if 0\n  // These cases don't arise without a projective transform\n  if (abs(q.w) < abs(r.w)) {\n    vec4 t = q; q = r; r = t;\n  }\n  if (abs(q.w) < 1e-2) return;\n#endif\n   r = q.w*r - r.w*q; // r.w = 0\n   p = q.w*p-q;\n   float pr = dot(p,r);\n   float d2 = (dot(p,p) - (pr*pr/dot(r,r)))/(q.w*q.w);\n   if (d2 < d2best) {\n      d2best = d2;\n   }\n}\n\nfloat linedist(vec3 p) {\n#define tryline(x0,y0,z0,w0,x1,y1,z1,w1,c) \\\n  tryline(vec4(p,1),vec4(x0,y0,z0,w0),vec4(x1,y1,z1,w1),c,d2)\n  // It's tempting to put the lines in an array, but this\n  // performs badly on my laptop, perhaps a shortage of registers.\n  float d2 = 1e8;\n  if (false) {\n    // All at infinity\n    tryline(1,0,0,0, 0,1,-1,0, 3);\n    tryline(0,1,0,0, 1,0,-1,0, 3);\n    tryline(0,0,1,0, 1,-1,0,0, 3);\n  }\n  if (K >= 0.25) {\n    float A = 3.0, B = 3.0, C = 1.0-K;\n    float z0 = (-B - sqrt(B*B-4.0*A*C))/(2.0*A);\n    float z1 = (-B + sqrt(B*B-4.0*A*C))/(2.0*A);\n    if (true) {\n      tryline(0,0,z0,1, 1,-1,0,0, 4);\n      tryline(0,z0,0,1, 1,0,-1,0, 5);\n      tryline(z0,0,0,1, 0,1,-1,0, 6);\n      tryline(0,0,z1,1, 1,-1,0,0, 4);\n      tryline(0,z1,0,1, 1,0,-1,0, 5);\n      tryline(z1,0,0,1, 0,1,-1,0, 6);\n      tryline(z0,z1,0,1, 0,0,1,0, 4);\n      tryline(z0,0,z1,1, 0,1,0,0, 5);\n      tryline(0,z0,z1,1, 1,0,0,0, 6);\n      tryline(z1,z0,0,1, 0,0,1,0, 4);\n      tryline(z1,0,z0,1, 0,1,0,0, 5);\n      tryline(0,z1,z0,1, 1,0,0,0, 6);\n    }\n    if (K == 0.25) return sqrt(d2);\n    vec2 t = lineparams(z0,z1);\n    float a = t[0], b = t[1];\n    tryline(a,-a,z0,1, b,z1,-b,1, 1);\n    tryline(a,z0,-a,1, b,-b,z1,1, 2);\n    tryline(-a,z0, a,1, z1,-b, b,1, 1);\n    tryline(-a,a,z0,1, z1, b,-b,1, 2);\n    tryline(z0, a,-a,1, -b, b,z1,1, 1);\n    tryline(z0,-a, a,1, -b,z1, b,1, 2);\n        \n    tryline(-b,z0,b,1, -a,a,z1,1, 1);\n    tryline(-b,b,z0,1, -a,z1,a,1, 2);\n    tryline(b,-b,z0,1, z1, -a,a,1, 1);\n    tryline(b,z0, -b,1, z1,a, -a,1, 2);\n    tryline(z0,b, -b,1, a,z1, -a,1, 1);\n    tryline(z0, -b,b,1, a, -a,z1,1, 2);\n  }\n#undef tryline\n  return sqrt(d2);\n}\n#else\nfloat linedist(vec3 p) {\n  float d = 1e8;\n  // 24 lines - 3 of the 27 are at infinity in this projection.\n  // Maybe should use Plucker coordinates for this?\n  d = min(d,line(p,vec3(0,0,0),vec3(0.70711,-0.70711,0)));\n  d = min(d,line(p,vec3(0,0,0),vec3(0.70711,0,-0.70711)));\n  d = min(d,line(p,vec3(-1,-0,-0),vec3(0,1,0)));\n  d = min(d,line(p,vec3(-1,-0,-0),vec3(0,0,1)));\n  d = min(d,line(p,vec3(0,0,0),vec3(0,0.70711,-0.70711)));\n  d = min(d,line(p,vec3(-0,-1,-0),vec3(1,0,0)));\n  d = min(d,line(p,vec3(-0,-1,-0),vec3(0,0,1)));\n  d = min(d,line(p,vec3(-0,-0,-1),vec3(1,0,0)));\n  d = min(d,line(p,vec3(-0,-0,-1),vec3(0,1,0)));\n  d = min(d,line(p,vec3(-0,-0,-1),vec3(0.70711,-0.70711,0)));\n  d = min(d,line(p,vec3(-0,-1,-0),vec3(0.70711,0,-0.70711)));\n  d = min(d,line(p,vec3(-1,-0,-0),vec3(0,0.70711,-0.70711)));\n  d = min(d,line(p,vec3(-1.618,-1,-0),vec3(0.46534,0.75294,-0.46534)));\n  d = min(d,line(p,vec3(-1,-1.618,-0),vec3(0.75294,0.46534,-0.46534)));\n  d = min(d,line(p,vec3(-1,-0,-1.618),vec3(0.75294,-0.46534,0.46534)));\n  d = min(d,line(p,vec3(-1.618,-0,-1),vec3(0.46534,-0.46534,0.75294)));\n  d = min(d,line(p,vec3(0.61803,-0.61803,0),vec3(0.64794,0.40045,-0.64794)));\n  d = min(d,line(p,vec3(0.61803,0,-0.61803),vec3(0.64794,-0.64794,0.40045)));\n  d = min(d,line(p,vec3(-0,-1.618,-1),vec3(-0.46534,0.46534,0.75294)));\n  d = min(d,line(p,vec3(-0,-1,-1.618),vec3(-0.46534,0.75294,0.46534)));\n  d = min(d,line(p,vec3(0,0.61803,-0.61803),vec3(-0.64794,0.64794,0.40045)));\n  d = min(d,line(p,vec3(-0.61803,0.61803,0),vec3(0.40045,0.64794,-0.64794)));\n  d = min(d,line(p,vec3(-0.61803,0,0.61803),vec3(0.40045,-0.64794,0.64794)));\n  d = min(d,line(p,vec3(0,-0.61803,0.61803),vec3(-0.64794,0.40045,0.64794)));\n  return d;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dorotate = !key(CHAR_R);\n  maxdist = 10.0*(exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT))));\n  vec3 ro = vec3(0,0,4);\n  ro.z += 0.25*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n  ro = transform(ro);\n  vec3 light = vec3(1,2,3);\n  // Leaving the light fixed (untransformed) produces more\n  // dramatic lighting.\n  if (key(CHAR_L)) light = transform(light);\n  light = normalize(light);\n  rosign = sign(getdist(ro));\n  vec3 aacol = vec3(0);\n  int type = mymod(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP),3);\n  if (type == 0) K = 1.0;\n  else  if (type == 1) K = 0.25;\n  else if (type == 2) K = 1.0-sin(0.2*iTime);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 rd = vec3(uv,-2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      float t = march(ro, rd);\n      vec3 basecol = hsv2rgb(0.1+0.01*iTime,1.0,1.0); //vec3(1,0.5,0);\n      vec3 col = mix(vec3(1),basecol,0.75);\n      if (t >= 0.0 && t < maxdist) {\n        vec3 p = ro+t*rd;\n        vec3 n = normalize(cgrad(p));\n        if (dot(n,rd) > 0.0) n = -n;\n        float diffuse = mix(1.0,dot(n,light),0.5);\n        float d = linedist(p);\n        float intensity = 0.5+0.5*smoothstep(0.006,0.008,d);\n        vec3 c = diffuse*intensity*basecol;\n        float fog = key(CHAR_F) ? 0.0 : t/maxdist;\n        col = mix(c,col,fog);\n      }\n      aacol += col;\n    }\n  }\n  aacol = pow(aacol/(AA*AA),vec3(0.4545));\t// gamma correction\n  //assert(!isnan(dot(aacol,aacol)));\n  fragColor = vec4(aacol,1);\n  if (check) fragColor.r = 1.0;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else   \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[832, 832, 853, 853, 879], [896, 947, 970, 1025, 1151], [1153, 1189, 1209, 1209, 1267], [1285, 1327, 1358, 1358, 1690], [1692, 1692, 1728, 1728, 1780], [1782, 1782, 1809, 1809, 2138], [2140, 2140, 2181, 2181, 2351], [2353, 2353, 2378, 2418, 2473], [2771, 2771, 2796, 2796, 2844], [2846, 2846, 2869, 2869, 2901], [2903, 2903, 2923, 2923, 2983], [2985, 3049, 3092, 3092, 3161], [8262, 8262, 8314, 8314, 9922]], "test": "untested"}
{"id": "WssyR7", "name": "Specular AntiAliasing", "author": "H4w0", "description": "Using specular antialiasing based on Tokuyoshi and Kaplanyan work on top of a centered anisotropic beckmann NDF.", "tags": ["aa", "ndf", "beckmann", "specularaa"], "likes": 24, "viewed": 2600, "published": 3, "date": "1584436880", "time_retrieved": "2024-07-30T21:18:13.167455", "image_code": "//=======================================================\n//= Screen Space Specular Antialiasing\n//=======================================================\n//== Ressources :\n//== *- 2016 - Filtering Distributions of Normals for Shading Antialiasing\n//== \tby A. Kaplanyan, S. Hill, A. Patney, A. Lefohn (HPG 2016)\n//== project page : https://research.nvidia.com/publication/filtering-distributions-normals-shading-antialiasing\n//== demo : https://blog.selfshadow.com/sandbox/specaa.html\n//==\n//== *- 2017 - Error Reduction and Simplification for Shading Anti-Aliasing\n//== \tby Y. Tokuyoshi (technical report)\n//== project page : http://www.jp.square-enix.com/tech/publications.html\n//==\n//== *- Improving Geometric Specular Antialiasing\n//== \tby A. Kaplanyan & Y. Tokuyoshi\n//=======================================================\n//== I also used some code from :\n//== *- @XT95's \"UI easy to integrate\" on Shadertoy \t  \n//=   \thttps://www.shadertoy.com/view/ldKSDm\t\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's distance functions ( Sphere + SmoothUnionCubic )\n//== \thttps://iquilezles.org/articles/distfunctions\n//=======================================================\n    \nconst bool SLIDE_ANIMATION = true;\n\n//-----------------------------------------------------------------------------\n//-- Constantes ---------------------------------------------------------------\nconst float EPSILON             = m_eps_3f;\nconst float SAMPLES_WORLD       = 32.;\nconst float SAMPLES_SHADOWS \t= 32.;\nconst vec3  WORLD_BOUNDING_BOX  = vec3(2.);\nconst float WORLD_LIGHT_INTENSITY = 5.;\n\t  vec3  WORLD_LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  WORLD_BACKGROUND = vec3(0.0);\n\n//-----------------------------------------------------------------------------\n//-- Specular AA --------------------------------------------------------------\n//-- Snippet code for specular antialiasing\n//-- Based on A. Kaplanyan & Y. Tokuyoshi work\n//-----------------------------------------------------------------------------\nvoid specular_anti_aliasing(in vec3 half_vector, \n                           \tinout float alpha_x,\n                            inout float alpha_y)\n{\n     \t\n    float sigma = 0.50; \t\t\t\t\t\t\t//- screen space variance\n    float Kappa = 0.18;\t\t\t\t\t\t\t\t//- clamping treshold\n    vec2  H = half_vector.xy;\t\t\t\t\t\t\n    vec2  footprint_bounding_box = fwidth(H); \t\t//- abs(dfdx(slope_h)) + abs(dfdy(slope_h))\n\tvec2  variance = sigma*sigma*footprint_bounding_box*footprint_bounding_box;\n    vec2  kernel_roughness = min(vec2(Kappa), 2.*variance); \n    alpha_x = sqrt(alpha_x*alpha_x + kernel_roughness.x);\n    alpha_y = sqrt(alpha_y*alpha_y + kernel_roughness.y);\n}\n\n//-----------------------------------------------------------------------------\n//-- UI -----------------------------------------------------------------------\n//-- From XT95's https://www.shadertoy.com/view/ldKSDm\n//-----------------------------------------------------------------------------\nfloat \tuiSlider(int id) {return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 \tuiColor(int id)\t {return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//-----------------------------------------------------------------------------\n//-- Scene SDF : vec2(SDF,MATID) ----------------------------------------------\nvec2 MAP(vec3 P)\n{       \n    float SDF = 1.;\n    SDF = opSUnn(SDF, sdSphere( P - vec3(+0.5,0.,0.), 0.8 ));    \n\tSDF = opSUnn(SDF, sdSphere( P - vec3(-0.5,0.,0.), 0.8 ));    \n    SDF = opSUnn(SDF, sdSphere( P - vec3(0.,0.,+0.5), 0.8 )); \n    SDF = opSUnn(SDF, sdSphere( P - vec3(0.,0.,-0.5), 0.8 )); \n\treturn vec2(SDF,1.);\n}\n\n//-----------------------------------------------------------------------------\n//-- Raymarching code ---------------------------------------------------------\nfloat \tworld_get_light_intensity()            { return WORLD_LIGHT_INTENSITY; }\nvec3 \tworld_get_light_direction()            { return WORLD_LIGHT_DIRECTION; }\nvec3 \tworld_get_background_color(in vec3 rd) { return WORLD_BACKGROUND; }\n\nvec2 world_intersect(in vec3 ro, in vec3 rd, in float tmax)\n{\n    float t = 0.01;\n    vec2  R = vec2(-1.);\n    for(float istep=0.; istep<SAMPLES_WORLD && t<tmax; istep+=1.)\n    {\n        vec2 H = MAP(ro + t * rd);\n        if( H.x < EPSILON )\n        {\n            R = vec2(t,H.y);\n            break;\n        }\n        t += H.x;\n    }\n    return R;\n}\n\nfloat world_get_shadow(in vec3 ro, in vec3 rd, in float tmax)\n{\n    float t = 0.01;\n    float r = 0.;\n    for(int istep=0; istep<int(SAMPLES_SHADOWS) && t<tmax; istep++)\n    {\n        vec2 H = MAP(ro + t * rd);\n        if( H.x < EPSILON) {break;}\n        t += H.x;\n    }\n    if(t>tmax) r = 1.;\n    return r;\n}\n\n\nvec3 world_get_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*MAP( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*MAP( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*MAP( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*MAP( pos + e.xxx ).x );  \n}\n\nvec3 raymarch(vec3 ro, vec3 rd, vec2 screen, float slide)\n{ \n    vec2  hitinfo = world_intersect(ro, rd, 100.);\n    float hit_dis = hitinfo.x;\n    float hit_obj = hitinfo.y;\n\n    if(hit_dis<0.) \n    {\n    \treturn world_get_background_color(rd);\n    }\n\n    vec3 hit_pos = ro+rd*hit_dis;\n    vec3 hit_nor = world_get_normal(hit_pos);\n    \n    vec3    P = hit_pos;\n    vec3    L = world_get_light_direction();\n    vec3    N = hit_nor;\n    vec3    V = -rd;\n        \n    mat3 TBN    = orthonormal_basis(N);\n    mat3 TBN_t  = transpose(TBN);\n    vec3 wo = normalize(TBN_t * V);\n    vec3 wi = normalize(TBN_t * L);\n    vec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n    vec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)\n    \n    float wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n    float wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n\n    float roughness_x \t= clamp( 0.01 + uiSlider(0), 0., 0.8);\n    float roughness_y \t= clamp( 0.01 + uiSlider(1), 0., 0.8);\n    float metallic \t\t= float(uiSlider(3)>0.5); \t\t// 0. or 1.\n    float reflectance \t= clamp(uiSlider(2),0.35,1.); \t// [0.35;1]\n    \n    float alpha_x \t\t= roughness_x*roughness_x;\n    float alpha_y \t\t= roughness_y*roughness_y;\n    vec3  base_color    = uiColor(0);\n    vec3 F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n    \n    if(screen.x>slide)\n    {\n        specular_anti_aliasing(wh,alpha_x,alpha_y);\n    }\n\n    //-- NDF + G + F\n    float lambda_wo = lambda_beckmann_anisotropic(wo,alpha_x,alpha_y);\n    float lambda_wi = lambda_beckmann_anisotropic(wi,alpha_x,alpha_y);\n    float D = ndf_beckmann_anisotropic(wh,alpha_x,alpha_y); \n    float G = 1. / (1. + lambda_wo + lambda_wi);\n\tvec3  F = fresnel_schlick(wi_dot_wh,F0);\n        \n    //-- Lighting\n  \tvec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ;  \n   \tvec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n    float lighting = world_get_shadow(P+EPSILON*N,L,2.) * wg_dot_wi * world_get_light_intensity();\n    \n    vec3 C = lighting * (diffuse_lambert + specular_microfacet);\n    C = C / (C + vec3(1.0)); //-- Reinhard Tonemapping\n    C = pow(C,vec3(0.4545)); //-- Gamma Correction  \n    return(C);\n}\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd, in vec2 screencoords)\n{\n    float slide = 0.5+0.5*sin(0.5*iTime);\n    if(!SLIDE_ANIMATION){slide = clamp(iMouse.x/iResolution.x,0.,1.);}\n    \n    vec3 color = raymarch(ro,rd,screencoords,slide);\n       \n    if( (screencoords.x-slide) <= 0.005 && (screencoords.x-slide) >= -0.005) \n        color = vec3(1.,0.,0.);\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    WORLD_LIGHT_DIRECTION = normalize( vec3(cos(iTime),1.5,sin(iTime)) );\n    \n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 1., 4.+(sin(iTime)), 1. );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd,fragCoord.xy/iResolution.xy), 1.);\n\n    //-- UI integration -----------------------------------------------\n    vec4 ui = texture(iChannel0,gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb,ui.rgb, ui.a*.8);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi_2 \t\t= 1.5707963267;  \nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */            \nconst float m_2_pi \t\t= 6.2831853071; \nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;     \n\n//----------------------------------------------------------------------------------\n//-- Ray ---------------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Intersection Functions ---------------------------------------------------\nvec2 intersection_axis_aligned_box(in vec3 ray_origin, in vec3 ray_direction, in vec3 box_parameters) \n{\n    vec3 m  = 1.0/ray_direction;\n    vec3 n  = m*ray_origin;\n    vec3 k  = abs(m)*box_parameters;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2(tN,tF);\n}\n\n//----------------------------------------------------------------------------------\n// IQ SDF functions ----------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//----------------------------------------------------------------------------------\n// SDF Operators -------------------------------------------------------------------\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat opUnn(float d1, float d2) \t{ return min(d1,d2); }\nfloat opSub(float d1, float d2) \t{ return max(-d1,d2); }\nfloat opInt(float d1, float d2) \t{ return max(d1,d2); }\nfloat opSUnn(float d1, float d2) \t{ return sminCubic(d1,d2,0.1); }\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n      \n\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0., 1. - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 1. : clamp(w.x / sin_theta(w), -1., 1.);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 0. : clamp(w.y / sin_theta(w), -1., 1.);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n//-----------------------------------------------------------------------------\n//-- Beckmann Distribution ----------------------------------------------------\nfloat p22_beckmann_anisotropic(float x, float y, float alpha_x, float alpha_y)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma_x = alpha_x * m_i_sqrt_2;\n    float sigma_y = alpha_y * m_i_sqrt_2;\n    float sigma_x_sqr = sigma_x*sigma_x;\n    float sigma_y_sqr = sigma_y*sigma_y;\n    return( \n            exp( -0.5 * ((x_sqr/sigma_x_sqr) + (y_sqr/sigma_y_sqr)) )\n    / //-------------------------------------------------------------------\n                    ( 2. * m_pi * sigma_x * sigma_y )\n    );\n}\n\nfloat ndf_beckmann_anisotropic(vec3 omega_h, float alpha_x, float alpha_y)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float beckmann_p22 = p22_beckmann_anisotropic(slope_x,slope_y,alpha_x,alpha_y);\n    return(\n                beckmann_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_beckmann_anisotropic(vec3 omega, float alpha_x, float alpha_y)\n{\n    float lambda = 0.;\n    float cos_phi = cos_phi(omega);\n    float sin_phi = sin_phi(omega);\n    float alpha_o = sqrt(cos_phi*cos_phi*alpha_x*alpha_x + sin_phi*sin_phi*alpha_y*alpha_y); \n    float nu = 1. / (alpha_o * tan_theta(omega));\n\n    if(nu < 1.6)\n        lambda = (1. - 1.259*nu + 0.396*nu*nu) / (3.535*nu + 2.181*nu*nu); \n    \n    return(lambda);\n}\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}", "buffer_a_code": "//-- UI From Anatole Duprat : XT95 \n//-- https://www.shadertoy.com/view/ldKSDm\n//-- Using the following License :\n\n// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//-- Modified from line 91 (custom sliders, boxes and cursors...)\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.5)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    //----------------------------------------------\n    //-- Changed Here :: Custom sliders\n    _cursor(40,30) _S _p _e _c _u _l _a _r _spc _A _A\n    _box(vec2(15,iResolution.y-35.),vec2(150,3),vec4(1.))\n\n    _slider(24,57, 0, 0.05) _R _o _u _g _h _n _e _s _s _spc _X\n    _slider(24,87, 1, 0.50) _R _o _u _g _h _n _e _s _s _spc _Y\n        \n    _box(vec2(15,iResolution.y-100.),vec2(150,3),vec4(1.))\n        \n    _slider(24,125, 2, 0.5) _R _e _f _l _e _c _t _a _n _c _e \n    _slider(24,155, 3, 0.0) _M _e _t _a _l \n    _color(24,185, 0, vec3(1.,0.,0.)) _C _o _l _o _r\n                \n    fragColor = min(col.rgba,1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1753, 2084, 2233, 2233, 2734], [2736, 3031, 3056, 3056, 3124], [3125, 3125, 3149, 3149, 3219], [3221, 3381, 3399, 3399, 3705], [3707, 3867, 3914, 3914, 3946], [3947, 3947, 3993, 3993, 4025], [4026, 4026, 4072, 4072, 4099], [4101, 4101, 4162, 4162, 4450], [4452, 4452, 4515, 4515, 4761], [4764, 4764, 4802, 4802, 5012], [5014, 5014, 5073, 5073, 7242], [7244, 7406, 7465, 7465, 7774], [7776, 7936, 7993, 7993, 8547]], "test": "untested"}
{"id": "WssyzM", "name": "Lab-02", "author": "MykhailKo", "description": "Lab-2, KPI, Computer graphics, IS-91 Mykhal Kosiuk", "tags": ["stamp"], "likes": 1, "viewed": 273, "published": 3, "date": "1584427900", "time_retrieved": "2024-07-30T21:18:13.915455", "image_code": "mat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur) {\n\tfloat d = length(uv-p);\n\tfloat c = smoothstep(r, r-blur, d);\n\treturn c;\n}\n\nfloat Band (float t, float start, float end, float blur) {\n\tfloat step1 = smoothstep(start-blur, start+blur, t);\n\tfloat step2 = smoothstep(end+blur, end-blur, t);\n\treturn step1*step2;\n}\n\nfloat Rect (vec2 uv, vec2 position, float rot, float height, float width, float blur) {\n    \n    uv -= position; // translating coordinates system\n    uv *= rotate2d(rot); // rotating coordinates system\n\tfloat band1 = Band(uv.x, -(width/2.0), width/2.0, blur);\n\tfloat band2 = Band(uv.y, -(height/2.0), height/2.0, blur);\n\treturn band1*band2;\n}\n\nfloat Logo(vec2 uv, float width, float height, float blur){\n    \n    float maskK = Rect(uv, vec2(-width/2.0 + width/6.5, 0.0), 0.0, height-height/2.5, height/10.0, blur);\n    maskK += Rect(uv, vec2(-width/2.0 + height/2.77777, -height/10.0), 15.0, height*0.5, height/16.77777, blur);\n    maskK += Rect(uv, vec2(-width/2.0 + height/2.85714, height/5.8823529), 120.0, height/3.333333, height/16.77777, blur);\n    maskK += Rect(uv, vec2(-width/2.0 + height/1.4285714, 0.0), 0.0, height-(height/5.0*2.0), height/10.0, blur);\n    maskK += Rect(uv, vec2(-width/2.0 + height/0.90909, 0.0), 0.0, height-(height/5.0*2.0), height/10.0, blur);\n    maskK += Rect(uv, vec2(-width/2.0 + height-(height/5.0), width/10.0), 15.0, height/2.631578, height/10.0-(height/50.0*2.0), blur);\n    maskK += Rect(uv, vec2(-width/2.0 + height, width/10.0), 120.0, height/2.77777777, height/10.0-(height/50.0*2.0), blur);\n    \n    return maskK;\n}\n\n\nfloat Stamp(vec2 uv, vec2 position, float height, float width, float blur){\n    \n    uv -= position; // translating coordinates system\n    \n\tfloat mask = Rect(uv, vec2(0.0, 0.0), 0.0, height, width, blur);\n    \n    float sr = height/20.0;\n    \n    int horN = int(5.0*(width/height));\n    float margin = (5.0*(width/height) - float(horN))/(float(horN)+2.0);\n    float edgePattern = 0.;\n    \n    for(float i = margin; int(i) < horN * 2; i += 1.0+margin){\n    \tedgePattern += Circle(uv, vec2(-(width/2.0) + sr*(i*2.0+1.0), height/2.0), sr, blur);\t\n        edgePattern += Circle(uv, vec2(-(width/2.0) + sr*(i*2.0+1.0), -height/2.0), sr, blur);\t\n    }\n    for(float i = 0.5; i < 9.0; i++){\n    \tedgePattern += Circle(uv, vec2(width/2.0, -(height/2.0) + sr*(i*2.0+1.0)), sr, blur);\n        edgePattern += Circle(uv, vec2(-width/2.0, -(height/2.0) + sr*(i*2.0+1.0)), sr, blur);\n    }\n    \n    float logo = Logo(uv, width, height, blur);\n    \n    return mask-edgePattern-logo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n        \n    float mask = Stamp(uv, vec2(cos(iTime)*0.65, sin(iTime)*0.3), 0.4, 0.5, 0.005);\n        \n    fragColor = vec4(abs(cos(iTime)), 1.0, abs(sin(iTime)), 1.0)*mask;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 112], [114, 114, 166, 166, 241], [243, 243, 301, 301, 428], [430, 430, 517, 517, 773], [775, 775, 834, 834, 1692], [2667, 2667, 2724, 2774, 3045]], "test": "untested"}
{"id": "ttVXWt", "name": "Hopf fibers", "author": "tmst", "description": "- A volumetric visualization of the Hopf fibration.\n- Use mouse drag to change some parameters.", "tags": ["volumetric", "hopf", "fibration"], "likes": 61, "viewed": 1263, "published": 3, "date": "1584417759", "time_retrieved": "2024-07-30T21:18:14.731274", "image_code": "#define PI 3.14159\n\n#define FIXED_UP vec3(0.,1.,0.)\n#define TAN_HFOVY .5773502691896257\n\n#define GE1 vec3(.04,0.,0.)\n#define GE2 vec3(0.,.04,0.)\n#define GE3 vec3(0.,0.,.04)\n#define STEP_D .04\n\n#define RES iResolution\n#define MS iMouse\n#define PHASE smoothstep(.2, .8, MS.z > 0. ? MS.y/RES.y : .5+.5*cos(.4*iTime))\n#define ANG (MS.z > 0. ? 2.*PI*MS.x/RES.x : PI + 1.5*iTime)\n\n// ================\n// Generic helpers\n// ================\n\nfloat square(float x) { return x*x; }\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 nvCamDirFromClip(vec3 nvFw, vec2 c) {\n    vec3 nvRt = normalize(cross(nvFw, FIXED_UP));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HFOVY*(c.x*(RES.x/RES.y)*nvRt + c.y*nvUp) + nvFw);\n}\n\n// Rodrigues' formula: v -> (v.n)n + (v-(v.n)n)c - (vxn)s\nmat3 oProd(vec3 n) {\n    float xy = n.x*n.y, xz = n.x*n.z, yz = n.y*n.z;\n    return mat3(n.x*n.x,xy,xz,  xy,n.y*n.y,yz,  xz,yz,n.z*n.z);\n}\nmat3 glRotate(vec3 axis, float angle) {\n    float c = cos(angle), s = sin(angle);\n    vec3 n = normalize(axis);\n    return (\n        (1.-c)*oProd(n) +\n        mat3(c,s*n.z,-s*n.y,  -s*n.z,c,s*n.x,  s*n.y,-s*n.x,c)\n\t);\n}\n\n// Colormap adapted from: iq - Palettes (https://www.shadertoy.com/view/ll2GD3)\nvec3 colormap(float t) {\n    return .5 + .5*cos(2.*PI*( t + vec3(0.,.1,.2) ));\n}\n\n// ==================\n// Volume definition\n// ==================\n\nvec3 hopf(vec3 p) {\n\t// inverse stereographic R^3 -> S^3\n    float psq = dot(p, p);\n    vec4 q = vec4(2.*p.xyz, -1. + psq) / (1. + psq);\n\n    // hopf map S^3 -> S^2 (map versor q -> qjq*, i.e., rotate j using q)\n    return vec3(\n        2.*(q.y*q.z - q.x*q.w),\n        1. - 2.*(q.y*q.y + q.w*q.w), // == q.x^2 - q.y^2 + q.z^2 - q.w^2\n        2.*(q.x*q.y + q.z*q.w)\n    );\n}\n\nvec4 getV(vec3 p, mat3 m) {\n    // Get point on S^2, and rotate it for visual effect\n    vec3 rp = m * hopf(p);\n\n    // Fixed y == union of linked circles of same radii (interp. by theta)\n\tfloat theta = atan(-rp.z, rp.x);\n    float sdy = square(.5 + .5*cos(rp.y*5.*PI));\n    float sdt = .5 + .5*sin(theta*20.);\n    float d1 = max(sdt*sdy, .55*sdy);\n    d1 = mix(d1, .8*sdy, PHASE); // Sampling from a cubemap here is interesting\n\n    return vec4(.5 + .5*rp.y, 0., 0., d1);\n}\n\nvec4 getC(vec3 p, vec3 camPos, mat3 m) {\n    // Quick exit if volume has low alpha\n    vec4 data0 = getV(p, m);\n    if (data0.a < .4) { return vec4(0.); }\n\n    // Normal\n    vec3 gradA = vec3(\n        getV(p + GE1, m).a - getV(p - GE1, m).a,\n        getV(p + GE2, m).a - getV(p - GE2, m).a,\n        getV(p + GE3, m).a - getV(p - GE3, m).a\n    );\n    vec3 normal = (-gradA/(length(gradA) + 1e-5));\n\n    // Material color with lighting\n    vec3 matColor = mix(colormap(data0.r), .5+.5*normal.xyz, .25);\n    vec3 lightPos = camPos + vec3(0., 1., 0.);\n    vec3 nvFragToLight = normalize(lightPos - p);\n    vec3 nvFragToCam = normalize(camPos - p);\n\n\tvec3 diffuse = clamp(dot(normal, nvFragToLight), 0., 1.) * matColor;\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    vec3 specular = pow(clamp(dot(normal, blinnH), 0., 1.), 60.) * vec3(1.);\n\n    return vec4(.4*matColor+.6*(diffuse+specular), pow(data0.w, 3.));\n}\n\n// =============\n// Render scene\n// =============\n\nvoid march(in vec3 p, in vec3 nv, out vec4 color) {\n    color = vec4(0.);\n    vec2 tRange = vec2(mix(1., 2.75, PHASE), 6.);\n\n\tmat3 m = glRotate( normalize(vec3(1.,sin(iTime),1.)), -ANG );\n\n    float t = tRange.s;\n    for (int i=0; i<250; i++) {\n        vec4 cHit = getC(p + t*nv, p, m);\n\n        vec4 ci = vec4(cHit.rgb, 1.)*( (STEP_D/.08)*cHit.a ); // Premul alpha\n        color += (1.-color.a)*ci;\n\n        t += STEP_D;\n        if (t > tRange.t || color.a > .95) { return; }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/RES.xy;\n    vec3 camPos = vec3(0., 1., 3.5);\n    vec3 nvCamDir = nvCamDirFromClip(normalize(-camPos), uv*2. - 1.);\n\n    vec4 objColor;\n    march(camPos + rand(fragCoord)*nvCamDir*STEP_D, nvCamDir, objColor);\n    vec3 finalColor = objColor.rgb + (1. - objColor.a)*vec3(.2);\n\n    fragColor = vec4(finalColor, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 458, 458, 472], [474, 474, 494, 494, 561], [563, 563, 605, 605, 768], [770, 828, 848, 848, 966], [967, 967, 1006, 1006, 1186], [1188, 1268, 1292, 1292, 1348], [1416, 1416, 1435, 1472, 1789], [1791, 1791, 1818, 1875, 2265], [2267, 2267, 2307, 2349, 3189], [3242, 3242, 3293, 3293, 3726], [3728, 3728, 3783, 3783, 4121]], "test": "untested"}
{"id": "3lVSWt", "name": "大龙猫 - Quicky#027", "author": "totetmatt", "description": "Some smoky ambiance", "tags": ["instagram", "quicky"], "likes": 22, "viewed": 823, "published": 3, "date": "1584398782", "time_retrieved": "2024-07-30T21:18:15.477279", "image_code": "#define bpm 124.\n#define beat floor(iTime*bpm/60.)\n#define ttime iTime*bpm/60.\nmat2 r(float a){\nfloat c=cos(a),s=sin(a);\nreturn mat2(c,-s,s,c);\n}\nfloat fig(vec2 uv){\n    uv*=r(-3.1415*.9);\nreturn min(1.,.1/abs( (atan(uv.x,uv.y)/2.*3.1415)-sin(- ttime+(min(.6,length(uv)))*3.141592*8.)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    uv+=vec2(cos(iTime*.1),sin(iTime*.1));\n    uv*=r(iTime*.01);\n    vec3 col = vec3(-.0);\n    for(float y=-1.;y<=1.;y++){\n    for(float x=-1.;x<=1.;x++){\n    vec2 offset = vec2(x,y);\n    vec2 id = floor((uv+offset)*r(length(uv+offset)));\n    vec2 gv = fract((uv+offset)*r(length(uv+offset)))-.5;\n        gv*=r(cos(length(id)*10.));\n    float d = fig(gv);+fig(gv+vec2(sin(ttime+length(id))*.1,cos(iTime)*.1));\n    col += vec3(d)/exp(length(gv)*6.);\n\n    \n    }}\n    col = mix(vec3(.1,.01,.02),vec3(.8,.4,.2),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 95, 95, 145], [146, 146, 165, 165, 289], [291, 291, 346, 346, 956]], "test": "untested"}
{"id": "tdfcR7", "name": "Dancing Sheep", "author": "fisheep", "description": "Pixel art sheep, bouncing around all day long.\nWould like to hear about optimizations and more tips and tricks", "tags": ["simple", "pixelart"], "likes": 8, "viewed": 280, "published": 3, "date": "1584391458", "time_retrieved": "2024-07-30T21:18:16.413775", "image_code": "vec2 rotate(vec2 uv, float a)\n{\n    float cosa = cos(a), sina = sin(a);\n    return vec2(uv.x*cosa-sina*uv.y,uv.x*sina+uv.y*cosa);\n}\n\nbool rect(vec2 p, vec4 dim, vec3 inCol, out vec3 outCol)\n{\n    bool res = false;\n    if(abs(p.x-dim.x)<0.5*dim.z && abs(p.y-dim.y)<0.5*dim.w)\n    {\n        outCol = inCol;\n        res = true;\n    }\n    return res;\n}\n\n\nbool circle(vec2 p, vec3 circ, vec3 inCol,bool outline, out vec3 outCol)\n{\n    float c = length(floor(p-circ.xy));\n    bool res = false;\n    if(c < circ.z)\n    {\n        res = true;\n        if(outline)\n        {\n            float outline = circ.z-0.8;\n            outCol= step(c,outline)*inCol+step(outline, c)*vec3(0);\n        }\n        else\n        {\n            outCol = inCol;\n        }\n    }\n    return res;\n}\n\nbool hornsAndEyes(vec2 p, vec2 c, out vec3 col)\n{\n    bool res = abs(abs(p.x-c.x-0.5)-1.0)<0.5 && abs(abs(p.y-c.y-3.5)-1.0)<0.5;\n    if(res)\n    {\n        col = vec3(0);\n    }\n    return res;\n}\n\nbool face(vec2 p, vec2 c, out vec3 col)\n{\n    bool hit = hornsAndEyes(p,c, col);\n    hit = hit || rect(p,vec4(c.x+0.5,c.y+1.0,4.5,6), vec3(0.5),col);\n    hit = hit || rect(p, vec4(c.x+0.5,c.y+2.5,8.5,1), vec3(0.5), col);\n    hit = hit || rect(p,vec4(c.x+0.5,c.y-2.25,3.5,1.25), vec3(0.5), col);\n    return hit;\n}\n\nbool legs(vec2 p, vec2 c, vec3 inCol, out vec3 col)\n{\n    bool hit = rect(p, vec4(c.x+1.5,c.y-6.0,1,2), inCol, col) || rect(p, vec4(c.x-0.5,c.y-6.0,1,2), inCol, col);\n    hit = hit || rect(p, vec4(c.x+1.5,c.y-6.5,3,3), vec3(0), col) || rect(p, vec4(c.x-0.5,c.y-6.5,3,3), vec3(0), col);\n    return hit;\n}\n\nbool body(vec2 p, vec2 c, vec3 inCol, out vec3 col)\n{\n    bool hit = legs(p, c, inCol, col);\n    hit = hit || circle(p, vec3(c.xy,7.5), inCol, true, col);\n    return hit;\n}\n\nbool sheep(vec2 p, vec2 c, vec3 bodyCol, out vec3 col)\n{\n    bool hit = face(p, c, col);\n    hit = hit || body(p, c, bodyCol, col);\n    return hit;\n}\n\nbool moon(vec2 p, vec3 circ, vec3 inCol, out vec3 col)\n{\n    vec3 crecentO = vec3(3,-2,0.2*circ.z);\n    bool hit = circle(p, circ,vec3(1.0,0.9,0.0),true, col);\n    hit = hit && !circle(p, circ-crecentO,vec3(1.0,0.9,0.0),false, col);\n    return hit;\n}\n\nvec3 bg(vec2 p, float dayV)\n{\n    vec3 col;\n    vec2 baseP = vec2(40,35);\n    vec2 sunP = baseP + vec2(-20,10) + vec2(0,40)*(1.0-dayV);\n    vec2 moonP = baseP + vec2(20,-2) + vec2(0,40)*dayV;\n    bool hit = circle(p, vec3(sunP,12.75),vec3(1.0,0.9,0.0),false, col);\n    hit = hit || moon(p, vec3(moonP, 10.5), vec3(1.0,0.9,0.0), col);\n    if(!hit)\n    {\n    \tcol = step(p.y,9.0)*mix(vec3(0.06,0.45,0.01),vec3(0.12,0.9,0.2),dayV-0.5)+\n        \tstep(9.0,p.y)*mix(vec3(0.1,0.06,0.45),vec3(0.2,0.12,0.9),dayV);\n    }\n    return col;\n}\n\nvec3 scene(vec2 p)\n{\n    vec3 col = vec3(0);\n    float dayV = 2.0*abs(fract(0.5+0.125*iTime)-0.5);\n    dayV = dayV*dayV*(3.0-2.0*dayV);\n    bool hit = false;\n    for(float i = 0.0;i<5.0;i++)\n    {\n        vec2 c = vec2(20.0*i +10.0*sin(2.0*iTime), 15.0+2.0*abs(cos(2.0*i+10.0*iTime)));\n        vec3 scol = mix(vec3(0.9,0.8,0.7),vec3(1),0.833*fract(0.6*i))*dayV;\n        hit = hit || sheep(p, c, scol, col);\n    }\n    return hit? col : bg(p, dayV);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*= vec2(80,45);\n    vec3 col = scene(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfcR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 131], [133, 133, 191, 191, 348], [351, 351, 425, 425, 765], [767, 767, 816, 816, 960], [962, 962, 1003, 1003, 1274], [1276, 1276, 1329, 1329, 1579], [1581, 1581, 1634, 1634, 1753], [1755, 1755, 1811, 1811, 1904], [1906, 1906, 1962, 1962, 2156], [2158, 2158, 2187, 2187, 2687], [2689, 2689, 2709, 2709, 3138], [3140, 3140, 3197, 3197, 3318]], "test": "untested"}
{"id": "3sXyz7", "name": "Day 88", "author": "jeyko", "description": "poto", "tags": ["mdmtjvm"], "likes": 9, "viewed": 474, "published": 3, "date": "1584378236", "time_retrieved": "2024-07-30T21:18:17.569684", "image_code": "// Fork of \"Day 85\" by jeyko. https://shadertoy.com/view/WdfczH\n// 2020-03-16 09:19:14\n\n// Fork of \"Day 84\" by jeyko. https://shadertoy.com/view/Wssczn\n// 2020-03-13 10:52:05\n\n// radial blur and chromatic abberation in this buffer\n// thx iq for pallette, mercury for hg-sdf, balkhan for glow\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),4.)*0.7;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*2.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*5.5; \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.6);\n    //1fragColor *= 18.;\n    fragColor = max(fragColor, 0.);\n    fragColor.r *= 0.95 + uvn.x*0.4;\n    fragColor.g *= 0.95 + uvn.y*0.2;\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.5));\n    fragColor *= 1. - dot(uvn,uvn)*1.;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime + 3.6)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvec3 att = vec3(1);\n\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0,vec2(floor(t)/256.)),texture(iChannel0,vec2(floor(t) + 1.)/256.), smoothstep(0.,1.,fract(t)));\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(vec2 t){\n    //t *= 1.4;\n    vec2 fr = fract(t);\n    //t *= 4.;\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,fr.x));\n}\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat sdRhombus(vec3 p, vec3 s){\n\t\n    \n    p = abs(p) - s;\n    \n    float d = max(p.z, max(p.x, p.y));\n    \n    \n    d = max(d, dot(p.yx + s.yx*0.5, normalize(vec2(1.))));\n    d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1.))));\n    //d = max(d - s.x*0., -dot(p.z,p.x));\n    //d \n    \n    \n    return d;\n}\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\nfloat sdBox( vec3 p, vec3 s )\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    \n    float dd = length(p) - 0.1;\n    \n    float clOff = - exp(-p.z*0.4)*0.02;\n    \n    p.y += - exp(-p.z*0.4)*0.02;\n    p.z -= iTime;\n    \n    vec3 g = p;\n    \n    p.z = pmod(p.z, 2.5);\n    vec3 ccc = vec3(0.,0.4,1.);\n    \n    ccc *= 1. + pow(abs(sin(p.z + iTime+ cos(p.y + iTime*0.5)) ), 20.);\n    \n    float dG = max(max(abs(p.x), abs(p.z)) - 0.3, abs(p.y) - 0.011);\n    \n    vec3 u = p;\n    vec3 q = abs(p);\n    \n    q.xz -= 0.24;\n    \n    float dR = sdRhombus(q, vec3(0.04));\n    \n    //glow += 0.1/(0.03 + dLamp*dLamp*2000.)*vec3(1,1.,1);\n    \n    \n    float dP = max(max(abs(p.x), abs(p.z)) - 0.01, (p.y) + 0.25);\n\n    dP = fOpUnionStairs(dG, dP, 0.25,6.);\n    \n    dP = min(dP,fOpUnionStairs(dG, dR, 0.09,6.));\n    \n    \n    \n    q.y += 0.01;\n    q.xy -= vec2(-0.15,0.01);\n    float dQ = max(q.x, q.y);\n    \n    q = u;\n    \n    q = abs(q);\n    q.x -= 0.7;\n    //q.z -= 0.2;\n    q = abs(q);\n    //q.x -= 0.4;\n    //float dS = max(q.z, q.y)-0.;\n    float dS = max(q.z, q.x)-0.05;\n    \n    d = dmin(d, vec2(dP, 6.));\n    d = dmin(d, vec2(dQ, 10.));\n    \n    \n    //d = dmin(d, vec2(dS, 6.));\n    \n    float dCl = p.y + 0.5 - valueNoise(p.xz*6. + iTime).x*0.4;\n     \n    dCl += - pow(valueNoise(p.xz*0.4 + iTime).x, 2.)*0.5;\n    dCl = abs(dCl) + 0.06;\n    \n    \n    float modDB = 6.;\n    \n\tfloat id = floor(u.z/modDB); \n    \n    //u.y += sin(iTime + id);\n    \n    u = g;\n    \n    float mm = sin(iTime + id*0.1  + sign(p.x)*0.9);\n    \n    \n    \n    u.y -= (0.2 + \n             mm\n            \n           )*0.3;\n    u.z = pmod(u.z, modDB);\n    \n    \n    //u.y += 0.5;\n    u.x = abs(u.x);\n    u.x -= 1.8;\n    \n    //float dB = length(u) - 0.87 + sin(iTime*3.)*0.05;\n    \n    float dB = length(u) - 0.2 ;\n    \n    \n    dB = fOpUnionSoft(dB,dCl, 0.96);\n    dB = abs(dB) + 0.03;\n    \n    dCl = abs(dCl) + 0.01;\n    \n    d = dmin(d, vec2(dB, 6.));\n    d = dmin(d, vec2(dCl, 6.));\n    \n    p.x = abs(p.x);\n    p.x -= 0.24;\n    float dPp = length(p.yx) - 0.01;\n    d = dmin(d, vec2(dPp, 6.));\n    \n    glow += 0.06/(0.03 + dCl*dCl*dCl*200.)*vec3(1,1.,1)*att;\n    \n    \n    //glow += 0.04/(0.001 + dB*dB*50.)*vec3(1,1.3,1)*att* smoothstep(1.,0.,length(u)*0.4)*smoothstep(1.,0.,length(glow)*0.04)*4.;\n    glow += 0.04/(0.001 + dB*dB*50.)*vec3(1,1.3,1)*att;\n    \n    vec3 c = vec3(1);\n    //glow += 0.3/(0.1 + d.x*d.x)*c;\n\td.x *= 0.6;\n    return d;\n}\nfloat dith;\nint it;\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n    \n\tvec2 d = map(ro);\n\n    if(d.x < 0.05)\n        ro += rd*0.1;\n    \n    p = ro; t = 0.; hit = false;\n    \n    \n    for(it = 0; it < 230    ; it++){\n    \td = map(p);\n        d.x *= dith;\n        \n    \t//glow += exp(-d.x*20.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        if(t > 40.){\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir ));\n\tvec3 up = normalize(cross(dir, right));\n    float fov = 0.6;\n    return normalize(dir + (right*uv.x + up*uv.y)*fov);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //\n\t//uv *= 1. - dot(uv,uv)*0.2;\n    uv *= 1. - dot(uv,uv)*0.2;\n    \n    uv.xy *= rot(sin((iTime - 3.6))*0.2);\n    \n    vec3 col = vec3(0);\n\n    dith = mix(0.95,1., texture(iChannel0, 20.*uv*256.).x);\n    vec3 ro = vec3(0);\n    \n    \n    float n = pow(valueNoise(iTime*1.).x, 2.);\n    float nb = valueNoise(iTime*1./2.).x;\n    float zoom = 0.9 + n*1.;\n    //ro.xz += vec2(sin(iTime*0.5),cos(iTime*0.5))*zoom;\n    n *= 1.;\n    //ro.xz += vec2(sin( nb*6.14*1.5),cos( nb*6.14*1.5))*zoom;\n    //ro.xz += vec2(sin( 0.4),cos(0.1))*zoom;\n    ro.xz += vec2(sin( 0.),cos(0.))*zoom;\n    \n    ro.y += 0.3;\n    \n    vec3 lookAt = vec3(0,ro.y - 0.4,0.);\n    \n    lookAt.y += iMouse.y/iResolution.y*0.05;\n    lookAt.x -= iMouse.x/iResolution.y*0.05 - 0.025;\n    lookAt.y += -0. + valueNoise(iTime*1./2.).x*0.5;\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p; float t; bool hit;\n    float side = 1.;\n    float tA = 0.;\n    \n    for(int i = 0; i < 2; i ++){\n    \tvec2 d = march(ro, rd, p, t, hit);\n    \tvec3 n = getNormal(p);\n        \n        vec3 ld = normalize(vec3(1));\n        vec3 h = normalize(ld - rd);\n        \n        float diff = max(dot(n, ld), 0.);\n        float spec = pow(max(dot(n, -h), 0.), 20.);\n        float fres = pow(1. - max(dot(n, -rd), 0.), 14.);\n        \n        tA = max(tA, t);\n        if(d.y == 10.){\n            \n            col += fres*0.05*pal(1.,1.,vec3(0.8,2.2,2.5),0.5,0.5 + dot(n, -rd) *80. + iTime)*att;\n            \n            att *= vec3(0.7,0.7,0.65)*0.9;\n            //glow *= att;\n            rd = refract(rd, normalize(n + vec3(length(sin(p*6.)), 0.,0.)*0.035),0.995);\n            ro = p + rd *0.;\n    \t\t        \n        } else {\n            //col += fres*0.04*vec3(0.1,0.6,0.8)*att;\n            \n            //glow *= att;\n            col += fres*0.04*vec3(0.6,0.6,0.8)*att;\n\n            //col += diff*0.01*vec3(0,0.5,1)*att;\n        \tbreak;\n        }\n    }\n\n    \n    col = mix(col, vec3(0.1 + sin(iTime + uv.x)*0.2,0.4 + sin(iTime*0.4 + uv.y)*0.2,0.7)*0.1, pow(smoothstep(0.,1.,tA*0.043), 1.6)*att);\n        \n    col += glow*0.009*att;\n    //col -= float(it)*0.00009;    \n    //col = mix(col, vec3(0.4,0.4,0.7)*0.1, pow(smoothstep(0.,1.,tA*0.143), 1.6));\n\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 351, 351, 1484]], "test": "untested"}
{"id": "wsXyzM", "name": "Moebius, Menger, Spiders", "author": "dr2", "description": "Lots of spiders, with a twist", "tags": ["raymarch", "mobius", "walk", "octopod"], "likes": 23, "viewed": 456, "published": 3, "date": "1584369107", "time_retrieved": "2024-07-30T21:18:18.660767", "image_code": "// \"Moebius, Menger, Spiders\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 footPos[8], kneePos[8], hipPos[8], ltDir, qHit;\nfloat dstFar, tCur, mobRad, legLenU, legLenD, bdyHt, spdVel, nSpd;\nint idObj;\nconst int idMob = 1, idBdy = 11, idHead = 12, idEye = 13, idAnt = 14, idLegU = 15, idLegD = 16;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat MobiusDf (vec3 p)\n{\n  vec3 b;\n  float sclFac, r, a;\n  const int nIt = 4;\n  sclFac = 2.6;\n  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  p = vec3 (mod (16. * a + 1., 2.) - 1., Rot2D (vec2 (p.y, r - 32. / (2. * pi)), pi * a));\n  for (int n = VAR_ZERO; n < nIt; n ++) {\n    p = abs (p);\n    p.xy = (p.x > p.y) ? p.xy : p.yx;\n    p.xz = (p.x > p.z) ? p.xz : p.zx;\n    p.yz = (p.y > p.z) ? p.yz : p.zy;\n    p = sclFac * p - b;\n    p.z += b.z * step (p.z, -0.5 * b.z);\n  }\n  return 0.9 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, float (nIt));\n}\n\nfloat SpdDf (vec3 p, float dMin, int tpId)\n{\n  vec3 q;\n  float d, s, len, szFac;\n  szFac = 0.2;\n  p /= szFac;\n  dMin /= szFac; \n  p.y -= bdyHt + 0.7;\n  q = p - vec3 (0., -0.15, 0.2);\n  d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3));\n  DMINQ (idBdy + tpId);\n  q = p - vec3 (0., 0.1, 1.1);\n  d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5));\n  DMINQ (idHead + tpId);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 0.25, 1.5);\n  d = PrSphDf (q, 0.13);\n  DMINQ (idEye + tpId);\n  q -= vec3 (0., 0.15, -0.3);\n  d = PrEETapCylDf (q, 1.3 * vec3 (0.3, 1.1, 0.4), vec3 (0.), 0.07, 0.7);\n  DMINQ (idAnt + tpId);\n  p.y += bdyHt;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = 0.6 * PrEETapCylDf (q, kneePos[j], hipPos[j], 0.25, 0.3);\n    DMINQ (idLegU + tpId);\n    q = p - kneePos[j];\n    d = 0.6 * PrEETapCylDf (q, footPos[j] - vec3 (0.3), kneePos[j] - vec3 (0.3), 0.2, 1.2);\n    DMINQ (idLegD + tpId);\n  }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, aq, na;\n  dMin = dstFar;\n  d = MobiusDf (p);\n  DMINQ (idMob);\n  q = p;\n  a = tCur * spdVel / (2. * pi * mobRad);\n  q.xz = Rot2D (q.xz, a);\n  na = floor (nSpd * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / nSpd;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += mobRad;\n  a += aq;\n  if (2. * floor (0.5 * na) != na) a += 2. * pi;\n  q.xy = Rot2D (q.xy, 0.5 * a);\n  q.y -= 0.8;\n  if (PrCylDf (q.xzy, 1., 0.7) < dMin) dMin = SpdDf (q, dMin, 0);\n  q = p;\n  a = - tCur * spdVel / (2. * pi * mobRad);\n  q.xz = Rot2D (q.xz, a);\n  na = floor (nSpd * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / nSpd;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += mobRad;\n  a += aq;\n  if (2. * floor (0.5 * na) != na) a += 2. * pi;\n  q.xy = Rot2D (q.xy, 0.5 * a + 0.5 * pi);\n  q.y -= 0.8;\n  if (PrCylDf (q.xzy, 1., 0.7) < dMin) dMin = SpdDf (vec3 (- q.xz, q.y).xzy, dMin, 10);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvoid SpdSetup (float gDisp)\n{\n  vec3 v;\n  float a, az, fz, d, ll;\n  nSpd = 10.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];\n    hipPos[j + 4].x *= -1.;\n  }\n  bdyHt = 1.5;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) + mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvec3 SpdCol (vec3 vn)\n{\n  vec3 col, c1, c2;\n  if (idObj >= idBdy + 10) {\n    idObj -= 10;\n    c1 = vec3 (0.5, 1., 0.2);\n    c2 = vec3 (0.5, 0.2, 0.2);\n  } else {\n    c1 = vec3 (1., 0.5, 0.2);\n    c2 = vec3 (0.2, 0.2, 0.5);\n  }\n  if (idObj == idBdy) {\n    col = mix (c1, c2, SmoothBump (0.2, 0.7, 0.05, mod (4. * qHit.z, 1.)));\n  } else if (idObj == idHead) {\n    col = c2;\n    if (qHit.z > 0.4) col = mix (vec3 (0.2, 0.05, 0.05), col,\n       smoothstep (0.02, 0.04, abs (qHit.x)));\n  } else if (idObj == idEye) {\n    col = (vn.z < 0.6) ? vec3 (0., 1., 0.) : c1;\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (c2, c1,  SmoothBump (0.4, 1., 0.2, fract (3.5 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 1.5;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.35, 0.5, 1.), vec3 (0.1, 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.15 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == idMob) {\n      col4 = vec4 (0.6, 0.6, 0.7, 0.1);\n      vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj >= idBdy) {\n      col4 = vec4 (SpdCol (vn), 1.);\n    }\n    sh = ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       step (0.95, sh) * col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    col = mix (col, BgCol (reflect (rd, vn)), 0.3);\n  } else col = BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0  // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = (floor (0.3 * tCur) + smoothstep (0.8, 1., mod (0.3 * tCur, 1.)));\n    az += 0.1 * t;\n    el -= 0.1 * pi * (1. - sin (0.06 * t));\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  zmFac = 4.5 - 1.5 * abs (el);\n  dstFar = 50.;\n  mobRad = 5.;\n  spdVel = 1.5;\n  SpdSetup (spdVel * tCur);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -20.);\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf)\n{\n  vec3 v;\n  float s;\n  v = v1 - v2;\n  s = clamp (dot (p, v) / dot (v, v), 0., 1.);\n  return length (p - s * v) - r * (1. - rf * s * s);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[862, 862, 887, 887, 1479], [1481, 1481, 1525, 1525, 2420], [2422, 2422, 2444, 2444, 3352], [3354, 3354, 3387, 3387, 3571], [3573, 3573, 3594, 3594, 3849], [3851, 3851, 3888, 3888, 4117], [4119, 4119, 4148, 4148, 5232], [5234, 5234, 5257, 5257, 6008], [6010, 6010, 6032, 6032, 6455], [6457, 6457, 6492, 6492, 7159], [7202, 7202, 7258, 7258, 8497], [8499, 8499, 8531, 8531, 8631], [8633, 8633, 8666, 8666, 8693], [8695, 8695, 8737, 8737, 8788], [8790, 8790, 8856, 8856, 8994], [8996, 8996, 9031, 9031, 9093], [9095, 9095, 9152, 9152, 9235], [9237, 9237, 9273, 9273, 9479], [9481, 9481, 9511, 9511, 9624], [9658, 9658, 9682, 9682, 9794], [9796, 9796, 9821, 9821, 10007], [10009, 10009, 10038, 10038, 10250], [10252, 10252, 10291, 10291, 10476]], "test": "untested"}
{"id": "WsfcRn", "name": "Euclidean Honeycombs", "author": "mla", "description": "Euclidean honeycombs and their duals: [url]https://en.wikipedia.org/wiki/Goursat_tetrahedron[/url]\n\nDisplay cycles through 4 mins of different options, or use manual controls (see code).\na,d: show/hide main honeycomb, dual\n<mouse>/<up>/<down>: move around", "tags": ["honeycomb", "euclidean", "goursat", "wythoff"], "likes": 9, "viewed": 563, "published": 3, "date": "1584366021", "time_retrieved": "2024-07-30T21:18:19.789749", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Euclidean Honeycombs\n//\n// Matthew Arcus, 2020.\n//\n// Using the Wythoff construction: https://en.wikipedia.org/wiki/Wythoff_construction\n// to construct honeycombs in 3D space. The fundamental region is a Goursat\n// Tetrahedron: https://en.wikipedia.org/wiki/Goursat_tetrahedron and the\n// Wythoff construction goes through in a similar way to the planar and spherical\n// case - a vertex is selected in the tetrahedron, then reflected in all ways in the\n// faces of the tetrahedron (this results in an infinite lattice of points). In each\n// image of the region, there is an edge from the vertex image to the vertex in each\n// adjacent region, perpendicular to the shared face.\n//\n// <mouse>: image rotation\n// <up>/<down>: move in/out\n// <left>/<right>: cycle through the 15 honeycombs of the tetrahedron\n// <page up>/<page down>: select centred vertex\n// a: show main honeycomb\n// d: show dual honeycomb\n// c: clip to sphere or cube\n// i: invert about origin\n// m: monochrome\n// o: put viewpoint at origin\n// r: autorotation\n// v: morph between trilinears\n// z: translate on z-axis (nice when inverting)\n//\n// Each region vertex is the centre of a polyhedron, which may however be of\n// zero volume (for example, if the region point coincides with that vertex).\n// The dual honeycomb is constructed by connecting the region vertices that\n// contain non-zero volume polyhedra.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Select basic tetrahedron here.\n#define T0 0 // Basic tetrahedron: (4,2,2,3,2,4)\n#define T1 1 // Two T0 tetrahedra joined\n#define T2 2 // Two T1 tetrahedra joined\n//#define SNUB // Special snub form\n// For a uniform snub, the four reflections of the region point should be\n// mutually  equidistant, but this is generally not possible, so the snub\n// forms are necessarily non-uniform.\n#define TYPE T1\n\nbool showdual = true;\nbool showmain = true;\nbool doinvert = true;\nbool dotranslate = false;\nbool dorotate = false;\nbool doclip = true;\nbool domorph = true;\nfloat clipsphere = 5.5;\nfloat clipcube = 2.1;\nint centre = 0; // The vertex index to centre\n\nconst float maxdepth = 20.0;\nconst float fogstart = 5.0;\n\nconst float sscale = 2.0; // Thickness of edges and vertices\nconst float swidth = sscale*0.05;\nconst float swidth2 = swidth*swidth;\nconst float twidth = sscale*0.02;\nconst float twidth2 = twidth*twidth;\nconst float fwidth = sscale*0.005;\n\nint alert = 0;\nvoid assert(bool test) {\n  if (!test) alert = 1;\n}\n\nconst float PI =  3.141592654;\n\n// PQRS is fundamental tetrahedron\n// Edges are PQ,PR,PS,QR,QS,RS\n#if TYPE==T0\nconst vec3 P = vec3(0,0,0);\nconst vec3 Q = vec3(1,0,0);\nconst vec3 R = vec3(1,1,0);\nconst vec3 S = vec3(1,1,1);\n#elif TYPE==T1\nconst vec3 P = vec3(0,0,0);\nconst vec3 Q = vec3(2,0,0);\nconst vec3 R = vec3(1,1,0);\nconst vec3 S = vec3(1,1,1);\n#elif TYPE==T2\nconst vec3 P = vec3(0,0,0);\nconst vec3 Q = vec3(2,0,0);\nconst vec3 R = vec3(1,1,-1);\nconst vec3 S = vec3(1,1,1);\n#endif\n\n// These are the planes of the tetrahedron.\n// Plane pP is opposite P, etc.\n// w coordinate is distance of plane from origin\n// Normals should face into the tetrahedron.\nconst float K = 1.414213562;\n#if TYPE==T0\nconst vec4 pP = vec4(-1,0,0,1);\nconst vec4 pQ = 0.5*K*vec4(1,-1,0,0);\nconst vec4 pR = 0.5*K*vec4(0,1,-1,0);\nconst vec4 pS = vec4(0,0,1,0);\n#elif TYPE==T1\nconst vec4 pP = 0.5*K*vec4(-1,-1,0,2);\nconst vec4 pQ = 0.5*K*vec4(1,-1,0,0);\nconst vec4 pR = 0.5*K*vec4(0,1,-1,0);\nconst vec4 pS = vec4(0,0,1,0);\n#elif TYPE==T2\nconst vec4 pP = 0.5*K*vec4(-1,-1,0,2);\nconst vec4 pQ = 0.5*K*vec4(1,-1,0,0);\nconst vec4 pR = 0.5*K*vec4(0,1,-1,0);\nconst vec4 pS = 0.5*K*vec4(0,1,1,0);\n#endif\n\nconst float lP = length(cross(Q-R,Q-S));\nconst float lQ = length(cross(R-S,R-P));\nconst float lR = length(cross(S-P,S-Q));\nconst float lS = length(cross(P-Q,P-R));\n\nconst vec4 tri2bary = vec4(lP,lQ,lR,lS); // The lengths of the unnormalized cross products\n\nvec4 T = vec4(1,1,1,1); // Trilinear coordinates of Wythoff point\nvec3 A; // The Wythoff point itself\nvec3 pA,qA,rA,sA; // A reflected in pP, pQ etc.\n\nvec4 trymirror(vec4 p4, vec4 m4, inout int flips) {\n  float t = dot(p4,m4);\n  flips += int(t < 0.0);\n  p4.xyz -= 2.0*min(0.0,t)*m4.xyz;\n  return p4;\n}\n\nvec3 fold(vec3 p, inout int flips) {\n  // Translate along z axis. Interesting when inverted.\n  if (dotranslate) p.z += 0.1*iTime;\n  // Move selected vertex to centre of image.\n  // P is the origin & therefore the default.\n  if (centre == 1) p += Q;\n  else if (centre == 2) p += R;\n  else if (centre == 3) p += S;\n\n  // Attempt to optimize folding for the three  tetrahedron types.\n#if TYPE==T0\n  // Fold in to unit cube\n  p = mod(p+1.0,2.0)-1.0;\n  flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n  p = abs(p);\n  vec4 p4 = vec4(p,1);\n  p4 = trymirror(p4,pQ,flips);\n  p4 = trymirror(p4,pR,flips);\n  p4 = trymirror(p4,pQ,flips);\n#elif TYPE==T1\n  p = mod(p+2.0,4.0)-2.0;\n  flips += int(p.x < 0.0) + int(p.y < 0.0);\n  p.xy = abs(p.xy);\n  vec4 p4 = vec4(p,1);\n  p4 = trymirror(p4,pS,flips);\n  for (int i = 0; i < 2; i++) {\n    p4 = trymirror(p4,pP,flips);\n    p4 = trymirror(p4,pQ,flips);\n    p4 = trymirror(p4,pR,flips);\n  }\n#elif TYPE==T2\n  p = mod(p+2.0,4.0)-2.0;\n  vec4 p4 = vec4(p,1);\n  for (int i = 0; i < 4; i++) {\n    p4 = trymirror(p4,pP,flips);\n    p4 = trymirror(p4,pQ,flips);\n    p4 = trymirror(p4,pR,flips);\n    p4 = trymirror(p4,pS,flips);\n  }\n#endif\n  return p4.xyz;\n}\n\nvec3 colors[] = vec3[](vec3(0.3),\n                       vec3(1,0,0),\n                       vec3(0,1,0),\n                       vec3(0,0,1),\n                       vec3(1,1,0),\n                       vec3(0,1,1),\n                       vec3(1,1,1),\n                       vec3(1,0,1),\n                       vec3(0.8,1,0.8)\n                      );\n         \n// Reflect p in mirror,normal M, distance d from origin.\nvec3 mirror(vec3 p, vec4 M) {\n  float t = dot(vec4(p,1),M);\n  return p - 2.0*t*M.xyz;\n}\n\nvec3 mp(vec3 p) {\n  return mirror(p,pP);\n}\nvec3 mq(vec3 p) {\n  p = mirror(p,pQ);\n  return p;\n}\nvec3 mr(vec3 p) {\n  return mirror(p,pR);\n}\nvec3 ms(vec3 p) {\n  return mirror(p,pS);\n}\n\n#if defined SNUB\nvec3 snubpoints[12];\nint snubcolors[12] = int[](4,4,6,3,2,2,5,1,1,6,3,5);\n#endif\n\nvoid init(vec4 tri) {\n  tri *= tri2bary;\n  A = tri.x*P + tri.y*Q + tri.z*R + tri.w*S;\n  A /= dot(tri,vec4(1));\n  pA = mp(A); qA = mq(A);\n  rA = mr(A); sA = ms(A);\n#if defined SNUB\n  // Reflections of a in P,Q,R,S\n  // Double reflections of Wythoff point A\n  // Currently just for T0 tetrahedron, and no dual\n  snubpoints[0] = mp(mq(A));\n  snubpoints[1] = mq(mp(A));\n  snubpoints[2] = mp(mr(A)); // p,r commute so no rp\n  snubpoints[3] = mp(ms(A)); // p,s commute so no sp\n  snubpoints[4] = mq(mr(A));\n  snubpoints[5] = mr(mq(A));\n  snubpoints[6] = mq(ms(A)); // q,s commute so no sp\n  snubpoints[7] = mr(ms(A));\n  snubpoints[8] = ms(mr(A));\n  snubpoints[9] = mr(mp(A)); // For T1, p,r don't commute!\n  snubpoints[10] = ms(mp(A));\n  snubpoints[11] = ms(mq(A));\n#endif\n}\n\nfloat face(vec3 p, vec3 q, vec3 r, vec3 s) {\n  p -= q;\n#if 0\n  r -= q;\n  s -= q;\n  r = normalize(r);\n  s = normalize(s);\n#endif\n  float rs = dot(r,s), pr = dot(p,r), ps = dot(p,s);\n  mat2 m = mat2(1,rs,rs,1);\n  vec2 t = inverse(m)*vec2(pr,ps);\n  t = max(t,0.0);\n  vec3 p1 = t[0]*r+t[1]*s;\n  return distance(p,p1);\n}\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\n#if defined SNUB\n// A is the region point\n// For scene0, A is the vertex, with segments drawn\n// from A to the 12 double reflections of A in the\n// tetrahedron sides. Some of these segments might\n// coincide.\nfloat snubscene0(vec3 p, out int index) {\n  float d,d0 = 1e8;\n  d = length(p-A)-swidth;\n  if (d < d0) d0 = d, index = 0;\n  for(int i = 0; i < snubpoints.length(); i++) {\n    vec3 r = snubpoints[i];\n    d = segment(p,A,r)-twidth;\n    if (d < d0) d0 = d,  index = snubcolors[i];\n  }\n  return d0;\n }\n\n// For scene1, vertices are drawn for the four\n// reflections of A in the tetrahedron sides\n// and for the six segments connecting those\n// four reflections.\nfloat snubscene1(vec3 p, out int index) {\n  float d,d0 = 1e8;\n  d = segment(p,pA,qA)-twidth;\n  if (d < d0) d0 = d,  index = 4;\n  d = segment(p,pA,rA)-twidth;\n  if (d < d0) d0 = d,  index = 6;\n  d = segment(p,pA,sA)-twidth;\n  if (d < d0) d0 = d,  index = 3;\n  d = segment(p,qA,rA)-twidth;\n  if (d < d0) d0 = d,  index = 2;\n  d = segment(p,qA,sA)-twidth;\n  if (d < d0) d0 = d,  index = 5;\n  d = segment(p,rA,sA)-twidth;\n  if (d < d0) d0 = d,  index = 1;\n\n  // The vertex spheres of the adjacent regions\n  // might overlap with this region.\n  d = length(pA-p)-swidth;\n  if (d < d0) d0 = d,  index = 0;\n  d = length(qA-p)-swidth;\n  if (d < d0) d0 = d,  index = 0;\n  d = length(rA-p)-swidth;\n  if (d < d0) d0 = d,  index = 0;\n  d = length(sA-p)-swidth;\n  if (d < d0) d0 = d,  index = 0;\n  return d0;\n}\n#endif\n\nvoid tryvertex(vec3 pos, vec3 P, int i, inout float d0, inout int index) {\n  float d = length(pos-P)-swidth;\n  if (d < d0) {\n    d0 = d; index = i;\n  }\n}\n\nvoid tryvertex(vec3 pos, vec3 A, vec3 P, vec3 nQ, vec3 nR, vec3 nS, int i, inout float d0, inout int index) {\n#if 1\n  float d = length(pos-P)-swidth;\n  if (d < d0) {\n    d0 = d; index = i;\n  }\n#else\n  float d = d0;\n  float t = 0.25;\n  //t = 0.5+0.5*sin(iTime);\n  //t = 0.8;\n  vec3 A1 = t*A + (1.0-t)*P;\n  d = min(d,face(pos,A1,nQ,nR)-fwidth);\n  d = min(d,face(pos,A1,nR,nS)-fwidth);\n  d = min(d,face(pos,A1,nS,nQ)-fwidth);\n  if (d < d0) { d0 = d; index = i; }\n#endif\n}\n\nfloat dualscene(vec3 pos, out int index) {\n  // For diagram: o-o-o-o\n  bool mp = bool(T[0]), mq = bool(T[1]);\n  bool mr = bool(T[2]), ms = bool(T[3]);\n  // Based on consideration of the Coxeter-Dynkin diagram:\n  // Dual node A appears if any of the b,c,d mirrors\n  // are activated, unless the diagram is 'o o-o', ie.\n  // a prism in which case the isolated node must be\n  // activated as well as one of the others (as is the\n  // case for Q and R in type T0).\n  float d = 1e8;\n#if TYPE==T0\n  // P-Q-R-S\n  if (mq || mr || ms) tryvertex(pos,A,P,-pQ.xyz,-pR.xyz,-pS.xyz,1,d,index);\n  if (mp && (mr || ms)) tryvertex(pos,A,Q,-pR.xyz,-pS.xyz,-pP.xyz,2,d,index);\n  if (ms && (mp || mq)) tryvertex(pos,A,R,-pS.xyz,-pP.xyz,-pQ.xyz,3,d,index);\n  if (mp || mq || mr) tryvertex(pos,A,S,-pP.xyz,-pQ.xyz,-pR.xyz,4,d,index);\n#elif TYPE==T1\n  // P\n  //  \\\n  //   R-S\n  //  /\n  // Q\n  if (mq || mr || ms) tryvertex(pos,A,P,-pQ.xyz,-pR.xyz,-pS.xyz,1,d,index);\n  if (mp || mr || ms) tryvertex(pos,A,Q,-pR.xyz,-pS.xyz,-pP.xyz,2,d,index);\n  if (ms && mp && mq) tryvertex(pos,A,R,-pS.xyz,-pP.xyz,-pQ.xyz,3,d,index);\n  if (mp || mq || mr) tryvertex(pos,A,S,-pP.xyz,-pQ.xyz,-pR.xyz,4,d,index);\n#elif TYPE==T2\n  // P-R\n  // | |\n  // S-Q\n  if (mq || mr || ms) tryvertex(pos,A,P,-pQ.xyz,-pR.xyz,-pS.xyz,1,d,index);\n  if (mp || mr || ms) tryvertex(pos,A,Q,-pR.xyz,-pS.xyz,-pP.xyz,2,d,index);\n  if (ms || mp || mq) tryvertex(pos,A,R,-pS.xyz,-pP.xyz,-pQ.xyz,3,d,index);\n  if (mp || mq || mr) tryvertex(pos,A,S,-pP.xyz,-pQ.xyz,-pR.xyz,4,d,index);\n#endif\n  float d0 = d;\n  // Again, look at reduced diagram with just 2 nodes -\n  // if connected, either mirror will do, if isolated,\n  // need both.\n#if TYPE==T0\n  if (mr || ms) d = min(d,segment(pos,P,Q)-twidth);\n  if (mq && ms) d = min(d,segment(pos,P,R)-twidth);\n  if (mq || mr) d = min(d,segment(pos,P,S)-twidth);\n  if (mp && ms) d = min(d,segment(pos,Q,R)-twidth);\n  if (mp && mr) d = min(d,segment(pos,Q,S)-twidth);\n  if (mp || mq) d = min(d,segment(pos,R,S)-twidth);\n#elif TYPE==T1\n  if (mr || ms) d = min(d,segment(pos,P,Q)-twidth);\n  if (mq && ms) d = min(d,segment(pos,P,R)-twidth);\n  if (mq || mr) d = min(d,segment(pos,P,S)-twidth);\n  if (mp && ms) d = min(d,segment(pos,Q,R)-twidth);\n  if (mp || mr) d = min(d,segment(pos,Q,S)-twidth);\n  if (mp && mq) d = min(d,segment(pos,R,S)-twidth);\n#elif TYPE==T2\n  if (mr && ms) d = min(d,segment(pos,P,Q)-twidth);\n  if (mq || ms) d = min(d,segment(pos,P,R)-twidth);\n  if (mq || mr) d = min(d,segment(pos,P,S)-twidth);\n  if (mp || ms) d = min(d,segment(pos,Q,R)-twidth);\n  if (mp || mr) d = min(d,segment(pos,Q,S)-twidth);\n  if (mp && mq) d = min(d,segment(pos,R,S)-twidth);\n#endif\n  if (d != d0) index = 8;\n  return d;\n}\n\nfloat mainscene(vec3 p, out int index) {\n  float d,d0 = 1e8;\n  d = length(p-A)-swidth;\n  if (d < d0) { d0 = d; index = 0; }\n  d = segment(p,A,pA)-twidth;\n  if (d < d0) { d0 = d; index = 1; }\n  d = segment(p,A,qA)-twidth;\n  if (d < d0) { d0 = d; index = 2; }\n  d = segment(p,A,rA)-twidth;\n  if (d < d0) { d0 = d; index = 3; }\n  d = segment(p,A,sA)-twidth;\n  if (d < d0) { d0 = d; index = 4; }\n  d = 1e8;\n  if (key(CHAR_0+1)) d = min(d,face(p,A,-pP.xyz,-pQ.xyz)-fwidth);\n  if (key(CHAR_0+2)) d = min(d,face(p,A,-pQ.xyz,-pR.xyz)-fwidth);\n  if (key(CHAR_0+3)) d = min(d,face(p,A,-pR.xyz,-pP.xyz)-fwidth);\n  if (key(CHAR_0+4)) d = min(d,face(p,A,-pP.xyz,-pS.xyz)-fwidth);\n  if (key(CHAR_0+5)) d = min(d,face(p,A,-pQ.xyz,-pS.xyz)-fwidth);\n  if (key(CHAR_0+6)) d = min(d,face(p,A,-pR.xyz,-pS.xyz)-fwidth);\n  if (d < d0) { d0 = d; index = 5; }\n  return d0;\n}\n\nfloat getdist(vec3 p, out int index) {\n  float iscale = 1.0;\n  int flips = 0;\n  if (doinvert) {\n    flips++;\n    // Invert in sphere, radius 2.\n    float r2 = 0.5*dot(p,p);\n    p /= r2;\n    iscale = r2;\n  }\n  p = fold(p,flips);\n#if defined SNUB\n  float d = flips%2 == 0 ? snubscene0(p,index) : snubscene1(p,index);\n#else\n  float d1,d = 1e8;\n  int index1;\n  if (showmain) {\n    d1 = mainscene(p,index1);\n    if (d1 < d) { d = d1; index = index1; }\n  }\n  if (showdual) {\n    d1 = dualscene(p,index1);\n    if (d1 < d) { d = d1; index = index1; }\n  }\n#endif\n  return iscale*d;\n}\n\nfloat eval(vec3 p) {\n  vec3 p0 = p;\n  int index;\n  float d = getdist(p,index);\n  if (doclip) {\n    if (doinvert) {\n      d = max(d,length(p0)-clipsphere); // Intersect with sphere\n    } else {\n      // Intersect with cube sides\n      d = max(d,abs(p0.x)-clipcube);\n      d = max(d,abs(p0.y)-clipcube);\n      d = max(d,abs(p0.z)-clipcube);\n    }\n  }\n  return d;\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),\n                        eval(p + e.yxy) - eval(p - e.yxy),\n                        eval(p + e.yyx) - eval(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float precis = 0.001; // Should be resolution dependent\n  float t = 0.25; // Start a little way from the eye - less occlusion.\n  for (int i = 0; i < 200 && t < maxdepth; i++) {\n    // Do we need a rate limiter?\n    float h = eval(ro + rd * t);\n    // Rate limit and apply fudge for inversion.\n    if (doinvert) h = min(1.0,0.6*h);\n    t += h;\n    if (h < t*precis) return t;\n  }\n  return -1.0;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 getcolor(vec3 pos) {\n  int index;\n  getdist(pos,index);\n  assert(index >= 0 && index < colors.length());\n  return 0.2+0.6*colors[index];\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nvec4 gettrilinear(int n) {\n  n = mymod(n,15);\n  return 1.0-vec4(float((n>>0)&1),float((n>>1)&1),float((n>>2)&1),float((n>>3)&1));\n}\n\nvec4 gettrilinear() {\n  float t = 0.5*iTime;\n  int i = int(t);\n  doinvert = doinvert != (i/30%2 == 1);\n  doclip = doclip != (i/60%2 == 1);\n  float k = 0.0;\n  if (domorph) k = fract(t);\n  return mix(gettrilinear(i/2),gettrilinear((i+1)/2),k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  showdual = !key(CHAR_D);\n  showmain = !key(CHAR_A);\n  doclip = key(CHAR_C);\n  doinvert = key(CHAR_I);\n  dorotate = !key(CHAR_R);\n  dotranslate = key(CHAR_Z);\n  domorph = !key(CHAR_V);\n\n#if defined TEST\n  //doinvert = true;\n  showdual = false;\n#endif\n  \n#if defined SNUB\n  T = vec4(1);\n#else\n  int n = mymod(keycount(KEY_RIGHT)-keycount(KEY_LEFT),16);\n  if (n == 0) T = gettrilinear();\n  else T = gettrilinear(n-1);\n#endif\n  centre = mymod(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP),4);\n  init(T);\n  vec2 p = (2.0*fragCoord.xy - iResolution.xy)/ iResolution.y;\n  vec3 ro = vec3(0, 0, 6.0);\n  //vec3 ro = vec3(0, 0, -0.2*iTime);\n  vec3 rd = normalize(vec3(p, -2.0));\n  if (key(CHAR_O)) ro = vec3(0);\n  ro = transform(ro);\n  ro *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  rd = transform(rd);\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  light = transform(light);\n\n  float t = march(ro,rd);\n  vec3 col = (doclip || doinvert) ? 0.05*(1.0-p.y)*vec3(1,0,1) : vec3(1,1,0.5);\n  if (t > 0.001) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    vec3 basecol = getcolor(pos);\n    float diffuse = clamp(dot(n, light), 0.0, 1.0);\n    float specular = pow(max(0.0,dot(reflect(light,n),vec3(rd))),4.0);\n    vec3 c = basecol;\n    c *= 0.3+0.5*diffuse;\n    vec3 speccol = basecol;\n    c += 0.3*specular*speccol;\n    col = mix(c,col,clamp((t-fogstart)/(maxdepth-fogstart),0.0,1.0));\n  }\n  if (key (CHAR_M)) col = vec3(0.333*dot(col,vec3(1)));\n  col = pow(col, vec3(0.4545));\n  if (alert != 0) col = vec3(1,0,0);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_O = 79; // Put viewpoint at origin\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2515, 2515, 2539, 2539, 2565], [4148, 4148, 4199, 4199, 4298], [4300, 4300, 4336, 4392, 5488], [5850, 5907, 5936, 5936, 5994], [5996, 5996, 6013, 6013, 6038], [6039, 6039, 6056, 6056, 6090], [6091, 6091, 6108, 6108, 6133], [6134, 6134, 6151, 6151, 6176], [6277, 6277, 6298, 6298, 7045], [7047, 7047, 7091, 7091, 7362], [7364, 7364, 7403, 7403, 7544], [9016, 9016, 9090, 9090, 9169], [9171, 9171, 9280, 9280, 9639], [9641, 9641, 9683, 9709, 12334], [12336, 12336, 12376, 12376, 13186], [13188, 13188, 13226, 13226, 13762], [13764, 13764, 13784, 13784, 14126], [14128, 14226, 14262, 14262, 14314], [14316, 14316, 14344, 14344, 14560], [14562, 14562, 14599, 14599, 15003], [15005, 15005, 15032, 15032, 15361], [15363, 15363, 15388, 15388, 15506], [15508, 15508, 15533, 15573, 15628], [15630, 15630, 15656, 15656, 15761], [15763, 15763, 15784, 15784, 16006], [16008, 16008, 16065, 16065, 17627]], "test": "untested"}
{"id": "WdfcRM", "name": "Tripattern", "author": "jahnertz", "description": "Just an exercise", "tags": ["triangle", "pattern", "cineshader"], "likes": 14, "viewed": 3056, "published": 3, "date": "1584328502", "time_retrieved": "2024-07-30T21:18:20.739210", "image_code": "float tri(vec2 st, float pct){\n  return 1.0 - smoothstep( pct, pct+0.05, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 color_a = vec3(uv.x * 0.2 + 0.8,0.2,0.0);\n    vec3 color_b = vec3(0.0,0.1,uv.y * 0.5 + 0.5);\n    vec3 color_c = vec3(0.6,0.5,0.0);\n    float s = 10.0;\n    uv *= s;\n    uv.x += iTime;\n    float y1 = mod(uv.x,1.0) + sin(uv.x / s + iTime * 2.0)+ sin(uv.y / s + iTime);\n    float y2 = mod(uv.x,1.0) + sin(uv.x / s + iTime + 1.0 * 2.0) + sin(uv.y / s + iTime);\n    vec3 col = color_a + vec3(tri(mod(uv,1.0), y1) * color_b + vec3(tri(mod(uv,1.0), y2)) * color_c);\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,col.r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 81], [83, 83, 140, 190, 889]], "test": "untested"}
{"id": "wdfcz4", "name": "axis&circle_indere", "author": "indere", "description": "axis", "tags": ["2d"], "likes": 2, "viewed": 309, "published": 3, "date": "1584327846", "time_retrieved": "2024-07-30T21:18:21.621850", "image_code": "\nvec3 drawGrid(float step, vec3 color, vec2 uv){\n    float len = 0.005;\n    float blur = 0.01;\n    vec3 res = vec3(1.0);\n    \n    \n\tif(abs(uv.x - floor(uv.x/step) * step) < len \n       || abs(uv.x - ceil(uv.x / step) * step) < len\n       || abs(uv.y - floor(uv.y/step) * step) < len \n       || abs(uv.y - ceil(uv.y / step) * step) < len\n      )\n        res = color;\n   \t\n    //y_axis\n    if(abs(uv.x) < len)\n        res = vec3(1.0,.0,0.0);\n    \n   \t//x_axis\n    if(abs(uv.y) < len)\n        res = vec3(0.0,.0,1.0);\n\t\n    return res;\n}\n\nvec3 drawCircle(vec2 center, float radius, vec2 uv, bool full){\n\tfloat e = 0.01;\n    float len = length(center - uv);\n    if(full)\n        return vec3(smoothstep(radius - e, radius, abs(len - radius)));\n    return vec3(smoothstep(0.0, e, abs(len - radius))); \n}\n\nvec3 drawSegement(vec2 begin, vec2 end, vec2 uv, float width){\n\tvec2 dis = end - begin;\n    vec2 dis1 = uv - begin;\n    \n    float t = clamp(dot(dis1, dis) / dot(dis , dis), 0.0, 1.0);\n    float d = length(dis1 - dis * t);\n    return vec3(smoothstep(0.0, width, d));\n    \n   \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 backGroundColor = vec3(1.0, 1.0, 1.0);\n    \n    \n    // pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \tuv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\t\n    \n    //grid\n    float step = 0.2;\n    vec3 c = vec3(0.8);\n    vec3 gridColor = drawGrid(step, c, uv);\n    \n    //circle\n    float radius = 0.5;\n    vec2 circleCenter = vec2(.0);\n    vec3 circleLine = drawCircle(circleCenter, radius, uv, false);\n    \n    //rotation/move point\n    float pointRadius = 0.05;\n    vec2 pointCenter = vec2(cos(iTime), sin(iTime));\n    pointCenter *= radius;\n    vec3 point = drawCircle(pointCenter, pointRadius, uv, true);\n    \n    //segement\n    vec2 begin = vec2(.0);\n    vec2 end = pointCenter;\n    float width = 0.01;\n    vec3 segement = drawSegement(begin, end, uv, width);\n    \n    vec3 color = backGroundColor * gridColor * circleLine * point *segement;\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 48, 48, 533], [535, 535, 598, 598, 796], [798, 798, 860, 860, 1075], [1079, 1079, 1136, 1136, 2093]], "test": "untested"}
{"id": "tslczN", "name": "Saturn & Titan (SS11)", "author": "angelo12", "description": "Inspire by https://solarsystem.nasa.gov/planets/saturn/by-the-numbers/ and KSP.", "tags": ["sdf", "space", "shadersundays"], "likes": 8, "viewed": 683, "published": 3, "date": "1584321473", "time_retrieved": "2024-07-30T21:18:22.518453", "image_code": "/*\n\tShader Sundays! (11/52) \n\t\"Saturn & Titan!\"\n\n    The inspiration for this shader came from the beautiful NASA pictures you see below.\n\tSpecifically this one: \n\thttps://d.ibtimes.co.uk/en/full/1653195/saturn-rings.jpg\n\thttps://solarsystem.nasa.gov/planets/saturn/overview/\n\n\tI added Titan because it has such a nice color and it broke the monotony of the scene a \n\tbit. I cannot wait for KSP2 to come out :D!\n*/\nfloat\nhash(vec2 n){\n    return fract(sin(dot(n,vec2(12.9898, 4.1414)))*43758.5453);\n}\n\nfloat\nsdRing(vec3 p)\n{\n    vec3 pos = p - vec3(-0., -0.00, 0.0);\n\n    float r = length(vec2(pos.x, pos.z));\n    float ringSize = 2.0;\n    float d = sdBox(pos, vec3(ringSize, 0.00002, ringSize));\n    if(r > ringSize || r < 1.35) d += 0.001;\n    if(r > 1.75 && r < ringSize - 0.18)  d += 0.001;\n    if(r > 1.975 && r < ringSize - 0.02)  d += 0.001;\n\n    return d;\n}\n\n#define SATURN_ID 0.0\n#define MOON_ID 1.0\n#define RING_ID 2.0\nvec2\nMap(vec3 p)\n{\n    vec2 res = vec2(1e10, -1.0);\n\n    UOP(sdSphere(p, 0.85), SATURN_ID);\n    UOP(sdRing(p), RING_ID);\n\n    float ang = -iTime/ 12.0 + M_PI;\n    float rad = 1.5;\n    UOP(sdSphere(p - vec3(rad*sin(ang), 0.2, rad*cos(ang)), 0.05), MOON_ID);\n\n    return res;\n}\n\n#define MAX_DIST 20.0\n#define MIN_DIST 0.0001\n#define MAX_STEPS 200\nvec2\nRayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec2 res = vec2(-1.0, -1.0);\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i)\n    {\n        vec2 hit = Map(ro + t*rd);\n        if(abs(hit.x) < t* MIN_DIST)\n        {\n            res = vec2(t, hit.y);\n            break;\n        }\n        t+= hit.x;\n    }\n\n    return res;\n}\n\nvec3\nCalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,\n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x\n    ));\n}\n\nvec3\nMaterial(float id, vec3 pos)\n{\n    vec3 col = vec3(1.0);\n\n    if(id == SATURN_ID )\n    {\n        vec2 uv = vec2(atan(pos.x, pos.z) / (2.0*M_PI) + 0.5, pos.y *0.5 + 0.5);\n        col = vec3(0.789, 0.765, 0.43);\n        if(uv.y > 0.91) col *= 0.95;\n    }\n\n    if(id == RING_ID )\n    {\n        float r = length(pos.xz);\n        r -= 1.0;\n        r = 1.0 - r;\n        col = mix(vec3(0.875, 0.7, 0.097) * 0.2, vec3(0.875, 0.7, 0.5)*1.0, r);\n    }\n\n    if(id == MOON_ID) col = vec3(0.25, 0.6, 0.375);\n\n    return col;\n}\n\nfloat\nCalcShadow(vec3 ro, vec3 rd)\n{\n    for(float t = 0.10; t < MAX_DIST;)\n    {\n        float h = Map(ro + t*rd).x;\n\n        if(h < MIN_DIST)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3\nRender(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    vec2 res = RayMarch(ro, rd);\n    float t = res.x;\n    float id = res.y;\n\n    //Sky\n    col += vec3(1.0) * pow(hash(uv * vec2(13.0, 2.2)), 703.58);\n    col *= 6.0;\n\n    //Opaque\n    if(id >= 0.0)\n    {\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormal(P);\n\n        //Material\n        col = Material(id, P);\n\n        //Lighting\n        vec3 lin = vec3(0.0);\n        float ang = M_PI / 4.2 + iTime / 25.0 ;\n        vec3 L = normalize(vec3(cos(ang), 0.5, sin(ang)));\n        float diff = saturate(dot(L, N));\n        float amb = 0.05;\n\n        //Shadowing\n        diff *= CalcShadow(P, L);\n\n        //Shading\n        float isRing =  (id == RING_ID) ? 0.0 : 1.0;\n        isRing *= P.y * 6.0;\n        lin += 0.07 * amb  * vec3(1.0) * isRing;\n        lin += 1.2 * diff * vec3(1.0, 1.0, 1.0);\n        col *= lin;\n    }\n    return saturate(col);\n}\n\n#define AA 2\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    float nearP = 1.8;\n    float roll = 0.0;\n    vec3 tot = vec3(0.0);\n\n#if AA > 1\n    for(int i =0; i < AA; ++i)\n    for(int j =0; j < AA; ++j)\n    {\n        vec2 offset = 0.5 - vec2(i, j)/ float(AA);\n        vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = ((fragPos) - 0.5*iResolution.xy)/iResolution.y;\n#endif\n\n        vec3 ta = vec3(0.0, 0.00, 0.0);\n        vec3 ro = ta + vec3(0.0, 1.7, -4.5);\n        mat3 cam = SetCamera(ro, ta, roll);\n        vec3 rd = cam * normalize(vec3(uv, nearP));\n        vec3 col = Render(ro, rd, uv);\n\n        GAMMA(col);\n        tot += col;\n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//Comment this out if running this file on shadertoy\n#define SHADERTOY \n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat\nsdGroundPlane(vec3 p)\n{\n    return p.y;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Camera functions------------------------------\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n\n//--------------------------------------------------------------------------------------\n//----------------------------------Post processing functions----------------------------\n#define GAMMA(col) col = pow(col, vec3(INV_GAMMA))\n\n\n//---------------------------------------------------------------------------------------- \n//----------------------------------Basic functions---------------------------------------\n#ifdef SHADERTOY\n#define saturate(col) clamp(col, 0.0, 1.0)\n#endif\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 415, 434, 434, 500], [502, 502, 524, 524, 865], [929, 929, 947, 947, 1204], [1274, 1274, 1307, 1307, 1610], [1612, 1612, 1637, 1637, 1866], [1868, 1868, 1903, 1903, 2386], [2388, 2388, 2424, 2424, 2595], [2597, 2597, 2637, 2637, 3531]], "test": "untested"}
{"id": "tdscz4", "name": "animation_PM", "author": "KofeyOK", "description": "wave PM", "tags": ["animated"], "likes": 2, "viewed": 287, "published": 3, "date": "1584315674", "time_retrieved": "2024-07-30T21:18:23.563659", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) { //функція для створення кола\n float d = length(uv-p);\n float c = smoothstep(r, r-blur, d);\n\n return c;\n}\nfloat Band (float t, float start, float end, float blur) //функція для створення смужки\n{\nfloat step1 = smoothstep(start-blur, start+blur, t);\n float step2 = smoothstep(end+blur, end-blur, t);\n\n return step1*step2;\n}\nfloat Rect (vec2 uv, float left, float right, float //функція для створення прямокутника\nbottom, float top, float blur) {\nfloat band1 = Band(uv.x, left, right, blur);\nfloat band2 = Band(uv.y, bottom, top, blur);\n\nreturn band1*band2;\n}\nfloat smiley (vec2 uv, vec2 p, float size){ //функція для створення смайла :)\nuv -= p; //translating coordinate systems\n uv /= size; //scaling coordinate systems\n\n float mask = Circle (uv, vec2(.0), .4, .01);\n\n mask -= Circle (uv, vec2(-.13, .2), .07, .01);\n mask -= Circle (uv, vec2(.13, .2), .07, .01);\n\nfloat mouth = Circle (uv, vec2(.0, .0), .3, .02);\n mouth -= Circle (uv, vec2(.0, 0.1), .3, .02);\n\n mask -= mouth;\n\n return mask;\n }\nfloat remap01 (float a, float b, float t){ //нормалізує значення t; 0<=t<=1\n return (t-a) / (b-a);\n}\nfloat remap (float a, float b, float c, float d, float // c<=t<=d\nt){\n return remap01 (a, b, t) * (d-c) + c;\n}\nfloat PIlike(vec2 uv, vec2 p, float size){\n uv -= p; //translating coordinate systems\n uv /= size; //scaling coordinate systems\n float x1 = uv.x;\n\n float m = sin(+x1*8.) *.1; // змінюється з часом і зростанням х\n \n m = m*m*4.;\n float y1 = uv.y-m; // -m перетворює прямокутник на синусоїду, яка змінюється з часом\n \n float y2 = uv.y;\n float m2 = sin(+y2*8.) *.1;\n float x2  = uv.x-m2;\n //float m = (x-.5)*(x+.5);  // цей блок коду змінює вигляд фігури\n \n //float y = uv.y+m; \n\n //x+= y;  // нахил фігури\n\n float blur = remap(-.1, .1, .01, .05, y1); // збільшує розмиття зі зростанням х\n //blur *= pow(blur*4., 3.);\n float mask = Rect (vec2(x1, y1), -.5, .5, .1, .3, blur); //будуємо фігуру\n mask += Rect (vec2(x2, y2), -.5, -.3, -0.2, 0.16, .04);\n mask += Rect (vec2(x2, y2), 0., 0.2, -0.2, 0.16, .04);\n float wheel = Circle(uv, vec2(0.,-0.2), 0.16, .07);\n mask+=wheel;\n    \n return mask;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1.\n\n    float t = iTime; // час\n    uv -= .5; // -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n\tfloat m = sin(t+uv.x*8.) *.1; // змінюється з часом і зростанням х\n \tuv.y -=m;\n    vec3 col = vec3(0.);\n\n    float mask = 0.;\n\tmask = Rect(uv, -.7, -.55, -.3, .3, .001);\n    mask += Rect(uv, -.3, -0.15, -.3, .3, .001);\n    mask += Rect(uv, -.7, -0.15, .15, .3, .001);\n    mask += Rect(uv, .1, 0.2, -.3, .3, .001);\n    mask += Rect(uv, .55, 0.65, -.3, .3, .001);\n    mask += Rect(vec2(uv.x+uv.y*0.23,uv.y), 0.225, 0.325, -.3, .3, .003);\n    mask += Rect(vec2(uv.x-uv.y*0.23,uv.y), 0.425, 0.525, -.3, .3, .003);\n    //mask = PIlike(uv, vec2(0.),1.);\n    col = vec3(1., 1., 1.)*mask;\n\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdscz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 104, 180], [181, 181, 295, 295, 422], [423, 423, 575, 575, 688], [689, 689, 732, 791, 1151], [1152, 1152, 1194, 1245, 1270], [1271, 1271, 1340, 1340, 1381], [1382, 1382, 1424, 1424, 2432], [2434, 2434, 2489, 2489, 3297]], "test": "untested"}
{"id": "tdlcRN", "name": "Another Diamond Cubic", "author": "mla", "description": "Another diamond cubic, inspired by [url]https://www.shadertoy.com/view/lsG3RG[/url] by kqyrt and using some code from [url]https://www.shadertoy.com/view/WdsyzH[/url] by Axioplase.\n\nNow with controls: see code.", "tags": ["diamond", "monochrome", "cubic"], "likes": 10, "viewed": 465, "published": 3, "date": "1584315251", "time_retrieved": "2024-07-30T21:18:24.881136", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Diamond Cubic structure\n//\n// Each 2x2x2 region is divided into 8 cubic cells, alternately type 0 and type 1\n// Type 0 has an atom at alternating corners and at the centre, the central\n// atom has a bond with each corner atom. Type 1 has an atom at the other set\n// of alternating corners and is otherwise empty. The corner atoms overlap\n// between cells.\n//\n// Controls:\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <left>/<right>: fog distance\n// i: apply inversion\n// s: swap cell types\n// r: show fundamental region\n//\n// For further details, see:\n// https://en.wikipedia.org/wiki/Diamond_cubic\n//\n// Another nice diamond cubic shader:\n// https://www.shadertoy.com/view/lsG3RG by kqyrt\n//\n// This shader uses some code from;\n// https://www.shadertoy.com/view/WdsyzH[/url] by Axioplase\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\nint maxsteps = 200;\nfloat maxdist = 15.0;\nfloat pradius = 0.3;  // Point radius\nfloat lradius = 0.1;  // Line radius\nbool dorotate = true; // Autorotate\nbool doinvert = true;\nbool doswap = false;\nbool showregion = false;\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat point(vec3 p, vec3 q) {\n  return distance(p,q);\n}\n\nfloat cell0(vec3 p, out int type) {\n  vec3 p0 = vec3(0);\n  vec3 p1 = vec3(1,1,1);\n  vec3 p2 = vec3(-1,-1,1);\n  vec3 p3 = vec3(1,-1,-1);\n  vec3 p4 = vec3(-1,1,-1);\n  type = 0;\n  float d = 1e8, d0 = d;\n  d = min(d, point(p,p0)-pradius);\n  d = min(d, point(p,p1)-pradius);\n  d = min(d, point(p,p2)-pradius);\n  d = min(d, point(p,p3)-pradius);\n  d = min(d, point(p,p4)-pradius);\n  if (d < d0) { d0 = d; type = 1; }\n  d = min(d, segment(p,p0,p1)-lradius);\n  d = min(d, segment(p,p0,p2)-lradius);\n  d = min(d, segment(p,p0,p3)-lradius);\n  d = min(d, segment(p,p0,p4)-lradius);\n  if (d < d0) { d0 = d; type = 2; }\n  return d;\n}\n\nfloat cell1(vec3 p, out int type) {\n  vec3 p1 = vec3(-1,1,1);\n  vec3 p2 = vec3(1,-1,1);\n  vec3 p3 = vec3(1,1,-1);\n  vec3 p4 = vec3(-1,-1,-1);\n  type = 0;\n  float d = 1e8, d0 = d;\n  d = min(d, point(p,p1)-pradius);\n  d = min(d, point(p,p2)-pradius);\n  d = min(d, point(p,p3)-pradius);\n  d = min(d, point(p,p4)-pradius);\n  if (d < d0) { d0 = d; type = 1; }\n  return d;\n}\n\nfloat getdist(vec3 p, out int type) {\n  float k = 1.0;\n  if (doinvert) {\n    k = 0.3*dot(p,p);\n    p /= k;\n  }\n  if (!showregion) {\n    // Space division into 4x4x4 cubes\n    p = mod(p+1.0,4.0)-2.0; // [-1,+3] -> [-2,+2]\n  }\n  // Parity of cell index\n  int celltype = (int(p.x < 0.0)+int(p.y < 0.0)+int(p.z < 0.0)) % 2;\n  if (doswap) celltype = 1-celltype;\n  // mod not used for next step to preserve fundamental region.\n  p += 1.0-2.0*step(0.0,p); // x -> x < 0 ? x+1 : x-1\n  return k*(celltype == 0 ? cell0(p,type) : cell1(p,type));\n}\n\nfloat getdist(vec3 p) {\n  int type;\n  return getdist(p,type);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  float precis = 0.0005;\n  for(int i = 0; i < maxsteps; i++) {\n    vec3 p = ro + t*rd;\n    float d = getdist(p);\n    // Longer distance estimates with inversion are\n    // inaccurate, so clamp to avoid overstepping.\n    if (doinvert) d = min(d,1.0);\n    t += 0.6*d;\n    if (t > maxdist || abs(d) < t*precis) break;\n  }\n  return t;\n}\n\nvec3 getnormal(vec3 p) {\n  float d = getdist(p);\n  vec2 e = vec2(0.001, 0);\n  vec3 n = d - vec3(getdist(p-e.xyy),\n                    getdist(p-e.yxy),\n                    getdist(p-e.yyx));\n  return normalize(n);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return v * mix( vec3(1.0), rgb, s);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_O = 79;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 m = iMouse.xy/iResolution.y;\n  vec3 ro = vec3(0,0,-4);\n  vec3 rd = normalize(vec3(uv,2));\n  vec3 light = normalize(vec3(1,2,3));\n  doinvert = key(CHAR_I);\n  showregion = key(CHAR_R);\n  doswap = key(CHAR_S);\n  maxdist = 10.0*(exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT))));\n  ro.z += 0.25*float(keycount(KEY_UP)-keycount(KEY_DOWN));\n  ro = transform(ro);\n  rd = transform(rd);\n  float t = march(ro, rd);\n  vec3 basecol = hsv2rgb(0.1+0.01*iTime,1.0,1.0); //vec3(1,0.5,0);\n  vec3 col = mix(vec3(1),basecol,0.75);\n  if (t < maxdist) {\n    vec3 p = ro+t*rd;\n    int type;\n    getdist(p,type);\n    vec3 n = getnormal(p);\n    float diffuse = mix(1.0,dot(n,light),0.5);\n    float intensity = type == 1 ? 0.5 : 1.0;\n    vec3 c = diffuse*intensity*basecol;\n    float fog = t/maxdist;\n    col = mix(c,col,fog);\n  }\n    \n  col = pow(col,vec3(0.4545));\t// gamma correction\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else   \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1214, 1214, 1253, 1253, 1394], [1396, 1396, 1425, 1425, 1451], [1453, 1453, 1488, 1488, 2073], [2075, 2075, 2110, 2110, 2443], [2983, 2983, 3006, 3006, 3046], [3048, 3048, 3079, 3079, 3429], [3431, 3431, 3455, 3455, 3646], [3648, 3648, 3684, 3684, 3736], [3738, 3738, 3765, 3765, 4094], [4096, 4096, 4137, 4137, 4307], [4744, 4744, 4764, 4764, 4824], [4826, 4826, 4851, 4851, 4899], [4901, 4901, 4924, 4924, 4956], [4958, 4958, 5010, 5010, 5973]], "test": "untested"}
{"id": "wsfczN", "name": "Day 87", "author": "jeyko", "description": "i overshadered this one ", "tags": ["mdmtjvm"], "likes": 10, "viewed": 496, "published": 3, "date": "1584306902", "time_retrieved": "2024-07-30T21:18:25.770757", "image_code": "// THX NUSAN, whom I learned refract/reflect logic thing and this shader is inspired by his stuff, check him out on ST\n\n// Fork of \"Day 86\" by jeyko. https://shadertoy.com/view/wslcz8\n// 2020-03-15 10:54:20\n\n// Fork of \"Day 85\" by jeyko. https://shadertoy.com/view/WdfczH\n// 2020-03-14 09:43:07\n\n// Fork of \"Day 84\" by jeyko. https://shadertoy.com/view/Wssczn\n// 2020-03-13 10:52:05\n\n// radial blur and chromatic abberation in this buffer\n// thx iq for pallette and hg-sdf for polarMod\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,2.)*0.;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.4)*1.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*3.; \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    //1fragColor *= 18.;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*0.1));\n    fragColor *= 1. - dot(uvn,uvn)*1.;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime + 3.6 + 5.)\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\nvec3 att = vec3(1);\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(float t, float sm){\n\treturn mix(texture(iChannel0,vec2(floor(t)/256.)),texture(iChannel0,vec2(floor(t) + 1.)/256.), smoothstep(0.,1.,pow(fract(t), sm)));\n}\n\nfloat iii;\nfloat sdRhombus(vec3 p, vec3 s){\n    p = abs(p) - s;\n    float d = max(p.z, max(p.x, p.y));\n    d = max(d, dot(p.yx + s.yx*0.5, normalize(vec2(1.))));\n    d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1.))));\n    \n    return d;\n}\n\nvec2 guv;\nvec3 id;\nfloat speed = 0.5;\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    \n\tvec3 modD = vec3(3.57);\n    \n    \n    p -= modD*0.5;\n    \n    vec3 q = p;\n    \n    id = floor(q/modD);\n    q = pmod(q,modD);\n    \n    \n    for(int i = 0; i < 9  ; i++){\n    \tiii = pModPolar(q.xz, 5.);\n    \tq.x -= 0.3 + sin(iTime)*0.0;\n        //q.y -= 0.2;\n        q.xy *= rot(0.5*PI);\n    }\n    \n    //q.x -= 0.1;\n    \n    q.x -= 0.38 - valueNoise(iTime +10., 2.).x*0.1;\n    q.y += 0.1 + valueNoise(iTime, 2.).x*0.2;\n    //q.xz *= rot(0.2);\n    q = abs(q);\n    \n    //float da=length(q) - 0.11;\n    float da=sdRhombus(q, vec3(0.12));\n    float db=max(q.x,max(q.z, q.y)) - 0.1;\n    d = dmin(d, vec2(da, 3.));\n    \n    d = dmin(d, vec2(db, 1.));\n    \n    \n    float dg = da;\n    //glow += exp(-d.x*30.)*att*vec3(0.6,0.3,0.1);\n    \n    vec3 gB = 0.02/(0.01 + db*db*db*db*200000.1)*vec3(0.9,0.1 + guv.x*0.2,0.1 );\n    \n    vec3 gA = 0.02/(0.01 + dg*dg*dg*dg*10000.1)*vec3(0.6,0.3,0.1 + guv*0.1);\n    \n    p += modD*0.5;\n    \n    \n    float lp = length(p + sin(p*50. + iTime)*0.5);\n    \n    float lpb = length(p );\n    \n    lpb = abs(lpb);\n    \n    \n    d = dmin(d, vec2(abs(length(p + + sin(p*80. + iTime)*0.0) - 0.12) + 0.006, 18.));\n    \n    \n    //vec3 cc = vec3(0.8,0.6,1.);\n    //vec3 cc = vec3(0.2,0.1,1.);\n    vec3 cc = vec3(0.17,0.14 + length(p)*0.9,1.);\n    \n    \n    cc = clamp(cc, 0., 1.);\n    //cc = pal(1.,1.,vec3(0.8,0.4,0.6),2.5,0.4 + iTime)*0.5;\n    \n    vec3 gC = exp(-lp*lp* (10. - 1.*pow(abs(sin(iTime)), 20.)))*cc*3.;\n    vec3 gD = exp(-lpb*lpb* (20. - 4.*pow(abs(sin(iTime)), 20.)))*cc*3.;\n    \n    float lgB = smoothstep(1.,0.,length(gA)*2.7);\n    \n    //float aaaa\n    \n    glow += gA * vec3(1,0.8 ,1);\n    glow += gB*lgB;\n    //glow += gC;\n    glow += gD;\n    \n    \n\td.x *= 0.9;\n    return d;\n}\nfloat dith;\n\nfloat side;\nint it; // do not do this lol\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = map(p);\n\n    \n    if(d.x < 0.1)\n        ro += rd*0.15;\n    p = ro; t = 0.; hit = false;\n    for(it = 0; it < 60; it++){\n    \td = map(p);\n        d.x *= dith * side;\n        \n    \t//glow += exp(-d.x*20.);\n        if(d.x < 0.0001){\n        \thit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir ));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + (right*uv.x + up*uv.y)*1.2);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.0001,0);  \n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\n#define mx (2.*iMouse.x/iResolution.x)\n#define my (0.6*iMouse.y/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //\n\t//uv *= 1. - dot(uv,uv)*0.2;\n    uv.xy *= rot(sin((iTime*0.7 - 3.6))*0.3);\n    uv *= 1. + dot(uv,uv)*1.5;\n    \n    guv = uv;\n    vec3 col = vec3(0);\n\n    dith = mix(0.94,1., texture(iChannel0, 20.*uv*256.).x);\n    vec3 ro = vec3(0);\n    \n    ro.y += sin(iTime*speed)*0.54;\n    ro.y -= 0.2 - my;\n    \n    float n = pow(valueNoise(iTime*1./2., 1.).x, 2.);\n    \n    \n    //ro.y += sin(n);\n    float nb = pow(valueNoise(iTime*1./6., 1.).x, 1.);\n    //float zoom = 1.4 + n*2.4;\n    float zoom = 2. + n*0.4;\n    n *= 1.;\n    ro.xz += vec2(sin( nb*6.14*1.5 + mx),cos( nb*6.14*1.5+ mx))*zoom;\n    \n    vec3 lookAt = vec3(0,0.  + sin(iTime)*0.2,0.);\n    //lookAt.y += -1. + valueNoise(iTime*1./2.).x;\n    vec3 rd = getRd(ro, lookAt, uv);\n    //rd.yz *= rot(iTime);\n    \n    vec3 p; float t = 0.; bool hit;\n    float tA = 0.; side = 1.; float tF;\n    \n    \n    float fres;\n    int ii;\n    for(int i = 0; i < 3   ; i ++){\n    \tvec2 d = march(ro, rd, p, t, hit);\n    \tvec3 n = getNormal(p)*side;\n        \n        vec3 ld = normalize(vec3(1));\n        \n        float diff = max(dot(n, ld), 0.);\n        fres = pow(1. - max(dot(n, -rd), 0.), 5.);\n        \n        #define aa(j) clamp(map(p + n/j).x*j, 0.,1.)\n        \n        if(i == 0){\n            tF = t;\n            ii = it;\n        }\n        tA = max(tA,t);\n        \n        \n        \n        if (hit){\n            \n            if(d.y == 3.){\n                //col *= 20.2;\n                \n                //glow *= (0.8 + fres - diff*0.1)*att ;\n                glow *= vec3(1.)*(0.8 + fres*1.5*vec3(1.,0.5,0.5) - diff*0.6 )*att ;\n\t\t\t\tcol += diff*0.01*pal(1.,1.,vec3(0.8,2.2,2.5),0.5,0.5 + dot(n, -rd) *4. + iTime)*att;\n                break;\n                \n            } else if (d.y == 1.){\n                ro = p + n*0.08;\n                side *= -1.;\n                rd = refract(rd, n,0.99);\n                att *= vec3(0.8,0.8,0.65);\n                //col += spec*0.05*vec3(1,0.1,1)*att;\n                col += min(pow(fres, 2.), 1.)*0.05*pal(1.,1.,vec3(0.8,2.2,2.5),0.5,0.5 + dot(n, -rd) *100. + iTime)*att;\n                \n                //col += fres*0.04*vec3(0.7,0.,0.2)*att;\n                //break;\n            \n            } else {\n            \tbreak;\n            }\n        }\n        \n        if(abs(id.x ) > 1. || abs(id.y ) > 1. || abs(id.z ) > 1.   )\n            break;\n    }\n        \n\t\n    \n    //col = mix(col, vec3(0.4,0.9,0.7)*0.1, pow(smoothstep(0.,1.,tA*0.053), 1.6)*att);\n    \n    //col -= glow*(0.00);\n    \n    col *= 5.5;\n    \n    float fii = float(ii);\n    //vec3 bgc =vec3(0.1 - fii*0.01,0.9 - tF*0.01,0.6+ fii*0.003)*0.19;\n    //vec3 bgc =vec3(2.9 - fii*0.01,0.9 - tF*0.02,0.2 + fii*0.005)*0.05;\n    vec3 bgc =vec3(2.9 - fii*0.01,1.9 - tF*0.02,1.8 - fii*0.01)*0.05;\n    bgc = clamp(bgc, 0.,3.);\n    col = mix(col, bgc, pow(smoothstep(0.,1.,tF*0.043 + length(p)*0.07 - fii*0.01), 1.));    \n\n    col -= fii*0.0001 + fii*0.0001*(smoothstep(0.,1.,length(p)*0.2)); // thx lsdlive\n    \n\t//col = 1. - col;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 545, 545, 1607]], "test": "untested"}
{"id": "3dsczN", "name": "Bokeh particles - 8x voronoi", "author": "michael0884", "description": "Having 8 closest particles stored in the buffer at each point you can analytically compute a more or less accurate bokeh with any aperture without convolution. WIP", "tags": ["bokeh", "particles"], "likes": 15, "viewed": 957, "published": 3, "date": "1584293445", "time_retrieved": "2024-07-30T21:18:26.782053", "image_code": "// Fork of \"Pilot wave system II\" by michael0884. https://shadertoy.com/view/3sXyz4\n// 2020-03-15 15:39:20\n\n// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-14 14:30:34\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n   \n    return bloom;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    col = vec4(0.0);\n    ivec2 p = ivec2(pos);\n\tcol.xyz += pixel(ch0, pos).xyz;  \n    col.xyz += bloom(size.y*0.05, pos)*0.2; \n    col.xyz += bloom(size.y*0.01, pos)*0.2; \n    col.xyz = HDRmapping(col.xyz, 1.); \n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n//particle buffer\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n//force scalar\nfloat F(float d)\n{\n    d /= 2.*prad;\n    return 0.;\n}\n\n//force vector\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    if(!all(equal(p0,p1)))\n   \t return normalize(p1-p0)*F(distance(p1,p0));\n    else\n     return vec2(0.);\n}\n\n//get particle from array\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n   \t\t\n        float id = pos.x + float(N.x)*pos.y;\n        //neighbors\n   \t\tget(ivec2(U.xy));\n      \n        vec2 F = vec2(0.,0.);\n        \n        vec4 p0 = getParticle(ids[0]);\n        for(int i = 1; i < CN; i++)\n        {\n            vec4 pi = getParticle(ids[i]);\n        \tF += Fv(U.xy, pi.xy);    \n        }\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 3.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        F += 0.05*(hash21(id+3.2533*iTime) - 0.5)*length(U.zw);\n        \n        U.zw += dt*F;\n        \n        U.xy += U.zw*dt*(pow(hash11(float(ids[0])),2.));\n        \n        //border conditions\n        U.xy = modc(U.xy, size);\n \n        //this pixel value\n        if(iFrame<3)\n        {\n            U.xy = size*hash22(pos)+1.;\n\t\t\tU.zw = 12.*hash22(5.14159*pos)*(hash22(3.14159*pos) - vec2(0.5, 0.7));\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(14,14)\n#define dt 0.2\n#define prad 1.\n#define k 0.3\n#define ff 4.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\n//closest particle ids\n#define CN 8\nint ids[CN];\n//particle distances\nfloat ds[CN];\n\nivec2 one2two(int a)\n{\n    return ivec2(a%tot_n, a/tot_n);\n}\n\nint two2one(ivec2 a)\n{\n    return a.x + tot_n*a.y;\n}\n\nvoid toarr(inout int b[CN], ivec2 a, int i)\n{\n    b[i] = a.x;\n    b[i+1] = a.y;\n}\n\nvoid init()\n{\n    for(int i = 0; i<CN; i++)\n    {\n        ids[i] = -1;\n        ds[i] = 1e10;\n    }\n}\n\nvoid getA(inout int b[CN], ivec2 p)\n{ \n    ivec4 a = floatBitsToInt(texel(fake, p/2));\n    toarr(b, one2two(a.x), 0);\n    toarr(b, one2two(a.y), 2);\n    toarr(b, one2two(a.z), 4);\n    toarr(b, one2two(a.w), 6);\n}\n\nvoid get(ivec2 p)\n{\n    getA(ids, p);\n}\n\nvec4 save()\n{\n    ivec4 v = ivec4(two2one(ivec2(ids[0],ids[1])),\n                    two2one(ivec2(ids[2],ids[3])),\n                    two2one(ivec2(ids[4],ids[5])),\n                    two2one(ivec2(ids[6],ids[7])));\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}\n\nvec2 modc(vec2 x, vec2 y)\n{\n    return x - y*floor(x/y);\n}", "buffer_b_code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat repD(vec2 p0, vec2 p)\n{\n    return length(modc(p - p0 + size*0.5, size) - size*0.5);\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return repD(getParticle(id).xy, p);\n}\n\nvoid insert(int id, float d, int i)\n{\n    //shift all by 1\n    for(int j = CN-1; j > i; j--)\n    {\n        ids[j] = ids[j-1];\n        ds[j] = ds[j-1];\n    }\n    \n    //insert\n    ids[i] = id; \n    ds[i] = d;\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+1.;\n    float dtemp = particleDistance(utemp, pos);  \n    //sorting\n    for(int i = 0; i < CN; i++)\n    {\n        if(ids[i] == utemp) return;\n        \n        if(ids[i] < 0 || ds[i] >= dtemp)\n        {\n            insert(utemp, dtemp, i);\n            return;\n        }\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    int t[CN];\n    getA(t, (p + dx)%ivec2(iResolution.xy));\n    \n\tfor(int i = 0; i < CN; i++)\n    {\n   \t\tif(t[i]>=0)\n        \tsort(t[i], p);\n    }\n}\n\nvoid randupd(ivec2 p )\n{\n    for(int i = 0; i < 6; i++)\n    {\n        //go through the entire array sudorandomly\n        sort(((iFrame + p.x + p.y*int(iResolution.x))^(1<<i))%tot_n, p);\n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 2);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    pos *= 2.;\n    if(pos.x < iResolution.x && pos.y < iResolution.y) //8x voronoi particle tracking but in 2x lower res\n    {\n        ivec2 p = 2*ivec2(pos/2.);\n\n        init();\n\n        update(p);\n\n        U = save();\n    } else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat repD(vec2 p0, vec2 p)\n{\n    return length(modc(p - p0 + size*0.5, size) - size*0.5);\n}\n\nfloat aperture(vec2 x0, vec2 x, float r)\n{\n    float d = repD(x0, x)/r;\n    return 1.-tanh(15.*(d-1.));//+0.5*exp(-pow(abs(6.*(d-0.8)),2.));\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    get(p);\n   \tvec3 x = vec3(0.);\n    for(int i = 0; i < CN; i++)\n    {\n        vec4 pd = getParticle(ids[i]); \n        float ha = hash11(float(ids[i]));\n        float z = abs(45.0*sin(0.2*iTime + 2.0*3.14*ha));\n        x += 30.*(0.5*sin(3.*vec3(3,1,0.7)*ha) + 0.5)*aperture(pd.xy, pos, z)/(z*z);\n    }\n    col.xyz = x; \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 244, 244, 384], [386, 386, 431, 457, 571], [697, 697, 737, 737, 1027], [1030, 1030, 1075, 1075, 1289]], "test": "untested"}
{"id": "3dXyzN", "name": "Improved LBM", "author": "yuchengzhong", "description": "Base on https://www.shadertoy.com/view/lsG3zK (by ndel)\n", "tags": ["lbm"], "likes": 10, "viewed": 645, "published": 3, "date": "1584293348", "time_retrieved": "2024-07-30T21:18:27.769413", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int LatSizeX = int(iResolution.y/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    \n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    \n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    vec3 m00 = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).xyz;\n    vec3 m10 = texture(iChannel0, (vec2(2*ix+3,2*iy+1)+0.5)/iResolution.xy).xyz;\n    vec3 m01 = texture(iChannel0, (vec2(2*ix+1,2*iy+3)+0.5)/iResolution.xy).xyz;\n    vec3 m11 = texture(iChannel0, (vec2(2*ix+3,2*iy+3)+0.5)/iResolution.xy).xyz;\n    \n    vec3 m0 = mix(m00,m10,(fragCoord.x-2.0*float(ix))*0.5);\n    vec3 m1 = mix(m01,m11,(fragCoord.x-2.0*float(ix))*0.5);\n    vec3 m = mix(m0,m1,(fragCoord.y-2.0*float(iy))*0.5);\n    float rho = m.x;\n    float vx  = m.y;\n    float vy  = m.z;\n\n    fragColor = vec4((rho-1.0));\n    fragColor = 5.0*vec4(abs(2.0*vx-1.0),abs(2.0*vy-1.0),(2.0*rho-1.0),1.0);\n    //fragColor = 5.0*vec4((2.0*rho-1.0),(2.0*rho-1.0),(2.0*rho-1.0),1.0);\n    //fragColor = texture(iChannel0,vec2(fragCoord)/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    float rho = 0.0;\n    if(distance(iMouse.xy/2.0,vec2(ix,iy)) < 4.0)\n    {\n            vec3 objectVelocity = vec3(iMouse.xy/iResolution.xy,iMouse.w)-texture(iChannel0, (vec2(ix,iy)+0.5)/iResolution.xy).xyz;\n            objectVelocity *= 1000.0*iTimeDelta;     \n            rho =min(length(objectVelocity),0.5);\n            \n    }\n    fragColor = vec4(rho,0.0,0.0,0.0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n\n#define G 0.5\n#define w 0.9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int LatSizeX = int(iResolution.y/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    \n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    \n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }    \n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    \n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; \n    float rho, vx, vy;\n    if((iFrame==0))\n    {\n        rho = 1.0;\n        vx = vy = 0.0;\n        f0 = 1.0-5.0/6.0*G;\n        f1 = 1.0/6.0 *G;\n        f2 = 1.0/6.0 *G;\n        \n        f3 = 1.0/6.0 *G;\n        f4 = 1.0/6.0 *G;\n        f5 = 1.0/24.0*G;\n        \n        f6 = 1.0/24.0*G;\n        f7 = 1.0/24.0*G;\n        f8 = 1.0/24.0*G;\n    }\n    else\n    {\n        int xplus  = clamp(ix+1,0,LatSizeX-1);\n        int xminus = clamp(ix-1,0,LatSizeX-1);\n        int yplus  = clamp(iy+1,0,LatSizeY-1);\n        int yminus = clamp(iy-1,0,LatSizeY-1);\n\n        f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        \n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        \n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        vx = (1.0/rho)*(f1-f2+f5-f6-f7+f8);\n        vy = (1.0/rho)*(f3-f4+f5-f6+f7-f8);  \n        \n        \n        vx = clamp(vx,-0.999,0.999);\n        vy = clamp(vy,-0.999,0.999);\n        //rho = mix(rho,1.0,0.01);\n        rho = rho*0.999;\n        if(ix==0||ix==LatSizeX-1)//boundary condition\n        {\n            vx = -vx;\n        }\n        if(iy==0||iy==LatSizeY-1)//boundary condition\n        {\n            vy = -vy;\n        }\n        rho += texture(iChannel1, (fragCoord)/iResolution.xy).x;\n        rho = clamp(rho,1.0,1.5);        \n        \n        float sq_term = (vx*vx+vy*vy);\n        \n        float f0eq = rho*(1.0-10.0/12.0*G*rho-2.0/3.0*sq_term);\n        float f1eq = rho*(1.0/6.0 *G*rho+1.0/3.0 *vx     +vx*vx/2.0            -sq_term/6.0);\n        float f2eq = rho*(1.0/6.0 *G*rho-1.0/3.0 *vx     +vx*vx/2.0            -sq_term/6.0);\n        \n        float f3eq = rho*(1.0/6.0 *G*rho+1.0/3.0 *vy     +vy*vy/2.0            -sq_term/6.0);\n        float f4eq = rho*(1.0/6.0 *G*rho-1.0/3.0 *vy     +vy*vy/2.0            -sq_term/6.0);\n        float f5eq = rho*(1.0/24.0*G*rho+1.0/12.0*(vx+vy)+1.0/8.0*(vx+vy)*(vx+vy)-sq_term/24.0);  \n        \n        float f6eq = rho*(1.0/24.0*G*rho-1.0/12.0*(vx+vy)+1.0/8.0*(vx+vy)*(vx+vy)-sq_term/24.0);\n        float f7eq = rho*(1.0/24.0*G*rho-1.0/12.0*(vx-vy)+1.0/8.0*(vx-vy)*(vx-vy)-sq_term/24.0);\n        float f8eq = rho*(1.0/24.0*G*rho+1.0/12.0*(vx-vy)+1.0/8.0*(vx-vy)*(vx-vy)-sq_term/24.0);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = mix(f0,f0eq,w);\n        f1 = mix(f1,f1eq,w);\n        f2 = mix(f2,f2eq,w);\n        f3 = mix(f3,f3eq,w);\n        f4 = mix(f4,f4eq,w);\n        f5 = mix(f5,f5eq,w);\n        f6 = mix(f6,f6eq,w);\n        f7 = mix(f7,f7eq,w);\n        f8 = mix(f8,f8eq,w);\n    }\n    if(itx==0&&ity==0)\n    {\n        fragColor.rgb = min(abs(vec3(f0,f1,f2)),1.0);\n    }\n    else if(itx==1&&ity==0)\n    {\n        fragColor.rgb = min(abs(vec3(f3,f4,f5)),1.0);\n    }\n    else if(itx==0&&ity==1)\n    {\n        fragColor.rgb = min(abs(vec3(f6,f7,f8)),1.0);\n    }\n    else\n    {\n        fragColor.rgb = min(abs(vec3(0.5*rho,0.5*vx+0.5,0.5*vy+0.5)),1.0);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iMouse.xy/iResolution.xy,iMouse.w,iTime);\n}", "buffer_c_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1134]], "test": "untested"}
{"id": "wsfcz8", "name": "Contaminated", "author": "raabix", "description": "Get creative while you are told to stay at home :D", "tags": ["newbie", "corona", "fun", "bored", "virus", "biohazard", "contamination"], "likes": 5, "viewed": 393, "published": 3, "date": "1584291729", "time_retrieved": "2024-07-30T21:18:28.697931", "image_code": "#define S(a,b,x) smoothstep((a),(b),(x))\n#define SMOOTH 0.01\n#define blend(a, b, x) mix((a),(b),(x))\n\n\n// Hash by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat value_noise(vec2 uv)\n{\n    vec2    ID = floor(uv);\n    // cell coord\n    vec2 cc = fract(uv);\n\n    float n1, n2, n3, n4, n12, n34;\n    \n    n1 = hash12(ID);\n    n2 = hash12(ID + vec2(1, 0));\n    n3 = hash12(ID + vec2(0, 1));\n    n4 = hash12(ID + vec2(1, 1));\n   \n    n12 = (blend(n1, n2, cc.x));\n    n34 = (blend(n3, n4, cc.x));\n    \n    return (blend(n12, n34, cc.y));\n}\n\nfloat oct_value_noise(float levels, float roughness, float descale, vec2 uv)\n{\n    float n = 0.,\n        scale = 1.; \n    float final_divisor =0.;\n    for(float i = 0.; i < levels; i++)\n    {\n        float octave_intensity = mix(1./(i+1.), 1., roughness);\n        final_divisor += octave_intensity;\n        n+= value_noise(uv * scale) * octave_intensity;\n        scale *= descale;\n        uv += vec2(7., 7.);\n    }\n    return n/final_divisor;\n}\n\nfloat sphere(vec2 pos, float r, vec2 uv)\n{\n    return length(uv - pos) -r;\n}\n\nfloat ring(vec2 pos, float r, vec2 uv)\n{\n    return abs(sphere(pos, r, uv));\n}\n\nfloat box(vec2 lw,  vec2 uv )\n{\n    vec2 d = abs(uv)-lw;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rot(vec2 pos, float angle, vec2 uv)\n{\n    uv -= pos; \n    uv = vec2(uv.x * cos(angle) - uv.y * sin(angle) , uv.x * sin(angle) + uv.y * cos(angle));\n    return uv + pos;\n}\n\n\n\nfloat biohazard(vec2 pos, float size, vec2 uv)\n{\n    uv *= size;\n    uv = rot(vec2(0), float(iFrame)/180., uv);\n    float val = 0.;\n    float ring_punchout = 0.;\n    float ring_w;\n    // Doing the first part of the Symbol\n    for(float i = 0.; i<3. ; i++)\n    {\n        float th_rad = .5;\n        float dist = 0.;\n        float angle = 3.1415/1.5 * i;\n        vec2 uv_tmp = rot(vec2(0., -th_rad), angle, uv - vec2(0.0, 0.5));\n        val = max(S(SMOOTH, 0.0, sphere(vec2(0.0), th_rad , uv_tmp)), val);\n        val -= S(SMOOTH, 0.0, sphere(vec2(0.0, 0.11), .39, uv_tmp));\n        // center of 2nd sphere, but smaller\n        dist = ring(vec2(0.0, 0.11), th_rad - .125 , uv_tmp) ;\n        \n        float ring_w = 0.022;\n        ring_punchout = max(S(SMOOTH+ring_w, ring_w, dist), ring_punchout);\n        \n        uv_tmp = rot(vec2(0., -th_rad), angle, uv - vec2(0.0, 0.5)) + vec2(0, 0.34); //UV for box\n        val = min(S(0., SMOOTH,  ( box(vec2(0.023, 0.06), uv_tmp)) ), val); // BOX\n\n    }\n    // the punchout ring\n    ring_w = 0.04;\n    \n    val = max(val,S(SMOOTH + ring_w, ring_w,   ring(vec2(0), .4, uv)));\n    val -= ring_punchout;\n    \n    \n    val -= S(SMOOTH, 0.0, sphere(vec2(0), 0.11, uv));\n    \n    return val;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n    // Centered pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord/iResolution.xy)-.5)*2., uv_vignette = uv;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    // draw symbol\n\tfloat val = clamp(biohazard(vec2(0), 1., uv), 0., 1.);\n    \n    // dirt\n    float n = oct_value_noise(8., 1., 1.6, uv*7. * vec2(1.5, .6));\n    n = S(value_noise((uv + vec2(45., 67.))* vec2(10, 4))*.6,\n          value_noise((uv + vec2(145., 167.))*9.)*.7+.4, n);\n  \n    vec4 bg = mix(vec4(.9, .9, .2, 0), vec4(0.8, 0.75, 0.14,0),1.- n);\n    float v = value_noise((uv + vec2(45., 67.))* vec2(320, 320));\n    // Output to screen               *    Vignette\n    O = bg*vec4(1.-val) * (1.-pow(length(uv_vignette*.6), v*3.+1.2));\n    \n   \n  // O = vec4(v);\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 259, 281, 281, 398], [401, 401, 429, 429, 778], [780, 780, 858, 858, 1224], [1226, 1226, 1268, 1268, 1302], [1304, 1304, 1344, 1344, 1382], [1384, 1384, 1415, 1415, 1497], [1499, 1499, 1541, 1541, 1674], [1678, 1678, 1726, 1726, 2902], [2905, 2905, 2954, 3002, 3697]], "test": "untested"}
{"id": "Wdlcz4", "name": "automata_5", "author": "balkhan", "description": " mouseable", "tags": ["mouse", "automata"], "likes": 3, "viewed": 332, "published": 3, "date": "1584284919", "time_retrieved": "2024-07-30T21:18:29.850848", "image_code": "void mainImage(out vec4 O, in vec2 u)\n{\n    O = A(u/R);\n    O = sin(O.x*35.-1.+vec4(.50, .04, 2.08, 0.00));\n}\n// Note to future self : nearest make buffers load sucessfully on android", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2 P;\n\n#define F    for (int k=0; k<9; k++ ) if(k!=4) P=vec2(mod(float(k), 3.),float(k/3))-1., \n\nfloat   N(vec2 u)\n{\n    float   r = .0;\n\tF\n        r += A(u+P/R).x /8.;\n    return r;\n}\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2    v = (u - R*.5) / R.y;\n    o -= o;\n    o += (( // big erratic negative ball\n        (length(v-(R.y/R.x)*1.*vec2(cos(iTime*1.5*.125+sin(iTime*.125))*.75,1.*cos(iTime*.5)*sin(iTime*.375)))*10. )<1.5\n        ||\n        ( // negative mouse square\n        mylength((u-iMouse.xy)/R.y)<.1 && iMouse.z>.5)\n        )\n          ? -1. : 0.)\n        +\n        ( // positive circling ball\n        (length(v-.5*vec2(cos(-iTime), sin(-iTime)))<.05)? 1. : 0.\n        )\n        ;\n    u/=R;\n    vec3 r;r-=r;\n    // Neighborhood collection into r\n    F r.y = max(r.y, N((u+P/R) ) /8. );\n    F r.x = max(r.x, A((u+P/R)).x /8. );\n    r.z = min(N(u), A(u).x );\n    o.x +=\n        clamp(\n            A(u).x\n            +\n           (4./(r.y+5.0)+12.*r.y+r.x*4.-r.z*3.)/(r.z/.01+r.y/.1-.7199)/32.\n        , 0., 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define R iResolution.xy\n#define A(u) texture(iChannel0, u)\nfloat mylength(vec2 p) {vec2 a = abs(p); return max(a.x, a.y);}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdlcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 109]], "test": "untested"}
{"id": "tsfczN", "name": "MISSION FAILED", "author": "butadiene", "description": "I imagined when the mission failed in the video game", "tags": ["3d", "raymarching"], "likes": 13, "viewed": 673, "published": 3, "date": "1584269161", "time_retrieved": "2024-07-30T21:18:30.770389", "image_code": "float PI = 3.1415926535;\n\n\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\nvec2 pmod(vec2 p,float n){\n  float np = acos(-1.)*2.0/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p)*vec2(cos(r),sin(r));\n}\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec4 ground(vec3 p){\n\tfloat d = p.y+0.7*fbm(p.xz)+16.0*noise(p.xz*0.08-vec2(0.0,0.1))-0.15;\n\treturn vec4(0.,0.,0.,d);\n}\n// from:https://qiita.com/aa_debdeb/items/bffe5b7a33f5bf65d25b\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.x * b.y + a.y * b.x - a.z * b.w + a.w * b.z,\n        a.x * b.z + a.y * b.w + a.z * b.x - a.w * b.y,\n        a.x * b.w - a.y * b.z + a.z * b.y + a.w * b.x\n    );\n}\n\n#define ITERATIONS 8\nvec2 Julia(vec4 p, vec4 c) {\n    vec4 z = p;\n    vec4 dz = vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 pz, pdz;\n    float r = 0.0, dr = 1.0;\n    for (int i = 0; i < ITERATIONS; i++) {\n        pz = z;\n        z = qmul(pz, pz) + c;\n        pdz = dz;\n        dz = 2.0 * qmul(pz, pdz);\n        r = length(z);\n        dr = length(dz);\n        if (r > 4.0) break;\n    }\n    return vec2(0.5 * log(r) * r / dr,r);\n}\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q = abs(p);\n\tvec3 m = max(s-q,0.0);\n\treturn length(abs(max(q-s,0.0)))-min(min(m.z,m.y),m.x);\n}\n\nvec4 tower(vec3 p){\n  float s = 0.11;\n  p -= vec3(-50.7,-6.,-3.);\n  p.xy *= rot(1.57);\n  float ci = 0.0;\n  float d = cube(p,vec3(15.,7.,7.));\n\n    vec2 dj =Julia(vec4(p*s,0.0),vec4(-0.9,0.2,0.2,0.0))/s;\n    d = dj.x;\n    ci = dj.y;\n\n  vec3 mat = vec3(clamp(log(ci*0.5),0.0,1.0));\n  mat = vec3(1.0);\n  float ks = 1.2;\n   p = mod(p,ks)-0.5*ks;\n   float cd = cube(p,vec3(0.4));\n\n   d = max(d,-cd);\n  return vec4(mat,d);\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec4 airplay(vec3 p){\n  p.x +=8.;\n  p.z -= 2.2;\n  p.y += 0.7;\n  p.xz *= rot(0.9);\n  float s = 1.3;\n  p *= s;\n  vec3 pp = p;\n  p.y += 0.35;\n  float d1 = cube(p+vec3(0.0,1.,0.0),vec3(3.7,1.6,2.9));\n  for(int i = 0;i<4;i++){\n    p = abs(p)-vec3(0.6,-0.13,0.4);\n    p.xz *= rot(1.5);\n    p.xy *= rot(1.4);\n  }\n    float d = cube(p,vec3(0.13,0.9,1.9));\n    d = max(d,-d1);\n    p = pp;\n    float dk1 = cube(p+vec3(0.0,1.4,0.0),vec3(3.7,1.6,2.9));\n    p.y -= 0.5;\n    p.x = abs(p.x)-0.4;\n    p.xy = pmod(p.xy,6.);\n      for(int i = 0;i<4;i++){\n        p = abs(p)-0.4*vec3(0.2,0.,0.2);\n        p.xz *= rot(0.1);\n        p.xy *= rot(1.1);\n      }\n      float d2 = cube(p,vec3(0.6,0.4,1.9));\n      d2 = max(d2,-dk1);\n      d = min(d,d2);\n      p = pp;\n      p.xz = abs(p.xz)-0.9;\n      p.yz *= rot(1.);\n      p.xz *= rot(-0.4);\n      float d3 = cube(p,vec3(0.05,0.05,1.5));\n      d = min(d,d3);\n      p = pp;\n      p.x = abs(p.x)-0.8;\n      p.z -= 1.3;\n      p.y -= 0.9;\n      p.xy *= rot(0.48);\n      p.xz *= rot(0.3);\n      p.yz  *= rot(0.2);\n      float d4 = cube(p,vec3(0.04,0.18,0.7));\n      d = max(d,-d4);\n      vec3 mat  = vec3(1.0);\n\n      mat = mix(0.3*vec3(0.5,0.9,0.9),mat,step(0.01,d4));\n      p = pp;\n      p.z += 2.;\n      p.y -= 1.2;\n        float d6 =  cube(p+vec3(0.,0.,1.),vec3(0.2,2.,1.));\n      p.yz *= rot(1.57*0.5);\n      float d5 = cube(p,vec3(0.02,0.9,0.9));\n\n      d = min(d,max(max(d5,-d6),-dk1));\n\n    return vec4(mat,d/s);\n}\n\nvec4 map(vec3 p){\n\tvec4 g = ground(p);\n\tvec4 ap = airplay(p);\n  vec4 tw = tower(p);\n\treturn min(min(g,tw),ap);\n}\n\nvec4 volume(vec3 p){\n    float time = iTime;\n    p -= vec3(-43.7,3.2,-9.5);\n    p.yz *= rot(0.5);\n    p.xy *= rot(0.2);\n    p.xz *= rot(2.3);\n    float sx = 7.9;\n    float sc = 2.8*pow((1.0-(p.x+sx)/(2.0*sx)),2.0);\n    p.y += sin(time+p.x);\n    float d1 = cube(p,vec3(sx,1.*sc,1.*sc))-2.0*fbm(p.xy*1.2-time*vec2(-2.,1.));\n  return vec4(-0.6*vec3(1.0),d1);\n}\n\nvec4 volumeFm(vec3 p){\n    float time = iTime;\n    p -= vec3(-43.7,3.2,-9.5);\n    p.yz *= rot(0.5);\n    p.xy *= rot(0.2);\n    p.xz *= rot(2.3);\n    float sx = 4.9;\n    float sc = 1.4*(1.0-(p.x+sx)/(2.0*sx));\n    p.y += sin(time+p.x);\n    float d1 = cube(p,vec3(sx,1.*sc,1.*sc))-2.0*fbm(p.xy*1.1-time*vec2(-2.,1.));\n  return vec4(clamp((1.0-sc*0.9),0.0,1.0)*vec3(1.0,0.2,0.0),d1);\n}\n\nvec3 getNormal(vec3 p)\n{\n vec4 n = vec4(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += 0.0001;\n        n[i] = map(s.xyz).w;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nfloat softray(vec3 ro, vec3 rd , float hn)\n{\n\tfloat t = 0.01;\n\tfloat jt = 0.0;\n\tfloat res = 1.;\n\tfor (int i = 0; i < 20; ++i) {\n\t\tjt = map(ro+rd*t).w;\n\t\tres = min(res,jt*hn/t);\n\t\tt = t+ clamp(0.02,10.,jt);\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\nfloat ao(vec3 p,vec3 n,float len,float power){\n\tfloat oss =0.0;\n\tfor(int i =0;i<3;i++){\n\t\tfloat d = map(p+n*len/3.0*float(i+1)).w;\n\t\toss += (len-d)*power;\n\t\tpower *=0.5;\n\t}\n\treturn clamp(1.-oss,0.0,1.0);\n}\n\n\nvec3 LD = normalize(vec3(1.,1.,1.));\n\nvec3 groundColor(vec3 p,vec3 n,vec3 col,vec4 sla){\n\tfloat hl = max(dot(n, LD),0.0);\n\thl = hl * 0.5 + 0.5;\n\thl = hl * hl;\n  vec3 gcol = vec3(1.0);\n  gcol = mix(vec3(103./255.,66./255.,41./255.),gcol,smoothstep(0.8,0.9,n.y));\n  float sh = clamp((sla.x+0.1),0.0,1.0);\n  return vec3(hl)*gcol*sh*sla.y;\n}\n\nvec3 towercolor(vec3 p,vec3 n,vec3 col,vec4 sla){\n  \tfloat hl = max(dot(n, LD),0.0);\n  \thl = hl * 0.5 + 0.5;\n  \thl = hl * hl;\n    float sh = clamp((sla.x+0.1),0.0,1.0);\n  \treturn vec3(hl)*col*sh*sla.y;\n  }\n\n  float cube2D(vec2 p,vec2 s){\n  \tvec2 q = abs(p);\n  \tvec2 m = max(s-q,0.0);\n  \treturn length(abs(max(q-s,0.0)))-min(m.x,m.y);\n  }\n\n  vec3 airplaycolor(vec3 p,vec3 n,vec3 col,vec3 rd,vec4 sla){\n    float time = iTime;\n    p.x +=8.;\n    p.z -= 2.2;\n    p.y += 0.7;\n    p.xz *= rot(0.9);\n    for(int i = 0; i<4;i++){\n      p = abs(p)-0.5;\n      p.xy *= rot(1.2);\n      p.yz *= rot(1.0);\n    }\n    float ds = abs(cube2D(p.xz,vec2(0.5,0.2)));\n    vec3 em = vec3(0.0);\n    if(ds<0.02&&col.r>0.9){\n     col = vec3(0.5,0.5,0.5);\n     em = 1.0*vec3(0.9,0.1,0.1)*pow(abs(sin(time)),2.0);\n    }\n  \tfloat NdotL = max(dot(n, LD),0.0);\n    vec3 R = normalize( - LD + 2.0 *n * NdotL );\n \t\tfloat spec = pow(max(0., dot(R, -rd)), 10.0);\n\n    float sh = clamp((sla.x+0.1),0.0,1.0);\n    return (NdotL*col+spec)*sh*sla.y+em;\n  }\n\n  //https://www.shadertoy.com/view/lsKSWR\nfloat vig(vec2 uv)\n{\n   float time = iTime;\n   uv *=  1.0 - uv.yx;\n   float vig = uv.x*uv.y * (12.0+7.*noise(vec2(time*10.)));\n   vig = pow(vig, 0.45);\n   return vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float time = iTime;\n\tvec2 uv = fragCoord/iResolution.xy;\n  vec2 uv2 = uv;\n\tuv = (uv-0.5)*2.;\n\tuv.y *= iResolution.y/iResolution.x;\n\tvec2 p = uv;\n  float rkt = 3.7+0.1*mod(time*0.2,24.0*0.2);\n\n\tvec3 rk = vec3(-50.7+30.*sin(rkt),8.3,-3.+30.*cos(rkt));\n  vec3 mov = (mod(time,24.0)-8.0)*0.5*vec3(0.4,0.0,0.4);\n  vec3 ro = mix(vec3(1.8,1.3,0.)+mov,rk,step(12.,mod(time,24.)));\n\tvec3 ta = vec3(1.0,1.2,1.3);\n  ta += mov*step(mod(time,24.),12.);\n  ta += vec3(-50.7,-1.,-3.);\n\tvec3 fo = normalize(ta-ro);\n\tvec3 le = cross(fo,vec3(0.,1.,0.));\n\tvec3 up = cross(le,fo);\n\tfloat fov= 2.2;\n\tvec3 rd = normalize(vec3(fo*fov+up*p.y+le*uv.x));\n\tfloat t = 0.002;\n  float vd;\n  float vdF;\n\tfloat d = 0.0;\n\tvec4 red;\n\n  vec4 revd;\n  vec4 revdF;\n  vec3 accol = vec3(0.0);\n\tvec3 col = vec3(0.0);\n  float BSC = 0.4;\n  float ACOL = 0.4;\n  float bac = BSC;\n\tfor(int i = 0;i<79;i++){\n\t\tvec4 red = map(ro+rd*t);\n\t\td = 1.4*red.w;\n    revd = volume(ro+rd*t);\n    vd = max(revd.w,bac);\n    revdF = volumeFm(ro+rd*t);\n    vdF = max(revdF.w,bac);\n    float jst = step(0.2,d);\n    accol += ACOL*revd.xyz*exp(-vd)*jst;\n    accol += ACOL*revdF.xyz*exp(-vd);\n    d = min(min(d,vd),vdF);\n    t +=0.7*d;\n\t}\n\n  vec3 spos = ro+rd*t;\n\tvec3 normal = getNormal(spos);\n  vec3 ref = reflect(rd,normal);\n  float sh = softray(spos,LD,3.3);\n  float ao = ao(spos,normal,0.25,1.);\n  vec4 sla = vec4(sh,ao,0.0,0.0);\n\tif(ground(spos).w<0.01){\n\t\tcol = groundColor(spos,normal,red.xyz,sla);\n\t}else if(tower(spos).w<0.01){\n    col = towercolor(spos,normal,tower(spos).xyz,sla);\n  }\n  else if(airplay(spos).w<0.01){\n    col = airplaycolor(spos,normal,airplay(spos).xyz,rd,sla);\n  }\n\n\n\n  vec3 fogcol = vec3(0.5,0.5,0.5);\n  float far = 350.;\n  float near =0.0;\n  float fogk = clamp((far-t-300.*fbm(time+spos.xz*0.1+0.01*spos.y))/(far-near),0.0,1.0);\n  col = mix(fogcol,col,fogk);\n  col += 0.1*accol;\n  col *= vig(uv2);\n\tfragColor = vec4(col,0.2);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 46, 46, 93], [94, 94, 120, 120, 250], [251, 251, 278, 278, 395], [397, 397, 423, 423, 756], [776, 776, 800, 800, 1024], [1026, 1026, 1046, 1046, 1145], [1146, 1209, 1236, 1236, 1481], [1504, 1504, 1532, 1532, 1902], [1904, 1904, 1930, 1930, 2031], [2033, 2033, 2052, 2052, 2451], [2453, 2453, 2498, 2498, 2567], [2569, 2569, 2590, 2590, 4012], [4014, 4014, 4031, 4031, 4126], [4128, 4128, 4148, 4148, 4485], [4487, 4487, 4509, 4509, 4868], [4870, 4870, 4894, 4894, 5087], [5089, 5089, 5133, 5133, 5327], [5329, 5329, 5375, 5375, 5534], [5575, 5575, 5625, 5625, 5874], [5876, 5876, 5925, 5925, 6081], [6085, 6085, 6113, 6113, 6213], [6217, 6217, 6276, 6276, 6892], [6896, 6936, 6956, 6956, 7104], [7106, 7106, 7162, 7162, 9058]], "test": "untested"}
{"id": "WdsyRn", "name": "Glossy Snake on Mars", "author": "ddoodm", "description": "Just testing some things and fiddling around. Tried to implement my own shadow algorithm without cheating ... and then cheated a bit ... but still learnt something! ^-^", "tags": ["shadow", "snake", "mars", "penumbra", "soft", "daylight"], "likes": 26, "viewed": 718, "published": 3, "date": "1584261267", "time_retrieved": "2024-07-30T21:18:31.737803", "image_code": "const float INFINITY = 300.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159;\nconst float SHADOW_AREA = 50.0;\nconst bool DO_REFLECTION = false;\n\nvec3 lp1 = normalize(vec3(0.7, 0.6, -0.7));\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nvec2 sdWorld(vec3 p) {\n    float dp = length(p);\n    float d = 0.0;\n    \n    float s1, b1, p1;\n    \n    // sphere\n    {\n        vec3 pp = p;\n        float bf = pow(abs(sin(iTime * 4.0)), 0.8);\n        pp -= vec3(\n            cos(iTime * 4.0) * 2.5,\n            bf*5.0,\n            -cos(iTime * 2.0 + PI/2.0) * 3.);\n        s1 = sdSphere(pp, 1.0);\n    }\n    \n    // box\n    {\n        vec3 pp = p + vec3(\n            cos(p.z*0.4 + iTime*4.0)*4.0,\n            -1.0 + sin(p.z-iTime*4.0)*0.5,\n            0.0);\n        pp.y += pow(abs(p.z*0.03), 11.0);\n        float r = max(0.0, 0.25);\n        vec3 br = vec3(r, r, 100.0);\n        b1 = sdBox(pp, br);\n        b1 -= 0.3; // rounding\n        b1 *= 0.5; // fix marcher\n                \n        d = min(s1, b1);\n    }\n    \n    // ground\n    {\n        vec3 pp = p;\n        float dirt = textureLod(iChannel0, p.xz*0.02, 0.0).x;\n        float cd = dp;\n\t\tcd *= 0.5 + 0.25 * (cos(p.x/30.0) + sin(p.z/20.0));\n\t\tpp.y -= pow(cd*0.015, 2.5);\n        dirt *= (1.0 - min(1.0,cd*0.005));\n        dirt *= 1.5;\n        pp.y += dirt;\n        \n        p1 = sdPlane(pp+vec3(0.0, 0.0, 0.0));\n        \n        // slight performance enhancement\n        if(dp < 100.0)\n        {\n            // mirrored hills with holes in em\n        \tfloat hillo = textureLod(iChannel0, p.xz*0.005, 0.0).y;\n            float hilld = 85.0;\n            pp.z = -abs(pp.z); // mirror\n            pp.y -= hillo * 5.0;\n            float hill1 = sdSphere(pp+vec3(0,30.,hilld), 50.0);\n            p1 = smin(p1, hill1, 20.0);\n            pp.x *= 2.4;\n            pp.y *= 1.1;\n            pp.z *= 1.0;\n            pp -= -(1.0+2.0*vec3(hillo,0,hillo))*2.0;\n            float hillh1 = sdSphere(pp+vec3(0,12.,hilld-48.), 21.0);\n            p1 = smax(hillh1, p1, 3.0);\n        }\n        \n        d = min(d, p1);\n    }\n    \n    // floor is 1, white is 2\n    float mat = 100.0;\n    if(p1<=d) mat = 1.0;\n    if(b1<=d) mat = 2.0;\n    if(s1<=d) mat = 3.0;\n    \n    return vec2(d, mat);\n}\n\nvec4 trace(vec3 ro, vec3 rd)\n{\n    const int ITERS = 200;\n    \n    vec3 p = ro;\n    vec2 d;\n    \n    for(int i = 0; i < ITERS; i++)\n    {\n        d = sdWorld(p);\n        \n        if(d.x <= EPSILON) {\n            return vec4(p, d.y);\n        }\n        if(d.x >= INFINITY) {\n            return vec4(p, 0.0);\n        }\n        \n        p += rd * d.x;\n    }\n    \n    return vec4(p, d.y);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    return normalize(vec3(\n    \tsdWorld(p+e.xyy).x - sdWorld(p-e.xyy).x,\n        sdWorld(p+e.yxy).x - sdWorld(p-e.yxy).x,\n        sdWorld(p+e.yyx).x - sdWorld(p-e.yyx).x\n\t));\n}\n\nfloat softShadow(vec3 ro, vec3 rd)\n{\n    const int ITERS = 30;\n\n    float nearest = 1.0;\n    \n    float t = 0.1;\n    for(int i = 0; i < ITERS; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = sdWorld(p).x;\n        \n        float od = d / t;\n        \n        if(od < nearest) {\n            nearest = od;\n        }\n        if(d <= EPSILON) {\n\t\t\treturn 0.0;\n        }\n        if(d >= INFINITY) {\n            break;\n        }\n        \n        t += min(0.5, max(EPSILON, d));\n    }\n    \n    return nearest;\n}\n\nvec3 shadeSky(vec3 rd)\n{\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    float du = max(0.0, dot(rd, up));\n    float id = 1.0 - du;\n    id = pow(id, 2.0);\n    \n    float dl = max(0.0, dot(rd, lp1));\n    dl = pow(dl, 5.0);\n    dl += pow(dl, 4.0);\n    vec3 lc = vec3(1.0, 0.9, 0.9);\n    \n    float hz = pow(max(0.0, 1.0 - du*0.6), 30.0);\n    vec3 hzc = vec3(1.0, 0.85, 0.85);\n    \n    vec3 bc = vec3(0.4, 0.6, 0.9);\n    \n    return mix(bc*id + lc*dl, hzc, hz);\n}\n\nvec3 shadeWorld(vec4 pm, vec3 ro, vec3 n)\n{\n    vec3 lp2 = vec3(0.0, -1.0, 0.0);\n    vec3 lp3 = -lp1;\n    \n    float mat = pm.w;\n    vec3 p = pm.xyz;\n    float d = length(p);\n    vec3 r = reflect(normalize(p-ro), n);\n\n    vec3 amb = vec3(0.15, 0.16, 0.2);\n    vec3 alb = vec3(1.0);\n    vec3 salb = vec3(1.0);\n    vec3 l3alb = vec3(1.0,0.7,0.5);\n    \n    if(mat < 1.5) {\n        // floor\n        amb *= 0.7;\n        alb = vec3(1.0,0.7,0.5);\n        salb = vec3(0);\n        l3alb = vec3(0);\n    } else if (mat < 2.5) {\n        // band\n        amb = vec3(0.3,0.2,0.25);\n        alb = vec3(1.0,0.4,0.4);\n    }\n    \n    float l1 = max(0.0, dot(n, lp1));\n    float l2 = max(0.0, dot(n, lp2));\n    float l3 = max(0.0, dot(n, lp3));\n    \n    float spec1 = pow(max(0.0, dot(r, lp1)), 50.0);\n    \n    float s1 = 1.0;\n    if(d <= SHADOW_AREA)\n    {\n\t\ts1 = softShadow(p, lp1);\n    \ts1 = max(0.2, min(1.0, s1 * 4.0));\n    }\n\n    return  amb * alb +\n        \talb * l1 * s1 +\n        \talb * l3 * l3alb * 0.15 +\n        \tsalb * spec1;\n}\n\nvec3 shade(vec4 hit, vec3 ro, vec3 rd)\n{\n    vec3 col;\n    vec3 p = hit.xyz;\n    float d = length(p - ro);\n    \n    if(hit.w < 0.5) {\n        col = shadeSky(rd);\n    } else {\n    \tvec3 n = normal(p);\n        vec3 sky = shadeSky(rd);\n        vec3 world = shadeWorld(hit, ro, n);\n        float dm = min(pow(d*0.003, 1.8), 1.0);\n        col = mix(world, sky, dm);\n        \n        if(DO_REFLECTION && hit.w>2.5 && hit.w<3.5)\n        {\n            // ball\n            vec3 r = reflect(rd, n);\n            vec4 rhit = trace(p+r*EPSILON, r);\n            vec3 rn = normal(rhit.xyz);\n            vec3 rc;\n            if(rhit.w<0.5) rc = shadeSky(r);\n            else rc = shadeWorld(rhit, p, rn);\n            col = mix(col, rc, 0.3);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = iTime*0.4 + PI*0.3 + iMouse.x/iResolution.x*PI*2.0;\n    \n    vec3 ro = vec3(0.0, 4.0, -15.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.8));\n    \n    mat3 rot = mat3(\n        cos(t), 0,\tsin(t),\n        0,\t\t1,\t0,\n        -sin(t),0,\tcos(t));\n    ro *= rot;\n    rd *= rot;\n    \n    vec4 hit = trace(ro, rd);\n    \n    vec3 col = shade(hit, ro, rd);\n    \n\tcol = ACESFilm(col);\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 220, 220, 360], [362, 362, 405, 405, 504], [506, 506, 549, 549, 649], [651, 651, 680, 680, 723], [725, 725, 758, 758, 786], [788, 788, 811, 811, 829], [831, 831, 853, 853, 2804], [2806, 2806, 2836, 2836, 3191], [3193, 3193, 3214, 3214, 3424], [3426, 3426, 3462, 3462, 3939], [3941, 3941, 3965, 3965, 4392], [4394, 4394, 4437, 4437, 5414], [5416, 5416, 5456, 5456, 6180], [6182, 6182, 6239, 6289, 6859]], "test": "untested"}
{"id": "wdXcz4", "name": "Rectangle_indere", "author": "indere", "description": "rectangle", "tags": ["2d"], "likes": 1, "viewed": 311, "published": 3, "date": "1584240875", "time_retrieved": "2024-07-30T21:18:32.616454", "image_code": "\nfloat rectangle_1(vec2 center, float width, float height, vec2 uv, float blur, vec2 offset){\n\tcenter += offset;\n    float wLen = abs(uv.x - center.x);\n    float hLen = abs(uv.y - center.y);\n    \n    float wCol = smoothstep(width, width - blur, wLen);\n    float hCol = smoothstep(height, height - blur, hLen);\n    \n    return wCol * hCol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 backGroundColor = vec3(1.0,1.0,0.5);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 center = vec2(0.0);\n    float width = 0.8;\n    float height = 0.8;\n    float blur = 0.1;\n    vec2 offset = vec2(.0);\n    \n    float col = rectangle_1(center, width, height, uv, blur, offset);\n    \n    fragColor = vec4(backGroundColor * vec3(abs(col)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 93, 93, 340], [343, 343, 400, 400, 843]], "test": "untested"}
{"id": "WsXyzN", "name": "Pilot wave system 3D", "author": "michael0884", "description": "Going mad and storing 8 particle id's in 1 texel based on the distance to the texel. Pilot wave particles the 3D remaster. \nBouncing droplet experiment - the game.", "tags": ["particles"], "likes": 22, "viewed": 777, "published": 3, "date": "1584224697", "time_retrieved": "2024-07-30T21:18:33.701553", "image_code": "// Fork of \"Pilot wave system II\" by michael0884. https://shadertoy.com/view/3sXyz4\n// 2020-03-14 20:40:40\n\n// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-14 14:30:34\n\n#define FOV 1.5\n#define R 140.\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n#define freq 15.\nfloat DE(vec3 pos)\n{\n    pos.xy += size*0.5;\n    float de = 1e10;\n    ivec2 p = ivec2(pos.xy);\n    get(p);\n   \tfloat y = 0.;\n   \n    for(int i = 0; i < CN; i++)\n    {\n        vec4 p0 = getParticle(ids[i]); \n        float d = distance(pos.xy, p0.xy);\n        \n        float ph = 6.*hash11(float(ids[i]));\n        float osc = (0.5+0.5*sin(freq*iTime+ph));\n        y += -2.*sin(-freq*iTime-ph)*sin(d)/(k*d+1.);\n        \n        de = min(de, sdSphere(pos - vec3(p0.xy, 4.*prad*osc+4.5), 0.5*prad));\n    }\n    de = min(de, 0.8*sdBox(pos - vec3(size, 4.*y)*0.5, vec3(size*0.5, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define M 128.\n#define min_d 0.5\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < M; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > size.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    vec2 uv = iMouse.xy/iResolution.xy;\n    vec2 angles = vec2(uv.x*2., 0.3*uv.y - 0.3)*PI;\n    \n    vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n    vec3 camera_y = -normalize(cross(camera_x,camera_z));\n    \n    //tracking particle\n    vec4 fp = getParticle(0);\n    \n    vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n    vec3 cam_pos = vec3(fp.xy-size.xy*0.5, 0.) - R*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    \n    vec4 sphere = vec4(0.,0.,0., 1.);\n    \n    vec4 X = ray_march(cam_pos, ray);\n  \n    if(X.w < min_d)\n    {\n    \tvec4 N0 = calcNormal(X.xyz, 0.6);\n   \t\tvec3 n = normalize(N0.xyz);\n        vec3 rd = reflect(ray, n);\n        vec3 rfd = refract(ray, n, 1.15);\n        vec3 col = texture(iChannel2,  rd.yzx).xyz;\n        vec3 col1 = texture(iChannel2,  rfd.yzx).xyz;\n        float K = 1. - pow(max(dot(n,rd),0.), 3.);\n        fragColor.xyz = col*K + 0.6*col1*(1.-K);\n    }\n    else\n    {    \n        //background\n        fragColor = texture(iChannel2,  ray.yzx);\n    }\n \n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n//particle buffer\n\n//Keyboard constants\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n//force scalar\nfloat F(float d)\n{\n    d /= 2.*prad;\n    return -ff*sin(d)/(k*d);\n}\n\n//force vector\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    if(!all(equal(p0,p1)))\n   \t return normalize(p1-p0)*F(distance(p1,p0));\n    else\n     return vec2(0.);\n}\n\n//get particle from array\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n   \t\t\n        int id = xy2i(p);\n        //neighbors\n   \t\tget(ivec2(U.xy));\n      \n        vec2 F = vec2(0.,0.);\n        \n        vec4 p0 = getParticle(ids[0]);\n        for(int i = 1; i < CN; i++)\n        {\n            vec4 pi = getParticle(ids[i]);\n        \tF += Fv(U.xy, pi.xy);    \n        }\n        \n        if(isKeyPressed(KEY_SPACE)) F *= 3.;\n        \n        if(id == 0)\n        {\n            //keyboard controls lol\n            vec2 uv = iMouse.xy/iResolution.xy;\n            vec2 angles = vec2(uv.x*2., 0.3*uv.y - 0.3)*PI;\n\n            vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n            vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n            vec3 camera_y = -normalize(cross(camera_x,camera_z));\n            vec2 dF = vec2(0.);\n       \t\t\n       \t\tif(isKeyPressed(KEY_A)) dF -= normalize(camera_x.xy);\n            if(isKeyPressed(KEY_D)) dF += normalize(camera_x.xy);\n            if(isKeyPressed(KEY_W)) dF += normalize(camera_y.xy);\n            if(isKeyPressed(KEY_S)) dF -= normalize(camera_y.xy);\n            F += 15.*dF;\n        }\n        \n        U.zw += dt*F;\n        U.zw *= 1. - 0.004*dt*length(U.zw); //cooling\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<3)\n        {\n            U.xy = size*hash22(pos+395.)+1.;\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(8,8)\n#define dt 0.1\n#define prad 4.\n#define k 0.3\n#define ff 4.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\n//closest particle ids\n#define CN 8\nint ids[CN];\n//particle distances\nfloat ds[CN];\n\nivec2 one2two(int a)\n{\n    return ivec2(a%tot_n, a/tot_n);\n}\n\nint two2one(ivec2 a)\n{\n    return a.x + tot_n*a.y;\n}\n\nvoid toarr(inout int b[CN], ivec2 a, int i)\n{\n    b[i] = a.x;\n    b[i+1] = a.y;\n}\n\nvoid init()\n{\n    for(int i = 0; i<CN; i++)\n    {\n        ids[i] = -1;\n        ds[i] = 1e10;\n    }\n}\n\nvoid getA(inout int b[CN], ivec2 p)\n{ \n    ivec4 a = floatBitsToInt(texel(fake, p/2));\n    toarr(b, one2two(a.x), 0);\n    toarr(b, one2two(a.y), 2);\n    toarr(b, one2two(a.z), 4);\n    toarr(b, one2two(a.w), 6);\n}\n\nvoid get(ivec2 p)\n{\n    getA(ids, p);\n}\n\nvec4 save()\n{\n    ivec4 v = ivec4(two2one(ivec2(ids[0],ids[1])),\n                    two2one(ivec2(ids[2],ids[3])),\n                    two2one(ivec2(ids[4],ids[5])),\n                    two2one(ivec2(ids[6],ids[7])));\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}", "buffer_b_code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid insert(int id, float d, int i)\n{\n    //shift all by 1\n    for(int j = CN-1; j > i; j--)\n    {\n        ids[j] = ids[j-1];\n        ds[j] = ds[j-1];\n    }\n    \n    //insert\n    ids[i] = id; \n    ds[i] = d;\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+1.;\n    float dtemp = particleDistance(utemp, pos);  \n    //sorting\n    for(int i = 0; i < CN; i++)\n    {\n        if(ids[i] == utemp) return;\n        \n        if(ids[i] < 0 || ds[i] >= dtemp)\n        {\n            insert(utemp, dtemp, i);\n            return;\n        }\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    int t[CN];\n    getA(t, max(p + dx, ivec2(0,0)));\n    \n\tfor(int i = 0; i < CN; i++)\n    {\n   \t\tif(t[i]>=0)\n        \tsort(t[i], p);\n    }\n}\n\nvoid randupd(ivec2 p )\n{\n    for(int i = 0; i < 6; i++)\n    {\n        //go through the entire array sudorandomly\n        sort(((iFrame + p.x + p.y*int(iResolution.x))^(1<<i))%tot_n, p);\n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 2);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    pos *= 2.;\n    if(pos.x < iResolution.x && pos.y < iResolution.y) //8x voronoi particle tracking but in 2x lower res\n    {\n        ivec2 p = 2*ivec2(pos/2.);\n\n        init();\n\n        update(p);\n\n        U = save();\n    } else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 279, 279, 314], [316, 316, 356, 356, 402], [404, 404, 435, 435, 469], [471, 471, 523, 523, 642], [644, 644, 679, 679, 703], [705, 705, 736, 736, 823], [842, 842, 862, 862, 1436], [1439, 1439, 1474, 1474, 1659], [1694, 1694, 1726, 1726, 1891], [1893, 1893, 1950, 1987, 3255]], "test": "untested"}
{"id": "WltSRB", "name": "ACEScg", "author": "TinyTexel", "description": "Rendering in ACEScg retains bounce colors better than rendering in sRGB. See code for more info. Settings are in the Common tab.\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys", "tags": ["pathtracing", "rendering", "tonemapping", "tonemap", "aces", "acescg"], "likes": 48, "viewed": 2549, "published": 3, "date": "1584222913", "time_retrieved": "2024-07-30T21:18:34.740774", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nGood intro to ACES: https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/\n\nOn Average the rendering with sharp RGB primaries produces results closer to the spectral refrence:\nhttps://computergraphics.stackexchange.com/questions/8152/for-shader-math-why-should-linear-rgb-keep-the-gamut-of-srgb\n\nRendering in ACEScg retains bounce colors better than rendering in sRGB. \nThat is because the AP1 primaries (i.e. ACEScg RGB primaries) cover a wider gamut than the Rec. 709 primaries which sRGB uses.\nThis means that saturated sRGB colors are not fully saturated in ACEScg.\nYou can still get strongly saturated colors by picking colors in ACEScg directly instead of doing so in sRGB.\n\nHowever, picking colors in sRGB and converting them to ACEScg before rendering has two advantages.\n\nFirst, the sRGB gamut lies largely inside and covers a decent portion of the Pointer's gamut, a comprehensive sampling of naturally occuring albedos.\nSo using sRGB to pick albedos ensures your values to be reasonable.\n(see Rec. 709 / sRGB section here: https://www.tftcentral.co.uk/articles/pointers_gamut.htm)\n\nSecond, since ACEScg has a wider gamut than sRGB, there is no guarantee that your rendering results will be in gamut (for LDR displays).\nPicking colors in sRGB mitigates that problem even if it doesn't completely solve it.\nFor example bounce colors can still get saturated to a point where they are not longer in sRGB gamut. \nSo softclipping the rendering+tonemapping result before applying the inverse sRGB EOTF might be a good idea.\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n\nCommon:  settings\nBufferA: rendering\nImage:   tonemapping\n\n*/\nfloat sRGB_InvEOTF(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_EOTF(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_InvEOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n\nfloat ACEScc_from_Linear(float lin) \n{    \n    if (lin <= 0.0) \n        return -0.3584474886;\n    \n    if (lin < exp2(-15.0))\n    \treturn log2(exp2(-16.0) + lin * 0.5) / 17.52 + (9.72/17.52);\n    \n    return log2(lin) / 17.52 + (9.72/17.52);\n}\n\nvec3 ACEScc_from_Linear(vec3 lin) \n{\n    return vec3(ACEScc_from_Linear(lin.r),\n                ACEScc_from_Linear(lin.g),\n                ACEScc_from_Linear(lin.b));\n}\n\n\nfloat Linear_from_ACEScc(float cc) \n{\n    if (cc < -0.3013698630)\n    \treturn exp2(cc * 17.52 - 9.72)*2.0 - exp2(-16.0)*2.0;\n    \n    return exp2(cc * 17.52 - 9.72);\n}\n\nvec3 Linear_from_ACEScc(vec3 cc) \n{\n    return vec3(Linear_from_ACEScc(cc.r),\n                Linear_from_ACEScc(cc.g),\n                Linear_from_ACEScc(cc.b));\n}\n\n\nfloat ACEScct_from_Linear(float lin)\n{\n    if(lin > 0.0078125)\n        return log2(lin) / 17.52 + (9.72/17.52);\n    \n\treturn lin * 10.5402377416545 + 0.0729055341958355;\n}\n\nvec3 ACEScct_from_Linear(vec3 lin) \n{\n    return vec3(ACEScct_from_Linear(lin.r),\n                ACEScct_from_Linear(lin.g),\n                ACEScct_from_Linear(lin.b));\n}\n\n\nfloat Linear_from_ACEScct(float cct)\n{\n    if(cct > 0.155251141552511)\n        return exp2(cct * 17.52 - 9.72);\n    \n\treturn cct / 10.5402377416545 - (0.0729055341958355/10.5402377416545);\n}\n\nvec3 Linear_from_ACEScct(vec3 cct) \n{\n    return vec3(Linear_from_ACEScct(cct.r),\n                Linear_from_ACEScct(cct.g),\n                Linear_from_ACEScct(cct.b));\n}\n\n\n\n// ACES fit by Stephen Hill (@self_shadow)\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl \n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\nconst mat3 AP1toSRGB = mat3\n(\n     1.704859, -0.621715, -0.083299,\n    -0.130078,  1.140734, -0.010560,\n    -0.023964, -0.128975,  1.153013\n);\n\n// AP1 => RRT_SAT\nconst mat3 RRT_SAT = mat3\n(\n\t0.970889, 0.026963, 0.002148,\n\t0.010889, 0.986963, 0.002148,\n\t0.010889, 0.026963, 0.962148\n);\n\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 x)\n{\n    vec3 a = (x            + 0.0245786) * x;\n    vec3 b = (x * 0.983729 + 0.4329510) * x + 0.238081;\n    \n    return a / b;\n}\n\n\nvec3 ToneTF0(vec3 x)\n{\n    vec3 a = (x            + 0.0509184) * x;\n    vec3 b = (x * 0.973854 + 0.7190130) * x + 0.0778594;\n    \n    return a / b;\n}\n\nvec3 ToneTF1(vec3 x)\n{\n    vec3 a = (x          + 0.0961727) * x;\n    vec3 b = (x * 0.9797 + 0.6157480) * x + 0.213717;\n    \n    return a / b;\n}\n\nvec3 ToneTF2(vec3 x)\n{\n    vec3 a = (x            + 0.0822192) * x;\n    vec3 b = (x * 0.983521 + 0.5001330) * x + 0.274064;\n    \n    return a / b;\n}\n\n\n// https://twitter.com/jimhejl/status/1137559578030354437\nvec3 ToneMapFilmicALU(vec3 x)\n{\n    x *= 0.665;\n    \n   #if 0\n    x = max(vec3(0.0), x - 0.004f);\n    x = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n    \n    x = sRGB_EOTF(x);\n   #else\n    x = max(vec3(0.0), x);\n    x = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n    \n    x = pow(x, vec3(2.2));// using gamma instead of sRGB_EOTF + without x - 0.004f looks about the same\n   #endif\n    \n    return x;\n}\n\n\nvec3 Tonemap_ACESFitted(vec3 srgb)\n{\n    vec3 color = srgb * ACESInputMat;\n   \n   #if 1\n    color = ToneTF2(color);\n   #else\n    color = RRTAndODTFit(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n\n    return color;\n}\n\nvec3 Tonemap_ACESFitted2(vec3 acescg)\n{\n    vec3 color = acescg * RRT_SAT;\n    \n   #if 1\n    color = ToneTF2(color); \n   #elif 1\n    color = RRTAndODTFit(color);\n   #elif 1\n    color = ToneMapFilmicALU(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n    //color = ToneMapFilmicALU(color);\n\n    return color;\n}\n\nvec3 ColorGrade(vec3 col)\n{\n    col = ACEScct_from_Linear(col);\n    {\n        vec3 s = vec3(1.1, 1.2, 1.0);\n        vec3 o = vec3(0.1, 0.0, 0.1);\n        vec3 p = vec3(1.4, 1.3, 1.3);\n        \n        col = pow(col * s + o, p);\n    }\n    col = Linear_from_ACEScct(col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 tex = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n\n    col *= exp2(EXPOSURE);\n    \n    #ifdef DO_COLORGRADE\n\tcol = ColorGrade(col);\n    #endif\n    \n    //if(false)\n    {\n        #if MODE == 0\n        col = Tonemap_ACESFitted2(col);\n        #elif MODE == 1\n        col = Tonemap_ACESFitted(col);\n        #else\n        col = RRTAndODTFit(col);\n        #endif\n    }\n    \n    fragColor = vec4(sRGB_InvEOTF(clamp(col, 0.0, 1.0)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}\n\n\n\n/*\n\nvec3 PQ(vec3 Lo)\n{\n    const float c1 = 107.0 / 128.0;\n    const float c2 = 2413.0 / 128.0;\n    const float c3 = 2392.0 / 128.0;\n    const float m1 = 1305.0 / 8192.0;\n    const float m2 = 2523.0 / 32.0;\n    \n    vec3 Lp = pow(Lo, vec3(m1));\n    \n    return pow((c1 + c2 * Lp) / (1.0 + c3 * Lp), vec3(m2));\n}\n\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nGood intro to ACES: https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/\n\nOn Average the rendering with sharp RGB primaries produces results closer to the spectral refrence:\nhttps://computergraphics.stackexchange.com/questions/8152/for-shader-math-why-should-linear-rgb-keep-the-gamut-of-srgb\n\nRendering in ACEScg retains bounce colors better than rendering in sRGB. \nThat is because the AP1 primaries (i.e. ACEScg RGB primaries) cover a wider gamut than the Rec. 709 primaries which sRGB uses.\nThis means that saturated sRGB colors are not fully saturated in ACEScg.\nYou can still get strongly saturated colors by picking colors in ACEScg directly instead of doing so in sRGB.\n\nHowever, picking colors in sRGB and converting them to ACEScg before rendering has two advantages.\n\nFirst, the sRGB gamut lies largely inside and covers a decent portion of the Pointer's gamut, a comprehensive sampling of naturally occuring albedos.\nSo using sRGB to pick albedos ensures your values to be reasonable.\n(see Rec. 709 / sRGB section here: https://www.tftcentral.co.uk/articles/pointers_gamut.htm)\n\nSecond, since ACEScg has a wider gamut than sRGB, there is no guarantee that your rendering results will be in gamut (for LDR displays).\nPicking colors in sRGB mitigates that problem even if it doesn't completely solve it.\nFor example bounce colors can still get saturated to a point where they are not longer in sRGB gamut. \nSo softclipping the rendering+tonemapping result before applying the sRGB EOTF might be a good idea.\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n\nCommon:  settings\nBufferA: rendering\nImage:   tonemapping\n\n*/\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\nvec3 MapColor(vec3 srgb)\n{\n    #if MODE == 0\n    return srgb * sRGBtoAP1;\n    #else\n    return srgb;\n    #endif\n}\n\nfloat Intersect_Scene(\nvec3 rp, vec3 rd,\nout float t, out vec3 n, out vec3 a)\n{\n     float hit;\n   \n    {\n    \tvec2 tt; vec3 n0, n1;\n\t\tfloat th = Intersect_Ray_Cube(rp, rd, vec3(0.0, -0.8, 0.0), vec3(1.5, 0.05, 1.5), /*out:*/ tt, n0, n1);\n      \n        hit = th > 0.0 ? 1.0 : 0.0;\n        t = tt.x;\n        n = n0;\n        a = MapColor(AlbedoPlane0);\n        \n        vec3 p = rp + rd * tt.x;\n        if((p.x > 0.0) == (p.z > 0.0)) a = MapColor(AlbedoPlane1);\n    }\n    \n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x);\n            a = MapColor(AlbedoSphere);\n            \n            hit = 1.0;\n        }\n    }\n    \n    return hit;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    vec2 ang = vec2(Pi * 0.3, -Pi * 0.02);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, iResolution.x / iResolution.y);\n    //vec3 cpos = -cam.Front * 2.5;\n    float cdist = exp2(1.0 + mouseAccu.w * 0.02);\n    vec3 cpos = -cam.Front * cdist;\n\n    vec3 pxId  = vec3(frameAccu, uv); \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint h = WellonsHash(uvec3(uv, iFrame), 0u).x;\n    \n    {\n        vec2 off;\n        {\n            // filter kernel:\n            float h0 = Hash11(h);\n            float h1 = Hash11(h);\n            \n        \toff = vec2(Sample_Triangle(h0), \n                       Sample_Triangle(h1));\n        }\n           \n        #if 1\n        {\n            // bloom kernel:\n            float h0 = Hash11(h);\n            float h1 = Hash01(h);\n            \n        \toff += AngToVec(h0 * Pi) * Pow2(log2(1.0 - Pow2(h1))) * 0.25;\n        }\n        #endif\n        \n        tex21 = (uv0.xy + off) / iResolution.xy * 2.0 - vec2(1.0);\n    }\n    \n    vec2 llp;// local sample pos on lens\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n        \n        llp = Sample_Disk(h0, h1);\n        llp *= 0.05;\n    }\n    \n    vec3 glp;// global sample pos on lens\n    float S1 = cdist - 0.0;// set sphere sharp\n    vec3 rdir = NewRay(cam, tex21, llp, S1, /*out:*/ glp);\n    \n    vec2 lightAng = vec2(Pi * 1.0, Pi * 0.3);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light0 = AngToVec(lightAng);\n    vec3 light = light0;\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n        \n        h1 = mix(0.999, 1.0, h1);\n        \n        light = Sample_Sphere(h0, h1, light);\n    }\n    \n    \n    vec3 pot = vec3(1.0);\n    vec3 col = vec3(0.0);\n    \n    vec3 pos = cpos + glp;\n    vec3 dir = rdir;\n\n    for(float i = 0.0; i < 4.0; ++i)\n    {\n        bool hit; float t; vec3 n; vec3 a;\n        hit = Intersect_Scene(pos, dir, /*out:*/ t, n, a) == 1.0;\n        \n        if(hit)\n    \t{\n    \t    vec3 p = pos + dir * t;\n\t\n    \t    pot *= a;\n    \t    \n    \t    float sh;\n    \t    {\n    \t        float t2; vec3 n2; vec3 a2;\n    \t        sh = Intersect_Scene(p + n * 0.0001, light, /*out:*/ t2, n2, a2);\n    \t        sh = 1.0 - sh;\n    \t    }\n    \t    \n    \t    col += pot * clamp01(dot(light, n)) * sh * 1.0;// * RcpPi;// impl scale prim light E by Pi\n    \t    \n    \t    pos = p + n * 0.0001;\n    \t    {\n    \t        float h0 = Hash11(h);\n    \t    \tfloat h1 = Hash01(h);\n    \t        \n    \t    \tdir = Sample_ClampedCosineLobe(h0, h1, n);\n    \t    }\n    \t    \n    \t} \n    \telse \n    \t{\n    \t    //col += pot * MapColor(textureLod(iChannel2, dir, 0.0).rgb);\n    \t    \n    \t    if(i == 0.0 && dot(light0, dir) > 0.999) col += vec3(Pi);\n    \t    \n    \t    break;\n    \t}\n    }\n    \n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n        float modeLast      = ReadVar (4, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK || float(MODE) != modeLast) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n        WriteVar (float(MODE)  , 4, 0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nGood intro to ACES: https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/\n\nRendering in ACEScg retains bounce colors better than rendering in sRGB. \nThat is because the AP1 primaries (i.e. ACEScg RGB primaries) cover a wider gamut than the Rec. 709 primaries which sRGB uses.\nThis means that saturated sRGB colors are not fully saturated in ACEScg.\nYou can still get strongly saturated colors by picking colors in ACEScg directly instead of doing so in sRGB.\n\nHowever, picking colors in sRGB and converting them to ACEScg before rendering has two advantages.\n\nFirst, the sRGB gamut lies largely inside and covers a decent portion of the Pointer's gamut, a comprehensive sampling of naturally occuring albedos.\nSo using sRGB to pick albedos ensures your values to be reasonable.\n(see Rec. 709 / sRGB section here: https://www.tftcentral.co.uk/articles/pointers_gamut.htm)\n\nSecond, since ACEScg has a wider gamut than sRGB, there is no guarantee that your rendering results will be in gamut (for LDR displays).\nPicking colors in sRGB mitigates that problem even if it doesn't completely solve it.\nFor example bounce colors can still get saturated to a point where they are not longer in sRGB gamut. \nSo softclipping the rendering+tonemapping result before applying the sRGB EOTF might be a good idea.\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n\nCommon:  settings\nBufferA: rendering\nImage:   tonemapping\n\n*/\n\n\n#define EXPOSURE 1.0\n// #define DO_COLORGRADE\n\n#define MODE 0\n/*\nMODE 0: rendering in ACEScg (AP1      primaries, D60 white point) + tonemapping with desaturated AP1 primaries\nMODE 1: rendering in sRGB   (Rec. 709 primaries, D65 white point) + tonemapping with desaturated AP1 primaries\nMODE 2: rendering + tonemapping in sRGB\n*/\n\n#if MODE != 0\n#undef DO_COLORGRADE\n#endif\n\n// albedos in linear sRGB (see MapColor() in Buffer A for sRGB->ACEScg conversion)\nconst vec3 AlbedoSphere = vec3(0.02, 1.0, 0.05);\nconst vec3 AlbedoPlane0 = vec3(1.00, 0.0, 0.05);\nconst vec3 AlbedoPlane1 = vec3(0.00, 0.1, 1.00);\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, out vec3 glp)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;\n    \n    glp = cam.Right * llp.x + cam.Up * llp.y;\n    \n    vec3 dir = normalize(imgPos * S1 - glp);\n\n    return dir;\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// constants rounded to nearest primes\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSRB.jpg", "access": "api", "license": "cc0-1.0", "functions": [[71, 1774, 1803, 1803, 1877], [1879, 1879, 1905, 1905, 1979], [1981, 1981, 2010, 2010, 2116], [2118, 2118, 2144, 2144, 2250], [2253, 2253, 2291, 2291, 2496], [2498, 2498, 2534, 2534, 2666], [2669, 2669, 2706, 2706, 2836], [2838, 2838, 2873, 2873, 3002], [3005, 3005, 3043, 3043, 3176], [3178, 3178, 3215, 3215, 3350], [3353, 3353, 3391, 3391, 3543], [3545, 3545, 3582, 3582, 3717], [4642, 4642, 4669, 4669, 4795], [4798, 4798, 4820, 4820, 4947], [4949, 4949, 4971, 4971, 5093], [5095, 5095, 5117, 5117, 5243], [5246, 5304, 5335, 5335, 5728], [5731, 5731, 5767, 5767, 5959], [5961, 5961, 6000, 6000, 6280], [6282, 6282, 6309, 6309, 6574], [6576, 6576, 6633, 6633, 7150]], "test": "untested"}
{"id": "tlVXRz", "name": "Night Sneakings", "author": "crocidb", "description": "My first attempt in creating a character. I'm not really happy with the lighting yet--I'm no artist--, but I think it's time to finish this one.", "tags": ["trash", "raymarch", "animation", "night", "character"], "likes": 39, "viewed": 3857, "published": 3, "date": "1584222723", "time_retrieved": "2024-07-30T21:18:35.680262", "image_code": "// Comment these lines to disable the effect\n#define BLOOM\n#define GRAIN\n\n#define BLOOM_SAMPLES 7\nfloat threshold = 0.34;\n\nvec4 bloom(vec2 uv)\n{\n    vec4 bloom = vec4(0.0);\n    vec4 col = vec4(0.0);\n    \n    for (int x = -BLOOM_SAMPLES; x < BLOOM_SAMPLES; x++)\n    for (int y = -BLOOM_SAMPLES; y < BLOOM_SAMPLES; y++)\n    {\n        col = texture(iChannel0, uv + vec2(x, y) * vec2(.0011));\n        float val = ((0.3 * col.r) + (0.59 * col.g) + (0.11 * col.b));\n        if (val < threshold) col = vec4(0.0);\n        \n        bloom += col;\n    }\n    \n    bloom /= float((2 * BLOOM_SAMPLES) * (2 * BLOOM_SAMPLES));\n    \n    return bloom;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec4 color = texture(iChannel0, uv);\n#ifdef BLOOM\n    color += bloom(uv) * 0.7;\n#endif\n\n#ifdef GRAIN\n    vec2 guv = uv + noise(vec2(iTime)) + noise(vec2(uv));\n    float h = hash12(guv)*0.3+0.7;\n    color = color * mix(1.0, h, clamp(color.y, 0.7, 1.0));\n#endif\n    \n    // gamma\n    color.xyz = pow( color.xyz, vec3(0.735) );\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Math\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nmat2 rot(float phi)\n{\n    float c = cos(phi);\n    float s = sin(phi);\n\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c));\n}\n\n// SDF\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// SDF Operators\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// Noise\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noiseo(vec2 st)\n{\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    \n    float r = mix( mix( dot( random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return r * .5 + .5;\n}\n\nfloat fbm(vec2 st)\n{\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < 4; i++)\n    {\n        value += amplitude * noiseo(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n// Noise and FBM (as seen on iq tutorials)\n//==========================================================================================\n// hashes\n//==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n#if 0\n    p *= 0.3183099;\n    float kx0 = 50.0*fract( p.x );\n    float kx1 = 50.0*fract( p.x+0.3183099 );\n    float ky0 = 50.0*fract( p.y );\n    float ky1 = 50.0*fract( p.y+0.3183099 );\n\n    float a = fract( kx0*ky0*(kx0+ky0) );\n    float b = fract( kx1*ky0*(kx1+ky0) );\n    float c = fract( kx0*ky1*(kx0+ky1) );\n    float d = fract( kx1*ky1*(kx1+ky1) );\n#else\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n#endif\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\nfloat fbm_2( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<2; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}", "buffer_a_code": "#define NOISE\n\n#define AA 1\n\n#define ZERO (min(iFrame,0))\n#define MAX_STEPS\t\t\t300\n#define MAX_DIST\t\t\t9.0\n#define SURFACE_DIST\t\t0.001\n\nconst vec3 bin_disp = vec3(0.0, -0.72, 1.0);\n\nfloat sin_func(float x, int t)\n{\n    float vi = sin(x);\n    float v = vi;\n    for (int i = 2; i <= t; i++)\n    {\n        v += sin(vi * float(i)) / 10.0;\n    }\n    \n    return v;\n}\n\nfloat cos_func(float x, int t)\n{\n    float vi = cos(x);\n    float v = vi;\n    for (int i = 2; i <= t; i++)\n    {\n        v += cos(vi * float(i)) / 10.0;\n    }\n    \n    return v;\n}\n\nvec2 map(vec3 p, bool complete)\n{\n    vec2 v = vec2(MAX_DIST, 0.0);\n    \n    // floor\n    float f = dot(p + vec3(0.0, 0.3, 0.0), vec3(0.0, 1.0, 0.0)) + 0.0;\n    f = min(f, sdBox(p + vec3(0.0, 0.32, 0.0), vec3(10.2, 0.3, 2.7)) - .025);\n\n    #ifdef NOISE\n    if (p.y < 0.1 && complete) f -= abs(noise(p * 40.0)) * .01 + (p.z > -2.73 ? abs(noise(p * 10.0)) * .03 : 0.0);\n    #endif\n    if (f < v.x) v = vec2(f, 1.0);\n    \n    // trash bin\n    vec3 bin_pos = p + bin_disp;\n    if (sdBox(bin_pos, vec3(1.3, 1.5, 0.6)) < v.x)\n    {\n        float dl = smoothstep(0.3, 1.0, ((p.y + 4.1) * 0.2));\n        float t = sdBox(bin_pos, vec3(1.0 * dl, 0.5, 0.5 * dl));\n        t = min(t, sdBox(bin_pos + vec3(0.0, -0.8 - p.z * 0.3, 0.0), vec3(1.0, 0.2, 0.5))) - .05;\n        t = opSmoothUnion(t, sdBox(bin_pos + vec3(0.0, -0.95 - p.z * 0.3, 0.0), vec3(1.0 * dl, 0.05, 0.5 * dl)) - .07, 0.05);\n        t = opSmoothSubtraction(sdBox(bin_pos + vec3(0.0, -0.3, 0.0), vec3(0.95 * dl, 0.7, 0.45 * dl)), t, 0.19);\n        t = opSmoothUnion(t, sdBox(abs(bin_pos + vec3(0.0, -0.015, 0.51)) + vec3(-0.4, 0.0, 0.0), vec3(0.005 * dl, 0.32, 0.002 * dl)), 0.035);\n        if (t < v.x) v = vec2(t, 3.0);\n    \n        // bin wheels\n        vec3 wheel_pos = abs(bin_pos + vec3(0.0, 0.62, 0.0));\n        wheel_pos.xy *= rot(PI_2);\n        wheel_pos +=  vec3(-0.0, -0.7, -0.4);\n\n        float bw = sdCappedCylinder(wheel_pos, 0.081, 0.016) - .02;\n        if (bw < v.x) v = vec2(bw, 4.0);\n\n        // bin lid\n        float x = iTime * 1.82f;\n        float sx = sin(x * PI_4);\n        float s = sx + sin(2.0 * sx) / 2.0 + sin(3.0 * sx) / 3.0 + sin(4.0 * sx) / 10.0 + sin(5.0 * sx) / 10.0;\n        vec3 lid_pos = bin_pos - vec3(0.0, 0.88, 0.0) - vec3(0.0, 0.0, .5);\n        lid_pos.yz *= rot(PI_4 * 0.4 + ((PI_4) * -smoothstep(2.0, 0.1, exp(s)) * 1.0 - 0.0));\n        lid_pos += vec3(0.0, 0.0, .5);\n\n        float lid = sdBox(lid_pos, vec3(0.99, 0.015, 0.5)) - .03;\n        lid = opSmoothUnion(lid, \n                 sdBox(\n                     abs(\n                         abs(\n                             abs(lid_pos - vec3(0.0, 0.04, 0.0)) \n                             - vec3(0.5, 0.0, 0.0))\n                         - vec3(0.2, 0.0, 0.0))\n                     - vec3(0.1, 0.0, 0.0), vec3(0.005, 0.018, 0.4)) - .01, \n                     0.1);\n\n        if (lid < v.x) v = vec2(lid, 3.0);\n\n        // character\n        float s2 = sin_func(x * PI_2, 6);\n        float s3 = sin_func(x * PI + PI_2, 2);\n        vec3 e_pos = bin_pos - vec3(-0.1 + s2 * 0.35, max(0.1 - s * 0.42 - s3 * 0.06, 0.1), 0.0);\n        \n        if (sdSphere(e_pos, 0.2) < v.x && complete)\n        {\n            float c2 = cos_func(x * PI_2, 6);\n\n            float eh = (cos_func(x * PI_2 + PI_4, 7) * 0.5 + 0.5) * 0.03;\n        \tfloat eh2 = (sin_func(x * PI_2, 8) * 0.5 + 0.5) * 0.03;\n            \n            float eye = sdSphere(abs(e_pos - vec3(0.06 + s2 * .02, max(0.0, -0.25 - s * 0.16), -0.02)) - vec3(0.074, 0.0, 0.0), .038);\n            if (eye < v.x) v = vec2(eye, 6.0);\n\n            float eyes = sdEllipsoid(e_pos - vec3(0.0, eh, 0.0), vec3(.075, .095 + eh, .07));\n            eyes = min(eyes, sdEllipsoid(e_pos - vec3(0.15, eh2, 0.0), vec3(.075, .095 + eh2, .07)));\n            eyes = opSmoothSubtraction(eye - .002, eyes, .04);\n            if (eyes < v.x) v = vec2(eyes, 5.0);\n        }\n    }\n    \n    // wall\n    if (sdBox(p - vec3(0.0, 1.5, 0.2), vec3(20.0, 1.5, 0.5)) < v.x)\n    {\n        float w = sdBox(p - vec3(0.0, 0.0, 0.2), vec3(20.0, 5.0, 0.2));\n        if (w < v.x) v = vec2(w, 2.0);\n\n       \tif (complete)\n        {\n            // wall bricks\n            vec3 c = vec3(0.45, 0.4, 0.0);\n            vec3 bp = p - vec3(0.0, 0.13, 0.01);\n            vec3 bp1 = mod(bp + 0.5 * c, c) - 0.5 * c;\n            bp -= vec3(0.225, 0.2, 0.0);\n            vec3 bp2 = mod(bp + 0.5 * c, c) - 0.5 * c;\n\n            float br = sdBox(bp1, vec3(0.188, 0.06, 0.03));\n            br = min(br, sdBox(bp2, vec3(0.188, 0.06, 0.03))) - .01;\n            \n            #ifdef NOISE\n            float abs_noise_1 = abs(noise(p * 30.0));\n            float abs_noise_2 = abs(noise(p * 5.0));\n            \n            br -= abs_noise_2 * 0.02 + abs_noise_1 * .01;\n            #endif\n            \n            if (br < v.x) v = vec2(br, 7.0);\n        }\n        \n    }\n\n    \n    return v;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e, true).x;\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec3 p;\n    vec2 obj;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = ro + t * rd;\n       \t\n        obj = map(p, true);\n        \n        if (obj.x < SURFACE_DIST || t > MAX_DIST) break;\n        \n        t += obj.x;\n    }\n    \n    obj.x = t;\n    return obj;\n}\n\n// Lighting\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.0016f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec2 obj = map(p + n * t, true);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 2.2) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nfloat getVisibility(vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < MAX_DIST)\n\t{\n\t\tvec2 o = map(p0 + rd * t, false);\n\n\t\tif(o.x < SURFACE_DIST)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\n\t\tt += o.x;\n\t}\n\n\treturn f;\n}\n\n// Texturing\nvec2 triplanar(vec3 p, vec3 normal)\n{\n    if (abs(dot(normal, vec3(0.0, 1.0, 0.0))) > .8)\n    {\n        return p.xz;\n    }\n    else if (abs(dot(normal, vec3(1.0, 0.0, 0.0))) > .8)\n    {\n        return p.yz;\n    }\n    else\n    {\n        return p.xy;\n    }\n}\n\n// Renderer\nvec3 render(vec2 obj, vec3 p, vec3 rd, vec2 uv)\n{\n    vec3 col;\n    \n    vec3 normal = calcNormal(p);\n    float fog;\n    \n    vec3 background = vec3(0.0, 0.01, 0.05);\n    float n = fbm(uv * 250.0 + iTime * .4);\n    n = smoothstep(0.6, 0.65, n) * .5;\n    background += n;\n    \n    if (obj.x >= MAX_DIST)\n    {\n        col = background;\n    }\n    else\n    {\n        float wallnoise = ((noise(p * 2.0)) * .2 + 0.7);\n        \n        vec3 albedo = vec3(0.0, 0.0, 0.0);\n        fog = pow((obj.x / MAX_DIST), 6.8);\n        float aa = 1.0;\n        \n        float diff_mask = 1.0;\n        float spec_power = 15.0;\n        float spec_mask = 1.0;\n        \n        if (obj.y >= 7.0) // wall bricks\n        {\n            float n = abs(noise(uv * 2.0));\n            albedo = vec3(0.505, 0.194, 0.184) * (n * 0.4 + 0.6);\n            \n            aa = ambientOcclusion(p, normal);\n            spec_power = 20.0;\n            spec_mask = .6 * n + .4;\n        }\n        else if (obj.y >= 6.0) // character eyes\n        {\n            //vec2 uv = triplanar(p, normal) * 3.0;\n            //uv = mod(uv * 0.02 + 0.5, 1.0);\n            albedo = vec3(0.165, 0.154, 0.184);\n            diff_mask = 0.0;\n            spec_power = 90.0;\n            spec_mask = 1.7f;\n        }\n        else if (obj.y >= 5.0) // character eye balls\n        {\n            albedo = vec3(1.365, 1.354, 1.384);\n            diff_mask = 0.0;\n            spec_power = 90.0;\n            spec_mask = .8f;\n        }\n        else if (obj.y >= 4.0) // bin wheel\n        {\n            albedo = vec3(0.105, 0.154, 0.184);\n        }\n        else if (obj.y >= 3.0) // bin\n        {\n            albedo = vec3(0.145, 0.454, 0.194);\n            vec3 d = (bin_disp - vec3(0.0, -1.5, 1.8)) - p;\n            vec3 n = normalize(d);\n            if (dot(normal, n) > 0.0) albedo *= (dot(normal, n) * .5 + .5) * .1;\n            aa = ambientOcclusion(p, normal);\n            spec_power = 90.0;\n            spec_mask = 2.5f;\n             \n        }\n        else if (obj.y >= 2.0) // Walls\n        {\n            albedo = vec3(0.305, 0.354, 0.384) * wallnoise;\n            aa = ambientOcclusion(p, normal);\n        }\n        else if (obj.y >= 1.0) // floor\n        {\n            albedo = vec3(0.285, 0.364, 0.294) * 0.9 * (p.z < -2.73 ? 0.6 : 0.8);\n            aa = ambientOcclusion(p, normal);\n            spec_power = 10.0;\n            spec_mask = 0.5;\n        }\n        \n        // Ambient light\n        #if 1\n        col += albedo * pow(aa, 2.0) * .4;\n        #endif\n        \n        // Top Light\n        #if 1\n        {\n            vec3 light_pos = vec3(-10.0, 20.0, 0.4);\n            vec3 light_col = vec3(0.2, 0.2, 1.0);\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = dot(light_dir, normal);\n            float visibility = getVisibility(p, light_pos, 10.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diff_mask * diffuse * albedo * visibility * light_col * .46;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n        #endif\n        \n        // Street Light\n        #if 1\n        {\n            vec3 light_pos = vec3(6.0, 7.0, -4.0);\n            vec3 light_col = vec3(0.725, 0.285, 0.0);\n            vec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n\n            float diffuse = dot(normalize(light_pos - p), normal);\n            float visibility = getVisibility(p, light_pos, 10.0);\n            float spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diff_mask * diffuse * albedo * visibility * light_col * 2.0;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n        #endif\n        \n    }\n    \n    return mix(col, background, fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(-1.5, 2.0, -4.0);\n    \n// Free camera 1\n#if 0\n    float d = 1.0;\n    float v = ((iMouse.x / iResolution.x) - .5) * -5.;\n    vec3 ta = ro + vec3(sin(v) * d, clamp((iMouse.y / iResolution.y) - .5, -0.5, 0.5), cos(v) * d);\n    \n// Free camera 2\n#elif 0\n    float d = 5.0;\n    float u = iMouse.x / iResolution.x * -5.0;\n    float v = (1.0 - iMouse.y / iResolution.y) * 10.0;\n    vec3 ta = vec3(0.0, 0.6, -1.0);\n    ro = vec3(\n        sin(u) * d,\n        v * .1f * d,\n        cos(u) * d\n    );\n    \n// Fixed camera\n#elif 1 \n    float mx = iMouse.x / iResolution.x * -0.2;\n    float my = (1.0 - iMouse.y / iResolution.y) * 0.5;\n    \n    float d = 5.0;\n    float u = mx + -2.6 + (sin(iTime * .3)) * -0.2;\n    float v = my + 2.6 + sin(iTime * .2) * 0.5;\n    vec3 ta = vec3(0.0, 0.8, -1.0);\n    ro = vec3(\n        sin(u) * d,\n        v * .1f * d,\n        cos(u) * d\n    );\n#endif\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for(int m=ZERO; m<AA; m++)\n    for(int n=ZERO; n<AA; n++)\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else    \n    \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif       \n        // Ray direction\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n        vec3 vv = normalize(cross(uu, ww));\n        \n        vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.3 * ww);\n        \n        // render\t\n        vec2 obj = rayMarch(ro, rd);\n        vec3 p = ro + obj.x * rd;\n    \n   \t\tvec3 col = render(obj, p, rd, uv);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n        \n\n    fragColor = vec4(tot,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 144, 144, 635], [638, 638, 695, 695, 1104]], "test": "untested"}
{"id": "wlKSW3", "name": "大龙猫 - Quicky#026", "author": "totetmatt", "description": "Falling Sprites ", "tags": ["instagram", "quicky"], "likes": 7, "viewed": 551, "published": 3, "date": "1584214840", "time_retrieved": "2024-07-30T21:18:36.440230", "image_code": "float hash21(vec2 uv){\n    uv = fract(uv *vec2(62026.3504,74514.74));\n    uv += dot(uv,uv+vec2(65.408,83.54));\n    return fract(uv.x*uv.y);\n}\nfloat sq(vec2 uv,vec2 s) {\n    uv.y += hash21(vec2(floor(uv.x*10.))) + tan(floor(uv.x*10.)+iTime*hash21(vec2(floor(uv.x*10.)+.1)))*.1;\n    s.y += hash21(floor(uv*100.));\n    vec2 d = abs(uv) - s;\n    float sqr = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return smoothstep(0.00021,0.0002,sqr);\n    \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n\n    float d = sq(uv,vec2(1.,.13));\n    vec3 col = vec3(.0);\n    col.g = d*.9*log2(2.-fract(iTime*.33))/hash21(vec2(floor(uv.x*100.)));\n    col.b = d*.9*log2(2.-fract(iTime*.66))/hash21(vec2(floor(uv.x*75.)));\n    \n    col *= smoothstep(1.0,.5*cos(uv.y*10.+iTime),length(uv));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKSW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 141], [142, 142, 168, 168, 447], [448, 448, 503, 503, 877]], "test": "untested"}
{"id": "Wsfyz4", "name": "Smooth molecular dynamics II", "author": "michael0884", "description": "Going mad and storing 8 particle id's in 1 texel based on the distance to the texel. Now with molecular dynamics lol", "tags": ["particles"], "likes": 10, "viewed": 433, "published": 3, "date": "1584213691", "time_retrieved": "2024-07-30T21:18:37.261035", "image_code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-14 14:30:34\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    get(p);\n   \tfloat y = 0., x = 0.;\n    for(int i = 0; i < CN; i++)\n    {\n        float d =particleDistance(ids[i],pos); \n         d /= 2.*prad;\n        y += -2.*sin(d)/(k*d);\n        x += gauss(d,2.*prad);\n    }\n    col = .5+.5*sin((5.+vec4(1,2,3,4))*(x)); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n//particle buffer\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n//force scalar\nfloat F(float d)\n{\n\treturn 0.5*(d - 10.*prad)*gauss(d, 10.*prad);\n}\n\n//force vector\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    if(!all(equal(p0,p1)))\n   \t return normalize(p1-p0)*F(distance(p1,p0));\n    else\n     return vec2(0.);\n}\n\n//get particle from array\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        int tid = xy2i(p);\n        //this pixel value\n        U = texel(ch1, pos);\n   \t\t\n        //neighbors\n   \t\tget(ivec2(U.xy));\n      \n        vec2 F = vec2(0.,-0.03);\n        \n        for(int i = 0; i < CN; i++)\n        {\n            if(ids[i]==tid) continue;\n            vec4 pi = getParticle(ids[i]);\n        \tF += Fv(U.xy, pi.xy);    \n        }\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 3.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += dt*F;\n        U.zw *= 1. - 0.004*dt*length(U.zw); //cooling\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<3)\n        {\n            U.xy = size*hash22(pos)+1.;\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(40,40)\n#define dt 0.5\n#define prad 1.\n#define k 0.3\n#define ff 4.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\n//closest particle ids\n#define CN 8\nint ids[CN];\n//particle distances\nfloat ds[CN];\n\nivec2 one2two(int a)\n{\n    return ivec2(a%tot_n, a/tot_n);\n}\n\nint two2one(ivec2 a)\n{\n    return a.x + tot_n*a.y;\n}\n\nvoid toarr(inout int b[CN], ivec2 a, int i)\n{\n    b[i] = a.x;\n    b[i+1] = a.y;\n}\n\nvoid init()\n{\n    for(int i = 0; i<CN; i++)\n    {\n        ids[i] = -1;\n        ds[i] = 1e10;\n    }\n}\n\nvoid getA(inout int b[CN], ivec2 p)\n{ \n    ivec4 a = floatBitsToInt(texel(fake, p/2));\n    toarr(b, one2two(a.x), 0);\n    toarr(b, one2two(a.y), 2);\n    toarr(b, one2two(a.z), 4);\n    toarr(b, one2two(a.w), 6);\n}\n\nvoid get(ivec2 p)\n{\n    getA(ids, p);\n}\n\nvec4 save()\n{\n    ivec4 v = ivec4(two2one(ivec2(ids[0],ids[1])),\n                    two2one(ivec2(ids[2],ids[3])),\n                    two2one(ivec2(ids[4],ids[5])),\n                    two2one(ivec2(ids[6],ids[7])));\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}", "buffer_b_code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid insert(int id, float d, int i)\n{\n    //shift all by 1\n    for(int j = CN-1; j > i; j--)\n    {\n        ids[j] = ids[j-1];\n        ds[j] = ds[j-1];\n    }\n    \n    //insert\n    ids[i] = id; \n    ds[i] = d;\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+1.;\n    float dtemp = particleDistance(utemp, pos);  \n    //sorting\n    for(int i = 0; i < CN; i++)\n    {\n        if(ids[i] == utemp) return;\n        \n        if(ids[i] < 0 || ds[i] >= dtemp)\n        {\n            insert(utemp, dtemp, i);\n            return;\n        }\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    int t[CN];\n    getA(t, max(p + dx, ivec2(0,0)));\n    \n\tfor(int i = 0; i < CN; i++)\n    {\n   \t\tif(t[i]>=0)\n        \tsort(t[i], p);\n    }\n}\n\nvoid randupd(ivec2 p )\n{\n    for(int i = 0; i < 9; i++)\n    {\n        //go through the entire array sudorandomly\n        sort(((iFrame + p.x + p.y*int(iResolution.x))^(1<<i))%tot_n, p);\n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 2);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    pos *= 2.;\n    if(pos.x < iResolution.x && pos.y < iResolution.y) //8x voronoi particle tracking but in 2x lower res\n    {\n        ivec2 p = 2*ivec2(pos/2.);\n\n        init();\n\n        update(p);\n\n        U = save();\n    } else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsfyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 139, 139, 174], [176, 176, 216, 216, 262], [264, 264, 295, 295, 329], [331, 331, 383, 383, 502], [504, 504, 549, 549, 838]], "test": "untested"}
{"id": "3sXyz4", "name": "Pilot wave system II", "author": "michael0884", "description": "Going mad and storing 8 particle id's in 1 texel based on the distance to the texel. Pilot wave particles the sequel. ", "tags": ["particles"], "likes": 16, "viewed": 512, "published": 3, "date": "1584209909", "time_retrieved": "2024-07-30T21:18:38.121734", "image_code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-14 14:30:34\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    get(p);\n   \tfloat y = 0., x = 0.;\n    for(int i = 0; i < CN; i++)\n    {\n        float d =particleDistance(ids[i],pos); \n         d /= 2.*prad;\n        y += -2.*sin(d)/(k*d);\n        x += gauss(d,2.*prad);\n    }\n    col = .5+.5*sin(0.1*vec4(1,2,3,4)*(3.*y + x*40.)); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n//particle buffer\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n//force scalar\nfloat F(float d)\n{\n    d /= 2.*prad;\n    return -ff*sin(d)/(k*d);\n}\n\n//force vector\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    if(!all(equal(p0,p1)))\n   \t return normalize(p1-p0)*F(distance(p1,p0));\n    else\n     return vec2(0.);\n}\n\n//get particle from array\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n   \t\t\n        //neighbors\n   \t\tget(ivec2(U.xy));\n      \n        vec2 F = vec2(0.,0.);\n        \n        vec4 p0 = getParticle(ids[0]);\n        for(int i = 1; i < CN; i++)\n        {\n            vec4 pi = getParticle(ids[i]);\n        \tF += Fv(U.xy, pi.xy);    \n        }\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 3.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += dt*F;\n        U.zw *= 1. - 0.004*dt*length(U.zw); //cooling\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<3)\n        {\n            U.xy = size*hash22(pos)+1.;\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(12,12)\n#define dt 0.5\n#define prad 1.\n#define k 0.3\n#define ff 4.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\n//closest particle ids\n#define CN 8\nint ids[CN];\n//particle distances\nfloat ds[CN];\n\nivec2 one2two(int a)\n{\n    return ivec2(a%tot_n, a/tot_n);\n}\n\nint two2one(ivec2 a)\n{\n    return a.x + tot_n*a.y;\n}\n\nvoid toarr(inout int b[CN], ivec2 a, int i)\n{\n    b[i] = a.x;\n    b[i+1] = a.y;\n}\n\nvoid init()\n{\n    for(int i = 0; i<CN; i++)\n    {\n        ids[i] = -1;\n        ds[i] = 1e10;\n    }\n}\n\nvoid getA(inout int b[CN], ivec2 p)\n{ \n    ivec4 a = floatBitsToInt(texel(fake, p/2));\n    toarr(b, one2two(a.x), 0);\n    toarr(b, one2two(a.y), 2);\n    toarr(b, one2two(a.z), 4);\n    toarr(b, one2two(a.w), 6);\n}\n\nvoid get(ivec2 p)\n{\n    getA(ids, p);\n}\n\nvec4 save()\n{\n    ivec4 v = ivec4(two2one(ivec2(ids[0],ids[1])),\n                    two2one(ivec2(ids[2],ids[3])),\n                    two2one(ivec2(ids[4],ids[5])),\n                    two2one(ivec2(ids[6],ids[7])));\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}", "buffer_b_code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid insert(int id, float d, int i)\n{\n    //shift all by 1\n    for(int j = CN-1; j > i; j--)\n    {\n        ids[j] = ids[j-1];\n        ds[j] = ds[j-1];\n    }\n    \n    //insert\n    ids[i] = id; \n    ds[i] = d;\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+1.;\n    float dtemp = particleDistance(utemp, pos);  \n    //sorting\n    for(int i = 0; i < CN; i++)\n    {\n        if(ids[i] == utemp) return;\n        \n        if(ids[i] < 0 || ds[i] >= dtemp)\n        {\n            insert(utemp, dtemp, i);\n            return;\n        }\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    int t[CN];\n    getA(t, max(p + dx, ivec2(0,0)));\n    \n\tfor(int i = 0; i < CN; i++)\n    {\n   \t\tif(t[i]>=0)\n        \tsort(t[i], p);\n    }\n}\n\nvoid randupd(ivec2 p )\n{\n    for(int i = 0; i < 6; i++)\n    {\n        //go through the entire array sudorandomly\n        sort(((iFrame + p.x + p.y*int(iResolution.x))^(1<<i))%tot_n, p);\n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 2);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    pos *= 2.;\n    if(pos.x < iResolution.x && pos.y < iResolution.y) //8x voronoi particle tracking but in 2x lower res\n    {\n        ivec2 p = 2*ivec2(pos/2.);\n\n        init();\n\n        update(p);\n\n        U = save();\n    } else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 139, 139, 174], [176, 176, 216, 216, 262], [264, 264, 295, 295, 329], [331, 331, 383, 383, 502], [504, 504, 549, 549, 848]], "test": "untested"}
{"id": "WsXyR4", "name": "Pi Night", "author": "dr2", "description": "Celebrating Pi's digits the night after Pi Day (mouseable)", "tags": ["text", "numerology"], "likes": 6, "viewed": 496, "published": 3, "date": "1584204801", "time_retrieved": "2024-07-30T21:18:39.130038", "image_code": "// \"Pi Night\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Celebrating Pi's digits the night after Pi Day (mouseable)\n\n#define MORE_DIG_1   0   // more digits (slower compile and may not work everywhere)\n#define MORE_DIG_2   0   // even more digits\n#define AA           1   // optional antialiasing\n\n#define txFnt iChannel0\n\nint GetTxChar (vec2 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir;\nvec2 qnTex;\nfloat dstFar, txDep;\nconst float pi = 3.14159;\n\nfloat FontTexDf (vec3 p)\n{\n  vec3 tx;\n  float d;\n  int ic;\n  ic = GetTxChar (p.xz);\n  if (ic != 0) {\n    tx = texture (txFnt, mod ((vec2 (mod (float (ic), 16.),\n       15. - floor (float (ic) / 16.)) + fract (p.xz)) * (1. / 16.), 1.)).gba - 0.5;\n    qnTex = vec2 (tx.r, - tx.g);\n    d = tx.b + 1. / 256.;\n  } else d = 1.;\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 srd, h;\n  float dHit, dLim, d, w;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  srd = - sign (rd.xz);\n  rdi = 1. / abs (rd);\n  w = txDep;\n  dHit = max (rdi.y * (abs (ro.y) - 0.5 * w - 0.02), 0.);\n  dLim = min (dHit + rdi.y * (w + 0.02), dstFar);\n  for (int j = 0; j < 160; j ++) {\n    p = ro + dHit * rd;\n    h = fract (rdi.xz * fract (srd * p.xz));\n    d = max (FontTexDf (p), abs (p.y) - 0.5 * w);\n    dHit += min (d, 0.01 + min (h.x, h.y));\n    if (d < 0.0001 || dHit > dLim) break;\n  }\n  if (d >= 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 32. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstTxt;\n  bgCol = StarPat (rd, 16.);\n  dstTxt = ObjRay (ro, rd);\n  if (dstTxt < dstFar) {\n    ro += rd * dstTxt;\n    if (abs (ro.y) < 0.495 * txDep) vn = normalize (vec3 (qnTex.x, 0.00001, qnTex.y));\n    else vn = vec3 (0., - sign (ro.y * rd.y), 0.);\n    col = vec3 (1., 1., 0.7) * (0.3 + 0.7 * max (dot (sunDir, vn), 0.) +\n       0.4 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.));\n    col = mix (col, bgCol, pow (min (dstTxt / dstFar, 1.), 5.));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, tCur, tCyc, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.5 * pi;\n  el = -0.33 * pi;\n  if (mPtr.z > 0.) {\n    az -= 3. * pi * mPtr.x;\n    el -= 1.5 * pi * mPtr.y;\n  }\n  ro = vec3 (0.01, 0., -40.);\n  sunDir = normalize (vec3 (0.5, 1., -1.));\n  ro.xz = Rot2D (ro.xz, 0.5 * pi + az);\n  ro.yz = Rot2D (ro.yz, 0.5 * pi + el);\n  sunDir.xz = Rot2D (sunDir.xz, 0.5 * pi + az);\n  sunDir.yz = Rot2D (sunDir.yz, 0.5 * pi + el);\n#if MORE_DIG_2\n  tCyc = 60.;\n#elif MORE_DIG_1\n  tCyc = 30.;\n#else\n  tCyc = 20.;\n#endif\n  txDep = 0.3;\n  ro.z += 1.5 * (tCyc - tCur);\n  ro.x -= 0.5;\n  dstFar = 200.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 2.));\n    rd.xz = Rot2D (rd.xz, 0.5 * pi + az);\n    rd.yz = Rot2D (rd.yz, 0.5 * pi + el);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\n#define C(c) _ic = (_nc -- == 0) ? (c) : _ic;\n\n#define _0     C(0x30)\n#define _1     C(0x31)\n#define _2     C(0x32)\n#define _3     C(0x33)\n#define _4     C(0x34)\n#define _5     C(0x35)\n#define _6     C(0x36)\n#define _7     C(0x37)\n#define _8     C(0x38)\n#define _9     C(0x39)\n\nint GetTxChar (vec2 p)\n{\n  vec2 fp;\n  ivec2 ip;\n  float d;\n  int _ic, _nc;\n  fp = floor (p);\n  fp.y = - fp.y;\n#if MORE_DIG_2\n  fp.y = mod (fp.y, 38.);\n#elif MORE_DIG_1\n  fp.y = mod (fp.y, 21.);\n#else\n  fp.y = mod (fp.y, 12.);\n#endif\n  ip = ivec2 (fp);\n  ip.x += 20;\n  _nc = ip.x;\n  _ic = 0;\n  if (ip.x >= 0 && ip.x < 80) {\n    if (ip.y ==  0) { _3 _1 _4 _1 _5 _9 _2 _6 _5 _3 _5 _8 _9 _7 _9 _3 _2 _3 _8 _4 _6 _2 _6 _4 _3 _3 _8 _3 _2 _7 _9 _5 _0 _2 _8 _8 _4 _1 _9 }\n    if (ip.y ==  1) { _7 _1 _6 _9 _3 _9 _9 _3 _7 _5 _1 _0 _5 _8 _2 _0 _9 _7 _4 _9 _4 _4 _5 _9 _2 _3 _0 _7 _8 _1 _6 _4 _0 _6 _2 _8 _6 _2 _0 }\n    if (ip.y ==  2) { _8 _9 _9 _8 _6 _2 _8 _0 _3 _4 _8 _2 _5 _3 _4 _2 _1 _1 _7 _0 _6 _7 _9 _8 _2 _1 _4 _8 _0 _8 _6 _5 _1 _3 _2 _8 _2 _3 _0 }\n    if (ip.y ==  3) { _6 _6 _4 _7 _0 _9 _3 _8 _4 _4 _6 _0 _9 _5 _5 _0 _5 _8 _2 _2 _3 _1 _7 _2 _5 _3 _5 _9 _4 _0 _8 _1 _2 _8 _4 _8 _1 _1 _1 }\n    if (ip.y ==  4) { _7 _4 _5 _0 _2 _8 _4 _1 _0 _2 _7 _0 _1 _9 _3 _8 _5 _2 _1 _1 _0 _5 _5 _5 _9 _6 _4 _4 _6 _2 _2 _9 _4 _8 _9 _5 _4 _9 _3 }\n    if (ip.y ==  5) { _0 _3 _8 _1 _9 _6 _4 _4 _2 _8 _8 _1 _0 _9 _7 _5 _6 _6 _5 _9 _3 _3 _4 _4 _6 _1 _2 _8 _4 _7 _5 _6 _4 _8 _2 _3 _3 _7 _8 }\n    if (ip.y ==  6) { _6 _7 _8 _3 _1 _6 _5 _2 _7 _1 _2 _0 _1 _9 _0 _9 _1 _4 _5 _6 _4 _8 _5 _6 _6 _9 _2 _3 _4 _6 _0 _3 _4 _8 _6 _1 _0 _4 _5 }\n    if (ip.y ==  7) { _4 _3 _2 _6 _6 _4 _8 _2 _1 _3 _3 _9 _3 _6 _0 _7 _2 _6 _0 _2 _4 _9 _1 _4 _1 _2 _7 _3 _7 _2 _4 _5 _8 _7 _0 _0 _6 _6 _0 }\n    if (ip.y ==  8) { _6 _3 _1 _5 _5 _8 _8 _1 _7 _4 _8 _8 _1 _5 _2 _0 _9 _2 _0 _9 _6 _2 _8 _2 _9 _2 _5 _4 _0 _9 _1 _7 _1 _5 _3 _6 _4 _3 _6 }\n    if (ip.y ==  9) { _7 _8 _9 _2 _5 _9 _0 _3 _6 _0 _0 _1 _1 _3 _3 _0 _5 _3 _0 _5 _4 _8 _8 _2 _0 _4 _6 _6 _5 _2 _1 _3 _8 _4 _1 _4 _6 _9 _5 }\n    if (ip.y == 10) { _1 _9 _4 _1 _5 _1 _1 _6 _0 _9 _4 _3 _3 _0 _5 _7 _2 _7 _0 _3 _6 _5 _7 _5 _9 _5 _9 _1 _9 _5 _3 _0 _9 _2 _1 _8 _6 _1 _1 }\n#if MORE_DIG_1\n    if (ip.y == 11) { _7 _3 _8 _1 _9 _3 _2 _6 _1 _1 _7 _9 _3 _1 _0 _5 _1 _1 _8 _5 _4 _8 _0 _7 _4 _4 _6 _2 _3 _7 _9 _9 _6 _2 _7 _4 _9 _5 _6 }\n    if (ip.y == 12) { _7 _3 _5 _1 _8 _8 _5 _7 _5 _2 _7 _2 _4 _8 _9 _1 _2 _2 _7 _9 _3 _8 _1 _8 _3 _0 _1 _1 _9 _4 _9 _1 _2 _9 _8 _3 _3 _6 _7 }\n    if (ip.y == 13) { _3 _3 _6 _2 _4 _4 _0 _6 _5 _6 _6 _4 _3 _0 _8 _6 _0 _2 _1 _3 _9 _4 _9 _4 _6 _3 _9 _5 _2 _2 _4 _7 _3 _7 _1 _9 _0 _7 _0 }\n    if (ip.y == 14) { _2 _1 _7 _9 _8 _6 _0 _9 _4 _3 _7 _0 _2 _7 _7 _0 _5 _3 _9 _2 _1 _7 _1 _7 _6 _2 _9 _3 _1 _7 _6 _7 _5 _2 _3 _8 _4 _6 _7 }\n    if (ip.y == 15) { _4 _8 _1 _8 _4 _6 _7 _6 _6 _9 _4 _0 _5 _1 _3 _2 _0 _0 _0 _5 _6 _8 _1 _2 _7 _1 _4 _5 _2 _6 _3 _5 _6 _0 _8 _2 _7 _7 _8 }\n    if (ip.y == 16) { _5 _7 _7 _1 _3 _4 _2 _7 _5 _7 _7 _8 _9 _6 _0 _9 _1 _7 _3 _6 _3 _7 _1 _7 _8 _7 _2 _1 _4 _6 _8 _4 _4 _0 _9 _0 _1 _2 _2 }\n    if (ip.y == 17) { _4 _9 _5 _3 _4 _3 _0 _1 _4 _6 _5 _4 _9 _5 _8 _5 _3 _7 _1 _0 _5 _0 _7 _9 _2 _2 _7 _9 _6 _8 _9 _2 _5 _8 _9 _2 _3 _5 _4 }\n    if (ip.y == 18) { _2 _0 _1 _9 _9 _5 _6 _1 _1 _2 _1 _2 _9 _0 _2 _1 _9 _6 _0 _8 _6 _4 _0 _3 _4 _4 _1 _8 _1 _5 _9 _8 _1 _3 _6 _2 _9 _7 _7 }\n    if (ip.y == 19) { _4 _7 _7 _1 _3 _0 _9 _9 _6 _0 _5 _1 _8 _7 _0 _7 _2 _1 _1 _3 _4 _9 _9 _9 _9 _9 _9 _8 _3 _7 _2 _9 _7 _8 _0 _4 _9 _9 _5 }\n#endif\n#if MORE_DIG_2\n    if (ip.y == 20) { _1 _0 _5 _9 _7 _3 _1 _7 _3 _2 _8 _1 _6 _0 _9 _6 _3 _1 _8 _5 _9 _5 _0 _2 _4 _4 _5 _9 _4 _5 _5 _3 _4 _6 _9 _0 _8 _3 _0 }\n    if (ip.y == 21) { _2 _6 _4 _2 _5 _2 _2 _3 _0 _8 _2 _5 _3 _3 _4 _4 _6 _8 _5 _0 _3 _5 _2 _6 _1 _9 _3 _1 _1 _8 _8 _1 _7 _1 _0 _1 _0 _0 _0 }\n    if (ip.y == 22) { _3 _1 _3 _7 _8 _3 _8 _7 _5 _2 _8 _8 _6 _5 _8 _7 _5 _3 _3 _2 _0 _8 _3 _8 _1 _4 _2 _0 _6 _1 _7 _1 _7 _7 _6 _6 _9 _1 _4 }\n    if (ip.y == 23) { _7 _3 _0 _3 _5 _9 _8 _2 _5 _3 _4 _9 _0 _4 _2 _8 _7 _5 _5 _4 _6 _8 _7 _3 _1 _1 _5 _9 _5 _6 _2 _8 _6 _3 _8 _8 _2 _3 _5 }\n    if (ip.y == 24) { _3 _7 _8 _7 _5 _9 _3 _7 _5 _1 _9 _5 _7 _7 _8 _1 _8 _5 _7 _7 _8 _0 _5 _3 _2 _1 _7 _1 _2 _2 _6 _8 _0 _6 _6 _1 _3 _0 _0 }\n    if (ip.y == 25) { _1 _9 _2 _7 _8 _7 _6 _6 _1 _1 _1 _9 _5 _9 _0 _9 _2 _1 _6 _4 _2 _0 _1 _9 _8 _9 _3 _8 _0 _9 _5 _2 _5 _7 _2 _0 _1 _0 _6 }\n    if (ip.y == 26) { _5 _4 _8 _5 _8 _6 _3 _2 _7 _8 _8 _6 _5 _9 _3 _6 _1 _5 _3 _3 _8 _1 _8 _2 _7 _9 _6 _8 _2 _3 _0 _3 _0 _1 _9 _5 _2 _0 _3 }\n    if (ip.y == 27) { _5 _3 _0 _1 _8 _5 _2 _9 _6 _8 _9 _9 _5 _7 _7 _3 _6 _2 _2 _5 _9 _9 _4 _1 _3 _8 _9 _1 _2 _4 _9 _7 _2 _1 _7 _7 _5 _2 _8 }\n    if (ip.y == 28) { _3 _4 _7 _9 _1 _3 _1 _5 _1 _5 _5 _7 _4 _8 _5 _7 _2 _4 _2 _4 _5 _4 _1 _5 _0 _6 _9 _5 _9 _5 _0 _8 _2 _9 _5 _3 _3 _1 _1 }\n    if (ip.y == 29) { _6 _8 _6 _1 _7 _2 _7 _8 _5 _5 _8 _8 _9 _0 _7 _5 _0 _9 _8 _3 _8 _1 _7 _5 _4 _6 _3 _7 _4 _6 _4 _9 _3 _9 _3 _1 _9 _2 _5 }\n    if (ip.y == 30) { _5 _0 _6 _0 _4 _0 _0 _9 _2 _7 _7 _0 _1 _6 _7 _1 _1 _3 _9 _0 _0 _9 _8 _4 _8 _8 _2 _4 _0 _1 _2 _8 _5 _8 _3 _6 _1 _6 _0 }\n    if (ip.y == 31) { _3 _5 _6 _3 _7 _0 _7 _6 _6 _0 _1 _0 _4 _7 _1 _0 _1 _8 _1 _9 _4 _2 _9 _5 _5 _5 _9 _6 _1 _9 _8 _9 _4 _6 _7 _6 _7 _8 _3 }\n    if (ip.y == 32) { _7 _4 _4 _9 _4 _4 _8 _2 _5 _5 _3 _7 _9 _7 _7 _4 _7 _2 _6 _8 _4 _7 _1 _0 _4 _0 _4 _7 _5 _3 _4 _6 _4 _6 _2 _0 _8 _0 _4 }\n    if (ip.y == 33) { _6 _6 _8 _4 _2 _5 _9 _0 _6 _9 _4 _9 _1 _2 _9 _3 _3 _1 _3 _6 _7 _7 _0 _2 _8 _9 _8 _9 _1 _5 _2 _1 _0 _4 _7 _5 _2 _1 _6 }\n    if (ip.y == 34) { _2 _0 _5 _6 _9 _6 _6 _0 _2 _4 _0 _5 _8 _0 _3 _8 _1 _5 _0 _1 _9 _3 _5 _1 _1 _2 _5 _3 _3 _8 _2 _4 _3 _0 _0 _3 _5 _5 _8 }\n    if (ip.y == 35) { _7 _6 _4 _0 _2 _4 _7 _4 _9 _6 _4 _7 _3 _2 _6 _3 _9 _1 _4 _1 _9 _9 _2 _7 _2 _6 _0 _4 _2 _6 _9 _9 _2 _2 _7 _9 _6 _7 _8 }\n#endif\n  }\n  return _ic;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[556, 556, 582, 582, 891], [893, 893, 926, 926, 1541], [1543, 1543, 1578, 1578, 2032], [2034, 2034, 2069, 2069, 2613], [2615, 2615, 2671, 2671, 3979], [9723, 9723, 9745, 9745, 9783], [9785, 9785, 9815, 9815, 9928], [9962, 9962, 9986, 9986, 10098], [10100, 10100, 10125, 10125, 10311], [10313, 10313, 10334, 10334, 10489]], "test": "untested"}
{"id": "3dXyR4", "name": "#693 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["2d", "experiment", "daily", "everyday"], "likes": 3, "viewed": 192, "published": 3, "date": "1584204044", "time_retrieved": "2024-07-30T21:18:39.994726", "image_code": "/* Code by Sixclones\n\nMy boilerplate: https://www.shadertoy.com/view/wdsyzH */\n\n// CONSTANTS & UTILS\n#define QP 0.785398163397448\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// UTILS FN\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\nto be used with cos/sin\n`map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\nvec2 map01(vec2 n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n/* rotate uv\nuv - uv to rotate\na - angle of the rotation\n\ninspired by Patricio Gonzalez Vivo (but in fact you find this everywhere)\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/rotate.glsl\n*/\nvec2 rotate2d(vec2 uv, float a) {\n  uv = mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n  return uv;\n}\n\n/* function to draw filled sdf\nx - sdf to draw\ns - size\n\nfrom Pixel Spirit Deck by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/fill.glsl */\nfloat fill(float x, float s) {\n  return 1.0 - step(s, x);\n}\n\n/* function to draw stroke\nx - sdf to draw\ns - size of the draw\nw - width of the stroke\np - precision of the stroke\n\ninspired by Pixel Spirit Deck `stroke` function by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/stroke.glsl */\nfloat stroke(float x, float s, float w, float p) {\n  return clamp(\n    S(x - 0.5 * w - p, x - 0.5 * w + p, s) * S(x + 0.5 * w + p, x + 0.5 * w - p, s),\n    0.0, 1.0\n  );\n}\n\n/* compute a rect signed distance field\nuv - uv of the screen\ns - size of the rect\n\nfrom Pixel Spirit Deck by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/rectSDF.glsl */\nfloat rectSDF(vec2 uv, vec2 s) {\n  return max(abs(uv.x / s.s), abs(uv.y / s.y));\n}\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n  \tvec2 uv0 = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  \tvec3 color = vec3(0.95);\n\n  \t// VIGNETTE\n  \tcolor -= S(0.55, 1.5, length(uv0));\n\n  \t// MASK\n    // compute the sdf of a rect\n  \tfloat rect = rectSDF(rotate2d(uv0, QP), vec2(0.5));\n    \n    // get a filled rect\n  \tfloat rectf = fill(rect, 0.65);\n    // color -= rectf; // uncomment to see the result of a fill\n\n    \n  \t// WAVES + MOIRÉ = MAGIC\n    /* split between left & right, a more simple writing is `mix(-ht, ht, step(0.0, uv0.y))`\n\tthe step is done on 0.0 because uv0 goes from -1.0 to 1.0\n\tfinally the split is rotated\n    */\n  \tfloat timer = mix(\n    \t-ht, ht,\n    \tstep(0.0, rotate2d(uv0, -ht + cos(ht + QP * uv.y)).x)\n  \t);\n    \n    /* amplitude of the waves */\n  \tfloat amp = map01(cos(t + TP * uv.x), 0.1, 0.75);\n    \n    /* waves are computed with a sinus combined with lot of offsets and cos/sin */\n  \tfloat waves = amp * sin(t + 5.0 * TP * uv.x + 2.5 * P * uv.y\n    \t+ P * cos(-t + 5.0 * TP * uv.x * pow(uv.y, uv.x))\n\t\t+ pow(cos(timer + P * uv.y), uv.x)\n  \t);\n    \n    // subtle offset\n  \tfloat offset = t + uv.x;\n\n  \t// STRIPES\n    /* number of stripes */\n  \tfloat ns = 30.0;\n    \n    /* passing this to a cos/sin will give you stripes\n\tthis could have been done with `fract(ns * uv.y)` */\n  \tfloat _stripes = ns * TP * uv.y;\n    \n    /* compute static + animated stripes and */\n  \tvec2 stripes = map01(vec2(\n    \tcos(_stripes),\n    \tcos(_stripes + waves + offset)\n  \t), 0.0, 1.0);\n\n  \t// DRAWING PARAMS\n    /* normally size of the draw but with stripes if more like the position\n\twith 0.5 I assure that the stripe is in the middle of the render\n\t(not clear comment, I admit, sorry)\n\t*/\n    float s = 0.5;\n  \tfloat w = 0.2; // width of strokes\n  \tfloat p = 50.0 / iResolution.x; // precision of strokes to avoid aliasing\n\n    // RENDER\n    // we create a mask by multiplying the addition of the stripes (static + animated) to the rect filled\n    color -= rectf * (stroke(stripes.x, s, w, p) + stroke(stripes.y, s, w, p));\n\n  \tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 410, 484, 484, 556], [558, 688, 737, 737, 793], [795, 795, 842, 842, 898], [900, 1119, 1152, 1152, 1218], [1220, 1411, 1441, 1441, 1470], [1472, 1750, 1800, 1800, 1921], [1923, 2144, 2176, 2176, 2226], [2228, 2236, 2291, 2291, 4382]], "test": "untested"}
{"id": "wslyzH", "name": "Logarithmic Conical Spiral", "author": "tdhooper", "description": "I used a crude version of this of this for [url=https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/source.gif]Fractal Polycephaly[/url]\n\nOld version can be found here [url]https://www.shadertoy.com/view/tscfRS[/url]", "tags": ["fractal", "spiral", "camera", "loop", "path", "logarithmic"], "likes": 12, "viewed": 737, "published": 3, "date": "1584203185", "time_retrieved": "2024-07-30T21:18:40.900305", "image_code": "/*\n\n\tLogarithmic Conical Spiral Center and Axis\n\t------------------------------------------\n\n\tWhen iteratively applying a transformtion matrix, the\n\tpositions visited form a logarithmic spiral on a cone.\n\t\n\tThis calculates the center (tip) and axis of that cone,\n\tas well as the angle between each iteration.\n\n\tThe general approach is to ignore the scaling component\n\tof the matrix, such that multiple iterations form a\n\tcylinder instead of a cone. Once we have the axis and\n\tposition of the cylinder, we can triangulate the tip of\n\tthe cone.\n\n\tWith these parameters, we can create a method that\n\trotates and scales space over time to smoothly transform\n\tthe second instance into the first, forming a\n\tseamless loop.\n\n\tSee also the 2d version:\n\thttps://www.shadertoy.com/view/tscBDH\n\n*/\n\n// Matrix functions\n// --------------------------------------------------------\n\nmat4 mTranslate(vec3 t) {\n\treturn mat4(\n        1, 0, 0, t.x,\n        0, 1, 0, t.y,\n        0, 0, 1, t.z,\n        0, 0, 0, 1\n   \t);\n}\n\nmat4 mRotate(vec3 forward, vec3 up) {\n    vec3 ww = normalize(forward * vec3(1,1,-1));\n    vec3 uu = normalize(cross(up * vec3(-1,1,1),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    return mat4(\n        uu, 0,\n        vv, 0,\n        ww, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 mScale(float s) {\n\treturn mat4(\n    \ts, 0, 0, 0,\n        0, s, 0, 0,\n        0, 0, s, 0,\n        0, 0, 0, 1\n    );\n}\n\nfloat getScale(mat4 m) {\n\treturn length(m[0].xyz);\n}\n\nvec3 mul(vec3 p, mat4 m) {\n\treturn (vec4(p, 1) * m).xyz;\n}\n\n\n// Logarithmic conical spiral center, axis, and angle\n// --------------------------------------------------------\n\n#define PI 3.1415926\n\n// Logarithmic spiral center\n// https://www.shadertoy.com/view/tscBDH\nvec2 spiralCenter(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\nvoid conicalSpiral(mat4 txm, float txmScale, out vec3 axis, out float angle, out vec3 center) {\n\n    // Remove scaling from transformation matrix\n    mat4 txmns = mScale(1. / txmScale) * txm;\n    \n    // Get first four positions, these form a cylinder\n    vec3 v0 = vec3(0);\n    vec3 v1 = mul(v0, txmns);\n    vec3 v2 = mul(v1, txmns);\n    vec3 v3 = mul(v2, txmns);\n    \n\n\t// Cylinder axis\n    // -------------\n    \n    // Calculate normals for the two middle points\n    vec3 n0 = v1 - mix(v0, v2, .5);\n    vec3 n1 = v2 - mix(v1, v3, .5);\n\n    // Cross for cylinder axis\n    axis = normalize(cross(n0, n1));\n\n    // Rotation matrix for cylinder direction\n    mat3 mAxis = mat3(n0, cross(axis, n0), axis);\n\n\n  \t// Angle between iterations\n    // ------------------------\n\n    // Project points onto axis plane\n    vec2 p1 = (v1 * mAxis).xy;\n    vec2 p2 = (v2 * mAxis).xy;\n\n    // Angle between the points\n    angle = PI - acos(dot(normalize(-p1), normalize(p2 - p1)));    \n    \n\n\t// Cone center (tip)\n\t// -----------------\n\n    // Center of the 2d logarithmic spiral\n    vec2 center2d = spiralCenter(p1, angle, txmScale);\n\n    // Transform back into 3d\n    center = vec3(center2d, 0) * inverse(mAxis);\n    \n    // Extrapolate the line between v0 and v1 to find the tip\n    float v1Height = dot(v1, axis);\n    float v1Radius = distance(center2d, p1);\n    center += axis * v1Height * (length(center2d) / (length(center2d) - v1Radius));\n}\n\n\n// Camera movement\n// --------------------------------------------------------\n\nmat4 txm;\nmat4 txmi;\nfloat txmScale;\n\nvec3 cameraAxis;\nfloat cameraAngle;\nvec3 cameraApex;\n\n// Rotate around axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n// With the calculated spiral properties, rotate and scale space\n// (aka move the camera), by a given amount until we have transformed\n// the second iteration into the first iteration\nfloat tweenCamera(inout vec3 p, float t) {\n    float scale = pow(txmScale, t);\n    p -= cameraApex;\n    p = erot(p, cameraAxis, cameraAngle * t);\n    p *= scale;    \n    p += cameraApex;\n    return scale;\n}\n\n\n// Modeling\n// --------------------------------------------------------\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fLine(vec3 p, vec3 n) {\n    float t = dot(p, n) / dot(n, n);\n    return length((n * t) - p) ;\n}\n\nstruct Model {\n\tfloat d;\n    vec3 p;\n    int id;\n};\n\nModel opU(Model a, Model b) {\n    if (a.d < b.d) {\n    \treturn a;\n    }\n    return b;\n}\n\nModel mGizmo(vec3 p) {\n\tfloat d = fBox(p, vec3(.5, .5, .5));\n   \treturn Model(d, p, 1);\n}\n\nModel mAxisAndCenter(vec3 p) {\n    float axis = fLine(p - cameraApex, cameraAxis) - .08;\n    float center = length(p - cameraApex) - .3;\n    float d = min(axis, center);\n   \treturn Model(d, p, 2);\n}\n\nModel scene(vec3 p) {\n    \n    Model model = mAxisAndCenter(p);\n\n    float scale = 1.;\n    vec3 pp = p;\n    \n    for (int i = 0; i < 15; i++) {\n        // Draw gizmo\n\t\tModel gizmo = mGizmo(p);\n        gizmo.d *= scale; // Fix distance for scale factor\n        model = opU(model, gizmo);\n        \n        // Apply matrix and scale\n        p = mul(p, txmi);\n        scale *= txmScale;\n    }\n\n\tscale = 1.;\n    p = mul(pp, txm);\n    \n    for (int i = 0; i < 12; i++) {\n        // Draw gizmo\n\t\tModel gizmo = mGizmo(p);\n        gizmo.d *= scale; // Fix distance for scale factor\n        model = opU(model, gizmo);\n        \n        // Apply matrix and scale\n        p = mul(p, txm);\n        scale /= txmScale;\n    }\n    \n    return model;\n}\n\nModel map(vec3 p) {\n    float scale = tweenCamera(p, mod(iTime * 2., 1.));\n    Model model = scene(p);\n    model.d /= scale;\n    return model;\n}\n\n\n\n// Rendering\n// --------------------------------------------------------\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \n    float t = iTime / 3. + .5;\n    \n    // Build the TRS transformation matrix for each iteration\n    mat4 mT = mTranslate(vec3(0, cos(t/2.), -sin(t/2.)) * (cos(t/2.) * .25 + 1.5));\n    mat4 mR = mRotate(vec3(cos(t) * -.5, cos(t/2.) * -.5, -1), vec3(sin(t) * -.5, 1, 0));\n    mat4 mS = mScale(.8 + sin(t) * .05);\n\ttxm = mS * mR * mT;\n    txmScale = getScale(txm);\n\ttxmi = inverse(txm);    \n\n    // Find conical spiral parameters for camera movement\n    conicalSpiral(txm, txmScale, cameraAxis, cameraAngle, cameraApex);\n    \n    \n    // Ray marching\n\n    float focalLength = 2.4;\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 rayDirection = normalize(vec3(p, -focalLength));\n    vec3 rayOrigin = vec3(0,0,15);\n    vec3 rayPosition = rayOrigin;\n    float rayLength = 0.;\n\n    Model model;\n    float dist = 0.;\n    vec3 bgcol = vec3(.014,.01,.02);\n    vec3 color = bgcol;\n    bool isBackground = false;\n\n    for (float i = 0.; i < 100.; i++) {\n        rayLength += dist;\n        rayPosition = rayOrigin + rayDirection * rayLength;\n        model = map(rayPosition);\n\t\tdist = model.d;\n        \n        if (dist < .001) {\n            break;\n        }\n\n        if (rayLength > 50.) {\n            isBackground = true;\n            break;\n        }\n    }\n\n    if ( ! isBackground) {\n        if (model.id == 2) {\n        \tcolor = vec3(1);\n        } else {\n    \t\tvec3 face = step(vec3(vmax(abs(model.p))), abs(model.p)) * sign(model.p);\n            float faceIndex = max(vmax(face * vec3(0,1,2)), vmax(face * -vec3(3,4,5)));\n    \t\tcolor = spectrum(faceIndex / 6.);\n    \t}\n    }\n    \n    float fog = 1. - exp((rayLength - 13.) * -.25);\n    color = mix(color, bgcol, clamp(fog, 0., 1.));\n\n    color = pow(color, vec3(1. / 2.2)); // Gamma\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[869, 869, 894, 894, 1002], [1004, 1004, 1041, 1041, 1273], [1275, 1275, 1297, 1297, 1396], [1398, 1398, 1422, 1422, 1450], [1452, 1452, 1478, 1478, 1510], [1650, 1720, 1786, 1786, 1982], [1984, 1984, 2079, 2129, 3417], [3592, 3672, 3710, 3710, 3775], [3777, 3961, 4003, 4003, 4167], [4243, 4243, 4263, 4263, 4301], [4303, 4303, 4331, 4331, 4418], [4420, 4420, 4449, 4449, 4521], [4576, 4576, 4605, 4605, 4663], [4665, 4665, 4687, 4687, 4754], [4756, 4756, 4786, 4786, 4954], [4956, 4956, 4977, 4977, 5689], [5691, 5691, 5710, 5710, 5835], [5913, 5975, 6043, 6043, 6086], [6087, 6087, 6111, 6111, 6209], [6211, 6211, 6266, 6266, 8059]], "test": "untested"}
{"id": "tslyzH", "name": "Octuple voronoi diagram", "author": "michael0884", "description": "Going mad and storing 8 particle id's in 1 texel based on the distance to the texel. ", "tags": ["particles"], "likes": 4, "viewed": 420, "published": 3, "date": "1584203179", "time_retrieved": "2024-07-30T21:18:42.004353", "image_code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-14 14:30:34\n\n\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    get(p);\n   \tfloat y = 0., x = 0.;\n    for(int i = 0; i < CN; i++)\n    {\n        float d =particleDistance(ids[i],pos); \n        y += sin(d);\n        x += gauss(d,20.);\n    }\n    col = .5+.5*sin(0.1*vec4(1,2,3,4)*float(ids[(iFrame/50)%CN])); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nfloat F(float d)\n{\n    return 0.;\n}\n\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    return normalize(p1-p0)*F(distance(p1,p0));\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n        \n        vec2 F = vec2(0.);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F = 5.*normalize(iMouse.xy - U.xy)/(d+2.);\n        }\n        \n        U.zw += dt*F;\n        U.xy += U.zw*dt;\n        \n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(8,8)\n#define dt 0.5\n#define prad 5.\n\n//save N last iterations\n#define LN 1.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\n//closest particle ids\n#define CN 8\nint ids[CN];\n//particle distances\nfloat ds[CN];\n\nivec2 one2two(int a)\n{\n    return ivec2(a%tot_n, a/tot_n);\n}\n\nint two2one(ivec2 a)\n{\n    return a.x + tot_n*a.y;\n}\n\nvoid toarr(inout int b[CN], ivec2 a, int i)\n{\n    b[i] = a.x;\n    b[i+1] = a.y;\n}\n\nvoid init()\n{\n    for(int i = 0; i<CN; i++)\n    {\n        ids[i] = -1;\n        ds[i] = 1e10;\n    }\n}\n\nvoid getA(inout int b[CN], ivec2 p)\n{ \n    ivec4 a = floatBitsToInt(texel(fake, p));\n    toarr(b, one2two(a.x), 0);\n    toarr(b, one2two(a.y), 2);\n    toarr(b, one2two(a.z), 4);\n    toarr(b, one2two(a.w), 6);\n}\n\nvoid get(ivec2 p)\n{\n    getA(ids, p);\n}\n\nvec4 save()\n{\n    ivec4 v = ivec4(two2one(ivec2(ids[0],ids[1])),\n                    two2one(ivec2(ids[2],ids[3])),\n                    two2one(ivec2(ids[4],ids[5])),\n                    two2one(ivec2(ids[6],ids[7])));\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}", "buffer_b_code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid insert(int id, float d, int i)\n{\n    //shift all by 1\n    for(int j = CN-1; j > i; j--)\n    {\n        ids[j] = ids[j-1];\n        ds[j] = ds[j-1];\n    }\n    \n    //insert\n    ids[i] = id; \n    ds[i] = d;\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+0.5;\n    float dtemp = particleDistance(utemp, pos);  \n    //sorting\n    for(int i = 0; i < CN; i++)\n    {\n        if(ids[i] == utemp) return;\n        \n        if(ids[i] < 0 || ds[i] >= dtemp)\n        {\n            insert(utemp, dtemp, i);\n            return;\n        }\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    int t[CN];\n    getA(t, max(p + dx, ivec2(0,0)));\n    \n\tfor(int i = 0; i < CN; i++)\n    {\n   \t\tif(t[i]>=0)\n        \tsort(t[i], p);\n    }\n}\n\nvoid randupd(ivec2 p )\n{\n    for(int i = 0; i < 4; i++)\n    {\n        //go through the entire array sudorandomly\n        sort(((iFrame + p.x + p.y*int(iResolution.x))^(1<<i))%tot_n, p);\n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 2);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n  \n    init();\n    \n    update(p);\n    \n    U = save();\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 141, 141, 176], [178, 178, 218, 218, 264], [266, 266, 297, 297, 331], [333, 333, 385, 385, 504], [506, 506, 551, 551, 825]], "test": "untested"}
{"id": "wdlczH", "name": "#694 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["2d", "experiment", "daily", "everyday"], "likes": 7, "viewed": 331, "published": 3, "date": "1584199845", "time_retrieved": "2024-07-30T21:18:43.040583", "image_code": "/* Code by Sixclones\n\nMy boilerplate: https://www.shadertoy.com/view/wdsyzH */\n\n// CONSTANTS & UTILS\n#define QP 0.785398163397448\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// UTILS FN\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\nto be used with cos/sin\n`map01(sin(x), 0.0, 1.0)`\n*/\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n/* function to draw stroke\nx - sdf to draw\ns - size of the draw\nw - width of the stroke\np - precision of the stroke\n\ninspired by Pixel Spirit Deck `stroke` function\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/stroke.glsl\n*/\nfloat stroke(float x, float s, float w, float p) {\n  return clamp(\n    S(s + p, s - p, x - 0.5 * w) * S(s - p, s + p, x + 0.5 * w),\n    0.0, 1.0);\n}\n\n/* function that render the waves\nuv - uv of the screen\nn - number of waves\nid - identification of the cell\npre - precision of the waves\noffset - offset used to change the shape/position of waves\n*/\nfloat waves(vec2 uv, float n, vec2 id, float pre, float offset) {\n    // create a repetition of `n` lines on the y axis\n    float x = fract(n * uv.y);\n    \n    /* define the width of each line by offsetting with `id.y`\n\t(by width I mean the wideness of the stroke)\n\tadding a subtle wavy effect inside the wave with `QP * uv.x`\n\tyou exagerate it by multiplying by `10.0 * QP * uv.x`\n\t*/\n  \tfloat w = map01(\n\t    sin(-tt + id.y + QP * uv.x + cos(ht)),\n    \t0.1, 0.45);\n    \n    // make the wave moves and offset each line with `id.y` again\n  \tfloat s = map01(\n\t    cos(ht + HP * uv.x + id.y + offset),\n    \t1.0 - w, w);\n    \n    // combine everything\n  \treturn stroke(x, s, w, pre);\n}\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n\t// number of lines that oscillate between 6 and 10 with a nice curve\n    float n = map01(\n      sin(ht + sin(t - P * uv.y) + cos(-t + HP * uv.x)),\n      6.0, 10.0);\n  \tvec2 id = floor(n * uv0);\n\n    // start with a white background and substract the waves\n  \tvec3 color = vec3(1.0);\n\n    // animate the precision\n  \tfloat pre = map01(cos(t + P * uv.y), 0.025, 0.125);\n    // define a different offset for each color channel\n  \tvec3 offset = vec3(\n    \t0.5 * cos(t + 1.2 * P * uv.x),\n    \t0.25 * cos(t + P * uv.x),\n    \t0.1 * cos(t + 0.8 * P * uv.x)\n  \t);\n    // make the magic happens\n  \tcolor.r -= waves(uv0, n, id, pre + 0.025, offset.x);\n  \tcolor.g -= waves(uv0, n, id, pre + 0.0, offset.y);\n  \tcolor.b -= waves(uv0, n, id, pre + 0.05, offset.z);\n\n  \tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 410, 484, 484, 556], [558, 688, 737, 737, 793], [795, 1047, 1097, 1097, 1195], [1197, 1396, 1461, 1515, 2078], [2080, 2088, 2143, 2143, 3046]], "test": "untested"}
{"id": "tslyRH", "name": "simple-heart", "author": "feefi", "description": "simple glowing heart", "tags": ["heart"], "likes": 4, "viewed": 469, "published": 3, "date": "1584192786", "time_retrieved": "2024-07-30T21:18:43.859394", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv.y -= pow(abs(uv.x),1.3); uv.y *= 1.1;\n    float t = iTime*3.;\n    t = sin(t+sin(t+sin(t+sin(t))))*0.5 + 0.5;\n    t = clamp(t,0.5,1.0);\n    float mainheart = 0.5*t/length(uv);\n    vec3 col = mainheart * vec3(0.2,0.1,0.05);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 380]], "test": "untested"}
{"id": "wslcz8", "name": "Day 86", "author": "jeyko", "description": "poto", "tags": ["mdmtjvm"], "likes": 26, "viewed": 716, "published": 3, "date": "1584190986", "time_retrieved": "2024-07-30T21:18:45.026273", "image_code": "// Fork of \"Day 85\" by jeyko. https://shadertoy.com/view/WdfczH\n// 2020-03-14 09:43:07\n\n// Fork of \"Day 84\" by jeyko. https://shadertoy.com/view/Wssczn\n// 2020-03-13 10:52:05\n\n// radial blur and chromatic abberation in this buffer\n// thx iq for pallette and hg-sdf for polarMod\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),4.)*0.7;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*4.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*3.; \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.6);\n    //1fragColor *= 18.;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.1));\n    fragColor *= 1. - dot(uvn,uvn)*0.6;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime + 3.6 + 5.)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvec3 att = vec3(1);\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0,vec2(floor(t)/256.)),texture(iChannel0,vec2(floor(t) + 1.)/256.), smoothstep(0.,1.,fract(t)));\n}\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat iii;\nfloat sdRhombus(vec3 p, vec3 s){\n\t\n    \n    p = abs(p) - s;\n    \n    float d = max(p.z, max(p.x, p.y));\n    \n    \n    d = max(d, dot(p.yx + s.yx*0.5, normalize(vec2(1.))));\n    d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1.))));\n    //d = max(d - s.x*0., -dot(p.z,p.x));\n    //d \n    \n    \n    return d;\n}\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 s )\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\n    #define modD vec3(1.5,2.5,0.9)\nfloat sdThangiPong(vec3 p){\n    float mmm = sin(iTime);\n\n    mmm = sign(mmm)*pow(abs(mmm), 5.);\n    \n    p.y -= iTime + iii + sin(iTime + iii);\n    p.y = pmod(p.y, modD.y);\n    \n    \n    p.xz *= rot(mmm*PI); \n    p.xz = abs(p.xz);\n    float d = sdRhombus(p , vec3(0.12));\n    \n    glow += 0.5/(0.08+ d*d*4.)*vec3(0.1,0.43,0.3)*att;\n    \n    p.y -= 0.4;\n    p.xz *= rot(0.25*PI);\n    \n    float n = fOpUnionStairs(d, sdRhombus(p - vec3(0,0.0 + 0.0,0), vec3(0.1)), 0.2,4.);\n    d = min(d, n);\n    //fOpUnionStairs\n    return d;\n}\nfloat gg;\nfloat speed = 0.5;\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    vec3 f = p;\n    \n    vec3 n = p;\n    vec3 q = p;\n    \n    iii = pModPolar(q.xz, 3.);\n    \n    \n    vec3 u = q;\n    q.x-= 2.2;\n    \n    float dd = -q.x ;\n\n    \n    vec3 i = q;\n    \n    \n    i.y = pmod(i.y, modD.y);\n    vec3 k = i;\n    i = abs(i);\n    \n    i = abs(i) - vec3(0.1,1.,0.4);\n    float dm = max(i.z,max(i.y,i.x)) ;\n    \n    \n    \n    //glow += 0.1/(0.04 + dd*dd*150.)*vec3(1.,0.2,0.1);    \n    \n    \n    q = abs(q);\n    \n    \n    q.z -= 1.8;\n    \n    //float ddC = length(q.xz) - 0.1;\n    float ddC = max(abs(q.x),abs(q.z)) - 0.2;\n    \n    \n    dd = fOpUnionStairs(ddC, dd, 0.7,5.);\n    \n    \n    \n    q = pmod(q, modD);\n    \n    \n    u = abs(q);\n    float dW = min( min(\n        \t\t\tmax(u.z, u.y),\n        \t\t\tmax(u.x, u.y)\n                ),        \t\t\tmax(u.x, u.z)) - 0.04 ;\n    \n    \n    dd = fOpUnionStairs(dd, dW, 0.4,4.);\n    \n    \n    \n    float dF = p.y + 0.4;\n    \n\n    \n    d = dmin(d, vec2(dd, 1.));\n    \n    d = dmin(d, vec2(dm, 11.));\n    \n    d = dmin(d, vec2(ddC, 1.));\n    \n    if(d.x == dW){\n    \td.y = 6.;\n    }\n    \n    n.y -= speed*iTime;\n    \n    \n\n    \n    float ddB = length(n) - 0.2;\n    \n    \n    float mmm = pow(abs(sin(f.y*0.5 + iTime*0.5 + cos(f.z + iTime*0.25) +  + cos(f.y + iTime*0.125) )), 5.);\n    float mmb = pow(abs(sin(f.y + iTime + cos(f.z*0.4 + iTime*0.45) +  + cos(f.y + iTime*0.5) )), 2.);\n    \n    float a= 0. + mmm*0.6;\n    \n    //ddB = fOpUnionStairs(ddB,ddD,2.,0.1 );\n    \n    \n    n.xz *= rot(mmm*4.);\n    n.yz *= rot(mmb*1.);\n    \n\tvec3 j = n;\n    \n    j = pmod(j, 0.1);\n    \n    \n    j = abs(j) - 0.06;\n    float ddD = max(j.x, max(j.y, j.z));    \n    \n    n = abs(n);\n    n.yz *= rot(0.9);\n    n.xz -= 0.1 + mmb*0.1;\n    \n \tfloat dRr = sdRhombus(n , -vec3(0.04));\n \tfloat dRb = sdRhombus(n , -vec3(0,0.1,0));\n    \n    \n    //ddB = mix(ddB,dRr,mmb*0.5 );\n    ddB = fOpUnionStairs(ddB,dRr,0.2 + mmb*0.1, 5. + sin(iTime) );\n    ddB = fOpUnionStairs(ddB,dRb,0.25 + sin(iTime)*0.2, 5. );\n    \n    ddB = mix(ddB,ddD,a );\n    d = dmin(d, vec2(ddB, 10.));\n    \n    \n    k.x += 1.2;\n    \n    //k.y = abs(k.y);    \n    \n    \n    \n \tfloat dT = sdThangiPong(k);\n    \n    \n    float dPp = length(k.xz) - 0.1; // pp huehue\n    //glow += 0.1/(0.04 + dPp*dPp*10.)*vec3(1.,0.2,0.1)*att;    \n\n    \n    k.x -= 0.5;\n    k = abs(k);\n    k.z -= 0.9;\n       \n    //float dPpb = length(k.xz) - 0.1; // pp huehue\n    \n    k = abs(k);\n    float dPpb = max(k.x,k.z) - 0.06; // pp huehue\n    //glow += 0.1/(0.01 + dPpb*dPpb*14.)*vec3(0.6,0.1,0.1)*att;    \n    glow += 0.2/(0.06 + dPpb*dPpb*dPpb*44.)*vec3(0.8,0.3,0.1)*att;    \n\n    \n    \n    d = dmin(d, vec2(dT, 4.));\n    d = dmin(d, vec2(abs(dPp) + 0.01, 4.));\n    d = dmin(d, vec2(abs(dPpb) + 0.01, 4.));\n    \n    \n    \n\n\n    \n    vec3 c = vec3(1);\n\td.x *= 0.6;\n    return d;\n}\nfloat dith;\n\nfloat side;\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = map(p);\n\n    \n    if(d.x < 0.3)\n        ro += rd*0.3;\n    p = ro; t = 0.; hit = false;\n    for(int i = 0; i < 140; i++){\n    \td = map(p);\n        d.x *= dith * side;\n        \n    \t//glow += exp(-d.x*20.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir ));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.0004,0);  \n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\n#define mx (2.*iMouse.x/iResolution.x)\n#define my (0.6*iMouse.y/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //\n\t//uv *= 1. - dot(uv,uv)*0.2;\n    uv.xy *= rot(sin((iTime*0.7 - 3.6))*0.3);\n    uv *= 1. + dot(uv,uv)*1.5;\n    \n    \n    vec3 col = vec3(0);\n\n    dith = mix(0.76,1., texture(iChannel0, 20.*uv*256.).x);\n    vec3 ro = vec3(0);\n    \n    ro.y += iTime*speed;\n    ro.y -= 0.57 - my;\n    \n    float n = pow(valueNoise(iTime*1.).x, 2.);\n    \n    \n    ro.y += sin(n);\n    float nb = valueNoise(iTime*1./2.).x;\n    float zoom = 1.2 + n*1.;\n    n *= 1.;\n    ro.xz += vec2(sin( nb*6.14*1.5 + mx),cos( nb*6.14*1.5 + mx))*zoom;\n    \n    ro.y += 0.3;\n    \n    vec3 lookAt = vec3(0,ro.y + sin(iTime)*0.05,0.);\n    lookAt.y += -0.5 + valueNoise(iTime*1./2.).x;\n    vec3 rd = getRd(ro, lookAt, uv);\n    //rd.yz *= rot(iTime);\n    \n    vec3 p; float t = 0.; bool hit;\n    float tA; side = 1.;\n    \n    for(int i = 0; i < 2   + min(0, iFrame) ; i ++){\n    \tvec2 d = march(ro, rd, p, t, hit);\n    \tvec3 n = getNormal(p)*side;\n        \n        vec3 ld = normalize(vec3(1));\n        vec3 j = normalize(ld - n);\n        \n        float diff = max(dot(n, ld), 0.);\n        float ss = pow(max(dot(n, j), 0.), 20.);\n        float fres = pow(1. - max(dot(n, -rd), 0.), 5.);\n        \n        //col += fres*0.04*vec3(0,0.5,1);\n        //col += diff*fres*0.03*vec3(0.8,0.2,0.7);\n        \n        col += ss*0.05*vec3(1,0.1,1)*att;\n        tA = max(tA,t);\n        if (d.y == 10.){\n            /*\n        \tside *= -1.;\n            att *= vec3(0.2,0.6,1.)*0.9;\n            \n            rd = refract(rd, n,0.5);\n            ro = p - n*0.4;*/\n\t\t\t\n        \tcol += fres*0.1*vec3(0,0.5,1)*diff*att;\n            ro = p + n*0.5;\n            att *= vec3(0.2,0.7,1.)*(0.9 );\n            \n            //rd = -refract(rd, n,0.4);\n            rd = reflect(rd, n);\n        } else if (d.y == 11.){\n            /*\n        \tside *= -1.;\n            att *= vec3(0.2,0.6,1.)*0.9;\n            \n            rd = refract(rd, n,0.5);\n            ro = p - n*0.1;*/\n            \n        \tcol += fres*0.1*vec3(0,0.5,1)*diff*att;\n            ro = p + n*0.5;\n            att *= vec3(0.2,0.6,1.)*0.9;   \n            rd = reflect(rd, n + sin(p*40.)*0.01);\n        }else if (d.y == 20.){\n            /*\n        \tside *= -1.;\n            att *= vec3(0.2,0.6,1.)*0.9;\n            \n            rd = refract(rd, n,0.5);\n            ro = p - n*0.1;*/\n            \n        \tcol += fres*0.5*vec3(0.5,0.5,0.5)*glow*0.05*att;\n            //ro = p + n*0.5;\n            //att *= vec3(0.2,0.6,1.)*0.9;\n            //rd = reflect(rd, n);\n            break;\n        } else {\n            //col += fres*0.5*vec3(0.5,0.7,0.8)*0.3*att;\n            #define aa(j) clamp(map(p + n/j).x*j, 0.,1.)\n            //float aaa = aa(0.5)*aa(0.1)*aa(0.7)*20.;\n            float aaa = aa(0.9)*aa(0.6)*10.;\n            //aaa = 0.3;\n            col += fres*0.5*vec3(0.5,0.7,0.8)*1.*att*aaa;\n            //col += spec*0.5*vec3(0.5,0.7,0.4)*0.3*att;\n        \tbreak;\n        }\n    }\n        \n    col += glow*0.006;\n    \n    \n    //col = mix(col, vec3(0.4,0.4,0.7)*0.3*att, pow(smoothstep(0.,1.,tA*0.143), 1.6));\n\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 280, 337, 337, 1396]], "test": "untested"}
{"id": "3dlcR8", "name": "Bela's Path Tracer", "author": "bela333", "description": "A simple path tracer", "tags": ["raymarching", "ray", "marching", "raymarcher", "raymarcher", "tracing", "montecarlo", "tracer", "marcher", "path", "raymarcing", "patchtracer"], "likes": 2, "viewed": 310, "published": 3, "date": "1584189342", "time_retrieved": "2024-07-30T21:18:45.930855", "image_code": "//Text rendering: https://www.shadertoy.com/view/4sBfRd\n#define C(c) U.x+=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 color = texture(iChannel0, uv);\n    float previous_frame = -texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    color = pow(color, vec4(1./3.))-0.5;\n    //color = color;\n    fragColor = clamp(color, 0.0, 1.0);\n    vec4 O = vec4(0.0);\n    vec2 U = ( uv - vec2(.985, 0.))*64.0/4.;\n    int f = abs(iFrame-int(previous_frame));\n    while(f > 0){\n        int v = f%10+48;\n    \tC(v);\n        f /= 10;\n    }\n    C(32);C(58);C(115);C(101);C(108);C(112);C(109);C(97);C(83);\n    fragColor -= O.xxxx;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (float st){\n\treturn random(vec2(st, st*1749.));\n}\n\nfloat random (vec4 st) {\n    float a = dot(st.xy, vec2(62.007, 95.311));\n    float b = dot(st.zw, vec2(13.611, 1.335));\n    return random(vec2(a, b));\n}", "buffer_a_code": "// Fork of \"Bela's Ray Marcher\" by bela333. https://shadertoy.com/view/3dlGDX\n// 2020-03-13 21:43:36\n\n//TODO: Refine\n#define PI 3.14159265359\n#define MAX_STEPS 255.0\n#define MAX_DISTANCE 100.0\n#define EPSYLON 0.0002\n#define SKY_COLOR vec4(135., 206., 235., 255.)/255.\n\n\n\nfloat sphereSDF(vec3 p, vec3 center, float radius){ \n\treturn length(p-center)-radius;\n}\n\nfloat planeSDF(vec3 p, float yPos){\n\treturn abs(p.y-yPos)-EPSYLON*4.;\n}\n\nfloat cube2SDF(vec3 p, float size){\n\treturn length(max(min(p, size),-size)-p);\n}\n\nfloat cubeSDF(vec3 p, vec3 center, float size){\n\treturn cube2SDF(p-center, size);\n}\n\n//Modified version of iq's box SDF\nfloat backdropSDF( vec2 p, float b )\n{\n  return -(length(max(p,0.0)) + min(max(p.x,p.y),0.0));\n}\n\nvec3 random_point_on_sphere(vec4 seed){\n\tfloat u = random(seed) * 2. * PI;\n    float v = acos(2.*random(seed*2.) - 1.);\n    \n    return vec3(\n    \tcos(u)*sin(v),\n    \tsin(u)*sin(v),\n        cos(v)\n    );\n}\n\nvec3 random_point_on_hemisphere(vec3 n, vec4 seed){\n\tvec3 p = random_point_on_sphere(seed);\n    return dot(n, p) > 0. ? p : -p;\n}\n\nvoid get_closer(float dist, int target_mat, inout float o, inout int material){\n    if(dist < o){\n        material = target_mat;\n    }\n    o = min(o, dist);\n}\n\nfloat getSDF(vec3 p, inout int material){\n    const float drop_radius = 0.5;\n    float backdrop = backdropSDF(-p.zy+vec2(-.5, drop_radius-.5), 1.0)+drop_radius;\n    float cube = cubeSDF(p, vec3(0., 0., 0.), 0.5);\n    float lamp = sphereSDF(p, vec3(1.0, 2., 1.), .5);\n    lamp = min(lamp, sphereSDF(p, vec3(-1.0, 2., 1.), .5));\n    float sphere = sphereSDF(p, vec3(0.0, 1.0, 0.0), .5);\n    \n    float o = backdrop;\n    material = 3;\n    get_closer(lamp, 2, o, material);\n    get_closer(cube, 4, o, material);\n    get_closer(sphere, 5, o, material);\n\treturn o;\n}\n\nvec3 get_color(int material, vec3 normal, out vec3 emit, inout vec3 dir, vec4 seed, vec3 wi){\n    switch(material){\n        //Lamp\n        case 2:\n        \tdir = vec3(0.0);\n        \tconst float blueness = 1.125;\n        \temit = vec3(.878, .941, blueness)*100./blueness;\n        \treturn vec3(0.);\n        //Backdrop\n        case 3:\n        \tdir = random_point_on_hemisphere(normal, seed);\n        \temit = vec3(0.);\n        \treturn vec3(.769, .949, .306);\n        //Box\n        case 4:\n        \tdir = random_point_on_hemisphere(normal, seed);\n        \temit = vec3(0.);\n        \treturn vec3(1.0);\n        case 5:\n        \tdir = -reflect(wi, normal);\n        \temit = vec3(0.);\n        \treturn vec3(1.0);\n    }\n}\n\n\nvec3 approximateNormal(vec3 p){\n\t//float defaultDist = getSDF(p);\n    vec2 sub = vec2(0, EPSYLON);\n    int m = -1;\n\tvec3 normal = vec3(\n    \tgetSDF(p+sub.yxx, m) - getSDF(p-sub.yxx, m),\n        getSDF(p+sub.xyx, m) - getSDF(p-sub.xyx, m),\n        getSDF(p+sub.xxy, m) - getSDF(p-sub.xxy, m)\n    );\n    return normalize(normal);\n}\n\nbool castRay(inout vec3 from, vec3 dir, inout int material){ \n\tfloat allDistance = 0.;\n    float i = 0.;\n    float dist;\n    for(i = 0.; i < MAX_STEPS; i++){ \n        vec3 p = from + dir*allDistance;\n    \tdist = getSDF(p, material);\n        //float localAngle = atan(allDistance, dist);\n        allDistance += dist;\n        if(allDistance > MAX_DISTANCE || dist < EPSYLON) break;\n    }\n    from = from + dir*allDistance;\n    if(dist > EPSYLON){\n    \treturn false;\n    }\n    return true;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\n\nvec3 sample_(inout vec3 from, inout vec3 dir, vec4 seed, inout vec3 emit){\n    vec3 wi = -dir;\n    int material = -1;\n\tbool result = castRay(from, dir, material);\n    vec3 normal = approximateNormal(from);\n    \n    if(!result){\n    \temit=vec3(0.)*1.0;\n        return vec3(0.0);\n    }\n    vec3 color = get_color(material, normal, emit, dir, seed, wi);\n    from += dir * EPSYLON*5.;\n    return color * dot(dir, normal);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 cameraPos = vec3(0.0, 0.0, 0.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    //iMouse.zw\n    vec2 mouse = (iMouse.xy/iResolution.xy*2.)-.1;\n    float updown = mouse.y*PI*.25;\n    vec2 plane = vec2(cos(mouse.x*PI), sin(mouse.x*PI))*cos(updown);\n    vec3 movement = vec3(plane.x, sin(updown), plane.y)*2.;\n    cameraPos += movement;\n    //cameraPos *= 2.5;\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 seed = vec3(uv, iTime);\n    vec2 aafc = fragCoord + vec2(random(vec4(seed, 0.0)), random(vec4(seed, 179.0)))-.5;\n    //vec2 aafc = fragCoord;\n    vec2 aauv = aafc/iResolution.xy;\n    \n\t\n    vec2 screenPos = aauv*2.0-1.0;\n    \n    \n    vec2 convScreenPos = screenPos;\n    convScreenPos.x *= iResolution.x/iResolution.y;\n    \n    vec3 gridPoint = vec3(convScreenPos, .875);\n    gridPoint = normalize(gridPoint);\n    gridPoint = calcLookAtMatrix(cameraPos, target, 0.0)*gridPoint;\n    //gridPoint += cameraPos;\n    vec3 color = vec3(1.0);\n    vec3 emit = vec3(0.0);\n    for(float i = 0.; i < 4.; i++){\n        vec3 emit_color = vec3(0.0);\n    \tvec3 sample_color = sample_(cameraPos, gridPoint, vec4(seed, i), emit_color);\n        emit += color * emit_color;\n        color *= sample_color;\n        if(length(gridPoint) == 0.){break;}\n    }\n    emit = max(emit, 0.0);\n    vec4 previous = texture(iChannel0, uv);\n    float previous_frame = -texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    \n    if(iFrame==0){\n    \tprevious_frame = 0.;\n    }\n    \n    if(iMouse.w > 0.5){\n    \tprevious_frame = float(iFrame);\n    }\n    \n    if(fragCoord.x <= 2. && fragCoord.y <= 2.){\n    \tfragColor = vec4(-previous_frame, 0., 0., 1.);\n        return;\n    }else if(iMouse.w > 0.5){\n    \tfragColor = vec4(emit, 1.0);\n        return;\n    }\n    \n    fragColor = (previous*(float(iFrame)-previous_frame)+vec4(emit, 1.0))/(float(iFrame)-previous_frame+1.);\n    //fragColor = -(previous+vec4(emit, 1.0));\n    //fragColor = vec4(emit, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 120, 120, 290], [292, 292, 349, 349, 880]], "test": "untested"}
{"id": "3ssczH", "name": "2Step_indere", "author": "indere", "description": "nonthing ", "tags": ["2d"], "likes": 0, "viewed": 258, "published": 3, "date": "1584158355", "time_retrieved": "2024-07-30T21:18:46.884306", "image_code": "\nfloat circle(vec2 center, vec2 offset, float radius, vec2 position, float blur){\n\tcenter += offset;\n    float distance = length(center - position);\n    \n    return smoothstep(radius,radius - blur, distance);\n    //if(distance <= radius)\n    //   return 1.0;\n   \t//return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set backGround Color\n    vec3 bgc = vec3(1.0, .0, 1.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //transform origin to center of screen\n    uv -= 0.5;\n    //uv *= 2.0;\n    //scale x\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 center = vec2(0.0);\n    float radius = 0.4;\n    //face\n    float col = circle(center, vec2(0.0), radius, uv, 0.05);\n    \n    //eyes\n    col -= circle(center, vec2(-0.18, 0.09), 0.1, uv, 0.05);\n    col -= circle(center, vec2(0.18, 0.09), 0.1, uv, 0.05);\n    \n    //mouth\n    float mouth = circle(center, vec2(.0), 0.3, uv, 0.05);\n    mouth -= circle(center, vec2(.0, 0.03), 0.31, uv, 0.05);\n    \n    col -= max(mouth, 0.0);\n    \n    fragColor = vec4(bgc + vec3(col), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 81, 81, 278], [281, 281, 338, 365, 1064]], "test": "untested"}
{"id": "3tKGzV", "name": "Symmetry linear - Grid", "author": "NoxWings", "description": "Symmetry linear - Grid", "tags": ["symmetrylineargrid"], "likes": 7, "viewed": 337, "published": 3, "date": "1584154052", "time_retrieved": "2024-07-30T21:18:47.823794", "image_code": "#define SURF_HIT 0.001\n#define FAR_PLANE 50.\n#define animTime iTime\n#define S(x,y,z) smoothstep(x,y,z)\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,iTime))\n\nconst float PI = 3.14159;\n\nmat2 r2d(float a) {float sa=sin(a), ca=cos(a);return mat2(ca, -sa, sa, ca);}\n\nfloat map(vec3 p) {\n    vec3 q = p;\n    \n    float fold = 5.0;\n    q = mod(q, fold) - fold*.5;\n    float d = length(q.xy) - 0.4;\n    d = min(d, length(q.xz) - 0.4);\n    d = min(d, length(q.yz) - 0.4);\n    return d;\n}\n\nvec3 mapNormal(vec3 p) {\n    vec2 e = vec2(SURF_HIT, 0);\n    float m = map(p);\n    return normalize(vec3(\n    \tm - map(p - e.xyy),\n        m - map(p - e.yxy),\n        m - map(p - e.yyx)\n    ));\n}\n\nfloat mapTrace(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i=0;i<128;i++) {\n        float h = map(ro + rd * d);\n        if (h < SURF_HIT || d >= FAR_PLANE) break;\n        d += h;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y * 1.0;\n\n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    \n    ro += vec3(0, 0, -5.* animTime);\n    rd.xy *= r2d(PI * mix(animTime * 0.1, animTime * 0.1 - 0.3, sin(animTime * PI * 0.3)));\n\n    float d = mapTrace(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 n = mapNormal(p);\n\n    vec3 fogCol = vec3(1);\n    vec3 col = fogCol;\n    if (d < FAR_PLANE) {\n        vec3 outer = vec3(0.9);\n        vec3 inner = vec3(0.1, 0.1, 0.1);\n        \n        float f = pow(clamp(1.0 - dot(-rd, n), 0.0, 1.0), 1.5);\n        float fog = clamp(pow(d/FAR_PLANE, 1.), 0.0, 1.0);\n        \n        col = f * outer + (1.0 - f) * inner;        \n        col = mix(col, fogCol, vec3(fog));\n    }\n\n    fragColor = vec4(col, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 199, 199, 256], [258, 258, 277, 277, 474], [476, 476, 500, 500, 671], [673, 673, 707, 707, 880], [882, 882, 939, 939, 1763]], "test": "untested"}
{"id": "3lK3RV", "name": "Symmetry linear - Balls", "author": "NoxWings", "description": "Symmetry linear", "tags": ["symmetrylinear"], "likes": 3, "viewed": 289, "published": 3, "date": "1584154048", "time_retrieved": "2024-07-30T21:18:48.853042", "image_code": "#define SURF_HIT 0.001\n#define FAR_PLANE 50.\n#define t (iTime*.5)\n#define S(x,y,z) smoothstep(x,y,z)\n\nconst float PI = 3.14159;\n\nmat2 r2d(float a) {float sa=sin(a), ca=cos(a);return mat2(ca, -sa, sa, ca);}\n\nfloat map(vec3 p) {\n    vec3 q = p;\n    float s = 5.0;\n    q = mod(q, s) - s*.5;\n    float d = length(q + vec3(0)) - 1.0;\n    return d;\n}\n\nvec3 mapNormal(vec3 p) {\n    vec2 e = vec2(SURF_HIT, 0);\n    float m = map(p);\n    return normalize(vec3(\n    \tm - map(p - e.xyy),\n        m - map(p - e.yxy),\n        m - map(p - e.yyx)\n    ));\n}\n\nfloat mapTrace(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i=0;i<128;i++) {\n        float h = map(ro + rd * d);\n        if (h < SURF_HIT || d >= FAR_PLANE) break;\n        d += h;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y * 1.0;\n\n    vec3 ro = vec3(0, 0, 5);\n    ro += vec3(sin(t*PI), sin(t*PI), 0.);\n    ro += vec3(0, t, -4.0*t) * 2.0;\n    \n    vec3 rd = normalize(vec3(uv, -1));\n    rd.xz *= r2d(cos(t*PI*0.5) * 0.5);\n\n    float d = mapTrace(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 n = mapNormal(p);\n\n    vec3 fogCol = vec3(1);\n    vec3 col = fogCol;\n    if (d < FAR_PLANE) {\n        float f = pow(clamp(1.0 - dot(-rd, n), 0.0, 1.0), 1.5);\n        \n        vec3 outer = vec3(0.9);\n        vec3 inner = vec3(0.6, 0.6, 0.9);\n        float fog = clamp(pow(d/FAR_PLANE, 2.), 0.0, 1.0);\n        \n        col = f * outer + (1.0 - f) * inner;        \n        col = mix(col, fogCol, vec3(fog));\n    }\n    \n    fragColor = vec4(col, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 148, 148, 205], [207, 207, 226, 226, 344], [346, 346, 370, 370, 541], [543, 543, 577, 577, 750], [752, 752, 809, 809, 1620]], "test": "untested"}
{"id": "WlKSRt", "name": "Chaotic Double Pendulum", "author": "Flyguy", "description": "Visualizes the time it took for the 2nd pendulum to flip with varying initial conditions & system parameters.\nClick a region to show it's physical state, press space to reset.\nChange the \"SWEEP_MODE\" for different visualizations (or make your own).", "tags": ["math", "visualization", "attractor", "chaos", "physics", "pendulum", "chaotic"], "likes": 22, "viewed": 954, "published": 3, "date": "1584143660", "time_retrieved": "2024-07-30T21:18:49.836413", "image_code": "vec4 Grad(float x)\n{ \n    float rx = log(x+1.0)/log(30.0) - 0.05;\n    vec4 col = vec4(0.5 + 0.5 * cos(vec3(rx*tau - tau*vec3(0,1,2)/3.0)), 1);//Rainbow\n    col.rgb *= smoothstep(30.0,0.0,x);//Fade to black\n    col.a = smoothstep(3600.0,0.0,x);//Fade to transparent\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.y;\n    \n    //Checkerboard background\n    vec4 col = mix(checkCol1, \n                   checkCol2, \n                   sign(sin(uv.x*tau*checkDens)*sin(uv.y*tau*checkDens)));\n\t\n    //Time-to-flip visualization\n    vec4 vis = Grad(texelFetch(iChannel0,ivec2(fragCoord),0).w);\n    col = mix(col, vis, vis.a);\n\n    //Physical pendulum visualization of selected region\n    SweepParams(iMouse.xy/iResolution.xy);\n    vec4 state = texelFetch(iChannel1,ivec2(iMouse.xy),0);\n    vec2 p0 = vec2(res.x/2.0,0.8);\n    vec2 p1 = p0 + l1*cossin(state.x-tau/4.0);\n    vec2 p2 = p1 + l2*cossin(state.y-tau/4.0);\n    vec2 msize = mSizeMax*vec2(m1,m2)/(m1+m2);\n    \n    StartCanvas(uv, 1.0/iResolution.y);\n    {\n        Color(1);\n        Line(p0, p1, l1Size);//Linkage 1\n        Line(p1, p2, l2Size);//Linkage 2\n        \n        Color(vec3(0,0,1));\n        Circle(p0, ancSize);//Anchor\n        Color(vec3(1,0,0));\n        Circle(p1, msize.x);//Mass 1\n        Circle(p2, msize.y);//Mass 2\n        \n\t\tColor(1);\n        Ring(mouse, curSize, curThk);//Cursor\n    }\n    EndCanvas(col);\n\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 curState = vec4(0);\n\n/*\nEquations of motion taken from:\nhttps://www.myphysicslab.com/pendulum/double-pendulum-en.html\nReturns:\nx -> Angular velocity of pendulum 1 (dA1/dt)\ny -> Angular velocity of pendulum 2 (dA2/dt)\nz -> Angular acceleration of pendulum 1 (dV1/dt)\nw -> Angular acceleration of pendulum 1 (dV2/dt)\n*/\nvec4 dAdt_dVdt(vec4 state)\n{\n    float a1 = state.x, //x = a1, Angle of pendulum 1\n          a2 = state.y, //y = a2, Angle of pendulum 2\n          v1 = state.z, //z = v1, Angular velocity of pendulum 1\n          v2 = state.w; //w = v2, Angular velocity of pendulum 2\n    \n    vec2 dvdt = vec2(0);\n    dvdt.x = -g*(2.0*m1 + m2)*sin(a1)-m2*g*sin(a1-2.0*a2)-2.0*sin(a1-a2)*m2*(v2*v2*l2 + v1*v1*l1*cos(a1-a2));\n    dvdt.x /= l1*(2.0*m1+m2-m2*cos(2.0*a1-2.0*a2));\n    \n    dvdt.y = 2.0*sin(a1-a2)*(v1*v1*l1*(m1+m2)+g*(m1+m2)*cos(a1) + v2*v2*l2*m2*cos(a1-a2));\n    dvdt.y /= l2*(2.0*m1+m2-m2*cos(2.0*a1-2.0*a2));\n    \n    return vec4(v1,v2,dvdt);\n}\n\nvec4 IntegrateRK4(vec4 state, float h)\n{         \n    vec4 k1 = h*dAdt_dVdt( state );\n    vec4 k2 = h*dAdt_dVdt( state + k1/2.0 );\n    vec4 k3 = h*dAdt_dVdt( state + k2/2.0 );\n    vec4 k4 = h*dAdt_dVdt( state + k3 );\n\n    state += (k1 + 2.0*k2 + 2.0*k3 + k4)/6.0;\n    \n    return state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    curState = texelFetch(iChannel0,ivec2(fragCoord),0);\n    bool reset = texelFetch(iChannel2,ivec2(0x20,0),0).x!=0.0; //Space = reset\n    vec4 initState = SweepParams(uv);\n    \n    if(iFrame == 0 || reset)\n    {\n    \tcurState = initState;\n    }\n    \n    for(int i=0;i<steps;i++)\n    {\n    \tcurState = IntegrateRK4(curState, dt / float(steps));\n    }\n    \n    //Keep a1/a2 between -pi & +pi\n    curState.x = mod(curState.x+tau/2.0,tau)-tau/2.0;\n    curState.y = mod(curState.y+tau/2.0,tau)-tau/2.0;\n    \n    fragColor = vec4(curState);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define A1_VS_A2 0 \n#define A1A2_VS_V1 1\n#define A1A2_VS_V2 2\n#define A1A2_VS_M1M2 3\n#define A1A2_VS_L1L2 4\n#define CUSTOM 5\n\n#define SWEEP_MODE A1_VS_A2\n\n//Constants\nconst float tau = atan(1.0)*8.0;\nconst float pi = atan(1.0)*4.0;\n\n//System Parameters\nfloat g = 1.0; //Gravity\nfloat m1 = 1.0, m2 = 1.0; //Mass on pendulum 1/2\nfloat l1 = 0.3, l2 = 0.3; //Length of pendulum 1/2\nfloat dt = 0.0167; //Time step per frame\nconst int steps = 10; //Steps per frame\n\n//Visualization Parameters\nconst float flipThres = pi*0.5;\n\nvec4 checkCol1 = vec4(0.17,0.17,0.17,1);\nvec4 checkCol2 = vec4(0.20,0.20,0.20,1);\nfloat checkDens = 8.0;\n\nfloat ancSize = 0.03;\nfloat mSizeMax = 0.1; //Actual mass size is a ratio of the mass to the total mass.\nfloat l1Size = 0.005;\nfloat l2Size = 0.005;\nfloat curSize = 0.02;\nfloat curThk = 0.004;\n\n//Global Functions\n\n//Sweeps the system paramters/initial conditions with uv coords.\n//uv from 0.0 to 1.0\nvec4 SweepParams(vec2 uv)\n{\n    float a1 = 0.0, a2 = 0.0, v1 = 0.0, v2 = 0.0;\n    vec4 initState = vec4(0);\n\t\n    #if(SWEEP_MODE == A1_VS_A2)\n\ta1 = tau*(uv.x-0.5);\n\ta2 = tau*(uv.y-0.5);\n    #endif\n    \n    #if(SWEEP_MODE == A1A2_VS_V1)\n\ta1 = a2 = tau*(uv.x-0.5);\n\tv1 = tau*(uv.y-0.5);\n    #endif\n    \n    #if(SWEEP_MODE == A1A2_VS_V2)\n\ta1 = a2 = tau*(uv.x-0.5);\n\tv2 = tau*(uv.y-0.5);\n    #endif\n    \n    #if(SWEEP_MODE == A1A2_VS_M1M2)\n\ta1 = a2 = pi*uv.x;\n\tm1 = uv.y+0.1;\n    m2 = (1.0-uv.y)+0.1;\n    #endif\n    \n    #if(SWEEP_MODE == A1A2_VS_L1L2)\n\ta1 = a2 = pi*(uv.x);\n\tl1 = 0.3*uv.y;\n    l2 = 0.3*(1.0-uv.y);\n    #endif\n    \n    #if(SWEEP_MODE == CUSTOM)\n\t/* your code here */\n    #endif\n    \n    return vec4(a1,a2,v1,v2);\n}\n\nvec2 cossin(float x)\n{\n\treturn vec2(cos(x),sin(x));   \n}\n\nfloat dfCircle(float d, vec2 uv)\n{\n    return length(uv)-d/2.0;\n}\n\nfloat dfRing(float d, float w, vec2 uv)\n{\n    return abs(length(uv)-d/2.0)-w/2.0;\n}\n\nfloat dfLine(vec2 start, vec2 end, float w, vec2 uv)\n{\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv)-w/2.0;\n}\n\n#define StartCanvas(p, s) {vec2 uv=p; float ps=s; vec4 c=vec4(0); vec4 oc=vec4(0,0,0,1);\n#define Color(v) oc.rgb = vec3(v);\n#define Alpha(v) oc.a = float(v);\n#define Circle(p,d) c=mix(c,oc,smoothstep(ps,0.,dfCircle(d,uv-(p))));\n#define Ring(p,d,w) c=mix(c,oc,smoothstep(ps,0.,dfRing(d,w,uv-(p))));\n#define Line(a,b,w) c=mix(c,oc,smoothstep(ps,0.,dfLine(a,b,w,uv)));\n#define EndCanvas(o) o=mix(o,c,c.w);}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 last = texelFetch(iChannel1,ivec2(fragCoord),0);\n    vec4 cur = texelFetch(iChannel0,ivec2(fragCoord),0);\n    float resetTime = last.z;\n    float flipTime = last.w;\n\tbool reset = texelFetch(iChannel2,ivec2(0x20,0),0).x!=0.0; //Space = reset\n    \n    if(iFrame == 0 || reset)\n    {\n        last.xy = cur.xy;\n        last.zw = vec2(0);\n        resetTime = float(iFrame)*dt;\n        flipTime = 3600.0; //Start with a large time where the gradient is transparent.\n    }\n\t\n    //Detect flip and set flipTime to the current time (relative to last reset).\n    //Detects the discontinuity as the angle goes from +pi to -pi (or vise-versa).\n    if(abs(last.y-cur.y) > flipThres)\n    {\n        flipTime = min(float(iFrame)*dt - resetTime, flipTime);\n    }\n    \n    fragColor = vec4(cur.xy,resetTime,flipTime);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 287], [289, 289, 346, 346, 1559]], "test": "untested"}
{"id": "tdXyRH", "name": "Destructible*", "author": "wyatt", "description": "I found the sorting condition for delaunay triangulation! It was the distance to the triangle/circumradius! \nNow I can interpolate between any set of points! very powerful mojo", "tags": ["particles", "triangulation"], "likes": 21, "viewed": 594, "published": 3, "date": "1584138505", "time_retrieved": "2024-07-30T21:18:50.858679", "image_code": "// Fork of \"Destructible \" by wyatt. https://shadertoy.com/view/3lKSDV\n// 2020-03-13 18:10:34\n\n// Fork of \"Foam Simulation\" by wyatt. https://shadertoy.com/view/tlyXDG\n// 2020-03-08 02:50:08\n\n// Fork of \"Triangulated Actors****\" by wyatt. https://shadertoy.com/view/ttGXDG\n// 2020-03-06 04:21:54\nvec4 color (float i) {\n\treturn vec4(shape(co(i))/O/W/2.,0,1);\n}\nMain \n    vec4 b = B(U),\n         a = A(b.x), aa = A(b.y), aaa = A(b.z),\n    \n    \t col1 = color(b.x), col2 = color(b.y), col3 = color(b.z);\n    vec3 by = vec3(\n         sg(U,aa.xy,aaa.xy)/sg(a.xy,aa.xy,aaa.xy),\n         sg(U,a.xy,aaa.xy)/sg(aa.xy,a.xy,aaa.xy),\n         sg(U,a.xy,aa.xy)/sg(aaa.xy,a.xy,aa.xy)\n        );\n    float o = length(U-a.xy),\n        s = min(sg(U,a.xy,aa.xy),min(sg(U,a.xy,aaa.xy),sg(U,aa.xy,aaa.xy)));\n\tvec2 w = co(b.x);\n    col1 = by.x*col1+by.y*col2+by.z*col3;\n\tQ = max(0.3*smoothstep(O/(1.+.1*o),0.,s),\n        smoothstep(1.1*O,.9*O,o))*\n        texture(iChannel2,1.6*col1.xy);\n\tQ = max(Q,0.1*abs(sin(vec4(1+2+3+4)+.1*tri(U,a.xy,aa.xy,aaa.xy))));\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define co(i) vec2(mod(i,R.x),i/R.x)\n#define id(U) (floor((U).x)+floor((U).y)*R.x)\n#define A(i) texelFetch(iChannel0,ivec2(co(i)),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U) { U = gl_FragCoord.xy;\n#define Init if (iFrame < 1) \n#define init  (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n\n#define O 6.\n#define W round(0.75*R.y/O)\n#define shape(u) clamp(round((u)/O)*O,O*2.,2.*O+O*W)\n\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} \nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nvec2 cc (vec2 a, vec2 b, vec2 c) {\n    vec2 ab = 0.5*(a+b), ac = 0.5*(a+c);\n\tfloat m1 = (a.x-b.x)/(b.y-a.y), m2 = (a.x-c.x)/(c.y-a.y);\n    float b1 = ab.y-m1*ab.x, b2 = ac.y-m2*ac.x;\n    float x = (b1-b2)/(m2-m1);\n    return vec2(x,m1*x+b1);\n}\n\nfloat ssg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn sign(dot(p-a,(b-a).yx*vec2(1,-1)))*length(p-a-(b-a)*i);\n}\nfloat tri (vec2 U, vec2 a, vec2 aa, vec2 aaa) {\n    if (length(a-aaa)<1e-3||length(aa-aaa)<1e-3||length(a-aa)<1e-3) return 1e3;\n    float ab = ssg(U,a,aa),\n          bc = ssg(U,aa,aaa),\n          ca = ssg(U,aaa,a),\n          l = min(abs(ab),min(abs(bc),abs(ca))),\n          s = (ab<0.&&bc<0.&&ca<0.)||(ab>0.&&bc>0.&&ca>0.)?-1.:1.;\n\tif (s>0.) return s*l;\n    vec2 m = cc(a,aa,aaa);\n    float v = length(a-m), w = length(U-m);\n    return l*s/v;\n}", "buffer_a_code": "// Information Storage\nMain \n\tvec2 u = shape(U);\n\tfloat i = id(U);\n    Q = A(i);\n    vec2 f = vec2(0), f1 = vec2(0);\n\tfloat n = 0., n1 = 0.;\n\tfor (int x = -2; x <= 2; x++)\n    for (int y = -2; y <= 2; y++){\n        vec2 v = shape(u+O*vec2(x,y));\n        // triangulated force\n    \tf += C(Q.xy+vec2(x,y)).xy;\n        // shape force\n        vec4 t = A(id(v));\n        vec2 r = t.xy-Q.xy;\n        float l = length(r), ll = length(u-v), lll = length(u+O*vec2(x,y)-v);\n        if (ll>1.&&ll<3.*O&&l>0.&&lll<1.) {\n            n++;\n            f += 500.*r/l/max(1.,l*l*ll)*sign(l-length(u-v));\n        }\n        // direct contact force\n        t = A(B(Q.xy+vec2(x,y)).x);\n        r = t.xy-Q.xy;\n        l = length(r);\n        if (l>0.) {\n            n1++;\n            f1 -= 50.*r/l/max(1.,l*l)*smoothstep(.9*O,.5*O,l);\n        }\n    }\n\tif (n>0.) f = f/n; else f = vec2(0);\n\tif (n1>0.) f1 = f1/n1; else f1 = vec2(0);\n\tQ.zw = Q.zw + f + f1-vec2(0,1e-3);\n\tQ.xy += f+Q.zw*(1./sqrt(1.+dot(Q.zw,Q.zw)));\n    \n    if (Q.x<15.){Q.z=abs(Q.z);}\n    if (Q.y<15.){Q.w=abs(Q.w);}\n    if (R.x-Q.x<15.){Q.z=-abs(Q.z);}\n    if (R.y-Q.y<15.){Q.w=-abs(Q.w);}\n\tif (iFrame < 3)\n    {\n    \t\n        Q = vec4(u,0.4,0.5);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// SORT TRIANGULATION\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 aa, inout vec4 aaa, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    // check b.x\n    vec4 n = A(b.x);\n    float ln = length(n.xy-U),\n          la = length(a.xy-U);\n    if (ln<la) {\n    \tQ.x = b.x;\n        a = n;\n    }\n    float pn = pie(U,a.xy,n.xy),\n          pa = pie(U,a.xy,aa.xy);\n    if (pn<=pa){\n        aa = n;\n        Q.y = b.x;\n    }\n    float tn = tri(U,a.xy,aa.xy,n.xy),\n          ta = tri(U,a.xy,aa.xy,aaa.xy);\n    if (tn<ta) {\n    \taaa = n;\n        Q.z = b.x;\n    }\n    // check b.y\n\tn = A(b.y);\n    ln = length(n.xy-U);\n    la = length(a.xy-U);\n    if (ln<la) {\n    \tQ.x = b.y;\n        a = n;\n    }\n    pn = pie(U,a.xy,n.xy);\n    pa = pie(U,a.xy,aa.xy);\n    if (pn<pa){\n        aa = n;\n        Q.y = b.y;\n    }\n    tn = tri(U,a.xy,aa.xy,n.xy),\n    ta = tri(U,a.xy,aa.xy,aaa.xy);\n    if (tn<ta) {\n    \taaa = n;\n        Q.z = b.y;\n    }\n    // check b.z\n\tn = A(b.z);\n    ln = length(n.xy-U);\n    la = length(a.xy-U);\n    if (ln<la) {\n    \tQ.x = b.z;\n        a = n;\n    }\n    pn = pie(U,a.xy,n.xy);\n    pa = pie(U,a.xy,aa.xy);\n    if (pn<pa){\n        aa = n;\n        Q.y = b.z;\n    }\n    tn = tri(U,a.xy,aa.xy,n.xy),\n    ta = tri(U,a.xy,aa.xy,aaa.xy);\n    if (tn<ta) {\n    \taaa = n;\n        Q.z = b.z;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 aa, inout vec4 aaa, vec2 U, float r) {\n\t X(Q,a,aa,aaa,U,vec2(r,0));\n     X(Q,a,aa,aaa,U,vec2(0,r));\n     X(Q,a,aa,aaa,U,vec2(0,-r));\n     X(Q,a,aa,aaa,U,vec2(-r,0));\n}\nMain \n\tQ = B(U);\n    vec4 a = A(Q.x), aa= A(Q.y), aaa = A(Q.z);\n    Xr(Q,a,aa,aaa,U,1.);\n    Xr(Q,a,aa,aaa,U,2.);\n    for (int i = 0; i < 10; i++) {\n        float j = mod(float(iFrame + i),R.x*R.y);\n        if (length(U-A(j).xy)<length(U-a.xy)) Q.x = float(j);\n    }\n    Init {\n        Q.z = Q.y = Q.x = float(id(shape(U)));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// COMPUTE FORCE FIELD\nMain \n\tvec4 b = B(U);\n\tvec4 a = A(b.x), aa = A(b.y), aaa = A(b.z);\n\tvec2 r = a.xy-aa.xy, r1 = a.xy-aaa.xy;\n\tfloat l = length(r), l1 = length(r1);\n\tif (l>0.&&l1>0.) \n      Q.xy = \n        50.*r/l/max(1.,l*l)*smoothstep(0.9*O,0.8*O,l)+\n        50.*r1/l1/max(1.,l1*l1)*smoothstep(0.9*O,0.8*O,l1);\n    if (length(Q.xy)>.1) Q.xy = 0.1*normalize(Q.xy);\n\tif (iMouse.z>0.&&length(a.xy-iMouse.xy)>0.)\n        Q += vec4(120,120,0,0)*clamp(0.03*(a.xy-iMouse.xy)/dot((a.xy-iMouse.xy),(a.xy-iMouse.xy)),-2e-4,2e-4).xyxy;\n\t\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 296, 318, 318, 359]], "test": "untested"}
{"id": "WdfczH", "name": "Day 85", "author": "jeyko", "description": "poto", "tags": ["mdmtjvm"], "likes": 19, "viewed": 544, "published": 3, "date": "1584136113", "time_retrieved": "2024-07-30T21:18:51.832077", "image_code": "// Fork of \"Day 84\" by jeyko. https://shadertoy.com/view/Wssczn\n// 2020-03-13 10:52:05\n\n// radial blur and chromatic abberation in this buffer\n// thx iq for pallette and hg-sdf for polarMod\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5),4.)*0.7;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*6.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*1.5; \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.3);\n    //1fragColor *= 18.;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.));\n    fragColor *= 1. - dot(uvn,uvn)*0.6;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime + 3.6)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvec3 att = vec3(1);\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0,vec2(floor(t)/256.)),texture(iChannel0,vec2(floor(t) + 1.)/256.), smoothstep(0.,1.,fract(t)));\n}\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat sdRhombus(vec3 p, vec3 s){\n\t\n    \n    p = abs(p) - s;\n    \n    float d = max(p.z, max(p.x, p.y));\n    \n    \n    d = max(d, dot(p.yx + s.yx*0.5, normalize(vec2(1.))));\n    d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1.))));\n    //d = max(d - s.x*0., -dot(p.z,p.x));\n    //d \n    \n    \n    return d;\n}\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 s )\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sdThangiPong(vec3 p){\n    float mmm = sin(iTime);\n\n    mmm = sign(mmm)*pow(abs(mmm), 5.);\n    \n    \n    \n    p = abs(p);\n    //p.xy *= rot(0.5);\n    //p -= 0.1;\n    \n    p.xz *= rot(mmm*PI);\n    \n    p -= vec3(0,0.14 + mmm*0.05,0);\n    float d = sdRhombus(p , vec3(0.03));\n    \n    //glow += exp(-d*200.);\n    \n    glow += 0.5/(0.009+ d*d*1000.)*vec3(0.5,0.43,0.7);\n    \n    p.xz *= rot(0.25*PI);\n    \n    float n = fOpUnionStairs(d, sdRhombus(p - vec3(0,0.0 + 0.0,0), -vec3(0.006)), 0.04,4.);\n    d = min(d, n);\n    //fOpUnionStairs\n    return d;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    \n    float dd = length(p) - 0.1;\n    \n    \n    \n    vec3 ccc = vec3(0.,0.4,1.);\n    \n    ccc *= 1. + pow(abs(sin(p.z + iTime+ cos(p.y + iTime*0.5)) ), 20.);\n    \n    float dG = max(max(abs(p.x), abs(p.z)) - 0.3, abs(p.y) - 0.011);\n    \n    vec3 q = abs(p);\n    \n    q.xz -= 0.34;\n    \n    float dR = sdRhombus(q, vec3(0.04));\n    \n    \n    float dLamp = sdThangiPong(q);\n    \n    d = dmin(d, vec2(dLamp, 1.));\n    \n    \n    float dP = max(max(abs(p.x), abs(p.z)) - 0.01, (p.y) + 0.25);\n\n    \n    const float height = 0.5;\n    const float width = 0.08;\n    \n    float dTot = sdBox( p, vec3(width*0.9,height,width*0.9) );\n    float dTotUp = sdVerticalCapsule( p - vec3(0,height*1.,0), height*0.05, width*1. );\n    \n    \n    vec3 l = p;\n    \n\n    //p = abs(p);\n    \n    vec3 m = p;\n    vec3 o = p;\n    o = abs(o);\n    o.xz -= 0.1;\n    float dTotDown = sdRhombus( o - vec3(0,height*0.,0), vec3(width*0.) );\n\t\n    o = abs(o);\n    o = p;\n    //o.xz *= rot(0.25*PI);\n    o.y -= height*0.7;\n    float dInGrain = length(o.xy) - 0.05;\n    float hb = height*0.9;\n    m.y -= hb;\n    float dInGrainB = length(m.yz - vec2(0,0.)) - 0.02;\n    \n    d = dmin(d, vec2(abs(dInGrainB + 0.03) + 0.0, 1.));\n    \n    m = abs(m);\n    m.zx *= rot(0.6);\n    m.z -= 0.02;\n    m.y = pmod(m.y + hb, 0.1);\n    \n    \n    m.z += 0.01;\n    //m.xz *= rot(0.3);\n    \n    //float dInGrainC = length(m.yz - vec2(0,0.)) - 0.02;\n    float dInGrainC = max(abs(m.y), abs(m.z)) - 0.02;\n    \n    //dInGrainC = max(dInGrainC, -abs(m.y) + 0.004);\n    //float dInGrainC = length(m.yz - vec2(0,0.)) - 0.02;\n    \n    //d = dmin(d, vec2(abs(dInGrainC + 0.016) + 0.0, 1.));\n    \n    glow += 0.8/(0.04 + dInGrainB*dInGrainB*dInGrainB*dInGrainB*20050.)*ccc;\n\n    \n    dInGrain = min(dInGrain, \n                   max(\n                       max(abs(p.x)- 0.015, abs(p.z)- 0.2),\n                      p.y - 0.4\n                      )\n                  );\n    dInGrain = max(dInGrain,-length(o.xy) + 0.03);\n    \n    \n    dTot = fOpUnionSoft(dTot, dTotUp, 0.1);\n    dTot = fOpUnionRound(dTot, dTotDown, 0.2);\n    \n    \n    float dTotIn = dTot + 0.02;\n    \n    dTotIn = max(dTotIn + 0.03,dInGrain);\n    glow += 0.03/(0.001 + dTotIn*dTotIn*dTotIn*2050.)*ccc;\n    \n    dTot = min(max(dTot,-dInGrain), dTotIn);\n    dTot = max(dTot,-dInGrainB);\n    dTot = min(max(dTot,-dInGrainC), dTotIn);\n    \n    \n    p = l;\n    \n    dP = fOpUnionStairs(dG, dP, 0.25,6.);\n    \n    dP = min(dP,fOpUnionStairs(dG, dR, 0.09,6.));\n    \n    \n    \n    d = dmin(d, vec2(dP, 6.));\n    d = dmin(d, vec2(dR, 1.));\n    d = dmin(d, vec2(dTot, 1.));\n    //d = dmin(d, vec2(dTotUp, 1.));\n    \n    \n    vec3 u = p;\n    \n\tpModPolar(u.xz, 3.);\n    \n    float hhh = 0.6;\n    u += hhh/2.;\n    u = pmod(u, hhh);\n    \n    u = abs(u);\n    //u.yx *= rot(0.9);\n    \n    u = abs(u) - 0.02;\n    \n    u.y += pow(abs(sin(l.z + iTime + cos(l.y*0.4 + iTime*0.4 ) + sin(l.x*1.2 + iTime*0.6 ))), 10.)*0.1;\n    \n    float dGrid = min(min(max(u.y,u.x),\n                     \tmax(u.z,u.x)\n                     ),\n                     max(u.y,u.z)\n                     );\n    \n    //dGrid = max(dGrid, min(u.y, -length(p.xz) + 0.9));\n    float dBalls = max(u.y,max(u.x, u.z));\n    \n    glow += 0.03/(0.001 + dBalls*dBalls*dBalls*2050.)*vec3(0.,0.4,1.);\n\n    \n    d = dmin(d, vec2(dGrid, 1.));\n    d = dmin(d, vec2(dBalls, 1.));\n    \n    \n    vec3 c = vec3(1);\n    //glow += 0.3/(0.1 + d.x*d.x)*c;\n\td.x *= 0.6;\n    return d;\n}\nfloat dith;\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n\n    p = ro; t = 0.; hit = false;\n    for(int i = 0; i < 120 + min(0, iFrame) ; i++){\n    \td = map(p);\n        d.x *= dith;\n        \n    \t//glow += exp(-d.x*20.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir ));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //\n\t//uv *= 1. - dot(uv,uv)*0.2;\n    uv *= 1. + dot(uv,uv)*0.2;\n    \n    uv.xy *= rot(sin((iTime - 3.6))*0.2);\n    \n    vec3 col = vec3(0);\n\n    dith = mix(0.76,1., texture(iChannel0, 20.*uv*256.).x);\n    vec3 ro = vec3(0);\n    \n    \n    float n = pow(valueNoise(iTime*1.).x, 2.);\n    float nb = valueNoise(iTime*1./2.).x;\n    float zoom = 0.9 + n*1.;\n    //ro.xz += vec2(sin(iTime*0.5),cos(iTime*0.5))*zoom;\n    n *= 1.;\n    ro.xz += vec2(sin( nb*6.14*1.5),cos( nb*6.14*1.5))*zoom;\n    \n    ro.y += 0.3;\n    \n    vec3 lookAt = vec3(0,ro.y,0.);\n    lookAt.y += -0.5 + valueNoise(iTime*1./2.).x;\n    vec3 rd = getRd(ro, lookAt, uv);\n    //rd.yz *= rot(iTime);\n    \n    vec3 p; float t; bool hit;\n    float side = 1.;\n    float tA;\n    \n    for(int i = 0; i < 1; i ++){\n    \tvec2 d = march(ro, rd, p, t, hit);\n    \tvec3 n = getNormal(p);\n        \n        vec3 ld = normalize(vec3(1));\n        vec3 h = normalize(ld - n);\n        \n        float diff = max(dot(n, ld), 0.);\n        float spec = pow(max(dot(n, -h), 0.), 20.);\n        float fres = pow(1. - max(dot(n, -rd), 0.), 5.);\n        \n        //col += fres*0.04*vec3(0,0.5,1);\n        col += diff*fres*0.03*vec3(0.8,0.2,0.7);\n        \n        col += spec*0.06*vec3(0,0.5,1);\n        \n        if (d.y == 6.){\n        \n        }\n        tA = t;\n    }\n        \n    col += glow*0.006;\n    \n    \n    col = mix(col, vec3(0.4,0.4,0.7)*2.4, pow(smoothstep(0.,1.,tA*0.043), 1.6));\n\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 249, 249, 1308]], "test": "untested"}
{"id": "wdXyzH", "name": "Simple Depth Aware Blur", "author": "BeardThings", "description": "Simple depth aware blur", "tags": ["blur"], "likes": 2, "viewed": 681, "published": 3, "date": "1584130898", "time_retrieved": "2024-07-30T21:18:52.787522", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float sampleCount=0.0;\n    \n    vec4 colorSamples=vec4(0.0);\n    \n    vec4 centerSample=texelFetch(iChannel0,ivec2(fragCoord),0);\n    for(int y=-5;y<=0;y++)\n    {\n        for(int x=-5;x<=0;x++)\n        {\n            vec4 sample1=texelFetch(iChannel0,ivec2(fragCoord)+ivec2(x,y),0);\n            vec4 sample2=texelFetch(iChannel0,ivec2(fragCoord)-ivec2(x,y),0);\n            \n            float dzdt1=sample1.z-centerSample.z;\n            float dzdt2=centerSample.z-sample2.z;\n            \n            const float epsilon=0.1;\n            float lowestdzdt=min(abs(dzdt1),abs(dzdt2));\n\t\t\tfloat weight1=lowestdzdt==abs(dzdt1)?1.0:0.0;\n            float weight2=lowestdzdt==abs(dzdt2)?1.0:0.0;\n            \n            if(weight1==0.0)\n            {\n                weight1=abs(lowestdzdt-abs(dzdt1))<epsilon?1.0:0.0;\n            }\n            else if(weight2==0.0)\n            {\n                weight2=abs(lowestdzdt-abs(dzdt2))<epsilon?1.0:0.0;\n            }\n            \n            colorSamples+=sample1*weight1+sample2*weight2;\n            sampleCount+=weight1+weight2;\n        }\n    }\n        \n    // Output to screen\n    fragColor = colorSamples/sampleCount;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float SDF(vec3 p)\n{\n    float s1=length(p)-0.1;\n    float s2=length(p-vec3(-0.2,0.0,0.2))-0.1;\n    return min(s1,s2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,10000.0);\n    \n    vec2 uv=fragCoord/iResolution.xy*2.0-1.0;\n    \n    vec3 dr=normalize(uv.x*vec3(1.0,0.0,0.0)+uv.y*vec3(0.0,1.0,0.0)+vec3(0.0,0.0,1.0));\n    vec3 o=vec3(0.0,0.0,-0.2);\n    float d=0.0;\n    for(int i=0;i<64;i++)\n    {\n        vec3 p=o+dr*d;\n        float s=SDF(o+dr*d);\n        if(s<0.001)\n        {\n            vec2 uv=normalize(p.xz);\n            vec4 color=texture(iChannel0,uv);\n            \n            fragColor=vec4(color.xyz*(p.z>0.1?10.0:1.0),p.z);\n            break;\n        }\n        d+=s;\n    }\n\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1318]], "test": "untested"}
{"id": "wdfcRH", "name": "2D SDF to texture mapping", "author": "aedion", "description": "Maps a 2D SDF to four regions, each with a different texture.\n\nUses the triangle function `clamp(1-abs(x-a),0,1)` to interpolate bands at distance a={0,1,2,3}. Notice that sum of all bands is a constant 1.0. Gamma corrects the blend, h/t spalmer\n", "tags": ["distancefield", "sdf"], "likes": 3, "viewed": 356, "published": 3, "date": "1584128596", "time_retrieved": "2024-07-30T21:18:53.596359", "image_code": "// Maps 2D SDF to four regions, each with a different texture.\n//\n// Uses a \"banding\" function that takes a scalar value as input and splits that into\n// channels in range [0,1] where the sum of all channels is 1.\n//\n// The sawtooth-like function `clamp(1 - abs(x-a), 0, 1)` where a in {0,1,2,3} works great\n// for this purpose and can be SIMD pretty easily.\n//\n// The one second blip in the animation shows the different channels (alpha is black).\n//\n// A linear color space assumption is made for the math. \n// Shadertoy is in gamma space, so need to decode the textures to linear then encode the \n// result back.\n\n\n// Maps input domain [0,3] to four channels.\n// Each channel is 1.0 at the integers, and the sum of all channels is 1.\nvec4 map03To4Channel(float x03) {\n\treturn clamp(1. - abs(vec4(x03, x03 - 1., x03 - 2., x03 - 3.)), 0., 1.);\n}\n\n/* Same idea as above, but for two and three channels respectively instead of four:\n    vec2 map01To2Channel(float x01) {\n        return clamp(1. - abs(vec2(x01, x01 - 1.)), 0., 1.);\n    }\n    vec3 map02To3Channel(float x02) {\n        return clamp(1. - abs(vec3(x02, x02 - 1., x02 - 2.)), 0., 1.);\n    }\n*/\n\n// Approximated gamma correction.\n// See https://iquilezles.org/articles/gamma for basics\n// and this neat video https://www.youtube.com/watch?v=LKnqECcg6Gw\n// and this cool tutorial https://www.shadertoy.com/view/lscSzl\n#define GAMMA_CORRECTION 1\n#define GAMMA 2.2\nvec3 deGamma(vec3 c) {\n    #if GAMMA_CORRECTION\n    \tc = pow(c,vec3(GAMMA));\n    #endif\n    return c;\n}\nvec3 gamma(vec3 c) {\n    #if GAMMA_CORRECTION\n    \tc = pow(c,vec3(1./GAMMA));\n    #endif\n    return c;\n}\n\n// Sample the texture, scaling it by a factor\nvec3 factorSample(sampler2D tex, vec2 uv, float factor) {\n    vec3 c = texture(tex, uv).rgb;\n    c = deGamma(c); // before multiplying, which needs linear space\n    return c * factor;\n}\n\n// IQ's: https://iquilezles.org/articles/distfunctions2d\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n// Smoothstep, but where \"slope\" is the derivative at value=0.5\nvec4 slopeSmoothstep(vec4 value, float slope) {\n    const float center = 0.5;\n\treturn smoothstep(0.0, 1.0, slope * (value - center) + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord/iResolution.y;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    float sd = sdPentagon(p, .5); // Can be any SDF\n    sd = 4. * sd + 1.5; // Scale and shift\n    sd = clamp(sd,0.,3.); // Clamp into domain [0,3]\n   \n    // Map distance to channels:\n    vec4 channel = map03To4Channel(sd);\n    \n    // Blend channels using a step-like function\n    float anim = 5.*sin(iTime*12.)+6.; // range [1,11]\n    float blur = anim * fwidth(sd); // fragment width based blur (1 = smooth anti-aliasing)\n    // Can be \"lerp\" or any other function that maintains sum-of-channels = 1\n    channel = slopeSmoothstep(channel, 1. / blur);\n    \n    vec3 col;\n    if (mod(floor(iTime),4.) == 0.) { // \"for first second out of four\"\n        // Debug view\n        col = channel.rgb; // throws away .a, which turns it black\n    } else {\n        // Multiply each texture by the associated channel\n        col  = factorSample(iChannel0, uv, channel.r);\n        col += factorSample(iChannel1, uv, channel.g);\n        col += factorSample(iChannel2, uv, channel.b);\n        col += factorSample(iChannel3, uv, channel.a);\n    }\n    \n    fragColor = vec4(gamma(col),1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[618, 737, 770, 770, 846], [1422, 1422, 1444, 1444, 1525], [1526, 1526, 1546, 1546, 1630], [1632, 1678, 1735, 1735, 1863], [1865, 1922, 1965, 1965, 2247], [2249, 2313, 2360, 2360, 2453], [2455, 2455, 2512, 2512, 3692]], "test": "untested"}
{"id": "tdXcRH", "name": "Pilot wave system", "author": "michael0884", "description": "Sorting and storing 4 particle id's in 1 texel based on the distance to the texel. This allows extremely cheap interactions between particles.\nIn this example I'm using a sin force.", "tags": ["particles"], "likes": 9, "viewed": 524, "published": 3, "date": "1584126834", "time_retrieved": "2024-07-30T21:18:54.429133", "image_code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-13 12:18:57\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    ivec4 sp = get(p);\n   \n    vec4 p0 = getParticle(sp.x);\n   \tivec4 cp = get(ivec2(p0.xy));\n    vec4 p1 = getParticle(cp.y);\n    vec4 p2 = getParticle(cp.z);\n    vec4 p3 = getParticle(cp.w);\n   \n    \n    float intensity = gauss(distance(pos, p0.xy), prad);\n    intensity += gauss(distance(pos, p1.xy), prad);\n    intensity += gauss(distance(pos, p2.xy), prad);\n    intensity += gauss(distance(pos, p3.xy), prad);\n    float pw = sin(distance(pos, p0.xy)/prad);\n    pw += sin(distance(pos, p1.xy)/prad);\n    pw += sin(distance(pos, p2.xy)/prad);\n    pw += sin(distance(pos, p3.xy)/prad);\n    \n    col = .5+.5*sin(vec4(1., 2., 3., 4.)*intensity + 0.2*pw) ; \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n//force scalar\nfloat F(float d)\n{\n    return -0.5*sin(d/(2.*prad));\n}\n\n//force vector\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    if(!all(equal(p0,p1)))\n   \t return normalize(p1-p0)*F(distance(p1,p0));\n    else\n     return vec2(0.);\n}\n\n//get particle from array\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n   \t\t\n        //neighbors\n   \t\tivec4 cp = get(ivec2(U.xy));\n   \t    vec4 p1 = getParticle(cp.y);\n   \t    vec4 p2 = getParticle(cp.z);\n   \t    vec4 p3 = getParticle(cp.w);\n        \n        vec2 F = Fv(U.xy, p1.xy) +\n            \t Fv(U.xy, p2.xy) +\n            \t Fv(U.xy, p3.xy) +\n            \t vec2(0.,0.);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 3.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += dt*F;\n        U.zw *= 1. - 0.004*dt*length(U.zw); //cooling\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//particle array\n//can be up to the resolution of the buffer\n//zero performance impact btw\n#define N ivec2(8,8)\n#define dt 0.8\n#define prad 8.\n\n//save N last iterations\n#define LN 1.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(fake, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}", "buffer_b_code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid sort(inout ivec4 u, inout vec4 d, int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p);\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(utemp != u.x && d.x > dtemp)\n    {\n        swap(u.x, utemp);\n        swap(d.x, dtemp);\n    }\n    if((!any(equal(ivec2(utemp), u.xy)) && d.y > dtemp) || u.y==u.x )\n    {\n        swap(u.y, utemp);\n        swap(d.y, dtemp);\n    }\n    if((!any(equal(ivec3(utemp), u.xyz)) && d.z > dtemp) || any(equal(ivec2(u.z), u.xy)))\n    {\n        swap(u.z, utemp);\n        swap(d.z, dtemp);\n    }\n    if((!any(equal(ivec4(utemp), u.xyzw)) && d.w > dtemp) || any(equal(ivec3(u.w), u.xyz)))\n    {\n        u.w = utemp;\n        d.w = dtemp;\n    }\n}\n\nvoid upd(inout ivec4 u, inout vec4 d, ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(u, d, t.x, p);\n    sort(u, d, t.y, p);\n    sort(u, d, t.z, p);\n    sort(u, d, t.w, p);\n}\n\nvoid randupd(inout ivec4 u, inout vec4 d, ivec2 p )\n{\n    //go through the entire array sudorandomly\n    int t = ((iFrame + p.x + p.y*int(iResolution.x))^32)%tot_n;\n    sort(u, d, t, p);\n}\n\n\nvoid updrad(inout ivec4 u, inout vec4 d, ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(u, d, p, ivec2(r, 0));\n    upd(u, d, p, ivec2(-r, 0));\n    upd(u, d, p, ivec2(0, r));\n    upd(u, d, p, ivec2(0, -r));\n}\n\nvoid update(inout ivec4 u, inout vec4 d, ivec2 p)\n{\n    randupd(u, d, p);\n    updrad(u, d, p, 0);\n    updrad(u, d, p, 3);\n    updrad(u, d, p, 5);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //particle indecies \n    ivec4 sp = get(p);\n    \n   \t//particle distances to this point\n    vec4 dist = vec4(particleDistance(sp.x, pos), \n                     particleDistance(sp.y, pos), \n                     particleDistance(sp.z, pos), \n                     particleDistance(sp.w, pos));\n   \n    update(sp, dist, p);\n    \n    U = save(sp);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 139, 139, 174], [176, 176, 216, 216, 262], [264, 264, 295, 295, 329], [331, 331, 383, 383, 502], [504, 504, 549, 549, 1234]], "test": "untested"}
{"id": "tsXyRH", "name": "I had a nightmare last night", "author": "tono", "description": "nightmare", "tags": ["eye", "nightmare"], "likes": 10, "viewed": 453, "published": 3, "date": "1584123557", "time_retrieved": "2024-07-30T21:18:55.307784", "image_code": "\n#define FAR 20.\n#define M(x,y) mod(x,y) - y/2.\n\n//If you want to make it worse, you need to make AA more than 2.\n#define GetsEvenWorse false\n#define AA 1\n\n#define OnlyEye false\n\nfloat pi = acos(-1.);\nfloat pi2 = acos(-1.) * 2.;\n\nfloat t,depth;\n\nvec3 cp = vec3(10.,5.,-11.);\n\nvec2 rot(vec2 p,float a){return vec2(mat2( cos(a),sin(a),-sin(a),cos(a))*p );}\n\nvec3 RotMat(vec3 p,vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return p * mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nvec2 random2(vec2 st){return -1.0 + 2.0*fract(sin( vec2( dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)) ))*43758.5453123);}\n\nfloat noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n    return mix( mix( dot( vec2(v00), f - vec2(0,0) ), dot( vec2(v10), f - vec2(1,0) ), u.x ),\n                 mix( dot( vec2(v01), f - vec2(0,1) ), dot( vec2(v11), f - vec2(1,1) ), u.x ), \n                 u.y)+0.5;\n}\n\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\nfloat deMengerSponge2(vec3 p, vec3 offset, float scale) {\n    vec4 z = vec4(p, 1.0);\n    for (int i = 0; i < 3; i++) {\n        z = abs(z);\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        //if (z.y < z.z) z.yz = z.zy;\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0))) / z.w;\n}\n\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n    return rot(p,-a);\n}\n\nvec2 Polar(vec2 i)\n{\n    vec2 pl = vec2(0.);\n    pl.y = sqrt(i.x*i.x+i.y*i.y)*2.+1.;\n    pl.x = atan(i.y,i.x)/acos(-1.);\n    return pl;\n}\n\nvec3 eyemove(vec3 p)\n{\n    float tt = iTime;\n    \n    p = RotMat(p,vec3(0.3,0.2,0.6),noise(vec2(tt))/4.);\n    p = RotMat(p,vec3(0.1,0.7,0.9),noise(vec2(tt/2.))/4.);\n    p= RotMat(p,vec3(0.,1.,0.),pow(clamp(cos(tt/2.),-.2,.2)*3.,3.));\n    p= RotMat(p,vec3(1.,0.,0.),pow(clamp(sin(tt/3.5),-.3,.3)*1.,3.));\n    p = RotMat(p,vec3(1.,1.,0.),pow(clamp(sin(tt/1.5),-.17,.17)*4.,3.));\n    return p;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(0.);\n    vec3 ee = p;\n    p -= vec3(0.,1.7,7.5);\n    vec3 pp = p;\n    float w = length(ee) - 2.;\n    float w2 = length(ee) - 2.5;\n    float camera = length((ee - cp)/vec3(1.,1.,5.)) - 10.5;\n    ee = eyemove(ee);\n    ee += vec3(0.,0.,.67) ;\n    float soul = min(w,length(ee) - 1.5);\n    pp.xz = rot(pp.xz,t /17.);\n    \n    p = mod(p,18.)-9.;\n    for(int i = 0 ; i< 3; i++)\n    {\n        p.xz = abs(p.xz) - 1.6;\n        p.xy = rot(p.xy, 3. );\n        p.yz = rot(p.yz,5.);\n        p.zx = rot(p.zx,-1.);\n        \n        p.yx = abs(p.yx) - .9;\n        p.zy = rot(p.zy, -7. );\n        p.xz = rot(p.xz,5.);\n        p.xz = rot(p.xz,-1.);\n    }\n    p.xz = rot(p.xz,length(pp.xy) * 1.16 );\n    float menger = deMengerSponge2(p, vec3(1.), 3.);\n    menger = max(menger,-w2);\n    menger = max(menger,-camera);\n    if(OnlyEye)\n    {\n        d = vec2(soul,2.);;\n    }else{\n        \n        vec2 s = vec2(soul,2.);\n    \tvec2 m = vec2(menger * .3,1.);\n        d = (m.x < s.x)?m:s;\n    }\n    //d = m;\n    return d;\n}\nvec2 march(vec3 p,vec3 rd)\n{\n    depth = 0.;\n    vec2 d = vec2(.0);\n    for(int i = 0; i <55; i++)\n    {\n        d = map(p + rd * depth);\n        if(abs(d.x) < 0.001 || d.x > FAR){break;}\n        depth += d.x;\n    }\n\tif(d.x > FAR){d.x = -1.;}\n    return d;\n}\n\nvec3 eyecolor(vec3 p)\n{\n    p = eyemove(p);\n    vec3 w = vec3(.8,0.8,.8);\n    vec3 b = vec3(0.);\n    vec2 P = Polar(p.xy);\n    vec3 i = vec3(1.,1.,0.) * sin(P.y*2. - 3.5);\n    \n    b += i;\n    b *= vec3(1.,1.,1.) * noise(p.xy * 9.) * .5 +.5;\n    vec3 o = mix(w,b,step( length(p.xy),1.15) * step( p.z,.1));\n    return o;\n}\n\nvec3 mengcolor(vec3 p)\n{\n    vec3 b = vec3(0.,.5,1.);\n    b += mix(vec3(0.,0.,0.),b,step(sin(Polar(p.xy).y + p.z + t),0.));\n    return b;\n}\n\n float B(float nh, float roughness)\n{\n    nh *= nh;\n    roughness *= roughness;\n    return exp((nh - 1.) / (roughness * nh))/ (pi * roughness * nh * nh);\n}\n\nfloat C(float nl, float nv, float nh, float vh)\n{\n    return min(1. ,min(2. * nh * nv / vh,2. * nh * nl  / vh ));\n}\n\nfloat fresnelSchlick(float nv, float fresnel)\n{\n    return max(0.,fresnel + (1. - fresnel) * pow(1. - nv, 5.));\n}\n\n\nvoid scene(inout vec3 ocolor,in vec2 f)\n{\n    if( !GetsEvenWorse)cp = vec3(10.,5.,-11.);\n    if(OnlyEye)\n    {\n        cp.xz = rot(cp.xz,-pi/4.);\n    }else{\n    \tcp.z += clamp(sin(iTime/12.),-.9,.1)*10.;\n    \tcp.xz = rot(cp.xz,t/2. - cos(t/2.));\n    }\n    \n    vec2 p = (f.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cs,cd));\n    \n    float fov = 2.;\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov);\n    vec3 skycolor = vec3(.2,.4,.8);\n    vec3 color = skycolor;\n    \n    vec3 light = normalize(vec3(.8,.4,.2));\n    vec2 d = vec2(-1.);\n    d = march(cp,rd);\n    if(d.x > 0.)\n    {\n        vec2 e = vec2(0.0001,0.);\n        vec3 pos = depth * rd + cp;\n    \tvec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n\n     \n        color = mix(eyecolor(pos),mengcolor(pos),step(d.y,1.));\n        vec3 view = rd;\n        vec3 hlf = normalize(light + view);\n        float nl = dot(N,light);\n        float nv = dot(N,view);\n        float nh = dot(N,hlf);\n        float vh = dot(view,hlf);\n        \n        float fresnel = 2.;\n        float roughness = .1;\n        //vec2(fresnel,roughness)\n        vec2 para = mix(vec2(4.,.07),vec2(3.,.1),step(d.y,1.));\n        \n        float dte = B(nh , para.y);\n        float gte = C(nl,nv,nh,vh);\n        float fte = fresnelSchlick(nv,para.x);\n\n        float sp = max(0.,dte * gte * fte / (nl * nv * 4.) * nl);\n\n        float dif = pow( max(0.,dot(light,N))*.5+.5,2. );\n        color =color * dif + sp * vec3(1.,1.,1.);\n        \n        \n    }\n    ocolor += color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime/2.;\n    depth = 55.;\n    vec3 color = vec3(0.);\n    for(int i = 0;i < AA;i++ )\n    {\n        for(int j = 0; j < AA;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(AA);\n            scene(color,fragCoord.xy + d);\n        }\n    }\n    color /= float(AA * AA);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 301, 301, 354], [356, 356, 400, 473, 965], [967, 967, 989, 989, 1095], [1097, 1097, 1120, 1120, 1565], [1567, 1625, 1682, 1682, 2109], [2111, 2111, 2139, 2139, 2251], [2253, 2253, 2273, 2273, 2390], [2392, 2392, 2414, 2414, 2784], [2787, 2787, 2805, 2805, 3823], [3824, 3824, 3852, 3852, 4082], [4084, 4084, 4107, 4107, 4405], [4407, 4407, 4431, 4431, 4546], [4549, 4549, 4585, 4585, 4703], [4705, 4705, 4754, 4754, 4820], [4822, 4822, 4869, 4869, 4935], [4938, 4938, 4979, 4979, 6659], [6661, 6661, 6718, 6718, 7094]], "test": "untested"}
{"id": "tdXcR8", "name": "micro detail visualization", "author": "public_int_i", "description": "visualizing how surface roughness results from micro details so small they blur together", "tags": ["visualization", "aliasing", "supersampling", "micro", "detail", "anti"], "likes": 4, "viewed": 453, "published": 3, "date": "1584110290", "time_retrieved": "2024-07-30T21:18:56.166488", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 117]], "test": "untested"}
{"id": "tsXyR8", "name": "FirstStep_indere", "author": "indere", "description": "fragCoord mean\nsmoothstep mean", "tags": ["2d"], "likes": 1, "viewed": 267, "published": 3, "date": "1584107237", "time_retrieved": "2024-07-30T21:18:56.957373", "image_code": "\nbool onTheCircle(vec2 center, float radius, vec2 point){\n    return (length(point - center) < radius) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 center = vec2(0.0);\n    float radius = 0.5;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    bool tag = onTheCircle(center, radius, uv);\n    float c = smoothstep(0.0, 1.0, length(uv));\n    if(tag)\n        fragColor = vec4(c,.0,.0,1.0);\n    else\n        fragColor = vec4(0.0,.0,.0,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 57, 57, 106], [108, 108, 165, 165, 542]], "test": "untested"}
{"id": "3sXczH", "name": "dark Britney", "author": "FabriceNeyret2", "description": "Powering to increase  shadow / highlight areas contrast.", "tags": ["video", "short"], "likes": 7, "viewed": 389, "published": 3, "date": "1584103787", "time_retrieved": "2024-07-30T21:18:57.847992", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec4  C = texture( iChannel0, U/iResolution.xy ),\n          L = pow( C, vec4(4.));\n    float v = 2.*L.r-L.g;      // BW channel extracting background\n\n  //O = vec4(v);               //  B&W\n    O = v*C;                   //  color\n  //O = L;\n  //O = mix(vec4(v),C,.3);     // just a touch of colors\n  //O = mix(vec4(v),L,.3);     // just a touch of colors\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 400]], "test": "untested"}
{"id": "WdXczH", "name": "Smooth fast molecular dynamics", "author": "michael0884", "description": "Sorting and storing 4 particle id's in 1 texel based on the distance to the texel. This allows extremely cheap interactions between particles.\nIn this example I'm using an atomic force approximation to model molecular dynamics.", "tags": ["particles"], "likes": 12, "viewed": 564, "published": 3, "date": "1584103504", "time_retrieved": "2024-07-30T21:18:58.771523", "image_code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-13 12:18:57\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    ivec4 sp = get(p);\n   \n    vec4 p0 = getParticle(sp.x);\n   \tivec4 cp = get(ivec2(p0.xy));\n    vec4 p1 = getParticle(cp.y);\n    vec4 p2 = getParticle(cp.z);\n    vec4 p3 = getParticle(cp.w);\n   \n    \n    float intensity = gauss(distance(pos, p0.xy), prad);\n    intensity += gauss(distance(pos, p1.xy), prad);\n    intensity += gauss(distance(pos, p2.xy), prad);\n    intensity += gauss(distance(pos, p3.xy), prad);\n    \n    col = .5+.5*sin(vec4(5., 6., 7., 8.)*intensity) ; \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n//force scalar\nfloat F(float d)\n{\n    return 0.5*(d - 2.*prad)*gauss(d, 2.*prad);\n}\n\n//force vector\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    if(!all(equal(p0,p1)))\n   \t return normalize(p1-p0)*F(distance(p1,p0));\n    else\n     return vec2(0.);\n}\n\n//get particle from array\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n   \t\t\n        //neighbors\n   \t\tivec4 cp = get(ivec2(U.xy));\n   \t    vec4 p1 = getParticle(cp.y);\n   \t    vec4 p2 = getParticle(cp.z);\n   \t    vec4 p3 = getParticle(cp.w);\n        \n        vec2 F = Fv(U.xy, p1.xy) +\n            \t Fv(U.xy, p2.xy) +\n            \t Fv(U.xy, p3.xy) +\n            \t vec2(0.,-0.02);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 3.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += dt*F;\n        U.zw *= 1. - 0.004*dt*length(U.zw); //cooling\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//particle array\n//can be up to the resolution of the buffer\n//zero performance impact btw\n#define N ivec2(30,30)\n#define dt 0.8\n#define prad 8.\n\n//save N last iterations\n#define LN 1.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(fake, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}", "buffer_b_code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid sort(inout ivec4 u, inout vec4 d, int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+0.5;\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(utemp != u.x && d.x > dtemp)\n    {\n        swap(u.x, utemp);\n        swap(d.x, dtemp);\n    }\n    if(!any(equal(ivec2(utemp), u.xy)) && d.y > dtemp)\n    {\n        swap(u.y, utemp);\n        swap(d.y, dtemp);\n    }\n    if(!any(equal(ivec3(utemp), u.xyz)) && d.z > dtemp)\n    {\n        swap(u.z, utemp);\n        swap(d.z, dtemp);\n    }\n    if(!any(equal(ivec4(utemp), u.xyzw)) && d.w > dtemp)\n    {\n        u.w = utemp;\n        d.w = dtemp;\n    }\n}\n\nvoid upd(inout ivec4 u, inout vec4 d, ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(u, d, t.x, p);\n    sort(u, d, t.y, p);\n    sort(u, d, t.z, p);\n    sort(u, d, t.w, p);\n}\n\nvoid randupd(inout ivec4 u, inout vec4 d, ivec2 p )\n{\n    //go through the entire array\n    for(int i = 1; i < 8; i++)\n    {\n    \tint t = ((iFrame + p.x + p.y*int(iResolution.x))^(1<<i))%tot_n;\n   \t\tsort(u, d, t, p);\n    }\n}\n\n\nvoid updrad(inout ivec4 u, inout vec4 d, ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(u, d, p, ivec2(r, 0));\n    upd(u, d, p, ivec2(-r, 0));\n    upd(u, d, p, ivec2(0, r));\n    upd(u, d, p, ivec2(0, -r));\n}\n\nvoid update(inout ivec4 u, inout vec4 d, ivec2 p)\n{\n    randupd(u, d, p);\n    updrad(u, d, p, 0);\n    updrad(u, d, p, 3);\n    updrad(u, d, p, 5);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //particle indecies \n    ivec4 sp = get(p);\n    \n    sp.yzw = ivec3(0); \n    \n   \t//particle distances to this point\n    vec4 dist = vec4(particleDistance(sp.x, pos), 1e10, 1e10, 1e10);\n        \n   \n    update(sp, dist, p);\n    \n    U = save(sp);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 139, 139, 174], [176, 176, 216, 216, 262], [264, 264, 295, 295, 329], [331, 331, 383, 383, 502], [504, 504, 549, 549, 1052]], "test": "untested"}
{"id": "3sfcz8", "name": "Infinite Stair", "author": "yasuo", "description": "Infinite Stair", "tags": ["stair"], "likes": 14, "viewed": 384, "published": 3, "date": "1584093149", "time_retrieved": "2024-07-30T21:18:59.826701", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 80\n#define MAX_DIST 50.\n#define SURF_DIST .003\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat stairPart(vec3 p) {\n    vec3 p2 = p;\n    p2 += vec3(0.1,0.1,0.0);\n    p2= abs(p2)-vec3(0.25,0.25,2.0);\n    p = abs(p)-vec3(0.2,0.2,0.7);\n    float b = max(p.x,max(p.y,p.z));\n    float b2 = max(p2.x,max(p2.y,p2.z));\n    b = max(-b2,b);\n    return b;\n}\n\nfloat stair(vec3 p, int drawBall){\n    vec3 pref = p;\n    float b = stairPart(p);\n    float b2 = stairPart(p-vec3(-0.4,0.4,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(0.4,-0.4,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(-0.8,0.8,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(0.8,-0.8,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(-1.2,1.2,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(-1.6,1.6,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(-2.0,2.0,0.0));\n    b = min(b,b2);\n    p = abs(p-vec3(1.7,-1.0,0.0))-vec3(0.7,0.03,0.7);\n    float b3 = max(p.x,max(p.y,p.z));\n    b = min(b,b3);\n    \n    \n    if(drawBall == 1){\n        \n        p = pref;\n        p = abs(p-vec3(2.7,-1.0,0.0))-vec3(0.35,0.03,0.7);\n        float b4 = max(p.x,max(p.y,p.z));\n        b = min(b,b4);\n        p = pref;\n        p = abs(p-vec3(3.,0.2,0.0))-vec3(0.03,1.2,0.7);\n        float b5 = max(p.x,max(p.y,p.z));\n        b = min(b,b5);\n        p = pref;\n        p = abs(p-vec3(3.,0.2,0.0))-vec3(0.06,1.15,0.6);\n        float b6 = max(p.x,max(p.y,p.z));\n        b = max(-b6,b);\n        \n        float speed = 0.6;\n        float animTime = mod(iTime,speed*10.0);\n        float x = 0.0;\n        x += animscene(animTime, 0.0, speed)*0.4;\n        x += animscene(animTime, speed, speed)*0.4;\n        x += animscene(animTime, speed*2.0, speed)*0.4;\n        x += animscene(animTime, speed*3.0, speed)*0.4;\n        x += animscene(animTime, speed*4.0, speed)*0.4;\n        x += animscene(animTime, speed*5.0, speed)*0.4;\n        x += animscene(animTime, speed*6.0, speed)*0.4;\n        x += animscene(animTime, speed*7.0, speed)*0.4;\n        x += animscene(animTime, speed*8.0, speed*2.0)*2.0;\n\n        float y = 0.0;\n        y += animscene(animTime, speed, speed*0.2)*-0.38;\n        y += animscene(animTime,speed+speed, speed*0.1)*-0.38;\n        y += animscene(animTime,speed+(speed*2.0), speed*0.1)*-0.42;\n        y += animscene(animTime,speed+(speed*3.0), speed*0.1)*-0.42;\n        y += animscene(animTime,speed+(speed*4.0), speed*0.1)*-0.38;\n        y += animscene(animTime,speed+(speed*5.0), speed*0.1)*-0.38;\n        y += animscene(animTime,speed+(speed*6.0), speed*0.1)*-0.38;\n        y += animscene(animTime,speed+(speed*7.0), speed*0.1)*-0.38;\n\n        float s = length(pref-vec3(-2.0+x,2.4+y,0.0))-0.2;\n        b = min(b,s);\n    }\n    \n    return b;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = 0.25;\n    \n    p.y+= iTime*1.5;\n    p.y=mod(p.y,12.6)-6.3;\n    p.y-= 4.20;\n    \n    float b = stair(p,0);\n    float b2 = stair((p+vec3(-1.7,3.17,2.5))*matRotateY(radians(90.0)),1);\n    float b3 = stair((p+vec3(0.8,3.17*2.0,4.2))*matRotateY(radians(-180.0)),0);\n    float b4 = stair((p+vec3(2.5,3.17*3.0,1.7))*matRotateY(radians(-90.0)),1);\n    b = min(b,min(b2,min(b3,b4)));\n    \n    vec4 resB = vec4(vec3(0.8),b*0.6);\n\n    return resB;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0,0.0,0.0,0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 5, -6);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-20.0));\n    ro.xz *= Rot(t*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 553, 553, 644], [646, 646, 682, 682, 724], [726, 838, 885, 885, 926], [928, 928, 953, 953, 1184], [1186, 1186, 1220, 1220, 3548], [3550, 3550, 3572, 3572, 4075], [4077, 4077, 4110, 4110, 4375], [4377, 4377, 4401, 4401, 4602], [4604, 4604, 4638, 4638, 4952], [4954, 4954, 4977, 4977, 5333], [5335, 5335, 5377, 5377, 5572], [5574, 5574, 5631, 5631, 6334]], "test": "untested"}
{"id": "wdfyzr", "name": "Set", "author": "zxxuan1001", "description": "It's fun to play with the formulas. ", "tags": ["2d", "fractals"], "likes": 4, "viewed": 372, "published": 3, "date": "1584087415", "time_retrieved": "2024-07-30T21:19:00.822040", "image_code": "#define ITERATION 12\n#define PI 3.1416\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y; \n    vec2 mo = iMouse.xy / iResolution.xy ;\n    float ti = iTime * 0.2;\n    ivec2 txy = ivec2(fragCoord.xy/iResolution.xy);\n    float fft  = texelFetch( iChannel0, ivec2(txy.x, 0), 0 ).x;\n    float a = 0.02*texelFetch( iChannel0, ivec2(txy.y, 1), 0 ).x;\n    float t = fft;\n    vec2 c = vec2(0.45*cos(PI*mo.x + ti*0.5), 0.45*sin(PI*mo.y + ti*0.5));\n    c += vec2(0.5 + a * sin(t));\n    \n    vec2 p = uv;  \n    float len = length(p);\n    float r = 0.0, g = 0.0, b = 0.0;\n    \n \tvec3 col = vec3(0.0);\n    for (int i = 0; i < ITERATION; ++i) {\n        p = abs(p)/dot(p,p) - c;\n        float l = len;\n        len = length(p);\n        l = len - l;\n        \n        col +=  l * len * vec3(sin(1.2*ti + 10.0), cos(1.8*ti + 12.0), sin(-1.2*ti));\n    \tcol = 1.0 - exp(-0.04*col);\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 96, 96, 1060]], "test": "untested"}
{"id": "WdXyz8", "name": "pointillism - 2b", "author": "FabriceNeyret2", "description": "ref image: [url]https://www.instagram.com/p/B9eSSDKph-T/[/url]\nColor version of [url]https://shadertoy.com/view/wslcRn[/url]\n\ngo fullscreen (if you wish) ONLY once video snapshop taken (at 4.5\" )\n", "tags": ["video", "bluenoise", "short", "pointillism", "penandink", "penink"], "likes": 6, "viewed": 473, "published": 3, "date": "1584081995", "time_retrieved": "2024-07-30T21:19:01.587992", "image_code": "// color version of https://shadertoy.com/view/wslcRn\n\n#define blue(U) texelFetch(iChannel1, ivec2((U-.5)/n*float(S)) % textureSize(iChannel1,0).xy, 0).x\n\n#define N 2\nfloat n = float(N);\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float r = T0(0).a,\n          s = r/R.y; int S = int(.5+1200./R.y);\n    \n    vec4  C = T0( floor(U/n)*n * s ),\n          L = pow(C,vec4(4.));\n    float v = ( 2.*L.r-L.g ) / 2.1, \n          l = 0.;\n    // v = pow(1.5*v,4.);\n    for (int k=0; k<S*S; k++) {\n        vec2 P = vec2(k%S,k/S) - float(S-1)/2.;\n        l += step( blue(U + P/float(S)) , v/2. );\n    }\n    l /= float(S*S);\n  //l = pow(l, 1./2.2);\n    O = vec4(l);\n    \n    O *= 2.*C; // comment for B&W, uncomment for color\n  //O *= mix(vec4(1),2.*C,.3);  // variant: just a touch of colors\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- select a target frame in video\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( iChannelTime[1] < 4.51 )  // 3.93\n         O = T1(U),\n         O.a = R.y; // memorize the size\n    else O = T0(U); \n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define T0(U)  texture(iChannel0,vec2(U)/R)\n#define T1(U)  texture(iChannel1,vec2(U)/R)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 226, 226, 779]], "test": "untested"}
{"id": "tdscRr", "name": "Quadruple voronoi diagram", "author": "michael0884", "description": "Sorting and storing 4 particle id's in 1 texel based on the distance to the texel. Basically the idea is the same as in the shader made by rory618.\nThis allows extremely cheap interactions between particles in theory.", "tags": ["particles"], "likes": 3, "viewed": 486, "published": 3, "date": "1584059053", "time_retrieved": "2024-07-30T21:19:02.363918", "image_code": "\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 grad(ivec2 p)\n{\n    ivec4 sp = get(p);\n    ivec4 spx = get(p+ivec2(1,0));\n    ivec4 spy = get(p+ivec2(0,1));\n    return tanh(100.*(abs(vec4(spx - sp)) + abs(vec4(spy - sp))));\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    ivec4 sp = get(ivec2(iMouse.xy));\n   \n    vec4 p0 = getParticle(sp.x);\n    vec4 p1 = getParticle(sp.y);\n    vec4 p2 = getParticle(sp.z);\n    vec4 p3 = getParticle(sp.w);\n    \n    /*float intensity = gauss(distance(pos, circumcenter(p0.xy, p1.xy, p2.xy)), 0.5*prad);\n    intensity += gauss(distance(pos, circumcenter(p0.xy, p1.xy, p3.xy)), 0.5*prad);\n    intensity += gauss(distance(pos, circumcenter(p2.xy, p1.xy, p3.xy)), 0.5*prad);*/\n    float intensity = gauss(distance(pos, p0.xy), 0.5*prad);\n    intensity += gauss(distance(pos, p1.xy), 0.5*prad);\n    intensity += gauss(distance(pos, p2.xy), 0.5*prad);\n     intensity += gauss(distance(pos, p3.xy), 0.5*prad);\n    \n    vec4 g = grad(p);\n    \n    col.xyz = 1.5*g.xxx + vec3(0.5,0,0)*g.yyy + sin(vec3(1,2,3)*intensity); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nfloat F(float d)\n{\n    return 0.;\n}\n\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    return normalize(p1-p0)*F(distance(p1,p0));\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n        \n        vec2 F = vec2(0.);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F = normalize(iMouse.xy - U.xy)/(d+2.);\n        }\n        \n        U.zw += dt*F;\n        U.xy += U.zw*dt;\n        \n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(5,5)\n#define dt 0.001\n#define prad 5.\n\n//save N last iterations\n#define LN 1.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(fake, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}\n\nvec2 circumcenter(vec2 x, vec2 y, vec2 z)\n{\n    vec2 xy = y - x;\n    vec2 xz = z - x;\n    vec2 a = 0.5*(x+y);\n    vec2 b = 0.5*(x+z);\n    vec2 d = vec2(dot(xy,a), dot(xz,b));\n    float det = determinant(mat2(xy, xz));\n    return vec2(determinant(mat2(d.x, xy.y, d.y, xz.y)),determinant(mat2(xy.x, d.x, xz.x, d.y)))/det;\n}", "buffer_b_code": "ivec4 u;\nvec4 d;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p);\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        //insert\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        //insert\n        d = vec4(d.x, dtemp, d.yz);\n        u = ivec4(u.x, utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        //insert\n        d = vec4(d.xy, dtemp, d.z);\n        u = ivec4(u.xy, utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        //insert\n        d = vec4(d.xyz, dtemp);\n        u = ivec4(u.xyz, utemp);\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(t.x, p);\n    sort(t.y, p);\n    sort(t.z, p);\n    sort(t.w, p);\n}\n\nvoid randupd(ivec2 p)\n{\n    for(int i = 0; i < 4; i++)\n    {\n    \t//go through the entire array sudorandomly\n    \tint t = ((iFrame + p.x + p.y*int(iResolution.x))^(1<<(3*i)))%tot_n;\n    \tsort(t, p);    \n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 3);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //particle indecies \n    u = ivec4(1);\n    d = vec4(1e10); \n   \n    update(p);\n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdscRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 28, 28, 63], [65, 65, 105, 105, 151], [153, 153, 184, 184, 218], [220, 220, 272, 272, 391], [393, 393, 413, 413, 575], [577, 577, 622, 622, 1429]], "test": "untested"}
{"id": "tdlyRr", "name": "float<>int bit reinterpret hash", "author": "michael0884", "description": "Experimenting with intBitsToFloat and floatBitsToInt. The hash probably is super bad", "tags": ["hash", "reinterpret"], "likes": 4, "viewed": 407, "published": 3, "date": "1584051583", "time_retrieved": "2024-07-30T21:19:03.136851", "image_code": "#define s 1048576\n\nfloat hash(float x)\n{\n    return abs(float((1345677*floatBitsToInt(x*x*x))%s)/float(s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord);\n    float rand = hash(uv.x + sqrt(2.)*uv.y + sqrt(5.)*iTime);\n    fragColor = vec4(vec3(rand),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 40, 40, 109], [111, 111, 168, 168, 302]], "test": "untested"}
{"id": "Wssczn", "name": "Day 84", "author": "jeyko", "description": "poto", "tags": ["mdmtjvm"], "likes": 62, "viewed": 2408, "published": 3, "date": "1584045903", "time_retrieved": "2024-07-30T21:19:04.197016", "image_code": "// radial blur and chromatic abberation in this buffer\n// thx iq for pallette and hg-sdf for polarMod\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 30.;\n    float scale = 0.00 + pow(length(uv - 0.5),4.)*0.5;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*3.7;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    float ss = smoothstep(0.,1.,dot(uvn,uvn)*3.);\n    fragColor = radial*1.; \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.4);\n    fragColor *= 18.;\n    fragColor = pow(fragColor, vec4(0.4545));\n    fragColor *= 1. - dot(uvn,uvn)*2.;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime + 3.6)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvec3 att = vec3(1);\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0,vec2(floor(t)/256.)),texture(iChannel0,vec2(floor(t) + 1.)/256.), smoothstep(0.,1.,fract(t)));\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    float modD = 3.;\n    float idz = floor(p.z/modD);\n    p.z = pmod(p.z, modD);\n    \n    \n    vec3 q = p;\n    vec3 b = p;\n    float idb = pModPolar(q.xy, 3.);\n    //b.xy *= rot(idz*0.5);\n    pModPolar(b.xy, 3.);\n    \n    b.x -= 0.8;\n    \n    vec3 u = p;\n    \n    //u.xy *= rot(idz);\n    float o = pModPolar(u.xy, 5.);\n    u.x -= 1.;\n    \n    q.x -= 0.8;\n    \n    float dG = -u.x;\n    d = dmin(d, vec2(dG, 3.));\n    \n    \n    \n    \n    //u -= 0.1;\n    u.y = abs(u.y);\n    u.y -= 0.7;\n    dG = length(u.xy) - 0.02;\n    d = dmin(d, vec2(dG, 8.));\n    \n        //glow += 0.2/(0.01 + dG*dG*2.)*att;\n\t//q = abs(q);\n    //q.xy *= rot(-1.5);\n    //q.x -= 0.2;\n    vec3 z = q;\n    z = abs(z) - vec3(0.01,0.4,0.1);\n    float dC = max(z.z, max(z.y, z.x));\n    d = dmin(d, vec2(dC, 0.));\n    z = q;\n    z.x += 0.02;\n    z = abs(z) ;\n    z -= vec3(0.01,0.3,0.02);\n    float dCb = max(z.z, max(z.y, z.x));\n    d = dmin(d, vec2(dCb, 1.));\n    \n    \n    \n    z = b;\n    z.y -= 0.2;\n    z.x += 0.3;\n    z.z += modD*0.10;\n    z.xy *= rot(0.7 + sin(iTime*0.2 + idz*0.5));\n    z = abs(z);\n    z.zx *= rot(-0.1);\n    z = abs(z) - vec3(0.01,0.5,0.04);\n    float dD = max(z.z,max(z.x, z.y));\n    \n    d = dmin(d, vec2(dD, 5.));\n    \n    \n    z = u;\n    z.y -= 0.2;\n    z.x += 0.3;\n    z.z -= modD*0.25;\n    \n    z = abs(z);\n    z.xz *=rot(0.25*PI);\n    z.x -= 0.4;\n    z.xy *=rot(0.25*PI);\n    \n    //z.x -= 0.08;\n    z = abs(z) - vec3(0.07,0.1,0.04);\n    float dDd = max(z.z,max(z.x, z.y));\n    //d = dmin(d, vec2(dDd, 5.));\n    \n    \n    vec4 a = valueNoise((idb + iTime*3. + idz*3.));\n    \n    //vec3 c = max(pal(0.7,1., vec3(3.7,0.3,0.6), 0.6,4.4 + sin(iTime) + sin(idz * idb)*0.2), 0.);\n    vec3 c = max(pal(0.7,1., vec3(3.,0.3,0.1), 0.6,4.4 + sin(iTime) + idz + sin(idz * idb)*0.2), 0.1);\n    \n    glow += pow(smoothstep(0.,1.,a.z*1.5), 20.)*1.5/(0.005 + dCb*dCb*(90. - a.x*20.))*att*c* pow(smoothstep(1.,0.,length(q.y*1.)), 5.);\n    //glow += pow(smoothstep(0.,1.,a.z*1.5), 20.)*1.5/(0.005 + dCb*dCb*(100. - a.x*20.))*att*c;\n    //glow += pow(smoothstep(0.,1.,a.z*1.5), 20.)*1.5/(0.005 + dCb*dCb*(90. - a.x*20.))*att*c* (smoothstep(1.,0.,length(q.y*1.6)));\n    //glow += pow(smoothstep(0.,1.,a.z*1.5), 20.)*0.01/(0.0004 + dCb*dCb*dCb*dCb*(50. - a.x*20.))*att*c;\n    \n    //glow += pow(smoothstep(0.,1.,a.z*1.5), 20.)*exp(-dCb*30.)*att*c*30.;\n    //glow += pow(smoothstep(0.,1.,a.z*1.5), 20.)*0.6/(0.004 + dCb*dCb*(20. - a.x*20.))*att*c;\n    \n    return d;\n}\nfloat dith;\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n\n    p = ro; t = 0.; hit = false;\n    for(int i = 0; i < 230 ; i++){\n    \td = map(p);\n        d.x *= dith;\n        \n    \t//glow += exp(-d.x*20.);\n        if(d.x < 0.002){\n        \thit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //\n\tuv *= 1. - dot(uv,uv)*0.14;\n    \n    uv.xy *= rot((iTime - 3.6)*0.1);\n    \n    vec3 col = vec3(0);\n\n    dith = mix(0.8,1., texture(iChannel0, 20.*uv*256.).x);\n    vec3 ro = vec3(0);\n    \n    ro.z += iTime*1.5;\n    \n    vec3 rd = normalize(vec3(uv,2.));\n    //rd.yz *= rot(iTime);\n    \n    vec3 p; float t; bool hit;\n    float side = 1.;\n    float tA;\n    \n    for(int i = 0; i < 3; i ++){\n    \tvec2 d = march(ro, rd, p, t, hit);\n    \tvec3 n = getNormal(p);\n        \n        vec3 ld = normalize(vec3(1));\n        vec3 h = normalize(ld - rd);\n        \n        float diff = max(dot(n, ld), 0.);\n        float spec = pow(max(dot(n, -h), 0.), 10.);\n        float fres = pow(1. - max(dot(n, -rd), 0.), 5.);\n        \n        if(i == 0){\n        \ttA = t;\n        }    \n        if(d.y == 5.){\n        \t//col += fres*0.1*att*(glow);\n            col += fres*0.06*att*(glow);\n        }\n        if(d.y == 8.){\n        \tcol += fres*0.02*att*(glow);\n            //col += fres*20.*att;\n        }\n        if (d.y == 3.){\n        \trd = reflect(rd, n);\n            att *= vec3(0.6,0.8,0.8)*0.2;\n            col += spec*0.04*att;\n            ro = p + n*0.2;\n        } else {\n        \tbreak;\n        }\n    }\n    \n    \n    col += glow*0.001;\n    \n    col = mix(col, vec3(0.4,0.4,0.7)*0.004, pow(smoothstep(0.,1.,tA*0.013), 1.6));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21490, "src": "https://soundcloud.com/the-algorithm/the-algorithm-floating-point", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wssczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 161, 161, 1211]], "test": "untested"}
{"id": "wdsyzn", "name": "Squared Numbers Grid", "author": "BackwardsCap", "description": "Trying to help https://www.shadertoy.com/view/wssyRn with a potential solution", "tags": ["grid", "id", "squarednumbers"], "likes": 4, "viewed": 414, "published": 3, "date": "1584040919", "time_retrieved": "2024-07-30T21:19:05.065694", "image_code": "#define p 1.25\n\n/*\nfloat applyRound(float i)\n{\n    if(fract(i)<0.5)return floor(i);\n    return ceil(i);\n}\n*/\n\nbool isPower(float id)\n{\n    //thanks to rory618 for pointing out the err of my ways with floating point values\n    return floor(pow(id-.5,1.0/p))!=floor(pow(id+.5,1.0/p));\n\n    \n    //my alternate solution that would be WAY faster but I still don't quite understand why it doesnt work\n    \n    //return 0.0==fract(pow(id,1.0/p));\n    //this works for p==2.0 but everything else does not work\n    \n    //for(int i=0;i<n;i++)\n    //{\n    //    if(id==round(pow(float(i),p))) return true;\n    //}\n    //return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //adjust aspect ratio\n    float ratio=iResolution.x/iResolution.y;\n    uv.x*=ratio;\n    \n    //scale our grid\n    float size = 200.;\n    uv*=size/ratio;\n    \n    \n    \n    //get our cell id, starting 0 at bottom left, counting up looping each row\n    float id = floor(uv.x+floor(uv.y)*size);\n    \n    //output variables and the size of our grid lines\n    float o = 0., l=0., gline=size/iResolution.x;\n   \t\n    //if our id is in the array we calculated, set it white\n    if(isPower(id))o=1.;\n    \n    //add grid lines\n    uv=fract(uv);\n    if(uv.x<gline||uv.y<gline) l = 1.0;\n    \n    //set the output color\n    fragColor.rgb = vec3(l+o);\n    //if floor(iTime)^2 == our cell id, set it red \n    if(round(pow(floor(iTime),p))==id&&l==0.)fragColor.rgb=vec3(1,0,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 134, 221, 626], [628, 628, 685, 685, 1498]], "test": "untested"}
{"id": "tdlyzn", "name": "Circular Distribution", "author": "BackwardsCap", "description": "I just watched Numberphile's golden ratio video and wanted to make this super unoriginal visualization", "tags": ["distribution", "ratio"], "likes": 5, "viewed": 405, "published": 3, "date": "1584038553", "time_retrieved": "2024-07-30T21:19:05.967284", "image_code": "void mainImage( out vec4 c, in vec2 f )\n{ \n    c.rgb = texture(iChannel0,f/iResolution.xy).rgb;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define px 3./iResolution.y\n#define PI 3.1415927\n#define PHI 1.61803398875\n#define SS(A,B,C) smoothstep(A,B,C)\n#define circle(A,B) SS(px,0.,length(A)-B)*SS(0.,px,length(A)-B/1.5)\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    vec2 uv = (2.0*f.xy-iResolution.xy) / iResolution.y;\n    float n = 1500.,size = .01, o = 0.;\n    for(float i=0.;i<n;i++)\n    {        \n        size*=.9985;\n        uv*=rot(PHI*sin(iTime/400.0));\n        o+=circle(uv+vec2(0,1.5*i/n),size);\n    }\n    c.rgb=vec3(o)+.65*texture(iChannel0,f/iResolution.xy).rgb*vec3(cos(uv.x-iTime),sin(uv.y+iTime),sin(iTime-uv.y/10.0));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 97]], "test": "untested"}
{"id": "wslcRn", "name": "pointillism - 2", "author": "FabriceNeyret2", "description": "ref image: [url]https://www.instagram.com/p/B9eSSDKph-T/[/url]\nWIP.\n\ngo fullscreen (if you wish) ONLY once video snapshop taken (at 4.5\" )\n", "tags": ["video", "bluenoise", "short", "pointillism", "penandink", "penink"], "likes": 9, "viewed": 519, "published": 3, "date": "1584037117", "time_retrieved": "2024-07-30T21:19:06.865881", "image_code": "// Fork of pointillism-1 https://shadertoy.com/view/wdlcRn\n\n#define blue(U) texelFetch(iChannel1, ivec2((U-.5)/n*float(S)) % textureSize(iChannel1,0).xy, 0).x\n\n#define N 2\nfloat n = float(N);\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float r = T0(0).a,\n          s = r/R.y; int S = int(.5+1200./R.y);\n    \n    vec4  C = T0( floor(U/n)*n * s ),\n          L = pow(C,vec4(4.));\n    float v = ( 2.*L.r-L.g ) / 2.1, \n          l = 0.;\n    // v = pow(1.5*v,4.);\n    for (int k=0; k<S*S; k++) {\n        vec2 P = vec2(k%S,k/S) - float(S-1)/2.;\n        l += step( blue(U + P/float(S)) , v/2. );\n    }\n    l /= float(S*S);\n  //l = pow(l, 1./2.2);\n    O = vec4(l);\n    \n // O *= C; // comment for B&W, uncomment for color\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- select a target frame in video\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( iChannelTime[1] < 4.51 )  // 3.93\n         O = T1(U),\n         O.a = R.y; // memorize the size\n    else O = T0(U); \n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define T0(U)  texture(iChannel0,vec2(U)/R)\n#define T1(U)  texture(iChannel1,vec2(U)/R)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 231, 231, 714]], "test": "untested"}
{"id": "3dlcRr", "name": "picsArt shader 1", "author": "Valdex", "description": "shader from picsArt", "tags": ["picsart"], "likes": 1, "viewed": 389, "published": 3, "date": "1584017062", "time_retrieved": "2024-07-30T21:19:07.816340", "image_code": "#define scaleFactor 1.\n#define textureSize iChannelResolution[0]\n#define type 3.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec4 vColor = texture(iChannel0, uv);\n    \n    float fXIndex = uv.x*iChannelResolution[0].x;\n    float fYIndex = uv.y*iChannelResolution[0].x;\n    mat3 convolutionMatrix = mat3(0.);\n    if (type == 1.) {\n        \n  \t\tconvolutionMatrix = mat3( 0.045, 0.122, 0.045,\n                                  0.122, 0.332, 0.122,\n  \t\t\t\t\t\t\t\t  0.045, 0.122, 0.045); // gaussian\n  \n    } else if (type == 2.) {\n\n  \t\tconvolutionMatrix = mat3(  -1.0, -1.0, -1.0,\n    \t\t\t\t\t\t\t   -1.0,  9.0, -1.0,\n    \t\t\t\t\t\t\t   -1.0, -1.0, -1.0);  // unsharpen\n\n    } else {\n\n    \tconvolutionMatrix = mat3( -2.0, -1.0,  0.0,\n       \t\t\t\t\t\t\t  -1.0,  1.0,  1.0,\n       \t\t\t\t\t\t\t   0.0,  1.0,  2.0);  //emboss\n        \n    }\n    \n    if( ! ( fYIndex < 1.0 || fYIndex > iChannelResolution[0].y - 1.0 || \n            fXIndex < 1.0 || fXIndex > iChannelResolution[0].x - 1.0 ))\n    {\n    \tfloat redXSum = vColor.r*convolutionMatrix[1][1];\n    \t//float redYSum = 0.0;\n    \n    \tfloat greenXSum = vColor.g*convolutionMatrix[1][1];\n    \t//float greenYSum = 0.0;\n    \n    \tfloat blueXSum = vColor.b*convolutionMatrix[1][1];\n    \t//float blueYSum = 0.0;\n    \t\n    \tfloat fTempX = ( fXIndex  -1.0 + 0.5 ) / iChannelResolution[0].x ;\n        float fTempY = ( fYIndex  -1.0 + 0.5 ) / iChannelResolution[0].y ;\n        vec4 vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum + convolutionMatrix[0][0]*vTempColor.r;\n        greenXSum = greenXSum + convolutionMatrix[0][0]*vTempColor.g;\n        blueXSum = blueXSum +  convolutionMatrix[0][0]*vTempColor.b;\n        \n        fTempX = ( fXIndex +scaleFactor + 0.5 ) / textureSize.x;\n        fTempY = ( fYIndex  -scaleFactor + 0.5 ) / textureSize.y;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum + convolutionMatrix[0][2]*vTempColor.r;\n        greenXSum = greenXSum + convolutionMatrix[0][2]*vTempColor.g;\n        blueXSum = blueXSum + convolutionMatrix[0][2]*vTempColor.b;\n        \n        fTempX = ( fXIndex -scaleFactor + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex  + 0.5 ) / textureSize.y ;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum+convolutionMatrix[1][0]*vTempColor.r;\n        greenXSum = greenXSum+convolutionMatrix[1][0]*vTempColor.g;\n        blueXSum = blueXSum+convolutionMatrix[1][0]*vTempColor.b;\n        \n        fTempX = ( fXIndex +scaleFactor + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex  + 0.5 ) / textureSize.y ;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum+convolutionMatrix[1][2]*vTempColor.r;\n        greenXSum = greenXSum+convolutionMatrix[1][2]*vTempColor.g;\n        blueXSum = blueXSum+convolutionMatrix[1][2]*vTempColor.b;\n        \n        fTempX = ( fXIndex -scaleFactor + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex +scaleFactor + 0.5 ) / textureSize.y ;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum +convolutionMatrix[2][0]*vTempColor.r;\n        greenXSum = greenXSum +convolutionMatrix[2][0]*vTempColor.g;\n        blueXSum = blueXSum + +convolutionMatrix[2][0]*vTempColor.b;\n        \n        fTempX = ( fXIndex +scaleFactor + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex +scaleFactor + 0.5 ) / textureSize.y ;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n         // X Direction\n        redXSum = redXSum +convolutionMatrix[2][2]*vTempColor.r;\n        greenXSum = greenXSum +convolutionMatrix[2][2]*vTempColor.g;\n        blueXSum = blueXSum +convolutionMatrix[2][2]*vTempColor.b;\n        \n        \n        fTempX = ( fXIndex  + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex -scaleFactor + 0.5 ) / textureSize.y;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum + convolutionMatrix[0][1]*vTempColor.r;\n        greenXSum = greenXSum + convolutionMatrix[0][1]*vTempColor.g;\n        blueXSum = blueXSum + convolutionMatrix[0][1]*vTempColor.b;\n        \n        fTempX = ( fXIndex  + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex +scaleFactor + 0.5 ) / textureSize.y;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        \n        redXSum = redXSum + convolutionMatrix[2][1]*vTempColor.r;\n        greenXSum = greenXSum + convolutionMatrix[2][1]*vTempColor.g;\n        blueXSum = blueXSum + convolutionMatrix[2][1]*vTempColor.b;\n        \n        \n        \n        float oneFloat = float(1.0);\n        float zeroFloat = float(0.0);\n        \n        if(redXSum<zeroFloat){\n        \tredXSum = zeroFloat;\n        }\n        \n        if(redXSum>oneFloat){\n        \tredXSum = oneFloat;\n        }\n        \n        if(greenXSum<zeroFloat){\n        \tgreenXSum = zeroFloat;\n        }\n        \n        if(greenXSum>oneFloat){\n        \tgreenXSum = oneFloat;\n        }\n        \n        \n        if(blueXSum<zeroFloat){\n        \tblueXSum = zeroFloat;\n        }\n        \n        if(blueXSum>oneFloat){\n        \tblueXSum = oneFloat;\n        }\n        /*\n        redXSum = 1.0 - redXSum;\n        greenXSum = 1.0-greenXSum;\n        blueXSum = 1.0-blueXSum;\n        \n        float sum = (redXSum+greenXSum+blueXSum)/3.0;*/\n        \n        vColor.r = redXSum;\n        vColor.g = greenXSum;\n        vColor.b = blueXSum;\n        //vColor = vec4((1.0-fRedTotalSum),(1.0-fGreenTotalSum),(1.0-fBlueTotalSum),vColor.a);\n    }\n    else\n    {\n    \tvColor.r=1.0;\n    \tvColor.g = 1.0;\n    \tvColor.b = 1.0;\n    }\n    \n    fragColor = vColor;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 138, 138, 5865]], "test": "untested"}
{"id": "Wdsczn", "name": "V Pathogen Path to Power", "author": "RaduBT", "description": "V For Vendetta - Pathogen Path To Power\n\nAdapted from Protean clouds Has been Shader of the Week!\nCreated by nimitz in 2019-05", "tags": ["3d", "fast", "volumetric"], "likes": 13, "viewed": 997, "published": 3, "date": "1584009511", "time_retrieved": "2024-07-30T21:19:08.676041", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n   \n\tfloat fft1 = (texture(iChannel0, p).xyz,1.0);\n \n    float fft = 0.15 + 1.116 *(((texture( iChannel0, vec2(p.y+5.0, 5.0) ).x)) * 3.51);\n    \n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb*fft1*.865;\n    col = iLerp(col.bgr, col.rgb*fft, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( fft*16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 21489, "src": "https://soundcloud.com/radubt/v-for-vendetta-pathogen-path-to-power", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdsczn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1132, 1153, 1153, 1205], [1317, 1317, 1336, 1336, 1353], [1354, 1354, 1406, 1406, 1450], [1490, 1490, 1509, 1509, 1560], [1562, 1562, 1580, 1580, 2107], [2109, 2109, 2160, 2160, 3194], [3196, 3196, 3218, 3218, 3333], [3335, 3408, 3454, 3454, 3800], [3802, 3802, 3859, 3859, 5129]], "test": "untested"}
{"id": "3slyzn", "name": "Mandalay Canyon", "author": "dr2", "description": "Traverse a fractal landscape with smooth transitions to avoid aliasing (mouseable)", "tags": ["fractal", "raymarch", "landscape"], "likes": 8, "viewed": 503, "published": 3, "date": "1584008732", "time_retrieved": "2024-07-30T21:19:09.447977", "image_code": "// \"Mandalay Canyon\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Traverse a fractal landscape with smooth transitions to avoid aliasing (mouseable).\n\n// More info in \"Mandalay Fractal\" (https://www.shadertoy.com/view/wstXD8)\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 HsvToRgb (vec3 c);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir, pFold;\nfloat dstFar, mScale, tDisc;\nconst float pi = 3.14159;\n\nconst float itMax = 12.;\n\nfloat PPFoldD (vec3 p)\n{\n  vec3 s;\n  p.y = max (p.y, p.z);\n  s = vec3 (p.x, max (abs (p.x - pFold.x) - pFold.x, p.y - 4. * pFold.x),\n     max (p.x - 2. * pFold.x - pFold.y, p.y - pFold.z));\n  return Minv3 (s);\n}\n\nvec3 PPFold (vec3 p)\n{\n  return vec3 (PPFoldD (p), PPFoldD (p.yzx), PPFoldD (p.zxy));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 p4;\n  float pp;\n  p.xz = mod (p.xz + 1., 2.) - 1.;\n  p4 = vec4 (p, 1.);\n  for (float j = 0.; j < itMax; j ++) {\n    p4.xyz = 2. * clamp (p4.xyz, -1., 1.) - p4.xyz;\n    p4.xyz = - sign (p4.xyz) * PPFold (abs (p4.xyz));\n    pp = dot (p4.xyz, p4.xyz);\n    p4 = mScale * p4 / clamp (pp, 0.25, 1.) + vec4 (p, 1.);\n  }\n  return length (p4.xyz) / p4.w;\n}\n\nfloat ObjCf (vec3 p)\n{\n  vec4 p4;\n  float pp, ppMin, cn;\n  p.xz = mod (p.xz + 1., 2.) - 1.;\n  p4 = vec4 (p, 1.);\n  cn = 0.;\n  ppMin = 1.;\n  for (float j = 0.; j < itMax; j ++) {\n    p4.xyz = 2. * clamp (p4.xyz, -1., 1.) - p4.xyz;\n    p4.xyz = - sign (p4.xyz) * PPFold (abs (p4.xyz));\n    pp = dot (p4.xyz, p4.xyz);\n    p4 = mScale * p4 / clamp (pp, 0.25, 1.) + vec4 (p, 1.);\n    if (pp < ppMin) {\n      cn = j;\n      ppMin = pp;\n    }\n  }\n  return cn;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi, eps;\n  eps = 0.0005;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    h = ObjDf (ro + s * rd);\n    if (h < eps || s > dstFar) {\n      sHi = s;\n      break;\n    }\n    sLo = s;\n    s += h;\n  }\n  if (h < eps) {\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (ObjDf (ro + s * rd) > eps) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.01, 0.1);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (float j = float (VAR_ZERO) + 1.; j < 4.; j ++) {\n    d = 0.02 * j;\n    ao += max (0., d - ObjDf (ro + d * rd));\n  }\n  return 0.4 + 0.6 * clamp (1. - 5. * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh, ao;\n  pFold = HsvToRgb (vec3 (0., 0.2, 1.));\n  mScale = 3.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    ao = ObjAO (ro, vn);\n    sh = min (ObjSShadow (ro, ltDir), ao);\n    col = HsvToRgb (vec3 (mod (0.02 * tDisc + 0.06 * ObjCf (ro), 1.), 0.5, 1.));\n    col = col * (0.2 * ao + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.4 * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 4.);\n  } else col = vec3 (0.4, 0.4, 0.5);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col[2];\n  vec2 canvas, uv;\n  float tCur, tStep, el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  zmFac = 1.2;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.) + 11.1;\n  dstFar = 10.;\n  ltDir = normalize (vec3 (0.3, 1.5, -1.));\n  tStep = 2.;\n  if (mPtr.z > 0.) {\n    az = 0.;\n    el = -0.05 * pi;\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n    el = clamp (el, -0.49 * pi, 0.1 * pi);\n  }\n  for (int k = VAR_ZERO; k <= 1; k ++) {\n    tDisc = tStep * (float (k) + floor (tCur / tStep));\n    if (mPtr.z <= 0.) {\n      az = 0.;\n      el = -0.05 * pi;\n      az += 0.1 * pi * cos (0.013 * 2. * pi * tDisc);\n      el += 0.06 * pi * cos (0.01 * 2. * pi * tDisc);\n    }\n    rd = StdVuMat (el, az) * normalize (vec3 (uv, zmFac));\n    ro = vec3 (1., 4.1, 0.07 * tDisc);\n    col[k] = ShowScene (ro, rd);\n  }\n  fragColor = vec4 (mix (col[0], col[1], smoothstep (0.1, 0.9, fract (tCur / tStep))), 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyzn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[535, 535, 559, 559, 746], [748, 748, 770, 770, 835], [837, 837, 859, 859, 1214], [1216, 1216, 1238, 1238, 1669], [1671, 1671, 1704, 1704, 2158], [2160, 2160, 2181, 2181, 2438], [2440, 2440, 2477, 2477, 2725], [2727, 2727, 2759, 2759, 2961], [2963, 2963, 2998, 2998, 3577], [4742, 4742, 4766, 4766, 4883], [4885, 4885, 4907, 4907, 4945], [4947, 4947, 4983, 4983, 5189], [5191, 5191, 5221, 5221, 5334]], "test": "untested"}
{"id": "WsXyRn", "name": "Volumetric Shadow", "author": "Txoka", "description": "VOl", "tags": ["volume"], "likes": 4, "viewed": 353, "published": 3, "date": "1584003334", "time_retrieved": "2024-07-30T21:19:10.336601", "image_code": "struct ray{\n    vec3 ro,rd;\n};\nstruct triangle{\n    vec3 p0,p1,p2;\n};\nfloat intersect(ray r,triangle t,out vec3 normal){\n\tvec3 e0 = t.p1 - t.p0;\n\tvec3 e1 = t.p2 - t.p0;\n\n\tvec3 n = cross(e0, e1);\n\tfloat d2 = dot(n, n);\n\tvec3 m = n * (1.0 / d2);\n\tn = m * sqrt(d2);\n\tnormal=n*sign(-dot(r.rd,n));\n    \n\tfloat dot_nd = dot(n, r.rd);\n\tfloat d = dot(t.p0 - r.ro, n) / dot_nd;\n\tvec3 p = r.ro + d * r.rd;\n            \n\tvec3 b;\n\tb.y = dot(cross(p - t.p2, e1), m);\n\tb.z = dot(cross(e0, p - t.p0), m);\n\tb.x = 1.0 - (b.y + b.z);\n    if(b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0)return max(0.,d);\n    return 0.;\n}\nfloat gamma=1.8;\nconst float pi=4.*atan(1.);\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat suc(ray r,float l,vec3 center,float radius){\n    vec3 o=r.ro-center;\n    \n    float a=dot(o,o);\n    float b=dot(r.rd,o);\n    float c=dot(r.rd,r.rd);\n    \n    float k=sqrt(a*c-b*b);\n    float w=b+c*l;\n    //integral =radius*atan(w/k)/k\n    float integ=radius*(atan(w,k)-atan(b,k))/k;\n    return integ;\n}\n\n\n\n\n\n\n\ntriangle t=triangle(vec3(0,1,0),vec3(2,1,2),vec3(0,3,0));\nvec3 light=vec3(2,0,0);\n\nfloat shadow(ray r){\n\tvec3 p0_=normalize(t.p0-light)*1000.+t.p0;\n    vec3 p1_=normalize(t.p1-light)*1000.+t.p1;\n    vec3 p2_=normalize(t.p2-light)*1000.+t.p2;\n    \n    vec3 n;\n    float l=0.;\n    float u;\n    u=intersect(r,triangle(t.p0,t.p1,p0_),n);if(u!=0.){if(l==0.){l=u;}l=min(l,u);}\n    u=intersect(r,triangle(t.p1,t.p2,p1_),n);if(u!=0.){if(l==0.){l=u;}l=min(l,u);}\n    u=intersect(r,triangle(t.p2,t.p0,p2_),n);if(u!=0.){if(l==0.){l=u;}l=min(l,u);}\n    \n    u=intersect(r,triangle(t.p1,p1_,p0_),n);if(u!=0.){if(l==0.){l=u;}l=min(l,u);}\n    u=intersect(r,triangle(t.p2,p2_,p1_),n);if(u!=0.){if(l==0.){l=u;}l=min(l,u);}\n    u=intersect(r,triangle(t.p0,p0_,p2_),n);if(u!=0.){if(l==0.){l=u;}l=min(l,u);}\n    \n    return l;\n}\n\n\nvec3 render(ray r){\n    vec3 res=vec3(0.);\n    vec3 n;\n    \n    ray q=r;\n   \t\n    \n    float l=shadow(r);\n    if(l==0.)l=100.;\n    \n    \n    float n1=suc(r,l,light,0.2);\n    r.ro+=r.rd*(l+0.001);\n    \n    \n    \n    l=shadow(r);\n    if(l==0.)l=100.;\n    \n    //n1+=suc(r,l,light,0.2);\n    r.ro+=r.rd*l;\n    \n    n1+=suc(r,1000.,light,0.2);\n    \n    n1=clamp(0.,1.,n1);\n    \n    \n    \n    \n    //only need hue but does not matter, its 60+fps anyway\n\tres+=pow(n1*hsv2rgb(vec3(iTime,1,1)),vec3(gamma));\n\tl=intersect(q,t,n);\n    \n    if(l!=0.){\n        vec3 p=r.ro+r.rd*l;\n        res+=max(0.,dot(n,-normalize(p-light)));\n    }\n    return vec3(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //ray origin and dir\n    vec3 uv = vec3((fragCoord*2.-iResolution.xy)/iResolution.y,-5);\n    \n    \n    vec2 m=(iMouse.xy*2.-iResolution.xy)/iResolution.xy;\n    m*=vec2(1,0.5)*pi;\n\n    if(iMouse.z<=0.)m=vec2(-iTime/3.,0.05);\n    #ifdef eyes\n    vec3 ro=vec3(-0.2,0,-4);\n    if(uv.x<0.)ro.x=0.2;\n    uv.xy+=ro.xy*5.;\n    #else\n    vec3 ro=vec3(0,0,-6);\n    #endif\n    \n    ro.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    ro.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    uv.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    uv.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    \n    vec3 rd=normalize(uv-ro);\n   \t\n    ray r=ray(ro,rd);\n    \n    vec3 col=render(r);\n    \n    fragColor=vec4(pow(col,vec3(1./gamma)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 120, 120, 596], [643, 643, 665, 665, 834], [835, 835, 885, 885, 1143], [1234, 1234, 1254, 1254, 1959], [1962, 1962, 1981, 1981, 2608], [2610, 2610, 2666, 2691, 3402]], "test": "untested"}
{"id": "wdXczn", "name": "Day 83", "author": "jeyko", "description": "theres some z fighting", "tags": ["mdtmjvm"], "likes": 10, "viewed": 1083, "published": 3, "date": "1583969847", "time_retrieved": "2024-07-30T21:19:11.284069", "image_code": "// theres some z fighting\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 60.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.8)*0.7;\n    float chromAb = dot(uvn,uvn)*5.;\n    vec2 offs = vec2(0) + texture(iChannel1, uv + iTime*4.).xz*0.;\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.99 ;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.x += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.y += texture(iChannel0, target).y;\n    \tradial.z += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    \n    \n    \n    radial /= steps;\n    \n    float ss = smoothstep(0.,1.,dot(uvn,uvn)*3.);\n    \n    fragColor = texture(iChannel0, uv)*0. + radial*1.4; \n    fragColor *= 0.23;\n    \n    fragColor = mix(fragColor, smoothstep(0.,1.,fragColor), 1.);\n    \n    \n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    //fragColor *= 1.;\n    //fragColor = pow(fragColor, vec4(0.45));\n\t\n    float duvuv = dot(uvn,uvn);\n    \n    //fragColor = pow(fragColor, vec4(0.49 - clamp(duvuv*0.4, 0., 0.50)));\n    \n    //fragColor = smoothstep(0.,1.,fragColor);\n    //fragColor = pow(fragColor, vec4(0.5,0.65,0.52,1.));\n    fragColor = max(fragColor, 0.);\n    fragColor *= 3.;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + dot(uvn,uvn)*0.5));\n    //fragColor *= 1. - duvuv*1.;\n\t//fragColor *= vec4(0.9,1.05,0.9,1.);\n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    //fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\n#define dmin(a, b) a.x < b.x ? a : b\n#define PI acos(-1.)\n#define tau (2.*PI)\n#define rot(x) mat2(cos(x),sin(x),sin(x),cos(x))\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvec3 path(float z){\n    z *= 0.3;\n\treturn vec3(cos(\n        z*0.7\n    \t+ cos(z*0.6)*0.2\n    \t- sin(z*0.7 + 2.)*0.2\n    ), sin(\n        z\n    \t+ cos(z*0.6)*0.2\n    \t- sin(z*0.7 + 2.)*0.2\n    ), 0.)*0.5;\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e7);\n\n    \n    p -= path(p.z);\n    \n    float modD = 4.;\n    vec3 q = p;\n    q.z = pmod(q.z, modD);\n    float i = pModPolar(q.xy, 5.);\n    \n    q.x -= 0.5;\n    vec3 z = q;\n    \n    z = abs(z);\n    \n    z -= 0.5;\n    \n    z.y -= 0.04;\n    z.x += 0.05;\n    z = abs(z);\n    z.x -= 0.02;\n    z = abs(z);\n    z.x -= 0.07;\n    z.xy *= rot(2.5);\n    //z += 0.01;\n    //float dP = length(q.xy - vec2(0.2,0.)) - 0.04;\n    //float dP = max(abs(q.x) - 0.1,abs(q.y)- 0.1);\n    \n    \n    vec3 u = z;\n    u.x += 0.1;\n    u.z -= modD*0.25;\n    u.xz *= rot(-0.6);\n    //u.y += 0.02;\n    u = abs(u)- vec3(0.01,0.22,0.95);\n    //u.y += 0.08;\n    float dPb = max((u.x),max((u.y), (u.z)));\n    \n    \n    \n    u = abs(z) - vec3(0.01,0.22,0.15);\n    u.x += 0.002;\n    float dPa = max((u.x),max((u.y), (u.z)));\n    \n    u = abs(z) - vec3(0.006,0.12,0.95);\n    float dP = max((u.x),max((u.y), (u.z)));\n    \n    \n    u = z;\n    z.x -= 0.03;\n    u = abs(z);\n    u -= vec3(0.01,0.12,0.95);\n    float dPc = max((u.x),max((u.y), (u.z)));\n    \n    glow +=  0.5/(0.01+dPc*dPc*4000.)*8.*pal(0.6,0.3,vec3(3.6,1.,.6),.9,3.9);\n\n    d = dmin(d, vec2(dP, 0.));\n    d = dmin(d, vec2(dPa, 2.));\n    d = dmin(d, vec2(dPb, 3.));\n    d = dmin(d, vec2(dPc, 4.));\n    \n    //glow +=  0.005/(0.1+dP*dP*20.)*8.*pal(0.6,0.3,vec3(3.6,1.,.6),.9,2.9);\n    \n    z = q;\n    z.x -= 0.1;\n    z = abs(z) - vec3(0.01,0.02,0.);\n    z.y -= 0.05;\n    float dPipe = length(z.xy)- 0.01;\n    d = dmin(d, vec2((dPipe) , 1.));\n    \n    glow += 0.4/(0.02+dPipe*dPipe*120.)*pal(0.6,0.3,vec3(3.6,4.,2.6),0.9,0.9);\n    \n    d.x *= 0.64;\n    return d;\n}\nfloat N;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d;\n\n    \n    p = ro; t = 0.; hit = false;\n    for(int i = 0; i < 280 ; i++){\n    \td = map(p);\n        d.x *= N;\n        //glow += exp(-d.x);\n        if(d.x < 0.0006){\n        \thit = true;\n            break;\n        }\n        \n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n\t\n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir ));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.001,0);\n    return normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    N = mix(0.6,1., texture(iChannel0,20.*uv*256.).x);\n\tuv *= 1. + dot(uv,uv)*0.1;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += iTime*4.;\n    \n    ro += path(ro.z);\n    \n    //vec3 rd = normalize(vec3(uv,1));\n    \n    vec3 lookAt = ro + vec3(0,0,4);\n    lookAt += path(lookAt.z);\n    vec3 rd = getRd( ro, lookAt,  uv);\n    \n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    col += pow(glow*0.4, vec3(1.))*0.01;\n    if(hit){\n        vec3 n = getNormal(p);\n        vec3 ld = normalize(vec3(1));\n        vec3 h = normalize(ld - rd);\n        \n        float diff = max(dot(n, ld), 0.);\n        float spec = pow(max(dot(n, -h), 0.), 10.);\n        float fres = pow(1. - max(dot(n, -rd), 0.), 5.);\n        \n        \n        if(d.y == 0.){\n        \tcol *= 0.5 + fres*0.5;\n        } if(d.y == 1.){\n        \tcol *=0.5 + fres*1.;\n            \n        \t//col += 4.4;\n        } else if(d.y == 2.){\n        \tcol *= 0.6 + diff*fres*1.;\n            \n        \t//col += 4.4;\n        } else if(d.y == 3.){\n        \tcol *= (0.6 + diff*fres + spec*2.6);\n            \n        \t//col += 0.7;\n        } else{\n        \tcol *= fres*1.;\n        \n        }\n        \n        //col += diff*0.006;\n        //col += 0.75 + n;\n        \n    } else {\n    \n    }\n    \n    \n    \n    //col = mix(col, vec3(0.01), smoothstep(0.,1.,(p.z - ro.z)*0.04));\n    //col = mix(col, vec3(0.04,0.05,0.08)*0.1, smoothstep(0.,1.,(t)*0.1));\n    //col = mix(col, vec3(0.04,0.05,0.08)*0.3, smoothstep(0.,1.,(p.z - ro.z)*0.08));\n    col = mix(col, vec3(0.03,0.03,0.08)*1.3, smoothstep(0.,1.,(p.z - ro.z)*0.06));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 1750]], "test": "untested"}
{"id": "wsXyRn", "name": "Fractal Lava", "author": "jarble", "description": "I added some sine-wave distortion to my [url=https://www.shadertoy.com/view/3lyXR3]\"fractal fire\"[/url] shader.", "tags": ["fractal", "lava"], "likes": 1, "viewed": 390, "published": 3, "date": "1583958832", "time_retrieved": "2024-07-30T21:19:12.215577", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 8.0;\n\nconst float RED = 0.0;\nconst float BLUE = 7.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float GREEN = 5.0;\nconst float WHITE = 6.0;\nconst float ORANGE = 1.0;\nconst float BLACK = 8.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\tfragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == BLACK){\n    \treturn vec3(0.0,0.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n\tvec4 neighbors;\n    float offset = iTime*20.0;\n    float offset1 = offset*20.0;\n    while(mag1 < mag){\n    neighbors = vec4(magnify(fragCoord+vec2(offset,1),mag1),\n        magnify(fragCoord+vec2(1,offset),mag1),\n        magnify(fragCoord-vec2(offset,1),mag1),\n        magnify(fragCoord-vec2(1,offset),mag1));\n    bool modified = true;\n\n    if(color1 == RED && is_next_to(ORANGE,neighbors)){\n    \tcolor1 = ORANGE;\n    }\n    else if(color1 == ORANGE && is_next_to(GRAY,neighbors)){\n        if(mag1 > 5.0){\n        \tcolor1 = YELLOW;\n        }\n        else{\n        \tcolor1 = GRAY;\n        }\n    }\n    else if(color1 == GRAY && is_next_to(RED,neighbors)){\n        color1 = RED;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = RED;\n    }\n    else if(color1 == GRAY && is_next_to(ORANGE,neighbors) && is_next_to(GRAY,neighbors)){\n        color1 = WHITE;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag;\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 329, 351, 351, 575], [578, 578, 618, 618, 779], [781, 781, 825, 825, 961], [965, 965, 993, 993, 1545], [1547, 1547, 1606, 1606, 2568], [2570, 2570, 2627, 2627, 2883]], "test": "untested"}
{"id": "3dfyRr", "name": "Fractal storm 3", "author": "jarble", "description": "It's a very turbulent fractal animation.", "tags": ["fractal", "storm"], "likes": 1, "viewed": 288, "published": 3, "date": "1583947073", "time_retrieved": "2024-07-30T21:19:13.249812", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float WHITE = 4.0;\nconst float FOREST_GREEN = 5.0;\nconst float LIGHTBLUE = 6.0;\nconst float SKYBLUE = 7.0;\nconst float SNOW = 8.0;\nconst float WHITESMOKE = 9.0;\nconst float LIGHTGRAY = 10.0;\nconst float LIME = 11.0;\nconst float LIGHTYELLOW = 12.0;\nconst float BEIGE = 13.0;\nconst float SAND = 14.0;\nconst float TAN = 15.0;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p,float colors[6],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\nfloat hash12(vec2 p,float colors[5],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\nfloat hash12(vec2 p,float colors[2],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\n\n\nfloat magnify(vec2 fragCoord,float mag,float[6] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[5] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[2] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[5] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[2] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[6] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord,mag,colors) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord+vec2(0,1),mag,colors) == color\n        && magnify(fragCoord+vec2(1,0),mag,colors) == color\n        && magnify(fragCoord-vec2(0,1),mag,colors) == color\n        && magnify(fragCoord-vec2(1,0),mag,colors) == color;\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom,float colors[6]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float FOREST_GREEN = colors[4];\n    float WHITE = colors[5];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW){\n        color1 = GREEN;\n    }\n\n    else if(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n\n    else if(color1 == GREEN && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n   \n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom,float[5] colors){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float YELLOW = colors[3];\n    float FOREST_GREEN = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(GRAY,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n    \tcolor1 = FOREST_GREEN;\n    }\n\n    else if(color1 == GRAY){\n        color1 = GREEN;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float WHITE = colors[3];\n    float YELLOW = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    \n    vec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = GRAY;\n    }\n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n    \tcolor1 = GRAY;\n    } \n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[1];\n    float GEAY = colors[1];\n    float WHITE = colors[1];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = YELLOW;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom,float colors[2]){\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,float[](GREEN,BLUE));\n}\t\n\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float WHITE = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = forest_biome(fragCoord,mag,mag/3.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nfloat combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,SKYBLUE,SNOW,GRAY,WHITE));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE));\n    }\n    return color1;\n}\n\nfloat deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n\n    if(color1 == GRAY){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](TAN,LIME,SNOW,GRAY,YELLOW));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE));\n    }\n    return color1;\n}\n\nfloat combined_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = glacier_biome(fragCoord,mag,mag/(81.*81.));\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forests_and_mountains(fragCoord,mag,zoom);\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE));\n    }\n    return color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float zoom = mag;\n    fragCoord *= zoom*((iMouse.x+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n    //choose the biome here\n\tfloat biome =\n        forest_biome\n    \t//savanna_biome\n        //glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        //combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 560, 608, 608, 955], [956, 956, 1004, 1004, 1351], [1353, 1353, 1401, 1401, 1748], [3689, 3689, 3733, 3733, 3869], [3871, 3871, 3905, 3905, 3934], [3936, 3936, 3964, 3964, 5039], [5041, 5041, 5116, 5116, 6145], [7325, 7325, 7401, 7401, 8479], [8628, 8628, 8702, 8702, 9593], [9736, 9736, 9810, 9810, 10200], [10327, 10327, 10411, 10411, 11484], [14814, 14814, 14871, 14871, 15385]], "test": "untested"}
{"id": "Wsfyzn", "name": "Rational Approximation in Colour", "author": "mla", "description": "Couldn't resist colourizing this one too - also use the continued fraction algorithm for finding an approximation ('x' key to compare with original).\n\nAlso show line at x,y=1 and points with y = 1/1,1/2,1/3..2/3,2/5,3/5,4/5.. etc.", "tags": ["approximation", "rational"], "likes": 6, "viewed": 326, "published": 3, "date": "1583941278", "time_retrieved": "2024-07-30T21:19:14.119487", "image_code": "// Original by FabriceNeyret2:\n// https://www.shadertoy.com/view/3tKXDt\n\n// Modified by Matthew Arcus, mla, 11/3/2020\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// Original function by Fabrice\nivec2 rationalize0(float k, float eps) {\n  float m = 1e8;\n  int a,_n;\n  for(int n_, n=1; n < 1000; n++) {\n    a = int(0.5+k*float(n));          // a/n ~ k\n    float d = abs(1.0-float(a)/float(n)/k); // relative error\n    if (d<m) m=d, _n=n;          // closer\n    if (m <= eps ) break;           // stop at 1% rel err\n  }\n  return ivec2(a,_n);\n}\n\n// Find continued fraction convergent\nivec2 rationalize1(float k, float eps) {\n  float k0 = k;\n  int x=1, y=0, z=0, w=1;\n  for (int i = 0; i < 10; i++) {\n    int q = int(floor(k));\n    k = 1.0/fract(k);\n    int x1=z, y1=w, z1=x+q*z, w1=y+q*w;\n    x=x1; y=y1; z=z1; w=w1;\n    if (abs(1.0-float(w)/float(z)/k0) < eps) break;\n  }\n  return ivec2(w,z);\n}\n\nint gcd(int i, int j) {\n while(j != 0) {\n   int i1 = j, j1 = i%j;\n   i = i1; j = j1;\n }\n return i;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 p = 2.0*fragCoord/iResolution.y;\n  vec2 m = 2.0*iMouse.xy/iResolution.y;\n  float eps = 5e-3, A = 20.0, B = 0.03;\n  if (iMouse.z > 0.0) {\n    eps = 1e-3, A = 40.0, B = 0.01;\n    p -= m; p /= 10.0; p += m;\n  }\n  float x = p.y/p.x;\n  ivec2 r = key(CHAR_X) ? rationalize0(x,eps) : rationalize1(x,eps);\n  //ivec2 r = rationalize1(x,eps);\n  float t = 0.1*iTime;\n  vec3 col = hsv2rgb(t+float(r.y)/A,1.0,exp(-B*(float(r.y)-1.0)));\n  float ds = fwidth(p.x);\n  float lwidth = 0.002;\n  float cwidth = 0.002;\n  float cdia = 0.02;\n  vec3 linecol = vec3(0.9);\n  col = mix(linecol,col,smoothstep(lwidth,lwidth+ds,abs(p.y-1.0)));\n  col = mix(linecol,col,smoothstep(lwidth,lwidth+ds,abs(p.x-1.0)));\n  for (int i = 1; i <= 6; i++) {\n    for (int j = 1; j <= 6; j++) {\n      if (gcd(i,j) != 1) continue;\n      col = mix(linecol,col,smoothstep(cwidth,cwidth+ds,abs(length(p-vec2(1,float(j)/float(i)))-cdia)));\n      col = mix(linecol,col,smoothstep(cwidth,cwidth+ds,abs(length(p-vec2(float(j)/float(i),1))-cdia)));\n    }\n  }\n  if (alert) col.r = 1.0;\n  outColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n  \n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsfyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 160, 160, 330], [332, 364, 404, 404, 709], [711, 749, 789, 789, 1060], [1062, 1062, 1085, 1085, 1162]], "test": "untested"}
{"id": "wlVXDd", "name": "Counting Bits in Colour", "author": "mla", "description": "A variation of [url]https://www.shadertoy.com/view/WlVXWt[/url]\n\nMore bit twiddling: [url]https://graphics.stanford.edu/~seander/bithacks.html[/url]", "tags": ["xor", "colour", "bitwise", "counting"], "likes": 10, "viewed": 425, "published": 3, "date": "1583932187", "time_retrieved": "2024-07-30T21:19:14.944281", "image_code": "// Original by FabriceNeyret2:\n// https://www.shadertoy.com/view/WlVXWt\n//\n// Modified by Matthew Arcus, mla, 11/3/2020.\n\n#if 0\n// Brian Kernighan’s Algorithm  cost = NB bits at 1 \n// https://www.geeksforgeeks.org/count-set-bits-in-an-integer/\n\nint nbBits(int n)  { \n    int c;\n    for( c = 0; n > 0; c++ )\n        n &= n - 1;\n    return c; \n} \n\n#else\n// mla pointed a more efficient one : \n// https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\nint nbBits(int v)  { \n    v -= v >> 1   & 0x55555555;                    \n    v = (v & 0x33333333) + (v >> 2   & 0x33333333);     \n    return ( v + (v >> 4) & 0xF0F0F0F ) * 0x1010101 >> 24;\n}\n#endif\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return v * mix( vec3(1.0), rgb, s);\n}\n\nint op(int x, int y) {\n    int a = int(0.1*iTime)%3;\n    if (a == 0) return x & y;\n    if (a == 1) return x | y;\n    if (a == 2) return x ^ y;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    ivec2 I = ivec2(U);\n    O = vec4( hsv2rgb(0.1*iTime+float(nbBits(op(I.x,I.y)))/ 6.,1.0,1.0),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[669, 669, 710, 710, 880], [882, 882, 904, 904, 1026], [1028, 1028, 1066, 1066, 1168]], "test": "untested"}
{"id": "ttKXWt", "name": "Sea of Ice", "author": "jarble", "description": "I added some sine-wave distortion to my \"glacier\" fractal. This is the result.\n\nMove the mouse to zoom in and out!", "tags": ["fractal", "sea", "ice", "iceberg"], "likes": 3, "viewed": 381, "published": 3, "date": "1583899929", "time_retrieved": "2024-07-30T21:19:16.010431", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 11.0;\nconst float distortion_scale = mag*mag;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float WHITE = 4.0;\nconst float FOREST_GREEN = 5.0;\nconst float LIGHTBLUE = 6.0;\nconst float SKYBLUE = 7.0;\nconst float SNOW = 8.0;\nconst float WHITESMOKE = 9.0;\nconst float LIGHTGRAY = 10.0;\nconst float LIME = 11.0;\nconst float LIGHTYELLOW = 12.0;\nconst float BEIGE = 13.0;\nconst float SAND = 14.0;\nconst float TAN = 15.0;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p,float colors[6],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\nfloat hash12(vec2 p,float colors[5],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\nfloat hash12(vec2 p,float colors[2],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\n\n\nfloat magnify(vec2 fragCoord,float mag,float[6] colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime)*10.0,sin(fragCoord.x/(distortion_scale*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[5] colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime)*10.0,sin(fragCoord.x/(distortion_scale*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[2] colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime)*10.0,sin(fragCoord.x/(distortion_scale*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[5] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[2] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[6] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord,mag,colors) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord+vec2(0,1),mag,colors) == color\n        && magnify(fragCoord+vec2(1,0),mag,colors) == color\n        && magnify(fragCoord-vec2(0,1),mag,colors) == color\n        && magnify(fragCoord-vec2(1,0),mag,colors) == color;\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom,float colors[6]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float FOREST_GREEN = colors[4];\n    float WHITE = colors[5];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW){\n        color1 = GREEN;\n    }\n\n    else if(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n\n    else if(color1 == GREEN && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n   \n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom,float[5] colors){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float YELLOW = colors[3];\n    float FOREST_GREEN = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(GRAY,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n    \tcolor1 = FOREST_GREEN;\n    }\n\n    else if(color1 == GRAY){\n        color1 = GREEN;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float WHITE = colors[3];\n    float YELLOW = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    \n    vec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = GRAY;\n    }\n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n    \tcolor1 = GRAY;\n    } \n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[1];\n    float GEAY = colors[1];\n    float WHITE = colors[1];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = YELLOW;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom,float colors[2]){\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,float[](GREEN,BLUE));\n}\t\n\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float WHITE = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = forest_biome(fragCoord,mag,mag/3.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nfloat combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,SKYBLUE,SNOW,GRAY,WHITE));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE));\n    }\n    return color1;\n}\n\nfloat deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n\n    if(color1 == GRAY){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](TAN,LIME,SNOW,GRAY,YELLOW));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE));\n    }\n    return color1;\n}\n\nfloat combined_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = glacier_biome(fragCoord,mag,mag/(81.*81.));\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forests_and_mountains(fragCoord,mag,zoom);\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE));\n    }\n    return color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float zoom = mag*(((iMouse.x-iMouse.y)*mag+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n\n    //choose the biome here\n\tfloat biome =\n        //forest_biome\n    \t//savanna_biome\n        glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        //combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 601, 649, 649, 996], [997, 997, 1045, 1045, 1392], [1394, 1394, 1442, 1442, 1789], [3796, 3796, 3840, 3840, 3976], [3978, 3978, 4012, 4012, 4041], [4043, 4043, 4071, 4071, 5146], [5148, 5148, 5223, 5223, 6252], [7432, 7432, 7508, 7508, 8586], [8735, 8735, 8809, 8809, 9700], [9843, 9843, 9917, 9917, 10307], [10434, 10434, 10518, 10518, 11591], [14921, 14921, 14978, 14978, 15506]], "test": "untested"}
{"id": "WtVXDd", "name": "Saturn rings", "author": "jarble", "description": "These rings appear over a fractal landscape.\n\nMove the mouse to zoom in and out!", "tags": ["fractal", "rings", "saturn"], "likes": 1, "viewed": 370, "published": 3, "date": "1583889498", "time_retrieved": "2024-07-30T21:19:17.153376", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float WHITE = 4.0;\nconst float FOREST_GREEN = 5.0;\nconst float LIGHTBLUE = 6.0;\nconst float SKYBLUE = 7.0;\nconst float SNOW = 8.0;\nconst float WHITESMOKE = 9.0;\nconst float LIGHTGRAY = 10.0;\nconst float LIME = 11.0;\nconst float LIGHTYELLOW = 12.0;\nconst float BEIGE = 13.0;\nconst float SAND = 14.0;\nconst float TAN = 15.0;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p,float colors[6],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\nfloat hash12(vec2 p,float colors[5],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\nfloat hash12(vec2 p,float colors[2],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\n\n\nfloat magnify(vec2 fragCoord,float mag,float[6] colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[5] colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[2] colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[5] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[2] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[6] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord,mag,colors) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord+vec2(0,1),mag,colors) == color\n        && magnify(fragCoord+vec2(1,0),mag,colors) == color\n        && magnify(fragCoord-vec2(0,1),mag,colors) == color\n        && magnify(fragCoord-vec2(1,0),mag,colors) == color;\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom,float colors[6]){\n    fragCoord *= zoom;\n    fragCoord.x += fragCoord.y;\n    fragCoord.y = fragCoord.x;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float FOREST_GREEN = colors[4];\n    float WHITE = colors[5];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW){\n        color1 = GREEN;\n    }\n\n    else if(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n\n    else if(color1 == GREEN && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n   \n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom,float[5] colors){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float YELLOW = colors[3];\n    float FOREST_GREEN = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(GRAY,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n    \tcolor1 = FOREST_GREEN;\n    }\n\n    else if(color1 == GRAY){\n        color1 = GREEN;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float WHITE = colors[3];\n    float YELLOW = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    \n    vec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = GRAY;\n    }\n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n    \tcolor1 = GRAY;\n    } \n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[1];\n    float GEAY = colors[1];\n    float WHITE = colors[1];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = YELLOW;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom,float colors[2]){\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,float[](GREEN,BLUE));\n}\t\n\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float WHITE = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = forest_biome(fragCoord,mag,mag/4.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nfloat combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,SKYBLUE,SNOW,GRAY,WHITE));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE));\n    }\n    return color1;\n}\n\nfloat deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n\n    if(color1 == GRAY){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](TAN,LIME,SNOW,GRAY,YELLOW));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE));\n    }\n    return color1;\n}\n\nfloat combined_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = glacier_biome(fragCoord,mag,mag/3.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forests_and_mountains(fragCoord,mag,zoom);\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE));\n    }\n    return color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n    //choose the biome here\n\tfloat biome =\n        //forest_biome\n    \t//savanna_biome\n        //glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 560, 608, 608, 955], [956, 956, 1004, 1004, 1351], [1353, 1353, 1401, 1401, 1748], [3353, 3353, 3397, 3397, 3533], [3535, 3535, 3569, 3569, 3598], [3600, 3600, 3628, 3628, 4703], [4705, 4705, 4780, 4780, 5872], [7052, 7052, 7128, 7128, 8206], [8355, 8355, 8429, 8429, 9320], [9463, 9463, 9537, 9537, 9927], [10054, 10054, 10138, 10138, 11211], [14535, 14535, 14592, 14592, 15116]], "test": "untested"}
{"id": "3t33WH", "name": "Interior Distance", "author": "iq", "description": "This shader shows how the usual union SDF operator implemented with min() produces the incorrect SDF in the interior of the shapes or exterior (if doing exterior modeling), but never produces correct distances everywhere.", "tags": ["2d", "distancefield", "sdf", "distance", "min", "union"], "likes": 49, "viewed": 5259, "published": 3, "date": "1583883639", "time_retrieved": "2024-07-30T21:19:17.935285", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader shows how the usual union SDF operator implemented\n// with min() produces the incorrect SDF in the interior of the shapes.\n// If the modeling is reversed and the exterior of the negative\n// space of the shape is modeled, then the exterior distance is wrong.\n//\n// While this is not an issue in most cases in practice, it can be\n// a problem in shaders that need to raymarch or do some other\n// distance based volumetric operations in the interior of the\n// shapes.\n//\n// This shader implements both correct interior and exterior distances\n// by modeling the boundary of the shape instead. Alternativelly, the\n// appropriate interior or exterior correct SDF could be chosen as\n// needed, but then there is double modeling work.\n//\n// More info here:\n// https://iquilezles.org/articles/interiordistance\n\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 c, in vec2 b ) \n{\n    vec2 q = abs(p-c) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n              \n// correct outside, incorrect inside\nfloat sdA( in vec2 p )\n{\n    float d = sdCircle( p, vec2(-0.4, 0.3), 0.5);\n    d = min(d,sdBox( p, vec2( 0.4,-0.4), vec2(0.4,0.4) ));\n    d = min(d,sdBox( p, vec2( 0.0, 0.0), vec2(0.4,0.8) ));\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n   float d =     sdBox( p, vec2( 0.0, 1.0), vec2(2.0,0.2) );\n       d = min(d,sdBox( p, vec2( 1.2, 1.0), vec2(0.8,1.0) ));\n       d = min(d,sdBox( p, vec2( 1.4,-0.3), vec2(0.6,0.9) ));\n       d = min(d,sdBox( p, vec2( 0.0,-1.0), vec2(1.0,0.2) ));\n       d = min(d,sdBox( p, vec2(-1.2,-0.8), vec2(0.8,0.6) ));\n       d = min(d,sdBox( p, vec2(-1.5, 0.3), vec2(0.6,0.7) ));\n       d = min(d,sdCrescent( p-vec2(-0.4-1.0, 0.3), 1.1, 0.5, 1.0, 1.0, -1.0 ));\n    return -d;\n}\n\n// correct both in side and outside\nfloat sdC( in vec2 p )\n{\n\tint kType[] = int[](0,0,0,0,0,0,1);\n\tfloat kPath[] = float[](-0.4, 0.8,\n                             0.4, 0.8,\n                             0.4,-0.0,\n                             0.8,-0.0,\n                             0.8,-0.8,\n                            -0.4,-0.8,\n                            -0.4,-0.2, 0.0,\n                            -0.4, 0.8 );\n    return sdShape(p,kType,kPath );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // distance computations\n    float dWrongInterior = sdA(p); // interior modeling\n    float dWrongExterior = sdB(p); // exterior modeling\n    float dCorrectBoth   = sdC(p); // boundary modeling\n\n    // animation\n    float f = fract(iTime/8.0);\n    float g = fract(iTime/2.0);\n    float d = (f<0.5) ? ((g<0.5)?dWrongInterior:dCorrectBoth) \n                      : ((g<0.5)?dWrongExterior:dCorrectBoth);\n    \n    // coloring\n    vec3 col = (d<0.0) ? vec3(0.6,0.8,1.0) : vec3(0.9,0.6,0.3);\n    col *= 1.0 - exp(-9.0*abs(d));\n\tcol *= 1.0 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n     // interactivity\n    if( iMouse.z>0.001 )\n    {\n        float dWrongInterior = sdA(m); // interior modeling\n        float dWrongExterior = sdB(m); // exterior modeling\n        float dCorrectBoth   = sdC(m); // boundary modeling\n        float d = (f<0.5) ? ((g<0.5)?dWrongInterior:dCorrectBoth) \n                          : ((g<0.5)?dWrongExterior:dCorrectBoth);\n\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t33WH.jpg", "access": "api", "license": "mit", "functions": [[1898, 1898, 1923, 1923, 1942], [1943, 1943, 1970, 1970, 1997], [1999, 2050, 2102, 2102, 2132], [2134, 2185, 2234, 2234, 2318], [2320, 2371, 2421, 2421, 2554], [2556, 2556, 2637, 2637, 3072], [3074, 3125, 3199, 3199, 3578], [3647, 3701, 3760, 3760, 4525], [4541, 4578, 4602, 4602, 4786], [4788, 4825, 4849, 4849, 5318], [5773, 5773, 5830, 5866, 7229]], "test": "error"}
{"id": "3lVSDd", "name": "caterpillar sort of thing", "author": "libensvivit", "description": "need optimization and coloring", "tags": ["raymarch", "caterpillar"], "likes": 7, "viewed": 329, "published": 3, "date": "1583882374", "time_retrieved": "2024-07-30T21:19:18.714202", "image_code": "float Sphere(vec3 p, float radius) {\n\treturn length(p)-radius;\n}\n\n// Blending function\nfloat smin( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// Get the distance to the plane and sphere\nfloat GetDist(vec3 p) {\n    float d = p.y;\n    float t = iTime;\n    \n    for(float i = 5.; i >= 1.; i-=1.) {\n        float size = .9 + i *.15 + 0.1*sin(iTime);\n        float spiral = 9.; \t\t\t\t\t\t\t// eight figure size\n        float ds = size*2.5; \t\t\t\t\t\t// distance between spheres\n        \n        float x = spiral*cos(t+ds);\n        float y = .3+1.5*size*sin(3.*t+i);\n        float z = spiral*cos(t+ds)*sin(t+ds);\n        \n    \td = smin(Sphere(p-vec3(x, y, z), size), d, .4);\n    }\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    for(int i = 0; i < 80; i++) {\n    \tfloat step = GetDist(ro + rd*d);\n        d += step*.5;\n        if(abs(d) < 0.0001 || d > 30.) break;\n    }\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    vec3 normal = d - vec3(GetDist(p-e.xyy),\n                           GetDist(p-e.yxy),\n                           GetDist(p-e.yyx)); //differentiation\n    normal = normalize(normal);\n    return normal;\n}\n\nfloat GetLight(vec3 p){\n\tvec3 light = vec3(3., 10., 7.);\n    vec3 normal = GetNormal(p);\n    \n    vec3 lightVec = normalize(light-p);\n    float dif = max(0., dot(normal, lightVec));\n    float shadow = RayMarch(p+normal*.002, lightVec);\n    \n    if(shadow < length(light-p)){\n        dif *= clamp(shadow*.2, 0.,1.);\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n   \n    // any ideas about mouse rotation?\n    vec3 ro = vec3(8., 10., 13.);\n    vec3 lookAt = vec3(0.);\n    float zoom = 1.;\n    \n    // front, right and up vectors (3d camera model)\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(f, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r,f));\n    vec3 c = ro + f * zoom; \t\t\t// center\n    vec3 i = c + r*uv.x + u*uv.y; \t\t// point on the rotated uv screen\n    vec3 rd = i - ro;\n    \n    float d = RayMarch(ro, rd);\n    float dif = GetLight(ro + rd *d);\n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 64], [66, 87, 127, 127, 211], [213, 257, 280, 280, 752], [754, 754, 788, 788, 965], [967, 967, 991, 991, 1249], [1251, 1251, 1274, 1274, 1594], [1596, 1596, 1652, 1652, 2359]], "test": "untested"}
{"id": "WtKSWd", "name": "Day 82", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 13, "viewed": 469, "published": 3, "date": "1583877197", "time_retrieved": "2024-07-30T21:19:19.614794", "image_code": "// some XOR extrusion of a plane with balkhan glow\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 30.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.)*0.5;\n    float chromAb = dot(uvn,uvn)*9.;\n    vec2 offs = vec2(0) + texture(iChannel1, uv + iTime*4.).xz*0.;\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.98;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.x += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.y += texture(iChannel0, target).y;\n    \tradial.z += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    \n    \n    \n    radial /= steps;\n    \n    float ss = smoothstep(0.,1.,dot(uvn,uvn)*3.);\n    \n    fragColor = texture(iChannel0, uv)*1.*(1. - ss) + radial*1.*ss; \n    \n    //fragColor *= 1.;\n    //fragColor = pow(fragColor, vec4(0.45));\n\t\n    float duvuv = dot(uvn,uvn);\n    \n    //fragColor = pow(fragColor, vec4(0.49 - clamp(duvuv*0.4, 0., 0.50)));\n    \n    fragColor = smoothstep(0.,1.,fragColor);\n    fragColor = pow(fragColor, vec4(0.5,0.65,0.52,1.));\n    \n    fragColor *= 1. - duvuv*1.;\n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 1.);\n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    //fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_a_code": "\nfloat xor(float x, float y) {return float(int(x) | int(y));}\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define R iResolution.xy\n#define T(e) texture(iChannel0, (e)/R).x\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define H (0.1 + sin(iTime*0.2)*0.02)\n\nfloat tot;\nfloat get(vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy);\n    /*\n    for(int i = 0; i < 5 ; i++){\n    \tuv *= rot(0.6);\n        uv = abs(uv);\n    }*/\n    float col = 0.;\n\n    uv *= 19. ;\n    \n\n    uv = pmod(uv, 10000./2.);\n    vec2 iuv = vec2(uv);\n    \n    iuv = abs(iuv);\n    \n    \n    float rep = 50.;\n    iuv = floor(iuv/rep)*rep;\n    \n    \n    \n    float r = xor(iuv.x, iuv.y);\n    \n    \n    float cumm = 0.;\n    \n    r = xor(iuv.x, iuv.y);\n    \n    \n    r = floor(r*0.097 + abs(sin(iTime*2.))*0.5);\n    for(int i = 0; i < 8; i++){\n        if(floor(mod(r, 10.)) < 2.){\n        \t//cumm += r * r*4.4 + r + r;\n            cumm += r;\n            \n            //cumm += r*1.;\n        } else {\n        \t//break;\n        }\n        cumm = fract(cumm)*100.;\n        r += 1.1;\n        //r += 1.2;\n        \n    }\n    \n    \n    float fr = float(r);\n    \n    \n    col += clamp(cumm, 0., 1.);\n    \n    //l -= step(1.-cumm*0.00000001,0.)*1.;\n    //col -= 0.3;\n    \n    col = clamp(col, 0.,1.);\n    if (col == 0.) \n        col -= col + 1.;\n    return col;\n}\n\n\nvec3 getPatt(vec2 U )\n{\n    \n\tvec3 col = vec3(0);\n    float st = 0.2 + sin(iTime)*0.1;    \n    \n    // antialiasing\n    \n    float t = get(U);\n    float n = get(U + vec2(0.,st));\n    float w = get(U + vec2(0.,-st));\n    float e = get(U + vec2(st,0.));\n    float s = get(U + vec2(-st,0.));\n    \n    float ne = get(U + vec2(st,st));\n    float ns = get(U + vec2(-st,st));\n    float sw = get(U + vec2(st,-st));\n    float se = get(U + vec2(-st,-st));\n    \n    \n    float cumm = t + n + w + e + s + ne + ns + sw + se;\n    \n    \n    col += cumm/9.;\n    //col += (ne + sw + sw + se)/4.;\n    \n    \n    float att = pow(smoothstep(0.,1., abs(col.x)/1.), 2.);\n\n    col -= col;\n\t\n    col += 1. - att; \n    //col += fract(U.xyy)*0.6;\n    //col += 1. - t;\n    \n    return col;\n}\n\n\n\n\n#define dmin(a,b) a.x < b.x ? a : b\n\nvec3 glow = vec3(0);\n\nfloat patt;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\n    //p.y += sin(p.xz*20.).x*0.0 + sin(p.xz*20.).y*0.02;\n    p.xy *= rot(p.z*0.);\n    \n    d = dmin(d,vec2(p.y + H, 0.));\n    d = dmin(d,vec2(-p.y + H, 0.));\n    \n    \n    patt = getPatt(1.*p.xz*400.).x*1.;\n    \n    patt = 1. - patt;\n    \n    d.x -= patt*0.0014;\n    \n    //glow += exp(-d.x*100.);\n    //glow += exp(-max(patt, 0.)*20.);\n    //glow += max(0.8/(0.8 + patt*patt*10.), 0.)*vec3(0.2,0.9,1.)*2.;\n    //glow -= max(0.6/(0.9 + patt*patt*100.), 0.)*vec3(0.2,0.,1.)*2.;\n    glow += max(0.4/(0.7 + patt*patt*10.), 0.)*vec3(0.2,0.9,0.5)*2.;\n    //d.x -= ;\n    \n    return d;\n}\n\nfloat n;\nvec2 march (vec3 ro, vec3 rd, inout vec3 p , inout float t, inout bool hit){\n\thit = false; p = ro; t = 0.;\n    \n    float dith = mix(0.63, 1., n);\n    vec2 d;\n    for(int i = 0; i < 220 ; i++){\n    \td = map(p);\n        d.x *= 0.3*dith;\n        if (d.x < 0.0004){\n        \thit = true;\n            break;\n        }\n        tot = t += d.x;\n        p = ro + rd*t;\n    }\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tfloat duv = dot(uv,uv);\n    uv *= 1. + duv*1.4;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    ro.z += iTime*0.2;\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    rd.yz *= rot(0.2);\n    \n    rd.xy *= rot(0.4 + iTime*0.15);\n    n = texture(iChannel0, 10.*uv*256. + iTime*2.4).x;\n    //ro -= 0.2*rd*n;\n    float dith = mix(0.4,1., n);\n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if (hit ){\n    \t//col += 0.6;\t\n    \tcol += (1. - patt)*vec3(0.7,0.9,0.6)*1.;\n    }\n    col += glow*0.02;\n    col = max(col, 0.);\n    float ss = pow(smoothstep(0.,1.,t*0.5), 0.8);\n    \n    col.r *= 1. + ss*1.4;\n    col.gb *= 1. - duv;\n    \n    //col = mix(col, vec3(0.1, 0.8,1.)*0.7,ss);\n    //col = mix(col, vec3(0.6, 0.95,0.556)*0.1,pow(smoothstep(0.,1.,t*0.2), 0.8));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 110, 110, 1520]], "test": "untested"}
{"id": "3tKXDt", "name": "how y/x close to rational ?", "author": "FabriceNeyret2", "description": "shows the smaller denominator of the 1st rational approximating y/x at 1%.\nThe whiter the \"less rational\" is y/x.\n\nApplication: probability of hit ray - true Menger sponge ;-D", "tags": ["approximation", "rational", "diophantine"], "likes": 2, "viewed": 402, "published": 3, "date": "1583864739", "time_retrieved": "2024-07-30T21:19:20.400693", "image_code": "// could be more efficient using one of those:\n//   https://en.wikipedia.org/wiki/Continued_fraction#Best_rational_approximations\n//   https://en.wikipedia.org/wiki/Diophantine_approximation\n//   https://en.wikipedia.org/wiki/Pad%C3%A9_approximant\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n  //vec2 U = (u-.5); // /iResolution.y;\n    vec2 U = u / iResolution.y;\n    int _n;\n    float k = U.y/U.x, d, m=1e5;\n    for( int a,n=1; n < 1000; n++) {\n        a = int(.5+k*float(n));          // a/n ~ k\n        d = abs(1.-float(a)/float(n)/k); // relative error\n        if ( d < m ) m=d, _n=n;          // closer\n        if ( m <= .01 ) break;           // stop at 1% rel err\n    }\n    O = vec4(_n)/40.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 287, 327, 696]], "test": "untested"}
{"id": "3lVSDt", "name": "benching int+ vs float+", "author": "FabriceNeyret2", "description": "on my GeForce GTX 760, + on ints is a lot costlier than + on floats", "tags": ["glsl", "bench"], "likes": 2, "viewed": 357, "published": 3, "date": "1583862160", "time_retrieved": "2024-07-30T21:19:21.162655", "image_code": "#define Z  min(0,iFrame)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float s=0.; int n=0;\n    for(int i=Z,j=Z+Z; i<100000; i++) { // on GeForce GTX 760 linux 640x360\n        s += float(i) + float(j);       // 7.5 fps \n      //s += float(i+j);                // 4.3 fps\n    }\n    O = vec4(s)+vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 64, 64, 301]], "test": "untested"}
{"id": "WtVSDt", "name": "benching log2 vs IEEEexponent", "author": "FabriceNeyret2", "description": "as expected:\n- optimizer don't know that floor(log2) is just reading the IEEE exponent\n- anyway doing it manually is costlier than the FPU\n\nOdd:\n- log2 is still costlier than floor(log2) or log2(floor)\n- float(a+b) is alot costler than float(a)-float(b)", "tags": ["glsl", "bench", "ieee", "log", "perf"], "likes": 1, "viewed": 362, "published": 3, "date": "1583861822", "time_retrieved": "2024-07-30T21:19:21.923621", "image_code": "#define Z  min(0.,iTime)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float s=0.; int n=0;\n    for(float i=Z; i<1e5; i++) { // on GeForce GTX 760 linux 640x360\n      //s += log2(i);                               // 7.5 fps\n        s += floor(log2(i));                        // 8.6 fps\n      //s += log2(floor(i));                        // 8.6 fps\n      //s += float(floatBitsToInt(i) >> 23) -127.;  // 6.7 fps\n      //s += float((floatBitsToInt(i) >> 23) -127); // 4.  fps\n      //n += int(log2(i));                          // 8.6 fps\n      //n += (floatBitsToInt(i) >> 23) -127;        // 8.6 fps\n    }\n    O = vec4(s)+vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 64, 64, 632]], "test": "untested"}
{"id": "WlVXWt", "name": "counting bits", "author": "FabriceNeyret2", "description": "Fast ways to count the number of bits set in an int.", "tags": ["binary", "bitcounter"], "likes": 10, "viewed": 413, "published": 3, "date": "1583860889", "time_retrieved": "2024-07-30T21:19:22.685584", "image_code": "#if 0\n// Brian Kernighan’s Algorithm  cost = NB bits at 1 \n// https://www.geeksforgeeks.org/count-set-bits-in-an-integer/\n\nint nbBits(int n)  { \n    int c;\n    for( c = 0; n > 0; c++ )\n        n &= n - 1;\n    return c; \n} \n\n#else\n// mla pointed a more efficient one : https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\nint nbBits(int v)  { \n    v -= v >> 1   & 0x55555555;                    \n    v = (v & 0x33333333) + (v >> 2   & 0x33333333);     \n    return ( v + (v >> 4) & 0xF0F0F0F ) * 0x1010101   >> 24;\n}\n#endif\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    ivec2 I = ivec2(U);\n    O = vec4( nbBits(I.x^I.y) ) / 8.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[546, 546, 584, 584, 648]], "test": "untested"}
{"id": "ttyXDd", "name": "Grid rotation illusion", "author": "jeyko", "description": "recreation of this https://youtu.be/QAja2jp1VjE?t=267", "tags": ["optical", "illusion", "reproduction"], "likes": 7, "viewed": 443, "published": 3, "date": "1583850784", "time_retrieved": "2024-07-30T21:19:23.531322", "image_code": "// recreation of this https://youtu.be/QAja2jp1VjE?t=267\n\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n// thx to Fabrice for adding antialiasing\nfloat get (vec2 uv){\n    float modD = 0.024;\n    uv /= modD*2.;\n    uv = smoothstep(-fwidth(uv.x),fwidth(uv.x), 2.* abs(fract(uv)-.5)-.5); // abs(fract(uv)-.5)-.25 is more correct at the end\n    uv = 2.*uv-1.; \n    return .5+ .5* uv.x*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    \n    uv *= 1. + sin(iTime*0.5)*0.3;\n    col += get(uv)*0.9;\n    col += get(uv*rot( sin(fract(1.*iTime/3.14))*0.3));\n    col = 1. - col;\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 186, 206, 206, 428], [430, 430, 487, 487, 754]], "test": "untested"}
{"id": "wtGSDd", "name": "moritzgrid", "author": "lennyjpg", "description": "helping moritz", "tags": ["grid"], "likes": 1, "viewed": 324, "published": 3, "date": "1583848965", "time_retrieved": "2024-07-30T21:19:24.402992", "image_code": "bool check(float index){\n    float res = sqrt(index);\n    return res == floor(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    float res = 10.0;\n    vec2 u = fract(uv * res);\n    float l = res * 2.0 / iResolution.x;\n    float grid = max(step(u.x,l), step(u.y,l));\n    vec2 i = ceil(uv * res);\n    float count = i.x + i.y * i.x;\n    float k = check(count) ? 1.0 : grid;\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 85], [87, 87, 144, 144, 458]], "test": "untested"}
{"id": "wtySDd", "name": "Optimized Multi XOR sorting", "author": "michael0884", "description": "Now the performance is O(N*(log2²(N)/2 + 2log2(N))) or something like that. ", "tags": ["2d", "sorting"], "likes": 4, "viewed": 380, "published": 3, "date": "1583848746", "time_retrieved": "2024-07-30T21:19:25.180912", "image_code": "// Fork of \"Multi XOR sorting simplified II\" by iq. https://shadertoy.com/view/WlyXDt\n// 2020-03-10 13:40:56\n\n// Fork of \"Multi XOR sorting simplified\" by michael0884\n// https://www.shadertoy.com/view/WlySDt\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    fragColor = texelFetch(iChannel0,p,0);\n    \n    if( p.x>=N && p.x<2*N )\n    {\n        p.x -= N;\n\t\tint id = p.y*N + p.x;\n        if( id<(M-1) )\n        {\n            vec4 v0 = getData(iChannel0,id+0);\n            vec4 v1 = getData(iChannel0,id+1);\n            fragColor = vec4((v0.x>v1.x)?1:0,\n                             (v0.y>v1.y)?1:0,\n                             (v0.z>v1.z)?1:0,\n                             (v0.w>v1.w)?1:0);\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 sort(ivec2 p)\n{\n    //step and substep\n    int pas, ste;\n    for(pas = S+4, ste = iFrame%(P); ste >= pas; ste -= pas, pas--); //black magic\n    ste = (pas - 1 - ste)%S;\n    // pair ids\n    int id0 = p.y*N + p.x;  \t\t//this pixel id\n    int id1 = id0^((1<<(ste+1))-1); //pair pixel id, by flipping first n bits, n - is the substep\n        \n\t// move data sorted\n    vec4 v0 = getData(iChannel0,id0);\n    vec4 v1 = getData(iChannel0,id1);\n    return (id0>id1) ? max(v0,v1) : min(v0,v1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    \n    if( max(p.x,p.y)>=N ) return;\n  //if( iFrame==0 ) { fragColor = texelFetch(iChannel1,2*p,0); return; }\n    if( (iFrame%(P))==0 ) { fragColor = texelFetch(iChannel1,2*p,0); return; }\n  //if( iFrame>N ) return;\n\n    fragColor = sort(p);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N   256\n#define M 65536 // N² = total number of texels\n#define S    16 // log2(M) = 2·log2(N)\n#define P    128+32// log2(M)²/2 + 2log2(M) - total number of passes\nvec4 getData( sampler2D ch, int id )\n{\n\treturn texelFetch(ch, ivec2(id%N,id/N), 0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtySDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 266, 266, 757]], "test": "untested"}
{"id": "tlyXWd", "name": "infinite book (218 chars)", "author": "FabriceNeyret2", "description": "could it be shorter ? :-)", "tags": ["2d", "2tweets", "gif", "short", "golf"], "likes": 13, "viewed": 355, "published": 3, "date": "1583846528", "time_retrieved": "2024-07-30T21:19:26.103446", "image_code": "// readable version at bottom ;-)\n\nvoid mainImage(out vec4 O, vec2 U) {\n    for ( vec2 R = iResolution.xy, V = vec2(0,1), T, i=R-R, u;\n          i.x < 1.; i+=.05 )\n        T = fract( iTime/7. +i +.01*R.y / length( U -R*(V*.2-.1)) ),\n        O = max(O, 1.2 -.5*length(\n              min( R.y, dot( u = U - R*V* (.1-.1*T),\n                             T = sin( 1.57* ( exp(-8.*T) + V.yx ) )\n                 )         ) *T - u ));\n}/*\n\n\n\n\n\n// --- 224 chars\n\n#define mainImage(O,U)                                                 \\\n    for ( vec2 R = iResolution.xy, V = O.xw, a,T, i=R-R;               \\\n          i.x < 1.; i+=.05 )                                           \\\n        T = fract( iTime/7. +i +.01*R.y / length( U -R*(V/5.-.1)) ),   \\\n        a = R*V* (.1-.1*T),                                            \\\n        T = sin( 1.57* ( exp(-8.*T) + V.yx ) ),                        \\\n        O = max(O, 1.2 -.5*length( U-a - T * min( dot(U-a, T), R.y))) /*\n\n\n\n\n\n// --- 232 chars\n\n#define mainImage(O,U)                                                 \\\n    vec2 R = iResolution.xy, V = O.xw, a,b;                            \\\n    for (float T, i = 0.; i < 1.; i+=.05)                              \\\n        T = fract( iTime/7. +i +.01*R.y / length( U -R*vec2(-.1,.1)) ),\\\n        a = R* V*(.1-.1*T),                                            \\\n        b = sin(1.57*(exp(-8.*T)+V.yx)),                               \\\n        O = max(O, 1.2 -.5*length( U-a - b * min( dot(U-a, b), R.y))) /*\n\n\n\n\n\n// --- 258 chars\n\n#define mainImage(O,U)                                               \\\n    vec2 R = iResolution.xy;                                         \\\n    for (float T, i = 0.; i < 1.; i+=.05) {                          \\\n        T = fract( iTime/7. +i +.01*R.y/length(U-R*vec2(-.1,.1)) );  \\\n        vec2 a = R* vec2(0,.1-.1*T),                                 \\\n             p = U - a,                                              \\\n             b = R.y* cos(1.57*exp(-8.*T)+vec2(0,11)) - a;           \\\n        O = max(O, 1.2 -.5*length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.)));\\\n    } /*\n\n\n\n\n\n// --- 334 chars\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);                      \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R.y;\n    O-=O;\n    for (float T, i = 0.; i < 1.; i+=.05) {\n        T = fract(.15*iTime+i+.01/length(U));\n        O = max(O, smoothstep( 1., -1., R.y* line(U,vec2(0,.1*(1.-T)),cos(1.57*exp(-8.*T)+vec2(0,11)))-1.4));\n    }\n}\n\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 71, 71, 430]], "test": "untested"}
{"id": "wtGXDt", "name": "Hexagonal Diffusion", "author": "brianhaak", "description": "Hexagonal lattice for diffusion, cellular automata, and other symmetries.\nChange SCALE in the \"Common\" tab (must be divisible by 2).", "tags": ["diffusion", "hexagonal", "lattice"], "likes": 4, "viewed": 391, "published": 3, "date": "1583834492", "time_retrieved": "2024-07-30T21:19:26.874384", "image_code": "void fetch_cell (in vec2 cell_pos, out Cell cell) {\n    \n    vec2 pos = vec2(2.0, 4.0) * cell_pos + 0.5;\n\n\tcell.data[0] = texture(iChannel0, (pos + vec2(0.0, 0.0)) / iChannelResolution[0].xy);\n    cell.data[1] = texture(iChannel0, (pos + vec2(1.0, 0.0)) / iChannelResolution[0].xy);\n    \n    cell.data[2] = texture(iChannel0, (pos + vec2(0.0, 1.0)) / iChannelResolution[0].xy);\n    cell.data[3] = texture(iChannel0, (pos + vec2(1.0, 1.0)) / iChannelResolution[0].xy);\n            \n    cell.data[4] = texture(iChannel0, (pos + vec2(0.0, 2.0)) / iChannelResolution[0].xy);\n    cell.data[5] = texture(iChannel0, (pos + vec2(1.0, 2.0)) / iChannelResolution[0].xy);\n    cell.data[6] = texture(iChannel0, (pos + vec2(0.0, 3.0)) / iChannelResolution[0].xy);\n    cell.data[7] = texture(iChannel0, (pos + vec2(1.0, 3.0)) / iChannelResolution[0].xy);\n}\n\n\nvoid render_visual_pixel (out vec4 frag_color, in vec2 frag_coord) {\n    \n    /*\n\t  Triangular tiling on hexagonal lattice:\n\n        01234567\n      0 a--b----\n      1 -------- (skip a line completely)\n      2 ----c--d\n      3 -------- (skip another line)\n\n\n      Hexagonal dense lattice:\n\n\t    01234567\n      0 a-b-c-d-\n      1 -------- (skip a line completely)\n      2 -e-f-g-h\n      3 -------- (skip another line)\n\n\n      Triangular dense dense lattice over the hexagonal:\n\n\t    01234567\n      0 a-b-.-d-\n      1 -------- (skip a line completely)\n      2 -.-f-.-h\n      3 -------- (skip another line)\n\t*/\n    \n    // The coordinate where vec4 frag_color is getting written.\n    vec2 write_coordinate = floor((frag_coord - 0.5) / SCALE);\n    // vec2 write_coordinate_for_cells = (frag_coord - 0.5) / SCALE;\n    vec2 write_coordinate_for_cells = (frag_coord - 0.5) / SCALE + vec2(0.5, 0.5) / SCALE; // - 0.5 / SCALE;\n    \n    vec2 is_odd = 1.0 - floor(mod(write_coordinate, 2.0));\n    \n    vec2 tile_coord = mod(write_coordinate, vec2(8.0, 4.0));// - 0.5;\n    \n    float line_0 = 1.0 - floor(mod(write_coordinate.y / 2.0, 2.0));\n    float line_2 = 1.0 - floor(mod((write_coordinate.y + 2.0) / 2.0, 2.0));\n    \n    //vec2 normalized_pixel_position = (2.0 * frag_coord / iResolution.xy) - 1.0; // -1..+1\n    //float viewport_screen_ratio = iResolution.x / iResolution.y;\n    //float horizontal_meters = VERTICAL_METERS * viewport_screen_ratio;\n    \n    //vec2 pixel_meters_position = vec2(\n    //    normalized_pixel_position.x * horizontal_meters,\n    //    normalized_pixel_position.y * VERTICAL_METERS);\n\n    \n    // float tile_x_isnt_4 = floor(abs(4.0 - tile_coord.x));\n    // float tile_x_isnt_1_or_5 = floor(abs(1.0 - tile_coord.x));\n    \n    // float render_intensity_dense_hex = is_odd.y * (line_0 * is_odd.x + line_2 * (1.0 - is_odd.x));\n    \n    float tile_x_is_0_or_3 = 1.0 - floor(abs(0.0 - tile_coord.x)) * floor(abs(3.0 - tile_coord.x));\n    float tile_x_is_4_or_7 = 1.0 - floor(abs(4.0 - tile_coord.x)) * floor(abs(7.0 - tile_coord.x));\n    \n    float render_intensity_sparse_tri = is_odd.y * (\n        line_0 * tile_x_is_0_or_3 +\n        \n        line_2 * tile_x_is_4_or_7\n    );\n    \n    \n    /*\n    \tCellular data storage uses the fact that on Shadertoy, buffers have the same size as screen.\n     \tSo our tiles get 8x4=32 pixels each and each contains 4 triangles (cells).\n     \tThese 32 pixels of buffer storage are spread over 4 cells.\n\t\tEach cell can use 8 pixels worth of data. Shadertoy provides float32 RGBA buffers,\n\t\tso each cell can have storage represented by 32 floating point numbers grouped into 8 vec4.\n    */\n    vec2 cell_position = vec2(\n        floor(write_coordinate_for_cells.x / 2.0),\n        floor(write_coordinate_for_cells.y / 4.0));\n    \n    Cell cell;\n    fetch_cell(cell_position, cell);\n            \n    float render_intensity = render_intensity_sparse_tri;\n\n    frag_color = vec4(\n        render_intensity * cell.data[0].r,\n        render_intensity * cell.data[0].g,\n        render_intensity * cell.data[0].b,\n    1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    render_visual_pixel(fragColor, vec2(fragCoord.x, iResolution.y - fragCoord.y));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nconst float SCALE = 1.0;\n// const float DAMPING_RATE = 0.2502;\n//const float DAMPING_RATE = 0.252;\nconst float DAMPING_RATE = 0.250019;\n\nconst float VERTICAL_METERS = 100.0;\n\nconst float G = 6.67430e-11;\nconst float PI = 3.14159265358979323846264338327950288419716939937510;\n\nconst float MASS_OF_EARTH = 5.972e24;\nconst float MASS_OF_MOON = 7.34767309e22;\nconst float MASS_OF_SUN = 1.989e30;\n\nconst float DISTANCE_TO_SUN = 1.496e11;\nconst float DISTANCE_TO_MOON = 3.844e8;\n\nconst float ORBITAL_SPEED_OF_EARTH = 29780.0;\nconst float ORBITAL_SPEED_OF_MOON = 1022.0;\n\nfloat gravity_potential (float source_point_mass, vec2 source_position, vec2 at_position) {\n\n    return -1.0 * G * source_point_mass / distance(at_position, source_position);\n}\n\n\nstruct Cell {\n    // 0 - 7\n    /*\n    float a;\n    float b;\n    float c;\n    float d;\n    float e;\n    float f;\n    float g;\n    float h;\n\n    // 8 - 15\n    float j;\n    float k;\n    float l;\n    float m;\n    float n;\n    float o;\n    float p;\n    float q;\n\n    // 16-23\n    float r;\n    float s;\n    float t;\n    float u;\n    float v;\n    float w;\n    float x;\n    float y;\n\n    // 24-31\n    float z;\n    float aa;\n    float ab;\n    float ac;\n    float ad;\n    float ae;\n    float af;\n    float ag;\n\t*/\n    vec4 data[8];\n};\n", "buffer_a_code": "/*\n  Hexagonal lattice can be mapped onto ordinary rectangular texture\n  with odd and even rows interleaving adjacency between cells (texels).\n\n  There is also a minimum adjacency lattice (of only three neighbor cells),\n  which has the same geometry as the hexagonal, it's just missing\n  cells in the centers of the hexagons.\n\n  It is hypothesized that adjacency-3 cells are also enough to fill up\n  3D space with organizing structure of cubeoctahedra.\n\n  The tiling structure 8x4 pixels of the\n  locations of the centers of triangular interconnects:\n\n  01234567\n  a--b----\n  -------- (skip a line completely)\n  ----c--d\n  -------- (skip another line)\n\n  Filling rendering (to show full bodies of the triangles)\n  is irregular and can't be split into rectangular tiles:\n\n  01234567\n  aabb----\n  a--bc--d\n  ----ccdd\n  e--fc--d\n\n*/\n\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nvoid fetch_cell (in vec2 cell_pos, out Cell cell) {\n    \n    vec2 pos = vec2(2.0, 4.0) * cell_pos + 0.5;\n\n\tcell.data[0] = texture(iChannel0, (pos + vec2(0.0, 0.0)) / iChannelResolution[0].xy);\n    cell.data[1] = texture(iChannel0, (pos + vec2(1.0, 0.0)) / iChannelResolution[0].xy);\n    \n    cell.data[2] = texture(iChannel0, (pos + vec2(0.0, 1.0)) / iChannelResolution[0].xy);\n    cell.data[3] = texture(iChannel0, (pos + vec2(1.0, 1.0)) / iChannelResolution[0].xy);\n            \n    cell.data[4] = texture(iChannel0, (pos + vec2(0.0, 2.0)) / iChannelResolution[0].xy);\n    cell.data[5] = texture(iChannel0, (pos + vec2(1.0, 2.0)) / iChannelResolution[0].xy);\n    cell.data[6] = texture(iChannel0, (pos + vec2(0.0, 3.0)) / iChannelResolution[0].xy);\n    cell.data[7] = texture(iChannel0, (pos + vec2(1.0, 3.0)) / iChannelResolution[0].xy);\n}\n\n\nvoid buffer_a_main (out vec4 frag_color, in vec2 frag_coord) { //, in float y_for_mouse) {\n    \n   \n    // The coordinate where vec4 frag_color is getting written.\n    vec2 write_coordinate = floor(frag_coord - 0.5);\n    //vec2 write_coordinate = frag_coord - 0.5;\n    \n    // 8 times per each cell this shader will be called to calculate different components.\n    // We need to compute the index of the target being \"rendered\" to determine what one of the 8\n    // components should be computed in this specific step.\n    vec2 cell_position = write_coordinate / vec2(2.0, 4.0);\n    \n    vec2 is_odd = floor(mod(frag_coord, 2.0));\n    \n    float data_index_y = floor(mod(write_coordinate.y, 4.0));\n    float data_index_x = is_odd.x;\n    \n    float data_index_float = data_index_y * 2.0 + data_index_x;\n    \n    float type = floor(mod(write_coordinate.x * 0.5, 4.0));\n    // float type_top_left = 1.0 - floor(mod(write_coordinate.x, 8.0));\n    \n    //float is_odd_y = mod(frag_coord.y, 2.0);\n    \n    vec2 this_texel = frag_coord/iChannelResolution[0].xy;\n    vec2 texel_step = 1.0 / iChannelResolution[0].xy;\n\n    // r: gravity potential\n    // g: discrete mass at the point or in the vicinity (mostly 0)\n    // b: velocity of the mass transfer (dx/dt)\n    // a: velocity of the mass transfer (dy/dt)\n    \n    \n    //\tCellular data storage uses the fact that on Shadertoy, buffers have the same size as screen.\n    // \tSo our tiles get 8x4=32 pixels each and each contains 4 triangles (cells).\n    // \tThese 32 pixels of buffer storage are spread over 4 cells.\n\t//\tEach cell can use 8 pixels worth of data. Shadertoy provides float32 RGBA buffers,\n\t//\tso each cell can have storage represented by 32 floating point numbers grouped into 8 vec4.\n    \n    // Fetch the previous values of this cell and its 3 neighbors:\n    Cell previous_this_cell_values;\n    fetch_cell(cell_position, previous_this_cell_values);\n    \n    // Fetch left and right cells (exact type depends on the cell type\n    Cell left_cell_values;\n    fetch_cell(cell_position + vec2(-1.0, 0.0), left_cell_values);\n    Cell right_cell_values;\n    fetch_cell(cell_position + vec2(1.0, 0.0), right_cell_values);\n    \n    // Fetch corner cell depending on the cell type\n    vec2 corner_cell_offset = vec2(\n        (2.0 * floor(mod(type, 2.0))) - 1.0,\n        (2.0 * floor(mod(type * 0.5, 2.0))) - 1.0);\n    \n    \n    Cell corner_cell_values;\n    fetch_cell(cell_position + corner_cell_offset, corner_cell_values);\n    \n    \n    vec2 mouse = vec2(iMouse.x, iResolution.y - iMouse.y);\n    vec2 write_coordinate_for_mouse = floor(frag_coord - 0.5) * SCALE;\n    \n    if (iMouse.z > 0.0 && length(mouse - write_coordinate_for_mouse) < 12.0 * SCALE && data_index_float < 0.5) {\n    \tfrag_color = vec4(1.0, 1.0, 1.0, 0.0);\n    } else {\n        if (data_index_float < 0.5) {\n            frag_color = vec4(\n\t        \tDAMPING_RATE * (previous_this_cell_values.data[0].r + left_cell_values.data[0].r + right_cell_values.data[0].r + corner_cell_values.data[0].r),\n                DAMPING_RATE * (previous_this_cell_values.data[0].g + left_cell_values.data[0].g + right_cell_values.data[0].g + corner_cell_values.data[0].g),\n                DAMPING_RATE * (previous_this_cell_values.data[0].b + left_cell_values.data[0].b + right_cell_values.data[0].b + corner_cell_values.data[0].b),\n                DAMPING_RATE * (previous_this_cell_values.data[0].a + left_cell_values.data[0].a + right_cell_values.data[0].a + corner_cell_values.data[0].a)\n\t    \t);\n        } else {\n            frag_color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t}\n\t\t\n    }\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    buffer_a_main(fragColor, vec2(fragCoord.x, fragCoord.y));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 842], [845, 845, 913, 1520, 3912], [3914, 3914, 3971, 3971, 4062]], "test": "untested"}
{"id": "3lyXDt", "name": "london mirror", "author": "isk", "description": "looks best in fullscreen", "tags": ["ifs"], "likes": 5, "viewed": 342, "published": 3, "date": "1583794420", "time_retrieved": "2024-07-30T21:19:27.843792", "image_code": "mat2 rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv=-1.+2.*fragCoord/iResolution.xy;\n    float duv=dot(uv,uv);\n    uv*=.5+.5*duv;\n    uv*=3.+sin(iTime*.123)*2.;\n    for(int i=0;i<13;++i) {\n        uv=abs(uv);\n        uv*=rot(sin(iTime*.0234));\n        uv-=.5;\n        uv*=rot(iTime*.0664);\n    }\n    vec3 col=texture(iChannel0, uv).rgb;\n    col*=1.-.3*duv;\n    fragColor=vec4(col,1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 77], [79, 79, 134, 134, 481]], "test": "untested"}
{"id": "WlySDt", "name": "Multi XOR sorting simplified", "author": "michael0884", "description": "Simplified code. Performance is exactly O(N*floor(log2(N))*ceil(log2(N))).", "tags": ["xor", "sort", "sorting", "parallel"], "likes": 26, "viewed": 1660, "published": 3, "date": "1583790933", "time_retrieved": "2024-07-30T21:19:28.663600", "image_code": "// Fork of \"Multi XOR sorting\" by michael0884. https://shadertoy.com/view/WlySDc\n// 2020-03-09 21:12:12\n\nvoid mainImage( out vec4 U, in vec2 p )\n{\n    p = floor((2.*N/iResolution.x)*p);\n    if(max(p.x, p.y) < N)\t//sorted array\n    {\n       \n    \tU.xyz = texel(ch0,p).xxx;\n    }\n    else if(max(p.x-N, p.y) < N) //sorting quality check\n    {\n        p.x -= N;\n\t\tfloat id = xy2i(p);\n    \tU.xyz = vec3(texel(ch0, i2xy(id+1.)).x < texel(ch0, i2xy(id)).x);\n    }\n    else discard;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 p )\n{  \n    p = floor(p);\n    if(max(p.x, p.y) < N)\n    {\n        //pair ids\n        float id0 = xy2i(p);  //this pixel id\n        float id1 = float(xor_n(int(id0), imod(-iFrame-1, steps))); //pair pixel id, just by flipping first n bits, n - is the step\n  \n        if(id1 < size) // if inside the array - this allows sorting arrays of non power 2 size\n        {\n            float val0 = texel(ch0, i2xy(id0)).x;\n            float val1 = texel(ch0, i2xy(id1)).x;\n            U.x = (id0 > id1) ? max(val0, val1) : min(val0, val1); //swap sorted\n        }\n        else\n        {\n            U = texel(ch0, p);\n        }\n        \n        if(imod(iFrame, steps*stepsf) == 0)\n        {\n            U.x = hash12(p);\n        }\n    }\n    else discard;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define N 300.\n\nfloat size = N*N;\nfloat steps = ceil(log2(N*N));\nfloat stepsf = floor(log2(N*N));\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//mappings\nvec2 i2xy(float id)\n{\n    return vec2(mod(id, N), floor(id/N));\n}\n\nfloat xy2i(vec2 xy)\n{\n    return xy.x + xy.y*N;\n}\n\n//flip lowest n bits\nint xor_n(int x, int n)\n{\n    return x ^ ( (1<<(n+1)) - 1 );\n}\n\nint imod(int a, float b)\n{\n    return a - int(b*floor(float(a)/b));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 146, 146, 477]], "test": "untested"}
{"id": "ttKXDc", "name": "printer", "author": "lennyjpg", "description": "rasterblaster", "tags": ["mono"], "likes": 3, "viewed": 300, "published": 3, "date": "1583790680", "time_retrieved": "2024-07-30T21:19:29.634006", "image_code": "void mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = f.xy / max(res.x,res.y);\n    float t = iTime * 0.37;    \n    vec2 u = fract(uv * 10.);\n    u.x += uv.x + fract(t) * 4.0 - 2.0;\n    float m = abs(u.x + u.y * - 1.);\n    m = smoothstep(m, m + 20. / res.x, 0.3);\n    fragColor = vec4(m);\n}\n\n/*\n// golf version via FabriceNeyret2 \n#define mainImage(O,U)          \\\n    vec2 R = iResolution.xy,    \\\n         u = U/max(R.x,R.y),    \\\n         f = fract(u/.1);      \\\n    O += R.x/20.* (.3 - abs(f.x - f.y + u.x+ fract(iTime*.37)*4.-2. ))\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 330]], "test": "untested"}
{"id": "WtVXDc", "name": "Day 81", "author": "jeyko", "description": "potaot", "tags": ["mdtmjvm"], "likes": 13, "viewed": 402, "published": 3, "date": "1583790472", "time_retrieved": "2024-07-30T21:19:30.440848", "image_code": "// Fork of \"Day 59\" by jeyko. https://shadertoy.com/view/3ldSWf\n// 2020-03-09 12:22:24\n\n// Fork of \"Day 55\" by jeyko. https://shadertoy.com/view/wl3Szs\n// 2020-02-16 14:20:34\n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    #define chromaticAbberationAmt (0.01 + sin(iTime)*0.00)\n    //float f = length(uv  - 0.5);\n    float f = dot(uv  - 0.5,uv  - 0.5);\n    fragColor.x = T(uv + f*chromaticAbberationAmt).x;\n    fragColor.z = T(uv).y;\n    fragColor.y = T(uv -f*chromaticAbberationAmt).z;\n    //fragColor += clamp(texture(iChannel0,uv, 6.), 0., 1.)*0.1;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n#define SPEED 200.\n#define iTime (iTime*SPEED )\n\n#define outline(x, w) (abs(x) - w)\n#define inline(x) -((x)) \n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pmod(a, x) mod(a, x) - x*0.5\n    \n#define pal(a,b,c,d,e) (a + b*sin(tau*(c*d + e)))\n\nvec2 sUv = vec2(0);\n#define mx (10.*iMouse.x/iResolution.x)\n\n\n#define spacing (0.00009)\n#define PLANES 400.\n    \n\n\nfloat xor(float x, float y) {return float(int(x) ^ int(y));}\n\n#define R iResolution.xy\n#define T(e) texture(iChannel0, (e)/R).x\n\nfloat gID;\n\n\nfloat get(vec2 fragCoord){\n    vec2 uv = (fragCoord);\n\n    //uv.x += sin(iTime)*200.;\n    \n    #define modD 100.\n    \n    vec2 id = floor(uv/modD);\n    \n\t//uv = mod(uv, modD);\n\n    //uv -= modD/2.;    \n    \n    uv *= 50. + 00.*iMouse.x/iResolution.x;\n\n    uv.y *= 3.;\n    uv.x *= 3.;\n    \n    \n    float col = 0.;\n    \n    vec2 iuv = vec2(uv);\n    \n    iuv = abs(iuv);\n    \n    //float rep = 10. + sin(floor(gID/0.3)/3.*0.001)*2.;\n    float dd = 40.3;\n    //float rep = 10. + sin(floor(gID/dd)/dd*0.1)*6.;\n    float rep = 20. + sin(floor(gID/dd)/dd*0.4)*5.;\n    iuv = floor(iuv/rep)*rep;\n    \n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    \n    \n    float r = xor(iuv.x, iuv.y);\n    \n    \n    float cumm = 0.;\n    \n    r = xor(iuv.x, iuv.y);\n    \n    \n    r = floor(r*0.006);\n    //r = floor(r*0.0065);\n    for(int i = 0; i < 1; i++){\n        if(floor(mod(r, 5.)) < 3.){\n        \tcumm += r + r + r;\n        }\n        //r += 0.3;\n        \n    }\n    \n    \n    float fr = float(r);\n    \n    \n    col += clamp(cumm, 0., 1.);\n    \n    col -= step(1.-cumm*0.01,0.)*1.;\n    \n    col = clamp(col, 0.,1.);\n    if (col == 0.) \n        col -= col + 1.;\n    return col;\n}\n\n\nfloat aa ( vec2 U) {\n\t\n\tvec3 col = vec3(0);\n    float st = 0.04;    \n    \n    // antialiasing\n    \n    float t = get(U);\n    float n = get(U + vec2(0.,st));\n    float w = get(U + vec2(0.,-st));\n    float e = get(U + vec2(st,0.));\n    float s = get(U + vec2(-st,0.));\n    \n    float ne = get(U + vec2(st,st));\n    float ns = get(U + vec2(-st,st));\n    float sw = get(U + vec2(st,-st));\n    float se = get(U + vec2(-st,-st));\n    \n    \n    float cumm = t + n + w + e + s + ne + ns + sw + se;\n    \n    //col += cumm/9.;\n    //col += (t + n + w + e + s )/5.;\n    col += (e + w)/2.;\n    \n    return col.x;\n\t\n}\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 p0, vec3 n){\n    float denom = dot(rd,n);\n    if (denom > 1e-6) {\n        float t = - dot(ro - p0, n)/denom; \n\t\tif (t > 0.) return t;\n        return t;\n    }  \n    return 1e10;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tsUv = uv;\n    uv *= 1. + dot(uv,uv)*4.;\n    \n    vec3 col = vec3(-0.0);\n\t\n    vec3 ro = vec3(0);\n    \n    \n    vec3 rd = normalize(vec3(uv,1));\n   \n    //ro.x -= 200.2;\n    ro -= rd*texture(iChannel0,60.*sUv*256.).x*0.0002;\n    \n    \n    //ro.x += 0.0 + mx*0.01;\n    ro.x += 0.033 + mx*0.01;\n    //ro.y += 0.004;\n    \n    rd.xy *= rot(1.6 );\n    rd.xz *= rot(0. + sin(iTime/SPEED)*0.06);\n    \n    #define fog(a) smoothstep(1., 0., a*23.4)\n    \n    float accum = 0.;\n    \n    float plA;\n    float m = 0.;\n    for(float i = 0.; i < PLANES + float(min(iFrame, 0)) ; i++ ){\n    \tplA = iPlane(ro, rd, vec3(0,0,mod(-iTime + i,PLANES))*spacing, vec3(0,0,1));\n        vec2 u = (ro+rd*plA).xy;\n        m = max(m, plA);\n    \t//col += sumonTheDemon( u, floor((-mx+i)/PLANES)*PLANES + i)*fog(plA);\n        gID = floor((-mx+i)/PLANES)*PLANES + i;\n        float g = smoothstep(0.,1., abs(aa( u*450.)));\n        accum += clamp(1. - g, 0., 1.)*0.06*fog(plA)*(smoothstep(1.,0.,accum*6.));\n        \n        //col += (1. - g)*fog(plA)*0.8;\n    }\n    col += accum;\n    \n    //col = mix(col, vec3(0),smoothstep(1.,0.,accum*6.));\n    \n    col *= 3.;\n    col = smoothstep(0.,1.,col);\n    col = smoothstep(0.,0.9,col);\n    col *= 1.9;\n    \n    col *= vec3(1.41,0.9,0.9);\n    col = 1. - col;\n    \n    \n    col *= 1. - 1.7*vec3(0.14 ,0.4 + sin(iTime/SPEED)*0.1,0.4)*pow(smoothstep(0.,1.,(1. - accum)*0.76), 3.);\n    \n    col *= 1. - dot(sUv,sUv)*vec3(1.8,0.7,0.8);\n    //col -=  0.8*vec3(0.7,0.4,0.5)*pow(smoothstep(0.,1.,(1. - accum)*0.87), 5.);\n    //col -= 0.5*vec3(0.7,0.9,0.5);\n    //col = pow(col, vec3(0.45));\n\t//#define pal(a,b,c,d,e) (a + b*sin(6.28*(c*d + e)))\n    \n    //col *= pal(1.,0., vec3(0.7,0.3,0.7), 0.9,0.9);\n    //col *= vec3(1.11,1.05,1.04);\n    \n    col = max(col, 0.);\n    col = pow(col, vec3(1. + 0.1*length(uv)));\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 271, 271, 650]], "test": "untested"}
{"id": "wtGSWG", "name": "ölaksdfgjalködjf", "author": "lennyjpg", "description": "sadasdfa", "tags": ["asdfasdfasdf"], "likes": 5, "viewed": 334, "published": 3, "date": "1583786314", "time_retrieved": "2024-07-30T21:19:31.250683", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;  \n    vec2 u = uv;\n    u *= 1.;\n    float t = iTime * 3.3;\n    float e = u.y - 0.3 ;\n    e += sin(u.x * 7.0 - t ) * .1;\n    float f = pow(u.x - 0.5,2.0)*3.0;\n    e += sin(f*1.0+t*0.5)*0.1;\n    e -= cos(u.x*17.241-t*1.22)*0.02;\n    e*=2.5;\n    float k = smoothstep(e,f,f*1.05); \n    float m = step(f,e);\n    vec3 a = vec3(33.,33.9,1.1);\n    vec3 b = vec3(1.0,0.2,0.3);\n    vec3 c = mix(a,b,m / k);\n    c.r *= uv.x / uv.y;\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 549]], "test": "untested"}
{"id": "wtVXDc", "name": "Some weird particle stuff", "author": "michael0884", "description": "Using the multi XOR sort to sort particles on a z-order curve. WIP", "tags": ["xor", "sort", "sorting", "parallel"], "likes": 5, "viewed": 376, "published": 3, "date": "1583784036", "time_retrieved": "2024-07-30T21:19:32.287910", "image_code": "// Fork of \"Bitonic sorting network\" by michael0884. https://shadertoy.com/view/ttVXDV\n// 2020-03-08 15:43:17\n\n//get particle id from id array\nvec2 getID(float id, float LI)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x+LI*N,y)).xy;\n}\n\n\n//random binary array id search\nvec2 search(int zid, float LI)\n{\n    float L = 0., R = N*N-1.;\n    vec4 p;\n    float i = 0.;\n    while(L!=R && i < log2(N))\n    {\n        i++;\n    \tfloat lid = floor((L+R)/2.);\n        float zid0 = getID(lid, LI).y; \n        float k = 0.5;\n        if(float(zid) < zid0)\n        {\n            R = (1.-k)*lid+R*k;\n        }\n        else\n        {\n            L = (1.-k)*lid+L*k;\n        }\n    }\n    return vec2(L,R);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n#define R 8.\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec2 pn = floor(1.*p);\n    p = floor(vec2(1.,1.)*p);\n    if(pn.x < LN*N && pn.y < N)\n    {\n    \tvec2 a = texel(ch1, pn).xy;\n        fragColor.xyz = jet_range(a.y, 0., 3e9);\n    }\n    else\n    {\n        int zid = xy2z(p);\n        //render points using last LN particle sorts\n        for(float li = 0.; li < LN; li++)\n        {\n            vec2 lid = search(zid, li);\n            fragColor.xyz = vec3(0);\n            for(float i = lid.x;i <= lid.y; i++)\n            {\n                vec4 a0 = getParticle(getID(i, li).x);\n                fragColor.xyz += vec3(gauss(length(p - a0.xy), 2.));\n            }\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\n#define D 6.\n\n//get particle id from id array\nvec2 getID(float id, float LI)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x+LI*N,y)).xy;\n}\n\n\n//random binary array id search\nvec2 search(int zid, float LI)\n{\n    float L = 0., R = N*N-1.;\n    vec4 p;\n    float i = 0.;\n    while(L!=R && i < log2(N))\n    {\n        i++;\n    \tfloat lid = floor((L+R)/2.);\n        float zid0 = getID(lid, LI).y; \n        float k = 0.5;\n        if(float(zid) < zid0)\n        {\n            R = (1.-k)*lid+R*k;\n        }\n        else\n        {\n            L = (1.-k)*lid+L*k;\n        }\n    }\n    return vec2(L,R);\n}\n\nvec2 nz(vec2 a)\n{\n    return (a.x == 0. && a.y == 0.)?vec2(0.):normalize(a);\n}\n\nvec2 cF(vec2 p)\n{\n    vec4 a = getParticle(p, vec2(0));\n    vec2 F = vec2(0.);\n   \n    int zid = xy2z(a.xy);\n    vec2 lid = search(zid, 0.);\n\n    for(float i = lid.x;i <= lid.y; i++)\n    {\n        vec4 a0 = getParticle(getID(i, 0.).x);\n        float d = distance(a0.xy, a.xy);\n        F += nz(a0.xy - a.xy)*abs(d - D)*exp(-0.08*d);\n    }\n    return F;\n    \n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n        \n        vec2 F = -0.1*cF(pos);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F -= 5.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += dt*F;\n        U.zw *= 0.9;\n        U.xy += U.zw*dt;\n        \n \n        //this pixel value\n        if(iFrame<1)\n        {\n            \n            U.xy = D*pos;\n\t\t\tU.zw = hash22(3.14159*pos) - 0.5;\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//N^2 is the point number\n#define N 65.\n#define dt 0.4\n\n//save N last iterations\n#define LN 1.\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nuniform sampler2D fake;\n\nvec4 getParticle(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(fake, vec2(x,y));\n}\n   \nvec4 getParticle(vec2 id, vec2 did)\n{\t\n    vec2 nid = id+did;\n    if(max(nid.x, nid.y) < N && min(nid.x, nid.y) >=0.) \n    {\n    \treturn texel(fake, nid);\n    }\n    else\n    {\n        return texel(fake, id);\n    }\n  \n}\n//from https://www.shadertoy.com/view/3tj3Rc\n\nint MASKS[] = int[] (0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF);\n\n//2d z-curve index\nint xy2z(vec2 U) {       // --- grid location to curve index\n    ivec2 I = ivec2(U*100.);\n    int n=8;\n    for (int i=3; i>=0; i--)\n        I =  (I | (I << n)) & MASKS[i],\n        n /= 2;\n    return I.x | (I.y << 1);\n}\n", "buffer_b_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        int maxorder = int(ceil(log2(N*N)));\n\n        int frame = iFrame;\n        float order = float(imod(frame, maxorder));\n        float oe = float(imod(frame, 2));\n\n        //pair id\n        float pid = XORN(id+oe, order)-oe; \n\n        if(pid < N*N) //if inside the array\n        {\n            U.xy = sort(id, pid); //swap sorted\n        }\n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        int maxorder = int(ceil(log2(N*N)));\n\n        int frame = -2*iFrame;\n        float order = float(imod(frame, maxorder));\n        float oe = float(imod(frame, 2));\n\n        //pair id\n        float pid = XORN(id+oe, order)-oe;\n\n        if(pid < N*N) //if inside the array\n        {\n            U.xy = sort(id, pid); //swap sorted\n        }\n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < LN*N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch2, pos);\n        if(pos.x < N)\n        {\n            float id = pos.x + pos.y*N;  \n\n            int maxorder = int(ceil(log2(N*N)));\n\n            int frame = -2*iFrame-1;\n            float order = float(imod(frame, maxorder));\n            float oe = float(imod(frame, 2));\n\n            //pair id\n            float pid = XORN(id+oe, order)-oe;\n\n            if(pid < N*N) //if inside the array\n            {\n                U.xy = sort(id, pid); //swap sorted\n            }\n\n            if(iFrame < 1)\n            {\n                U.x = id;\n            }\n        }\n        else\n        {\n            if(imod(iFrame, 2) == 0)\n            {\n            \tfloat LI = pos.x/N;\n            \tU = texel(ch2, pos - vec2(N,0.)); //store last in next\n            }\n        }\n       \n    }\n    else discard;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 143, 175, 175, 302], [305, 337, 369, 369, 753], [755, 755, 786, 786, 820], [836, 836, 885, 885, 1511]], "test": "untested"}
{"id": "wlKXWc", "name": "cables2", "author": "yuntaRobo", "description": "Sphere and cables.", "tags": ["raymarching", "torus", "sphere", "cables"], "likes": 115, "viewed": 4525, "published": 3, "date": "1583773251", "time_retrieved": "2024-07-30T21:19:33.224406", "image_code": "const float PI = 3.1415926;\nconst float TAU = PI * 2.0;\nconst float E = 0.01;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\nvec2 de(vec3 p)\n{\n    float d = 100.0;\n    float a = 0.0;\n\n    p.yz *= rotate2D(PI / 5.0);\n    p.y -= 0.5;\n\n    // reaction\n    vec3 reaction = vec3(cos(iTime), 0.0, sin(iTime)) * 3.0;\n    p += exp(-length(reaction - p) * 1.0) * normalize(reaction - p);\n    \n    // cables\n    float r = atan(p.z, p.x) * 3.0;\n    const int ite = 50;\n    for (int i = 0; i < ite; i++)\n    {\n        r += 0.5 / float(ite) * TAU;\n        float s = 0.5 + sin(float(i) * 1.618 * TAU) * 0.25;\n        s += sin(iTime + float(i)) * 0.1;\n        vec2 q = vec2(length(p.xz) + cos(r) * s - 3.0, p.y + sin(r) * s);\n        float dd = length(q) - 0.035;\n        a = dd < d ? float(i) : a;\n    \td = min(d, dd);\n    }\n\n    // sphere\n    float dd = length(p - reaction) - 0.1;\n    a = dd < d ? 0.0 : a;\n    d = min(d, dd);\n\n    return vec2(d, a);\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    float ad = 0.0;\n    for (float i = 1.0; i > 0.0; i -= 1.0 / 128.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            color = mix(vec3(0.1, 0.1, 0.5), vec3(0.0, 0.0, 1.0), fract(o.y * 1.618));\n            color = mix(vec3(1.0, 1.0, 1.0), color, step(0.05, fract(o.y * 1.618)));\n            color = mix(vec3(0.175, 0.1, 0.1), color, step(0.35, fract(o.y * 1.618 + 0.9)));\n            color *= exp(-(1.0 - i) * 15.0);\n            return;\n        }\n\n        o.x *= 0.6;\n        ray.pos += ray.dir * o.x;\n        ad += o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n    \n    color = mix(vec3(0.0), vec3(1.0), ray.dir.y * ray.dir.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.0);\n\n    vec3 view = vec3(0.0, 0.0, 10.0);\n    vec3 at = normalize(vec3(0.0, 0.0, 0.0) - view);\n    vec3 right = normalize(cross(at, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, at);\n    float focallength = 3.0;\n\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n    \n    trace(ray, color, 20.0);\n\n    color = pow(color, vec3(0.454545));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 150, 150, 230], [232, 232, 249, 249, 1047], [1049, 1049, 1098, 1098, 1785], [1787, 1787, 1844, 1844, 2386]], "test": "untested"}
{"id": "tlVXD3", "name": "Filmic Tonemap Fast", "author": "spalmer", "description": "I was toying around and came up with a simple, fast Reinhard approximation to the combined ACES+sRGB gamma operations.", "tags": ["gamma", "hdr", "filmic", "tonemap", "srgb", "aces"], "likes": 11, "viewed": 2716, "published": 3, "date": "1583767182", "time_retrieved": "2024-07-30T21:19:34.106049", "image_code": "int method; // global variable only for this toy;\n// my actual codebase uses a separate function \n// for each operator and the inverse thereof.\n\n    //c = max(0., c); // pow doesn't appreciate negatives but here we never have any\n\n// my curve can be tuned for various gamma approximations etc.\n// but would need to adjust the inverse operator to match.\n// I figure being close to ACES is probably not a bad thing.\n\n// the ACES filmic tonemap operator explained here:\n//   http://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve\n// main ACES site on github, for further reference:\n//   http://github.com/ampas/aces-dev\n\n// anyway it's not precisely ACES+sRGB, it wiggles around it like 3 times,\n// has in fact a little deeper toe as you can see a slight band between \n// the red and green swatches in this toy.  But that's partially because\n// this one isn't tuned to the precise scale I had in the other toy\n// where I was actually trying to match it as exactly as possible.\n// point is, I'm sure it can be tuned to match ACES a little better \n// if you care enough to run some optimizer on it.\n\n// I mostly tend to care about low-exposure scenes, so I'm probably\n// not the most knowledgeable tone mapping guru around,\n// so if anyone has any suggestions, I'm all ears.\n\n// linear to sRGB\nfloat toneMap(float c)\n{\n    switch (method) {\n  \t  case 0: // to sRGB gamma via filmic-like Reinhard-esque combination approximation\n\t    c = c / (c + .1667); // actually cancelled out the gamma correction!  Probably cheaper than even sRGB approx by itself.\n\t\tbreak; \t// considering I can't tell the difference, using full ACES+sRGB together seems quite wasteful computationally.\n  \t  case 1: // ACES+sRGB, which I approximated above\n\t    c = ((c*(2.51*c+.03))/(c*(2.43*c+.59)+.14));\n\t    c = pow(c, 1./2.2); // to sRGBish gamut\n\t    break;\n  \t  default: // sRGB approx by itself\n\t    c = pow(c, 1./2.2);\n        break;\n    }\n    return c;\n}\n\n// sRGB to linear\nfloat unToneMap(float c)\n{\n    switch (method) {\n  \t  case 0: // via inverse filmic-like Reinhard-esque combination approximation\n        c = c/(6.-6.*c);\n\t\tbreak;\n      case 1: // inverse ACES+sRGB\n        c = pow(c, 2.2); // from sRGBish gamut\n        c = -(sqrt((-10127.*c+13702.)*c+9.)+59.*c-3.) / (486.*c-502.); // inverse ACES according to Maxima\n\t    break;\n      default: // just approx un-sRGB\n        c = pow(c, 2.2);\n        break;\n    }\n    return c;\n}\n\n// combined exposure, tone map, gamma correction\nvec3 toneMap(vec3 crgb, float exposure) // exposure = white point\n{\n    vec4 c = vec4(crgb, exposure);\n    for (int i = 4; i-- > 0; ) c[i] = toneMap(c[i]);\n    // must compute the tonemap operator of the exposure level, although optimizes out at compile time, \n    // do it all in vec4 and then divide by alpha.\n    return c.rgb / c.a;\n}\n\n// for completeness - sRGB gamma tonemapped color back to linear - inverse tone map\nvec3 unToneMap(vec3 crgb, float exposure)\n{\n    vec3 c = crgb * toneMap(exposure);\n    for (int i = 3; i-- > 0; ) c[i] = unToneMap(c[i]);\n    return c;\n}\n\nvec3 dither(vec3 c, vec2 p)\n{\n    float x; // noise\n    x = fract(iTime*0. + 23456.7*sin(dot(p, vec2(12.93,8.57)))); // from ALU hash\n    x = 2. * x - 1.; // signed\n    c += .75 * exp2(-8.) * x; // tuned for 8 bits per channel\n    return c;\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    if (iChannelResolution[0].x == 0.) { o = vec4(1,0,0,1); return; } // hopefully fix the toy warning by handling texture not yet loaded!?\n    vec2 uv = p / iResolution.xy;\n    vec4 t = texture(iChannel0, uv);\n    t.rgb = pow(t.rgb, vec3(2.2)); //t.rgb*t.rgb; // from sRGB\n    vec3 c = t.rgb;\n    const float vary = 3.; //.1; //1.; //24.; //.5; //\n    const float lowest = .1; //1.; //.25; //.5; //\n    float expo = (sin(iTime*1.2) + 1.) * vary + lowest;\n    // blow out! or try, anyway.  or dim.\n    // tonemap can handle either way ok\n    // but it does affect the color balance\n    c *= expo;\n    method = int((uv.x + iTime * .01) * 6.) % 3; //0; //1; //\n  #if 0\n    // roundtrip debugging\n    if ((iFrame & 16) != 0) { // fast flicker means botched.  no flicker means success!\n    c = toneMap(c, expo);\n    c = unToneMap(c, expo);\n    }\n  #endif\n    c = toneMap(c, expo);\n    // color code method at bottom (red = my approx, green = ACES+sRGB, blue = just sRGB)\n    if (abs(uv.y-.5)>.495) c = pow(max(vec3(0),cos(float(method) * 2. - vec3(0,2,4))), vec3(.45));\n\tc = dither(c, p);\n\to = vec4(c, 1);\n}\n\n\n// or you could try to correct for exposure first\n// but then there's not nearly so much need for tonemap.\n// but sRGB would still be desirable.\n\n\n// I have many other approximations to filmic tonemap curve\n// but at this point am unsure of most of their relationship to sRGB.\n// ACES at least I know is supposed to precede sRGB gamma correction.\n\n\n// by sRGBish gamma I mean using the \n// approximate power of 2.2 way,\n// which is not the high-quality conversion,\n// but close enough for shaders.\n// heck, even x*x and sqrt(x) would be fine, really.\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1290, 1308, 1332, 1332, 1950], [1952, 1970, 1996, 1996, 2434], [2436, 2485, 2552, 2552, 2822], [2824, 2908, 2951, 2951, 3061], [3063, 3063, 3092, 3092, 3305], [3307, 3307, 3343, 3343, 4447]], "test": "untested"}
{"id": "wlGSWc", "name": "Wythoffian Tiling Generator", "author": "mla", "description": "A variation of Knighty's [url]https://www.shadertoy.com/view/4sf3zX[/url] with some extra features. \n\nInspiration also from fizzer's [url]https://www.shadertoy.com/view/3tyXWw[/url].\n\nMouse, arrow keys etc: see code header.", "tags": ["tiling", "hyperbolic", "snub", "wythoffian"], "likes": 25, "viewed": 1317, "published": 3, "date": "1583766198", "time_retrieved": "2024-07-30T21:19:35.246998", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Wythoffian Tiling Generator\n//\n// Spherical, Euclidean, and Hyperbolic tilings, including duals and snubs.\n//\n// Based on Knighty's excellent 'Tilings': https://www.shadertoy.com/view/4sf3zX\n//\n// Modified by Matthew Arcus, mla, 9/3/2020\n//\n// Fundamental triangle angles are PI/P, PI/Q, PI/R and an appropriate\n// geometry is selected for the specified angles.\n//\n// P and Q are fixed in the code (but of course may be changed), R varies,\n// either automatically or with <left>/<right> keys.\n//\n// By default, display cycles through the 7 uniform tilings based on\n// the underlying triangle, as well as the snub form. Triangle goes\n// through (2,3,5),(2,3,6),(2,3,7), etc.\n//\n// <mouse>: apply appropriate isometry to tiling\n// <up>/<down>: zoom in/out\n// <left>/<right>: select R angle of fundamental triangle\n// d: show dual\n// f: use plain fill for tiles\n// p: show region parity\n// s: just show snub forms\n// t: show main tiling\n// x: texture tiles\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n// Original header\n////////////////////////////////////////////////////////////////////////////////\n// triangular groups tessellations. Coxeter group p-q-r. Stereographic\n// projection. \n// adapted from fragmentarium script.see:\n// http://www.fractalforums.com/fragmentarium/triangle-groups-tessellation/\n// Licence: free.\n// the type of the space embedding the tessellation depend on the value:\n// 1/p+1/q+1/r\n// if >1 its the sphere\n// if =1 its the euclidean plane\n// if <1 its the hyperbolic plane\n//  \n// Distance estimation to lines and vertices is used for antialiasing.\n// You can still improve quality by using antialiasing.\n////////////////////////////////////////////////////////////////////////////////\n\nbool snubify = false;\nbool dofill = true;\nbool dodual = true;\nbool dotiling = true;\nbool dotexture = true;\nbool doparity = true;\n\n// These are the p, q and r parameters that define the Coxeter/triangle group\nint P = 2; // Pi/p: angle beween reflexion planes a and b.\nint Q = 3; // Pi/q: angle beween reflexion planes b and c.\nint R = 3; // Pi/r: angle beween reflexion planes c and a.\n\n// Iteration number.\nconst int Iterations = 30;\n\n// Colors\nconst vec3 segColor        = vec3(0,0,0);\nconst vec3 dualColor       = vec3(1,0,0);\nconst vec3 backgroundColor = vec3(0);\nconst vec3 fillColor = vec3(1,1,0.7);\nconst vec3 faceColor0 = vec3(1,1,0);\nconst vec3 faceColor1 = vec3(0,1,1);\nconst vec3 faceColor2 = vec3(0,0,1);\nconst vec3 snubColor = vec3(0,1,0);\n\nvec3 A,B,C; // The vertices of the triangle\nfloat K = 0.0; // spaceType\nvec3 na,nb,nc; // The normals of the reflexion planes, na = (1,0,0),\nvec3 bary; // Barycentre coordinates of \"Wythoff point\"\n\nfloat aaScale = 0.005; //anti-aliasing scale == half of pixel size.\n\nconst float PI = 3.14159265;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;;\n}\n\n//#define assert(e)\n\n////////////////////////////////////////////////////////////////////////////////\n// Geometry\n////////////////////////////////////////////////////////////////////////////////\n\n// For hyperbolic and spherical geometry, hdott(p,q) = -hdots(p,q)\nfloat hdott(vec3 a, vec3 b){\n  //dot product for \"time like\" vectors.\n  return K*dot(a.xy,b.xy)+a.z*b.z;\n}\nfloat hdots(vec3 a, vec3 b){\n  //dot product for \"space like\" vectors (these are duals of the \"time like\" \n  //vectors).  \n  return dot(a.xy,b.xy)+K*a.z*b.z;\n}\nfloat hlengtht(vec3 v){\n  return sqrt(abs(hdott(v,v)));\n}\nfloat hlengths(vec3 v){\n  return sqrt(abs(hdots(v,v)));\n}\nvec3 hnormalizet(vec3 v){\n  // normalization of \"time like\" vectors.\n  return v/hlengtht(v);\n}\nvec3 hnormalizes(vec3 v){\n  //normalization of \"space like\" vectors (not used).\n  return v/hlengths(v);\n}\n\n/////////////////////////////////////////////////\n\nvoid initialize() {\n  // Set the space type\n  K = float(sign(Q*R+P*R+P*Q-P*Q*R)); // 1/P+1/Q+1/R-1;\n\n  float cospip=cos(PI/float(P)), sinpip=sin(PI/float(P));\n  float cospiq=cos(PI/float(Q)), sinpiq=sin(PI/float(Q));\n  float cospir=cos(PI/float(R)), sinpir=sin(PI/float(R));\n  float ncsincos=(cospiq+cospip*cospir)/sinpip;\n\n  // dot(na,nb) = -cos(PI/P)\n  // dot(nb,nc) = -cos(PI/Q)\n  // dot(nc,na) = -cos(PI/R)\n  // |na| = |nb| = |nc| = 1\n  na = vec3(1,0,0);\n  nb = vec3(-cospip,sinpip,0);\n  nc = vec3(-cospir,-ncsincos,sqrt(abs(1.0-cospir*cospir-ncsincos*ncsincos)));\n  if (K == 0.0) {\n    // This case is a little bit special - nc.z doesn't enter into\n    // inner product, but acts as a scaling factor.\n    nc.z = 0.25;\n  }\n\n  // \"vertices\" of the \"triangle\" made by the reflexion planes\n  A = cross(nb,nc); //vec3(nb.y*nc.z,-nb.x*nc.z,nb.x*nc.y-nb.y*nc.x);\n  B = cross(nc,na); //vec3(0,nc.z,-nc.y);\n  C = cross(na,nb); //vec3(0,0,nb.y);\n}\n\nvec3 reflecta(vec3 z) {\n  return z*vec3(-1,1,1);\n}\n\nvec3 reflectb(vec3 z) {\n  return z-2.0*dot(nb,z)*nb;\n}\n\nvec3 reflectc(vec3 z) {\n  // Only need spaceType for this\n  return z-2.0*dot(nc,z)*nc*vec3(1,1,K);\n}\n\nvec3 fold(vec3 pos, inout int flips) {\n  for (int i=0; i<Iterations; i++) {\n    int flips0 = 0;\n    flips0 += int(pos.x < 0.0);\n    pos.x = abs(pos.x); // Reflect in y-axis - always a line of symmetry\n    float t = 2.0*min(0.0,dot(nb,pos));\n    flips0 += int(t < 0.0);\n    pos -= t*nb;\n    t = 2.0*min(0.0,dot(nc,pos));\n    flips0 += int(t < 0.0);\n    pos -= t*nc*vec3(1,1,K);\n    if (flips0 == 0) break;\n    //pos = hnormalizet(pos); // TBD: test this..\n    flips += flips0;\n  }\n  return pos;\n}\n\nfloat DD(float t, float r2){\n  // Stereographic projection\n  //return t*(1.0+K*r2); // TBD: test this..\n  return t*(1.0+K*r2)/(1.0+K*K*sqrt(r2)*t);\n}\n\nfloat hdistance(vec3 p, vec3 q) {\n  return hlengths(p-q)/hlengtht(p+q);\n}\n\nfloat hangle(vec3 p, vec3 q, vec3 r) {\n  // Return cosine of angle at p\n  return hdots(p-q,p-r);\n}\n\n// Distance to half-line from p in direction n.\nfloat dist2Segment(vec3 z, vec3 p, vec3 n, float r2, float radius){\n  // pmin is the orthogonal projection of z onto the plane defined by p and n\n  // then pmin is projected onto the unit sphere\n\t\n  // we are assuming that p and n are normalized. If not, we should do: \n  mat2 smat=mat2(vec2(hdots(n,n),hdots(p,n)),vec2(hdott(p,n),hdott(p,p)));\n  //mat2 smat=mat2(1,hdots(p,n),hdott(p,n),1);\n\n  // v is the components of the \"orthogonal\" projection (depends on the\n  // metric) of z on the plane defined by p and n wrt to the basis (p,n)\n  vec2 v = smat*vec2(hdott(z,p),-hdots(z,n));\n  v.y = min(0.0,v.y); //crops the part of the segment past the point p\n\t\n  vec3 pmin = hnormalizet(v.x*p-v.y*n);\n  \n  float t = hdistance(pmin,z);\n  return DD((t-radius)/(1.0+K*t*radius),r2); // Return distance to \"cylinder\"\n}\n\nvoid snubdual(vec3 z, vec3 p, float r2, float radius, inout float dmin) {\n  dmin = min(dmin,dist2Segment(z,p,A-p,r2,radius));\n  dmin = min(dmin,dist2Segment(z,p,B-p,r2,radius));\n  dmin = min(dmin,dist2Segment(z,p,C-p,r2,radius));\n}\n\nfloat dist2Tiling(vec3 z, vec3 p, float r2, bool parity) {\n  const float radius = 0.01;// Thickness of the lines\n  float dmin = 1e8;\n  if (!snubify) {\n    dmin = min(dmin,dist2Segment(z,p,-na,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,-nb,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,-nc*vec3(1,1,K),r2,radius));\n  } else if (!parity) {\n    // The six rays from the triangle point.\n    vec3 p0 = reflecta(reflectb(p));\n    vec3 p1 = reflectb(reflecta(p));\n    vec3 p2 = reflectb(reflectc(p));\n    vec3 p3 = reflectc(reflectb(p));\n    vec3 p4 = reflectc(reflecta(p));\n    vec3 p5 = reflecta(reflectc(p));\n    dmin = min(dmin,dist2Segment(z,p,p0-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p1-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p2-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p3-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p4-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p5-p,r2,radius));\n  } else {\n    // The three rays passing through the other triangle.\n    vec3 p0 = reflecta(p);\n    vec3 p1 = reflectb(p);\n    vec3 p2 = reflectc(p);\n    dmin = min(dmin,dist2Segment(z,p0,p1-p0,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p1,p2-p1,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p2,p0-p2,r2,radius));\n  }\n  return dmin;\n}\n\nfloat dist2Dual(vec3 z, vec3 p, float r2, bool parity) {\n  const float radius = 0.008; // Thickness of the lines\n  float dmin = 1e8;\n  if (!snubify) {\n    if (bary.z != 0.0) dmin = min(dmin,dist2Segment(z,A,B-A,r2,radius));\n    if (bary.x != 0.0) dmin = min(dmin,dist2Segment(z,B,C-B,r2,radius));\n    if (bary.y != 0.0) dmin = min(dmin,dist2Segment(z,C,A-C,r2,radius));\n  } else {\n    // Centre of snub triangle. Should check this is valid!\n    vec3 f = (reflecta(p)+reflectb(p)+reflectc(p))/3.0;\n    // Snub dual method from fizzer.\n    if (parity) {\n      snubdual(z,f,r2,radius,dmin);\n    } else {\n      snubdual(reflecta(z),f,r2,radius,dmin);\n      snubdual(reflectb(z),f,r2,radius,dmin);\n      snubdual(reflectc(z),f,r2,radius,dmin);\n    }\n  }\n  return dmin;\n}\n\nvec3 color(vec2 z, vec3 p){\n  float r2 = dot(z,z);\n  vec3 z3 = vec3(2.0*z,1.0-K*r2)/(1.0+K*r2);\n  int flips = 0;\n  z3 = fold(z3,flips);\n  bool parity = (flips&1) == 0;\n  vec3 color = backgroundColor;\n  // Fill in the tile colors. This can probably be simplified.\n  if (dofill) {\n    color = fillColor;\n  } else if (!snubify) {\n    // Non-chiral case, just 3 sectors of triangle.\n    bool side0 = dot(z3,cross(p,na)) < 0.0;\n    bool side1 = dot(z3,cross(p,nb)) < 0.0;\n    bool side2 = dot(z3,cross(p,nc*vec3(1,1,K))) < 0.0;\n    if (side0 && !side1) color = faceColor0;\n    else if (side1 && !side2) color = faceColor1;\n    else if (side2 && !side0) color = faceColor2;\n  } else if (!parity) {\n    // Triangle contains snub Wythoff point, p, there are\n    // 6 sectors, boundaries are between p and it's 6\n    // double reflections.\n    vec3 p0 = reflecta(reflectb(p));\n    vec3 p1 = reflectb(reflecta(p));\n    vec3 p2 = reflectb(reflectc(p));\n    vec3 p3 = reflectc(reflectb(p));\n    vec3 p4 = reflectc(reflecta(p));\n    vec3 p5 = reflecta(reflectc(p));\n    bool side0 = dot(z3,cross(p,p0)) < 0.0;\n    bool side1 = dot(z3,cross(p,p1)) < 0.0;\n    bool side2 = dot(z3,cross(p,p2)) < 0.0;\n    bool side3 = dot(z3,cross(p,p3)) < 0.0;\n    bool side4 = dot(z3,cross(p,p4)) < 0.0;\n    bool side5 = dot(z3,cross(p,p5)) < 0.0;\n    if (side1 && !side0) color = faceColor1;\n    if (side2 && !side1) color = snubColor;\n    if (side3 && !side2) color = faceColor2;\n    if (side4 && !side3) color = snubColor;\n    if (side5 && !side4) color = faceColor0;\n    if (side0 && !side5) color = snubColor;\n  } else {\n    // The other triangle, containing the centre of\n    // a snub triangle. The three sides of the snub triangle\n    // pass through region.\n    vec3 p0 = reflecta(p);\n    vec3 p1 = reflectb(p);\n    vec3 p2 = reflectc(p);\n    bool side0 = dot(z3,cross(p0,p1-p0)) < 0.0;\n    bool side1 = dot(z3,cross(p1,p2-p1)) < 0.0;\n    bool side2 = dot(z3,cross(p2,p0-p2)) < 0.0;\n    if (side0) color = faceColor1;\n    else if (side1) color = faceColor2;\n    else if (side2) color = faceColor0;\n    else color = snubColor;\n  }\n  \n  if (doparity && parity) color *= 0.9; // Antialias this?\n\n  if (dotexture) color *= 0.8+0.2*texture(iChannel2, z3.xy + 0.0*iTime).r;\n\n  //antialiasing using distance de segments and vertices (ds and dv) \n  //(see:https://iquilezles.org/articles/distance)\n  if (dodual) {\n    float ds = dist2Dual(z3,p,r2,parity);\n    color = mix(dualColor,color,smoothstep(-1.0,1.0,ds/aaScale));\n  }\n  if (dotiling) {\n    float ds = dist2Tiling(z3, p, r2, parity);\n    color = mix(segColor,color,smoothstep(-1.0,1.0,ds/aaScale));\n  }\n\t\n  // Final touch in order to remove jaggies at the edge of the circle\n  // (for hyperbolic case)\n  if (K == -1.0) {\n    color = mix(backgroundColor,color,\n                smoothstep(-1.0,1.0,(1.0-sqrt(r2))/aaScale));\n  }\n  return color;\n}\n\n// Decode integer k bitwise as bary coords.\nvec3 getbary(int k) {\n  k = 1+(k%7);\n  return vec3((k>>0)&1,(k>>1)&1,(k>>2)&1);\n}\n\n// Find bary coords of point whose 3 reflections form an equilateral triangle.\n// Fairly standard application of 2-dimensional Newton-Raphson.\n// It's pretty silly doing this in a fragment shader, but it's fun.\n// There are ways of directly calculating the \"Fermat point\", but\n// I haven't tried that for non-euclidean triangles.\nvec2 eval(vec2 s) {\n  vec3 t = mat3(A,B,C)*vec3(s,1.0-s.x-s.y);\n  vec3 p0 = reflecta(t);\n  vec3 q0 = reflectb(t);\n  vec3 r0 = reflectc(t);\n  // Doesn't seem to matter whether we equalize angles or distances\n#if 0\n  // Reflect to an equilateral triangle\n  float d0 = hdistance(p0,q0);\n  float d1 = hdistance(q0,r0);\n  float d2 = hdistance(r0,p0);\n#else\n  // Reflect to an equiangular triangle\n  float d0 = hangle(p0,q0,r0);\n  float d1 = hangle(q0,r0,p0);\n  float d2 = hangle(r0,p0,q0);\n#endif\n  return vec2(d1-d0,d2-d1);\n}\n\nmat2 jacobian(vec2 s, float eps) {\n  // f(a+eps) = f(a-eps) + 2*eps*f'(a) => f'(a) =  (f(a+eps)-f(a-eps))/(2*eps)\n  vec2 e = vec2(eps,0);\n  vec2 s0 = eval(s+e.xy);\n  vec2 s1 = eval(s-e.xy);\n  vec2 s2 = eval(s+e.yx);\n  vec2 s3 = eval(s-e.yx);\n  // df[0]/da df[0]/db\n  // df[1]/da df[1]/db\n  // Column major!\n  return mat2(s0-s1,s2-s3)/(2.0*eps);\n}\n\nvec2 refine(vec2 s) {\n  // 0 = f(a+dx) = f(a)+M(dx)\n  // f(a) = -M(dx)\n  // dx = -inv(M)(f(a))\n  mat2 m = inverse(jacobian(s,1e-6));\n  vec2 t = eval(s);\n  vec2 dx = m*t;\n  return s-dx;\n}\n\nvec3 getsnub() {\n  // Solve f(a,b,c) = g(a,b,c) = h(a,b,c)\n  // Here f,g,h are distances to 3 sides of triangle, or the three\n  // angles in the triangle.\n  // a,b,c are bary coords\n  // In fact, we can set a+b+c = 1, so only 2 variables really.\n  // Have a vector quantity: [f-g,h-g], which we want to set to [0,0].\n  // f(x+dx) = f(x) + F(dx)\n  // ie. f(x) + F(dx) = 0 => dx = -inv(F)(f(x))\n  // We need a decent starting point, here the middle of the triangle\n  vec2 s = vec2(0.333,0.333);\n  // A few iterations are enough\n  for (int i = 0; i < 4; i++) s = refine(s);\n  assert(length(eval(s)) < 1e-4); // Check we have a solution\n  vec3 res = vec3(s,1.0-s.x-s.y);\n  return res;\n}\n\nvec3 getbary(int k, float t) {\n  k %= 16;\n  if (k >= 14) {\n    snubify = true;\n    return getsnub();\n  }\n  //k = max(0,k-1);\n  k = min(k,12);\n  return mix(getbary(k/2),getbary((k+1)/2),t);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_P = 80;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Set up our options\n  dofill = keypress(CHAR_F);\n  dodual = !keypress(CHAR_D);\n  dotiling = !keypress(CHAR_T);\n  dotexture = !keypress(CHAR_X);\n  doparity = !keypress(CHAR_P);\n  snubify = keypress(CHAR_S);\n\n  // P,Q are fixed, select value for R.\n  int rselect = keycount(KEY_RIGHT)-keycount(KEY_LEFT);\n  if (rselect > 0) {\n    R = 2+rselect;\n  } else {\n    int cycle = snubify ? 3 : 16;\n    R = 5+int(iTime)/(cycle);\n  }\n  // Set up triangle, bary coords and Wythoff point.\n  initialize();\n  bary = snubify ? getsnub() : getbary(int(iTime),fract(iTime));\n  // The barycentric coords for the vertex.\n  vec3 p = mat3(A,B,C)*bary;\n    // Weighted average of the vertices of the triangle\n  p = hnormalizet(p);\n\n  // Scaling\n  float scaleFactor = K == 1.0 ? 2.0 : 1.0;\n  // Zoom in and out with arrow keys\n  scaleFactor *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n\n  // Get screen point..\n  vec2 z = scaleFactor*(2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n  // ..and apply appropriate isometry.\n  if (iMouse.x > 0.0) {\n    vec2 m = scaleFactor*vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n    if (K == 0.0) {\n      // euclidean translation\n      z -= m;\n    } else if (K == 1.0) {\n      // spherical, invert at mouse position\n      z -= m;\n      float k = 1.0/dot(z,z);\n      z *= k;\n      scaleFactor *= k; // Adjust scale factor for inversion\n      z += m;\n    } else if (K == -1.0) {\n      // hyperbolic, invert centre of unit disc to mouse position\n      float X = dot(m,m);\n      m /= X;\n      z -= m;\n      float k = (1.0-X)/(X*dot(z,z));\n      z *= k;\n      scaleFactor *= abs(k); // Adjust scale factor for inversion\n      z += m;\n    }\n  }\n  aaScale = 2.0*scaleFactor/iResolution.y;\n  fragColor = vec4(color(z,p),1.0);\n  if (alert) fragColor.x = 1.0;\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2993, 2993, 3014, 3014, 3041], [3239, 3306, 3334, 3375, 3412], [3413, 3413, 3441, 3535, 3572], [3573, 3573, 3596, 3596, 3630], [3631, 3631, 3654, 3654, 3688], [3689, 3689, 3714, 3757, 3783], [3784, 3784, 3809, 3863, 3889], [3942, 3942, 3961, 3985, 4884], [4886, 4886, 4909, 4909, 4936], [4938, 4938, 4961, 4961, 4992], [4994, 4994, 5017, 5051, 5094], [5096, 5096, 5134, 5134, 5591], [5593, 5593, 5621, 5696, 5742], [5744, 5744, 5777, 5777, 5817], [5819, 5819, 5857, 5890, 5917], [5919, 5967, 6034, 6236, 6777], [6779, 6779, 6852, 6852, 7010], [7012, 7012, 7070, 7070, 8299], [8301, 8301, 8357, 8357, 9066], [9068, 9068, 9095, 9095, 11938], [11940, 11984, 12005, 12005, 12065], [12067, 12397, 12416, 12416, 12918], [12920, 12920, 12954, 13033, 13266], [13268, 13268, 13289, 13362, 13454], [13456, 13456, 13472, 13918, 14138], [14140, 14140, 14170, 14170, 14330], [14332, 14332, 14357, 14357, 14417], [14419, 14419, 14444, 14444, 14492], [14494, 14494, 14517, 14517, 14549], [14813, 14813, 14870, 14894, 16659]], "test": "untested"}
{"id": "wtVXW3", "name": "Simplest raymarcher", "author": "NoxWings", "description": "step0", "tags": ["step0"], "likes": 0, "viewed": 162, "published": 3, "date": "1583762906", "time_retrieved": "2024-07-30T21:19:36.043867", "image_code": "const float FAR_PLANE = 20.0;\nconst float SURF_HIT = 0.01;\n\nfloat sphere(vec3 p, float radius) { \n    return length(p) - radius;\n}\n\nfloat plane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat map(vec3 p) {\n    float ball = sphere(p, 1.0);\n    float floorPlane = plane(p, -1.0);\n    return min(ball, floorPlane);\n}\n\nvec3 mapNormal(vec3 p) {\n    vec2 e = vec2(SURF_HIT, 0);\n    float d = map(p);\n    \n    return normalize(vec3(\n        d - map(p - e.xyy),\n        d - map(p - e.yxy),\n        d - map(p - e.yyx)\n    ));\n}\n\nfloat trace(vec3 ro, vec3 rd, int maxIter, float maxD) {\n    float d = 0.0;\n    for (int i = 0; i < maxIter && d <= maxD; i++) {\n        vec3 p = ro + rd * d;\n        float s = map(p);\n        d += s;\n        if (s < SURF_HIT) break;\n    }\n    return d;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    float d = trace(ro, rd, 128, FAR_PLANE);\n\n    if (d >= FAR_PLANE) { return vec3(0); }\n    \n    vec3 p = ro + rd*d;\n    vec3 n = mapNormal(p);\n    vec3 l = normalize(vec3(1));\n    \n    float lambert = max(0.0, dot(l, n));\n    \n    return vec3(lambert);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fakeScreen = fragCoord / iResolution.xy * 2.0 - 1.0;\n    fakeScreen.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0,0,3);\n    vec3 rd = normalize(vec3(fakeScreen, -1.73));\n    \n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 96, 96, 130], [132, 132, 167, 167, 194], [196, 196, 215, 215, 323], [325, 325, 349, 349, 528], [530, 530, 586, 586, 785], [787, 787, 818, 818, 1076], [1079, 1079, 1136, 1136, 1406]], "test": "untested"}
{"id": "3lVSDc", "name": "Nexus of LOVE", "author": "quizcanners", "description": "I've put some love into my first shader.\n", "tags": ["music", "space", "stars", "nebula"], "likes": 12, "viewed": 899, "published": 3, "date": "1583754723", "time_retrieved": "2024-07-30T21:19:36.898582", "image_code": "// Fork of \"Nexus XIII\" by quizcanners. https://shadertoy.com/view/WtyXzG\n// 2020-03-09 10:49:50\n// Thanks to BigWings for a great heart tutorial: https://www.youtube.com/watch?v=dXyPOLf2MbU\n\nfloat Kisses(float a, float b, float k)\n{\n    float h = clamp((b-a)/k + .5, 0., 1.);\n    return mix(a,b,h) + h * (1. - h)* k * .5;\n}\n\n\nvec2 Hugs(float blur, vec2 uv)\n{\n \tuv.x *= .7 + blur*.3;\n    \n    float radius = .25;\n    \n    float shape = abs(uv.x);\n    \n    uv.y -= Kisses(sqrt(shape) * .35, blur * radius, .1);\n    \n    uv.y += .1 + blur * radius * .5;\n    \n    return uv;\n}\n\nvec3 TheShapeOfMyHeart(float blur, vec2 uv)\n{\n   \n   // uv = HeartOffset(blur, uv);\n    \n    float l =  length(uv);\n    \n    vec2 light = normalize(vec2(0.5, .2));\n    \n    float blick = max(0.,  (dot(normalize(uv), light) - .7) * 2.);\n    \n    float edge = blur * .3;\n    \n    const float blickPosition = 0.21;\n    \n    blick *= smoothstep(blickPosition-edge, blickPosition, l) * smoothstep(blickPosition+edge, blickPosition, l);// * (1. - blur);\n    \n    float s = smoothstep(0.25+edge, 0.25 - edge, l);\n    \n    return vec3(s,  blick , blick);\n\n}\n\nvoid Love (out vec4 col, in vec3 uv, in float zoom)\n{\n    \n    vec2 baseUv = uv.xy;\n    \n    uv.xy *= mix(0.8, 0.01, zoom);\n    \n    float deCenter = length(uv);\n    \n    deCenter = min(1., deCenter * deCenter);\n\n    vec2 smokeDin = vec2(-iTime + sin(uv.z*23.)*12.34, iTime + cos(uv.z*11.))*0.02;\n    \n    vec2 smokeUV = uv.xy;\n \n    float texC = texture(iChannel3, smokeUV*13.+ smokeDin.yx*0.5).r\n        \t\t*texture(iChannel3, smokeUV*15.*zoom*uv.y - smokeDin.yx*1.2).r*0.015;\n      \n    \n    float texA = (1.- texture(iChannel3, smokeUV*0.6 - texC * 0.5 + smokeDin*0.2).r);\n    \n    float texB = 1.-texture(iChannel3, smokeUV *  (1.-texA*0.1 + texC * 0.4 * (.5-texA)) + smokeDin*0.1).r;\n        \n    texA *= (0.5 + texB)*0.25;\n\n    texA *= texA * 8.* zoom * zoom * (1.-col.a) * deCenter;\n    \n    vec2 grid = uv.xy*10.;\n    \n     uv.xy = mod(grid,1.0);\n\n     grid -= uv.xy;\n    \n    uv.xy-=0.5;\n     \n    \n    vec4 add = vec4(0,0,0, texA);\n    \n    float depthMod = uv.z*0.123;\n    \n    float iTimeAndZoom = iTime + zoom;\n    \n    float cutMod = col.a * (12.);\n    \n    float upscale =  (col.a * 20.);\n    \n    const float cuttingMod = 1.;\n    \n    float distMod =  (1. + texA* 50.  + cutMod)* max(0.1,  zoom - col.a*8.) ;\n    \n    float blur = smoothstep(.98, .1  ,zoom);\n    \n    for(int x=-1;x<=1;x++){\n    \tfor(int y=-1;y<=1;y++){\n        \n            vec2 dUv = uv.xy - vec2(x,y);\n            vec2 dGrid = grid + vec2(x,y);\n\n            vec3 vol = texture(iChannel2, vec3(dGrid.xy*0.123+depthMod, (dGrid.x + iTimeAndZoom)*0.006 )).rgb ;\n\n            float music = texture(iChannel0, vec2(zoom*.6 + vol.b*.4,0.05)).x;\n  \n        \tmusic = 0.4 + smoothstep(-.2,1., music) * .5;\n            \n            float big = vol.b*vol.b * music * upscale;\n            \n            dUv += (vol.xy - .5)*1.5;\n            \n          \tfloat ray = max(0., 1.-abs(dUv.x*dUv.y*300.));\n            \n            vec2 loveUv = dUv*(1.-music) * 5. *( 1. + vol.b);//* big * 8000.;// * .1 / big;\n            \n            float deBlur = max(0.15, blur - music * music* .5);\n            \n            vec2 heart = Hugs(deBlur, loveUv);\n            \n            vec3 love = TheShapeOfMyHeart(deBlur, heart);\n            \n            dUv += heart * .5  * vol.b;\n\n            dUv += -dUv * .6 * music;\n            \n            add.a += love.r * .15;\n            \n            float len = length(dUv) +0.0001;\n            \n            float dist = big /len; \n\n            float cut = smoothstep(cuttingMod,.5,len);\n            \n            dist += ray * cut * big;\n            \n            add.rgb +=  (dist* vol  + \n                         love ) * distMod * cut ;\n    \t}\n     }\n\n   col += add * zoom * (1.-zoom);\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n     vec3 noise =  texture(iChannel2, vec3(uv*123.123+iTime, iTime+uv.x*uv.y*543.21)).rgb;\n    \n    vec4 col = vec4(0,0,0,0);\n    \n     float topMask = texture(iChannel1, uv).x;\n    \n     uv -= 0.5;\n    \n   \n  \n    \n    float aspect = iResolution.x/iResolution.y; \n    \n    uv.x*=aspect;\n        \n    float vignette = 1. - dot(uv,uv);\n    \n      vec2 M = (iMouse.xy - iResolution.xy * .5)/iResolution.y;\n    \n    uv += M;\n    \n    const float stepCnt = 5.;\n    const int steCntInt = 5;\n    const float oneStep = 1./stepCnt;\n    const float SPEED = 0.02;\n    \n    float zoom = iTime*SPEED;\n    \n    float index = floor(mod(zoom, 1.)*stepCnt);\n    \n    zoom = mod(zoom, oneStep);\n    \n    float off = 0.;\n    \n    float music = 0.;  \n    \n    for(int i=0;i<steCntInt;i++){\n        \n        float totalZoom = zoom + off;\n        \n    \tLove(col, vec3(uv.xy,index), totalZoom);\n    \toff += oneStep;\n        index = mod(index-1., stepCnt);\n    \t\n    }    \n    \n   \n    \n    col.rgb*=vec3(1.,0.6,.6) * (//2. * topMask + \n                                5.) * oneStep;\n    \n    col.rgb *= vignette;\n    \n    vec3 mixing = col.gbr+col.brg;\n    \n    col.rgb+= mixing * mixing * 0.1;\n    \n    col.rgb += noise*col.rgb*0.02;\n \n    \n    \n    fragColor = vec4(col.rgb,1.0);\n}\n", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21447, "src": "https://soundcloud.com/user-269456534/heart-shaped-box-nirvana-cover", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 233, 233, 324], [327, 327, 359, 359, 573], [575, 575, 620, 658, 1124], [1126, 1126, 1179, 1179, 3820], [3822, 3822, 3879, 3879, 5182]], "test": "untested"}
{"id": "wtyXDc", "name": "Z-curve particle sort", "author": "michael0884", "description": "Using the multi XOR sort to sort particles on a z-order curve. WIP", "tags": ["xor", "sort", "sorting", "parallel"], "likes": 6, "viewed": 435, "published": 3, "date": "1583749772", "time_retrieved": "2024-07-30T21:19:38.004626", "image_code": "// Fork of \"Bitonic sorting network\" by michael0884. https://shadertoy.com/view/ttVXDV\n// 2020-03-08 15:43:17\n\n//get particle id from id array\nvec2 getID(float id, float LI)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x+LI*N,y)).xy;\n}\n\n\n//random binary array id search\nvec2 search(int zid, float LI)\n{\n    float L = 0., R = N*N-1.;\n    vec4 p;\n    float i = 0.;\n    while(L!=R && i < log2(N))\n    {\n        i++;\n    \tfloat lid = floor((L+R)/2.);\n        float zid0 = getID(lid, LI).y; \n        float k = 0.5;\n        if(float(zid) < zid0)\n        {\n            R = (1.-k)*lid+R*k;\n        }\n        else\n        {\n            L = (1.-k)*lid+L*k;\n        }\n    }\n    return vec2(L,R);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n#define R 8.\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec2 pn = floor(1.*p);\n    p = floor(vec2(1.,1.)*p);\n    if(pn.x < LN*N && pn.y < N)\n    {\n    \tvec2 a = texel(ch1, pn).xy;\n        fragColor.xyz = jet_range(a.y, 0., 3e9);\n    }\n    else\n    {\n        int zid = xy2z(p);\n        //render points using last LN particle sorts\n        for(float li = 0.; li < LN; li++)\n        {\n            vec2 lid = search(zid, li);\n            fragColor.xyz = vec3(0);\n            for(float i = lid.x;i <= lid.y; i++)\n            {\n                vec4 a0 = getParticle(getID(i, li).x);\n                fragColor.xyz += vec3(gauss(length(p - a0.xy), 2.));\n            }\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n        \n        vec2 F = vec2(0.);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F = normalize(iMouse.xy - U.xy)/(d+2.);\n        }\n        \n        U.zw += dt*F;\n        U.xy += U.zw*dt;\n        \n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = hash22(3.14159*pos) - 0.5;\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//N^2 is the point number\n#define N 65.\n#define dt 0.5\n\n//save N last iterations\n#define LN 1.\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nuniform sampler2D fake;\n\nvec4 getParticle(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(fake, vec2(x,y));\n}\n   \n//from https://www.shadertoy.com/view/3tj3Rc\n\nint MASKS[] = int[] (0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF);\n\n//2d z-curve index\nint xy2z(vec2 U) {       // --- grid location to curve index\n    ivec2 I = ivec2(U*100.);\n    int n=8;\n    for (int i=3; i>=0; i--)\n        I =  (I | (I << n)) & MASKS[i],\n        n /= 2;\n    return I.x | (I.y << 1);\n}\n", "buffer_b_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        int maxorder = int(ceil(log2(N*N)));\n\n        int frame = iFrame;\n        float order = float(imod(frame, maxorder));\n        float oe = float(imod(frame, 2));\n\n        //pair id\n        float pid = XORN(id+oe, order)-oe; \n\n        if(pid < N*N) //if inside the array\n        {\n            U.xy = sort(id, pid); //swap sorted\n        }\n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        int maxorder = int(ceil(log2(N*N)));\n\n        int frame = -2*iFrame;\n        float order = float(imod(frame, maxorder));\n        float oe = float(imod(frame, 2));\n\n        //pair id\n        float pid = XORN(id+oe, order)-oe;\n\n        if(pid < N*N) //if inside the array\n        {\n            U.xy = sort(id, pid); //swap sorted\n        }\n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < LN*N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch2, pos);\n        if(pos.x < N)\n        {\n            float id = pos.x + pos.y*N;  \n\n            int maxorder = int(ceil(log2(N*N)));\n\n            int frame = -2*iFrame-1;\n            float order = float(imod(frame, maxorder));\n            float oe = float(imod(frame, 2));\n\n            //pair id\n            float pid = XORN(id+oe, order)-oe;\n\n            if(pid < N*N) //if inside the array\n            {\n                U.xy = sort(id, pid); //swap sorted\n            }\n\n            if(iFrame < 1)\n            {\n                U.x = id;\n            }\n        }\n        else\n        {\n            if(imod(iFrame, 2) == 0)\n            {\n            \tfloat LI = pos.x/N;\n            \tU = texel(ch2, pos - vec2(N,0.)); //store last in next\n            }\n        }\n       \n    }\n    else discard;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 143, 175, 175, 302], [305, 337, 369, 369, 753], [755, 755, 786, 786, 820], [836, 836, 885, 885, 1511]], "test": "untested"}
{"id": "WtKXD3", "name": "Breathing thingy", "author": "hazenn", "description": "trying some stuff", "tags": ["fractal"], "likes": 3, "viewed": 270, "published": 3, "date": "1583736774", "time_retrieved": "2024-07-30T21:19:39.094711", "image_code": "const float PI = 3.1415;\nmat2 rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat triwave(float x)\n{\n\treturn 1.0-4.0*abs(0.5-fract(0.5*x + 0.25));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float offset = 1. - sin(iTime);\n    \n\tvec2 f = abs(uv);\n    vec2 e = floor(f);\n    \n    for (int i=0;i<6;i++){\n    f *= 3.;\n    e = floor(f-offset); f = fract(f); \n    f = f * ( ((e.x == 0.) && (e.y == 0.))?0.:1. );\n    }\n    \n    \n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = smoothstep(0.1,0.,dot(f,f)) * col;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 102], [104, 104, 128, 128, 176], [179, 179, 236, 286, 747]], "test": "untested"}
{"id": "tlyXDc", "name": "dfgsdfgsdfg", "author": "lennyjpg", "description": "sdfgsfdgsdfg", "tags": ["grid", "random", "dots", "rotation"], "likes": 6, "viewed": 504, "published": 3, "date": "1583722776", "time_retrieved": "2024-07-30T21:19:39.952417", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / 20.0;\n    uv -= iTime * 0.3;\n    vec2 s = uv;\n    vec2 g  = fract(s) - 0.5;\n    float off = rand(ceil(s));\n    float z = rand(ceil(s))*0.5;\n    float dir = off - 0.5;\n    float speed = 1.0 + rand(s)*0.5;\n    float t = iTime * dir;\n    float angle = 1.1 + t*7.0 + off ;\n    g += vec2(sin(angle),cos(angle)) * 0.3;\n    float d = length(g)*2.5;\n    float w = (sin(z+t)+1.0)*0.24;\n    float e = 1.0-smoothstep(d,d+0.1,w);\n    fragColor = vec4(e);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 151, 151, 625]], "test": "untested"}
{"id": "3lVXW3", "name": "pixel gradient", "author": "Arthas_me", "description": "pixel gradient color transition", "tags": ["pixel"], "likes": 3, "viewed": 738, "published": 3, "date": "1583721830", "time_retrieved": "2024-07-30T21:19:40.955735", "image_code": "bool pixelGradient(in vec2 uv) {\n\tuv = floor(uv * 40.);\n    float percentage = floor(uv.x /40. * 10.);\n      int p = int(percentage)/2,\n          n = 8 >>  min(p,4-p), \n          q = 4 - 2*min(p,4-p),\n          i = int(uv.x + uv.y) % n, \n          x = int(uv.x) % q; \n\treturn\n        p < 1 ?    i==0 && x > 2\n      : p < 2 ?    i==0 && x > 0\n      : p < 3 ?    i==0\n      : p < 4 ? !( i==0 && x > 0 )\n      : p < 5 ? !( i==0 && x > 2 )\n      : true;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * vec2((iResolution.x/iResolution.y), 1.);\n    \n    \n    \n    vec3 a = vec3(0.7, 0.2, 0.4);\n    vec3 b = vec3(0.3, 0.2, 0.7);\n\n    vec3 col = pixelGradient(uv) ? a : b;\n\n    fragColor = vec4(pow(col, vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 452], [455, 455, 512, 512, 774]], "test": "untested"}
{"id": "wlySWc", "name": "大龙猫 - Quicky#025", "author": "totetmatt", "description": "Just a quicky", "tags": ["instagram", "quicky"], "likes": 4, "viewed": 401, "published": 3, "date": "1583707980", "time_retrieved": "2024-07-30T21:19:42.046817", "image_code": "\nmat2 r(float a){ float c= cos(a),s=sin(a);\nreturn mat2(c,-s,s,c);}\nfloat fig(vec2 uv) {\n   uv*=5.;\n   uv*=r(iTime*.33 + cos(length(uv.y-uv.x)));\n    return 0.1/smoothstep(0.1,0.9,abs(uv.x*4.)+sin(iTime*.5)*+pow(length(uv),2.));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n     \n     vec3 col = vec3(0.);\n     \n     col = vec3( fig(uv) + fig(uv*r(3.141/2.))  );\n     vec2 cc = uv*r(-iTime);\n     col= mix(vec3(.0,.0,.0),vec3(.9 * abs(atan(cc.x,cc.y))/3.141592,.2,.9),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlySWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 17, 17, 67], [68, 68, 88, 88, 230], [231, 231, 286, 286, 581]], "test": "untested"}
{"id": "ttGSW3", "name": "Area Lights WIP: (SS10)", "author": "angelo12", "description": "First pass at integrating PBR and simple area lights.", "tags": ["raymarch", "testing", "arealights"], "likes": 6, "viewed": 421, "published": 3, "date": "1583704724", "time_retrieved": "2024-07-30T21:19:43.006253", "image_code": "vec3  areaLightPos;\nvec3  areaLightCol;\nfloat areaLightRad;\n\nfloat _time;\n\n#define SPHERE_ID 0.0\n#define GROUND_ID 1.0\n#define LIGHT_ID 2.0\nvec2 \nMap(vec3 p)\n{\n    vec2 res = vec2(1e10, -1.0);\n\n    //Geometry\n    //UOP(sdSphere(p - vec3(0.0, 0.0, 0.1), 0.25), SPHERE_ID);\n    UOP(sdGroundPlane(p + 0.25), GROUND_ID);\n\n    //Lights\n    float r = 0.2;\n    areaLightRad = 0.1;\n    areaLightPos = vec3(r * cos(_time), 0.2 * cos(_time) + 0.1, r*sin(_time));\n    UOP(sdSphere(p - areaLightPos, areaLightRad), LIGHT_ID);\n\n    return res;\n}\n\n#define MAX_DIST 20.0\n#define MAX_STEPS 200\n#define MIN_DIST 0.001\nvec2 \nRayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec2 res = vec2(-1.0);\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i)\n    {\n        vec2 hit = Map(ro + rd*t);\n\n        if(abs(hit.x) < t * MIN_DIST)\n        {\n            res = vec2(t, hit.y);\n            break;\n        }\n\n        t += hit.x;\n    }\n    return res;\n}\n\nvec3\nCalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,\n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x));\n}\n\nfloat\nCalcSoftShadows(vec3 ro, vec3 rd)\n{\n    float k = 2.0;\n    float n = 1.0;\n    for(float t = 0.2; t < MAX_DIST;)\n    {\n        float h = Map(ro + t*rd).x;\n        if(h < MIN_DIST) return 0.0;\n\n        n = min(n, h*k/ t);\n        t += h;\n    }\n    return n;\n}\n\nfloat specTrowbridgeReitz( float HoN, float a, float aP )\n{\n\tfloat a2 = a * a;\n\tfloat aP2 = aP * aP;\n\treturn ( a2 * aP2 ) / pow( HoN * HoN * ( a2 - 1.0 ) + 1.0, 2.0 );\n}\n\nfloat visSchlickSmithMod( float NoL, float NoV, float r )\n{\n\tfloat k = pow( r * 0.5 + 0.5, 2.0 ) * 0.5;\n\tfloat l = NoL * ( 1.0 - k ) + k;\n\tfloat v = NoV * ( 1.0 - k ) + k;\n\treturn 1.0 / ( 4.0 * l * v );\n}\n\nfloat fresSchlickSmith( float HoV, float f0 )\n{\n\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - HoV, 5.0 );\n}\n\nfloat sphereLight( vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )\n{\n\tvec3 L = areaLightPos - pos;\n\tvec3 centerToRay = dot( L, r ) * r - L;\n\tvec3 closestPoint = L + centerToRay * clamp( areaLightRad / length( centerToRay ), 0.0, 1.0 );\t\n\tvec3 l = normalize( closestPoint );\n\tvec3 h = normalize( V + l );\n\t\n\tNoL\t= clamp( dot( N, l ), 0.0, 1.0 );\n\tfloat HoN = clamp( dot( h, N ), 0.0, 1.0 );\n\tfloat HoV = dot( h, V );\n\t\n\tfloat distL = length( L );\n\tfloat alpha = roughness * roughness;\n\tfloat alphaPrime = clamp( areaLightRad / ( distL * 2.0 ) + alpha, 0.0, 1.0 );\n\t\n\tfloat specD\t= specTrowbridgeReitz( HoN, alpha, alphaPrime );\n\tfloat specF\t= fresSchlickSmith( HoV, f0 );\n\tfloat specV\t= visSchlickSmithMod( NoL, NoV, roughness );\n\t\n\treturn specD * specF * specV * NoL;\n}\n\nvec3 \nRender(vec3 ro, vec3 rd)\n{\n    //Ray setup\n    vec3 col = vec3(0.0);\n    vec2 res = RayMarch(ro, rd);\n    float t = res.x;\n    float id = res.y;\n\n    //Sky rendering\n    vec3 sky = vec3(0.0);\n    col += sky;\n\n    //Opaque pass\n    if(id >= 0.0)\n    {\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormal(P);\n        vec3 V = -rd;\n        vec3 R = reflect(rd, N);\n        float NdotV = saturate(dot(N,V));\n\n        //Noise\n        float noise =  texture(iChannel0, P.xz* 0.2).x * 0.5 ;\n        noise +=  texture(iChannel0, P.xz*0.4).y * 0.25; \n        noise +=  texture(iChannel0, P.xz*0.8).z * 0.125;\n        noise +=  texture(iChannel0, P.xz*1.6).z * 0.125 / 2.0;\n\n        //Material & PBR parameters\n        col = vec3(1.0);\n        if(id == LIGHT_ID) {col = vec3(1.0, 1.0, 1.0);return col;}\n\n        //Albedo\n        vec3 albedo = texture(iChannel1, P.xz* 1.0).xyz;\n        albedo = mix( albedo, albedo * 1.3, noise * 0.35 - 1.0 ); \n\n        //Roughness\n        float roughness = 0.2 - clamp( 0.5 - dot( albedo, albedo ), 0.05, 0.95 );\n\n        //F0\n        float f0 = 0.3;\n\n        //Lighting\n        vec3 lin = vec3(0.0);\n        vec3 L = normalize(vec3(1.0, 1.0, 0.0));\n        float diff = saturate(dot(L, N));\n\n        //Shadowing\n        //diff *= CalcSoftShadows(P, L);\n\n        //Shading\n        float NdotLSphere;\n        float specSph\t= sphereLight( P, N, V, R, f0, roughness, NdotV, NdotLSphere );\n        lin += albedo * 0.3183 * ( NdotLSphere ) + specSph;\n\n        //lin += 1.00 * diff * vec3(1.0, 1.0, 1.0);\n        col *= lin;\n    }\n\n    //Fog\n    col = mix(col, vec3(0.0), 1.0 - exp(-0.1*t*t));\n    return saturate(col);\n}\n\n#define AA 2\nvoid \nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    _time = iTime / 2.0;\n    vec3 tot = vec3(0.0);\n\n    //Camera\n    float nearP = 1.0;\n    float roll = 0.0;\n    vec3 ta = vec3(0.0);\n    vec3 ro = ta + vec3(0.0, 0.2, -1.0);\n\n#if AA > 1\n    for(int i =0; i < AA; ++i)\n    for(int j =0; j < AA; ++j)\n    {\n        vec2 offset = 0.5 - vec2(i, j) / float(AA);\n        vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy) / iResolution.y;\n#else\n        vec2 uv = ((fragPos) - 0.5*iResolution.xy) / iResolution.y;\n#endif \n        mat3 cam = SetCamera(ro, ta, roll);\n        vec3 rd = cam * normalize(vec3(uv, nearP));\n\n        vec3 col = Render(ro, rd);\n\n        tot += col;\n#if AA > 1\n    }\n    tot /= float(AA* AA);\n#endif\n\n    GAMMA(tot);\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//Comment this out if running this file on shadertoy\n#define SHADERTOY \n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat\nsdGroundPlane(vec3 p)\n{\n    return p.y;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Camera functions------------------------------\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n\n//--------------------------------------------------------------------------------------\n//----------------------------------Post processing functions----------------------------\n#define GAMMA(col) col = pow(col, vec3(INV_GAMMA))\n\n\n//---------------------------------------------------------------------------------------- \n//----------------------------------Basic functions---------------------------------------\n#ifdef SHADERTOY\n#define saturate(vol) clamp(vol, 0.0, 1.0)\n#endif\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 159, 159, 532], [601, 601, 635, 635, 934], [936, 936, 961, 961, 1185], [1187, 1187, 1228, 1228, 1450], [1452, 1452, 1511, 1511, 1621], [1623, 1623, 1682, 1682, 1827], [1829, 1829, 1876, 1876, 1929], [1931, 1931, 2039, 2039, 2740], [2742, 2742, 2774, 2790, 4411]], "test": "untested"}
{"id": "3tKXzc", "name": "СhamomileFlowr", "author": "Arseny", "description": "Сhamomile", "tags": ["2d"], "likes": 1, "viewed": 287, "published": 3, "date": "1583700855", "time_retrieved": "2024-07-30T21:19:43.912829", "image_code": "\n\n\n\nfloat N21(vec2 p) {  // https://youtu.be/zXsWftRdsvU\n    return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv) { // https://youtu.be/zXsWftRdsvU\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) { // https://youtu.be/zXsWftRdsvU\n    float c = SmoothNoise(uv*4.);\n    \n    // don't make octaves exactly twice as small\n    // this way the pattern will look more random and repeat less\n    c += SmoothNoise(uv*8.2)*.5;\n    c += SmoothNoise(uv*16.7)*.25;\n    c += SmoothNoise(uv*32.4)*.125;\n    c += SmoothNoise(uv*64.5)*.0625;\n    \n    c /= 2.;\n    \n    return c;\n}\n\nconst float innerR = 0.2;\nfloat seed = 228.322;\n\nfloat circGrid(vec2 uv, float offset, float blur){\n    vec2 lv = fract(uv);\n    lv -= 0.5;\n    return 1. - smoothstep(0., blur, abs(length(lv) - (0.5 - offset - blur)));\n}\n\nfloat inv(float x){\n    return 1. - x;\n}\n\n/*vec3 cent(vec2 uv){\n    vec3 yel = vec3(1., 1., 0.);\n    vec3 col = vec3(0);\n    float rnd1 = SmoothNoise2(uv * 5.);\n    float rnd2 = SmoothNoise2(uv * 5. + vec2(5112.41, 4241.123));\n    vec2 trans = uv * rot(length(uv) / R);\n    //float mult = circGrid(2. * uv / (length(trans) + 0.3) * 10., 0., 0.1);\n    trans = trans / (length(trans) + 0.3) * 10.;\n    float mult = circGrid(trans, 0., 0.1);\n    //return vec3(mult);\n    mult = (2. - mult) / 2.;\n    float rnd = min(rnd1, rnd2);\n    //return vec3(rnd);\n    vec3 mxclr = vec3(0);\n    mxclr = mix(vec3(0), yel, inv(inv(mult) * rnd));\n    \n    col = mix(mxclr, yel, (length(uv) / R));\n    //cont_rand(cont_rand(uv, seed), seed).x;\n    col *= 1. - smoothstep(R - 0.01, R, length(uv));\n    return col;\n}*/\n\n\nfloat circ(vec2 uv, vec2 cen, float r, float thick){\n    return 1. - smoothstep(0., thick, abs(r - length(uv - cen)));\n}\n\n\n    #define PI 3.14159265359\n    #define centR 0.1\n    #define k 0.4\n    #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec2 getcent(float indx, float indy){\n    indx += N21(vec2(indx, indy)) * 0.2;\n    vec2 cent = vec2(centR + (indy + 0.5) / 7., 0.);\n    float agl = (indy + 0.5) / 7. / k;\n    cent *= rot(agl);\n    agl = 2. * PI / 12. * -(indx + 0.5);\n    cent *= rot(agl);\n    return cent;\n}\n\n/*float polargreed(vec2 uv){\n    float ans = 0.;\n    //uv *= 3.;\n    float len = length(uv);\n    if (len < centR){\n        return 0.;\n    }\n    //vec2 pv1 = vec2(atan(uv.y, uv.x) / 6.2831 + 0.5 + pow(len, 0.5) / 5., len);\n    vec2 pv = vec2(-atan(-uv.y, -uv.x) / (2. * PI) + 0.5 + (len - centR) * k, len);\n    float indx = floor(mod(pv.x, 1.) * 12.);\n    float indy = floor((len - centR) * 7.);\n    \n    //return abs(1. / 14. - length(uv - cent))*10.;\n    //return 1. - length(uv - cent)*10.;\n    \n    for (float i = -1.; i <= 1.; i++){\n        for (float j = -1.; j <= 1.; j++){\n            ans = max(ans, circ(uv, getcent(indx + i, indy + j), 0.07, 0.01));\n        }\n    }\n    //return circ(uv, cent, 0.07, 0.01);\n    return (1. - ans) * fract((len - centR) * 7.);\n    return indy * indx / 7. / 12.;//ind / 12. * fract((len - centR) * 7.);\n    if (fract(pv.x * 12.) < 0.1){\n        return 1.;\n    } else {\n        return 0.;\n    }\n    return abs(pv.x), 0.1;\n    //float m = min(fract(x), fract(1. - x));\n    //ans = smoothstep(0., 0.1, m * 0.5 + .2 - pv.y);\n    float m;\n    //float dst = abs(fract(pv1.x * 23.) - 0.5) * 2.;\n    //dst = min(dst, abs(fract(pow(len, 0.7) * 7. + iTime) - 0.5) * 2.);\n    //m = fract(pv1.x * 23.);\n    //ans = max(ans, 1. - smoothstep(0., 0.1, abs(m - 0.5)));\n    //m = fract(sqrt(len) * 7.);\n    //ans = max(ans, 1. - smoothstep(0., 0.1, abs(m - 0.5)));\n    //ans = dst;//max(ans, 1. - smoothstep(0., 0.1, dst));\n    return ans;\n}*/\n\n    #define N (7.)\n    #define R 0.1\n\nfloat sectorsAmount(float indy, float Num){\n    return floor((2. * PI * (indy / Num + centR) / R));\n}\n\nvec2 getCntr(float indx, float indy){\n    vec2 ans = vec2(indy + 0.5, 0.);\n    ans /= N;\n    ans.x += centR;\n    float agl = (indx + 0.5) / sectorsAmount(indy, N) * 2. * PI;\n  \tans *= rot(agl);\n    ans += (N21(vec2(indx + fract(floor(iTime * 3.) * 1.42), indy + fract(floor(iTime * 3.) * 4.25))) - 0.5) * 0.02;\n    return ans;\n}\n\nfloat anotherone(vec2 uv){\n    float ans = 0.;\n    uv *= 3.;\n    float len = length(uv);\n    if (len < centR){\n        return 0.;\n    }\n    //vec2 pv1 = vec2(atan(uv.y, uv.x) / 6.2831 + 0.5 + pow(len, 0.5) / 5., len);\n    float indy = floor((len - centR) * N);\n    vec2 pv = vec2(atan(-uv.y, -uv.x) / (2. * PI) + 0.5, len);\n    //float indx = floor(mod(pv.x, 1.) * 12.);\n    //indy += centR;\n    float sctrsAmount = sectorsAmount(indy, N);\n    float indx = floor(mod(pv.x, 1.) * sctrsAmount);\n    //return indx / sctrsAmount;\n    return 1. - circ(uv, getCntr(indx, indy), 0.13, 0.1);\n    //indy -= centR;\n    //return abs(1. / 14. - length(uv - cent))*10.;\n    //return 1. - length(uv - cent)*10.;\n    \n    for (float i = -1.; i <= 1.; i++){\n        for (float j = -1.; j <= 1.; j++){\n            ans = max(ans, circ(uv, getcent(indx + i, indy + j), 0.07, 0.01));\n        }\n    }\n    return (1. - ans) * fract((len - centR) * 7.);\n    return ans;\n}\n\nvec3 petal(vec2 beg, vec2 end, vec2 uv){\n    vec2 lv = uv;\n    lv -= beg;\n    end -= beg;\n    beg -= beg;\n    lv /= length(end);\n    //end /= length(end);\n    float agl = -atan(end.y, end.x);\n    lv *= rot(agl);\n    //end *= rot(-atan(end.y, end.x));\n    //if (abs(end.x - 1.)< 0.01){\n    //    return vec3(1.);\n   \t//}\n    if (lv.x < 0. || lv.x > 1.) return vec3(0.);\n    float t = 0.;\n    float bord = min(\n        1. / (-50. * lv.x), \n        1. / (50. * (lv.x - 1.))\n    ) + 0.3;\n    bord *= 0.7;\n    t = smoothstep(0., 0.1, bord - abs(lv.y));\n    //if (-(lv.x - 1.) * lv.x > abs(lv.y)){\n//        return vec3(1.);\n  //  }\n    return vec3(t);\n}\n\n#define needperpetal 0.13\n\nvec3 getPet(float indx, vec2 uv){\n    //float needperpetal = 0.13;\n    float amou = floor((innerR + 0.1) * 2. * PI / needperpetal);\n    vec2 beg = vec2(innerR, 0.);\n    float agl = (indx + 0.5) / amou * 2. * PI; \n    beg *= rot(agl);\n    vec2 end = beg * 5.;\n    agl = N21(vec2(indx * .6235, indx * .241)) * 0.1;\n    end *= rot(agl);\n    return petal(beg, end, uv);\n}\n\nvec3 petalzz(vec2 uv){\n    float len = length(uv);\n    if (len < (innerR + 0.1)) return vec3(0.);\n    vec2 pv = vec2(atan(-uv.y, -uv.x) / (2. * PI) + 0.5, len);\n    float amou = floor((innerR + 0.1) * 2. * PI / needperpetal);\n    float indx = floor(pv.x * amou);\n    \n    vec3 ans = vec3(0.);\n    for (float i = -1.; i <= 1.; i++){\n        ans = max(ans, getPet(indx + i, uv));\n        //ans = max(ans, vec3(0));\n   \t}\n    return ans;\n    //return vec3(indx / amou);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    vec3 col = vec3(0.);\n    \n    \n    if (length(uv) < innerR + 0.1){\n        vec3 yel = vec3(255., 207., 13.) / 256.;\n    \tcol = vec3(mix(vec3(0), yel, anotherone(uv)));\n    }\n    if (length(col) < 0.01){\n        //vec2 b = vec2(innerR, 0.);\n        //b *= rot(0.5);\n        //col = petal(b, b * 5., uv);\n        col = petalzz(uv);        \n    }\n    //vec3 yel = vec3(1., 0.64, 0.);\n    \n    if (length(uv) < 0.01){\n        col = vec3(.24, .52, .25);\n    }\n    \n    //col = vec3(circGrid(uv / (length(uv) + 0.3) * 10., 0., 0.1));\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //col = vec3(thisrand(uv, iTime));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 23, 56, 107], [109, 109, 137, 169, 488], [490, 490, 519, 551, 885], [936, 936, 986, 986, 1107], [1109, 1109, 1128, 1128, 1149], [1909, 1909, 1961, 1961, 2029], [2156, 2156, 2193, 2193, 2430], [3937, 3937, 3980, 3980, 4038], [4040, 4040, 4077, 4077, 4368], [4370, 4370, 4396, 4396, 5318], [5320, 5320, 5360, 5360, 5968], [5997, 5997, 6030, 6063, 6364], [6366, 6366, 6388, 6388, 6834], [6836, 6836, 6893, 6944, 7736]], "test": "untested"}
{"id": "WlGXDc", "name": "Day 80", "author": "jeyko", "description": " Planned to be laser cut.", "tags": ["mdtmjvm"], "likes": 11, "viewed": 446, "published": 3, "date": "1583695418", "time_retrieved": "2024-07-30T21:19:44.683767", "image_code": "\n// Planned to be laser cut.\n// It's an XOR pattern with some slight modification in Buffer A\n\n\n#define R iResolution.xy\n#define T(e) texture(iChannel0, (e)/R).x\n\n\nfloat xor(float x, float y) {return float(int(x) ^ int(y));}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U/iResolution.xy);\n    \n    float st = 1.;\n    \n    vec3 col = vec3(0);\n\n    float t = T(U);\n    /*\n    float n = T(U + vec2(0.,st));\n    float w = T(U + vec2(0.,-st));\n    float e = T(U + vec2(st,0.));\n    float s = T(U + vec2(-st,0.));\n    \n    float ne = T(U + vec2(st,st));\n    float ns = T(U + vec2(-st,st));\n    float sw = T(U + vec2(st,-st));\n    float se = T(U + vec2(-st,-st));\n    */\n    \n    //float cumm = t + n + w + e + s + ne + ns + sw + se;\n    \n    float att = pow(smoothstep(0.,1., abs(t*9.)/6.), 20.);\n    //float att = pow(smoothstep(0.,1., abs(cumm)/6.), 20.);\n    \n    \n    \n    col += 1. - att;\n    \n    //col += t;\n    \n    C = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float xor(float x, float y) {return float(int(x) ^ int(y));}\n\n#define R iResolution.xy\n#define T(e) texture(iChannel0, (e)/R).x\n\nfloat get(vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy);\n    \n    float col = 0.;\n\n    uv *= 6. + 10.*iMouse.x/iResolution.x;\n    \n    vec2 iuv = vec2(uv);\n    \n    iuv = abs(iuv);\n    \n    \n    float rep = 30.;\n    iuv = floor(iuv/rep)*rep;\n    \n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    \n    \n    float r = xor(iuv.x, iuv.y);\n    \n    \n    float cumm = 0.;\n    \n    r = xor(iuv.x, iuv.y);\n    \n    \n    r = floor(r*0.006);\n    for(int i = 0; i < 3; i++){\n        if(floor(mod(r, 5.)) < 3.){\n        \tcumm += r + r;\n        }\n        \n    }\n    \n    \n    float fr = float(r);\n    \n    \n    col += clamp(cumm, 0., 1.);\n    \n    col -= step(1.-cumm*0.01,0.)*1.;\n    \n    col = clamp(col, 0.,1.);\n    if (col == 0.) \n        col -= col + 1.;\n    return col;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    \n\tvec3 col = vec3(0);\n    float st = 0.5;    \n    \n    // antialiasing\n    \n    float t = get(U);\n    float n = get(U + vec2(0.,st));\n    float w = get(U + vec2(0.,-st));\n    float e = get(U + vec2(st,0.));\n    float s = get(U + vec2(-st,0.));\n    \n    float ne = get(U + vec2(st,st));\n    float ns = get(U + vec2(-st,st));\n    float sw = get(U + vec2(st,-st));\n    float se = get(U + vec2(-st,-st));\n    \n    \n    float cumm = t + n + w + e + s + ne + ns + sw + se;\n    \n    col += cumm/9.;\n    \n    C = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 193, 193, 224], [226, 226, 267, 267, 951]], "test": "untested"}
{"id": "WlySDc", "name": "Multi XOR sorting", "author": "michael0884", "description": "Experimenting with exotic sorting methods.  No idea why this works. Performance is exactly O(N*ceil(log2(N))^2).", "tags": ["xor", "sort", "sorting", "parallel"], "likes": 14, "viewed": 786, "published": 3, "date": "1583694259", "time_retrieved": "2024-07-30T21:19:45.449719", "image_code": "// Fork of \"Bitonic sorting network\" by michael0884. https://shadertoy.com/view/ttVXDV\n// 2020-03-08 15:43:17\n\nvec2 getID(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    N = float(min(size.x, size.y));\n    p = floor(vec2(1.,1.)*p);\n    if(p.x < N && p.y < N)\n    {\n    \tfloat id = p.x + p.y*N;\n        vec2 i = getID(id);\n        vec2 i1 = getID(id+1.);\n    \t//fragColor.xyz = 1.*vec3(1,1,1)*jet_range(getParticle(i1.x).z - getParticle(i.x).z,-0.1,0.1);\n    \tfragColor.xyz = 1.*getParticle(i.x).xyz;\n    } else discard;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    N = float(min(size.x, size.y));\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n\n        U = pixel(ch2, pos*vec2(512.,512.)/vec2(N,N));\n        U.w = length(U.xyz);\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//N^2 is the point number\nfloat N;\n#define slowdown 1.\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nuniform sampler2D fake;\n\nvec4 getParticle(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(fake, vec2(x,y));\n}\n    ", "buffer_b_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    N = float(min(size.x, size.y));\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        if(mod(float(iFrame), slowdown) == 0.)\n        {\n            float frame = floor(float(iFrame)/slowdown);\n\t\t\t\n            float order = mod(-frame, ceil(log2(N*N))+1.);\n            \n            //pair id\n            float pid = XORN(id, order); \n\n            if(pid < N*N) //if inside the array\n            {\n               float p0_id = getID(id);\n               float p1_id = getID(pid);\n                \n               vec4 val0 = getParticle(p0_id);\n               vec4 val1 = getParticle(p1_id);\n                \n               float cmin = (val0.w<val1.w) ? p0_id: p1_id;\n         \t   float cmax = (val0.w<val1.w) ? p1_id: p0_id;\n\n          \t   U.x = (pid > id) ? cmin : cmax; //swap sorted\n            }\n        }\n        \n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 133, 133, 223], [225, 225, 274, 274, 630]], "test": "untested"}
{"id": "WlGXWV", "name": "asdkl;fj", "author": "lennyjpg", "description": "laksdjf", "tags": ["alskdjf"], "likes": 1, "viewed": 321, "published": 3, "date": "1583693916", "time_retrieved": "2024-07-30T21:19:46.284487", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;  \n    float t = iTime * .2;\n    float v = uv.y;\n    v += t;\n    float e = v;\n    vec2 g = fract(uv*10.0)*iResolution.x/-iResolution.y;\n    float r = length(g-0.5);\n    float d =step(r,0.1);\n   uv.y+=uv.x*0.25;\n    //e += sin(uv.x * 10.0 + t) * .01;\n    float f = pow((uv.x - .5) * 1.2, 2.) * 2.;\n    e += sin(f * 2.0 + t) * .4;\n    float z = t+99.9;\n    z += (sin(t*.5)+2.3)*0.17;\n    uv.x += z;\n    vec3 a = vec3(1.1,0.99,.95);\n    vec3 b = vec3(.0,.0,.1);\n    e -= fract((uv.x * uv.y * 0.017+t) * 3.0 - 2.2) * 1.2;\n    float m = e;\n    float c = smoothstep(m,m + 1.5 / iResolution.y, .5);\n  c = (sin(m*1.6 )+.5)*0.45 + 0.34;\n  //c *= sin(uv.y*2.3);\n    fragColor.rgb = d+mix(a,b,c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 786]], "test": "untested"}
{"id": "WlySWc", "name": "Parallel irrational pair sorting", "author": "michael0884", "description": "Experimenting with exotic sorting methods.  No idea why this works", "tags": ["random", "sort", "sorting", "parallel"], "likes": 5, "viewed": 366, "published": 3, "date": "1583687339", "time_retrieved": "2024-07-30T21:19:47.226967", "image_code": "// Fork of \"Bitonic sorting network\" by michael0884. https://shadertoy.com/view/ttVXDV\n// 2020-03-08 15:43:17\n\nvec2 getID(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    p = floor(vec2(0.5,0.5)*p);\n    if(p.x < N && p.y < N)\n    {\n    \tfloat id = p.x + p.y*N;\n        vec2 i = getID(id);\n    \tfragColor.xyz = 1.*vec3(1,1,1)*jet_range(getParticle(i.x).z,0.,1.);\n    } else discard;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n\n        float id = 1.3668*2.*3.14159*(pos.x + pos.y*N)/(N*N);\n        if(iFrame < 1)\n        {\n           // U.xy = size*0.5 + size.x*(vec2(1,0)*cos(id) + vec2(0,1)*sin(id))*0.25;\n            U.xy = size*hash22(pos);\n            U.zw = hash22(2.*pos);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N 170.\n#define slowdown 1.\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat nbase(float x)\n{\n    return mix(hash11(floor(x)),hash11(ceil(x)), fract(x));\n}\n\nfloat fbm(float x, float t)\n{\n    float a = 1., b = 1., c = 0.;\n    for(int i = 0; i < 3; i++)\n    {\n        c += a*nbase(b*x + t);\n        a *= 2.5;\n        b *= 4.5;\n    }\n    return c;\n}\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\nfloat gauss(float x, float r)\n{\n    return exp(-pow(x/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nuniform sampler2D fake;\n\nvec4 getParticle(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(fake, vec2(x,y));\n}\n    ", "buffer_b_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\n\n//flip n bits\nfloat XORN(float x, float o, float n)\n{\n    int X = int(x);\n    int O = int(o);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1<<O));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        if(mod(float(iFrame), slowdown) == 0.)\n        {\n            float frame = floor(float(iFrame)/slowdown);\n\t\t\t\n            float order2 = mod(sqrt(3.)*frame, floor(log2(N*N)));\n            float order1 = mod(frame, floor(log2(N*N)));\n           \tfloat odd_even = mod(frame,2.);\n            //pair id\n            float pid = XORN(id, order1, order2); //almost random sort\n\n            if(pid < N*N) //if inside the array\n            {\n               float p0_id = getID(id);\n               float p1_id = getID(pid);\n                \n               vec4 val0 = getParticle(p0_id);\n               vec4 val1 = getParticle(p1_id);\n                \n               float cmin = (val0.z<val1.z) ? p0_id: p1_id;\n         \t   float cmax = (val0.z<val1.z) ? p1_id: p0_id;\n\n          \t   U.x = (pid > id) ? cmin : cmax; //swap sorted\n            }\n        }\n        \n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 133, 133, 223], [225, 225, 274, 274, 491]], "test": "untested"}
{"id": "WtGSD3", "name": "featuristic UI test2", "author": "yasuo", "description": "Experimenting futuristic UI design ", "tags": ["ui"], "likes": 31, "viewed": 826, "published": 3, "date": "1583678283", "time_retrieved": "2024-07-30T21:19:48.091655", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define  uicol vec3(0.2,0.75,0.7)*1.3\n#define hash(h) fract(sin(h) * 43758.5453123)\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n    float angle = 2.0*3.14159265/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.*fix;\n    p = vec2(-cos(a), sin(a))*r;\n\n    return p;\n}\n\nvec3 UI(vec2 uv, vec3 col, float t) {\n    vec2 uiuvref = uv;\n\n    uv = mod(uv,0.2)-0.1;\n    float d = sdBox(uv,vec2(0.0005,0.01));\n    float d2 = sdBox(uv,vec2(0.01,0.0005));\n    d = min(d,d2);\n    col = mix(col,uicol*0.4,S(d,0.0)); \n    \n    // center UI\n    mat2 r = Rot(radians(t*10.0));\n\n    uv = uiuvref;\n    uv*= 0.4;\n    uv*=Rot(radians(t*10.0)+radians(-3.0));\n    uv.yx = pModPolar(uv.yx,60.0,1.8);\n    d = sdBox(uv,vec2(0.0002,0.17));\n    uv = uiuvref;\n\n    uv*= 0.4;\n    uv*=r;\n    uv.yx = pModPolar(uv.yx,60.0,1.8);\n    d2 = sdBox(uv,vec2(0.0002,0.16));\n\n    d = min(d,d2);\n    d = max(-(length(uv)-0.15),d);\n    col = mix(col,(uicol),S(d,-0.001));\n    \n    uv = uiuvref;\n    d = abs(length(uv)-0.36)-0.001;\n    col = mix(col,(uicol),S(d,-0.001));\n\n    d = abs(length(uv)-0.08)-0.01;\n    d2 = sdPie(uv*Rot(radians(-t*50.0)),vec2(0.2,0.21),0.12);\n    d = max(d2,d);\n    col = mix(col,uicol,S(d,-0.001));\n\n    uv*=Rot(radians(t*50.0));\n    d = abs(length(uv)-0.345)-0.002;\n    d2 = sdBox(uv,vec2(0.05,0.7));\n    d = max(d2,d);\n    col = mix(col,uicol,S(d,-0.001));\n    \n    uv = uiuvref;\n    uv*=Rot(radians(-sin(t*1.5)*270.0));\n    d = abs(length(uv)-0.32)-0.002;\n    d2 = sdBox(uv,vec2(0.07,0.7));\n    d = max(d2,d);\n    col = mix(col,uicol,S(d,-0.001));\n    \n    uv = uiuvref;\n    uv*=Rot(radians(-sin(t*1.2)*180.0));\n    d = abs(length(uv)-0.05)-0.002;\n    d2 = sdBox(uv,vec2(0.04,0.8));\n    d = max(-d2,d);\n    col = mix(col,uicol,S(d,-0.001));    \n    \n    uv = uiuvref;\n    uv*= 0.55;\n    uv*=Rot(radians(-t*15.0));\n    uv.yx = pModPolar(uv.yx,70.0,1.8);\n    d = sdBox(uv,vec2(0.0005,0.17));\n    d = max(-(length(uv)-0.15),d);\n    col = mix(col,uicol,S(d,-0.001));\n    \n    \n    uv = uiuvref;\n    uv*= 0.85;\n    uv*=Rot(radians(t*20.0));\n    uv.yx = pModPolar(uv.yx,40.0,1.8);\n    d = sdBox(uv,vec2(0.0005,0.17));\n    d = max(-(length(uv)-0.15),d);\n    col = mix(col,uicol,S(d,-0.001));    \n    \n    uv = uiuvref;\n    d = length(uv)-0.03+sin(t*2.0)*0.005;\n    col = mix(col,uicol,S(d,-0.001)); \n    \n    uv = uiuvref;\n    uv*=1.0+sin(t*5.0)*0.05;\n    uv*=Rot(radians(t*50.0));\n    d =abs(sdBox(uv,vec2(0.11)))-0.001;\n    d2 = sdBox(uv,vec2(0.07,0.21));\n    d = max(-d2,d);\n    d2 = sdBox(uv,vec2(0.21,0.07));\n    d = max(-d2,d);\n    col = mix(col,uicol,S(d,-0.001)); \n    \n    uv = uiuvref;\n\tfloat numBar = 20.0;\n    float deg = 360.0/numBar;\n    vec2 pos = vec2(0.0,0.0);\n    for(float i = 0.0; i<numBar; i+=1.0) {\n\t\tfloat rotVal = radians(i*deg+t*10.0)+radians(2.5);\n        float rotVal2 = radians(i*deg+t*10.0)+radians(10.0);\n        \n    \tmat2 m = Rot(rotVal);\n        mat2 m2 = Rot(rotVal);\n        float animateVal = sin(hash(i)*(i*deg)*t*0.1)*0.01;\n        float animateVal2 = sin(hash(i)*(i*deg)*t*0.07)*0.02;\n        float bdist = 0.45;\n        float bdist2 = 0.46;\n        float x = pos.x+cos(rotVal)*(bdist+animateVal);\n        float y = pos.y+sin(rotVal)*(bdist+animateVal);\n        float bar = sdBox((uv+vec2(y, x))*m, vec2(0.001,0.03+animateVal));\n        x = pos.x+cos(rotVal2)*(bdist2+animateVal2);\n        y = pos.y+sin(rotVal2)*(bdist2+animateVal2);\n        float b = length(uv+vec2(y, x))-0.01;\n        b =  min(b,bar);\n    \tcol = mix( col, uicol, S(b,0.0) );\n    }\n    \n    uv = uiuvref;\n    deg = 360.0/20.0;\n    for(float i = 0.0; i<numBar; i+=1.0) {\n\t\tfloat rotVal = radians(i*deg-t*30.0)+radians(45.0);\n    \tmat2 m = Rot(rotVal);\n        float bdist = 0.25;\n        float x = pos.x+cos(rotVal)*bdist;\n        float y = pos.y+sin(rotVal)*bdist;\n        float b = sdTriangleIsosceles((uv+vec2(y, x))*m, vec2(0.015,0.02));\n    \tcol = mix( col, uicol, S(b,0.0) );\n    }\n    \n    float dist = 0.33;\n    uv = uiuvref;\n    uv*= Rot(radians(-sin(t*1.1)*150.0));\n    uv.x -= dist;\n    uv.y -= dist;\n    \n    d = sdTriangleIsosceles(uv*Rot(radians(-140.0)),vec2(0.015,0.02));\n    col = mix(col,uicol,S(d,-0.001)); \n    \n    uv = uiuvref;\n    uv*= Rot(radians(-sin(t*1.3)*160.0)+radians(45.0));\n    uv.x -= dist;\n    uv.y -= dist;\n    \n    d = sdTriangleIsosceles(uv*Rot(radians(-140.0)),vec2(0.015,0.02));\n    col = mix(col,uicol,S(d,-0.001)); \n        \n    uv = uiuvref;\n    uv*= Rot(radians(sin(t*1.4)*180.0)+radians(90.0));\n    uv.x -= dist;\n    uv.y -= dist;\n    \n    d = sdTriangleIsosceles(uv*Rot(radians(-140.0)),vec2(0.015,0.02));\n    col = mix(col,uicol,S(d,-0.001)); \n            \n    uv = uiuvref;\n    uv*= Rot(radians(sin(-t*1.6)*270.0)+radians(120.0));\n    uv.x -= dist;\n    uv.y -= dist;\n    \n    d = sdTriangleIsosceles(uv*Rot(radians(-140.0)),vec2(0.015,0.02));\n    col = mix(col,uicol,S(d,-0.001)); \n    \n    // graph\n    uv = uiuvref;\n    uv.x = abs(uv.x);\n    uv.x -= 0.67;\n    uv.y += 0.3;\n    \n    uv.y = mod(uv.y,0.042)-0.021;\n    d = sdBox(uv,vec2(0.1,0.01));\n    \n    uv = uiuvref;\n    uv.x = abs(uv.x);\n    uv.x -= 0.67;\n    uv.y += 0.3;\n    d = max(uv.y-0.5,d);\n    d = max(-(uv.y-0.09),d);\n    col = mix(col,uicol*0.5,S(d,-0.001)); \n    \n    uv = uiuvref;\n    uv.x = abs(uv.x);\n    uv.x -= 0.67;\n    uv.y -= 0.12;\n    \n    for(float i = 1.0; i<=10.0; i+=1.0) {\n        float x = 0.0;\n        float y = i*0.042-0.105;\n        float w = abs(sin(hash(i)*t*3.0)*0.1);\n        d = sdBox(uv+vec2(-0.1+w,y),vec2(w,0.01));\n        col = mix(col,uicol,S(d,-0.001)); \n    }\n    \n    dist = 0.205;\n    uv = uiuvref;\n    uv*= Rot(radians(t*30.0)+radians(170.0));\n    uv.x -= dist;\n    uv.y -= dist;\n    \n    d = abs(length(uv)-0.015)-0.001;\n    col = mix(col,uicol,S(d,-0.001)); \n    \n    uv = uiuvref;\n    uv = abs(uv);\n    uv.x -=1.2;\n    uv.y -=0.7;\n    \n    d = sdSegment(uv,vec2(-0.43,-0.3),vec2(-0.65,-0.3))-0.001;\n    d2 = sdSegment(uv,vec2(-0.65,-0.3),vec2(-0.77,-0.4))-0.001;\n    d = min(d,d2);\n    col = mix(col,uicol,S(d,-0.001)); \n    \n    uv = uiuvref;\n    uv = abs(uv);\n    uv.x -=1.39;\n    uv.y -=0.73;\n    \n    d = sdBox(uv+vec2(0.74,0.36),vec2(0.010+sin(t*5.0)*0.003+0.007));\n    d2 = sdBox(uv+vec2(0.69,0.36),vec2(0.010+sin(t*6.0)*0.003+0.007));\n    d = min(d,d2);\n    float d3 = sdBox(uv+vec2(0.64,0.36),vec2(0.010+sin(t*7.0)*0.003+0.007));\n    d = min(d,d3);\n    col = mix(col,uicol,S(d,-0.001)); \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 uiuvref = uv;\n   \n    vec3 col = .94*max(mix(vec3(0.0,0.2,0.3)+(.1-length(uv)/3.),vec3(1),.1),0.);\n    \n    float t = mod(iTime,8000.0);\n    \n    // UI\n    float uvy = sin((t+2.0)*0.6)*1.2;\n\tif (uv.y+uvy > 0.5 && uv.y+uvy < 0.52) {\n        uv.x += sin(uv.y*2.0)*0.1;\n    }\n    col = UI(uv,col,t);\n    \n    float dt = dot(uv, vec2(12.9898, 78.233));\n    float noise = fract(sin(dt) * 43758.5453 + t);\n    vec3 grain = vec3(noise) * (1.0 - col);\n    col+=grain*0.15;    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 280, 280, 360], [362, 362, 413, 413, 721], [723, 723, 772, 772, 946], [948, 948, 1000, 1000, 1119], [1121, 1152, 1212, 1212, 1441], [1443, 1443, 1480, 1480, 7529], [7531, 7531, 7588, 7588, 8164]], "test": "untested"}
{"id": "WtySW3", "name": "Fast Octree Path Tracing(Mobile)", "author": "yuchengzhong", "description": "origin:https://www.shadertoy.com/view/3dSGDR @fizzer\nGGX\nMIS\nRemove Filter", "tags": ["voxel", "pathtracing", "mis", "pt", "ggx", "traversal", "octree", "importantsample", "microsurface"], "likes": 17, "viewed": 1228, "published": 3, "date": "1583674112", "time_retrieved": "2024-07-30T21:19:48.953352", "image_code": "float boxSize = 1.0;\nfloat seed;\nvec2 hash2() \n{\n    return fract(sin(vec2(seed+=1.0,seed+=1.0))*vec2(43758.5453123,22578.1459123));\n}\nfloat bluenoise(vec2 uv)\n{\n    uv += 1337.0*fract(iTime);\n    vec3 p3  = fract(vec3(uv.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat D_GGX(float Roughness, float NoH)\n{\n\tfloat a = Roughness * Roughness;\n\tfloat a2 = a * a;\n\tfloat d = (NoH * a2 - NoH) * NoH + 1.0;\t       \n\treturn a2 / (3.1415926535*d*d);\t\t\t\t\t\n}\nvec3 F_Schlick(vec3 S, float VoH)\n{\n\tfloat Fc = pow(1.0 - VoH, 5.0);\n\treturn S + (1.0-S)*Fc;\n}\nfloat F_Schlick_S(float S, float VoH)\n{\n\tfloat Fc = pow(1.0 - VoH, 5.0);\n\treturn S + (1.0-S)*Fc;\n}\nfloat Vis_Schlick( float Roughness, float NoV, float NoL )\n{\n\tfloat k = sqrt( Roughness ) * 0.5;\n\tfloat Vis_SchlickV = NoV * (1.0 - k) + k;\n\tfloat Vis_SchlickL = NoL * (1.0 - k) + k;\n\treturn 0.25 / ( Vis_SchlickV * Vis_SchlickL );\n}\nvec3 ImportanceSampleCos(vec3 d) \n{\n    vec2 rand = hash2();\n    float phi = 6.28318530718*rand.x;\n    float xiy = rand.y;\n    float r = sqrt(xiy);\n    float x = r*cos(phi);\n    float y = r*sin(phi);\n    float z = sqrt(max(0.0,1.0-x*x-y*y));\n\tvec3 w = d;\n\tvec3 u = cross(w.yzx, w);\n\tvec3 v = cross(w, u);\n    return w*z+u*x+v*y;\n}\nvec3 ImportanceSampleGGX(vec3 d,vec3 V,float roughness,out vec3 H)\n{\n    roughness =max(0.04,roughness);\n    vec2 rand = hash2();\n    float phi = 6.28318530718*rand.x;\n    float xiy = rand.y;\n\tfloat a = roughness * roughness;\n\tfloat CosTheta = sqrt((1.0 - xiy) / (1.0 + (a*a - 1.0) * xiy));\n\tfloat SinTheta = sqrt(1.0 - CosTheta * CosTheta);\n\tH = vec3(SinTheta * cos(phi),SinTheta * sin(phi), CosTheta);\n\tvec3 w = (d);\n\tvec3 u = (cross(w.yzx, w));\n\tvec3 v = cross(w, u);\n\tH = v * H.x + u * H.y + w * H.z;\n\tvec3 R = H*2.0 * dot(V,H)  - V;\n    return normalize(R);\n}\nvec4 SpecularBRDF_PDF(vec3 L,vec3 V,vec3 N,float roughness,float Spec,float M,vec3 C,out vec3 F,vec3 H)\n{\n     roughness =max(0.04,roughness);\n\t float NoL = dot(N, L);\n\t float NoV = dot(N, V);\n\t float NoH = dot(N, H);\n\t float VoH = dot(V, H);\n\n\t float D = D_GGX( roughness, NoH );\n\t float Vis = Vis_Schlick( roughness, NoV, NoL );\n     vec3 F0 =  mix(vec3(0.04+0.04*Spec),C*Spec,M);\n\t F = F_Schlick( F0, VoH );\n\t return vec4(max((D * Vis ) * F, 0.00001),max(D * NoH /(4.0*VoH), 0.00001));\n}\n// Ray-box intersection.\nvec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\nvec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)\n{\n    rp = rp - (p0 + p1) / 2.0;\n    vec3 arp = abs(rp) / (p1 - p0);\n    return normalize(step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp));\n}\nfloat trace(vec3 ro, vec3 rd, inout vec3 outn,out int id,int ignore)\n{\n    vec2 ob = box(ro, rd, vec3(-boxSize), vec3(boxSize));\n    \n    float tt = max(0., ob.x);\n    vec3 n = vec3(0, 1, 0);\n    for(int j = 0; j < 23; ++j)//should be 1.41*2*2^n，layer:n(1~6):6,12,23,46,91,181\n    {\n        if(tt > ob.y - 1e-4)\n        {\n            break;\n        }\n        vec3 p2 = ro + rd * tt;\n        vec3 p = p2 + sign(rd) * 1e-4;\n        vec3 p0 = vec3(-boxSize), p1 = vec3(+boxSize);\n        id = 0;\n        for(int i = 0; i < 3; ++i)\n        {\n            vec3 c = p0 + (p1 - p0) * (0.5);\n            vec3 o = step(c, p);\n            id = int(float(id) * 8.0 + dot(o, vec3(1, 2, 4)));\n            p0 = p0 + (c - p0) * o;\n            p1 = p1 + (c - p1) * (vec3(1) - o);\n        }\n        if(id!=ignore&&cos(float(id))>0.5)//cos:random empty\n        {\n            n = (boxNormal(p2,p0,p1));//+(p2 - (p0 + p1) / 2.) / (p1 - p0)\n            break;\n        }        \n        vec2 b = box(ro, rd, p0, p1);\n        tt = b.y;\n    }\n    outn = n;//normalize(pow(abs(n), vec3(16)) * sign(n));\n    return tt;\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//#define USE_MOUSE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 texelsize = vec2(1.0)/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 LightDir = normalize(vec3(0.5,2.0,1.0));\n    vec3 LightColor = vec3(1.5);\n#ifdef USE_MOUSE\n    float a = 1.7 - 1.7 * iMouse.y / iResolution.y;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    float a2 = 0.0 - 2. * iMouse.x / iResolution.x+0.02*iTime;\n    mat2 m2 = mat2(cos(a2), sin(a2), -sin(a2), cos(a2));\n#else\n    float a = 0.6;// - 1.7 * iMouse.y / iResolution.y;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    float a2 = 0.02*iTime;\n    mat2 m2 = mat2(cos(a2), sin(a2), -sin(a2), cos(a2));\n#endif\n    \n    seed = bluenoise(fragCoord.xy);\n    seed = mod( seed*55.24317542, 3.14352);\n        \n    vec3 acc = vec3(0.0); \n    float normal_identity =0.0;\n#define S 2   \n#define D 4\n    for(int samples =0;samples<S;samples++)\n    {\n        vec2 offset = 2.0*texelsize*(hash2());\n        vec3 ro = vec3(0, -.1, 3.0);\n        vec3 rd = normalize(vec3(uv+offset, -2.0));\n\n        ro.yz *= m;\n        rd.yz *= m;\n        ro.xz *= m2;\n        rd.xz *= m2;\n        \n        \n        // Scene AABB.\n        vec2 ob = box(ro, rd, vec3(-boxSize), vec3(boxSize)); \n        vec3 nro = ro;      \n        vec3 nrd = rd;\n        //trace\n        int hitid=-1;\n        int ignoreid=-1;\n\n        vec3 n = vec3(0, 1, 0);\n        vec3 radiance = vec3(0.0);\n        vec3 mask = vec3(1.0);\n        vec3 n_last = n;\n        \n        for(int depth=0;depth<D;depth++)\n        {\n          float tt = trace(nro, nrd, n,hitid,ignoreid);\n          ignoreid = hitid;        \n          bool hit = !(ob.y < ob.x || tt >= ob.y - 1e-4);           \n          vec3 color;\n          float metallic =step(sin(float(hitid)),0.0);\n          float specular =1.0;\n          float roughness = 0.2*step(cos(float(hitid+21)),0.0);\n          normal_identity += (depth==0?(hit?dot((n*0.5+0.5),vec3(4.0,2.0,1.0))/8.0:0.0):0.0);\n          if(hit)\n          {\n\n              \n              color = hsv2rgb(vec3(cos(float(hitid)*0.5+0.5),0.7,0.99));//vec3(0.0);\n              float preF = min(0.4,F_Schlick_S( mix(0.04+0.04*specular,length(color*specular),metallic), dot(-nrd,n) ));\n              float diffuseTerm = (mix(0.6,0.3,metallic)*0.5+mix(0.8,0.6,specular)*0.5)*(1.0-preF);                \n              if(hash2().x<diffuseTerm)\n              {            \n                  nro = nro+nrd*tt;\n                  vec3 d = ImportanceSampleCos(n);  \n                  vec3 H = normalize(d-nrd);\n                  vec3 F0 =  mix(vec3(0.04+0.04*specular),color*specular,metallic);\n\t              vec3 F = F_Schlick( F0, dot(-nrd,H) );\n                  vec3 diffuse = (1.0-metallic)*(vec3(1.0) - F)*color/diffuseTerm;\n                  mask*=diffuse/3.1415926;\n                  nrd = d;\n              }\n              else\n              {\n                  nro = nro+nrd*tt;\n                  vec3 H = vec3(0.5);\n                  vec3 d = ImportanceSampleGGX(n,-nrd,roughness,H);\n\t\t\t      vec3 F=vec3(0.0);\n                  vec4 brdf_pdf = SpecularBRDF_PDF(d,-nrd,n, roughness,specular,metallic,color,F,H);\n\t\t\t      float NoL = max(dot(n, d), 0.0);\n                  vec3 specular = (NoL*(brdf_pdf.xyz))/brdf_pdf.w/(1.0-diffuseTerm);\n                  mask*=specular;\n                  nrd = d;\n              }\n              vec2 ob2 = box(nro, LightDir, vec3(-boxSize), vec3(boxSize));\n              vec3 nn;\n              int hitid2 = -1;\n              int igid2 = ignoreid;\n              float tt2 = trace(nro, LightDir, nn,hitid2,igid2);\n              hit = !(ob2.y < ob2.x || tt2 >= ob2.y - 1e-4);\n              vec3 suncolor = hit||depth==0?vec3(0.0):LightColor*max(dot(LightDir,n),0.0);\n              radiance +=mask*suncolor;\n          }\n          else//hit the sky\n          {\n              vec2 ob2 = box(nro, LightDir, vec3(-boxSize), vec3(boxSize));\n              vec3 nn;\n              int hitid2 = -1;\n              int igid2 = ignoreid;\n              float tt2 = trace(nro, LightDir, nn,hitid2,igid2);\n              hit = !(ob2.y < ob2.x || tt2 >= ob2.y - 1e-4);\n              vec3 suncolor = hit||depth==0?vec3(0.0):LightColor*max(dot(LightDir,n_last),0.0);\n              color=1.0*texture(iChannel1, nrd).xyz+suncolor;\n              radiance +=mask*color;            \n              break;   \n          }\n\n          n_last = n;   \n          ob = box(nro, nrd, vec3(-boxSize), vec3(boxSize));\n        } \n        acc +=clamp(radiance,0.0,10.0);\n    }\n    \n    acc/=float(S);\n    normal_identity/=float(S);\n    acc = clamp(acc,0.0,1.0);\n\n    fragColor.rgb = pow(acc,vec3(1.0/2.2));\n}\n\n\n\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtySW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 48, 48, 134], [135, 135, 161, 161, 313], [315, 315, 356, 356, 498], [499, 499, 534, 534, 593], [594, 594, 633, 633, 692], [693, 693, 753, 753, 925], [926, 926, 961, 961, 1256], [1257, 1257, 1325, 1325, 1821], [1822, 1822, 1927, 1927, 2312], [2313, 2338, 2381, 2381, 2593], [2594, 2594, 2635, 2635, 2778], [2779, 2779, 2849, 2849, 3874], [3875, 3875, 3897, 3897, 4066], [4067, 4087, 4144, 4144, 8819]], "test": "untested"}
{"id": "wtVXDV", "name": "Color rush", "author": "avin", "description": "visual experiment with color worms", "tags": ["noise", "collision", "colors", "hue"], "likes": 16, "viewed": 657, "published": 3, "date": "1583672328", "time_retrieved": "2024-07-30T21:19:49.776152", "image_code": "#define SF 2./min(iResolution.x, iResolution.y)\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;    \n    vec2 ouv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel1, ouv).xyz;    \n    \n    for (float i = 0.; i < float(COUNT); i += 1.) {\n        vec4 point = FD(i, 0);\n        \n        vec2 pos = point.xy;        \n        \n        float d = length(uv - pos)*1.5;                \n        float g = SS(d, RADIUS);                    \n        \n        col = mix(col, vec3(1.).rgb, g*.5);                       \n    }       \n\n    fragColor = texture(iChannel0, ouv);\n    fragColor = vec4(col, 0.);\n        \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define COUNT 122\n#define RADIUS .03\n#define SPEED .0038\n\n#define FD(x,y) texelFetch(iChannel0, ivec2(x, y), 0)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define MOD3 vec3(.1031, .11369, .13787)\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int x = int(fragCoord.x);\n    float fx = fragCoord.x;\n    int y = int(fragCoord.y);\n    \n    if(y > 2 || x > COUNT){\n    \tdiscard;\n    }     \n    \n    vec2 rt = vec2(iResolution.x / iResolution.y, 1.);\n    \n    if(iFrame == 1){\n        float ms = sqrt(float(COUNT));\n        float yp = floor(float(x) / ms) - ms*.45;\n        float xp = mod(float(x), ms) - ms*.45;\n        vec2 pos = (vec2(xp,yp)) * (1./ms)*.9;\n                \n        pos *= rt;                       \n                \n        vec2 dir = normalize(vec2(hash12(fragCoord*200.)*2.-1., hash12(fragCoord * 100.)*2.-1.));   \n        \n        if(y==0){\n            fragColor = vec4(pos, dir);                   \n        }\n        if(y==1){\n            fragColor = vec4(0., hash11(float(x)), 0., 0.);                   \n        }\n        \n    } else {\n        vec4 iPoint = FD(x,0);\n        vec2 pos = iPoint.xy;        \n        vec2 dir = iPoint.zw;\n                \n        \n        bool col = false;\n                                                       \n        \n        if(iPoint.x <= (-.5*rt.x + RADIUS)){\n            dir.x *= -1.;      \n            col = true;\n        }\n        if(iPoint.x >= (.5*rt.x - RADIUS)){\n            dir.x *= -1.; \n            col = true;\n        }\n        if(iPoint.y <= (-.5*rt.y + RADIUS)){\n            dir.y *= -1.;            \n            col = true;\n        }\n        if(iPoint.y >= (.5*rt.y - RADIUS)){\n            dir.y *= -1.;            \n            col = true;\n        }\n        \n        for(int i=0; i<COUNT; i+=1){\n            if(i!=x){\n                vec4 nPoint = FD(i,0);\n                vec2 nPointDir = nPoint.zw;\n                if(distance(nPoint.xy, pos) < (RADIUS*2.)){\n                    vec2 inV = normalize(nPoint.xy - pos);\n                    if(dot(dir, inV) > 0.){                    \t \n                        dir = reflect(dir, inV);                        \n                    }\n                    \n                    col = true;                    \n                }\n            }        \t\n        }\n        \n        dir = normalize(dir);\n                \n        pos += dir * SPEED \n            + vec2(\n                snoise(vec3(fx, fx*100., iTime)),\n                snoise(vec3(fx*33., fx*78., iTime))\n            )*.005;\n            // + vec2(sin(iTime*20. + hash11(float(x*25))), cos(iTime*10.  + hash11(float(x*100)))) * SPEED * .5;\n        \n        pos.x = min(max(pos.x, -.5*rt.x + RADIUS), .5*rt.x - RADIUS);\n        pos.y = min(max(pos.y, -.5*rt.y + RADIUS), .5*rt.y - RADIUS);\n        \n    \n        if(y==0){\n            fragColor = vec4(pos, dir);\n        } else if(y==1){\n            float oColFactor = FD(x,1.).y;\n            fragColor =  vec4(oColFactor + iTime*.25, oColFactor, 0, 0);\n        }       \n        \n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define COL1 vec3(24, 32, 38) / 255.0\n#define COL2 vec3(235, 241, 245) / 255.0\n\n#define SF 2./min(iResolution.x, iResolution.y)\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;    \n    vec2 ouv = fragCoord/iResolution.xy;    \n    \n    float m = 0.; \n    \n    vec3 backCol = texture(iChannel1, ouv).xyz;    \n    vec3 col = backCol*.99;\n    \n    for (float i = 0.; i < float(COUNT); i += 1.) {\n        vec4 point = FD(i, 0);\n        vec4 colData = FD(i, 1);\n        \n        float pointColFactor = colData.x;        \n        \n        vec2 pos = point.xy;        \n        \n        float d = length(uv - pos);        \n        float g = SS(d, RADIUS);                \n        \n        if(g > 0.){\n        \t\n        }\n        col = mix(col, hue(pointColFactor).rgb, g);                       \n    }       \n    \n    fragColor = vec4(col, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 150, 150, 738]], "test": "untested"}
{"id": "ttVXDV", "name": "Bitonic sorting network", "author": "michael0884", "description": "Fast parallel sort O(N*log2²(N)/2)", "tags": ["sort", "sorting", "parallel", "bitonic"], "likes": 11, "viewed": 910, "published": 3, "date": "1583670324", "time_retrieved": "2024-07-30T21:19:50.562050", "image_code": "vec2 getID(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    p = floor(vec2(0.4,0.4)*p);\n    if(p.x < N && p.y < N)\n    {\n    \tfloat id = p.x + p.y*N;\n        vec2 i = getID(id);\n    \tfragColor.xyz = 1.*vec3(1,1,1)*jet_range(getParticle(i.x).z,0.,1.);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n\n        float id = 1.3668*2.*3.14159*(pos.x + pos.y*N)/(N*N);\n        if(iFrame < 1)\n        {\n           // U.xy = size*0.5 + size.x*(vec2(1,0)*cos(id) + vec2(0,1)*sin(id))*0.25;\n            U.xy = size*hash22(pos);\n            U.zw = hash22(2.*pos);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//bitonic sort works correctly only for arrays of size 2^N\n#define N 128.\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat nbase(float x)\n{\n    return mix(hash11(floor(x)),hash11(ceil(x)), fract(x));\n}\n\nfloat fbm(float x, float t)\n{\n    float a = 1., b = 1., c = 0.;\n    for(int i = 0; i < 3; i++)\n    {\n        c += a*nbase(b*x + t);\n        a *= 2.5;\n        b *= 4.5;\n    }\n    return c;\n}\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\nfloat gauss(float x, float r)\n{\n    return exp(-pow(x/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nuniform sampler2D fake;\n\nvec4 getParticle(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(fake, vec2(x,y));\n}\n    ", "buffer_b_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\n#define slowdown 10.\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        if(mod(float(iFrame), slowdown) == 0.)\n        {\n            //initial parameters for bitonic sort step\n            float frame = floor(float(iFrame)/slowdown);\n            float Nlog2 = ceil(log2(N*N));\n            int cstep = int(mod(frame, Nlog2*Nlog2)); //bitonic sort step\n            int rank;\n            for(rank = 0; rank<cstep ; rank++)\n            {\n                cstep -= rank+1;\n            }\n            float stepno = float(1<<(rank+1));\n            float offset = float(1<<(rank-cstep));\n            float stage  = 2.*offset;\n            \n            //bitonic sort\n            float csign = (mod(id, stage)< offset) ? 1. : -1.;\n            float cdir  = (mod(floor(id/stepno),2.)<=0.5) ? 1. : -1.; \n            \n\t\t\tfloat adr1d = csign*offset + id;\n            \n            float p0_id = U.x;\n            float p1_id = getID(adr1d);\n\n            vec4 val0 = getParticle(p0_id);\n            vec4 val1 = getParticle(p1_id);\n\n            float cmin = (val0.z<val1.z) ? p0_id: p1_id;\n            float cmax = (val0.z<val1.z) ? p1_id: p0_id;\n\n            U.x = (csign==cdir) ? cmin : cmax;\n        }\n        \n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 112], [114, 114, 163, 163, 366]], "test": "untested"}
{"id": "wtKXWV", "name": "Fast Octree Path Tracing", "author": "yuchengzhong", "description": "origin:https://www.shadertoy.com/view/3dSGDR @fizzer\nWait til all texture is loaded\nGGX\nMIS\n", "tags": ["voxel", "pathtracing", "mis", "pt", "ggx", "traversal", "octree", "importantsample", "microsurface"], "likes": 49, "viewed": 2858, "published": 3, "date": "1583665145", "time_retrieved": "2024-07-30T21:19:51.579330", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 color = texture(iChannel0, uv).rgb;\n    \n\tfragColor = vec4(pow(clamp(color, 0., 1.), vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float boxSize = 1.0;\nfloat seed;\nfloat bluenoise(vec2 uv)\n{\n    uv += 1337.0*fract(iTime);\n    float v = texture( iChannel2 , (uv + 0.5) / iChannelResolution[2].xy, 0.0).x;\n    return v;\n}\nvec2 hash2() \n{\n    return fract(sin(vec2(seed+=1.0,seed+=1.0))*vec2(43758.5453123,22578.1459123));\n}\nfloat D_GGX(float Roughness, float NoH)\n{\n\tfloat a = Roughness * Roughness;\n\tfloat a2 = a * a;\n\tfloat d = (NoH * a2 - NoH) * NoH + 1.0;\t       \n\treturn a2 / (3.1415926535*d*d);\t\t\t\t\t\n}\nvec3 F_Schlick(vec3 S, float VoH)\n{\n\tfloat Fc = pow(1.0 - VoH, 5.0);\n\treturn S + (1.0-S)*Fc;\n}\nfloat F_Schlick_S(float S, float VoH)\n{\n\tfloat Fc = pow(1.0 - VoH, 5.0);\n\treturn S + (1.0-S)*Fc;\n}\nfloat Vis_Schlick( float Roughness, float NoV, float NoL )\n{\n\tfloat k = sqrt( Roughness ) * 0.5;\n\tfloat Vis_SchlickV = NoV * (1.0 - k) + k;\n\tfloat Vis_SchlickL = NoL * (1.0 - k) + k;\n\treturn 0.25 / ( Vis_SchlickV * Vis_SchlickL );\n}\nvec3 ImportanceSampleCos(vec3 d) \n{\n    vec2 rand = hash2();\n    float phi = 6.28318530718*rand.x;\n    float xiy = rand.y;\n    float r = sqrt(xiy);\n    float x = r*cos(phi);\n    float y = r*sin(phi);\n    float z = sqrt(max(0.0,1.0-x*x-y*y));\n\tvec3 w = d;\n\tvec3 u = cross(w.yzx, w);\n\tvec3 v = cross(w, u);\n    return w*z+u*x+v*y;\n}\nvec3 ImportanceSampleGGX(vec3 d,vec3 V,float roughness,out vec3 H)\n{\n    roughness =max(0.04,roughness);\n    vec2 rand = hash2();\n    float phi = 6.28318530718*rand.x;\n    float xiy = rand.y;\n\tfloat a = roughness * roughness;\n\tfloat CosTheta = sqrt((1.0 - xiy) / (1.0 + (a*a - 1.0) * xiy));\n\tfloat SinTheta = sqrt(1.0 - CosTheta * CosTheta);\n\tH = vec3(SinTheta * cos(phi),SinTheta * sin(phi), CosTheta);\n\tvec3 w = (d);\n\tvec3 u = (cross(w.yzx, w));\n\tvec3 v = cross(w, u);\n\tH = v * H.x + u * H.y + w * H.z;\n\tvec3 R = H*2.0 * dot(V,H)  - V;\n    return normalize(R);\n}\nvec4 SpecularBRDF_PDF(vec3 L,vec3 V,vec3 N,float roughness,float Spec,float M,vec3 C,out vec3 F,vec3 H)\n{\n     roughness =max(0.04,roughness);\n\t float NoL = dot(N, L);\n\t float NoV = dot(N, V);\n\t float NoH = dot(N, H);\n\t float VoH = dot(V, H);\n\n\t float D = D_GGX( roughness, NoH );\n\t float Vis = Vis_Schlick( roughness, NoV, NoL );\n     vec3 F0 =  mix(vec3(0.04+0.04*Spec),C*Spec,M);\n\t F = F_Schlick( F0, VoH );\n\t return vec4(max((D * Vis ) * F, 0.00001),max(D * NoH /(4.0*VoH), 0.00001));\n}\n// Ray-box intersection.\nvec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\nvec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)\n{\n    rp = rp - (p0 + p1) / 2.0;\n    vec3 arp = abs(rp) / (p1 - p0);\n    return normalize(step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp));\n}\nfloat trace(vec3 ro, vec3 rd, inout vec3 outn,out int id,int ignore)\n{\n    vec2 ob = box(ro, rd, vec3(-boxSize), vec3(boxSize));\n    \n    float tt = max(0., ob.x);\n    vec3 n = vec3(0, 1, 0);\n    for(int j = 0; j < 23; ++j)//should be 1.41*2*2^n，layer:n(1~6):6,12,23,46,91,181\n    {\n        if(tt > ob.y - 1e-4)\n        {\n            break;\n        }\n        vec3 p2 = ro + rd * tt;\n        vec3 p = p2 + sign(rd) * 1e-4;\n        vec3 p0 = vec3(-boxSize), p1 = vec3(+boxSize);\n        id = 0;\n        for(int i = 0; i < 3; ++i)\n        {\n            vec3 c = p0 + (p1 - p0) * (0.5);\n            vec3 o = step(c, p);\n            id = int(float(id) * 8.0 + dot(o, vec3(1, 2, 4)));\n            p0 = p0 + (c - p0) * o;\n            p1 = p1 + (c - p1) * (vec3(1) - o);\n        }\n        if(id!=ignore&&cos(float(id))>0.5)//cos:random empty\n        {\n            n = (boxNormal(p2,p0,p1));//+(p2 - (p0 + p1) / 2.) / (p1 - p0)\n            break;\n        }        \n        vec2 b = box(ro, rd, p0, p1);\n        tt = b.y;\n    }\n    outn = n;//normalize(pow(abs(n), vec3(16)) * sign(n));\n    return tt;\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#define USE_MOUSE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 texelsize = vec2(1.0)/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 LightDir = normalize(vec3(0.5,2.0,1.0));\n    vec3 LightColor = vec3(2.5);\n#ifdef USE_MOUSE\n    float a = 1.7 - 1.7 * iMouse.y / iResolution.y;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    float a2 = 0.6 - 2. * iMouse.x / iResolution.x+0.05*iTime;\n    mat2 m2 = mat2(cos(a2), sin(a2), -sin(a2), cos(a2));\n#else\n    float a = 0.6;// - 1.7 * iMouse.y / iResolution.y;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    float a2 = 0.02*iTime;\n    mat2 m2 = mat2(cos(a2), sin(a2), -sin(a2), cos(a2));\n#endif\n    \n    seed = bluenoise(fragCoord.xy);\n    seed = mod( seed*55.24317542, 3.14352);\n        \n    vec3 acc = vec3(0.0); \n    float normal_identity =0.0;\n#define S 12   \n#define D 4\n    for(int samples =0;samples<S;samples++)\n    {\n        vec2 offset = 2.0*texelsize*(hash2());\n        vec3 ro = vec3(0, -.1, 3.0);\n        vec3 rd = normalize(vec3(uv+offset, -2.0));\n\n        ro.yz *= m;\n        rd.yz *= m;\n        ro.xz *= m2;\n        rd.xz *= m2;\n        \n        \n        // Scene AABB.\n        vec2 ob = box(ro, rd, vec3(-boxSize), vec3(boxSize)); \n        vec3 nro = ro;      \n        vec3 nrd = rd;\n        //trace\n        int hitid=-1;\n        int ignoreid=-1;\n\n        vec3 n = vec3(0, 1, 0);\n        vec3 radiance = vec3(0.0);\n        vec3 mask = vec3(1.0);\n        vec3 n_last = n;\n        \n        for(int depth=0;depth<D;depth++)\n        {\n          float tt = trace(nro, nrd, n,hitid,ignoreid);\n          ignoreid = hitid;        \n          bool hit = !(ob.y < ob.x || tt >= ob.y - 1e-4);           \n          vec3 color;\n          float metallic =step(sin(float(hitid)),0.0);\n          float specular =1.0;\n          float roughness = 0.2*step(cos(float(hitid+21)),0.0);\n          normal_identity += (depth==0?(hit?dot(vec3(int(n.x>0.0),int(n.y>0.0),int(n.y>0.0)),vec3(4.0,2.0,1.0))/8.0:0.0):0.0);\n          if(hit)\n          {\n              \n              \n              color = hsv2rgb(vec3(cos(float(hitid)*0.5+0.5),0.7,0.99));//vec3(0.0);\n              float preF = min(0.4,F_Schlick_S( mix(0.04+0.04*specular,length(color*specular),metallic), dot(-nrd,n) ));\n              float diffuseTerm = (mix(0.6,0.3,metallic)*0.5+mix(0.8,0.6,specular)*0.5)*(1.0-preF);                \n              if(hash2().x<diffuseTerm)\n              {            \n                  nro = nro+nrd*tt;\n                  vec3 d = ImportanceSampleCos(n);  \n                  vec3 H = normalize(d-nrd);\n                  vec3 F0 =  mix(vec3(0.04+0.04*specular),color*specular,metallic);\n\t              vec3 F = F_Schlick( F0, dot(-nrd,H) );\n                  vec3 diffuse = (1.0-metallic)*(vec3(1.0) - F)*color/diffuseTerm;\n                  mask*=diffuse/3.1415926;\n                  nrd = d;\n              }\n              else\n              {\n                  nro = nro+nrd*tt;\n                  vec3 H = vec3(0.5);\n                  vec3 d = ImportanceSampleGGX(n,-nrd,roughness,H);\n\t\t\t      vec3 F=vec3(0.0);\n                  vec4 brdf_pdf = SpecularBRDF_PDF(d,-nrd,n, roughness,specular,metallic,color,F,H);\n\t\t\t      float NoL = max(dot(n, d), 0.0);\n                  vec3 specular = (NoL*(brdf_pdf.xyz))/brdf_pdf.w/(1.0-diffuseTerm);\n                  mask*=specular;\n                  nrd = d;\n              }\n              vec2 ob2 = box(nro, LightDir, vec3(-boxSize), vec3(boxSize));\n              vec3 nn;\n              int hitid2 = -1;\n              int igid2 = ignoreid;\n              float tt2 = trace(nro, LightDir, nn,hitid2,igid2);\n              hit = !(ob2.y < ob2.x || tt2 >= ob2.y - 1e-4);\n              vec3 suncolor = hit||depth==0?vec3(0.0):LightColor*max(dot(LightDir,n),0.0);\n              radiance +=mask*suncolor;\n          }\n          else//hit the sky\n          {\n              vec2 ob2 = box(nro, LightDir, vec3(-boxSize), vec3(boxSize));\n              vec3 nn;\n              int hitid2 = -1;\n              int igid2 = ignoreid;\n              float tt2 = trace(nro, LightDir, nn,hitid2,igid2);\n              hit = !(ob2.y < ob2.x || tt2 >= ob2.y - 1e-4);\n              vec3 suncolor = hit||depth==0?vec3(0.0):LightColor*max(dot(LightDir,n_last),0.0);\n              color=1.0*texture(iChannel1, nrd).xyz+suncolor;\n              radiance +=mask*color;            \n              break;   \n          }\n\n          n_last = n;   \n          ob = box(nro, nrd, vec3(-boxSize), vec3(boxSize));\n        } \n        acc +=clamp(radiance,0.0,10.0);\n    }\n    \n    acc/=float(S);\n    normal_identity/=float(S);\n    acc = clamp(acc,0.0,1.0);\n        \n    \n    \n#define R 4\n#define V 10.0\n#define V2 0.75\n\n    vec3 acc_re = vec3(0.0);\n    float acc_weight = 0.0;\n    for(int i=-R;i<=R;i++)\n    for(int j=-R;j<=R;j++)\n    {\n        vec4 last = texture(iChannel0,st+vec2(i,j)*texelsize);\n        float weight = max(dot(last.rgb,acc),0.1)*pow((1.0-abs(last.a-normal_identity)),16.0)/(length(vec2(i,j))+1.0);\n        acc_re+=last.rgb*weight;\n        acc_weight+=weight;\n    }\n    vec4 last = texture(iChannel0,st);\n    acc_re+=V*acc;\n    acc_re/=(acc_weight+V);\n    acc_re = mix(acc_re,last.rgb,V2);\n    fragColor.rgb = acc_re;\n    fragColor.a = normal_identity;\n}\n\n\n\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv);\n    \n\tfragColor = color;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 214]], "test": "untested"}
{"id": "wtGSDG", "name": "Learning about RayMarching", "author": "firegump", "description": "just learing, left click to drag the screen.", "tags": ["raymarching"], "likes": 6, "viewed": 531, "published": 3, "date": "1583664148", "time_retrieved": "2024-07-30T21:19:52.555720", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\nfloat hd = 1.;//height information\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099);\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                              hash( i + vec2(1.0,0.0) ), u.x),\n                         mix( hash( i + vec2(0.0,1.0) ), \n                              hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    return 0.5000*texture( iChannel0, p*1.00 ).x;//+ \n           //0.2500*texture( iChannel0, p*2.02 ).x+\n           //0.250*texture( iChannel0, p*4.05 ).x;\n           \n}\nfloat bgm( vec2 p )\n{\n    return 0.5000*texture( iChannel1, p*1.00 ).x+ \n           0.2500*texture( iChannel1, p*2.02 ).x+\n           0.250*texture( iChannel1, p*4.05 ).x;\n           \n}\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p,inout float hd) {\n    float bgm = bgm(vec2(0.1,1));//bgm anima\n    bgm = clamp(0.5,1.,bgm);\n        \n    float w1 = noise(p.xz+iTime);\n    float w2 = noise(p.xz-iTime*1.);\n    w1 = w1+ w2;\n    //w1 = pow(w1,2.);\n    \n    float w3 = fbm(p.xz*.01 + iTime*.01)*0.3;\n    float w4 = fbm(p.xz*.02 - iTime*.04)*0.2;\n    \n    \n    float w = w1*.6+ w3+w4;//wave\n    //w = w1*.6;\n    //w = w3 + w4;\n    \n    float sinOffset =  sin(p.x*1.+ iTime)*.05 + sin(p.z*4. + iTime*2.)*.05;\n    sinOffset = sinOffset * .3;\n    float hd1 = sinOffset + w*0.2;//wave height\n    hd = hd1 + bgm*.1;\n    \n    vec3 pn = vec3(0,1,0);\n    pn.x = p.x*0.01 + sin(iTime)*.01;//wobble\n    pn.z = p.z*0.01 + cos(iTime)*.01;\n    \n    pn.xz = pn.xz*(sin(iTime*1.)*.26 + .89);//convex\n    //pn.xz = pn.xz*(sin(iTime*1.)*.5+.7);//wave concave ,convex \n    float plane = dot(p,normalize(pn)) +2. + hd1;//plane distance\n    \n    vec3 bp = p-vec3(0,sin(iTime)*.5+ .5,0);\n    \n    bp = abs(bp);\n    bp.xz -= 1.;\n     \n   \n    float scale = mix(1.,5.,smoothstep(-1.,1.,bp.y));\n    \n    bp.xz *= scale;\n    bp.xz *= Rot(bp.y+iTime);\n    \n    \n    \n    bp.xz = abs(bp.xz);\n    bp.xz -= 1.5;\n    \n    \n    \n    float box = sdBox(bp, vec3(1,1,1));\n    \n    //box = sdBox(p-vec3(0,1,0)-sin(p.x* 6.5+iTime*4.)*.02, vec3(1,.02,1));//wave\n    //box = abs(box)-.1;   //making  shell\n    vec4 s1 = vec4(0,1.5+ bgm,0,1.);\n    float sd1 = length(p-s1.xyz) - s1.w-bgm;\n    float sd = sd1;\n    float d = smin(plane, box*.1,0.9);\n    d= smin(sd, d,0.7);\n    \n    //sky\n    float sdsky = length(p)- 52.;\n    sdsky = abs(sdsky) - 1.5;\n    \n    d = min(d,sdsky);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float h = 1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p,hd);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    \n\tfloat d = GetDist(p, hd);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, hd),\n        GetDist(p-e.yxy, hd),\n        GetDist(p-e.yyx, hd));\n    \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p,vec3 rd, vec3 lightPos, vec3 lightCol) {\n    vec3 v = -rd;\n    \n    \n    //attenuation\n    float atten = 1. - length(lightPos - p)/20.;//float is light Area\n    atten = smoothstep(1.,.5,clamp(0.,1.,atten));\n    \n    float MoveRadius = 0.;\n    float MoveSpeed = 0.;\n    \n    //float t = iTime * MoveSpeed;\n    //lightPos.xz += vec2(sin(t), cos(t)) * MoveRadius;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    vec3 ref = reflect(n,rd);\n    //ambient\n    float amb = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n    //diffuse\n    float NdotL = dot(n, l);\n    NdotL = NdotL*.5 + .5;\n    float dif = clamp(NdotL, 0. , 1.);\n    //specular\n    vec3 h = normalize(l + v);\n    float spe = pow(max(dot(n,h),0.), 128.);\n    //fresnel\n    //float fs = .4; //fresnel scale\n    \n    \n    \n    \n    \n    float fre =  clamp(  1.+ dot(rd,n)       ,0.,1.);\n    fre = pow(fre, 4.);\n    //dom\n    float dom = smoothstep( -0.2, 0.2, ref.y );\n    \n    \n    //ficker\n    vec4 fcol = texture(iChannel3,p.xz);\n    \n    \n    vec3 finCol = vec3(0.); \n    finCol += amb * vec3(1,1,0) * .5;\n    finCol += dif * vec3(1,1,1) * .5;\n    finCol += spe * vec3(1,1,1) * 1.;\n    finCol *= fre * vec3(1,1,0)* .1;\n   \tfinCol += dom * vec3(0,1,1) * 0.1;\n    vec3 refT = texture(iChannel2,ref).xyz;\n    finCol += refT*.5*( dot(rd,n)*.5+.5);\n    \n    \n    finCol *= atten*lightCol*1.4;\n    finCol *= 2.;\n    //finCol = vec3(dom);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    //if(p.y<.01 && d<length(lightPos-p)) dif *= 0.3;//shadow\n    \n    //color adjust\n    finCol.rg *= 0.5;\n    finCol.g *= .7;\n    //finCol = i\n    return finCol ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(0,4.2, -12);//camera point\n    ro.yz *= Rot(-m.y*3.14*.6 + sin(iTime*.6)*0.52 -.4);//camera rotate animation\n    ro.xz *= Rot(-m.x*6.2831 + sin(iTime*.3));\n    \n    vec3 rd = R(uv, ro, vec3(0,3,0), 1.);//look point\n    \n    //vec3 Bgcol = texture(iChannel2,rd).xyz;\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 lightPos = vec3(-2. , 9. , -4. );\n    vec3 lightCol = vec3(1, 1 ,1);\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tvec3 dif = GetLight(p,rd,lightPos, lightCol);\n        //dif.x = clamp(0.,1.,dif.x);\n        //vec3 BGcolor = mix(vec3(.1,0.1,0.1), vec3(0.1,0.1,1),smoothstep(1., 100.,d));\n        //col = Bgcol;\n    \t//if(col.r > 0.)  col = dif;\n        col = dif;\n        //col = vec3(uv,1.);\n        col = dif *3.5;//color adjust\n        \n        //float hda = smoothstep(0.,1.,hd);\n        //col += vec3(hd)*1.1*(sin(iTime*2.)*.2+.8)*vec3(1,0.7,.5)*sin(p.z + p.x + p.y );\n        \n        vec3 hdcol = vec3(hd)*1.1*(sin(iTime*2.)*.1+.9)*vec3(0,.3,.7);\n        col += hdcol;\n        \n        \n        col = pow(col, vec3(1.0/2.2));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 102, 122, 122, 198], [200, 200, 226, 226, 556], [558, 558, 579, 579, 750], [751, 751, 772, 772, 936], [937, 937, 956, 956, 1032], [1034, 1034, 1075, 1075, 1166], [1169, 1169, 1198, 1198, 1279], [1282, 1282, 1320, 1320, 2924], [2926, 2926, 2960, 2960, 3192], [3194, 3194, 3218, 3218, 3429], [3431, 3431, 3492, 3492, 5071], [5073, 5073, 5115, 5115, 5310], [5314, 5314, 5371, 5371, 6625]], "test": "untested"}
{"id": "wlKSWV", "name": "Odd-Even sorting", "author": "michael0884", "description": "Super simple sorting", "tags": ["sort", "sorting", "parallel", "oddeven"], "likes": 6, "viewed": 404, "published": 3, "date": "1583663413", "time_retrieved": "2024-07-30T21:19:53.416418", "image_code": "vec2 getID(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{    \n    p = floor(vec2(0.15,0.15)*p);\n    if(p.x < N && p.y < N)\n    {\n    \tfloat id = p.x + p.y*N;\n        vec2 i = getID(id);\n    \tfragColor.xyz = 1.*vec3(1,1,1)*jet_range(getParticle(i.x).z,0.,1.);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n\n        float id = 1.3668*2.*3.14159*(pos.x + pos.y*N)/(N*N);\n        if(iFrame < 1)\n        {\n           // U.xy = size*0.5 + size.x*(vec2(1,0)*cos(id) + vec2(0,1)*sin(id))*0.25;\n            U.xy = size*hash22(pos);\n            U.zw = hash22(2.*pos);\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N 50.\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat nbase(float x)\n{\n    return mix(hash11(floor(x)),hash11(ceil(x)), fract(x));\n}\n\nfloat fbm(float x, float t)\n{\n    float a = 1., b = 1., c = 0.;\n    for(int i = 0; i < 3; i++)\n    {\n        c += a*nbase(b*x + t);\n        a *= 2.5;\n        b *= 4.5;\n    }\n    return c;\n}\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\nfloat gauss(float x, float r)\n{\n    return exp(-pow(x/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nuniform sampler2D fake;\n\nvec4 getParticle(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(fake, vec2(x,y));\n}\n    ", "buffer_b_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nfloat just_sorting(float id1, float id2)\n{\n    vec4 a0 = getParticle(getID(id1));\n    vec4 a1 = getParticle(getID(id2));\n    if(id2 < id1)\n    {\n        if(a1.z > a0.z)\n        \treturn getID(id2);\n    \telse\n        \treturn getID(id1);\n    } \n    else\n    {\n        if(a1.z < a0.z)\n        \treturn getID(id2);\n    \telse\n        \treturn getID(id1);\n    }\n}\n\n\n#define slowdown 1.\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;\n        \n        \n        if(mod(float(iFrame), slowdown) == 0.)\n        {\n            \n            //odd even sort\n            float oe = floor(mod(float(iFrame)/slowdown,2.)); \n            //pair id\n            float pair = abs(floor((id+oe)/2.));\n            //left or right on the pair\n            float pairid = (id + oe) - 2.*pair; //0 or 1\n            //partners id\n            float id1 = mod((2.*pairid - 1.) + id, N*N);\n\n            U.y = pairid;\n\n            U.x = just_sorting(id, id1);\n        }\n        \n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 112], [114, 114, 163, 163, 372]], "test": "untested"}
{"id": "ttKSWK", "name": "SDF_CornellBox", "author": "Hei149", "description": "raymarching", "tags": ["raymarching", "cornellbox", "pathtracing"], "likes": 3, "viewed": 265, "published": 3, "date": "1583642964", "time_retrieved": "2024-07-30T21:19:54.266147", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "///SDF path tracing cornell box\n#define rotate(angle) mat2(cos(angle), sin(angle), -sin(angle), cos(angle))\nconst vec3 light_position = vec3(0.0, 24.9, 0.0);\nconst vec3 light_dimension = vec3(8.0, 1.0, 8.0);\nconst float lightIntensity = 2.0f;\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n    return length(p.xz) - r;\n}\nfloat sdCappedCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz) - r, abs(p.y) - h);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 h = abs(p) - b;\n    return max(h.x, max(h.y, h.z));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat matId = 0.0;\nfloat map(vec3 p)\n{\n    float d = sdBox(p - vec3(25.0, 0.0, 0.0), vec3(0.1, 25.0, 25.0));\n    float d1= sdBox(p + vec3(25.0, 0.0, 0.0), vec3(0.1, 25.0, 25.0));\n    if(d < d1){\n        matId = 1.0;\n    }\n    else\n    {\n        matId = 2.0;\n        d = d1;\n    }\n    d1 = sdBox(p - vec3(0.0, 0.0, 25.0), vec3(25.0, 25.0, 0.1));\n    d1 = min(d1, sdBox(abs(p) - vec3(0.0, 25.0, 0.0), vec3(25.0, 0.1, 25.0)));\n    \n    vec3 rp = p + vec3(-8.0, 18.0, 15.0);\n    rp.xz *= rotate(-0.314);\n    d1 = min(d1, sdBox(rp, vec3(7)));\n\n    rp = p + vec3(8., 12.0, 0.0);\n    rp.xz *= rotate(0.262);\n    if(d1 < d)\n    {\n        matId = 0.0;\n        d = d1;\n    }\n    d1 = sdBox(rp, vec3(7, 14, 7));\n    if(d1 < d)\n    {\n        matId = 4.0;\n        d = d1;\n    }\n    d1 = sdBox(p - light_position, light_dimension);\n    if(d1 < d)\n    {\n        matId = 3.0;\n        d = d1;\n    }\n    \n    return d;\n}\n\nvec3 hash33(vec3 p)\n{\n    return fract(sin(p * vec3(29.244, 89.6994, 456.4939)) * 50391.2484);\n}\n\nvec3 RandomInUnitSphere(vec3 seed) \n{\n    vec3 h = hash3(g_seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nbool rayMarch(vec3 r0, vec3 rd, inout float d)\n{\n    d = 0.0;\n    for(int i = 0; i < 100; ++i)\n        {\n            vec3 p = r0 + d * rd;\n            float t = map(p);\n            d += t;\n            if(abs(t) < 0.001)\n            {\n                return true;\n            }\n            if(d > 200.0) break;\n        }\n    return false;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    g_seed = float(base_hash(floatBitsToUint(gl_FragCoord.xy)))/float(0xffffffffU)+iTime;\n    vec2 luv = fragCoord.xy / iResolution.xy;\n    vec2 uv = (fragCoord + vec2(fract(iTime)) - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(0.1, 0.0, -100.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 10.;\n    \n    vec3 tgt = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(tgt - r0);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    float zoom = 1.5;\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + zoom * ww);\n    \n    float d = 0.0;\n    vec3 col = vec3(1.0);\n    const vec3 red =  vec3(0.65, 0.05, 0.05);\n    const vec3 white = vec3(0.73);\n    const vec3 green = vec3(0.12, 0.45, 0.15);\n\n    vec3 albedo = white;\n    vec3 tcol = vec3(0.0);\n    for(int i = 0; i < 4; ++i){\n        if(rayMarch(r0, rd, d))\n        {\n            if(matId == 1.0)\n            {\n                albedo = red;\n            }\n            else if(matId == 2.0)\n            {\n                albedo = green;\n            }\n            else if(matId == 3.0)\n            {\n                if(dot(norm(r0 + d * rd), vec3(0.0, 1.0, 0.0)) < 0.0)\n                    tcol += col * lightIntensity;\n                break;\n            }\n            else\n            {\n                albedo = white;\n            }\n\n            vec3 p = r0 + d * rd;\n            vec3 n = norm(p);\n            //magic number \n            r0 = p + n * 0.01;\n            col *= albedo;\n#if 1\n            if(matId == 4.0)\n            {\n                r0 = p + n * 0.01;\n                rd = normalize(reflect(rd, n));\n            }\n            else\n               #endif\n              \trd = normalize(RandomInUnitSphere(r0) + n);\n\n            vec2 rand = hash2(g_seed);\n            vec3 lp = vec3(light_position.x + rand.x * light_dimension.x, light_position.y, rand.y * light_dimension.z);\n             vec3 ld = normalize(lp - p);\n             float sdis = 0.0;\n             if(rayMarch(r0, ld, sdis))\n             {\n                 if(matId == 3.0f)\n                 {\n                     float area = light_dimension.x * light_dimension.z;\n                     float weight = sqrt(1.0f - clamp(area / dot(lp, lp), 0.0f, 1.0f));\n                     weight = 2.0f * 3.141592 * (1.0f - weight);\n                     tcol += (col / 3.141592 * lightIntensity) * weight * max(dot(n, ld), 0.0f);\n                 }\n             }\n        }\n        else\n        {\n            col *= vec3(0.0);\n            break;\n        }\n    }\n    \n    col = pow(tcol, vec3(0.4545));\n    \n    float numSample = texture(iChannel0, luv).w + 1.0;\n    col = mix(texture(iChannel0, luv).rgb, col, 1.0 / numSample);\n    fragColor = vec4(col, numSample);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKSWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 182]], "test": "untested"}
{"id": "WlVXDV", "name": "ReflectionMess", "author": "Hei149", "description": "sdf", "tags": ["sdf", "pathtracing"], "likes": 9, "viewed": 400, "published": 3, "date": "1583641749", "time_retrieved": "2024-07-30T21:19:55.030104", "image_code": "#define rotate(angle) mat2(cos(angle), sin(angle), -sin(angle), cos(angle))\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n    return length(p.xz) - r;\n}\nfloat sdCappedCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz) - r, abs(p.y) - h);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 h = abs(p) - b;\n    return max(h.x, max(h.y, h.z));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat matId = 0.0;\n\nvec3 kifs(vec3 p)\n{\n    float t = iTime * 0.2;\n    for(int i = 0; i < 3; ++i)\n    {\n        p = abs(p) - 0.3;\n        p.xz *= rotate(0.7878 + t);\n        p.yz *= rotate(1.3 + t);\n        p.xy *= rotate(2.6 + t);\n    }   \n    return p; \n}\n\nfloat map(vec3 p)\n{\n    /*\n    float d = sdSphere(p + vec3(0.0 ,0.3, 0.0), 0.5);\n    d = min(d, sdCappedCylinder(p - vec3(1.0, 0.0, -2.0), 0.5, 1.0));\n    //d = min(d, p.y + 1.0);\n    float d1 = sdBox(p + vec3(-2.0, 0.0, 0.0), vec3(0.5, 1.0, 0.5));\n    if(d < d1)\n        matId = 0.0;\n    else\n    {\n        matId = 1.0;\n        d = d1;\n    }\n    */\n    //p.xz *= rotate(iTime);\n    matId = 1.0;\n    p = kifs(p);\n    float d = sdBox(p, vec3(0.2));\n    return d;\n}\n\nvec3 hash33(vec3 p)\n{\n    return fract(sin(p * vec3(29.244, 59.6994, 456.4939)) * 50391.2484);\n}\nvec3 RandomInUnitSphere(vec3 seed) \n{\n    vec3 h = hash33(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nbool rayMarch(vec3 r0, vec3 rd, inout float d)\n{\n    d = 0.0;\n    for(int i = 0; i < 100; ++i)\n        {\n            vec3 p = r0 + d * rd;\n            float t = map(p);\n            d += t;\n            if(abs(t) < 0.001)\n            {\n                return true;\n            }\n            if(d > 100.0) break;\n        }\n    return false;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 luv = fragCoord.xy / iResolution.xy;\n    vec3 final_col = vec3(0.0);\n    vec2 uv = (fragCoord + vec2(fract(iTime)) - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(0.0, 3.0, -5.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 10.;\n    r0.yz *= rotate(mouse.y);\n    r0.xz *= rotate(mouse.x);\n    vec3 tgt = vec3(0.0);\n    vec3 ww = normalize(tgt - r0);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    float zoom = 1.3;\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + zoom * ww);\n    \n    float d = 0.0;\n    vec3 col = vec3(1.0);\n    for(int i = 0; i < 10; ++i){\n        if(rayMarch(r0, rd, d))\n        {\n            float mat = matId;\n            vec3 p = r0 + d * rd;\n            vec3 n = norm(p);\n            r0 = p + 0.1 * n;\n            vec3 albedo = vec3(0.2, 0.5, 0.8);\n            if(mat >  0.5){\n                rd = reflect(rd, n);\n            }\n            else{\n                rd = normalize(RandomInUnitSphere(r0) + n);\n                \n            }\n            col *= albedo;\n        }\n        else{\n            col *= texture(iChannel0, rd).rgb;//mix(vec3(1.0), vec3(0.5, 0.7, 1.0), rd.y + 1.5);\n            break;\n        }\n    }\n\n    col = pow(col, vec3(0.4545));\n    /*\n    if(iMouse.z < 0.0)\n    {\n        vec3 color = texture(iChannel0, luv).rgb;\n        float alpha = 1.0 / float(iFrame + 1);\n        col = mix(color.rgb, col, alpha);\n    }\n    */\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 110, 110, 138], [140, 140, 175, 175, 206], [207, 207, 257, 257, 307], [309, 309, 338, 338, 401], [403, 403, 444, 444, 537], [559, 559, 578, 578, 796], [798, 798, 817, 1176, 1261], [1263, 1263, 1284, 1284, 1359], [1360, 1360, 1397, 1397, 1582], [1584, 1584, 1632, 1632, 1923], [1925, 1925, 1944, 1944, 2134], [2136, 2136, 2191, 2191, 3670]], "test": "untested"}
{"id": "3lKSDV", "name": "Destructible ", "author": "wyatt", "description": "Looks good with 4x speedup. Forces depend on particle collisions  as well as neighborhood interactions within the solid bodies. ", "tags": ["particles", "triangulation"], "likes": 28, "viewed": 775, "published": 3, "date": "1583636124", "time_retrieved": "2024-07-30T21:19:55.807027", "image_code": "// Fork of \"Foam Simulation\" by wyatt. https://shadertoy.com/view/tlyXDG\n// 2020-03-08 02:50:08\n\n// Fork of \"Triangulated Actors****\" by wyatt. https://shadertoy.com/view/ttGXDG\n// 2020-03-06 04:21:54\n\nMain \n    vec4 b = B(U),\n         a = A(b.xy), aa = A(b.zw);\n    \n    float \t\n          r = length(a.xy-aa.xy), \n          rr = length(shape(b.xy)-shape(b.zw)),\n          o = length(U-a.xy),\n          w = sg(U,a.xy,aa.xy),\n          v = pie(U,a.xy,aa.xy);\n    \n    Q = smoothstep(1.5*O,O,min(rr,O*o))*\n        smoothstep(2.,0.,w)*\n        (0.6+0.4*sin(vec4(1,2,3,4)+6.2*length(round(10.+b.xy/W/O)*W*O/R)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U) { U = gl_FragCoord.xy;\n#define Init if (iFrame < 1) \n#define init  (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n\n#define O 5.\n#define W 5.\nvec2 shape (vec2 u) {\n    u = round(u/O)*O;\n    vec2 q = W*O+min(floor(u/60.)*60.,O*W*8.);\n\tu = clamp(u,O*2.+q,2.*O+O*W+q);\n    return u;\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} ", "buffer_a_code": "// Information Storage\nMain \n\tvec2 u = shape(U);\n    Q = A(U);\n    vec2 f = vec2(0), f1 = vec2(0);\n\tfloat n = 0., n1 = 0.;\n\tfor (int x = -2; x <= 2; x++)\n    for (int y = -2; y <= 2; y++){\n        vec2 v =shape(u+O*vec2(x,y));\n    \tQ.zw += C(Q.xy+vec2(x,y)).xy;\n        vec4 t = A(v);\n        vec2 r = t.xy-Q.xy;\n        float l = length(r), ll = length(u-v), lll = length(u+O*vec2(x,y)-v);\n        if (ll>1.&&ll<3.*O&&l>0.&&lll<1.) {\n            n++;\n            f += 100.*r/l/max(1.,l*l*ll)*sign(l-length(u-v));\n        }\n        t = A(B(Q.xy+vec2(x,y)).xy);\n        r = t.xy-Q.xy;\n        l = length(r);\n        if (l>0.) {\n            n1++;\n            f1 -= 10.*r/l/max(1.,l*l)*smoothstep(.9*O,0.5*O,l);\n        }\n    }\n\tif (n>0.) f = f/n; else f = vec2(0);\n\tif (n1>0.) f1 = f1/n1; else f1 = vec2(0);\n\tQ.zw = Q.zw + f + f1;\n\tQ.xy += f+Q.zw*(1./sqrt(1.+dot(Q.zw,Q.zw)));\n    \n    if (Q.x<5.){Q.x=5.;Q.z*=-.9;}\n    if (Q.y<5.){Q.y=5.;Q.w*=-.9;}\n    if (R.x-Q.x<5.){Q.x=R.x-5.;Q.z*=-.9;}\n    if (R.y-Q.y<5.){Q.y=R.y-5.;Q.w*=-.9;}\n\n\tif (iFrame < 3)\n    {\n    \t\n        Q = vec4(u,0.2,0.3);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// SORT TRIANGULATION\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 aa, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    float ln = length(n.xy-U), la = length(a.xy-U);\n    if (ln<=la) {\n    \tQ.xy = b.xy;\n        a.xy = n.xy;\n    }\n    float pn = pie(U,a.xy,n.xy), \n          pa = pie(U,a.xy,aa.xy);\n    if (pn<=pa){\n        aa = n;\n        Q.zw = b.xy;\n    }\n\tn = A(b.zw);\n    ln = length(n.xy-U);\n    if (ln<la) {\n    \tQ.xy = b.zw;\n        a.xy = n.xy;\n    }\n    pn = pie(U,a.xy,n.xy);\n    if (pn<pa){\n        aa = n;\n        Q.zw = b.zw;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 aa, vec2 U, float r) {\n\t X(Q,a,aa,U,vec2(r,0));\n     X(Q,a,aa,U,vec2(0,r));\n     X(Q,a,aa,U,vec2(0,-r));\n     X(Q,a,aa,U,vec2(-r,0));\n}\nMain \n\tQ = B(U);\n    vec4 a = A(Q.xy), aa= A(Q.zw);\n    Xr(Q,a,aa,U,1.);\n    Xr(Q,a,aa,U,2.);\n    Xr(Q,a,aa,U,4.);\n    Xr(Q,a,aa,U,8.);\n    for (int i = 0; i < 10; i++) {\n        vec2 u = vec2(\n            (10*iFrame+i)%int(R.x),\n            (10*iFrame+i)/int(R.x)%int(R.y));\n        if (length(U-A(u).xy)<length(U-a.xy)) Q.xy = u;\n    }\n    Init {\n        Q.xy = U;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// COMPUTE FORCE FIELD\nMain \n\tvec4 b = B(U);\n\tvec4 a = A(b.xy), aa = A(b.zw);\n\tvec2 r = a.xy-aa.xy;\n\tfloat l = length(r);\n   \tvec2 v = vec2(0);\n\tif (l>0.) \n      Q.xy = 100.*r/l/max(1.,l*l)*smoothstep(0.9*O,0.5*O,l);\n    if (length(Q.xy)>.1) Q.xy = 0.1*normalize(Q.xy);\n\tif (iMouse.z>0.&&length(a.xy-iMouse.xy)>0.)\n        Q -= vec4(2,2,0,0)*clamp(0.03*(a.xy-iMouse.xy)/dot((a.xy-iMouse.xy),(a.xy-iMouse.xy)),-2e-4,2e-4).xyxy;\n\t\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3tGXz3", "name": "Interactive liquid metal blob", "author": "tmst", "description": "- Same as my previous [url=https://www.shadertoy.com/view/3tGSDD]Swirling cube[/url], but rendered as a solid.\n- Use the mouse to interact!", "tags": ["cube", "voxel", "metal", "liquid", "swirling", "sculpt"], "likes": 57, "viewed": 1371, "published": 3, "date": "1583635308", "time_retrieved": "2024-07-30T21:19:57.039731", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = textureLod(iChannel0, uv, 0.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BOX_N 127.0\n#define DENSITY_THRESH 2.0\n\n// Data is organized into 3 \"pages\" of 128x128x128 values.\n// (The values are at voxel corners, so there are 127x127x127 voxels)\n// Each \"page\" takes up 2 faces of the 1024x1024 cubemap,\n// each face storing 8x8=64 of the 128x128 slices.\n\nvec3 vcubeFromLMN(in int page, in vec3 lmn)\n{\n    // subtexture within [0,8)^2\n    float l = mod(floor(lmn.x), 128.0);\n    float tm = mod(l, 8.0);\n    float tn = mod((l - tm)/8.0, 8.0);\n    vec2 tmn = vec2(tm, tn);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(floor(lmn.yz), 128.0);\n\n    // pixel position on 1024x1024 face\n    vec2 fragCoord = 128.0*tmn + mn + 0.5;\n    vec2 p = fragCoord*(2.0/1024.0) - 1.0;\n\n    vec3 fv;\n    if (page == 1) {\n        fv = vec3(1.0, p);\n    } else if (page == 2) {\n        fv = vec3(p.x, 1.0, p.y);\n    } else {\n        fv = fv = vec3(p, 1.0);\n    }\n\n    if (l < 64.0) {\n        return fv;\n    } else {\n        return -fv;\n    }\n}\n\nvoid lmnFromVCube(in vec3 vcube, out int page, out vec3 lmn)\n{\n    // page and parity, and pixel position on 1024x1024 texture\n    vec2 p;\n    float parity;\n    if (abs(vcube.x) > abs(vcube.y) && abs(vcube.x) > abs(vcube.z)) {\n        page = 1;\n        p = vcube.yz/vcube.x;\n        parity = vcube.x;\n    } else if (abs(vcube.y) > abs(vcube.z)) {\n        page = 2;\n        p = vcube.xz/vcube.y;\n        parity = vcube.y;\n    } else {\n        page = 3;\n        p = vcube.xy/vcube.z;\n        parity = vcube.z;\n    }\n    vec2 fragCoord = floor((0.5 + 0.5*p)*1024.0);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(fragCoord, 128.0);\n\n    // subtexture within [0,8)^2\n    vec2 tmn = floor(fragCoord/128.0);\n\n    float lAdd;\n    if (parity > 0.0) {\n        lAdd = 0.0;\n    } else {\n        lAdd = 64.0;\n    }\n    lmn = vec3(tmn.y*8.0 + tmn.x + lAdd, mn);\n}\n", "cube_a_code": "// --------------------------------------\n// Helpers for accessing volumetric data\n// --------------------------------------\n\nvec2 getDataNearest(vec3 lmn) {\n    return texture(iChannel0, vcubeFromLMN(1, lmn)).st;\n}\n\nvec2 getDataInterp(vec3 lmn) {\n    vec3 flmn = floor(lmn);\n\n    vec2 d000 = getDataNearest( flmn );\n    vec2 d001 = getDataNearest( flmn + vec3(0.0, 0.0, 1.0) );\n    vec2 d010 = getDataNearest( flmn + vec3(0.0, 1.0, 0.0) );\n    vec2 d011 = getDataNearest( flmn + vec3(0.0, 1.0, 1.0) );\n    vec2 d100 = getDataNearest( flmn + vec3(1.0, 0.0, 0.0) );\n    vec2 d101 = getDataNearest( flmn + vec3(1.0, 0.0, 1.0) );\n    vec2 d110 = getDataNearest( flmn + vec3(1.0, 1.0, 0.0) );\n    vec2 d111 = getDataNearest( flmn + vec3(1.0, 1.0, 1.0) );\n\n    // TODO: Compare to interpolation in Buf A\n    vec3 t = lmn - flmn;\n    vec2 dY0Z0 = mix(d000, d100, t.x);\n    vec2 dY1Z0 = mix(d010, d110, t.x);\n    vec2 dY0Z1 = mix(d001, d101, t.x);\n    vec2 dY1Z1 = mix(d011, d111, t.x);\n    vec2 dZ0 = mix(dY0Z0, dY1Z0, t.y);\n    vec2 dZ1 = mix(dY0Z1, dY1Z1, t.y);\n    return mix(dZ0, dZ1, t.z);\n}\n\n// ------------------------------\n// Some noise for the cube faces\n// ------------------------------\n\nfloat rand(in vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n\n    float r00 = rand(vec2(pi.x    ,pi.y    ));\n    float r10 = rand(vec2(pi.x+1.0,pi.y    ));\n    float r01 = rand(vec2(pi.x    ,pi.y+1.0));\n    float r11 = rand(vec2(pi.x+1.0,pi.y+1.0));\n\n    vec2 m = pf*pf*(3.0-2.0*pf);\n    return mix(mix(r00, r10, m.x), mix(r01, r11, m.x), m.y);\n}\n\nfloat fbm(vec2 uv) {\n    vec2 p = uv*32.0;\n\n    float v = noise(p);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    p *= 0.5;\n    v = mix(v, noise(p), 0.5);\n\n    return v;\n}\n\n// ----------------------------------------------------------------------\n// Rodrigues' formula: v -> (v.n)n + (v-(v.n)n)c - (vxn)s\n// in matrix form: (1-c)[n*n^T] + cI - s[[0,n3,-n2][-n3,0,n1][n2,-n1,0]]\n// ----------------------------------------------------------------------\n\nmat3 glRotate(vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 n = normalize(axis);\n\n    return mat3(\n        (1.0-c)*n.x*n.x + c,\n        (1.0-c)*n.y*n.x + s*n.z,\n        (1.0-c)*n.z*n.x - s*n.y,\n\n        (1.0-c)*n.x*n.y - s*n.z,\n        (1.0-c)*n.y*n.y + c,\n        (1.0-c)*n.z*n.y + s*n.x,\n\n        (1.0-c)*n.x*n.z + s*n.y,\n        (1.0-c)*n.y*n.z - s*n.x,\n        (1.0-c)*n.z*n.z + c\n    );\n}\n\n// -----------------------\n// Volumetric data update\n// -----------------------\n\n// NOTE: These pixels refer to voxel *corners* with s as \"density\" and\n// t as \"temperature\".  These will be interpolated in the voxel volume.\n\nvec3 cpLine(vec3 q0, vec3 q1, vec3 p) {\n    vec3 vEdge = q1 - q0;\n    float t = dot(p - q0, vEdge) / dot(vEdge, vEdge);\n    return q0 + t*vEdge;\n}\n\nfloat sdLine(vec3 q0, vec3 q1, vec3 p) {\n    vec3 x = cpLine(q0, q1, p);\n    return distance(x, p);\n}\n\nvoid doPage1(out vec4 fragColor, in vec3 lmn)\n{\n    float iTimeN = float(iFrame)/60.0;\n\n    vec3 mid = vec3(63.5);\n    vec3 absd = abs(lmn-mid);\n    float dcorner = max(max(absd.x, absd.y), absd.z);\n\n    vec2 stNext = vec2(0.0);\n    if (dcorner > 62.0) {\n        // On the cube faces, add density noise at 0 temperature\n        float noiseVal = 0.0;\n\n        if (absd.x > 62.0) {\n            noiseVal = fbm(0.02*lmn.yz);\n        } else if (absd.y > 62.0) {\n            noiseVal = fbm(0.02*lmn.xz);\n        } else if (absd.z > 62.0) {\n            noiseVal = fbm(0.02*lmn.xy);\n        }\n\n        float modTime = mod(iTimeN, 12.0);\n        float dofull = 1.0 - step(0.64, abs(modTime-3.0));\n        float doempty = 1.0 - step(0.45, abs(modTime-9.0));\n\n        float dNext = 2.0*pow(noiseVal, 3.0);\n        dNext = mix(dNext, 0.5, mix(0.0, 0.8, dofull));\n        dNext = mix(dNext, 0.0, mix(0.0, 0.8, doempty));\n\n        stNext = vec2(dNext, 0.0);\n\n    } else {\n        // On the interior: shrink, rotate, increase density, and lower temperature\n        vec3 dlmn = lmn - mid;\n\n        float axisAng = 0.75*iTimeN;\n        vec3 nvAxis = normalize( vec3(cos(axisAng),0.0,sin(axisAng)) );\n\n        mat3 mr = glRotate(nvAxis, 0.075*cos(iTimeN));\n        vec3 dlmnrot = mr * dlmn;\n        vec3 lmnrot = mid + dlmnrot;\n\n        float mamt = -0.0125;\n        vec3 next = mix(lmnrot, mid, mamt);\n\n        vec2 stOld = getDataInterp(next);\n        stNext = vec2( stOld.s*1.07, stOld.t*0.99 );\n    }\n\n    // Mouse input\n    //---------------------------------------\n    // Punch a hole along entry-exit axis, setting density 0 and temperature 1 (max)\n    vec4 entry = texelFetch(iChannel1, ivec2(0,0), 0);\n    vec4 exit = texelFetch(iChannel1, ivec2(1,0), 0);\n\n    if (entry.a > 0.5 && exit.a > 0.5) {\n        vec3 lmnEntry = BOX_N * entry.xyz;\n        vec3 lmnExit = BOX_N * exit.xyz;\n\n        float dHole = sdLine(lmnEntry, lmnExit, lmn);\n        stNext = mix(\n            vec2(0.0, 1.0),\n            stNext,\n            smoothstep(10.0, 16.0, dHole)\n        );\n    }\n    //---------------------------------------\n\n    fragColor = vec4(stNext, 0.0, 0.0);\n}\n\n// -----------------------------------------\n// Check if level surface at DENSITY_THRESH\n// -----------------------------------------\n\n// NOTE: These pixels refer to the voxel volumes,\n// not the corner points as in page 1.\n\nvoid doPage2(out vec4 fragColor, in vec3 lmn)\n{\n    vec2 data0 = getDataNearest(lmn);\n\n    float h000 = data0.s;\n    float h001 = getDataNearest( lmn + vec3(0.0, 0.0, 1.0) ).s;\n    float h010 = getDataNearest( lmn + vec3(0.0, 1.0, 0.0) ).s;\n    float h011 = getDataNearest( lmn + vec3(0.0, 1.0, 1.0) ).s;\n    float h100 = getDataNearest( lmn + vec3(1.0, 0.0, 0.0) ).s;\n    float h101 = getDataNearest( lmn + vec3(1.0, 0.0, 1.0) ).s;\n    float h110 = getDataNearest( lmn + vec3(1.0, 1.0, 0.0) ).s;\n    float h111 = getDataNearest( lmn + vec3(1.0, 1.0, 1.0) ).s;\n\n    // Check if at least one of the values is beyond threshold\n    float solid = (\n        step(DENSITY_THRESH, h000) + step(DENSITY_THRESH, h001) +\n        step(DENSITY_THRESH, h010) + step(DENSITY_THRESH, h011) +\n        step(DENSITY_THRESH, h100) + step(DENSITY_THRESH, h101) +\n        step(DENSITY_THRESH, h110) + step(DENSITY_THRESH, h111)\n    ) / 8.0;\n\n    // Also record the density/temp here, so it's not off by a frame\n    fragColor = vec4(data0, 0.0, solid);\n}\n\n// ---------------------------------------\n// Compute normals at voxel corner points\n// ---------------------------------------\n\n#define GD 2.0\n\nvoid doPage3(out vec4 fragColor, in vec3 lmn)\n{\n    // Compute normal\n    float hLA = getDataNearest( lmn + vec3(-GD,  0.0,  0.0) ).s;\n    float hLB = getDataNearest( lmn + vec3( GD,  0.0,  0.0) ).s;\n    float hMA = getDataNearest( lmn + vec3( 0.0, -GD,  0.0) ).s;\n    float hMB = getDataNearest( lmn + vec3( 0.0,  GD,  0.0) ).s;\n    float hNA = getDataNearest( lmn + vec3( 0.0,  0.0, -GD) ).s;\n    float hNB = getDataNearest( lmn + vec3( 0.0,  0.0,  GD) ).s;\n\n    vec3 gradA = vec3(hLB-hLA, hMB-hMA, hNB-hNA);\n    vec3 normal = 0.5 + 0.5*(-gradA/(length(gradA) + 1e-5));\n\n    fragColor = vec4(normal, 0.0);\n}\n\n// -------------------------------------\n// Determine what to do based on rayDir\n// -------------------------------------\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir)\n{\n    vec3 lmn;\n    int pageDst;\n    lmnFromVCube(rayDir, pageDst, lmn);\n\n    if (pageDst == 1) {\n        doPage1(fragColor, lmn);\n    } else if (pageDst == 2) {\n        doPage2(fragColor, lmn);\n    } else if (pageDst == 3) {\n        doPage3(fragColor, lmn);\n    }\n}\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FIXED_UP vec3(0.0, 1.0, 0.0)\n#define TAN_HALF_FOVY 0.5773502691896257\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\n#define BOX_MIN vec3(-1.0)\n#define BOX_MAX vec3(1.0)\n#define EPS 0.0001\n\n// ================\n// Generic helpers\n// ================\n\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, FIXED_UP));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid materialShader(\n    in float diffuseCoefficient,\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 diffuse,\n    out vec3 specular\n) {\n    float intensityDiffuse = clamp(dot(nvNormal, nvFragToLight), 0.0, 1.0);\n    intensityDiffuse *= diffuseCoefficient;\n\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float intensitySpecular = pow(clamp(dot(nvNormal, blinnH), 0.0, 1.0), specularExponent);\n    intensitySpecular *= specularCoefficient;\n\n    diffuse = intensityDiffuse * texColor * lightColor;\n    specular = intensitySpecular * lightColor;\n}\n\nvec3 colormapInferno(float t) {\n    return vec3(\n        1.0 - (t - 1.0)*(t - 1.0),\n        t*t,\n        t * (3.0*t - 2.0)*(3.0*t - 2.0)\n    );\n}\n\nvec3 skybox(vec3 nvDir) {\n    return texture(iChannel1, nvDir).rgb;\n}\n\n// ========================\n// Marching through voxels\n// ========================\n\nvoid boxClip(\n    in vec3 boxMin, in vec3 boxMax,\n    in vec3 p, in vec3 v,\n    out vec2 tRange, out float didHit\n){\n    //for each coord, clip tRange to only contain t-values for which p+t*v is in range\n    vec3 tb0 = (boxMin - p) / v;\n    vec3 tb1 = (boxMax - p) / v;\n    vec3 tmin = min(tb0, tb1);\n    vec3 tmax = max(tb0, tb1);\n\n    //t must be > tRange.s and each tmin, so > max of these; similar for t1\n    tRange = vec2(\n        max(max(tmin.x, tmin.y), tmin.z),\n        min(min(tmax.x, tmax.y), tmax.z)\n    );\n\n    //determine whether ray intersects the box\n    didHit = step(tRange.s, tRange.t);\n}\n\nvec3 lmnFromWorldPos(vec3 p) {\n    vec3 uvw = (p - BOX_MIN) / (BOX_MAX - BOX_MIN);\n    return floor(uvw * vec3(BOX_N));\n}\n\nvoid readLMN(in vec3 lmn, out vec2 st, out vec3 n) {\n    st = texture(iChannel0, vcubeFromLMN(2, lmn)).st;\n    n = 2.0 * (texture(iChannel0, vcubeFromLMN(3, lmn)).xyz - 0.5);\n}\n\nvoid boxFromLMN(in vec3 lmn, out vec3 boxMin, out vec3 boxMax) {\n    vec3 boxSize = (BOX_MAX - BOX_MIN) / BOX_N;\n\n    boxMin = BOX_MIN + (floor(lmn)/BOX_N) * (BOX_MAX - BOX_MIN);\n    boxMax = boxMin + boxSize;\n}\n\n// Interpolate normal, density, and temperature in voxel volume\nvoid hitVoxel(\n    in vec3 lmn,\n    in vec3 pVoxelIn, in vec3 pVoxelOut, in vec3 voxelBoxMin, in vec3 voxelBoxMax,\n    out vec3 pHit, out vec3 nvHit, out vec2 stHit, out bool didHit\n) {\n    vec3  n000,  n001,  n010,  n011,  n100,  n101,  n110,  n111;\n    vec2 st000, st001, st010, st011, st100, st101, st110, st111;\n\n    readLMN(lmn, st000, n000);\n    readLMN(lmn + vec3(0.0, 0.0, 1.0), st001, n001);\n    readLMN(lmn + vec3(0.0, 1.0, 0.0), st010, n010);\n    readLMN(lmn + vec3(0.0, 1.0, 1.0), st011, n011);\n    readLMN(lmn + vec3(1.0, 0.0, 0.0), st100, n100);\n    readLMN(lmn + vec3(1.0, 0.0, 1.0), st101, n101);\n    readLMN(lmn + vec3(1.0, 1.0, 0.0), st110, n110);\n    readLMN(lmn + vec3(1.0, 1.0, 1.0), st111, n111);\n\n    vec3 nc000 = n000;\n    vec3 nc001 = n001 - n000;\n    vec3 nc010 = n010 - n000;\n    vec3 nc100 = n100 - n000;\n    vec3 nc011 = n011 - n001 - n010 + n000;\n    vec3 nc101 = n101 - n001 - n100 + n000;\n    vec3 nc110 = n110 - n010 - n100 + n000;\n    vec3 nc111 = n111 - n011 - n101 - n110 + n001 + n010 + n100 - n000;\n\n    vec2 stc000 = st000;\n    vec2 stc001 = st001 - st000;\n    vec2 stc010 = st010 - st000;\n    vec2 stc100 = st100 - st000;\n    vec2 stc011 = st011 - st001 - st010 + st000;\n    vec2 stc101 = st101 - st001 - st100 + st000;\n    vec2 stc110 = st110 - st010 - st100 + st000;\n    vec2 stc111 = st111 - st011 - st101 - st110 + st001 + st010 + st100 - st000;\n\n    vec3 tb0 = (pVoxelIn - voxelBoxMin) / (voxelBoxMax - voxelBoxMin);\n    vec3 in0  =  nc000 + tb0.z* nc001 + tb0.y*( nc010 + tb0.z* nc011) + tb0.x*( nc100 + tb0.z* nc101 + tb0.y*( nc110 + tb0.z* nc111));\n    vec2 ist0 = stc000 + tb0.z*stc001 + tb0.y*(stc010 + tb0.z*stc011) + tb0.x*(stc100 + tb0.z*stc101 + tb0.y*(stc110 + tb0.z*stc111));\n\n    vec3 tb1 = (pVoxelOut - voxelBoxMin) / (voxelBoxMax - voxelBoxMin);\n    vec3 in1  =  nc000 + tb1.z* nc001 + tb1.y*( nc010 + tb1.z* nc011) + tb1.x*( nc100 + tb1.z* nc101 + tb1.y*( nc110 + tb1.z* nc111));\n    vec2 ist1 = stc000 + tb1.z*stc001 + tb1.y*(stc010 + tb1.z*stc011) + tb1.x*(stc100 + tb1.z*stc101 + tb1.y*(stc110 + tb1.z*stc111));\n\n    float th = (DENSITY_THRESH - ist0.s) / (ist1.s - ist0.s);\n    didHit = th > 0.0 && th < 1.0;\n    pHit = mix(pVoxelIn, pVoxelOut, th);\n    nvHit = normalize(mix(in0, in1, th));\n    stHit = mix(ist0, ist1, th);\n}\n\nvoid march(in vec3 p, in vec3 nv, out vec4 color) {\n    vec2 tRange;\n    float didHitBox;\n    boxClip(BOX_MIN, BOX_MAX, p, nv, tRange, didHitBox);\n\n    color = vec4(0.0);\n    if (didHitBox < 0.5) {\n        return;\n    }\n\n    float t = tRange.s;\n    for (int i=0; i<500; i++) {\n        // Get voxel data\n        vec3 worldPos = p + (t+EPS)*nv;\n        vec3 lmn = lmnFromWorldPos(worldPos);\n\n        vec3 curBoxMin, curBoxMax;\n        boxFromLMN(lmn, curBoxMin, curBoxMax);\n\n        vec2 curTRange;\n        float curDidHit;\n        boxClip(curBoxMin, curBoxMax, p, nv, curTRange, curDidHit);\n\n        // Quick lookup to see if the surface intersects this voxel\n        float isSolid = texture(iChannel0, vcubeFromLMN(2, lmn)).w;\n        if (isSolid > 0.0) {\n            // It does, so hit interpolated surface inside the voxel\n            vec3 pVoxelIn  = p + curTRange.s * nv;\n            vec3 pVoxelOut = p + curTRange.t * nv;\n\n            vec3 pHit;\n            vec3 nvHit;\n            vec2 stHit;\n            bool didHitSurf;\n            hitVoxel(\n                lmn,\n                pVoxelIn, pVoxelOut, curBoxMin, curBoxMax,\n                pHit, nvHit, stHit, didHitSurf\n            );\n\n            // Hit surface, so determine color and quit\n            if (didHitSurf) {\n                vec3 lightPos = p + vec3(0.0, 1.0, 0.0);\n                vec3 nvFragToLight = normalize(lightPos - pHit);\n                vec3 nvFragToCam = normalize(p - pHit);\n\n                vec3 matColor = colormapInferno(stHit.t);\n                vec3 lightColor = vec3(1.0);\n\n                vec3 diffuse;\n                vec3 specular;\n                materialShader(\n                    1.0-stHit.t, 1.0-stHit.t, 60.0,\n                    lightColor, matColor, nvHit,\n                    nvFragToLight,\n                    nvFragToCam,\n                    diffuse, specular\n                );\n                vec3 ambient = stHit.t * matColor;\n\n                vec3 vRefl = reflect(-nvFragToCam, nvHit);\n                vec3 cRefl = skybox(vRefl);\n\n                vec3 colorFinal = mix(diffuse+ambient, cRefl, 0.75*(1.0-stHit.t)) + specular;\n\n                color = vec4(clamp(colorFinal, 0.0, 1.0), 1.0);\n                break;\n            }\n        }\n\n        // Move up to next voxel\n        t = curTRange.t;\n        if (t+EPS > tRange.t) { break; }\n    }\n}\n\n// =============\n// Render scene\n// =============\n\nvoid sceneCamera(in vec2 fragCoord, out vec3 camPos, out vec3 nvCamDir) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec2 sphPos = vec2(0.1*iTime, 0.5*3.14159);\n    camPos = 2.0 * (\n        sin(sphPos.y) * vec3(cos(2.0*sphPos.x), 0.0, sin(2.0*sphPos.x)) +\n        cos(sphPos.y) * vec3(0.0, 1.0, 0.0)\n    );\n    vec3 lookTarget = vec3(0.0);\n\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n    mat4 clipToWorld = getClipToWorld(iResolution.x/iResolution.y, nvCamFw);\n\n    vec4 vWorld = clipToWorld * vec4(uv*2.0 - 1.0, 1.0, 1.0);\n    nvCamDir = normalize(vWorld.xyz / vWorld.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 camPos;\n    vec3 nvCamDir;\n    sceneCamera(fragCoord, camPos, nvCamDir);\n\n    vec3 bgColor = skybox(nvCamDir);\n\n    vec4 objColor;\n    march(camPos, nvCamDir, objColor);\n    vec3 finalColor = objColor.rgb + (1.0 - objColor.a)*bgColor;\n\n    fragColor = vec4(finalColor, 1.0);\n\n    // Mouse input\n    // For load/store cf. https://www.shadertoy.com/view/MddGzf\n    //---------------------------------------\n    ivec2 ipx = ivec2(fragCoord - 0.5);\n\n    bool storeEntry = ipx == ivec2(0,0);\n    bool storeExit = ipx == ivec2(1,0);\n\n    if (storeEntry || storeExit) {\n        vec4 entry = vec4(0.0);\n        vec4 exit = vec4(0.0);\n\n        vec2 mouseXY;\n        if (iMouse.z > 0.0) {\n            mouseXY = iMouse.xy;\n        } else {\n            float radius = 0.25*min(iResolution.x,iResolution.y);\n            mouseXY = 0.5*iResolution.xy + radius*vec2(cos(2.0*iTime), sin(2.0*iTime));\n        }\n\n        vec3 camPosMouse;\n        vec3 nvCamDirMouse;\n        sceneCamera(mouseXY, camPosMouse, nvCamDirMouse);\n\n        vec2 tRange;\n        float didHitBox;\n        boxClip(BOX_MIN, BOX_MAX, camPosMouse, nvCamDirMouse, tRange, didHitBox);\n\n        if (didHitBox > 0.5) {\n            vec3 pEntry = camPosMouse + tRange.s*nvCamDirMouse;\n            vec3 lmnEntry = lmnFromWorldPos(pEntry);\n            entry = vec4(lmnEntry / BOX_N, 1.0);\n\n            vec3 pExit = camPosMouse + tRange.t*nvCamDirMouse;\n            vec3 lmnExit = lmnFromWorldPos(pExit);\n            exit = vec4(lmnExit / BOX_N, 1.0);\n        }\n\n        if (storeEntry) {\n            fragColor = entry;\n        } else if (storeExit) {\n            fragColor = exit;\n        }\n    }\n    //---------------------------------------\n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 147]], "test": "untested"}
{"id": "WtVSWV", "name": "Final Project of Graphics -- YR", "author": "Yaorui", "description": "Final Project of Graphics", "tags": ["yr"], "likes": 2, "viewed": 267, "published": 3, "date": "1583627052", "time_retrieved": "2024-07-30T21:19:58.573630", "image_code": "#define BALLNUM 3\nconst int numberOfSampling = 10;\n\nvec4 LoadCap(int ind)\n{\n    float fi = float(ind) + 3. * txSize;\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvec4 LoadParticle (int ind)\n{\n  float fi = float(ind);\n  //return texelFetch(iChannel2, ivec2(mod(fi, txRow), floor(fi / txRow)), 0);\n  return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvec3 bgColor(const ray r){\n    float theta = atan(r.dir.z, r.dir.x);\n    float phi = asin(r.dir.y/length(r.dir));\n    \n    vec2 p = vec2(theta/2., phi);\n    \n    float octaves = 8.;\n    float H = 1.;\n    float f = 0.5 + 0.5 * snoise(p);\n    \n    f = fractalSum(p, 2., H, octaves);\n    \n    float marble = 0.5 * sin(50. * p.y + 145.*f + iTime * 0.5) + 0.5;\n    \n    return mix(vec3(0.9), mix(vec3(0.3, 0.5, 1.0), vec3(0.0, 0.3, 1.0), (phi+M_PI/2.)/M_PI), marble);\n}\n\nhit hitSphere(const ray r, const sphere s){\n    vec3 o2o = r.ori - s.ori;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(o2o, r.dir);\n    float c = dot(o2o, o2o) - s.r*s.r;\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n            // no solution, return dummy\n        return  dummyHit;\n    }\n    else {\n        float sqrtDelta = sqrt(delta);\n        float t;\n        float temp = (-b-sqrtDelta)/(2.*a);\n        if(temp > minT){t = temp;}\n        else {t = (-b+sqrtDelta)/(2.*a);}\n        if(t < minT)return dummyHit;\n        vec3 hitP = r.ori + t*r.dir;\n        return hit(t, hitP, (hitP-s.ori)/s.r, s.mat);\n    }\n}\n\n\nhit hitCylinder(const ray r,cylinder cld){\n    vec3 o2o = r.ori - cld.ori;\n    float a = dot(r.dir.yz, r.dir.yz);\n    float b = 2.0 * dot(o2o.yz, r.dir.yz);\n    float c = dot(o2o.yz, o2o.yz) - cld.r*cld.r;\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n        return  dummyHit;\n    }\n    else {\n        float sqrtDelta = sqrt(delta);\n        float t;\n        float temp = (-b-sqrtDelta)/(2.*a);\n        if(temp > 0.01){t = temp;}\n        else {t = (-b+sqrtDelta)/(2.*a);}\n        if(t < 0.01)return dummyHit;\n        vec3 hitP = r.ori + t*r.dir;\n        return hit(t, hitP, normalize(vec3(0, (hitP-cld.ori).yz)), cld.mat);\n    }\n}\n\nhit hitCap(const ray r, const cap cp, int cId){\n    vec3 o2o = r.ori - cp.ori;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(o2o, r.dir);\n    float c = dot(o2o, o2o) - cp.r2*cp.r2;\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n            // no solution, return dummy\n        return  dummyHit;\n    }\n    else {\n        float sqrtDelta = sqrt(delta);\n        float t1 = (-b-sqrtDelta)/(2.*a);\n        float t2 = (-b+sqrtDelta)/(2.*a);\n        \n        if(t2 < minT){\n            return dummyHit;\n        }\n        \n        float dirCos = dot(cp.norm,r.dir)/ length(r.dir);\n        float sOri2Plane = sqrt(cp.r2*cp.r2 - cp.r1*cp.r1);\n        float rOri2Plane = dot(r.ori - cp.ori, cp.norm) - sOri2Plane;\n        \n        hit hit1 = dummyHit;\n        if(rOri2Plane < 0. && dirCos > 0. || rOri2Plane > 0. && dirCos < 0.){\n            float t =  rOri2Plane/dirCos /length(r.dir);\n            t = abs(t);\n            vec3 hitP = r.ori + t* r.dir;\n            vec3 center = cp.ori + cp.norm * sOri2Plane;\n            vec2 uv = (hitP.xy - center.xy + vec2(cp.r1))/cp.r1/2.*vec2(iResolution.y);\n            if(t > minT && length(hitP - (cp.ori + sOri2Plane * cp.norm)) < cp.r1){\n                hit1 = hit(t, hitP, -cp.norm, cp.mat);\n                vec4 col = texture (iChannel3, getUvForCap(iResolution.xy, uv, cId));\n                if(col.r * col.a > 0.2){\n                    if(cId == 0){\n                        hit1.mat = material(LAMBERTIAN,col.a * vec3(1.0,0.7,0.0), 0.);\n                    }else if(cId == 1){\n                        hit1.mat = material(LAMBERTIAN,col.a * vec3(0.1,0.3,0.8), 0.);\n                    }\n                    else if(cId == 2){\n                        hit1.mat = material(LAMBERTIAN,col.a * vec3(0.9,0.3,0.3), 0.);\n                    }\n                }\n            }\n        }\n        \n        if(t1 > minT){\n            vec3 hitP = r.ori + t1*r.dir;\n            float dist2Plane = dot(hitP - cp.ori, cp.norm) - sOri2Plane;\n            if(dist2Plane > 0.){\n                if(hit1.t > -1. && hit1.t < t1)\n                    return hit1;\n                else \n                    return hit(t1, hitP, (hitP-cp.ori)/cp.r2, cp.mat);\n            }       \n            if(hit1.t > -1.)\n                return hit1;\n        }\n\n        vec3 hitP = r.ori + t2*r.dir;\n        float dist2Plane = dot(hitP - cp.ori, cp.norm) - sOri2Plane;\n        if(dist2Plane > 0.){\n            if(hit1.t > -1. && hit1.t < t2)\n                return hit1;\n            else \n                return hit(t2, hitP, (hitP-cp.ori)/cp.r2, cp.mat);\n        }\n        if(hit1.t > -1.)\n            return hit1; \n        return dummyHit;\n    }\n}\n\nvec3 color(ray r, cap[BALLNUM] cp, cylinder cld){\n    vec3 col = vec3(1);\n    int depth = 8;\n    while(depth != 0){\n            hit h = dummyHit;\n        for(int i = 0; i < cp.length(); i++){\n                hit tempH = hitCap(r, cp[i], i);\n            if(tempH.t > 0. && (h.t < 0. || h.t > tempH.t)){\n                    float newSeed = g_seed * float(depth);\n                h = tempH;\n                //if(h.t > minT && dot(h.normal, r.dir) > 0.)col *= vec3(1.0, 0, 0);\n            }\n        }\n        \n        hit tempH = hitCylinder(r, cld);\n        if(tempH.t > 0. && (h.t < 0. || h.t > tempH.t)){\n            float newSeed = g_seed * float(depth);\n            h = tempH;\n        }\n                \n        if(h.t > 0.){\n               vec3 scatter = r.dir;\n           float newSeed = g_seed * float(depth); // This would give the result a constant look\n            //float newSeed = g_seed * iTime; // This would give the result a changing look\n           if(h.mat.type == LAMBERTIAN){\n                   scatter = normalize(h.normal) + normalize(random_in_unit_sphere(newSeed));\n               col *= h.mat.albedo;\n            }\n            else if(h.mat.type == METAL){\n                   vec3 reflectDir = reflect(normalize(r.dir), normalize(h.normal));\n               reflectDir =normalize(reflectDir)+ h.mat.roughness * normalize(random_in_unit_sphere(newSeed));\n               if(dot(reflectDir, h.normal) < 0.){\n                       col = vec3(0);\n                   break;\n                }\n               else{\n                   col *= h.mat.albedo;\n                   scatter = reflectDir;\n               }\n            }\n            else if(h.mat.type == DIELECTRIC){\n                    vec3 outNorm;\n                float ni2nt;  \n                float cosine;\n                if(dot(r.dir, h.normal) > 0.){\n                        //col = vec3(1000,0,0);\n                    outNorm = -h.normal;\n                    ni2nt = h.mat.roughness;\n                    cosine = ni2nt * dot(normalize(r.dir), normalize(h.normal));\n                    \n                }\n                else{\n                        outNorm = h.normal;\n                    ni2nt = 1.0/h.mat.roughness;\n                    cosine = -dot(normalize(r.dir), normalize(h.normal));\n                }\n                vec3 reflectDir = reflect(normalize(r.dir), normalize(h.normal));\n                vec3 refractDir = refract(normalize(r.dir), normalize(outNorm),ni2nt);\n                float reflectProb = 0.;               \n                if(length(refractDir) > 0.0001){\n                        reflectProb = schlick(cosine, ni2nt);\n                }\n                else{\n                        reflectProb = 1.;\n                }\n                if(rand1(newSeed) > reflectProb){\n                        //if(dot(refractDir, h.normal)<0.)col*=vec3(1, 0, 0);\n                    scatter = refractDir;\n                }\n                else{\n                        scatter = reflectDir;\n                }\n            }\n            r = ray(h.p, scatter);\n            depth--;\n        }\n        else {\n                col *= bgColor(r);\n            break;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;       \n    camera c = getCamera(ic, iResolution.xy);\n    \n    cp[0] = cap(LoadCap(0).xyz, .5, 5., vec3(0, 0, 1), material(DIELECTRIC,vec3(1), 1.5));\n    cp[1] = cap(LoadCap(1).xyz, .5, 5., vec3(0, 0, 1), material(DIELECTRIC,vec3(1), 1.5));\n    cp[2] = cap(LoadCap(2).xyz, .5, 5., vec3(0, 0, 1), material(DIELECTRIC,vec3(1), 1.5));\n    \n    cylinder cld = cylinder(vec3(0, 0, 4), 0.05, material(METAL,vec3(0.8), 0.8));\n    \n    // Here I use i to get differnet seeds for each run\n    \n    \n    vec3 resultCol = vec3(0);\n    for(int i = 0; i < numberOfSampling; i++){\n        // Here I use i to get differnet seeds for each run\n        init_rand(fragCoord, float(i));\n        vec2 random = rand2(g_seed);\n        ray r = getRay(c, uv + random/iResolution.xy);\n        resultCol += color(r, cp, cld)/ float(numberOfSampling);\n    }\n    \n    fragColor = vec4(pow(resultCol,vec3(1.0/2.2)), 1.0);\n    //fragColor = texture (iChannel1, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n#define M_PI 3.1415925585\n\n#define CAPNUM 3\n\n\nconst float minT = 0.0001;\nconst float maxT = 1e8;\n\n// a Better camera structure\nstruct iCamera{\n    vec3 lookFrom;\n    vec3 lookAt;\n    vec3 up;\n    float fov;\n    float aperture;\n};\n    \nstruct camera{\n    vec3 origin;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 LowerLeftCorner;\n    float focusDist;\n    float aperture;\n};\n    \ncamera getCamera(iCamera ic, vec2 iResolution){\n    vec3 lookDir = ic.lookFrom-ic.lookAt;\n    float focusDist = length(lookDir);\n    lookDir = normalize(lookDir);\n    vec3 horizontal = normalize(cross(ic.up, lookDir));\n    vec3 vertical = normalize(cross(lookDir, horizontal));\n    float halfHeight = tan(ic.fov*M_PI/360.);\n    float halfWidth = halfHeight * iResolution.x / iResolution.y;\n    vec3 lowerLeftCorner = ic.lookFrom - halfWidth*horizontal*focusDist - halfHeight*vertical*focusDist - lookDir*focusDist;\n    horizontal *= 2. * halfWidth;\n    vertical *= 2. * halfHeight;\n    camera c = camera(ic.lookFrom, horizontal, vertical, lowerLeftCorner, focusDist, ic.aperture);\n    return c;\n}\n\nstruct ray{\n    vec3 ori;\n    vec3 dir;\n};\n    \nstruct material{\n        int type;\n    vec3 albedo;\n    float roughness;\n};\n\n\nstruct sphere{\n    vec3 ori;\n    float r;\n    material mat;\n};\n    \nstruct cap{\n    vec3 ori; // the origin of the outer circle\n    float r1; // the radius of the inner circle\n    float r2; // the radius of the outer circle\n    vec3 norm; // the (normalized) normal of the plane\n    material mat;\n};\n    \nstruct cylinder{\n    vec3 ori;\n    float r;\n    material mat;\n};\n    \nstruct hit{\n    float t;\n    vec3 p;\n    vec3 normal;\n    material mat;\n};\n    \nconst material dummyMat = material(0, vec3(0), 0.);\nconst hit dummyHit = hit(-1.0, vec3(0), vec3(0), dummyMat);\n\n/*vec3 refract2(vec3 inDir, vec3 normDir, float ni2nt){\n        inDir = normalize(inDir);\n    normDir = normalize(normDir);\n    float dt = dot(inDir, normDir);\n    float discriminant = 1.-ni2nt*ni2nt*(1.-dt*dt);\n    if(discriminant > 0.){\n            return ni2nt * (inDir-normDir*dt) - normDir * sqrt(discriminant);\n    }\n    else\n        return vec3(0);\n}*/\n    \nfloat schlick(float cosine, float ni2nt){\n    float r0 = (1.-ni2nt)/(1.+ni2nt);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow(1.-cosine, 5.);\n}\n\niCamera ic = iCamera(vec3(0, 0, 40), vec3(0, 0, 0), vec3(0, 1, 0), 5., 0.0);\ncap cp[CAPNUM];\nbool capInit = false;\n\n/***************To get a random number************************/\n// Ray tracing in one weekend basecode for Dartmouth CS 77/177 \n// by Wojciech Jarosz, 2019\n// adapted from on https://www.shadertoy.com/view/XlycWh\n\n#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 5\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n    return r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n    return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nray getRay(camera c, vec2 uv){\n    vec2 random = c.aperture * random_in_unit_disk(g_seed);\n    vec3 offset = c.horizontal * random.x + c.vertical * random.y;\n    return ray(c.origin + offset, c.LowerLeftCorner + uv.x * c.horizontal * c.focusDist + uv.y * c.vertical* c.focusDist - c.origin - offset);\n}\n\n/*************************************************************/\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat fade(float t){\n    return 1. - smoothstep(0.0, 1.0, abs(t));\n}\n\n\n\nvec2 grad(vec2 cell){\n    float angle = radians(360. * hash12(cell));\n    return vec2(cos(angle), sin(angle));\n}\n         \nfloat bump(vec2 tt, vec2 p){\n    vec2 g = grad(p);\n    return  fade(tt.x) * fade(tt.y) * dot(g, tt);\n}\n\n// return a random value between -1 and 1\nfloat snoise(vec2 p){\n    vec2 cell = floor(p);\n    vec2 frac = p - cell;\n    float res = 0.;\n    res += bump(frac, cell);\n    res += bump(vec2(frac.x-1.,frac.y), cell+vec2(1, 0));\n    res += bump(vec2(frac.x, frac.y-1.), cell+vec2(0, 1));\n    res += bump(vec2(frac.x-1.,frac.y-1.), cell + vec2(1));\n    return res;\n}\n\n\nfloat fractalSum(vec2 p, float domainScale, float H, float octaves){\n    float result = 0.;\n    float valueScale = 1.;\n    float valueScaleInc = pow(domainScale, -H);\n    for(float octave = octaves; octave > 0.; --octave, p*=domainScale, valueScale*=valueScaleInc){\n        float n = snoise(p);\n        float fade = min(1., octave);\n        result += valueScale * n * fade;\n    }\n    result /= (1.0- pow(valueScaleInc, octaves))/(1.0 - valueScaleInc);\n    return 0.5 + 0.5 * result;\n}\n\n/****************************Particle**********************************/\n#define BUF_SIZE iChannelResolution[2].xy\n\nconst float txRow = 16.;\nconst float txSize = txRow * txRow / 2.;\n\nconst vec2 G = vec2(0., -16000.*9.8f); // external (gravitational) forces\nconst float REST_DENS = 1000.f; // rest density\nconst float GAS_CONST = 2000.f; // const for equation of state\nconst float H = 26.f; // kernel radius\nconst float HSQ = H*H; // radius^2 for optimization\nconst float MASS = 65.f; // assume all particles have the same mass\nconst float VISC = 250.f; // viscosity constant\nconst float DT = 0.0008f; // integration timestep\n\n// smoothing kernels defined in Müller and their gradients\nconst float POLY6 = 315.f/(65.f*M_PI*pow(H, 9.f));\nconst float SPIKY_GRAD = -45.f/(M_PI*pow(H, 6.f));\nconst float VISC_LAP = 45.f/(M_PI*pow(H, 6.f));\n\n// simulation parameters\nconst float EPS = H/2.; // boundary epsilon\nconst float BOUND_DAMPING = -0.5f;\n\nfloat r;\nvec2 center;\n\nstruct Particle {\n    vec2 x;\n    vec2 v;\n    vec2 f;\n    float p; // pressure\n    float rho; // rho (density)\n};\n\nvec2 getUvForCap(vec2 iResolution, vec2 uv, int cId){\n    float stepSize  = iResolution.x / 3.;\n    return vec2(stepSize * float(cId) + uv.x/3., uv.y)/iResolution.xy;\n}\n/***********************************************************************/", "buffer_a_code": "// Store rho and p\nvec4 Init(int mId, int cId){\n   return vec4(0.);\n}\n\nParticle p = Particle(vec2(0), vec2(0), vec2(0), 0., 0.);\n\nvec4 LoadParticle(int ind, int cId)\n{\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvoid ComputeDensityPressure(int id, int cId)\n{\n    p.rho = 0.f;\n    for(int j = 0; j < int(txSize); j++)\n    {\n        vec4 jXV = LoadParticle(j, cId);\n        if(jXV.x < .0)continue;\n        vec2 rij = jXV.xy - p.x;\n        float r2 = dot(rij, rij);\n        if(r2 < HSQ)\n        {\n            // this computation is symmetric\n            p.rho += MASS*POLY6*pow(HSQ-r2, 3.f);\n        }\n    }\n    p.p = GAS_CONST*(p.rho - REST_DENS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int mId;\n    vec2 kv = floor(fragCoord);\n    mId = int(kv.x + txRow * kv.y);\n    if (kv.x >= txRow || float(mId) > txSize * 3.) discard;\n    int cId = mId/ int(txSize);\n    mId = mId - cId * int(txSize);\n    vec4 col;\n    if(iFrame < 5){\n        col = Init(mId, cId);\n    }\n    else {\n        p.x = LoadParticle(mId, cId).xy;\n        p.v = LoadParticle(mId, cId).ba;\n        ComputeDensityPressure(mId, cId);\n        col = vec4(p.f, p.rho, p.p);\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Store f\nvec4 Init(int mId, int cId){\n   return vec4(0.);\n}\n\nParticle p = Particle(vec2(0), vec2(0), vec2(0), 0., 0.);\n\nvec4 LoadParticle(int ind, int cId)\n{\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvec4 LoadOther(int ind, int cId){\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n\nvoid ComputeForces(int mId, int cId)\n{\n    vec2 fpress = vec2(0);\n    vec2 fvisc = vec2(0);\n    //vec2 iOther = LoadOther(mId);\n    \n    for(int j = 0; j < int(txSize); j++)\n    {\n        if(mId == j)\n            continue;\n        \n        vec4 jXV = LoadParticle(j, cId);\n        if(jXV.x < .0)continue;\n        vec2 rij = jXV.xy - p.x;\n        float r = length(rij);\n\n        if(r < H)\n        {      \n            vec2 jOther = LoadOther(j, cId).ba; // Get rho and p of particle j\n            \n            // compute pressure force contribution\n            fpress += -normalize(rij)*MASS*(p.p + jOther.y)/(2.f *jOther.x) * SPIKY_GRAD*pow(H-r,2.);\n            // compute viscosity force contribution\n            fvisc += VISC*MASS*(jXV.gb - p.v)/jOther.x * VISC_LAP*(H-r);\n        }\n    }\n    vec2 fgrav = G * p.rho;\n    p.f = fpress + fvisc + fgrav;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int mId;\n    vec2 kv = floor(fragCoord);\n    mId = int (kv.x + txRow * kv.y);\n    if (kv.x >= txRow || float(mId) > 3. * txSize) discard;\n    int cId = mId/int(txSize);\n    mId = mId - cId * int(txSize);\n    vec4 col;\n    if(iFrame < 5){\n        col = Init(mId, cId);\n    }\n    else {\n        p.x = LoadParticle(mId, cId).xy;\n        p.v = LoadParticle(mId, cId).ba;\n        //ComputeDensityPressure(mId);\n        p.rho = LoadOther(mId, cId).b;\n        p.p = LoadOther(mId, cId).a;\n        ComputeForces(mId, cId);\n        col = vec4(p.f, p.rho, p.p);\n    }\n    fragColor = col;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Reference： https://bigtheta.io/2017/07/08/implementing-sph-in-2d.html\nParticle p = Particle(vec2(0), vec2(0), vec2(0), 0., 0.);\n\nvec4 LoadParticle(int ind, int cId)\n{\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\n\nvec4 LoadOther(int ind, int cId){\n    float fi = float(cId) * txSize + float(ind);\n    return texture (iChannel1, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n\nvec4 LoadCap(int ind)\n{\n    float fi = float(ind) + 3. * txSize;\n    return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nhit hitCap(const ray r, const cap cp){\n    vec3 o2o = r.ori - cp.ori;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(o2o, r.dir);\n    float c = dot(o2o, o2o) - cp.r2*cp.r2;\n    float delta = b*b - 4.0*a*c;\n    if(delta<0.0){\n        // no solution, return dummy\n        return  dummyHit;\n    }\n    else {\n        float sqrtDelta = sqrt(delta);\n        float t1 = (-b-sqrtDelta)/(2.*a);\n        float t2 = (-b+sqrtDelta)/(2.*a);\n        \n        if(t2 < minT){\n            return dummyHit;\n        }\n        \n        float dirCos = dot(cp.norm,r.dir)/ length(r.dir);\n        float sOri2Plane = sqrt(cp.r2*cp.r2 - cp.r1*cp.r1);\n        float rOri2Plane = dot(r.ori - cp.ori, cp.norm) - sOri2Plane;\n        \n        hit hit1 = dummyHit;\n        if(rOri2Plane < 0. && dirCos > 0. || rOri2Plane > 0. && dirCos < 0.){\n            float t =  rOri2Plane/dirCos /length(r.dir);\n            t = abs(t);\n            vec3 hitP = r.ori + t* r.dir;\n            if(t > minT && length(hitP - (cp.ori + sOri2Plane * cp.norm)) < cp.r1){\n                hit1 = hit(t, hitP, -cp.norm, cp.mat);\n            }\n        }\n        \n        if(t1 > minT){\n            vec3 hitP = r.ori + t1*r.dir;\n            float dist2Plane = dot(hitP - cp.ori, cp.norm) - sOri2Plane;\n            if(dist2Plane > 0.){\n                if(hit1.t > -1. && hit1.t < t1)\n                    return hit1;\n                else \n                    return hit(t1, hitP, (hitP-cp.ori)/cp.r2, cp.mat);\n            }       \n            if(hit1.t > -1.)\n                return hit1;\n        }\n\n        vec3 hitP = r.ori + t2*r.dir;\n        float dist2Plane = dot(hitP - cp.ori, cp.norm) - sOri2Plane;\n        if(dist2Plane > 0.){\n            if(hit1.t > -1. && hit1.t < t2)\n                return hit1;\n            else \n                return hit(t2, hitP, (hitP-cp.ori)/cp.r2, cp.mat);\n        }\n        if(hit1.t > -1.)\n            return hit1; \n        return dummyHit;\n    }\n}\n\nvec4 InitSPH(int mId, int cId)\n{\n    vec2 ptcStep = vec2(r) / txRow * 2.;\n    float x = ptcStep.x * mod(float(mId), txRow);\n    float y = ptcStep.y * floor(float(mId)/txRow);\n    init_rand(vec2(x, y), 2.); \n    x += (rand1(g_seed)-0.5) * ptcStep.x/2.;\n    if(dot(vec2(x, y) - center, vec2(x, y) - center) < r*r)\n    {\n        return vec4(x, y, 0, 0);\n    }\n    else return vec4(-1);\n}\n\nvoid Integrate(int mId, int cId)\n{\n    // forward Euler integration\n    vec4 other = LoadOther(mId, cId);\n    //p.v += DT*p.f/p.rho;\n    p.v += DT*other.xy/other.z + vec2(12000. * (-LoadCap(cId).a), 0.);\n    p.x += DT*p.v;\n    //p.x += other.x;\n    //p.x += 0.1;\n\n    //float offSet = LoadCap(cId).a;\n    //p.x.x -= 200. * offSet;\n    vec2 toCenter = p.x - center;\n    \n    if(dot(toCenter, toCenter) > (r - EPS)*(r - EPS)){\n        p.v = reflect(normalize(p.v), normalize(-toCenter)) * length(p.v)/2.;\n        p.x = center + normalize(toCenter) * (r - EPS);\n    }\n    \n    else{\n        vec4 col = texture (iChannel3, getUvForCap(iResolution.xy, p.x, cId));\n        if(col.a > 1.){\n            p.x -= DT*p.v; \n            p.v =  (p.v+ rand2(g_seed) * length(p.v)/5.) * BOUND_DAMPING ;\n            //p.v *= BOUND_DAMPING;\n        }\n        // Return to the original position, v inverse\n        // Not the right way to calculate bounce\n    }\n    \n    //p.x.x += offSet;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int mId;\n    vec2 kv = floor(fragCoord);\n    mId = int (kv.x + txRow * kv.y);\n    if (kv.x >= txRow) {\n        discard;\n    }\n    else if(float(mId) < 3. * txSize){\n        r = min(iResolution.x, iResolution.y)/2.;\n        center = vec2(r);\n        vec4 col;\n        int cId = mId / int(txSize);\n        mId = mId - cId * int(txSize);\n        if(iFrame < 5){\n            fragColor = InitSPH(mId, cId);\n        }\n        else {\n            p.x = LoadParticle(mId, cId).xy;\n            p.v = LoadParticle(mId, cId).ba;\n            Integrate(mId, cId);\n            fragColor = vec4(p.x, p.v);\n        }\n    }\n    else if(float(mId) < 3. * txSize + 3.){\n        // Recording position of caps   \n        int index = mId - 3 * int(txSize);\n        fragColor = LoadCap(index); \n\n        if(index == 0){\n            if(fragColor.r == 0.){\n                fragColor = vec4(-1,0, 1,0);\n            }\n        }\n        else if(index == 1){\n            if(fragColor.r == 0.){\n                fragColor = vec4(0, 0, 1,0);\n            }\n        }\n        else if(index == 2){\n            if(fragColor.r == 0.){\n                fragColor = vec4(1, 0, 1,0);\n            }\n        }\n        else return;\n\n        fragColor.a = 0.;// initialize speed\n        cap mCap = cap(fragColor.rgb, .5, 5., vec3(0, 0, 1), material(DIELECTRIC,vec3(1), 1.5));\n        int holding = -1;\n        camera c = getCamera(ic, iResolution.xy);\n\n        ray mouseRay = getRay(c, iMouse.xy/iResolution.xy);\n        hit h;\n        h = hitCap(mouseRay, mCap);\n        if(h.t > 0.){\n            if(index == 0){       \n                if(LoadCap(1).x-h.p.x > 1.){\n                    fragColor.a = h.p.x - fragColor.r;\n                    fragColor.r = h.p.x;\n                }\n            }\n            else if(index == 1){\n                if(LoadCap(2).x-h.p.x > 1. && \n                    (h.p.x - LoadCap(0).x)> 1.){\n                    fragColor.a = h.p.x - fragColor.r;\n                    fragColor.r = h.p.x;\n                }\n            }\n            else if(index == 2){\n                if(h.p.x - LoadCap(1).x > 1.){\n                    fragColor.a = h.p.x - fragColor.r;\n                    fragColor.r = h.p.x;\n                }\n            }\n        }\n        \n    }\n    else{\n        discard;\n    }\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Reference: https://www.shadertoy.com/view/4dG3RW\nvec4 LoadParticle (int ind, int cId)\n{\n  float fi = float(cId) * txSize + float(ind);\n  //return texelFetch(iChannel2, ivec2(mod(fi, txRow), floor(fi / txRow)), 0);\n  return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     BUF_SIZE);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    float dMin = 1000.;\n   \n    vec2 resizedUv = fragCoord;\n    float stepSize  = iResolution.x / 3.;\n    int cId = int(floor(fragCoord.x/stepSize));\n    resizedUv.x = mod(resizedUv.x, stepSize) * 3.;\n    \n    fragColor = texture(iChannel3, fragCoord/iResolution.xy);\n    \n    if(fragColor.a < 0.2){\n        // initialize\n        \n        vec2[3] origins;\n        origins[0] = vec2(iResolution.y)/2.; // head\n        origins[1] = origins[0]+ vec2(-32, 32); // left ear\n        origins[2] = origins[0] + vec2(32, 32); // right ear\n        \n        float[3] r;\n        r[0] = 36.; r[1] = 18.; r[2] = 18.;// head radius and ear radius \n        float edge = H/2.; // weight of edge\n        bool flag = false;\n        for(int i = 0; i < 3; i++){  \n            float p2ori = length(resizedUv - origins[i]);\n            if(p2ori < r[i] + edge){\n                flag = true;\n                if(p2ori < r[i]){\n                    fragColor = vec4(1.0, 1.0, 1.0, 2.);\n                    return;\n                }\n                else fragColor = vec4(0.0, 0.0, 0.0, 2.); \n            }\n        }\n        if(flag)return;\n    }\n    if(fragColor.a > 1.0){// in shape\n        return;\n    }\n    for (int n = 0; n < int(txSize); n++){\n        vec4 pPos = LoadParticle(n, cId);\n        if(pPos.x > 0.){\n            dMin = min (dMin, length (resizedUv - pPos.xy));\n        }\n    }\n    \n    vec4 col = dMin < H/2.? vec4(1., 0, 0, 1.): vec4(0, 0, 0, 0.2);\n        //vec3(dMin);//mix (vec3 (0.2),  vec3 (0., 1., 0.), 1. - smoothstep (0.4, 0.5, dMin));\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 75, 75, 218], [220, 220, 249, 249, 453], [455, 455, 481, 481, 919], [921, 921, 964, 964, 1552], [1555, 1555, 1597, 1597, 2191], [2193, 2193, 2240, 2240, 4853], [8039, 8039, 8096, 8146, 9144]], "test": "untested"}
{"id": "wtKSzd", "name": "Interactive Explorer (v.0)", "author": "quizcanners", "description": "Made a scene with FPS controls (WASD + Mouse + EQ (Up/Down)). \nWant to test RayCasts to make fast RayMarching for primitives.", "tags": ["raymarching", "template"], "likes": 7, "viewed": 336, "published": 3, "date": "1583626805", "time_retrieved": "2024-07-30T21:19:59.652744", "image_code": "// A better iteration of this shader: https://www.shadertoy.com/view/wdsyzM\n\n// I want to try out combining RayCast (Intersect) functions with RayMarching.\n// Red color shows how many steps were made before getting the color.\n// Also to add Camra Controls for exploring a raymarch shader. \n\n// Fork of \"RayMarching starting point\" by BigWIngs. https://shadertoy.com/view/WtGXDD\n// Camera Rotation:\t\t \t ssell      \t\t     https://www.shadertoy.com/view/XtXyW4\n// Ray Box intersection: \tyuchengzhong \t\t\t https://www.shadertoy.com/view/wtKXWV\n// Fish Eye:\t\t\t\tTDM\t\t\t\t\t\t https://www.shadertoy.com/view/XsfXWX\n// Also looking into this one: \t\t\t\t\t     https://www.shadertoy.com/view/tl23Rm\n// Shadows: Maarten \t\t\t\t\t\t\t\t https://www.shadertoy.com/view/4dfXDn\n\nvec4 loadValue( in ivec2 dataIndex )\n{\n    return texelFetch( iChannel0, dataIndex, 0 );\n}\n\nvec4 Volume(vec3 pos){\n\tfloat hmix;\n                 \n    vec4 bakeUV = SampleVolume(pos, GetVolumeHSlices(iResolution.y), hmix);\n             \n    return mix( texture(iChannel0, bakeUV.xy), texture(iChannel0, bakeUV.zw), hmix);\n}\n\nvec3 getFishEye(vec2 uv, float level) {\n    \n    float len = length(uv);\n    float a = len * level;\n    vec3 fishUV = vec3(uv / len * sin(a), cos(a));\n    \n    vec3 camForward = \t\tloadValue(CAM_FORWARD).xyz;\n    vec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0))); \n    vec3 camUp = normalize(cross(camRight, camForward));\n    \n    return (fishUV.x * camRight) + (fishUV.y * camUp) + (fishUV.z * camForward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cameraPosition = loadValue(CAM_POS_PRSST).xyz;\n\tvec3 rayDirection = getFishEye(uv,  1.5);\n    \n    vec2 rayCast = GetRaycastDist(cameraPosition, rayDirection);\n\n   // rayCast.x = 0.; // DEBUG\n    \n    vec3 col = vec3(0);\n    \n    if (rayCast.x<MAX_DIST){\n\n        float dist = max(0.,rayCast.x);\n        float steps;\n        \n        float mxDist = \n            //MAX_DIST;\n            rayCast.y;\n        \n        GetRayMarchDist(cameraPosition, rayDirection, mxDist, dist, steps);\n        \n        steps /= 30.; // DEBUG\n\n         if(dist<mxDist) {\n            vec3 hitPos = cameraPosition + rayDirection * dist;\n            vec3 n = GetNormal(hitPos, dist);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.6;\n            col += dif;  \n             \n            #ifdef DEBUG\n             col.r =  steps; \n            #endif\n             \n             vec3 safeHitPos = hitPos + n * 0.001*dist; // To start other calculations not trom inside the object\n             \n             float shadow = Shadow(safeHitPos, lightSource_0.xyz, SHADOW_RADIUS, lightSource_0.w);\n\n             vec4 baked = Volume(safeHitPos + n*VOLUME_SCALE * .3);\n             \n             col.rgb *= (shadow * lightSource_0_Color + baked.b * skyColor);\n             \n         \t\n             \n         } else {\n              col.rgb = \n             #ifdef DEBUG\n                 vec3(steps,0.,0.);\n             #else\n             \t SkyBox(rayDirection);\n             #endif\n         }\n\n        \n        //float remapped = sharpstep(0., 2., rayCast.y);\n      \t//col.rgb = vec3(0., remapped, remapped);\n        \n         col.rgb = max(vec3(0.), col.rgb);\n         col = pow(col, vec3(.4545));\t// gamma correction\n         vec3 mixed = col.gbr + col.brg;\n    \n    col.rgb += mixed*mixed *  .2;\n   } else {\n    \tcol.rgb = SkyBox(rayDirection); \n   }\n    \n   \n    // Volumetric lights \n    \n    const float VOL_STEPS = 10.;\n    \n    const float VOL_STEP_SIZE = 3. * VOLUME_SCALE/ VOL_STEPS;\n    \n    const float FOG_DENSITY = .25/VOL_STEPS;\n    \n    vec4 ambientLight = vec4(0., 0., 0., FOG_DENSITY);\n    \n    float volDist = VOL_STEP_SIZE;\n    \n    for (float i=0.; i<VOL_STEPS; i+=1.)\n    {\n    \tvec3 volumePosition = cameraPosition + rayDirection * volDist;\n        \n        vec3 volCol = Volume(volumePosition).rgb;\n        \n        float smoothAdd = smoothstep(rayCast.x, rayCast.x*0.7, volDist);\n       \n        float adding = FOG_DENSITY * smoothAdd;\n        \n        ambientLight.rgb += volCol * adding / ambientLight.a;\n      \n        ambientLight.a += adding;\n        \n        volDist += VOL_STEP_SIZE * (1. + i*i/VOL_STEPS); // volDist*1.6;\n        \n        i+= (1. - smoothAdd) * 100.;\n    }\n    \n    ambientLight.a = min(1., ambientLight.a);\n  \n    ambientLight.rgb =  \n        lightSource_0_Color.rgb *  (0.05 * lightSource_0.w * ambientLight.r) +\n        skyColor * ambientLight.b * 0.2\n        ;\n    \n    col.rgb = mix(col.rgb, ambientLight.rgb , ambientLight.a);\n  \n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// CONFIGS\n\n#define MAX_STEPS 25\n#define MAX_DIST 500.\n#define SURF_DIST .001\n//#define MARCH_VOLUME_SHADOW\n#define DEBUG\n\n//___ MOVEMENT\nconst float PLAYER_SPEED = .6;\nconst float PLAYER_RUN_SPEED = 1.;\nconst float MOUSE_SENSITIVITY = 3.;\nconst float PLAYER_SIZE = .1;\nconst float SLOWDOWN_RANGE = 5.;\n\n//__ RENDERING\nconst float  SHADOW_RADIUS = 8.;\n\nconst float VOLUME_SCALE = 10.;\nconst vec4 VOLUME_POSITION_N_SIZE = vec4(50., -20., 10., 1./VOLUME_SCALE); // w = 1/size\nconst float VOLUME_HEIGHT = 16.;\nconst float DE_VOL_HEIGHT = 1./VOLUME_HEIGHT;\n\nvec3 skyColor= vec3(.3,.3, .7);\nvec3 eqColor = vec3(.5,.4,.4);\nvec3 floorColor = vec3(.1,.3,.1);\n\nvec3 SkyBox(vec3 rayDirection)\n{\n    return  floorColor * max(0., -rayDirection.y)\n        +   eqColor * (1.-abs(rayDirection.y)) \n        +\tskyColor * (max(0., rayDirection.y));\n        \n    \n\t//return vec3(rayDirection.x*max(0.,rayDirection.y),rayDirection.y,.1);\n}\n\n\n// *************** PERSISTANCE\n\nconst ivec2 CAM_POS_PRSST       \t= ivec2(1, 1);\nconst ivec2 CAM_ROT_PRSST       \t= ivec2(3, 1);\nconst ivec2 CAM_MOUSE_PREV_PRSST    = ivec2(7, 1);\nconst ivec2 CAM_ROTATION_PRSST      = ivec2(9, 1);\nconst ivec2 CAM_FORWARD       \t\t= ivec2(11, 1);\nconst ivec2 GAME_STATE       \t\t= ivec2(13, 1);\n\nconst float PRSST_MAX_Y = 2.;\n\nbool inStoreArea( in ivec2 dataIndex, in ivec2 fragCoord)\n{\n  return ( dataIndex.x==fragCoord.x && dataIndex.y==fragCoord.y);\n}\n\nbool inStoreRange( in ivec2 dataIndex1, in ivec2 dataIndex2, in ivec2 fragCoord)\n{\n  return ( dataIndex1.x<=fragCoord.x && dataIndex1.y<=fragCoord.y && dataIndex2.x>=fragCoord.x && dataIndex2.y>=fragCoord.y);\n}\n\nvoid storeValue( in ivec2 dataIndex, in vec4 data, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = inStoreArea(dataIndex, fragCoord) ? data : fragColor;\n}\n\n// ************** MATH\n\nvec3 hash33(vec3 pos)\n{\n\tpos = fract(pos * vec3(.1234, .5678, .923));\n    pos += dot(pos, pos.yxz+23.45);\n    return fract((pos.xxy + pos.yxx)*pos.zyx);\n\n}\n\nfloat sharpstep(float a, float b, float x){\n    return (x-a)/(b-a);\n}\n\nvec2 Rot(vec2 uv, float angle){\n\tfloat si = sin(angle);\n\tfloat co = cos(angle);\n    return vec2(co * uv.x - si* uv.y, si * uv.x + co * uv.y);\n}\n\n// ************** VOLUME\n\n\n\nvec4 GetVolumeHSlices(float resolutionY)\n{\n  float sliceWidth = (resolutionY - VOLUME_HEIGHT * 2.) * DE_VOL_HEIGHT;       \n  return vec4(VOLUME_HEIGHT, sliceWidth* .5, 1./sliceWidth, DE_VOL_HEIGHT);\n}\n\nvec4 SampleVolume(vec3 worldPos, vec4 VOLUME_H_SLICES, out float hmix) {\n\n    vec4 outputUV = vec4(0.);\n    \n\tvec3 bsPos = (worldPos.xyz - VOLUME_POSITION_N_SIZE.xyz) * VOLUME_POSITION_N_SIZE.w;\n\n\tbsPos.xz = clamp((bsPos.xz + VOLUME_H_SLICES.y)* VOLUME_H_SLICES.z, 0., 1.)*VOLUME_H_SLICES.w;\n\tfloat h = min(max(0., bsPos.y), VOLUME_H_SLICES.x*VOLUME_H_SLICES.x - 1.);\n\n\tfloat sectorY = floor(h * VOLUME_H_SLICES.w);\n\tfloat sectorX = floor(h - sectorY * VOLUME_H_SLICES.x);\n\n    vec2 uv_low = vec2(sectorX, sectorY) * VOLUME_H_SLICES.w;\n    \n\tvec2 sector = clamp(uv_low, 0., 1.)+ bsPos.xz;\n\n    outputUV.xy = sector;\n\n\th += 1.;\n\n\tsectorY = floor(h * VOLUME_H_SLICES.w);\n\tsectorX = floor(h - sectorY * VOLUME_H_SLICES.x);\n\n\tsector = clamp(vec2(sectorX, sectorY)*VOLUME_H_SLICES.w, 0., 1.) + bsPos.xz;\n\n    outputUV.zw = sector;\n\n\thmix = fract(h); \n\n\treturn outputUV;\n}\n\n// **************  RAYMARCHING\n\n\nfloat smAdd(float d1, float d2, float smth)\n{\n\tfloat h = max(smth - abs(d1 - d2), 0.0) / (smth + 0.0001);\n\treturn min(d1, d2) - h * h*h*smth*(1.0 / 6.0);\n}\n\nfloat smMinus(float d1, float d2, float k) {\n\n\tfloat h = clamp((1. - (d2 + d1) / (k + 0.0001))*0.5, 0.,1.);\n\n\treturn mix(d1, -d2, h) + k * h * (1. - h);\n}\n\n// ****************** SHAPES\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p)-s; \n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat distToBox(in vec2 pos, in vec2 boxMin, in vec2 boxMax, in float expand)\n{\n    boxMin -= vec2(expand,expand);\n    boxMax += vec2(expand,expand);\n    float bMax = max(pos.x - boxMax.x, pos.y - boxMax.y);\n    float bMin = max(boxMin.x - pos.x, boxMin.y - pos.y);\n    return max(bMax, bMin);\n}\n\n\n// ****************** RAY CASTING\n\nfloat planeLineIntersect(vec3 o,vec3 d,vec3 pn,vec3 pp)\n{\n    return dot(pp-o,pn)/dot(d,pn);\n}\n\n// Box:             https://www.shadertoy.com/view/ld23DV\nvoid iBox( in vec3 ro, in vec3 m, in vec3 boxSize, inout vec2 nearestCast) \n{ \n    \n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\n    float isNear = step(tN, tF) * step(0., tF) * step(tN, nearestCast.x);\n\n    nearestCast = mix(nearestCast, vec2(tN, tF), isNear);\n}\n\nvoid IntersectSphere(vec3 rayOrigin, vec3 rayDirection, vec3 pos, float radius, inout vec2 nearestCast)\n{\n    float t = max(0.,dot(pos - rayOrigin, rayDirection));\n    vec3 p = rayOrigin + rayDirection * t;\n    float y = length(pos - p);\n    \n    float hit = step(y, radius);\n    \n    float x = sqrt(mix(1., radius * radius - y * y,  hit));\n\n    float isNearest = hit * step(t-x, nearestCast.x);\n\n    nearestCast = mix(nearestCast, vec2(t-x,t+x), isNearest);\n}\n\n\n// ***************** TEST SCENE\n\n\nconst int SPHERE_CNT = 7;\n\nvec4 lightSource_0 = vec4(70., 60., 100., 20.);\n\nvec3 lightSource_0_Color = vec3(.8, .8, .1);\n\nvec4[SPHERE_CNT] GetSpheres(){\n\tvec4  spheres[SPHERE_CNT];\n    spheres[0] = vec4(30.,\t80.,\t\t5., \t32.5);\n    spheres[1] = vec4(60.,\t15.,\t\t-29., \t17.);\n    spheres[2] = vec4(10.,\t0.,\t\t45., \t22.5);\n    spheres[3] = vec4(35.,\t0.,\t\t50., \t31.);\n    spheres[4] = vec4(60.,\t1.,\t\t65., \t9.);\n    spheres[5] = vec4(100.,\t15.,\t\t5., \t22.5);\n    spheres[6] = vec4(110.,\t45.,\t9., \t31.);\n    return spheres;\n}\n\nconst int BOX_CNT = 3;\n\nvec4[BOX_CNT] GetBoxes(){\n\tvec4  boxes[BOX_CNT];\n    boxes[0] = vec4(-28.,\t56.,\t5., \t38.5);\n    boxes[1] = vec4(100.,\t21.,\t39., \t25.);\n    boxes[2] = vec4(380.,\t-370.,\t15., \t360.);\n    \n    return boxes;\n}\n\nconst int TOTAL_SHAPE_VARIATION = 2;\nconst int TOTAL_SHAPES = SPHERE_CNT+BOX_CNT;\n\nvec2 GetRaycastDist(vec3 rayPos, vec3 rayDir)\n{\n   \t \n    vec2 nearestCast = vec2(MAX_DIST+1.,MAX_DIST+1.);\n    \n    // SPHERES\n    int raycastIndex = 0;\n    vec4  spheres[SPHERE_CNT] = GetSpheres();\n    \n    for(int i=0; i<SPHERE_CNT; i++)\n    {\n        vec4 s = spheres[i];\n        IntersectSphere(rayPos, rayDir, s.xyz , s.w, nearestCast);\n    }\n\n    // BOXES\n    vec4  boxes[BOX_CNT] = GetBoxes();\n    vec3 precalculateM = sign(rayDir)/max(abs(rayDir), 1e-8);\n    \n    for(int i=0; i<BOX_CNT; i++)\n    {\n        vec4 b = boxes[i];\n        iBox(rayPos - b.xyz, precalculateM, vec3(b.w,b.w,b.w), nearestCast);\n    }\n    \n    return nearestCast;\n}\n\n\nfloat GetDist(vec3 p) {\n    \n    vec4  spheres[SPHERE_CNT] = GetSpheres();\n    \n    float sphereDist = MAX_DIST; \n    \n    for(int i=0; i<SPHERE_CNT; i++)\n    {\n        vec4 s = spheres[i];\n        float dist = sdSphere(p - s.xyz, s.w);\n        sphereDist = \n            smAdd(sphereDist, dist, 1.);\n            min(dist, sphereDist);\n    }\n    \n   float gyr = sdGyroid(p, .7, 1., .01);\n    \n   sphereDist = smMinus(sphereDist, gyr, 0.4);\n \n    \n    vec4  boxes[BOX_CNT] = GetBoxes();\n    \n    for(int i=0; i<BOX_CNT; i++)\n    {\n       vec4 b = boxes[i];\n       float dist = sdBox(p - b.xyz, vec3(b.w,b.w,b.w));\n        \n       sphereDist = smAdd(sphereDist, dist, 10.);\n           min(dist, sphereDist);\n    }\n\n    return sphereDist;\n}\n\nvec3 GetNormal(vec3 p, float dist ) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat Shadow(vec3 p, vec3 pos, float radius, float lightPower)\n{\n\tvec3 rayDir = normalize(pos - p);\n\tfloat maxDist = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * maxDist;\n\t\n    float minStep = radius * 0.15;\n    \n\t// distance traveled\n\tfloat dt =minStep;\n\n    float sd = 0.;\n    \n    float fullShadow = 0.;\n    \n\tfor (float i = 0.; i < 32.; i+=1.)\n\t{\t\t\t\t\n\t\tsd = GetDist(p + rayDir * dt);\n\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(minStep, abs(sd));\n\t\t\n        fullShadow = step(sd, -radius);\n        \n        i+= (fullShadow + step(maxDist,dt))* 100.;\n\t}\n\n\tlf = clamp((lf*maxDist + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\n\treturn lf * lightPower / maxDist ;\n}\n\n\n\nvoid GetRayMarchDist(vec3 rayPos, vec3 rayDir, float maxDist, inout float dist, out float steps){\n    \n    steps = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayPos + rayDir*dist;\n        float dS = GetDist(p);\n        dist += dS;\n        #ifdef DEBUG\n        steps += 1.; // DEBUG\n        #endif\n        if(dist>maxDist || abs(dS)<SURF_DIST*(1.+dist))\n        { \n            break;\n        }\n    }\n   \n}\n\n\n\n", "buffer_a_code": "\n// This buffer handles camera movement\n// ASCII: https://www.ascii-code.com/\n\nconst float KEY_E            = 69.5 / 256.0;\nconst float KEY_Q            = 81.5 / 256.0;\nconst float KEY_W            = 87.5 / 256.0;\nconst float KEY_A            = 65.5 / 256.0;\nconst float KEY_S            = 83.5 / 256.0;\nconst float KEY_D            = 68.5 / 256.0;\nconst float KEY_LEFT         = 37.5 / 256.0;\nconst float KEY_UP           = 38.5 / 256.0;\nconst float KEY_RIGHT        = 39.5 / 256.0;\nconst float KEY_DOWN         = 40.5 / 256.0;\nconst float KEY_SHIFT        = 16.5 / 256.0;\nconst float KEY_SPACE \t     = 32.5 / 256.0;\n\nvec4 loadValue( in ivec2 dataIndex )\n{\n    return texelFetch( iChannel0, dataIndex, 0 );\n}\n\nvec3 volumeUVtoWorld(vec2 uv, vec4 VOLUME_H_SLICES) {\n\n\tfloat hy = floor(uv.y*VOLUME_H_SLICES.x);\n\tfloat hx = floor(uv.x*VOLUME_H_SLICES.x);\n\n\tvec2 xz = uv * VOLUME_H_SLICES.x;\n\n\txz.x -= hx;\n\txz.y -= hy;\n\n\txz = (xz*2. - 1.) *VOLUME_H_SLICES.y;\n\t\n\tfloat h = hy * VOLUME_H_SLICES.x + hx;\n\n\tvec3 bsPos = vec3(xz.x, h, xz.y) / VOLUME_POSITION_N_SIZE.w;\n\n\tvec3 worldPos = VOLUME_POSITION_N_SIZE.xyz + bsPos;\n\n\treturn worldPos;\n}\n\nvec4 Quat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    return normalize(vec4(axis * sin(angle), cos(angle)));\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + (q.w * t) + cross(q.xyz, t);\n}\n\nvec4 QxQ(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = (q1.w * q2.w) - dot(q1.xyz, q2.xyz);\n    res.xyz = (q1.w * q2.xyz) + (q2.w * q1.xyz) + cross(q1.xyz, q2.xyz);\n    return normalize(res);\n}\n\nvec2 GetMouseDelta()\n{\n        vec4 mousePrevious = loadValue( CAM_MOUSE_PREV_PRSST);\n        float downPrevious = mousePrevious.z; \n        float down = clamp(iMouse.z * 800., 0. , 1.);\n        return down * downPrevious *  (iMouse.xy/iResolution.xy-mousePrevious.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    if (fragCoord.y<=PRSST_MAX_Y) {\n        \n      fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        \n       ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n        \n       #define WRITE_INDEX(data) inStoreArea(data, ifragCoord)  \n       #define PRSST_RANGE(data1, data2) inStoreRange(data1, data2, ifragCoord)  \n        \n        \n        vec4 gameState = loadValue(GAME_STATE);\n        \n        if (gameState.x == 0.)\n        {\n        \n            if (WRITE_INDEX(CAM_FORWARD)){\n             \tfragColor = vec4(vec3(0.,0.,1.), 0.0);\n                return;\n            }\n            \n            if (WRITE_INDEX(GAME_STATE)){\n             \tfragColor = vec4(1., 0., 0. , 0.0);\n                return;\n            }\n            \n            if (WRITE_INDEX(CAM_ROTATION_PRSST))\n       \t\t{\n                fragColor = vec4(0., 0., 0., 1.0);\n                return;\n            }\n            \n            discard;\n        }\n        \n        // Camera persistance: \n        \n        if (WRITE_INDEX(CAM_FORWARD)) {\n            \n             vec4 lastQuat    = loadValue(CAM_ROTATION_PRSST);\n            vec2 mouseDelta  = GetMouseDelta() * MOUSE_SENSITIVITY;\n\n            vec3 forward = loadValue(CAM_FORWARD).xyz;\n            vec3 right   = normalize(cross(forward, vec3(0.,1.,0.)));\n            vec3 up      = normalize(cross(right, forward));\n\n            lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n            lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n            fragColor = lastQuat;\n            \n            fragColor = vec4(Rotate(lastQuat, vec3(0.,0.,1.)), 0.0);\n            \n       } else  if (WRITE_INDEX(CAM_ROTATION_PRSST)) {\n            \n            vec4 lastQuat    = loadValue(CAM_ROTATION_PRSST);\n            vec2 mouseDelta  = GetMouseDelta() * MOUSE_SENSITIVITY;\n\n            vec3 forward = loadValue(CAM_FORWARD).xyz;\n            vec3 right   = normalize(cross(forward, vec3(0.,1.,0.)));\n            vec3 up      = normalize(cross(right, forward));\n\n            lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n            lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n            fragColor = lastQuat;\n           \n       } else  if (WRITE_INDEX(CAM_MOUSE_PREV_PRSST)) {\n           \n           vec4 mousePrevious = loadValue( CAM_MOUSE_PREV_PRSST);\n           mousePrevious.xy = iMouse.xy/iResolution.xy;\n           mousePrevious.z = clamp(iMouse.z * 800., 0. , 1.);\n           fragColor = mousePrevious;\n           \n           \n       } else if (WRITE_INDEX(CAM_POS_PRSST)) {\n           \n \t\t\tvec4 camera = loadValue(CAM_POS_PRSST);\n  \n           \n             vec3 off;\n\n            off.x -=  texture( iChannel1, vec2(KEY_A,0)).x;\n            off.x +=  texture( iChannel1, vec2(KEY_D,0)).x;\n            off.z +=  texture( iChannel1, vec2(KEY_W,0)).x;\n            off.z -=  texture( iChannel1, vec2(KEY_S,0)).x;\n            off.y +=  texture( iChannel1, vec2(KEY_E,0)).x;\n            off.y -=  texture( iChannel1, vec2(KEY_Q,0)).x;\n\n            if (length(off)>0.0001){\n                \n                off = normalize(off);\n                \n                vec3 camForward = \tloadValue(CAM_FORWARD).xyz;\n    \t\t\tvec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0))); \n\n                vec3 add = camForward * off.z + camRight * off.x;\n             \n                float run = texture( iChannel1, vec2(KEY_SHIFT,0)).x;\n                \n                float dist = min(1., GetDist(camera.xyz) / SLOWDOWN_RANGE);\n                \n                camera.xyz += (vec3(add.x,0.,add.z) + vec3(0., 1., 0.) * off.y) * max(0.1, dist)  * mix(PLAYER_SPEED, PLAYER_RUN_SPEED, run);\n            \n                if (dist<PLAYER_SIZE)\n                {\n                    camera.xyz += GetNormal(camera.xyz, 1.) * (PLAYER_SIZE - dist);\n                }\n            }\n            \n            \n            fragColor = camera;\n       }\n    } else {\n\n        // Ambient Light Baking\n        \n        vec2 uv = fragCoord/iResolution.xy;\n \n        fragColor = texture(iChannel0, uv);\n                \n        vec3 pos = volumeUVtoWorld(uv, GetVolumeHSlices(iResolution.y));\n\n        vec3 randomDirection = normalize(hash33(pos + iTime));\n        \n        pos += randomDirection* VOLUME_SCALE * 0.5;\n        \n        float dist = GetDist(pos);\n        \n        if (dist<0.)\n            return;\n        \n        vec3 addColor = vec3(0.);\n        \n        // SKY LIGHT\n        \n        vec2 rayCast = GetRaycastDist(pos, randomDirection);\n        \n        if (rayCast.x + 1. > MAX_DIST) \n        {\n        \taddColor.b = 1.;  //SkyBox(randomDirection);\n        }\n        \n        // LIGHT POINT\n        \n        vec3 toLight = lightSource_0.xyz- pos;\n        float len = length(toLight);\n        \n        #ifdef MARCH_VOLUME_SHADOW\n        \tfloat visible =  Shadow(pos, lightSource_0.xyz, SHADOW_RADIUS, lightSource_0.w);\n        #else\n         \tvec2 lightPointRay = GetRaycastDist(pos, normalize(toLight));\n        \tfloat visible = step(0., dist) * step(length(toLight), lightPointRay.x + 0.01);\n        #endif\n        \n       \n        addColor.r += visible;\n      \n        \n        //addColor += lightSource_0_Color.rgb *  ( lightSource_0.w * visible * 1000. / (len*len + 1.));\n\n        // STORING\n        \n        fragColor.a += 1.;\n        \n        float newPortion = 1./ (fragColor.a);\n        \n        fragColor.a = min(50., fragColor.a);\n        \n        fragColor.rgb = mix(fragColor.rgb, addColor, newPortion);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[750, 750, 788, 788, 840], [842, 842, 864, 864, 1072], [1074, 1074, 1113, 1113, 1498]], "test": "untested"}
{"id": "3tKSWV", "name": "Hex Neon Love", "author": "tutmann", "description": "Mix of https://www.shadertoy.com/view/WdK3Dz and https://www.shadertoy.com/view/wtdSzX", "tags": ["2d", "bezier", "heart", "glow", "curve", "neon", "hexagonalgrid"], "likes": 49, "viewed": 1763, "published": 3, "date": "1583623088", "time_retrieved": "2024-07-30T21:20:00.553336", "image_code": "// This is a mix of:\n// https://www.shadertoy.com/view/WdK3Dz and https://www.shadertoy.com/view/wtdSzX\n\n\n#define POINT_COUNT 8\n\nvec2 points[POINT_COUNT];\nconst float speed = -0.5;\nconst float len = 0.25;\nconst float scale = 0.017;\nfloat intensity = 0.8;\nfloat radius = 0.03;\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n\n//http://mathworld.wolfram.com/HeartCurve.html\nvec2 getHeartPosition(float t){\n    return vec2(16.0 * sin(t) * sin(t) * sin(t),\n                -(13.0 * cos(t) - 5.0 * cos(2.0*t)\n                - 2.0 * cos(3.0*t) - cos(4.0*t)));\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nfloat getSegment(float t, vec2 pos, float offset){\n\tfor(int i = 0; i < POINT_COUNT; i++){\n        points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);\n    }\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat dist = 10000.0;\n    \n    for(int i = 0; i < POINT_COUNT-1; i++){\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));\n    }\n    return max(0.0, dist);\n}\n\n#define FLAT_TOP_HEXAGON\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 s = vec2(1.7320508, 1);\n#else\nconst vec2 s = vec2(1, 1.7320508);\n#endif\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453);\n}\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p)\n{    \n    p = abs(p);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    return max(dot(p, s*.5), p.y); // Hexagon.\n    #else\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    #endif    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p)\n{    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    \n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    #else\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    #endif\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 pos = centre - uv;\n    pos.y /= widthHeightRatio;\n    //Shift upwards to centre heart\n    pos.y += 0.03;\n    \n    \n    // Aspect correct screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling, translating, then converting it to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    float us = sin(iTime/5.0)*40.0+45.0;\n    vec2 ut = vec2(sin(iTime/2.), cos(iTime/3.0));\n    vec2 hp = u*us + ut;\n    vec4 h = getHex(hp);\n    float eDist = hex(h.xy); // Edge distance.\n    vec3 border = mix(vec3(1.), vec3(0), smoothstep(0., 0.06, eDist - .5 + .12));\n    vec2 hu = (h.zw*s - ut) / us;\n    pos = vec2(1,-1)*hu;    \n    \n\t\n    float t = iTime;\n    \n    //Get first segment\n    float dist = getSegment(t, pos, 0.0);\n    float glow = getGlow(dist, radius, intensity);\n    \n    vec3 col = vec3(0.0);\n    \n    //White core\n    col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Pink glow\n    col += glow * vec3(0.94,0.14,0.4);\n    \n    //Get second segment\n    dist = getSegment(t, pos, 3.4);\n    glow = getGlow(dist, radius, intensity);\n    \n    //White core\n    col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Blue glow\n    col += glow * vec3(0.2,0.6,1.0);\n        \n    //Tone mapping\n    col = 1.0 - exp(-col);\n\n    //Output to screen\n    fragColor = vec4(col*border,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 357, 406, 406, 1682], [1685, 1732, 1763, 1763, 1916], [1918, 1958, 2015, 2015, 2057], [2059, 2059, 2109, 2109, 2605], [2921, 2921, 2943, 2943, 3009], [3011, 3340, 3362, 3362, 3536], [3538, 4230, 4251, 4630, 5468], [5470, 5470, 5526, 5526, 7135]], "test": "untested"}
{"id": "ttGXDV", "name": "Actual Fluid", "author": "Txoka", "description": "Just a cool fluid.\nUse mouse to add color.", "tags": ["wave", "simulation", "fluid", "advection", "physics", "air", "pressure"], "likes": 10, "viewed": 615, "published": 3, "date": "1583608967", "time_retrieved": "2024-07-30T21:20:01.447945", "image_code": "//(function(){if(Effect.prototype.Paint.toString().length>1000){_Paint=Effect.prototype.Paint;} Effect.prototype.Paint = function(...args){for(var i=0; i<20;i++){_Paint.apply(this,args);}}})()\n\nvoid mainImage(out vec4 Q,in vec2 U){\n  \tQ=vec4(A(U));\n    //Q+=vec4(B(U).xy,A(U).w,0)*2.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float h=1.;\t//advection step size\nconst float dt=.25;\nconst float k=5e-3;\t//mouse fluid generation radius\n\t\t\t\t\t//(not actual radius)\n\n#define R iResolution.xy\n#define M iMouse\n\n#define A(u) texture(iChannel0,(u)/R)\n#define B(u) texture(iChannel1,(u)/R)\n\n#define colors vec3(sin(iTime),sin(iTime*1.6180),sin(iTime*2.7182))*0.5+0.5\n\nfloat dot2(vec2 k){return dot(k,k);}\n\n#define RK4 vec2 k1=B(U).xy,k2=B(U-0.5*h*k1).xy,k3=B(U-0.5*h*k2).xy,k4=B(U-h*k3).xy;\n#define V h*(k1+2.*(k2+k3)+k4)/6.;", "buffer_a_code": "void mainImage(out vec4 Q,in vec2 U){\n    RK4\n\tU-=V;\n    Q=A(U);\n    \n    Q.w-=dt*(B(U+vec2(1,0)).x-B(U-vec2(1,0)).x+B(U+vec2(0,1)).y-B(U-vec2(0,1)).y);\n\n    if(M.z>0.)\n        Q+=dt*vec4(colors,.2)*exp(-k*dot2(M.xy-U));\n    \n\tif(iFrame==0)\n        Q=vec4(3,0,0,.1)*exp(-k*dot2(U-.5*R.xy));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 Q,in vec2 U){\n    Q.zw=B(U).zw;\n    RK4\n    U-=V;\n    Q.xy=B(U).xy;\n\n    Q.xy-=dt*vec2(A(U+vec2(1,0)).w-A(U-vec2(1,0)).w,A(U+vec2(0,1)).w-A(U-vec2(0,1)).w);\n    \n    \n    if(M.z>0.){\n        if(all(equal(Q.zw,vec2(0)))||all(equal(Q.zw,M.xy)))\n        \tQ.xy+=.5*dt*vec2(\n        \t    sin(iTime*2.),\n        \t    cos(iTime*2.)\n        \t)*exp(-k*dot2(M.xy-U));\n        else\n            Q.xy+=.15*dt*(M.xy-Q.zw)*exp(-k*dot2(M.xy-U));\n    \tQ.zw=M.xy;\n    }else Q.zw=vec2(0);\n    \n\tif(iFrame==0)\n        Q.xy=vec2(0,1.)*exp(-k*dot2(U-R.xy*.5));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 231, 231, 286]], "test": "untested"}
{"id": "wtyXWV", "name": "Advection RK4+BFECC", "author": "Txoka", "description": "Fork of https://www.shadertoy.com/view/wt33z2\nJust the code for RK4+BFECC cleaned for better understanding.", "tags": ["advection", "rk4", "bfecc"], "likes": 8, "viewed": 661, "published": 3, "date": "1583603155", "time_retrieved": "2024-07-30T21:20:02.367486", "image_code": "void mainImage(out vec4 Q,in vec2 U){\n    Q = A(U);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float dt = 2.;\n\n#define R iResolution.xy\n\n#define _A(u) texture(iChannel0,(u)/R.xy)\n#define _B(u) texture(iChannel1,(u)/R.xy)\n#define _C(u) texture(iChannel2,(u)/R.xy)\n\n#define A(id) texelFetch(iChannel0,ivec2(id),0)\n#define B(id) texelFetch(iChannel1,ivec2(id),0)\n\n\nvec2 v(vec2 U, vec2 r){\n    vec2 uv = (U*2.-r)/r.y;\n    return vec2(-uv.y,uv.x)*6.;\n}\nvec2 RK4(vec2 U,vec2 r,float dt){\n\tvec2 k1 = v(U\t\t\t,r);\n    vec2 k2 = v(U-.5*k1*dt\t,r);\n    vec2 k3 = v(U-.5*k2*dt\t,r);\n    vec2 k4 = v(U-k3*dt\t\t,r);\n\treturn dt*(k1+2.*(k2+k3)+k4)/6.;\n}\nfloat init(vec2 U,vec2 r){\n\tvec2 uv = U/r.y;\n\tint X = int(18.*uv.x)%2;\n\tint Y = int(18.*uv.y)%2;\n\treturn float(X^Y);\n}", "buffer_a_code": "void mainImage(out vec4 Q,in vec2 U){\n    Q = _A(U - RK4(U,R,dt));\n    if(iFrame==0)Q = vec4(init(U,R));\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 Q,in vec2 U){\n    vec4 z = _A(U - RK4(U,R,-dt));\n    vec4 k = B(U);\n    Q=k+.5*(k-z);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 Q,in vec2 U){\n    Q = _A(U - RK4(U,R,dt));\n    if(iFrame==0)Q = vec4(init(U,R));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 53]], "test": "untested"}
{"id": "tlySDV", "name": "Not Day 79", "author": "jeyko", "description": "hm", "tags": ["mdtmjvm"], "likes": 83, "viewed": 3473, "published": 3, "date": "1583601981", "time_retrieved": "2024-07-30T21:20:03.224196", "image_code": "// Sorry I changed the shader, I just really don't like the one original day 79.\n// I've commented the old one if you would like to see it.\n\n// So this is actually Day 110\n\n#define tsp iTime + 1.1\n\n\n#define pmod(p,z) mod(p,z) - 0.5*z\n#define dmin(a,b) a.x < b.x ? a : b\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nvec3 glow = vec3(0);\n\nvec3 path (float z){\n    z *= 0.29;\n\treturn vec3(0. + sin(z),0. + cos(z),0.)*1.;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.y, max(p.z,p.x));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e7);\n    \n    vec3 k = p;\n    p -= path(p.z);\n    \n    \n    p.z *= 0.5;\n    \n    \n    vec3 par = vec3(2.8,2.14,0.9);\n    vec4 q = vec4(p.xyz, 1.);\n    \n    \n    for(float i = 0.; i < 9.;i++){\n        q.xyz = abs(mod(q.xyz - par*0.5,par) - 0.5*par);\n        \n    \tfloat dpp = dot(q.xyz, q.xyz);\n        \n        q.xy *= rot(0.4);\n        q = q/dpp;\n    }\n    \n    float dF = length(q.xz)/q.w;\n    d.x = min(d.x, dF);\n    \n    d.x = opSmoothIntersection( d.x, -length(p.xy) + 0.36 , 0.4 );\n    \n    d.x -= 0.04;\n    d.x = abs(d.x) + 0.003;\n    glow -= 0.1/(0.001 + d.x*d.x*200.);\n    \n    \n    \n    float dL = length(q.zx)/q.w;\n\n    d.x = max(d.x,  -length(p.xy) + 0.2 );\n    \n    d.x *= 0.45;\n    \n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    p = ro;; t = 0.; hit = false;\n    \n    for(float i = 0.; i < 150.; i++){\n    \td = map(p)*dith;\n        float eps = 0.001 + 0.001*5.0*pow(float(i)/200.0,2.0);\n        if(d.x < eps){\n            t += 0.005;\n        }\n        \n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return -normalize(vec3(\n        map(p - t.xyy).x - map(p + t.xyy).x,\n        map(p - t.yxy).x - map(p + t.yxy).x,\n        map(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= rot(sin(iTime*0.5)*0.6);\n    \n    uv *= 1. - dot(uv,uv)*.1;\n    \n    dith = mix(0.95,1.,texture(iChannel0,iResolution.xy*(uv + iTime*10.)/256.).x);\n    \n    vec3 col = vec3(0);\n\n\tvec3 ro = vec3(0);\n    \n    ro.z += iTime*1.7 + 0.1;\n    \n    ro += path(ro.z);\n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    lookAt += path(lookAt.z + .5);\n    \n    vec3 rd = getRd(ro, lookAt,uv);\n    \n    \n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    col += glow*0.001;\n    \n    vec3 fc = pal(0.6,0.5,vec3(1.,0.5,0.6) + cos(rd.xyz)*1., 1.7  - dot(uv,uv)*0.2,-2.1 - dot(uv,uv)*0.2);\n    fc = max(fc,0.);\n    col = mix(col,fc, smoothstep(0.,1.,t*0.1));\n    \n    fragColor = vec4(col,1.0);\n}\n\n// The following comment is Day 79\n\n/*\n\n\n// Made shader having not slept for 2 days (was in a game jam) \n// in like 30 minutes. \n// not really something I thought about or put much effort in. \n\n#define pmod(p,x) (mod(p,x) - 0.5*x)\n#define dmin(a,b) a.x < b.x ? a : b\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin(tau*((c)*(d) + e)))\n\n#define coolPal(a,b) pal(0.5,0.6,vec3(0.97 + sin(iTime*0.02 + p.z*0.04),3.4 + sin(b)*0.2,0.8),0.4 + (a),3.3 + (b))\n#define tunnW 0.8\n\n#define mx (10.*iMouse.x/iResolution.x)\n#define my (10.*iMouse.y/iResolution.x)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\nvec3 glow = vec3(0);\nvec3 glowFog = vec3(0);\nvec3 glowCol = vec3(0);\n\n\nfloat sdSphere(vec3 p, float s){\n\treturn length(p) -s;\n}\nfloat sdBox(vec3 p, vec3 r){\n    p = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\n\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0, vec2(t)/256.),texture(iChannel0, vec2(t+1.)/256.),smoothstep(0.,1.,fract(t)));\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\t\n    p.xy *= rot(p.z*0.3);\n    vec3 z = p;\n    #define modDist 2.\n    \n    vec3 id = floor(p/modDist )- max(sign(vec3(p.x,p.y,p.z)), 0.);\n   \tp -= modDist*0.5;\n    \n    p = pmod(p , modDist);\n    \n    vec3 q = p;\n    \n    q = abs(q);\n    q -= modDist*0.5;\n    \n    for(int i = 0; i < 3; i++){\n    \n    \tq = abs(q);\n        q.x-= 0.1;\n        \n        q.xz *= rot(0.25*pi);\n        q.yz *= rot(0.25*pi);\n    }\n    \n    float cube = sdBox(q, vec3(0.5));\n    \n    //sph = fOpIntersectionStairs(sph, -length(p.xz) + 0.1,5.,0.1);\n    d = dmin(d, vec2(cube, 0.));\n    \n    float cubeWalls = cube - 0.06;\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.4,0.4,0.6)));\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.4,0.6,0.4)));\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.6,0.4,0.4)));\n    \n    d = dmin(d, vec2(cubeWalls, 2.));\n    \n    \n    \n    float ball = sdSphere(abs(p) - vec3(modDist*0.5,0,modDist*0.5),0.1);\n    d = dmin(d, vec2(ball, 1.));\n    \n    \n    vec4 n = valueNoise(id.x + id.z + iTime);\n    \n    vec3 c = pal(0.8,0.9,vec3(0.6,0.2+ abs(sin(z.x*0.5 +iTime*0.3))*0.6,0.5),0.4,3.7 + sin(z.z)*0.1);\n    c = max(c, 0.);\n    glow += min(exp(-max(ball, 0.)*6.)*4. * pow(n.x,5.)*40.*c, 3.);\n\n    \n    \n    // TUBE\n    \n    vec3 pC = vec3(atan(p.x,p.z)/tau,length(p.xz), p.y);\n    \n    pC.x = pmod(pC.x, 0.1);\n    \n    pC.y -= 1.05;\n    \n    pC.y += pow(smoothstep(0.,1.,abs(p.y)*0.8), 1.7)*0.8;\n    \n    //pC.y += pow(abs(p.y), 1.2);\n    \n    float glowTube = max(abs(pC.x),abs(pC.y)) - 0.01;\n    \n    glowTube = max(glowTube, -length(vec3(pC.x*3., pC.y - 0.02, pmod(pC.z, 0.3))) + 0.04);\n    //glowTube = max(glowTube, 0.);\n    glow += exp(-glowTube*190.)*max(pal(0.4,0.6,vec3(0.,0.5,0.7),0.8,0.7 + sin(p.z)), 0.)*3.;\n    \n    d = dmin(d,vec2(glowTube + 0.02, 0.));\n    \n    \n    d.x *= 0.5;\n    return d;\n}\n\nfloat N;\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\tt = 0.; hit = false; p = ro;\n    \n    \n\tfloat a = mix(0.8,1.,N); // remove banding from glow\n    \n    for(int i = 0; i < 150; i++){\n    \td = map(p)*a;\n        glowFog += exp(-d.x*50.);\n        if(d.x < 0.001 || t > 10.){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = cross(vec3(0,1,0), dir);\n\tvec3 up = cross(dir, right);\n    float fov = 1. + sin(iTime)*0.;\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tN = texture(iChannel0,(uv)*256.).x*1.;\n    uv *= 1. + dot(uv,uv)*0.25;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    \n    vec3 lookAt = vec3(0);\n    \n    ro.z += iTime*1.;\n    lookAt.z = ro.z + 2.;\n    \n    ro.xz += vec2(\n    \tsin(iTime),\n    \tcos(iTime)\n    )*0.1;\n    \n    \n    \n    vec3 rd = getRd(ro, lookAt, uv);\n\n    //rd.xz *= rot(sin(0.5*pi*(floor(iTime*0.125) + pow(smoothstep(0.,1.,fract(iTime*0.125)), 2.5))));\n    float t; bool hit; vec3 p;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if (hit){\n    \tvec3 n = getNormal(p);\n    \n        vec3 ld = normalize(vec3(1));\n        \n        //col += 0.7 + n;\n        float diff = max(dot(ro,ld), 0.);\n        float fres = pow(1. - max(dot(n,-rd), 0.), 5.);\n        float spec = pow(max(dot(n, normalize(ld - rd)), 0.), 20.);\n        \n            float ao = clamp(map(p + n*0.5).x/0.5,0.,1.);\n        if(d.y == 2.){\n        \tcol += min(diff*fres, 1.)*0.5*vec3(0.2,0.2,0.4);\n        \n        }\n        if(d.y == 0.){\n        \tcol += min(diff*fres, 1.)*0.4*vec3(0.4,0.3,0.62) + spec*vec3(0.4,0.,0.2)*0.1;\n        \t\n        }\n        \n        col *= ao*0.5 + 0.25;\n    }\n    \n    col += glow*0.01;\n    \n    col = mix(col, vec3(0.3,0.,0.6)*0.1, smoothstep(0.,1., t*0.12));\n    col += vec3(0.3,0.,0.1)*0.01*smoothstep(0.,1., t*0.12)*glowFog;\n    col = max(col, 0.);\n    col = col*0. + smoothstep(0.,1.,col)*0.8;\n    col = pow(col, vec3(0.4545 + dot(uv,uv)*0.15));\n    \n    \n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlySDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 439, 459, 459, 521], [523, 523, 551, 551, 602], [605, 605, 657, 657, 756], [758, 758, 816, 816, 916], [918, 918, 977, 977, 1076], [1078, 1078, 1095, 1095, 1829], [1844, 1844, 1918, 1918, 2233], [2235, 2235, 2277, 2277, 2465], [2467, 2467, 2490, 2490, 2689], [2693, 2693, 2750, 2750, 3543]], "test": "untested"}
{"id": "ttGSWV", "name": "voronoi manhattan and euclidean", "author": "paz7", "description": "Click and drag the mouse along x axis to blend between euclidean and manhattan distance", "tags": ["voronoi"], "likes": 2, "viewed": 375, "published": 3, "date": "1583593006", "time_retrieved": "2024-07-30T21:20:04.146729", "image_code": "#define iR iResolution\n\nvec2 Hash12(float f){ \n    return vec2(fract(sin(65.621*f+f) * 43758.5453),fract(sin(65.621*f-f) * 231.654));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat scale = iR.x/iR.y;\n    vec2 uv = (fragCoord)/iR.x*scale;\n    \n    float seed = 621.;\n    \n    int numberOfPoints = 200;\n    vec2 points[200];\n    vec2 offset;\n    \n   \tfor(int i = 0;i<numberOfPoints-1;i++){\n        seed += float(i);\n    \tvec2 xy = Hash12(seed);\n        offset = vec2(sin(xy.x+iTime+float(i)*45.),sin(xy.y+iTime+float(i)*45.))/100.;\n        xy += offset;\n        xy.x *= scale;\n        points[i] = xy;\n    }\n\n    vec3 col = vec3(0,0,0);\n    float t = iMouse.x/iR.x;\n    float mind = 9999.;\n    int pid = 0;\n    float p = 0.;\n\n    vec3 hsvcol = vec3(0,.8,.9);\n    for(int i = 0;i<numberOfPoints-1;i++){\n        float e = euclidDist(uv,points[i]+offset);\n        float m = manhattanDist(uv,points[i]+offset);\n\t\t\n        if(e<.005) p = 1.;\n        \n        float d = m*t + e*(1.-t);\n        if(d<mind) {\n            pid = i;\n            mind = d;\n        }\n    }\n    hsvcol.x = float(pid)/float(numberOfPoints-1);\n    col+=hsv2rgb(hsvcol);\n    col*=(1.-mind)*(1.-mind)*(1.-mind)*(1.-mind);\n    col-=p;\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "float manhattanDist(vec2 a, vec2 b){\n\treturn abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nfloat euclidDist(vec2 a, vec2 b){\n\treturn sqrt(pow(a.x-b.x,2.) + pow(a.y-b.y,2.));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 45, 45, 135], [137, 137, 194, 194, 1253]], "test": "untested"}
{"id": "3lySDV", "name": "Simple geometric 2D art", "author": "mrange", "description": "I was experimenting with replicating geometric art. I thought the result was interesting so I thought I share even though it is a very simple distance field function.", "tags": ["2d"], "likes": 6, "viewed": 464, "published": 3, "date": "1583573926", "time_retrieved": "2024-07-30T21:20:04.917668", "image_code": "// License CC0: mrange\n// I was experimenting with replicating geometric art. I thought the result was interesting \n// so I thought I share even though it is a very simple distance field function.\n// \n\n// Experiment with these parameters for variants\nconst float size  = 1.0 ;\nconst float off   = 0.15;\nconst float width = 0.01;\nconst int   rep   = 13  ;\n\n#define PHI (.5*(1.+sqrt(5.)))\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat dodec(in vec3 z) {\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(z-vec3(size,0.,0.),plnormal);\n        \n  dmin = abs(dmin) - width;\n//  dmin = abs(dmin) - width*0.5;\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100000.0;\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)*TAU/float(rep));\n    ip -= vec2(size, 0.0);\n    float id = dodec(vec3(ip, off*size));\n    d = min(d, id);\n  }\n  return d;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 uv = 2.0*(q - 0.5);\n  uv.x *= iResolution.x/iResolution.y;\n    \n  float d = df(uv);\n\n  float fuzzy = 0.001;\n    \n  vec3 col = mix(vec3(0.3), vec3(1.0), smoothstep(-fuzzy, fuzzy, d));\n  \n  col = postProcess(col, q);\n    \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lySDV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[632, 632, 656, 656, 1026], [1028, 1028, 1061, 1061, 1146], [1148, 1148, 1166, 1166, 1384], [1386, 1386, 1429, 1454, 1703], [1705, 1705, 1760, 1760, 2061]], "test": "untested"}
{"id": "3tVSDy", "name": "Tartans", "author": "mla", "description": "Some tartans from [url]https://www.tartanregister.gov.uk[/url]", "tags": ["tartan", "sett", "fbi"], "likes": 14, "viewed": 434, "published": 3, "date": "1583573132", "time_retrieved": "2024-07-30T21:20:05.680628", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Tartans\n//\n// Various tartans from the Scottish Register of Tartans:\n// https://www.tartanregister.gov.uk\n//\n// Current sequence: Buchanan (1850), Hunting Stewart, Macbeth, Macleod,\n// Fraser (1745), Thomson Dress Blue, Black Watch Plaid of Pipers, St.\n// Piran's Cornish Flag and the FBI.\n//\n// <mouse>: pan image or modify colours (depending on 'm' key)\n// <left>/<right>: select tartan\n// <up>/<down>: scale\n// <page up>/<page down>: multiply threadcount\n// m: select mouse mode - pan or colouring\n// h: only modify colours on LHS.\n// \n// Display currently just solid blocks of colour (threads 1 pixel wide\n// by default, <up>/<down> scales, and <page up>/<page down>\n// multiplies threadcount).\n//\n// RGB for colours taken from the Register. Use mouse to modify\n// colours (press 'm' key to enable) - x axis controls brightness, y\n// axis mixes in a dull tan for an attempt at a \"weathered\" look.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Colors from Register\nconst int K  = 0x101010; //BLACK\nconst int R  = 0xC80000; //RED;\nconst int Y  = 0xE8C000; //YELLOW;\nconst int Y2 = 0xD8B000; //YELLOW (Macleod)\nconst int G  = 0x006818; //GREEN;\nconst int WW = 0xFCFCFC; //WILSON WHITE;\nconst int B  = 0x2C2C80; //BLUE;\nconst int DG = 0x003820; //DARK GREEN;\nconst int BL = 0x1474B4; //BALMORAL BLUE;\nconst int WG = 0x408060; //WTHRD GREEN;\nconst int HG = 0x285800; //HUNTING GREEN;\nconst int DR = 0x880000; //DARK RED;\nconst int P  = 0x780078; //PURPLE;\nconst int DB = 0x1C1C50; //DARK BLUE;\nconst int W  = 0xE0E0E0; //WHITE;\nconst int H  = 0x006428; //BOTTLE;\nconst int DB2 = 0x202060; //DARK BLUE;\nconst int LG = 0x289C18; //LIGHT GREEN;\nconst int AB = 0x1870A4; //ANC BLUE;\nconst int LN = 0xC0C0C0; //LIGHT GREY;\nconst int RB = 0x1C0070; //ROYAL BLUE;\n\nint tfactor = 1; // Multiply threadcount\nint scale = 1;\n\n// The setts\n\n// Buchanan (1850) - an asymmetric sett\n// B18G46K6B18K6Y40K6Y40K6B18K6R40W6R40K6B18K6G46\n// Pallet:\n// K=101010BLACK;B=2C2C80BLUE;G=006818GREEN;R=C80000RED;W=E0E0E0WHITE;Y=E8C000YELLOW;\nconst int buchanan[] =\n  int [](B,18,G,46,K,6,B,18,K,6,Y,40,K,6,Y,40,K,6,B,18,K,6,R,40,W,6,R,40,K,6,B,18,K,6,G,46);\n\n// Hunting Stewart - an asymmetric sett.\n// B9HG4B9K3B3K3B3K8HG27R4HG27K8HG5K13HG4K13HG5K8HG27Y4HG27K8B3K3B3K3\n// G=006818GREEN;K=101010BLACK;B=2C2C80BLUE;DG=003820DARK GREEN;\n// R=C80000RED;Y=E8C000YELLOW;BL=1474B4BALMORAL BLUE;\n// WG=408060WTHRD GREEN;HG=285800HUNTING GREEN;\n\n// No reflection and odd threadcounts.\nconst int huntingstewart[] = int[](B,9,HG,4,B,9,K,3,B,3,K,3,B,3,K,8,HG,27,R,4,HG,27,K,8,HG,5,\n                                   K,13,HG,4,K,13,HG,5,K,8,HG,27,Y,4,HG,27,K,8,B,3,K,3,B,3,K,3);\n\n// Most other tartans are reflected: halve end threadcounts to get correct reflection\n\n// Fraser (1745)\n// R4B24R4G24R48WW2\n// G=006818GREEN;WW=FCFCFCWILSON WHITE;B=2C2C80BLUE;R=C80000RED;\n\nconst int fraser[] = int[](R,4/2,B,24,R,4,G,24,R,48,WW,2/1);\n\n// Macbeth\n// B144 Y16 K20 WW4 K4 WW4 K8 G32 R24 K4 R12 WW4\nconst int macbeth[] = int[](B,144/2,Y,16,K,20,WW,4,K,4,WW,4,K,8,G,32,R,24,K,4,R,12,WW,4/2);\n\n// Farquharson\n// R4 B16 K4 B4 K4 B4 K32 G32 Y8 G32 K32 B32 K4 R8\nconst int farquharson[] = int[](R,4/2,B,16,K,4,B,4,K,4,B,4,K,32,G,32,Y,8,G,32,K,32,B,32,K,4,R,8/2);\n\n// \"Loud MacLeod\"\n// K32Y4K32Y48R4\n// K=101010BLACK;R=C80000RED;Y=D8B000YELLOW;\nconst int macleod[] = int[](K,32/2,Y2,4,K,32,Y2,48,R,4/2);\n\n// Fujitsu\n// Y2K12G64K24DR24P18DB12W2\n// Y=E8C000YELLOW;K=101010BLACK;G=006818GREEN;DR=880000DARK RED;P=780078PURPLE;DB=1C1C50DARK BLUE;W=E0E0E0WHITE;\nconst int fujitsu[] = int[](Y,2/2,K,12,G,64,K,24,DR,24,P,18,DB,12,W,2/2);\n\n// Asda\n// \"Winning design in a competition run by ASDA Wal-mart in Elgin,\n// Morayshire. The winner, Angela Dean, was aged nine. Different warp\n// and weft.\"\n//\n// LG136R8LG12DB8H68DB8LG12R8LG136DB8H32R8H38DB8.LG248Y12H28Y12\n// H=006428BOTTLE;DB=202060DARK BLUE;R=C80000RED;Y=E8C000YELLOW;LG=289C18LIGHT GREEN;\n// Not doing this one (yet) as warp and weft are different.\nconst int asda0[] = int[](LG,136,R,8,LG,12,DB2,8,H,68,DB,8,LG,12,R,8,LG,136,DB2,8,H,32,R,8,H,38,DB,8);\nconst int asda1[] = int[](LG,248,Y,12,H,28,Y,12);\n\n// The FBI Tartan\n// \"Commissioned for use for the FBI Pipe Band from Thomas\n// Gordon & Sons of Glasgow but now regarded as being the FBI\n// tartan\".\n\n// DR4AB52RB32LN6RB4LN4RB12\n// AB=1870A4ANC BLUE;DR=880000DARK RED;LN=C0C0C0LIGHT GREY;RB=1C0070ROYAL BLUE;\n\nconst int fbi[] = int[](DR,4/2,AB,52,RB,32,LN,6,RB,4,LN,4,RB,12/2);\n\n// Black Watch Plaid of Pipers\n// DB24K4R4K4R4K24DG22Y4DG22K24DB22K4R4\n// K=101010BLACK; DG=006818GREEN; R=C80000RED; Y=E8C000YELLOW; DB=202060DARK BLUE;\n// DG here is just G, DB is DB2\nconst int blackwatchpiper[] = int[](DB2,24/2,K,4,R,4,K,4,R,4,K,24,G,22,Y,4,G,22,K,24,DB2,22,K,4,R,4/2);\n\n// Thomson Dress Blue\n// R6AB60K12W24K24Y6\n// AB=1870A4ANC BLUE;K=101010BLACK;R=C80000RED;W=E0E0E0WHITE;Y=E8C000YELLOW;\nconst int thomson[] = int[](R,6/2,AB,60,K,12,W,24,K,24,Y,6/2);\n\n// St. Piran's Cornish Flag\n// R4K2W20K40W10K40W20K2 - full sett\n// K=101010BLACK;R=C80000RED;W=E0E0E0WHITE;\nconst int stpirans[] = int[](R,4,K,2,W,20,K,40,W,10,K,40,W,20,K,2);\n\nint settlength = 0;  // Total number of bands\nint settsize = 0;    // Total number of threads\nbool reflect = true; // Is sett reflected?\n\nconst int NSETTS = 9;\n\n// Index into the sett.\nint sett(int settid,int i) {\n  int k = 0;\n  if (settid == k++) return buchanan[i];\n  if (settid == k++) return huntingstewart[i];\n  if (settid == k++) return macbeth[i];\n  if (settid == k++) return macleod[i];\n  if (settid == k++) return fraser[i];\n  if (settid == k++) return thomson[i];\n  //if (settid == k++) return farquharson[i];\n  if (settid == k++) return blackwatchpiper[i];\n  //if (settid == k++) return fujitsu[i];\n  if (settid == k++) return stpirans[i];\n  if (settid == k++) return fbi[i];\n  return 0;\n}\n\n// Set up the sett.\nbool setupsett(int settid) {\n  if (settid < 0 || settid >= NSETTS) return false;\n  // Keep list of tartans in the two blocks consistent.\n  int k = 0;\n  if (settid == k++) settlength = buchanan.length(),reflect = false;\n  if (settid == k++) settlength = huntingstewart.length(),reflect = false;\n  if (settid == k++) settlength = macbeth.length();\n  if (settid == k++) settlength = macleod.length();\n  if (settid == k++) settlength = fraser.length();\n  if (settid == k++) settlength = thomson.length();\n  //if (settid == k++) settlength = farquharson.length();\n  if (settid == k++) settlength = blackwatchpiper.length();\n  //if (settid == k++) settlength = fujitsu.length();\n  if (settid == k++) settlength = stpirans.length(),reflect = false;\n  if (settid == k++) settlength = fbi.length();\n  if (k != NSETTS) return false;\n\n  for (int i = 0; i < settlength; i += 2) {\n    settsize += tfactor*sett(settid,i+1);\n  }\n  return true;\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nint getsettcol(int settid,int n) {\n  if (reflect) {\n    n = mymod(n,2*settsize);\n    n = min(n,2*settsize-n-1);\n  } else {\n    n = mymod(n,settsize);\n  }\n  int total = 0;\n  for (int i = 0; i < settlength; i += 2) {\n    total += tfactor*sett(settid,i+1);\n    if (n < total) return sett(settid,i);\n  }\n  return 0;\n}\n\nvec3 hex2rgb(int n) {\n  return vec3((n>>16)&0xFF,(n>>8)&0xFF,(n>>0)&0xFF)/256.0;\n}\n\nvec3 getcol(int settid,ivec2 a) {\n  // Determine if we have a warp or weft thread at this location\n  bool warp = mymod(a.x-a.y,4) < 2;\n  int n =  warp ? a.x : a.y;\n  // And look up in the sett.\n  vec3 col = hex2rgb(getsettcol(settid,n));\n  if (!warp) col *= 0.9;\n  return col;\n}\n\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_H = 72;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nbool keypress(int key) {\n  return texelFetch(iChannel0,ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  tfactor = 1+max(0,keycount(KEY_PAGE_UP)-keycount(KEY_PAGE_DOWN));\n  scale = 1+max(0,keycount(KEY_UP)-keycount(KEY_DOWN));\n\n  int settid = keycount(KEY_RIGHT)-keycount(KEY_LEFT);\n  settid = mymod(settid,NSETTS+1);\n  if (settid == 0) settid = mymod(int(0.5*iTime),NSETTS);\n  else settid--;\n\n  if (!setupsett(settid)) {\n    fragColor = vec4(1);\n    return;\n  }\n  vec2 p = fragCoord-0.5*iResolution.xy;\n  if (!keypress(CHAR_M) && iMouse.x > 0.0) {\n    p -= iMouse.xy-0.5*iResolution.xy;\n  }\n  p /= float(scale);\n  vec3 col = getcol(settid,ivec2(floor(p)));\n  float value = 1.0;\n  float saturation = 1.0;\n  if (keypress(CHAR_M) && iMouse.x > 0.0) {\n    value = iMouse.x/iResolution.y;\n    saturation = iMouse.y/iResolution.y;\n  }\n  // Unsaturate by mixing with tan for a \"weathered\" look.\n  vec3 satcol = hex2rgb(0xD2B48C);//hex2rgb(0x4A412A);\n  if (!keypress(CHAR_H) || fragCoord.x < 0.5*iResolution.x) {\n    col = value*(mix(satcol,col,saturation));\n  }\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[5380, 5404, 5432, 5432, 5919], [5921, 5941, 5969, 5969, 6871], [6873, 6873, 6898, 6938, 6993], [6995, 6995, 7029, 7029, 7308], [7310, 7310, 7331, 7331, 7392], [7394, 7394, 7427, 7492, 7672], [8017, 8017, 8042, 8042, 8090], [8092, 8092, 8115, 8115, 8147], [8149, 8149, 8173, 8173, 8231], [8233, 8233, 8285, 8285, 9267]], "test": "untested"}
{"id": "WlyXWV", "name": "arctest", "author": "Del", "description": "arc", "tags": ["arc"], "likes": 3, "viewed": 304, "published": 3, "date": "1583571362", "time_retrieved": "2024-07-30T21:20:06.609145", "image_code": "// testing some 2d shape extrusion\n\n#define AA 2\n#define PI\t3.1415926\n#define TAU 6.2831853\n\n// 2d distance functions by IQ\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat pizza( vec2 p, vec2 c, float rad1, float rad2)\n{\n    p.x = abs(p.x);\n    \n    vec2 c2 = vec2(c.y,-c.x);\n    \n    float l = -dot(c,p.xy);\n    float q = p.x+c.x*l;\n    float l2;\n    \n    if (max(q,-sign(p.y*c.y)) < 0.0) {\n        l = -length(p.xy);\n    }\n    \n    if (l < 0.0) {\n        l2 = length(p.xy);\n    } else {\n        l2 = dot(c2,p.xy)*sign(c.y);\n    }\n    \n    \n    \n    vec2 a = vec2(max(l2-rad2,rad1-l2),l);\n    \n    return length(max(a,0.0))+min(0.0,max(a.x,a.y));\n}\n\n\nfloat map( in vec3 pos )\n{\n    float fill = (0.5+sin(iTime)*0.5)*PI;\n    \n    vec2 uv = pos.xz;\n    \n    // arc\n    float ta = radians(90.0);\n    float tb =  fill;\n    float rb = 0.1;\n    float d1 = sdArc(uv-vec2(0.0,1.5),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);  \n\n    // pie\n    float d2 = sdPie(uv,vec2(sin(tb),cos(tb)),0.5);\n    \n    // horseshoe\n    float t = 3.14-fill;\n    vec2  w = vec2(0.0,0.1);\n    //float d3 = sdHorseshoe(uv+vec2(0.0,1.5),vec2(cos(t),sin(t)), 0.5, w);    \n\n    // pizza!\n    \n    \n\tfloat d3 = pizza(uv+vec2(0.0,1.5),vec2(cos(t),sin(t)),0.4,0.5);\n    \n                       \n    d1=min(d1,d2);\n    d1=min(d1,d3);\n    d1 = opExtrussion(pos.zxy,d1,0.1);\n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n     // camera movement\t\n    float an = sin(iTime)*0.5;\n    float y = 2.;\n    float dist=1.5;\n    \n    if (iMouse.z>0.5)\n    {\n        an=iMouse.x/iResolution.x*4.0;\n        y = (iMouse.y/iResolution.y)*8.0;\n        y-=4.0;\n        dist=3.0;\n    }\n    \n\tvec3 ro = vec3( dist*cos(an), y, dist*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 8.0;\n        float t = 0.0;\n        for( int i=0; i<80;i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.6,0.4,0.4);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            vec3 ambcol = vec3(0.4,0.3,0.3)*amb;\n            col = ambcol + vec3(0.6,0.55,0.85)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 124, 202, 202, 386], [388, 388, 437, 437, 611], [613, 613, 672, 672, 768], [770, 770, 836, 836, 1095], [1097, 1097, 1151, 1151, 1580], [1583, 1583, 1609, 1609, 2294], [2296, 2296, 2328, 2328, 2567]], "test": "untested"}
{"id": "wtKXDy", "name": "Very nice bug (SMOKE)", "author": "Txoka", "description": "Bug of https://www.shadertoy.com/view/ttVSWG\nI think this is very nice", "tags": ["bug"], "likes": 4, "viewed": 394, "published": 3, "date": "1583537392", "time_retrieved": "2024-07-30T21:20:07.385070", "image_code": "void mainImage(out vec4 Q, in vec2 U){\n    ivec2 id=ivec2(U);\n    Q=vec4(B(id).x);\n    //Q+=vec4(B(id).xy,A(id).z,0)*3.;\n}\n/*\nIt works like this:\n\nPressure should obviusly create a force outwards:\n\n\tvelocity.xy-=vec2(dx_dpressure,dy_dpressure)\n\n\nIf more air is flowing towards a point than air is \nflowing outwards of it (negative divergence) it should \nlogically increase the pressure at that point (and vice-versa):\n\n\tpressure-=velocity_divergence\n\n\nand that should be everything.\n\nThen just add a channel for\tcolouring the fluid generated \nby the mouse and follow it with\n\tcolor=\n\t\ttexture(iChannel0,U/R.xy+velocity.xy*0.01).color;\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 Q, in vec2 U){\n    ivec2 id=ivec2(U);\n    Q=texelFetch(iChannel1,id,0);\n    Q.w=0.;\n    \n    vec3 dadx=B(id+ivec2(1,0)).xyz-B(id-ivec2(1,0)).xyz;\n    vec3 dady=B(id+ivec2(0,1)).xyz-B(id-ivec2(0,1)).xyz;\n    \n    Q.xy-=vec2(dadx.z,dady.z)*0.1;\n    \n    //if(any(lessThan(id,ivec2(5)))||any(greaterThan(id,ivec2(R.xy)-5)))Q=vec4(0.);\n    Q.xy+=vec2(sin(iTime*2.)*0.5,cos(iTime*2.)*0.5)*exp(-0.005*dot2(U-R.xy*.5))*0.05;\n\tif(M.z>0.)Q.xy+=vec2(sin(iTime*2.)*0.5,cos(iTime*2.)*0.5)*exp(-0.005*dot2(M.xy-U))*0.1;\n    if(iFrame==0)Q.xy=vec2(0,-1)*exp(-0.005*dot2(U-R.xy*.5))*0.2;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 RK4(vec2 p){\n    vec2 k1=texture(iChannel0,p/R.xy).xy;\n    vec2 k2=texture(iChannel0,(p-0.5*10.*k1)/R.xy).xy;\n    vec2 k3=texture(iChannel0,(p-0.5*10.*k2)/R.xy).xy;\n    vec2 k4=texture(iChannel0,(p-10.*k3)/R.xy).xy;\n    return 10.*((k1+k4)/6.+(k2+k3)/3.);\n}\nvoid mainImage(out vec4 Q, in vec2 U){\n    ivec2 id=ivec2(U);\n    Q=texelFetch(iChannel0,id,0);\n    Q.w=0.;\n    \n    vec3 dadx=A(id+ivec2(1,0)).xyz-A(id-ivec2(1,0)).xyz;\n    vec3 dady=A(id+ivec2(0,1)).xyz-A(id-ivec2(0,1)).xyz;\n    \n    float divergence=dadx.x+dady.y;\n    \n    Q.z-=divergence;\n    #ifdef use_RK4\n    Q.x=texture(iChannel0,(U+RK4(U).xy)/R.xy).x;\n    #else\n    Q.x=texture(iChannel0,(U-B(id).xy*10.)/R.xy).x;\n    #endif\n    Q.xz+=vec2(1.,.1)*exp(-0.005*dot2(U-R.xy*.5))*.5;\n    if(M.z>0.)Q.xz+=vec2(1.,.1)*exp(-0.005*dot2(M.xy-U));\n\tif(iFrame==0)Q.xy=vec2(2.,.2)*exp(-0.005*dot2(U-R.xy*.5));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution\n#define M iMouse\n\n#define A(id) texelFetch(iChannel0,(id+ivec2(R.xy))%ivec2(R.xy),0)\n#define B(id) texelFetch(iChannel1,(id+ivec2(R.xy))%ivec2(R.xy),0)\n\nfloat dot2(vec2 k){return dot(k,k);}\n\n//RK4 (just for color tracking not for actual simulation)\n#define use_RK4", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 122]], "test": "untested"}
{"id": "wlKSDy", "name": "facepaint", "author": "samhattangady", "description": "Tried out a different method of modelling the face. Made it a lot more rugged loooking, so finished it off with some warpaint. Just don't feel like working on the ears though.", "tags": ["sdf", "3dmodel"], "likes": 10, "viewed": 410, "published": 3, "date": "1583529610", "time_retrieved": "2024-07-30T21:20:08.161012", "image_code": "/*\n * 01 Mar 2020\n * Just want to make something from scratch again. I think building on the things\n * that I have built before may not be the best approach for every single model,\n * because it doesn't always allow me to get the practice in, and I stick to doing\n * things the same way every time, and don't have an oppurtunity to improve the base\n * framework... ‾\\_(ツ)_/‾\n * As far as possible, apart from the sdf functions, I want to rewrit the whole thing\n * from scratch, just to see where the whole thing can be simpler.\n*/\n\n#define RAYMARCH_STEPS 100\n#define MAX_RAYMARCH_DISTANCE 15.0\n#define RAYMARCH_SURFACE_DISTANCE 0.01\n#define PI 3.14159\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\nfloat sdfCappedCone( vec3 p, vec3 origin, vec3 scale, float h, float r1, float r2, float radius )\n{\n    p*=scale;\n    p -= origin;\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) ) - radius;\n}\nfloat smin(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\nvec2 distanceField(vec3 pos) {\n    //pos = rotate3D(pos, vec3(0.0, 0.0, -0.2));\n    float material = 1.0;\n    float d, d1, d2;\n    vec3 t1, symx;\n    d = MAX_RAYMARCH_DISTANCE;\n    // base head\n    d1 = sdfCappedCone(pos, vec3(0.0, -0.0, 0.0), vec3(1.0, 1.0, 1.0), 1.0, 0.5, 0.3, 0.9);\n    d = smin(d, d1, 0.001);\n    d1 = sdfSphere(pos, vec3(0.0, 0.5, 0.4), 1.6);\n    d = smin(d, d1, 0.4);\n\n    // eyesockets\n    d1 = sdfRoundBoxRotated(pos, vec3(0.0, 0.6, -1.2), vec3(2.0, 0.0, 0.0), vec3(0.0, 0.0, 0.12), 0.4);\n    d2 = sdfRoundBoxRotated(pos, vec3(0.0, 1.2, -1.2), vec3(2.5, 0.4, 0.4), vec3(-0.4, 0.0, 0.18), 0.1);\n    d1 = smax(d1, -d2, 0.1);\n    d = smax(d, -d1, 0.2);\n\n    // cheekbones\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfSphere(symx, vec3(0.8, -0.25, -0.8), 0.3);\n    d = smin(d, d1, 0.4);\n\n    // chin\n    d1 = sdfRoundBoxRotated(pos, vec3(0.0, -1.4, -1.05), vec3(0.4, 0.2, 0.2), vec3(0.3, 0.0, 0.0), 0.04);\n    d = smin(d, d1, 0.5);\n\n    // jaw\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfRoundBoxRotated(symx, vec3(0.8, -1.0, -0.4), vec3(0.3, 0.2, 0.6), vec3(-0.3, 0.8, 0.3), 0.01);\n    d = smin(d, d1, 0.5);\n\n    // nose\n    t1 = pos-vec3(0.0, 0.4, -1.0);\n    t1 = rotate3D(t1, vec3(0.4, 0.0, 0.0));\n    symx = vec3(abs(t1.x), t1.yz);\n    d1 = sdfRoundBoxRotated(t1, vec3(0.0), vec3(0.1, 0.4, 0.2), vec3(-0.2, 0.0, 0.0), 0.05);\n    d2 = sdfRoundBoxRotated(t1, vec3(0.0, -0.4, 0.0), vec3(0.06, 0.4, 0.2), vec3(0.2, 0.0, 0.0), 0.05);\n    d1 = smin(d1, d2, 0.1);\n    d2 = sdfSphere(t1, vec3(0.0, -0.72, -0.23), 0.1);\n    d1 = smin(d1, d2, 0.2);\n    d2 = sdfSphere(t1, vec3(0.22, -0.64, -0.2), 0.12);\n    d1 = smin(d1, d2, 0.2);\n    d2 = sdfSphere(t1, vec3(-0.23, -0.66, -0.2), 0.13);\n    d1 = smin(d1, d2, 0.2);\n    d = smin(d, d1, 0.2);\n\n    //eyes\n    d1 = sdfSphere(pos, vec3(0.44, 0.5, -0.8), 0.35);\n    if (d1<d)\n        material = 2.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(-0.44, 0.5, -0.8), 0.35);\n    if (d1<d)\n        material = 2.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(0.48, 0.49, -1.0), 0.20);\n    if (d1<d)\n        material = 3.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(-0.42, 0.46, -1.0), 0.19);\n    if (d1<d)\n        material = 3.0;\n    d = smin(d, d1, 0.02);\n\n\n    // mouth\n    d1 = sdfSphere(pos, vec3(-0.48, -0.82, -1.4), 0.12);\n    d = smax(d, -d1, 0.23);\n    d1 = sdfSphere(pos, vec3(0.48, -0.82, -1.4), 0.12);\n    d = smax(d, -d1, 0.23);\n    t1 = rotate3D(pos, vec3(0.3, 0.0, -0.1));\n    d1 = sdfCappedCone(t1, vec3(0.1, -0.95, -0.84), vec3(1.0, 1.0, 1.0), 0.2, 0.5, 0.3, 0.0);\n    d = smin(d, d1, 0.12);\n    t1 = rotate3D(pos, vec3(0.27, 0.0, -0.14));\n    d1 = sdfCappedCone(t1, vec3(0.1, -1.35, -0.84), vec3(1.0, 1.0, 1.0), 0.1, 0.3, 0.5, 0.0);\n    d = smin(d, d1, 0.23);\n\n    // neck\n    d1 = sdfCappedCone(pos, vec3(0.0, -1.5, 0.4), vec3(1.0, 1.0, 1.0), 0.9, 1.3, 1.1, 0.1);\n    d = smin(d, d1, 0.05);\n\n    // ears\n    symx = vec3(abs(pos.x), pos.yz);\n    symx = rotate3D(symx, vec3(0.0, 0.0, -0.1));\n    symx.y /= 1.2;\n    t1 = symx - vec3(1.5, 0.13, 0.0);\n    d1 = sdfSphere(t1, vec3(0.0), 0.5);\n    d2 = sdfRoundBoxRotated(t1, vec3(0.0), vec3(0.1, 2.0, 2.0), vec3(0.0, 0.9, 0.0), 0.0);\n    d1 = smax(d2, d1, 0.05);\n    d2 = sdfSphere(t1, vec3(0.25, 0.1, 0.0), 0.1);\n    d1 = smax(-d2, d1, 0.3);\n    d2 = sdfSphere(t1, vec3(0.21, -0.1, -0.01), 0.1);\n    d1 = smax(-d2, d1, 0.1);\n    d = smin(d, d1, 0.05);\n\n    // warpaint\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfRoundBoxRotated(symx, vec3(0.74, 0.1, -1.0), vec3(0.25, 0.04, 1.0), vec3(0.0, 0.0, 0.2), 0.1);\n    if (d1<d)\n        material = 4.0;\n\n\n    return vec2(d, material);\n}\n\nvec2 raymarch(vec3 point, vec3 direction) {\n    // return type: vec2(distance, material);\n    float dist = 0.0;\n    vec2 d;\n    for (int i=0; i<RAYMARCH_STEPS; i++) {\n        d = distanceField(point);\n        dist += d.x;\n        point += d.x * direction;\n        if (d.x < RAYMARCH_SURFACE_DISTANCE)\n            return vec2(dist, d.y);\n        if (dist > MAX_RAYMARCH_DISTANCE)\n            return vec2(dist, 0.0);\n    }\n    return vec2(dist, 0.0);\n}\n\nvec3 calculate_normal(vec3 pos) {\n    vec3 h = vec3(0.001, 0.0, 0.0);\n    float d = distanceField(pos).x;\n    return normalize(vec3(\n                d-distanceField(pos+h.xyy).x,\n                d-distanceField(pos+h.yxy).x,\n                d-distanceField(pos+h.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.0 - vec2(1.0);\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 point = vec3(uv, -5.0);\n    vec3 camera = vec3(0.0, 0.0, -6.0);\n    float mouseX = ((-iMouse.x/iResolution.x)+0.5)*PI/1.5;\n    mouseX = 0.3 + 0.3*sin(iTime/2.0);\n\n    point = rotate3D(point, vec3(0.0, mouseX, 0.0));\n    camera = rotate3D(camera, vec3(0.0, mouseX, 0.0));\n    vec3 light_position = vec3(1.0, 1.0, -3.0);\n    vec3 ray_direction = normalize(point-camera);\n    vec2 obj = raymarch(point, ray_direction);\n    float dist = obj.x;\n    float material = obj.y;\n    vec3 color = vec3(0.01);\n    if (dist < MAX_RAYMARCH_DISTANCE) {\n        vec3 surface_point = point + ray_direction*dist;\n        vec3 normal = calculate_normal(surface_point);\n        float light = dot(normal, normalize(surface_point-light_position));\n        light = max(0.0, light);\n        if (material < 1.5) {\n            color = vec3(0.38, 0.22, 0.15);\n            color += vec3(0.18) * smoothstep(0.1, 1.0, light);\n            color += vec3(0.05) * smoothstep(0.3, 1.0, light);\n        } else if (material < 2.5) {\n            color = vec3(0.25, 0.28, 0.34);\n            color += vec3(0.33) * smoothstep(0.1, 1.0, light);\n        } else if (material < 3.5) {\n            color = vec3(0.03, 0.025, 0.02);\n            color += vec3(0.2) * smoothstep(0.9, 1.0, light);\n        } else if (material < 4.5) {\n            color = vec3(0.002, 0.002, 0.002);\n            color += vec3(0.1) * smoothstep(0.1, 1.0, light);\n        }\n    }\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[658, 658, 700, 700, 1145], [1146, 1146, 1205, 1205, 1255], [1256, 1256, 1316, 1316, 1455], [1456, 1456, 1538, 1538, 1719], [1720, 1720, 1761, 1761, 1813], [1814, 1814, 1907, 1907, 2085], [2086, 2086, 2106, 2106, 2127], [2128, 2128, 2234, 2234, 2897], [2898, 2898, 2997, 2997, 3364], [3365, 3365, 3406, 3406, 3482], [3483, 3483, 3524, 3524, 3600], [3601, 3601, 3631, 3680, 7249], [7251, 7251, 7294, 7340, 7701], [7703, 7703, 7736, 7736, 7982], [7984, 7984, 8041, 8041, 9636]], "test": "untested"}
{"id": "wlVXWy", "name": "point vibes", "author": "artemis", "description": "play with BEAM_X and BEAM_Y !\n\nuse t for the function and toff for animating the function.", "tags": ["2d", "oscilloscope"], "likes": 5, "viewed": 317, "published": 3, "date": "1583528298", "time_retrieved": "2024-07-30T21:20:08.941908", "image_code": "#define PI 3.14159265359\n#define TAU (3.14159265359 * 2.0)\n\n// change BEAM_X and BEAM_Y :)\n// use t wave functions and toff for dynamic phase shifts\n#define BEAM_X (cos(t * 4.0 + toff / 2.0) * 250.0 + cos(t) * 250.0) / 2.0\n#define BEAM_Y (sin(t * 3.0 - toff / 2.0) * 250.0) / 2.0\n//#define BEAM_X cos(t) * 125.0\n//#define BEAM_Y sin(t) * 125.0\n\n\n#define FALLOFF_START 1.0\n#define DECAY_START 0.1\n#define DECAY 20.0\n#define LP_STEP 0.02\n\n\nfloat sRGB(float x) {\n    if (x <= 0.00031308)\n        return 12.92 * x;\n    else\n        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;\n}\n\nfloat saw(float t) {\n \treturn t - floor(t);   \n}\n\nfloat tri(float t) {\n    return 2.0 * abs(t - floor(t + 0.5));\n}\n\n\nfloat electron_beam(vec2 pix, float t, float toff) {\n    float beam_x = BEAM_X;\n    float beam_y = BEAM_Y;\n\n    float dist = distance(pix, vec2(beam_x, beam_y));\n    \n    float power = 1.0 - (min(toff * 2.0 - t, DECAY) / DECAY);\n    \n    float falloff = power * FALLOFF_START;\n    \n    return min(power, power * (falloff * falloff) / (dist * dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy / 2.0;\n    \n    float scale = 512.0 / iResolution.x;\n    \n    vec2 uv = (fragCoord - center) * scale;\n        \n    float beam = 0.0;\n    float init_t = iTime - mod(iTime, LP_STEP);\n    \n    for (int i = 0; i < 400; i++) {\n        float t = float(i) * LP_STEP;\n        beam += electron_beam(uv, init_t - t, init_t / 2.0);\n    }\n    \n    vec3 beam_col = vec3(sRGB(beam * 0.25), sRGB(beam), sRGB(beam));\n    \n    fragColor = vec4(beam_col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 459, 459, 571], [573, 573, 593, 593, 621], [623, 623, 643, 643, 687], [690, 690, 742, 742, 1041], [1043, 1043, 1100, 1100, 1578]], "test": "untested"}
{"id": "tlKSWy", "name": "Melting glaciers", "author": "jarble", "description": "This fractal looks like a melting glacier.", "tags": ["fractal", "glacier"], "likes": 2, "viewed": 310, "published": 3, "date": "1583526627", "time_retrieved": "2024-07-30T21:20:09.707860", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //p += vec2(sin(p.x),sin(p.y))*p;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag;\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n\tint biome = glacier_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 647, 684, 778, 926], [932, 932, 987, 987, 1050], [1052, 1052, 1111, 1111, 1316], [1319, 1319, 1362, 1362, 1498], [1500, 1500, 1534, 1534, 1563], [1565, 1565, 1591, 1591, 2666], [2669, 2669, 2722, 2722, 3396], [3398, 3398, 3454, 3454, 3510], [3512, 3512, 3587, 3587, 3924], [4204, 4204, 4261, 4261, 4468]], "test": "untested"}
{"id": "3lGXWG", "name": "Rorschach's Dream (Best)", "author": "deerfeeder", "description": "Based on @BigWIngs's gyro tut", "tags": ["raymarching", "template", "gyroid", "artofcode", "deerfeeder"], "likes": 13, "viewed": 643, "published": 3, "date": "1583513497", "time_retrieved": "2024-07-30T21:20:10.551604", "image_code": "// Fork of \"Rorschach's Dream (Soft)\" by deerfeeder. https://shadertoy.com/view/WlySWG\n// 2020-03-05 17:20:37\n\n// Fork of \"Rorschach's Dream\" by deerfeeder. https://shadertoy.com/view/wtGXzd\n// 2020-03-05 16:50:36\n\n// Fork of \"RayMarching starting point\" by BigWIngs. https://shadertoy.com/view/WtGXDD\n// 2020-03-04 23:37:06\n// Music by me (Deerfeeder - My Church)\n// raymarching artifacts as a feature\n\n#define MAX_STEPS 5\n#define MAX_DIST 10.\n#define SURF_DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat GetDist(vec3 p) {\n    p.xy*=Rot(iTime*0.06);\n    p.zx*=Rot(iTime*0.06);\n    float box = sdBox(p, vec3(1.0));\n   \t\n    // return box;\n    float gyro = sdGyroid(p,5.+abs(5.0*cos(iTime*0.065)),0.125,2.0)/2.0;\n    return max(box, gyro*4.);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //uv.x = abs(uv.x);\n   uv.y = abs(uv.y);\n\tvec2 m = vec2(cos(iTime*1.),iMouse.x)/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    //float amp = texture(iChannel0, vec2(1., 0.0)).r*4.3;\n    float pos = atan(uv.y/abs(uv.x))/3.14 + 0.5;\n    float amp = texture(iChannel0, vec2(pos, 0.0)).x*(pos*0.3+0.1)*10.0;\n    vec3 ro = vec3(sin((iTime)*0.096), 1.+cos(iTime*0.1), 2.-cos((iTime+ amp)*0.36));\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(0.1 + abs(0.5 * cos(iTime*0.1))));\t// gamma correction\n    col += texture(iChannel1, uv*10.-iTime*.3).rrr * 0.5;\n    fragColor = vec4(1. - col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36475, "src": "https://soundcloud.com/miiiis/qdecaydark", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 528, 528, 604], [606, 606, 635, 635, 716], [718, 718, 784, 784, 863], [865, 865, 888, 888, 1108], [1110, 1110, 1144, 1144, 1355], [1357, 1357, 1381, 1381, 1571], [1573, 1573, 1623, 1623, 1818], [1822, 1822, 1879, 1879, 2831]], "test": "untested"}
{"id": "4ltBzN", "name": "flatrounded cube", "author": "abje", "description": "prototype of an sdf.\narrow keys. shift and ctrl to move.\npress spacebar to set the center of the sdf test sphere.", "tags": ["3d", "improvement"], "likes": 2, "viewed": 325, "published": 3, "date": "1583504123", "time_retrieved": "2024-07-30T21:20:11.409311", "image_code": "vec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nfloat shape(vec3 p,float s, float r) {\n    \n    \n    vec3 p2 = abs(p);\n    //q.x is the smallest, q.z is the biggest, q.y is in the middle\n    //q reflects the sdf so i can reduce calculations\n    vec3 q = vec3(min(min(p2.x,p2.y),p2.z),0,max(max(p2.x,p2.y),p2.z));\n    q.y = p2.x+p2.y+p2.z-q.x-q.z;\n    \n    float l = q.z-s-r;\n    l = max(l,(p2.x+p2.y+p2.z-s*3.0-r)/sqrt(3.0));\n    l = max(l,((q.y+q.z-s*2.0-r)/sqrt(2.0)));\n    \n    if (l < 0.0 || q.y < s) return l;\n    \n    if (q.y-q.z+r<0.0)\n    {\n        float a = length(max(q.xy-s,vec2(0)));\n        l = length(vec2(q.z-r-s,a));\n    }\n    else if (q.x > s&&l>0.0)\n    {\n        float tri = max(dot(q,vec3(-2.0, 1.0, 1.0))-r,0.0);\n\n        tri /= sqrt(6.0);\n        \n        float tric = length(vec2(tri,(dot(p2,vec3( 1.0, 1.0, 1.0))-r-s*3.0)/sqrt(3.0)));\n        \n        l = tric;\n    }\n    \n    return l;\n}\n\nfloat scene(vec3 p) {\n    \n    vec3 q = mod(p,4.0)-2.0;\n    \n    return abs(shape(q,sin(iTime)*0.5+0.5, cos(iTime)*0.5+0.5)-0.2);\n}\n\nfloat sdftest(vec3 p) {\n    vec3 sph = getdata(sphere).xyz;\n    \n    if (sph == vec3(0)) return FAR;\n    \n    float size = scene(sph);\n    \n    return length(p-sph)-size;\n}\n\nfloat map(vec3 p) {\n    \n    float l = scene(p);\n    \n    l = min(l,abs(sdftest(p)));\n    \n    return l-0.001;\n}\n\nint getsurface(vec3 p) {\n    \n    if (scene(p) < 0.002) return 1;\n    \n    return 2;\n}\n\nvec3 getnormal(vec3 p) {\n    vec2 e = vec2(0,0.001);\n    \n    return normalize(vec3(\n        map(p+e.yxx)-map(p-e.yxx),\n        map(p+e.xyx)-map(p-e.xyx),\n        map(p+e.xxy)-map(p-e.xxy)));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    \n    float d = 0.0;\n    \n    for (int i = 0; i < 1000; i++) {\n        float l = map(ro+rd*d);\n        \n        if (l < 0.001 || d > FAR) {\n            return d;\n        }\n        \n        d += l;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = getdata(campos).xyz;\n    vec3 rd = normalize(vec3(uv,1));\n\n    vec4 rotcam = getdata(camrot);\n\n    rd.zy *= rot(rotcam.y);\n    rd.zx *= rot(rotcam.x);\n    \n    float l = march(ro,rd);\n    \n    vec3 col = -rd*0.25+0.25;\n    \n    if (l < FAR) {\n        vec3 p = ro+rd*l;\n        int id = getsurface(p);\n        vec3 n = getnormal(p);\n            \n        float a = max(0.1,dot(n,normalize(vec3(1))));\n\t\t\n        a /= (l*l*0.005+1.0);\n        \n        if (id == 1) {\n            col = n*0.5+0.5;\n        } else {\n            col = vec3(a);\n        }\n        \n        float b = max(scene(p),sdftest(p));\n        b = max(1.0-b*b*1000.0,0.0);\n        \n        col = mix(col,vec3(1),b);\n    }\n\t\n    fragColor.rgb = pow(col,vec3(1.0/2.2));    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat getkey(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\nvec4 updatedata(int index) {\n    vec4 data = getdata(index);\n    \n    vec4 iMouse2 = getdata(lastmouse);\n    \n    \n    bool refresh = iFrame == 0;\n    \n    if (index == lastmouse) {\n        return iMouse;\n    } else if (index == campos) {\n        \n        if (refresh) {\n            return vec4(vec3(0),1);\n        }\n        \n        vec4 rotcam = getdata(camrot);\n        \n        vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                         getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                         getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n        \n        move.zy *= rot(rotcam.y);\n        move.zx *= rot(rotcam.x);\n        \n        vec3 newpos = data.xyz+movespeed*move*iTimeDelta;\n        \n        data.xyz = newpos;\n        \n        return data;\n    } else if (index == camrot) {\n        \n        if (refresh) {\n            return vec4(0,0,0,0);\n        }\n        \n        if (min(iMouse2.z,iMouse.z) > 0.5) {\n            data.xy += (iMouse.xy-iMouse2.xy)/iResolution.y*sensitivity;\n        }\n        \n        return data;\n    } else if (index == sphere) {\n        \n        if (refresh) {\n            return vec4(0,0,0,0);\n        }\n        \n        if (getkey(KEY_SPACE,0) > 0.5) {\n            data = getdata(campos);\n        }\n        \n        return data;\n    }\n    \n    \n    return data;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = updatedata(coord.x+coord.y*int(iResolution.x));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define lastmouse 0\n#define campos 1\n#define camrot 2\n#define sphere 3\n\n#define pi acos(-1.0)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define sc(a) vec2(sin(a),cos(a))\n#define sqr(a) (a*a)\n\n#define FAR 100.0\n\n#define sensitivity 3.0\n#define movespeed 2.0\n\n//keyboard keys\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_RIGHT 39\n#define KEY_LEFT  37\n#define KEY_SHIFT 16\n#define KEY_CTRL  17\n#define KEY_SPACE 32\n\n//movement keys\n#define MOVE_FORW   KEY_UP\n#define MOVE_LEFT   KEY_LEFT\n#define MOVE_RIGHT  KEY_RIGHT\n#define MOVE_BACK   KEY_DOWN\n#define MOVE_UP     KEY_SHIFT\n#define MOVE_DOWN   KEY_CTRL\n\n\n\n/*\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n\tfloat tN = max(max( t1.x, t1.y ), t1.z);\n\tfloat tF = min(min( t2.x, t2.y ), t2.z);\n\n\treturn vec2(max(tN,0.0), tF);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat smax( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//cone distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\n//cone distance modified to be more accurate at the top of the cone, not used\nfloat cone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xz);\n    \n    vec2 q2 = vec2(max(dot(vec2(-c.y,c.x),vec2(q,p.y)),0.0),\n                   dot(c,vec2(q,p.y)));\n    return length(q2)*sign(q2.y);\n    \n    if (dot(vec2(-c.y,c.x),vec2(q,p.y)) < 0.0) {\n        return dot(c,vec2(q,p.y));\n    } else {\n        return length(vec2(q,p.y));\n    }\n}\n\n//cylinder distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat cylinder( vec3 p, vec2 s)\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(max(abs(q)-s,0.0));\n}\n\n//torus distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat torus( vec3 p, float s)\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(abs(q)-vec2(s,0));\n}\n\nfloat halftorus(vec3 p,float s)\n{\n    float len = abs(length(vec2(p.x,min(p.y,0.0)))-s);\n    return length(vec3(len,max(p.y,0.0),p.z));\n}\n\n//box distance by iq\n//https://iquilezles.org/articles/distfunctions\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat box2(vec3 p) {\n    return length(max(p,0.0))+min(0.0,max(max(p.x,p.y),p.z));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    return box2(abs(p)-b);\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// special cone with a bottom\nfloat cone( vec3 p, vec2 c, float bot)\n{\n    p.x = length(p.xz); //for 3d\n    \n    float l = dot(c,p.xy);\n    \n    vec2 q = p.xy-c*l;\n    \n    if (q.x < 0.0) {\n        l = length(p.xy)*sign(p.y);\n    } else if (q.y < -bot && p.x > c.y/c.x*bot) {\n        l = length(p.xy-vec2(c.y/c.x*bot,-bot));\n    } else if (l < 0.0) {\n        l = max(l,-p.y-bot);\n    }\n    \n    return l;\n}\n\nfloat pie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat pizza(vec3 p, vec2 c, float r, float h) {\n    \n    vec2 q;\n    q.y = abs(p.y)-h;\n    q.x = pie(p.xz,c,r);\n    \n    return length(max(q,0.0));\n    \n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat char(vec3 p) {\n    \n    float l = capsule(p,vec3(0,2,-1),vec3(0,2,1))-0.9;\n    //l = min(l, length(p-head)-0.5);\n    \n    vec3 headp = vec3(0,3,4);\n    \n    l = smin(l,capsule(p,vec3(0,2,1.2),headp)-0.4,0.2);\n    \n    vec3 q = p-headp;\n    q.xz *= rot(pi*0.6);\n    q.yz *= rot(pi*0.0);\n    q.xy *= rot(pi*0.65);\n    \n    float head = pizza(q-vec3(0,-0.2,-1.0),sc(0.4),1.2, 0.18)-0.05;\n    \n    head = smin(head, length(q-vec3(0,-0.3,0))-0.5,0.1);\n    \n    l = smin(l,head,0.05);\n    \n    return l;\n    \n}\n\nfloat mid(vec3 p) {\n    p = max(p,p.yzx);\n    \n    return min(min(p.x,p.y),p.z);\n}\n\nvec3 mmid(vec3 p) {\n    return   p.x<min(p.y,p.z) ? p.y<p.z ? vec3(0,1,0) : vec3(0,0,1)\n           : p.x>max(p.y,p.z) ? p.y>p.z ? vec3(0,1,0) : vec3(0,0,1)\n           : vec3(1,0,0);\n}\n\nfloat menger(vec3 p) {\n    vec3 d = abs(p)-0.5;\n    \n    for (float s = 1.0; s < 10.0; s *= 3.0) {\n        \n        vec3 f = clamp(floor((p+0.5/s)*s),1.0-s,s-1.0)/s;\n        \n        vec3 q = abs(p-f);\n        \n        q = (1.0/s)/6.0-q;\n        \n        vec3 m = vec3(greaterThan(q,max(q.yzx,q.zxy)));\n        \n        q *= 1.0-m;\n        d = max(d,q);\n    }\n    \n    \n    \n    return box2(d);\n}\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltBzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 150], [152, 152, 190, 190, 1016], [1018, 1018, 1039, 1039, 1149], [1151, 1151, 1174, 1174, 1323], [1325, 1325, 1344, 1344, 1437], [1439, 1439, 1463, 1463, 1525], [1527, 1527, 1551, 1551, 1720], [1722, 1722, 1753, 1753, 1975], [1977, 1977, 2034, 2084, 2906]], "test": "untested"}
{"id": "3lKSz3", "name": "glitch: cyberpunk text", "author": "hornet", "description": "saibapankg", "tags": ["text"], "likes": 25, "viewed": 1161, "published": 3, "date": "1583484836", "time_retrieved": "2024-07-30T21:20:12.627055", "image_code": "vec4 shampain_glitch( vec2 p, float GLITCH, float rndx )\n{\n    vec2 ssuv = p.xy;\n    p *= iResolution.xy;\n    \n    float in_time = mod(iTime,40.0);\n    \n    //fragColor = texture( iChannel3, ssuv ); return;\n    \n    float aspect = iResolution.x / iResolution.y;\n\tvec2 uv = p.xy / iResolution.xy;\n    //uv.y = 1.0 - uv.y;\n\t\n\tfloat time = mod( in_time, 32.0); // + modelmat[0].x + modelmat[0].z;\n        \n\tfloat gnm = sat( GLITCH );\n\tfloat rnd0 = rand( mytrunc( vec2(time, time), 6.0 ) );\n\tfloat r0 = sat((1.0-gnm)*0.7 + rnd0);\n\tfloat rnd1 = rand( vec2(mytrunc( uv.x, 10.0*r0 ), time) ); //horz\n\t//float r1 = 1.0f - sat( (1.0f-gnm)*0.5f + rnd1 );\n\tfloat r1 = 0.5 - 0.5 * gnm + rnd1;\n\tr1 = 1.0 - max( 0.0, ((r1<1.0) ? r1 : 0.9999999) ); //note: weird ass bug on old drivers\n\tfloat rnd2 = rand( vec2(mytrunc( uv.y, 40.0*r1 ), time) ); //vert\n\tfloat r2 = sat( rnd2 );\n\n\tfloat rnd3 = rand( vec2(mytrunc( uv.y, 10.0*r0 ), time) );\n\tfloat r3 = (1.0-sat(rnd3+0.8)) - 0.1;\n\n\tfloat pxrnd = rand( uv + time );\n\n\tfloat ofs = 0.05 * r2 * GLITCH * ( rnd0 > 0.5 ? 1.0 : -1.0 );\n\tofs += 0.5 * pxrnd * ofs;\n\n\tuv.y += 0.1 * r3 * GLITCH;\n\n    const int NUM_SAMPLES = 10;\n    const float RCP_NUM_SAMPLES_F = 1.0 / float(NUM_SAMPLES);\n    \n\tvec4 sum = vec4(0.0);\n\tvec3 wsum = vec3(0.0);\n\tfor( int i=0; i<NUM_SAMPLES; ++i )\n\t{\n\t\tfloat t = float(i) * RCP_NUM_SAMPLES_F;\n\t\tuv.x = sat( uv.x + ofs * t );\n\t\tvec4 samplecol = texture( iChannel3, uv, -10.0 );\n        if (rndx > 0.7 && rndx < 0.75 )\n            samplecol = (2.0-2.0*samplecol) * vec4( 0.1, 0.2*rnd1, 0.5*rnd1, 1.0 );\n\t\tvec3 s = spectrum_offset_rgb( t );\n\t\tsamplecol.rgb = samplecol.rgb * s;\n\t\tsum += samplecol;\n\t\twsum += s;\n\t}\n\tsum.rgb /= wsum;\n\tsum.a *= RCP_NUM_SAMPLES_F;\n\n    //fragColor = vec4( sum.bbb, 1.0 ); return;\n    \n    vec4 outcol;\n    \n\toutcol.a = sum.a;\n\toutcol.rgb = sum.rgb; // * outcol0.a;\n    \n    return outcol;\n}\n\n//#define CANCELLED 1\n\nvec2 calc_glitch_uv( vec2 ssuv, out float rnd0, out float GLITCH )\n{\n    float in_time = mod(iTime, 40.0 );\n\n\n    #ifndef CANCELLED\n    //TODO: some minor glitch in base...\n    GLITCH = max( 0.1, 10.0 - in_time*in_time );\n\n    if ( in_time > 30.0 )\n        GLITCH = clamp( in_time-20.0, 0.0, 20.0 );\n    #else\n    GLITCH = 0.4;\n    \n    #endif //CANCELLED\n    \n    float GLITCHs = clamp( GLITCH, 0.0, 1.0);\n    \n    //DBG\n    //GLITCH = 0.1;\n\n    if ( iMouse.z > 0.5 )\n    \tGLITCH = 0.05 + 20.0 * iMouse.x / iResolution.x;\n\n    \n    float time = mytrunc( in_time, 10.0 );\n    float ftime = fract( time );\n    \n    float rndt = hashf( uint(1337.0*ftime) );\n    \n    #ifdef CANCELLED\n    GLITCH = 1.0 - clamp( 2.0*hashf(mytrunc(in_time,1.0)*1227.0), 0.0, 1.0);\n    #endif\n    \n    float sign0 = -1.0 + 2.0 * step( rndt, 0.5 );\n    vec2 uv0 = mytrunc( ssuv, vec2(64.0) );\n    float seed0 = uv0.y + sign0*3.0/32.0*(1.0+uv0.x)*uv0.y;\n    seed0 = mytrunc( seed0, 16.0 );\n\n    rnd0 = hashf( seed0 + fract(0.39*time) );\n    float rnd1 = hashf( rnd0 );\n\n    float rnd0v = rnd0;\n    rnd0 = mix( 0.0, rnd0, GLITCH );\n    \n    float maxofs = 5.0 / iChannelResolution[0].x;\n    float mask = step(0.98, rnd0);\n    vec2 uv1 = ssuv;\n\n    //note: offset-glitch\n    uv1 += maxofs * mask;\n\n    //invert sometimes\n    if(rnd0v>(1.0-0.03*GLITCHs))\n        uv1 = 1.0 - uv1;\n    \n    if (rnd0v>0.1 && rnd0v<(0.1+0.05*GLITCHs) )\n    \tuv1 *= mix( 1.0, 1.5, GLITCH );\n    \n    if (rnd0v>0.5 && rnd0v<0.5+0.05*GLITCHs)\n    \tuv1 *= mix( 1.0, 0.5, GLITCH );\n    \n    return uv1;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy; \n    \n    //fragColor = texture( iChannel0, fragCoord.xy / iResolution.xy ); return;\n    //fragColor = texture( iChannel1, fragCoord.xy / iResolution.xy ); return;\n    //fragColor = texture( iChannel2, fragCoord.xy / iResolution.xy ); return;\n    //fragColor = texture( iChannel3, fragCoord.xy / iResolution.xy ); return;\n\n    //TODO:\n    {\n        vec2 target_uv = uv43_from_fragcoord( fragCoord.xy, iResolution.xy );\n        if ( target_uv.x > 1.0 )\n        {\n            fragColor = vec4(0,0,0,1); return;\n        }\n        //fragColor = vec4( target_uv, 0, 1); return;\n    }\n\n    float rnd0, GLITCH;\n    vec2 uv1 = calc_glitch_uv( ssuv, rnd0, GLITCH );\n    \n\tfragColor = shampain_glitch( uv1, mix( 0.0, rnd0*rnd0, sat(GLITCH-0.2) ), rnd0 );\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const uint texw = 16u;\nconst uint texh = 16u;\n\nvec2 idx_to_ofs( uint idx )\n{\n    return vec2( float(idx % texw)/float(texw), float(idx/texw)/float(texh) );\n}\n\n#define _A (11*16+1)\n#define _B (11*16+2)\n#define _C (11*16+3)\n#define _D (11*16+4)\n#define _E (11*16+5)\n#define _F (11*16+6)\n#define _G (11*16+7)\n#define _H (11*16+8)\n#define _I (11*16+9)\n#define _J (11*16+10)\n#define _K (11*16+11)\n#define _L (11*16+12)\n#define _M (11*16+13)\n#define _N (11*16+14)\n#define _O (11*16+15)\n#define _P (10*16+0)\n#define _Q (10*16+1)\n#define _R (10*16+2)\n#define _S (10*16+3)\n#define _T (10*16+4)\n#define _U (10*16+5)\n#define _V (10*16+6)\n#define _W (10*16+7)\n#define _X (10*16+8)\n#define _Y (10*16+9)\n#define _Z (10*16+10)\n\n// #define _s = star\n#define _h (13*16+3)\n// #define _c = colon\n\n#define __ (16*5+13)\n\n#define _0 (16*12+0)\n#define _1 (16*12+1)\n#define _2 (16*12+2)\n#define _3 (16*12+3)\n#define _4 (16*12+4)\n#define _5 (16*12+5)\n#define _6 (16*12+6)\n#define _7 (16*12+7)\n#define _8 (16*12+8)\n#define _9 (16*12+9)\n\n// C Y B E R P U N K\n// E R R O R\n\nuint map_idx( int screen_idx, float time )\n{\n    //return uint(screen_idx);\n    \n    int luterr[40*30] = int[](\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _h,__,_A,_N,__,_E,_X,_C,_E,_P,_T,_I,_O,_N,__,_O,_C,_C,_U,_R,_R,_E,_D,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,_C,_P,_U,__,__,__,__,_T,_Y,_R,_E,_L,_L,_C,_O,_R,_E,_2,_0,_2,_0,__,__,__,__,__,__,__,\n        __,_E,_X,_C,_E,_P,_T,_I,_O,_N,__,_T,_Y,_P,_E,__,__,__,__,_P,_R,_E,_F,_E,_T,_C,_H,__,_A,_B,_O,_R,_T,__,__,__,__,__,__,__,\n        __,__,__,_F,_A,_U,_L,_T,__,_S,_T,_A,_T,_U,_S,__,__,__,__,_D,_E,_B,_U,_G,__,_E,_V,_E,_N,_T,__,__,__,__,__,__,__,__,__,__,\n        _C,_U,_R,_R,_E,_N,_T,__,_P,_R,_O,_C,_E,_S,_S,__,__,__,__,_F,_S,__,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,__,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,__,\n        _R,_0,__,__,__,__,__,__,__,__,_0,_0,_0,_0,_0,_2,_0,_0,__,__,__,_R,_1,__,__,__,__,__,__,__,_1,_F,_F,_8,_2,_5,_8,_0,__,__,\n        _R,_2,__,__,__,__,__,__,__,__,_0,_0,_1,_5,_0,_A,_A,_0,__,__,__,_R,_3,__,__,__,__,__,__,__,_0,_0,_6,_4,_2,_5,_9,_8,__,__,\n        _R,_4,__,__,__,__,__,__,__,__,_1,_F,_F,_8,_2,_4,_8,_0,__,__,__,_R,_5,__,__,__,__,__,__,__,_0,_0,_0,_0,_0,_0,_0,_0,__,__,\n        _R,_6,__,__,__,__,__,__,__,__,_F,_F,_F,_7,_B,_B,_5,_C,__,__,__,_R,_7,__,__,__,__,__,__,__,_0,_0,_0,_0,_0,_0,_0,_2,__,__,\n        _R,_8,__,__,__,__,__,__,__,__,_0,_0,_0,_0,_0,_0,_2,_4,__,__,__,_S,_P,__,__,__,__,__,__,__,_F,_F,_4,_0,_F,_C,_B,_0,__,__,\n        _L,_R,__,__,__,__,__,__,__,__,_F,_F,_F,_2,_3,_B,_4,_C,__,__,__,_P,_C,__,__,__,__,__,__,__,_D,_E,_A,_D,_B,_E,_E,_F,__,__,\n        _C,_P,_S,_R,__,__,__,__,__,__,_8,_0,_0,_0,_0,_1,_1,_3,__,__,__,_F,_P,_E,_X,_C,__,__,__,__,_0,_0,_0,_0,_0,_0,_0,_0,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _S,_T,_A,_C,_K,_D,_U,_M,_P,__,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_B,_0,__,__,_D,_8,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_1,__,_0,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_B,_8,__,__,_0,_1,__,_0,_0,__,_0,_0,__,_0,_0,__,_9,_C,__,_0,_1,__,_F,_2,__,_F,_F,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_C,_0,__,__,_F,_F,__,_6,_F,__,_0,_0,__,_0,_4,__,_4,_C,__,_C,_1,__,_F,_9,__,_F,_F,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_C,_8,__,__,_C,_4,__,_F,_C,__,_4,_0,__,_0,_0,__,_1,_8,__,_5,_C,__,_F,_7,__,_F,_F,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_D,_0,__,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,_F,_D,__,_4,_0,__,_F,_F,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_D,_8,__,__,_4,_C,__,_5,_C,__,_F,_7,__,_E,_E,__,_8,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_E,_0,__,__,_0,_0,__,_7,_0,__,_0,_0,__,_2,_E,__,_0,_A,__,_4,_0,__,_D,_5,__,_E,_E,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_E,_8,__,__,_F,_8,__,_B,_0,__,_1,_8,__,_F,_F,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_F,_0,__,__,_0,_0,__,_0,_0,__,_0,_0,__,_F,_F,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_F,_8,__,__,_0,_0,__,_0,_0,__,_0,_0,__,_1,_F,__,_4,_C,__,_1,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_D,_0,_0,__,__,_0,_1,__,_0,_0,__,_0,_0,__,_0,_0,__,_1,_C,__,_5,_C,__,_F,_7,__,_F,_F,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__\n    );\n    \n    int lut[40*30] = int[](\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __\n    );\n\n\t//note: https://www.dafont.com/5x5.font\n    int lut_cancelled[40*30] = int[] (\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K,__, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K,__, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K,__, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,_h,_h,__,__,_h,_h,_h,__,_h,_h,__,__,_h,_h,_h,__,_h,__,_h,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,_h,__,_h,__,_h,__,_h,__,_h,__,_h,__,__,_h,__,__,_h,__,_h,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,_h,_h,__,__,_h,__,_h,__,_h,_h,__,__,__,_h,__,__,__,_h,__,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,_h,__,__,__,_h,_h,_h,__,_h,__,_h,__,__,_h,__,__,__,_h,__,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,_h,__,__,__,_h,__,_h,__,_h,__,_h,__,__,_h,__,__,__,_h,__,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,_h,_h,_h,__,_h,_h,_h,__,_h,__,__,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,__,__,__,_h,__,__,__,_h,_h,_h,__,_h,_h,_h,__,__,\n    \t__,__,_h,__,__,__,_h,__,_h,__,_h,_h,__,_h,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,_h,__,\n    \t__,__,_h,__,__,__,_h,__,_h,__,_h,__,_h,_h,__,_h,__,__,__,_h,_h,__,__,_h,__,__,__,_h,__,__,__,_h,_h,__,__,_h,__,__,_h,__,\n    \t__,__,_h,__,__,__,_h,_h,_h,__,_h,__,_h,_h,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,_h,__,\n    \t__,__,_h,_h,_h,__,_h,__,_h,__,_h,__,__,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,_h,_h,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        \n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,        \n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __\n    );\n        \n    int ii = screen_idx % (40*30);\n    uint i0 = uint( luterr[ ii ] );\n    uint i1 = uint( lut[ ii ] );\n\t//uint i2 = uint( lut_cancelled[ii] ); return i2;\n    \n    float t0 = clamp( time-30.0 + 0.25*float(screen_idx)/(40.0*30.0), 0.0, 1.0 );\n    uint idx = uint( mix( float(i0), float(i1), t0 ) );\n    \n    float t1 = clamp( time-32.0 + 0.25*float(screen_idx)/(40.0*30.0), 0.0, 1.0 );\n    idx = uint( mix( float(idx), float(__), t1 ) );\n    \n    return idx;\n}\n\nvec4 render_text( vec2 ssuv, vec2 fragCoord )\n{\n    vec4 fragColor = vec4(0.0);\n\n    float in_time = mod( iTime, 40.0 );\n\n    const uint w = 40u;\n    const uint h = 30u;\n    int idx = int( ssuv.x * float(w) ) + int(w) * int((1.0-ssuv.y)*float(h));\n    //fragColor = vec4( vec3(idx)/float(w*h), 1.0); return;\n    \n    vec2 luv = fract( ssuv * vec2(w,h) );\n    luv = luv / vec2(texw, texh);\n\n    float frq = 10.0 + 5.0 * hashf( uint(idx) );\n    \n    uint rnd_idx_u = hash( uint(idx) + hash( uint(idx) + uint(float(iFrame+1000)/frq)) );\n    float rnd_idx = toFloat( rnd_idx_u );\n    \n    float rnd_t = hashf( uint(1337.0*in_time) );\n    \n    float timeScale = 0.5;\n    uint rnd = hash( uint(idx) + uint( timeScale * in_time ) );\n    float rndf = toFloat( rnd );\n    \n    uint scl = texw*texh;\n    uint letteridx = map_idx(idx, in_time);\n    \n    float time_total_s = 20.0;\n    float time_per_idx_s = float(w*h) / time_total_s;\n    const float speed = 175.0;\n    float time = (in_time+0.75)*speed;\n\n    //int curidx = int(time) % int(w*h);\n    int curidx = min( int(time), int(w*h + 80u) );\n    float curidx_t = float(curidx) * time_per_idx_s;\n    \n    float idx_t = float(idx) * time_per_idx_s;\n\n    float dt = curidx_t - idx_t;\n    \n    float glitchmask = dt / (80.0*time_per_idx_s);\n    \n    glitchmask = min( glitchmask, 0.995 );\n    \n    float glitch = step( glitchmask, rnd_idx );\n\n    float m_visible = (dt>-0.5) ? 1.0 : 0.0;\n    \n    if ( glitch > 0.5 )\n    {\n        letteridx = hash( uint(idx*1337) + uint(iFrame/2) ) % (w*h);\n        \n        m_visible += step(rnd_idx, 0.001);\n    }\n    \n    vec2 ofs = idx_to_ofs( letteridx );\n\n    vec3 s = textureLod( iChannel0, ofs + luv, 0.0 ).rgb;\n    float txtmask = remap( s.x, 0.0, 0.8, 1.0, 0.0 );\n    \n    float v = txtmask;\n    \n    float p0 = 0.0;\n    {\n        const float PI = 3.1415926435;\n        const float waves = 44.0;\n        const int NUM_ITER = 8;\n        //note: approx square-wave\n        for ( int i=1; i<NUM_ITER; i+=2 )\n             p0 += (float(i)/float(NUM_ITER)) * sin(float(i)*PI * (waves*ssuv.y) );\n        p0 = remap( p0, 0.0, 1.0, 0.6, 1.0 );\n    }\n    \n    v = 1.0 - v;\n    v = min( v, p0 );\n    \n    if ( dt <= 3.5 && dt > -0.1 )\n    {\n        v = 1.0 - v * mix( 0.1, 1.0, rnd_t );\n        v *= 2.0;\n    }\n    \n    v *= m_visible;\n\n    vec4 c = vec4( vec3(v), 1.0 );\n\n    //note: feedback\n    if ( iFrame > 0 )\n    {\n        vec4 prev = texture( iChannel1, fragCoord.xy/iResolution.xy );\n        c = mix( c, prev, 0.5 );\n    }\n\n    \n    fragColor = c;\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4( fragCoord/iResolution.xy, 0, 1.0); return;\n\n    vec2 target_uv = uv43_from_fragcoord( fragCoord.xy, iResolution.xy );\n    if ( target_uv.x > 1.0 )\n    {\n        fragColor = vec4(0,0,0,1); return;\n    }\n\n    vec2 ssuv = target_uv; //fragCoord/iResolution.xy;\n \n    fragColor = render_text( ssuv, fragCoord );\n}\n", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//note: from https://www.shadertoy.com/view/WttXWX , bias: 0.020888578919738908 = minimal theoretic limit\nuint hash(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat toFloat( uint x )\n{\n    return float(x) / 4294967296.0;\n    //return uintBitsToFloat(x) / 4294967296.0;\n}\nfloat hashf( uint x )\n{\n    return toFloat( hash( x ) );\n}\n\nfloat hashf( float x )\n{\n    return hashf( floatBitsToUint( x ) );\n}\n\nfloat remap( float x, float imn, float imx, float omn, float omx )\n{\n    return omn + (omx-omn)*clamp(x-imn, 0.0, 1.0) / (imx-imn);\n}\n\nvec2 uv43_from_fragcoord( vec2 fc, vec2 res )\n{\n    //float ss_aspect = res.x / res.y;\n    const float target_aspect = 4.0/3.0;\n    vec2 target_res = vec2( res.y * target_aspect, res.y );\n    vec2 target_uv = fc.xy / target_res;\n\n    return target_uv;\n}\n\nfloat mytrunc( float x, float num_levels )\n{\n\treturn floor(x*num_levels) / num_levels;\n}\nvec2 mytrunc( vec2 x, float num_levels )\n{\n\treturn floor(x*num_levels) / num_levels;\n}\n\nvec2 mytrunc( vec2 x, vec2 num_levels )\n{\n\treturn floor(x*num_levels+0.5) / num_levels;\n}\n\n\n//note: input [0;1]\nvec3 spectrum_offset_rgb( float t )\n{\n    float t0 = 3.0 * t - 1.5;\n\treturn clamp( vec3( -t0, 1.0-abs(t0), t0), 0.0, 1.0);\n}\n\nfloat sat( float t ) {\n\treturn clamp( t, 0.0, 1.0 );\n}\n\nvec2 sat( vec2 t ) {\n\treturn clamp( t, 0.0, 1.0 );\n}\n\n//remaps inteval [a;b] to [0;1]\nfloat remap  ( float t, float a, float b ) {\n\treturn sat( (t - a) / (b - a) );\n}\n\n//note: /\\ t=[0;0.5;1], y=[0;1;0]\nfloat linterp( float t ) {\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n}\n\n//note: [0;1]\nfloat rand( vec2 n ) {\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n//note: [-1;1]\nfloat srand( vec2 n ) {\n\treturn rand(n) * 2.0 - 1.0;\n}\n\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n        \n    float rnd = hashf( uint(1337*iFrame) + uint(fragCoord.y) + hash(uint(fragCoord.x)) );\n    \n    const int NUM_SAMPLES = 8;\n    float blurdist_px = 2.0 * float( textureSize(iChannel0, 0).y );\n    vec2 blurdir_px = vec2(0,blurdist_px);\n    vec2 stepvec_px = blurdir_px / float(NUM_SAMPLES);\n    \n    //TODO: convert to normalized\n    vec2 p = fragCoord.xy;\n    p -= 0.5 * blurdir_px;\n    p += blurdir_px * rnd / float(NUM_SAMPLES);\n    \n    vec3 sumc = vec3(0.0);\n    float sumw = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        vec2 uv = p / iResolution.xy;\n        float w = 1.0;\n    \tsumc += w * texture( iChannel0, uv ).rgb; //TODO: black if outside\n        sumw += w;\n        p += stepvec_px;\n    }\n    sumc /= sumw;\n \n    //note: feedback\n    if ( iFrame > 0 )\n    {\n        vec3 prev = texture( iChannel1, ssuv ).rgb;\n        sumc = mix( sumc, prev, 0.9 );\n    }\n\n    \n    fragColor = vec4(sumc, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//TODO: should probably also downsample...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n        \n    float rnd = hashf( uint(1337*iFrame) + uint(fragCoord.y) + hash(uint(fragCoord.x)) );\n    \n    const int NUM_SAMPLES = 8;\n    float blurdist_px = 50.0; //0.5 * float( textureSize(iChannel0, 0).y );\n    vec2 blurdir_px = vec2(0,blurdist_px);\n    vec2 stepvec_px = blurdir_px / float(NUM_SAMPLES);\n    \n    //TODO: convert to normalized\n    vec2 p = fragCoord.xy;\n    p -= 0.5 * blurdir_px;\n    p += blurdir_px * rnd / float(NUM_SAMPLES);\n    \n    vec3 sumc = vec3(0.0);\n    float sumw = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        vec2 uv = p / iResolution.xy;\n        float w = 1.0;\n    \tsumc += w * texture( iChannel0, uv ).rgb; //TODO: black if outside\n        sumw += w;\n        p += stepvec_px;\n    }\n    sumc /= sumw;\n    \n    \n    fragColor = vec4(sumc, 1.0);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n        \n    float rnd = hashf( uint(1227*iFrame) + uint(fragCoord.y) + hash(uint(fragCoord.x)) );\n    \n    const int NUM_SAMPLES = 8;\n    float blurdist_px = 100.0; //0.5 * float( textureSize(iChannel0, 0).y );\n    vec2 blurdir_px = vec2(blurdist_px, 0);\n    vec2 stepvec_px = blurdir_px / float(NUM_SAMPLES);\n    \n    //TODO: convert to normalized\n    vec2 p = fragCoord.xy;\n    p -= 0.5 * blurdir_px;\n    p += blurdir_px * rnd / float(NUM_SAMPLES);\n    \n    vec3 sumc = vec3(0.0);\n    float sumw = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        vec2 uv = p / iResolution.xy;\n        float w = 1.0;\n    \tsumc += w * texture( iChannel2, uv ).rgb; //TODO: black if outside\n        sumw += w;\n        p += stepvec_px;\n    }\n    sumc /= sumw;\n\n    vec3 s = sumc;\n\n    vec3 sA = texture( iChannel0, ssuv).rgb;\n    vec3 sB = texture( iChannel1, ssuv).rgb;\n    \n    s = sA + sB + sumc;\n\n    \n    fragColor = vec4(s, 1.0);\n}\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKSz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 1870], [1895, 1895, 1963, 1963, 3450], [3452, 3452, 3509, 3509, 4303]], "test": "untested"}
{"id": "tlyXDG", "name": "Foam Simulation", "author": "wyatt", "description": "Triangulated particle simulation + Fluid simulation", "tags": ["particles", "triangulation"], "likes": 38, "viewed": 1178, "published": 3, "date": "1583470245", "time_retrieved": "2024-07-30T21:20:13.395002", "image_code": "// Fork of \"Triangulated Actors****\" by wyatt. https://shadertoy.com/view/ttGXDG\n// 2020-03-06 04:21:54\n\nMain \n    vec4 b = B(U),\n         a = A(b.xy), aa = A(b.zw);\n    \n    float \t\n          r = length(a.xy-aa.xy), \n          o = length(U-a.xy),\n          w = sg(U,a.xy,aa.xy),\n          v = pie(U,a.xy,aa.xy);\n    \n    Q = 0.5+0.5*smoothstep(12.,8.,min(r,10.*o))*\n        smoothstep(3.,0.,w)*\n        vec4(.9,0.8,1,1);\n    Q = 0.5+0.5*sin(1.+3.1*Q+2.*abs(D(U).z));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U) { U = gl_FragCoord.xy;\n#define Init if (iFrame < 1) \n#define init  (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} ", "buffer_a_code": "// Information Storage\nMain \n\tvec2 u = floor(U/8.+0.5)*8.;\n    u = clamp(u,vec2(10),R-10.);\n    Q = A(U);\n    Q.zw = C(Q.xy).zw;\n    for (int x = -2; x <= 2; x++)\n    for (int y = -2; y <= 2; y++)\n    Q.zw += C(Q.xy+vec2(x,y)).xy;\n    Q.zw += 1e-6*sin(u);\n    if (length(Q.zw)>.8) Q.zw = 0.8*normalize(Q.zw);\n    Q.xy += Q.zw;\n    \n    if (Q.x<5.)Q.x=5.;\n    if (Q.y<5.)Q.y=5.;\n    if (R.x-Q.x<5.)Q.x=R.x-5.;\n    if (R.y-Q.y<5.)Q.y=R.y-5.;\n\n\tif (Q.x<1.&&Q.y<1.) Q = 10.*R.xyxy;    \n    if (init)\n    {\n    \t\n        Q = vec4(u,0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// SORT TRIANGULATION\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 aa, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    float ln = length(n.xy-U), la = length(a.xy-U);\n    if (ln<=la) {\n    \tQ.xy = b.xy;\n        a.xy = n.xy;\n    }\n    float pn = pie(U,a.xy,n.xy), \n          pa = pie(U,a.xy,aa.xy);\n    if (pn<=pa){\n        aa = n;\n        Q.zw = b.xy;\n    }\n\tn = A(b.zw);\n    ln = length(n.xy-U);\n    if (ln<la) {\n    \tQ.xy = b.zw;\n        a.xy = n.xy;\n    }\n    pn = pie(U,a.xy,n.xy);\n    if (pn<pa){\n        aa = n;\n        Q.zw = b.zw;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 aa, vec2 U, float r) {\n\t X(Q,a,aa,U,vec2(r,0));\n     X(Q,a,aa,U,vec2(0,r));\n     X(Q,a,aa,U,vec2(0,-r));\n     X(Q,a,aa,U,vec2(-r,0));\n}\nMain \n\tQ = B(U);\n    vec4 a = A(Q.xy), aa= A(Q.zw);\n    Xr(Q,a,aa,U,1.);\n    Xr(Q,a,aa,U,2.);\n    Xr(Q,a,aa,U,3.);\n    for (int i = 0; i < 10; i++) {\n        vec2 u = vec2(\n            (10*iFrame+i)%int(R.x),\n            (10*iFrame+i)/int(R.x)%int(R.y));\n        if (length(U-A(u).xy)<length(U-a.xy)) Q.xy = u;\n    }\n    Init {\n        Q.xy = U;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// COMPUTE FORCE FIELD\nMain \n\tvec4 b = B(U);\n\tvec4 a = A(b.xy), aa = A(b.zw);\n\tvec2 r = a.xy-aa.xy;\n\tfloat l = length(r);\n   \tvec2 v = vec2(0);\n\tif (l>2.3) \n      Q.xy = \n        0.1*(-r/l/l+20.*r/l/l/l/l);\n    \n    \n    \n    \n    Q.zw = C(U-C(U).zw).zw;\n    vec4 \n    n = D(U+vec2(0,1)),\n    e = D(U+vec2(1,0)),\n    s = D(U-vec2(0,1)),\n    w = D(U-vec2(1,0));\n    Q.zw = mix(Q.zw,\n           mix(aa.zw,a.zw,0.5+0.5*pie(U,a.xy,aa.xy)),\n           smoothstep(2.5,1.5,sg(U,a.xy,aa.xy))*\n           smoothstep(12.,8.,min(length(aa.xy-a.xy),10.*length(U-a.xy)))\n    );\n    Q.zw -= 0.25*vec2(e.z-w.z,n.z-s.z);\n    if (length(Q.zw)>0.8) Q.zw = 0.8*normalize(Q.zw);\n    if (iMouse.z>0.&&length(a.xy-iMouse.xy)>0.)\n        Q -= vec4(1,1,-1,-1)*clamp(0.03*(a.xy-iMouse.xy)/dot((a.xy-iMouse.xy),(a.xy-iMouse.xy)),-2e-4,2e-4).xyxy;\n\t\n    if (U.x < 2.||U.y < 2.||R.x-U.x<2.||R.y-U.y<2.) Q.zw *= 0.;\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main \n\tQ = D(U-C(U).zw);\n    vec4 \n    n = C(U+vec2(0,1)),\n    e = C(U+vec2(1,0)),\n    s = C(U-vec2(0,1)),\n    w = C(U-vec2(1,0));\n    Q.zw = vec2(Q.z,0)-0.25*(e.z-w.z+n.w-s.w);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tlGXWG", "name": "Pore Torus", "author": "PauloFalcao", "description": "A very simple test generated in materialmaker in 1 minute with some custom nodes.\nhttps://twitter.com/paulofalcao/status/1235750994081992705\nThe displace is based on the base SDF normal.", "tags": ["displace", "generated", "materialmaker", "nodes", "everythingmaker"], "likes": 9, "viewed": 572, "published": 3, "date": "1583460968", "time_retrieved": "2024-07-30T21:20:14.210820", "image_code": "// Pore Torus\n// By PauloFalcao\n//\n// A very simple test generated in materialmaker in 1 minute\n// MaterialMaker is a nodebased shader maker to make texture, but with some custom nodes, \n// created directly in the tool, it's possible to make complex stuff like raymarching :)\n\n\nmat2 rot(float r){\n  float s=sin(r);float c=cos(r);\n  return mat2(c,-s,s,c);\n}\n\nfloat wave3d_constant(float x) {\n\treturn 1.0;\n}\n\nfloat wave3d_sine(float x) {\n\treturn 0.5-0.5*cos(3.14159265359*2.0*x);\n}\n\nfloat wave3d_triangle(float x) {\n\tx = fract(x);\n\treturn min(2.0*x, 2.0-2.0*x);\n}\n\nfloat wave3d_sawtooth(float x) {\n\treturn fract(x);\n}\n\nfloat wave3d_square(float x) {\n\treturn (fract(x) < 0.5) ? 0.0 : 1.0;\n}\n\nfloat wave3d_bounce(float x) {\n\tx = 2.0*(fract(x)-0.5);\n\treturn sqrt(1.0-x*x);\n}\n\nfloat mix3d_mul(float x, float y, float z) {\n\treturn x*y*z;\n}\n\nfloat mix3d_add(float x, float y, float z) {\n\treturn min(x+y+z, 1.0);\n}\n\nfloat mix3d_max(float x, float y, float z) {\n\treturn max(max(x, y), z);\n}\n\nfloat mix_min(float x, float y, float z) {\n\treturn min(min(x, y), z);\n}\n\nfloat mix3d_xor(float x, float y, float z) {\n\tfloat xy = min(x+y, 2.0-x-y);\n\treturn min(xy+z, 2.0-xy-z);\n}\n\nfloat mix3d_pow(float x, float y, float z) {\n\treturn pow(pow(x, y), z);\n}vec4 o354278_p_SkyColor_gradient_fct(float x) {\n  if (x < 0.000000000) {\n    return vec4(0.793357015,0.864655972,0.979166985,1.000000000);\n  } else if (x < 0.118182000) {\n    return mix(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000), mix(vec4(0.793357015,0.864655972,0.979166985,1.000000000), vec4(0.510612011,0.698400021,1.000000000,1.000000000), (x-0.000000000)/0.118182000), 1.0-0.5*(x-0.000000000)/0.118182000);\n  } else if (x < 0.411598000) {\n    return 0.5*(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000) + mix(mix(vec4(0.793357015,0.864655972,0.979166985,1.000000000), vec4(0.510612011,0.698400021,1.000000000,1.000000000), (x-0.000000000)/0.118182000), mix(vec4(0.287342012,0.329521000,0.557291985,1.000000000), vec4(0.171140000,0.209502995,0.416667014,1.000000000), (x-0.411598000)/0.533857000), 0.5-0.5*cos(3.14159265359*(x-0.118182000)/0.293416000)));\n  } else if (x < 0.945455000) {\n    return mix(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000), mix(vec4(0.287342012,0.329521000,0.557291985,1.000000000), vec4(0.171140000,0.209502995,0.416667014,1.000000000), (x-0.411598000)/0.533857000), 0.5+0.5*(x-0.411598000)/0.533857000);\n  }\n  return vec4(0.171140000,0.209502995,0.416667014,1.000000000);\n}\nfloat o354282_input_in1(vec3 p) {\nvec2 o354281_0_q = vec2(length((p).xz)-0.610000000,(p).y);\nfloat o354281_0_1_sdf3d = length(o354281_0_q)-0.360000000;\n\nreturn o354281_0_1_sdf3d;\n}\nvec3 normal_o354282(vec3 p) {\n\tfloat d = o354282_input_in1(p);\n    vec2 e = vec2(.001,0);\n    vec3 n = d - vec3(\n        o354282_input_in1(p-vec3(e.xyy)),\n        o354282_input_in1(p-vec3(e.yxy)),\n        o354282_input_in1(p-vec3(e.yyx)));\n    return normalize(n);\n}\n\nfloat o354283_fct(vec3 uv) {\n\treturn mix3d_mul(wave3d_sine(8.000000000*uv.x), wave3d_sine(8.000000000*uv.y), wave3d_sine(8.000000000*uv.z));\n}float o354278_input_sdf_a(vec3 p) {\nvec3 o354283_0_1_color3d = vec3(o354283_fct(((p)).xyz));\n\nvec3 n=normal_o354282((p));\nfloat o354282_0_in = o354282_input_in1((p)+((n*(o354283_0_1_color3d-0.5))*0.134000000));float o354282_0_1_sdf3d = max(o354282_input_in1((p))-0.134000000,o354282_0_in/((0.134000000+0.2)*10.0));\n\nreturn o354282_0_1_sdf3d;\n}\nvec4 o354284_p_g_gradient_fct(float x) {\n  if (x < 0.000000000) {\n    return vec4(1.000000000,0.906248987,0.000000000,1.000000000);\n  } else if (x < 0.079855277) {\n    return mix(mix(vec4(1.000000000,0.468750000,0.000000000,1.000000000), vec4(0.000000000,0.000000000,1.000000000,1.000000000), (x-0.079855277)/0.343188719), mix(vec4(1.000000000,0.906248987,0.000000000,1.000000000), vec4(1.000000000,0.468750000,0.000000000,1.000000000), (x-0.000000000)/0.079855277), 1.0-0.5*(x-0.000000000)/0.079855277);\n  } else if (x < 0.423043997) {\n    return 0.5*(mix(vec4(1.000000000,0.468750000,0.000000000,1.000000000), vec4(0.000000000,0.000000000,1.000000000,1.000000000), (x-0.079855277)/0.343188719) + mix(mix(vec4(1.000000000,0.906248987,0.000000000,1.000000000), vec4(1.000000000,0.468750000,0.000000000,1.000000000), (x-0.000000000)/0.079855277), mix(vec4(0.000000000,0.000000000,1.000000000,1.000000000), vec4(0.000000000,0.000000000,0.000000000,1.000000000), (x-0.423043997)/0.576956003), 0.5-0.5*cos(3.14159265359*(x-0.079855277)/0.343188719)));\n  } else if (x < 1.000000000) {\n    return mix(mix(vec4(1.000000000,0.468750000,0.000000000,1.000000000), vec4(0.000000000,0.000000000,1.000000000,1.000000000), (x-0.079855277)/0.343188719), mix(vec4(0.000000000,0.000000000,1.000000000,1.000000000), vec4(0.000000000,0.000000000,0.000000000,1.000000000), (x-0.423043997)/0.576956003), 0.5+0.5*(x-0.423043997)/0.576956003);\n  }\n  return vec4(0.000000000,0.000000000,0.000000000,1.000000000);\n}\nvec3 o354278_input_tex3d_a(vec3 p) {\np.xz*=rot(iTime*0.5);\nvec3 o354283_0_1_color3d = vec3(o354283_fct(((p)).xyz));\nvec3 o354284_0_1_color3d = o354284_p_g_gradient_fct(dot(o354283_0_1_color3d, vec3(1.0))/3.0).rgb;\n\nreturn o354284_0_1_color3d;\n}\nfloat o354278_input_sdf_b(vec3 p) {\n\nreturn ((p)).y+1.0;\n}\nvec3 o354278_input_tex3d_b(vec3 p) {\n\nreturn (vec3(mod(floor(((p)).x)+floor(((p)).z),2.0))*0.25+0.5);\n}\nvec2 input_o354278(vec3 p) {\n    p.xz*=rot(iTime*0.5);\n    float sdfa=o354278_input_sdf_a(p);\n\tfloat sdfb=o354278_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\nvec3 normal_o354278(vec3 p) {\n\tfloat d = input_o354278(p).x;\n    vec2 e = vec2(.001,0);\n    vec3 n = d - vec3(\n        input_o354278(p-vec3(e.xyy)).x,\n        input_o354278(p-vec3(e.yxy)).x,\n        input_o354278(p-vec3(e.yyx)).x);\n    return normalize(n);\n}\n\nvoid march_o354278(out float d,out vec3 p,out vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o354278(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o354278( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = input_o354278( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o354278( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o354278( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 raymarch_o354278(vec2 uv) {\n    vec3 cam=vec3(1.250000000+sin(iTime*0.25)*0.5,1.400000000+cos(iTime*0.2)*0.5,1.500000000);\n\tvec3 lookat=vec3(0.000000000,0.000000000,0.000000000);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,-1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*1.000000000+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o354278(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o354278_input_tex3d_a(p):o354278_input_tex3d_b(p);\n\tfloat fog=max(1.0-(d/50.0),0.0);\n\tvec3 light=normalize(vec3(0.950000000,1.200000000,0.400000000));\n\tif (d<50.0) {\n\t    vec3 n=normal_o354278(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tfloat r=clamp(dot(reflect(rd,-n),light),0.0,1.0);\n\t\tfloat cAO=calcAO_o354278(p,n);\n\t\tfloat shadow=calcSoftshadow_o354278(p,light,0.05,5.0);\n\t\tcolor=min(vec3(max(shadow,0.200000000)),max(l,0.200000000))*max(cAO,0.200000000)*objColor+pow(r,200.000000000)*0.850000000;\n\t} else {\n\t    color=o354278_p_SkyColor_gradient_fct(rd.y).xyz;\n\t}\n    return color*(fog)+o354278_p_SkyColor_gradient_fct(rd.y).xyz*(1.0-fog);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nvec2 UV = fragCoord/iResolution.xy-0.5;\nUV.x*=iResolution.x/iResolution.y;\nvec4 o354278_0_d = vec4(raymarch_o354278((UV)),1.0);\n\nvec4 o354278_0_1_rgba = o354278_0_d*1.3;\nfragColor = o354278_0_1_rgba;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 278, 296, 296, 356], [358, 358, 390, 390, 405], [407, 407, 435, 435, 479], [481, 481, 513, 513, 561], [563, 563, 595, 595, 615], [617, 617, 647, 647, 687], [689, 689, 719, 719, 769], [771, 771, 815, 815, 832], [834, 834, 878, 878, 905], [907, 907, 951, 951, 980], [982, 982, 1024, 1024, 1053], [1055, 1055, 1099, 1099, 1161], [1163, 1163, 1207, 1207, 1236], [1236, 1236, 1283, 1283, 2733], [2734, 2734, 2767, 2767, 2914], [2915, 2915, 2944, 2944, 3181], [3183, 3183, 3211, 3211, 3325], [3325, 3325, 3360, 3360, 3668], [3669, 3669, 3709, 3709, 5159], [5160, 5160, 5196, 5196, 5404], [5405, 5405, 5440, 5440, 5463], [5464, 5464, 5500, 5500, 5567], [5568, 5568, 5596, 5596, 5782], [5784, 5784, 5813, 5813, 6042], [6044, 6044, 6117, 6117, 6280], [6282, 6327, 6376, 6376, 6644], [6646, 6691, 6775, 6775, 7093], [7096, 7096, 7128, 7128, 8254], [8257, 8257, 8312, 8312, 8514]], "test": "untested"}
{"id": "WtGSDy", "name": "Color gradient banding", "author": "AstroSlime", "description": "Create a color gradient with banding.", "tags": ["color", "gradient"], "likes": 0, "viewed": 355, "published": 3, "date": "1583450204", "time_retrieved": "2024-07-30T21:20:15.076506", "image_code": "float colorBand1(float value, float colorSteps) {\n\treturn floor(value * colorSteps) / colorSteps;\n}\n\nfloat colorBand2(float value, float colorSteps) {\n    float currentStep;\n    float stepSize = 1.0 / colorSteps;\n    modf(value / stepSize, currentStep);\n\treturn currentStep * stepSize;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tfloat o = colorBand1(uv.y, 8.0);\n\n    // Output to screen\n    fragColor = vec4(o, o, 1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 99], [101, 101, 150, 150, 287], [289, 289, 346, 396, 539]], "test": "untested"}
{"id": "WlGXWy", "name": "Day 77", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 20, "viewed": 569, "published": 3, "date": "1583448296", "time_retrieved": "2024-07-30T21:20:15.842458", "image_code": "// Fork of \"Day 76\" by jeyko. https://shadertoy.com/view/WtyXzt\n// 2020-03-05 21:05:41\n\n// hex function from BigWIngs - check out his tutorial on youtube\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 40.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.)*0.04;\n    float chromAb = dot(uvn*1.5,uvn*1.5)*10.;\n    vec2 offs = vec2(0) + texture(iChannel1, uv + iTime*4.).xz*0.0;\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.99;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.x += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.y += texture(iChannel0, target).y;\n    \tradial.z += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    \n    \n    \n    radial /= steps;\n    \n    fragColor = texture(iChannel0, uv)*0.6 + radial*0.4; \n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    fragColor *= 0.7;\n    \n    fragColor = pow(fragColor, vec4(0.9));\n    \n    fragColor.b *= 0.5;\n    fragColor = smoothstep(0.,1.,fragColor);\n    //fragColor = pow(fragColor, vec4(0.45));\n\t\n    float duvuv = dot(uvn,uvn);\n    \n    fragColor = pow(fragColor, vec4(0.4545 + 0.87*clamp(duvuv*0.4, 0., 0.50)));\n    \n    fragColor *= 1. - duvuv*1.4;\n    \n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 glow = vec3(0);\n\nvec4 noise(vec2 u){\n\treturn texture(iChannel0, (u)/256.);\n}\n#define pmod(p,x) (mod(p,x) - 0.5*x)\n#define dmin(a,b) a.x < b.x ? a : b\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin(tau*((c)*(d) + e)))\n\n\nvec3 path(float z){\n    z *= 0.14;\n\treturn vec3(\n    \tsin(z + cos(z)*0.6),\n    \tcos(z + sin(z*0.8)*0.5),\n    \t0.\n    )*2.9;\n}\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n#define pi acos(-1.)\n#define tau (2.*pi)\nvec3 pCoords = vec3(0);\n\nfloat tCoords = 0.;\nvec3 cCoords = vec3(1.);\n\n#define coolPal(a,b) pal(0.5,0.6,vec3(0.97 + sin(iTime*0.02 + p.z*0.04),3.4 + sin(b)*0.2,0.8),0.4 + (a),3.3 + (b))\n#define tunnW 0.8\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    \n    //p.xy *= rot(0. + sin(p.z)*0.24 + cos(p.y)*0.13);\n\tp -= path(p.z);\n    p.xy *= rot(0. + sin(p.z)*0.24 + cos(p.y)*0.13);\n    //p.xy *= rot(0.6);\n\tfloat wave = pow(abs(sin(p.z*0.2 + iTime*0.7)), 40.);\n    \n    pCoords = vec3(atan(p.y,p.x)/tau, length(p.xy), p.z);\n    \n    float tunn = -length(p.xy + normalize(p.xy)*wave*0.15) + tunnW;\n    \n    //tunn = max(tunn, - max(abs(p.x)- 0.86,abs(p.y) - 0.3 ));\n    \n    d = dmin(d, vec2(tunn, 2.));\n    \n    \n    p.xy *= rot(0.5 + sin(p.z*0.2 + p.y*0.4)*1.);\n    \n    vec3 pCoordsB = pCoords;\n    pCoordsB.y -= 0.4;\n    pCoordsB.x = pmod(pCoordsB.x, 0.05)/0.05;\n    pCoordsB.z = pmod(pCoordsB.z, 1.)/1.;\n    \n    pCoordsB = abs(pCoordsB) - 0.5;\n    float dCubeGlow = max(pCoordsB.x, max(pCoordsB.y,pCoordsB.z));\n    \n    \n    glow += max(exp(-dCubeGlow*10.)*0.04*pow(wave,0.4)*pal(0.5,0.5,vec3(1.6,2.9,0.9),0.5,0.5)*0.7, 0.);\n    \n    float attA = pow(abs(sin(sin(p.z + iTime) + p.z*0.7 + sin(p.y*1.5) + iTime*0.4) ), 10.);\n    float attB = pow(abs(sin(iTime*0.2 + sin(p.z + iTime) + p.z*0.4 + sin(p.y*1.5))), 10.);\n    glow += attB*smoothstep(0.,1.,length(p.xy)*0.8)*max(exp(-dCubeGlow*12.)*0.02*pal(0.8,0.6,vec3(0.3,0.6,0.5),0.5,0.4)*2.1, 0.);\n\n    \n    vec3 c = max(coolPal(0.3, 1.5), 0.);\n    \n    vec3 q = p;\n    float pipe;\n\n    \n    \n    q = p;\n    q.xy -= 0.4;\n    pipe = length(q.xy) - 0.06;\n    d = dmin(d, vec2(pipe,10.));\n    q.xy += 0.9;\n    pipe = length(q.xy) - 0.06;\n    d = dmin(d, vec2(pipe,10.));\n    \n    \n    \n    float dtt = 10e7;\n    float dsqP = 10e6;\n    q = p;\n    q.xy -= vec2(-0.6,0.2);\n    vec3 z = abs(vec3(q.x,q.y,pmod(q.z, 0.4))) - vec3(0.1,0.04,0.2);\n    z.xy *= rot(0.125*pi);\n    float rc = max(z.y,max(z.x, z.z));\n    q = abs(q) - 0.07;\n    dtt = rc + 0.02 ;\n    pipe = max(q.x,q.y);\n    pipe = max(pipe, -rc);\n    dsqP = min(dsqP, pipe);\n    \n    q = p;\n    q.xy += vec2(-0.4,0.4);\n    z = abs(vec3(q.x,q.y,pmod(q.z, 0.4))) - vec3(0.1,0.04,0.2);\n    z.xy *= rot(0.125*pi);\n    rc = max(z.y,max(z.x, z.z));\n    q = abs(q) - 0.07;\n    dtt = min(dtt,rc + 0.02 );\n    pipe = max(q.x,q.y);\n    pipe = max(pipe, -rc);\n    dsqP = min(dsqP, pipe);\n    \n    \n    glow += exp(-dtt*(10. - pow(wave,0.4)*10. + sin(p.z)*1.))*max(coolPal(0.8, 1.8), 0.)*1.*pow(abs(sin(p.z + iTime)), 10.);\n    glow += exp(-dtt*(50. - pow(wave,0.4)*10. + sin(p.z)*1.))*max(coolPal(0.8, 1.8), 0.)*0.9;\n    \n    d = dmin(d, vec2(dtt,6.));\n    \n    \n    q = p;\n    q.z = pmod(q.z, 0.2);\n    \n    d = dmin(d, vec2(dsqP,6.));\n    \n    float net;\n    \n    pCoordsB = pCoords;\n    pCoordsB.y -= 0.7;\n    pCoordsB.x = pmod(pCoordsB.x,1./8.)/(1./8.);\n    pCoordsB.z = pmod(pCoordsB.z,1.)/(1.);\n    float ww = 0.01;\n    net = length(pCoordsB.xy) - ww;\n    net = min(net,length(pCoordsB.yz) - ww);\n    \n    glow += exp(-net*(20. - pow(wave,0.4)*10. + sin(p.z)*4.))*max(coolPal(0.7, 1.8), 0.)*1.;\n    d.x *= 0.7;\n\treturn d;\n}\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\tt = 0.; hit = false; p = ro;\n    for(int i = 0; i < 150; i++){\n    \td = map(p);\n        glow += exp(-max(d.x, 0.)*20.)*0.01;\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = cross(vec3(0,1,0), dir);\n\tvec3 up = cross(dir, right);\n    float fov = 1. + sin(iTime)*0.1;\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\n\n#define mx (10.*iMouse.x/iResolution.x)\n#define my (10.*iMouse.y/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\t//uv *= 1. + dot(uv,uv)*1.5;\n    \n    vec3 ro = vec3(0);\n    ro.z += iTime*SPEED+ sin(iTime)*1.;\n    ro.z += mx;\n        \n    ro += path(ro.z);\n    \n    float wave = pow(abs(sin(ro.z*0.2 + iTime*0.7 + 0.17)), 20.);\n    \n    vec3 lookAt = vec3(0,0,ro.z);\n    lookAt.z += 2.;\n    lookAt += path(lookAt.z); \n\tvec3 rd = getRd(ro, lookAt, uv*(1. + wave*0.06));\n    \n    ro -= rd*texture(iChannel0,(uv)*16.).x*0.2; // remove banding from glow\n    \n    \n    rd.xy *= rot(sin(iTime + sin(iTime*0.4)*0.5 )*0.1);\n    \n    float t; vec3 p; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n     \n    \n    if(hit){\n\n    \tvec3 n = getNormal(p);       \n        if(d.y == 2.){\n            vec4 hc = HexCoords(vec2(8.*pCoords.x, pCoords.z*1.)*1.);\n            vec4 hcc = hc;\n            float dHex = 10e6;\n            \n            float md = 0.1 ;\n            \n            float formula = hc.y + 0.4*sin(p.z*0.03 + iTime*0.3);\n            formula += hc.w*0.1;\n            float id = floor(formula/md);\n            hc.y = (pmod(formula, md))/md;\n            \n            \n            dHex = min(dHex,abs(hc.y) - 0.1);\n            \n            vec3 c = coolPal(0. + 0.8, sin(id*0.7)*0.19);\n            c *= max(0.,sin(id*0.9 + sin(hc.w)*9.));\n            \n\t\t\tc -= hcc.y*0.7;\n            c = max(c, 0.);\n            \n            col += c;\n            \n            float atten = sin(p.x);\n            \n        }\n        if(d.y == 8.){\n            float dd;\n            \n            cCoords = pmod(abs(cCoords),0.2)/0.2;\n            \n            cCoords = cCoords - 0.1;\n        }\n        if(d.y == 6.){\n            float dd;\n            \n            col += pow(1. - max(dot(n, -rd), 0.), 5.)*0.3;\n            \n            \n        }\n        if(d.y >= 10.){\n        \tvec3 c = pal(0.6,0.1,vec3(0.7,2.4,3.3), 0.2,3.3 + sin(p.z*0.5)*0.5);\n            \n            c = max(c, 0.);\n            float a = pmod(p.z + iTime*0.5, 1.)/1.;\n            col += pow(1. - max(dot(n, -rd), 0.), 5.)*0.1;\n\n            col += smoothstep(0.03,0.,abs(a) - 0.14)*c;\n        }\n        \n    }\n    \n    col += pow(glow,vec3(1./0.45))*0.001;\n    \n    col = max(col, 0.);\n    //col = mix(col, vec3(0.4,0.5,0.9)*1.5,pow(smoothstep(0.,1.,t*0.08), 3.9));\n \n\tcol = mix(col, vec3(0.7,0.3,0.2)*3.5,pow(smoothstep(0.,1.,t*0.08), 3.9));   \n    col *= 0.96;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED (2.4 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 212, 212, 1547]], "test": "untested"}
{"id": "wlyXzt", "name": "Chromatic crystalline veneer", "author": "loicvdb", "description": "Don't ask me about the name idk what it means", "tags": ["raymarching", "fractal", "mandelbulb", "pathtracing", "tracing", "fresnel", "path", "realism"], "likes": 61, "viewed": 1399, "published": 3, "date": "1583445047", "time_retrieved": "2024-07-30T21:20:16.709141", "image_code": "vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return bloom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.4 * iResolution.y, fragCoord) * .07;\n    bloomSum += bloom(.07 * iResolution.y, fragCoord) * .07;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = ACESFilm(fragColor.rgb+bloomSum);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define Pi 3.14159265359\n\n// radius of the scene\n#define SceneRadius 100.\n// minimum distance before considering a hit\n#define MinDist .01\n// maximum number of steps when tracing a ray\n#define MaxSteps 512\n// number of light bounces\n#define RayDepth 3\n// Ior of the fresnel effect on the reflections\n#define Ior 1.45\n// enable reflexion caustics for more realism\n#define Caustics false\n\n#define HASH( seed ) fract(cos(seed)*43758.5453)\n#define RANDOM HASH(seed++)\n#define RANDOM2D vec2(RANDOM, RANDOM)\n\nfloat seed;\n\nvec3 CamPos = vec3(0, 0, -4.);\nvec3 CamRot = vec3(0., -1.5, 0.);\nfloat CamFocalLength = 1.5;\nfloat CamFocalDistance = 3.25;\nfloat CamAperture = .05;\n\nvec3 LightDir = normalize(vec3(-.0, -.1, .1));\nvec3 LightColor = vec3(4.);\nfloat LightRadius = .3;\n\n// self explanatory ...\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\n// cosine weighted sample for diffuse samples\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = RANDOM2D;\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\n// cone sample for NEE on a spherical cap\nvec3 getConeSample(vec3 dir, float theta) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = RANDOM2D;\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = 1. - r.y*(1.-cos(min(theta, Pi*.5)));\n\tfloat oneminus = sqrt(1.0 - r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n// fresnel\nfloat fresnel(vec3 dir, vec3 n, float ior) {\n    float cosi = dot(dir, n);\n    float etai = 1.0;\n  \tfloat etat = ior;\n    if (cosi > 0.0) {\n         float tmp = etai;\n         etai = etat;\n         etat = tmp;\n     }\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if (sint >= 1.0) return 1.0;\n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\n// julia variant of the quadratic mandelbulb\n// http://www.bugman123.com/Hypercomplex/index.html\nfloat sdfMandelbulb(vec3 z, vec3 c, out vec3 diffuseColor){\n    z *= rotationMatrix(vec2(.0, .08).xxy);\n    vec3 orbitTrap = vec3(1);\n    float r = length(z);\n\tfloat dr = 1., xxyy;\n    for (int i = 0; i < 100; i++) {\n        xxyy = z.x*z.x+z.y*z.y;\n        r = sqrt(xxyy+z.z*z.z);\n        orbitTrap = min(orbitTrap, abs(z*3.));\n        if (r>10.) break;\n        dr = r*2.*dr + 1.;\n        z = vec3(vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y)*(1.-z.z*z.z/xxyy), -2.*z.z*sqrt(xxyy)) + c;\n    }\n    diffuseColor = 1.-orbitTrap;\n\treturn 0.5*log(r)*r/dr;\n    \n}\n\n// plane with a texture and POM\nfloat sdfPlane(vec3 pos, out vec3 diffuseColor){\n    diffuseColor = texture(iChannel2, pos.xz*.5).rgb;\n    // uncomment for a checkerboard pattern\n    //diffuseColor = fract(pos.x)<.5 ^^ fract(pos.z)<.5 ? vec3(0) : vec3(1);\n    return pos.y + .51 + length(diffuseColor)*.001;\n}\n\nfloat sdf(vec3 pos, out vec3 diffuseColor){\n    \n    vec3 c = vec3(-1.26, .37, .0);\n    \n    vec3 dcM, dcS;\n    float s = sdfPlane(pos, diffuseColor);\n    float sM = sdfMandelbulb(pos, c, dcM);\n    if(sM < s){\n        diffuseColor = dcM;\n        s = sM;\n    }\n    return s;   \n}\n\nfloat sdf(vec3 pos){\n    vec3 ph; // placeholder\n    return sdf(pos, ph);\n}\n\n// UPDATE (29/12/2021) : fixed the NaN issue causing a black screen\nvec3 normal(vec3 pos, float dist){\n    vec2 k = vec2(abs(dist) + 0.0000001, 0.);\n    return normalize(vec3(sdf(pos + k.xyy),\n\t  \t\t\t\t\t  sdf(pos + k.yxy),\n  \t\t\t\t          sdf(pos + k.yyx)) - vec3(dist));\n}\n\n// traces a ray\nbool rayHit(inout vec3 pos, vec3 dir){\n    pos += RANDOM * sdf(pos) * dir;\n    float dist;\n    for(int i = 0; i < MaxSteps; i++){\n        dist = sdf(pos);\n        if(length(pos) > SceneRadius) break;\n        if(dist < MinDist) return true;\n        pos += dir * dist * .99;\n    }\n    return false;\n}\n\n// traces a shadow ray and computes direct light on the surface\nvec3 directLight(vec3 pos, vec3 n){\n    vec3 dir = getConeSample(-LightDir, LightRadius);\n    float dnrd = dot(n, dir);\n    if(dnrd < 0.0) return vec3(0);\n    return rayHit(pos, dir) ? vec3(0.) : LightColor * dnrd * (1.-fresnel(-dir, n, Ior));\n}\n\n\nvec3 background(vec3 dir) {\n    vec3 col = texture(iChannel1, dir).rgb;\n    return col*col+col;\n}\n\n// path tracing algorithm\nvec3 pathTrace(vec3 pos, vec3 dir){\n    \n    vec3 light = vec3(0.), attenuation = vec3(1.);\n    \n    // set this to zero for no reflected light at all (when fireflies are too annoying)\n    vec3 LCsLR2 = LightColor/(sin(LightRadius)*sin(LightRadius)); \n    \n    bool diffuse = false;\n    for(int i = 0; i <= RayDepth; i++){\n        \n        if(sdf(pos) < 0.) return light;\n        \n        // if the ray doesn't hit anything, the background gets rendered\n        if(!rayHit(pos, dir))\n            return light + attenuation *\n            \t(dot(dir, -LightDir) > cos(LightRadius)\t\t// if the ray end up in the light\n                    ? diffuse\t\t\t\t\t\t\t\t// if the ray if a diffuse ray\n                        ? vec3(0.)\t\t\t\t\t\t\t// then don't add any background (direct light already in nee)\n                        : LCsLR2\t\t\t\t\t\t\t// else add the light color\n                    : background(dir)\t\t\t\t\t\t// else sample the cubemap\n                );\n        \n        vec3 diffuseColor;\n        float dist = sdf(pos, diffuseColor);\n        vec3 n = normal(pos, dist);\n        pos += n*(1.5*MinDist-dist);\n        \n        // nee\n        light += attenuation * diffuseColor * directLight(pos, n);\n        \n        if(fresnel(dir, n, Ior) > RANDOM) {\n            // reflection\n            dir = reflect(dir, n);\n            if(Caustics) diffuse = false;\n        } else {\n            // diffuse\n            dir = getCosineWeightedSample(n);\n        \tattenuation *= diffuseColor;\n            diffuse = true;\n        }\n    }\n    return light;\n}\n\n// n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation){\n    \n    // create a point on the first \"blade\"\n    float side = sin(Pi / float(nbBlades));\n    vec2 tri = RANDOM2D;\n    if(tri.x-tri.y > 0.) tri = vec2(1.-tri.x, -1.+tri.y);\n    tri *= vec2(side, sqrt(1.-side*side));\n    \n    // rotate it to create the other blades\n    float angle = rotation + 2.*Pi*floor(RANDOM * float(nbBlades))/float(nbBlades);\n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    \n    //mouse mouvement\n    CamRot.yx -= Pi*(iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    CamPos *= rotationMatrix(CamRot);\n    \n    // random numbers seed\n    seed = cos(iTime)+cos(fragCoord.x)+sin(fragCoord.y);\n    \n    // uv on the camera sensor (from -1 to 1 vertically)\n    vec2 uv = (fragCoord+RANDOM2D-iResolution.xy*.5) / iResolution.y;\n    \n    // gerenate ray direction & position in camera space\n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(6, 0.0), 0.0);\n    vec3 dir = normalize(focalPoint-aperture);\n    vec3 pos = aperture;\n    \n    // convertion to world space\n    mat3 CamMatrix = rotationMatrix(CamRot);\n    dir *= CamMatrix;\n    pos = pos*CamMatrix + CamPos;\n    \n    fragColor = iFrame == 0 ? vec4(0.) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iMouse.z > 0.) fragColor.a = 0.;\n    fragColor.rgb = mix(fragColor.rgb, pathTrace(pos, dir), 1.0/(++fragColor.a));\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 162], [287, 287, 327, 327, 618], [620, 620, 674, 674, 951]], "test": "untested"}
{"id": "wtVSzd", "name": "大龙猫 - Quicky#024", "author": "totetmatt", "description": "Training the fract & double loop + like the 1./x ligt effect", "tags": ["instagram", "quicky"], "likes": 2, "viewed": 369, "published": 3, "date": "1583443542", "time_retrieved": "2024-07-30T21:20:17.481077", "image_code": "#define bpm iTime*(138./60.*8.)\n#define sbpm mod(floor(bpm) + pow(fract(bpm),.005),8.)\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\nvec3 fig(vec2 uv,float p,vec3 ttt) {\n    float d = length(uv);\n    vec3 col = vec3(.1/pow(d,p));\n    return mix(vec3(.1),vec3(.4,.3-length(uv*.2),.3-length(uv*.3)),col)*ttt ;\n\n}\nmat2 r(float a){\nfloat c= cos(a),s=sin(a);\nreturn mat2(c,-s,s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    //uv*=r(sbpm/8.);\n       uv*=r( (uv.x* max(uv.y*4.,0.))*.2);\n    vec2 gv = fract(uv*2.-.5)-.5;\n    vec2 id = floor(uv);\n    vec3 col = vec3(0.);\n \n    for(float y=-1.0;y<=1.0;y++){\n    for(float x=-1.0;x<=1.0;x++){\n    vec2 offset= vec2(x,y+(2.-sbpm)*.1);\n        float m  =mod(sbpm+(sin(id.x*20.))  ,8.) > 2. ? 2.*length(uv) : 0.;\n        vec2 z = mod(sbpm+(sin(id.x*20.))  ,8.) <= 2. ? vec2(1.,fract(y)) : vec2(1.);\n        \n        \n        vec3 b = fig( fract(gv+offset.yx*r(cos(iTime)))-.5,1.005,vec3(1.,.5,0.2));\n      \n        vec3 coll = \n            b +\n            fig( (gv*z+offset),2.,vec3(.1,.5,1.))+\n            fig(uv+vec2(sin(iTime*1.6)*.5,cos(iTime*4.)*.4),0.9 +m ,vec3(.2,.5,1.)) +\n            fig(uv+vec2(cos(iTime*3.33)*.3,sin(iTime*1.6)*.4),.9+m,vec3(1.,.5,0.2)) ;;\n        col += coll/9.;\n    }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 249, 285, 285, 426], [427, 427, 443, 443, 494], [495, 495, 550, 550, 1474]], "test": "untested"}
{"id": "3tyXDG", "name": "sölakdfjalöskjdf", "author": "lennyjpg", "description": "aslädjkfaläksdjf\n", "tags": ["aslkdfjalskdj"], "likes": 1, "viewed": 309, "published": 3, "date": "1583440562", "time_retrieved": "2024-07-30T21:20:18.246031", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;  \n    vec2 u = uv;\n    u *= 1.;\n    float t = iTime * 7.3;\n    float e = u.y - 0.1;\n    e += sin(u.x * 10.0 + t) * .01;\n    float f = pow(u.x - 0.5,2.0)*3.0;\n    e+=sin(f*2.0+t)*0.1;\n    float k = smoothstep(e,f,f*1.05); \n    float m = step(f,e);\n    vec3 a = vec3(1.0,0.9,10.0);\n    vec3 b = vec3(1.0,0.2,0.3);\n    vec3 c = mix(a,b,m / k);\n    //c.rg -= k;\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 486]], "test": "untested"}
{"id": "WtGSDG", "name": "ACES vs PWC", "author": "0x1D", "description": "Tonemapping tests", "tags": ["tonemap"], "likes": 4, "viewed": 473, "published": 3, "date": "1583436060", "time_retrieved": "2024-07-30T21:20:19.204469", "image_code": "// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n);\nconst mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n);\n\n// Based on http://www.oscars.org/science-technology/sci-tech-projects/aces\nvec3 aces_tonemap(vec3 color){\t\n\tvec3 v = m1 * color;\n    //vec3 v = color;\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n    //return pow(clamp((a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nconst float pi = 3.141592;\n// ACES Match\n//const float n = 0.0;\n//const float m = 0.1424;\n//const float p = 0.076;\n//const float f = 0.199;\n//const float q = 0.126;\n// Tweaked values\nconst float n = 0.0;\nconst float m = 0.15;\nconst float p = 0.065;\nconst float f = 0.222;\nconst float q = 0.163;\n\nfloat pwc_a(float x)\n{\n    return p * pow((x-n)/(m-n),(q-p)*(m-n)/(p*(f-m)));\n}\nfloat pwc_b(float x)\n{\n    return (q-p)/(f-m)*x-m*(q-p)/(f-m)+p;\n}\nfloat pwc_c(float x)\n{\n    return 2.0/pi*(1.0-q)*atan(pi/2.0*(q-p)/(1.0-q)*(x-f)/(f-m))+q;\n}\nfloat pwc(float x)\n{\n    if(x < n)\n        return 0.0f;\n    else if(x < m)\n        return pwc_a(x);\n    else if(x < f)\n        return pwc_b(x);\n    else\n        return pwc_c(x);\n}\nvec3 pwc_tonemap(vec3 c)\n{\n    c = m1 * c;\n    vec3 tmp = vec3(pwc(c.r), pwc(c.g), pwc(c.b));\n    \n    c = m2 * tmp;\n    \n    return pow(clamp(c, 0.0, 1.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    \n    \n    // dof\n    const float focus = 2.35;\n\n    vec4 acc = vec4(0.0);\n    const int N = 12;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off/vec2(800.0,450.0) ); \n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        float coc = 0.05 + 12.0*abs(depth-focus)/depth;\n        \n        if( dot(off,off) < (coc*coc) )\n        {\n            float w = 1.0/(coc*coc); \n            acc += vec4(color*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz / acc.w;\n\n    \n    // gamma\n    //col = pow( col, vec3(0.4545) );\n\n    // color correct - it seems my laptop has a fucked up contrast/gamma seeting, so I need\n    //                 to do this for the picture to look okey in all computers but mine...\n    //col = col*1.1 - 0.06;\n    \n    // vignetting\n    col *= 0.8 + 0.3*sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\tcol *= 1.;\n    \n    //tonemapping test\n    float tmmask = iTime*2.*3.141592;\n    if (q.x > sin(tmmask*0.1)*0.5+0.5) {\n     col = aces_tonemap(col);\n    } else {\n        col = pwc_tonemap(col);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSDG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[350, 426, 456, 456, 725], [1023, 1023, 1045, 1045, 1102], [1103, 1103, 1125, 1125, 1169], [1170, 1170, 1192, 1192, 1262], [1263, 1263, 1283, 1283, 1442], [1443, 1443, 1469, 1469, 1619], [1621, 1621, 1678, 1678, 2923]], "test": "untested"}
{"id": "WlGXWG", "name": "escher-like 2 ( 313 chars)", "author": "FabriceNeyret2", "description": "golfing [url]https://shadertoy.com/view/ldyXWw[/url] (435 chars)\ncould it be smaller ? :-)\n\nreproducing [url]https://twitter.com/CPriestman/status/684874950944100352/photo/1[/url]", "tags": ["2d", "gif", "short", "golf", "copies", "reproductions", "escherlike"], "likes": 13, "viewed": 456, "published": 3, "date": "1583434045", "time_retrieved": "2024-07-30T21:20:20.080128", "image_code": "// golfing https://shadertoy.com/view/ldyXWw (435 chars)\n// reproducing https://twitter.com/CPriestman/status/684874950944100352/photo/1\n\n// --- -16 ch by Coyote; -2 by Fab. Now pretty obfuscated :-p\n\n#define r    mat2( cos( vec4(0,11,33,0) + 1.57*                      //\n#define c(m) clamp( mod( m+ iTime -.3*( V = ceil(r.8)) * U/3.16 -.5 ) ) -V.y, 6.) -4., 0.,1.).x//\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, V,\n\t     U = u+u - R;\n    if ( abs( U *= 7.5/R.y ).x < 7.5 )\n        U += 3.,\n        U = abs( r( c() == 0. ? R=-R, U.y++, ++U, -c(3.) : c() ) ))\n                *( U - r-.8)) * V*3.16 ) ) -.5,\n        O += .5 - R.y/30. * max( V = U.y < U.x ? U.yx : U, --V.y ).x;\n}/*\n\n\n\n\n\n// --- 331 chars\n\n#define r(t)   mat2( cos( 1.57*t + vec4(0,11,33,0)) )              //\n#define c(U,m) clamp( mod( m+ iTime -.3*( V = ceil( r(.8) * (U)/3.16 -.5 ) ) -V.y, 6.) -4., 0.,1.) //\n#define mainImage(O,u)                                              \\\n    vec2 R = iResolution.xy, V,                                     \\\n\t     U = 7.5* (u+u-R) / R.y, t;                                 \\\n    if ( abs(U.x) < 7.5 )                                           \\\n        t = c( U += 3. , ),                                         \\\n        U = abs( r( ( t.x == 0. ? R=-R, U.y++, -c(++U,3.) : t ).x ) \\\n                *( U - r(-.8) * V*3.16 ) ) -.5,                     \\\n        U.y < U.x ? U = U.yx : U,                                   \\\n        O += .5 - R.y/30. *  max( U.x, --U.y )                     /*\n            \n            \n            \n            \n\n// --- 333 chars\n\n#define r(t)     mat2( cos( 1.57*t + vec4(0,11,33,0)) )            //\n#define c(U,m) ( V = ceil( r(.8) * (U)/3.16 -.5 ),                  \\\n                 clamp( mod( m+ iTime -V.y-.3*V, 6.) -4., 0.,1.)    \\\n               )                                                   //\n#define mainImage(O,u)                                              \\\n    vec2 R = iResolution.xy, V,                                     \\\n\t     U = 7.5* (u+u-R) / R.y, t;                                 \\\n    if ( abs(U.x) < 7.5 )                                           \\\n        t = c( U += 3. , ),                                         \\\n        U = abs( r( ( t.x == 0. ? R=-R, U.y++, -c(++U,3.) : t ).x ) \\\n                *( U - r(-.8) * V*3.16 ) ) -.5,                     \\\n        U.y < U.x ? U = U.yx : U,                                   \\\n        O += .5 - R.y/30. *  max( U.x, --U.y )                     /*\n            \n            \n            \n            \n\n// --- 337 chars\n\n#define R(t)     mat2( cos( 1.57*t + vec4(0,11,33,0)) )        //\n#define C(U,m) ( V = ceil( R(.8) * (U)/3.16 -.5 ),              \\\n                 clamp( mod( m+ iTime -V.y-.3*V, 6.) -4., 0.,1.)\\\n               )                                               //\n#define mainImage(O,u)                                          \\\n    vec2 R = iResolution.xy, V,                                 \\\n\t     U = 7.5* (u+u-R) / R.y, t;                             \\\n    if ( abs(U.x) < 7.5 )                                       \\\n        t = C( U += 3. , ),                                     \\\n        t.x == 0. ? R=-R, U.y++, t = - C( ++U , 3. ) : t,       \\\n        U = abs( R(t.x) * ( U - R(-.8) * V*3.16 ) ),            \\\n        U.y < U.x ? U = U.yx : U,                               \\\n        O += .5 - R.y/30. *  max( U.x-.5, U.y-1.5 )            /*\n\n            \n            \n            \n            \n// --- 341 chars\n\n#define R(t)     mat2( cos( 1.57*t + vec4(0,11,33,0)) )      //\n#define C(U,m) ( V = ceil( R(.8) * (U)/3.16 -.5 ),            \\\n    clamp( mod( m+iTime -V.y-.3*V.x, 6.) -4., 0.,1.)  )      //\n#define mainImage(O,u)                                        \\\n    vec2 R = iResolution.xy, V,                               \\\n\t     U = 7.5* (u+u-R) / R.y;                              \\\n    float t;                                                  \\\n    if ( abs(U.x) < 7.5 )                                     \\\n        t = C( U += 3. , ),                                   \\\n        t == 0. ? R=-R, U.y++, t = - C( ++U , 3. ) : t,       \\\n        U = abs( R(t) * ( U - R(-.8) * V*3.16 ) ),            \\\n        U.y < U.x ? U = U.yx : U,                             \\\n        O += .5 - R.y/30. *  max( U.x-.5, U.y-1.5 )          /*\n\n            \n            \n            \n            \n// --- 362 chars\n\n#define R(t)     mat2(cos(t+vec4(0,11,33,0)))                //\n#define C(U,m) ( V = ceil( R(1.25) * (U)/k -.5 ),             \\\n    clamp( mod( m+iTime -V.y-.3*V.x, 6.) -4., 0.,1.) *1.57 ) //\n#define mainImage(O,u)                                        \\\n    vec2 R = iResolution.xy, V,                               \\\n\t     U = 7.5* (u+u-R) / R.y;                              \\\n    float t,s, k = 3.16;                                      \\\n    if ( abs(U.x) < 7.5 )                                     \\\n        s = t = C( U += 3. , ),                               \\\n        t > 0. ? t : t = - C( U += vec2(1,2) , 3. ),          \\\n        U = abs( R(t)* ( U - R(-1.25)*V*k ) ),                \\\n        U.y < U.x ? U = U.yx : U,                             \\\n        O += .5 - R.y/30.* ( max( U.x, U.y-1. ) -.5 ) ,       \\\n        s > 0. ? O : O = 1.-O                                /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtGXWG", "name": "loopless dots along circle (266c", "author": "FabriceNeyret2", "description": "golfing [url]https://shadertoy.com/view/XsVBz3[/url] ( 379 chars )\ncould it be shorter ? :-)\n\nin a fragment shader, regular patterns can generally be done loopless: each pixel determine on which feature it lays (or not).\n", "tags": ["2tweets", "tuto", "short", "golf", "loopless"], "likes": 5, "viewed": 473, "published": 3, "date": "1583429676", "time_retrieved": "2024-07-30T21:20:20.967754", "image_code": "// golfing https://shadertoy.com/view/XsVBz3 ( 379 chars )\n\n#define S(v,r)  smoothstep ( 3./R.y, 0., length(v) r )    //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U =   u+u - R ;\n    float n = ( 16.+ 15.*sin(iTime) ) / 6.3,\n          a = atan(U.y,U.x) * n;\n    O =   S( U = abs( vec2( ( fract (a)     - .5 ) * .5/n,\n                              length(U)/R.y - .5\n                    )     ),\n             -.03 )\n        * ( .6 + .6 * cos( ceil(a)/n + vec4(0,23,21,0) ) )\n        + S( max(U.x,U.y) - .1 , );\n} /*\n\n\n\n\n\n\n// --- 270 chars\n        \n#define S(v,r)  smoothstep ( 3./R.y, 0., length(v) r )   //\n#define mainImage(O,u)                                    \\\n    vec2  R = iResolution.xy,                             \\\n          U = ( u+u - R ) / R.y;                          \\\n    float n = (16.+15.*sin(iTime))/6.3,                   \\\n          a = atan(U.y,U.x) * n;                          \\\n    U = abs( vec2( ( fract (a) - .5 ) * .5/ n,            \\\n                     length(U) - .5                       \\\n            ));                                           \\\n    O =   S( U, -.03 )                                    \\\n        * ( .6 + .6 * cos( ceil(a)/n + vec4(0,23,21,0) ) )\\\n        + S(max(U.x,U.y)-.1,)                            /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WlySWG", "name": "Rorschach's Dream (Soft)", "author": "deerfeeder", "description": "Based on @BigWIngs's gyro tut", "tags": ["raymarching", "template", "gyroid", "artofcode", "deerfeeder"], "likes": 3, "viewed": 424, "published": 3, "date": "1583427171", "time_retrieved": "2024-07-30T21:20:21.821472", "image_code": "// Fork of \"Rorschach's Dream\" by deerfeeder. https://shadertoy.com/view/wtGXzd\n// 2020-03-05 16:50:36\n\n// Fork of \"RayMarching starting point\" by BigWIngs. https://shadertoy.com/view/WtGXDD\n// 2020-03-04 23:37:06\n// Music by me (Deerfeeder - Fall)\n// raymarching artifacts as a feature\n\n#define MAX_STEPS 12\n#define MAX_DIST 100.\n#define SURF_DIST 0.1\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat GetDist(vec3 p) {\n    p.xy*=Rot(iTime*0.08);\n    p.zx*=Rot(iTime*0.08);\n    float box = sdBox(p, vec3(3.0));\n   \t\n    // return box;\n    float gyro = sdGyroid(p,abs(5.0*tanh(iTime*3.65)),0.125,2.0)/1.0;\n    return max(box, gyro*2.);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.x = abs(uv.x);\n    //uv.y = abs(uv.y);\n\tvec2 m = vec2(cos(iTime*1.)+iMouse.y,sin(iTime*1.))/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    float amp = texture(iChannel0, vec2(1., 0.0)).r*7.3;\n    amp = amp > 12.1 ? amp:0.;\n    vec3 ro = vec3(sin((iTime)*0.096), 3. + 3. + sin(iTime * 0.1) , -cos((iTime+ amp)*0.096));\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(0.2 + abs(2. * cos(iTime*0.1))));\t// gamma correction\n    \n    fragColor = vec4(1.-col,1.0);\n}", "image_inputs": [{"id": 21428, "src": "https://soundcloud.com/miiiis/mi-ish-airborne", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 394, 413, 413, 489], [491, 491, 520, 520, 601], [603, 603, 669, 669, 748], [750, 750, 773, 773, 990], [992, 992, 1026, 1026, 1237], [1239, 1239, 1263, 1263, 1453], [1455, 1455, 1505, 1505, 1700], [1704, 1704, 1761, 1761, 2588]], "test": "untested"}
{"id": "wtGXzd", "name": "Rorschach's Dream", "author": "deerfeeder", "description": "Based on @BigWIngs's gyro tut", "tags": ["raymarching", "template", "gyroid", "artofcode", "deerfeeder"], "likes": 5, "viewed": 387, "published": 3, "date": "1583406229", "time_retrieved": "2024-07-30T21:20:22.612357", "image_code": "// Fork of \"RayMarching starting point\" by BigWIngs. https://shadertoy.com/view/WtGXDD\n// 2020-03-04 23:37:06\n// Music by me (Deerfeeder - Cataclysm LIVE)\n// raymarching artifacts as a feature\n\n#define MAX_STEPS 6\n#define MAX_DIST 10.\n#define SURF_DIST 0.05\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat GetDist(vec3 p) {\n    p.xy*=Rot(iTime*0.11);\n    p.zx*=Rot(iTime*0.11);\n    float box = sdBox(p, vec3(1.25));\n   \t\n    // return box;\n    float gyro = sdGyroid(p,abs(5.0*tanh(iTime*3.65)),0.125,2.0)/1.0;\n    return max(box, gyro*2.);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //uv.x = abs(uv.x);\n    uv.y = abs(uv.y);\n\tvec2 m = vec2(cos(iTime*5.),sin(iTime*5.))/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    float amp = texture(iChannel0, vec2(10., 0.0)).r*1.;\n    vec3 ro = vec3(sin((iTime)*0.06), 3., -cos((iTime+ amp)*0.36));\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(0.2 + abs(2. * cos(iTime*0.01))));\t// gamma correction\n    \n    fragColor = vec4(hsv2rgb(vec3(-0.40+col.x*0.55,0.55,0.8)),1.0);\n}", "image_inputs": [{"id": 21426, "src": "https://soundcloud.com/miiiis/deerfeeder-cataclysm-live", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 318, 318, 394], [396, 396, 425, 425, 506], [508, 508, 574, 574, 653], [655, 655, 678, 678, 896], [898, 898, 932, 932, 1143], [1145, 1145, 1169, 1169, 1359], [1361, 1361, 1411, 1411, 1606], [1608, 1608, 1630, 1630, 1799], [1801, 1801, 1858, 1858, 2653]], "test": "untested"}
{"id": "WtVXzd", "name": "Shark shader", "author": "z0rg", "description": "Simple landscape series", "tags": ["landscape", "shark"], "likes": 11, "viewed": 322, "published": 3, "date": "1583404479", "time_retrieved": "2024-07-30T21:20:23.374320", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\n\nfloat _cir(vec2 uv, float sz)\n{\n  return length(uv)-sz;\n}\n\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\n\nvec4 shark(vec2 uv)\n{\n  float sharp = 80.;\n  uv.x += .02*sin(10.*uv.y+iTime*2.);\n\n  float yUp = 0.;\n  float upOffX = .03;\n  float bodyUp = float(uv.x >0.)*(1.-sat(_cir(vec2(2.,1.)*uv+vec2(upOffX,yUp),.2)*sharp))\n  \t+ float(uv.x <0.)*(1.-sat(_cir(vec2(2.,1.)*uv+vec2(-upOffX,yUp),.2)*sharp));\n  float downy = .07;\n  float dOffX = 0.05;\n  float bodyDown = float(uv.x >0.)*(1.-sat(_cir(vec2(2.5,.7)*uv+vec2(dOffX,yUp+downy),.2)*sharp))\n  +   float(uv.x <0.)*(1.-sat(_cir(vec2(2.5,.7)*uv+vec2(-dOffX,yUp+downy),.2)*sharp));\n  float yArm = -.15;\n  float armX = .0;\n  float leftArm = (1.-sat(_sub(_cir(uv-vec2(armX,yArm),.2),_cir(uv-vec2(armX,yArm)+vec2(.0,.2),.3))*sharp));\n  float yPalm = -.42;\n  float palm = (1.-sat(_sub(_cir(.7*vec2(4.,1.)*uv-vec2(armX,yPalm),.15),_cir(.7*vec2(4.,1.)*uv-vec2(armX+sin(-PI+iTime)*.02,yPalm+.02*sin(iTime))+vec2(.0,.2),.3))*sharp));\n  float y2 = -.3;\n  float palm2 = (1.-sat(_sub(_cir(2.*uv-vec2(armX,y2),.2),_cir(2.*uv-vec2(armX,y2)+vec2(.0,.2),.3))*sharp));\n  float y3 = -1.1;\n\n  float palm3 = (1.-sat(_sub(_cir(3.*uv-vec2(armX,y3),.2),_cir(3.*uv-vec2(armX,y3)+vec2(.0,.2),.3))*sharp));\n\n  return vec4(0.,0.1,0.1,sat(palm3+palm2+bodyUp+bodyDown+leftArm+palm));\n}\n\nvec3 rdrLand(vec2 uv, float drawShark)\n{\n  vec3 back = vec3(0.);\n  vec3 dark = vec3(4.,32.,24.)/255.;\n  vec3 light = vec3(123.,165.,103.)/255.;\n  vec3 grad = dark+mix(light.yzx,dark,length(uv));\n  vec2 sunP = (uv-vec2(.1))+.09*vec2(sin(55.*uv.y+iTime),sin(35.*uv.x+iTime*2.));\n  vec3 sun = (1.-sat(_cir(sunP,.1)*50.))*light;\n  vec3 sunHalo = pow((1.-sat(_cir(sunP,.1)*5.)),2.)*light.zyx;\n  sun += sunHalo;\n  float shark = shark(uv+vec2(0.,mod(-iTime*.1,2.)-1.)).w;\n  back = back+grad+sun;\n  return mix(back,grad*.7,shark*drawShark)*sat(1.-lenny(uv)+.3);\n}\n\nvec3 rdrScn(vec2 uv)\n{\n  float maskLand = 1.-sat(_cir(uv,.5)*50.);\n\n  vec3 land = rdrLand(uv,1.);\n  vec2 sp = uv-vec2(.1);\n  float auv = iTime*.05+atan(-abs(sp.y),sp.x)/PI*2.;\n  float freq = 55.;\n  vec3 land2 = rdrLand(uv+vec2(sin(auv*freq),cos(auv*freq))*.02,.2)*.5;\n  return mix(rdrLand(uv*.7,0.)*.5,land,maskLand)+(land2*.5)*length(uv*3.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv *= 2.;\n  vec3 col = rdrScn(uv);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXzd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[426, 426, 444, 444, 505], [507, 507, 528, 528, 558], [559, 559, 579, 579, 606], [607, 607, 625, 625, 671], [673, 673, 704, 704, 730], [732, 732, 762, 762, 784], [786, 786, 807, 807, 1981], [1983, 1983, 2023, 2023, 2538], [2540, 2540, 2562, 2562, 2884], [2886, 2886, 2943, 2943, 3103]], "test": "untested"}
{"id": "WlKSRd", "name": "Paper Rolls", "author": "dr2", "description": "Where has all the loo paper gone (serious business)?", "tags": ["repetition", "toilet", "gridmarch"], "likes": 15, "viewed": 504, "published": 3, "date": "1583394789", "time_retrieved": "2024-07-30T21:20:24.138277", "image_code": "// \"Paper Rolls\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1  // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit;\nvec2 gId, trkF, trkA;\nfloat tCur, dstFar, hgSize, wavHt, nCylV, nCylH, cylHt, cylRd, cylHo, emFrac;\nint idObj;\nbool isOcc;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId * hgSize);\n  a = atan (p.z, - p.x) / (2. * pi);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * a + 0.5)) / 6.);\n  d = max (abs (q.x) - 0.85 * hgSize, q.y - wavHt + 0.05 * dot (q.xz, q.xz));\n  DMINQ (1);\n  if (isOcc) {\n    p.y -= wavHt - 0.03;\n    q = p;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (nCylH * a + 0.5)) / nCylH);\n    if (nCylH > 1.) q.x = abs (q.x) - 0.8;\n    q.y -= cylHt * nCylV;\n    d = max (PrCylDf (q.xzy, cylRd, cylHt * nCylV), cylHo - length (q.xz));\n    DMINQ (2);\n  }\n  return dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 p, u, fRand;\n  p = HexToPix (gId * hgSize);\n  u = mod (0.1 * vec2 (p.x + p.y, p.x - p.y) * (1. + 0.3 * sin (0.2 * 2. * pi * p)) +\n    0.1 * tCur, 1.) - 0.5;\n  wavHt = 0.6 * dot (exp (-100. * u * u), vec2 (1.));\n  fRand = Hashv2v2 (gId * vec2 (37.3, 43.1) + 27.1);\n  isOcc = (fRand.y >= emFrac);\n  if (isOcc) {\n    nCylV = 1. + floor (4. * fRand.x);\n    nCylH = 1. + floor (6. * fRand.y);\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-99.);\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float ao, d;\n  ao = 0.;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 4; j ++) {\n    d = 0.01 + float (j) / 20.;\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    ao += max (0., d - 3. * ObjDf (p));\n  }\n  return 0.6 + 0.4 * clamp (1. - 2. * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, sh, ao;\n  bgCol = vec3 (0.5, 0.4, 0.4);\n  emFrac = 0.05;\n  cylHt = 0.3;\n  cylRd = 0.3;\n  cylHo = 0.12;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      if (vn.y > 0.01) col = mix (vec3 (0.65, 0.65, 0.7), vec3 (0.6, 0.6, 0.55),\n         smoothstep (0.4, 0.6, Fbm2 (ro.xz)));\n      else col = vec3 (0.95, 0.95, 1.) * (0.85 + 0.15 * cos (9. * 2. * pi * qHit.z / hgSize));\n    } else if (idObj == 2) {\n      if (length (qHit.xz) < cylHo + 0.01) col = vec3 (0.6, 0.4, 0.);\n      else col = mix (vec3 (1., 0.8, 0.9), vec3 (1.3),\n         smoothstep (0.02, 0.05, abs (mod (qHit.y / (2. * cylHt) + 0.5 * (nCylV + 1.), 1.) - 0.5)));\n    }\n    ao = ObjAO (ro, vn);\n    sh = min (ObjSShadow (ro, ltDir), ao);\n    col *= ao * (0.3 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.)) +\n       0.7 * sh * max (dot (vn, ltDir), 0.);\n    col = mix (col, bgCol, smoothstep (0.5, 1., dstObj / dstFar));\n  } else col = (0.1 + 0.9 * step (-0.1, rd.y)) * bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), dot (trkA.yx, cos (trkF * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)),\n     dot (trkF * trkA.yx, - sin (trkF * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)),\n     dot (trkF * trkF * trkA.yx, - cos (trkF * t)), 0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec4 dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, vFly;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.) + 11.1;\n  hgSize = 1.6;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, -0.05 * pi);\n  trkF = vec2 (0.1, 0.17);\n  trkA = vec2 (1.25, 0.45);\n  vuMat = StdVuMat (el, az);\n  vFly = 2.;\n  ro = TrackPath (vFly * tCur);\n  ro.y += 5.;\n  vd = normalize (TrackVel (vFly * tCur));\n  vuMat = StdVuMat (el + 0.5 * sin (vd.y), az + 2. * atan (vd.x, vd.z));\n  zmFac = 2.2;\n  dstFar = 120.;\n  ltDir = normalize (vec3 (0., 1.5, -1.));\n  ltDir.xz = Rot2D (ltDir.xz, 0.3 * pi * sin (0.05 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    rd.xy = Rot2D (rd.xy, -10. * TrackAcc (vFly * tCur).x);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSRd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[688, 688, 710, 710, 1293], [1295, 1295, 1317, 1317, 1718], [1720, 1720, 1753, 1753, 2821], [2823, 2823, 2844, 2844, 3092], [3094, 3094, 3131, 3131, 3534], [3536, 3536, 3568, 3568, 3928], [3930, 3930, 3965, 3965, 5058], [5060, 5060, 5086, 5086, 5166], [5168, 5168, 5193, 5193, 5295], [5297, 5297, 5322, 5322, 5440], [5442, 5442, 5498, 5498, 6949], [6951, 6951, 6993, 6993, 7044], [7046, 7046, 7070, 7070, 7300], [7302, 7302, 7326, 7326, 7386], [7388, 7388, 7410, 7410, 7448], [7450, 7450, 7495, 7495, 7598], [7600, 7600, 7636, 7636, 7842], [7843, 7843, 7873, 7873, 7986], [8020, 8020, 8044, 8044, 8174], [8176, 8176, 8201, 8201, 8387], [8389, 8389, 8410, 8410, 8565]], "test": "untested"}
{"id": "WtyXRy", "name": "Biquadratic & Triquadratic", "author": "iq", "description": "Fast biquadratic (2D, top) and triquadratic (3D, bottom) texture filtering, with 4 samples and 8 samples respectively. Based on Roger Cabo Ashauer and paniq's.", "tags": ["2d", "3d", "biquadratic", "triquadratic"], "likes": 20, "viewed": 1053, "published": 3, "date": "1583390994", "time_retrieved": "2024-07-30T21:20:24.907221", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Fast biquadratic (2D) and triquadratic (3D) texture\n// filtering, with 4 samples and 8 samples respectively.\n// Based on an example by Roger Cabo Ashauer until I\n// realized it's equivalent to Paniq's biquadratic\n// implementation https://www.shadertoy.com/view/wtXXDl\n//\n// Top:     2D biquadratic  filtering\n// Bottom:  3D triquadratic filtering\n\n\n// Other texture interpolation shaders:\n// \n// Samples      Type\n// ----------   ---------\n//  1 linear    2x2 cubic     : https://www.shadertoy.com/view/XsfGDn\n//  4 linear    3x3 quadratic : https://www.shadertoy.com/view/WtyXRy and https://www.shadertoy.com/view/wtXXDl\n//  4 linear    4x4 cubic     : https://www.shadertoy.com/view/4df3Dn and https://www.shadertoy.com/view/tlXSR2\n//  9 linear    4x4 cubic     : https://www.shadertoy.com/view/MtVGWz\n// 16 nearest   4x4 cubic     : https://www.shadertoy.com/view/XsSXDy\n\n// Enable this to see continuity properties\n// #define SHOW_DERIVATIVES\n\n\n\nvec4 texture2( sampler2D sam, vec2 uv );\nvec4 texture3( sampler3D sam, vec3 uv );\n\nvec4 textureQuadratic( in sampler2D sam, in vec2 p )\n{\n    float texSize = float(textureSize(sam,0).x); \n    \n#if 1\n    //Roger/iq style\n\tp = p*texSize;\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tp = i + f*0.5;\n\tp = p/texSize;\n    //f = f*f*(3.0-2.0*f); // optional for extra sweet\n\tfloat w = 0.5/texSize;\n\treturn mix(mix(texture2(sam,p+vec2(0,0)),\n                   texture2(sam,p+vec2(w,0)),f.x),\n               mix(texture2(sam,p+vec2(0,w)),\n                   texture2(sam,p+vec2(w,w)),f.x), f.y);\n    \n#else\n    // paniq style (https://www.shadertoy.com/view/wtXXDl)\n    vec2 f = fract(p*texSize);\n    vec2 c = (f*(f-1.0)+0.5) / texSize;\n    vec2 w0 = p - c;\n    vec2 w1 = p + c;\n    return (texture(sam, vec2(w0.x, w0.y))+\n    \t    texture(sam, vec2(w0.x, w1.y))+\n    \t    texture(sam, vec2(w1.x, w1.y))+\n    \t    texture(sam, vec2(w1.x, w0.y)))/4.0;\n#endif    \n\n    \n}\n\nvec4 textureQuadratic( in sampler3D sam, in vec3 p )\n{\n    float texSize = float(textureSize(sam,0).x); \n\n\tp = p*texSize;\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tp = i + f*0.5;\n\tp = p/texSize;\n    \n\tfloat w = 0.5/texSize;\n\n\treturn mix(mix(mix(texture3(sam,p+vec3(0,0,0)),\n                       texture3(sam,p+vec3(w,0,0)),f.x),\n                   mix(texture3(sam,p+vec3(0,w,0)),\n                       texture3(sam,p+vec3(w,w,0)),f.x), f.y),\n               mix(mix(texture3(sam,p+vec3(0,0,w)),\n                       texture3(sam,p+vec3(w,0,w)),f.x),\n                   mix(texture3(sam,p+vec3(0,w,w)),\n                       texture3(sam,p+vec3(w,w,w)),f.x), f.y), f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y;\n    vec2 p2 = p*0.1;\n    vec3 p3 = vec3(p*0.2,0.171);\n\t    \n\tvec3 colA = (p.y<0.5)?texture2( iChannel0, p2 ).xyz:\n                          texture3( iChannel1, p3 ).xyz;\n    vec3 colB = (p.y<0.5)?textureQuadratic( iChannel0, p2 ).xyz:\n                          textureQuadratic( iChannel1, p3 ).xyz;\n\n\tfloat g = sin(3.1416*p.x + iTime);\n    \n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, g ) );\n \n    #ifdef SHOW_DERIVATIVES\n    col = 0.5+0.1*vec3(dFdx(col.x),dFdy(col.x),0.0)*iResolution.y;\n    #endif\n    \n\tcol *= smoothstep( 0.0, 0.01, abs(g-0.0) );\n\tcol *= smoothstep( 0.0, 0.01, abs(p.y-0.5) );\n\n    fragColor = vec4( col, 1.0 );\n}\n\n//----\nvec4 texture2( sampler2D sam, vec2 uv )\n{\n#ifndef SHOW_DERIVATIVES    \n    return texture(sam,uv);\n#else    \n    float res = float(textureSize(sam,0).x);\n    uv = uv*res - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 f = fract(uv);\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/res, 0.0 );\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/res, 0.0 );\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/res, 0.0 );\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/res, 0.0 );\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif    \n}\n\nvec4 texture3( sampler3D sam, vec3 uv )\n{\n#ifndef SHOW_DERIVATIVES    \n    return texture(sam,uv);\n#else    \n    float res = float(textureSize(sam,0).x);\n    uv = uv*res - 0.5;\n    vec3 iuv = floor(uv);\n    vec3 f = fract(uv);\n\tvec4 rg1 = textureLod( sam, (iuv+ vec3(0.5,0.5,0.5))/res, 0.0 );\n\tvec4 rg2 = textureLod( sam, (iuv+ vec3(1.5,0.5,0.5))/res, 0.0 );\n\tvec4 rg3 = textureLod( sam, (iuv+ vec3(0.5,1.5,0.5))/res, 0.0 );\n\tvec4 rg4 = textureLod( sam, (iuv+ vec3(1.5,1.5,0.5))/res, 0.0 );\n\tvec4 rg5 = textureLod( sam, (iuv+ vec3(0.5,0.5,1.5))/res, 0.0 );\n\tvec4 rg6 = textureLod( sam, (iuv+ vec3(1.5,0.5,1.5))/res, 0.0 );\n\tvec4 rg7 = textureLod( sam, (iuv+ vec3(0.5,1.5,1.5))/res, 0.0 );\n\tvec4 rg8 = textureLod( sam, (iuv+ vec3(1.5,1.5,1.5))/res, 0.0 );\n\treturn mix(mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y ),\n               mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y ), f.z );\n#endif    \n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXRy.jpg", "access": "api", "license": "mit", "functions": [[2115, 2115, 2169, 2169, 2989], [2991, 2991, 3045, 3045, 3667], [3669, 3669, 3726, 3726, 4408], [4410, 4417, 4458, 4458, 4960], [4962, 4962, 5003, 5003, 5859]], "test": "untested"}
{"id": "WtKSzt", "name": "MONSTER", "author": "butadiene", "description": "30min livecoding", "tags": ["raymarching", "cineshader"], "likes": 97, "viewed": 49662, "published": 3, "date": "1583384504", "time_retrieved": "2024-07-30T21:20:25.670181", "image_code": "float TK = 1.;\nfloat PI = 3.1415926535;\n\nvec2 rot(vec2 p,float r){\n\tmat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n\treturn m*p;\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np = 2.0*PI/n;\n\tfloat r = atan(p.x,p.y)-0.5*np;\n\tr = mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q = abs(p);\n\tvec3 m = max(s-q,0.0);\n\treturn length(max(q-s,0.0))-min(min(m.x,m.y),m.z);\n}\n\nfloat dist(vec3 p){\n\tp.z -= 1.*TK*iTime;\n\tp.xy = rot(p.xy,1.0*p.z);\n\tp.xy = pmod(p.xy,6.0);\n\tfloat k = 0.7;\n\tfloat zid = floor(p.z*k);\n\tp = mod(p,k)-0.5*k;\n\tfor(int i = 0;i<4;i++){\n\t\tp = abs(p)-0.3;\n\n\t\tp.xy = rot(p.xy,1.0+zid+0.1*TK*iTime);\n\t\tp.xz = rot(p.xz,1.0+4.7*zid+0.3*TK*iTime);\n\t}\n\treturn min(cube(p,vec3(0.3)),length(p)-0.4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = 2.0*(uv-0.5);\n\tuv.y *= iResolution.y/iResolution.x;\n\tuv = rot(uv,TK*iTime);\n\tvec3 ro = vec3(0.0,0.0,0.1);\n\tvec3 rd = normalize(vec3(uv,0.0)-ro);\n\tfloat t  =2.0;\n\tfloat d = 0.0;\n\tfloat ac = 0.0;\n\tfor(int i = 0;i<66;i++){\n\t\td = dist(ro+rd*t)*0.2;\n\t\td = max(0.0000,abs(d));\n\t\tt += d;\n\t\tif(d<0.001)ac += 0.1;//exp(-15.0*d);\n\t}\n\tvec3 col = vec3(0.0);\n\tcol = vec3(0.1,0.7,0.7)*0.2*vec3(ac);//vec3(exp(-1.0*t));\n\tvec3 pn = ro+rd*t;\n\tfloat kn = 0.5;\n\tpn.z += -1.5*iTime*TK;\n\tpn.z = mod(pn.z,kn)-0.5*kn;\n\tfloat em = clamp(0.01/pn.z,0.0,100.0);\n\tcol += 3.0*em*vec3(0.1,1.0,0.1);\n\tcol = clamp(col,0.0,1.0);\n\t//col = 1.0-col;\n\n\n    // Output to screen\n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 66, 66, 127], [129, 129, 155, 155, 274], [276, 276, 302, 302, 398], [400, 400, 419, 419, 736], [739, 739, 796, 796, 1514]], "test": "untested"}
{"id": "3lGSR3", "name": "rainbow around the circle", "author": "libensvivit", "description": "beginner here", "tags": ["wave", "circle"], "likes": 15, "viewed": 588, "published": 3, "date": "1583382226", "time_retrieved": "2024-07-30T21:20:26.437131", "image_code": "#define PI      3.14159265\n#define TWO_PI  6.28318530\n#define HALF_PI 1.57079633\n\nvec3 circle(vec2 uv, float rad, float i){\n    float d  = length(uv);\n    float a  = atan(uv.y, uv.x);\n    vec3 c = vec3(1.);\n    vec3 colmult;\n\n    if(i == 0.) colmult = vec3(1., 0., 0.);\n    if(i == 1.) colmult = vec3(0., 1., 0.);\n\tif(i == 2.) colmult = vec3(0., 0., 1.);\n    \n    \n    rad += 0.05*cos(5.*a - i*HALF_PI + 3.*iTime)*pow(.5+.5*cos(iTime - a), 6.);\n    c -= 1.-smoothstep(rad, rad+0.01, d) + smoothstep(rad*.93, rad*.93+0.01, d);\n\n    return c * colmult;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(1.);\n    float rad = 0.4;\n        \n    col += circle(uv, rad, 0.);\n    col += circle(uv, rad, 1.);\n    col += circle(uv, rad, 2.);\n        \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGSR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 123, 123, 552], [555, 555, 609, 609, 915]], "test": "untested"}
{"id": "3tySz3", "name": "Rotunda Spin", "author": "hzhou17", "description": "Spin", "tags": ["spin"], "likes": 2, "viewed": 97, "published": 3, "date": "1583374404", "time_retrieved": "2024-07-30T21:20:27.227019", "image_code": "#define PI 3.1415926\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap(float a, float b, float c, float d, float t)\n{\n  return (c + (d-c) * (t-a)/(t-b));\n}\n\nfloat remap01(float a, float b, float t)\n{\n  return sat((t-a)/(b-a));             \n}\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur)\n{\n    float d = length(uv -p);//distance from orgin (bottom left)\n    float c = smoothstep(r, r - blur, d);\n    return c;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n\tfloat step2 = smoothstep(end + blur, end - blur, t);\n\n\treturn step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n\t\n    return band1 * band2;\n}\n\nfloat Tri(vec2 uv, float blur)\n{\n    float tri1 = Band(uv.x, -.5+uv.y, .5-uv.x, blur);\n    float tri2 = Band(uv.y, -.5, .5, blur); \n    \n    return tri1*tri2;\n}\n\n//################################################################################################\n//################################################################################################\n\nfloat Diamond (vec2 uv)\n\n{\n    uv *=  rotate2d(PI/2.);\n\n    uv *= mat2(-1.,.6, 1.,.6); //Scale\n\n    float mask = Rect(uv, -.03, .03, -.03, .03, .001);\n\n    return mask;  \n}\n\nfloat DiamondRing(vec2 uv)\n{\n    uv *=  rotate2d(PI/16.);\n    \n    float mask = 0.;\n    for (float i = 0.; i <= 2.* PI; i+= PI/8.) // thick 8 lines\n    {\n       uv *=  rotate2d(i);\n        \n       uv += vec2(0., .395);\n\t\n       mask += Diamond(uv); \n        \n       uv -= vec2(0., .395);\n    }\n    return mask; \n}\n\nfloat Triangle(vec2 uv)\n{\n    //uv *=  rotate2d(PI/4.);\n\n    //uv *= mat2(-1.,.6, 1.,.6); //Scale\n    \n    uv *= 2.;\n\n    float mask = Tri(uv, .001);\n\n    return mask;  \n}\n\nfloat TriRing(vec2 uv)\n{\n    uv *=  rotate2d(PI/16.);\n    \n    float mask = 0.;\n    for (float i = 0.; i <= 2.* PI; i+= PI/8.) // thick 8 lines\n    {\n       uv *=  rotate2d(i);\n        \n       uv += vec2(0., .295);\n\t\n       mask += Triangle(uv); \n        \n       uv -= vec2(0., .295);\n    }\n    return mask; \n}\n\n\n\n\n\nvec4 CenterCircle(vec2 uv)\n{\n    float d = length(uv);\n    \n\tvec4 col = vec4(0.);\n    col.a = S(.15, .149, d);            \n    \n    float brownLine3 = S(.15, .148, d);\n    col.rgb = mix(col.rgb, vec3(0.31, 0.196, 0.14), brownLine3); \n    \n    \n    \n    float greenRing = S(.148, .146, d);\n    col.rgb = mix(col.rgb, vec3(.678, .910, .931), greenRing);      \n    \n    \n    \n    float purpleRing = S(.136, .135, d);\n   \tcol.rgb = mix(col.rgb, vec3(.757, .773, 925), purpleRing);    \n    \n    \n    float blueCenter = S(.126, .125, d);\n    col.rgb = mix(col.rgb, vec3(0.8, 0.894, 0.996), blueCenter);  \n    \n    \n    \n    \n \n    return col;\n\n}\n\nvec4 Base(vec2 uv)\n{\n    \n\tvec4 col = vec4(0.937, 0.937, 0.812, 1.);\n    \n    //d = distance\n    float d = length(uv);\n    \n    col.a = S(.5, .49, d);\n    \n    \n    float edgeShade = remap01(.45, .5, d);\n        \n    edgeShade *= edgeShade;\n    col.rgb *= 1. - edgeShade * .5;\n    \n\n    \n    col.rgb = mix(col.rgb, vec3(0.937, 0.937, 0.812), S(.475, .485, d)); //edge shadow\n    \n    col.rgb = mix(col.rgb, vec3(0.31, 0.196, 0.14), S(.48, .49, d));   //Brown outline\n    \n    \n    float purpleOutter = S(.445, .435, d); //purple outter ring\n    \n    col.rgb = mix(col.rgb, vec3(.757, .773, 925), purpleOutter);\n    \n    \n    float green = S(.43, .42, d);//green ring\n    col.rgb = mix(col.rgb, vec3(.678, .910, .931), green);\n    \n    \n    float purpleInner = S(.37, .36, d); //purple inner ring\n    \n    col.rgb = mix(col.rgb, vec3(.757, .773, 925), purpleInner);\n    \n    float yellowCenter1 = S(.355, .345, d);\n    col.rgb = mix(col.rgb, vec3(0.925, 0.953, 0.957), yellowCenter1);\n    \n    \n    float brownLine1 = S(.28, .279, d);\n    col.rgb = mix(col.rgb, vec3(0.31, 0.196, 0.14), brownLine1);\n    \n    float yellowCenter2 = S(.279, .277, d);\n    col.rgb = mix(col.rgb, vec3(0.925, 0.953, 0.957), yellowCenter2);    \n    \n    \n    float brownLine2 = S(.205, .203, d);\n    col.rgb = mix(col.rgb, vec3(0.31, 0.196, 0.14), brownLine2);\n    \n    \n    float yellowCenter3 = S(.203, .202, d);\n    col.rgb = mix(col.rgb, vec3(0.925, 0.953, 0.957), yellowCenter3);   \n    \n    \n    float brownLine3 = S(.15, .148, d);\n    col.rgb = mix(col.rgb, vec3(0.31, 0.196, 0.14), brownLine3);    \n    \n    \n    float yellowCenter4 = S(.148, .146, d);\n    col.rgb = mix(col.rgb, vec3(0.8, 0.894, 0.996), yellowCenter4);  \n    \n        \n    \n    return col;\n}\n\n\n\nfloat Thick8LinesMask(vec2 uv)\n{\n    float mask = 0.;\n\n    for (float i = .0; i <= 2.* PI; i+= PI/4.) // thick 8 lines\n    {\n       uv *=  rotate2d(i);\n       mask = max(mask, Rect(uv, -.005, .005, -.49, .49, .001));\n    }\n    return mask;\n}\n\nfloat LightLinesMask(vec2 uv)\n{\n    float mask = 0.;\n\n    for (float i = .0; i <= 2.* PI; i+= PI/32.) // thick 8 lines\n    {\n       uv *=  rotate2d(i);\n       mask = max(mask, Rect(uv, -.001, .001, -.49, .49, .001));\n    }\n    return mask;\n}\n\nvec4 Rotunda(vec2 uv)\n{\n    vec4 lineColor = vec4(0.31, 0.196, 0.14, 1.);\n    vec4 diamondColor = vec4(0.906, 0.451, 0.529, 1.);\n    vec4 triColor = vec4(.678, .910, .931, 1.);\n    \n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.);\n    \n    vec4 base = Base(uv);\n    \n    float thicklines = Thick8LinesMask(uv);\n    \n    float lightlines = LightLinesMask(uv);\n    \n    float diamondRing = DiamondRing(uv);\n    \n    float triRing = TriRing(uv);\n    \n    vec4 center = CenterCircle(uv);\n    \n    \n    col = mix(col, base, base.a);\n    \n    col = mix(col, lineColor, thicklines);\n    \n    col = mix(col, center, center.a);\n    \n    col = mix(col, triColor, triRing);   \n    \n    col = mix(col, diamondColor, diamondRing);\n    \n    //col = mix(col, lineColor, lightlines);\n    \n\n    return col;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.xy;\n\n\tuv -= .5;\n    uv.x *=\tiResolution.x/iResolution.y;\n\t\n    \n    uv *=  rotate2d(iTime/3.);\n    \n\tuv *= 1.5;\n    \n\n    \n    fragColor = Rotunda(uv);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tySz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 151, 151, 189], [191, 191, 233, 233, 275], [277, 277, 329, 329, 451], [453, 453, 481, 481, 563], [565, 565, 622, 622, 763], [765, 765, 848, 848, 976], [978, 978, 1010, 1010, 1138], [1339, 1339, 1365, 1365, 1511], [1513, 1513, 1541, 1541, 1826], [1828, 1828, 1853, 1925, 1999], [2001, 2001, 2025, 2025, 2311], [2317, 2317, 2345, 2345, 2956], [2958, 2958, 2978, 2978, 4702], [4706, 4706, 4738, 4738, 4947], [4949, 4949, 4980, 4980, 5190], [5192, 5192, 5215, 5215, 5972], [5976, 5976, 6033, 6083, 6272]], "test": "untested"}
{"id": "WtyXzt", "name": "Day 76", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 7, "viewed": 499, "published": 3, "date": "1583359898", "time_retrieved": "2024-07-30T21:20:27.997958", "image_code": "// fake volumetric\n// hex function from BigWIngs - check out his tutorial on youtube\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.)*0.2;\n    float chromAb = dot(uvn,uvn)*13.;\n    vec2 offs = vec2(0) + texture(iChannel1, uv + iTime*4.).xz*0.0;\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.99;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.x += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.y += texture(iChannel0, target).y;\n    \tradial.z += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    \n    \n    \n    radial /= steps;\n    \n    fragColor = texture(iChannel0, uv)*0.6 + radial*0.4; \n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    fragColor *= 1.7;\n    //fragColor = pow(fragColor, vec4(0.45));\n\t\n    float duvuv = dot(uvn,uvn);\n    \n    fragColor = pow(fragColor, vec4(0.49 - clamp(duvuv*0.4, 0., 0.50)));\n    \n    fragColor *= 1. - duvuv*1.7;\n    \n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    //fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 glow = vec3(0);\n\nvec4 noise(vec2 u){\n\treturn texture(iChannel0, (u)/256.);\n}\n#define pmod(p,x) (mod(p,x) - 0.5*x)\n#define dmin(a,b) a.x < b.x ? a : b\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin(tau*((c)*(d) + e)))\n\n\nvec3 path(float z){\n    z *= 0.24;\n\treturn vec3(\n    \tsin(z + cos(z)*0.6),\n    \tcos(z + sin(z*0.8)*0.5),\n    \t0.\n    )*0.9;\n}\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n#define pi acos(-1.)\n#define tau (2.*pi)\nvec3 pCoords = vec3(0);\n\nfloat tCoords = 0.;\nvec3 cCoords = vec3(0.);\n\n#define coolPal(a,b) pal(0.2,0.6,vec3(0.97,3.4 + sin(b)*0.2,0.8),0.4 + (a),2.1 + (b))\n#define tunnW 0.8\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    \n    p.xy *= rot(0. + sin(p.z)*0.24 + cos(p.y)*0.13);\n\tp -= path(p.z);\n\tfloat wave = pow(abs(sin(p.z*0.2 + iTime*0.7)), 40.);\n    \n    pCoords = vec3(atan(p.y,p.x)/tau, length(p.xy), p.z);\n    \n    float tunn = -length(p.xy + normalize(p.xy)*wave*0.15) + tunnW;\n    \n    //tunn = max(tunn, - max(abs(p.x)- 2.,abs(p.y) - 0.2 ));\n    \n    d = dmin(d, vec2(tunn, 2.));\n    \n    vec3 pCoordsB = pCoords;\n    pCoordsB.y -= 0.4;\n    pCoordsB.x = pmod(pCoordsB.x, 0.05)/0.05;\n    pCoordsB.z = pmod(pCoordsB.z, 1.)/1.;\n    \n    pCoordsB = abs(pCoordsB) - 0.5;\n    float dCubeGlow = max(pCoordsB.x, max(pCoordsB.y,pCoordsB.z));\n    \n    \n    glow += max(exp(-dCubeGlow*10.)*0.02*pow(wave,0.4)*pal(0.4,0.6,vec3(0.3,0.6,0.9),0.5,0.1)*0.4, 0.);\n    \n    float attA = pow(abs(sin(sin(p.z + iTime) + p.z*0.7 + sin(p.y*1.5) + iTime*0.4) ), 10.);\n    float attB = pow(abs(sin(iTime*0.2 + sin(p.z + iTime) + p.z*0.4 + sin(p.y*1.5))), 10.);\n    glow += attB*smoothstep(0.,1.,length(p.xy)*0.8)*max(exp(-dCubeGlow*12.)*0.02*pal(0.8,0.6,vec3(0.3,0.6,0.5),0.5,0.4)*0.7, 0.);\n\n    \n    vec3 c = max(coolPal(0.3, 1.5), 0.);\n    \n    vec3 q = p;\n    float pipe;\n\n    q = p;\n    \n    float net;\n    \n    pCoordsB = pCoords;\n    pCoordsB.y -= 0.7;\n    pCoordsB.x = pmod(pCoordsB.x,1./8.)/(1./8.);\n    pCoordsB.z = pmod(pCoordsB.z,1.)/(1.);\n    float ww = 0.01;\n    net = length(pCoordsB.xy) - ww;\n    net = min(net,length(pCoordsB.yz) - ww);\n    \n    glow += exp(-net*(20. - pow(wave,0.4)*10. + sin(p.z)*4.))*max(coolPal(0.3, 1.6), 0.)*0.5;\n    d.x *= 0.5;\n\treturn d;\n}\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\tt = 0.; hit = false; p = ro;\n    for(int i = 0; i < 150; i++){\n    \td = map(p);\n        glow += exp(-max(d.x, 0.)*20.)*0.01;\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = cross(vec3(0,1,0), dir);\n\tvec3 up = cross(dir, right);\n    float fov = 1. + sin(iTime)*0.1;\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\n\n#define mx (10.*iMouse.x/iResolution.x)\n#define my (10.*iMouse.y/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\tuv *= 1. + dot(uv,uv)*1.5;\n    \n    vec3 ro = vec3(0);\n    ro.z += iTime*SPEED+ sin(iTime)*1.;\n    ro.z += mx;\n        \n    ro += path(ro.z);\n    \n    float wave = pow(abs(sin(ro.z*0.2 + iTime*0.7 + 0.17)), 20.);\n    \n    vec3 lookAt = vec3(0,0,ro.z);\n    lookAt.z += 2.;\n    lookAt += path(lookAt.z); \n\tvec3 rd = getRd(ro, lookAt, uv*(1. + wave*0.2));\n    \n    ro -= rd*texture(iChannel0,(uv)*16.).x*0.7; // remove banding from glow\n    \n    \n    rd.xy *= rot(sin(iTime + sin(iTime*0.4)*0.5 )*0.1);\n    \n    float t; vec3 p; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if(hit){\n    \n        if(d.y == 2.){\n            vec4 hc = HexCoords(vec2(8.*pCoords.x, pCoords.z*2.)*1.);\n            vec4 hcc = hc;\n            float dHex = 10e6;\n            \n            float md = 0.2;\n            \n            float formula = hc.y + iTime*0.03;\n            formula += hc.w*0.2;\n            float id = floor(formula/md);\n            hc.y = (pmod(formula, md))/md;\n            hc.y += 0.05;\n            \n            \n            dHex = min(dHex,abs(hc.y) - 0.1);\n            \n            vec3 c = coolPal(0. + 0.35, sin(id)*0.1);\n            c *= max(0.,sin(id*0.9 + sin(hc.w)*4.));\n            \n            c = max(c, 0.);\n            \n            \n            col -= hcc.y*0.1;\n            \n            float atten = sin(p.x);\n            \n        }\n        if(d.y == 8.){\n            float dd;\n            \n            cCoords = pmod(abs(cCoords),0.2)/0.2;\n            \n            cCoords = cCoords - 0.1;\n        }\n        \n    }\n    \n    col += pow(glow,vec3(1./0.45))*0.01;\n    \n    col = max(col, 0.);\n    col = mix(col, vec3(0.4,0.5,0.9)*1.5,pow(smoothstep(0.,1.,t*0.06), 3.9));\n    \n    col *= 2.4;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED (1.5 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 143, 143, 1381]], "test": "untested"}
{"id": "ttyXzt", "name": "Kuu", "author": "yx", "description": "A shadertoy port of my Grafiikka entry at Instanssi 2020. Placed 2nd out of 16 entries.\n\nDownload the original executable version here: [url]https://www.pouet.net/prod.php?which=84949[/url]", "tags": ["raymarching", "sdf", "pathtraced"], "likes": 24, "viewed": 1033, "published": 3, "date": "1583351815", "time_retrieved": "2024-07-30T21:20:28.771888", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 tex = texture(iChannel0,uv);\n    \n    // divide by sample-count\n\tvec3 color = tex.rgb/tex.a;\n    \n    #if !GRADING\n    fragColor.rgb=color;return;\n    #endif\n    \n\t// vignette to darken the corners\n\tuv-=.5;\n\tcolor *= 1.-dot(uv,uv)*.8;\n\n    // exposure and tonemap\n    color *= .3;\n    color = 1.-exp(color*-2.);\n\n\t// gamma correction\n\tcolor = pow(color, vec3(.45));\n\n    // make it pop\n    color = smoothstep(.44,.98,color);\n\t    \n\tfragColor = vec4(color,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SHADING 1\n#define BOKEH (SHADING && 1)\n#define GRADING (SHADING && 1)\n\n/*\n\n~ Kuu\n  by yx/Polarity\n\n~ 2.4kb executable graphics\n  released at Instanssi 2020\n\n~ should take no longer than 15 seconds to render\n\n~ tools:\n  crinkler 2.1a by loonies & tbc\n  shader minifier by llb\n\n~ greetings:\n  alkama\n  blackle\n  cpdt\n  evvvvil\n  fizzer\n  flopine\n  noby\n  nusan\n  slerpy\n  tdhooper\n\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 565]], "test": "untested"}
{"id": "ttGXzt", "name": "Chaosflux Intro shader", "author": "NinjaKoala", "description": "Intro shader for Chaosflux (www.chaosflux.de/en/)", "tags": ["procedural", "2d", "sound", "bezier", "bassdrum", "svg", "chaosflux"], "likes": 8, "viewed": 481, "published": 3, "date": "1583349758", "time_retrieved": "2024-07-30T21:20:29.904859", "image_code": "\n/*\nTweak audio offset at the beginning of the common tab if video and sound are out of sync\nThe logo is generated with a script from svg (see https://www.shadertoy.com/view/Wtt3Wl)\nMost handwritten code is in common tab.\n*/\n\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tconst int num_its=3;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tfor(int i=ZERO;i<3;i++){\n\t\tt=params[i];\n\t\tfor(int j=ZERO;j<num_its;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n    \n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n        nor=vec2(nor.y,-nor.x);\n        \n        float sgn;\n        \n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n        else{\n            sgn=-1.;\n        }\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\n\tint n_ints = 0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    else{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat c1_dis(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[45] p=vec2[](vec2(-0.105141,0.182258),\n\t                  vec2(-0.11508,0.164798),\n\t                  vec2(-0.11508,0.164798),\n\t                  vec2(-0.0522583,0.12777),\n\t                  vec2(-0.0366835,0.071916),\n\t                  vec2(-0.0232558,0.0237615),\n\t                  vec2(-0.0335432,-0.0292464),\n\t                  vec2(-0.0183582,-0.0897851),\n\t                  vec2(-0.0314756,-0.108016),\n\t                  vec2(-0.0494529,-0.125753),\n\t                  vec2(-0.066798,-0.140289),\n\t                  vec2(-0.0946587,-0.163637),\n\t                  vec2(-0.120175,-0.179013),\n\t                  vec2(-0.120175,-0.179013),\n\t                  vec2(-0.109808,-0.196231),\n\t                  vec2(-0.109808,-0.196231),\n\t                  vec2(-0.0830266,-0.180124),\n\t                  vec2(-0.0538651,-0.155685),\n\t                  vec2(-0.0393691,-0.143537),\n\t                  vec2(-0.0241098,-0.129402),\n\t                  vec2(-0.0111155,-0.113782),\n\t                  vec2(-0.00953226,-0.118148),\n\t                  vec2(-0.00781082,-0.122568),\n\t                  vec2(-0.00589974,-0.127012),\n\t                  vec2(0.0111504,-0.166663),\n\t                  vec2(0.0429379,-0.184876),\n\t                  vec2(0.0695119,-0.192438),\n\t                  vec2(0.0960858,-0.2),\n\t                  vec2(0.118602,-0.197645),\n\t                  vec2(0.118602,-0.197645),\n\t                  vec2(0.116566,-0.177646),\n\t                  vec2(0.116566,-0.177646),\n\t                  vec2(0.0976779,-0.179565),\n\t                  vec2(0.074988,-0.173109),\n\t                  vec2(0.0522982,-0.166652),\n\t                  vec2(0.0269573,-0.152586),\n\t                  vec2(0.0125464,-0.119072),\n\t                  vec2(0.00466514,-0.100628),\n\t                  vec2(-0.000302719,-0.0809023),\n\t                  vec2(-0.00305472,-0.0624878),\n\t                  vec2(-0.0101084,-0.0146491),\n\t                  vec2(-0.00427636,0.0305246),\n\t                  vec2(-0.0173262,0.0773271),\n\t                  vec2(-0.0359264,0.144031),\n\t                  vec2(-0.105141,0.182258));\n\n\tivec2[3] seg=ivec2[](ivec2(0,1),\n\t                     ivec2(13,14),\n\t                     ivec2(29,30));\n\n\tivec4[14] c_bez=ivec4[](ivec4(1,2,3,4),\n\t                        ivec4(4,5,6,7),\n\t                        ivec4(7,8,9,10),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(14,15,16,17),\n\t                        ivec4(17,18,19,20),\n\t                        ivec4(20,21,22,23),\n\t                        ivec4(23,24,25,26),\n\t                        ivec4(26,27,28,29),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,0));\n\n\tif(all(lessThan(uv,vec2(0.118602,0.182258)+border)) && all(greaterThan(uv,vec2(-0.120175,-0.2)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<14;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*sqrt(dis_sq);\n}\n\nfloat c2_dis(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[20] p=vec2[](vec2(0.115786,0.105228),\n\t                  vec2(0.115786,0.105228),\n\t                  vec2(0.0749222,0.0961511),\n\t                  vec2(0.0326449,0.0753585),\n\t                  vec2(-0.00963247,0.0545663),\n\t                  vec2(-0.0555063,0.0214215),\n\t                  vec2(-0.0606167,-0.0293583),\n\t                  vec2(-0.0700874,-0.123468),\n\t                  vec2(-0.0190461,-0.184747),\n\t                  vec2(-0.0190461,-0.184747),\n\t                  vec2(-0.00365474,-0.171851),\n\t                  vec2(-0.00365474,-0.171851),\n\t                  vec2(-0.0492953,-0.117546),\n\t                  vec2(-0.040622,-0.0313615),\n\t                  vec2(-0.0366603,0.00800584),\n\t                  vec2(0.00178575,0.0377826),\n\t                  vec2(0.0415353,0.0573318),\n\t                  vec2(0.0812846,0.0768809),\n\t                  vec2(0.120178,0.0856193),\n\t                  vec2(0.120178,0.0856193));\n\n\tivec2[2] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(19,0));\n\n\tivec4[6] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(3,4,5,6),\n\t                       ivec4(6,7,8,9),\n\t                       ivec4(10,11,12,13),\n\t                       ivec4(13,14,15,16),\n\t                       ivec4(16,17,18,19));\n\n\tif(all(lessThan(uv,vec2(0.120178,0.105228)+border)) && all(greaterThan(uv,vec2(-0.0700874,-0.184747)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<6;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*sqrt(dis_sq);\n}\n\nfloat f_dis(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[51] p=vec2[](vec2(0.109562,0.2),\n\t                  vec2(0.109562,0.2),\n\t                  vec2(0.037349,0.170164),\n\t                  vec2(0.0173221,0.0971424),\n\t                  vec2(0.00947485,0.0701233),\n\t                  vec2(0.00781763,0.0430998),\n\t                  vec2(0.00790292,0.0164592),\n\t                  vec2(0.00797488,-0.00543141),\n\t                  vec2(0.00806484,-0.0253073),\n\t                  vec2(-0.00108769,-0.0567024),\n\t                  vec2(-0.00608919,-0.0738517),\n\t                  vec2(-0.0187514,-0.092047),\n\t                  vec2(-0.034038,-0.108926),\n\t                  vec2(-0.0445917,-0.120389),\n\t                  vec2(-0.0556361,-0.13091),\n\t                  vec2(-0.0668022,-0.140296),\n\t                  vec2(-0.094663,-0.163644),\n\t                  vec2(-0.120179,-0.17902),\n\t                  vec2(-0.120179,-0.17902),\n\t                  vec2(-0.109812,-0.196239),\n\t                  vec2(-0.109812,-0.196239),\n\t                  vec2(-0.0830308,-0.180131),\n\t                  vec2(-0.0538693,-0.155692),\n\t                  vec2(-0.0442579,-0.147632),\n\t                  vec2(-0.0348368,-0.138945),\n\t                  vec2(-0.026665,-0.130701),\n\t                  vec2(-0.00684664,-0.110669),\n\t                  vec2(0.010864,-0.0874883),\n\t                  vec2(0.0182046,-0.0623181),\n\t                  vec2(0.0280318,-0.0286219),\n\t                  vec2(0.0280435,-0.00538805),\n\t                  vec2(0.0279668,0.0165335),\n\t                  vec2(0.0279309,0.0276838),\n\t                  vec2(0.0278949,0.0385177),\n\t                  vec2(0.0290266,0.0507666),\n\t                  vec2(0.0331576,0.0530595),\n\t                  vec2(0.0373322,0.0552654),\n\t                  vec2(0.0415317,0.0573307),\n\t                  vec2(0.081281,0.0768799),\n\t                  vec2(0.120179,0.0856134),\n\t                  vec2(0.120179,0.0856134),\n\t                  vec2(0.115781,0.105222),\n\t                  vec2(0.115781,0.105222),\n\t                  vec2(0.0750217,0.0961694),\n\t                  vec2(0.0328012,0.0754328),\n\t                  vec2(0.0338771,0.0806009),\n\t                  vec2(0.0351061,0.0859649),\n\t                  vec2(0.0367155,0.0918335),\n\t                  vec2(0.0538191,0.154196),\n\t                  vec2(0.117361,0.181442),\n\t                  vec2(0.117362,0.181442));\n\n\tivec2[3] seg=ivec2[](ivec2(18,19),\n\t                     ivec2(40,41),\n\t                     ivec2(50,0));\n\n\tivec4[16] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(41,42,43,44),\n\t                        ivec4(44,45,46,47),\n\t                        ivec4(47,48,49,50));\n\n\tif(all(lessThan(uv,vec2(0.120179,0.2)+border)) && all(greaterThan(uv,vec2(-0.120179,-0.196239)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<16;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*sqrt(dis_sq);\n}\n\nfloat func(float x, float y){\n\n\tx=abs(mod(x,2.)-1.);\n\n\treturn (((-2.*y)*x)+(3.*y))*x*x;\n}\n\nfloat func_derv(float x, float y){\n\n\tx=abs(mod(x,2.)-1.);\n\n\treturn 6.*y*x*(1.-x);\n}\n\nfloat wallpaper_dis(vec2 uv, float wavelen){\n\tuv.y=abs(mod(uv.y,wavelen)-wavelen/2.);\n\n\tfloat dis=1e38;\n\n\tfor(float i=0.;i<4.;i+=1.){\n\n\t\tfloat x=uv.x*2./wavelen;\n\t\tfloat y=wavelen/2.*(.65+i*.05);\n\n\t\tvec2 grad=vec2(2./wavelen*func_derv(x,y),1);\n\n\t\tfloat cur_dis=abs(uv.y-func(x,y))/length(grad);\n\n\t\tdis=min(cur_dis,dis);\n\t}\n\n\treturn dis;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tuv.x*=iResolution.x/iResolution.y;\n\n\tborder=2./iResolution.y;\n\n\tfloat zoom=1.7;\n\n\tuv*=zoom;\n\tborder*=zoom;\n    \n\tvec3 bg_col=chaosflux_color2;\n    vec3 pattern_col=chaosflux_color3;\n\n\tconst vec3 disk_col=black;\n\tconst vec3 font_col=white;\n\n\tvec3 color=bg_col;\n\n\tfloat dis=1e38;\n    \n    float thickness=.002;\n\tfloat wavelen=.6;\n\n\tfloat disk_alpha1=1.;\n\tfloat disk_alpha2=1.;\n\tfloat disk_alpha3=1.;\n    \n    float t0=iTime-(pattern_start_time+audio_offset+pattern2_start_time);\n    \n    vec2 lb=last_beat(t0);\n\n    float t1=disk_animation(t0);\n    float t2=disk_animation(lb.x);\n    \n    if(t0<smooth_movement_time){\n    \tt1=t2;\n    }\n    \n    vec3 fp=fade_pattern(iTime);\n\n    disk_alpha1=fp.x;\n    disk_alpha2=fp.y;\n    disk_alpha3=fp.z;\n\n    dis=min(dis,wave_pattern(iTime,uv));\n    float fade=1.-smoothstep(-wave_border,wave_border,dis);\n    dis=1e38;\n\n    dis=min(dis,wallpaper_dis(uv,wavelen)-thickness);\n    dis=min(dis,wallpaper_dis(uv.yx,wavelen)-thickness);\n    vec3 pattern_color=mix(pattern_col,color,smoothstep(-border/2.,border/2.,dis));\n    color=mix(pattern_color,color,fade);\n    dis=1e38;\n\n\tvec2 disk_center1=t1*original_disk_center1;\n\tvec2 disk_center2=t1*original_disk_center2;\n\tvec2 disk_center3=t1*original_disk_center3;\n\n    if(t1==0.){\n        float alpha=clamp(disk_alpha1+disk_alpha2+disk_alpha3,0.,1.);\n        \n\t\tdis=min(dis,distance(disk_center1,uv)-disk_radius);\n\t\tcolor=mix(mix(color,disk_col,alpha),color,smoothstep(-border/2.,border/2.,dis));\n\t\tdis=1e38;\n    }\n    else{\n        dis=min(dis,distance(disk_center1,uv)-disk_radius);\n\t\tcolor=mix(mix(color,disk_col,disk_alpha1),color,smoothstep(-border/2.,border/2.,dis));\n\t\tdis=1e38;\n        dis=min(dis,distance(disk_center2,uv)-disk_radius);\n        color=mix(mix(color,disk_col,disk_alpha2),color,smoothstep(-border/2.,border/2.,dis));\n        dis=1e38;\n        dis=min(dis,distance(disk_center3,uv)-disk_radius);\n        color=mix(mix(color,disk_col,disk_alpha3),color,smoothstep(-border/2.,border/2.,dis));\n        dis=1e38;\n    }\n    \n    if(t0<rgb_logo_time || !rgb_flicker(t0-rgb_logo_time)){\n    \tdis=min(dis,c1_dis(uv-disk_center1));\n        color=mix(mix(color,font_col,disk_alpha1),color,smoothstep(-border/2.,border/2.,dis));\n        dis=1e38;\n        dis=min(dis,c2_dis(uv-disk_center2));\n        color=mix(mix(color,font_col,disk_alpha2),color,smoothstep(-border/2.,border/2.,dis));\n        dis=1e38;\n        dis=min(dis,f_dis(uv-disk_center3));\n        color=mix(mix(color,font_col,disk_alpha3),color,smoothstep(-border/2.,border/2.,dis));\n    }\n    else{\n        const vec3[4] colors=vec3[4](blue,green,red,black);\n        \n        for(int i=ZERO;i<4;i++){\n            dis=min(dis,c1_dis(uv+float(-3+2*i)*logo_offset));\n            dis=min(dis,c2_dis(uv+float(-3+2*i)*logo_offset));\n            dis=min(dis,f_dis(uv+float(-3+2*i)*logo_offset));\n            color=mix(colors[i],color,smoothstep(-border/2.,border/2.,dis));\n            dis=1e38;\n        }\n    }\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "//Tweak if image and sound are out of sync\nconst float audio_offset=.5;\n\nfloat border;\n\nconst float eps=.0015;\nconst float eps2=exp2(-14.);\nconst float pi=3.14159265358979;\n\nconst float beat_time_fac=.3;\n\nconst vec3 freqs=vec3(43.6535,55.,65.4064);\n\nconst float pattern_start_time=.5;\nconst float pattern2_start_time=5.;\n\nconst float disk_radius=.275;\n\nconst float rgb_logo_time=15.;\nconst float flicker_dur=.07;\nconst float flicker1=.1;\nconst float flicker2=.3;\nconst float flicker3=1.;\n\nconst float fizzle_dur1=.025;\nconst float fizzle_dur2=.0125;\nconst float fizzle_dur3=.05;\n\nconst vec3 white=vec3(1);\nconst vec3 black=vec3(0);\nconst vec3 red=vec3(1,0,0);\nconst vec3 green=vec3(0,1,0);\nconst vec3 blue=vec3(0,0,1);\n\nconst vec3 chaosflux_color1=vec3(.686274509803922,.905882352941176,.729411764705882);\nconst vec3 chaosflux_color2=vec3(.788235294117647,.3678431372549,.36078431372549);\nconst vec3 chaosflux_color3=vec3(.913725490196078,.87843137254902,.643137254901961);\n\nconst vec2 original_disk_center1=vec2(-1.1,0);\nconst vec2 original_disk_center2=vec2(0);\nconst vec2 original_disk_center3=vec2(1.1,0);\n\nconst vec2 logo_offset=vec2(.005,.0);\n\nconst float wave_speed=2.;\nconst float wave_border=.025;\n\nconst float time_fac=.5;\nconst int max_speed=7;\nconst int speed_fac=2;\n\nconst float dur=4.5;\nconst float begin=9.5;\nconst float fade_time=1.5;\n\nconst float attack_amp=.038;\nconst float attack_time=.17;\nconst float decay_time=.1;\nconst float sustain_amp=.035;\nconst float sustain_time=.1;\nconst float increase_time=.6;\nconst float increase_amp=.073;\nconst float release_time=.05;\n\nconst float attack_param=.8;\nconst float sustain_param=.7;\nconst float increase_param=.9;\n\nconst float detune_width=.025;\nconst float offset_width=.05;\n\nconst float vibrato_depth=.2;\nconst float vibrato_freq=8.;\n\nconst float drum_time=1.;\n\nconst float animation_dur=10.;\n\nconst float drum_time_pow=.7;\n\nconst float drum_exp_fac=1.;\nconst float drum_lin_fac=1.;\nconst float drum_freq_fac=.5;\nconst float drum_filter_fac=1.;\nconst float drum_kick_fac=2.;\nconst float drum_bass_fac=1.;\nconst float drum_amp=.6;\n\nconst float sine_amp=2.5;\n\nconst float smooth_movement_time=8.5;\n\nconst vec2 drum1_pan=vec2(1.,.1);\nconst vec2 drum2_pan=vec2(1.,1.);\nconst vec2 drum3_pan=vec2(.1,1.);\n\n#define ZERO min(0,iFrame)\n\nfloat filtered_triangle(float x, float fac){\n    float val=0.;\n    \n    x*=4.;\n    \n    float old_x=mod(x,4.);\n    \n    x=mod(x,2.);\n    \n    if(x>=1.){\n        x=2.-x;\n    }\n    \n    if(x<fac){\n        val=x;\n    }\n    else if(x<=1.){\n        float tmp=1.-fac;\n        val=fac+sin(mod((x-fac)/tmp*.5*pi,2.*pi))*tmp*2./pi;\n    }\n    \n    if(old_x>2.){\n        val*=-1.;\n    }\n    \n    return val;\n}\n\n//modified from https://www.shadertoy.com/view/llGSzw\nfloat hash(float t)\n{\n    uint n=uint(t*iSampleRate);\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash4(float t)\n{\n    uint n=uint(t*iSampleRate);\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec4 k = n * uvec4(n,n*16807U,n*48271U,n*72037U);\n    return vec4( k & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat exp_decay(float t, float decay_time){\n    return exp(log(eps)*t/decay_time);\n}\n\nfloat linear_decay(float t, float duration){\n    return max(0.,1.-max(0.,t)/duration);\n}\n\nfloat linear_attack(float t, float duration){\n    return clamp(t/duration,0.,1.);\n}\n\n//attack, decay, sustain, increase, release\nfloat linear_adsir(float t, float att_amp, float att_time, float dec_time, float sus_amp, float sus_time, float inc_amp, float inc_time, float rel_time){\n    float amp=0.;\n    \n    t=max(0.,t);\n                  \n    if(t<att_time){\n        amp=att_amp*linear_attack(t,att_time);\n    }\n    else if(t<att_time+dec_time){\n        amp=mix(att_amp,sus_amp,linear_attack(t-att_time,dec_time));\n    }\n    else if(t<att_time+dec_time+sus_time){\n        amp=sus_amp;\n    }\n    else if(t<att_time+dec_time+sus_time+inc_time){\n        amp=mix(sus_amp,inc_amp,linear_attack(t-(att_time+dec_time+sus_time),inc_time));\n    }\n    else if(t<att_time+dec_time+sus_time+inc_time+rel_time){\n        amp=mix(inc_amp,0.,linear_attack(t-(att_time+dec_time+sus_time+inc_time),rel_time));\n    }\n \n    return amp;\n}\n\nfloat fizzle(float t, float dur){\n    float amp=.0;\n    if(t>0. && t<dur){\n        amp=.1;\n    }\n    \n    return amp*sin(10.*t*2.*pi)*(.2+max(0.,.8*sin(100.*t*2.*pi)))*(-1.+(hash(t)+hash(t+.001)));\n}\n\nfloat drum(float t, float freq, float beat_t, float speed){\n    //beat_t is the time of the beat\n    //speed is for changing sound according to current rythm speed\n    \n    float cur_drum_time=drum_time/pow(speed,drum_time_pow);\n    \n    float amp_decay_time=drum_exp_fac*drum_time;\n    float lin_amp_decay_time=drum_lin_fac*drum_time;\n    float freq_decay_time=drum_freq_fac*cur_drum_time;\n    float filter_decay_time=drum_filter_fac*cur_drum_time;\n    \n    float kick_freq=drum_kick_fac*freq;\n    float bass_freq=drum_bass_fac*freq;\n    \n    t=max(0.,t-beat_t);\n    \n    float tmp=log(eps)/freq_decay_time;\n    float phase=(exp(tmp*t)-1.)/tmp*(kick_freq-bass_freq)+bass_freq*t;\n    \n    float amp=drum_amp*exp_decay(t,amp_decay_time)*linear_decay(t,lin_amp_decay_time);\n    \n    float filter_val=exp_decay(t,filter_decay_time);\n    \n    return amp*filtered_triangle(phase,filter_val);\n}\n\nfloat sine_tone(float t, float freq, float dur){\n\n    float amp=1.;\n    \n    float param=linear_adsir(t,attack_param,attack_time*dur,decay_time*dur,sustain_param,sustain_time*dur,increase_param,increase_time*dur,release_time*dur);\n    amp*=linear_adsir(t,attack_amp,attack_time*dur,decay_time*dur,sustain_amp,sustain_time*dur,increase_amp,increase_time*dur,release_time*dur);\n    amp*=1.+vibrato_depth*sin(mod(max(t-dur*(attack_time+decay_time+sustain_time),0.)*vibrato_freq*2.*pi,2.*pi));\n    \n    return amp*filtered_triangle(t*freq,param);\n}\n\nfloat fade(float t, float duration){\n    float val=0.;\n    \n    if(t>0. && t<duration){\n        val=1.;\n    }\n    \n    return val;\n}\n\nbool rgb_flicker(float t){\n\tbool show=false;\n    \n    if((t>flicker1 && t<flicker1+flicker_dur) || (t>flicker2 && t<flicker2+flicker_dur) || t>flicker3){\n        show=true;\n    }\n    \n    return show;\n}\n\nfloat disk_animation(float t){\n    return max(1.-1./animation_dur*max(t,0.),0.);\n}\n\nfloat beat_wave(float t, float t0, vec2 uv, vec2 wave_center, float dis){\n    float wave_rad=wave_speed*(t-t0);\n    \n    float dis_abs=abs(dis);\n    float dis_sign=sign(dis);\n    \n    float tmp_dis=1e38;\n    \n    if(t>t0){\n        tmp_dis=distance(uv,wave_center)-wave_rad;\n    }\n    \n    dis_abs=min(dis_abs,abs(tmp_dis));\n    dis_sign*=sign(tmp_dis);\n    \n    return dis_abs*dis_sign;\n}\n\nvec2 drum_pattern1(float t){\n    vec2 val=vec2(0);\n    \n\tval+=drum(t,freqs[1],0.*beat_time_fac,1.)*drum1_pan;\n\tval+=drum(t,freqs[1],1.*beat_time_fac,1.)*drum2_pan;\n\tval+=drum(t,freqs[1],3.*beat_time_fac,1.)*drum3_pan;\n\tval+=drum(t,freqs[0],5.*beat_time_fac,1.)*drum1_pan;\n\tval+=drum(t,freqs[0],7.*beat_time_fac,1.)*drum2_pan;\n\tval+=drum(t,freqs[2],8.*beat_time_fac,1.)*drum3_pan;\n    \n    return val;\n}\n\nvec3 fade_pattern1(float t){\n    vec3 val=vec3(0);\n    \n    val+=fade(t-0.*beat_time_fac,1.*beat_time_fac)*vec3(1,0,0);\n    val+=fade(t-1.*beat_time_fac,2.*beat_time_fac)*vec3(0,1,0);\n    val+=fade(t-3.*beat_time_fac,2.*beat_time_fac)*vec3(0,0,1);\n    val+=fade(t-5.*beat_time_fac,2.*beat_time_fac)*vec3(1,0,0);\n    val+=fade(t-7.*beat_time_fac,1.*beat_time_fac)*vec3(0,1,0);\n    val+=fade(t-8.*beat_time_fac,1.*beat_time_fac)*vec3(0,0,1);\n    \n    return val;\n}\n\nfloat wave_pattern1(float t, vec2 uv){\n    float dis=1e38;\n    \n    dis=beat_wave(t,0.*beat_time_fac,uv,original_disk_center1,dis);\n    dis=beat_wave(t,1.*beat_time_fac,uv,original_disk_center2,dis);\n    dis=beat_wave(t,3.*beat_time_fac,uv,original_disk_center3,dis);\n    dis=beat_wave(t,5.*beat_time_fac,uv,original_disk_center1,dis);\n    dis=beat_wave(t,7.*beat_time_fac,uv,original_disk_center2,dis);\n    dis=beat_wave(t,8.*beat_time_fac,uv,original_disk_center3,dis);\n    \n    return dis;\n}\n\nvec2 last_beat(float t){\n    t=max(0.,t);\n    float t0=t;\n    \n    t*=time_fac;\n    \n    float second=floor(t);\n    \n    float speed=min(second+1.,float(max_speed))*float(speed_fac);\n    \n    float frac=fract(t);\n    \n    vec2 ret=vec2(0);\n    \n    //point in time of last beat\n    ret.x=(second+floor(frac*3.*speed)/(3.*speed))/time_fac;\n    //\"position\" of last beat\n    ret.y=mod(floor(frac*3.*speed),3.);\n    \n    return ret;\n}\n\nvec2 drum_pattern2(float t){\n    vec2 val=vec2(0);\n    \n    t=max(0.,t);\n    \n    float t0=t;\n    \n    t*=time_fac;\n    \n    float second=floor(t);\n    \n    float speed=min(second+1.,float(max_speed))*float(speed_fac);\n    float frac=fract(t);\n    \n    int n=int(ceil(drum_time*time_fac*3.*speed));\n    int ind0=int(frac*3.*speed);\n    int ind1=max(0,ind0-n);\n    for(int ind=ind0;ind>=ind1;ind--){\n        float beat=(second+float(ind)/(3.*speed))/time_fac;\n        int type=int(mod(float(ind),3.));\n        \n        vec2 drum_pan;\n        \n        if(type == 0){\n            drum_pan=drum1_pan;\n        }\n        else if(type == 1){\n            drum_pan=drum2_pan;\n        }\n        else if(type == 2){\n            drum_pan=drum3_pan;\n        }\n        \n        drum_pan=mix(vec2(1.),drum_pan,disk_animation(beat));\n\n        val+=drum(t0,freqs[type],beat,speed)*drum_pan;\n    }\n    \n    second-=1.;\n    speed=min(second+1.,float(max_speed))*float(speed_fac);\n    frac=t-second;\n    //n=int(ceil(drum_time*time_fac*3.*speed));\n    n=4;\n    ind0=int(3.*speed-1.);\n    ind1=max(0,ind0-n);\n    \n    for(int ind=ind0;ind>=ind1;ind--){\n        float beat=(second+float(ind)/(3.*speed))/time_fac;\n        int type=int(mod(float(ind),3.));\n\n        vec2 drum_pan;\n        \n        if(type == 0){\n            drum_pan=drum1_pan;\n        }\n        else if(type == 1){\n            drum_pan=drum2_pan;\n        }\n        else if(type == 2){\n            drum_pan=drum3_pan;\n        }\n        \n        drum_pan=mix(vec2(1.),drum_pan,disk_animation(beat));\n        \n        val+=drum(t0,freqs[type],beat,speed)*drum_pan;\n    }\n    \n    float val2=0.;\n\n    float fade_param=linear_attack(t0-begin,fade_time);\n\n    for(int i=1;i<3;i++){\n        for(int j=0;j<3;j++){\n            val2+=sine_amp*sine_tone(t0-(begin+offset_width*hash(92.81+float(i*3+j))),(1.+detune_width*hash(float(i*3+j)))*float(1<<i)*freqs[j],dur);\n        }\n    }\n    \n    val=mix(val,vec2(0),fade_param);\n    \n    float val3=.0;\n    \n    val3+=fizzle(t0-(rgb_logo_time+flicker1),fizzle_dur1);\n    val3+=fizzle(t0-(rgb_logo_time+flicker2),fizzle_dur2);\n    val3+=fizzle(t0-(rgb_logo_time+flicker3),fizzle_dur3);\n    \n    return val+val2+val3;\n}\n\nvec3 fade_pattern2(float t){\n    vec3 val=vec3(0);\n    \n    vec2 lb=last_beat(t);\n    \n    val[int(lb.y)]=1.;\n\t\n    if(t>animation_dur){\n        val=vec3(1);\n    }\n    \n    return val;\n}\n\nfloat wave_pattern2(float t, vec2 uv){\n    float dis=1e38;\n    \n    t=max(0.,t);\n    \n    float t0=t;\n    \n    t*=time_fac;\n    \n    float second=floor(t)-1.;\n    \n    float speed=min(second+1.,float(max_speed))*float(speed_fac);\n    float frac=t-second;\n    \n    int ind0=int(3.*speed-1.);\n    int ind1=0;\n    \n    vec2 wave_center=vec2(0);\n    \n    for(int ind=ind1;ind<=ind0;ind++){\n        float beat=(second+float(ind)/(3.*speed))/time_fac;\n        if(beat < begin+dur*(attack_time+decay_time+sustain_time+increase_time)){\n            int type=int(mod(float(ind),3.));\n\n            float t2=disk_animation(beat);\n\n            if(type==0){\n                wave_center=original_disk_center1*t2;\n            }\n            else if(type==1){\n                wave_center=original_disk_center2*t2;\n            }\n            else if(type==2){\n                wave_center=original_disk_center3*t2;\n            }\n\n            dis=beat_wave(t0,beat,uv,wave_center,dis);\n        }\n    }\n    \n    second+=1.;\n    speed=min(second+1.,float(max_speed))*float(speed_fac);\n    frac=t-second;\n    ind0=int(frac*3.*speed);\n    ind1=0;\n    \n    for(int ind=ind1;ind<=ind0;ind++){\n        float beat=(second+float(ind)/(3.*speed))/time_fac;\n        if(beat < begin+dur*(attack_time+decay_time+sustain_time+increase_time)){\n            int type=int(mod(float(ind),3.));\n\n            float t2=disk_animation(beat);\n\n            if(type==0){\n                wave_center=original_disk_center1*t2;\n            }\n            else if(type==1){\n                wave_center=original_disk_center2*t2;\n            }\n            else if(type==2){\n                wave_center=original_disk_center3*t2;\n            }\n\n            dis=beat_wave(t0,beat,uv,wave_center,dis);\n        }\n    }\n\n    return dis;\n}\n\nvec2 drum_pattern(float t){\n    t-=pattern_start_time;\n    \n    if(t<pattern2_start_time){\n        return drum_pattern1(t);\n    }\n    else{\n        return drum_pattern2(t-pattern2_start_time);\n    }\n}\n\nvec3 fade_pattern(float t){\n    t-=pattern_start_time+audio_offset;\n    \n    if(t<pattern2_start_time){\n        return fade_pattern1(t);\n    }\n    else{\n        return fade_pattern2(t-pattern2_start_time);\n    }\n}\n\nfloat wave_pattern(float t, vec2 uv){\n    t-=pattern_start_time+audio_offset;\n    \n    if(t<pattern2_start_time){\n        return wave_pattern1(t,uv);\n    }\n    else{\n        return wave_pattern2(t-pattern2_start_time,uv);\n    }\n}", "sound_code": "vec2 mainSound( in int samp,float time){\n    vec2 val=drum_pattern(time);\n    vec4 hash_val=hash4(time)*2.-1.;\n    val+=eps2*hash_val.xy+eps2*hash_val.zw;\n    return val;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 348, 397, 432, 612], [614, 699, 742, 742, 1757], [1759, 1759, 1840, 1859, 2034], [2036, 2036, 2114, 2114, 2573], [2575, 2575, 2600, 2600, 2619], [2621, 2621, 2668, 2668, 2779], [2781, 2781, 2829, 2829, 3147], [3149, 3149, 3220, 3220, 4090], [13298, 13298, 13327, 13327, 13387], [13389, 13389, 13423, 13423, 13472], [13474, 13474, 13518, 13518, 13812]], "test": "untested"}
{"id": "ttySzt", "name": "Conductive Fresnel", "author": "bhouston", "description": "This shows conductive (complex) Fresnel on the bottom, dielectric Fresnel on the top.  Using wavelength-based IOR (n) and extinction (k) parameters.", "tags": ["fresnel", "metallic", "extinction", "conductive", "ior"], "likes": 5, "viewed": 535, "published": 3, "date": "1583348920", "time_retrieved": "2024-07-30T21:20:30.679787", "image_code": "vec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\n\nconst float INFINITY = 100000.0;\n\n#define ENV_MAP // enable envmap\n//#define REFLETIVITY_METAL_APPROX // replace dieletric Fresnel with just 1.0    \n\n//\n// Wavelength dependent IOR and Extinction derived from\n// https://refractiveindex.info/\n// \n// Wavelength micrometers used are r = 0.63, g = 0.532, b = 0.465\n// \n\nvoid getNK( out vec3 n, out vec3 k ) { \n\n\tfloat stage = mod( iTime / ( 3.14156 * 2.0 ), 6.0 );\n    \n\tif( stage < 1.0 ) {\n\t\t// IRON\n\t\tn = vec3(2.943, 2.9211, 2.4728);\n\t\tk = vec3(2.9718, 2.9236, 2.7067);\t\n    }\n\telse if( stage < 2.0 ) {\n    \t// SILVER\n        // NOTE: almost no difference between Dielectric and Conductive Fresnel\n        n = vec3(0.056909, 0.054007, 0.046878);\n        k = vec3(4.2543, 3.429, 2.8028);\t\n    }\n\telse if( stage < 3.0 ) {\n        // COPPER\n        n = vec3(0.27527,1.1159,1.2469);\n        k = vec3(3.3726, 2.5956, 2.4562);\n    }\n\telse if( stage < 4.0 ) {\n\t\t// ALUMINIUM\n\t\tn = vec3(1.1167, 0.97274, 0.57037);\n\t\tk = vec3(6.8768, 6.5119, 5.2086);\t\n    }\n\telse if( stage < 5.0 ) {\n\t\t// NICKEL\n        n = vec3(1.9479, 1.8975, 1.7094);\n        k = vec3(3.7424, 3.5489, 2.8128);\t\n    }\n\telse if( stage < 6.0 ) {\n        // GOLD\n        // NOTE: almost no difference between Dielectric and Conductive Fresnel\n        n = vec3(0.18836, 0.54386, 1.3319);\n        k = vec3(3.4034, 2.2309, 1.8693);\n    }\n}\n\nfloat pow2( const in float a ) { return a *a; }\nvec3 pow2( const in vec3 a ) { return a *a; }\n\n//\n// Approximation of Spectral Complex Fresnel based on just sampling RGB wavelengths\n//\n// source: https://docs.chaosgroup.com/display/OSLShaders/Complex+Fresnel+shader\n//\nvec3 F_ConductiveFresnel( const in vec3 n, const in vec3 k, const in float dotNV ) {\n\n    vec3 rs_num = pow2( n ) + pow2( k ) - 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs_den = pow2( n ) + pow2( k ) + 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs = rs_num / rs_den;\n     \n    vec3 rp_num = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) - 2.0 * n * dotNV + 1.0;\n    vec3 rp_den = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) + 2.0 * n * dotNV + 1.0;\n    vec3 rp = rp_num / rp_den;\n     \n    return clamp( 0.5 * ( rs + rp ), vec3(0.0), vec3(1.0) );\n}\n\nvec3 F_DielectricFresnel( const in vec3 reflectivity, const in float dotNV ) {\n\t// Based on the standard Schlick approximation\n\tfloat fresnel = pow( 1.0 - dotNV, 5.0 );\n\treturn vec3( ( 1.0 - reflectivity ) * fresnel + reflectivity );\n}\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n    vec3 tmp = rpos - sp;\n\tfloat dt = dot(rdir, -tmp);\n\tif (dt < 0.0)\n\t\treturn INFINITY;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius)\n\t\treturn INFINITY;\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n\tvec3 ray = vec3(uv.x, uv.y, 1.0);\n\tray = normalize(ray);\t\n\t\n\tvec3 point, normal; \n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n    \n    vec3 viewDir = normalize( -point );\n    float dotVN = dot( viewDir, normal );\n    \n    vec3 n, k;\n    getNK( n, k );\n    \n    // Calculate reflectivity (F0) from the conductive Fresnel\n    vec3 reflectivity = F_ConductiveFresnel( n, k, 1.0 );\n    \n    vec3 reflection = reflect( viewDir, normal );\n\n    vec3 env = texture( iChannel2, reflection ).xyz;\n    \n    vec3 F = vec3( 0.0 );\n                  \n\tif (dist < INFINITY) {\n\t  \n        if( ( uv.y + cos( iTime ) ) < 0.0 ) {  \n#ifdef REFLETIVITY_METAL_APPROX        \n\t\t\tF = reflectivity;\n#else\n            F = F_DielectricFresnel( reflectivity, dotVN );\n#endif\n        }\n        else {\n\t\t\tF = F_ConductiveFresnel( n, k, dotVN );\n        }\n    }\n    \n    \n\tfragColor.xyz = F;\n#ifdef ENV_MAP\n    fragColor.xyz *= env * 1.5;\n#endif\n    \n    if (dist >= INFINITY) {\n\t  \n        if( ( uv.y + cos( iTime ) ) > 0.0 && abs( uv.x ) > 1.0 ) {  \n            fragColor.xyz = vec3( 0.2 );\n\t    }\n            \n    }\n    \n\tfragColor.w = 1.0;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttySzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 372, 410, 410, 1397], [2449, 2449, 2548, 2548, 2860], [2862, 2862, 2919, 2919, 4177]], "test": "untested"}
{"id": "ttGSzt", "name": "Triangulated Actors***", "author": "wyatt", "description": "Triangulated particle simulation ", "tags": ["particles", "triangulation"], "likes": 29, "viewed": 647, "published": 3, "date": "1583345668", "time_retrieved": "2024-07-30T21:20:31.445739", "image_code": "// Fork of \"Triangulated Actors**\" by wyatt. https://shadertoy.com/view/ttVXzD\n// 2020-03-04 04:25:15\n\nMain {\n    Q = A(U);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define init  (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} ", "buffer_a_code": "// Information Storage\nMain {\n\tQ = A(U);;\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++)\n    Q.zw += C(Q.xy+vec2(x,y)).xy;\n    vec2 v = Q.zw;\n    float V = length(v);\n    v = v*sqrt(V*V/(1.+V*V));\n    //if (length(v)>0.)v = normalize(v);\n    Q.xy += v;\n    \n    if (Q.x<2.)Q.x=2.;\n    if (Q.y<2.)Q.y=2.;\n    if (R.x-Q.x<2.)Q.x=R.x-2.;\n    if (R.y-Q.y<2.)Q.y=R.y-2.;\n\n    \n    if (init)\n    {\n    \tU = floor(U/5.+0.5)*5.;\n        U = clamp(U,vec2(40),R-40.);\n        Q = vec4(U,0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// SORT TRIANGULATION\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 aa, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    float ln = length(n.xy-U), la = length(a.xy-U);\n    if (ln<=la) {\n    \tQ.xy = b.xy;\n        a.xy = n.xy;\n    }\n    float pn = pie(U,a.xy,n.xy), \n          pa = pie(U,a.xy,aa.xy);\n    if (pn<=pa){\n        aa = n;\n        Q.zw = b.xy;\n    }\n\tn = A(b.zw);\n    ln = length(n.xy-U);\n    if (ln<la) {\n    \tQ.xy = b.zw;\n        a.xy = n.xy;\n    }\n    pn = pie(U,a.xy,n.xy);\n    if (pn<pa){\n        aa = n;\n        Q.zw = b.zw;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 aa, vec2 U, float r) {\n\t X(Q,a,aa,U,vec2(r,0));\n     X(Q,a,aa,U,vec2(0,r));\n     X(Q,a,aa,U,vec2(0,-r));\n     X(Q,a,aa,U,vec2(-r,0));\n     X(Q,a,aa,U,vec2(r,r));\n     X(Q,a,aa,U,vec2(-r,r));\n     X(Q,a,aa,U,vec2(r,-r));\n     X(Q,a,aa,U,vec2(-r,-r));\n}\nMain {\n\tQ = B(U);\n    vec4 a = A(Q.xy), aa= A(Q.zw);\n    Xr(Q,a,aa,U,1.);\n    Xr(Q,a,aa,U,2.);\n    Xr(Q,a,aa,U,3.);\n    Xr(Q,a,aa,U,4.);\n    for (int i = 0; i < 30; i++) {\n        vec2 u = vec2(\n            (30*iFrame+i)%int(R.x),\n            (30*iFrame+i)/int(R.x)%int(R.y));\n        if (length(U-A(u).xy)<length(U-a.xy)) Q.xy = u;\n    }\n    Init {\n        Q.xy = U;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// COMPUTE FORCE FIELD\nMain {\n\tvec4 b = B(U);\n\tvec4 a = A(b.xy), aa = A(b.zw);\n\tvec2 r = a.xy-aa.xy;\n\tfloat l = length(r);\n   \tvec2 v = vec2(0);\n\tfloat f = 0.;\n    float s = 0.5+sign(b.x-0.5*R.x)*sign(b.z-0.5*R.x);\n    if (length(a.xy-aa.xy)>0.&&length(aa.zw-a.zw)>0.) f = abs(dot(normalize(a.xy-aa.xy),normalize((aa-a).zw)));\n    if (l>0.&&length(a.xy-aa.xy)>4.42) v = \n        -0.1*s*r/l/l+\n        \n       \t.1*f*(aa-a).zw/max(.1,l);\n       ;\n    if (a.x<20.) v.x += .02;\n    if (R.x-a.x<20.) v.x -= .02;\n    if (a.y<20.) v.y += .02;\n    if (R.y-a.y<20.) v.y -= .02;\n    Q.xy = 1e-1*v;\n    if (iMouse.z>0.&&length(a.xy-iMouse.xy)>0.) Q.xy += clamp(0.03*(a.xy-iMouse.xy)/dot((a.xy-iMouse.xy),(a.xy-iMouse.xy)),-2e-4,2e-4);\n\t//if (iFrame < 10) Q.xy -= 3e-2*(U-0.5*R)/dot(U-0.5*R,U-0.5*R);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "float maxx (float a, float b) {\n\tif (abs(a-0.5)<abs(b-0.5)) return b;\n    else return a;\n}\nvec4 maxx( vec4 a, vec4 b) {\n\treturn vec4(maxx(a.x,b.x),maxx(a.y,b.y),maxx(a.z,b.z),maxx(a.w,b.w));\n}\nMain {\n    vec4 b = B(U),\n         a = A(b.xy), aa = A(b.zw);\n    \n    \tvec2 bb = floor(b.xy/10.+0.5)*10.;\n        bb = clamp(bb,vec2(30),R-30.)/R;\n    float o = length(U-a.xy),\n          w = sg(U,a.xy,aa.xy),\n          v = pie(U,a.xy,aa.xy),\n        s = sign(b.x-0.5*R.x);\n    Q = 0.5+0.5*s*vec4(exp(-2.*o)+exp(-w-0.1*(v+1.)*length(aa.xy-a.xy)));\n\tQ = maxx(Q,mix(D(U),vec4(.5),0.3*vec4(.1,.2,.3,.4)));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wlyXRt", "name": "Float bit hacking", "author": "ockiller", "description": "Green : native 1/x, sqrt and 1/sqrt\nRed : approximation by exploiting the logarithmic binary representation of floats\nPurple : red + one Newton iteration", "tags": ["fastsqrt", "fastinversesqrt", "fastinverse"], "likes": 9, "viewed": 1221, "published": 3, "date": "1583345124", "time_retrieved": "2024-07-30T21:20:32.229643", "image_code": "// \"Fast\" inverse, sqrt and 1/sqrt using the fact that the binary representation of a float\n// is like taking its logarithm (it's pretty close).\n//\n// They are the only interesting \"x^exponent\" functions that can be approximated like that\n// as the exponent must be between -1 and 1 to avoid integer overflows.\n//\n//\n// Mathematical explanations\n// -------------------------\n// floatBitsToUint(x) ~= 2^23 * log2(x) + floatBitsToUint(1.0) = logF(x) + 0x3F800000u\n// logF(x) ~= floatBitsToUint(x) - 0x3F800000u\n//\n// uintBitsToFloat(i) ~= exp2((i - 0x3F800000u) / 2^23) = expF(i - 0x3F800000u)\n// expF(i) ~= uintBitsToFloat(i + 0x3F800000u)\n//\n// x^y = expF(y * logF(x)) ~= uintBitsToFloat(y * (floatBitsToUint(x) - 0x3F800000u) + 0x3F800000u)\n//\n//\n// More precision (pun intended)\n// --------------\n// You can tweak the magic constant 0x3F800000u to spread the error more evenly. Then, you can\n// enhance precision with Newton iterations. For the expression y = x^c, we get:\n// y = y - c * (y^(1/c) - x) / y^(1/c - 1)\n// Pretty useless in the general case as it contains operations we wanted to approximate\n// in the first place, but for some exponents c it can be simplified a lot.\n// You can also tweak the coefficients you get in these iterations to get even more precision.\n//\n// Putting all together for c = -0.5, you will end up with the famous \"Quake 3 fast rsqrt\":\n// https://en.wikipedia.org/wiki/Fast_inverse_square_root\n// which is probably the only case where it worked well, at a time where FPUs were slow.\n// Don't expect it to be faster on a GPU or on a modern CPU though.\n\n#define C(v) smoothstep(1.0, 0.0, abs(v - U.y) * R.y / (0.5 * R.x * min(v, fwidth(v)) + 1.0))\n\nfloat inverseNewton(float x, float guess) { return guess * (2.0 - x * guess); }\nfloat sqrtNewton   (float x, float guess) { return 0.5 * (guess + x / guess); } // div :(\nfloat invSqrtNewton(float x, float guess) { return guess * (1.5 - 0.5 * x * guess * guess); }\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, U = u / R;\n    O = vec4(vec3(0.0), 1.0);\n    \n    // 1/x = expF(-logF(x))\n\tfloat fastInverse = uintBitsToFloat(0x7F000000u - floatBitsToUint(U.x));\n//\tfloat fastInverse = uintBitsToFloat(0x7EF40000u - floatBitsToUint(U.x));\n    float fastInverseN1 = inverseNewton(U.x, fastInverse);\n    O.rgb += C(0.2 * vec3(fastInverse, 1.0 / U.x, fastInverseN1));\n   \n    // sqrt(x) = expF(logF(x) / 2)\n\tfloat fastSqrt = uintBitsToFloat((floatBitsToUint(U.x) >> 1) + 0x1FC00000u);\n//\tfloat fastSqrt = uintBitsToFloat((floatBitsToUint(U.x) >> 1) + 0x1FBC0000u);\n    float fastSqrtN1 = sqrtNewton(U.x, fastSqrt);\n    O.rgb += C(vec3(fastSqrt, sqrt(U.x), fastSqrtN1));\n    \n    // 1/sqrt(x) = expF(-logF(x) / 2)\n\tfloat fastInvSqrt = uintBitsToFloat(0x5F400000u - (floatBitsToUint(U.x) >> 1));\n//\tfloat fastInvSqrt = uintBitsToFloat(0x5F3759DFu - (floatBitsToUint(U.x) >> 1));\n    float fastInvSqrtN1 = invSqrtNewton(U.x, fastInvSqrt);\n    O.rgb += C(0.2 * vec3(fastInvSqrt, 1.0 / sqrt(U.x), fastInvSqrtN1));\n\n    O.r += O.b;\n    O.rgb = sqrt(O.rgb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1684, 1684, 1727, 1727, 1763], [1764, 1764, 1807, 1807, 1843], [1844, 1854, 1897, 1897, 1947], [1949, 1949, 1985, 1985, 3049]], "test": "untested"}
{"id": "wlySRt", "name": "Artist Friendly Metallic Fresnel", "author": "bhouston", "description": "Dielectric Fresnel is on top.  Conductive Fresnel driven by Artistic Edge Tint is on the bottom.  Define-based presets are from the \"Artist Friendly Metallic Fresnel\" paper: http://jcgt.org/published/0003/04/03/paper-lowres.pdf", "tags": ["complex", "fresnel", "metallic", "conductor"], "likes": 4, "viewed": 986, "published": 3, "date": "1583343010", "time_retrieved": "2024-07-30T21:20:32.993601", "image_code": "vec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\n\nconst float INFINITY = 100000.0;\n\n#define UNOBTAINIUM\n#define ENV_MAP\n\n//\n// these numbers are taken from the paper http://jcgt.org/published/0003/04/03/paper-lowres.pdf\n// using GIMP's dropper tool.\n//\n\n#ifdef GOLD\n\t// NOTE: Edge tint chosen to look identical to dielectric Fresnel\n\tvec3 reflectivity = vec3( 241.0/255.0, 186.0/255.0, 95.0/255.0 );\n\tvec3 edgeTint = vec3( 254.0/255.0, 248.0/255.0, 187.0/255.0 );\n#endif\n\n#ifdef COPPER\n\t// NOTE: Edge tint chosen to look identical to dielectric Fresnel\n\tvec3 reflectivity = vec3( 236.0/255.0, 175.0/255.0, 128.0/255.0 );\n\tvec3 edgeTint = vec3( 254.0/255.0, 241.0/255.0, 209.0/255.0 );\n#endif\n\n#ifdef SILVER\n\t// NOTE: Edge tint chosen to look identical to dielectric Fresnel\n\tvec3 reflectivity = vec3( 245.0/255.0, 242.0/255.0, 234.0/255.0 );\n\tvec3 edgeTint = vec3( 255.0/255.0, 255.0/255.0, 255.0/255.0 );\n#endif\n\n#ifdef UNOBTAINIUM\n\tvec3 reflectivity = vec3( 153.0/255.0, 179.0/255.0, 230.0/255.0 );\n\tvec3 edgeTint = vec3( 0.0/255.0, 255.0/255.0, 128.0/255.0 );\n#endif\n\n\nfloat pow2( const in float a ) { return a *a; }\nvec3 pow2( const in vec3 a ) { return a *a; }\n\nvoid edgeTintToConductiveFresnel( const in vec3 reflectivity, const in vec3 edgeTint, out vec3 n, out vec3 k ) {\n\t// this is based on the code in Autodesk's Standard Surface OSL as well as in the OSL repository in my thread from 2015.\n\tvec3 r = clamp( reflectivity, vec3(0), vec3(0.99) );\n\tvec3 g = edgeTint;\n\tvec3 r_sqrt = sqrt( r );\n\tvec3 n_min = ( 1.0 - r ) / ( 1.0 + r );\n\tvec3 n_max = ( 1.0 + r_sqrt ) / ( 1.0 - r_sqrt );\n\tn = mix( n_max, n_min, g );\n\tvec3 k2 = (( n + 1.0 ) * ( n + 1.0 ) * r - ( n - 1.0 ) * ( n - 1.0 ) ) / ( 1.0 - r );\n\tk2 = max( k2, 0.0 );\n\tk = sqrt( k2 );\n}\n\n//\n// Approximation of Spectral Complex Fresnel based on just sampling RGB wavelengths\n//\n// Refractive index for red, green, blue wavelengths (f.e. for 0.65, 0.55, 0.45 micrometers)\n// Extinction coefficient for red, green, blue wavelengths (f.e. for 0.65, 0.55, 0.45 micrometers)\n//\n// source: https://docs.chaosgroup.com/display/OSLShaders/Complex+Fresnel+shader\n//\nvec3 F_ConductiveFresnel( const in vec3 reflectivity, const in vec3 edgeTint, const in float dotNV ) {\n\n\tvec3 n, k;\n\tedgeTintToConductiveFresnel( reflectivity, edgeTint, n, k );\n\n\t//n=vec3(0.27105, 0.67693, 1.3164);\n\t//k=vec3(3.6092, 2.6247, 2.2921);\n\n    vec3 rs_num = pow2( n ) + pow2( k ) - 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs_den = pow2( n ) + pow2( k ) + 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs = rs_num / rs_den;\n     \n    vec3 rp_num = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) - 2.0 * n * dotNV + 1.0;\n    vec3 rp_den = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) + 2.0 * n * dotNV + 1.0;\n    vec3 rp = rp_num / rp_den;\n     \n    return clamp( 0.5 * ( rs + rp ), vec3(0.0), vec3(1.0) );\n}\n\nvec3 F_DielectricFresnel( const in vec3 reflectivity, const in float dotNV ) {\n\t// Based on the standard Schlick approximation\n\tfloat fresnel = pow( 1.0 - dotNV, 5.0 );\n\treturn vec3( ( 1.0 - reflectivity ) * fresnel + reflectivity );\n}\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n    vec3 tmp = rpos - sp;\n\tfloat dt = dot(rdir, -tmp);\n\tif (dt < 0.0)\n\t\treturn INFINITY;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius)\n\t\treturn INFINITY;\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n\tvec3 ray = vec3(uv.x, uv.y, 1.0);\n\tray = normalize(ray);\t\n\t\n\tvec3 point, normal; \n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n    \n    vec3 viewDir = normalize( -point );\n    float dotVN = dot( viewDir, normal );\n  \n        \n    vec3 reflection = reflect( viewDir, normal );\n\n    vec3 env = texture( iChannel2, reflection ).xyz;\n\n    vec3 F = vec3( 0.0 );\n    \n\tif (dist < INFINITY) {\n\t  \n     if( ( uv.y + sin( iTime ) ) < 0.0 ) {  \n\t\t\tF = F_DielectricFresnel( reflectivity, dotVN );\n        }\n        else {\n\t\t\tF = F_ConductiveFresnel( reflectivity, edgeTint, dotVN );\n        }\n    }\n    else {\n        fragColor = vec4(0.0);\n    }\n     \n    \n    \n\tfragColor.xyz = F;\n#ifdef ENV_MAP\n    fragColor.xyz *= env * 1.5;\n#endif\n    \n    if (dist >= INFINITY) {\n\t  \n        if( ( uv.y + sin( iTime ) ) > 0.0 && abs( uv.x ) > 1.0 ) {  \n            fragColor.xyz = vec3( 0.2 );\n\t    }\n    }\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlySRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3073, 3073, 3172, 3172, 3484], [3486, 3486, 3543, 3543, 4573]], "test": "untested"}
{"id": "wlGSRt", "name": "sqrt \"fast\" approx", "author": "FabriceNeyret2", "description": "white : sqrt(x)\nred: X0 = approx from halfing the exponant in x mantissa\ngreen: 1 step of ( X + x/X )  / 2  Babylonian series\nblue:   2 steps ( but not sure is still gain on nowdays GPU :-) )\ndark: -log10(rel error) in range [0,10] -> blue = 5 digits or +", "tags": ["test", "float", "exponent", "mantissa", "floatbitstoint", "ieee754", "ieee754"], "likes": 11, "viewed": 2113, "published": 3, "date": "1583342395", "time_retrieved": "2024-07-30T21:20:33.809420", "image_code": "// variant of https://shadertoy.com/view/WtyXzd\n// Babylonian method: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n// converges exponentially fast once \"close enough\" to solution\n// -> use exponant in IEEE float representation for a very good estimate as X0. \n\n#define s(X)  ( X + x/(X) ) /2.  // Babylonian series\n\n  #define C(v) smoothstep( 1.5,0., abs( v - y )/fwidth(y) )\n//#define R(v) smoothstep( 1.5,0., abs( 1e2*(v-sqrt(x)) - y )/fwidth(y) )\n  #define E(v) smoothstep( 1.5,0., abs( -log2(abs( v/sqrt(x)-1.) )/log(10.) -10.*U.y )*R.y/10. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\n    vec2  R = iResolution.xy,                       \n          U = u / R;\n    float N = 256.,\n          x = N*U.x, y = sqrt(N)*U.y,\n         // --- Good first estimate using exponant in IEEE float representation\n      // X0 = intBitsToFloat( ( ( (floatBitsToInt(x) >> 23) -127 )/2 + 127 ) << 23 ),\n      // X0 = intBitsToFloat( (   (floatBitsToInt(x) >> 24) +64 ) << 23 ),           // Indeed even better than above :-)\n         X0 = intBitsToFloat(     (floatBitsToInt(x) & 0xff000000) / 2 +(1 << 29) ), // Simplified\n      // X0 = intBitsToFloat(      floatBitsToInt(x)               / 2 +(1 << 29) ), // ( less good )\n      // X0 = uintBitsToFloat(    (floatBitsToUint(x) +  0x3F800000u ) / 2u ), // Even faster, see https://www.shadertoy.com/view/wlyXRt\n         X1 = s(X0),  //   iteration 1                                         //              and https://en.wikipedia.org/wiki/Fast_inverse_square_root\n         X2 = s(X1),  //   iteration 2                                         // invSqrt with similar cost: good for normalizations\n         X3 = s(X2);  // ( iteration 3 )\n    \n    O =  C( vec4(X0,X1,X2,X3) ); \n // O.rb += O.a;                    // if you want to display X3 as pink\n    O += C( sqrt(x)  );\n    \n    O.a = 0.;\n    O += E( vec4(X0,X1,X2,X3) )*.5; // -log10( relative error )\n    O.rb += O.a;                    \n    if (mod(u.y,R.y/10.)<1.) O += .2;// ticks per significant bit\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 623, 623, 2035]], "test": "untested"}
{"id": "WtyXzd", "name": "exponent via floatBitsToInt", "author": "FabriceNeyret2", "description": "Left: log2(y)  Right: IEEEexponent(y)\ndoes optimizer knows that exp2(floor) and floor(log2) are trivial op ?\nNB: length of floatBitsToInt name + storing exponent sign as uint + offset instead of signed int prevents using that for golfing floor(log2()) :-)", "tags": ["test", "float", "exponent", "mantissa", "floatbitstoint", "ieee754", "ieee754"], "likes": 4, "viewed": 410, "published": 3, "date": "1583340099", "time_retrieved": "2024-07-30T21:20:34.581356", "image_code": "// https://en.wikipedia.org/wiki/Single-precision_floating-point_format#Precision_limits_on_integer_values\n// https://en.wikipedia.org/wiki/IEEE_754\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\n    vec2  R = iResolution.xy,                       \n          U = u / R;\n    float N = 12., \n          y = exp2(N) * U.y;\n    \n    O = int(u)==int(R)/2 ? vec4(1,0,0,1)  // red separator\n      : vec4(  U.x < .5 \n                   ? int( log2( y ))                // left\n                   : (floatBitsToInt(y) >> 23) -127 // right\n            ) /N ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 188, 188, 543]], "test": "untested"}
{"id": "WtGSzd", "name": "PapillaCell", "author": "Reva", "description": "Ex05, interact with mouse", "tags": ["2d", "cellularnoise", "cinashader"], "likes": 2, "viewed": 265, "published": 3, "date": "1583334900", "time_retrieved": "2024-07-30T21:20:35.347308", "image_code": "// Author Reva - 2020-03-04\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n        return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    st *= rotate2d(noise(st));\n    \n    // Cell positions\n    vec2 point[10];\n    vec2 move = iMouse.xy/iResolution.xy - 0.5;\n    for(float i = 0.; i < 10.; i+= 1.){\n        vec2 pos = random2(vec2(i) - 5.93);\n        vec2 vel = vec2(noise(pos*iTime));\n        point[int(i)] = clamp(pos + vel*0.5 + move,vec2(-0.8),vec2(0.8));\n    }\n\n    float m_dist = 1.;  // minimun distance\n\n    // Iterate through the points positions\n    for (int i = 0; i < 10; i++) {\n        float dist = distance(st, point[i]);\n\n        // Keep the closer distance\n        m_dist = min(m_dist, dist);\n    }\n\n    // Draw the min distance (distance field)\n    float t = m_dist*0.8;\n    \n    vec3 color = pal(t,vec3(0.635,0.589,0.504),vec3(0.720,0.534,0.493),vec3(0.500,0.818,0.915),vec3(0.410,0.317,0.297));\n    \n    // Show isolines\n    // color -= step(0.10,m_dist)*-0.060;\n\n    fragColor = vec4(1.0 - color,0.5 - m_dist);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 51, 51, 190], [192, 277, 299, 299, 703], [705, 705, 772, 772, 819], [821, 821, 848, 848, 930], [933, 933, 990, 990, 1956]], "test": "untested"}
{"id": "3lGXzt", "name": "Ripples normal map", "author": "OskarSwierad", "description": "Ripples", "tags": ["effect"], "likes": 10, "viewed": 617, "published": 3, "date": "1583326348", "time_retrieved": "2024-07-30T21:20:36.120241", "image_code": "#define PI 3.14159265359\n\nfloat saturate(float x)\n{\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat RemapTo01(float val, float rangeMin, float rangeMax)\n{\n    return saturate((val - rangeMin) / (rangeMax - rangeMin));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvCentered = uv * 2.0 - vec2(1.0);\n    uvCentered *= aspectRatio;\n    \n    vec2 pivot = vec2(0.05, 0.1);\n    \n    float radius = 0.5;\n    vec2 diff = (uvCentered - pivot) / radius;\n    float dist = length(diff);\n    \n    float mask = float(dist < 1.0);\n    \n    //diff = smoothstep(vec2(0.0), vec2(1.0), diff);\n    \n    float waveFreq = 32.0;\n    float speed = 3.0;\n    float distForSin = length(diff);\n    distForSin = pow(distForSin, 0.5);\n    float height = sin(distForSin * waveFreq - (iTime * speed));\n    //height *= 0.5;\n    //height = (dist < 1.0) ? heightAdd : 0.0;\n    \n    vec2 dir = normalize(diff);\n    //diff += dir * height * 0.9;\n    \n    vec3 norm = normalize(vec3(\n        diff.xy,\n        sqrt( saturate( 1.0 - dot( diff.xy, diff.xy ) ) )\n    ));\n    \n    norm.xy += dir * height * 0.9;\n    norm = normalize(norm);\n    \n    \n    //norm.z += heightAdd;\n    //norm = normalize(norm);\n    \n    float softEdgeMask = RemapTo01(dist, 1.0, 0.4);\n    softEdgeMask = smoothstep(0.0, 1.0, softEdgeMask);\n    if (softEdgeMask > 0.0)\n    {\n    \tnorm.xy *= softEdgeMask;\n    }\n    norm = normalize(norm);\n    \n    vec3 col = vec3(0.5);\n    col = vec3(uvCentered, 0.0);\n    //col = vec3(dist);\n    \n    if (mask < 1.0)\n    {\n        norm = vec3(0,0,1);\n    }\n    \n    col = vec3(norm);\n    \n    col = col * 0.5 + vec3(0.5);\n    //col = vec3(heightAdd);\n   \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 51, 51, 81], [83, 83, 143, 143, 208], [210, 210, 267, 267, 1779]], "test": "untested"}
{"id": "3tyXRt", "name": "Slope: GGX Anisotropic", "author": "H4w0", "description": "GGX / Trowbridge Reitz : slope distribution function", "tags": ["microfacet", "anisotropic", "ggx", "ndf"], "likes": 17, "viewed": 3410, "published": 3, "date": "1583318337", "time_retrieved": "2024-07-30T21:20:37.264183", "image_code": "//=======================================================\n//= Slope Distribution Function : GGX Anisotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Remapping : \n//== *- roughness \t-> alpha = clamp(0.1+uiSlider(0),0.,0.8 )^2;\n//== *- metallic \t-> 0 or 1\n//== *- reflectance used for non-metallic F0 (Filament)\n//==    -> F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n//=======================================================\n//== Implementations details :  \n//== *- Computations are done in tangent space (PBRT-like)\n//== *- Code can be a lot simplified but I wanted a verbose/self-explained code \n//== *- Code could have more checks (non-zero length before normalization, etc.)\n//== *- NDFs are expressed using the slope distribution functions P22\n//== *- Fresnel Term uses the Schlick Approximation\n//== *- Equations are written with the lovely style of @valentingalea (https://www.shadertoy.com/view/XtBXDz)\n//== \t( again it's a personal taste :D )\n//== *- Checked P22() and D() by numerical integration\n//==    Checked Lambda with the Weak White Furnace Test\n//=======================================================\n//== Using some wonderful ressources on BRDFs/NDFs/Masking :\n//== *- Xavier Chermain's thesis (FR): https://tel.archives-ouvertes.fr/tel-02446425/document\n//== *- Jonathan Dupuy's thesis  (EN): https://hal.archives-ouvertes.fr/tel-01291974v2/document\n//== *- Eric Heitz's thesis \t (FR): https://tel.archives-ouvertes.fr/tel-01073518v2/document\n//== *- Eric Heitz : Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\n//== \t(PDF + SLIDES) : http://jcgt.org/published/0003/02/03/ \n//== *- PBRT (book : http://www.pbr-book.org/ | code : https://github.com/mmp/pbrt-v3/ )\n//== *- Filament documentation : https://google.github.io/filament/Filament.html\n//== *- Self Shadow blog : https://blog.selfshadow.com/\n//=======================================================\n//== I also used some code from :\n//== *- @XT95's \"UI easy to integrate\" on Shadertoy \t  \n//=   \thttps://www.shadertoy.com/view/ldKSDm\t\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst bool  USE_DIFFUSE_TERM = true;\n\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_GREY = vec3(0.0);\n\n//-----------------------------------------------------------------------------\n//-- GGX Distribution ---------------------------------------------------------\nfloat p22_ggx_anisotropic(float x, float y, float alpha_x, float alpha_y)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float alpha_x_sqr = alpha_x*alpha_x;\n    float alpha_y_sqr = alpha_y*alpha_y;\n    float denom = ( 1. + (x_sqr/alpha_x_sqr) + (y_sqr/alpha_y_sqr) ); \n    float denom_sqr = denom*denom; \n    return( \n                            1.\n    / //-------------------------------------------------------------------\n        ( ( m_pi * alpha_x * alpha_y) * (denom_sqr) )\n    );\n}\n\nfloat ndf_ggx_anisotropic(vec3 omega_h, float alpha_x, float alpha_y)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float ggx_p22 = p22_ggx_anisotropic(slope_x,slope_y,alpha_x,alpha_y);\n    return(\n                  ggx_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_ggx_anisotropic(vec3 omega, float alpha_x, float alpha_y)\n{\n    float cos_phi = cos_phi(omega);\n    float sin_phi = sin_phi(omega);\n    float alpha_o = sqrt(cos_phi*cos_phi*alpha_x*alpha_x + sin_phi*sin_phi*alpha_y*alpha_y); \n    float a = 1. / (alpha_o * tan_theta(omega));\n    return( 0.5 * (-1. + sqrt(1. + 1. / (a*a))) ); \n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_GREY; }\n\n//-----------------------------------------------------------------------------\n//-- UI -----------------------------------------------------------------------\n//-- From XT95's https://www.shadertoy.com/view/ldKSDm\n//-----------------------------------------------------------------------------\nfloat \tuiSlider(int id) {return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 \tuiColor(int id)\t {return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        mat3 TBN    = orthonormal_basis(N);\n        mat3 TBN_t  = transpose(TBN);\n        vec3 wo = normalize(TBN_t * V);\n        vec3 wi = normalize(TBN_t * L);\n        vec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n        vec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)\n        \n        float wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n        float wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n                     \n        //-- Filament BRDF parametrization\n        //-- Single scattering\n        //-- diffuse lambertian term + specular term\n        float reflectance \t= clamp(uiSlider(2),0.35,1.); \t// [0.35;1]\n        float metallic \t\t= float(uiSlider(3)>0.5); \t\t// 0. or 1.\n        float roughness_x \t= clamp( 0.1 + uiSlider(0), 0., 0.8);\n        float roughness_y \t= clamp( 0.1 + uiSlider(1), 0., 0.8);\n    \tfloat alpha_x \t\t= roughness_x*roughness_x;\n        float alpha_y \t\t= roughness_y*roughness_y;\n        vec3  base_color    = uiColor(0);\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n              \n        //-- NDF + G + F\n        float lambda_wo = lambda_ggx_anisotropic(wo,alpha_x,alpha_y);\n        float lambda_wi = lambda_ggx_anisotropic(wi,alpha_x,alpha_y);\n        float D = ndf_ggx_anisotropic(wh,alpha_x,alpha_y);\n        float G = 1. / (1. + lambda_wo + lambda_wi);\n        \n     \n\t\tvec3 F  = fresnel_schlick(wi_dot_wh,F0);\n        \n        //-- Lighting\n        vec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ;\n        vec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n        vec3 diffuse_factor  = vec3(1.)-F; \n        if(!USE_DIFFUSE_TERM){diffuse_lambert = vec3(0.);}\n        \n        color = wg_dot_wi * get_light_intensity() * (diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    //-- Rendering ----------------------------------------------------\n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd) , 1.);\n    \n    //-- UI integration -----------------------------------------------\n    vec4 ui = texture(iChannel0,gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb,ui.rgb, ui.a*.8);\n    \n    //-- Image post-process -------------------------------------------\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */\nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;            \n\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0., 1. - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 1. : clamp(w.x / sin_theta(w), -1., 1.);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 0. : clamp(w.y / sin_theta(w), -1., 1.);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n", "buffer_a_code": "//-- UI From Anatole Duprat : XT95 \n//-- https://www.shadertoy.com/view/ldKSDm\n//-- Using the following License :\n\n// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//-- Modified from line 91 (custom sliders, boxes and cursors...)\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.5)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    //----------------------------------------------\n    //-- Changed Here :: Custom sliders\n    _cursor(20,30) _G _G _X _spc _A _n _i _s _o _t _r _o _p _i _c\n    _box(vec2(15,iResolution.y-35.),vec2(150,3),vec4(1.))\n\n    _slider(24,57, 0, 0.2) _R _o _u _g _h _n _e _s _s _spc _X\n    _slider(24,87, 1, 0.2) _R _o _u _g _h _n _e _s _s _spc _Y\n        \n    _box(vec2(15,iResolution.y-100.),vec2(150,3),vec4(1.))\n        \n    _slider(24,125, 2, 0.5) _R _e _f _l _e _c _t _a _n _c _e \n    _slider(24,155, 3, 1.0) _M _e _t _a _l \n    _color(24,185, 0, vec3(1.000,0.782,0.344)) _C _o _l _o _r\n                \n    fragColor = min(col.rgba,1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3683, 3843, 3918, 3918, 4336], [4338, 4338, 4409, 4409, 4824], [4826, 4826, 4898, 4898, 5167], [5170, 5330, 5384, 5384, 5439], [5441, 5601, 5642, 5642, 5668], [5669, 5669, 5709, 5709, 5735], [5736, 5736, 5776, 5776, 5802], [5804, 6099, 6124, 6124, 6192], [6193, 6193, 6217, 6217, 6287], [6289, 6451, 6488, 6488, 8684], [8686, 8846, 8903, 8977, 9687]], "test": "untested"}
{"id": "WlGXRt", "name": "Slope: Beckmann Anisotropic", "author": "H4w0", "description": "Beckmann slope distribution function", "tags": ["microfacet", "anisotropic", "ndf", "beckmann"], "likes": 7, "viewed": 853, "published": 3, "date": "1583318316", "time_retrieved": "2024-07-30T21:20:38.415105", "image_code": "//=======================================================\n//= Slope Distribution Function : Beckmann Anisotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Remapping : \n//== *- roughness \t-> alpha = clamp(0.1+uiSlider(0),0.,0.8 )^2;\n//== *- metallic \t-> 0 or 1\n//== *- reflectance used for non-metallic F0 (Filament)\n//==    -> F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n//=======================================================\n//== Implementations details :  \n//== *- Computations are done in tangent space (PBRT-like)\n//== *- Code can be a lot simplified but I wanted a verbose/self-explained code \n//== *- Code could have more checks (non-zero length before normalization, etc.)\n//== *- NDFs are expressed using the slope distribution functions P22\n//== *- Beckmann P22 functions convert alpha in rms roughness (sigma) to match the statistical distribution \n//==\t(Beckmann P22 -> Bivariate Normal Distribution). \t\n//== \tThis is a purely personal preference and you can easily change using the following relation : \n//==\t\talpha = sqrt(2.) * sigma\n//== *- Fresnel Term uses the Schlick Approximation\n//== *- Equations are written with the lovely style of @valentingalea (https://www.shadertoy.com/view/XtBXDz)\n//== \t( again it's a personal taste :D )\n//== *- Checked P22() and D() by numerical integration\n//==    Checked Lambda with the Weak White Furnace Test\n//=======================================================\n//== Using some wonderful ressources on BRDFs/NDFs/Masking :\n//== *- Xavier Chermain's thesis (FR): https://tel.archives-ouvertes.fr/tel-02446425/document\n//== *- Jonathan Dupuy's thesis  (EN): https://hal.archives-ouvertes.fr/tel-01291974v2/document\n//== *- Eric Heitz's thesis \t (FR): https://tel.archives-ouvertes.fr/tel-01073518v2/document\n//== *- Eric Heitz : Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\n//== \t(PDF + SLIDES) : http://jcgt.org/published/0003/02/03/ \n//== *- PBRT (book : http://www.pbr-book.org/ | code : https://github.com/mmp/pbrt-v3/ )\n//== *- Filament documentation : https://google.github.io/filament/Filament.html\n//== *- Self Shadow blog : https://blog.selfshadow.com/\n//=======================================================\n//== I also used some code from :\n//== *- @XT95's \"UI easy to integrate\" on Shadertoy \t  \n//=   \thttps://www.shadertoy.com/view/ldKSDm\t\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst bool  USE_DIFFUSE_TERM = true;\n\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_GREY = vec3(0.0);\n\n//-----------------------------------------------------------------------------\n//-- Beckmann Distribution ----------------------------------------------------\nfloat p22_beckmann_anisotropic(float x, float y, float alpha_x, float alpha_y)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma_x = alpha_x * m_i_sqrt_2;\n    float sigma_y = alpha_y * m_i_sqrt_2;\n    float sigma_x_sqr = sigma_x*sigma_x;\n    float sigma_y_sqr = sigma_y*sigma_y;\n    return( \n            exp( -0.5 * ((x_sqr/sigma_x_sqr) + (y_sqr/sigma_y_sqr)) )\n    / //-------------------------------------------------------------------\n                    ( 2. * m_pi * sigma_x * sigma_y )\n    );\n}\n\nfloat ndf_beckmann_anisotropic(vec3 omega_h, float alpha_x, float alpha_y)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float beckmann_p22 = p22_beckmann_anisotropic(slope_x,slope_y,alpha_x,alpha_y);\n    return(\n                beckmann_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_beckmann_anisotropic(vec3 omega, float alpha_x, float alpha_y)\n{\n    float lambda = 0.;\n    float cos_phi = cos_phi(omega);\n    float sin_phi = sin_phi(omega);\n    float alpha_o = sqrt(cos_phi*cos_phi*alpha_x*alpha_x + sin_phi*sin_phi*alpha_y*alpha_y); \n    float nu = 1. / (alpha_o * tan_theta(omega));\n\n    if(nu < 1.6)\n        lambda = (1. - 1.259*nu + 0.396*nu*nu) / (3.535*nu + 2.181*nu*nu); \n    \n    return(lambda);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_GREY; }\n\n//-----------------------------------------------------------------------------\n//-- UI -----------------------------------------------------------------------\n//-- From XT95's https://www.shadertoy.com/view/ldKSDm\n//-----------------------------------------------------------------------------\nfloat \tuiSlider(int id) {return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 \tuiColor(int id)\t {return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        mat3 TBN    = orthonormal_basis(N);\n        mat3 TBN_t  = transpose(TBN);\n        vec3 wo = normalize(TBN_t * V);\n        vec3 wi = normalize(TBN_t * L);\n        vec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n        vec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)\n        \n        float wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n        float wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n                     \n        //-- Filament BRDF parametrization\n        //-- Single scattering\n        //-- diffuse lambertian term + specular term\n        float reflectance \t= clamp(uiSlider(2),0.35,1.); \t// [0.35;1]\n        float metallic \t\t= float(uiSlider(3)>0.5); \t\t// 0. or 1.\n        float roughness_x \t= clamp( 0.1 + uiSlider(0), 0., 0.8);\n        float roughness_y \t= clamp( 0.1 + uiSlider(1), 0., 0.8);\n    \tfloat alpha_x \t\t= roughness_x*roughness_x;\n        float alpha_y \t\t= roughness_y*roughness_y;\n        vec3  base_color    = uiColor(0);\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n              \n        //-- NDF + G + F\n        float lambda_wo = lambda_beckmann_anisotropic(wo,alpha_x,alpha_y);\n        float lambda_wi = lambda_beckmann_anisotropic(wi,alpha_x,alpha_y);\n        float D = ndf_beckmann_anisotropic(wh,alpha_x,alpha_y);\n        float G = 1. / (1. + lambda_wo + lambda_wi);\n        \n     \n\t\tvec3 F  = fresnel_schlick(wi_dot_wh,F0);\n        \n        //-- Lighting\n        vec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ;\n        vec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n        vec3 diffuse_factor  = vec3(1.)-F; \n        if(!USE_DIFFUSE_TERM){diffuse_lambert = vec3(0.);}\n        \n        color = wg_dot_wi * get_light_intensity() * (diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n\n    fragColor = vec4( render(ro,rd) , 1.);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n    \n    //-- UI integration -----------------------------------------------\n    vec4 ui = texture(iChannel0,gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb,ui.rgb, ui.a*.8);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */\nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;            \n\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0., 1. - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 1. : clamp(w.x / sin_theta(w), -1., 1.);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 0. : clamp(w.y / sin_theta(w), -1., 1.);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n", "buffer_a_code": "//-- UI From Anatole Duprat : XT95 \n//-- https://www.shadertoy.com/view/ldKSDm\n//-- Using the following License :\n\n// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//-- Modified from line 91 (custom sliders, boxes and cursors...)\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.5)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    //----------------------------------------------\n    //-- Changed Here :: Custom sliders\n    _cursor(12,30) _B _e _c _k _m _a _n _n _spc _A _n _i _s _o _t _r _o _p _i _c\n    _box(vec2(15,iResolution.y-35.),vec2(150,3),vec4(1.))\n\n    _slider(24,57, 0, 0.2) _R _o _u _g _h _n _e _s _s _spc _X\n    _slider(24,87, 1, 0.2) _R _o _u _g _h _n _e _s _s _spc _Y\n        \n    _box(vec2(15,iResolution.y-100.),vec2(150,3),vec4(1.))\n        \n    _slider(24,125, 2, 0.5) _R _e _f _l _e _c _t _a _n _c _e \n    _slider(24,155, 3, 1.0) _M _e _t _a _l \n    _color(24,185, 0, vec3(1.000,0.782,0.344)) _C _o _l _o _r\n                \n    fragColor = min(col.rgba,1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3985, 4145, 4225, 4225, 4659], [4661, 4661, 4737, 4737, 5165], [5167, 5167, 5244, 5244, 5604], [5607, 5767, 5821, 5821, 5876], [5878, 6038, 6079, 6079, 6105], [6106, 6106, 6146, 6146, 6172], [6173, 6173, 6213, 6213, 6239], [6241, 6536, 6561, 6561, 6629], [6630, 6630, 6654, 6654, 6724], [6726, 6888, 6925, 6925, 9136], [9138, 9298, 9355, 9355, 9991]], "test": "untested"}
{"id": "WtGXRt", "name": "Slope: Beckmann Isotropic", "author": "H4w0", "description": "Beckmann slope distribution function", "tags": ["microfacet", "ndf", "beckmann", "isotropic"], "likes": 6, "viewed": 633, "published": 3, "date": "1583318279", "time_retrieved": "2024-07-30T21:20:39.543089", "image_code": "//=======================================================\n//= Slope Distribution Function : Beckmann Isotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Remapping : \n//== *- roughness \t-> alpha = clamp(0.1+uiSlider(0),0.,0.8 )^2;\n//== *- metallic \t-> 0 or 1\n//== *- reflectance used for non-metallic F0 (Filament)\n//==    -> F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n//=======================================================\n//== Implementations details :  \n//== *- Computations are done in tangent space (PBRT-like)\n//== *- Code can be a lot simplified but I wanted a verbose/self-explained code \n//== *- Code could have more checks (non-zero length before normalization, etc.)\n//== *- NDFs are expressed using the slope distribution functions P22\n//== *- Beckmann P22 functions convert alpha in rms roughness (sigma) to match the statistical distribution \n//==\t(Beckmann P22 -> Bivariate Normal Distribution). \t\n//== \tThis is a purely personal preference and you can easily change using the following relation : \n//==\t\talpha = sqrt(2.) * sigma\n//== *- Fresnel Term uses the Schlick Approximation\n//== *- Equations are written with the lovely style of @valentingalea (https://www.shadertoy.com/view/XtBXDz)\n//== \t( again it's a personal taste :D )\n//== *- Checked P22() and D() by numerical integration\n//==    Checked Lambda with the Weak White Furnace Test\n//=======================================================\n//== Using some wonderful ressources on BRDFs/NDFs/Masking :\n//== *- Xavier Chermain's thesis (FR): https://tel.archives-ouvertes.fr/tel-02446425/document\n//== *- Jonathan Dupuy's thesis  (EN): https://hal.archives-ouvertes.fr/tel-01291974v2/document\n//== *- Eric Heitz's thesis \t (FR): https://tel.archives-ouvertes.fr/tel-01073518v2/document\n//== *- Eric Heitz : Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\n//== \t(PDF + SLIDES) : http://jcgt.org/published/0003/02/03/ \n//== *- PBRT (book : http://www.pbr-book.org/ | code : https://github.com/mmp/pbrt-v3/ )\n//== *- Filament documentation : https://google.github.io/filament/Filament.html\n//== *- Self Shadow blog : https://blog.selfshadow.com/\n//=======================================================\n//== I also used some code from :\n//== *- @XT95's \"UI easy to integrate\" on Shadertoy \t  \n//=   \thttps://www.shadertoy.com/view/ldKSDm\t\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst bool  USE_DIFFUSE_TERM = true;\n\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_GREY = vec3(0.0);\n\n//-----------------------------------------------------------------------------\n//-- Beckmann Distribution ---------------------------------------------------------\nfloat p22_beckmann_isotropic(float x, float y, float alpha)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma = alpha * m_i_sqrt_2;\n    float sigma_sqr = sigma*sigma;\n    return( \n            exp( -0.5 * ((x_sqr/sigma_sqr) + (y_sqr/sigma_sqr)) )\n    / //-------------------------------------------------------------------\n                    ( 2. * m_pi * sigma_sqr )\n    );\n}\n\nfloat ndf_beckmann_isotropic(vec3 omega_h, float alpha)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float beckmann_p22 = p22_beckmann_isotropic(slope_x,slope_y,alpha);\n    return(\n                beckmann_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_beckmann_isotropic(vec3 omega, float alpha)\n{\n    float lambda    = 0.;\n    float tan_theta = tan_theta(omega);\n    float nu        = 1. / (alpha * tan_theta);\n    if(nu < 1.6)\n        lambda = (1. - 1.259*nu + 0.396*nu*nu) / (3.535*nu + 2.181*nu*nu); \n    return(lambda);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_GREY; }\n\n//-----------------------------------------------------------------------------\n//-- UI -----------------------------------------------------------------------\n//-- From XT95's https://www.shadertoy.com/view/ldKSDm\n//-----------------------------------------------------------------------------\nfloat \tuiSlider(int id) {return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 \tuiColor(int id)\t {return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        mat3 TBN    = orthonormal_basis(N);\n        mat3 TBN_t  = transpose(TBN);\n        vec3 wo = normalize(TBN_t * V);\n        vec3 wi = normalize(TBN_t * L);\n        vec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n        vec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)\n        \n        float wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n        float wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n                     \n        //-- Filament BRDF parametrization\n        //-- Single scattering\n        //-- diffuse lambertian term + specular term\n        float reflectance \t= clamp(uiSlider(1),0.35,1.); \t// [0.35;1]\n        float metallic \t\t= float(uiSlider(2)>0.5); \t\t// 0. or 1.\n        float roughness \t= clamp( 0.1 + uiSlider(0), 0., 0.8);\n    \tfloat alpha \t\t= roughness*roughness;\n        vec3  base_color    = uiColor(0);\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n              \n        //-- NDF + G + F\n        float lambda_wo = lambda_beckmann_isotropic(wo,alpha);\n        float lambda_wi = lambda_beckmann_isotropic(wi,alpha);\n        float D = ndf_beckmann_isotropic(wh,alpha);\n        float G = 1. / (1. + lambda_wo + lambda_wi);\n        \n     \n\t\tvec3 F  = fresnel_schlick(wi_dot_wh,F0);\n        \n        //-- Lighting\n        vec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ;\n        vec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n        vec3 diffuse_factor  = vec3(1.)-F; \n        if(!USE_DIFFUSE_TERM){diffuse_lambert = vec3(0.);}\n        \n        color = wg_dot_wi * get_light_intensity() * (diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n\n    fragColor = vec4( render(ro,rd) , 1.);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n    \n    //-- UI integration -----------------------------------------------\n    vec4 ui = texture(iChannel0,gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb,ui.rgb, ui.a*.8);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */\nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;            \n\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0., 1. - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 1. : clamp(w.x / sin_theta(w), -1., 1.);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 0. : clamp(w.y / sin_theta(w), -1., 1.);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n", "buffer_a_code": "//-- UI From Anatole Duprat : XT95 \n//-- https://www.shadertoy.com/view/ldKSDm\n//-- Using the following License :\n\n// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//-- Modified from line 91 (custom sliders, boxes and cursors...)\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.5)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    //----------------------------------------------\n    //-- Changed Here :: Custom sliders\n    _cursor(20,30) _B _e _c _k _m _a _n _n _spc _I _s _o _t _r _o _p _i _c\n    _box(vec2(15,iResolution.y-35.),vec2(150,3),vec4(1.))\n\n    _slider(24,57, 0, 0.2) _R _o _u _g _h _n _e _s _s \n    _box(vec2(15,iResolution.y-70.),vec2(150,3),vec4(1.))\n        \n    _slider(24,95, 1, 0.5) _R _e _f _l _e _c _t _a _n _c _e \n    _slider(24,125, 2, 1.0) _M _e _t _a _l \n    _color(24,155, 0, vec3(1.000,0.782,0.344)) _C _o _l _o _r\n    \n    fragColor = min(col.rgba,1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3983, 4148, 4209, 4209, 4538], [4540, 4540, 4597, 4597, 5013], [5015, 5015, 5073, 5073, 5302], [5305, 5465, 5519, 5519, 5574], [5576, 5736, 5777, 5777, 5803], [5804, 5804, 5844, 5844, 5870], [5871, 5871, 5911, 5911, 5937], [5939, 6234, 6259, 6259, 6327], [6328, 6328, 6352, 6352, 6422], [6424, 6586, 6623, 6623, 8674], [8676, 8836, 8893, 8893, 9529]], "test": "untested"}
{"id": "ttKXzc", "name": "Knot Dynamics", "author": "dr2", "description": "Knotted chain; click in ring to cycle through a set of simple knots (else auto)", "tags": ["collision", "dynamics", "chain", "topology", "polymer"], "likes": 12, "viewed": 494, "published": 3, "date": "1583305973", "time_retrieved": "2024-07-30T21:20:40.686035", "image_code": "// \"Knot Dynamics\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nconst int lenChain = 256;\nvec3 vnObj, ltDir;\nvec2 qBlk;\nfloat dstFar, tCur, spRad;\nint idBall;\nconst float pi = 3.14159;\n\n#define AA  1     // optional antialiasing\n#define TUBE 1    // = 0/1, show balls/tubes\n\n#if TUBE\n\nfloat CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s;\n  float dMin, d, a, b, w;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      vnObj = vec3 (s.xy, 0.);\n    } else {\n      ro.z -= len * sign (s.z);\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vnObj = ro + d * rd;\n        }\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat PolyHit (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatS;\n  vec3 r, rp, vnObjS;\n  float dMin, d, sz;\n  sz = 0.45;\n  dMin = dstFar;\n  idBall = -1;\n  for (int n = 0; n < lenChain + 1; n ++) {\n    if (n == 0) r = Loadv4 (0).xyz;\n    else {\n      rp = r;\n      r = (n < lenChain) ? Loadv4 (2 * n).xyz : Loadv4 (0).xyz;\n      rMat = DirToRMatT (normalize (r - rp), vec3 (0., 0., 1.));\n      d = CapsHit ((ro - 0.5 * (r + rp)) * rMat, rd * rMat, sz, 0.5 * length (r - rp));\n      if (d < dMin) {\n        dMin = d;\n        rMatS = rMat;\n        vnObjS = vnObj;\n        idBall = n;\n      }\n    }\n  }\n  if (idBall >= 0) vnObj = rMatS * normalize (vnObjS);\n  return dMin;\n}\n\n#else\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec3 v;\n  float b, d, w, dMin, sz;\n  dMin = dstFar;\n  sz = 0.55;\n  idBall = -1;\n  for (int n = 0; n < lenChain; n ++) {\n    v = ro - Loadv4 (2 * n).xyz;\n    b = dot (rd, v);\n    w = b * b + sz * sz - dot (v, v);\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        idBall = n;\n      }\n    }\n  }\n  if (idBall >= 0) vnObj = (ro - Loadv4 (2 * idBall).xyz + dMin * rd) / sz;\n  return dMin;\n}\n\n#endif\n\nvec4 SphHit (vec3 ro, vec3 rd)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + spRad * spRad - dot (ro, ro);\n  d = dstFar;\n  if (w >= 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / spRad;\n  }\n  return vec4 (d, vn);\n}\n\nvoid BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  float dn, df, bSize;\n  bSize = 10. * dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk)) / bSize;\n  }\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  return vec3 (0.5, 0.5, 0.7) * (0.3 + 0.1 * rd.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 d4;\n  vec3 col, vnSph;\n  float dstObj, dstExtSph, h;\n  d4 = SphHit (ro, rd);\n  dstExtSph = d4.x;\n  col = BgCol (ro, rd);\n  if (dstExtSph < dstFar) {\n#if TUBE\n    dstObj = PolyHit (ro, rd);\n#else   \n    dstObj = BallHit (ro, rd);\n#endif\n    if (dstObj < dstFar) {\n      h = mod (float (idBall) / float (lenChain) + 0.1 * tCur, 1.);\n      col = HsvToRgb (vec3 (h, 1., 0.8)) * (0.3 + 0.7 * max (dot (vnObj, ltDir), 0.)) +\n         0.2 * pow (max (dot (normalize (ltDir - rd), vnObj), 0.), 16.);\n    }\n    vnSph = d4.yzw;\n    col += 0.05 + 0.05 * max (dot (vnSph, ltDir), 0.) +\n       0.15 * pow (max (dot (normalize (ltDir - rd), vnSph), 0.), 32.);\n    rd = reflect (rd, vnSph);\n    ro += dstExtSph * rd;\n    BlkHit (ro, rd);\n    qBlk = step (0.1, mod (8. * qBlk + 0.1/2., 1.));\n    col = mix (col, BgCol (ro, rd) * (0.8 + 0.2 * qBlk.x * qBlk.y),\n       pow (1. - abs (dot (rd, vnSph)), 3.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 rd, ro, col, wgBxC, c;\n  vec2 canvas, uv, uvv;\n  float asp, el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, -0.46, 0.02);\n  mPtr.xyz =  Loadv4 (2 * lenChain + 1).xyz;\n  spRad = Loadv4 (2 * lenChain).y;\n  dstFar = 20. * spRad;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0. && length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) > wgBxC.z) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -5. * spRad);\n  ltDir = vuMat * normalize (vec3 (-2., 3., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    rd = vuMat * normalize (vec3 (uvv, 4.5));\n    c = ShowScene (ro, rd);\n    if (abs (length (0.5 * uvv - wgBxC.xy) - wgBxC.z) * canvas.y < 2.) c = vec3 (0.5, 0.8, 0.8);\n    col += c / naa;\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = normalize (cross (vu, vd));\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) *\n     6. - 3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Knot Dynamics\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define N_KNOT  11\nvec3 knc[N_KNOT], kns[N_KNOT];\nfloat sclFac;\nint knType;\n\nconst int lenChain = 256;\nfloat spRad;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\n// Knot parametrizations from A.K. Trautwein thesis (University of Iowa, 1995) (many more)\n\nvoid KtSetup ()\n{\n  for (int k = 0; k < N_KNOT; k ++) {\n    knc[k] = vec3 (0);  kns[k] = vec3 (0);\n  }\n  if (knType == 1) {  // 3.1 trefoil knot\n     knc[0] = vec3 ( 41,   36,   0);   kns[0] = vec3 (-18,   27,   45);\n     knc[1] = vec3 (-83, -113,  -30);  kns[1] = vec3 (-83,   30,  113);\n     knc[2] = vec3 (-11,   11,  -11);  kns[2] = vec3 ( 27,  -27,   27);\n     sclFac = 0.015;\n  } else if (knType == 2) {  // 4.1 figure 8 knot\n     knc[0] = vec3 (  32,   94,   16);  kns[0] = vec3 (-51,   41,   73);\n     knc[1] = vec3 (-104,  113, -211);  kns[1] = vec3 (-34,    0,  -39);\n     knc[2] = vec3 ( 104,  -68,  -99);  kns[2] = vec3 (-91, -124,  -21);\n     sclFac = 0.008;\n  } else if (knType == 3) {  // 5.1 knot\n     knc[0] = vec3 (  88,   89,   44);  kns[0] = vec3 ( 115,  -32,  -69);\n     knc[1] = vec3 (-475, -172,   34);  kns[1] = vec3 (-127,  294,  223);\n     knc[2] = vec3 ( -87,   76,   16);  kns[2] = vec3 (  36,  102,  120);\n     knc[3] = vec3 (  11,  -61,   42);  kns[3] = vec3 ( -19,  113, -125);\n     sclFac = 0.0045;\n  } else if (knType == 4) {  // 5.2 knot\n     knc[0] = vec3 ( -33,  -57,   34);  kns[0] = vec3 ( 43,   99, -21);\n     knc[1] = vec3 (   0,  -54, -100);  kns[1] = vec3 (214, -159, -93);\n     knc[2] = vec3 (-101, -117,  -27);  kns[2] = vec3 (-47,   -5, -16);\n     knc[3] = vec3 (   0,  -31,   52);  kns[3] = vec3 ( 11,  -45,  84);\n     sclFac = 0.008;\n  } else if (knType == 5) {  // granny knot\n     knc[0] = vec3 (-22,   0,  0);  kns[0] = vec3 (-128,   0,   0);\n     knc[1] = vec3 (  0, -10,  0);  kns[1] = vec3 (   0, -27,   0);\n     knc[2] = vec3 (-44,   0, 70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[3] = vec3 (  0,  38,  0);  kns[3] = vec3 (   0,  38,   0);\n     sclFac = 0.016;\n  } else if (knType == 6) {  // square knot\n     knc[0] = vec3 ( -22,  11,   0);  kns[0] = vec3 (-128,   0,   0);\n     knc[2] = vec3 ( -44, -43,  70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[4] = vec3 (   0,  34,   8);  kns[4] = vec3 (   0, -39,  -9);\n     sclFac = 0.016;\n  } else if (knType == 7) {  // 6.1 knot\n     knc[0] = vec3 (  12,   29,  -30);  kns[0] = vec3 ( 20,  78, -78);\n     knc[1] = vec3 (-163, -180, -111);  kns[1] = vec3 ( 76,  58,  37);\n     knc[2] = vec3 ( -87,   88,  -67);  kns[2] = vec3 (-15,  72, -51);\n     knc[3] = vec3 ( -21,    0,   31);  kns[3] = vec3 ( 14, -14,   8);\n     knc[4] = vec3 (  24,    0,  -11);  kns[4] = vec3 (-50,   0,  65);\n     sclFac = 0.008;\n  } else if (knType == 8) {  // 6.2 knot\n     knc[0] = vec3 (  -6,  -21,  -18);  kns[0] = vec3 (-21,  -24,  -13);\n     knc[1] = vec3 (-195, -207,  113);  kns[1] = vec3 ( 92,  -72, -107);\n     knc[2] = vec3 ( -64,  112,   86);  kns[2] = vec3 (-23,   -7,   -9);\n     knc[3] = vec3 (  -6,  -13,  -26);  kns[3] = vec3 ( 13,  -40,   -7);\n     knc[4] = vec3 (  24,  -27,   24);  kns[4] = vec3 ( 15,   -3,   33);\n     knc[5] = vec3 (   0,  -17,   21);  kns[5] = vec3 ( 41,    0,   31);\n     sclFac = 0.008;\n  } else if (knType == 9) {  // 6.3 knot\n     knc[0] = vec3 (-40,   90,  52);  kns[0] = vec3 ( 32,  89,  64);\n     knc[1] = vec3 ( 69, -142,  53);  kns[1] = vec3 (-12, 147,  35);\n     knc[2] = vec3 (120,   74,  77);  kns[2] = vec3 (-52,  85, -87);\n     knc[3] = vec3 (-56,    0, 101);  kns[3] = vec3 ( 46, -56, -19);\n     knc[4] = vec3 (  0,   23,  -5);  kns[4] = vec3 (-17,   0,   2);\n     knc[5] = vec3 ( 14,   16,   3);  kns[5] = vec3 ( 19,   7,   9);\n     sclFac = 0.008;\n  } else if (knType == 10) {  // 7.2 Knot\n     knc[0] = vec3 (  10, 42, 0);  kns[0] = vec3 (115, -104, 30);\n     knc[1] = vec3 (-184, -252,  20);  kns[1] = vec3 ( 10,  47,  19);\n     knc[2] = vec3 (   0,  -21,   6);  kns[2] = vec3 (101, -65, -31);\n     knc[3] = vec3 (  23,  -23,  -4);  kns[3] = vec3 ( 55, -23, -24);\n     knc[4] = vec3 ( -38,   36, -44);  kns[4] = vec3 ( -6, -10, -50);\n     knc[5] = vec3 ( -14,  -13,  31);  kns[5] = vec3 ( 8,    2,  39);\n     knc[6] = vec3 (  16,  -18, -16);  kns[6] = vec3 ( 14,  -9,  23);\n     sclFac = 0.007;\n  } else if (knType == 11) {  // 7.7 Knot\n     knc[0] = vec3 ( -5,   17, -28);  kns[0] = vec3 (  0,   21,   9);\n     knc[1] = vec3 (  8, -174, 110);  kns[1] = vec3 ( 83,   13,   4);\n     knc[2] = vec3 ( 87,  -15,  11);  kns[2] = vec3 (100,    3,  -6);\n     knc[3] = vec3 ( -5,   -9, -46);  kns[3] = vec3 ( 22,   46, -17);\n     knc[4] = vec3 (-10,   16,  32);  kns[4] = vec3 ( 10,  -25,  -9);\n     knc[5] = vec3 ( -2,  -21, -12);  kns[5] = vec3 (-10,    7,  -9);\n     knc[6] = vec3 (  5,   -9,  -9);  kns[6] = vec3 (  6,   -3,  18);\n     sclFac = 0.01;\n  }\n}\n\nvec3 KtPoint (float a)\n{\n  vec3 r;\n  float f;\n  r = vec3 (0.);\n  for (int k = 0; k < N_KNOT; k ++) {\n    f = float (k + 1) * a;\n    r += knc[k] * cos (f) + kns[k] * sin (f);\n  }\n  return sclFac * r;\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm)\n{\n  vec3 rmN, rmN1, rmN2, dr, dr1, dr2, am;\n  float fOvlap, fBend, rSep, c11, c22, c12, cd, c, dt;\n  int k1, k2;\n  fOvlap = 50.;\n  fBend = 1000.;\n  rm = Loadv4 (2 * mId).xyz;\n  vm = Loadv4 (2 * mId + 1).xyz;\n  am = vec3 (0.);\n  for (int n = 0; n < lenChain; n ++) {\n    if (n != mId) {\n      rmN = Loadv4 (2 * n).xyz;\n      dr = rm - rmN;\n      rSep = length (dr);\n      if (rSep < 1. || n == mId + 1 || n == mId - 1 ||\n         mId == 0 && n == lenChain - 1 || mId == lenChain - 1 && n == 0)\n         am += fOvlap * (1. - rSep) * normalize (dr);\n    }\n  }\n  for (int m = 0; m < 4; m ++) {\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      if (k1 < 0) k1 += lenChain;\n      k2 -= 2;\n      if (k2 < 0) k2 += lenChain;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      if (k1 < 0) k1 += lenChain;\n      k2 += 1;\n      if (k2 > lenChain - 1) k2 -= lenChain;\n    } else if (m == 3) {\n      k1 += 1;\n      if (k1 > lenChain - 1) k1 -= lenChain;\n      k2 += 2;\n      if (k2 > lenChain - 1) k2 -= lenChain;\n    }\n    rmN1 = Loadv4 (2 * k1).xyz;\n    rmN2 = Loadv4 (2 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n  dr = rm - spRad * normalize (rm);\n  rSep = length (dr);\n  if (rSep < 1.) am += fOvlap * (1. - rSep) * normalize (dr);\n  dt = 0.02;\n  vm += dt * am;\n  rm += dt * vm;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm = 8. * KtPoint (2. * pi * mIdf / float (lenChain));\n  vm = 0.5 * normalize (vec3 (Hashff (mIdf), Hashff (mIdf), Hashff (mIdf)) - 0.5);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 rm, vm, wgBxC;\n  vec2 canvas, iFrag;\n  float nStep, asp;\n  int mId, pxId;\n  bool doInit;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 2 * lenChain + 2) discard;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, -0.46, 0.02);\n  if (iFrame <= 5) {\n    doInit = true;\n    spRad = float (lenChain) / 9.;\n    knType = N_KNOT;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (2 * lenChain);\n    nStep = stDat.x;\n    spRad = stDat.y;\n    knType = int (stDat.z);\n    ++ nStep;\n  }\n  mPtrP.z = Loadv4 (2 * lenChain + 1).z;\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) < wgBxC.z) {\n      if (mPtrP.z <= 0.) doInit = true;\n    }\n  }\n  if (nStep > 10000.) doInit = true;\n  if (doInit) {\n    if (++ knType > N_KNOT) knType = 1;\n    KtSetup ();\n    nStep = 0.;\n  }\n  if (pxId < 2 * lenChain) {\n    mId = pxId / 2;\n    if (doInit) Init (mId, rm, vm);\n    else Step (mId, rm, vm);\n    if      (pxId == 2 * mId) stDat = vec4 (rm, 0.);\n    else if (pxId == 2 * mId + 1) stDat = vec4 (vm, 0.);\n  } else {\n    if (pxId == 2 * lenChain) stDat = vec4 (nStep, spRad, float (knType), 0.);\n    else if (pxId == 2 * lenChain + 1) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Knot Dynamics\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define N_KNOT  11\nvec3 knc[N_KNOT], kns[N_KNOT];\nfloat sclFac;\nint knType;\n\nconst int lenChain = 256;\nfloat spRad;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\n// Knot parametrizations from A.K. Trautwein thesis (University of Iowa, 1995) (many more)\n\nvoid KtSetup ()\n{\n  for (int k = 0; k < N_KNOT; k ++) {\n    knc[k] = vec3 (0);  kns[k] = vec3 (0);\n  }\n  if (knType == 1) {  // 3.1 trefoil knot\n     knc[0] = vec3 ( 41,   36,   0);   kns[0] = vec3 (-18,   27,   45);\n     knc[1] = vec3 (-83, -113,  -30);  kns[1] = vec3 (-83,   30,  113);\n     knc[2] = vec3 (-11,   11,  -11);  kns[2] = vec3 ( 27,  -27,   27);\n     sclFac = 0.015;\n  } else if (knType == 2) {  // 4.1 figure 8 knot\n     knc[0] = vec3 (  32,   94,   16);  kns[0] = vec3 (-51,   41,   73);\n     knc[1] = vec3 (-104,  113, -211);  kns[1] = vec3 (-34,    0,  -39);\n     knc[2] = vec3 ( 104,  -68,  -99);  kns[2] = vec3 (-91, -124,  -21);\n     sclFac = 0.008;\n  } else if (knType == 3) {  // 5.1 knot\n     knc[0] = vec3 (  88,   89,   44);  kns[0] = vec3 ( 115,  -32,  -69);\n     knc[1] = vec3 (-475, -172,   34);  kns[1] = vec3 (-127,  294,  223);\n     knc[2] = vec3 ( -87,   76,   16);  kns[2] = vec3 (  36,  102,  120);\n     knc[3] = vec3 (  11,  -61,   42);  kns[3] = vec3 ( -19,  113, -125);\n     sclFac = 0.0045;\n  } else if (knType == 4) {  // 5.2 knot\n     knc[0] = vec3 ( -33,  -57,   34);  kns[0] = vec3 ( 43,   99, -21);\n     knc[1] = vec3 (   0,  -54, -100);  kns[1] = vec3 (214, -159, -93);\n     knc[2] = vec3 (-101, -117,  -27);  kns[2] = vec3 (-47,   -5, -16);\n     knc[3] = vec3 (   0,  -31,   52);  kns[3] = vec3 ( 11,  -45,  84);\n     sclFac = 0.008;\n  } else if (knType == 5) {  // granny knot\n     knc[0] = vec3 (-22,   0,  0);  kns[0] = vec3 (-128,   0,   0);\n     knc[1] = vec3 (  0, -10,  0);  kns[1] = vec3 (   0, -27,   0);\n     knc[2] = vec3 (-44,   0, 70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[3] = vec3 (  0,  38,  0);  kns[3] = vec3 (   0,  38,   0);\n     sclFac = 0.016;\n  } else if (knType == 6) {  // square knot\n     knc[0] = vec3 ( -22,  11,   0);  kns[0] = vec3 (-128,   0,   0);\n     knc[2] = vec3 ( -44, -43,  70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[4] = vec3 (   0,  34,   8);  kns[4] = vec3 (   0, -39,  -9);\n     sclFac = 0.016;\n  } else if (knType == 7) {  // 6.1 knot\n     knc[0] = vec3 (  12,   29,  -30);  kns[0] = vec3 ( 20,  78, -78);\n     knc[1] = vec3 (-163, -180, -111);  kns[1] = vec3 ( 76,  58,  37);\n     knc[2] = vec3 ( -87,   88,  -67);  kns[2] = vec3 (-15,  72, -51);\n     knc[3] = vec3 ( -21,    0,   31);  kns[3] = vec3 ( 14, -14,   8);\n     knc[4] = vec3 (  24,    0,  -11);  kns[4] = vec3 (-50,   0,  65);\n     sclFac = 0.008;\n  } else if (knType == 8) {  // 6.2 knot\n     knc[0] = vec3 (  -6,  -21,  -18);  kns[0] = vec3 (-21,  -24,  -13);\n     knc[1] = vec3 (-195, -207,  113);  kns[1] = vec3 ( 92,  -72, -107);\n     knc[2] = vec3 ( -64,  112,   86);  kns[2] = vec3 (-23,   -7,   -9);\n     knc[3] = vec3 (  -6,  -13,  -26);  kns[3] = vec3 ( 13,  -40,   -7);\n     knc[4] = vec3 (  24,  -27,   24);  kns[4] = vec3 ( 15,   -3,   33);\n     knc[5] = vec3 (   0,  -17,   21);  kns[5] = vec3 ( 41,    0,   31);\n     sclFac = 0.008;\n  } else if (knType == 9) {  // 6.3 knot\n     knc[0] = vec3 (-40,   90,  52);  kns[0] = vec3 ( 32,  89,  64);\n     knc[1] = vec3 ( 69, -142,  53);  kns[1] = vec3 (-12, 147,  35);\n     knc[2] = vec3 (120,   74,  77);  kns[2] = vec3 (-52,  85, -87);\n     knc[3] = vec3 (-56,    0, 101);  kns[3] = vec3 ( 46, -56, -19);\n     knc[4] = vec3 (  0,   23,  -5);  kns[4] = vec3 (-17,   0,   2);\n     knc[5] = vec3 ( 14,   16,   3);  kns[5] = vec3 ( 19,   7,   9);\n     sclFac = 0.008;\n  } else if (knType == 10) {  // 7.2 Knot\n     knc[0] = vec3 (  10, 42, 0);  kns[0] = vec3 (115, -104, 30);\n     knc[1] = vec3 (-184, -252,  20);  kns[1] = vec3 ( 10,  47,  19);\n     knc[2] = vec3 (   0,  -21,   6);  kns[2] = vec3 (101, -65, -31);\n     knc[3] = vec3 (  23,  -23,  -4);  kns[3] = vec3 ( 55, -23, -24);\n     knc[4] = vec3 ( -38,   36, -44);  kns[4] = vec3 ( -6, -10, -50);\n     knc[5] = vec3 ( -14,  -13,  31);  kns[5] = vec3 ( 8,    2,  39);\n     knc[6] = vec3 (  16,  -18, -16);  kns[6] = vec3 ( 14,  -9,  23);\n     sclFac = 0.007;\n  } else if (knType == 11) {  // 7.7 Knot\n     knc[0] = vec3 ( -5,   17, -28);  kns[0] = vec3 (  0,   21,   9);\n     knc[1] = vec3 (  8, -174, 110);  kns[1] = vec3 ( 83,   13,   4);\n     knc[2] = vec3 ( 87,  -15,  11);  kns[2] = vec3 (100,    3,  -6);\n     knc[3] = vec3 ( -5,   -9, -46);  kns[3] = vec3 ( 22,   46, -17);\n     knc[4] = vec3 (-10,   16,  32);  kns[4] = vec3 ( 10,  -25,  -9);\n     knc[5] = vec3 ( -2,  -21, -12);  kns[5] = vec3 (-10,    7,  -9);\n     knc[6] = vec3 (  5,   -9,  -9);  kns[6] = vec3 (  6,   -3,  18);\n     sclFac = 0.01;\n  }\n}\n\nvec3 KtPoint (float a)\n{\n  vec3 r;\n  float f;\n  r = vec3 (0.);\n  for (int k = 0; k < N_KNOT; k ++) {\n    f = float (k + 1) * a;\n    r += knc[k] * cos (f) + kns[k] * sin (f);\n  }\n  return sclFac * r;\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm)\n{\n  vec3 rmN, rmN1, rmN2, dr, dr1, dr2, am;\n  float fOvlap, fBend, rSep, c11, c22, c12, cd, c, dt;\n  int k1, k2;\n  fOvlap = 50.;\n  fBend = 1000.;\n  rm = Loadv4 (2 * mId).xyz;\n  vm = Loadv4 (2 * mId + 1).xyz;\n  am = vec3 (0.);\n  for (int n = 0; n < lenChain; n ++) {\n    if (n != mId) {\n      rmN = Loadv4 (2 * n).xyz;\n      dr = rm - rmN;\n      rSep = length (dr);\n      if (rSep < 1. || n == mId + 1 || n == mId - 1 ||\n         mId == 0 && n == lenChain - 1 || mId == lenChain - 1 && n == 0)\n         am += fOvlap * (1. - rSep) * normalize (dr);\n    }\n  }\n  for (int m = 0; m < 4; m ++) {\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      if (k1 < 0) k1 += lenChain;\n      k2 -= 2;\n      if (k2 < 0) k2 += lenChain;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      if (k1 < 0) k1 += lenChain;\n      k2 += 1;\n      if (k2 > lenChain - 1) k2 -= lenChain;\n    } else if (m == 3) {\n      k1 += 1;\n      if (k1 > lenChain - 1) k1 -= lenChain;\n      k2 += 2;\n      if (k2 > lenChain - 1) k2 -= lenChain;\n    }\n    rmN1 = Loadv4 (2 * k1).xyz;\n    rmN2 = Loadv4 (2 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n  dr = rm - spRad * normalize (rm);\n  rSep = length (dr);\n  if (rSep < 1.) am += fOvlap * (1. - rSep) * normalize (dr);\n  dt = 0.02;\n  vm += dt * am;\n  rm += dt * vm;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm = 8. * KtPoint (2. * pi * mIdf / float (lenChain));\n  vm = 0.5 * normalize (vec3 (Hashff (mIdf), Hashff (mIdf), Hashff (mIdf)) - 0.5);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 rm, vm, wgBxC;\n  vec2 canvas, iFrag;\n  float nStep, asp;\n  int mId, pxId;\n  bool doInit;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 2 * lenChain + 2) discard;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, -0.46, 0.02);\n  if (iFrame <= 5) {\n    doInit = true;\n    spRad = float (lenChain) / 9.;\n    knType = N_KNOT;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (2 * lenChain);\n    nStep = stDat.x;\n    spRad = stDat.y;\n    knType = int (stDat.z);\n    ++ nStep;\n  }\n  mPtrP.z = Loadv4 (2 * lenChain + 1).z;\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) < wgBxC.z) {\n      if (mPtrP.z <= 0.) doInit = true;\n    }\n  }\n  if (nStep > 10000.) doInit = true;\n  if (doInit) {\n    if (++ knType > N_KNOT) knType = 1;\n    KtSetup ();\n    nStep = 0.;\n  }\n  if (pxId < 2 * lenChain) {\n    mId = pxId / 2;\n    if (doInit) Init (mId, rm, vm);\n    else Step (mId, rm, vm);\n    if      (pxId == 2 * mId) stDat = vec4 (rm, 0.);\n    else if (pxId == 2 * mId + 1) stDat = vec4 (vm, 0.);\n  } else {\n    if (pxId == 2 * lenChain) stDat = vec4 (nStep, spRad, float (knType), 0.);\n    else if (pxId == 2 * lenChain + 1) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Knot Dynamics\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define N_KNOT  11\nvec3 knc[N_KNOT], kns[N_KNOT];\nfloat sclFac;\nint knType;\n\nconst int lenChain = 256;\nfloat spRad;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\n// Knot parametrizations from A.K. Trautwein thesis (University of Iowa, 1995) (many more)\n\nvoid KtSetup ()\n{\n  for (int k = 0; k < N_KNOT; k ++) {\n    knc[k] = vec3 (0);  kns[k] = vec3 (0);\n  }\n  if (knType == 1) {  // 3.1 trefoil knot\n     knc[0] = vec3 ( 41,   36,   0);   kns[0] = vec3 (-18,   27,   45);\n     knc[1] = vec3 (-83, -113,  -30);  kns[1] = vec3 (-83,   30,  113);\n     knc[2] = vec3 (-11,   11,  -11);  kns[2] = vec3 ( 27,  -27,   27);\n     sclFac = 0.015;\n  } else if (knType == 2) {  // 4.1 figure 8 knot\n     knc[0] = vec3 (  32,   94,   16);  kns[0] = vec3 (-51,   41,   73);\n     knc[1] = vec3 (-104,  113, -211);  kns[1] = vec3 (-34,    0,  -39);\n     knc[2] = vec3 ( 104,  -68,  -99);  kns[2] = vec3 (-91, -124,  -21);\n     sclFac = 0.008;\n  } else if (knType == 3) {  // 5.1 knot\n     knc[0] = vec3 (  88,   89,   44);  kns[0] = vec3 ( 115,  -32,  -69);\n     knc[1] = vec3 (-475, -172,   34);  kns[1] = vec3 (-127,  294,  223);\n     knc[2] = vec3 ( -87,   76,   16);  kns[2] = vec3 (  36,  102,  120);\n     knc[3] = vec3 (  11,  -61,   42);  kns[3] = vec3 ( -19,  113, -125);\n     sclFac = 0.0045;\n  } else if (knType == 4) {  // 5.2 knot\n     knc[0] = vec3 ( -33,  -57,   34);  kns[0] = vec3 ( 43,   99, -21);\n     knc[1] = vec3 (   0,  -54, -100);  kns[1] = vec3 (214, -159, -93);\n     knc[2] = vec3 (-101, -117,  -27);  kns[2] = vec3 (-47,   -5, -16);\n     knc[3] = vec3 (   0,  -31,   52);  kns[3] = vec3 ( 11,  -45,  84);\n     sclFac = 0.008;\n  } else if (knType == 5) {  // granny knot\n     knc[0] = vec3 (-22,   0,  0);  kns[0] = vec3 (-128,   0,   0);\n     knc[1] = vec3 (  0, -10,  0);  kns[1] = vec3 (   0, -27,   0);\n     knc[2] = vec3 (-44,   0, 70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[3] = vec3 (  0,  38,  0);  kns[3] = vec3 (   0,  38,   0);\n     sclFac = 0.016;\n  } else if (knType == 6) {  // square knot\n     knc[0] = vec3 ( -22,  11,   0);  kns[0] = vec3 (-128,   0,   0);\n     knc[2] = vec3 ( -44, -43,  70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[4] = vec3 (   0,  34,   8);  kns[4] = vec3 (   0, -39,  -9);\n     sclFac = 0.016;\n  } else if (knType == 7) {  // 6.1 knot\n     knc[0] = vec3 (  12,   29,  -30);  kns[0] = vec3 ( 20,  78, -78);\n     knc[1] = vec3 (-163, -180, -111);  kns[1] = vec3 ( 76,  58,  37);\n     knc[2] = vec3 ( -87,   88,  -67);  kns[2] = vec3 (-15,  72, -51);\n     knc[3] = vec3 ( -21,    0,   31);  kns[3] = vec3 ( 14, -14,   8);\n     knc[4] = vec3 (  24,    0,  -11);  kns[4] = vec3 (-50,   0,  65);\n     sclFac = 0.008;\n  } else if (knType == 8) {  // 6.2 knot\n     knc[0] = vec3 (  -6,  -21,  -18);  kns[0] = vec3 (-21,  -24,  -13);\n     knc[1] = vec3 (-195, -207,  113);  kns[1] = vec3 ( 92,  -72, -107);\n     knc[2] = vec3 ( -64,  112,   86);  kns[2] = vec3 (-23,   -7,   -9);\n     knc[3] = vec3 (  -6,  -13,  -26);  kns[3] = vec3 ( 13,  -40,   -7);\n     knc[4] = vec3 (  24,  -27,   24);  kns[4] = vec3 ( 15,   -3,   33);\n     knc[5] = vec3 (   0,  -17,   21);  kns[5] = vec3 ( 41,    0,   31);\n     sclFac = 0.008;\n  } else if (knType == 9) {  // 6.3 knot\n     knc[0] = vec3 (-40,   90,  52);  kns[0] = vec3 ( 32,  89,  64);\n     knc[1] = vec3 ( 69, -142,  53);  kns[1] = vec3 (-12, 147,  35);\n     knc[2] = vec3 (120,   74,  77);  kns[2] = vec3 (-52,  85, -87);\n     knc[3] = vec3 (-56,    0, 101);  kns[3] = vec3 ( 46, -56, -19);\n     knc[4] = vec3 (  0,   23,  -5);  kns[4] = vec3 (-17,   0,   2);\n     knc[5] = vec3 ( 14,   16,   3);  kns[5] = vec3 ( 19,   7,   9);\n     sclFac = 0.008;\n  } else if (knType == 10) {  // 7.2 Knot\n     knc[0] = vec3 (  10, 42, 0);  kns[0] = vec3 (115, -104, 30);\n     knc[1] = vec3 (-184, -252,  20);  kns[1] = vec3 ( 10,  47,  19);\n     knc[2] = vec3 (   0,  -21,   6);  kns[2] = vec3 (101, -65, -31);\n     knc[3] = vec3 (  23,  -23,  -4);  kns[3] = vec3 ( 55, -23, -24);\n     knc[4] = vec3 ( -38,   36, -44);  kns[4] = vec3 ( -6, -10, -50);\n     knc[5] = vec3 ( -14,  -13,  31);  kns[5] = vec3 ( 8,    2,  39);\n     knc[6] = vec3 (  16,  -18, -16);  kns[6] = vec3 ( 14,  -9,  23);\n     sclFac = 0.007;\n  } else if (knType == 11) {  // 7.7 Knot\n     knc[0] = vec3 ( -5,   17, -28);  kns[0] = vec3 (  0,   21,   9);\n     knc[1] = vec3 (  8, -174, 110);  kns[1] = vec3 ( 83,   13,   4);\n     knc[2] = vec3 ( 87,  -15,  11);  kns[2] = vec3 (100,    3,  -6);\n     knc[3] = vec3 ( -5,   -9, -46);  kns[3] = vec3 ( 22,   46, -17);\n     knc[4] = vec3 (-10,   16,  32);  kns[4] = vec3 ( 10,  -25,  -9);\n     knc[5] = vec3 ( -2,  -21, -12);  kns[5] = vec3 (-10,    7,  -9);\n     knc[6] = vec3 (  5,   -9,  -9);  kns[6] = vec3 (  6,   -3,  18);\n     sclFac = 0.01;\n  }\n}\n\nvec3 KtPoint (float a)\n{\n  vec3 r;\n  float f;\n  r = vec3 (0.);\n  for (int k = 0; k < N_KNOT; k ++) {\n    f = float (k + 1) * a;\n    r += knc[k] * cos (f) + kns[k] * sin (f);\n  }\n  return sclFac * r;\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm)\n{\n  vec3 rmN, rmN1, rmN2, dr, dr1, dr2, am;\n  float fOvlap, fBend, rSep, c11, c22, c12, cd, c, dt;\n  int k1, k2;\n  fOvlap = 50.;\n  fBend = 1000.;\n  rm = Loadv4 (2 * mId).xyz;\n  vm = Loadv4 (2 * mId + 1).xyz;\n  am = vec3 (0.);\n  for (int n = 0; n < lenChain; n ++) {\n    if (n != mId) {\n      rmN = Loadv4 (2 * n).xyz;\n      dr = rm - rmN;\n      rSep = length (dr);\n      if (rSep < 1. || n == mId + 1 || n == mId - 1 ||\n         mId == 0 && n == lenChain - 1 || mId == lenChain - 1 && n == 0)\n         am += fOvlap * (1. - rSep) * normalize (dr);\n    }\n  }\n  for (int m = 0; m < 4; m ++) {\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      if (k1 < 0) k1 += lenChain;\n      k2 -= 2;\n      if (k2 < 0) k2 += lenChain;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      if (k1 < 0) k1 += lenChain;\n      k2 += 1;\n      if (k2 > lenChain - 1) k2 -= lenChain;\n    } else if (m == 3) {\n      k1 += 1;\n      if (k1 > lenChain - 1) k1 -= lenChain;\n      k2 += 2;\n      if (k2 > lenChain - 1) k2 -= lenChain;\n    }\n    rmN1 = Loadv4 (2 * k1).xyz;\n    rmN2 = Loadv4 (2 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n  dr = rm - spRad * normalize (rm);\n  rSep = length (dr);\n  if (rSep < 1.) am += fOvlap * (1. - rSep) * normalize (dr);\n  dt = 0.02;\n  vm += dt * am;\n  rm += dt * vm;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm = 8. * KtPoint (2. * pi * mIdf / float (lenChain));\n  vm = 0.5 * normalize (vec3 (Hashff (mIdf), Hashff (mIdf), Hashff (mIdf)) - 0.5);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 rm, vm, wgBxC;\n  vec2 canvas, iFrag;\n  float nStep, asp;\n  int mId, pxId;\n  bool doInit;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 2 * lenChain + 2) discard;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, -0.46, 0.02);\n  if (iFrame <= 5) {\n    doInit = true;\n    spRad = float (lenChain) / 9.;\n    knType = N_KNOT;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (2 * lenChain);\n    nStep = stDat.x;\n    spRad = stDat.y;\n    knType = int (stDat.z);\n    ++ nStep;\n  }\n  mPtrP.z = Loadv4 (2 * lenChain + 1).z;\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) < wgBxC.z) {\n      if (mPtrP.z <= 0.) doInit = true;\n    }\n  }\n  if (nStep > 10000.) doInit = true;\n  if (doInit) {\n    if (++ knType > N_KNOT) knType = 1;\n    KtSetup ();\n    nStep = 0.;\n  }\n  if (pxId < 2 * lenChain) {\n    mId = pxId / 2;\n    if (doInit) Init (mId, rm, vm);\n    else Step (mId, rm, vm);\n    if      (pxId == 2 * mId) stDat = vec4 (rm, 0.);\n    else if (pxId == 2 * mId + 1) stDat = vec4 (vm, 0.);\n  } else {\n    if (pxId == 2 * lenChain) stDat = vec4 (nStep, spRad, float (knType), 0.);\n    else if (pxId == 2 * lenChain + 1) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXzc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2355, 2355, 2387, 2387, 2595], [2597, 2597, 2629, 2629, 3092], [3094, 3094, 3125, 3125, 3179], [3181, 3181, 3216, 3216, 4149], [4151, 4151, 4207, 4207, 5447], [5449, 5449, 5471, 5471, 5509], [5511, 5511, 5533, 5533, 5571], [5573, 5573, 5603, 5603, 5716], [5718, 5718, 5754, 5754, 5960], [5962, 5962, 5998, 5998, 6086], [6088, 6088, 6112, 6112, 6234], [6328, 6328, 6353, 6353, 6481]], "test": "untested"}
{"id": "3lKSWh", "name": "Menger Sponge Breakdown", "author": "Parcle", "description": "Link to associated article: https://lucodivo.github.io/menger_sponge.html", "tags": ["raymarching"], "likes": 4, "viewed": 326, "published": 3, "date": "1583303384", "time_retrieved": "2024-07-30T21:20:41.628513", "image_code": "// The MIT License\n// Copyright © 2013 Connor Alexander Haskins\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A helpful breakdown for teaching a beginner how to create a Menger Sponge\n// This shader has an associated article which can be found here: http://connorahaskins.com/menger_sponge.html\n\n#define MAX_STEPS 60\n#define MISS_DIST 10.0\n#define HIT_DIST 0.01\n\n#define WIDTH 2.0\n#define HALF_WIDTH 1.0\n    \nvec2 distanceRayToScene(vec3 rayDir);\nfloat distPosToScene(vec3 rayPos);\nfloat sdYAlignedPlane(vec3 rayPos);\nmat2 rotate(float angle);\n\nfloat sdSphere(vec3 rayPos, vec3 sphereCenterPosition, float radius);\nfloat sdSphere(vec3 rayPos, float radius);\nfloat sdSphere(vec3 rayPos);\nfloat sdCube(vec3 rayPos);\nfloat sdCross(vec3 rayPos);\n\nfloat sdBoundedCross(vec3 rayPos);\nfloat sdBoundedCrossSlimmed(vec3 rayPos);\nfloat sdBoundedCrossWithBox(vec3 rayPos);\nfloat sdMengerSpongeIteration1(vec3 rayPos);\nfloat sdBoundedBoxFieldBroken(vec3 rayPos);\nfloat sdBoundedBoxField(vec3 rayPos);\nfloat sdTwentySevenBoxesKinda(vec3 rayPos);\nfloat sdTwentySevenBoxesCross(vec3 rayPos);\nfloat sdTwentySevenBoxes(vec3 rayPos);\nfloat sdTwentySevenCrossesBound(vec3 rayPos);\nfloat sdMengerSpongeIteration2(vec3 rayPos);\nfloat sdMengerSponge(vec3 rayPos, int numIterations);\n\nconst vec3 cameraPos = vec3(6.0, 6.0, -6.0);\nconst vec3 missColor = vec3(0.0, 0.0, 0.0);\n\nconst float floorHeight = -3.0;\nconst vec3 spherePos = vec3(0.0, 0.0, 0.0);\nconst float sphereScale = 3.0;\nconst vec3 cubePos = vec3(0.0, 0.0, 0.0);\nconst float cubeScale = 2.0;\nconst vec3 crossPos = vec3(0.0, 0.0, 0.0);\nconst float crossScale = 1.1;\nconst vec3 infSpherePos = vec3(0.0, 0.0, 0.0);\nconst float infSphereScale = 0.5;\nconst vec3 mengerSpongePos = vec3(0.0, 0.5, 0.0);\nconst float mengerSpongeScale = 2.5;\nconst int mengerSpongeIterations = 3;\n\nfloat distPosToScene(vec3 rayPos) {\n    \n    float distFloor = sdYAlignedPlane(rayPos - vec3(0.0, floorHeight, 0.0));\n    float dist;\n    \n    // NOTE: Pairing the floors with some objects through a union helps \n\t// create a more understandable scene\n    \n    // Sphere Method #1\n\tdist = min(sdSphere(rayPos, spherePos, sphereScale), distFloor);\n    \n    // Sphere Method #2\n    //dist = min(sdSphere(rayPos - spherePos, sphereScale), distFloor);\n    \n    // Sphere Method #3\n    //dist = min(sdSphere((rayPos - spherePos) / sphereScale) * sphereScale, distFloor);\n    \n    // Cube\n    //dist = min(sdCube((rayPos - cubePos) / cubeScale) * cubeScale, distFloor);\n    \n    // Cross\n    //dist = sdCross((rayPos - crossPos) / crossScale) * crossScale;\n    \n    // Infinite Spheres\n    //vec3 infRayPos = mod(rayPos, WIDTH) - HALF_WIDTH;\n    //dist = sdSphere((infRayPos - infSpherePos) / infSphereScale) * infSphereScale;\n    \n    \n    \n    // === Menger Sponge ===\n    // MengerSponge Part 1: Bounded Cross\n    //dist = sdBoundedCross((rayPos - mengerSpongePos) / 1.5) * 1.5;\n    \n    // MengerSponge Part 2: Slimmed Bounded Cross\n    //dist = sdBoundedCrossSlimmed((rayPos - mengerSpongePos) / 1.5) * 1.5;\n    \n    // MengerSponge Part 3: Bounded Cross w/ Box\n    //dist = sdBoundedCrossWithBox((rayPos - mengerSpongePos) / 1.5) * 1.5;\n    \n    // MengerSponge Part 4: Iteration 1\n    //dist = sdMengerSpongeIteration1((rayPos - mengerSpongePos) / 1.5) * 1.5;\n    \n    // MengerSponge Part 5: Bounded Box Field (Broken)\n    //dist = sdBoundedBoxFieldBroken((rayPos - mengerSpongePos) / 0.5) * 0.5;\n    \n    // MengerSponge Part 6: Bounded Box Field (Fixed)\n    //dist = sdBoundedBoxField((rayPos - mengerSpongePos) / 0.5) * 0.5;\n    \n    // MengerSponge Part 7: Twenty Seven Boxes...Kinda\n    //dist = sdTwentySevenBoxesKinda((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // MengerSponge Part 8: Twenty Seven Boxes Cross-Section\n    //dist = sdTwentySevenBoxesCross((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // MengerSponge Part 9: 27 Cubes\n    //dist = sdTwentySevenBoxes((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // MengerSponge Part 10: 27 Crosses Bound\n    //dist = sdTwentySevenCrossesBound((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // MengerSponge Part 11: Iteration 2\n    //dist = sdMengerSpongeIteration2((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // Menger Sponge\n    //dist = sdMengerSponge((rayPos - mengerSpongePos) / mengerSpongeScale, mengerSpongeIterations) * mengerSpongeScale;\n    \n    return dist;\n}\n\n// NOTE: Entry point of fragment shader\n// This function point is called per pixel\n// fragCoord is (x,y) location of pixel\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Subtract half the width/height resolution components to\n    // Move origin, (0,0), from bottom left corner to center of screen\n    vec2 pixelCoord = fragCoord.xy - (iResolution.xy * 0.5);\n\n    // Scale y value to [-1.0, 1.0], scale x by same factor (if screen is wider, x will have values >1 & <-1)\n    pixelCoord = pixelCoord / iResolution.y;\n\n    // Represents the fragment position on the plane where rays are shot through\n    // Can be thought of as the pixel coordinate on the screen\n    vec3 fragmentPos = vec3(pixelCoord.x, pixelCoord.y, 0.0);\n    \n    // The point in which our rays emit from\n    // Adjusting z value in the range of [-3.0, 0.0] gives a variety of viewing angles\n    const vec3 focalPoint = vec3(0.0, 0.0, -1.0);\n    \n    // get the direction of a ray emitting from the focal point through fragment position\n    vec3 rayDir = fragmentPos - focalPoint;\n\n    // rotate direction vectors to point towards the world origin (where our objects will be centered)\n    // these \"magic\" numbers were derived from the angle needed to point from cameraPos to the world origin\n    rayDir.yz *= rotate(radians(35.24)); \n    rayDir.xz *= rotate(radians(45.0));\n    rayDir = normalize(rayDir);\n\n    vec2 dist = distanceRayToScene(rayDir);\n\n    if(dist.x > 0.0) { // hit\n        // color surface by number of iterations (from white to black)\n        vec3 col = vec3(1.0 - (dist.y/float(MAX_STEPS)));\n        fragColor = vec4(col, 1.0);\n    } else { // miss\n        fragColor = vec4(missColor, 1.0);\n    }\n}\n\n\n// returns vec2(dist, iterations)\n// NOTE: ray dir arguments are assumed to be normalized\nvec2 distanceRayToScene(vec3 rayDir) {\n\n\tfloat dist = 0.0;\n\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = cameraPos + (dist * rayDir);\n        float posToScene = distPosToScene(pos);\n        dist += posToScene;\n        if(abs(posToScene) < HIT_DIST) return vec2(dist, i); // absolute value for posToScene incase the ray makes its way inside an object\n        if(posToScene > MISS_DIST) break;\n    }\n\n    return vec2(-1.0f, MAX_STEPS);\n}\n\nfloat sdSphere(vec3 rayPosition, vec3 sphereCenterPosition, float radius) {\n    vec3 centerToRay = rayPosition - sphereCenterPosition;\n\tfloat distToCenter = length(centerToRay);\n    return distToCenter - radius;\n}\n\nfloat sdSphere(vec3 rayPos, float radius) {\n    return length(rayPos) - radius;\n}\n\nfloat sdSphere(vec3 rayPos) {\n    return length(rayPos) - HALF_WIDTH;\n}\n\nfloat sdCube(vec3 rayPos) {\n\tconst vec3 corner = vec3(HALF_WIDTH);\n    vec3 ray = abs(rayPos); // fold ray into positive octant\n    vec3 cornerToRay = ray - corner;\n    float cornerToRayMaxComponent = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n    float distToInsideRay = min(cornerToRayMaxComponent, 0.0);\n    vec3 closestToOutsideRay = max(cornerToRay, 0.0);\n\treturn length(closestToOutsideRay) + distToInsideRay;\n} \n\nfloat sdCross(vec3 rayPos) {\n    const vec3 corner = vec3(HALF_WIDTH);\n\tvec3 ray = abs(rayPos); // fold ray into positive quadrant\n\tvec3 cornerToRay = ray - corner;\n\n    float smallestComp = min(min(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat largestComp = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat middleComp = cornerToRay.x + cornerToRay.y + cornerToRay.z\n\t\t\t\t\t\t\t- smallestComp - largestComp;\n            \n\tvec2 closestOutsidePoint = max(vec2(smallestComp, middleComp), 0.0);\n\tvec2 closestInsidePoint = min(vec2(middleComp, largestComp), 0.0);\n\n\treturn (middleComp > 0.0) ? length(closestOutsidePoint) : -length(closestInsidePoint);\n}\n\nfloat sdBoundedCross(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos);\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\treturn intersection;\n}\n\n\nfloat sdBoundedCrossSlimmed(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos / 0.33) * 0.33;\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\treturn intersection;\n}\n\n\nfloat sdBoundedCrossWithBox(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos * 3.0) / 3.0;\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\tfloat spongeBox = sdCube(rayPos);\n\tfloat boxCrossUnion = min(intersection, spongeBox);\n\treturn boxCrossUnion;\n}\n\n\nfloat sdMengerSpongeIteration1(vec3 rayPos) {\n\tfloat crossDist = sdCross(rayPos * 3.0) / 3.0;\n\tfloat spongeBox = sdCube(rayPos);\n\treturn max(spongeBox, -crossDist);\n}\n\n\nfloat sdBoundedBoxFieldBroken(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos / 3.9) * 3.9;\n\tvec3 ray = mod(rayPos, 2.0);\n\tfloat dist = sdCube(ray / 1.5) * 1.5;\n\treturn max(dist, boundingBox);\n}\n\n\nfloat sdBoundedBoxField(vec3 rayPos) { \n\tfloat boundingBox = sdCube(rayPos / 4.0) * 4.0;\n\tvec3 ray = mod(rayPos, 2.0);\n\tray -= 1.0;\n\tfloat dist = sdCube(ray / 0.8) * 0.8;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenBoxesKinda(vec3 rayPos) {\n\t// bounding box spans all axes between [-halfBoxDimen, halfBoxDimen]\n\tfloat boundingBox = sdCube(rayPos);\n\t// The rays are transformed into boxed spaces with all axes between [0, boxDimen / 3.0)\n\t// this is because each cube should have a third the dimension of the entire cube\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tvec3 ray = mod(rayPos, boxedWorldDimen);\n\t// The origin within the boxes is moved from the corner to the center of the cube,\n\t// with the rays now having a range between [-boxDimen / 6.0, boxDimen / 6.0)\n\tray -= (boxedWorldDimen) / 2.0;\n\t// Transform coordinates of each boxed space to range [-halfBoxDimen, halfBoxDimen)\n\tray *= 3.0;\n\t// Shrink the cubes slightly to reveal gaps between them\n\tfloat dist = sdCube(ray / 0.9) / 0.9;\n\t// Correct warping of space caused by previously stretching the ray\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenBoxesCross(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos);\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tvec3 ray = mod(rayPos, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCube(ray / 0.9) * 0.9;\n\tdist /= 3.0;\n\tdist = max(dist, boundingBox);\n\t// Cross that runs along the axes of our world\n\tfloat axesCross = sdCross(rayPos / 0.25) * 0.25;\n\treturn max(dist, axesCross);\n}\n\nfloat sdTwentySevenBoxes(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos);\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\t// We want to translate the first box in the positive octant to change it’s world coordinates\n\t// from [0, boxedWorldDimen) to [-boxedWorldDimen / 2.0, boxedWorldDimen / 2.0) \n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCube(ray / 0.9) * 0.9;\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenCrossesBound(vec3 rayPos) {\n    const float oneThird = 1.0 / 3.0;\n\tfloat boundingBox = sdCube(rayPos);\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCross(ray / oneThird) * oneThird;\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdMengerSpongeIteration2(vec3 rayPos) {\n    const float oneThird = 1.0 / 3.0;\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat crossesUnboundDist = sdCross(ray / oneThird) * oneThird;\n\tcrossesUnboundDist /= 3.0;\n    \n\tfloat distFirstIter = sdMengerSpongeIteration1(rayPos);\n\treturn max(distFirstIter, -crossesUnboundDist);\n}\n\nfloat sdMengerSponge(vec3 rayPos, int numIterations) {\n\tfloat spongeCube = sdCube(rayPos);\n    if(spongeCube > HIT_DIST) return spongeCube; // use dist of sponge box as bounding box\n\tfloat mengerSpongeDist = spongeCube;\n\n\tfloat scale = 1.0;\n\tfor(int i = 0; i < numIterations; ++i) {\n    \tfloat boxedWidth = WIDTH / scale;\n    \tvec3 ray = mod(rayPos + boxedWidth / 2.0, boxedWidth);\n    \tray -= boxedWidth / 2.0;\n    \tray *= scale;\n    \tfloat crossesDist = sdCross(ray * 3.0);\n    \tscale *= 3.0;\n    \tcrossesDist /= scale;\n    \tmengerSpongeDist = max(mengerSpongeDist, -crossesDist);\n\t}\n    \n\treturn mengerSpongeDist;\n}\n\nfloat sdYAlignedPlane(vec3 rayPos) {\n    return abs(rayPos.y);\n}\n\nmat2 rotate(float angle) {\n    float sine = sin(angle);\n    float cosine = cos(angle);\n    return mat2(cosine, -sine, sine, cosine);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKSWh.jpg", "access": "api", "license": "mit", "functions": [[2793, 2793, 2828, 2828, 5485], [5487, 5610, 5665, 5803, 7191], [7194, 7284, 7322, 7322, 7731], [7733, 7733, 7808, 7808, 7946], [7948, 7948, 7991, 7991, 8029], [8031, 8031, 8060, 8060, 8102], [8104, 8104, 8131, 8131, 8533], [8536, 8536, 8564, 8564, 9202], [9204, 9204, 9239, 9239, 9407], [9410, 9410, 9452, 9452, 9634], [9637, 9637, 9679, 9679, 9948], [9951, 9951, 9996, 9996, 10117], [10120, 10120, 10164, 10164, 10316], [10319, 10319, 10357, 10357, 10523], [10525, 10525, 10569, 10639, 11436], [11438, 11438, 11482, 11482, 11860], [11862, 11862, 11901, 11901, 12400], [12402, 12402, 12448, 12448, 12817], [12819, 12819, 12864, 12864, 13303], [13305, 13305, 13359, 13359, 13923], [13925, 13925, 13961, 13961, 13989], [13991, 13991, 14017, 14017, 14125]], "test": "error"}
{"id": "wtVXz3", "name": "simple feedback example", "author": "aferriss", "description": "Simple feedback example", "tags": ["texcoords", "feedback", "offset"], "likes": 3, "viewed": 394, "published": 3, "date": "1583282282", "time_retrieved": "2024-07-30T21:20:42.393468", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Scale of the noise determines the density of flow\n    vec4 noise = texture(iChannel1, uv * 0.25 + sin(iTime * 3.0 ) * 0.01);\n    \n    // The distortino amount is just the red and green channels of the noise multiplied by some value\n    vec2 distortion = noise.rg * vec2(0.005, 0.01);\n    \n    // Add the distortion to the uv's\n    vec4 lastFrame = texture(iChannel2, uv + distortion);\n    \n    // Output color\n    fragColor = lastFrame;\n        \n    // In the beginning, seed the feedback with an image\n    // Also reset every now and then\n    if(iTime < 0.1 || mod(iTime, 5.0) < 0.5){\n\n\t\tfragColor = texture(iChannel1, uv);\n    }\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 215]], "test": "untested"}
{"id": "tlKSz3", "name": "MyGrids", "author": "Arseny", "description": "sex", "tags": ["2d"], "likes": 6, "viewed": 408, "published": 3, "date": "1583278130", "time_retrieved": "2024-07-30T21:20:43.165405", "image_code": "//#define BLINKING\n\nfloat circGrid(vec2 uv, float offset, float blur){\n    vec2 lv = fract(uv);\n    lv -= 0.5;\n    return 1. - smoothstep(0., blur, abs(length(lv) - (0.5 - offset - blur)));\n}\n\nfloat polargreed(vec2 uv){\n    float ans = 0.;\n    float len = length(uv);\n    if (len < 0.1){\n        return 0.;\n    }\n    vec2 pv1 = vec2(atan(uv.y, uv.x) / 6.2831 + 0.5 + pow(len, 0.5) / 5., len);\n    //float m = min(fract(x), fract(1. - x));\n    //ans = smoothstep(0., 0.1, m * 0.5 + .2 - pv.y);\n    float m;\n    float dst = abs(fract(pv1.x * 23.) - 0.5) * 2.;\n    float t = iTime;\n    #ifdef BLINKING\n    t = 0.;\n    #endif\n    dst = min(dst, abs(fract(pow(len, 0.7) * 7. + t) - 0.5) * 2.);\n    //m = fract(pv1.x * 23.);\n    //ans = max(ans, 1. - smoothstep(0., 0.1, abs(m - 0.5)));\n    //m = fract(sqrt(len) * 7.);\n    //ans = max(ans, 1. - smoothstep(0., 0.1, abs(m - 0.5)));\n    ans = dst;//max(ans, 1. - smoothstep(0., 0.1, dst));\n    return ans;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    vec3 col = vec3(0);\n    col = vec3(polargreed(uv));\n    \n    \n    #ifdef BLINKING\n    if (mod(floor(iTime * 40.), 2.) < 0.1){\n        col = vec3(0.5);\n    }\n    #endif\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 70, 70, 191], [193, 193, 219, 219, 950], [952, 952, 1009, 1059, 1457]], "test": "untested"}
{"id": "wlVSz3", "name": "Orchard (Alternative Projection)", "author": "Dave_Hoskins", "description": "This is an alternative projection of my 'Abstract Orchard' [url]https://www.shadertoy.com/view/tdGGWV[/url]\nRemoves rotation distortion associated with screen projection.\nAlthough translation movements break it.\nThanks to munrocket for Quaternion code. :)", "tags": ["3d", "raymarching", "orchard", "cylindricalprojection"], "likes": 66, "viewed": 4584, "published": 3, "date": "1583276759", "time_retrieved": "2024-07-30T21:20:44.137804", "image_code": "// Orchard (Alternative Projection)\n// by Dave Hoskins. March 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This breaks the effect a little...\n//#define MOVE_CAMERA\n\n\nint spointer;\nvec3 sunLight;\n#define SUN_COLOUR vec3(1., .9, .8)\n#define FOG_COLOUR vec3(1., .7, .7)\n\nstruct Stack\n{\n    vec3 pos;\n    float alpha;\n    float dist;\n    int mat;\n\n};\n\n#define STACK_SIZE 8\nStack stack[STACK_SIZE];\n\n//==============================================================================\n//--------------------------------------------------------------------------\nfloat getGroundHeight(vec2 p)\n{\n    float y =(sin(p.y*.23)+cos(p.x*.18))*.8;\n    return y;\n}\n//--------------------------------------------------------------------------\nmat3 getCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//--------------------------------------------------------------------------\n// Loop the camposition around a uneven sine and cosine, and default the time 0\n// to be steep at a loop point by adding 140...\nvec3 getCamPos(float t)\n{\n    //t = sin(t*.01)*200.;\n    t+=140.;\n    vec3 p = vec3(3.0+50.0*sin(t*.03),\n                  1.5,\n                  4.0 + 50.0*cos(t*.044));\n    p.y-=getGroundHeight(p.xz);\n    return p;\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n//------------------------------------------------------------------------------\nfloat randomTint(vec3 pos)\n{\n    float r = texture(iChannel1, pos.xz*.0027).x;\n    return r+.5;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//------------------------------------------------------------------------------\nvec4 grassTexture(vec3 pos, vec3 nor)\n{\n    \n    float g = texture(iChannel1, pos.xz*.5).x;\n    float s = texture(iChannel1, pos.xz*.015).x*.2;\n    \n    \n    vec3 flower = texture(iChannel2, pos.xz*.15).xyz;\n    float rand = texture(iChannel1, pos.xz*.003).x;\n    rand *= rand*rand;\n    \n    flower =pow(flower,vec3(8, 15, 5)) *10. * rand;\n    vec4 mat = vec4(g*.05+s, g*.65, 0, g*.1);\n    mat.xyz += flower;\n\n    // Do the red ground lines...\n    pos = fract(pos);\n    mat = mix(mat, vec4(.2, 0,0,0), (smoothstep(.05, .0,min(pos.x, pos.z))\n              \t\t\t\t\t  + smoothstep(.95, 1.,max(pos.x, pos.z))) * clamp(sin(iTime), 0.0, 1.0));\n\n    \n\treturn min(mat, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec4 barkTexture(vec3 p, vec3 nor)\n{\n    vec2 r = floor(p.xz / 5.0) * 0.02;\n    float br = texture(iChannel1, r).x;\n\tvec3 mat = texCube(iChannel3, p*.4, nor) * vec3(.4, .3, .1*br) *br;\n    mat += texCube(iChannel3, p*.53, nor)*smoothstep(0.0,.3, mat.x)*br;\n   \treturn vec4(mat, .1);\n}\n\n//------------------------------------------------------------------------------\nvec4 leavesTexture(vec3 p, vec3 nor)\n{\n    \n    vec3 rand = texCube(iChannel2, p*.15,nor);\n\tvec3 mat = vec3(0.4,1.2,0) *rand;\n   \treturn vec4(mat, .0);\n}\n\n//------------------------------------------------------------------------------\nvec4 fruitTexture(vec3 p, vec3 nor, float i)\n{\n    \n    \n    float rand = texCube(iChannel2, p*.1 ,nor).x;\n    float t = dot(nor, normalize(vec3(.8, .1, .1)));\n\tvec3 mat = vec3(1.,abs(t)*rand,0);\n    mat = mix(vec3(0,1,0), mat, i/10.);\n\n   \treturn vec4(mat, .5);\n}\n\n\n\n//------------------------------------------------------------------------------\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h)\n{\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\n\n//------------------------------------------------------------------------------\nconst int   SEEDS = 8 ;\nconst float STEP_SIZE = 2.;\n#define SIZE .03\n\n\n// This seed code is the starfield stuff from iapafoto\n// I've just removed the alpha part...\n// https://www.shadertoy.com/view/Xl2BRR\nmat2 rotMat2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nvec3 floatingSeeds(in vec3 ro, in vec3 rd, in float tmax)\n{ \n \n    float d =  0.;\n    ro /= STEP_SIZE;\n\tvec3 pos = floor(ro),\n\t     ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + .5 + rs*0.5) * ri;\n\t\n    float dint;\n\tvec3 offset, id;\n    vec3 col = vec3(0);\n    vec3 sum = vec3(0);\n    //float size = .04;\n    \n\tfor( int i=0; i< SEEDS; i++ )\n    {\n        id = hash33(pos);\n\n        offset = clamp(id+.2*cos(id*iTime),SIZE, 1.-SIZE);\n        d = distanceRayPoint(ro, rd, pos+offset, dint);\n        \n        if (dint > 0. && dint * STEP_SIZE < tmax)\n        {\n            col = vec3(.4)*smoothstep(SIZE, 0.0,d);\n            sum += col;\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n  \n\treturn sum * .7;\n}\n\n//--------------------------------------------------------------------------\nfloat findClouds2D(in vec2 p)\n{\n\tfloat a = 1.5, r = 0.0;\n    p*= .000001;\n    for (int i = 0; i < 5; i++)\n    {\n        r+= texture(iChannel1,p*=2.2).x*a;\n        a*=.5;\n    }\n\treturn max(r-1.5, 0.0);\n}\n//------------------------------------------------------------------------------\n// Use the difference between two cloud densities to light clouds in the direction of the sun.\nvec4 getClouds(vec3 pos, vec3 dir)\n{\n    if (dir.y < 0.0) return vec4(0.0);\n    float d = (4000. / dir.y);\n    vec2 p = pos.xz+dir.xz*d;\n    float r = findClouds2D(p);\n    float t = findClouds2D(p+normalize(sunLight.xz)*30.);    \n    t = sqrt(max((r-t)*20., .2))*2.;\n    vec3 col = vec3(t) * SUN_COLOUR;\n    // returns colour and alpha...\n    return vec4(col, r);\n} \n\n\n//------------------------------------------------------------------------------\n// Thanks to Fizzer for the space-folded tree idea...\n/// https://www.shadertoy.com/view/4tVcWR\nvec2 map(vec3 p, float t)\n{\n \n    float matID, f;\n    p.y += getGroundHeight(p.xz);\n\tfloat num = (floor(p.z/5.))*5.+(floor(p.x/5.0))*19.;\n\tp.xz = mod(p.xz, 5.0)-2.5;\n    //p.xz *= rotMat2D(p.y*num/300.); // ... No, just too expensive. :)\n    \n    float d = p.y;\n    matID = 0.0;\n\n    float s=1.,ss=1.6;\n    \n    // Tangent vectors for the branch local coordinate system.\n    vec3 w=normalize(vec3(-1.5+abs(hash11(num*4.)*.8),1,-1.));\n    vec3 u=normalize(cross(w,vec3(0,1.,0.)));\n\n    float scale=3.5;\n    p/=scale;\n    vec3 q = p;\n    // Make the iterations lessen over distance for speed up...\n    int it = 10-int(min(t*.03, 9.0));\n\n\tfloat h  = hash11(num*7.)*.3+.3;\n    vec3 uwc = normalize(cross(u,w));\n    int dontFold = int(hash11(num*23.0) * 9.0)+3;\n    \n    float thick = .2/(h-.24);\n    for (int i = 0; i < it; i++)\n    {\n\t\tf = scale*max(p.y-h,max(-p.y,length(p.xz)-.06/(p.y+thick)))/s;\n        if (f <= d)\n        {\n            d = f;\n            matID = 1.0;\n        }\n\n        // Randomly don't fold the space to give more branch types...\n        if (i != dontFold)\n        \tp.xz = abs(p.xz);\n\n        p.y-=h;\n        p*=mat3(u,uwc,w);\n        p*=ss;\n\t\ts*=ss;\n    }\n\n    float fr = .2;\n    f = (length(p)-fr)/s;\n    if (f <= d)\n    {\n        d = f;\n        matID = 2.0;\n    }\n    \n    q.y -= h*1.84;\n    h *= 1.1;\n    for (int i = 0; i < it; i++)\n    {\n      \tp = (normalize(hash31(num+float(i+19))-.5))*vec3(h, 0.1, h);\n     \tp+=q;\n        float ds =length(p)-.015;\n     \tif (ds <= d)\n        {\n            matID = 3.0+float(i);\n         \td = ds;\n        }\n    }\n\n\treturn vec2(d, matID);\n}\n\n//------------------------------------------------------------------------------\nfloat sphereRadius(float t)\n{\n\tt = abs(t-.0);\n\tt *= 0.003;\n\treturn clamp(t, 1.0/iResolution.y, 3000.0/iResolution.y);\n}\n\n//------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd, float dis)\n{\n\tfloat res = 1.0;\n    float t = .1;\n\tfloat h;\n\t\n    for (int i = 0; i < 15; i++)\n\t{\n        vec3 p =  ro + rd*t;\n\n\t\th = map(p,dis).x;\n\t\tres = min(3.*h / t, res);\n\t\tt += h;\n\t}\n    res += t*t*.08; // Dim over distance\n    return clamp(res, .6, 1.0);\n}\n\n//-------------------------------------------------------------------------------------------\n// Taken almost straight from Inigo's shaders, thanks man!\n// But I've changed a few things like the for-loop is now a float,\n// which removes the need for the extra multiply and divide in GL2\nfloat calcOcc( in vec3 pos, in vec3 nor, float d )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(float h= 0.05; h < .3; h+= .07)\n    {\n\t\tvec3 opos = pos + h*nor;\n        float d = map( opos, d ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n//-------------------------------------------------------------------------------------------\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co)\n{\n\tfloat t = hash12(co)*.5;\n\tvec4 normal = vec4(0.0);\n\tvec3 p;\n    float alphaAcc = 0.0;\n\n    spointer = 0;\n\tfor( int j=min(0,iFrame); j < 140; j++ )\n\t{\n        // Check if it's full or too far...\n\t\tif (spointer == STACK_SIZE || alphaAcc >= 1.) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = sphereRadius(t);\n\t\tvec2 h = map(p, t);\n\t\tif( h.x <= sphereR)\n\t\t{\n            //h = max(h,0.0);\n            float alpha = (1.0 - alphaAcc) * min(((sphereR-h.x+.01) / sphereR), 1.0);\n\t\t\tstack[spointer].pos = p;\n            stack[spointer].alpha = alpha;\n            stack[spointer].dist = t;\n            stack[spointer].mat = int(h.y);\n            alphaAcc += alpha;\n\t        spointer++;\n        }\n\t\tt +=  h.x+t*0.007;\n\t}\n    return alphaAcc;\n}\t\n\n//-------------------------------------------------------------------------------------------\nvec3 lighting(in vec4 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n  \n\tfloat sh = shadow(pos+sunLight*.01,  sunLight, d);\n    float occ = calcOcc(pos, normal, d);\n    // Light surface with 'sun'...\n\tvec3 col = mat.xyz * SUN_COLOUR*(max(dot(sunLight,normal)*.5+.2, 0.0))*sh;\n    // Ambient...\n\t\n    float fre = clamp(1.0+dot(normal,eyeDir),0.0,1.0)*.3;\n    float bac = clamp(.8*dot( normal, normalize(vec3(-sunLight.x,0.0,-sunLight.z))), 0.0, 1.0 );\n    normal = reflect(eyeDir, normal); // Specular...\n\tcol += pow(max(dot(sunLight, normal), 0.0), 16.0)  * SUN_COLOUR * sh * mat.w * occ;\n    col += bac*mat.xyz * occ;\n    col += mat.xyz * abs(normal.y)*.3*occ;\n\tcol += SUN_COLOUR * fre *.2*occ;\n\n\treturn min(col, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec3 getNormal2(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), 0.).x - map(p-vec3(e,0.0,0.0), 0.).x,\n                            map(p+vec3(0.0,e,0.0), 0.).x - map(p-vec3(0.0,e,0.0), 0.).x,\n                            map(p+vec3(0.0,0.0,e), 0.).x - map(p-vec3(0.0,0.0,e), 0.).x));\n}\n\nvec3 getNormal(vec3 pos, float ds)\n{\n\n    float c = map(pos, 0.).x;\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 0.0).x, map(pos + eps_zero.yxy, 0.0).x,\n                          map(pos + eps_zero.yyx, 0.0).x) - c);\n}\n\n\n//------------------------------------------------------------------------------\nvec3 getSky(vec3 dir)\n{\n\tvec3 col = mix(vec3(FOG_COLOUR), vec3(.0, 0.4,0.6),(abs(dir.y)));\n    return col;\n}\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    phi *= 0.5;\n    return vec4(sin(phi) * normalize(axis), cos(phi));\n}\n\nvec3 rotate(vec3 point, vec4 rotor) {\n    vec3 rotv = rotor.xyz;\n    return qmult(rotor, vec4(point * rotor.w - cross(point, rotv), dot(point, rotv))).xyz;\n}\n\nvec4 slerp(vec3 u0, vec3 u1, float t) {\n    return qrotor(cross(u0, u1), t * acos(dot(u0, u1)));\n}\n// Thanks to DR2 for this matrix code...\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//==============================================================================\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    sunLight = normalize(vec3(-.8,1.8,-1.5));\n    \n    // Camera stuff...\n    // A simple cylindrical projection with normal Y\n    float time = iTime*1.+mouseXY.x*10.0;\n    \n    #ifdef MOVE_CAMERA\n\t\n    vec3 camera = getCamPos(time*.2);\n\tvec3 lookat = getCamPos(time*.2+10.);\n\n    #else\n    \n    // Don't move the camera bodge...\n    vec3 camera = getCamPos(0.0);\n\tvec3 lookat = getCamPos(0.0);\n    lookat += vec3(40.0*sin(time * 5.28), 0., 40.0*cos(time * .28) );\n\n    #endif\n    \n    float ride = sin(time*.5)*.4;\n    \n    \n    //mat3 camMat = getCamMat(camera, lookat, 0.0);\n    //uv *= .7;\n    // I didn't want to normalize here because it'll distort across the vertical slightly...\n    // But it looks like it's needed for a unit ray length...\n//\tvec3 seedDir = camMat * normalize(vec3(0.0, uv.y,  1.));\n//\tseedDir.xz = rot2D(seedDir.xz, uv.x*1.13); // Adjusted for rotation PI (roughly!) :)\n    \n\n    // Now using Quaternions, thanks to munrocket for the Quat code.\n    // https://www.shadertoy.com/view/3stXR2\n// Quarternion version..\n//    vec3 seedDir  = normalize(vec3(0,0, 1.));\n//    vec2 rotXY = vec2(uv.x+time*.5, -uv.y+ride);\n//    vec4 rotor = qrotor(vec3(0., 1., 0.), rotXY.x);\n//    rotor = qmult(rotor, qrotor(vec3(1., 0., 0.), rotXY.y));\n    //seedDir = rotate(seedDir, rotor);\n    \n    vec3 seedDir  = normalize(vec3(0,0, 1.));\n    seedDir = viewMat (uv.y+ride, uv.x+time*.5)*seedDir;\n  \n    \n\n\tvec3 rd = seedDir;\n\n\tvec3 col = vec3(0);\n\n\tvec3 sky  = getSky(rd);\n  \n\n    // Build the stack returning the final alpha value...\n    float alpha = marchScene(camera, rd, fragCoord);\n    vec4 mat;\n    // Render the stack...\n    if (alpha > .0)\n    {\n        for (int i = 0; i < spointer; i++)\n        {\n            vec3  pos = stack[i].pos; \n            float d = stack[i].dist;\n            \n            vec3 nor =  getNormal(pos, sphereRadius(d));\n            int matID = stack[i].mat;\n            if (matID == 0) mat =  grassTexture(pos, nor);\n            else\n\t\t\t\tif (matID == 1) mat = barkTexture(pos, nor);\n            else\n                if (matID == 2) mat = leavesTexture(pos, nor);\n            else\n                mat = fruitTexture(pos, nor, float(matID - 3));\n\n            mat *= randomTint(pos);\n \n            vec3  temp = lighting(mat, pos, nor, rd, d);\n            if (matID == 3) temp=temp*.4+vec3(.15, .01,0);\n            \n            temp = mix(sky, temp , exp(-d*.01));\n            col += temp * stack[i].alpha;\n        }\n    }\n    vec4 cc = getClouds(camera, rd);\n    sky+= pow(max(dot(sunLight, rd), 0.0), 20.0)*SUN_COLOUR*.03;\n    //sky = clamp(sky, 0.0,1.);\n\tsky = mix(sky, cc.xyz, cc.w);\n\tcol += sky *  (1.0-alpha);\n    \n    float d = stack[0].dist;\n    col+= floatingSeeds(camera, rd, d);\n    \n   \n    // Sun glow effect...\n    col+=pow(max(dot(sunLight, rd), 0.0), 6.0)*SUN_COLOUR*.2;\n    \n    // Clamp and contrast...\n    //col = col * vec3(1.1, 1.1,.9);\n    col = clamp(col,0.,1.);\n    col = col*col*(3.0-2.0*col);\n\n    \n    // The usual vignette...which manages to add more vibrancy...\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.3 + 0.7*pow(90.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.5);\n\t// A nice fade in start...\n    \n    \n    col *= smoothstep(0.0, 5.0, time);\n    fragColour = vec4(sqrt(col), 1.0);\n    \n}\n\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVSz3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[446, 604, 635, 635, 696], [697, 774, 826, 826, 1003], [1005, 1210, 1235, 1262, 1428], [1430, 1540, 1563, 1563, 1648], [1649, 1759, 1781, 1781, 1898], [1900, 1919, 1941, 1941, 2074], [2076, 2095, 2117, 2117, 2241], [2244, 2325, 2353, 2353, 2422], [2424, 2515, 2567, 2567, 2748], [2750, 2831, 2870, 2870, 3496], [3498, 3579, 3615, 3615, 3863], [3865, 3946, 3984, 3984, 4099], [4101, 4182, 4228, 4228, 4446], [4450, 4531, 4594, 4594, 4648], [4802, 4937, 4961, 4961, 5034], [5036, 5036, 5095, 5095, 5816], [5818, 5895, 5926, 5926, 6097], [6098, 6274, 6310, 6310, 6639], [6643, 6820, 6847, 6847, 8422], [8424, 8505, 8534, 8534, 8624], [8626, 8707, 8757, 8757, 9007], [9009, 9296, 9348, 9348, 9596], [9598, 9692, 9743, 9743, 10471], [10474, 10568, 10653, 10653, 11306], [11308, 11389, 11423, 11423, 11694], [11696, 11696, 11732, 11732, 12009], [12012, 12093, 12116, 12116, 12201], [12203, 12203, 12238, 12238, 12288], [12309, 12309, 12337, 12337, 12451], [12453, 12453, 12488, 12488, 12561], [12563, 12563, 12600, 12600, 12720], [12722, 12722, 12761, 12761, 12820], [12821, 12862, 12897, 12897, 13095], [13097, 13178, 13236, 13236, 16611]], "test": "untested"}
{"id": "WlVSz3", "name": "Raindrops on a puddle", "author": "4rknova", "description": "A simple water ripple effect.", "tags": ["interactive", "water", "ripple"], "likes": 18, "viewed": 1348, "published": 3, "date": "1583273324", "time_retrieved": "2024-07-30T21:20:44.903757", "image_code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPSILON\t\t\t\t.25\n#define PI\t\t\t\t\t3.14159265359\n#define RADIAN\t\t\t\t180.0 / PI\n#define SIZE                (42.)\n#define RMARCH_MAX_STEPS \t25\n\nfloat des_sphere(vec3 p, float r) { return length(p) - r; }\nfloat deu_box\t(vec3 p, vec3  b) { return length(max(abs(p)-b,0.0)); }\nvec3  translate (vec3 v, vec3  t) { return v - t; }\n\nconst float cCamera_fov = 60.0;\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\t\nvoid generate_ray(vec2 uv, Camera c, out Ray r)\n{\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(cCamera_fov * 0.5 * RADIAN)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\t\n\tr.d = normalize(tmat * r.d);\n}\n\nfloat scene_distance(vec3 p)\n{\n    vec2 uv = 0.5*(p.xz/SIZE+1.);\n\tvec3 res = texture(iChannel0, uv).xyz;\n    float d = dot(res, vec3(0,1,0));\n\treturn deu_box(p + vec3(0,d,0), vec3(SIZE,5,SIZE));\n}\n\nvec3 scene_normal(vec3 pos, float d)\n{\n    vec3 n;\n\t\n\t// Gradient via Forward differencing\n    n.x = scene_distance(vec3(pos.x + EPSILON, pos.y, pos.z));\n    n.y = scene_distance(vec3(pos.x, pos.y + EPSILON, pos.z));\n    n.z = scene_distance(vec3(pos.x, pos.y, pos.z + EPSILON));\n\t\n    return normalize(n - d);\n}\n\nvec3 scene_shade(vec3 v, vec3 p, vec3 n)\n{\n    vec3 col = vec3(0.5, 0.7, 0.9);\n    \n    vec3 d = texture(iChannel1, reflect(v, n)).xyz;\n    col *= vec3(d);\n    \n    return col;\n}\n\nbool rmarch(Ray r, out vec3 p, out vec3 n, out int iter)\n{\n\tp = r.o;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < RMARCH_MAX_STEPS; i++) {\n\t\titer = i;\n\n\t\td = scene_distance(pos);\n\n\t\tif (d < EPSILON) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpos += d * r.d;\n\t}\n\t\n\tn = scene_normal(p, d);\t\n\treturn d < EPSILON;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 nv = (fragCoord.xy / iResolution.xy);\t\n    \n    \n    vec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n        * vec2(iResolution.x / iResolution.y, 1);\t\n\n    Camera c;\n    c.p = vec3(20, 18, 14);\n    c.t = vec3(-6, -4, 10);\n    c.u = vec3(0, 1, 0); \n   \n\n    Ray r;\n    generate_ray(uv, c, r);\n\n    vec3 col = texture(iChannel1, normalize(r.d)).xyz;    \n    \n    vec3 sp, sn;\n    int iter = RMARCH_MAX_STEPS;\t\n    bool res = rmarch(r, sp, sn, iter);\n\n\n    if (res) {\n        col = scene_shade(r.d, sp, sn);    \n    }\n\n \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define STRENGTH     (3.50)\n#define MODIFIER     (0.99)\n#define STEP         (2.50)\n\n#define S(e) (texture(iChannel0, p+e).x) // Sample\n\nvec3 getPos()\n{\n  \tfloat t = iTime*4.0;\n    vec2  s = fract(floor(t)*vec2(0.456665,0.708618))*iResolution.xy;\n    return vec3(s, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = 0.;\n    vec2  p = gl_FragCoord.xy / iResolution.xy;\n    vec4  c = texture(iChannel0, p);\n   \tvec3  e = vec3(vec2(STEP)/iResolution.xy,0.);\n   \tfloat s0 = c.y, s1 = S(-e.zy)\n        , s2 = S(-e.xz)\n        , s3 = S(e.xz)\n        , s4 = S(e.zy);\n\n   \tvec3 pos = getPos();\n \tif (pos.z > 0.5) d = STRENGTH * smoothstep(3.,0.5,length(pos.xy - gl_FragCoord.xy));\n\n   \t// Calculate new state\n   \td += -(s0 - .5) * 2. + (s1 + s2 + s3 + s4 - 2.);\n   \td *= MODIFIER;\n    d *= smoothstep(0.,1.,float(iFrame >= 60)); // Clean buffer at startup\n    d = d * 0.5 + 0.5;\n \tfragColor = vec4(d, c.x, 0, 0); // Save current and previous state    \n}\n   ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVSz3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[266, 266, 301, 301, 325], [326, 326, 359, 359, 395], [396, 396, 431, 431, 447], [545, 545, 594, 594, 932], [934, 934, 964, 964, 1130], [1132, 1132, 1170, 1170, 1444], [1446, 1446, 1488, 1488, 1624], [1626, 1626, 1684, 1684, 1934], [1936, 1936, 1991, 1991, 2554]], "test": "untested"}
{"id": "tlVXR3", "name": "Fractal Blizzard", "author": "jarble", "description": "Another edit of my fire shader.\n\nMove the mouse to zoom in and out!", "tags": ["fractal", "snow", "blizzard", "snowstorm"], "likes": 4, "viewed": 362, "published": 3, "date": "1583272087", "time_retrieved": "2024-07-30T21:20:45.671703", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 8.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 7.0;\nconst float SNOW = 2.0;\nconst float YELLOW = 9.0;\nconst float RED = 5.0;\nconst float WHITE = 6.0;\nconst float PALE_GREEN = 1.0;\nconst float BLACK = 8.0;\nconst float GRAY = 3.0;\nconst float ORANGE = 10.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        && magnify(fragCoord+vec2(1,0),mag) == color\n        && magnify(fragCoord-vec2(0,1),mag) == color\n        && magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\tfloat offset = iTime*20.0;\n    return magnify(fragCoord+vec2(offset,1),mag) == color\n        || magnify(fragCoord+vec2(1,offset),mag) == color\n        || magnify(fragCoord-vec2(offset,1),mag) == color\n        || magnify(fragCoord-vec2(1,-offset*10.0),mag) == color;\n}\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == SNOW){\n    \treturn vec3(255, 250, 250)/255.0;\n    }\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == BLACK){\n    \treturn vec3(0.0,0.0,0.0);\n   \t}\n    else if(color == PALE_GREEN){\n    \treturn vec3(152,251,152)/255.0;\n    }\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n    while(mag1 < mag){\n    bool modified = true;\n    if(color1 == GREEN && is_next_to(fragCoord,mag1,PALE_GREEN)){\n    \tcolor1 = PALE_GREEN;\n    }\n    else if(color1 == PALE_GREEN && is_next_to(fragCoord,mag1,SNOW)){\n        if(mag1 > 5.0){\n        \tcolor1 = SNOW;\n        }\n        else{\n        \tcolor1 = SNOW;\n        }\n    }\n    else if(color1 == SNOW && is_next_to(fragCoord,mag1,GREEN)){\n        color1 = GREEN;\n    }\n    else if(color1 == SNOW && is_next_to(fragCoord,mag1,PALE_GREEN) && is_next_to(fragCoord,mag1,SNOW)){\n        color1 = WHITE;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x) + iTime*2.0*vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 384, 406, 406, 630], [633, 633, 673, 673, 722], [724, 724, 776, 776, 819], [820, 820, 880, 880, 1092], [1094, 1094, 1148, 1148, 1417], [1420, 1420, 1448, 1448, 2150], [2152, 2152, 2211, 2211, 2841], [2843, 2843, 2900, 2900, 3240]], "test": "untested"}
{"id": "ttVXR3", "name": "Mobius illusion", "author": "jeyko", "description": "From this video https://youtu.be/2SzmkCseDi0?t=337", "tags": ["mobius", "illusion", "trick"], "likes": 8, "viewed": 388, "published": 3, "date": "1583270848", "time_retrieved": "2024-07-30T21:20:46.439650", "image_code": "\n// From this video https://youtu.be/2SzmkCseDi0?t=337\n\nfloat tau = 6.28;\n\nfloat doPatt(vec2 uv){\n\t\n    vec2 uvp = vec2(atan(uv.y, uv.x)/tau, length(uv));\n    \n    float uvpb = mod(uvp.x*80.,1.) - 0.5;\n\n    uvpb *= length(uvp.y)*4.;\n    \n    return smoothstep(0.2,0.01, abs(uvpb) - 0.2 + - sin(iMouse.x/iResolution.x)*0.2 )*(smoothstep(0.,1.,length(uv)*2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1);\n\n    \n    \n    col -= doPatt(uv);\n    col -= doPatt(uv + vec2(0.04 + sin(iTime)*0.04, 0.04 + sin(iTime)*0.04));\n    col -= doPatt(uv + vec2(-0.05, 0.1));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 97, 97, 360], [362, 362, 419, 419, 703]], "test": "untested"}
{"id": "3lVXz3", "name": "N-body gravity simulation", "author": "olli666", "description": "Gravity simulator based on simulating mass body trajectories in 4D according to gravity law. Bodies gradually escape from the system over time as is inevitable for systems with more than 2 bodies.\n\nBackground illustrates 2D gravity force field.", "tags": ["simulation", "physics", "gravity"], "likes": 20, "viewed": 821, "published": 3, "date": "1583269455", "time_retrieved": "2024-07-30T21:20:47.202610", "image_code": "// Gravity simulator. Written by Olli Parviainen\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\n// mainImage() renders the image using trajectory data from iChannel0\n// a.k.a Buffer A that calculates body trajectories according to gravity law\n//\n// data stored to texels, one body per x-coordinate\n// - coord y=0 : body XYZ + size data\n// - coord y=1 : body velocity XYZ data\n\n\nconst int BODIES = 50;\t// note: if change number of bodies, update it also to Buffer A page\n\nconst float PI = 3.1415926536;\nconst float PI2 = 2.0 * PI;\nconst float MINVAL = -1000.0;\n\nconst vec3 AMBIENT_LIGHT = 0.4 * normalize(vec3(0.5, -0.5, -1.0));\n\nconst vec4 SUN_COLOR = vec4(1,1,0,0);\n\n\nvec4 getBodyPosSize(in int bodyNum)\n{\n    return texelFetch(iChannel0, ivec2(bodyNum, 0), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/min(iResolution.x, iResolution.y) - vec2(iResolution.x/iResolution.y, 1.0);\n    float grid = iResolution.y / 25.0;\n\n    float min_z = MINVAL;\n    vec2 force = vec2(0.0);\n\n    vec4 body0 = getBodyPosSize(0);\n    // render bodies\n    for (int i = 0; i < BODIES; i ++) {\n        // scale body coords&size according to z\n        // To do: \n        // - could recalculate \"scale\" or \"bodyScaled\" already in Buffer A\n        //   as they're now recalculated here in every pixel \n        vec4 body = getBodyPosSize(i);\n        float scale = 1.0 / (1.0 - body.z);\n        if (scale < 0.0) \n\t        // behind camera\n            continue;\n\n        vec4 bodyScaled = scale * body;\n\n        // calculate body visual radius \n        vec2 diff = bodyScaled.xy - uv;\n        float R = dot(diff,diff);\n        force += scale * pow(body.w,3.0) * diff / R;        \n        float radius2 = bodyScaled.w * bodyScaled.w;\n\n        if (R < radius2) {\n            // calculate z-coordinate of the surface\n            float z = sqrt(radius2 - R);       \n            if (body.z + z < min_z)\n                // surface point is behind what's already rendered\n                continue;\n            min_z = body.z + z;\n\n            // draw body\n            if (i == 0) {\n                // central body\n\t            float lum = (1.0 - R / radius2);\n                fragColor = vec4(lum) + 0.5 * SUN_COLOR;\n            } \n            else \n            {\n                // other bodies: choose color\n                vec3 angle = vec3(i) + vec3(0.0, 0.3333, 0.6666) * PI2;            \n                vec3 color=0.5+0.5*cos(angle);\n                fragColor = vec4(color, 1);\n\n                // diffuse surface lighting from central body + ambient\n                vec3 surface = vec3(diff, -z);\n                vec3 surface_norm = normalize(surface);\n                vec3 bodySurface = body.xyz - surface;\n                vec3 vecToBody0 = bodySurface - body0.xyz;\n                float distToBody0 = clamp(length(vecToBody0) - body0.w, 1e-4,1e4);\n                float intensity = dot(surface_norm, normalize(vecToBody0)) / distToBody0;\n                intensity = 0.5 * clamp(0.2 + intensity, 0.0, 2.0);\n\n                // direct reflection from central body\n                vec3 vreflect = normalize(reflect(vec3(0,0,1), surface_norm));\n                float reflectCrossBody0 = length(vreflect * length(vecToBody0) - vecToBody0);\n                if (reflectCrossBody0 < body0.w) {\n                    intensity += 0.2 / reflectCrossBody0;\n                }\n                \n                fragColor *= dot(surface_norm, AMBIENT_LIGHT) + \n                    intensity;\n            }\n        }\n    }\n    if (min_z == MINVAL) \n    {\n        // render background grid. The force field used to distort background\n        // is not physically quite accurate, yet squared field in 2D looks\n        // nicer than true grabity field\n        vec2 coord = fragCoord - 2e2 * force.xy * grid;\n        coord = mod(coord, grid);\n        float color = 0.0;\n        \n        if (coord.x < 2.0) {\n            color += (coord.x > 1.0) ? 2.0 - coord.x : coord.x;\n        }\n        if (coord.y < 2.0) {\n            color += (coord.y > 1.0) ? 2.0 - coord.y : coord.y;\n        }\n        \n        fragColor=vec4(0.8*sqrt(color));\n        // to display 2D gravity field\n        // fragColor += clamp((round(sqrt(dot(force, force))*2e3)-3.0) * 0.05, 0.0, 0.6);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Gravity simulator. Written by Olli Parviainen\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\n// The Buffer A calculates body trajectories according to gravity physics.\n//\n// data stored to texels, one body per x-coordinate\n// - coord y=0 : body XYZ + Size data\n// - coord y=1 : body velocity XYZ data\n\nconst int BODIES = 50; // note: if change number of bodies, update it also to Buffer A page\n\nconst float GRAVITY_COEFF = 1000.0;\nconst float UPDATE_STEP = 0.005;\nconst float PI = 3.1415926536;\n\nvec4 getBodyPosSize(in int bodyNum)\n{\n    return texelFetch(iChannel0, ivec2(bodyNum, 0), 0);\n}\n\n\nvoid getBodyPosVel(in int bodyNum, out vec4 XYZW, out vec3 velXYZ)\n{\n    XYZW = texelFetch(iChannel0, ivec2(bodyNum, 0), 0);\n    velXYZ = texelFetch(iChannel0, ivec2(bodyNum, 1), 0).xyz;\n}\n    \n\n// initialize data\nvoid init(in int body, out vec4 XYZW, out vec3 velXYZ) \n{    \n    vec4 times = vec4(iTime) + vec4(body, float(body) + 0.5 * PI, 4*body, 15*body);\n        \n    XYZW = (cos(times) + vec4(0,0,0,1.5)) * vec4(0.5, 0.5, 0.05, 0.02);\n    velXYZ = 1.4*sin(times.xyz);\n    if (body == 0) {\n        XYZW = vec4(0.0,0.0,0.0,0.1);\n        velXYZ = vec3(0);\n    }\n}\n\n// calculate acceleration due to gravity\nvec3 calculate_gravity_accel(in int curBodyNum, in vec4 bodyXYZW, float dTimeAdvance)\n{\n    vec3 accelVec = vec3(0.0);\n    float bodySize = bodyXYZW.w;\n        \n    for (int i = 0; i < BODIES; i ++) {\n        if (i == curBodyNum) continue;\n        vec4 otherXYZW;\n        vec3 otherVelXYZ;\n        getBodyPosVel(i, otherXYZW, otherVelXYZ);\n        \n        otherXYZW += dTimeAdvance * vec4(otherVelXYZ.xyz, 0);\n        \n        vec3 diff = otherXYZW.xyz - bodyXYZW.xyz;\n        float R = sqrt(dot(diff, diff));\n        float otherSize = pow(otherXYZW.w, 3.0);\n        float accel = otherSize / R; \n        \n        accelVec += normalize(diff) * accel;\n    }\n    return GRAVITY_COEFF * accelVec;\n}\n\n\n// euler: simplest trajectory update method\nvoid update_trajectory_euler(in int body, out vec4 XYZW, out vec3 velXYZ)\n{\n    vec4 bodyXYZW;\n    vec3 bodyVelXyz;\n    getBodyPosVel(body, bodyXYZW, bodyVelXyz);\n    \n    vec3 accelVec = calculate_gravity_accel(body, bodyXYZW, 0.0);\n    \n    velXYZ = bodyVelXyz + UPDATE_STEP * accelVec;\n    XYZW = bodyXYZW + UPDATE_STEP * 0.5 * vec4(bodyVelXyz + velXYZ.xyz, 0.0);\n}\n\n\n// heun: two-stage trajectory update method, better than euler\nvoid update_trajectory_heun(in int body, out vec4 XYZW, out vec3 velXYZ)\n{\n    vec4 bodyXYZW;\n    vec3 bodyVelXyz;\n    getBodyPosVel(body, bodyXYZW, bodyVelXyz);\n    \n    // step 1\n    vec3 accelVec1 = calculate_gravity_accel(body, bodyXYZW, 0.0);       \n    vec3 velXYZ1 = bodyVelXyz + UPDATE_STEP * accelVec1;\n    XYZW = bodyXYZW + UPDATE_STEP * 0.5 * vec4(bodyVelXyz + velXYZ1, 0);\n\n    // step 2\n    vec3 accelVec2 = calculate_gravity_accel(body, XYZW, UPDATE_STEP);    \n    vec3 accelVec_mid = 0.5 * (accelVec1 + accelVec2);\n    \n    velXYZ = bodyVelXyz + UPDATE_STEP * accelVec_mid;       \n    XYZW = bodyXYZW + UPDATE_STEP * 0.5 * vec4(bodyVelXyz + velXYZ, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 XYZW;\n    vec3 velXYZ;\n    ivec2 xy = ivec2(floor(fragCoord));\n\n    if ((xy.y > 1) || (xy.x > BODIES))\n        // nothing to do, release GPU early for other work\n        return;\n    \n    int bodyNum = xy.x;\n    \n    if (iFrame == 0) {\n        // initialize data\n        init(bodyNum, XYZW, velXYZ);\n    } else {\n        // update trajectory\n        update_trajectory_heun(bodyNum, XYZW, velXYZ);\n        \n        if (bodyNum == 0) {\n            // weakly pull the body #0 towards centre to keep the system centralized on display\n            // while minimizing impact to overall system\n            vec3 diff = vec3(0.0) - XYZW.xyz;\n            velXYZ = mix(velXYZ, diff, 0.02);\n        }\n    }\n    \n    // store data to output texels\n    if (xy.y == 0) {\n\t    fragColor = XYZW;\n    } else {\n\t    fragColor = vec4(velXYZ, 0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVXz3.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[709, 709, 746, 746, 804], [806, 806, 863, 863, 4314]], "test": "untested"}
{"id": "WtVXRc", "name": "log tiling inf zoom ( 190 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["2tweets", "gif", "short", "log", "golf"], "likes": 6, "viewed": 276, "published": 3, "date": "1583267801", "time_retrieved": "2024-07-30T21:20:48.085250", "image_code": "// --- expended version at the end :-)\n\n// -2 by Coyote\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  t = exp2(fract(-.3*iTime)) +u-u,\n          R = iResolution.xy,\n          U = t - t* ( u - R*vec2(.25,0) ) / R.y,\n          l = exp2( floor( log2( min(U,U.yx) )) );\n    O += 1.- ( R*l/t*.6 *   ( .1 - min( U = abs( abs( U/l - 1.5 ) - .5),U.x) ) ).y;\n} /*\n\n\n\n\n\n\n// --- 192 chars\n\n#define mainImage(O,u)                                   \\\n    vec2  t = exp2(fract(-.3*iTime)) +u-u,               \\\n          R = iResolution.xy,                            \\\n          U = t - t* ( u - R*vec2(.25,0) ) / R.y,        \\\n          l = exp2( floor( log2( min(U,U.yx) )) );       \\\n    U = abs( abs( U/l - 1.5 ) - .5),                     \\\n/ * O += 1.- R.y/32.    *abs( .1 - min(U.x,U.y) )   * /  \\\n/ * O += 1.- R.y*l/t*.6 *abs( .1 - min(U.x,U.y) )   * /  \\\n    O += 1.- ( R*l/t*.6 *   ( .1 - min(U,U.x) ) ).y /*\n\n\n\n\n\n\n// --- 210 chars\n// ( NB: #define m min(U.x,U.y) = same size )\n\n#define mainImage(O,u)                                      \\\n    float t = exp2(fract(-.3*iTime)), l;                    \\\n    vec2  R = iResolution.xy,                               \\\n          U = t* ( 1.- ( u - vec2(R.x/4.,0) ) / R.y );      \\\n    U.x > 0. ?                                              \\\n        l = exp2( floor( log2( min(U.x,U.y) )) ),           \\\n        U = abs( abs( U/l - 1.5 ) - .5),                    \\\n    / * O += 1.- R.y/32.    *abs( .1 - min(U.x,U.y) )   * / \\\n    / * O += 1.- R.y*l/t*.6 *abs( .1 - min(U.x,U.y) )   * / \\\n        O += 1.- R.y*l/t*.6 *   ( .1 - min(U.x,U.y) )       \\\n    :O /*\n\n\n\n\n\n\n// --- 219 chars\n\n#define mainImage(O,u)                                      \\\n    vec2  R = iResolution.xy, L,                            \\\n          U = 1.- ( u - vec2(R.x/4.,0) ) / R.y;             \\\n    float t = exp2(fract(-.3*iTime)), l;                    \\\n    if ( U.x > 0. )                                         \\\n        L = floor( log2( U *= t ) ),                        \\\n        l = exp2(min(L.x,L.y)),                             \\\n        U = abs( 2.* abs( U/l - 1.5 ) - 1.),                \\\n    / * O += 1.- R.y/32.    *abs( .2 - min(U.x,U.y) )   * / \\\n    / * O += 1.- R.y*l/t/3. *abs( .2 - min(U.x,U.y) )   * / \\\n        O += 1.- R.y*l/t/3. *   ( .2 - min(U.x,U.y) )  /*\n\n\n\n\n\n\n// --- 236 chars\n\n#define mainImage(O,u)                                         \\\n    vec2 R = iResolution.xy, L,                                \\\n         U = 1.- ( u - vec2(R.x/4.,0) ) / R.y;                 \\\n    float t = fract(-.3*iTime), l;                             \\\n    if ( U.x > 0. )                                            \\\n        U = log2( U * exp2(t) ),                               \\\n        L = floor(U),                                          \\\n        l = min(L.x,L.y),                                      \\\n        U = abs( 2.*abs(exp2(U - l) - 1.5) - 1.),              \\\n    / * O += max(0., 1.- R.y/32.          *abs( min(U.x,U.y) -.2) )  * / \\\n    / * O += max(0., 1.- R.y/exp2(1.-l+t) *abs( min(U.x,U.y) -.2) )  * / \\\n        O += max(0., 1.- R.y/exp2(1.-l+t) *( .2 - min(U.x,U.y) ))   /*\n\n\n\n\n\n\n// --- 286 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, L,F,\n         U = 1.- (u-.25*vec2(R.x,0)) / R.y;\n    if ( U.x < 0. ) { O-=O; return; };\n\n    float t = fract(-.3*iTime), l;\n    U = log2(U*exp2(t));\n    L = floor(U);\n    l = min(L.x,L.y);\n    F = exp2(U - l) - 1.;\n    F = abs( 2.*abs(F-.5) - 1.);\n          \n // O = vec4( max(0., 1. -R.y/32.               *abs(min(F.x,F.y)-.2)) );\n    O = vec4( max(0., 1. -R.y/exp2(abs(l)+1.+t) *abs(min(F.x,F.y)-.2)) );  // framed\n // O = vec4( max(0., 1.- R.y/exp2(abs(l)+1.+t) *(.2- min(U.x,U.y))) );    // filled\n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 93, 93, 353]], "test": "untested"}
{"id": "ttKSR3", "name": "mud planet - cubemapped", "author": "flockaroo", "description": "cubemap version of mudplanet [url]https://www.shadertoy.com/view/4sXfDX[/url]\n", "tags": ["fluid", "cubemap", "cfd", "singlepass"], "likes": 16, "viewed": 624, "published": 3, "date": "1583265018", "time_retrieved": "2024-07-30T21:20:48.860179", "image_code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// mud planet\n// single pass CFD on spherical symetry\n// based on \"spilled\" (https://www.shadertoy.com/view/MsGSRd)\n\n// uncomment this for metallic reflections\n//#define METAL_REFLECTIONS\n\n#define MAX_RADIUS 400.\n#define PI 3.14159265359\n\n#define USE_CUBE\n\n#ifndef USE_CUBE\nvec2 sph2frag(vec3 p)\n{\n\tfloat r = min(iResolution.x/4.,MAX_RADIUS);\n    vec2 center = vec2(r,r);\n    p=normalize(p);\n    if(p.z<0.0) center.x += 2.*r;\n    return center+sqrt(1.-abs(p.z))*normalize(p.xy)*r;\n}\n#endif\n\n// final distance funtion\nfloat dist(vec3 pos)\n{\n    vec3 pos0=pos;\n    #ifdef USE_CUBE\n    pos+=(texture(iChannel0,pos).xyz-.5)*.75;\n    #else\n    pos+=(texture(iChannel0,sph2frag(pos)/iResolution.xy).xyz-.5)*.75;\n    #endif\n    float d = 10000.;\n    \n    // sphere in the middle\n\td=min(d,length(pos)-1.);\n        \n    return d;\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, vec3 dir)\n{\n    // cull the sphere\n    if(length(pos-dir*dot(dir,pos))>1.3) \n    \treturn vec4(0,0,1,1);\n    \n    float eps=0.001;\n    float bg=1.0;\n    for(int cnt=0;cnt<100;cnt++)\n    {\n        float d = dist(pos);\n        pos+=d*dir*.7;\n        if(d<eps) { bg=0.0; break; }\n    }\n    vec3 n = getGrad(pos,.001);\n    if(dot(n,n)<.0001) n=vec3(0,0,1);\n    return vec4(n,bg); // .w=1 => background\n}\n\nmat3 rotX(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(1,0,0, 0,c,s, 0,-s,c);\n}\n\nmat3 rotZ(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(c,s,0, -s,c,0, 0,0,1);\n}\n\nvec3 getSun()\n{\n    float phi=.2*iTime;\n    float phi2=.7*cos(phi);\n    vec3 sun=vec3(vec2(cos(phi),sin(phi))*cos(phi2),sin(phi2));\n    return sun;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    vec3 pos = vec3(0,-13.5,0);\n    // pixel view direction\n    vec3 dir = normalize(8.*normalize(-pos)+vec3(sc.x,0,sc.y*iResolution.y/iResolution.x));\n    // rotate view around x,z\n    float phi = iMouse.x/iResolution.x*7.;\n    float th  = iMouse.y/iResolution.y*7.;\n    if (iMouse.x==0.) { phi=iTime*.5; th=.27*.5*iTime; }\n    mat3 rx = rotX(th);\n    mat3 rz = rotZ(phi);\n    pos = rz*(rx*pos);\n    dir = rz*(rx*dir);\n    vec3 eye = pos;\n    \n    vec3 sun = getSun();\n    \n    // march it...\n   \tvec4 n=march(pos,dir);\n    float bg=n.w;\n\n    // march the shadow\n    vec3 poss=pos+sun*.01;\n   \tvec4 n2=march(poss,sun);\n    float shadow = n2.w;\n    \n    // calc some ambient occlusion\n    float ao=1.;\n    // calc ao by stepping along normal\n    ao*=dist(pos+normalize(getGrad(pos,.1))*.1)/.1;\n    // adjust contrast of ao\n    //ao=pow(ao,.4);\n    \n    // reflection dir\n    vec3 R = pos-2.0*dot(pos,n.xyz)*n.xyz;\n    R = -((R*rz)*rx).yzx;\n    \n    vec3 c = vec3(1);\n    \n    float diff=clamp(clamp(dot(sun,n.xyz)*2.,0.,1.)*shadow+.3,0.,1.5);\n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c += normalize(n.xyz)*.1+.1;\n\n    //c *= 1.*length((texture(iChannel0,sph2frag(pos)/iResolution.xy).xyz-.5)*2.+.5);\n    //c *= (texture(iChannel0,sph2frag(pos)/iResolution.xy).xyz-.5)*.3+.5;\n    c*=.8;\n    \n    //  reflection of cubemap\n    float fres = 1.-(dot(normalize(eye-pos),n.xyz));\n    fres=.1+.9*fres;\n    #ifdef METAL_REFLECTIONS\n    c *= texture(iChannel1,R).xyz/**1.2*fres*/;\n    #else\n    //c += texture(iChannel1,R).xyz*fres;\n    #endif\n    \n    // specular from sun\n    c += clamp(pow(max(0.,dot(R,sun)),.5)*fres,0.,1.);\n    \n    // apply background\n    if(bg>.5) { diff=0.0; ao=1.; }\n    float sdot=clamp(dot(sun,dir),0.,1.);\n    c=mix(c,vec3(.03,.13,.28),1.-diff);\n    \n    // apply ambient occlusion\n    c*=ao;\n    \n    // draw sun\n    float sunmix=(pow(sdot,600.)*2.+.3*sdot);\n    c=c*(.8-2.*sunmix)+vec3(1)*bg*sunmix;\n        \n    // vignetting\n    float vign = (1.06-.3*length(sc.xy));\n    \n\tfragColor = vec4(c*vign,1);\n    //fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// mud planet\n// single pass CFD on spherical symetry\n// based on \"spilled\" (https://www.shadertoy.com/view/MsGSRd)\n\n#define MAX_RADIUS 400.\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nconst mat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nconst mat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\n#define USE_CUBE\n\n#ifndef USE_CUBE\nvec2 sph2frag(vec3 p)\n{\n    //p=p.zxy;\n\tfloat r = min(iResolution.x/4.,MAX_RADIUS);\n    vec2 center = vec2(r,r);\n    p=normalize(p);\n    if(p.z<0.0) center.x += 2.*r;\n    return center+sqrt(1.-abs(p.z))*normalize(p.xy)*r;\n}\n\nvec3 frag2sph(vec2 f)\n{\n\tfloat r = min(iResolution.x/4.,MAX_RADIUS);\n    vec2 center = vec2(r,r);\n    float sz=1.;\n    if(f.x>2.*r)  { center.x += 2.*r; sz=-1.; }\n    vec2 R = (f-center)/r/sqrt(2.);\n    if(dot(R,R)>.55) return vec3(100);\n    //R/=sqrt(2.);\n    vec3 n = vec3(R.xy,sqrt(1.-dot(R,R))*sz);\n    vec3 p = reflect(vec3(0,0,-1.*sz),n);\n    //p=p.yzx;\n    return p;\n}\n\nvec3 frag2sphDiff(vec2 p, vec2 dp)\n{\n    float eps=.001;\n    return (frag2sph(p+normalize(dp)*eps)-frag2sph(p))/eps*length(dp);\n}\n#endif\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvec3 rotAx(vec3 p, vec3 ang)\n{\n\treturn transformVecByQuat( p, rotateQuatbyAngle(vec4(0,0,0,1), ang) );\n}\n\nvec3 getRot(vec3 pos, vec3 b)\n{\n    vec3 n=normalize(pos);\n    vec3 p = normalize(b-dot(b,n)*n);\n    vec3 rot=vec3(0);\n    for(int i=0;i<RotNum;i++)\n    {\n\t\t#ifdef USE_CUBE\n        vec3 v = texture(iChannel0,pos+p).xyz-.5;\n        #else\n        vec2 fr = sph2frag(pos+p);\n        vec3 v = texture(iChannel0,fr/Res.xy).xyz-.5;\n        #endif\n        //vec3 v = frag2sphDiff(fr,v2d);\n        rot+=cross(v,p);\n        p = rotAx(p,n*ang);\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvec3 getSun()\n{\n    float phi=.2*iTime;\n    float phi2=.7*cos(phi);\n    vec3 sun=vec3(vec2(cos(phi),sin(phi))*cos(phi2),sin(phi2));\n    return sun;\n}\n\n#ifdef USE_CUBE\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n#endif\n{\n\t#ifdef USE_CUBE\n    vec3 pos = rayDir;\n    #else\n    vec3 pos = frag2sph(fragCoord.xy);\n    if(pos.x>10.) discard;\n    #endif\n    vec3 n = normalize(pos);\n    //float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec3 b = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).xyz;\n    b=normalize(b-dot(b,n)*n)*.01;\n    \n    vec3 v=vec3(0);\n    float bbMax=5.; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec3 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n            float str=.01;\n            str*=pow(dot(b,b),.25)*5.;\n            v+=cross(getRot(pos+p,b),p)*str;\n            p = rotAx(p,n*ang);\n        }\n        b*=2.;\n    }\n    \n    #ifdef USE_CUBE\n    fragColor=texture(iChannel0,normalize(pos+v));\n    #else\n    fragColor=texture(iChannel0,sph2frag(pos+v)/iResolution.xy);\n    #endif\n    // mix the flow field with its own velocity field for consistency\n    // (actually i have the suspicion that this does not what its supposed to do)\n    fragColor.xyz=mix(fragColor.xyz,v*5.0+.5,.01);\n\n    // add a little \"motor\" where the sun shines most\n    vec3 sun=getSun();\n    vec3 vel = vec3(sun.yx*vec2(1,-1),0)*.5;\n    //vel *= 0.01/(dot(pos-pos0,pos-pos0)/.2+.2);\n    fragColor.xyz = mix(fragColor.xyz,vel+.5,0.01/(dot(pos-sun,pos-sun)/.2+.2));\n\n    // add a little \"freezer\" on the poles\n    //fragColor.xyz = mix(fragColor.xyz,vec3(.5),pow(pos.z*pos.z,10.));\n\n    if(iFrame<=4 || KEY_I>0.5) fragColor=mix(vec4(.5),texture(iChannel2,fragCoord.xy/iResolution.xy*.5),.2);\n}\n", "cube_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKSR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[627, 653, 675, 675, 958], [960, 960, 995, 995, 1175], [1177, 1192, 1230, 1253, 1617], [1619, 1619, 1641, 1641, 1716], [1718, 1718, 1740, 1740, 1815], [1817, 1817, 1832, 1832, 1966], [1968, 1968, 2025, 2051, 4322]], "test": "untested"}
{"id": "3tVXzc", "name": "Semi stable collapse", "author": "hamoid", "description": "No attempts were made at optimization. Just looking for interesting aesthetics.", "tags": ["feedback"], "likes": 6, "viewed": 375, "published": 3, "date": "1583263182", "time_retrieved": "2024-07-30T21:20:49.723869", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 175]], "test": "untested"}
{"id": "WtVSz3", "name": "Day 75", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 11, "viewed": 455, "published": 3, "date": "1583260803", "time_retrieved": "2024-07-30T21:20:50.579581", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.)*0.04;\n    float chromAb = dot(uvn,uvn)*7.;\n    vec2 offs = vec2(0) + texture(iChannel1, uv + iTime*4.).xz*0.0;\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.99;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.x += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.y += texture(iChannel0, target).y;\n    \tradial.z += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    \n    \n    \n    radial /= steps;\n    \n    fragColor = texture(iChannel0, uv)*0.6 + radial*0.4; \n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    fragColor *= 1.4;\n    //fragColor = pow(fragColor, vec4(0.45));\n\t\n    float duvuv = dot(uvn,uvn);\n    \n    fragColor = pow(fragColor, vec4(0.59 + duvuv));\n    \n    fragColor *= 1. - duvuv;\n    \n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    //fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 glow = vec3(0);\nvec3 glowB = vec3(0);\nfloat side = 1.;\n#define dmin(a,b) a.x < b.x ? a : b\n    \n#define pmod(p, x) mod(p,x) - 0.5*x\nvec3 attenuation = vec3(1);\n\nfloat chebyshevl(vec3 p){\n\treturn max(p.x, max(p.y, p.z));\n}\n\nfloat manhattanl(vec3 p){\n\treturn abs(p.x) + abs(p.y) + abs(p.z);\n}\n\n\nfloat lpnorm(vec3 p, float s){\n    return pow(\n        (\n         pow(abs(p.x),s)+\n         pow(abs(p.y),s)+\n         pow(abs(p.z),s)), \n        1.0/s);\n}\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define pal(a,b,c,d,e) ((a) + (b)*sin(tau*((c)*(d) + (e))))\n// from hg sdf\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    \n    \n    for(int i = 0; i < 0; i++){\n    \tp = abs(p);\n        p.xy *= rot(0.3);\n        p.yz *= rot(0.5*pi);\n        p.y += 0.2;\n    }\n    \n    const float modD = 10.;\n    \n    vec3 q = p;\n    \n    float a = pow(abs(sin(q.z*0.01+ q.x*0.001 + iTime*0.6)), 2000.)*2.*smoothstep(0.,1.,length(q.xy)*0.14)*1.;\n    p.xy -= normalize(p.xy)*a*0.2;\n    \n    p.xy *= rot(p.z*0.014);\n    //p.z = pmod(p.z,modD);\n    \n    float reps = 3.;\n    \n    vec3 pC = vec3(atan(p.y,p.x)/tau,length(p.xy),p.z);\n    \n    //float id = floor(pC.x/reps);\n    \n    float i = pModPolar(p.xy, 3.);\n    \n    #define WID 0.6\n    \n    \n    #define modDB vec3(4.,4.,10.)\n    \n    float id = floor(p.z/modDB.z);\n    \n    \n    p.x -= WID ;\n    p = pmod(p, modDB);\n    \n    \n    \n    //float dCubez = length(p) - 0.4;\n    \n    \n    p = abs(p);\n    float dCubez = min(\n    \tmax(p.y, p.z),\n        max(p.y, p.x)\n    );\n    \n    \n    dCubez = min(dCubez, max(p.x,p.z)) - 0.3 ;\n    \n    \n    \n    \n    d = dmin(d, vec2(dCubez,1.));\n    \n    vec3 j = p;\n    \n    j = abs(j);\n    j -= 0.8;\n    j.xy -= 0.2;\n    j.yz *= rot(0.1 + sin(iTime)*0.4);\n    //j.xy *= rot(3.5);\n    j = abs(j);\n    \n    dCubez = max(j.x, j.z) - 0.06;\n    \n    \n    \n    d = dmin(d, vec2(dCubez,3.));\n    \n    p -= 0.5;\n    d = dmin(d, vec2(max(p.x, max(p.z, p.y)),0.));\n    \n    p += 0.5;\n    p.xy *= rot(sin(iTime*0.4)*0.1 + 0.4);\n    p = pmod(p, 0.6);\n    \n    \n    \n    \n    dCubez = max(p.x,p.z);\n    dCubez = min(dCubez,max(p.y,p.x));\n    \n    //d = dmin(d, vec2(dCubez, 4.) );\n    \n    float b = pow(abs(sin(q.z*0.1+ q.x*0.1 + sin(q.x*0.04 + iTime*0.4) + sin(q.y*0.01 + iTime) + sin((q.x + q.z + q.y)*1.)*0.5 + iTime*0.5)), 7000.)*2.*smoothstep(0.,1.,length(q.xy)*0.04)*4.;\n    //float b = pow(abs(sin( sin(q.x*0.01 + iTime*0.4) +  sin(q.y*0.05 + iTime*0.8) +  sin(q.z*0.02 + iTime*0.8) + q.z*0.01   + iTime*0.2)), 7000.)*2.*smoothstep(0.,1.,length(q.xy)*0.14)*1.;\n    \n    \n    vec3 c = pal(0.8,0.8,vec3(0.5,0.2,0.2),0.1,0.3);\n    vec3 cb = pal(0.8,0.8,vec3(0.2,0.6,0.9),1.1,2.9);\n    c = max(c, 0.);\n    glowB += exp(-max(dCubez, 0.)*500.)*a*9.*c;\n    \n    glowB += exp(-max(dCubez, 0.)*500.)*b*9.*cb;\n    \n    \n    //d.x *= 0.3;\n    d.x *= 0.9;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\n    hit = false; t = 0.; p = ro;\n    for(int i = 0; i < 250; i++){\n    \td = map(p);\n        d.x *= side;\n        glow += exp(-max(d.x, 0.)*200.);\n        \n        if(d.x < 0.001 ){\n        \thit = true;\n            break;\n        }\n        if (t > 70.)\n            break;\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n    \nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0);\n    return normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. + dot(uv,uv)*0.8;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    \n    ro.z += iTime*6. - sin(iTime)*3.;\n    \n    ro.x += sin(iTime*0.4)*0.1;\n    ro.y += cos(iTime*0.2)*0.1;\n    \n    vec3 rd = normalize(vec3(uv,1.5 + sin(iTime)*0.0));\n    \n    rd.xz *= rot(0.3*iMouse.x/iResolution.x - 0.15);\n    rd.xz *= rot(sin(iTime*0.4)*0.2);\n    rd.xy *= rot(sin(iTime*0.15)*1.5);\n    rd.yz *= rot(sin(iTime*0.15)*0.1);\n    \n    //ro.xy += texture(iChannel0,2.*(uv + iTime)*256.).xy*0.01;\n    ro -= rd*texture(iChannel0,2.*(uv + iTime)*256.).x*1.4; // reduce banding\n    \n    #define fogD 0.007\n    \n    #define fogC vec3(1.5,1.5,1.6)\n    \n    vec3 p; float t; bool hit; bool hitAtLeastOnce = false;\n    float maxT;\n    float firstT;\n    vec2 d;\n    \n    for(int i =0; i < 3 + min(iFrame,0); i++){\n    \td = march(ro, rd, p , t, hit);\n        maxT = max(maxT, t);\n        if(i == 0)\n            firstT = t;\n        if(!hit)\n            break;\n        if(hit)\n            hitAtLeastOnce = true;\n        \n        \n        vec3 n = getNormal(p)*side;\n        \n        float fres = pow(1. - max(dot(n ,-rd),0.), 5.);\n        //rd = reflect(rd, n);\n        \n        if(d.y == 1.){\n        \trd = refract(rd, n + sin(p.x*10. + p.y*10. + p.z*10.)*0.02, 0.9);\n        \t//attenuation *= vec3(0.7,0.9,0.9)*0.8;\n            //attenuation *= vec3(0.7,0.9,0.9)*(0.5 + fres*0.6);\n            attenuation *= vec3(0.5,0.7,0.8)*(0.8 + fres*0.6);\n            //attenuation *= vec3(0.8,0.96,0.78)*(0.5 + fres*0.4)*1.1;\n            side *= -1.;\n    \t\tcol += mix(\n                (glow + glowB*0.3 )*0.03*(0.9 ),\n            \tfogC,\n                smoothstep(0.,1.,t*fogD)\n            )*attenuation*0.4;\t\n        }\n        if(d.y == 0.){\n        \trd = reflect(rd, n);\n            //side *= -1.;\n        \tattenuation *= fres*0.2;\n    \t\t//col += attenuation;\t\n        }\n        if(d.y == 3.){\n        \trd = reflect(rd, n);\n            //side *= -1.;\n            \n            attenuation *= vec3(0.5,0.4,0.3)*1.8; \n                \n        \trd = reflect(rd, n);\n            //side *= -1.;\n    \t\tcol += mix(\n                (glow + glowB*0.1)*0.03*(0.9 ),\n            \tfogC,\n                smoothstep(0.,1.,t*fogD)\n            )*attenuation;\n            \n        \t//attenuation *= fres*0.9;\n    \t\t//col += attenuation;\t\n        }\n    \tro = p + rd*0.1;\n        //col += glow*0.01*attenuation*(1.);\t\n\t\t\n    }\n    \n    \n    col = mix(col, fogC, smoothstep(0.,1.,firstT*fogD));\n    \n    col = max(col, 0.);\n    col *= 1.;\n    \n    col = smoothstep(0.,1.,col)*1.;    col += glowB*0.001;\t\n    \n    //col += mix(col, vec3(0.6), smoothstep(0.,1.,firstT*0.004))*attenuation;\n    \n    col *= 1.;\n\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 1272]], "test": "untested"}
{"id": "3tKXRc", "name": "woodcut video 2", "author": "FabriceNeyret2", "description": ".", "tags": ["video", "woodcut"], "likes": 4, "viewed": 300, "published": 3, "date": "1583257692", "time_retrieved": "2024-07-30T21:20:51.448258", "image_code": "// variant of https://shadertoy.com/view/wtyXRc\n\n#define C(a) sin(6.283/8.*dot(U,sin(a+vec2(0,11)))) // trame with angle a\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = textureLod(iChannel0,U/iResolution.xy,2.);\n    \n    O = pow( mix(vec4(1), vec4( C(0.), C(2.1), C(-2.1), 1),.6) ,\n          // vec4(4.*clamp(1.-(2.*O.r-O.g),0.,1.)) );\n                  4.*clamp(1.-1.2*O,0.,1.) );\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 162, 162, 385]], "test": "untested"}
{"id": "wtGXzc", "name": "CubeMap paint + drops + HUD", "author": "FabriceNeyret2", "description": "Illustrates continuous view-dep update of cubemap.   \nMouse controls view dir.  Arrows keys for zoom (space = reset to 1).\nBright spot spray-painted in view dir, + simulated falling drops + green HUD.", "tags": ["cubemap", "paint", "droplets", "drops"], "likes": 8, "viewed": 505, "published": 3, "date": "1583248938", "time_retrieved": "2024-07-30T21:20:52.312947", "image_code": "// === display cubeMap + HUD\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( 2.*u - R ) /R.y;\n    vec3 rayDir = ray(U);\n \n    O -= O;\n    O.b = .7 * ( .5+.5*rayDir.y );       // background env\n    O.g = .3 * ( .5-.5*rayDir.y );\n    O *= .95+.05*sin(100.*rayDir.y);\n // O *= .95+.05*sin(100.*rayDir.y - sin(30.*atan(rayDir.z,rayDir.x)));\n // O = texture(iChannel2, .5+.5*vec2(atan(rayDir.z,rayDir.x)/3.14,rayDir.y)); // cylindrical map\n\n    vec4 T = texture(iChannel0, rayDir); // dynamic env\n    O = mix(O, T, T.a);\n    \n    float c = dot(rayDir, sprite.xyz);   // slow HUD part\n    if (c>.9) O.g += max(0.,1.-100.*abs(c-.98));\n    U = abs(U);                          // fast HUD part\n    if ( length(U)<.1 && min(U.x,U.y) < 2./R.y ) O.g ++;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// === update CubeMap: paint around view direction\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 rayOri, vec3 rayDir )\n{\n    O = texture(iChannel0, rayDir) * .995; // faded past\n\n    vec3 EyeDir = viewDir;      // --- paint in eye direction\n\n#if 1                           // spray\n    vec3 X = normalize (cross(EyeDir,vec3(0,1,0))), // jitter paint dir\n         Y = cross(X, EyeDir);\n    vec2 D = hash12(iTime);\n    D =  .5 * D.x * cos(6.283*(D.y+vec2(0,.25)));\n    EyeDir = normalize( EyeDir + mat2x3(X,Y)*D );\n#endif\n    \n    float c = dot(rayDir,EyeDir);\n    if (c>.9) O = mix( O,\n                       min( texture(iChannel2, U/R)* 2., 1.),  // texture in cubemap frame\n                    // min( texture(iChannel2, (rayDir*mat2x3(X,Y)).xy)* 2., 1.), // texture in eyeDir Frame\n                       pow(max(0.,c), 300.) \n                     );\n\n    \n    for (int i=1; i<81; i++) {  // --- paint drops\n        vec3 P = drop(i).xyz;\n        c = dot(rayDir,P);\n        if (c>.9) O = mix(O,vec4(.5,0,0,1),pow(c,5e3));\n    }\n}", "cube_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === view angles (mouse) + drops simulation + HUD sprite\n\n#define key(a)    texelFetch(iChannel3,ivec2(a,1),0).x\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel1, ivec2(U), 0); // previous state\n    \n    if (U==vec2(.5))           // --- track view angles\n      O.xy = length(iMouse.xy) < 20. \n                ? vec2(3.*cos(.3*iTime),.3*sin(.137*iTime))  // demo mode\n                : (2.*iMouse.xy - R ) / R * vec2(3.14,1.57); // mouse control\n    \n    else if (U==vec2(1.5))    // --- sprite lazy follow mouse\n        if (iFrame==0) \n             O.xyz = vec3(0,-1,0);\n        else O.xyz = normalize( mix(O.xyz, viewDir,.1));\n\n   else if (U==vec2(2.5))     // --- key controls\n        if (iFrame==0) \n              O = vec4(1,0,0,0);\n        else  key(32)>0. ? O.r = 1.\n            : O.r *= 1. + .3*(key(38)-key(40)); // zoom: up/down space=reset\n        \n    else if (U.y==.5)         // --- drops simulation\n        if (iFrame < int(5.*U.x) || O.y < -.995) \n            O.xyz = normalize( vec3( 2.*hash12(U.x+1.73*iTime) -1., 5 )).xzy;\n        else {\n            float l = length(O.xz),\n                  a = atan(O.y,l);\n            a -= .3/60.;\n            O.y = sin(a);\n            if (l>1e-5) O.xz *= cos(a)/l; \n        }\n    \n    else discard;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R         iResolution.xy\n#define rot(a)    mat2 ( cos(a+vec4(0,11,33,0)) )\n#define hash12(p) fract(sin((p)*vec2(127.1,311.7)) *43758.5453123)\n#define viewAngle texelFetch(iChannel1, ivec2(0), 0)\n#define viewDir   ray(vec2(0))\n#define drop(i)   texelFetch(iChannel1, ivec2(i,0), 0)\n#define sprite    texelFetch(iChannel1, ivec2(1), 0)\n#define zoom      texelFetch(iChannel1, ivec2(2), 0).x\n\nvec3 dir;\n\n#define ray(U) (                     \\\n    dir = normalize(vec3(U,zoom)),   \\\n    dir.xz *= rot(viewAngle.x),      \\\n    dir.yz *= rot(viewAngle.y),      \\\n    dir )\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 68, 68, 751]], "test": "untested"}
{"id": "wtyXRc", "name": "woodcut video", "author": "FabriceNeyret2", "description": ".", "tags": ["video", "woodcut"], "likes": 3, "viewed": 354, "published": 3, "date": "1583238976", "time_retrieved": "2024-07-30T21:20:53.160680", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/iResolution.xy;\n    O = textureLod(iChannel0,U,2.);\n    float v = 2.*O.r-O.g;\n  //O = vec4(mix(1.,sin(300.*U.y),.6) / clamp(1.-v,0.,1.) );\n    O = vec4(pow(mix(1.,sin(300.*U.y),.6) , 4.*clamp(1.-v,0.,1.)) );\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 263]], "test": "untested"}
{"id": "ttySz3", "name": "Attentive Petal", "author": "BenoitArbelot", "description": "Experiment to draw a petal or tear shape. Mouse to interact.", "tags": ["petal"], "likes": 3, "viewed": 301, "published": 3, "date": "1583230192", "time_retrieved": "2024-07-30T21:20:54.025368", "image_code": "/* Inspired by https://thebookofshaders.com/07/ */\n\n#define PI 3.14159265\n#define rot(a)   mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec4 DrawPetalPolar(vec2 uv, vec2 pos, float size, vec2 dir){\n    \n    //Distance\n    vec2 dist = uv - pos;\n    \n    //Rotate\n    float angle = -atan(dir.y, dir.x);\n    \n    dist *= rot(angle);\n    \n    //Translate\n    dist.x -= size * 0.25f;\n    \n    //Polar coordinates\n    float r = length(dist)*2.0;\n    float a = atan(dist.y, dist.x);\n    \n    //Shaping function\n    float f = -1.;\n    \n    if(a > PI*0.5 || a < -PI*0.5){\n    \tf = size * cos(a*2.);\n    }\n    \n    return vec4(1. - smoothstep(-.8, .8, (r-f)/fwidth(r-f)));\n}\n\nvec4 DrawPetalDistance(vec2 dist, float size, vec2 dir){\n    \n    dist.y *= 5.;\n    \n    float d = length(dist);\n    \n    return vec4(smoothstep(size - 0.01, size + 0.01, d));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Petal position\n    vec2 pos = vec2(.5 + .3*cos(iTime), .5+ .3*cos(iTime*.7));\n\n    // Petal direction\n    vec2 dir = normalize(iMouse.xy/iResolution.xy - pos);\n    \n    // Output to screen\n    fragColor = DrawPetalPolar(uv, pos, 1., dir);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttySz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 188, 208, 655], [657, 657, 713, 713, 839], [841, 841, 898, 934, 1228]], "test": "untested"}
{"id": "WtySRc", "name": "Hexagon - gradient  2D ", "author": "iq", "description": "Signed distance and gradient to a (rounded) hexagon. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "hexagon", "distance"], "likes": 19, "viewed": 1067, "published": 3, "date": "1583214183", "time_retrieved": "2024-07-30T21:20:54.869112", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a hexagon. Probably\n// faster than central differences or automatic\n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgHexagon( in vec2 p, in float r ) \n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    vec2 s = sign(p);\n    p = abs(p);\n\tfloat w = dot(k.xy,p);    \n    p -= 2.0*min(w,0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    float d = length(p)*sign(p.y);\n    vec2  g = (w<0.0) ? mat2(-k.y,-k.x,-k.x,k.y)*p : p;\n    return vec3( d, s*g/d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // size\n\tfloat si = 0.3 + 0.2*cos( iTime );\n    // corner radious\n    float ra = 0.3*(0.5+0.5*sin(iTime*2.0));\n\n    // sdf(p) and gradient(sdf(p))\n\tvec3 dg = sdgHexagon(p,si);\n    float d = dg.x-ra;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n     vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtySRc.jpg", "access": "api", "license": "mit", "functions": [[1374, 1469, 1512, 1512, 1830], [1832, 1832, 1889, 1889, 2599]], "test": "ok"}
{"id": "WlGXz3", "name": "Hexagon - gradient 2D", "author": "TimoKinnunen", "description": "Signed distance and gradient to a (rounded) hexagon. Correct distance field everywhere, which allows for example making an outline shape with ease.", "tags": ["2d", "distancefield", "sdf", "gradient", "hexagon", "distance"], "likes": 4, "viewed": 565, "published": 3, "date": "1583206548", "time_retrieved": "2024-07-30T21:20:55.720835", "image_code": "// Fork of \"Cross - gradient 2D\" by iq. https://shadertoy.com/view/WtdXWj\n// 2020-03-03 03:08:40\n\n// The MIT License\n// Copyright © 2020 Timo Kinnunen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a hexagon. Optimized to the best of my ability but not profiled.\n\n// List of iq's other 2D distances+gradients:\n//\n// Circle:   https://www.shadertoy.com/view/WltSDj\n// Box:      https://www.shadertoy.com/view/wlcXD2\n// Cross:    https://www.shadertoy.com/view/WtdXWj\n// Segment:  https://www.shadertoy.com/view/WtdSDj\n\n// return distance (.x) and gradient (.yz)\nvec3 sdgHexagon(vec2 p, float r) {\n    const vec4 K = vec4(sqrt(3.0), 0.5 * sqrt(3.0), 1.0 / sqrt(3.0), 2.0 / sqrt(3.0));\n    vec3 a = vec3(abs(p),0);\n\n    if(K.x * a.x <= min(a.y, r)) {\n        // gradient is vertical\n        a.z = a.y - r;\n        a.xy = vec2(0.0, -1.0);\n    } else if(abs(a.z = dot(a.xy, vec2(K.y, -1.5))) <= r) {\n        // gradient is 30 degrees from horizontal\n        a.z = a.z + a.y + a.y - r;\n        a.xy = vec2(-K.y, -0.5);\n    } else {\n        // gradient is towards a sharp corner\n        a.z = length(a.xy = a.z < r ? vec2(K.z * r - a.x, r - a.y) : vec2(K.w * r - a.x, -a.y));\n        a.xy = vec2(a.x / a.z, a.y / a.z);\n    }\n    return vec3(a.z, p.x < 0. ? -a.x : a.x, p.y < 0. ? -a.y : a.y);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n\n    float mult = iResolution.y;\n    float mult3 = 3.0/mult;\n    vec2 pos = U-0.5*iResolution.xy;\n\n    // size\n\tfloat b = floor(0.125*iResolution.y);\n    \n    // corner radius\n    float ra1 = (0.5+0.5*sin(iTime*1.2))*0.25*mult;\n    float ra2 = (0.5+0.5*sin(iTime*1.3))*0.25*mult;\n\n    float center = 0.5*(ra1+ra1+ra2);\n    float radius = 0.5*ra2;\n\n    // sdf(p) and gradient(sdf(p))\n\tvec3 dg = sdgHexagon(pos,b);\n    float d = abs(dg.x-center)-radius;\n    vec2 g = dg.yz*sgn(dg.x-center);\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = vec3(0.5+0.5*g,0.5+0.5*sign(d));\n\tcol *= 1.0 - 0.5*exp2(-16.0*abs(d*mult3));\n\tcol *= 0.75 + 0.25*cospi(64.0*d*mult3);\n\tcol = mix(vec3(1.0), col, smoothstep(0.0,0.01,abs(d*mult3)));\n\n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float sinpi(float v) {return sin(radians(180.0)*v);}\nvec2  sinpi(vec2  v) {return sin(radians(180.0)*v);}\nvec3  sinpi(vec3  v) {return sin(radians(180.0)*v);}\nvec4  sinpi(vec4  v) {return sin(radians(180.0)*v);}\nfloat cospi(float v) {return cos(radians(180.0)*v);}\nvec2  cospi(vec2  v) {return cos(radians(180.0)*v);}\nvec3  cospi(vec3  v) {return cos(radians(180.0)*v);}\nvec4  cospi(vec4  v) {return cos(radians(180.0)*v);}\nfloat tanpi(float v) {return tan(radians(180.0)*v);}\nvec2  tanpi(vec2  v) {return tan(radians(180.0)*v);}\nvec3  tanpi(vec3  v) {return tan(radians(180.0)*v);}\nvec4  tanpi(vec4  v) {return tan(radians(180.0)*v);}\nfloat atanpi(vec2 v) {return atan(v.y,v.x)/radians(180.0);}\nfloat sgn(float x) {return (x<0.)?-1.:1.;}\nvec2 sgn(vec2 v) {return vec2(v.x<0.?-1:1, v.y<0.?-1:1);}\nvec3 sgn(vec3 v) {return vec3(v.x<0.?-1:1, v.y<0.?-1:1, v.z<0.?-1:1);}\nvec4 sgn(vec4 v) {return vec4(v.x<0.?-1:1, v.y<0.?-1:1, v.z<0.?-1:1, v.w<0.?-1:1);}\nfloat sqr(float x) {return x*x;}\nvec2 sqr(vec2 x) {return x*x;}\nvec3 sqr(vec3 x) {return x*x;}\nvec4 sqr(vec4 x) {return x*x;}\nfloat lengthSqr(vec2 x) {return dot(x, x);}\nfloat lengthSqr(vec3 x) {return dot(x, x);}\nfloat lengthSqr(vec4 x) {return dot(x, x);}\nfloat vmax(vec2 v) {return max(v.x, v.y);}\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {return min(v.x, v.y);}\nfloat vmin(vec3 v) {return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {return min(min(v.x, v.y), min(v.z, v.w));}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXz3.jpg", "access": "api", "license": "mit", "functions": [[1532, 1575, 1609, 1609, 2301], [2303, 2303, 2339, 2339, 3184]], "test": "untested"}
{"id": "3lyXR3", "name": "Fractal Fire", "author": "jarble", "description": "This fractal animation looks like fire!\n\nMove the mouse to zoom in and out!", "tags": ["procedural", "fractal", "fire", "texture"], "likes": 3, "viewed": 400, "published": 3, "date": "1583197982", "time_retrieved": "2024-07-30T21:20:56.588515", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 8.0;\n\nconst float RED = 0.0;\nconst float BLUE = 7.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float GREEN = 5.0;\nconst float WHITE = 6.0;\nconst float ORANGE = 1.0;\nconst float BLACK = 8.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n\n    return hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == BLACK){\n    \treturn vec3(0.0,0.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n\tvec4 neighbors;\n    float offset = iTime*20.0;\n    float offset1 = offset*20.0;\n    while(mag1 < mag){\n    neighbors = vec4(magnify(fragCoord+vec2(offset,1),mag1),\n        magnify(fragCoord+vec2(1,offset),mag1),\n        magnify(fragCoord-vec2(offset,1),mag1),\n        magnify(fragCoord-vec2(1,offset1),mag1));\n    bool modified = true;\n\n    if(color1 == RED && is_next_to(ORANGE,neighbors)){\n    \tcolor1 = ORANGE;\n    }\n    else if(color1 == ORANGE && is_next_to(GRAY,neighbors)){\n        if(mag1 > 5.0){\n        \tcolor1 = YELLOW;\n        }\n        else{\n        \tcolor1 = GRAY;\n        }\n    }\n    else if(color1 == GRAY && is_next_to(RED,neighbors)){\n        color1 = RED;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = RED;\n    }\n    else if(color1 == GRAY && is_next_to(ORANGE,neighbors) && is_next_to(GRAY,neighbors)){\n        color1 = WHITE;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x) + vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 329, 351, 351, 575], [578, 578, 618, 618, 783], [785, 785, 829, 829, 965], [969, 969, 997, 997, 1549], [1551, 1551, 1610, 1610, 2573], [2575, 2575, 2632, 2632, 2962]], "test": "untested"}
{"id": "3tGSR3", "name": "Day 74", "author": "jeyko", "description": "Another day of daily creative coding challenge", "tags": ["mdtmjvm"], "likes": 94, "viewed": 5512, "published": 3, "date": "1583187696", "time_retrieved": "2024-07-30T21:20:57.466169", "image_code": "\n// I fixed up the shader a bit, compared to the original and added tome color toning\n\n// It is basically just two perpendicular planes which are rotated depending on the position of the viewer.\n// Materials are reflective\n// Then some glowy lines are added on top\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    // Radial blur and chromatic abberation\n    float steps = 40.;\n    float scale = 0.00 + pow(length(uv - 0.5),3.4)*0.1;\n    float chromAb = pow(length(uv - 0.5),1.)*1.5;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.98;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor = radial*1.5; \n    \n    // mimap glow\n    //fragColor += texture(iChannel0,uv, 6.)*0.1;\n    \n    // color correction\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.14); \n    \n    fragColor *= 1.;\n    fragColor.g *= 1.1;\n    fragColor.r *= 0.95 + uvn.x*0.7;\n    fragColor.g *= 0.95 + uvn.y*0.3;\n    fragColor = max(fragColor, 0.);\n    // vignette\n    fragColor = pow(fragColor, vec4(0.545 + dot(uvn,uvn)*2.)); \n\t\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define iTime (iTime - 7.4)\n\n#define SPEED 0.3\n#define FL_H 0.3\n\n\n#define mx (10.*iMouse.x/iResolution.x)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin(6.28*((c)*(d) + (e))))\n\nvec3 glowB = vec3(0);\n\nvec3 reflAtten = vec3(1);\n\n\nvec3 path (float z){\n    z *= 0.5;\n\treturn vec3(\n    \tsin(z + cos(z*0.7))*0.7,\n    \tcos(z + cos(z*1.2))*0.6,\n        0.\n    )*2.;\n}\n\n#define pmod(p,x) mod(p,x) - x*0.5\nfloat map(vec3 p){\n\tfloat d = 10e6;\n    \n    // w is used for the lines \n    // and p is used for the tunnel\n    \n    vec3 w = p; \n    w = abs(w);\n    \n    // the tunnel is made by the next two lines, otherwise it's just to planes\n\tp -= path(p.z);\n    \n    p.xy *= rot(\n        sin(w.z*2.9 + p.z*0.7 + sin( w.x*2. + w.z*4. + iTime*0. + 0.5) + w.z*0.1)*1.6\n    ); \n    \n    float flTop =(-p.y + FL_H )*0.3;\n    float flBot =(p.y + FL_H )*0.3;\n    float floors = min(flBot, flTop);\n    d = min(d,floors);\n    \n    const float sep = 0.2; // seperation between glowy lines\n    \n    w.y = pmod(w.y,sep);\n    \n    \n    vec3 z = p;\n    // random attenuation to feed to the glowy lines\n    float atten = pow(abs(sin(z.z*0.2 + iTime*0.1)), 50.);\n    float attenC = pow(abs(sin(z.z*0.1  + sin(z.x + iTime)*0.2 + sin(z.y*3.)*4. + iTime*0.2)), 100.);\n    float attenB = pow(abs(sin(w.z*0.2  + sin(w.x + iTime)*0.2 + sin(w.y*0.7)*4. + w.y*20. + iTime*0.2)), 10.);\n    vec3 col = pal(0.1,0.6 - attenC*0.5,vec3(1.7  - atten*0.6,1.1,0.8),0.2 - atten*0.4 ,0.5 - attenB*0.6 );\n\tcol = max(col, 0.);\n    \n    float sc = 60. - atten*55.;\n    \n    // distance to the glowy lines\n    float dGlowzers = max(floors,-abs(w.y) + sep*0.5) - 0.02;\n    \n    // glow\n    glowB += exp(-dGlowzers*(70.))*reflAtten*col*40.;\n    d *= 0.65;\n    return d;\n}\nfloat march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tfloat d = 10e6;\n\tp = ro; t = 0.; hit = false;\n    for (int i = 0; i < 180 ; i++){\n    \td = map(p);\n        //glow += exp(-d.x*20.)*0.001;\n        if(d < 0.001){\n        \thit = true;\n            break;\n        }\n    \tt += d;\n        p = ro + rd*t;        \n    }\n\n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0);\n    return normalize(\n    \tvec3(\n        \tmap(p - t.xyy) - map(p + t.xyy),\n        \tmap(p - t.yxy) - map(p + t.yxy),\n        \tmap(p - t.yyx) - map(p + t.yyx)\n        )\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - dot(uv,uv)*-0.2;\n    \n    \n    \n    //uv.xy *= rot(0.1)\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += mx*2.;\n    ro.z += iTime*SPEED - sin(iTime)*SPEED*0.3;\n    ro += path(ro.z);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 1.);\n    \n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    rd.xy *= rot(sin(iTime)*0.05);\n    \n    bool hit; float t; vec3 p;\n    \n    float bounce;\n    \n    float firstT = 0.;\n    float d;\n    for(int i = 0; i < 2 ; i++){\n        d = march(ro, rd, p, t, hit);\n        vec3 n = getNormal(p);\n        if(i == 0)\n        \n        reflAtten *= vec3(0.2);\n        \n        rd = reflect(rd, n);\n        ro = p + rd*0.2;\n    }\n    \n\t\n    \n    glowB = max(glowB, 0.);\n    col += glowB*0.0006;\n    \n    col = clamp(col,0., 1.);\n    col = pow(col, vec3(1.3));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 325, 325, 1468]], "test": "untested"}
{"id": "wlKXzV", "name": "raymarching refraction (simple)", "author": "isk", "description": "using a refracted ray into a cubemap to pick surface colour.\nnotice how other objects are not visible behind those in front. this requires a slightly more complex solution.", "tags": ["raymarch", "refraction"], "likes": 10, "viewed": 1116, "published": 3, "date": "1583181775", "time_retrieved": "2024-07-30T21:20:58.320883", "image_code": "// anti-aliasing samples. set to 0 to disable AA.\n#define AA 2\n\nconst float PI=acos(-1.);\nconst float EPS=.001,MAX=100.;\nconst int ITER=256;\n\nfloat ycyl(vec3 p, float r) {\n    return length(p.xz)-r;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat ztor(vec3 p, vec2 r) {\n    vec2 circ=vec2(length(p.xz)-r.x,p.y);\n    return length(circ)-r.y;\n}\n\nfloat scene(vec3 p) {\n    float d=MAX;\n    d=min(d,ycyl(p,.5));\n    d=min(d,sph(abs(p)-1.,.6));\n    d=min(d,ztor(p, vec2(1., .3)));\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 D=vec2(.001,0);\n    return normalize(scene(p)-vec3(scene(p-D.xyy),scene(p-D.yxy),scene(p-D.yyx)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t=0.,d;\n    for(int i=0; i<ITER; ++i){\n        d=scene(ro+rd*t);\n        if(abs(d)<EPS) return t;\n        t+=d;\n        if(t>MAX) return t;\n    }\n    return t;\n}\n\nvec3 ray(vec2 uv, vec3 ro, vec3 poi){\n    vec3 f=normalize(poi-ro),\n         r=normalize(cross(f,vec3(0,1,0))),\n         u=cross(r,f),\n         c=ro+f,\n         i=c+r*uv.x+u*uv.y;\n    return normalize(i-ro);\n}\n\nvec3 render(vec2 uv){\n    float orbit=-2.*PI*iMouse.x/iResolution.x;\n    vec3 ro;\n    if (iMouse.z>0.)\n        ro=vec3(sin(orbit)*5.,-2.*iMouse.y/iResolution.y+1.,cos(orbit)*5.);\n    else\n        ro=vec3(sin(iTime),cos(iTime),5.);\n    vec3 rd=ray(uv,ro,vec3(0));\n    float t=march(ro,rd);\n    if(t>=MAX) return texture(iChannel0,rd).rgb;\n    vec3 p=ro+rd*t,n=normal(p);\n    return texture(iChannel0,refract(rd,n,.75)).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col=vec3(0);\n#if AA>1\n    vec2 aao;\n    const float AAINC=1./float(AA);\n    for (aao.x=-.5; aao.x<.5; aao.x+=AAINC)\n        for (aao.y=-.5; aao.y<.5; aao.y+=AAINC)\n            col+=render(uv+aao/iResolution.y);\n    col/=float(AA*AA);\n#else\n    col+=render(uv);\n#endif\n    fragColor=vec4(col,1.);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 171, 171, 200], [202, 202, 230, 230, 256], [258, 258, 286, 286, 359], [361, 361, 382, 382, 508], [510, 510, 530, 530, 640], [642, 642, 672, 672, 844], [846, 846, 883, 883, 1055], [1057, 1057, 1078, 1078, 1481], [1483, 1483, 1537, 1537, 1901]], "test": "untested"}
{"id": "wtVSzK", "name": "knit 2", "author": "FabriceNeyret2", "description": "the yarn spiral is totally wrong but it still looks good :-p\n\nmouse controls camera.", "tags": ["raymarching", "sdf", "knot", "short", "knitting"], "likes": 13, "viewed": 511, "published": 3, "date": "1583172060", "time_retrieved": "2024-07-30T21:20:59.181582", "image_code": "// variant of https://shadertoy.com/view/WlVXzK\n// variant of https://shadertoy.com/view/ttKSDm\n\nfloat PI = 3.14159,\n       r = .15,                                                   // wire radius\n      dr = .1,                                                    // yarn radius (but section totally wrong)\n       d = 1.32, e = 4.5, f = 3., s, t0=1e9;\n\n#define FRAME 0\n\n#define S(a,da)  ( abs(mod(atan(q.y,q.x)-a+PI, 2.*PI) -PI) - da ) // section\n#define Ts(q,a,da) max(T(q),S(a,da) )                             // torus section\n#define R(a)       mat2( cos( a + vec4(0,33,11,0)) )              // rotation\n#define CS(a)      vec2(cos(a),sin(a))\n#define T0(q)     ( length(vec2(length(q.xy)-1.,q.z)) - r-dr )      // torus\n#define Ts0(q,a,da) max(T0(q),S(a,da) )                             // torus section\n\nfloat T(vec3 q) { // global s for yarn orientation\n    vec3 c=q; float t, a;     \n        a = atan(c.y,c.x); \n    \n    q = vec3( length(c.xy) - 1., c.z,  a*5.9*s ), \n    a = atan(q.y,q.x); \n    q.xy -= r * CS(-floor(q.z-a)+q.z);\n    t = length(q.xy) - dr;\n    return t*=.5;\n}\n\nfloat knot0(vec3 p) {                           // --- half stitch\n    vec3 q; float t, a=p.y+f/4.;\n  //p.z += .4*(1.-.5*a*a),                      // depth twist\n    p.z += .4*cos(1.5*a),                       // depth twist\n    p.x = mod(p.x-d,2.*d)-d;                    // + rank periodicity\n    q = p, t = Ts(q,PI/2.,1.55*PI/2.);          // half stitch\n    t0 = min(t0,Ts0(q,PI/2.,1.55*PI/2.));        // blur coloring attempt\n    return t;\n}\nfloat knot(vec3 p) {                            // --- full rank of stitch\n    vec3 q=p; float t;\n    q.y = mod(q.y,e)-f,                         // + vertical periodicity\n    s = 1.; t = knot0(q);                                    // top half stitch\n    s= -1.; q.y = -1.5-q.y,  q.x -= d, t = min(t, knot0(q)); // bottom symmetric\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = 1e9, tx,ty,tz, E = 0.;\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)),     // ray direction\n          P = 20./q, p, a, qa;                 // marching point along ray \n    vec2  M = (length(iMouse.xy)<20.) ? vec2(0): 3.14*(2.*iMouse.xy-q.xy)/q.y,\n        //C = 3.14*vec2(-.3,.4),               // camera\n          C = M==vec2(0) ? vec2(iTime) : M;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.04 )\n        p = P,\n        p.xz *= R(C.x), p.yz *= R(C.y),        // camera rotation\n        q = p,\n#if FRAME\n        a = abs(qa=q),                         // draw frame\n        t = max(min( ty= max(a.x,a.z) -.01, min( tx= max(a.z,a.y) -.01 ,tz= max(a.x,a.y) -.01 )  ),length(q)-2.),\n#endif\n        t = min(t, knot(p)),                   // odd rank\n        p.y -= e/2., \n        t = min(t, knot(p)),                   // even rank\n        E += .001/t,                           // blur coloring attempt\n        P += t*D;                              // step forward = dist to obj\n\n    O *= 1.5; \n // O.r += E;                                  // coloring attempts\n // O.r += exp(-10.*t0);\n // O = O*vec4(1,0,0,1) + exp(-20.*abs(t0));\n\n#if FRAME                                      // --- color frame\n    if (t==tx) O.gb*=.4+.4*sign(qa.x);         // x axis: red   ( whiter on positive side )\n    if (t==ty) O.rb*=.4+.4*sign(qa.y);         // y axis: green\n    if (t==tz) O.rg*=.4+.4*sign(qa.z);         // z axis: blue\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[810, 810, 827, 860, 1085], [1087, 1087, 1108, 1153, 1535], [1536, 1536, 1556, 1610, 1884]], "test": "untested"}
{"id": "wtySWD", "name": "Planet Blast", "author": "TekF", "description": "Shooting a planet with a gigantic frickin' laser!\nA different scene, but the same scatter engine as my previous shader.", "tags": ["raymarching", "montecarlo", "laser", "scatter", "atmospheric"], "likes": 38, "viewed": 1861, "published": 3, "date": "1583166001", "time_retrieved": "2024-07-30T21:21:00.428249", "image_code": "// Fork of \"Photoreal Clouds\" by TekF. https://shadertoy.com/view/tlcSzs\n// 2020-02-14 14:25:32\n\n// Tone Mapping by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\nfloat exposureModifier = 1.1;\n\n// Exposure curve parameters\n//#define SHOW_CURVE 1\nconst vec3 gradient = vec3(1.4,1.5,1.6);\nconst vec3 whiteSoftness = vec3(.3);\nconst vec3 blackClip = vec3(.0,.1,.2)*.3+.0;\nconst vec3 blackSoftness = vec3(.65,.5,.35)*2.;\n\nvec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvec3 SRGBToLinear ( vec3 col )\n{\n    return mix( col/12.92, pow((col+.055)/1.055,vec3(2.4)), step(.04045,col) );\n}\n\nvec3 HDRtoLDR( vec3 col )\n{\n#if (1)\n    // soft cut off near black to enhance contrast\n   \t// this is good for correcting for atmospheric fog\n\tcol = max(col-blackClip,0.); \n    col = sqrt(col*col+blackSoftness*blackSoftness)-blackSoftness;\n\n    col *= gradient;\n    \n    // soft clamp to white (oh this is so good)\n    vec3 w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n#else\n    // skip tone mapping\n\tcol*=.4;\n#endif\n    \n\treturn LinearToSRGB(col);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    fragCoord /= vec2(RESOLUTION_REDUCTION);\n    // smooth out the transition between pixels\n//    fragCoord -= 1.*sin(fragCoord*6.283185)/6.283185;\n    fragColour = SampleTextureCatmullRom4Samples(iChannel0,fragCoord/iResolution.xy,iResolution.xy);\n#else    \n    ivec2 ifragCoord = ivec2(fragCoord);\n    fragColour = texelFetch(iChannel0,ifragCoord,0);\n\n#ifdef MOSAIC_PREVIEW\n    const float targetCount = 1024.;\n    if ( fragColour.a < targetCount )\n    {\n        // blend a square big enough to hit targetCount\n        int kernelSize = int(ceil(sqrt(targetCount/fragColour.a)));\n        const int maxKernel = 32;\n        kernelSize = min(kernelSize,maxKernel);\n        ivec2 blockuv = (ifragCoord/kernelSize)*kernelSize;\n        for ( int i=0; i < maxKernel; i++ )\n        {\n            if ( i > kernelSize ) break;\n            for ( int j=0; j < maxKernel; j++ )\n            {\n                if ( j > kernelSize ) break;\n                fragColour += texelFetch(iChannel0,blockuv+ivec2(i,j),0);\n            }\n        }\n    }\n#endif\n#endif\n    \n    fragColour /= fragColour.a;\n\n\tvec4 blurred = texelFetch(iChannel1,ifragCoord,0);\n    blurred /= blurred.a;\n    \n    // adjust saturation\n    blurred = mix( blurred, vec4(dot(blurred,vec4(.2,.7,.1,0))), .5 );\n    \n\tvec4 exposure = blurred;\n    \n    // prevent it adjusting to impossibly dark colours\n\texposure += .02;//.003;//.0007; // arbitrary value chosen to look right for scene (also to limit graininess on really dark areas\n    \n    // how much to compensate? - fully! then modify blur radius in buf B\n    fragColour *= exposureModifier/exposure;\n\n//fragColour = blurred*2.;\n    \n    fragColour.rgb = HDRtoLDR( fragColour.rgb );\n    \n#ifdef SHOW_CURVE\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 f = HDRtoLDR(vec3( uv.x*3. ));\n    f = SRGBToLinear(f); // show curve without gamma correction (comment this out to see actual HDR->colour value mapping)\n    f -= (uv.y*1.04-.02);\n    fragColour.rgb = SRGBToLinear(fragColour.rgb);\n    fragColour.rgb = mix( vec3(1), fragColour.rgb, smoothstep( 0., 1.4, abs(f)/max(dFdx(f),vec3(1)/iResolution.y) ) );\n    fragColour.rgb = LinearToSRGB(fragColour.rgb);\n#endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Planet Blast by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// scene parameters\nconst float cloudiness = -.1;\n\nconst vec3 groundColour = vec3(.1,.15,.05); // grassy\n//const vec3 groundColour = vec3(.1); // dark grey (looks a bit brown because of tone mapping)\n//const vec3 groundColour = vec3(1); // snow\n\nconst vec3 lightDirection = normalize(vec3(2,2,5));\nconst vec3 lightColour = vec3(.3);\n\n\n// control the ray marcher\nconst float minStepLength = .05;\nconst int marchCount = 200;\nconst float shadowDrawDistance = 8.;\nconst float shadowStep = .05;\n\nconst float directLightProportion = 1./6.; // proportion of scattered rays used to sample direct light (balance graininess of god rays vs graininess of radiosity)\n//^ this shouldn't be affecting radiosity brightness, but it is! Bah!\n\nstruct ScatterData\n{\n\tfloat scatter; // proportion of rays scattered per metre - must be less than 1.0\n\tvec3 tint; // what proportion of RGB light remains after 1m - must be more than 0.0 - applies independent of scatter, so if this is 1,1,1 we still have reduction in visibility caused by scatter\n    vec3 emission; // amount of light added per 1m - should work for values > 1 but I'm not sure\n\tvec3 scatterTint; // particles can have one colour when light bounces off them and a different colour when light is absorbed by them - this can be [0,1]\n    float eccentricity; // bias the direction of scattering toward/away from (+ve/-ve) incident light direction\n};\n\nScatterData Mix( ScatterData a, ScatterData b, float c )\n{\n\t// this isn't perfect - interpolated media can have values that look different either of the two being blended\n    // e.g. this can cause a halo around very dense objects when they interpolate to the colour of the sky\n    // to reduce this effect, premultiply by scatter, to prioritise the parameters of the denser media\n    \n\t// but tint doesn't need this - since it is effectively the same as scatter (hard to explain but very easy to see this is true with a test)\n    \n    // fudge to prevent vacuum getting it wrong\n    const float vacuum = .001;\n    \n    a.scatter += vacuum;\n    b.scatter += vacuum;\n    \n    ScatterData m = \n        ScatterData(\n            mix( a.scatter, b.scatter, c ),\n            mix( a.tint, b.tint, c ),\n            mix( a.emission*a.scatter, b.emission*b.scatter, c ),\n            mix( a.scatterTint*a.scatter, b.scatterTint*b.scatter, c ),\n            mix( a.eccentricity*a.scatter, b.eccentricity*b.scatter, c )\n        );\n    return\n        ScatterData(\n            m.scatter - vacuum,\n            m.tint,\n            m.emission/m.scatter,\n            m.scatterTint/m.scatter,\n            m.eccentricity/m.scatter\n        );\n}\n\n\n// signed distance field (SDF) for a torus\n// returned value is distance of pos from the surface (negative if inside)\nfloat Torus( vec3 position, vec3 axis, float majorRadius, float minorRadius )\n{\n    axis = normalize(axis);\n    float perp = dot(axis,position);\n    position -= perp*axis;\n    return length( vec2( perp, length(position) - majorRadius ) ) - minorRadius;\n}\n\n\nfloat Billow( vec3 pos )\n{\n    return abs(Noise(pos)-.5)-.25;\n}\n    \nScatterData SampleMedia( vec3 pos )\n{\n    float planetRadius = 20.;\n    vec3 planetCentre = normalize(vec3(3,-3.5,0))*planetRadius + vec3(0,0,-4);\n    float altitude = length(pos-planetCentre) - planetRadius;\n    \n\n    ScatterData air = ScatterData( .7, vec3(1,.6,.3), vec3(0), vec3(.6,.8,1), .3 );\n    ScatterData space = ScatterData( .0, vec3(1), vec3(0), vec3(1), .0 );\n    \n    \n    vec3 groundColour = mix(\n        \t\t\t\t\t// green vs desert\n        \t\t\t\t\tmix(\n                                vec3(.1,.3,.05),\n                                vec3(.6,.5,.1),\n                                smoothstep( .6, .9, mix( Noise(pos), .5-.5*cos(pow(abs(pos.y/planetRadius),.333)*tau), .7 ) ) // 2 bands of desert either side of the equator\n                            ),\n        \t\t\t\t\t// ocean\n        \t\t\t\t\tvec3(.01,.03,.15),\n        \t\t\t\t\tsmoothstep( .45, .55, mix( Noise(pos/3.), Noise(pos/.8), .3 ) ) // smooth so we don't mind the lack of detail!\n        \t\t\t\t);\n    \n    ScatterData ground = ScatterData( 1., vec3(0), vec3(0), groundColour, .3 );\n    \n    \n    ScatterData cloud = ScatterData( .99, vec3(1), vec3(0), vec3(1), .0 );\n\n    // swirled position\n    vec3 swirlPos = pos - planetCentre;\n\t// rotate this so it's somewhere nice wrt camera (or rotate camera & light - but camera code is a bit locked to right-way-uppedness)\n    swirlPos.xy = swirlPos.xy*sqrt(2./4.) + swirlPos.yx*vec2(1,-1)*sqrt(2./4.);\n\n    float distFromSwirlSquared = dot(swirlPos.xz,swirlPos.xz);\n    float distFromSwirl = sqrt(distFromSwirlSquared);\n    float swirl = .7/(distFromSwirlSquared+.7);\n    float swirlAngle = swirl*7.;\n    swirlPos.xz = swirlPos.xz*cos(swirlAngle) + swirlPos.zx*vec2(1,-1)*sin(swirlAngle);\n    swirlPos.xz /= 2.; // scale against the swirl a bit\n\n    // push up the planet under the swirl\n//    altitude -= 2.*sin(distFromSwirl*4.+.25*tau)*swirl;\n    altitude -= 2.*sin(swirl*.75*tau)*swirl;\n    \n    float cloudSDF = pow( abs((altitude-.1)/.1), 2. )*.1;\n    cloudSDF += (Noise(swirlPos/.3)-.5)*.15;\n    cloudSDF *= .7;\n    cloudSDF += (Noise(swirlPos/.15)-.5)*.10;\n\n    vec3 uvw = pos;\n\t// billowy noise looks nice for clouds\n\t// but it makes the grid of the noise very visible (because I'm using a cheap and nasty noise function)\n    // so rotate it with each octave of noise\n    uvw = vec3( uvw.xy*sqrt(3./4.)+uvw.yx*vec2(-1,1)*sqrt(1./4.), uvw.z ).yzx;\n\tcloudSDF -= Billow(uvw/.15)*.05;\n    uvw = vec3( uvw.xy*sqrt(3./4.)+uvw.yx*vec2(-1,1)*sqrt(1./4.), uvw.z ).yzx;\n    cloudSDF -= Billow(uvw/.06)*.06;\n    uvw = vec3( uvw.xy*sqrt(3./4.)+uvw.yx*vec2(-1,1)*sqrt(1./4.), uvw.z ).yzx;\n    cloudSDF -= Billow(uvw/.03)*.03;\n\n    float cloudVariation = (Noise(swirlPos/1.2+2.)-.5)+cloudiness;\n    \n    cloudSDF -= mix( cloudVariation*.1, .05, smoothstep(.0,.2,swirl) );\n    \n    ground.emission = swirl*swirl*vec3(1,.2,.04)*30.*(1.-abs(Noise((pos - planetCentre)*(1.-.3*swirl)/.15)-.5)/.5);\n//^ ok mix for emission is borked, probably because of space\n    \n    ScatterData scatter =\n        Mix(Mix(Mix(\n            space,\n            air,\n            exp2( clamp( -altitude/.12, -15., 15. ) ) ),\n            cloud,\n            smoothstep( 1., -1., cloudSDF/.01 ) ),\n            ground, // ground overrides most things\n            smoothstep( 1., -1., altitude/(.001+swirl*.2) ) // break up the surface near the blast\n        );\n    \n    // laser is too powerful to blend sensibly with space & atmosphere - it should just add to them!\n    float laserMask = exp2( clamp( -distFromSwirlSquared/.05, -15., 15. ) );//.01/(distFromSwirlSquared+.01)//smoothstep( .8, 0., distFromSwirl )\n    scatter.emission +=  vec3(20,7,13)*1.*laserMask;\n    \n    return scatter;\n}\n\n\nvec3 SphereMap( vec2 uv )\n{\n    // uv is in the range [0,1)\n    // map this range onto a unit sphere, with a uniform distribution of points\n    \n    // use the fact that the surface area of a slice of a sphere is the same\n    // as the surface area of a cylinder with the height of the slice and the\n    // radius of the sphere\n    \n    // wrap the 2D space around a cylinder\n    float h = uv.y*2.-1.; // height up cylinder\n    float a = uv.x*tau; // angle around the circle\n    \n    // position on the circular slice of the cylinder at this height\n    vec2 v = vec2(sin(a),cos(a));\n    \n    // project onto the corresponding slice of the sphere\n    // by multiplying by width of sphere at this height\n    v = v * sqrt(1.-h*h);\n    \n    return vec3(v,h);\n}\n\n/* obsfuscated version:\nvec3 SphereMap( vec2 uv )\n{\n    return vec3( sin((uv.xx+vec2(0,.25))*6.283185)*2.*sqrt(uv.y*(1.-uv.y)), uv.y*2.-1. );\n}*/\n\n                 \nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 pixelIndex = ivec2(fragCoord);\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    fragCoord *= vec2(RESOLUTION_REDUCTION);\n    if ( fragCoord.x > iResolution.x || fragCoord.y > iResolution.y )\n    {\n        fragColour = vec4(.5,.5,.5,1);\n        return;\n    }\n#endif\n\n    fragColour = vec4(0);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    if ( iMouse.x < 1. && iMouse.y < 1. )\n        mouse = vec2(.41,.68);\n    \n    // slightly ugly hack: remap the range of mouse movements to give better camera control without re-adjusting all the magic numbers below.\n    mouse.y = pow(mouse.y,.5)*.7+.1;\n    \n\tvec2 camAngle = ((mouse-.5)*vec2(1.3,-.4999)+vec2(.2*1.3,.1))*6.283185;\n\n#ifdef ANIMATE\n//    camAngle.x+=iTime*.05;\n#endif\n    \n    float mouseH = .608 - mouse.y; // make high camera positions frame the whole torus\n    \n    vec3 camTarget = vec3(1,-1,-1);// + vec3(5.5,.5,-9)*1.6*mouseH;\n    float camDistance = 12.;\n    float camZoom = 1.;\n\n\tcamDistance *= exp2(3.*mouseH); // move camera in/out\n    \n    vec3 camPos = camDistance*vec3(-vec2(sin(camAngle.x),cos(camAngle.x))*cos(camAngle.y),sin(camAngle.y)).xzy+vec3(0,-3.5,0);\n    vec3 camK = normalize( camTarget-camPos );\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n\n    const int maxPasses = 100;\n    \n    int sampleCountMul = sampleCountMultiplier;\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    sampleCountMul *= (RESOLUTION_REDUCTION*RESOLUTION_REDUCTION);\n    sampleCountMul = (sampleCountMul*7)/8; // not sure why but without this res reduction always slows it down\n#endif        \n\tint numPasses = max(1,sampleCountMul*(320*180)/int(iResolution.x*iResolution.y));\n\n    int bounceCount = 0;\n    for ( int pass=0; pass < maxPasses; pass++ )\n    {\n        if ( pass >= numPasses ) break;\n\n        SeedRand( iFrame*numPasses+pass, fragCoord );\n\n        vec2 jitter = vec2(rand2())-.5;\n        vec3 ray = normalize( vec3( (fragCoord+jitter-iResolution.xy*.5)/iResolution.y, camZoom ) );\n\n        ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n\n\t\tfloat stepLength = minStepLength;\n\n        // First, march through space, allowing the ray to be deflected randomly by scatter\n        vec3 pos = camPos;\n        pos += ray * rand() * stepLength; // randomize initial step to hide aliasing errors (doesn't fix them, but hides them really well)\n        float lastH = stepLength;\n        vec3 lastTint = SampleMedia(pos).tint;\n        vec3 tint = vec3(1);\n        vec3 emission = vec3(0);\n\t\tbool lightRay = false;\n        float t = 0.;\n        for ( int i=0; i < marchCount; i++ )\n        {\n            //if ( max(max(tint.r,tint.g),tint.b) <= .01 ) break; // early out when rays have almost no effect - this doesn't seem to improve performance\n            \n            // step through media [step size modified by probability]\n            ScatterData scatter = SampleMedia(pos);\n\n            float h = stepLength*(1. + .9*(rand()*2.-1.)); // adjust steps randomly to hide aliasing errors\n\n            // experimenting with variable step size\n            // at the moment it just increases with distance, so rays can travel further but become less accurate\n\t\t\t// I could do this adaptively, but that's more complicated\n\t\t\tstepLength *= 1.01;\n\n            // accumulate average tint\n            tint *= pow(max(vec3(.00000001),mix(scatter.tint,lastTint,.5)),vec3(lastH));\n\n            float pointH = mix(lastH,h,.5); // length of step represented by this scatter sample        \n\n            // accumulate emission with current tint applied        \n            emission += tint*(scatter.emission * pointH);  // pretty sure emission should be multiplied not pow'd, so it's additive not exponential\n\n            if ( pow(max(.00000001,1.-scatter.scatter), pointH) < rand() )// [modified by average of last/next step size]\n            {\n                if ( rand() < directLightProportion ) // proportion of rays which become direct light rays\n                {\n                \t// direct light\n                    // apply the scatter tint and point the ray at the light\n\n                    // correct brightness by proportion of rays not scattered this way\n                    tint /= directLightProportion;\n\t                tint *= scatter.scatterTint;\n\n                    // apply a curve for eccentricity\n                    // this uses the derivative of the curve used for the random scatter\n                    // we want to say \"how much light is scattered in this direction\" rather than \"what direction should this light be scattered in\"\n                    float cos0 = dot(ray,lightDirection);\n                    float ae = abs(scatter.eccentricity);\n                    \n                    float se = (scatter.eccentricity<0.)?-1.:1.; // sign(eccentricity) but without 0.0\n\t\t\t\t\t//float cos1 = (pow(cos0*se*.5+.5,1.-ae)*2.-1.)*se;\n\t\t\t\t\t// dcos1/dcos0 (computed by wolframalpha.con)\n                    float dcos1dcos0 = (1. - ae)*pow( max(.00000001,0.5 - se*0.5*cos0), -ae );\n\n                    // hack to reduce speckly artefacts caused by lighting amplified by multiple bounces\n                    // these speckles are technically correct, but they occur as a result of highly unlikely combinations of bounces\n                    // so it will take a very long time for them to average out\n\t\t\t\t\tif ( bounceCount > 0 ) dcos1dcos0 = clamp(dcos1dcos0,0.,10.);\n                    \n                    tint *= dcos1dcos0;\n\n                    // break out of this loop so we can do a separate shadow-tracing loop which doesn't scatter\n\t\t            ray = lightDirection;\n                    lightRay = true;\n                    break;\n                }\n                else\n                {\n                    vec3 newRay = SphereMap( vec2(rand2()) );\n\n                    // eccentricity - push & scale the sphere along the view ray to bias rays in same/opposite direction\n                    // amount of push such that at -1 or 1 the near side of the spheroid hits 0 and the far side hits infinity\n                    float cos0 = dot(newRay,ray);\n\n                    // Apply a curve to the distribution of rays.\n                    // This isn't ideal, it tends to create a sharp bright spot around the light rather than a softer blob\n                    // but it has the advantage that it reduces to 1-dimension which makes it easier to compute the derivative, \n                    // which is needed for direct light.\n                    // We can do this in 1D because a slice through the surface of a sphere has the same area for a given\n                    // thickness of slice, regardless of where the slice is positioned. (napkin ring problem)\n                    float ae = 1.-abs(scatter.eccentricity);\n                    float se = (scatter.eccentricity<0.)?-1.:1.;\n                    float cos1 = (pow(max(.00000001,cos0*se*.5+.5),ae*ae)*2.-1.)*se;\n                    newRay = normalize(newRay - cos0*ray);\n                    newRay = ray*cos1 + newRay*sqrt(max(.00000001,1.-cos1*cos1));\n                    ray = newRay;\n\n                    // correct brightness by proportion of rays not scattered this way\n                    // to conserve energy (this seems to have a bug, as the image changes significantly when I change directLightProportion)\n                    tint /= 1.-directLightProportion;\n\n                    // break energy conservation to prevent speckles caused by rare multiply scattered rays\n                    // technically they are correct, but they're so rare the speckles they cause are unlikely\n                    // to ever be corrected.\n                    // reduce this amount for faster convergence but less radiosity\n\t\t\t\t\ttint = clamp(tint,0.,5.);\n                    \n                    tint *= scatter.scatterTint;\n                }\n                \n                bounceCount++;\n            }\n\n            pos += ray*h;\n            t += h;\n            lastH = h;\n            lastTint = scatter.tint;\n        }\n                \n        \n        if ( directLightProportion > 0. && lightRay )\n        {\n            // haven't balanced this for variable step size, so use a const step\n            vec3 lastAbsorption;\n            float shadowT = 0.;\n            for ( int i=0; i < int(shadowDrawDistance/shadowStep); i++ )\n            {\n                // step through media [step size modified by probability]\n                ScatterData scatter = SampleMedia(pos);\n\n                float h = shadowStep; // todo: port the random stuff here too, and change the loop the same way\n                \n                // accumulate average tint\n               \t// don't scatter, just count the proportion of scattered rays as a darkening tint\n                vec3 absorption = scatter.tint*(1.-scatter.scatter);\n                if ( i > 0 )\n                {\n                \ttint *= pow(max(vec3(.00000001),mix(absorption,lastAbsorption,.5)),vec3(lastH));\n                }\n\n                pos += ray*h;\n                shadowT += h;\n                lastH = h;\n                lastAbsorption = absorption;\n            }\n            \n            emission += lightColour*tint;\n        }\n        fragColour.rgb += emission;\n\n        fragColour.a += 1.;\n    }\n\n\t// this prevents NaNs/INFs - but it's good to turn it off for testing, since I like to know what's causing bad numbers\n\tfragColour.rgb = clamp( fragColour.rgb, 0., 10000.*fragColour.a );\n    \n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    // precompute checkerboard of negative/positive values\n    // required by SampleTextureCatmullRom4Samples\n    fragColour = (pixelIndex.x&1)==(pixelIndex.y&1) ? fragColour : -fragColour;\n#endif\n    \n    if ( iFrame > 0 && iMouse.z <= 0. )\n    {\n        fragColour += texelFetch(iChannel0,pixelIndex,0)\n#ifdef ANIMATE\n            *.93\n#endif\n            ;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// quality adjustments - to improve fps\n//#define RESOLUTION_REDUCTION 3 this doesn't work with the local exposure code\nconst int sampleCountMultiplier = 7; // increase this until fps drops\n#define MOSAIC_PREVIEW 1\n\n\n// maths constants\nconst float tau = 6.28318530718;\nconst float phi = 1.61803398875; // golden ratio\n\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\n// sequential rand functions - return a different value each time\nuint seed = 1u;\n\nvoid SeedRand( int frame, vec2 fragCoord )\n{\n    seed = coord3(uvec3(frame,fragCoord));\n}\nfloat rand() { return hash1(coord1(seed++)); }\nvec2 rand2() { return hash2(coord1(seed++)); }\nvec3 rand3() { return hash3(coord1(seed++)); }\nvec4 rand4() { return hash4(coord1(seed++)); }\n\n\n// continuous noise\n// cheaper and uglier than perlin\nfloat Noise( vec3 pos )\n{\n    uvec3 p = uvec3(ivec3(floor(pos))+0x8000000);\n    vec3 f = smoothstep(.0,1.,fract(pos));\n    uvec2 d = uvec2(0,1);\n    \n    return\n        mix(\n        \tmix(\n                mix( hash1(coord3(p+d.xxx)), hash1(coord3(p+d.yxx)), f.x ),\n                mix( hash1(coord3(p+d.xyx)), hash1(coord3(p+d.yyx)), f.x ),\n                f.y\n            ),\n        \tmix(\n                mix( hash1(coord3(p+d.xxy)), hash1(coord3(p+d.yxy)), f.x ),\n                mix( hash1(coord3(p+d.xyy)), hash1(coord3(p+d.yyy)), f.x ),\n                f.y\n            ),\n            f.z\n        );\n}\n\n\n// catmull-rom texture sampler, from https://www.shadertoy.com/view/4tyGDD by Giliam de Carpentier\nvec4 SampleTextureBilinearlyAndUnpack(sampler2D tex, vec2 uv)\n{\n    vec4 sample_color = texture(tex, uv, 0.0);\n#ifdef PACK_SIGNED_TO_UNSIGNED\n    sample_color = 2.0 * sample_color - 1.0;\n#endif // PACK_SIGNED_TO_UNSIGNED\n    return sample_color;\n}\n \nvec4 SampleTextureCatmullRom4Samples(sampler2D tex, vec2 uv, vec2 texSize)\n{\n    // Based on the standard Catmull-Rom spline: w1*C1+w2*C2+w3*C3+w4*C4, where\n    // w1 = ((-0.5*f + 1.0)*f - 0.5)*f, w2 = (1.5*f - 2.5)*f*f + 1.0,\n    // w3 = ((-1.5*f + 2.0)*f + 0.5)*f and w4 = (0.5*f - 0.5)*f*f with f as the\n    // normalized interpolation position between C2 (at f=0) and C3 (at f=1).\n \n    // half_f is a sort of sub-pixelquad fraction, -1 <= half_f < 1.\n    vec2 half_f     = 2.0 * fract(0.5 * uv * texSize - 0.25) - 1.0;\n \n    // f is the regular sub-pixel fraction, 0 <= f < 1. This is equivalent to\n    // fract(uv * texSize - 0.5), but based on half_f to prevent rounding issues.\n    vec2 f          = fract(half_f);\n \n    vec2 s1         = ( 0.5 * f - 0.5) * f;            // = w1 / (1 - f)\n    vec2 s12        = (-2.0 * f + 1.5) * f + 1.0;      // = (w2 - w1) / (1 - f)\n    vec2 s34        = ( 2.0 * f - 2.5) * f - 0.5;      // = (w4 - w3) / f\n \n    // positions is equivalent to: (floor(uv * texSize - 0.5).xyxy + 0.5 +\n    // vec4(-1.0 + w2 / (w2 - w1), 1.0 + w4 / (w4 - w3))) / texSize.xyxy.\n    vec4 positions  = vec4((-f * s12 + s1      ) / (texSize * s12) + uv,\n                           (-f * s34 + s1 + s34) / (texSize * s34) + uv);\n \n    // Determine if the output needs to be sign-flipped. Equivalent to .x*.y of\n    // (1.0 - 2.0 * floor(t - 2.0 * floor(0.5 * t))), where t is uv * texSize - 0.5.\n    float sign_flip = half_f.x * half_f.y > 0.0 ? 1.0 : -1.0;\n \n    vec4 w          = vec4(-f * s12 + s12, s34 * f); // = (w2 - w1, w4 - w3)\n    vec4 weights    = vec4(w.xz * (w.y * sign_flip), w.xz * (w.w * sign_flip));\n \n    return SampleTextureBilinearlyAndUnpack(tex, positions.xy) * weights.x +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zy) * weights.y +\n           SampleTextureBilinearlyAndUnpack(tex, positions.xw) * weights.z +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zw) * weights.w;\n}\n", "buffer_b_code": "// Adaptive Exposure by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// blur the image so I can sample exposure locally\n\nconst vec2 exposureRadius = vec2(.03); // low values mean space and ground and horizon can all be exposed at once!\n// this adds a bit of a comic book feel to it - where details are emphasized more than overall brightness\n\nconst float globalExposure = .4; // 0.0 = use only nearby exposure, 1.0 = sample exposure over entire image, 0.5 = 50/50 blend\n\nvec2 BoxMuller( vec2 rand )\n{\n//    float r = sqrt(-2.*log(rand.x));\n    float a = tau * rand.y;\n\n// alternative curve, to hang onto small details AND do larger ones\nfloat r = -2.*log(max(.0001,rand.x));\n//float r = pow(-2.*log(rand.x),3.); // push it even further - weird\n    \n    return r*vec2(sin(a),cos(a));\n}\n\n\n// blurred image of Buffer A\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    /*would like it to be resolution independent\n\t=> take random samples from buf a spread over a gaussian (normal) distribution\n\tand feedback, so high res just takes longer to converge*/\n    // ooh box muller transform: https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n\n    vec2 blurRadius = sqrt(iResolution.x*iResolution.y) * exposureRadius;\n    \n    fragColour = vec4(0);\n    const int numPasses = 10;\n    for ( int pass = 0; pass < numPasses; pass++ )\n    {\n        SeedRand( iFrame*numPasses+pass, fragCoord );\n    \n    \tvec2 tappos;\n        if ( rand() > globalExposure )\n        {\n        \ttappos = BoxMuller( rand2() ) * blurRadius;\n            tappos = clamp(fragCoord+tappos,vec2(0),iResolution.xy-1.);\n        }\n        else\n        {\n            tappos = rand2()*(iResolution.xy-1.);\n        }\n\n        fragColour += texelFetch( iChannel0, ivec2(tappos), 0 );\n\t}\n    \n    // this might need *.99 or something\n    if ( iFrame > 0 && iMouse.z <= 0. )\n    {\n        fragColour += texelFetch( iChannel1, ivec2(fragCoord), 0 );\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtySWD.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[535, 535, 567, 567, 652], [654, 654, 686, 686, 768], [770, 770, 797, 797, 1288], [1290, 1290, 1348, 1348, 3582]], "test": "untested"}
{"id": "wtKSRG", "name": "Quasicrystal-v1", "author": "natpbs", "description": "An implementation of the projection method to generate a non-periodic tiling of the plane\nReference: §2.6.1 and §2.6.3 from Marjorie Senechal - Quasicrystals and Geometry (1996, Cambridge University Press).", "tags": ["tiling", "tessellation", "penrose"], "likes": 15, "viewed": 763, "published": 3, "date": "1583164183", "time_retrieved": "2024-07-30T21:21:01.297923", "image_code": "// by natpbs\n// suggested usage: click the 'pause' button\n// and drag the mouse around on the canvas\n\n//#define DRAW_GRID\n#define FAST_VERSION\n#define DEBUG\n\nstruct vec5 {\n vec2 a;\n vec3 b;\n};\n\nstruct mat5 {\n mat2 a; mat2x3 b;\n mat3x2 c; mat3 d;\n};\n\nconst float tau = 2.*acos(-1.);\nconst float a = sqrt(2./5.);\nconst float b = 2.*acos(-1.)/5.;\nconst mat5 B = mat5(\n a * mat2(\n  1.,cos(b),\n  0.,sin(b)\n ),\n a * mat2x3(\n  cos(2.*b),cos(3.*b),cos(4.*b),\n  sin(2.*b),sin(3.*b),sin(4.*b)\n ),\n a * mat3x2(\n  1.,cos(2.*b),\n  0.,sin(2.*b),\n  sqrt(.5),sqrt(.5)\n ),\n a * mat3(\n  cos(4.*b),cos(b),cos(3.*b),\n  sin(4.*b),sin(b),sin(3.*b),\n  sqrt(.5),sqrt(.5),sqrt(.5)\n )\n);\n\nvec3 offset3;\nvec5 offset5;\n\nvec5 fiveFromTwo(vec2 p2) {\n vec5 p5 = vec5(\n  B.a * p2,\n  B.b * p2\n );\n return p5;\n}\n\nvec5 fiveFromThree(vec3 p3) {\n vec5 p5 = vec5(\n  B.c * p3,\n  B.d * p3\n );\n return p5;\n}\n\nvec2 twoFromFive(vec5 p5) {\n vec2 p2 = p5.a * B.a + p5.b * B.b;\n return p2;\n}\n\nvec3 threeFromFive(vec5 p5) {\n vec3 p3 = p5.a * B.c + p5.b * B.d;\n return p3;\n}\n\nvec5 snapToGrid(vec5 p) {\n // note that floor(x+.5)\n p.a = floor(.5 + p.a);\n p.b = floor(.5 + p.b);\n return p;\n}\n\nvec5 getNeighbor(vec5 p, int k) {\n float sig = (k&1) == 0 ? 1. : -1.;\n k >>= 1;\n if (k<2) {\n  p.a[k] += sig;\n } else {\n  p.b[k-2] += sig;\n }\n return p;\n}\n\nbool isInWindow(vec5 p5) {\n vec3 p = threeFromFive(p5);\n    p -= offset3;\n const vec3 base[5] = vec3[](\n  vec2(1,0) * B.c,\n  vec2(0,1) * B.c,\n  vec3(1,0,0) * B.d,\n  vec3(0,1,0) * B.d,\n  vec3(0,0,1) * B.d\n );\n\tfor (int i=0; i<4; i++) {\n\t\tfor (int j=i+1; j<5; j++) {\n\t\t\tvec3 n = normalize(cross(base[i],base[j]));\n\t\t\tfloat d = abs(dot(p,n));\n            float t = 0.;\n            for (int k=0; k<5; k++) {\n                if (k==i || k==j) {\n                    continue;\n                }\n                t += abs(dot(base[k],n));\n            }\n            if (d > .5*t) {\n                return false;\n            }\n\t\t}\n\t}\n return true;\n}\n\nfloat drawPoint(vec2 p, vec2 q) {\n float d = distance(p,q);\n d = smoothstep(-.1,0.,-d);\n return d;\n}\n\nfloat drawLine(vec2 p, vec2 a, vec2 b) {\n vec2 ap = p - a;\n vec2 ab = b - a;\n float t = dot(ap,ab) / dot(ab,ab);\n t = clamp(t,0.,1.);\n vec2 q = a + t * ab;\n float d = distance(p,q);\n d = smoothstep(-.03,0.,-d);\n return d;\n}\n\nfloat drawGrid(vec5 p, vec5 q) {\n vec2 a = abs(p.a - q.a);\n vec3 b = abs(p.b - q.b);\n float d = max(\n  max(a.x,a.y),\n  max(b.x,max(b.y,b.z))\n );\n d = smoothstep(.48,.5,d);\n return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n fragColor = vec4(vec3(0),1);\n vec2 p2 = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.x;\n p2 *= 16.;\n vec5 p5 = fiveFromTwo(p2);\n    if (iMouse.z > 0.) {\n        offset3 = vec3(\n            1. * (iMouse.xy - .5*iResolution.xy) / iResolution.x,\n            0\n        );\n        offset5 = fiveFromThree(offset3);\n        p5.a += offset5.a;\n        p5.b += offset5.b;\n    } else {\n        offset3 = vec3(0);\n        offset5 = vec5(vec2(0),vec3(0));\n    }\n vec5 q5 = snapToGrid(p5);\n vec2 q2 = twoFromFive(q5);\n vec3 q3 = threeFromFive(q5);\n float d = length(q3);\n fragColor.r += drawPoint(p2,q2);\n int count = 0;\n for (int j=0; j<10; j++) {\n  vec5 r5 = getNeighbor(q5,j);\n  if (isInWindow(r5)) {\n   count++;\n   vec2 r2 = twoFromFive(r5);\n   fragColor.r += drawPoint(p2,r2);\n   fragColor.b += drawLine(p2,q2,r2);\n   #ifndef FAST_VERSION\n   for (int k=0; k<10; k++) {\n       if ((k|1)==(j|1) && (k&1) != (j&1)) {\n           continue;\n       }\n    vec5 s5 = getNeighbor(r5,k);\n    if (isInWindow(s5)) {\n     vec2 s2 = twoFromFive(s5);\n     fragColor.r += drawPoint(p2,s2);\n     fragColor.b += drawLine(p2,r2,s2);\n    }\n   }\n   #endif\n  }\n }\n    #ifdef DRAW_GRID\n\t\tfragColor.rgb += .4*drawGrid(p5,q5);\n    #endif\n    #ifdef DEBUG\n if (!isInWindow(q5)) {\n  fragColor.rb = vec2(1.);\n }\n count = 0\n  | ((count & 1) << 4)\n  | ((count & 2) << 1)\n  | ((count & 4) >> 1)\n  | ((count & 8) >> 5);\n fragColor.rgb += float(count) / 64.;\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[692, 692, 719, 719, 777], [779, 779, 808, 808, 866], [868, 868, 895, 895, 945], [947, 947, 976, 976, 1026], [1028, 1028, 1053, 1079, 1140], [1142, 1142, 1175, 1175, 1295], [1937, 1937, 1970, 1970, 2037], [2039, 2039, 2079, 2079, 2262], [2264, 2264, 2296, 2296, 2448], [2450, 2450, 2505, 2505, 3944]], "test": "untested"}
{"id": "tlKXzK", "name": "morifuji-triange1", "author": "morimorikochan", "description": "triange1", "tags": ["triangle"], "likes": 1, "viewed": 577, "published": 3, "date": "1583162526", "time_retrieved": "2024-07-30T21:21:02.201507", "image_code": "#define PI 3.141592653589793\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n     vec2 uv = (fragCoord.xy/iResolution.xy);\n\n    float rad1 = cos(PI/3.);\n    float rad2 = sin(PI/3.);\n\n    float io1 = step(.5, mod(uv.y*10., 1.0));\n\n    float line2 = mod(uv.y * 10. *rad1 + uv.x *10. * rad2, 1.);\n    float io2 = step(.5, line2);\n\n    float line3 = mod(uv.y * 10. *rad1 - uv.x *10. * rad2 , 1.);\n    float io3 = step(.5, line3);\n\n    float io = (io1 + io2 + io3)/3.;\n\n    fragColor = vec4(vec3(io), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 54, 54, 128], [130, 130, 186, 186, 618]], "test": "untested"}
{"id": "tlKSzK", "name": "raymarching reflections", "author": "isk", "description": "using a reflected ray into a cubemap to pick surface colour.", "tags": ["raymarching", "reflection"], "likes": 6, "viewed": 483, "published": 3, "date": "1583159802", "time_retrieved": "2024-07-30T21:21:03.050238", "image_code": "// anti-aliasing samples. set to 0 to disable AA.\n#define AA 2\n\n// how many times to calculate bounced reflection rays.\n#define REFLECT 2\n\nconst float PI=acos(-1.);\nconst float EPS=.001,MAX=100.;\nconst int ITER=256;\n\nfloat ycyl(vec3 p, float r) {\n    return length(p.xz)-r;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat ztor(vec3 p, vec2 r) {\n    vec2 circ=vec2(length(p.xz)-r.x,p.y);\n    return length(circ)-r.y;\n}\n\nfloat scene(vec3 p) {\n    float d=MAX;\n    d=min(d,ycyl(p,.5));\n    d=min(d,sph(abs(p)-1.,.6));\n    d=min(d,ztor(p, vec2(1., .3)));\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 D=vec2(.001,0);\n    return normalize(scene(p)-vec3(scene(p-D.xyy),scene(p-D.yxy),scene(p-D.yyx)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t=0.,d;\n    for(int i=0; i<ITER; ++i){\n        d=scene(ro+rd*t);\n        if(abs(d)<EPS) return t;\n        t+=d;\n        if(t>MAX) return t;\n    }\n    return t;\n}\n\nvec3 ray(vec2 uv, vec3 ro, vec3 poi){\n    vec3 f=normalize(poi-ro),\n         r=normalize(cross(f,vec3(0,1,0))),\n         u=cross(r,f),\n         c=ro+f,\n         i=c+r*uv.x+u*uv.y;\n    return normalize(i-ro);\n}\n\nvec3 render(vec2 uv){\n    float orbit=-2.*PI*iMouse.x/iResolution.x;\n    vec3 ro;\n    if (iMouse.z>0.)\n        ro=vec3(sin(orbit)*5.,-2.*iMouse.y/iResolution.y+1.,cos(orbit)*5.);\n    else\n        ro=vec3(sin(iTime),cos(iTime),5.);\n    vec3 rd=ray(uv,ro,vec3(0));\n    vec3 col=texture(iChannel0,rd).rgb;\n    float t;\n    vec3 p,n;\n    for(int i=0; i<REFLECT; ++i){\n        t=march(ro,rd);\n        if(t>=MAX) return col;\n        p=ro+rd*t;\n        n=normal(p);\n        rd=reflect(rd,n);\n        ro=p+rd*EPS;\n        col=texture(iChannel0,rd).rgb;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col=vec3(0);\n#if AA>1\n    vec2 aao;\n    const float AAINC=1./float(AA);\n    for (aao.x=-.5; aao.x<.5; aao.x+=AAINC)\n        for (aao.y=-.5; aao.y<.5; aao.y+=AAINC)\n            col+=render(uv+aao/iResolution.y);\n    col/=float(AA*AA);\n#else\n    col+=render(uv);\n#endif\n    fragColor=vec4(col,1.);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 246, 246, 275], [277, 277, 305, 305, 331], [333, 333, 361, 361, 434], [436, 436, 457, 457, 583], [585, 585, 605, 605, 715], [717, 717, 747, 747, 919], [921, 921, 958, 958, 1130], [1132, 1132, 1153, 1153, 1700], [1702, 1702, 1756, 1756, 2120]], "test": "untested"}
{"id": "WtVSRV", "name": "raymarched tunnel", "author": "isk", "description": "raymarched version of the classic tunnel effect", "tags": ["raymarching", "tunnel"], "likes": 3, "viewed": 311, "published": 3, "date": "1583157339", "time_retrieved": "2024-07-30T21:21:03.899966", "image_code": "const int ITER=256;\nconst float MAX=100.,EPS=.001;\n\nvec3 ray(vec2 uv, vec3 ro, vec3 poi) {\n    vec3 f=normalize(poi-ro),\n         r=normalize(cross(vec3(0,1,0),f)),\n         u=cross(f,r),\n         m=ro+f,\n         p=m+r*uv.x+u*uv.y;\n    return normalize(p-ro);\n}\n\nfloat zcyl(vec3 p, float r) {\n    return length(p.xy)-r;\n}\n\nfloat scene(vec3 p) {\n    return .5-zcyl(p,.5);\n}\n\nfloat map(vec3 ro, vec3 rd) {\n    float t=0.,d;\n    for(int i=0; i<ITER; ++i) {\n        d=scene(ro+rd*t);\n        if(abs(d)<EPS) return t;\n        t+=d;\n        if(t>MAX) return t;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    const vec2 D=vec2(.001,0);\n    return normalize(scene(p)-vec3(scene(p-D.xyy),scene(p-D.yxy),scene(p-D.yyx)));\n}\n\nvec3 march(vec2 uv) {\n    vec3 ro=vec3(sin(iTime)/2.,sin(iTime*.8)*.2,cos(iTime)/2.),rd=ray(uv,ro,vec3(0));\n    \n    float t=map(ro, rd);\n    \n    if (t<MAX) {\n        vec3 p=ro+rd*t;\n        vec3 n=normal(p);\n        vec2 uv=vec2(p.z,atan(p.y,p.x));\n        vec3 tex=texture(iChannel0,uv-vec2(iTime,.0)).rgb;\n        return tex/max(abs(-p.z),1.);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col=march(uv);\n    fragColor=vec4(col,1);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 90, 90, 262], [264, 264, 293, 293, 322], [324, 324, 345, 345, 373], [375, 375, 404, 404, 577], [579, 579, 600, 600, 716], [718, 718, 739, 739, 1098], [1100, 1100, 1155, 1155, 1265]], "test": "untested"}
{"id": "WlVXzK", "name": "knit", "author": "FabriceNeyret2", "description": "made with 1 torus section + symmetries \n\nmouse controls camera.", "tags": ["raymarching", "sdf", "knot", "short", "knitting"], "likes": 7, "viewed": 331, "published": 3, "date": "1583152200", "time_retrieved": "2024-07-30T21:21:04.768644", "image_code": "// variant of https://shadertoy.com/view/ttKSDm\n\nfloat PI = 3.14159,\n       r = .16,                                // rope radius\n       d = 1.32, e = 4.5, f = 3.;\n\n#define FRAME 0\n\n#define T(q)     ( length(vec2(length(q.xy)-1.,q.z)) - r )        // torus\n#define S(a,da)  ( abs(mod(atan(q.y,q.x)-a+PI, 2.*PI) -PI) - da ) // section\n#define Ts(q,a,da) max(T(q),S(a,da) )                             // torus section\n#define R(a)       mat2( cos( a + vec4(0,33,11,0)) )              // rotation\n\nfloat knot0(vec3 p) {                           // --- half stitch\n    vec3 q; float t, a=p.y+f/4.;\n  //p.z += .4*(1.-.5*a*a),                      // depth twist\n    p.z += .4*cos(1.5*a),                       // depth twist\n    p.x = mod(p.x-d,2.*d)-d;                    // + rank periodicity\n    q = p, t = Ts(q,PI/2.,1.55*PI/2.);          // half stitch\n    return t;\n}\nfloat knot(vec3 p) {                            // --- full rank of stitch\n    vec3 q=p; float t;\n    q.y = mod(q.y,e)-f,                         // + vertical periodicity\n    t = knot0(q);                                    // top half stitch\n    q.y = -1.5-q.y,  q.x -= d, t = min(t, knot0(q)); // bottom symmetric\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = 1e9,tx,ty,tz;\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)),     // ray direction\n          P = 25./q, p, a, qa;                 // marching point along ray \n    vec2  M = (length(iMouse.xy)<20.) ? vec2(0): 3.14*(2.*iMouse.xy-q.xy)/q.y,\n        //C = 3.14*vec2(-.3,.4),               // camera\n          C = M==vec2(0) ? vec2(iTime) : M;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.04 )\n        p = P,\n        p.xz *= R(C.x), p.yz *= R(C.y),        // camera rotation\n        q = p,\n#if FRAME\n        a = abs(qa=q),                         // draw frame\n        t = max(min( ty= max(a.x,a.z) -.01, min( tx= max(a.z,a.y) -.01 ,tz= max(a.x,a.y) -.01 )  ),length(q)-2.),\n#endif\n        t = min(t, knot(p)),                   // odd rank\n        p.y -= e/2., \n        t = min(t, knot(p)),                   // even rank\n        P += t*D;                              // step forward = dist to obj\n\n#if FRAME                                      // --- color frame\n    if (t==tx) O.gb*=.4+.4*sign(qa.x);         // x axis: red   ( whiter on positive side )\n    if (t==ty) O.rb*=.4+.4*sign(qa.y);         // y axis: green\n    if (t==tz) O.rg*=.4+.4*sign(qa.z);         // z axis: blue\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 518, 563, 871], [872, 872, 892, 946, 1204]], "test": "untested"}
{"id": "WtySzV", "name": "Surface Forces*", "author": "wyatt", "description": "3 interacting color channels", "tags": ["fluid"], "likes": 24, "viewed": 554, "published": 3, "date": "1583105480", "time_retrieved": "2024-07-30T21:21:05.661257", "image_code": "// Fork of \"Surface Forces\" by wyatt. https://shadertoy.com/view/3tKXWm\n// 2020-03-01 23:03:05\n\n// Fork of \"Last Fluid\" by wyatt. https://shadertoy.com/view/3tcSDj\n// 2020-02-28 04:10:38\n\nfloat ln (vec3 p, vec3 a, vec3 b) {return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));}\nMain {\n    vec4 b = B(U);\n    Neighborhood;\n    vec3 no = normalize(0.3*b.xyz+vec3(grdx+grdy+grdz,2)),\n        re = reflect(no,vec3(0,0,1));\n    Q.xyz = abs(0.5+0.8*b.xyz*mat3(.6,.7,.7,.3,.6,.1,-.4,.9,.1));\n    float l = ln(vec3(0.5,0.5,6)*R.xyy,vec3(U,b.x),vec3(U,b.x)+re);\n    Q *= 0.5*exp(-.001*l)+0.5*exp(-.01*l)+exp(-0.1*l);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fluid step 1 : d/dt V = d/dx P\n\nMain {\n    \n    vec3 f = A(U).xyz;\n\tQ = B(U-0.5*B(U-0.5*B(U).xy).xy);\n    Neighborhood;\n    Q.xy -= grd;  \n    Neighborhood3;\n    vec2 g = grdx*(3.*f.y-f.z)+grdy*(3.*f.z-f.x)+grdz*(3.*f.x-f.y);\n    Q.xy += 0.05*g;\n\tQ.xy *= 0.99;\n   Border Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fluid step 2 : d/dt P = d/dx V\n\nMain {\n\tQ = B(U-0.5*A(U-0.5*A(U).xy).xy);\n    Neighborhood;\n    Q.w  -= div;\n    Neighborhood2;\n    Q.xyz -= 0.25*(N*n.y-S*s.y+E*e.x-W*w.x).xyz;\n    if (length(Q.xyz)>0.) \n        Q.xyz = mix(Q.xyz,normalize(Q.xyz),0.01);\n    if (iFrame < 1) Q = vec4(0);\n    Input\n        Q.xyz = sin(vec3(1,2,3)*iTime);\n    Border Q.x = -1.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood2 vec4 N = B(U+vec2(0,1)), E = B(U+vec2(1,0)), S = B(U-vec2(0,1)), W = B(U-vec2(1,0)), M = 0.25*(n+e+s+w);\n#define Neighborhood3 n = D(U+vec2(0,1)), e = D(U+vec2(1,0)), s = D(U-vec2(0,1)), w = D(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define grd 0.25*vec2(e.w-w.w,n.w-s.w)\n#define grdx 0.25*vec2(e.x-w.x,n.x-s.x)\n#define grdy 0.25*vec2(e.y-w.y,n.y-s.y)\n#define grdz 0.25*vec2(e.z-w.z,n.z-s.z)\n#define grd2 0.25*vec2(E.x-W.x,N.x-S.x)\n#define div 0.25*(e.x-w.x+n.y-s.y)\n#define Main void mainImage(out vec4 Q, vec2 U)\n#define I 20.\n#define loop for (float i = -I; i <= I; i++)\n#define std vec4(16,8,4,1)\n#define gau(x) 0.3989422804/std*exp(-x*x/std/std)\n#define Input if ((iMouse.z>0.&&length(U-iMouse.xy)<30.)||(iFrame<1&&length(U-0.5*R)<26.))\n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)", "buffer_c_code": "// gaussian blur pass 1\nMain {\n\tQ = vec4(0);\n\tloop Q += gau(i) * B(U+vec2(i,0));\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// gaussian blur pas2\nMain {\n\tQ = 0.1*D(U);\n\tloop Q += gau(i) * C(U+vec2(0,i));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtySzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 223, 223, 275]], "test": "untested"}
{"id": "WlGXRK", "name": "day 73", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 39, "viewed": 845, "published": 3, "date": "1583101086", "time_retrieved": "2024-07-30T21:21:06.550879", "image_code": "\n// SHOUTOUT TO LUNA, SHE HAS AWESOME GOLD STUFF shadetoy.com/user/yx\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 10.;\n    float scale = 0.00 + dot(uvn,uvn)*0.05;\n    float chromAb = dot(uvn,uvn)*4.;\n    vec2 offs = vec2(0) + texture(iChannel1, uv + iTime*4.).xz*0.001;\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.99;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.x += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.y += texture(iChannel0, target).y;\n    \tradial.z += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    \n    \n    \n    radial /= steps;\n    \n    fragColor = texture(iChannel0, uv)*0.8 + radial*1.5;\n    \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.7);\n    fragColor *= 0.6;\n    fragColor = pow(fragColor, vec4(0.45));\n\n    \n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    //fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"day 75\" by jeyko. https://shadertoy.com/view/3tGXRK\n// 2020-03-01 19:53:26\n\nvec3 attenuation = vec3(1);\n\n#define mx (iTime + 20.*iMouse.x/iResolution.x)\n\n#define pmod(p,x) mod(p,x) - x*0.5\n\n#define dmin(a,b) a.x < b.x ? a : b\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\n#define modDist 1.\n#define HEIGHT 0.5\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define pal(a,b,c,d,e) ( (a) + (b)*sin(tau*((c)*(d) +(e)) ))\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n\nfloat side = 1.;\nvec3 glow = vec3(0);\nvec3 glowB = vec3(0);\n\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e6);\n\n    p.y += sin(p.z + p.x*4.  + iTime)*0.02;\n    \n    \n    vec3 q = p;\n    \n    vec2 id = floor(p.xz);\n    p.xz = pmod(p.xz, modDist);\n    vec3 j = p;\n    \n    float dBall = length(p) - 0.14;\n    \n    d = dmin(d, vec2(dBall, 0.));\n    #define colW 0.1\n    \n    j.xz = abs(j.xz)- colW;\n    vec3 k = j;\n    j = abs(j);\n    vec3 i = j;\n    j.y -= HEIGHT*0.95;\n    for (int i =0; i < 3; i ++){\n        j = abs(j);\n        \n        j.x -= 0.05;\n        j.xy *= rot(-0.25*pi + sin(iTime+ id.y*0.1) - 0.34 );\n        j.xz *= rot(-0.25*pi);\n    }\n    \n    \n    float dCol = min\n        (max(j.x, j.z),max(k.x, k.z) );\n    \n    \n    \n    d = dmin(d, vec2(dCol, 1.));\n    \n    float dGoldA = min(length(j.xz),length(k.xz) ) - 0.01 ;\n    \n    d = dmin(d, vec2(dGoldA, 2.));\n    \n    i = abs(i);\n    i.xy *= rot(0.4);\n    i.xz *= rot(0.2);\n    i = abs(i);\n    i.xz *= rot(0.6*pi);\n    \n    dGoldA = length(i.xy)- 0.03 ;\n    d = dmin(d, vec2(dGoldA, 2.));\n    \n\n    p.xz = pmod(p.xz, 0.2);\n    \n    p.y -= 0.3;\n    p = abs(p) - 0.001;\n    \n    float dGlow = min(\n    \tlength(p.xy) - 0.1,\n    \tlength(p.zy) - 0.1\n    );\n    \n    //d = dmin(d, vec2(dGlow,9.));\n    //float attenC = pow(abs(sin(q.z*0.1  + sin(q.x*0.2 + iTime)*2. + sin(q.y*3.)*0. + iTime*2.2)), 200.);\n    float attenC = pow(abs( sin(q.x +iTime + sin(q.z*0.1 + iTime) + q.z) ), 40.);\n\n    //float attenC = 0.2;\n    \n    vec3 col = pal(0.2,0.8 ,vec3(0.1 + pow(abs(sin(iTime*1.)), 40. )*0.005,2.2,0.3),0.5 + sin(iTime)*0.005,0.5 - attenC*0.6);\n\n    glowB += exp(-dGlow*20.) * col*attenuation*4.*attenC;    \n    \n    \n    q.xz = pmod(q.xz, 0.2);\n    \n    float dCeilings = q.y + HEIGHT;\n    dCeilings = min(dCeilings,-q.y + HEIGHT);\n    \n    dCeilings += max(exp(-q.x*100.), exp(-q.z*100.))*0.0000004;\n    \n    d = dmin(d, vec2(dCeilings, 0.));\n    \n    \n    \n    //d = dmin(d, vec2(dGlow, 5.));\n    \n    d.x *= 0.5;\n    \n    //d.x *= 0.5;\n    return d;\n}\n\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n    p = ro; t = 0.; hit = false;\n    \n    for(int i = 0; i < 150 ; i++){\n    \td = map(p);\n        d.x *= side;\n        glow += exp(-max(d.x, 0.)*80.)*attenuation*1.;\n        \n        \n        if(d.x < 0.001 || t > 20.){\n        \thit = true;\n            break;\n        }\n        t+=d.x;\n        p += rd*d.x;\n    }\n    \n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.001,0);\n    return normalize(vec3(\n    \tmap(p - t.xyy).x - map(p + t.xyy).x ,\n    \tmap(p - t.yxy).x - map(p + t.yxy).x ,\n    \tmap(p - t.yyx).x - map(p + t.yyx).x \n    ));\n}\n\nvec3 getNormala(vec3 p){\n\tvec2 t= vec2(0.0001,0);\n    return normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x \n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y,\n        d;\n\n    uv *= 1. + length(uv)*0.2;\n    \n    vec3 col = vec3(0),\n    \t ro = vec3(0),\n    \t rd = normalize(vec3(uv,1.)),\n         p;\n\n    ro.y += sin(iTime)*0.04;    \n    ro.z += mx;\n    \n    \n    rd.xy *= rot(sin(iTime*0.7)*0.02);\n    float t; bool hit;\n    float tB = 0.;\n    \n    for(int i = 0; i < 2 + min(iFrame, 0); i++){\n    \td = march(ro, rd, p,t, hit);\n    \t\n        if(i == 0)\n            tB = t;\n        \n        vec3 n = getNormal(p)*side;\n        \n        //float diff = max();\n        \n        if(d.y == 0.){\n        \t//col += 0.1;\n            /*\n            if(i == 0)\n                glow *= 0.5;\n            attenuation *= 0.5;*/\n        }\n        if(d.y == 2.){\n            vec3 c = vec3(0.7,0.6,0.5)*4.;\n            if(i == 0)\n                glow *= c*1.;\n            \n            glow *= c*1.;\n        \tattenuation *= c*0.6;\n        }\n        if(d.y == 1.){\n        \t//col += 0.1;\n            //vec3 c = vec3(0.1,0.6,0.9);\n            vec3 c = vec3(0.11,0.1,0.1);\n            if(i == 0)\n                glow *= c;\n            glow *= c;\n        \tattenuation *= c*3.;\n            //side *= -1.;\n        \trd = refract(rd, n, 0.4 + sin(p.x*40. + p.y*40. + iTime)*0.2);\n        \t//rd = reflect(rd, n);\n        } else {\n        \trd = reflect(rd, n);\n            \n        }\n        \n        \n        ro = p + rd*0.05;\n        \n        \n        attenuation *= 0.7;\n    }\n    \n    \n    glow = pow(glow, vec3(1.1))*0.02;\n    \n\tcol += glow*0.02;\n\tcol += glowB*0.01;\n    \n    col = clamp(col, 0., 10.);\n    \n    \n    col = mix(col, vec3(0.7), smoothstep(0.,1.,tB*0.05));\n    \n    \n    uv *= 0.8;\n    col *= 1. - dot(uv,uv);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 128, 128, 1209]], "test": "untested"}
{"id": "WtGSzK", "name": "flip", "author": "isk", "description": "just flipping some tiles", "tags": ["tile"], "likes": 7, "viewed": 580, "published": 3, "date": "1583098106", "time_retrieved": "2024-07-30T21:21:07.406591", "image_code": "const float PI=acos(-1.);\n\nfloat h21(vec2 p) {\n    p=fract(p*vec2(589.27,916.79));\n    p+=dot(p,p+23.51);\n    return fract(p.x*p.y);\n}\n\nmat2 rmat(float theta) {\n    float s=sin(theta),c=cos(theta);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t=iTime;\n    \n    uv *= 10.+7.*sin(t*.283);\n    uv *= rmat(sin(t*.114));\n    \n    vec2 xy=fract(uv)-.5;\n    float r=h21(floor(uv));\n    \n    float side=sign(xy.x);\n    xy.x=abs(xy.x);\n    \n    float phase=t*.25+r*2.*PI;\n    float flip=.01+.49*smoothstep(0.,.1,abs(sin(phase)*.5));\n    float fill=1.-step(flip,xy.x);\n    \n    float dim=0.2+0.8*smoothstep(0.,.5,flip);\n    vec3 col=vec3(fill*dim);\n    col*=.4+.6*vec3(fract(r*12.3),fract(r*56.9),fract(r*177.2));\n    \n    const float bev=.06,nbev=.5-bev;\n    float edge=step(flip-bev,xy.x*side);\n    edge-=step(flip-bev,xy.x*-side);\n    edge+=step(nbev,xy.y);\n    edge-=(1.-step(-nbev,xy.y));\n    col *= (1.+.2*edge);\n    \n    fragColor=vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 46, 46, 134], [136, 136, 160, 160, 226], [228, 228, 283, 283, 1055]], "test": "untested"}
{"id": "WtySzK", "name": "Strange Tunnel", "author": "Alkama", "description": "Converted from a liveshading session with Bonzomatic.", "tags": ["raymarching", "distancefield", "liveshading"], "likes": 10, "viewed": 478, "published": 3, "date": "1583096791", "time_retrieved": "2024-07-30T21:21:08.274271", "image_code": "float t = 0.;\nconst float pi = acos(-1.);\nconst mat3 yuv2rgb = mat3(1., 0., 1.13983, 1., -0.39465, -0.58060, 1., 2.03211, 0.);\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); } \nfloat cube(vec3 p, vec3 s) { vec3 b=abs(p)-s; return max(max(b.x,b.y),b.z); }\nfloat torus(vec3 p, float l, float s) { return length(vec2(length(p.xz)-l, p.y))-s; }\nvec2 scene(vec3 p) {\n    p.y=mod(p.y,.5)-.25;\n    p.xz *= rot((2.*pi+sin(t*2.))*2.*p.y);\n    float s=1., r=0.;\n    for(int i=0;i<3;i++) {\n        p = 2.*clamp(p, -.1, .1)-p;\n        r = max((.04*sin(t*5.)+.2)/dot(p,p), .9);\n        p*=r; s*=r;\n    }\n    vec2 c = vec2(max(cube(p,vec3(.5)), -min(cube(p,vec3(.6,.45,.45)),min(cube(p,vec3(.45,.6,.45)), cube(p,vec3(.45,.45,.6))))), 1.);\n    vec2 t = vec2(torus(p, 1., .05), 2.);\n    t=t.x<c.x?t:c;\n    return t*vec2(.3/s, 1.);\n}\nvec3 march(vec3 og, vec3 dir, int it, float tr, float md) {\n    int i=0;\n    float d=0.;\n    vec3 p = og;\n    for (i=0; i<it; i++) {\n        vec2 t = scene(p);\n        float h = t.x;\n        if (h<tr*d) return vec3(d,i,t.y);\n        if (d>md) return vec3(d,i,0);\n        d += h;\n        p += dir * h;\n    }\n    return vec3(d,i,0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n    float tt = mod(.2*iTime,pi*2.);\n\tt = (tt+sin(tt*5.)*.18);\n    vec3 eye = vec3(.03*sin(t*2.), t-.5, .03*cos(t));\n    vec3 f = normalize(vec3(0,t,0)-eye);\n    vec3 s = normalize(cross(vec3(0,1,1), f));\n    vec3 u = normalize(cross(f,s));\n    vec3 dir = normalize(f*(.55+sin(tt*5.)*.25)+uv.x*s+uv.y*u);\n    vec3 lp = .2*vec3(sin(t),sin(t)+t,cos(t*1.5));\n    vec3 col = vec3(0.);\n    vec3 m = march(eye, dir, 200, .001, 2.);\n    vec3 p = eye+dir*m.x;\n    if (m.z > 0.) {\n        vec2 e=vec2(.001,0);\n        vec3 n = normalize(vec3(scene(p+e.xyy).x-scene(p-e.xyy).x,scene(p+e.yxy).x-scene(p-e.yxy).x,scene(p+e.yyx).x-scene(p-e.yyx).x));\n        vec3 ld = normalize(lp - p);\n        float diff=max(0.,dot(n,ld));\n        float nd = dot(n,-dir);\n        float spec=pow(max(0., nd),20.);\n        float fres=1.-abs(nd);\n        float ao = scene(p+n*.1).x/.1 + scene(p+n*.3).x/.3;\n        vec3 acd = normalize(acos(-dir));\n        if (m.z > 1.) {\n            col = ao*.5+.15*fres*yuv2rgb*acd.zyx;\n        } else {\n            col = ao*0.2+.5*spec*acd.xzy;\n        }\n        col *= pow(max(0.,2.-length(p-vec3(0.,t,0.))),3.);\n    }\n    col *= pow(1.4-length(uv), 3.);\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtySzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 146, 146, 196], [198, 198, 226, 226, 275], [276, 276, 315, 315, 361], [362, 362, 382, 382, 837], [838, 838, 897, 897, 1170], [1171, 1171, 1228, 1228, 2531]], "test": "untested"}
{"id": "WlyXRK", "name": "Alien Shooter (WIP)", "author": "quizcanners", "description": "I want to make Top-Down shooter in a shader. TODO: Enemies, GOOOORE, more bullets\nWASD + LMB ", "tags": ["game", "interactive", "physics"], "likes": 6, "viewed": 615, "published": 3, "date": "1583095020", "time_retrieved": "2024-07-30T21:21:09.183839", "image_code": "vec4 loadValue( in vec2 savePos )\n{\n    return texture( iChannel1, savePos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bg = texture(iChannel0, uv);\n    vec4 dta = texture(iChannel1, uv);\n    \n   float aspect = iResolution.x/iResolution.y;\n    \n    uv -= .5;\n\n    uv.x *= aspect;\n\n    vec4 player =  loadValue(PLAYER_POS);\n    vec4 bulletZero = loadValue(BULLETS);\n    vec4 cameraPos = loadValue(CAMERA_POS);\n    \n    \n    uv.xy += cameraPos.xy;\n    \n    vec2 fromPlayer = player.xy - uv.xy;\n    \n    float toPlayer = 0.02 /(length(fromPlayer) + 0.001);\n        \n    float toBullet = 0.002 / DistToLine(uv, bulletZero.xy + cameraPos.zw, bulletZero.xy+bulletZero.zw * BULLET_SPEED*0.91); \n\n    uv += normalize(fromPlayer) * toBullet * toBullet * 20.;\n    \n    vec4 cleanSoil = texture(iChannel2, uv*3.);//vec4(0.,0.,0.,1.); //texture(iChannel0, uv);\n\n    float scorged = min(1., bg.g);\n    \n    vec4 scorgedSoil = texture(iChannel3, uv*3.)/(1.+bg.g*bg.g * 0.2);\n    \n    \n    vec3 col = vec3(toBullet, toBullet, toPlayer) + vec3(bg.r,0.,0.) + (cleanSoil.rgb  * (1.-scorged)\n        + scorgedSoil.rgb * scorged) * (1.-toPlayer)\n        ;\n    \n    \n    vec3 mixing = col.gbr+col.brg;\n    \n    col.rgb+= mixing * mixing * 0.1;\n    \n    //col.rgb += dta.rgb; // Debug\n    \n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer for special effects:\n// R: Fire Bullet trace\n// G: Burn Marks\n// B: Blood Marks\n\nvec4 loadValue( in vec2 savePos )\n{\n    return texture( iChannel2, savePos);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 MousePos = iMouse.xy/iResolution.xy;\n    \n    vec2 persistanceUV = uv;\n    \n    float aspect = iResolution.x/iResolution.y;\n\n    uv -= .5;\n    uv.x *= aspect;\n    \n    vec4 cameraPos = loadValue(CAMERA_POS);\n    vec4 player =  loadValue(PLAYER_POS);\n    vec4 bulletZero = loadValue(BULLETS);\n    \n    vec2 M = MousePos - .5;\n    M.x *= aspect;\n    M+= cameraPos.xy;\n    \n    vec2 prev = cameraPos.xy;\n    cameraPos.xy = mix(cameraPos.xy, player.xy + M.xy - cameraPos.xy, iTimeDelta*5.);\n    cameraPos.zw = cameraPos.xy - prev;\n    \n    vec2 srcColor = persistanceUV + vec2(cameraPos.z / aspect, cameraPos.w);\n\n    vec2 edge = clamp((0.49 - abs(srcColor-0.5))*1000., 0., 1.);\n\n    vec4 col = texture(iChannel0,srcColor) * edge.x * edge.y;\n\n    uv.xy += cameraPos.xy;\n\n    float toBullet = DistToLine(uv, bulletZero.xy //+ cameraPos.zw\n                                , bulletZero.xy+bulletZero.zw * BULLET_SPEED*0.91); \n\n    float toPlayer = 0.02 /(length(player.xy - uv.xy) + 0.001);\n\n    col.r *= 0.9;\n\n    col.r += max(0.,(0.01 - toBullet) * 100.);\n\n    col.g = clamp(max(toPlayer * .1/toBullet, col.g),0.,5.);\n\n    fragColor = col;  \n    \n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nconst float PLAYER_SPEED = 0.01;\nconst float BULLET_SPEED = 0.1;\nconst float CAMERA_SPEED = 0.1;\n    \nconst float PRSST_STEP = 10.;\nconst float HALF_STEP = PRSST_STEP * .5;\nconst vec2 PRST_SIZE = vec2(800., 450.);\n\n\n// Line 1\nconst vec2 P_MOUSEPOS = (\tvec2(0., 0.) \t\t\t\t+ HALF_STEP) / PRST_SIZE;\nconst vec2 PLAYER_POS = (\tvec2(PRSST_STEP, 0.) \t\t+ HALF_STEP) / PRST_SIZE;\nconst vec2 BULLET_COUNT = (\tvec2(PRSST_STEP*2., 0.) \t+ HALF_STEP) / PRST_SIZE;\nconst vec2 CAMERA_POS = (\tvec2(PRSST_STEP*3., 0.) \t+ HALF_STEP) / PRST_SIZE;\n\n// Line 2\nconst vec2 BULLETS = (\tvec2(0., PRSST_STEP) \t\t+ HALF_STEP) / PRST_SIZE;\n\nconst float PERSST_AREA_LINES = 2.;\n\n\n//Functions\n\nbool isStoreArea( in vec2 savePos, in vec2 fragCoord)\n{\n    vec2 r = savePos - fragCoord;\n    return length(r) < (1./200.);\n}\n\nvoid storeValue( in vec2 savePos, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 r = savePos - fragCoord;\n    fragColor = ( length(r) < (1./200.)) ? va : fragColor;\n}\n\nfloat DistToLine(vec2 pos, vec2 a, vec2 b) \n{\n\t\tvec2 pa = pos - a;\n\t\tvec2 ba = b - a;\n\t\tfloat t = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n\t\treturn length(pa - ba * t);\n}", "buffer_b_code": "// LOGIC BUFFER (BULLETS, PLAYER, ENEMIES)\n\nvec4 loadValue( in vec2 savePos )\n{\n    return texture( iChannel0, savePos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 persistanceUV = uv;\n\n    const float PERSIST_AREA = PERSST_AREA_LINES * PRSST_STEP;\n    \n    if (persistanceUV.y < PERSIST_AREA){\n\n        vec2 MousePos = iMouse.xy/iResolution.xy;\n\n        float aspect = iResolution.x/iResolution.y;\n\n        uv -= .5;\n        uv.x *= aspect;\n\n        vec4 cameraPos = loadValue(CAMERA_POS);\n        vec4 player =  loadValue(PLAYER_POS);\n        vec4 bulletZero = loadValue(BULLETS);\n\n        vec2 M = MousePos - .5;\n        M.x *= aspect;\n        M+= cameraPos.xy;\n\n        vec2 prev = cameraPos.xy;\n        cameraPos.xy = mix(cameraPos.xy, player.xy + M.xy - cameraPos.xy, iTimeDelta*5.);\n        cameraPos.zw = cameraPos.xy - prev;\n        \n        vec4 prevM = loadValue(P_MOUSEPOS);\n      \n        vec4 bulletCount =  loadValue(BULLET_COUNT); // x - active, z - delay\n\n        float force = prevM.z; \n        prevM.xy -= 0.5;\n\n        float down = clamp(iMouse.z * 800., 0. , 1.);\n    \n    \tfloat click = down * max(0.,1. - force*100.); // Not down previous frame\n      \n        \n        \n        bulletZero.xy += bulletZero.zw * BULLET_SPEED;\n        \n        bulletCount.y += iTimeDelta; // To have delay between bullets\n        \n        if (down * bulletCount.y > 0.5)\n        {\n        \tbulletCount.x +=1.;\n            bulletZero = vec4(player.xy, normalize(M.xy - player.xy));\n            bulletCount.y = 0.; \n        }\n\n    \tforce = clamp(down*iTimeDelta * 5. + force, 0. , 1.) * down;\n\n        storeValue(BULLETS, bulletZero, fragColor, persistanceUV);\n\n        storeValue(BULLET_COUNT, bulletCount, fragColor, persistanceUV);\n        \n        storeValue(P_MOUSEPOS, vec4(M + 0.5, force, 0), fragColor, persistanceUV);\n        \n        if (isStoreArea( PLAYER_POS, persistanceUV)){\n            \n            vec2 off;\n\n            off.x -=  texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x;\n            off.x +=  texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x;\n            off.y +=  texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x;\n            off.y -=  texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x;\n\n            if (length(off)>0.0001){\n                player.xy += normalize(off) * PLAYER_SPEED;\n            }\n            \n            fragColor = player;\n        } \n        \t\n            \n          \n         storeValue(CAMERA_POS, cameraPos, fragColor, persistanceUV);\n          \n    }\n    \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 78], [80, 80, 137, 137, 1372]], "test": "untested"}
{"id": "WlySRK", "name": "Fractal storm 2", "author": "jarble", "description": "Another fractal based on cellular automata.", "tags": ["fractal"], "likes": 1, "viewed": 295, "published": 3, "date": "1583091335", "time_retrieved": "2024-07-30T21:21:10.028581", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 8.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float RED = 5.0;\nconst float WHITE = 6.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        && magnify(fragCoord+vec2(1,0),mag) == color\n        && magnify(fragCoord-vec2(0,1),mag) == color\n        && magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\tfloat mag1= (fragCoord.x-fragCoord.y)/mag+mag*iTime*20.0;\n    return magnify(fragCoord+vec2(0,mag1),mag) == color\n        || magnify(fragCoord+vec2(mag1,0),mag) == color\n        || magnify(fragCoord-vec2(0,mag1),mag) == color\n        || magnify(fragCoord-vec2(mag1,0),mag) == color;\n}\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n    while(mag1 < mag){\n    bool modified = true;\n    if(color1 == GREEN && is_next_to(fragCoord,mag1,BLUE)){\n    \tcolor1 = BLUE;\n    }\n    else if(color1 == BLUE && is_next_to(fragCoord,mag1,GRAY)){\n        if(mag1 > 5.0){\n        \tcolor1 = YELLOW;\n        }\n        else{\n        \tcolor1 = GRAY;\n        }\n    }\n    else if(color1 == GRAY && is_next_to(fragCoord,mag1,GREEN)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(fragCoord,mag1,GRAY)){\n        color1 = GREEN;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord + mag*iTime*vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 278, 300, 300, 524], [527, 527, 567, 567, 616], [618, 618, 670, 670, 713], [714, 714, 774, 774, 986], [988, 988, 1042, 1042, 1328], [1331, 1331, 1359, 1359, 1773], [1775, 1775, 1834, 1834, 2409], [2411, 2411, 2468, 2468, 2756]], "test": "untested"}
{"id": "WtGSRK", "name": "Hexes", "author": "paz7", "description": "Drag the mouse to place the center of the circles", "tags": ["2d"], "likes": 3, "viewed": 294, "published": 3, "date": "1583090830", "time_retrieved": "2024-07-30T21:21:10.926180", "image_code": "float HexDist(vec2 p){\n\tp = abs(p);\n    \n    float c = dot(p,normalize(vec2(1,2.236)));\n    return max(c,p.x);\n}\n\nvec4 HexCoords(vec2 uv){\n\tvec2 r = vec2(1.,1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv,r)-h;\n    vec2 b = mod(uv-h,r)-h;\n    \n    vec2 gv;\n    if(length(a)<length(b))\n    \tgv = a;\n    else\n       gv = b;\n    \n    float x = atan(gv.x,gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x,y,id.x,id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.y;\n    vec2 ss = uv;\n    vec2 m = (iMouse.xy)/iResolution.y;\n\tuv -= m;\n    vec4 col = vec4(0);\n    \n    uv *= 16.;\n    \n    vec4 hc = HexCoords(uv);\n    float d = (distance(ss,hc.zw)+.5);\n    float scrollSpeed = 1.5;\n    float c = sin(d*2. - iTime*scrollSpeed);\n    \n    col += c;\n\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 112], [114, 114, 138, 138, 440], [442, 442, 499, 499, 848]], "test": "untested"}
{"id": "3tGSRK", "name": "Shapeshifting sponge", "author": "jarble", "description": "This \"sponge\" shapeshifts in a very strange way.", "tags": ["fractal"], "likes": 1, "viewed": 255, "published": 3, "date": "1583089938", "time_retrieved": "2024-07-30T21:21:11.803834", "image_code": "\nconst float mag = 8.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float RED = 2.0;\nconst float YELLOW = 3.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*2.0);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,mag),mag) == color\n        && magnify(fragCoord+vec2(mag,0),mag) == color\n        && magnify(fragCoord-vec2(0,mag),mag) == color\n        && magnify(fragCoord-vec2(mag,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\tfloat mag1= (fragCoord.x-fragCoord.y)/mag+mag*iTime*20.0;\n    return magnify(fragCoord+vec2(0,mag1),mag) == color\n        || magnify(fragCoord+vec2(mag1,0),mag) == color\n        || magnify(fragCoord-vec2(0,mag1),mag) == color\n        || magnify(fragCoord-vec2(mag1,0),mag) == color;\n}\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    while(mag > 1.0){\n    if(color1 == GREEN && is_next_to(fragCoord,mag,BLUE)){\n    \tcolor1 = BLUE;\n    }\n    else if(color1 == BLUE && is_next_to(fragCoord,mag,GREEN)){\n        color1 = GREEN;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord*2.0 + mag*iTime*vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 185, 207, 207, 335], [338, 338, 378, 378, 427], [429, 429, 481, 481, 524], [525, 525, 585, 585, 805], [807, 807, 861, 861, 1147], [1150, 1150, 1178, 1178, 1449], [1452, 1452, 1511, 1511, 1755], [1757, 1757, 1814, 1814, 2106]], "test": "untested"}
{"id": "ttKXzy", "name": "Fractal storm", "author": "jarble", "description": "I combined two of my shaders to make this animation.", "tags": ["fractal"], "likes": 2, "viewed": 257, "published": 3, "date": "1583086016", "time_retrieved": "2024-07-30T21:21:12.662538", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float RED = 5.0;\nconst float WHITE = 6.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * (.1031));\n    p3 += dot(p3, p3.yzx + 33.33+iTime/1000.);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nfloat magnify1(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nfloat pixel_above(vec2 fragCoord,float mag){\n\treturn magnify1(fragCoord+vec2(pow(2.0,mag),0)*iTime,mag);\n}\n\nvoid rainbowClouds( out float fragColor, in vec2 fragCoord,float maximum)\n{\n    float color1 = 0.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+1.0)+magnify1(fragCoord,maximum);\n    }\n    fragColor = color1/maximum;\n}\n\nfloat magnify(vec2 fragCoord,float mag){\n\tfloat the_color;\n    rainbowClouds(the_color,fragCoord,mag);\n    return floor(the_color);\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        && magnify(fragCoord+vec2(1,0),mag) == color\n        && magnify(fragCoord-vec2(0,1),mag) == color\n        && magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        || magnify(fragCoord+vec2(1,0),mag) == color\n        || magnify(fragCoord-vec2(0,1),mag) == color\n        || magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n    while(mag1 < mag){\n    bool modified = true;\n    if(color1 == GREEN && is_next_to(fragCoord,mag1,BLUE)){\n    \tcolor1 = BLUE;\n    }\n    else if(color1 == BLUE && is_next_to(fragCoord,mag1,GREEN)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(fragCoord,mag1,BLUE)){\n    \tcolor1 = GREEN;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord + iTime*vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 278, 300, 300, 538], [541, 541, 562, 562, 698], [701, 701, 742, 742, 791], [793, 793, 837, 837, 899], [901, 901, 976, 976, 1159], [1161, 1161, 1201, 1201, 1294], [1296, 1296, 1348, 1348, 1391], [1392, 1392, 1452, 1452, 1664], [1666, 1666, 1720, 1720, 1932], [1935, 1935, 1963, 1963, 2377], [2379, 2379, 2438, 2438, 2830], [2832, 2832, 2889, 2889, 3173]], "test": "untested"}
{"id": "3tGXRy", "name": "Mandelbrot&Julia Explorer (SS9)", "author": "angelo12", "description": "Mouse over some different areas of the Mandelbrot set to see the corresponding Julia set.", "tags": ["fractal", "mandelbrot", "shadersundays"], "likes": 1, "viewed": 398, "published": 3, "date": "1583079831", "time_retrieved": "2024-07-30T21:21:13.528223", "image_code": "#define AA 2\n#define ZOOMTOGGLE 0\n#define OFFSETX -1.1\n#define OFFSETY -0.2\n\n/*\n\tShader Sundays! (9/52) \n\t\"Mandelbrot&Julia Explorer\"\n\t\n\tThe inspiration for this shader came from watching this very cool video from numberphile\n\tWhere they explain the relationship between the Mandelbrot & Julia set, I wanted to see \n\tit for myself so here it is. There's some hacked in zoom I thought to put in last min,\n\tbecause you can't have a mandelbrot set without zoom. The color gradient I got from the \n\trecent IQ shader. \n\t\n\tNumberphile vid:\n\thttps://youtu.be/FFftmWSzgmk\n\tIQ Mandelbrot Shader:\n\thttps://www.shadertoy.com/view/ttVSDW\n*/\n\nvec2\nsquare(vec2 Z)\n{\n    //a^2 - b^2 + 2abi\n    return vec2(Z.x* Z.x - Z.y * Z.y, 2.0*Z.x*Z.y);\n}\n\nfloat\nmandelbrot(vec2 uv, const int max_steps, float zoom, vec2 offset)\n{\n    float res = -1.0;\n    vec2 C = uv*zoom + offset;\n    vec2 Z  = vec2(0.0);\n\n    for(int i = 0; i < max_steps; ++i)\n    {\n        Z = square(Z) + C;\n\n        if(length(Z) > 2.0)\n        {\n            res = float(i);\n            break;\n        }\n    }\n\n    return res;\n}\n\nfloat\njulia(vec2 uv, const int max_steps, float zoom, vec2 offset)\n{\n    float res = -1.0;\n    vec2 C = offset;\n    vec2 Z = uv;\n\n    for(int i = 0; i < max_steps; ++i)\n    {\n        Z = square(Z) + C;\n\n        if(length(Z) > 2.0)\n        {\n            res = float(i);\n            break;\n        }\n    }\n\n    return res;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    //Setup\n    float time = iTime / 10.0;\n    float AR = iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 tot = vec3(0.0);\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy) / iResolution.y;\n    \n    //SS AA loop\n    for(int i = 0; i < AA; ++i)\n    for(int j = 0; j < AA; ++j)\n    {\n        vec2 offset = vec2(i, j) / float(AA) - 0.5;\n\t\t\n        vec2 muv = ((fragPos + offset) - 0.5*iResolution.xy ) / iResolution.y;\n        vec2 uv = ((fragPos + offset)) / iResolution.xy;\n\t\t\n        //Minimap setup\n        vec2 uv2 = uv;\n        uv2.x = 1.0 - uv2.x;\n        uv2 *= vec2(2.6, 2.6);\n        vec2 id = floor(uv2);\n        uv2 = vec2(1.0 - uv2.x, uv2.y);\n        vec2 juv = (fract(uv2) - 0.5);\n        juv.x *= AR;     \n\t\tfloat inJulia = saturate(1.0 - id.y) * saturate(1.0 - id.x); \n        float inMandelbrot = 1.0 - inJulia;\n        \t\t\n        //Zoom \n        const int max_steps = 500;\n        float zoom = 1.0;\n        #if ZOOMTOGGLE\n        zoom = (sin(time)* 0.5 + 0.5)*float(ZOOMTOGGLE);\n        #endif\n        \n        //Offset and Mouse movement\n        vec2 mov = vec2(OFFSETX, OFFSETY);\n        vec2 movement = mov + mouse.xy;\n\n    \t//Num Steps for Mandelbrot and Julia\n        float mI = mandelbrot(muv, max_steps, zoom, mov );        \n        float jI = julia(juv, max_steps, zoom, movement);\n\t\t\n        //Applying mandelbrot and julia colors\n        col += (mI<0.0) ? vec3(0.0) : 0.5 + 0.5*cos( pow(zoom,0.22)*mI*0.05 + vec3(7.0,2.0,3.0));\n        col *= inMandelbrot;\n        col += (jI<0.0) ? vec3(0.0) : (0.5 + 0.5*cos( pow(zoom,0.21)*jI*0.05 + vec3(2.0,2.0,5.0))) * inJulia;     \n        \n        //Mouse markers\n        col += (length(muv - mouse.xy) < 0.005) ? vec3(1.0) : vec3(0.0);\n        col += (length(juv - mouse.xy) < 0.01) ? vec3(1.0) * inJulia : vec3(0.0) ;\n\n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    GAMMA(tot);\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//Comment this out if running this file on shadertoy\n#define SHADERTOY \n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Camera functions------------------------------\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n\n//--------------------------------------------------------------------------------------\n//----------------------------------Post processing functions----------------------------\n#define GAMMA(col) col = pow(col, vec3(INV_GAMMA))\n\n\n//---------------------------------------------------------------------------------------- \n//----------------------------------Basic functions---------------------------------------\n#ifdef SHADERTOY\n#define saturate(col) clamp(col, 0.0, 1.0)\n#endif\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[630, 630, 651, 674, 728], [730, 730, 803, 803, 1075], [1077, 1077, 1145, 1145, 1399], [1401, 1401, 1454, 1466, 3361]], "test": "untested"}
{"id": "wlKSRy", "name": "circlecolor", "author": "abhisarshukla", "description": "default colors with a circle.", "tags": ["beginner", "circle"], "likes": 0, "viewed": 229, "published": 3, "date": "1583078121", "time_retrieved": "2024-07-30T21:21:14.371968", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float d = length(uv);\n    float r = 0.3*sin(1.);\n    float ctf = max((sin(0.5)+cos(iTime)), 0.25)/2.;\n    float c = smoothstep(r-0.005, r, d)+1.;\n    if(d > r) c *= ctf+0.5; else c *= 1.5-ctf;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col *= vec3(c);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 112, 696]], "test": "untested"}
{"id": "3tKXzy", "name": "Snub Hexagonal Tiling", "author": "mla", "description": "A complement to fizzer's [url]https://www.shadertoy.com/view/3tyXWw[/url]", "tags": ["tiling", "hexagonal", "snub"], "likes": 6, "viewed": 373, "published": 3, "date": "1583055001", "time_retrieved": "2024-07-30T21:21:15.142906", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Snub hexagonal tiling plus dual.\n// cf. https://www.shadertoy.com/view/3tyXWw by fizzer\n//\n// <mouse>: translate, or move Wythoff point\n// d: show dual\n// f: show fundamental region\n// m: change mouse mode\n// r: show basic grid regions\n// t: show tiling\n// z: auto zoom\n//\n// Moving the Wythoff point makes the tiling non-uniform and in some\n// positions, the tiling not drawn completely.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float X = 1.732050808; // sqrt(3)\nconst float Y = 0.577350269; // 1/sqrt(3)\n\nconst mat2 M = 0.5*mat2(1,-X,1,X);\nconst mat2 Minv = Y*mat2(X,X,-1,1);\n\nvec2 reflection(vec2 p, vec2 q, vec2 r) {\n  // reflect p in the line through q and r\n  p -= q;\n  vec2 n = (r-q).yx * vec2(1,-1);\n  p -= 2.0*dot(p,n)*n/dot(n,n);\n  p += q;\n  return p;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a;\n  vec2 ba = b-a;\n  float h = dot(pa,ba)/dot(ba,ba);\n  return length(pa - ba * h);\n}\n\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 70;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_Z = 90; // zooming\n\nbool key(int key) {\n    return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nvec3 diagram(vec2 z, float scale) {\n  vec2 z0 = z;\n  z.x += 0.5;\n  z = Minv*z; // Convert to square grid\n  ivec2 index = ivec2(floor(z)); // Remember cell in grid\n  z -= floor(z);\n  z = M*z; // Back to triangles\n\n  // Map to equilateral triangles [(0,0),(1,0),(0.5,0.866)],[(0,0),(1,0),(0.5,-0.866)]\n  z.x -= 0.5;\n  bool inlower = z.y < 0.0; // Point is in lower triangle,\n  if (inlower) z = -z;      // so rotate to upper triangle\n\n  // All patterns have rotational symmetry about triangle centre, so:\n  // map centre of triangle to origin...\n  z.y -= 0.5*Y;\n\n  // ...and reflect in planes of symmetry of triangle\n  const vec2 A = 0.5*(vec2(1,X));  // normalized\n  const vec2 B = 0.5*(vec2(-1,X)); // normalized\n  float ta = dot(z,A);\n  z -= 2.0*max(ta,0.0)*A;\n  float tb = dot(z,B);\n  z -= 2.0*max(tb,0.0)*B;\n  z.y += 0.5*Y;        // Shift origin back to region centre,\n  if ((ta > 0.0) != (tb > 0.0)) z.x = -z.x; // Want even number of reflections\n\n  vec3 col = vec3(1);\n  vec3 col3 = vec3(1,0,0);\n  vec3 col4 = vec3(1,1,0);\n\n  bool inregion = length(z-z0) < 1e-4;\n  \n  scale *= 2.0*X;\n  z *= 2.0*X; // Scale so region is 1 by X\n\n  float pwidth = scale*3.0/iResolution.y;\n  float eps = 0.01;\n  float lwidth0 = 2.0*eps;\n  float lwidth1 = max(lwidth0+pwidth,4.0*eps);\n  float bwidth = max(pwidth,1.0*eps);\n\n  if (!key(CHAR_R)) {\n    float d = min(abs(z.x),z.y);\n    d = min(d,line(abs(z),vec2(0,1),vec2(X,0)));\n    float mfact = smoothstep(-bwidth,bwidth,d);\n    col = mix(col3,col4,(z.x < 0.0 ? mfact : mfact-1.0));\n    if (key(CHAR_F) && !inregion) col = mix(col,0.8*col,mfact);\n  }\n\n  vec2 p = vec2(0.48,0.44); // The snub Wythoff point\n  if (!key(CHAR_M) && iMouse.x > 0.0) {\n    p = iMouse.xy/iResolution.y;\n  }\n\n  // Now reflect p in various lines of symmetry to get the\n  // actually points of the tilings.\n  // This really needs a picture.\n  vec2 p0 = vec2(p.x,-p.y);\n  vec2 p1 = vec2(-p.x,p.y);\n  vec2 p2 = reflection(p,vec2(X,0),vec2(0,1));\n  vec2 p3 = -p2;\n  vec2 p4 = reflection(-p,vec2(-X,0),vec2(0,1));\n  vec2 p5 = reflection(p,vec2(-X,0),vec2(0,1));\n  vec2 p6 = reflection(p,vec2(-X,0),vec2(0,1));\n  vec2 p7 = reflection(p1,vec2(-X,0),vec2(0,1));\n\n  // The centre point of various triangles.\n  // This needs a picture as well.\n  vec2 t1 = (p0+p1+p2)/3.0;\n  vec2 t2 = (p0+p1+p3)/3.0;\n  vec2 t3 = (p1+p2+p6)/3.0;\n  vec2 t4 = -(-t1-vec2(-X,0))+vec2(-X,0);\n  vec2 t5 = (p1+p4+p6)/3.0;\n  vec2 t6 = -(t5-vec2(-X,0))+vec2(-X,0);\n\n  // Draw the lines. We have to draw all the lines that\n  // intersect with the fundamental region - there are\n  // quite a few, some of which only have a few pixels\n  // in common.\n  vec3 col1 = vec3(0.2);\n  vec3 col2 = vec3(0.8);\n\n  // Dual edges\n  if (!key(CHAR_D)) {\n    float d = 1e8;\n    d = min(d,segment(z,t1,t2));\n    d = min(d,segment(z,t1,vec2(X,0)));\n    d = min(d,segment(z,t1,t3));\n    d = min(d,segment(z,t1,t3));\n    d = min(d,segment(z,-t1,t4));\n    d = min(d,segment(z,-t1,t4));\n    //d = min(d,segment(z,t5,t6));\n    d = min(d,segment(z,p7,t3));\n    //d = min(d,segment(z,p7,-p7));\n    col = mix(col2,col,smoothstep(lwidth0,lwidth1,d));\n  }\n  \n  // Main tiling edges\n  if (!key(CHAR_T)) {\n    float d = 1e8;\n    d = min(d,segment(z,p0,p1));\n    d = min(d,segment(z,p1,p2));\n    d = min(d,segment(z,p2,p0));\n    d = min(d,segment(z,p1,p3));\n    d = min(d,segment(z,p1,p4));\n    d = min(d,segment(z,p1,p5));\n    col = mix(col1,col,smoothstep(lwidth0,lwidth1,d));\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy+0.123)/iResolution.y;\n  float scale = 1.0;\n  if (key(CHAR_Z)) scale = exp(2.0*sin(iTime));\n  z *= scale;\n  if (key(CHAR_M) && iMouse.x > 0.0) {\n    z -= (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  }\n  vec3 col = diagram(z,scale);\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[716, 716, 757, 800, 900], [902, 902, 941, 941, 1082], [1084, 1084, 1120, 1120, 1221], [1419, 1419, 1438, 1438, 1499], [1501, 1501, 1536, 1536, 4940], [4942, 4942, 4995, 4995, 5299]], "test": "untested"}
{"id": "WtKSzy", "name": "video effect showing compression", "author": "FabriceNeyret2", "description": "fract of  amplified difference with luminance\nclearly shows chrominance encoded at low resolution.", "tags": ["video", "color"], "likes": 11, "viewed": 423, "published": 3, "date": "1583048647", "time_retrieved": "2024-07-30T21:21:16.049482", "image_code": "// variant of  https://shadertoy.com/view/3tKSzy\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = sqrt( texture(iChannel0,U/iResolution.xy) );\n    \n    O = fract( 1e2* ( O - (O.r+O.g+O.b)/3. ));\n    \n    O *= O;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 88, 88, 212]], "test": "untested"}
{"id": "3tKSzy", "name": "B&W video is indeed yellow", "author": "FabriceNeyret2", "description": "right: amplifying the difference with pure B&W\nleft: doing computation in flat space\ntop: ref = isoluminance. bottom: luma", "tags": ["video", "color"], "likes": 2, "viewed": 314, "published": 3, "date": "1583048304", "time_retrieved": "2024-07-30T21:21:16.928133", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U/=iResolution.xy;\n    O = texture(iChannel0,U);\n    if (U.x<.5) O = pow(O,vec4(1./2.2));                 // to flat space\n    \n    float l = U.y>.5 ? (O.r+O.g+O.b)/3.                  // isoluminance\n                     : dot(O.rgb,vec3(.299,.587,.114));  // luma\n    \n    O = .5 + 20.*(O-l);                                  // amplifies difference with B&W\n    \n    if (U.x<.5) O = pow(O,vec4(2.2));                    // to sRGB\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 478]], "test": "untested"}
{"id": "3tKSRy", "name": "Golfing Rolling feedback-177 c", "author": "GregRostami", "description": "Golfing this great feedback shader by hamoid.\n[url]https://shadertoy.com/view/3lKXRG[/url]\nPlease help me make this shorter.", "tags": ["feedback"], "likes": 8, "viewed": 422, "published": 3, "date": "1583033192", "time_retrieved": "2024-07-30T21:21:17.831717", "image_code": "void mainImage(out vec4 o, vec2 U) {m}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 o, vec2 U) {m}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define m                                                                 \\\n  vec2 u = U / iResolution.xy;                                            \\\n  o = mix( o =  texture(iChannel1, u  ),                                  \\\n           pow( texture(iChannel0, u + cos(u.x*u.y*20. + vec2(55,0))/1e3),\\\n                 1.+.01*vec4(1,2,3,0) ),                                  \\\n          .95 + .05*fract(o.r/.12) );", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtKSzG", "name": "Playtime Painter", "author": "quizcanners", "description": "Painting is something I did in Unity. \nWanted to see if I can recreate the similar tool in here. TODO: Brightness && Saturation picker.", "tags": ["game", "interactive", "painting"], "likes": 11, "viewed": 985, "published": 3, "date": "1583017696", "time_retrieved": "2024-07-30T21:21:18.914821", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n\n  \n    \n    uv -= .5;\n    \n     vec3 mixing = col.gbr+col.brg;\n    \n    col.rgb+= mixing * mixing * 0.1;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x*= aspect;\n    \n     vec4 bg = texture(iChannel1, uv * 4.6);\n    \n    uv *= 12.;\n    \n   \n    \n  \tuv = floor(uv) * 0.5; // For Grid\n    \n    vec3 bgCol = (0.6 + bg.rgb *0.2 + mod(uv.x - uv.y, 1.) * 0.1);\n    \n    col.rgb =  (col.rgb  + (length(bg.rgb) - 0.4) * (1.1- col.a) * .5  ) * col.a + \n                        bgCol  * (1.-col.a);\n    \n    \n  \n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nbool isStoreArea( in vec2 savePos, in vec2 fragCoord)\n{\n    vec2 r = savePos - fragCoord;\n    return length(r) < (1./200.);\n}\n\n\nvoid storeValue( in vec2 savePos, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 r = savePos - fragCoord;\n    fragColor = ( length(r) < (1./200.)) ? va : fragColor;\n}\n\nvec4 loadValue( in vec2 savePos )\n{\n    return texture( iChannel0, savePos);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 MousePos = iMouse.xy/iResolution.xy;\n    \n    \n    const float SAMPLER_AREA = 0.9;\n    const float BRIGHNESS_AREA = 0.85;\n    const float PERSIST_AREA = 0.99;\n    \n    // PERSISTENCE\n    vec2 persistanceUV = uv;\n   \n    const vec2 PRST_SIZE = vec2(800., 450.);\n    \n    const vec2 P_MOUSEPOS = (vec2(0., 449.) + 0.5) / PRST_SIZE;\n    const vec2 BRUSH_COLOR = (vec2(10., 449.) + 0.5) / PRST_SIZE;\n    const vec2 BRUSH_BRIGHTNESS = (vec2(20., 449.) + 0.5) / PRST_SIZE;\n    const vec2 P_MOUSEVEC = (vec2(30., 449.) + 0.5) / PRST_SIZE;\n    \n    vec4 prevM = loadValue(P_MOUSEPOS);\n   \n    prevM.xy -= 0.5;\n    float force = prevM.z; \n    float thickness = prevM.w;\n    \n   \n    vec4 prevM_Vec = loadValue(P_MOUSEVEC);\n    prevM_Vec.xy -= 0.5;\n    float prevThickness = prevM_Vec.w;\n    float prevLineLength = prevM_Vec.z;\n    \n    vec4 brushHUE = loadValue(BRUSH_COLOR);\n    vec4 brushColor = brushHUE;\n    brushColor.a = 1.;\n    \n    vec4 colorUE = loadValue(BRUSH_BRIGHTNESS);\n    \n    float brushBrightness = colorUE.x;\n    float brushContrast = colorUE.y;\n    \n \t// COLOR MGMT\n    uv -= .5;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 realM = MousePos - .5;\n    \n    uv.x *= aspect;\n    \n    realM.x *= aspect;\n   \n    vec2 M = realM;// + prevM_Vec.xy * force;\n    \n    float lineLength = length(M-prevM.xy);\n    \n    if (persistanceUV.y<SAMPLER_AREA)\n    {\n          \n        brushColor = mix(vec4(1.), brushHUE, brushContrast) *  brushBrightness;\n        brushColor.a = 1.;\n          \n        if (persistanceUV.x < BRIGHNESS_AREA)\n        {\n          \n            // PAINTING\n\n            vec4 col = texture(iChannel0, persistanceUV);\n\n            float distToNext = length(uv - M);\n\n            float t = mix(thickness,prevThickness , clamp(distToNext/lineLength ,0.,1.)) + 0.0001;\n\n            //M += (M-prevM.xy)*0.25;\n\n            float minD = DistToLine(uv, M,prevM.xy);//  min(d0, d1);\n\n            const float DIST_COEF = 0.005;\n\n            float maxDist = DIST_COEF * 4. * t - minD;\n\n\n            if (maxDist>0.) {\n\n\n                const float SHARPNESS = 920.;\n\n                vec2 direction = M - prevM.xy; \n\n                float lineLength = length(direction);\n\n                float dist = \n                    lineLength > t *0.01 \n                    ? DistToCurve(prevM.xy, prevM.xy+prevM_Vec.xy * lineLength * 0.3, M  , uv)\n                    : DistToLine(uv, M,prevM.xy)\n                        ; \n\n\n                float smudgeStep = floor(iTime * 2. );\n\n                vec2 ruv = Rotate(uv,  smudgeStep * 123.456);\n                float mask = texture(iChannel1, ruv + smudgeStep*0.123).b;\n\n                //mask*= mask;\n\n                float soft = (.001/dist);\n\n                float toBlur =  max(0.,DIST_COEF * (1. + mask * 5.) * (t) -dist - lineLength\n                                   ) * force * 15.;\n\n                float toPaint = \n\n                    // NEON BRUSH:\n                               // (.003/dist));\n\n                    // NORMAL BRUSH:\n                                max(0., (DIST_COEF * t * (1. + toBlur * .3) -dist)* SHARPNESS / t  * force //* min(1., 0.5 + lineLength*10.)\n                                   ) ;\n\n                float alpha = clamp(toPaint, 0., 1.);\n                float rgbAlpha = clamp((alpha*2.+soft * maxDist * max(0., 1.-col.a))/(col.a + alpha), 0., 1.);\n                vec4 maskb = vec4(rgbAlpha,rgbAlpha,rgbAlpha, alpha);\n\n                // Pixel Offset For Blur\n                vec2 off= (1./iResolution.xy)*0.5; // To sample area between pixels(Bilinear filtering would work as 4 blurring 4 pixels)\n\n                vec2 blurUv = persistanceUV - prevM_Vec.xy * prevLineLength * lineLength * 400. * toBlur * maxDist;\n\n                vec4 up = texture(iChannel0, blurUv + off);\n                vec4 down = texture(iChannel0, blurUv + vec2(off.x,-off.y));\n                vec4 left = texture(iChannel0, blurUv + vec2(-off.x, off.y)); \n                vec4 right = texture(iChannel0, blurUv - off);\n                float total = up.a + down.a + left.a + right.a + 0.01;\n                vec4 blurred = (up*up.a+down*down.a+left*left.a+right*right.a) / total;\n\n                col = mix(col, blurred, min(1.,toBlur));\n                \n                \n                \n                fragColor = max(vec4(0.,0.,0.,0.), mix(col, brushColor, maskb));\n                //fragColor.rgb = sqrt(fragColor.rgb);\n\n               // fragColor.rgb = vec3(ruv*20.,0.);\n            } else {\n                fragColor = col;\n            }\n            \n         } else \n         {\n            float brightness = persistanceUV.y * SAMPLER_AREA;\n            float contrast = (persistanceUV.x - BRIGHNESS_AREA) / (1. - BRIGHNESS_AREA);\n            fragColor = mix(vec4(1.), brushHUE, contrast) *  brightness;\n            fragColor.a = 1.;\n            \n            float dist = length(iResolution.yx * vec2(SAMPLER_AREA, 1. - BRIGHNESS_AREA ) * 0.02 * vec2(brushBrightness - brightness, brushContrast -contrast ));\n            \n            fragColor.rgb = mix(fragColor.rgb, vec3(1.), smoothstep(0.03, 0., abs(dist - 0.1)) );\n            \n        }\n        \n    } else {\n        \n    \t// TOP PART\n\n        float x = persistanceUV.x;\n\n        float down = clamp(iMouse.z * 800., 0. , 1.);\n    \n        float click = down * max(0.,1. - force*100.); // Not down previous frame\n           \n    \tforce = clamp(down*iTimeDelta * 5. + force, 0. , 1.) * down;\n        \n        if (persistanceUV.y>PERSIST_AREA)\n        {\n            // STORING DATA\n\n            realM = M;\n            float path = length(prevM.xy - realM.xy);\n            storeValue(P_MOUSEVEC, vec4(\n                (lineLength>0.001 \n                ? normalize(realM-prevM.xy)\n                : vec2(0.,0.)) + 0.5,\n                lineLength, thickness), fragColor, persistanceUV);\n            \n            thickness = mix(thickness, 1./(path*5. + .1) + 0.5, min(0.3,path*5.)) * down;\n            \n            storeValue(P_MOUSEPOS, vec4(realM + 0.5, force, thickness), fragColor, persistanceUV);\n           \n            if (isStoreArea(BRUSH_COLOR, persistanceUV))\n            {\n\n                float inSamplingArea = clamp((MousePos.y - SAMPLER_AREA) * 100., 0., 1.);\n                \n                fragColor = mix(brushColor, GetColorPalette(MousePos.x), click * inSamplingArea );\n                \n            } else if (isStoreArea(BRUSH_BRIGHTNESS, persistanceUV))\n            {\n                float hueSampler = clamp((MousePos.y - SAMPLER_AREA) * 100., 0., 1.);\n            \n                float inBrightnessArea = (1. - hueSampler) * clamp((MousePos.x - BRIGHNESS_AREA) * 1000., 0., 1.);\n\n                brushBrightness = mix(brushBrightness, MousePos.y * SAMPLER_AREA, click * inBrightnessArea);\n                brushContrast = mix(brushContrast, (MousePos.x - BRIGHNESS_AREA) / (1. - BRIGHNESS_AREA) , click * inBrightnessArea);\n                \n                fragColor = vec4(brushBrightness, brushContrast, 0, 0);\n            }\n            \n        } else {\n            // PALETTE\n            fragColor = GetColorPalette(x);\n            \n            float dist = length(brushColor.rgb - fragColor.rgb);\n            \n            fragColor.rgb = mix(fragColor.rgb, vec3(1.), smoothstep(0.01, 0., dist));\n            \n        }\n    }\n    \n}", "buffer_a_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * Analytic Spline Distance\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec2 k = vec2(1.,0.);\nconst float pi = acos(-1.);\n\nfloat dist(vec2 p_0,vec2 p_1,vec2 p_2,vec2 x,float t)\n{\n    return length(x-pow(1.-t,2.)*p_0-2.*(1.-t)*t*p_1-t*t*p_2);\n}\n\nfloat DistToCurve(vec2 p_0,vec2 p_1,vec2 p_2, vec2 uv)\n{\n\t//coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = uv-p_0;\n    vec2 F = p_2-2.*p_1+p_0;\n    vec2 G = p_1-p_0;\n    vec3 coeff = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n    float a = coeff.x;\n    float b = coeff.y;\n    float c = coeff.z;\n\n\t//discriminant and helpers\n    float p = b-a*a/3.;\n    float q = 2.*a*a*a/27.-a*b/3.+c;\n    float dis = q*q/4.+p*p*p/27.;\n    float tau = a/3.;\n    \n    //solution with cardan formula\n    float sqrtDis = sqrt(dis);\n    float k1 = -.5*q+sqrtDis;\n    float k2 = -.5*q-sqrtDis;\n    float u = sign(k1)*pow(abs(k1), 1./3.);\n    float v = sign(k2)*pow(abs(k2), 1./3.);\n    \n    float t_min = 1.;\n    \n    if(dis > 0.)\n    {\n        t_min = u+v-tau;\n        t_min = clamp(t_min, 0.,1.);\n    }\n    else if(dis < 0.)\n    {\n      \n        \n        float fac = sqrt(-4./3.*p);\n        float arg = -.5*q*sqrt(-27./p/p/p);\n        float acosArg = acos(arg)/3.;\n        \n           float t1 = -fac*cos(acosArg+pi/3.)-tau,\n            t2 = fac*cos(acosArg)-tau,\n            t3 = -fac*cos(acosArg-pi/3.)-tau;\n        t1 = clamp(t1,0.,1.);\n        t2 = clamp(t2,0.,1.);\n        t3 = clamp(t3,0.,1.);\n        float b1 = dist(p_0,p_1,p_2,uv,t1),\n            b2 = dist(p_0,p_1,p_2,uv,t2),\n            b3 = dist(p_0,p_1,p_2,uv,t3);\n        t_min = mix(mix(t1, t2, step(b2, b1)), t3, step(b3, min(b1, b2)));\n    } \n    \n    return dist(p_0,p_1,p_2,uv,t_min);\n}\n\n// *************************************** \n\nvec2 Rotate(in vec2 uv, in float angle)\n{\n\n\tfloat si = sin(angle);\n\tfloat co = cos(angle);\n\tfloat tx = uv.x;\n\tfloat ty = uv.y;\n\tuv.x = (co * tx) - (si * ty);\n\tuv.y = (si * tx) + (co * ty);\t\n\n    return uv;\n}\n\nfloat DistToLine(vec2 pos, vec2 a, vec2 b) {\n\t\tvec2 pa = pos - a;\n\t\tvec2 ba = b - a;\n\t\tfloat t = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n\t\treturn length(pa - ba * t);\n\t}\n\nvec4 GetColorPalette(in float x)\n{\n    float r = smoothstep(0.33, 0., x) + smoothstep(0.66, 1., x);\n    float g = smoothstep(0., 0.33, x)* smoothstep(0.66, 0.33, x);\n    float b = smoothstep(0.33, 0.66, x)* smoothstep(1., 0.66, x);\n    \n    vec3 col = sqrt(vec3(r,g,b)); // not sure about this\n    \n\treturn vec4(col, 1);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 749]], "test": "untested"}
