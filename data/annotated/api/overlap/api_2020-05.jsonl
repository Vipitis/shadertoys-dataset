{"id": "wdBfD3", "name": "Aquatic Ecosystem", "author": "jarble", "description": "It's alive!\nClick and drag the mouse to look around.", "tags": ["raymarching", "fish", "swimming", "creatures"], "likes": 4, "viewed": 357, "published": 3, "date": "1590961960", "time_retrieved": "2024-07-30T21:03:49.141065", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\n\nconst float scale = EPSILON*100.0;\n\nvec3 animate(vec3 p){\n    float t1 = iTime/10.0;\n    vec3 p1 = p/100.0+vec3(t1,t1,t1);\n    p += vec3(sin(p1.y+t1)+cos(p1.z),sin(p1.z)+cos(p1.x),sin(p1.x)+cos(p1.y))*100.0;\n    return p;\n}\n\nvec3 surface_color(in vec3 uv)\n{\n    uv /= scale;\n    uv = animate(uv);\n    //uv /= scale;\n    \n    uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(sin(vec2(uv.x, uv.y)));\n        uv.x = uv.y + uv.x;\n        uv.y = uv.x - uv.y;\n    }\n    return vec3((lar * .5), lar*.7, lar)*1.5;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    p = animate(p);\n\n    float to_return = 3.9 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n    return to_return * scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    vec3 eye = scale*vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*50.0; \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 305, 305, 471], [473, 473, 505, 505, 797], [799, 1039, 1063, 1063, 1226], [1228, 1649, 1740, 1740, 2046], [2061, 2315, 2380, 2380, 2512], [2514, 2603, 2632, 2632, 2942], [2944, 3436, 3576, 3576, 4166], [4168, 4538, 4623, 4623, 4982], [4984, 5311, 5360, 5395, 5526], [5528, 5528, 5585, 5585, 6599]], "test": "untested"}
{"id": "wdBBW3", "name": "Happy Swirl", "author": "BeardThings", "description": "Happy Little Swirl\n\n(Interested in a way to reduce the high frequency noise)", "tags": ["raymarched", "swirl", "sdf", "blur", "colorful", "colourful", "happy", "pastel"], "likes": 4, "viewed": 374, "published": 3, "date": "1590956568", "time_retrieved": "2024-07-30T21:03:49.916991", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n   \tfragColor += textureLod(iChannel0, fragCoord/iResolution.xy, length(uv*2.-1.)*2.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float sdf(vec3 p,out vec3 c)\n{\n    vec3 colors[5] = vec3[5](\n        vec3(0.4,0.7,0.9),\n        vec3(0.5,0.8,0.9),\n        vec3(0.9,0.6,0.6),\n        vec3(0.9,0.4,0.5),\n        vec3(0.9,0.4,0.7));\n    \n    float sdf=1000.;\n    const int n=5;\n    for(int i = 0; i < n; i++)\n    {\n        float t=2.*3.1415/float(n)*float(i);\n        float r=0.4;\n        \n        float time = float(iFrame)*0.016;\n        vec3 o=vec3(cos(time+t+p.z*2.)*r,sin(time+t+p.z*2.)*r,0.);\n        \n    \tfloat pd=dot(p-o,p-o);\n    \tfloat sd=dot(p,vec3(0.,0.,1.));\n    \tfloat df=sqrt(pd-sd*sd)-.03;\n        if(df < sdf)\n        {\n            sdf = df;\n            c = colors[i]+pow(dot(normalize(p.xy-o.xy),vec2(1.,0.)),2.);\n        }\n    }\n    return sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    fragColor = vec4(0.);\n    \n    vec3 o=vec3(0.,0.,-1.);\n    vec3 d=normalize(vec3(0.,0.,1.)+vec3(uv.x/iResolution.y*iResolution.x,0.,0.)+vec3(0.,uv.y,0.));\n    float s=0.;\n    for(int i=0;i<13;i++)\n    {\n        vec3 p=o+d*s;\n        \n        vec3 c;\n        float di=sdf(p, c);\n        if(di<0.01)\n        {\n            float e=0.001;\n            vec3 t;\n            vec3 n=normalize(vec3(di-sdf(p-vec3(e,0.,0.),t),\n                        di-sdf(p-vec3(0.,e,0.),t),\n                        di-sdf(p-vec3(0.,0.,e),t)));\n            \n            vec3 dir=d;\n            fragColor.rgb=c*(dot(-dir,n)+1.)*0.5;\n            fragColor.a=1.;\n            break;\n        }\n        s+=di;\n    }\n    \n    ivec2 tex=ivec2(fragCoord+vec2(1.));\n    vec4 c = textureLod(iChannel0, vec2(tex)/iResolution.xy, 1.);\n    fragColor = fragColor + c*(1.-fragColor.a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 186]], "test": "untested"}
{"id": "Wty3zV", "name": "Vortex Dust", "author": "irwatts", "description": "Inspired by David Bruce's work on the '80s HBO intro. (https://youtu.be/agS6ZXBrcng?t=329)", "tags": ["procedural", "mask", "vortex", "sinusoidal", "dust"], "likes": 18, "viewed": 883, "published": 3, "date": "1590954151", "time_retrieved": "2024-07-30T21:03:50.800147", "image_code": "const int ITERATIONS = 64;\nconst float SPEED = 0.25;\nconst float PAN = 2.8;\nconst float MASK_VIS = 0.0; // Set between 0-1 to visualize masks\n\nfloat vortex(vec2 uv, float dist, float seed, float bias, float offset)\n{\n    float ang = atan(uv.y, uv.x)+sin(dist+0.1*seed)*(1.2-offset)*2.0;\n    ang += 3.14159*(0.01*seed);\n    return clamp((sin((ang)*(3.0+offset*float(ITERATIONS)))+bias)/(1.0+bias), 0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(iResolution.xy*0.5))/iResolution.y;\n    float texel = 1.0/iResolution.y;\n    float dist = length(uv);\n    vec3 col = vec3(0.0);\n    for (int i=0; i<ITERATIONS; i++) \n    {\n        float offset = float(i)/float(ITERATIONS);\n        float seed = 1000.0*fract(3.1379136*floor(iTime*SPEED+offset));\n        float time = fract(iTime*SPEED+offset);\n        vec2 pan = vec2(0.0, time*PAN);\n        float maskA = vortex(uv, dist, seed+100.0*float(i), -0.998+texel, offset);\n        float dist2 = length(uv+pan);\n        float maskB = vortex(uv+pan, dist2, seed+42.0*float(i), -0.99+texel, offset);\n        float radius = pow(((maskA*maskA)+(maskB*maskB)), 2.0);\n        float fade = time*(1.0-time);\n        float mask = maskA*maskB*fade*radius;\n        col = mix(col, vec3(0.42+1.0*dist-0.2*offset-0.1*radius, 0.75-0.5*offset-0.5*dist, 1.0-0.8*dist), mask);\n        col = max(vec3(maskA*MASK_VIS, maskB*MASK_VIS+0.1, max(maskA*MASK_VIS*2.0, maskB*MASK_VIS)+0.12)*fade, col);\n    }\n    fragColor = vec4(col*4.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 216, 216, 409], [410, 410, 467, 467, 1508]], "test": "untested"}
{"id": "WdBfDc", "name": "Rainbow Fractal Galaxy", "author": "jarble", "description": "This galaxy is full of fractal-patterned objects.\n\nClick and drag the mouse to look around!", "tags": ["3d", "raymarching", "fractal", "galaxy"], "likes": 1, "viewed": 360, "published": 3, "date": "1590949209", "time_retrieved": "2024-07-30T21:03:51.667827", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 surface_color(in vec3 uv)\n{\n   uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(vec2(uv.x, uv.y));\n        uv.x = uv.y + sin(uv.x-(uv.z+uv.y))+(uv.x);\n        uv.y = uv.x + sin(uv.y-(uv.z+uv.x))-(uv.y);\n    }\n    return cos(vec3(lar * 2.0, lar * 3.0, lar * 1.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    float py1 = p.y;\n    float px1 = p.x;\n    float pz1 = p.z;\n    p.x += (sin(py1/100.0)+cos(pz1/100.0))*100.0;\n    p.y += cos(sin(pz1/100.0)+cos(px1/100.0))*100.0;\n    p.z += sin(sin(px1/100.0)+cos(py1/100.0))*100.0;\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    return  3.9 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n         if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    vec3 eye = vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*50.0;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 282, 282, 562], [564, 804, 828, 828, 1259], [1261, 1682, 1773, 1773, 2079], [2094, 2348, 2413, 2413, 2545], [2547, 2636, 2665, 2665, 2975], [2977, 3469, 3609, 3609, 4199], [4201, 4571, 4656, 4656, 5414], [5416, 5743, 5792, 5827, 5958], [5960, 5960, 6017, 6017, 7051]], "test": "untested"}
{"id": "3dSBDc", "name": "glitchy edge detection alt", "author": "thefox231", "description": "alternative ver of https://www.shadertoy.com/view/WsBfWc", "tags": ["edgedetection", "glitch"], "likes": 2, "viewed": 381, "published": 3, "date": "1590943678", "time_retrieved": "2024-07-30T21:03:52.514564", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 offset = texture(iChannel1, uv).xz;\n    vec2 uvOff = (fragCoord + offset) / iResolution.xy;\n\n    vec4 color = texture(iChannel0, uv);\n    vec4 color2 = texture(iChannel0, 1.0 - uvOff);\n    \n    fragColor = mod(color / color2, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 350]], "test": "untested"}
{"id": "WsBfWc", "name": "glitchy edge detection", "author": "thefox231", "description": "glitchy lil edge detection attempt", "tags": ["edgedetection", "glitch"], "likes": 4, "viewed": 478, "published": 3, "date": "1590943497", "time_retrieved": "2024-07-30T21:03:53.409171", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 offset = texture(iChannel1, uv).xz;\n    vec2 uvOff = (fragCoord + offset) / iResolution.xy;\n\n    vec4 color = texture(iChannel0, uv);\n    vec4 color2 = texture(iChannel0, uvOff);\n    \n    fragColor = mod(color / color2, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 344]], "test": "untested"}
{"id": "3sBfWc", "name": "Tempest Spirale", "author": "Paltoquet", "description": "use of sin radom function with angular coordinate.\nHow can i improve, add color ?", "tags": ["random"], "likes": 0, "viewed": 289, "published": 3, "date": "1590943445", "time_retrieved": "2024-07-30T21:03:54.233966", "image_code": "\n#define PI 3.14159\n\nfloat random (float theta, float time) {\n    //float period = mod(time, 10.0) ;\n    float period = 230.000;\n    return fract(sin(dot(theta, period * period))* 2.856);\n}\n\nfloat period(float theta, float nbCroissant) {\n    float period = 2.0 * PI;\n\tperiod = period * nbCroissant;\n    return sin(theta * period);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord/iResolution.xy;\n\n    float speed = 15.0;\n    float nbCroissant = mod(iTime * speed, 200.0);\n    //float nbCroissant = 1.0;\n    st = st * vec2(2.0) - vec2(1.0);\n    float theta = atan(st.y, st.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    float currentCroissant = floor(current * nbCroissant);\n    \n    float amplitude = random(currentCroissant, iTime);\n    \n    float range = period(current, nbCroissant);\n    float dist = length(st);\n    range = range * amplitude;\n    \n    vec3 color = dist < range ? vec3(range) : vec3(0.0);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 61, 100, 189], [191, 191, 237, 237, 332], [334, 334, 390, 390, 1140]], "test": "untested"}
{"id": "ws2BDK", "name": "ABasicFluid", "author": "EvilRyu", "description": "Basic fluid simulation, with a high vorticity confinement, the result looks interesting (although pretty wrong)", "tags": ["fluid", "navierstokes", "gridbased"], "likes": 33, "viewed": 767, "published": 3, "date": "1590937970", "time_retrieved": "2024-07-30T21:03:54.990942", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// from aiekick： https://www.shadertoy.com/view/lttXDn\nvec3 blackbody(float t)\n{\n\tfloat Temp = t*7500.0;\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord/iResolution.xy;\n    vec3 col=texture(iChannel3,pos).xyz;\n    col=blackbody(smoothstep(-3.,250.,length(col)));\n    float d=distToOcc(pos,iResolution.xy, iTime);\n    col.xyz+=vec3(.6)*(1.-smoothstep(0.,.1, d));\n    fragColor.xyz=col.xyz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Advection and body force\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize=1./iResolution.xy;\n    vec2 pos=fragCoord.xy*pixelSize;\n    \n    // semi-lagrangian\n    vec2 U=texture(iChannel3,pos).xy;    \n    vec2 prevPos=pos-iTimeDelta*U*pixelSize;\n    \n    // Interpolation is done by sampling\n    vec2 Unext = texture(iChannel3,prevPos).xy;\n    \n    // Body forces\n   \n    if(pos.x>=0.43 && pos.x<=0.5 && pos.y<=1. && pos.y>=0.8)\n    {\n        Unext+=iTimeDelta*vec2(0.,-1000.);\n    }\n    \n    if(pos.x>=0. && pos.x<=0.1 && pos.y<=.5 && pos.y>=.45)\n    {\n        Unext+=iTimeDelta*vec2(1000.,0.);\n    }\n    \n    if(pos.x>=0. && pos.x<=0.1 && pos.y<=.5 && pos.y>=.45)\n    {\n        Unext+=iTimeDelta*vec2(1000.,0.);\n    }\n    \n     if(pos.x>=.9 && pos.x<=1. && pos.y<=.5 && pos.y>=.45)\n    {\n        Unext+=iTimeDelta*vec2(-1000.,0.);\n    }\n    \n    if(iMouse.z>0.||iMouse.w>0.)\n    {\n        float intensity=smoothstep(0.,0.05,length((fragCoord.xy-iMouse.xy)/iResolution.xy));\n        Unext*=intensity;\n    }\n        \n    // Vorticity confinement force\n    float W=texture(iChannel1, pos).y;\n    float Wleft=texture(iChannel1, pos-vec2(pixelSize.x,0)).y;\n    float Wright=texture(iChannel1, pos+vec2(pixelSize.x,0)).y;\n    float Wdown=texture(iChannel1, pos-vec2(0,pixelSize.y)).y;\n    float Wup=texture(iChannel1, pos+vec2(0,pixelSize.y)).y;\n    \n    vec3 GradW=vec3(Wright-Wleft, Wup-Wdown, 0.)*.5;\n    vec2 Fcon=cross(GradW/(length(GradW)+1e-10), vec3(0,0,W)).xy;\n    \n    Unext+=50.*iTimeDelta*Fcon;\n    \n        \n    // Boundary conditions\n    if(pos.x > 1.0 - pixelSize.x ||\n      \tpos.y > 1.0 - pixelSize.y ||\n      \tpos.x < pixelSize.x ||\n      \tpos.y < pixelSize.y)\n    {\n        Unext = vec2(0.0, 0.0);\n    }\n    \n    // occluder\n    if(distToOcc(pos, iResolution.xy, iTime)<=0.)\n   \t{\n        Unext=vec2(0);\n    }\n   \n    // output Fcon is just for visualization\n    fragColor=vec4(Unext,Fcon);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Divergence/Vortocity\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize=1./iResolution.xy;\n    vec2 pos=fragCoord.xy*pixelSize;\n    \n    vec2 left=texture(iChannel0, pos-vec2(pixelSize.x,0)).xy;\n    vec2 right=texture(iChannel0, pos+vec2(pixelSize.x,0)).xy;\n    vec2 down=texture(iChannel0, pos-vec2(0,pixelSize.y)).xy;\n    vec2 up=texture(iChannel0, pos+vec2(0,pixelSize.y)).xy;\n    \n    // Central difference\n    float D=((right.x-left.x) + (up.y-down.y))*0.5;\n    \n    // Vortisity\n    float W=((right.y-left.y) - (up.x-down.x))*0.5;\n    \n    fragColor = vec4(D,W,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Jacobian\n\nvec2 pixelSize;\nfloat P;\n\nfloat getPressure(vec2 pos, bool hori)\n{\n    if(distToOcc(pos, iResolution.xy, iTime)<=0.)\n    {\n        if(hori)\n        {\n            return P+rho*dx/iTimeDelta*texture(iChannel0, pos).x;\n        }\n        else\n        {\n            return P+rho*dx/iTimeDelta*texture(iChannel0,pos).y;\n        }\n        \n    }\n    if(pos.x<pixelSize.x || pos.x>1.-pixelSize.x)\n    {\n        return P+rho*dx/iTimeDelta*texture(iChannel0, pos).x;\n    }\n    else if(pos.y<pixelSize.y || pos.y>1.-pixelSize.y)\n    {\n        return P+rho*dx/iTimeDelta*texture(iChannel0,pos).y;\n    }\n    else\n    {\n        return texture(iChannel2, pos).x;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pixelSize=1./iResolution.xy;\n    vec2 pos=fragCoord.xy*pixelSize;\n    \n    float D=texture(iChannel1,pos).x;\n    \n    // Using previous pressure as guess\n    float Pleft, Pright, Pup, Pdown;\n    \n    P=texture(iChannel2,pos).x;\n    \n    float Usolid=0.;\n              \n    Pleft=getPressure(pos-vec2(pixelSize.x,0),true);\n    Pright=getPressure(pos+vec2(pixelSize.x,0),true);\n    Pup=getPressure(pos+vec2(0,pixelSize.y),false);\n    Pdown=getPressure(pos-vec2(0,pixelSize.y),false);\n    \n    P=(Pleft+Pright+Pup+Pdown-D*rho*dx/iTimeDelta)/4.;\n\n    fragColor = vec4(P,0,0,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Velocity field substract pressure gradient force\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize=1./iResolution.xy;\n    vec2 pos=fragCoord.xy*pixelSize;\n\t\n    vec2 U=texture(iChannel0,pos).xy;\n    \n    float Pleft=texture(iChannel2, pos-vec2(pixelSize.x,0)).x;\n    float Pright=texture(iChannel2, pos+vec2(pixelSize.x,0)).x;\n    float Pup=texture(iChannel2, pos+vec2(0,pixelSize.y)).x;\n    float Pdown=texture(iChannel2, pos-vec2(0,pixelSize.y)).x;\n    \n\n    vec2 dP=vec2((Pright-Pleft)/dx, (Pup-Pdown)/dx)*.5;\n    U-=dP*iTimeDelta/rho;\n    fragColor = vec4(U,0,0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float rho=1.;\nconst float dx=1.;\n\nfloat hash11(float p)\n{\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat noise(float x)\n{\n    float p=floor(x);\n    float f=fract(x);\n    f=f*f*(3.-2.*f);\n    return mix(hash11(p),hash11(p+1.0),f);\n}\n\nmat3 m_rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3( c, s, 0, -s, c, 0, 0, 0, 1);\n}\nmat3 m_trans(float x, float y)\n{\n    return mat3(1., 0., 0., 0., 1., 0, -x, -y, 1.);\n}\nmat3 m_scale(float s)\n{\n    return mat3(s, 0, 0, 0, s, 0, 0, 0, 1);\n}\n\nfloat distToOcc(vec2 pos, vec2 resolution, float time)\n{\n    float ratio=resolution.x/resolution.y;\n    pos.x*=ratio;\n\tpos=pos*2.-1.;\n    pos*=0.6;\n    pos.x-=.4;\n   \n    pos*=6.0;\n    pos.y+=3.;\n   \tvec3 p = vec3(pos, 1.);\n    float d = 1.0;\n    for(int i = 0; i < 7; ++i)\n    {\n        d=min(d,(length(max(abs(p.xy)-vec2(0.01,1.0), 0.0)))/p.z);\n        p.x=abs(p.x);\n        float pi=3.1415936;\n        p=m_scale(1.22) * m_rot(0.25*pi) * m_trans(0.,3.*noise(float(i))) * p;\n\n    }\n    \n    d=smoothstep(0.1, 0.15,d);\n    return d;\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BDK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[110, 167, 192, 192, 544], [546, 546, 603, 603, 866]], "test": "untested"}
{"id": "wdSfWh", "name": "circuits all the way down", "author": "unnick", "description": "a recreation of [url]https://youtu.be/V4oRHv-Svwc?t=90[/url]", "tags": ["2d"], "likes": 4, "viewed": 320, "published": 3, "date": "1590933917", "time_retrieved": "2024-07-30T21:03:56.021188", "image_code": "#define res iResolution.xy\n#define ires ivec2(res)\n\n#define decaysp vec2(3, 30)\n#define colormat (mat2x3(.5,.6,.2, .9,.95,1) * mat2x2(1,0,-1,1))\n#define op(x,y) x^y\n#define speed 0x625b\n\nint modinv(int a, int m) {\n    int r = 1; int q = 0;\n    for(int i = 0; i < m; i++) {\n        q |= r & (1 << i);\n        r += (-((r >> i) & 1)) & (a << i);\n    }\n    return q;\n}\n\nvoid mainImage(out vec4 color, in vec2 _pos) {\n    int m = int(floor(log2(max(res.x, res.y)))); int s = 1 << m;\n    ivec2 pos = ivec2(_pos) - (ivec2(ires.xy) >> 1);\n    float t = fract(float(((op((pos.x), (pos.y))) * modinv(speed, m) + iFrame) & (s-1)) / float(s));\n    color.rgb = colormat * exp(-t * decaysp);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 213, 213, 364], [366, 366, 412, 412, 679]], "test": "untested"}
{"id": "WsBfW3", "name": "Fractal textured planet", "author": "jarble", "description": "This planet's surface is colored by a 3-dimensional fractal.", "tags": ["raymarching", "fractal", "planet"], "likes": 2, "viewed": 299, "published": 3, "date": "1590930437", "time_retrieved": "2024-07-30T21:03:56.918788", "image_code": "/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = (50.0+20.0*sin(iTime/5.0))*vec3(sin(iTime/5.0), sin(iTime/6.0), cos(iTime/5.0));\n    \n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = (50.0+20.0*sin(iTime/5.0))*vec3(sin(iTime/5.0), sin(iTime/6.0), cos(iTime/5.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "common_code": "#define image_scale 8.0\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 surface_color(in vec3 uv)\n{\n    uv /= sin(uv.x*uv.y*uv.z/15.0)+10.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(vec2(uv.x, uv.y));\n        uv.x = uv.y + sin(uv.x-(uv.z+uv.y))+(uv.x);\n        uv.y = uv.x + sin(uv.y-(uv.z+uv.x))-(uv.y);\n    }\n    return vec3(cos(lar * 2.0), cos(lar * 3.0), cos(lar * 1.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p *= 1.0;\n    return length(p/10.0)-2.0+(sin(p.x+2.0+(sin(p.y+4.0+(sin(p.z+8.0)))))+sin(p.y+2.0+(sin(p.z+4.0+(sin(p.x+8.0)))))+sin(p.z+2.0+(sin(p.y+4.0+(sin(p.x+8.0))))))/30.0;\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.1, 0.1, 0.1);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 421, 512, 512, 824], [839, 839, 866, 866, 1015], [1017, 1017, 1074, 1074, 1797]], "test": "untested"}
{"id": "WdBBW3", "name": "multi-scale truchet scaled - 2", "author": "FabriceNeyret2", "description": "\"multi-scale truchet scaled\" by phi16 simplified and commented [url]https://shadertoy.com/view/wdjfDK[/url]\n\nThen golfed (+further simplif) there (unlisted) [url]https://www.shadertoy.com/view/wd2fD3[/url]", "tags": ["2d", "truchet"], "likes": 27, "viewed": 441, "published": 3, "date": "1590927519", "time_retrieved": "2024-07-30T21:03:57.917119", "image_code": "// Fork of \"multi-scale truchet scaled\" by phi16. (1825) https://shadertoy.com/view/wdjfDK\n// Simplified and commented.\n\n// hash(int(p)) with seed varying with parameter i and time\n#define rand(p,i) fract(  sin( dot( ceil(p), vec2(12.9,78.2) ) ) * 4e5  \\\n                         + .2 + 1.4 * (i + floor(iTime/2.) )            \\\n                       )             \nfloat H(vec2 U) {                           // choose truchet LOD\n    float i=0.;\n    for( ; i < 5. ; i++, U*=2. )\n        if( U.y > 1. && ( abs(U.y) > 2. || rand(U,i) < .5 ) ) break;\n \n    return i;\n}\n\nvoid mainImage( out vec4 O, vec2 co )\n{\n    vec2 R = iResolution.xy, F,\n         U = co / R.y - vec2( .5*R.x/R.y, - .075);\n    \n    float z =  1.8 * exp2(-fract(iTime/2.)),// zooming coordinates\n          h = H(U*=z), s = exp2(h), u,v,d;  // truchet LOD h and scale s\n    \n    F = fract(U*s);                         // local coords in truchet tile    \n    v = rand( U*s, h ) -.5;                 // 2 rands per tile: sign,abs\n\n    if( v < 0.) F = vec2( 1.-F.y, F.x );    // < 0 : rotate 90°\n    v = abs(v);                             // [0,.5]\n    d =  v > .4                             // 20% luck:\n           ? min(  abs( length(F)    - .5 ),// round parts at one of the 2 ends\n                   abs( length(F-1.) - .5 )\n                ) -1./6. \n       : v > .1                             // 60% luck:\n           ? min(       abs(F.y-.5)  -1./6.,// segment parts\n                  max(  abs(F.x-.5) - 1./6.,// crossing ?\n                      -(abs(F.y-.5) - 1./4.) \n                )    )\n       :     min( abs( F.y = abs(F.y-.5) ), // 20% luck:\n                  length( F-.5 )            // semi-round parts ?\n                ) - 1./6.;\n   \td /= s;        \n    \n    for(float c,i=h; i < 6.; i++, s*=2., d=-d) {  // draw all LOD >= h\n        F = round(U*s)/s;                   // local tile id\n        vec2 e = vec2(-1,1)/64.;            // ( any small value ? )\n        c = max( max( H( F + e.xx),         // seek deepest LOD \"around\"\n                      H( F + e.yx)),\n                 max( H( F + e.xy),\n                      H( F + e.yy)) );\n        if( i < c )                         // if less deep,\n            u = length(U - F) - 1./6./s,    // draw disk (?) \n            d = min( d, u );                // ( not sure why we continue )\n    }\n    int(iTime/2.) % 2 >0 ? d = -d : d;      // for cycling continuity, alternate BW\n    O = vec4( .5+.5* d*R.y/z );             // paint with AA\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 384, 432, 568]], "test": "untested"}
{"id": "3sSBW3", "name": "Julia set Yolk of the dragon", "author": "workingclasshacker", "description": "messing around in the yolk of a dragon egg", "tags": ["fractal"], "likes": 2, "viewed": 291, "published": 3, "date": "1590925819", "time_retrieved": "2024-07-30T21:03:58.868575", "image_code": "#define MAXITER 10000\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n    uv+=.9*sin(iTime*.2)*.1;\n    float t = iTime*.2;\n    uv*=cos(t/2.);\n    //uv +=sin(t)*.1;\n    vec2 z = vec2(uv.y*3., uv.x*2.);\n    vec2 c = vec2(sin(t),cos(t)*sin(t));\n    int i;\n    int max = 0;\n    for(i=0;i<100;i++){\n     \tfloat x = z.x;\n        z.x = x*x-z.y*z.y+c.x;\n        z.y = 2.*x*z.y+c.y;\n        if(i>max){\n         \tmax = i;\t   \n        }\n        if(length(z)>2.0 || i>MAXITER){\n         \tbreak;   \n        }\n    }\n\tfloat n = 0.0;\n    if(length(z)<2.){\n     \tn = 1.0;   \n    }\n    \n    float mu = 1.+float(i)+log(log2(length(z)))/log2(2.);\n    vec3 col = vec3(mu/float(MAXITER));\n    // Output to screen\n    col.r = sin(1./mu);\n    col.g = tan(1./(mu*.1));\n    if(col.g >.5){\n     \tcol.r = col.g;   \n    }\n    col.b = 0.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 129, 966]], "test": "untested"}
{"id": "td2fDV", "name": "Сolorful hills", "author": "avin", "description": "Color experiment", "tags": ["colors", "lines", "sin", "curve"], "likes": 16, "viewed": 475, "published": 3, "date": "1590925280", "time_retrieved": "2024-07-30T21:03:59.820032", "image_code": "#define COUNT 50.\n#define COL_BLACK vec3(23,32,38) / 255.0 \n\n#define SF 1./min(iResolution.x,iResolution.y)\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    \n    float m = 0.;\n    float t = iTime *.5;\n    vec3 col;\n    for(float i=COUNT; i>=0.; i-=1.){        \n        float edge = -.1 + i*.025 + sin(iTime + uv.x*10. + i*100.)*.1 + cos(iTime + uv.x*2.5 + i*100.)*.1;\n        float mi = SS(edge, uv.y - 1.) - SS(edge + .0025, uv.y);        \n        m *= SS(edge, uv.y+.01);\n        m += mi;        \n        \n        if(mi > 0.){\n        \tcol = hue(i/COUNT).rgb;\n        }        \n    }           \n    \n    col = mix(COL_BLACK, col, m);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2fDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 285, 285, 850]], "test": "untested"}
{"id": "wdjfDK", "name": "multi-scale truchet scaled", "author": "phi16", "description": "Inspired by [url]https://www.shadertoy.com/view/4t3BW4[/url]", "tags": ["2d", "truchet"], "likes": 25, "viewed": 480, "published": 3, "date": "1590914707", "time_retrieved": "2024-07-30T21:04:00.686713", "image_code": "float rand(vec2 co, float i){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453 + 0.2 + sqrt(2.) * (i + floor(iTime/2.)));\n}\n\nfloat pattern(vec2 uv, vec2 seed, float seedi) {\n    float v = rand(seed, seedi);\n    if(v < 0.5) uv.xy = vec2(1.-uv.y,uv.x);\n    if(distance(v,0.5) > 0.4) {\n        return min(\n            distance(distance(uv,vec2(0)),0.5)-1./6.,\n            distance(distance(uv,vec2(1)),0.5)-1./6.\n        );\n    } else if(distance(v,0.5) > 0.1) {\n        return min(\n            distance(uv.y,0.5)-1./6.,\n            max(\n                distance(uv.x,0.5)-1./6.,\n                - (distance(uv.y,0.5)-1./4.)\n            )\n        );\n    } else {\n        uv.y = abs(uv.y-0.5);\n        return min(\n            abs(uv.y)-1./6.,\n            distance(uv,vec2(0.5,0.5))-1./6.\n        );\n    }\n}\n\nint hierarchy(vec2 uv) {\n    float u = 1.0;\n    for(int i=0;i<5;i++) {\n        vec2 iuv = floor(uv*u)/u;\n        float s = 1./u;\n        if((distance(iuv.y,0.) > s || rand(iuv*u, float(i)) < 0.5) && iuv.y > s/4.) return i;\n        u *= 2.;\n    }\n    return 5;\n}\n\nint chierarchy(vec2 uv) {\n    float s = 1./64.;\n    int h = 0;\n    h = max(h, hierarchy(uv + vec2(-s,-s)));\n    h = max(h, hierarchy(uv + vec2(+s,-s)));\n    h = max(h, hierarchy(uv + vec2(-s,+s)));\n    h = max(h, hierarchy(uv + vec2(+s,+s)));\n\treturn h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ut = fract(iTime/2.);\n    float it = floor(iTime/2.);\n    \n    vec2 uv = fragCoord / iResolution.y;\n    vec2 scr = uv;\n    uv.y += 0.075;\n    uv.x -= iResolution.x / iResolution.y / 2.;\n    uv *= 1.8 * pow(2.,-ut);\n    \n    float d = 0.;\n    vec2 luv = fract(uv);\n    int h = hierarchy(uv);\n    float flip = cos(float(h)*3.1415926535);\n    float s = pow(2.,float(h));\n    luv = fract(uv*s);\n    vec2 seed = floor(uv*s);\n   \td = pattern(luv, seed, float(h)) / s * flip;\n    s = 1.0;\n    for(int i=0;i<6;i++) {\n        vec2 corner = floor(uv*s+.5)/s;\n        int ch = chierarchy(corner);\n        if(h <= i && i < ch) {\n            float u = distance(uv, corner)-1./6./s;\n            if(i%2 == 0) d = min(d, u);\n            else d = max(d, -u);\n        }\n        s *= 2.;\n    }\n    d *= mod(it+0.5,2.) < 1.0 ? 1.0 : -1.0;\n    d /= pow(2.,-ut) / pow(2.,-scr.y);\n    \n    vec3 dr = mix(vec3(0.,2.,1.), vec3(1.,0.5,0.), exp(-scr.y)) * exp(min(0.,d)*200.);\n    vec3 br = mix(vec3(0.2,0.8,0.), vec3(0.8,0.6,0.2), exp(-scr.y));\n    vec3 col = mix(dr,br,smoothstep(-1.,1.,d*iResolution.y*2.));\n    fragColor = vec4(clamp(col,vec3(0.),vec3(1.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 142], [144, 144, 192, 192, 821], [823, 823, 847, 847, 1084], [1086, 1086, 1111, 1111, 1341], [1343, 1343, 1400, 1400, 2552]], "test": "untested"}
{"id": "ws2BWV", "name": "Good Faith - Madeon Webcam", "author": "jackwitherell", "description": "crummy attempt at copying and pasting code from the web to make something that people want for no reason other than its unique and hard to find", "tags": ["webcam", "colorfilter", "colorbalance", "madeon", "goodfaith"], "likes": 3, "viewed": 518, "published": 3, "date": "1590912683", "time_retrieved": "2024-07-30T21:04:01.432719", "image_code": "//in lieu of a docstring or any kind of documentation, I offer this\n\n//id rather you just reach out to me on discord if you wanna know how any of this works\n//please don't learn from my code it's disgusting and i'm tired\n\n\n\n//garbage maths\nfloat antidist(float br, float rang){\n    return (sin(        (1.0-abs(rang-br))*(3.14159/4.0)        ));\n}\n\n// stolen code!!!! https://www.shadertoy.com/view/XljGzV\nvec3 rgb2hsl( in vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original\n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax ) {\n\t\t\th = ( g - b ) / cDelta;\n\t\t} else if ( g == cMax ) {\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\t} else {\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\t\t}\n\n\t\tif ( h < 0.0) {\n\t\t\th += 6.0;\n\t\t}\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\n//also stolen, source is above\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n//heavily butchered version of gimp's color balance, thanks stackoverflow https://stackoverflow.com/questions/50522249/color-balance-with-core-image\nvec3 balanceFilter(highp vec3 textureColor, float brightness) {\n\n    float lightness = brightness; //hguefe\n\n    const float a = 0.25;\n    const float b = 0.333;\n    const float scale = 0.7;\n\n    //hack 0, dismiss old way of handling 'color offsets', cram in some green in the midtones (pretty much the only part of this function I didn't butcher\n    vec3 midtones = (((lightness - b) /  a + 0.5) * clamp ((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0) * scale) * vec3(-0.1,0.5,-0.1);\n\n    highp vec3 newColor = textureColor.rgb + midtones ;\n    \n    //hack 1, cram in some red in the shadows\n    newColor=newColor+vec3(-0.1*lightness+0.24,0.0,0.0);\n    \n    highp vec3 newHSL = rgb2hsl(newColor);\n    //hack 2, improperly use this functionality and create some inverse lum boy thing\n    highp float oldLum = sqrt( 0.299*pow(textureColor.r,2.0) + 0.587*pow(textureColor.g,2.0) + 0.114*pow(textureColor.b, 2.0) );\n    \n    \n    //hack 3, cram in some blum/\n    textureColor.rgb = hsl2rgb(vec3(newHSL.xy, oldLum))+vec3(0.0,0.0,lightness);\n\n    return textureColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // standard boilerplate shadertoy, ignore this if you're from the internet\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = texture(iChannel0,uv).rgb;\n    \n    //stolen code!!! https://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\n    float brightness = sqrt( 0.299*pow(col.r,2.0) + 0.587*pow(col.g,2.0) + 0.114*pow(col.b, 2.0) );\n    \n    //inverted canvas\n    col = 1.0 - col;\n    \n    //col = vec3(col.r + 0.299*(antidist(brightness, 0.1) - antidist(brightness, 0.7)),\n    //           col.g + 0.587*(antidist(brightness, 0.5) - antidist(brightness, 0.1) - antidist(brightness, 0.9)),\n    //           col.b + 0.3*(antidist(brightness, 0.9) - antidist(brightness, 0.3))\n    //          );\n    \n    col = balanceFilter(col, brightness);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 240, 277, 277, 347], [349, 406, 432, 432, 1114], [1115, 1146, 1173, 1173, 1316], [2531, 2531, 2588, 2667, 3465]], "test": "untested"}
{"id": "tdSBzc", "name": "just21", "author": "elle", "description": "21", "tags": ["number", "box", "gyroid"], "likes": 2, "viewed": 265, "published": 3, "date": "1590893943", "time_retrieved": "2024-07-30T21:04:02.284442", "image_code": "#define BOX_CNT 7\n#define EPS\t0.0001\n#define MAX_STEPS 100\n#define MAX_DIST 200.0\n#define NUMBER1 0\n#define NUMBER2 1\n#define PLANE\t2\n\nstruct Intersect {\n    int\t\tidx;\n    float\tdist;};\n\nstruct Point\t{\n\tvec3\tpos;\n    vec3\tcol;};\n    \nvec3 diffCol[] = vec3[](vec3(0.0, 1.0, 0.7),\n\t\t\t\t\t\tvec3(1.0, 1.0, 0.0),\n\t\t\t\t\t\tvec3(0.8, 0.0, 0.8));\n\nfloat diff[] =  float[](0.4,  0.4,  0.5);\nfloat spec[] =  float[](0.8,  0.9,  0.2);\nfloat specPow[]=float[](64.0, 32.0, 4.0);\n\nvec3 rotate(vec3 p, float angleX, float angleY, float angleZ)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\tr = (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n    cosA = cos(angleZ);\n\tsinA = sin(angleZ);\n\treturn (vec3(cosA * r.x - sinA * r.y, sinA * r.x + cosA * r.y, r.z));\n}\n\n//https://iquilezles.org/articles/distfunctions\nvec2 repeat(in vec2 p, in float s, in vec2 lim)\n{\n    return p - s * clamp(round(p / s), -lim, lim);\n}\n\n\nfloat gyroidDist(vec3 p, float scale, float thickness, float bias)\n{\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy)) + bias) / (scale) - thickness;\n}\n\n\nfloat planeDist(in vec3 pos, in vec4 normal)\n{\n    return (dot(pos, normal.xyz) + normal.w);\n}\n\n\nfloat box(vec3 p)\n{\n\tfloat b = 1.0;\n\tfloat rounding = 0.6;\n\treturn length(max(abs(p) - b, 0.0)) - rounding;\n}\n\nfloat blob(float dist[BOX_CNT], int i1, int i2)\n{\n    float k = 2.2;\n    float res = 0.0;\n    for (int i = i1; i <= i2; i++)\n        res += exp(-k * dist[i]);\n\treturn -log(res)/k;\n}\n\n\nIntersect sceneDist(vec3 pos)\n{   \n    Intersect res;\n\tfloat SINt = sin(iTime * 0.5);\n    \n    float dist[BOX_CNT];\n    vec3 p1 = pos + vec3( 6.0, -6.0, 0.0);\n    vec3 p2 = pos + vec3( 3.0,  6.0, 0.0);\n    vec3 p3 = pos + vec3( 0.0, -3.0, 0.0);\n    vec3 p4 = pos + vec3( 9.0,  3.0, 0.0);\n    vec3 p5 = pos + vec3( 4.35, 0.0, 0.0);\n    \n    vec3 p6 = pos + vec3(-7.0,  1.5, 0.0);\n    vec3 p7 = pos + vec3(-4.0, -6.0, 0.0);\n\n    p1.xy = repeat(p1.xy, 2.0, vec2(1.5, 0.0));\n\tp2.xy = repeat(p2.xy, 2.0, vec2(1.5, 0.0));\n    p5.xy = repeat(p5.xy, 2.0, vec2(0.9, 0.0));\n    p6.xy = repeat(p6.xy, 2.0, vec2(0.0, 2.2));\n \n    //2\n    dist[0] = box(rotate(p1, 0.0, 8.0 * clamp(SINt - 0.0, 0.0, 0.2), 0.0));\n    dist[1] = box(rotate(p2, 0.0, 8.0 * clamp(SINt - 0.2, 0.0, 0.2), 0.0));\n    dist[2] = box(rotate(p3, 0.0, 8.0 * clamp(SINt - 0.05, 0.0, 0.2), 0.0));\n    dist[3] = box(rotate(p4, 0.0, 8.0 * clamp(SINt - 0.15, 0.0, 0.2), 0.0));\n    dist[4] = box(rotate(p5, 0.0, 8.0 * clamp(SINt - 0.1, 0.0, 0.2), 0.0));\n    //1\n    dist[5] = box(rotate(p6, 8.0 * clamp(SINt - 0.3, 0.0, 0.2), 0.0, 0.0));\n    dist[6] = box(rotate(p7, 0.0, 0.0, 8.0 * clamp(SINt - 0.25, 0.0, 0.2)));\n    \n    float distPlane = planeDist(pos, vec4(0.0, 1.0, 0.0, 100.0));\n    \n    float distBox = min(blob(dist, 0, 4), blob(dist, 4, 6));\n    \n    res.dist = min(distPlane, distBox);\n    if (res.dist == distPlane)\n        res.idx = PLANE;\n    else if (SINt <= 0.4) \n    \tres.idx = NUMBER1;\n    else\n        res.idx = NUMBER2;\n    return (res);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    sceneDist(vec3(p.x + EPS, p.y, p.z)).dist - sceneDist(vec3(p.x - EPS, p.y, p.z)).dist,\n    sceneDist(vec3(p.x, p.y + EPS, p.z)).dist - sceneDist(vec3(p.x, p.y - EPS, p.z)).dist,\n    sceneDist(vec3(p.x, p.y, p.z  + EPS)).dist - sceneDist(vec3(p.x, p.y, p.z - EPS)).dist));\n}\n\n\nIntersect rayMarch(vec3 ro, vec3 rd)\n{\n    Intersect d;\n    Intersect intersect;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        d = sceneDist(ro + intersect.dist * rd);\n        intersect.dist += d.dist;\n        if (intersect.dist < EPS || intersect.dist >= MAX_DIST)\n            break;\n    }\n    intersect.idx = d.idx;\n    return (intersect);\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float min_t, in float max_t, in float k)\n{\n    float res = 1.0;\n    for (float t = min_t; t < max_t;)\n    {\n        float dist = sceneDist(ro + rd * t).dist;\n        if (dist < EPS)\n            return 0.0;\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return (res);\n}\n\nvec3 getLight(int idx, vec3 pos, vec3 eye, vec3 lightPos)\n{\n    vec3 diffuseCol = diffCol[idx];\n    vec3 specularCol = vec3(1.0);\n    vec3 Norm = getNormal(pos);\n    vec3 Ldir = normalize(lightPos - pos);\n    vec3 View = normalize(eye - pos);\n    vec3 Refl = normalize(reflect(-Ldir, Norm));\n\n    float dotLN = dot(Ldir, Norm);\n    float dotRV = dot(Refl, View);\n\n    // light not visible\n    if (dotLN < 0.0)\n        return vec3(0.0);\n\n    // light reflection in opposite direction, apply only diffuse lighting\n    if (dotRV < 0.0)\n        return 1.7 * (diffuseCol * dotLN) * diff[idx];\n\n    vec3 half_direction = normalize(normalize(Ldir) + View);\n    float specular = pow(max(dot(half_direction, Norm), 0.0), specPow[idx]);\n    return 1.7 * diffuseCol * dotLN * diff[idx] + specularCol * specular * spec[idx];\n}\n\nPoint getColor(vec3 ro, vec3 rd, vec3 eye, vec3 lightPos, vec2 uv)\n{\n    Point point;\n    Intersect intersect = rayMarch(ro, rd);\n    point.pos = ro + intersect.dist * rd;\n    if (intersect.dist > MAX_DIST - EPS)\n    {\n        float bg = gyroidDist(rotate(vec3(uv.x, uv.y, iTime*0.3), 0.0, cos(iTime*0.01), cos(iTime*0.01)), 28.0, 0.001, 3.0);\n        point.col += abs(bg) * 6.0;\n        point.col *= vec3(rd.y + 0.4, 0.05, rd.y + 0.7); //background\n    }\n    else\n    {    \n\t\t//ambient\n        vec3 ambientCol = vec3(0.5, 0.5, 0.5);    \n    \tvec3 ambientLight = 0.3 * vec3(1.0);\n    \tpoint.col = ambientLight * ambientCol;\n\n    \t//shadow\n    \tvec3 shadowDir = normalize(lightPos - point.pos);\n    \tfloat shadow = getShadow(point.pos + shadowDir, shadowDir, 0.0, MAX_DIST, 8.0);\n\n    \t//diffuse + specular\n    \tvec3 blinn_phong = getLight(intersect.idx, point.pos, eye, lightPos) * shadow;\n    \tpoint.col += blinn_phong;\n    }\n    return point;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 6.4 * (iMouse.xy / iResolution.xy);\n\tfloat SINt = 0.5 + 0.5 * sin(iTime * 0.6);\n\tvec3 ro = rotate(vec3(0.0, 0.0, 30.0), SINt - 0.4 , 0.0, 0.0);\n    vec3 rd = -rotate(vec3(uv, 1.0), SINt - 0.4, 0.0, 0.0);  \n\tvec3 lightPos = rotate(vec3(5.0, -10.0, 80.0), 0.0, 0.0, 0.0);\t  \n    \n    Point point = getColor(ro, rd, ro, lightPos, uv);\n\tvec3 color = point.col;   \n    \n    vec3 rd1 = rd - (2.0 * dot(rd, getNormal(point.pos)) * getNormal(point.pos));\n    Point point2 = getColor(point.pos + rd1, rd1, ro, lightPos, uv);\n    color = mix(color, point2.col, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 525, 525, 885], [887, 935, 984, 984, 1037], [1040, 1040, 1108, 1108, 1193], [1196, 1196, 1242, 1242, 1290], [1293, 1293, 1312, 1312, 1402], [1404, 1404, 1453, 1453, 1585], [1588, 1588, 1619, 1619, 3097], [3099, 3099, 3123, 3123, 3428], [3431, 3431, 3469, 3469, 3782], [3784, 3784, 3869, 3869, 4115], [4117, 4117, 4176, 4176, 4931], [4933, 4933, 5001, 5001, 5879], [5882, 5882, 5937, 5937, 6684]], "test": "untested"}
{"id": "wlVXWz", "name": "Lunar Planet", "author": "propagant", "description": "Random atmospheric lunar planet made for fun", "tags": ["space", "lunarplanet"], "likes": 3, "viewed": 524, "published": 3, "date": "1590891118", "time_retrieved": "2024-07-30T21:04:03.120208", "image_code": "// Lunar planet atmospheric practice shader written by Matej Vanco, May 2020\n\n\n// Method shortcuts\n\n#define sph(c, p) length(c - p.xyz) - p.w\n\n#define geometry(p) sph(p, vec4(-0.1,0.,1.8,0.25))\n\n// Ray-march core\nfloat march(vec3 ro, vec3 rd)\n{\n    float pr = 0.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n     \tvec3 p = ro + rd * pr;\n        pr += geometry(p);\n        if(pr >= 8.)\n            break;\n    }\n    return pr;\n}\n\n// Normals calculation\nvec3 normal(vec3 p)\n{\n \tvec2 off = vec2(0.001, 0.0);\n    float copy = geometry(p);\n    vec3 n = copy - vec3(geometry(p- off.xyy), geometry(p- off.yxy), geometry(p- off.yyx));\n    return normalize(n);\n}\n\n// Simple diffuse lighting\nfloat lighting(vec3 p, vec3 lpos)\n{\n    vec3 n = normal(p);\n    vec3 l = normalize(lpos - n);\n    vec3 ll = normalize(lpos - p);\n    float diff = dot(l, n) + 1.;\n    diff+=pow(max(dot(l,n),0.),2.0)*2.0;\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n// Ray\n    vec3 ro = vec3(0.0);\n    vec3 rd = normalize(vec3(uv.xy,1.0));\n    float m = march(ro,rd);\n    \n    vec3 p = ro + rd * m;\n// Lighting\n    vec3 lp = vec3(sin(iTime*0.15)*3.,2.0,0.5);\n    vec3 col = vec3(lighting(p,lp)) \n        * vec3(lighting(p,vec3(lp.x,-lp.y/2.,lp.z)));\n\tcol += vec3(0.25,0.35,0.3)/1.;\n// Bg cutoff\n    col *= exp(-1. * pow(m,1.1));\n    \n// Stars\n    if(m > 3.) col+=vec3(smoothstep(0.998, 1., fract(cos(dot(uv, vec2(0.2, 7.13)))*5894.5458)))/4.;\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 22993, "src": "https://soundcloud.com/astropilot/space-ambient-demo-00", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVXWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 213, 244, 244, 424], [426, 449, 470, 470, 650], [652, 679, 714, 714, 900], [902, 902, 959, 959, 1562]], "test": "untested"}
{"id": "WsjBRG", "name": "Springy Structure (Soft Body)", "author": "Plento", "description": "I tried something similar here: https://www.shadertoy.com/view/WdXBzf which sorta worked but the physics seemed off. Wyatts shader: https://www.shadertoy.com/view/tsdXWB helped me understand what I was doing wrong. Thanks Wyatt!  Use the speedup if u can!", "tags": ["2d", "mouse", "simulation", "particles", "graph", "physics"], "likes": 42, "viewed": 1154, "published": 3, "date": "1590882565", "time_retrieved": "2024-07-30T21:04:03.995866", "image_code": "// Plento\n\n// I got close with this result here: https://www.shadertoy.com/view/WdXBzf\n// but ended up cheating a little from here: https://www.shadertoy.com/view/tsdXWB\n// Thanks Wyatt!\n\n\n// Common: Physics parameters\n// BufA: particles\n// BufB: initial shape\n\n\n// Grab vertices with mouse\n// Works better with the speedup plugin or higher monitor refresh rate\n\n\n// Controls line thickness\n#define lf(x) exp(-x*1.8)\n\n// 0 --> Draw line between next and last vert\n// 1 --> Draw line between all verts\n#define DrawMode 1\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec3 col = vec3(1);\n    vec4 bA = ch(iChannel0, u);\n    \n    for(int i = 0; i < nVerts; i++){\n    \tvec4 s0 = ch(iChannel0, vec2(i, 0.));\n        #if DrawMode == 0\n        vec4 s1 = ch(iChannel0, vec2(i+1, 0.));\n        col -= lf(line(u, s0.xy, s1.xy));\n        #else\n        for(int e = 0; e < nVerts; e++){\n            vec4 s1 = ch(iChannel0, vec2(e, 0.));\n            if(i!=e) col -= lf(line(u, s0.xy, s1.xy)); \n        }\n        #endif\n    }\n    col*=smoothstep(R.x, 0., length(u-R.xy*.5));\n    f = vec4(col, 1.);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\n\n// Number of vertices to connect to\nconst int nVerts = 12;\n\n// How fast the verts conform to the initial structure (Rigidness, spring factor)\nconst float tol = .004; \n\n// Radius of ball if using ball as shape in Buffer B\n#define rad R.x/5.5 \n\n// Toggle gravity\n#define Gravity\n\nconst float friction = .01;\n\n\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nconst float pi = 3.14159;", "buffer_a_code": "void mainImage( out vec4 f, in vec2 u ){\n    ivec2 iu = ivec2(u);\n    \n    // Only deal with the pixels that act as vertices\n    if(iu.x <= nVerts && iu.y == 0){\n        vec4 bA = ch(iChannel0, u); // current vert\n        vec4 bB = ch(iChannel1, u); // current verts initial location\n        \n        // Go through every vert\n        for(int n = 0; n < nVerts; n++){\n            if(n != iu.x){ // Make sure were not looking at ourself\n             \tvec4 s0 = ch(iChannel0, vec2(n, 0.)); // nth vert\n                vec4 s1 = ch(iChannel1, vec2(n, 0.)); // nth \"correct\" initial loc\n                \n                vec2 v0 = bA.xy - s0.xy; // current vert to nth vert\n                vec2 v1 = bB.xy - s1.xy; // cuurent verts initial loc to nth initial loc\n                \n                vec2 nv = normalize(v0); // just direction\n               \n                float d0 = length(v0); // dist from nth vert to current vert\n                float d1 = length(v1); // dist from nth initial loc to current initial loc\n                \n            \tfloat dif = d0-d1; // How far off is actual location to the initial\n            \t\n                if(d0 > 0.)\n                   \tbA.zw -= dif*nv*tol; // add velocity to vert to make up for the distance difference\n            }\n        }\n        \n        #ifdef Gravity\n        bA.w -= .08; // Add gravity\n        #endif\n        bA.zw -= friction*bA.zw; // Add friction\n        bA.xy += bA.zw; // Update location\n        \n        // Grab verts\n        float d = length(iMouse.xy - bA.xy);\n        if(iMouse.z > 0. && d <= 32.){\n            //bA.xy = iMouse.xy;\n            bA.xy = mix(iMouse.xy,bA.xy,exp2(-100.*iTimeDelta)); // from spalmer\n            bA.zw = vec2(0);  \n        }\n        \n        // Get initial positions\n        if(iFrame < 4){\n        \tbA.xy = ch(iChannel1, u).xy; \n            bA.zw = vec2(0);\n        }\n     \t\n        // Boundaries\n        if(bA.y < 0.){\n            bA.y += abs(bA.y);\n            bA.w *= -1.;\n            bA.zw -= .2*bA.zw;\n        }\n        else if(bA.y > R.y){\n            float dd = abs(bA.y-R.y);\n            bA.y -= dd;\n            bA.w *= -1.;\n            bA.zw -= .2*bA.zw;\n        }\n        else if(bA.x < 0.){\n            bA.x += abs(bA.x);\n            bA.z *= -1.;\n            bA.zw -= .2*bA.zw;\n        }\n        else if(bA.x > R.x){\n            float dd = abs(bA.x-R.x);\n            bA.x -= dd;\n            bA.z *= -1.;\n            bA.zw -= .2*bA.zw;\n        }\n        f = bA;\n    }\n    else return;\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Choose a initial shape\n// Restart shader\n\n#define ball\n//#define random\n//#define spiral\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    ivec2 iu = ivec2(u);\n    float id = float(iu.x);\n    // Only set positions for number of verts\n    if(iu.x <= nVerts && iu.y == 0){\n        vec4 bB = ch(iChannel0, u);\n         \n        if(iFrame == 0){\n            #ifdef ball\n            float a = 2.*pi/float(nVerts);\n            bB.xy = rad*vec2(cos(a*id),sin(a*id)) + R.xy*.5;\n            #endif\n            \n            #ifdef random\n            bB.xy = hash21(iDate.w+float(iu.x)*482.43)*R*.65 + R.xy*.15;\n            #endif\n            \n            #ifdef spiral\n            float a = (2.*pi/float(nVerts)) * 3.;\n            float r = mix(10., 300., id/float(nVerts));\n            bB.xy = R.xy*.5 + r*vec2(cos(a*id),sin(a*id));\n            #endif\n            \n            bB.zw = vec2(0);\n        }\n     \t\n        f = vec4(bB.xy, 0., 0.);\n    }\n    else\n        return;\n    \n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 561, 561, 1084]], "test": "untested"}
{"id": "tdjBWK", "name": "Jungle planet with mountains", "author": "jarble", "description": "Based on my [url=https://www.shadertoy.com/view/3djfWV]\"Jungle Planet\"[/url] shader.\nIt's an interesting shape, but it needs anti-aliasing.", "tags": ["raymarching"], "likes": 1, "viewed": 345, "published": 3, "date": "1590877614", "time_retrieved": "2024-07-30T21:04:04.733893", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\n\nvec3 hash33(vec3 p)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 1.0;\n    vec2 col = (uv.xy*scale*(sin(uv.x+time1)));\n    vec2 col2;\n    for(float i = 1.0; i < 3.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(0.5+uv.y/200.0,col2.x,0.5+uv.x/200.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p *= 1.0;\n    return length(p/10.0)-2.0+(sin(p.x*2.0+(sin(p.y*4.0+(sin(p.z+8.0)))))+sin(p.y*2.0+(sin(p.z*4.0+(sin(p.x+8.0)))))+sin(p.z*2.0+(sin(p.y*4.0+(sin(p.x+8.0))))))/30.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = (50.0+20.0*sin(iTime/5.0))*vec3(sin(iTime/5.0), sin(iTime/6.0), cos(iTime/5.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 203, 253, 656], [658, 898, 922, 922, 1105], [1107, 1528, 1619, 1619, 1925], [1940, 2194, 2259, 2259, 2391], [2393, 2482, 2511, 2511, 2821], [2823, 3315, 3455, 3455, 4045], [4047, 4417, 4502, 4502, 5260], [5262, 5589, 5638, 5673, 5804], [5806, 5806, 5863, 5863, 6792]], "test": "untested"}
{"id": "WsjfWV", "name": "GLSL Bug: float * mat()", "author": "FabriceNeyret2", "description": "On OpenGL(linux/nVIDIA)  I see:\n     left ( = const * mat )  as mid-grey, \n     right ( = float * mat ) as mid-red  (instead of mid-grey).\n\nUncomment the last line to see that float * mat() is compiled as diag(float) * mat().", "tags": ["glsl", "bug"], "likes": 0, "viewed": 347, "published": 3, "date": "1590869154", "time_retrieved": "2024-07-30T21:04:05.594591", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(fragCoord.x)==int(iResolution.x)/2) \n        { fragColor = vec4(0); return; } // separator black line\n\n#define var(v) min( v, v + iTime ) // = v. trick to prevent compiler to simplify const expressions\n    \n    vec2 U = fragCoord/iResolution.xy;\n    mat2 M = U.x < .5 \n               ?     2.  * mat2(1,1,1,1)   // left:   const * mat() is ok\n               : var(2.) * mat2(1,1,1,1);  // right: notConst*mat() is wrong\n\n   fragColor = vec4(M)/4.;         // only r and a are set, i.e., M.xx and M.yy: \n //fragColor = vec4(M).abgr/4.;    // float*mat() is compiled as mat(float)*mat() \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 657]], "test": "untested"}
{"id": "3djfWV", "name": "Jungle Planet", "author": "jarble", "description": "I colored the surface of an object using my [url=https://www.shadertoy.com/view/wssBzs]\"rainbow jungle\"[/url] shader.", "tags": ["raymarching"], "likes": 1, "viewed": 346, "published": 3, "date": "1590865805", "time_retrieved": "2024-07-30T21:04:06.364533", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {    \n    return length(p/4.0)-1.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/5.0), 10.0*sin(iTime/5.0), 10.0*cos(iTime/5.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 205, 255, 666], [668, 908, 932, 932, 968], [970, 1391, 1482, 1482, 1788], [1803, 2057, 2122, 2122, 2254], [2256, 2345, 2374, 2374, 2684], [2686, 3178, 3318, 3318, 3908], [3910, 4280, 4365, 4365, 4789], [4791, 5118, 5167, 5202, 5333], [5335, 5335, 5392, 5392, 6309]], "test": "untested"}
{"id": "3dBfz3", "name": "Family Bible", "author": "eiffie", "description": "LossyTextCompression Drop the alphabet to 8 chars then expand using context. Doesn't  work. Maybe useful for hiding messages.", "tags": ["compression"], "likes": 11, "viewed": 467, "published": 3, "date": "1590841449", "time_retrieved": "2024-07-30T21:04:07.361866", "image_code": "//The Ole Family Bible - by eiffie (lossy text compression)\n//Like the wisdom on its pages the old family Bible has withstood the test\n//of time. Its pages intact due to the diligence of binders. Its leather\n//bound cover still protecting against moisture due to the skill of tanners\n//using 18th century technology. And due to the typesetters, many lacking \n//even a basic education, more than a few spelling errors.\n\n#define R iResolution.xy\nfloat td;\nfloat DEC(vec2 p, vec2 a){//if(a>32.)a+=32.;\n  float sx=p.x;\n  p.x*=0.5-pow(p.y,4.)*0.4+p.y*0.2;\n  p.x+=0.2+sin(a.x)*0.05;\n  vec2 c=vec2(mod(a.x,16.),15.-floor(a.x/16.));\n  vec4 v=texture(iChannel2,(c+p)/16.);//return 1.0-v.x;\n  float d=v.w*(1.+p.y*0.1);\n  if(a.y>4.)d=min(d,length(p-vec2(0.25))+.4);\n  return d;\n}\nfloat text(in vec2 uv){\n  vec2 scl=vec2(320.,36.);\n  vec2 F=floor(uv*scl),P=fract(uv*scl);\n  float lo=0.;int io=0;\n  if(F.x>75.){io=-75;lo=scl.y;if(F.x>165.){io-=90;lo+=scl.y;if(F.x>240.){io-=75;lo+=scl.y;}}}\n  vec2 v=vec2((scl.y-1.-F.y)+1.5+lo,0.5);\n  vec4 t=texture(iChannel0,v/R);\n  float idx=F.x+t.x+float(io);\n  t=texture(iChannel0,(v+vec2(1,0))/R);\n  float d=1.;\n  if(idx<t.x){\n    v=vec2(0.5+mod(idx,R.x),1.5+floor(idx/R.x));\n    t=texture(iChannel0,v/R);\n    if(t.x==0.)return 1.;\n    float r=25.*max(length(fwidth(uv)),0.0008);//\n    d=DEC(P,t.xy);\n    d=smoothstep(0.53-r,0.53+r,d);\n  }\n  return d;\n}\n#define pi 3.14159 \nvec2 rotate(vec2 v, float a){float ca=cos(a),sa=sin(a);return v*mat2(ca,sa,-sa,ca);} \nfloat rbox(vec3 p, vec4 r){return length(max(abs(p.xyz)-r.xyz,0.))-r.w;} \nfloat nois(vec2 v){// based on 2d noise by Trisomie21 \n  vec4 h=fract(sin(vec4(floor(v.x)+floor(v.y)*100.)+vec4(0,1,100,101))*100.); \n  v=smoothstep(0.,1.,fract(v));return mix(mix(h.x,h.y,v.x),mix(h.z,h.w,v.x),v.y);\n} \nvec3 mcol=vec3(0); \nfloat opn=1.*pi;//angle of book open 0-pi \n#define splty .12 \nfloat Cover(vec3 p){ \n  p.y-=splty; \n  return rbox(p,vec4(.5,0,0.75,0.01)); \n} \nfloat Page(vec3 p){\n  p.y-=(pi-opn)*0.015+sin(p.x*6.9+5.7)*opn*0.011/(1.+p.x); \n  return 0.7*rbox(p,vec4(0.48,splty/2.,0.73,0)); \n} \nfloat DE(vec3 p){ \n  vec3 p0=p; \n  float dT=p.y+splty; \n  p.xy=rotate(p.xy,opn/2.); \n  p.y=abs(p.y); \n  p.xy=rotate(p.xy,opn/2.); \n  p.x-=.5+.5*p.y*opn; \n  float dC=Cover(p); \n  float dP=Page(p); \n  float d=min(dT,min(dC,dP)); \n  if(mcol.x>0.){ \n    vec2 s1=vec2(1.);float s2=0.; \n    if(d==dT){\n      mcol=vec3(0.7,0.4,0.2); \n      s1=vec2(5.,50.);s2=0.001; \n    }else if(d==dC){ \n      mcol=vec3(0.2,0.22,0.3); \n      s1=vec2(20.0);s2=0.001; \n      float dG=max(min(abs(p.x),abs(p.z-0.1))-0.05,max(abs(p.x)-0.3,abs(p.z)-0.4)); \n      if(dG<dC){s2=0.;mcol=vec3(1.,.8,0.5);}  \n    }else if(d==dP){ \n      mcol=vec3(2); \n      //s1=vec2(100.0);\n      s2=0.; \n      if(-p0.x>-p0.y/(1.+opn))p.x=-p.x-0.45;else p.x+=.35;//undo the abs(p.y) after rotating y to x\n      p.xz*=vec2(1.2,1.4667);\n      if(max(abs(p.x),abs(p.z))<1.){\n        float d=text(vec2(0.5)+0.5*p.xz);//0-1 \n        mcol=vec3(2.*d);\n      }  \n    } \n    d+=nois(p.xz*s1)*s2; \n  } \n  return d; \n} \nvec3 normal(vec3 p, float d){//from dr2 \n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx)); \n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w)); \n} \nvec3 sky(vec3 rd, vec3 L){ \n  float d=0.5*dot(rd,L)+0.5; \n  return mix(vec3(0,0.1,0.2),vec3(1,0.9,0.5),d); \n} \nfloat rnd; \nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);} \n \nfloat ShadAO(in vec3 ro, in vec3 rd){ \n float t=0.01*rnd,s=1.0,d,mn=0.01; \n for(int i=0;i<12;i++){ \n  d=max(DE(ro+rd*t)*1.5,mn); \n  s=min(s,d/t+t*0.5); \n  t+=d; \n } \n return s; \n} \nvec3 scene(vec3 ro, vec3 rd){\n  td=DE(ro)*rnd;\n  float d,px=1.0/R.x; \n  for(int i=0;i<64;i++){ \n    td+=d=DE(ro+rd*td);\n    if(td>10.0 || d<px*td)break;\n  }\n  vec3 L=normalize(vec3(0.4,0.5,0.5)); \n  vec3 col=sky(rd,L); \n  if(d<px*td*5.0){ \n    mcol=vec3(0.001);  \n    vec3 so=ro+rd*td; \n    d=DE(so);\n    vec3 scol=mcol.xyz;mcol=vec3(0);\n    vec3 N=normal(so,d); \n    float dif=0.5+0.5*dot(N,L); \n    float vis=clamp(dot(N,-rd),0.05,1.0); \n    float fr=pow(1.-vis,5.0); \n    float shad=ShadAO(so,L); \n    col=(scol*dif+fr*sky(reflect(rd,N),L))*shad; \n  } \n  return col; \n} \nmat3 lookat(vec3 fw){fw=normalize(fw);\n  vec3 rt=normalize(cross(fw,vec3(0,0,1)));\n  return mat3(-rt,normalize(cross(rt,fw)),fw);\n}\nvoid mainImage(out vec4 O, in vec2 U){ \n  vec2 uv=vec2(U-0.5*R)/R.x; \n  randomize(U);\n  vec2 ms=vec2(0);\n  vec3 ro2=vec3(-0.25,0.3,0);\n  if(iMouse.x!=0.)ms=(iMouse.xy/R);\n  float lt=1.;\n  vec3 ro=vec3(0.5,1.5,-2),ro1=ro; \n  if(iTime<5.0){\n      opn=0.;lt=iTime/5.;\n  }else if(iTime<5.+5.*pi){\n      opn=pi*(0.5-.5*cos((iTime-5.)*0.2));\n  }else if(iTime<10.+5.*pi){\n      float t=iTime-(5.+5.*pi);\n      ro=mix(ro1,ro2,t/5.);\n  }else {\n      vec2 v=vec2(0.22,0.35)*U/R+ms*vec2(0.6,0.8)-vec2(.05);\n      float d=1.;\n      if(v.x>0.&&v.y>0.&&v.x<1.&&v.y<1.)d=text(v);\n      O=vec4(d,d,d,1.);\n      return;\n  }\n  vec3 rd=normalize(vec3(uv.xy,1));\n  O=vec4(scene(ro,lookat(-ro1)*rd),1.0)*lt; \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\nfloat gb(int c, float start, float bits){return mod(floor(float(c)/exp2(start)),exp2(bits));}//get bits\nint dat[573]=int[573](4405797,7909807,3697656,9625835,14880926,15477224,2346556,13667659,5437891,16541509,16166076,10623364, \n5744691,10686709,619059,8600113,6161701,1995199,9617821,13534160,12867552,10325224,2291527,7605579, \n8600102,13075749,14580140,15697352,15962020,3048792,7613158,6546737,7607341,4405807,12856105,10814808, \n1696276,14935114,8476220,3474868,14893621,14854524,124748,9617821,14936824,429962,9718108,11242728, \n5194379,15699176,14766010,4405820,13608777,10735123,1202227,10250722,10739335,10774337,2255410,2739974, \n12916292,6136052,10747074,11899051,1995045,1737626,14045597,12049635,13580833,4961329,10842528,7770611, \n12140496,10325816,12448198,4590660,1513927,10436779,15535928,7628818,1955654,9714867,9833704,7604860, \n1768998,10563109,5396531,13919560,7625988,15408670,16353888,6580039,3164525,8605507,428108,9617821, \n11701480,12511006,7983373,13533582,11546180,6907940,7356127,7615870,14935345,14767676,10382129,14774839, \n10742075,10246852,2632391,13570235,5642936,2490867,14322920,13383718,1607767,15503773,13536322,10242400, \n2632391,14151867,7609128,14339846,1663685,1692135,8932789,1995175,8425338,13803813,13829744,3169411, \n7616325,10573617,10693003,836019,905586,15948175,14893500,256315,5531549,10648120,11548484,9720804, \n5526216,11603176,10686827,857651,15959500,1691944,1606911,7856349,11424798,15929144,12483230,2346532, \n11031509,2308660,12866517,15076584,3681858,6443494,1356333,9617821,15722912,1030055,7856349,8600094, \n15225125,16267075,16680861,8040262,1692040,10419005,4576706,8136609,687575,10789351,649171,13989488, \n10235423,13201200,11453484,9468357,1735817,14574055,9949011,9394500,2247539,5760966,13438776,1607977, \n10030843,14774069,2711100,12863842,707704,13044977,7621180,14900870,6565223,8600105,14139685,5942535, \n8517371,14869513,13643111,2041336,2306535,3776661,11701480,12511006,13533453,16526916,3016108,1215206, \n10695604,1202227,1692135,15796524,4443700,3564015,743928,12964191,16539368,11306412,2276895,8152902, \n2254805,16541510,973164,8381489,7623368,10636038,7987075,11428576,1608584,10499698,9988568,15722022, \n14274952,7626472,11917446,1692040,689612,1784357,12440039,14858576,8113212,9632234,15929144,2280598, \n5526485,10734704,223044,311783,13275549,13535656,2669240,10323188,8547590,10664331,13430020,12439976, \n6831336,16354993,2185031,14830443,1735228,9978468,7629325,9394502,8839027,13057256,13536160,1926083, \n3776844,11701480,12511006,10686733,9615923,1341888,16354619,7627323,1554998,10456157,1735210,13516133, \n662397,4911591,13077777,311468,1620533,13391167,2308671,14830443,1735228,3424868,1692072,13516133, \n10623869,10689779,6136203,2854149,11833245,13237891,15497669,15699508,3170853,12111418,16385768, \n6846916,10699095,15645235,10610072,11560772,10507236,11792691,12930582,1995251,14290810,1692057, \n12126508,14026472,3434517,13313768,9834296,13383494,3419897,7983928,2263960,16724117,11308264,11733293, \n11560769,10735140,2507175,11895620,11701480,12511006,10518797,9617803,4623592,8506053,1734713,16645428, \n10614516,13564955,9617859,1995087,961725,6636007,2914755,10225548,7615367,11218758,6485827,6508294, \n8465965,15754510,10233965,16404103,12177588,15962004,2047920,6501300,1356333,15405619,3744152,2920248, \n12881093,13657658,13807148,2920248,12881093,13133370,15960453,13390536,6532168,3955974,1523745,5605785, \n2277272,14111767,15960455,9864536,10206919,7359038,2306493,4615703,1358910,9617579,8763930,7633350, \n1088030,6635691,6461315,1994797,14774835,7884075,4405801,10686625,6540838,11527701,16680392,10701446, \n11266099,11303362,11101122,2191908,1691885,4951721,997910,1487350,15599465,1725458,15960481,15074648, \n12856899,10607173,2158131,10124486,13378920,7609632,10697263,7516497,5869152,7621182,4082438,10128453, \n15634232,9669829,977705,1476513,10005081,10774046,1994770,5606493,8423504,15595158,8564419,5432873, \n13810238,10665880,7616907,13060145,10563114,12189867,11032024,1249198,1664221,1395687,15507869,10432904, \n10735142,13873395,11428576,5901544,1606834,5812395,13430022,10251496,14882631,4307516,7243225,14772552, \n14793276,13815265,14896834,9734451,13535558,7633349,1406513,2042844,6078877,9085320,8637982,8589777, \n3048635,14914116,13685820,4324040,8558646,1041945,2506956,13537080,1216096,15492185,8501820,5520371, \n2920248,14892594,2210322,11251871,3171048,13997317,13533685,7614020,2277126,15492934,1467452,11897438, \n11439928,9885250,6565444,14699885,703036,2308629,10636139,758139,1268569,10128693,740678,9780966, \n10573632,9725762,16201973,1607789,9818525,8604996,980537,16378228,9832168,15960700,13457776,13896519, \n12964020,12094200,1216412,15450525,15959484,13044472,11956796,13582372,11548482,5526500,16505208, \n9834296,7608870,752966,5194215,7603517,16162342,5902268,1030106,7983591,16372408,743928,16582505, \n15960979,14912416,1608059,3378828,8476206,1995070,8621565,12514763,15790349,6441758,1554989,5813299, \n13536519,6535912,1214358,9617821,1212751,9833437,8483371,15595158,11560771,7627300,14514118,12394663 \n);\nint alph[128]=int[128](879450,879450,867022,743898,601946,608850,811578,574712,879034,341414,642440,642451,135354,135300, \n101472,101475,879450,879450,866774,485838,379250,387666,564775,869617,879014,442189,865107,878867, \n136005,137028,852802,879427,879450,879450,473562,879054,879442,372314,813914,574712,879023,427430, \n281864,281875,660122,135300,26624,3,879450,879450,866774,867150,870770,870763,879162,845050,518977, \n39130,642675,642664,135813,157828,2,2112,879450,879450,473806,473550,878962,878970,879450,870234, \n879434,439738,270600,270600,135828,135300,0,0,879450,879450,473558,481742,601682,608850,879143,583911, \n441770,439738,281868,642675,135813,856244,835,0,879450,879450,473550,473934,372299,372299,859697, \n804081,874145,349862,282220,413299,136005,856708,102211,68706,879450,879450,485846,875342,601458, \n372299,826919,256241,867759,439718,282444,281864,135813,135300,834,851994\n);\nfloat hash(vec2 u){return fract(sin(dot(u,vec2(117,113)))*342.13);}\nvec4 get(ivec2 v){return texture(iChannel0,(vec2(v)+vec2(0.5))/R);}\nfloat getC(int idx){//extract a 3 bit char and transform to 5 bits thru context lookup\n  int aid=0;float f1=mod(float(idx-1),8.);\n  if(f1<5.)aid=int(gb(dat[(idx-1)/8],f1*3.,9.));//the 3 chars are in same float\n  else{//get them individually\n    f1=gb(dat[(idx-1)/8],f1*3.,3.);\n    float f2=gb(dat[idx/8],mod(float(idx),8.)*3.,3.);\n    float f3=gb(dat[(idx+1)/8],mod(float(idx+1),8.)*3.,3.);\n    aid=int(f1+f2*8.+f3*64.);\n  }\n  float a=gb(alph[aid/4],mod(float(aid),4.)*5.,5.);\n  return (a<26.?65.+32.+a:32.);\n}\nvoid mainImage( out vec4 O, in vec2 U ) {\n  vec4 st=get(ivec2(0));\n  ivec2 F=ivec2(floor(U));\n  if(iFrame<2 || (st.x!=R.x && !all(equal(F,ivec2(0))))){O=vec4(0);return;}\n  O=texture(iChannel0,U/R);\n  \n  if(F.y==0){//state, page & line index\n    if(F.x==0){//state\n      if(O.x!=R.x){O.x=R.x;O.y=0.;O.z=0.;O.w=0.;}\n      else O.y+=1.;\n      return;\n    }\n    if(O.x==0.){\n      if(F.x==1){O=vec4(-1.,2200,0,0);return;}\n      int jl=int(get(F-ivec2(1,0)).x);\n      float f=getC(jl);\n      if(f==32.){\n        f=getC(jl-1);\n        if(f==32.){\n          int j2=int(get(F-ivec2(2,0)).x);\n          if(j2!=jl){O.x=float(jl);return;}//double spaced\n        }\n      }\n      if(jl==0)return;//not ready yet\n      for(int i=0;i<72;i++){//look for end of line\n        int j=jl+i;\n        if(j>4584){\n          if(j==4585 && jl!=4585)O.x=4585.;\n          else O.x=float(j)+58.+hash(vec2(j,j))*6.;\n          break;\n        }\n        if(i>70){O.x=float(j);break;}\n        float f=getC(j);\n        if(f==32.){\n          f=getC(j+1);\n          if(f==32. || i>60){O.x=float(j+1);break;}\n        }\n      }\n    }\n    return;\n  }\n  int idx=(F.y-1)*int(R.x)+F.x;\n  if(idx>=4585 && O.x==0.){//create extra gargled words\n    if(idx>6500)return;//not read\n    if(idx<4588 || F.x==0){O.x=26.;}\n    else{\n      O.x=hash(vec2(F))*34.;//=get(F-ivec2(1,0)).z;\n      //O.z=floor(hash(F)*7.+1.)*64.+floor(O.z/8.);\n    }\n    //O.x=gb(alph[int(O.z)/4],mod(O.z,4.)*5.,5.);\n    O.x=(O.x<26.?65.+32.+O.x:32.);\n    return;\n  }\n  if(idx==0)O=vec4(73,3,0,0);else if(idx==4584)O=vec4(110,0,0,0);\n  else{\n    if(O.x==0.){//extract data\n      O.x=getC(idx);//lower case\n    }else if(O.y==0. && idx>3){//format uppercase, period\n      if(get(F-ivec2(1,0)).x==32.){O.y=1.;\n        if(get(F-ivec2(2,0)).x==32.){O.x-=32.;\n          if(get(F-ivec2(3,0)).x==32.)O.y=3.;//Big caps\n        }\n      }else if(get(F).x==32.){\n        if(get(F+ivec2(1,0)).x==32.)O.y=5.;//period\n      }else O.y=1.;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 480, 498, 768], [769, 769, 792, 792, 1379], [1400, 1400, 1429, 1429, 1484], [1486, 1486, 1513, 1513, 1558], [1560, 1560, 1579, 1614, 1777], [1861, 1861, 1881, 1881, 1939], [1941, 1941, 1960, 1960, 2072], [2074, 2074, 2091, 2091, 3034], [3036, 3036, 3065, 3076, 3214], [3216, 3216, 3242, 3242, 3325], [3339, 3339, 3365, 3365, 3439], [3443, 3443, 3480, 3480, 3622], [3624, 3624, 3653, 3653, 4196], [4198, 4198, 4219, 4219, 4329], [4330, 4330, 4368, 4368, 5019]], "test": "untested"}
{"id": "wdBfDK", "name": "Mandelbrot with \"smart\" AA", "author": "mrange", "description": "Licence CC0: Nothing special, just a mandelbrot with orbit traps, experimenting with \"smart\" AA", "tags": ["2d", "mandelbrot", "aa"], "likes": 16, "viewed": 568, "published": 3, "date": "1590827507", "time_retrieved": "2024-07-30T21:04:08.115850", "image_code": "\n#define MANDELBROT_ZOOM_START 0.0\n#define MANDELBROT_ITER       240\n\nvoid pR(inout vec2 p, in float a) { \n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);    \n}\n\nvec2 pMod2(inout vec2 p, in vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nvec3 mandelbrot(float time, vec2 p, out float ii) {\n  vec3 col = vec3(0.0);\n\n  float ztime = (time - MANDELBROT_ZOOM_START)*step(MANDELBROT_ZOOM_START, time);\n\n  float zoo = 0.64 + 0.36*cos(.07*ztime);\n  float coa = cos(0.15*(1.0-zoo)*ztime);\n  float sia = sin(0.15*(1.0-zoo)*ztime);\n  zoo = pow(zoo,8.0);\n  vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n  vec2 c = vec2(-.745,.186) + xy*zoo;\n\n  const float B = 10.0;\n  float l = 0.0;\n  vec2 z  = vec2(0.0);\n\n  vec2 zc = vec2(1.0);\n  \n  pR(zc, ztime);\n\n  float d = 1e20;\n  \n  int i = 0;\n        \n  for(int j = 0; j < MANDELBROT_ITER; ++j) {\n// \"Furry\" mandelbrot\n//    const float ss = 0.125*1.13125;\n//    const float ss = sqrt(1.99)/10.0;\n//    z = tanh(ss*z)/ss;\n    float re2 = z.x*z.x;\n    float im2 = z.y*z.y;\n    float reim= z.x*z.y;\n        \n    if(re2 + im2 > (B*B)) break;\n\n    z = vec2(re2 - im2, 2.0*reim) + c;\n\n    vec2 zm = z;\n    vec2 n = pMod2(zm, vec2(4));\n    vec2 pp = zm - zc;\n    float dd = dot(pp, pp);\n\n    d = min(d, dd);\n\n    l += 1.0;\n    \n    i = j;\n  }\n\n  ii = float(i)/float(MANDELBROT_ITER);\n  \n  float sl = l - log2(log2(dot(z,z))) + 4.0; \n\n  vec3 dc = vec3(pow(max(1.0 - d, 0.0), 20.0));\n  vec3 gc = 0.5 + 0.5*cos(3.0 + sl*0.15 + vec3(0.1,0.5,0.9));\n  return gc + dc*smoothstep(28.8, 29.0, ztime);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float s = 2.0/iResolution.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n  float ii = 0.0;\n  vec3 col = mandelbrot(iTime, p+o1, ii);\n\n  // \"smart\" AA? Is that a good idea?  \n  vec2 dii2 = vec2(dFdx(ii), dFdy(ii));\n  float dii = length(dii2);\n  \n  if(abs(dii) > 0.01) {\n    col += mandelbrot(iTime, p-o1, ii);\n    col += mandelbrot(iTime, p+o2, ii);\n    col += mandelbrot(iTime, p-o2, ii);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 105, 105, 153], [155, 155, 195, 195, 289], [292, 292, 343, 343, 1577], [1579, 1579, 1634, 1634, 2209]], "test": "untested"}
{"id": "wdSfDK", "name": "Zoom vs Scale", "author": "eiffie", "description": "Left side is typical zoom by scaling space. Right side scales Z each iteration. I wish I could think of some use for this to end my description... um, no.", "tags": ["mandelbrot"], "likes": 2, "viewed": 312, "published": 3, "date": "1590826859", "time_retrieved": "2024-07-30T21:04:09.056336", "image_code": "#define rez iResolution.xy\nfloat DE(vec2 z){\n  const int iters=200;\n  float scl=1.0+(0.5+0.5*cos(iTime*0.1))*500000.;\n  if(z.x<0.){z/=scl;scl=1.;}\n  z+=vec2(-.74820292,-.18466048)*scl;\n  vec2 c=z,mc=fract(c)-0.5;\n  float d=step(mc.x*mc.y,0.)*.2+.7;\n  float m=dot(z,z);\n  int n=0; \n  for (n = 0; n < iters && m<4.*scl*scl; n++) {  \n   z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)/scl+c;\n   m = dot(z,z);\n  }\n  z/=scl;\n  m = dot(z,z);\n  return (float(iters-n)+1.33*log(log(m)))/float(iters);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(2.0*fragCoord.xy-rez)/rez.x;\n  float d=DE(2.*uv);\n  fragColor=vec4(d,d,d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[483, 483, 540, 540, 632]], "test": "untested"}
{"id": "tsSfWK", "name": "Animated Two-Tiled Truchet", "author": "Shane", "description": "An animated two-tiled Truchet arrangement.", "tags": ["abstract", "animation", "truchet"], "likes": 38, "viewed": 916, "published": 3, "date": "1590816024", "time_retrieved": "2024-07-30T21:04:09.957925", "image_code": "/*\n\n    Animated Two-Tiled Truchet\n    --------------------------\n\n\n\tAn animated two-tiled Truchet arrangement -- to accompany the texture mapped\n\tone -- for anyone only interested in the animated portion. I tried to give \n\tit a kind of geometric art deco feel.\n\n    For anyone wanting to make one of these, a few simple observations should help: \n    \n    Animating square grid Truchet arc tiles on their own requires the flow directions \n    to be reversed on alternate checkered tiles. Furthermore, in order to work \n    straight line tiles in with them, both horizontal and vertical lines must span \n    two grid cells. In addition, adjacent horizontal line rows must flow in opposite \n    directions. The same applies to adjacent vertical line columns.\n\n\n    Other examples:\n\n\t// The texture mapped version of this.\n\tAnimated Textured Truchet - Shane\n\thttps://www.shadertoy.com/view/3dSBzt\n\n\t// A much, much simpler version containing just the arc tiles.\n\tMinimal Animated Truchet - Shane\n\thttps://www.shadertoy.com/view/XtfyDf\n\n*/\n\n\n// Displays each separate grid cell, which allows you to more easily discern\n// individual tiles.\n//#define SHOW_GRID\n\n// Thinner Truchet rails.\n//#define THINNER\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Global Truchet constants. The angle is either the angle of the\n// Truchet semi-circles, which have been normalized to the zero to one\n// range, or the value of the straight line position on the straight\n// edge tile arrangement, which also ranges from zero to one.\nvec2 ang;\n\n// The Truchet distance field. A lot of this is standard stuff. The additional\n// code here involved texture mapping.\nvec2 df(vec2 p){\n    \n    // Two by two cell random value.\n    vec2 ip2 = floor(p/2.);\n    float rnd2 = hash21(ip2 + .43);  \n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random 1x1 numbers, for flipping and rotating.\n    float rnd = hash21(ip);\n    float rnd3 = hash21(ip + .57);\n    \n    // The distance field container. Each cell contains either two lines\n    // or two arcs, so this will hold each one.\n    vec2 d = vec2(1e5);\n  \n    \n    // When animating arc Truchet arrangements only, the trick is to \n    // reverse the animation flow on alternate checkered cells... \n    // I have a basic animated version on here somewhere, if you\n    // require more information.\n    //\n    // Anyway, working in the extra overlapping straight line tiles \n    // complicates things. However, after a while, you'll realise that \n    // either the horizontal or vertical line must span two cells for \n    // the animation to work, so that's what the following two-by-two \n    // checkered \"mod\" decision is all about.\n    //\n    // Every 2 by 2 alternate checker, put in the overlapped straight \n    // tiles. Otherwise, calculate the distance field for the double \n    // arc one.\n    //\n    if(mod(ip2.x + ip2.y, 2.)<.5){ // Alternate checkers.\n    //if(rnd2<.5){ // Random 2x2 coverings.\n    //if((mod(ip2.x, 2.)<.5 || mod(ip2.y, 2.)<.5) && rnd2<.5){ // Mixing.\n        \n        \n        \n        // Overlapping straight tile.\n\n        d = abs(p);\n        ang = p.yx;\n\n        // Reversing just the X-directions on every second column. It's \n        // common sense... but it still took me a while to figure out.. :)\n        if(mod(ip.x + 1., 2.)<.5){\n            ang.x *= -1.;\n\n        }\n        // Reversing just the Y-directions on every second row.\n        if(mod(ip.y + 1., 2.)>.5){\n            ang.y *= -1.;\n        }  \n\n\n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n            d = d.yx;\n            ang = ang.yx;\n        }\n\n        // This makes things line up.\n        ang += .5;\n        \n        // The straight lines are about 1.5 times the length of the\n        // quarter arcs, so multiply the straight line pattern \n        // frequency by 3 and the arc frequency by 2.\n        ang *= 3.;\n\n    }\n    else {\n        \n        \n        // Double arc tile.\n        \n        // Randomly rotate.\n        if(rnd<.5) {\n        \tp = p.yx*vec2(1, -1);\n    \t}\n        \n        // Individual arc distances. One in each corner.\n        d.x = length(p - .5) - .5;\n    \td.y = length(p + .5) - .5;\n        d = abs(d);\n        \n        // The angles of the pixels subtended to the circle centers of each \n        // arc. Standard polar coordinate stuff... In a hurry, I threw some\n        // negative signs in and everything lined up, but you could rework \n        // everything to work without them.\n        ang.x = -atan(p.y - .5, p.x - .5);\n        ang.y = -atan(p.y + .5, p.x + .5);\n        \n        \n        // This comes up all the time when animating square Truchets.\n        // It's necessary to reverse the animation flow on alternate\n        // checker squares.\n        if(mod(ip.x + ip.y, 2.)<.5) ang *= -1.;\n\n        \n        // Reverse the flow on all randomly rotated tiles.\n        if(rnd<.5) ang *= -1.;\n        \n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n             d = d.yx;\n             ang = ang.yx;\n         }\n        \n        // Normalizing the angle. Four arcs make up a circle, which\n        // means each needs to run from zero to one four times over\n        // for the texture to wrap... I'm pretty sure that's right...\n        // but I've been wrong before. :)\n        ang *= 4./6.2831853;\n        \n        // The straight lines are about 1.5 times the length of the\n        // quarter arcs, so multiply the straight line pattern \n        // frequency by 3 and the arc frequency by 2.\n        ang *= 2.;\n        \n        \n        \n    }\n    \n    // Adding some time-based movement... or animation, if you wish to \n    // call it that. :D By the way, if you take out the time component,\n    // I think the \"fract\" call still needs to be there.\n    ang = fract(ang + iTime/4.);\n    \n    \n    return d;\n    \n}\n\n// The square grid boundaries.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    p = abs(p);\n    return abs(max(p.x, p.y) - .5) - .001;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    const float gSc = 7.;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-1, -.5)*iTime/4.;\n    \n\n    // Smoothing factor, based on scale.\n    float sf = 2./iResolution.y*gSc;\n   \n    // Thinner rails.\n    float lSc = 6.;\n    #ifdef THINNER\n    lSc = 8.;\n    #endif\n    \n    // Line width.\n    float lw = 1./lSc/gSc;\n    \n    // Calling the Truchet pattern distance field and giving it a bit of width.\n    // Each cell contains two overlapping arcs or line objects. \n    vec2 d = df(p) - 2.5/lSc;\n    \n    // Background color. Keeping things simple.\n    vec3 col = vec3(1., .9, .8);\n    \n    #ifdef THINNER\n    // Line pattern. Used for thinner Truchet widths.\n    float pat = abs(fract(p.x*lSc + .5*0.)  - .5) - lw*lSc/2.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, pat)));\n    #endif\n   \n    // Rendering the two Truchet layers. A lot of this was made up as I\n    // went along, so you could ignore the details.\n    //\n    for(int i = 0; i<2; i++){\n         \n        // The tile layer distance... offset by a small amount or whatever\n        // reason I had at the time. :)\n        float di = d[i] - lw/4.;\n        \n        // The animated part: This is a standard cheap way to do it, but \n        // you could also plug \"ang[i]\" into a function that renders\n        // shapes, etc.\n        float tracks = clamp(sin(ang[i]*6.2831 + iTime*6.)*4., 0., 1.);\n       \n         \n        \n        // Set to 1 for normal edge thickness.\n        float gap = 1. + lw;// + sf/2.;//.25/lSc;\n        // Set to \"di + lw\" for normal edge thickness.\n        \n        // Fake ambient occlusion and dark edge.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., di))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di));\n        \n        // Outer layers.\n        col = mix(col, vec3(1., .9, .8), 1. - smoothstep(0., sf, di + lw*2.)); \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + gap/lSc));\n        // Middle.\n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, di + gap/lSc + lw));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + 2.*gap/lSc));\n        // The central tracks.\n        col = mix(col, vec3(1)*tracks, 1. - smoothstep(0., sf, di + 2.*gap/lSc + lw));\n         \n\n    }\n    \n    // Displaying the grid cells.\n    #ifdef SHOW_GRID\n    float grid = gridField(p);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    #endif\n\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1204, 1237, 1259, 1259, 1317], [1320, 1348, 1369, 1369, 1432], [1714, 1832, 1848, 1890, 6362], [6364, 6395, 6419, 6419, 6533], [6535, 6535, 6589, 6632, 9315]], "test": "untested"}
{"id": "3sBBDV", "name": "twinkle starfield", "author": "TheNosiriN", "description": "something simple I managed to do for a game", "tags": ["2d", "random", "space", "stars", "starfield", "twinkle"], "likes": 10, "viewed": 951, "published": 3, "date": "1590801618", "time_retrieved": "2024-07-30T21:04:10.721882", "image_code": "#define RES 0.2\n\n\n// perlin noise from: https://www.shadertoy.com/view/4sc3z2\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\nfloat hash21(vec2 p)\n{\n \tp = fract( p*vec2(123.34, 456.21) );\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\n\nfloat star(vec2 p, float time)\n{\n\tfloat d = length(p);\n    float m = (max(0.2, abs(sin(time))) * 0.02) / d;\n    \n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\n\nvec3 starField(vec2 uv)\n{\n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for (int x=-1; x<=1; x++){\n        for (int y=-1; y<=1; y++)\n        {\n            vec2 offset = vec2(x, y);\n            \n            float n = hash21(id + offset);\n            float star = star(gv - offset - (vec2(n, fract(n*100.0)) - 0.5), iTime*fract(n*135.246));\n            float size = min(1.0, fract(n*1234.567) + 0.1);\n            \n            col += star * size;\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.y)/RES;\n    vec3 coords = vec3(vec2(uv.x, uv.y + iTime*0.03), iTime*0.3);\n    \n    \n    vec3 stars = starField( vec2(coords.x, coords.y)*5.0 );\n    \n    \n    float warpAmplitude = 10.0;\n   \tfloat warpFrequency = 0.04;\n    \n    vec3 clouds = vec3( perlin_noise(coords) ) * 0.3;\n    \n    vec3 cloudsCol = 0.5 + 0.5*cos((coords*2.0)+vec3(0,3,9)); //color\n    clouds *= cloudsCol;\n    stars *= cloudsCol*2.0;\n    stars *= clouds+0.5;\n    vec3 col = clouds + stars;\n   \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 140, 140, 292], [293, 293, 321, 321, 1260], [1263, 1263, 1285, 1285, 1379], [1382, 1382, 1414, 1414, 1549], [1552, 1552, 1577, 1577, 2082], [2085, 2085, 2142, 2142, 2709]], "test": "untested"}
{"id": "3sSBDV", "name": "Fly On, Buckaroo (Live Version)", "author": "blackle", "description": "live coded in 1 hour on the neuvoids stream for the algorave event on 29/05/2020\nedit: some slight performance improvements\nwatch the replay here: https://www.twitch.tv/videos/635826054", "tags": ["ufo", "livecode"], "likes": 25, "viewed": 855, "published": 3, "date": "1590797606", "time_retrieved": "2024-07-30T21:04:11.470880", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat comp(vec3 p, vec3 ax, float ro) {\n  \n  p = erot(p,ax,ro);\n  p = asin(sin(p));\n  return length(p)-1.;\n}\n\nfloat cloudssdf(vec3 p) {\n  p.y += iTime*.2;\n  float d1 = comp(p, normalize(vec3(1,2,5)), 0.5);\n  p.y += iTime*.2;\n  float d3 = comp(p*2., normalize(vec3(3,1,1)), 2.5)/2.;\n  p.y += iTime*.2;\n  float d4 = comp(p*3., normalize(vec3(4,-2,5)), 3.5)/3.;\n  return (d1+d3+d4)/3.;\n}\n\nfloat linedist (vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat body;\nfloat beamm;\nfloat scene(vec3 p) {\n  p.z += sin(iTime);\n  p = erot(p, vec3(0,1,0), cos(iTime)*.2);\n  beamm = 0.9*(linedist(p, vec3(0), vec3(0,0,-10))-.3-sin(p.z*3.+iTime*4.)*.05 - sin(iTime)*.2);\n  vec3 p2 =p;\n  p2.z = sqrt(p2.z*p2.z+0.02);\n  p2.z+=3.;\n  body = length(p2)-3.8;\n  body += smoothstep(0.8,1.,sin(atan(p2.x,p2.y)*10.))*.02;\n  body += smoothstep(0.8,1.,sin(atan(p2.x,p2.y)*45.))*.003;\n  float hat = length(p-vec3(0,0,0.8))-0.7;\n  return min(min(body,hat), beamm);\n}\nfloat bpm = 125.;\nfloat eye;\nfloat buckaroo(vec3 p) {\n  float bpmt = iTime/60.*bpm;\n  float t = pow(sin(fract(bpmt)*3.14/2.), 20.);\n  p.z += sin(iTime);\n  p = erot(p, vec3(0,1,0), cos(iTime)*.2);\n  p-=vec3(0,0,0.9);\n  p.z += t*.1;\n  p.x = abs(p.x);\n  float b =  length(p)-0.2;\n  b = min(b, linedist(p, vec3(0), vec3(.3,0,.3))-.04);\n  b = min(b, length(p-vec3(.3,0,.3))-.07);\n  b = min(b, linedist(p, vec3(0), vec3(0,0,-.5))-.15);\n  eye = length(p-vec3(.1,.18,.0))-.03;\n  return min(b, eye);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p)-vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 norm2(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(buckaroo(p)-vec3(buckaroo(k[0]), buckaroo(k[1]), buckaroo(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n  return vec3(r*r,g*g,b*b);\n}\n\nvec3 clouds(inout vec3 p, vec3 cam, vec3 init, int depth) {\n  p = init;\n  for (int i = 0; i < depth; i++) {\n    float dist = min(scene(p),cloudssdf(p));\n    dist = sqrt(dist*dist+0.05);\n    p += dist*cam;\n  }\n  float f1 = length(sin(p)*.5+.5)/sqrt(3.);\n  float f2 = smoothstep(0., 30., distance(p,init));\n  vec3 sun = max(0.,dot(vec3(1./sqrt(3.)), cam))*vec3(1);\n  sun = pow(sun,vec3(9)) + pow(sun,vec3(4))*srgb(0.7,0.5,0.2);\n  return mix(srgb(0.2,0.3,0.7), srgb(0.8,0.3,0.3), f1) + mix(srgb(0.2,0.4,0.7), srgb(0.7,0.7,0.7), f2) + sun;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 cam = normalize(vec3(1,uv));\n  \n  float bpmt = iTime/60.*bpm;\n  float t = mix(floor(bpmt) + pow(sin(fract(bpmt)*3.14/2.), 20.), bpmt, 0.8);\n  vec3 init = vec3(-8.+sin(t)*2.,0,0.1);\n  cam = erot(cam, vec3(0,0,1), t*.2);\n  init = erot(init, vec3(0,0,1), t*.2);\n  vec3 clp;\n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  float glow = 0.;\n  for (int i = 0; i < 120 && !hit; i++) {\n    dist = scene(p);\n    if (!isnan(beamm)) glow += .5/(1.+beamm*100.);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n    if(distance(p,init)>20.)break;\n  }\n  glow = min(glow,1.);\n  bool bdy = (dist == body);\n  vec3 n = norm(p);\n  vec3 obj = hit ? sin(n)*.5+.5 : vec3(0);\n  vec3 clds = clouds(clp, cam, init, 20);\n  if (hit) {\n    vec3 p2 = p+n*.1;\n    float ao = smoothstep(-.1,.1,scene(p2));\n    vec3 r = reflect(cam,n);\n    float fres = 1.-abs(dot(cam,n))*.5;\n    obj = clouds(p2, r, p2, 10)*fres*ao;\n    if (!bdy) {\n      p2 = p+cam;\n      r = refract(cam,n,1.1);\n      vec3 p5 = p;\n      bool hhit = false;\n      float bb;\n      for (int i = 0; i < 50 && !hhit; i++) {\n        bb = buckaroo(p5);\n        hhit = bb*bb< 1e-6;\n        p5+=bb*r;\n        if(distance(p5,p)>2.)break;\n      }\n      bool ey = eye==bb;\n      if (hhit) {\n        vec3 n5 = norm2(p5);\n        float fk = length(sin(n5*2.)*.5+.5)/sqrt(3.);\n        obj = fk*(ey ? srgb(0.1,0.1,0.1) : srgb(0.3,0.75,0.3)) + obj*.5;\n      } else {\n      \tobj = obj*.5 + clouds(p2, r, p2, 20)*.9;\n      }\n    }\n  }\n  obj = obj  + srgb(0.2,0.4,0.6)*glow;\n  float fctr = smoothstep(-3.,1., distance(clp,init)-distance(p,init));\n  fragColor.xyz = mix(clds, obj, fctr) + glow*glow*.9*sqrt(fctr*.5+.5);\n  fragColor.xyz = sqrt(fragColor.xyz);\n  fragColor.xyz = abs(erot(fragColor.xyz, normalize(sin(clp*.3+t)), 0.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSBDV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 296, 335, 335, 404], [406, 406, 431, 431, 680], [682, 682, 723, 723, 810], [837, 837, 858, 858, 1301], [1331, 1331, 1355, 1355, 1794], [1796, 1796, 1815, 1815, 1926], [1928, 1928, 1948, 1948, 2071], [2073, 2073, 2111, 2111, 2141], [2143, 2143, 2202, 2202, 2680], [2683, 2683, 2740, 2740, 4557]], "test": "untested"}
{"id": "WdSBDK", "name": "perlin noise with octaves", "author": "TheNosiriN", "description": "noise with ocvtaves and warp coords. I always use this in games but I've never visualized it.", "tags": ["procedural", "noise", "perlinnoise", "smoke"], "likes": 13, "viewed": 482, "published": 3, "date": "1590785012", "time_retrieved": "2024-07-30T21:04:12.214890", "image_code": "// perlin noise from: https://www.shadertoy.com/view/4sc3z2\n#define RES 20.0\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\n/*vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    \n    vec3 result = vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x);\n    return sin(result) * cos(result);\n}*/\n\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/RES;\n    vec3 coords = vec3(vec2(uv.x, uv.y + iTime*0.5), iTime*0.5);\n    \n    int octaves = 3;\n    \n    float frequency = 0.5;\n    float amplitude = 1.0;\n    float persistence = 0.9;\n    float roughness = 2.0;\n    \n    float warpAmplitude = 10.0;\n   \tfloat warpFrequency = 0.4;\n    \n    float col;\n    for (int i=0; i<octaves; i++)\n    {\n        float warp = perlin_noise( coords * warpFrequency );\n        coords += warp * warpAmplitude;\n        \n        col += perlin_noise( coords * frequency ) * amplitude;\n       \tfrequency *= roughness;\n        amplitude *= persistence;\n    }\n    \n    \n\tfragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 100, 100, 273], [487, 487, 515, 515, 1454], [1457, 1457, 1514, 1514, 2172]], "test": "untested"}
{"id": "3dBBWK", "name": "Alien artifact", "author": "jarble", "description": "For some reason, this raymarched object appears to change its shape as the camera angle changes.", "tags": ["raymarching"], "likes": 1, "viewed": 321, "published": 3, "date": "1590781378", "time_retrieved": "2024-07-30T21:04:13.039686", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\n    //surface color\n    return fract((p3+.2)/p3.zyx);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {    \n    return (length(p*sin(p))-.4)/5.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 206, 226, 262], [265, 505, 529, 529, 573], [575, 996, 1087, 1087, 1393], [1408, 1662, 1727, 1727, 1859], [1861, 1950, 1979, 1979, 2289], [2291, 2783, 2923, 2923, 3513], [3515, 3885, 3970, 3970, 4728], [4730, 5057, 5106, 5141, 5272], [5274, 5274, 5331, 5331, 6251]], "test": "untested"}
{"id": "td2fDy", "name": "Holed Cylinder", "author": "Leria", "description": "Simple coding of holed cylinder, testing a sort of dichotomic stepping for raymarching.\n", "tags": ["blue", "polar", "disk", "cylinder", "cordinates"], "likes": 1, "viewed": 357, "published": 3, "date": "1590779703", "time_retrieved": "2024-07-30T21:04:13.898389", "image_code": "vec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n\nconst vec3 cam = vec3(0., 0., 10.);\nfloat uniform_step = 1.;\nvoid draw_disk(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing\n    vec3 p = cam+dir*antialiasing;\n    float s = 0.;\n  \t\n    \n    for(s; s < 150.; s++)\n    {               \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p, p);\n        float dist_center = length(center-cam);\n        \n        vec2 nu = polar_coord(p-(center));\n\n        //if too far, then big step\n        \n        if(sqrt(dist_dist) < (dist_center-radius))\n        {\n        \tk_step += (sqrt(dist_dist)/2.);\n        }\n\n        //if in the shape, draw\n        else if( (length(nu) - 4. <= 0.) && (length(nu) - 1.5 >= 0.) && (distance(p.y, center.y) < 2.))\n        {\n        \tc += 0.2*vec3(0.4, 0.4, 0.6);\n        }   \n        \n        //if it will never be in the shape anymore, return;\n        if(length(p) > (dist_center+radius))\n        {\n         \tbreak;   \n        }\n        \n        p += dir*k_step;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    \n    draw_disk(normalize(vec3(uv, -1.)), vec3(0., 0., 0.), vec3(0., 1., 0.), 30., color);\n    \n    fragColor = vec4(color, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2fDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 174], [237, 237, 317, 317, 1302], [1304, 1304, 1361, 1361, 1585]], "test": "untested"}
{"id": "tsjBDy", "name": "Rippling Rainbow Spheres", "author": "jarble", "description": "I don't know how I got this \"rippling\" effect. The spheres seem to appear or disappear depending on the camera's angle.", "tags": ["raymarching"], "likes": 4, "viewed": 369, "published": 3, "date": "1590776818", "time_retrieved": "2024-07-30T21:04:14.846853", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\n    return fract((p3+.2)/p3.zyx);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {    \n    return length(((sin(p/2.0))/((p.x+p.y+p.z))))*100.0-.5;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p)/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 206, 206, 242], [245, 485, 509, 509, 575], [577, 998, 1089, 1089, 1395], [1410, 1664, 1729, 1729, 1861], [1863, 1952, 1981, 1981, 2291], [2293, 2785, 2925, 2925, 3515], [3517, 3887, 3972, 3972, 4730], [4732, 5059, 5108, 5143, 5274], [5276, 5276, 5333, 5333, 6261]], "test": "untested"}
{"id": "3dSBzt", "name": "Animated Textured Truchet", "author": "Shane", "description": "An animated texture-mapped two-tiled Truchet arrangement, rendered in a faux 3D style.", "tags": ["texture", "abstract", "animation", "truchet", "mapping", "art"], "likes": 41, "viewed": 989, "published": 3, "date": "1590761895", "time_retrieved": "2024-07-30T21:04:15.855158", "image_code": "/*\n\n    Animated Textured Truchet\n    -------------------------\n\n\tHere's that animated texture-mapped two-tiled Truchet code that literally\n    no one asked for. :D Yeah, I don't imagine it'd be something many would \n\trequest, but there'd be some things contained within that I believe a few \n    people would find useful, so here it is.\n\n\tI've texture mapped and animated Truchet tiles and Wang tiles before, but \n    have never texture mapped this particular dual tile arrangement. A quick \n    look on the internet would suggest that little to no one else has either.\n\t\n    Actually, animating this wasn't as bad as I thought it'd be, but it did\n\trequire some logic and finesse. For the mapping part, you use the standard \n    texure mapping for the overlapping rectangular tles, and polar coordinates \n    for the arc tiles, then flip and rotate the texture coordinates where \n    necessary -- Rotate a tile, rotate coordinates, etc. For anyone who's \n    comfortable coding up repeat patterns, it shouldn't be too much of a \n    stretch.\n\n\tHowever, a few simple observations should help: Animating square grid \n    Truchet arc tiles on their own requires the flow directions to be reversed \n    on alternate checkered tiles. Furthermore, in order to work straight line \n    tiles in with them, both horizontal and vertical lines must span two grid \n    cells. In addition, adjacent horizontal line rows must flow in opposite \n    directions. The same applies to adjacent vertical line columns.\n\n\tAnyway, I have a raymarched extruded version coming up, so this was just a\n\tpractice run. By the way, I have a much simpler version of this that I'll \n\tput up soon, for anyone who just wants the pattern animation portion.\n\n\n\tOther examples:\n\n\t// Animation without the complication of texture mapping.\n\tAnimated Two-Tiled Truchet - Shane\n    https://www.shadertoy.com/view/tsSfWK\n\n\n*/\n\n\n// A jagged edge option: Aesthetically, it's interesting, but a little too busy\n// for me, but it's here as an option to show that it can be done.\n//#define JAGGED_EDGES\n\n// Displays each separate grid cell, which allows you to more easily discern\n// individual tiles.\n//#define SHOW_GRID\n\n// Serrated beveling.\n//#define SERRATED_EDGES\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n   \n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n \n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p){ \n    \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n);\n    return sin(p*6.2831853 + iTime*2.); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 0\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n}\n\n\n/*\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n*/\n\n// IQ's vec2 to float hash.\nfloat hash21M(vec2 p, float scale){  \n    p.y = mod(p.y, scale); // Wrapping around the Truchet.\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\n// A basic dot pattern, which returns the offset dot \n// value and its ID.\nvec3 dfDots(vec2 p, float scale){\n    \n    p *= scale;\n    vec2 oP = p;\n    \n    // Repeating along Y, which runs along the Truchet.\n    // The 2D hash function also needs to wrap with it.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Row offsetting. It's hacky, but it works.\n    if(mod(ip.x, 2.)<.5){\n        \n        p = oP - vec2(0, .5);\n        ip = floor(p);\n        p -= ip + .5;\n    }\n    \n    \n    // Random size.\n    float rnd = hash21M(ip, scale);\n    // Random XY offset.\n    vec2 rndP = (vec2(rnd, hash21M(ip + .37, scale)) - .5)*.2;\n    \n    // Circular distance field.\n    float d = length(p - rndP) - .15 - rnd*.225;\n    \n    // Return the distance and ID.\n    return vec3(d, ip);\n}\n\n\n\n\n\n// Texture coordinates for each Truchet segment. Remember that there are\n// two segments per tile. Either two quarter arcs or overlaying lines.\n// Technically, the arcs overlay also, which I did for style purposes.\nvec2 tuv[2];\n\n// A hacky shadow container, which I threw in as an afterthough, because\n// I decided that I wanted fake shadows at the last minute. :)\nvec2 gShadow;\nconst vec2 gShOff = vec2(.07, -.07);\n\n\n// The Truchet distance field. A lot of this is standard stuff. The additional\n// code here involved texture mapping. That was just a case of \nvec2 df(vec2 p){\n    \n    \n    // Two by two cell random value.\n    vec2 ip2 = floor(p/2.);\n    float rnd2 = hash21(ip2 + .43);  \n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random 1x1 numbers, for flipping and rotating.\n    float rnd = hash21(ip);\n    float rnd3 = hash21(ip + .57);\n    \n    // The distance field container. Each cell contains either two lines\n    // or two arcs, so this will hold each one.\n    vec2 d = vec2(1e5);\n    \n    // Shadow offset coordinate.\n    vec2 pShOff = p - gShOff;\n    \n    \n    // UV radial coordinate for each arc... and just to confuse matters, I'm \n    // using radius and angles to represent the UV straight line tiles also... \n    // Yes, that's bad name coding -- No Google apprentiship for me. :D\n    vec2 rad;\n    \n    // The angle is either the angle of the Truchet arcs, which have been \n    // normalized to the zero to one range, or the value of the straight line \n    // position on the straight edge tile arrangement, which also ranges from \n    // zero to one.\n    vec2 ang;\n  \n    \n    // When animating arc Truchet arrangements only, the trick is to \n    // reverse the animation flow on alternate checkered cells... \n    // I have a basic animated version on here somewhere, if you\n    // require more information.\n    //\n    // Anyway, working in the extra overlapping straight line tiles \n    // complicates things. However, after a while, you'll realise that \n    // either the horizontal or vertical line must span two cells for \n    // the animation to work, so that's what the following two-by-two \n    // checkered \"mod\" decision is all about.\n    //\n    // Every 2 by 2 alternate checker, put in the overlapped straight \n    // tiles. Otherwise, calculate the distance field for the double \n    // arc one.\n    //\n    if(mod(ip2.x + ip2.y, 2.)<.5){ // Alternate checkers.\n    //if(rnd2<.5){ // Random 2x2 coverings.\n    //if((mod(ip2.x, 2.)<.5 || mod(ip2.y, 2.)<.5) && rnd2<.5){ // Mixing.\n        \n        \n        \n        // Overlapping straight tile.\n\n        // Set the UV coordinates prior to folding the center over\n        // to form a vertical or horizontal line.\n        rad = p*vec2(-1, 1);\n\t\tang = p.yx; // I can't remember why I reversed these. :)\n        \n        // Horizontal and vertical line distance fields.\n        d = abs(p);\n        gShadow = abs(pShOff);\n        \n\n        // Reversing just the X-directions on every second column. It's \n        // common sense... but it still took me a while to figure out.. :)\n        if(mod(ip.x + 1., 2.)<.5){\n            ang.x *= -1.;\n            rad.x *= -1.;\n\n        }\n        \n        // Reversing just the Y-directions on every second row.\n        if(mod(ip.y + 1., 2.)>.5){\n            ang.y *= -1.;\n            rad.y *= -1.;\n        }  \n\n\n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n            d = d.yx;\n            ang = ang.yx;\n            gShadow = gShadow.yx;\n            rad = rad.yx;\n        }\n\n        // This makes things line up.\n        ang += .5;\n        //ang *= 3.;\n\n    }\n    else {\n        \n        \n        // Double arc tile.\n        \n        // Randomly rotate.\n        if(rnd<.5) {\n        \tp = p.yx*vec2(1, -1);\n            pShOff = pShOff.yx*vec2(1, -1);\n    \t}\n        \n        // Individual arc distances. One in each corner.\n        d.x = length(p - .5) - .5;\n    \td.y = length(p + .5) - .5;\n        \n        // Shadows: Same as above, but with the offset coordinates.\n        gShadow.x = length(pShOff - .5) - .5;\n        gShadow.y = length(pShOff + .5) - .5;\n        \n        // The angles of the pixels subtended to the circle centers of each \n        // arc. Standard polar coordinate stuff... In a hurry, I threw some\n        // negative signs in and everything lined up, but you could rework \n        // everything to work without them.\n        ang.x = -atan(p.y - .5, p.x - .5);\n        ang.y = -atan(p.y + .5, p.x + .5);\n        \n        // Arcs have the distance field form: arc = abs(circle) - arcWidth/2.\n        // However, this folds things across the center, which you don't want\n        // for your UV coordinates, so set \"uv\" to the unfolded distance.\n        // This is one of the many things I've learned the hard way. :)\n        rad = d;\n        \n        // Turn the quarter circles into arcs. Do the same with the \n        // offset shadow distance field.\n        d = abs(d);\n        gShadow = abs(gShadow);\n        \n        // This comes up all the time when animating square Truchets.\n        // It's necessary to reverse the animation flow on alternate\n        // checker squares.\n        if(mod(ip.x + ip.y, 2.)<.5){\n            ang *= -1.;\n            rad *= -1.;\n        }\n        \n        // Reverse the flow on all randomly rotated tiles.\n        if(rnd<.5){\n            ang *= -1.;\n            rad *= -1.;\n        } \n        \n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n             d = d.yx;\n             ang = ang.yx;\n             \n             gShadow = gShadow.yx;\n             \n             rad = rad.yx;\n         }\n        \n        // Normalizing the angle. Four arcs make up a circle, which\n        // means each needs to run from zero to one four times over\n        // for the texture to wrap... I'm pretty sure that's right...\n        // but I've been wrong before. :)\n        ang *= 4./6.2831853;\n        \n        //ang *= 2.;\n        \n        \n        \n    }\n    \n    // Adding some time-based movement... or animation, if you wish to \n    // call it that. :D By the way, if you take out the time component,\n    // I think the \"fract\" call still needs to be there.\n    ang = fract(ang + iTime/4.);\n\n    // UV coordinates. One set for each cell object.\n    tuv[0] = vec2(rad.x, ang.x);\n    tuv[1] = vec2(rad.y, ang.y);\n    \n    \n    return d;\n    \n}\n\n\n// The square grid boundaries.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    p = abs(p);\n    \n    return abs(max(p.x, p.y) - .5) - .03;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Subtle barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .025*(r*r*.5 + r);\n    \n    // Scaling and translation.\n    const float gSc = 6.;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-1, -.25)*iTime/4.;\n    \n    // Smoothing factor, based on scale.\n    float sf = 2./iResolution.y*gSc;\n   \n    // Line scale, and line width... This relates back to a simpler example \n    // I made. I wouldn't pay it too much attention.\n    float lSc = 7.; \n    float lw = 1./lSc/gSc;\n    \n    // Calling the Truchet pattern distance field and giving it a bit of width.\n    // The width relates back to another example, but you could hard code figures\n    // in, if you wanted.\n    vec2 d = df(p) - 2.5/lSc;\n    \n    // Giving the shadow the same width.  You could add more to represent more \n    // depth, but it's not that important.\n    gShadow = gShadow - 2.5/lSc;\n    \n    // Setting the background to the texture.\n    vec3 bgTex = texture(iChannel0, p/gSc + .5).xyz; bgTex *= bgTex;\n    bgTex = smoothstep(.05, .5, bgTex); // Ramping up the color a bit.\n\tvec3 col = bgTex;\n    \n    // Applying some horizontal lines to give an industrial look, or something.\n    float pat = abs(fract(p.y*lSc*2. + .5)  - .5) - lw*lSc;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pat));\n   \n  \n\n    // Rendering the two Truchet layers. A lot of this was made up as I\n    // went along, so you could ignore the details.\n    //\n    for(int i = 0; i<2; i++){\n         \n        // The distance field value for the layer. I've bumped it up by a\n        // small portion for some reason. It looks untidy, but I'll leave\n        // it there, just in case. :)\n        float di = d[i] - lw/4.;\n\n        \n        // Using the Truchet texture coordinates to apply some texture color to \n        // the Truchet object. I'm using the trusty metallic texture, but the\n        // wood and blue noise textures look all right as well.        \n        vec3 tx = texture(iChannel0, tuv[i]).xyz; tx *= tx;\n        tx = smoothstep(.05, .5, tx);\n        vec3 tx2 = max(1. - tx.zyx, 0.);\n        \n     \n        // Putting a repeat random dot pattern onto the Truchet. I tried some \n        // fancier patterns, but went with something simple in the end.\n        vec3 tr3 = dfDots(tuv[i] + vec2(.0, 0), 4.); // The \"4\" is a wrap scale.\n        float tr = tr3.x;\n        float rnd = hash21M(tr3.yz + .67, 4.);\n        \n        float ns = n2D3G(p/gSc*1.5)*.66 + n2D3G(p/gSc*3.)*.34;\n        rnd = mix(rnd, 1. - rnd, smoothstep(-.125, .125, ns));\n        \n        \n        //rnd = smoothstep(.5, .85, rnd);\n        vec3 dotCol = .5 + .5*cos(rnd*6.2831 + vec3(2, 1, 0));\n        dotCol = mix(tx*3., dotCol, .9);\n        \n        \n        // Applying the dots to the texture object. I'm not sure why I took this\n        // route. You could apply the pattern directly to the Truchet object below,\n        // if you wanted... I'm sure I had my reasons. :)\n        tx = mix(tx, vec3(0), 1. - smoothstep(0., sf, tr - .1));\n        tx = mix(tx, dotCol*1.5, 1. - smoothstep(0., sf, tr + .05));\n         \n    \n        // Applying the shadows. Because there's two layers, you have to apply \n        // them in a different way. Combine the two shadows for the first (ground)\n        // layer, then apply the top shadow to the bottom object layer... Confused?\n        // That makes both of us. :D It's one of the reasons I find it easier to\n        // to render things in 3D.\n        //\n        // By the way, you could arrange for this to be outside the loop, but I \n        // think it's more readable here.\n        float diSh = i == 0? min(gShadow[0], gShadow[1]) : max(gShadow[1], d[0]);\n\n        // Jagged edge option... Not sure what I was thinking with this modification,\n        // but I've left it here as an option, just in case I decide to rework it. :)\n        #ifdef JAGGED_EDGES\n        float diO = max(di, -tr/4.);\n        diSh = max(diSh, -dfDots((tuv[i] - gShOff), 4.).x/4.);\n        #else\n        float diO = di;\n        #endif\n        \n        \n        // Self shadowing. Analogous to ambient occlusion, but not really. :)\n        // You could almost use just this and save yourself the hassle of rendering\n        // fake shadow layers, but the shadows are offset in the direction of the\n        // light which provides more of an air of authenticity.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., diO))*.5);\n         \n        // Render the shadow layer. See the \"diSh\" comments above.  \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., diSh))*.5);\n        \n        // Rendering the stroke layer... The black edge. \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, diO));\n        \n        float sh = max(.35 - di/lw/6., 0.);\n        tx2 *= sh;\n        \n        \n        \n        \n        // Outer Truchet layer.\n        float gap = 1. + lw;\n        col = mix(col, tx2, 1. - smoothstep(0., sf, diO + lw*2.));\n        \n        #ifdef SERRATED_EDGES\n        // Side decorations.\n        float lnd = (abs(fract(tuv[i].y*12. - .5) - .5) - lw/3.)/12.;\n        lnd = max(lnd, di);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, lnd))*.85);\n        #endif\n\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + gap/lSc));\n        col = mix(col, tx, 1. - smoothstep(0., sf, di + gap/lSc + lw*1.5));\n\n        // Inner Truchet layer.\n        gap = .9;\n        di = max(di, -tr*4.);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + 2.*gap/lSc));\n        col = mix(col, tx*sh, 1. - smoothstep(0., sf, di + 2.*gap/lSc + lw*1.5));\n        \n        #ifndef SERRATED_EDGES\n        // Another kind of side bevel.\n        col = mix(col, tx, (1. - smoothstep(0., sf, abs(di + gap/lSc*.9/2. + lw*1.5) - lw/3.))*.75);\n        #endif\n\n    }\n  \n    // Displaying the grid cells.\n    #ifdef SHOW_GRID\n    float grid = gridField(p);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., grid))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    col = mix(col, 1.25 - bgTex.zyx, (1. - smoothstep(0., sf, grid  + .03)));\n\t#endif\n    \n    // Toning things down.\n    //col = 1. - exp(-col*1.5);\n    \n     // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    float vig = pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./6.);\n    col *= min(vig*1.25, 1.);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2227, 2260, 2282, 2282, 2340], [2343, 2371, 2392, 2392, 2465], [2469, 2491, 2511, 2864, 3065], [3067, 3108, 3133, 3133, 3568], [3723, 3751, 3786, 3786, 3914], [3916, 3991, 4024, 4024, 4697], [5121, 5264, 5280, 5327, 11415], [11418, 11449, 11473, 11473, 11590], [11593, 11593, 11647, 11695, 18277]], "test": "untested"}
{"id": "WsjBWG", "name": "Shimmering Gemstones", "author": "jarble", "description": "Based on my \"Asteroid Belt\" shader", "tags": ["raymarching"], "likes": 2, "viewed": 344, "published": 3, "date": "1590723352", "time_retrieved": "2024-07-30T21:04:16.648038", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\n    p3 *= p3 + (15.0*((p3.x+p3.y+p3.z)*3.0)*((p3.x*3.0+p3.y*2.0+p3.z*1.0)));\n    return fract((p3+.1*sin(p3.y+p3.x+p3.z))/p3.zyx);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+sin(iTime)*2.0, 5.0, 2.0*sin(iTime));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p+iTime*10.0*vec3(0.0,1.0,0.0))/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 475, 608], [611, 851, 885, 885, 971], [973, 1394, 1485, 1485, 1791], [1806, 2060, 2125, 2125, 2257], [2259, 2348, 2377, 2377, 2687], [2689, 3181, 3321, 3321, 3911], [3913, 4283, 4368, 4368, 5126], [5128, 5455, 5504, 5539, 5670], [5672, 5672, 5729, 5729, 6661]], "test": "untested"}
{"id": "wdBBDy", "name": "Tornado World", "author": "jarble", "description": "It's a mesmerizing sea of technicolor tornadoes.", "tags": ["raymarching", "tornado", "cyclone"], "likes": 1, "viewed": 361, "published": 3, "date": "1590714197", "time_retrieved": "2024-07-30T21:04:17.550624", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\tp3 *= (p3.y+p3.y+p3.z)*(15.0);\n    return fract((p3+1.2+sin((iTime+p3.y+p3.x+p3.z)*5.0)/10.0)/(p3+.5+sin(p3.y+p3.x+p3.z)));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 475, 601], [604, 844, 878, 878, 964], [966, 1387, 1478, 1478, 1784], [1799, 2053, 2118, 2118, 2250], [2252, 2341, 2370, 2370, 2680], [2682, 3174, 3314, 3314, 3904], [3906, 4276, 4361, 4361, 5119], [5121, 5448, 5497, 5532, 5663], [5665, 5665, 5722, 5722, 6609]], "test": "untested"}
{"id": "tsSfWy", "name": "Emerald Spheres", "author": "jarble", "description": "It's a world of iridescent shiny spherical objects.", "tags": ["raymarching"], "likes": 0, "viewed": 326, "published": 3, "date": "1590707367", "time_retrieved": "2024-07-30T21:04:18.452214", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\tp3 *= 100.0;\n    return fract((p3+1.0+sin(p3.x+p3.y+p3.z))/p3);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/200.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 475, 541], [544, 784, 818, 818, 904], [906, 1327, 1418, 1418, 1724], [1739, 1993, 2058, 2058, 2190], [2192, 2281, 2310, 2310, 2620], [2622, 3114, 3254, 3254, 3844], [3846, 4216, 4301, 4301, 5059], [5061, 5388, 5437, 5472, 5603], [5605, 5605, 5662, 5662, 6552]], "test": "untested"}
{"id": "wdSfWy", "name": "Rainbow Lanterns", "author": "jarble", "description": "This raymarched scene has floating \"lanterns\" with many different colors.", "tags": ["raymarching"], "likes": 1, "viewed": 289, "published": 3, "date": "1590705829", "time_retrieved": "2024-07-30T21:04:19.211184", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\tp3 *= 100.0;\n    return fract((p3+1.0)/(p3));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 475, 523], [526, 766, 800, 800, 886], [888, 1309, 1400, 1400, 1706], [1721, 1975, 2040, 2040, 2172], [2174, 2263, 2292, 2292, 2602], [2604, 3096, 3236, 3236, 3826], [3828, 4198, 4283, 4283, 5041], [5043, 5370, 5419, 5454, 5585], [5587, 5587, 5644, 5644, 6536]], "test": "untested"}
{"id": "tdlcWB", "name": "Capsule World", "author": "logw", "description": "Shows a world that is shaped like the surface of a 4D pill capsule.", "tags": ["raytracing", "noneuclidean"], "likes": 1, "viewed": 165, "published": 3, "date": "1590705683", "time_retrieved": "2024-07-30T21:04:20.253398", "image_code": "// I wanted to make a program to show what it would be like to be inside\n// a complex non-Euclidean space.  I had been thinking about this even\n// back when I only had access to a fixed-function GPU, but I only figured\n// out how to do uniform isotropic curvature (i.e., either elliptical or\n// hyperbolic geometery).  I never implemented my plans to glue together\n// chunks of different curvature.  With raytracing, I can make anisotropic\n// curvature, but I still rely on gluing pieces together to make a more\n// complex space, because as far as I know only simple shapes have\n// geodesics that can be computed easily.  In this example, I used spheres\n// and cylinders, whose geodesics can be described using trigonometry.\n//\n// You are on the surface of a 4D \"pill capsule\", meaning a segment of 4D\n// cylinder with hemihyperspherical caps on either end.  The cross section\n// of the cylinder is itself a 2D sphere (the surface of a ball).\n//\n// Walk (on ground) = WASD\n// Look = click and drag\n// Jetpack = space (direction is affected by looking up or down)\n// Tilt (in air) = WASD\n//\n// I worked out the math to do geometrically-accurate lighting, but got\n// distracted by other projects and never implemented it.  I'm releasing\n// this as-is so it doesn't stay hidden forever.\n\nconst vec3 fog_color = vec3(0.8, 0.9, 1.0);\nconst float fog_density = 0.2;\nconst int n_floor_tile_rows = 20; // around cylinder\nconst float floor_tile_height = pi / float(n_floor_tile_rows);\nconst float max_dist = log(512.0) / fog_density;\nconst vec3 color1 = vec3(1.0, 0.1, 0.5);\nconst vec3 color2 = vec3(0.1, 1.0, 0.6);\nconst vec2 n_hud_lines = vec2(6.0, 6.0);\nconst float hud_line_size = 0.35;\n\nconst uint hit_nothing = 0u;\nconst uint hit_sphere_floor = 1u;\nconst uint hit_cylinder_floor = 2u;\nconst uint hit_window = 3u;\n\nstruct Ray\n{\n    vec4 r;\n    vec4 v;\n    uint region;\n};\n\n#if 0\nvec4 hash4(in ivec4 r)\n{\n    vec4 abs_r = vec4(abs(r));\n    vec4 x = abs_r.x + vec4(32.9281, 18.3921, 22.8247, 28.02821)\n             + float(sign(r.x)) * vec4(1.0232, -0.3958, 2.0032, 1.5928);\n    vec4 y = abs_r.x + abs_r.y + vec4(10.9284, 29.2759, 13.2948, 19.0282)\n             + float(sign(r.y)) * vec4(-0.7492, -0.9428, 0.7832, 1.9482);\n    vec4 z = abs_r.x + abs_r.y + abs_r.z + vec4(16.2981, 18.2841, 15.2948, 20.7492)\n             + float(sign(r.z)) * vec4(0.3958, 0.9824, 2.0948, 1.0934);\n    vec4 w = abs_r.x + abs_r.y + abs_r.z + abs_r.w + vec4(14.02981, 19.2434, 13.4502, 27.4392)\n             + float(sign(r.w)) * vec4(-0.3249, 4.2849, 2.4981, 1.4398);\n    return 2.0 * fract(pi*tan(x)*tan(y)*tan(z)*tan(w)) - 1.0;\n}\n\nfloat noise1(in vec4 r)  // Perlin, as I understand it.\n{\n    ivec4 int_r = ivec4(floor(r));\n    const ivec4[16] offset = ivec4[16](\n        ivec4(0, 0, 0, 0), ivec4(0, 0, 0, 1),\n        ivec4(0, 0, 1, 0), ivec4(0, 0, 1, 1),\n        ivec4(0, 1, 0, 0), ivec4(0, 1, 0, 1),\n        ivec4(0, 1, 1, 0), ivec4(0, 1, 1, 1),\n        ivec4(1, 0, 0, 0), ivec4(1, 0, 0, 1),\n        ivec4(1, 0, 1, 0), ivec4(1, 0, 1, 1),\n        ivec4(1, 1, 0, 0), ivec4(1, 1, 0, 1),\n        ivec4(1, 1, 1, 0), ivec4(1, 1, 1, 1)\n    );\n    mat4[4] grad;\n    for (int row = 0; row < 4; row++)\n    {\n        for (int col = 0; col < 4; col++)\n        {\n            grad[row][col] = hash4(int_r + offset[4*row+col]);\n        }\n    }\n    vec4 fract_r = r - vec4(int_r);\n    mat4 value;\n    for (int row = 0; row < 4; row++)\n    {\n        for (int col = 0; col < 4; col++)\n        {\n            value[row][col] = dot(fract_r - vec4(offset[4*row+col]),\n                                  grad[row][col]);\n        }\n    }\n    vec4[2] weight_1D;\n    weight_1D[1] = (3.0-2.0*fract_r) * fract_r * fract_r;\n    weight_1D[0] = 1.0 - weight_1D[1];\n    vec4 weight01 = vec4(weight_1D[0][0]*weight_1D[0][1],\n                         weight_1D[0][0]*weight_1D[1][1],\n                         weight_1D[1][0]*weight_1D[0][1],\n                         weight_1D[1][0]*weight_1D[1][1]);\n    vec4 weight23 = vec4(weight_1D[0][2]*weight_1D[0][3],\n                         weight_1D[0][2]*weight_1D[1][3],\n                         weight_1D[1][2]*weight_1D[0][3],\n                         weight_1D[1][2]*weight_1D[1][3]);\n    mat4 weight = outerProduct(weight23, weight01);\n    float v0 = weight_1D[0][0]*value[0][0] + weight_1D[1][0]*value[2][0];\n    float v1 = weight_1D[0][0]*value[1][0] + weight_1D[1][0]*value[3][0];\n    return dot(vec4(1.0) * matrixCompMult(weight, value), vec4(1.0));\n}\n#endif\n\nvec3 hash3(in ivec3 r)\n{\n    vec3 abs_r = vec3(abs(r));\n    vec3 x = abs_r.x + vec3(32.9281, 18.3921, 22.8247)\n             + float(sign(r.x)) * vec3(1.0232, -0.3958, 2.0032);\n    vec3 y = abs_r.x + abs_r.y + vec3(10.9284, 29.2759, 13.2948)\n             + float(sign(r.y)) * vec3(-0.7492, -0.9428, 0.7832);\n    vec3 z = abs_r.x + abs_r.y + abs_r.z + vec3(16.2981, 18.2841, 15.2948)\n             + float(sign(r.z)) * vec3(0.3958, 0.9824, 2.0948);\n    // Use clamp because fract is not always between 0.0 and 1.0 for very\n    // large inputs.\n    return clamp(2.0 * fract(pi*tan(x)*tan(y)*tan(z)) - 1.0, -1.0, 1.0);\n}\n\nfloat noise1(in vec3 r)\n{\n    ivec3 int_r = ivec3(floor(r));\n    const ivec3[8] offset = ivec3[8](\n        ivec3(0, 0, 0), ivec3(0, 0, 1),\n        ivec3(0, 1, 0), ivec3(0, 1, 1),\n        ivec3(1, 0, 0), ivec3(1, 0, 1),\n        ivec3(1, 1, 0), ivec3(1, 1, 1)\n    );\n    vec3[8] grad;\n    for (int i = 0; i < 8; i++)\n    {\n        grad[i] = hash3(int_r + offset[i]);\n    }\n    vec3 fract_r = r - vec3(int_r);\n    mat2x4 value;\n    for (int row = 0; row < 2; row++)\n    {\n        for (int col = 0; col < 4; col++)\n        {\n            value[row][col] = dot(fract_r - vec3(offset[4*row+col]),\n                                  grad[4*row+col]);\n        }\n    }\n    vec3[2] weight_1D;\n    weight_1D[1] = (3.0-2.0*fract_r) * fract_r * fract_r;\n    weight_1D[0] = 1.0 - weight_1D[1];\n    vec2 weight0 = vec2(weight_1D[0][0], weight_1D[1][0]);\n    vec4 weight12 = vec4(weight_1D[0][1]*weight_1D[0][2],\n                         weight_1D[0][1]*weight_1D[1][2],\n                         weight_1D[1][1]*weight_1D[0][2],\n                         weight_1D[1][1]*weight_1D[1][2]);\n    mat2x4 weight = outerProduct(weight12, weight0);\n    return dot(vec4(1.0) * matrixCompMult(weight, value), vec2(1.0));\n}\n\nvec3 tile_color(in vec3 edge_dist, in vec3 r, in vec3 base_color)\n{\n    vec3 profile = 1.0 - pow(max(1.0-edge_dist, 0.0), vec3(10.0));\n    return vec3(\n        base_color\n        * max(profile.x*profile.y*profile.z\n                  - max(noise1(200.0*r)-0.3, 0.0),\n              0.0)\n    );\n}\n\nvec3 triangle_coords(in vec3 p0, in vec3 p1, in vec3 p2,\n                     in vec3 r, out ivec3 icoord)\n{\n    // Normal to the (flat) triangle\n    vec3 n = normalize(cross(p1-p0, p2-p0));\n    // Project r onto the flat triangle\n    float scale = dot(n, p0) / dot(n, r);\n    vec3 r_ = scale * r;\n    // Decompose in terms of p1-p0 and p2-p0\n    vec3 u;\n    u.xy =\n        inverse(\n            transpose(mat2x3(p1-p0, p2-p0))\n            * mat2x3(p1-p0, p2-p0)\n        ) * transpose(mat2x3(p1-p0, p2-p0)) * (r_-p0);\n    u.z = 1. - u.x - u.y;\n    vec3 coord;\n    vec3 icoordf;\n    coord = modf(4.*u, icoordf);\n    icoord = ivec3(icoordf);\n    return coord;\n}\n\nvec3 sphere_floor_color(in vec4 r)\n{\n    // Constructing the vertices of a pentagonal rotunda\n    const float sL = 2. * sin(tau/20.); // side length\n    const float prc = 0.5*sL / sin(tau/10.); // pentagon radius at corner\n    // Use to reflect across the xz (φ=0) plane\n    const vec3 ref = vec3(1., -1., 1.);\n    // normal to the plane at φ = τ/10\n    const vec3 v = vec3(-sin(tau/10.), cos(tau/10.), 0.);\n    // Use to reflect across the φ=τ/10 plane\n    const mat3 ref_ = mat3(1.) - outerProduct(2.*v, v);\n    // Corner of top pentagon\n    const vec3 p0 = vec3(prc*cos(tau/10.),\n                         prc*sin(tau/10.),\n                         sqrt(1.-prc*prc));\n    // Bottom corner of bottom pentagon\n    const vec3 p3 = vec3(cos(tau/20.), sin(tau/20.), 0.);\n    // Side corner of bottom pentagon\n    const vec3 p1 = normalize(vec3(p0.x+p3.x, 0., p0.z+p3.z));\n    // Center of the bottom pentagon\n    const vec3 p2 = normalize(p0 + p1 + ref_*p1 + p3 + ref_*p3);\n    \n    float phi = mod(atan(r.y, r.x), tau/5.) - tau/10.;\n    float s = length(r.xy);\n    // r mapped into a standard τ/10 slice centered on the x axis\n    vec3 r_ = vec3(s*cos(phi), s*sin(phi), abs(r.w));\n    // r_ reflected onto the +y side of that slice\n    vec3 r_p = vec3(r_.x, abs(r_.y), r_.z);\n    // Convex coördinates (not sure if that is a real term)\n    // of the point within the triangle.  (Coëfficients of a\n    // convex combination giving r_ as a function of the\n    // corners of the triangle\n    vec3 u = vec3(1.);\n    // Discretized version of convex coördinates giving the\n    // identity of the sub-triangle\n    ivec3 i;\n    bool checker = false;\n    vec3 color = r.w > 0. ? color1 : color2;\n    if (dot(r_p, normalize(cross(ref*p0, p0))) > 0.)\n    {\n        u = triangle_coords(vec3(0., 0., 1.), ref*p0, p0, r_, i);\n    }\n    else if (dot(r_p, normalize(cross(p1, p0))) > 0.)\n    {\n        u = triangle_coords(p0, ref*p0, p1, r_, i);\n        checker = true;\n    }\n    else if (dot(r_p, normalize(cross(p1, p2))) > 0.)\n    {\n        u = triangle_coords(p0, p1, p2, r_p, i);\n    }\n    else if (dot(r_p, normalize(cross(p1, p3))) > 0.)\n    {\n        if (dot(r_p, normalize(cross(p3, p2))) > 0.)\n        {\n            u = triangle_coords(p1, p3, p2, r_p, i);\n        }\n        else\n        {\n            u = triangle_coords(p2, p3, ref_*p3, r_p, i);\n        }\n    }\n    else\n    {\n        u = triangle_coords(p1, ref*p3, p3, r_, i);\n        checker = true;\n    }\n    if (!bool((i.x^i.y^i.z)&1))\n    {\n        u = 1. - u;\n    }\n    else if (checker)\n    {\n        color = vec3(1.);\n    }\n    return tile_color(min(1.9*u, 1.), r.xyw, color);\n}\n\nvoid cast_ray_on_sphere(in Ray R, out Ray S, out float dist,\n                        out uint hit_status)\n{\n    S = R;\n    hit_status = hit_nothing;\n    dist = 0.0;\n    vec4 new_r;\n    vec4 new_v;\n    float new_dist;\n    bool hit;\n    cast_ray_on_sphere_at_plane(R.r, R.v, Z, floor_z, new_r, new_v,\n                                new_dist, hit);\n    if (hit)\n    {\n        hit_status = hit_sphere_floor;\n        S.r = new_r;\n        S.v = new_v;\n        dist = new_dist;\n    }\n    float sign_ = R.region == region_right_sphere ? 1.0 : -1.0;\n    cast_ray_on_sphere_at_plane(R.r, R.v, sign_ * W, 0.0,\n                                new_r, new_v, new_dist, hit);\n    if (hit && (hit_status == hit_nothing || new_dist < dist))\n    {\n        hit_status = hit_window;\n        S.r = new_r;\n        S.r.w = sign_ * cylinder_length/2.0;\n        S.v = new_v;\n        S.region = region_cylinder;\n        dist = new_dist;\n    }\n}\n\nvoid cast_ray_on_cylinder(in Ray R, out Ray S, out float dist,\n                          out uint hit_status)\n{\n    S = R;\n    dist = 0.0;\n    hit_status = hit_nothing;\n    vec4 new_r;\n    vec4 new_v;\n    float new_dist;\n    bool hit;\n    cast_ray_on_cylinder_at_floor(R.r, R.v, floor_z, new_r, new_v,\n                                  new_dist, hit);\n    if (hit)\n    {\n        hit_status = hit_cylinder_floor;\n        S.r = new_r;\n        S.v = new_v;\n        dist = new_dist;\n    }\n    cast_ray_on_cylinder_at_window(R.r, R.v, cylinder_length/2.0,\n                                   new_r, new_v, new_dist, hit);\n    if (hit && (hit_status == hit_nothing || new_dist < dist))\n    {\n        hit_status = hit_window;\n        S.r = new_r;\n        S.r.w = 0.0;\n        S.v = new_v;\n        S.region = region_right_sphere;\n        dist = new_dist;\n    }\n    cast_ray_on_cylinder_at_window(R.r, R.v, -cylinder_length/2.0,\n                                   new_r, new_v, new_dist, hit);\n    if (hit && (hit_status == hit_nothing || new_dist < dist))\n    {\n        hit_status = hit_window;\n        S.r = new_r;\n        S.r.w = 0.0;\n        S.v = new_v;\n        S.region = region_left_sphere;\n        dist = new_dist;\n    }\n}\n\nvec3 cylinder_floor_color(in vec4 r)\n{\n    const int n_cols = 2*n_floor_tile_rows;\n    const float f_n_cols = float(n_cols);\n    vec2 tile_coords;\n    tile_coords.y = r.w / floor_tile_height;\n    tile_coords.x = (atan(r.y, r.x) + tau/2.) * f_n_cols / tau;\n    // Yes this rounds both 0.5 and -0.5 to 0 and that’s good\n    ivec2 i_coords = ivec2(tile_coords);\n    const int n_rows = 2 * int(cylinder_length / 2. / floor_tile_height);\n    vec3 color = vec3(1.);\n    if (n_rows/2 - abs(i_coords.y) - 1 < n_rows/3\n        && ((i_coords.y-i_coords.x)&3) < 2)\n    {\n        color = r.w > 0. ? color1 : color2;\n    }\n    vec3 edge_dist = vec3(1. - abs(1. - 2.*fract(tile_coords)), 1.);\n    return tile_color(edge_dist, r.xyw, color);\n}\n\nfloat draw_hud(in Camera camera, in vec4 dir)\n{\n    float th = asin(dot(dir, camera.body_axes[1]));\n    vec2 px = vec2(1.0/cos(th), 1.0) * field_of_view / iResolution.x;\n    float ph_px = atan(dot(dir, -camera.body_axes[2]),\n                       dot(dir, camera.body_axes[0])) / px.x;\n    float th_px = th / px.y;\n    vec2 slice = vec2(tau, pi) / px / n_hud_lines;\n    float hzig = abs(mod(ph_px, slice.x) - slice.x/2.0);\n    float hzigzag = abs((1.0-hud_line_size)*slice.x/2.0 - hzig);\n    float a = 0.0;\n    if ((1.0-hud_line_size)*slice.x/2.0 - hzig < 0.0)\n    {\n    \tfloat vzig = abs(mod(th_px, slice.y) - slice.y/2.0);\n    \ta = max(vzig-(slice.y/2.0-1.0), 0.0);\n    }\n    if (mod(th_px, slice.y) < 10.0)\n    {\n        a = max(a, max(1.0-hzigzag, 0.0));\n    }\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screen_coords = 2.0 * (fragCoord - iResolution.xy/2.0)\n                         / iResolution.x;\n    vec3 color = fog_color;\n    Camera camera = load_camera(iChannel1);\n    vec4 v = normalize(screen_coords.x*tan_fov*camera.axes[0]\n                       + screen_coords.y*tan_fov*camera.axes[1]\n                       - camera.axes[2]);\n    Ray R = Ray(camera.axes[3] + camera.w*W, v, camera.region);\n    Ray S;\n    float dist = 0.0;\n    float new_dist;\n    uint hit_status = hit_nothing;\n    for (uint count = 0u; count < 10u; count++)\n    {\n        if (R.region == region_right_sphere\n            || R.region == region_left_sphere)\n        {\n            cast_ray_on_sphere(R, S, new_dist, hit_status);\n        }\n        else if (R.region == region_cylinder)\n        {\n            cast_ray_on_cylinder(R, S, new_dist, hit_status);\n        }\n        else\n        {\n            break;\n        }\n        dist += new_dist;\n        if (dist >= max_dist)\n        {\n            break;\n        }\n        if (hit_status == hit_sphere_floor)\n        {\n            color = sphere_floor_color(S.r);\n            break;\n        }\n        else if (hit_status == hit_cylinder_floor)\n        {\n            color = cylinder_floor_color(S.r);\n            break;\n        }\n        else if (hit_status == hit_nothing)\n        {\n            break;\n        }\n        else if (hit_status == hit_window)\n        {\n            R = S;\n        }\n        else\n        {\n            break;\n        }\n    }\n    if (hit_status != hit_nothing)\n    {\n        color = mix(fog_color, color, exp(-fog_density*dist));\n    }\n    float hud = draw_hud(camera, v);\n    color = mix(color, 1.0-color, 0.75*hud);\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float walk_speed = 0.4; // radians/sec.\nconst float walk_accel_time = 0.25; // sec.\nconst float gravity = 0.75; // radians/sec./sec.\nconst float thrust = 1.125; // radians/sec./sec.\nconst float mouse_sensitivity = 2.0*pi; // radians / half screen\nconst float tilt_rate = 0.6; // radians/sec.\n\nvoid store(inout vec4 fragColor, in vec2 fragCoord,\n           in vec4 value, in ivec2 addr)\n{\n    if (ivec2(fragCoord) == addr)\n    {\n        fragColor = value;\n    }\n}\n\nvoid store(inout vec4 fragColor, in vec2 fragCoord,\n           in float value, in ivec3 addr)\n{\n    if (ivec2(fragCoord) == addr.xy)\n    {\n        fragColor[addr.z] = value;\n    }\n}\n\nvoid store_mat4(inout vec4 fragColor, in vec2 fragCoord,\n                in mat4 value, in ivec2 addr)\n{\n    ivec2 cur_addr = ivec2(fragCoord);\n    if (cur_addr.y == addr.y\n        && addr.x <= cur_addr.x && cur_addr.x < addr.x + 4)\n    {\n        fragColor = value[cur_addr.x-addr.x];\n    }\n}\n\nbool key_is_pressed(uint code)\n{\n    return bool(texelFetch(iChannel0, ivec2(code, 0), 0).r);\n}\n\nvoid orthogonalize(inout Camera camera)\n{\n    for (uint i = 0u; i < 4u; i++)\n    {\n        for (uint j = 0u; j < i; j++)\n        {\n            camera.body_axes[i] -= dot(camera.body_axes[i],\n                                       camera.body_axes[j])\n                                   * camera.body_axes[j];\n        }\n        camera.body_axes[i] = normalize(camera.body_axes[i]);\n    }\n}\n\nvoid move_camera_on_sphere(inout Camera camera, in vec4 dir, in float dist)\n{\n    camera.body_axes = rotation_matrix(camera.body_axes[3], dir, dist)\n                       * camera.body_axes;\n}\n\nvoid move_camera_on_cylinder(inout Camera camera, in vec4 dir, in float dist)\n{\n    vec4 dir_tan = vec4(0.0);\n    dir_tan.xyz = normalize(dir.xyz);\n    float angle = dist * length(dir.xyz);\n    if (angle != 0.0)\n    {\n        // Rotation matrix goes on the left because the rotation vectors\n        // are in global coördinates.\n        mat4 mat = rotation_matrix(camera.body_axes[3], dir_tan, angle);\n        camera.body_axes = mat * camera.body_axes;\n    }\n    camera.w += dist * dir.w;\n}\n\nvoid move_camera(inout Camera camera, in vec3 step_)\n{\n    vec4 r_;\n    vec4 v_;\n    float ray_dist;\n    float left_ray_dist;\n    bool hit;\n    bool hit_left;\n    float sphere_sign;\n    if (step_ == vec3(0.0))\n    {\n        return;\n    }\n    vec4 global_dir = camera.body_axes * vec4(normalize(step_), 0.0);\n    float dist = length(step_);\n    switch (camera.region)\n    {\n        case region_right_sphere:\n        case region_left_sphere:\n            sphere_sign = camera.region == region_right_sphere ? 1.0 : -1.0;\n            cast_ray_on_sphere_at_plane(camera.body_axes[3], global_dir,\n                                        sphere_sign * W,\n                                        0.0, r_, v_, ray_dist, hit);\n            if (hit && dist >= ray_dist)\n            {\n                move_camera_on_sphere(camera, global_dir, ray_dist);\n                camera.region = region_cylinder;\n                camera.w = sphere_sign * cylinder_length / 2.0;\n                move_camera_on_cylinder(camera, global_dir, dist - ray_dist);\n            }\n            else\n            {\n                move_camera_on_sphere(camera, global_dir, dist);\n            }\n            break;\n        case region_cylinder:\n            cast_ray_on_cylinder_at_window(camera.body_axes[3] + camera.w*W,\n                                           global_dir,\n                                           cylinder_length / 2.0, r_, v_,\n                                           ray_dist, hit);\n            cast_ray_on_cylinder_at_window(camera.body_axes[3] + camera.w*W,\n                                           global_dir,\n                                           -cylinder_length / 2.0, r_, v_,\n                                           left_ray_dist, hit_left);\n            if (hit && dist >= ray_dist)\n            {\n                move_camera_on_cylinder(camera, global_dir, ray_dist);\n                camera.region = region_right_sphere;\n                camera.w = 0.0;\n                move_camera_on_sphere(camera, global_dir, dist - ray_dist);\n            }\n            else if (hit_left && dist >= left_ray_dist)\n            {\n                move_camera_on_cylinder(camera, global_dir, left_ray_dist);\n                camera.region = region_left_sphere;\n                camera.w = 0.0;\n                move_camera_on_sphere(camera, global_dir, dist - left_ray_dist);\n            }\n            else\n            {\n                move_camera_on_cylinder(camera, global_dir, dist);\n            }\n            break;\n    }\n    update_camera(camera);\n}\n\nvoid rotate_camera_right(inout Camera camera, in float angle,\n                         inout vec3 velocity)\n{\n    camera.look.x = mod(camera.look.x + angle, tau);\n    update_camera(camera);\n}\n\nvoid rotate_camera_up(inout Camera camera, in float angle,\n                      inout vec3 velocity)\n{\n    camera.look.y = clamp(camera.look.y + angle, -pi/2.0, pi/2.0);\n    update_camera(camera);\n}\n\nvoid set_z_to_floor(inout Camera camera, in vec3 global_z)\n{\n    vec4 dir = camera.body_axes * vec4(-global_z, 0.0);\n    // No need for asin since we should already be very close.\n    // Note that we want z = 0, not floor_z, because the camera sits\n    // at z = 0 when on the floor.\n    float dist = camera.body_axes[3].z;\n    switch (camera.region)\n    {\n        case region_right_sphere:\n        case region_left_sphere:\n        \tmove_camera_on_sphere(camera, dir, dist);\n        \tbreak;\n        case region_cylinder:\n        \tmove_camera_on_cylinder(camera, dir, dist);\n        \tbreak;\n    }\n}\n\nvec4 get_mouse()\n{\n    vec4 offset = vec4(iResolution.xy, iResolution.xy) / 2.0;\n    return 2.0 * (iMouse - offset) / iResolution.x;\n}\n\nvec3 get_walk_accel(in Camera camera, in vec3 velocity, in vec3 global_z)\n{\n    vec3 accel_raw = vec3(0.0);\n    if (key_is_pressed(0x57u)) // W\n    {\n        accel_raw.z -= 1.0;\n    }\n    if (key_is_pressed(0x41u)) // A\n    {\n        accel_raw.x -= 1.0;\n    }\n    if (key_is_pressed(0x53u)) // S\n    {\n        accel_raw.z += 1.0;\n    }\n    if (key_is_pressed(0x44u)) // D\n    {\n        accel_raw.x += 1.0;\n    }\n    // Convert view coördinates to body coördinates\n    vec3 accel_body = mat3(transpose(camera.body_axes)*camera.axes)\n                      * accel_raw;\n    accel_body -= dot(accel_body, global_z) * global_z;\n    if (accel_body != vec3(0.0))\n    {\n        vec3 accel_norm = normalize(accel_body);\n    \treturn accel_norm * (walk_speed - dot(accel_norm, velocity))\n               / walk_accel_time;\n    }\n    return vec3(0.0);\n}\n\nvec3 get_accel(in Camera camera, in bool on_floor, in vec3 velocity,\n               in vec3 global_z, in vec3 global_z_unnorm)\n{\n    vec3 accel = vec3(0.0);\n    if (on_floor)\n    {\n    \taccel += get_walk_accel(camera, velocity, global_z);\n    }\n    accel -= gravity * global_z_unnorm;\n    if (key_is_pressed(0x20u)) // space\n    {\n        accel.y += thrust;\n    }\n    return accel;\n}\n\nvoid do_right_body(inout Camera camera, inout vec3 velocity,\n                   in vec3 global_z_body)\n{\n    vec4 global_z = camera.body_axes * vec4(global_z_body, 0.0);\n    float angle = abs(global_z_body.y) > 0.7 ? acos(global_z_body.y)\n                  : asin(length(global_z_body.xz));\n    if (angle > 0.001)\n    {\n    \tangle = min(0.9*angle, 0.1);\n        vec4 axis1 = global_z;\n        vec4 axis0 = camera.body_axes[1]\n                     - axis1 * dot(camera.body_axes[1], axis1);\n        if (dot(axis0, axis0) < 0.000001)\n        {\n            axis0 = camera.body_axes[2]\n                    - axis1 * dot(camera.body_axes[2], axis1);\n        }\n        axis0 = normalize(axis0);\n        mat4 rot = rotation_matrix(axis0, axis1, angle);\n        camera.body_axes = rot * camera.body_axes;\n        velocity = mat3(transpose(camera.body_axes)\n                        * transpose(rot)\n                        * camera.body_axes)\n                   * velocity;\n        update_camera(camera);\n    }\n}\n\nvoid rotate_body_by_tilt_control(inout Camera camera, inout vec3 velocity)\n{\n    mat4 rot = mat4(1.0);\n    float step_ = tilt_rate * iTimeDelta;\n    if (key_is_pressed(0x57u)) // W\n    {\n        rot = rotation_matrix(camera.axes[2], camera.axes[1], step_);\n    }\n    if (key_is_pressed(0x41u)) // A\n    {\n        rot *= rotation_matrix(camera.axes[0], camera.axes[1], step_);\n    }\n    if (key_is_pressed(0x53u)) // S\n    {\n        rot *= rotation_matrix(camera.axes[1], camera.axes[2], step_);\n    }\n    if (key_is_pressed(0x44u)) // D\n    {\n        rot *= rotation_matrix(camera.axes[1], camera.axes[0], step_);\n    }\n    camera.body_axes = rot * camera.body_axes;\n    velocity = mat3(transpose(camera.body_axes)\n                        * transpose(rot)\n                        * camera.body_axes)\n                   * velocity;\n    update_camera(camera);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (any(greaterThanEqual(ivec2(fragCoord), size_of_addrs)))\n    {\n        discard;\n    }\n    fragColor = vec4(0.0);\n    vec4 old_mouse = get_mouse();\n    Camera camera;\n    vec3 velocity = vec3(0.0);\n    bool on_floor = true;\n    if (iFrame == 0)\n    {\n        camera = new_camera(Y, X, vec2(0.0, 0.0), region_right_sphere,\n                            W, 0.0);\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        old_mouse = load(iChannel1, addr_mouse);\n        camera = load_camera(iChannel1);\n        velocity = load(iChannel1, addr_velocity).xyz;\n        on_floor = bool(load(iChannel1, addr_on_floor));\n    }\n    vec3 global_z_unnorm = (Z*camera.body_axes).xyz;\n    vec3 global_z = normalize(global_z_unnorm);\n    velocity += iTimeDelta\n                * get_accel(camera, on_floor, velocity, global_z,\n                            global_z_unnorm);\n    on_floor = on_floor && dot(velocity, global_z) <= 0.0;\n    if (on_floor)\n    {\n        do_right_body(camera, velocity, global_z);\n        global_z = normalize((Z*camera.body_axes).xyz);\n        velocity -= dot(velocity, global_z) * global_z\n            \t\t+ velocity * iTimeDelta / walk_accel_time;\n    }\n    else\n    {\n        rotate_body_by_tilt_control(camera, velocity);\n        global_z = normalize((Z*camera.body_axes).xyz);\n    }\n    vec3 step_ = velocity * iTimeDelta;\n    if (!on_floor && dot(velocity, global_z) < 0.0)\n    {\n        vec4 new_r;\n        vec4 new_v;\n        float dist;\n        bool hit;\n        if (camera.region == region_cylinder)\n        {\n            cast_ray_on_cylinder_at_floor(camera.body_axes[3] + camera.w*W,\n                                          normalize(camera.body_axes\n                                                    * vec4(step_, 0.0)),\n                                          0.0, new_r, new_v, dist, hit);\n        }\n        else if (camera.region == region_right_sphere\n                 || camera.region == region_left_sphere)\n        {\n            cast_ray_on_sphere_at_plane(\n                camera.body_axes[3],\n                normalize(camera.body_axes*vec4(step_, 0.0)),\n                Z, 0.0, new_r, new_v, dist, hit\n            );\n        }\n        if (hit && dist < length(step_))\n        {\n            step_ *= dist / length(step_);\n            velocity -= dot(velocity, global_z) * global_z;\n            on_floor = true;\n        }\n    }\n    move_camera(camera, step_);\n    if (on_floor)\n    {\n    \tset_z_to_floor(camera, global_z);\n    }\n    vec4 mouse = get_mouse();\n    if (old_mouse.z >= -1.0)\n    {\n        vec2 mouse_step = (mouse.xy - old_mouse.xy) * mouse_sensitivity;\n        if (mouse_step != vec2(0.0))\n        {\n            rotate_camera_right(camera, mouse_step.x, velocity);\n            rotate_camera_up(camera, mouse_step.y, velocity);\n        }\n    }\n    orthogonalize(camera);\n    store(fragColor, fragCoord, mouse, addr_mouse);\n    store_mat4(fragColor, fragCoord, camera.body_axes, addr_camera_axes);\n    store(fragColor, fragCoord, camera.w, addr_camera_w);\n    store(fragColor, fragCoord, vec4(camera.look, 0.0, 0.0),\n          addr_camera_look);\n    store(fragColor, fragCoord, float(camera.region), addr_camera_region);\n    store(fragColor, fragCoord, vec4(velocity, 0.0), addr_velocity);\n    store(fragColor, fragCoord, float(on_floor), addr_on_floor);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Global coördinates: w is axis of cylinder, z is up (⟂ to floor),\n// Camera coördinates: w is ⟂ to surface, -z is the pointing direction,\n//   x is right, y is up.\n\nconst float tau = radians(360.0);\nconst float pi = radians(180.0);\nconst vec4 X = vec4(1.0, 0.0, 0.0, 0.0);\nconst vec4 Y = vec4(0.0, 1.0, 0.0, 0.0);\nconst vec4 Z = vec4(0.0, 0.0, 1.0, 0.0);\nconst vec4 W = vec4(0.0, 0.0, 0.0, 1.0);\nconst float field_of_view = radians(90.0);\nconst float cylinder_length = tau; // times the radius of the cylinder\nconst float floor_level = -0.15; // times the radius of the spheres/cylinder\nconst float floor_z = sin(floor_level);\n\nconst float tan_fov = tan(field_of_view/2.0);\n\nconst ivec2 addr_camera_axes = ivec2(0, 0);\nconst ivec2 addr_mouse = ivec2(4, 0);\nconst ivec3 addr_camera_region = ivec3(5, 0, 0);\nconst ivec3 addr_on_floor = ivec3(5, 0, 1);\nconst ivec3 addr_camera_w = ivec3(5, 0, 3);\nconst ivec2 addr_camera_look = ivec2(6, 0);\nconst ivec2 addr_velocity = ivec2(7, 0);\nconst ivec2 size_of_addrs = ivec2(8, 1);\n\nconst uint region_left_sphere = 0u;\nconst uint region_right_sphere = 1u;\nconst uint region_cylinder = 2u;\n\nstruct Camera\n{\n    mat4 axes; // axes of camera coördinate system, in columns\n    // body_axes[0]: reference vector for camera rotation, initially\n    //     equal to axes[0], but gets parallel transported around\n    // body_axes[1]: direction of jet thrust and camera rotation\n    // body_axes[2]: arbitrary vector orthogonal to the others\n    // body_axes[3]: normal to the capsule surface, equal to axes[3]\n    mat4 body_axes;\n    vec2 look; // Angles giving the look direction relative to ref_axes\n    uint region;\n    float w; // w-coördinate of camera, if it is on the cylinder\n};\n\nvec4 wedge_product(in vec4 a, in vec4 b, in vec4 c)\n{\n    return vec4( determinant(mat3(a.yzw, b.yzw, c.yzw)),\n                -determinant(mat3(a.xzw, b.xzw, c.xzw)),\n                 determinant(mat3(a.xyw, b.xyw, c.xyw)),\n                -determinant(mat3(a.xyz, b.xyz, c.xyz)));\n}\n\nmat4 rotation_matrix(in uint axis0, in uint axis1, in float angle)\n{\n    mat4 result = mat4(1.0);\n    result[axis0][axis0] =  cos(angle);\n    result[axis1][axis0] = -sin(angle);\n    result[axis0][axis1] =  sin(angle);\n    result[axis1][axis1] =  cos(angle);\n    return result;\n}\n\nmat4 rotation_matrix(in vec4 axis0, in vec4 axis1, float angle)\n{\n    return mat4(1.0)\n           + (cos(angle)-1.0) * outerProduct(axis0, axis0)\n           - sin(angle) * outerProduct(axis0, axis1)\n           + sin(angle) * outerProduct(axis1, axis0)\n           + (cos(angle)-1.0) * outerProduct(axis1, axis1);\n}\n\nmat3 rotation_matrix(in vec3 axis0, in vec3 axis1, float angle)\n{\n    return mat3(1.0)\n           + (cos(angle)-1.0) * outerProduct(axis0, axis0)\n           - sin(angle) * outerProduct(axis0, axis1)\n           + sin(angle) * outerProduct(axis1, axis0)\n           + (cos(angle)-1.0) * outerProduct(axis1, axis1);\n}\n\nmat4 camera_view_wrt_body(in vec2 look)\n    // Return the view basis expressed in terms of the body basis.\n{\n    return rotation_matrix(0u, 2u, look.x)\n           * rotation_matrix(1u, 2u, look.y);\n}\n\nvoid update_camera(inout Camera camera)\n{\n    camera.axes = camera.body_axes * camera_view_wrt_body(camera.look);\n}\n    \nCamera new_camera(in vec4 dir, in vec4 right, in vec2 look, in uint region,\n                  in vec4 pos, in float w)\n{\n    Camera camera;\n    camera.body_axes =\n        mat4(right, -wedge_product(-dir, pos, right), -dir, pos);\n    camera.axes = camera.body_axes;\n    camera.look = look;\n    camera.region = region;\n    camera.w = w;\n\tupdate_camera(camera);\n    return camera;\n}\n\nvec4 load(in sampler2D iChannel1, in ivec2 addr)\n{\n    return texelFetch(iChannel1, addr, 0);\n}\n\nfloat load(in sampler2D iChannel1, in ivec3 addr)\n{\n    return texelFetch(iChannel1, addr.xy, 0)[addr.z];\n}\n\nmat4 load_mat4(in sampler2D iChannel1, in ivec2 addr)\n{\n    return mat4(texelFetch(iChannel1, addr, 0),\n                texelFetch(iChannel1, addr + ivec2(1, 0), 0),\n                texelFetch(iChannel1, addr + ivec2(2, 0), 0),\n                texelFetch(iChannel1, addr + ivec2(3, 0), 0));\n}\n\nCamera load_camera(in sampler2D iChannel1)\n{\n    Camera camera;\n    camera.body_axes = load_mat4(iChannel1, addr_camera_axes);\n    camera.look = load(iChannel1, addr_camera_look).xy;\n    camera.w = load(iChannel1, addr_camera_w);\n    camera.region = uint(load(iChannel1, addr_camera_region));\n    update_camera(camera);\n    return camera;\n}\n\nvoid cast_ray_on_sphere_at_plane(\n    in vec4 r, // origin of ray (normalized)\n    in vec4 v, // direction of ray (normalized, ⟂ to r)\n    in vec4 n, // normal to the (3D) plane\n    in float d, // offset of plane from center of sphere\n    out vec4 r_, // hit point\n    out vec4 v_, // direction of ray at hit point\n    out float th, // distance travelled\n    out bool hit) // whether it hit anything\n{\n    r_ = vec4(0.0);\n    th = 0.0;\n    hit = false;\n    float cos_angle_diff = d / length(vec2(dot(r, n), dot(v, n)));\n    if (abs(cos_angle_diff) <= 1.0 && dot(r, n) >= d)\n    {\n        hit = true;\n        th = atan(dot(v, n), dot(r, n)) + acos(cos_angle_diff);\n        r_ = r * cos(th) + v * sin(th);\n        v_ = v * cos(th) - r * sin(th);\n    }\n}\n\nvoid cast_ray_on_cylinder_at_window(\n    in vec4 r, // origin of ray (r.xyz normalized)\n    in vec4 v, // direction of ray (normalized)\n    in float win_w, // w coördinate of the window\n    out vec4 r_, // hit point\n    out vec4 v_, // direction of ray at hit point\n    out float dist, // distance travelled\n    out bool hit) // whether it hit anything\n{\n    r_ = vec4(0.0);\n    dist = 0.0;\n    hit = false;\n    if (sign(v.w) == sign(win_w) && r.w * sign(v.w) <= abs(win_w))\n    {\n        hit = true;\n        float w_dist = abs(win_w - r.w);\n        float th_dist = w_dist * length(v.xyz) / abs(v.w);\n        dist = length(vec2(w_dist, th_dist));\n        vec3 v_3D = normalize(v.xyz);\n        r_.w = win_w;\n        r_.xyz = r.xyz * cos(th_dist) + v_3D * sin(th_dist);\n        v_.w = v.w;\n        v_.xyz = (v_3D * cos(th_dist) - r.xyz * sin(th_dist)) * length(v.xyz);\n    }\n}\n\nvoid cast_ray_on_cylinder_at_floor(\n    in vec4 r, // origin of ray (r.xyz normalized)\n    in vec4 v, // direction of ray (normalized)\n    in float plane_z, // z-coördinate of the target plane which is\n                      // parallel to the floor\n    out vec4 r_, // hit point\n    out vec4 v_, // direction of ray at hit point\n    out float dist, // distance travelled\n    out bool hit) // whether it hit anything\n{\n    r_ = vec4(0.0);\n    dist = 0.0;\n    hit = false;\n    vec3 v_3D = normalize(v.xyz);\n    float cos_angle_diff = plane_z / length(vec2(r.z, v_3D.z));\n    if (abs(cos_angle_diff) <= 1.0)\n    {\n        hit = true;\n        float th = atan(v_3D.z, r.z) + acos(cos_angle_diff);\n        r_.xyz = r.xyz * cos(th) + v_3D * sin(th);\n        r_.w = r.w + th * v.w / length(v.xyz);\n        v_.xyz = (v_3D * cos(th) - r.xyz * sin(th)) * length(v.xyz);\n        v_.w = v.w;\n        dist = length(vec2(th, r_.w - r.w));\n    }\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4456, 4456, 4480, 4480, 5071], [6269, 6269, 6336, 6336, 6562], [6564, 6564, 6672, 6709, 7222], [7224, 7224, 7260, 7317, 9865], [9867, 9867, 9974, 9974, 10786], [10788, 10788, 10899, 10899, 12008], [12010, 12010, 12048, 12048, 12740], [12742, 12742, 12789, 12789, 13523], [13525, 13525, 13580, 13580, 15318]], "test": "untested"}
{"id": "wdSBDG", "name": "RWoS Distortion", "author": "blackle", "description": "In the \"monte carlo geometry processing\" paper they describe a way to distort 2d shapes using bezier control points. this is an attempt to do something like that with the RWoS integrator. changes every 15*60 frames.", "tags": ["bep"], "likes": 7, "viewed": 621, "published": 3, "date": "1590699158", "time_retrieved": "2024-07-30T21:04:21.086172", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 BuffA = texture(iChannel0, uv);\n    vec2 distorted = BuffA.xy/BuffA.z;\n    fragColor = texture(iChannel1, distorted);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//buf A calculates the distortion map given boundary conditions (see \"scene\")\n//based on the bezier distortion described here: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec2 rand_unit(float seed) {\n    float h1 = hash(seed, 4375893.44353);\n    float h2 = hash(seed, h1);\n    return normalize(tan(vec2(h1,h2))); //see https://www.shadertoy.com/view/3djyWW for an explination of this trick\n}\n\nfloat box(vec2 p, vec2 d) {\n    vec2 q = abs(p)-d;\n    return abs(length(max(q,0.)) + min(0.,max(q.x,q.y)));\n}\n\nmat2 rot(float a) {\n    float c = cos(a); float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nint distorter_id;\nvec3 scene(vec2 p) {\n    float border = box(p - vec2(.5), vec2(.5));\n    if (distorter_id % 4 == 0) {\n        //rotated circle\n        float distorter = abs(length(p-.5)-.3);\n    \tif (distorter < border) {\n        \treturn vec3(distorter, (p-.5)*0.5*rot(.9)+.5);\n    \t}\n    }\n    if (distorter_id % 4 == 1) {\n        //shifted square\n        float distorter = box(p - vec2(.5), vec2(.18));\n    \tif (distorter < border) {\n        \treturn vec3(distorter, p+.2);\n    \t}\n    }\n    if (distorter_id % 4 == 2) {\n        //differently spaced dots with different boundary conditions at each\n        float distorter1 = length(asin(sin(p*20.))/20.);\n        float distorter2 = length(asin(sin(rot(.2)*p*25.))/25.);\n    \tif (min(distorter1, distorter2) < border) {\n            if (distorter1 < distorter2) {\n        \t\treturn vec3(distorter1, (p-.5)*rot(1.1)+.5);\n            }\n        \treturn vec3(distorter2, (p-.5)*rot(-1.1)+.5);\n    \t}\n    }\n    if (distorter_id % 4 == 3) {\n        //noop, just the regular boundary conditions that will converge to undistorted UVs. fun to watch converge\n    }\n    return vec3(border, p);\n}\n\n//random walk on spheres. see: https://www.shadertoy.com/view/WsXBzl\nvec3 rWoS(vec2 p, float seed) {\n    float res = iChannelResolution[0].x;\n    \n    for (int i = 0; i < 25; i++) {\n        seed = hash(seed, seed);\n        vec2 dir = rand_unit(seed);\n        vec3 dist = scene(p);\n        if (dist.x < 1./res) return vec3(dist.yz, 1.);\n        p += dir*dist.x;\n    }\n    //return nothing if we didn't reach the boundary\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //iq's 1 sample blur https://www.shadertoy.com/view/MsdGD2\n    float sgn = iFrame % 2 == 0 ? -.5 : .5;\n    fragColor = texture(iChannel0, (fragCoord+sgn)/iChannelResolution[0].xy);\n    distorter_id = iFrame / (15*60);\n    if (iFrame % (15*60) == 0) {\n        fragColor = vec4(0);\n\t}\n    vec2 uv = fragCoord/iResolution.xy;\n    //our seed is only time-based to reduce the noise level of the final image,\n    //though it results in some funny elastic distortion as it converges\n    float seed = hash(hash(uv.x,uv.y), float(iFrame));\n    for (int i = 0; i < 10; i++) {\n        seed = hash(seed, 3423.);\n        fragColor.xyz += rWoS(uv, seed);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSBDG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 251, 251, 421]], "test": "untested"}
{"id": "wsBBDG", "name": "Circle_Inversion + smoothclamp 2", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/tdjfRd[/url]", "tags": ["geometry", "onetweet", "golf"], "likes": 3, "viewed": 341, "published": 3, "date": "1590697272", "time_retrieved": "2024-07-30T21:04:21.956844", "image_code": "// variant of https://shadertoy.com/view/tdjfRd\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,  U = (u+u - R) / R.y;\n    O = texture( iChannel0, .5+ U / ( 1.+3.*smoothstep(.25,1.,dot(U,U)) ) );\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 215]], "test": "untested"}
{"id": "XsBGWw", "name": "barrel distortion test", "author": "Impossible", "description": "testing ovr barrel distortion", "tags": ["oculus"], "likes": 0, "viewed": 442, "published": 3, "date": "1590696557", "time_retrieved": "2024-07-30T21:04:22.804577", "image_code": "vec4 HmdWarpParam = vec4( 1, 0.22, 0.24, 0 );\nvec2 Scale = vec2(0.1469278, 0.2350845);\nvec2 ScaleIn = vec2(4, 2.5);\n\nvec2 HmdWarp(vec2 texIn, vec2 LensCenter)\n{\n   vec2 theta = (texIn - LensCenter) * ScaleIn;\n   float rSq = theta.x * theta.x + theta.y * theta.y;\n   vec2 theta1 = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\n   return LensCenter + Scale * theta1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvo = fragCoord.xy / iResolution.xy;\n\tvec2 uv;\n\tvec2 ScreenCenter = vec2( 0.25, 0.5 );\n\tvec2 LensCenter = vec2( 0.2863248, 0.5 );\t\n\t\n\tuv = HmdWarp(uvo,LensCenter); //gl_TexCoord[0].xy);\n   if (any(notEqual(clamp(uv, ScreenCenter-vec2(0.25,0.5), ScreenCenter+vec2(0.25, 0.5)) - uv, vec2(0.0, 0.0))))\n   {\n\t   ScreenCenter = vec2( 0.75, 0.5 );\n\t   LensCenter = vec2( 0.7136753, 0.5 );\n\t   \n\t   uv = HmdWarp(uvo,LensCenter);\n\t   \n\t    if (any(notEqual(clamp(uv, ScreenCenter-vec2(0.25,0.5), ScreenCenter+vec2(0.25, 0.5)) - uv, vec2(0.0, 0.0))))\n\t\t   fragColor = vec4(0.0, 0.0, 0.0, 1.0);\t\t\t\n\t\telse\n\t\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n   }\n   else\t\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 160, 160, 433], [435, 435, 492, 492, 1203]], "test": "untested"}
{"id": "wdBfWG", "name": "more time in meat-space", "author": "mds2", "description": "It's a music visualizer that's made of meat!\n\nStarted as a modification of https://www.shadertoy.com/view/3sBGzm\n\nResponds to mouse interaction", "tags": ["raycast", "music", "subsurface", "flesh"], "likes": 2, "viewed": 438, "published": 3, "date": "1590694726", "time_retrieved": "2024-07-30T21:04:23.624385", "image_code": "#define MAX_DIST 4.0\n\n#define LINEAR_STRIATIONS 0 // looks better with 0, faster with 1\n\n#define SUBSAMPLE 0 // set to 1 for subsampling\n\nconst float inv_subsurface_thick = 75.0; // make it bigger to make a smaller subsurface\n\nconst float tor_rad = 0.5;\nvec2 box_size = vec2(0.075, 0.065);\n\n\nconst float round_size = 0.1;\n\nconst vec3 refl_color = vec3(1.0); // vec3(1.0, 0.6, 0.3); // \nconst vec3 diff_color = vec3(0.8, 0.7, 0.6); // vec3(0.2, 1.0, 0.8); // vec3(0.8, 0.2, 0.2); // \nconst vec3 subsurf_color = vec3(1.0, 0.5, 0.4); // vec3(0.8, 0.6, 0.4);\nconst float specular_intense = 0.5;\n\nvec3 light_dir = vec3(0.8, 0.6, 0.0);\nvec3 cut_dir_1 = vec3(0.0, 0.0, 1.0);\nvec3 cut_dir_2 = vec3(0.0, 0.0, 1.0);\n\nmat3 twist;\n\nfloat dist_to_mouse = 0.0;\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nvec2 sdf_ring(in vec3 pt) {\n    vec2 tor_coord = abs(vec2(length(pt.xz) - tor_rad, pt.y));\n    tor_coord = max(vec2(0.0), tor_coord - box_size);\n#if !LINEAR_STRIATIONS\n    float theta = mod(abs(0.125 * atan(pt.x, pt.z) / 3.141592654), 1.0);\n#else    \n    float theta = 0.5 + 0.125 * pt.x / tor_rad;\n#endif\n    \n    const float music_texture_y = 0.0;\n#if 1\n    const float blur_step = 0.25 / 1024.0;\n    float blur_sound = 0.25 * (texture(iChannel0, vec2(theta - 2.0 * blur_step, music_texture_y)).r +\n                               texture(iChannel0, vec2(theta - blur_step, music_texture_y)).r +\n                               texture(iChannel0, vec2(theta + blur_step, music_texture_y)).r +\n                               texture(iChannel0, vec2(theta + 2.0 * blur_step, music_texture_y)).r);\n    float sound = blur_sound - 0.5;\n#else \n    float sound = texture(iChannel0, vec2(theta, music_texture_y)).r - 0.5;\n#endif\n    return vec2(length(tor_coord) - round_size - 1.25 * round_size * sound, 1.0 + 2.0 * sound);\n}\n\nfloat sdf(in vec3 pt) {\n    float bumps = 0.0;\n    float bump_size = 0.001;\n    vec2 sdf_and_bumpscale = sdf_ring(pt);\n    float s = sdf_and_bumpscale.x;\n    bump_size *= sdf_and_bumpscale.y;\n    s += 75.0 * bump_size * smoothstep(0.25 * iResolution.y, 0.05 * iResolution.y, dist_to_mouse);\n    if (s < 5.0 * bump_size) {\n        bumps = bump_size * dot(sin(80.0 * pt), vec3(1.0));\n    }\n    return s + bumps;\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    float f = sdf(pt);\n    return h_inv * vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nvec3 norm_perturb(in vec3 pt) {\n    const float rad_2_unit = 1.0 / (2.0 * 3.141592654);\n    float ang1 = atan(pt.x, pt.z) * rad_2_unit;\n    vec2 about = vec2(length(pt.xz) - tor_rad, pt.y);\n    float ang2 = atan(about.y, about.x) * rad_2_unit;\n    const float scale = 3.0;\n    vec3 bmp = normalize(noise3(55.0 * pt, 12.7));\n    return 0.2 * bmp;\n}\n\nvec3 zero_norm_perturb(in vec3 pt) {\n    return vec3(0.0);\n}\n\nvec3 grid_norm_perturb(in vec3 pt) {\n    vec2 uv1 = mod(3.0 * pt.xy, vec2(1.0));\n    vec2 uv2 = mod(3.0 * pt.yz, vec2(1.0));\n    vec2 uv3 = mod(3.0 * pt.zx, vec2(1.0));\n    return texture(iChannel2, uv1).rgb - vec3(0.5) +\n        texture(iChannel2, uv2).rgb - vec3(0.5) +\n        texture(iChannel2, uv3).rgb - vec3(0.5);\n}\n\nfloat ray_cast(in vec3 o, in vec3 dir) {\n    float accum = 0.0;\n    float val = sdf(o);\n    vec3 pt = o;\n    for (int i = 0; i < 512; ++i) {\n        accum += 0.5 * val;\n        pt = o + accum * dir;\n        val = sdf(pt);\n        if (accum > MAX_DIST || val < 1.0e-3) {\n            return accum;\n        }\n    }\n    return MAX_DIST + 1.0;\n}\n\nfloat cast_out(in vec3 o, in vec3 dir) {\n    float accum = 0.0;\n    float val = sdf(o);\n    vec3 pt = o;\n    for (int i = 0; i < 128; ++i) {\n        accum += max(0.95 * abs(val), 5.0e-4);\n        pt = o + accum * dir;\n        val = sdf(pt);\n        if (accum > 1.0e-3 && val > -1.0e-3) {\n            return accum;\n        }\n    }\n    return MAX_DIST + 1.0;\n}\n\nvec4 color_at(in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    dist_to_mouse = length(fragCoord.xy - iMouse.xy);\n    \n    vec3 dir = normalize(vec3(uv, -2.0));\n    vec3 orig = vec3(0.0, 0.0, 1.0);\n    \n    float theta = 0.3;\n    vec2 angles = cos(theta + vec2(0.0, 0.5 * 3.141592654));\n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                     0.0, angles.x, angles.y,\n                     0.0, -angles.y, angles.x);\n    orig = twist * tilt * orig;\n    dir = twist * tilt * dir;\n\n    float dist = ray_cast(orig, dir);\n    \n    vec3 col = vec3(1.0 / dist);\n\n    if (dist < MAX_DIST) {\n        vec3 pt = orig + dir * dist;\n\t\tvec3 n = normalize(sdf_grad(pt));\n        n = normalize(n + norm_perturb(pt));\n        vec3 bounce = normalize(reflect(dir, n));\n        vec2 weights = smoothstep(0.4, 1.9, noise2(12.0 * pt, 0.0));\n        float refl_bright = 0.2 * smoothstep(0.0, 1.0, dot(bounce, light_dir));\n        float diff_bright = 0.05 +\n            0.75 * smoothstep(0.1, 1.0, dot(n, light_dir)) + 0.25;\n        float dist_out = cast_out(pt + 1.0e-2 * dir, light_dir) +\n            0.1 * dot(light_dir, norm_perturb(pt));\n        col = (weights.x + specular_intense) * refl_bright * refl_color + diff_bright * 0.6 * diff_color;\n        col += 0.5 * weights.y * (1.0 / max(1.0, 1.0 + inv_subsurface_thick * dist_out)) * subsurf_color;\n        \n    } else {\n        col = vec3(0.0);\n    }\n    \n    // Output to screen\n\treturn vec4(col, 1.0);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = 0.5 + 0.01 * mod(iTime, 200.0 * 3.14159265);\n    theta *= 2.0 * 3.141592654;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    twist = mat3(ct, 0.0, st,\n                 0.0, 1.0, 0.0,\n                 -st, 0.0, ct);\n    \n\n    float push_pull = 3.141592654 * 0.75;\n    cut_dir_1.xz = sin(push_pull + vec2(0.5 * 3.141592654, 0.0));\n    push_pull = -push_pull;\n    cut_dir_2.xz = -sin(push_pull + vec2(0.5 * 3.141592654, 0.0));\n#if SUBSAMPLE\n    vec4 col_out = 0.25 * color_at(fragCoord);\n    const float scatter_scale = 0.8;\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.6, 0.8));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(-1.0, 0.0));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.0, -1.0));\n#else\n    vec4 col_out = color_at(fragCoord);\n#endif\n    fragColor = col_out;\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// All hash functions copied from https://www.shadertoy.com/view/Xt3cDn\n// Thanks, nimitz!\n\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n//Faster than \"full\" xxHash and good quality\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\n//--------------------------------------------------\n\nfloat hash13(vec3 x)\n{\n    uint n = baseHash(floatBitsToUint(x.xy)) ^\n        baseHash(floatBitsToUint(x.yz)) ^\n        baseHash(floatBitsToUint(x.zx));\n    \n    return float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\n\nfloat noise_term(in vec3 x, in float scale_val) {\n    vec3 s = vec3(scale_val);\n    vec3 x000 = x - mod(x, s);\n    vec3 x001 = x + vec3(0.0, 0.0, scale_val);\n    x001 = x001 - mod(x001, s);\n    vec3 x010 = x + vec3(0.0, scale_val, 0.0);\n    x010 = x010 - mod(x010, s);\n    vec3 x011 = x + vec3(0.0, s.xy);\n    x011 = x011 - mod(x011, s);\n    vec3 x100 = x + vec3(scale_val, 0.0, 0.0);\n    x100 = x100 - mod(x100, s);\n    vec3 x101 = x + vec3(scale_val, 0.0, scale_val);\n    x101 = x101 - mod(x101, s);\n    vec3 x110 = x + vec3(s.xy, 0.0);\n    x110 = x110 - mod(x110, s);\n    vec3 x111 = x + s;\n    x111 = x111 - mod(x111, s);\n    \n    float v000 = hash13(x000);\n    float v001 = hash13(x001);\n    float v010 = hash13(x010);\n    float v011 = hash13(x011);\n    float v100 = hash13(x100);\n    float v101 = hash13(x101);\n    float v110 = hash13(x110);\n    float v111 = hash13(x111);\n    \n    vec3 uvw = mod(x, s) / s;\n    \n    float zweight = smoothstep(0.0, 1.0, uvw.z);\n    float v00 = mix(v000, v001, zweight);\n    float v01 = mix(v010, v011, zweight);\n    float v10 = mix(v100, v101, zweight);\n    float v11 = mix(v110, v111, zweight);\n    \n    float yweight = smoothstep(0.0, 1.0, uvw.y);\n    float v1 = mix(v10, v11, yweight);\n    float v0 = mix(v00, v01, yweight);\n    \n    float xweight = smoothstep(0.0, 1.0, uvw.x);\n    \n    return mix(v0, v1, xweight);\n}\n\nfloat noise(in vec3 x, in float base_scale, in float space_decay, in float height_decay,\n           in float shift_by) {\n\tfloat h = 1.0;\n    float s = base_scale;\n\n    float summation = 0.0;\n    \n    for (int i = 0; i < 5; ++i) {\n    \tsummation = summation + h * noise_term(x + vec3(0.0, 0.0, s * shift_by), s);\n        s *= space_decay;\n        h *= height_decay;\n    }\n    return summation;\n}\n\nfloat simple_noise(in vec3 uv, in float shift_by) {\n  return noise(uv * 10.0, 5.0, 0.75, 0.75, shift_by);\n}\n\nvec2 noise2(in vec3 uv, in float shift_by) {\n    return vec2(simple_noise(uv, shift_by),\n                simple_noise(uv + vec3(0.0, 0.0, 101.0), shift_by));\n}\n\nvec3 noise3(in vec3 uv, in float shift_by) {\n    return vec3(simple_noise(uv, shift_by),\n                simple_noise(uv + vec3(0.0, 0.0, 101.0), shift_by),\n               simple_noise(uv + vec3(0.0, 101.0, 0.0), shift_by));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[748, 748, 797, 797, 922], [924, 924, 973, 973, 1097], [1100, 1100, 1127, 1127, 2118], [2120, 2120, 2143, 2143, 2531], [2533, 2533, 2560, 2560, 2816], [2818, 2818, 2849, 2849, 3165], [3167, 3167, 3203, 3203, 3227], [3229, 3229, 3265, 3265, 3551], [3553, 3553, 3593, 3593, 3893], [3895, 3895, 3935, 3935, 4253], [4255, 4255, 4289, 4339, 5789], [5795, 5795, 5852, 5852, 6717]], "test": "untested"}
{"id": "3s2BzV", "name": "Path Racers", "author": "friol", "description": "Who's gonna win?", "tags": ["tunnel", "light", "shadows", "pathtracing"], "likes": 73, "viewed": 2733, "published": 3, "date": "1590693513", "time_retrieved": "2024-07-30T21:04:24.731425", "image_code": "\n//\n// friol 2o2o\n// choose your noise function wisely\n// dof/bokeh blur readapted from halcy\n// 29.05.2020: cleaned up a bit and darkened the walls&reflective sphere\n//\n\nvec3 dof(sampler2D tex, vec2 uv) \n{\n    vec3 col = vec3(0.0);\n    float asum = 0.0;\n    float coc = texture(tex,uv).a;\n    for(float t=0.0;t<2.0*3.141592;t+=3.141592/16.0) \n    {\n    \tfloat r = cos(3.14 / 6.0) / cos(mod(t, 2.0 * 3.14 / 6.0) - 3.14 / 6.0);\n        \n        vec2 offset = vec2(sin(t), cos(t)) * r * t * vec2(1.0) / iResolution.xy * coc;\n        vec4 samp = texture(tex, uv + offset * 1.0);\n        \n        offset = vec2(sin(t), cos(t)) * r * t * vec2(1.0) / iResolution.xy * samp.a;\n        samp = texture(tex,uv+offset);\n        \n        col += samp.rgb * samp.a * t;\n        asum+=samp.a*t;\n    }\n    col = col / asum;\n    return(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(dof(iChannel0, uv), 0.0);\n    if (iTime<8.0) fragColor=mix(fragColor,vec4(0.0),(8.0-iTime)/8.0);\n\t//fragColor = vec4(texture(iChannel0, uv));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float globalTempo=130.0; // global, song tempo dancing\n\n\nvec2 oldRand(inout vec2 seed,float time) \n{\n    seed+=vec2(-0.001,0.001);\n    return vec2(fract(cos(dot(seed.xy ,vec2(123.4+sin(time),234.5))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 133421.631));\n}\n\nvec2 rand2n(vec2 co,float time){\n    return vec2(\n        fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453),\n        fract(cos(dot(co.xy ,vec2(32.9898,78.233))) * 13758.5453)\n    );\n}\n\nfloat hash21(vec2 p) {\n  return fract(sin(dot(p, vec2(425.215, 714.388)))*45758.5453);\n}\n", "buffer_a_code": "\nconst int samplesPerPixel=32; // in 2025, you'll be able to raise this to 256\nconst int maxRayReflections=3;\n\n#define INFINITY 999999.0\n\nstruct rtIntersection \n{\n    float dist;\n\tvec3 position;\n    vec3 normal;\n    int material;\n};\n    \nbool intersectSphere( float radius, vec3 center, vec3 ro,vec3 rd, out rtIntersection hit ) \n{\n\tvec3 oc = center - ro;\n    float l = dot(rd, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(radius, 2.0);\n    if (det < 0.0) return false;\n\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return false;\n\n    vec3 pos = ro + len * rd;\n    hit = rtIntersection(len, pos, (pos - center) / radius,-1);\n    return true;\n}\n\n\nbool intersectPlane( vec3 normal,vec3 ro,vec3 rd, out rtIntersection hit ) \n{\n\tfloat len = -dot(ro, normal) / dot(rd, normal);\n    if (len < 0.0) return false;\n    hit = rtIntersection(len, ro + len * rd, normal, -1);\n    return true;\n}\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n    \nbool intersect_aabb(vec3 ro,vec3 rd, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / rd;\n\tvec3 t_1 = (aabb.min_ - ro) * div;\n\tvec3 t_2 = (aabb.max_ - ro) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3 ray_at(vec3 ro,vec3 rd, float t)\n{\n\treturn ro + t * rd;\n}\n\nfloat intersect_box(vec3 ro,vec3 rd, out vec3 normal, vec3 size)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ro,rd, AABB(-size, size), t_min, t_max)) {\n\t\tvec3 p = ray_at(ro,rd,t_min);\n\t\tp /= size;\n\t\tif(abs(p.x) > abs(p.y)) {\n\t\t\tif(abs(p.x) > abs(p.z)) {\n\t\t\t\tnormal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t\t}\n\t\t}\n\t\telse if(abs(p.y) > abs(p.z)) {\n\t\t\tnormal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\telse {\n\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nrtIntersection rayTraceScene(vec3 ro,vec3 rd)\n{\n    float maxt=10000.0;\n    rtIntersection noResult=rtIntersection(-1.0,vec3(0.0),vec3(0.0),0);\n\n    rtIntersection resultSphere;\n    if (intersectSphere(.3,vec3(0.0,.3,4.5+5.0*sin(iTime/2.0)),ro,rd,resultSphere))\n    {\n        maxt=resultSphere.dist;\n        resultSphere.material=0;\n    }\n\n    rtIntersection resultSphere2;\n    if (intersectSphere(0.23,vec3(.8*sin(iTime),.2,-1.*cos(iTime)),ro,rd,resultSphere2))\n    {\n        maxt=min(maxt,resultSphere2.dist);\n        resultSphere2.material=3;\n    }\n\n    rtIntersection resultSphere3;\n    if (intersectSphere(.2,vec3(cos(iTime),.2,-0.25),ro,rd,resultSphere3))\n    {\n       \tmaxt=min(maxt,resultSphere3.dist);\n        resultSphere3.material=1;\n    }\n    \n    rtIntersection resultPlane;\n    if (intersectPlane(vec3(0.0,1.0,0.0),ro,rd,resultPlane))\n    {\n        maxt=min(maxt,resultPlane.dist);\n        resultPlane.material=2;\n    }\n\n    rtIntersection resultPlane2; // Up\n    if (intersectPlane(vec3(0.0,-1.0,0.0),ro-vec3(0.0,2.0,0.0),rd,resultPlane2))\n    {\n        maxt=min(maxt,resultPlane2.dist);\n        resultPlane2.material=2;\n    }\n\n    rtIntersection resultPlane3;\n    if (intersectPlane(vec3(1.0,0.0,0.0),ro-vec3(-1.2,0.0,0.0),rd,resultPlane3))\n    {\n        maxt=min(maxt,resultPlane3.dist);\n        resultPlane3.material=2;\n    }\n\n    rtIntersection resultPlane4;\n    if (intersectPlane(vec3(-1.0,0.0,0.0),ro-vec3(1.2,0.0,0.0),rd,resultPlane4))\n    {\n        maxt=min(maxt,resultPlane4.dist);\n        resultPlane4.material=2;\n    }\n\n    const int numBoxes=4;\n    rtIntersection resultBoxes[numBoxes];\n    float boxDist[numBoxes];\n    if (iTime>=(60.0/globalTempo)*32.)\n    {\n        for (int b=0;b<numBoxes;b++)\n        {\n            float x=0.2;//float(b)*0.1;\n            float y=1.9;//mod(float(b)*234.0,4.0);\n            vec3 dimensions=vec3(1.5,.1,2.2);\n\n            if (b==2)\n            {\n                x=.5;\n                dimensions=vec3(0.2,2.1,2.2);\n            }\n\n            if (b==0)\n            {\n                x=-0.1;\n                dimensions=vec3(0.2,2.1,2.2);\n            }\n\n            vec3 resNormal;\n            boxDist[b]=intersect_box(ro-vec3(-.7+x*4.0,y,-64.0+mod(32.0*iTime+float(b)*32.0,128.0)),rd,resNormal,\n                                     dimensions);\n            if (boxDist[b]!=INFINITY)\n            {\n                maxt=min(maxt,boxDist[b]);\n                resultBoxes[b].material=b+4;\n                resultBoxes[b].dist=boxDist[b];\n                resultBoxes[b].normal=resNormal;\n            }\n        }\n    }\n    \n    if (maxt==resultSphere.dist) return resultSphere;\n    if (maxt==resultSphere2.dist) return resultSphere2;\n    if (maxt==resultSphere3.dist) return resultSphere3;\n    if (maxt==resultPlane.dist) return resultPlane;\n    if (maxt==resultPlane2.dist) return resultPlane2;\n    if (maxt==resultPlane3.dist) return resultPlane3;\n    if (maxt==resultPlane4.dist) return resultPlane4;\n    \n    if (iTime>=(60.0/globalTempo)*32.)\n    {\n        for (int b=0;b<numBoxes;b++)\n        {\n            if (maxt==boxDist[b]) return resultBoxes[b];\n        }\n    }\n        \n    return noResult;\n}\n\n\n//\n//\n//\n\nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineDistribution(vec3 dir)\n{\n\t//dir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n(dir.xy,iTime);\n\tr.x=r.x*2.*3.141592;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    float fogAmount = 1.0 - exp(-dist * 0.035);\n    return mix(c, fxcol, fogAmount);\n}\n\nvec3 pathTrace(vec3 ro, vec3 rd, in vec2 fragCoord,in vec2 uv,out float firstDistance)\n{\n    vec3 fogColor=vec3(0.008,0.08,0.08);\n    //vec3 lightPos=vec3(1.2,4.0,-2.0);\n\n    vec3 rayOrigin=ro;\n    vec3 rayDir=rd;\n    \n    vec3 accumulatedCol=vec3(0.0);\n    vec3 firstRayHit=vec3(-1.0);\n    \n    for (int ref=0;ref<maxRayReflections;ref++)\n    {\n        rtIntersection rayHit=rayTraceScene(rayOrigin,rayDir);\n        if (rayHit.dist==-1.0)\n        {\n        \tif (ref==0) accumulatedCol=vec3(fogColor);\n            return accumulatedCol;\n        }\n        \n        int mat=rayHit.material;\n        vec3 pHit=rayOrigin+rayDir*rayHit.dist;\n        if (ref==0) firstDistance=rayHit.dist;\n        vec3 N=rayHit.normal;\n        //float dotprod=max(dot(lightPos,N),0.0);\n\n        if (mat==0)\n        {\n            accumulatedCol+=vec3(0.71,0.2,.1712)*9.52;\n        }\n        else if (mat==1)\n        {\n            accumulatedCol+=vec3(0.31,0.52,.962)*2.52;\n        }\n        else if (mat==2) // walls\n        {\n            vec3 pHit2=vec3(pHit.x,pHit.y,pHit.z-iTime*8.0);\n            vec2 tuv = pHit2.yz + vec2(N.x, 0);\n            if (abs(N.y)>0.2) tuv = pHit2.xz + vec2(0, N.y);\n\n            vec3 sampleCol;\n            tuv*=4.;\n\n            if (abs(N.y)>0.2) tuv*=.8;\n            vec2 id = floor(tuv);\n            tuv -= id + .5;\n\n            vec3 pointcol=vec3(hash21(id));\n            sampleCol = pointcol;\n\n            float k=1.0;\n            // sync with snare entry\n            if ((iTime>=(60.0/globalTempo)*64.) && (mod(hash21(id+floor(iTime/(60.0/globalTempo))),8.0)>0.96)) k=128.0;\n            if (ref==0) \n            {\n                accumulatedCol=sampleCol*vec3(.11,.14,.28)*k;\n            }\n            else\n            {\n                if (k==1.0) accumulatedCol*=sampleCol;\n                else accumulatedCol+=sampleCol;\n            }\n            if (ref==0) accumulatedCol=fog(accumulatedCol,distance(rayOrigin,firstRayHit),fogColor);\n            \n            if (mod(hash21(id - .2),8.0)<0.06) mat=3;\n        }\n        else if (mat==3)\n        {\n            accumulatedCol += 0.1;\n        }\n        else if ((mat==4)||(mat==5)||(mat==6)||(mat==7))\n        {\n            if (mat==4) accumulatedCol+=vec3(0.31,0.52,.962)*12.52;\n            if (mat==5) accumulatedCol+=vec3(0.61,0.2,.1712)*2.52;\n            if (mat==6) accumulatedCol+=vec3(0.71,0.12,.1712)*12.52;\n            if (mat==7) accumulatedCol+=vec3(0.271,0.52,.712)*12.52;\n            //accumulatedCol+=vec3(0.92)*3.0;\n        }\n\n        // bounce ray\n        rayOrigin=pHit+N*.004;\n        if (mat==3) { vec3 randRay=normalize(getCosineDistribution(reflect(rayDir,N))); rayDir=mix(normalize(reflect(rayDir,N)),randRay,0.1); }\n        else rayDir=normalize(getCosineDistribution(reflect(rayDir,N)));\n    }    \n\n    /*rtIntersection rayHit=rayTraceScene(rayOrigin,rayDir);\n    if (rayHit.dist==-1.0)\n    {\n        return accumulatedCol;\n    }\n\n    int mat=rayHit.material;\n    vec3 pHit=rayOrigin+rayDir*rayHit.dist;\n    //if (ref==0) firstDistance=rayHit.dist;\n    vec3 N=rayHit.normal;\n    float dotprod=max(dot(lightPos,N),0.0);\n    if (mat==0)\n    {\n        accumulatedCol+=vec3(0.71,0.2,.1712)*dotprod;\n    }\n    else if (mat==2) // walls\n    {\n        accumulatedCol+=vec3(0.11,0.12,.12)*dotprod;\n    }*/\n    \n    //accumulatedCol=fog(accumulatedCol,distance(rayOrigin,firstRayHit),fogColor);\n    return accumulatedCol;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float camadderx=0.0; float camaddery=0.0;\n    if (iMouse.z>0.0)\n    {\n    \tvec2 mousepos=(iMouse.xy-0.5*iResolution.xy)/iResolution.x;\n        camadderx=(mousepos.x)*1.5;\n        camaddery=(-mousepos.y)*2.0;\n    }    \n    \n    camPos=vec3(camadderx+0.5*sin(iTime)*cos(iTime),camaddery+0.8+.2*sin(iTime),-2.);\n    //camPos=vec3(0.0,0.8,-2.);\n    camTarget=vec3(0.0,0.32,0.0);\n    \n    vec3 finalCol=vec3(0.0);\n\n    float fd=0.0;\n    float totalfd=0.0;\n    for (int s=0;s<samplesPerPixel;s++)\n    {\n        vec2 seed = uv.xy * (float(100-s) - 1.0);\n    \tvec3 rayDir = getCameraRayDir(uv-(oldRand(seed,iTime)/256.0), camPos, camTarget); \n    \tfinalCol+=pathTrace(camPos, rayDir,fragCoord,uv,fd);\n        totalfd+=fd;\n    }\n    finalCol/=float(samplesPerPixel);\n    totalfd/=float(samplesPerPixel);\n    \n    finalCol=pow(finalCol,vec3(0.45));\n    \n    float coc=totalfd*0.02;\n    if ((totalfd>2.0)&&(totalfd<=2.5)) coc=totalfd*0.05;\n    if (totalfd>2.5) coc= 0.7 * abs(1.0 - length(camPos - camTarget) / totalfd);\n    \n    // if you like motion blur\n    //fragColor = vec4(mix(texture(iChannel0, fragCoord / iResolution.xy).rgb,finalCol, 0.5),coc);\n    fragColor = vec4(finalCol,coc);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//\n// bytebeat\n//\n\n#define PI 3.141592\n#define TAU PI*2.0\n\n\nfloat notes[12];\n\n\n//\n//\n//\n\nfloat modfix(float phase) {\n    return mod(phase, TAU);\n}\n\nfloat sinf(float t, float freq) {\n\treturn sin(modfix(TAU * t * freq));\n}\n\nfloat kick(float t) \n{\n    return clamp(1.25 * sinf(t, 120. * exp(-t * 5.0)) * exp(-t * 5.), -1.0, 1.0) * smoothstep(0.001, 0.003, t);\n}\n\n//\n// saw\n//\n\nfloat sawpitch(float p) {\n\treturn pow(1.059460646483, p) * 440.0;\n}\n\nfloat saw(float phase) \n{\n    float s = 0.0;\n    for (int k=1; k < 17; k++) {\n        s += (sin(TAU*float(k)*phase) / float(k));\n    }\n    return -(1.0/PI)*s;\n}\n\nvec2 sawSynth(float t,vec3 notes)\n{\n    // good triads: 0,2,7 0,3,7 0,3,2\n    float s = 0.0;\n    float semitones[3];\n    semitones[0] = notes.x;\n    semitones[1] = notes.y;\n    semitones[2] = notes.z;\n    \n    for (int i=0;i<3;i++) \n    {\n        float f = sawpitch(semitones[i]);\n        \n        for (int u=0;u<3;u++) {\n            float fu = float(u);\n            float new_f = f + fu*sin(fu);\n    \t\ts += saw(t * new_f)*0.11111111111111;\n        }\n    }\n    \n    return vec2(\n        s*clamp((1.0+cos(t))/2.0,0.25,0.75),\n        s*clamp((1.0+sin(t))/2.0,0.25,0.75)\n    );\n}\n\n// synthie\n\nfloat pulse( float morph, float pulse, float phase )\n{\n\tfloat a, b;\n    if( pulse < 0.5 )\n        a = morph * pulse * 0.5;\n    else\n        a = morph * ( 1.0 - pulse ) / 2.0;\n    if( phase < pulse )\n    {\n        if( phase < a )\n        {\n            b = phase / a - 1.0;\n            return 1.0 - b * b;\n        }\n        if( phase < pulse - a )\n            return 1.0;\n        b = ( phase - pulse + a ) / a;\n        return 1.0 - b * b;\n    }\n    if( phase < pulse + a )\n    {\n        b = ( phase - pulse ) / a - 1.0;\n        return b * b - 1.0;\n    }\n    if( phase <= 1.0 - a )\n        return -1.0;\n    b = ( phase - 1.0 + a ) / a;\n    return b * b - 1.0;\n}\n\nvec2 synthie(float time,float note1,float note2)\n{\n\tfloat y=time*globalTempo/240.0;\n    float a=16.0;\n    float s=1.0;\n    float b=16.0;\n    float bi=floor(b*y);\n    float w=b*y-bi;\n    float sqe=pow(min(1.0,min(s-s*w,a*w)),2.0)*(3.0-mod(bi,3.0));\n    float x=time*note1;\n    float x2=time*note2;\n    \n    float wave=\n        pulse(0.75, 0.75, fract(x))+pulse(0.9+sin(y*2.0/16.0)*0.1-sqe*0.1, 0.5+0.45*sin(y*16.0), fract(x))+\n        pulse(0.75, 0.75, fract(x2))+pulse(0.9+sin(y*2.0/16.0)*0.1-sqe*0.1, 0.5+0.45*sin(y*16.0), fract(x2));\n        \n    \n    return ((1.0+0.5*sin(time))/2.0)*vec2(\n        (wave*sqe*0.07)*clamp((1.0+sin(time))/2.,0.25,0.75),\n        (wave*sqe*0.07)*clamp((1.0+cos(time))/2.,0.25,0.75)\n    );\n}\n\n// snare\n\nvec2 sine(float time, float freq) {\n    return vec2(sin(time * freq * 3.1415 * 2.));\n}\n\nvec2 noise(float a, float b) {\n    return vec2(2. * (0.5 - fract(sin(dot(vec2(a, b) ,vec2(12.9898,78.213))) * 42758.5453)));\n}\n\nvec2 exp_noise(float time, float b, float q) {\n    return vec2(noise(time, b) * exp(-time * q));\n}\n\nvec2 exp_sine(float time, float freq, float q) {\n    return vec2(sine(time, freq)) * exp(-time * q);\n}\n\nvec2 snare(float time) {\n    return exp_noise(time, 1., 20.) * 0.3 + exp_sine(time, 200. * exp(-time), 50.) * 0.7;\n}\n\nvec2 tom(float time) {\n    return exp_sine(time, 60. * exp(-time), 25.);\n}\n\nvec2 finalSnare(float time,float panning)\n{\n    return 0.9 * vec2(\n        (tom(fract(time)) + snare(fract(time))).x*panning,\n        (tom(fract(time)) + snare(fract(time))).y*(1.0-panning)\n        );\n}\n\n// hi-hat\n\nvec2 hihat(float time,float panning)\n{\n    float tb = mod(time,(60.0/globalTempo)*0.25);\n    float hihat=(fract(cos(time * 32234.523) * 134.) * exp(mod(tb, 1. / 2.0) / 2.0 * -120.)*(fract(tb) + .2));\n    return vec2(hihat*panning,hihat*(1.0-panning))*.55;\n}\n\n#define hihatsss(starttime,endtime,panning) if ((time>=starttime)&&(time<endtime)) finalSound+=hihat(time,panning);\n\n// bazzz\n\nfloat adsr(float t, vec4 env, float s)\n{\n    float a = t/env.x;\n    float d = max(s, 1.0-(t-env.x)*(1.0-s)/env.y);\n    float r = (1.0 - max(0.0,t-(env.x+env.y+env.z))/env.w);\n    return max(0.,min(a, r*d));\n}\n\nfloat sineBazz(float phase, float time, float note) \n{\n    return sin (TAU*note*4.0*phase)*exp(-3.*phase);\n}\n\nvoid initNotes()\n{\n\tnotes[0]=16.055;\n    notes[1]=17.01;\n    notes[2]=18.02;\n    notes[3]=19.09;\n    notes[4]=20.225;\n    notes[5]=21.43;\n    notes[6]=22.705;\n    notes[7]=24.055;\n    notes[8]=25.485;\n    notes[9]=27.00;\n    notes[10]=28.605;\n    notes[11]=30.305;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 finalSound=vec2(0.0);\n    \n    initNotes();\n\n    if (time>=(60.0/globalTempo)*32.)\n    {\n        if ((time>=(60.0/globalTempo)*31.5)&&(time<(60.0/globalTempo)*120.0))\n        {\n            finalSound += kick(mod(time,60.0/globalTempo))*0.5;\n        }\n\n        const int numSteps=16;\n        int notearr[16];\n        notearr[0]=0;notearr[1]=3;notearr[2]=0;notearr[3]=6;\n        notearr[4]=0;notearr[5]=0;notearr[6]=0;notearr[7]=0;\n        notearr[8]=0;notearr[9]=3;notearr[10]=0;notearr[11]=5;\n        notearr[12]=6;notearr[13]=1;notearr[14]=0;notearr[15]=5;\n\n        float note=notes[notearr[int(mod((floor(time/(60.0/globalTempo))),16.0))]];\n        float b = sineBazz(mod (time, (60.0/globalTempo)*0.25), time,note);\n\n        b = adsr(b, vec4(1.1, .1, 1.9, 1.0), 1.0)*(.9+.5*abs(sin(time)));\n        b *= b*b;\n        finalSound+=b*0.15;\n\n        hihatsss((60.0/globalTempo)*32.,(60.0/globalTempo)*36.0,0.30);\n        hihatsss((60.0/globalTempo)*40.,(60.0/globalTempo)*44.0,0.30);\n        hihatsss((60.0/globalTempo)*48.,(60.0/globalTempo)*52.0,0.30);\n        hihatsss((60.0/globalTempo)*56.,(60.0/globalTempo)*60.0,0.30);\n        hihatsss((60.0/globalTempo)*64.0,(60.0/globalTempo)*96.0,0.30);\n        \n\t\tif (time>(60.0/globalTempo)*96.0) finalSound+=sawSynth(mod(time-(60.0/globalTempo)*96.0,32.0*(60.0/globalTempo)),vec3(12.+7.8))*0.02;\n    }\n\n    if (\n        (time>=(60.0/globalTempo)*32.) &&\n        (time<(60.0/globalTempo)*96.0)\n       )\n    {\n        finalSound+=finalSnare(fract(mod((time+0.45),2.0*60.0/globalTempo)),0.65)*0.6;\n        if (time>=(60.0/globalTempo)*64.) finalSound+=finalSnare(fract(mod((time+.55),4.*60.0/globalTempo)),0.35)*0.6;\n    }\n\n    // open all\n    if (time>=(60.0/globalTempo)*126.)\n    {\n        finalSound += kick(mod(time,60.0/globalTempo))*0.5;\n        hihatsss((60.0/globalTempo)*120.0,(60.0/globalTempo)*256.0,0.30);\n        finalSound+=finalSnare(fract(mod((time+0.45),2.0*60.0/globalTempo)),0.65)*0.6;\n\t\tfinalSound+=finalSnare(fract(mod((time+.55),4.*60.0/globalTempo)),0.35)*0.6;\n    }\n    \n    time=mod(time,(60.0/globalTempo)*32.0);\n    if (time<(60.0/globalTempo)*16.0) finalSound+=synthie(time,notes[0]*16.0,notes[3]*18.0)*0.4;\n    else finalSound+=synthie(time,notes[3]*12.0,notes[8]*12.0)*0.4;\n\n    \n    return finalSound*1.2;\n}\n", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2BzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 206, 206, 826], [828, 828, 884, 884, 1088]], "test": "untested"}
{"id": "wsBBWG", "name": "Shorter version of my blackhole", "author": "Leria", "description": "Not very computing/hardware optimised but doing the stuff. It's very simple and the code is not very dark as you can see in other shaders, but it could be shorter maybe. No user interactions.", "tags": ["simple", "ray", "marching", "galaxy", "blackhole", "short"], "likes": 1, "viewed": 395, "published": 3, "date": "1590690266", "time_retrieved": "2024-07-30T21:04:25.469452", "image_code": "//Free for all use\n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t16.\n#define RAY_TRACING \t\t0\n#define GRAV_CONST\t\t\t6.674\n#define STEP\t\t\t\t0.05\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct BlackHole\n{\n    vec3 pos; //position\n    float mass; //blackhole mass\n    float inner_radius; //inner radius\n    float accretion_disk_radius; //accretion disk\n};\n\nBlackHole bh;\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_black_hole(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tbh = BlackHole(pos, mass, inner_rad, disk_rad);\n}\n\nvoid space_time_bending(inout Ray r, inout vec3 p, float s)\n{    \n\n    vec3 bh_vec = bh.pos - p;\n    float d = dot(bh_vec,bh_vec);\n    vec3 res = normalize(bh_vec) * (GRAV_CONST*bh.mass)/(d);\n        \n    r.dir = normalize(r.dir + s*res);\n}\n\nvec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n                 \nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{        \n    vec3 p = ray_interpolation(r, k*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3)))));\n    \n    float s = 0.;\n     \n    for(s; s < 2000.; s++)\n    {               \n        vec2 nu = polar_coord(p-bh.pos);\n        \n        if((length(nu) - bh.inner_radius >= 0.) && (length(nu)-bh.accretion_disk_radius <= 0.) && (distance(p.y, bh.pos.y) < .2))\n        {\n            vec4 tex = texture(iChannel0, p/8.+0.01*iTime);\n            float coef = length(p-bh.pos);\n        \tc += 2.*(1./coef)*tex.r*vec3(0.6, 0.3, 0.2);\n        }\n        \n        p += r.dir*k;\n        space_time_bending(r, p, k); //comment this line to see what's behind\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 cam = vec3(0., 2., 30.);\n    bh = BlackHole(vec3(0., 0., -15.), 200./iResolution.y, 4., RADIUS);\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n\n    vec3 ray_dir = vec3(uv, -1.);\n    bh.pos = normalize(vec3(-10, 20., bh.pos.z));\n    ray_march_scene(Ray(cam, normalize(ray_dir)), STEP, color);\n    \n    fragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[406, 406, 447, 447, 483], [485, 485, 626, 626, 678], [680, 680, 741, 741, 920], [922, 922, 948, 948, 1096], [1115, 1115, 1167, 1167, 1816], [1818, 1818, 1875, 1875, 2273]], "test": "untested"}
{"id": "tdBBWG", "name": "Sea of Colors", "author": "jarble", "description": "It's an infinite sea of randomly-colored bubbles.", "tags": ["raymarching"], "likes": 0, "viewed": 293, "published": 3, "date": "1590689229", "time_retrieved": "2024-07-30T21:04:26.262332", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\t\n    return fract((p3.zyx*sin(p3.x)+2.0)*(p3.zxy*cos(p3.x)+2.0+sin((p3.x+p3.y+p3.z)*2.0)));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 475, 569], [572, 812, 846, 846, 932], [934, 1355, 1446, 1446, 1752], [1767, 2021, 2086, 2086, 2218], [2220, 2309, 2338, 2338, 2648], [2650, 3142, 3282, 3282, 3872], [3874, 4244, 4329, 4329, 5087], [5089, 5416, 5465, 5500, 5631], [5633, 5633, 5690, 5690, 6582]], "test": "untested"}
{"id": "wsSBWG", "name": "sdFunc - Glowing Objects", "author": "NightJolt", "description": "signed distance function", "tags": ["sdfunc"], "likes": 4, "viewed": 404, "published": 3, "date": "1590689162", "time_retrieved": "2024-07-30T21:04:27.110065", "image_code": "float map(float value, float fmin, float fmax, float tmin, float tmax) {\n    return tmin + (value - fmin) * (tmax - tmin) / (tmax - tmin);\n}\n\nfloat modAxis(float p, float size) {\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp = mod(-p + halfsize, size) - halfsize;\n\treturn p;\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 s, float r) {\n    vec2 d = abs(p) - s;\n    float sd = length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n    \n    return sd - r;\n}\n\nfloat su(float d1, float d2, float k) {\n    float h = clamp(.5 + .5 * (d2 - d1) / k, 0., 1.);\n    \n    return mix(d2, d1, h) - k * h * (1. - h);\n}\n\nfloat ss(float d1, float d2, float k) {\n    float h = clamp(.5 -.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1. - h);\n}\n\nfloat si(float d1, float d2, float k) {\n    float h = clamp(.5 - .5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat un(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec2 rotate(vec2 p, float angle) {\n    mat2 rot_mat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    return rot_mat * p;\n}\n\nvec2 magic(vec2 p) {\n    mat2 mat = mat2(cos(p.x), cos(p.y), cos(p.y), cos(p.x));\n    \n    return mat * p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 coord = fragCoord;\n    vec2 uv = coord / res;\n    vec2 p = coord - res * .5;\n    \n    //p.x = modAxis(p.x, 400.);\n    //p.y = modAxis(p.y, 400.);\n    \n    float rect = sdBox(rotate(p, -iTime), vec2(30.), 50.);\n    float rect_2 = sdBox(rotate(p, -iTime), vec2(20.), 100.);\n    float circle_ring =\n        un (\n            un (\n                sdCircle(p + vec2(100. * cos(iTime), 100. * sin(iTime)), 30.),\n    \t\t\tsdCircle(p + vec2(-100. * cos(iTime), -100. * sin(iTime)), 30.)\n            ),\n            un (\n                sdCircle(p + vec2(-100. * sin(-iTime), -100. * cos(-iTime)), 30.),\n    \t\t\tsdCircle(p + vec2(100. * sin(-iTime), 100. * cos(-iTime)), 30.)\n            )\n        );\n    float d = ss(su(rect, circle_ring, 20.), rect_2, 10.);\n    \n    vec3 c = vec3(5. / length(abs(mod(uv / d, 1.) - .5)));\n   \n\tvec3 col = vec3(.5 + sin(uv.x * 10. + iTime * 2.) * .3, .25, .7 + sin(uv.y * 20. + iTime * .5) * .3);\n    col *= 0.1;\n    \n    vec3 f_col = c / d * col * sqrt(length(p));\n    \n    fragColor = vec4(f_col - mod(f_col, .1), iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 140], [142, 142, 178, 178, 345], [347, 347, 380, 380, 408], [410, 410, 448, 448, 565], [567, 567, 606, 606, 713], [715, 715, 754, 754, 858], [860, 860, 899, 899, 1004], [1006, 1006, 1036, 1036, 1062], [1064, 1064, 1098, 1098, 1203], [1205, 1205, 1225, 1225, 1313], [1315, 1315, 1370, 1370, 2456]], "test": "untested"}
{"id": "WdSfDy", "name": "WorleyNoise3D", "author": "im_sky", "description": "Worley Noise 3D", "tags": ["noise"], "likes": 6, "viewed": 546, "published": 3, "date": "1590684342", "time_retrieved": "2024-07-30T21:04:27.984727", "image_code": "#define PI 3.14159265359\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat Hash(float f)\n{\n    return fract(sin(f)*43758.5453);\n}\n\nfloat Hash21(vec2 v)\n{\n    return Hash(dot(v, vec2(253.14, 453.74)));\n}\n\nfloat Hash31(vec3 v)\n{\n    return Hash(dot(v, vec3(253.14, 453.74, 183.3)));\n}\n\nvec3 Random3D( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1,311.7,217.3)),dot(p,vec3(269.5,183.3,431.1)), dot(p,vec3(365.6,749.9,323.7))))*437158.5453);\n}\n\nvec2 Rotate2D(vec2 v, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    mat2 rotMat = mat2(c,s,-s,c);\n    return rotMat * v;\n}\n\nvec4 GetWorleyNoise3D(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec4 res = vec4(1.0);\n    for(int x = -1; x <=1; ++x)\n    {\n        for(int y = -1; y <=1; ++y)\n        {\n            for(int z = -1; z <=1; ++z)\n            {\n                vec3 gp = p + vec3(x, y, z);\t//grid point\n\n                vec3 v = Random3D(gp);\n\n\t\t\t\tvec3 diff = gp + v - uvw;\n                \n                float d = length(diff);\n                \n                if(d < res.x)\n                {\n                    res.xyz = vec3(d, res.x, res.y);\n                }\n                else if(d < res.y)\n                {\n                    res.xyz = vec3(res.x, d, res.y);\n                }\n                else if(d < res.z)\n                {\n                    res.z = d;\n                }\n                \n                res.w = Hash31(gp);\n            }\n        }\n    }\n\n    return res;\n}\n\nfloat fBMWorley(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n\tfloat totalAmplitude = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        totalAmplitude += amplitude;\n        \n        vec4 n = GetWorleyNoise3D(x * frequency);\n        total += amplitude * n.x;\n        \n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total/totalAmplitude;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 3.0;\n    vec3 uvw = vec3(uv, iTime * 0.1);\n    \n    //uv *= 0.5*(sin(iTime * 2.0) + 5.0) * 2.40;\n\n\tfloat noise = fBMWorley(uvw, 2.0, 0.5, 4);\n    //noise += GetWorleyNoise3D(uvw * 2.0) * 0.5;\n\n    vec3 color = noise * vec3(1.0);\n    fragColor = vec4(1.0 - color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 118, 118, 217], [219, 219, 240, 240, 279], [281, 281, 303, 303, 352], [354, 354, 376, 376, 432], [434, 434, 459, 459, 597], [599, 599, 635, 635, 751], [753, 753, 786, 786, 1683], [1685, 1685, 1756, 1756, 2153], [2155, 2155, 2212, 2212, 2559]], "test": "untested"}
{"id": "WdSfDG", "name": "Mandelbuld fractal", "author": "kotfind", "description": "Mandelbulb fractal.\nCan be rotated with the mouse.", "tags": ["3d", "fractal", "mandelbulb", "raymarcing"], "likes": 2, "viewed": 430, "published": 3, "date": "1590661432", "time_retrieved": "2024-07-30T21:04:29.036914", "image_code": "#define u_resolution iResolution.xy\n#define u_mouse iMouse.xy\n#define u_time iTime\n\n#define inf 1000000.0\n#define M_PI 3.1415926\n\nfloat map(in vec3 p) {\n\tvec3 z = p;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n    float power = 8.0;\n\n\tfor(int i = 0; i < 8; ++i)\n    {\n\t\tr = length(z);\n\n\t\tif(r > 2.0)\n            continue;\n\n\t\ttheta = power * atan(z.y / z.x);\n        phi   = power * (asin(z.z / r) + u_time * 0.2);\n\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\tr = pow(r, power);\n\n\t\tz = r * vec3(cos(theta) * cos(phi),\n                     sin(theta) * cos(phi),\n                     sin(phi)) + p;\n\t}\n\n\treturn 0.5 * log(r) * r / dr;\n}\n\nfloat cast_ray(in vec3 ro, in vec3 rd) {\n    float t = 0.01;\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = ro + t * rd;\n\n        float h = map(p);\n        if (h < 0.001) break;\n        if (t > 10.0) break;\n        t += h;\n    }\n    if (t > 10.0) t = inf;\n    return t;\n}\n\nvec3 calc_normal(in vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //                      map(p + e.yxy) - map(p - e.yxy),\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    float d = map(p);\n    return normalize(vec3(map(p + e.xyy) - d,\n                          map(p + e.yxy) - d,\n                          map(p + e.yyx) - d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - u_resolution.xy / 2.0) / min(u_resolution.x, u_resolution.y);\n\n    float r     = 3.0;\n    float theta = 2.0*M_PI * (u_mouse.x / u_resolution.x - 0.25);\n    float phi   = 1.0*M_PI * (u_mouse.y / u_resolution.y + 0.000001);\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ro = ta + r * vec3(sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 rd = normalize(vec3(uv.x*uu + uv.y*vv + 1.0*ww));\n\n    vec3 col = vec3(0.);\n\n    float t = cast_ray(ro, rd);\n    if (t < inf) {\n        vec3 p = ro + t*rd;\n        vec3 norm = calc_normal(p);\n\n        vec3 c = vec3(1.0);\n\n        vec3  sun1_dir = normalize(vec3(1.0, 2.0, 3.0));\n        float sun1_dif = clamp(dot(norm, sun1_dir), 0.0, 1.0);\n        float sun1_sha = step(inf - 1.0, cast_ray(p, sun1_dir)) * (1.0 - 0.2) + 0.2;\n\n        vec3  sun2_dir = normalize(vec3(-1.0, -2.0, -3.0));\n        float sun2_dif = clamp(dot(norm, sun2_dir), 0.0, 1.0);\n        float sun2_sha = step(inf - 1.0, cast_ray(p, sun2_dir)) * (1.0 - 0.2) + 0.2;\n\n        col = c * clamp(0.6 * (sun1_sha * sun1_dif + sun2_sha * sun2_dif), 0.05, 0.90);\n    }\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 152, 152, 633], [635, 635, 675, 675, 912], [914, 914, 943, 943, 1324], [1326, 1326, 1381, 1381, 2696]], "test": "untested"}
{"id": "Wdjfzt", "name": "The Spheres of Wada", "author": "mla", "description": "See [url]http://paulbourke.net/fractals/wada/[/url]\n\nA tetrahedron of shiny spheres.\n\nup/down to zoom, mouse to rotate, c,d for background colour, v to vary sphere radius,", "tags": ["reflection", "spheres", "wada"], "likes": 13, "viewed": 415, "published": 3, "date": "1590655124", "time_retrieved": "2024-07-30T21:04:30.125004", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Spheres of Wada\n//\n// Matthew Arcus, mla, 2020.\n//\n// Something that I haven't seen on Shadertoy:\n// http://paulbourke.net/fractals/wada/\n//\n// Repeated reflections in tangential spheres produces Apollonian-\n// like fractal patterns.\n//\n// mouse + up/down to rotate and zoom\n// left/right to vary attenuation\n// c and d affect background colour\n// v to vary sphere radius for extra weirdness\n// r to stop autorotation\n// h to move viewpoint to centre with almost enclosing spheres\n//\n// Different base polyhedra also available.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#if 1\nconst float K = 0.5*sqrt(2.0);\nconst int NSPHERES = 4;\nvec4 spheres[NSPHERES] =\n  vec4[](vec4(1,0,K,1),vec4(-1,0,K,1),vec4(0,1,-K,1),vec4(0,-1,-K,1));\n#elif 1\n// Octahedron\nconst int NSPHERES = 6;\nvec4 spheres[NSPHERES] =\n  vec4[](vec4(1,0,1,1),vec4(-1,0,1,1),vec4(1,0,-1,1),vec4(-1,0,-1,1),\n         vec4(0,sqrt(2.0),0,1),vec4(0,-sqrt(2.0),0,1));\n#else\n// Cube\nconst int NSPHERES = 8;\nvec4 spheres[NSPHERES] =\n  vec4[](vec4(1,1,1,1),vec4(-1,1,1,1),vec4(1,1,-1,1),vec4(-1,1,-1,1),\n         vec4(1,-1,1,1),vec4(-1,-1,1,1),vec4(1,-1,-1,1),vec4(-1,-1,-1,1));\n#endif\n\nconst int MAXSTEPS = 50;\n\nfloat intersectsphere(vec3 p, vec3 r, vec4 sphere) {\n  p -= sphere.xyz; // Centre on sphere\n  float r2 = sphere.w; // Sphere radius squared\n  // Want dot(p+t*r,p+t*r) = r2\n  // ie. p.p - r2 + 2tp.r + t^2 = 0\n  float A = 1.0;\n  float B = dot(p,r);\n  float C = dot(p,p)-r2;\n  float D = B*B - C;\n  if (D < 0.0) return -1.0;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  //if (t < 0.0) t = t1;\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.zx = rotate(p.zx,phi);\n    p.yz = rotate(p.yz,-theta);\n  }\n  return p;\n}\n\nvec3 skycolor(vec3 r) {\n  vec3 col = vec3(1);\n  if (!key(CHAR_C)) col *= pow(abs(r),vec3(2.0));\n  if (!key(CHAR_D)) col *= texture(iChannel0,r).rgb;\n  return col;\n}\n\nfloat attenuation = 1.0;\n\nvec3 raycolor(vec3 p, vec3 r) {\n  int lastsphere = -1;\n  float att = 1.0;\n  for (int i = 0; i < MAXSTEPS; i++) {\n    float t = 1e8;\n    int hitsphere = -1;\n    for (int j = 0; j < NSPHERES; j++) {\n      if (j == lastsphere) continue;\n      float t1 = intersectsphere(p,r,spheres[j]);\n      if (t1 > 0.0 && t1 < t) {\n        t = t1;\n        hitsphere = j;\n      }\n    }\n    if (hitsphere == -1) return att*skycolor(r);\n    lastsphere = hitsphere;\n    p += t*r;\n    att *= attenuation;\n    r = reflect(r,normalize(p-spheres[hitsphere].xyz)); // Normal is just direction from sphere centre\n  }\n  return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  for (int i = 0; i < NSPHERES; i++) {\n    spheres[i].xyz = transform(spheres[i].xyz);\n    if (key(CHAR_V)) spheres[i].w *= 1.0 + 0.35*sin(0.5*iTime);\n    else if (key(CHAR_H)) spheres[i].w = 1.25;\n  }\n  float camera = key(CHAR_H) ? 0.0 : 1.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  attenuation *= exp(0.05*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)-2));    \n  vec3 p = vec3(0,0,camera);\n  //p = transform(p);\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,-2);\n      //r = transform(r);\n      r = normalize(r);\n      col += raycolor(p,r);\n    }\n  }\n  col /= AA*AA;\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n  if (check) fragColor = vec4(1,0,0,1);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159;\nbool check = false;\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvoid assert(bool b) { if (!b) check = true; }\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_L = 76;\nconst int CHAR_P = 80;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1300, 1300, 1352, 1352, 1770], [1772, 1772, 1799, 1799, 2132], [2134, 2134, 2157, 2157, 2298], [2326, 2326, 2357, 2357, 2936], [2938, 2938, 2995, 2995, 3860]], "test": "untested"}
{"id": "wdjBzd", "name": "Make rows of moving cells", "author": "chen1180", "description": "Test the noise generator from the shader book!\nreference: https://thebookofshaders.com/10/", "tags": ["random", "thebookofshaders"], "likes": 0, "viewed": 357, "published": 3, "date": "1590647945", "time_retrieved": "2024-07-30T21:04:31.089426", "image_code": "float rand(float i){\n\treturn fract(sin(i)*43758.5453123);\n}\nfloat rand2d(vec2 uv){\n    return fract(sin(dot(uv.xy,vec2(12.123452,78.48254)))*43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    if (uv.y>0.5){\n        uv*=50.0;\n        uv.x+=5.0*iTime;\n   \n    }else{\n        uv*=75.0;\n        uv.x-=7.5*iTime;\n    }\n    vec2 ipos = floor(uv);  // get the integer coords\n    float random=rand(ipos.x);\n    if (random<0.4)\n        random=0.0;\n    else\n        random=1.0;\n    // Time varying pixel color\n    vec3 col = vec3(random);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 59], [60, 60, 82, 82, 158], [159, 159, 216, 266, 704]], "test": "untested"}
{"id": "wsjfRd", "name": "fwidth vs length(dFdxy)", "author": "FabriceNeyret2", "description": "fwidth() is convenient to tune a LOD. \nBut it's a L1 norrm, not L2, and thus angularly biased -> length(vec2(dFdx,dFdy)) is better (top).\nWhat then applied to vectors ? MIPmap rely on max. Again, length() is smoother (top).\nBottom: len(width) vs width(len", "tags": ["tuto", "hardwarederivatives"], "likes": 3, "viewed": 463, "published": 3, "date": "1590646563", "time_retrieved": "2024-07-30T21:04:32.070802", "image_code": "#define matNorm(m) sqrt( m[0][0]*m[0][0] +  m[1][0]*m[1][0] +  m[0][1]*m[0][1] +  m[1][1]*m[1][1] )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         M = 2.*iMouse.xy - 1. - R,\n         U = ( 2.* u -1. - R ) / R.y;\n    \n    U = U/dot(U,U);                                   // example function: inversion\n    \n    int i = int(U.x>0.) + 2*int(U.y>0.);              // quadrant id\n    if (iMouse.z>0.) i = int(M.x>0.) + 2*int(M.y>0.); // click to open\n    else if (U.y==0.||U.x==0.&&U.y<0.) { O = vec4(0,0,1,0); return; }  // blue separators\n    \n    float m =   i==0 ?  length(fwidth(U))\n              : i==1 ?  fwidth(length(U))\n           // : i==2 ?  fwidth(U.x)+fwidth(U.y)       // looks identical to case 0 * sqrt(2)\n           // : i==2 ?  max(fwidth(U.x),fwidth(U.y))  // looks identical to case 0 / sqrt(2)\n              :         length(vec2(length(dFdx(U)),length(dFdy(U)))); \n                        // is matNorm( mat2(dFdx(U),dFdy(U)) );\n    O = vec4(16.*m);\n    O.gb = sin(O.gb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 139, 139, 1024]], "test": "untested"}
{"id": "tdjfRd", "name": "Circle_Inversion + smoothclamp", "author": "FabriceNeyret2", "description": "variant of lil_chickehh's  \"Circle_Inversion\"  [url]https://shadertoy.com/view/3s2fz3[/url]\nwith AA + golfing , eiffie's clamped inversion U / clamp(dot(U,U),.25,1.), changed into smoothclamp.", "tags": ["geometry", "2tweets", "golf"], "likes": 4, "viewed": 337, "published": 3, "date": "1590644409", "time_retrieved": "2024-07-30T21:04:32.953442", "image_code": "// Smoothclamp variant of \"Circle_Inversion\" by lil_chickehh. https://shadertoy.com/view/3s2fz3\n// There, I AA and golfed (sorry...) it,\n// and eiffie's suggested clamped inversion U / clamp(dot(U,U),.25,1.)\n// That I here turned to #def smoothclamp(v,a,b) ( a+(b-a)*smoothstep(a,b,v) )\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = ( u+u - R) / R.y;\n    U = cos(   21.*U / ( .3+smoothstep(.25,1.,dot(U,U)) )\n             + 16.*sin(iTime*.2+vec2(0,33))  );\n    U += U.y;\n    O += .5 + U.x/fwidth(U.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 324, 324, 537]], "test": "untested"}
{"id": "tsjBRd", "name": "mindless noodle 2", "author": "mds2", "description": "yet another mindless noodle while edging towards a particular effect.  Haven't achieved the effect yet.", "tags": ["raycast", "subsurface", "holes"], "likes": 2, "viewed": 325, "published": 3, "date": "1590642233", "time_retrieved": "2024-07-30T21:04:34.468391", "image_code": "#define MAX_DIST 4.0\n\n#define SUPERSAMPLE 0 // per IQ, enable at your own risk\n// #define SUPERSAMPLE 1 // it's a boolean\n\n#define RAYMARCH_STEP_SCALE 0.175 // lower gives better quality, higher gives better framerate\n\n#define RAYMARCH_OUT_STEP_SCALE 0.5\n\nfloat length_1 = 0.4;\nconst float crinkle = 0.0025; // make this smaller to make grid finer\n\nvec2 bright_clamp = vec2(0.0, 0.9); // ramp brightness values in this range to 0.0,1.0\n\n#define HOLES_OR_RODS 1 // 1 for holes, 0 for rods\n\nconst vec3 light_dir = normalize(vec3(0.05, 0.05, -0.15));\n\nfloat wiggle = 10.0;\nconst float wiggle_speed = 0.5;\n\nfloat do_bright_clamp(in float x) {\n#if !HOLES_OR_RODS\n    // return clamp((x-bright_clamp.y)/(bright_clamp.x - bright_clamp.y), 0.0, 1.0);\n\treturn smoothstep(bright_clamp.y, bright_clamp.x, x);\n#else\n    // return clamp((x-bright_clamp.x)/(bright_clamp.y - bright_clamp.x), 0.0, 1.0);\n    return smoothstep(bright_clamp.x, bright_clamp.y, x);\n#endif\n}\n\nfloat core_sdf(in vec3 pt) {\n    const vec3 p1 = vec3(0.0, 0.15, 0.7);\n    const vec3 p2 = -vec3(0.0, -0.1, 0.65);\n    float d1 = length((pt - p1)* vec3(1.6)) - 3.1 * length_1;\n    // float d1 = dot(pt - p1, normalize(p2 - p1)) - 1.85 * length_1;\n    // float d2 = length((pt - p2) * vec3(1.6)) - 3.0 *  length_1;\n    float d2 = dot(pt - p2, normalize(p1 - p2)) - 1.9 * length_1;\n    // float d1 =  length((pt.xy + vec2(0.0, -0.15))) -0.8 *  length_1;\n    return smooth_max(d1, d2, 0.05);\n}\n\n\n\nfloat sdf(in vec3 pt) {\n    float result = core_sdf(pt);\n    result += 12.0 * crinkle * (1.0 - 2.0 * texture(iChannel0, vec2(1.0 * pt.x + 0.5, 0.0)).r); // \n    if (result < 2.0 * crinkle) {\n        vec3 hole_coord = vec3(pt.xy, 0.0);\n        float noise_val = simple_noise(10.0 * hole_coord,  wiggle);\n        // float hole_dist = 0.5 * hole_size - length(cell_rel.xy);\n        float hole_dist = noise_val - 1.1;\n#if HOLES_OR_RODS\n        result = smooth_max(result, hole_dist, 0.05 * crinkle);\n#else\n        result = smooth_max(result, -hole_dist, 0.05 * crinkle);\n#endif\n        result += 1.5 * crinkle * simple_noise(75.0 * hole_coord, 13.1);\n       // result -= crinkle * smoothstep(0.0, 0.8, simple_noise(32.0 * pt, 28.1));\n    }\n    return result;\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return h_inv *\n        vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n             sdf(pt + vec3(0.0, h, 0.0)) - f,\n             sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\n\n\nfloat raymarch(in vec3 pt, in vec3 dir, out float sumdist) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = sdf(pt);\n    sumdist = 0.0;\n    for(int i = 0; i < 256; ++i) {\n        if (accum > MAX_DIST || s < 1.0e-3) {\n            return accum;\n        }\n        accum += RAYMARCH_STEP_SCALE * s;\n        p = pt + accum * d;\n        s = sdf(p);\n        sumdist = sumdist + RAYMARCH_STEP_SCALE * s / max(s, 1.0e-3);\n    }\n    if (s > 1.0e-3) {\n        return MAX_DIST + 1.0;\n    }\n    return accum;\n}\n\nfloat raymarch_out(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float total_step = 0.0;\n    float accum = 0.0;\n    float s = core_sdf(pt);\n    for(int i = 0; i < 256; ++i) {\n        if (total_step > MAX_DIST) {\n            return accum;\n        }\n        float curr_step = RAYMARCH_OUT_STEP_SCALE * max(abs(s), 1.0e-3);\n        total_step += curr_step;\n        accum += curr_step * smoothstep(crinkle, -crinkle, s); \n        p = pt + total_step * d;\n        s = core_sdf(p);\n    }\n    return accum;\n}\n\nfloat ramp(in float a, in float b, in float x) {\n    float p = (x-a)/(b-a);\n    return clamp(p, 0.0, 1.0);\n}\n\nvec4 color_at(in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 6.0));\n    \n    vec3 orig = vec3(0.0, 0.25, -1.5);\n    \n    // float theta = 0.005 * sin(0.5 * iTime) + 3.141592654;\n    float ct = -1.0; // cos(theta);\n    float st = 0.0; // sin(theta);\n    \n    mat3 spin = mat3(ct, 0.0, st,\n                     0.0, 1.0, 0.0,\n                     -st, 0.0, ct);\n    \n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                     0.0, 0.6, -0.8,\n                     0.0, 0.8, 0.6);\n    \n    orig = tilt * orig * spin;\n    dir = tilt * dir * spin;\n    \n    orig.y -= 0.2;\n    \n    float cloud_integral = 0.0;\n    \n    float dist = raymarch(orig, dir, cloud_integral);\n    \n    vec3 color_mul = vec3(1.0);\n    \n    \n    vec3 col = vec3(0.0);\n    vec3 refl_color = 1.0 * vec3(0.8, 1.0, 0.5);\n    vec3 trans_color = 1.0 * vec3(1.0, 0.1, 0.5); // 1.0 , 0.5, 0.4);\n    float thru_dist = 1000.0;\n    vec3 n = dir;\n    if (dist < MAX_DIST) {\n        vec3 pt = orig + dir * dist;\n        thru_dist = raymarch_out(pt, light_dir);\n        n = normalize(sdf_grad(pt));\n        dir = normalize(reflect(dir, n));\n  \n\n    \n    \tcol = (0.8 * smoothstep(0.99, 1.0, dot(dir, light_dir)) + 0.5 * smoothstep(0.2, 1.0, dot(n, light_dir)))*\n        \trefl_color;\n    \n\t    float pen_length = 0.1 * length_1; //  10.25 * crinkle;\n    \tfloat soften_subsurface = 1.0;\n    \n\t    col += ( soften_subsurface * pen_length / max(abs(soften_subsurface *  thru_dist), pen_length)) * trans_color;\n    \n    }\n    float sweep = 20.0 * fragCoord.x / iResolution.x + smoothstep(0.0, iResolution.y, fragCoord.y);\n    float cloud_modulate = 0.25; //  + 0.25 * sin(1.71 * iTime + sweep);\n    float cloud_contrib =  0.125 * cloud_modulate * cloud_integral;\n    // cloud_contrib *= smoothstep(0.4, 0.6, cloud_contrib);\n    col +=  1.0 * vec3(-1.0, 1.0, 1.0) * cloud_contrib;\n\n    // col = vec3(freckles, 0.0);\n    // Output to screen\n    return  vec4(color_mul * col,1.0);\n}\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // length_1 += 0.05 * length_1 * sin(0.11 * iTime);\n \n    wiggle = mod(wiggle_speed * iTime, 100.0);\n \n\tvec4 col_out = color_at(fragCoord);\n#if SUPERSAMPLE\n    col_out *= 0.25;\n    const float scatter_scale = 0.8;\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.6, 0.8));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(-1.0, 0.0));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.0, -1.0));\n#endif\n    fragColor = col_out;\n}\n", "image_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nfloat smooth_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nvec3 smooth_max(in vec3 x, in vec3 y, float s) {\n\treturn vec3(smooth_max(x.x, y.x, s),\n                smooth_max(x.y, y.y, s),\n                smooth_max(x.z, y.z, s));\n}\n\nfloat smooth_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nvec3 smooth_min(in vec3 x, in vec3 y, float s) {\n\treturn vec3(smooth_min(x.x, y.x, s),\n                smooth_min(x.y, y.y, s),\n                smooth_min(x.z, y.z, s));\n}\n\n//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfloat stupid_hash(in float x) {\n    return mod(10.0 * sin(10.01 * x + 5.0), 1.0);\n}\n    \n//--------------------------------------------------\n\nfloat hash13(vec3 v)\n{\n    float l = dot(v, v);\n    float tmp = stupid_hash(v.x);\n    tmp = stupid_hash(l * tmp + v.y);\n    tmp = stupid_hash(l * tmp + v.z);\n    \n\treturn tmp;\n}\n\n\nfloat noise_term(in vec3 x, in float scale_val) {\n    vec3 s = vec3(scale_val);\n    vec3 x000 = x - mod(x, s);\n    vec3 x001 = x + vec3(0.0, 0.0, scale_val);\n    x001 = x001 - mod(x001, s);\n    vec3 x010 = x + vec3(0.0, scale_val, 0.0);\n    x010 = x010 - mod(x010, s);\n    vec3 x011 = x + vec3(0.0, s.xy);\n    x011 = x011 - mod(x011, s);\n    vec3 x100 = x + vec3(scale_val, 0.0, 0.0);\n    x100 = x100 - mod(x100, s);\n    vec3 x101 = x + vec3(scale_val, 0.0, scale_val);\n    x101 = x101 - mod(x101, s);\n    vec3 x110 = x + vec3(s.xy, 0.0);\n    x110 = x110 - mod(x110, s);\n    vec3 x111 = x + s;\n    x111 = x111 - mod(x111, s);\n    \n    float v000 = hash13(round(x000));\n    float v001 = hash13(round(x001));\n    float v010 = hash13(round(x010));\n    float v011 = hash13(round(x011));\n    float v100 = hash13(round(x100));\n    float v101 = hash13(round(x101));\n    float v110 = hash13(round(x110));\n    float v111 = hash13(round(x111));\n    \n    vec3 uvw = mod(x, s) / s;\n    \n    float zweight = smoothstep(0.0, 1.0, uvw.z);\n    float v00 = mix(v000, v001, zweight);\n    float v01 = mix(v010, v011, zweight);\n    float v10 = mix(v100, v101, zweight);\n    float v11 = mix(v110, v111, zweight);\n    \n    float yweight = smoothstep(0.0, 1.0, uvw.y);\n    float v1 = mix(v10, v11, yweight);\n    float v0 = mix(v00, v01, yweight);\n    \n    float xweight = smoothstep(0.0, 1.0, uvw.x);\n    \n    return mix(v0, v1, xweight);\n}\n\nfloat noise(in vec3 x, in float base_scale, in float space_decay, in float height_decay,\n           in float shift_by) {\n\tfloat h = 1.0;\n    float s = base_scale;\n\n    float summation = 0.0;\n    \n    for (int i = 0; i < 3; ++i) {\n    \tsummation = summation + h * noise_term(x + vec3(0.0, 0.0, s * shift_by), s);\n        s *= space_decay;\n        h *= height_decay;\n    }\n    return summation;\n}\n\nfloat simple_noise(in vec3 uv, in float shift_by) {\n  return noise(uv * 10.0, 5.0, 0.75, 0.75, shift_by);\n}\n\nvec2 noise2(in vec3 uv, in float shift_by) {\n    return vec2(simple_noise(uv, shift_by),\n                simple_noise(uv + vec3(0.0, 0.0, 10.1), shift_by));\n}\n\nvec3 noise3(in vec3 uv, in float shift_by) {\n    return vec3(simple_noise(uv, shift_by),\n                simple_noise(uv + vec3(0.0, 0.0, 101.0), shift_by),\n               simple_noise(uv + vec3(0.0, 101.0, 0.0), shift_by));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[603, 603, 638, 638, 955], [957, 957, 985, 985, 1447], [1451, 1451, 1474, 1474, 2207], [2209, 2209, 2236, 2236, 2483], [2487, 2487, 2547, 2547, 3020], [3022, 3022, 3067, 3067, 3554], [3556, 3556, 3604, 3604, 3664], [3666, 3666, 3701, 3751, 5720], [5726, 5726, 5783, 5839, 6265]], "test": "untested"}
{"id": "wdjfRt", "name": "Infinite Debris", "author": "jarble", "description": "The random shapes and colors go on forever!", "tags": ["raymarching", "hash"], "likes": 0, "viewed": 296, "published": 3, "date": "1590634866", "time_retrieved": "2024-07-30T21:04:35.339063", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += (p3, (p3.xyz*cos(p3.x+p3.y)+p3.xyz*sin(p3.x*2.0+p3.y*3.0))+33.33);\n    return fract(p3*(p3*2.0));\n\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 476, 534, 690], [693, 933, 967, 967, 1053], [1055, 1476, 1567, 1567, 1873], [1888, 2142, 2207, 2207, 2339], [2341, 2430, 2459, 2459, 2769], [2771, 3263, 3403, 3403, 3993], [3995, 4365, 4450, 4450, 5208], [5210, 5537, 5586, 5621, 5752], [5754, 5754, 5811, 5811, 6703]], "test": "untested"}
{"id": "3ssfzn", "name": "webcam_noise", "author": "ianwall", "description": "Offset colors", "tags": ["asd"], "likes": 6, "viewed": 779, "published": 3, "date": "1590634554", "time_retrieved": "2024-07-30T21:04:36.277554", "image_code": "float rounding = 0.0;\nfloat sharpness = 0.02;\nfloat INNER = (1./3.);\n\nfloat rand(float x)\n{\n\treturn fract(sin(x)*100000.0);    \n}\n\nfloat noise1D(float x)\n{\n    float i = floor(x);  // integer\n\tfloat f = fract(x);  // fraction\n\tfloat u = f*f*f*(f*(f*6.-15.)+10.); // custom cubic curve\n\treturn mix(rand(i), rand(i + 1.0), u); // using it in the interpolation\n}\n\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n#define PI 3.1415926\n    // distance\n    \n\tfloat t = (1.0/5.0)*iTime*(2.0*3.1415936);\n    float WIGGLE = 0.2;\n    float COLOR_OFFSET = 0.7;\n    float N = WIGGLE*smoothstep(-1.3,1.3,(sin(t/5.0)));\n    vec2 uvR = uv + N*vec2(noise(uv+t), noise(312.0+uv+t));\n    vec2 uvG = uv + N*vec2(noise(uv+COLOR_OFFSET+t), noise(312.0+uv+COLOR_OFFSET+t));\n    vec2 uvB = uv + N*vec2(noise(uv-COLOR_OFFSET+t), noise(312.0+uv-COLOR_OFFSET+t));\n    \n\tfloat R = texture(iChannel0, uvR).r;\n\tfloat G = texture(iChannel0, uvG).g;\n\tfloat B = texture(iChannel0, uvB).b;\n    \n\tfragColor = vec4(R,G,B, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 91, 91, 129], [131, 131, 155, 155, 359], [362, 362, 384, 384, 523], [525, 610, 632, 632, 1036], [1038, 1038, 1095, 1095, 1720]], "test": "untested"}
{"id": "3s2fzd", "name": "Crazy Cobwebs", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/Wd2fzd]\"Iridescent bubble fly-through\"[/url] animation.", "tags": ["raymarching", "hash"], "likes": 2, "viewed": 295, "published": 3, "date": "1590626829", "time_retrieved": "2024-07-30T21:04:37.362653", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 10.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3)+p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint+vec3(0.0,0.0,0.0);\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 476, 534, 649], [651, 697, 724, 724, 871], [874, 874, 908, 908, 970], [973, 1213, 1247, 1285, 1380], [1382, 1803, 1894, 1894, 2200], [2215, 2469, 2534, 2534, 2666], [2668, 2757, 2786, 2786, 3096], [3098, 3590, 3730, 3730, 4320], [4322, 4692, 4777, 4777, 5535], [5537, 5864, 5913, 5948, 6079], [6081, 6081, 6138, 6138, 7030]], "test": "untested"}
{"id": "Wd2fzd", "name": "Iridescent bubble fly-through", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/tsBfRd]\"Iridescent bubbles\"[/url] shader.", "tags": ["raymarching", "hash"], "likes": 1, "viewed": 290, "published": 3, "date": "1590626199", "time_retrieved": "2024-07-30T21:04:38.200413", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 10.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2fzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 476, 534, 659], [661, 707, 734, 734, 881], [884, 884, 918, 918, 980], [983, 1223, 1257, 1257, 1298], [1300, 1721, 1812, 1812, 2118], [2133, 2387, 2452, 2452, 2584], [2586, 2675, 2704, 2704, 3014], [3016, 3508, 3648, 3648, 4238], [4240, 4610, 4695, 4695, 5453], [5455, 5782, 5831, 5866, 5997], [5999, 5999, 6056, 6056, 6948]], "test": "untested"}
{"id": "wdBfzd", "name": "3D details distrib on surface", "author": "FabriceNeyret2", "description": "(camera follow mouse).\n#56: flag for detail free 3D orientation or normal + free surface orientation\nflags SHADED , FOG\nWIP. slow and dirty for now.", "tags": ["procedural", "noise", "hypertexture", "trabeculum", "mm"], "likes": 10, "viewed": 590, "published": 3, "date": "1590614411", "time_retrieved": "2024-07-30T21:04:39.045154", "image_code": "// started from \"hypertexture-trabeculum\" by FabriceNeyret2. https://shadertoy.com/view/ltj3Dc\n\n#define SHADED 1      // 1: fast light-dir shading. 0: stepCount pseudo-shading\n#define FOG 0         // activate fog\nbool geoMode = true;  // details 3D free (true) or 2D constrained (false)\n                      // space to toggle.\nconst float skyTrsp = .1;\nconst vec3 skyColor = vec3(.7,.8,1),\n           sunColor = vec3(1,.7,.1) *10.,   \n           lightDir = vec3(.94,.24,.24), // normalize(vec3(.8,.2,-.2));\n           ambient  = vec3(.2), \n           diffuse  = vec3(.8);\n\n// --- utils\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) ) // https://www.shadertoy.com/view/ll2cDc\n#define hash13(n)     fract(sin(n+vec3(0.,12.345,124))*43758.5453)\n#define hash33(n)     hash13(dot(n,vec3(1,13.1,107.7)))\n#define rot(a)        mat2(cos(a),-sin(a),sin(a),cos(a))\n\nmat3 rot3D(vec3 A, float a) {\n    A = normalize(A);\n    float s = sin(a), c = cos(a), C = 1. - c;\n /* return mat3(C* A.x*A.x + c,        C* A.x*A.y - A.z * s,  C* A.z*A.x + A.y * s,\n                C* A.x*A.y + A.z * s,  C* A.y*A.y + c,        C* A.y*A.z - A.x * s,\n                C* A.z*A.x - A.y * s,  C* A.y*A.z + A.x * s,  C* A.z*A.z + c    );\n */ return mat3(c) +  C*outerProduct(A,A) +  mat3(  0  ,-s*A.z, s*A.y,\n                                                  s*A.z,  0   ,-s*A.x,\n                                                 -s*A.y, s*A.x,  0   );\n}                                           // GLSL bug: can't factor s !\n\nfloat distrib( vec3 p, inout vec3 C, inout vec3 id) { // return dist; C=pos, id=detail 3D id\n    float d = 1e15;\n    vec3 ip = floor(p);\n    for (int k=0; k<27; k++) {                    // --- visit 3x3x3 neighborhood\n                vec3  p0 = ip + vec3(k%3,k/3%3,k/9) - 1., // cell id\n                       c = hash33(p0)+p0-p;       // vector-dist to cell sample\n                float d0 = dot(c,c);              // dist²\n                if  (d0<d) d=d0, C=c+p, id = p0;  // keep closest sample info\n            }\n    return sqrt(d);\n}\n\nfloat rad = .5,  // macro sphere radius\n     grid = 10., // grid density in each direction\n     size =.03;  // detail radius ( take care of using smaller Eps for hit and normals ) \n\n#if 0 // --- should be the correct one, but gives bad detail scattering\n\nfloat dist2scene(vec3 p, inout vec3 id) {\n    vec3 P=vec3(0); id=vec3(-2);     // for debug\n    float v = length(p) - rad+size,                    // distance to macro sphere\n          d = distrib(grid*p,P,id)/grid ;         // dist to detail center. P=center, id\n          P /= grid;\n // if (dot(p,p)/4. > size*size + rad*rad + size*rad) return v-2.*size;  // bounding sphere: save everything!  \n // if (v > 2.*size) return  v+2.*size;           // bounding sphere: save nothing :-(\n    if  ( abs(length(P)-rad+size)<2.*size ) \n    {\n        P = normalize(P)* rad;\n        vec3 a = p-P, h = hash33(id);                 // detail random rotation\n        if (geoMode)                                  // free 3D rot\n            a.yz *= rot(6.28*h.x), a.xy *= rot(6.28*h.z);\n        else                                          // 2D rot + align along N\n            a *= rot3D(vec3(P.y,-P.x,0),acos(normalize(P).z)),\n            a.xy *= rot(6.28*h.z);\n\n        a = abs(a); d = max(a.x,max(a.y,a.z)) - size; // distance to detail = cube\n\n        if (  d < v ) v = d;                          // we hit a detail\n        else id = vec3(-1);                           // we hit nothing or the surface\n    } //else id=vec3(-1);  \n    float bg = .85-length(p);                     // background sphere\n    if (bg < v ) v = bg, id = vec3(-2);           // we missed the object: id = sky.\n    return v;\n}\n\n#else // --- temporary one with better scattered details... not really on the surface\n\nfloat dist2scene(vec3 p, inout vec3 id) {\n    vec3 P=vec3(0); id=vec3(-2);     // for debug\n    float v = length(p) - rad,                    // distance to macro sphere\n          d = distrib(grid*p,P,id)/grid ;         // dist to detail center. P=center, id\n          P /= grid;\n // if (dot(p,p)/4. > size*size + rad*rad + size*rad) return v-2.*size;  // bounding sphere: save everything!  \n // if (v > 2.*size) return  v+2.*size;           // bounding sphere: save nothing :-(\n                                                  // put detail on surface\n    if  ( abs(length(P)-rad-size)<size ) P = normalize(P)*(rad-size); // [ why -size ? ]\n    vec3 a = p-P, h = hash33(id);                 // detail random rotation\n    if (geoMode)                                  // free 3D rot\n        a.yz *= rot(6.28*h.x), a.xy *= rot(6.28*h.z);\n    else                                          // 2D rot + align along N\n        a *= rot3D(vec3(P.y,-P.x,0),acos(normalize(P).z)),\n        a.xy *= rot(6.28*h.z);\n\n    a = abs(a); d = max(a.x,max(a.y,a.z)) - size; // distance to detail = cube\n    \n    v += 2.*size;           // [ why can't I put all below or around rad ? ]\n    if ( length(P) < rad && d < v ) v = d;        // we hit a detail\n    else id = vec3(-1);                           // we hit nothing or the surface\n    \n    float bg = .85-length(p);                     // background sphere\n    if (bg < v ) v = bg, id = vec3(-2);           // we missed the object: id = sky.\n    return v;\n}\n\n#endif\n\nvec3 calcNormal(vec3 p) { // taken here https://www.shadertoy.com/view/3sBBWy\n  vec3 n = vec3(0), id;\n  for(int i = 0; i < 4; i++){\n      vec3 e = .001*( vec3(9>>i&1, i>>1&1, i&1) *2.-1. );\n      n += e * dist2scene(p+e, id);\n  }\n  return normalize(n);\n}\n\n#define NORM 2    // 0 : full DF normal 1: centered directional 2: even cheaper\nfloat shadedNormal( vec3 p, float v ) {\n    float epsL = .005, dx; vec3 id;               // use smaller eps for contrast\n#if NORM == 0\n    dx =  dot(calcNormal(p),lightDir);            // true Lambert with full DF normal\n#elif NORM == 1                                   // centered directional derivative\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\n    dx = ( dist2scene(p+epsL*lightDir, id)\n          -dist2scene(p-epsL*lightDir, id)) / (2.*epsL);\n#else                                             // cheap directional derivative\n    dx = (dist2scene(p+epsL*lightDir, id)-v)/epsL;\n#endif\n    return clamp(dx, 0.,1.);                      // approx Lambert shading    \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         q = ( 2.*u - R ) / R.y,\n         M = iMouse.xy / R;\n    if ( M==vec2(0)) M=vec2(.5);\n    geoMode = !keyToggle(32);\n    \n    // --- set camera\n    float theta = -( M.x - .5 ) *6.28,\n            phi = -( M.y - .5 ) *3.14;\n#if 1 // camera shake \n    float t=10.*iTime,B=.02;   theta += B*cos(t); phi += B*sin(t);\n#endif\n    vec3 cameraPos = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi)),   \n      cameraTarget = vec3(0),\n         W = normalize( cameraPos - cameraTarget ),\n         U = normalize(cross( vec3(0,1,0), W )),\n         V = cross(W,U),\n    rayDir = normalize( q.x*U + q.y*V -1.5*W );\n  \n    // --- ray-trace volume\n    float l = .5, d,\n        transp = 1.;\n    vec3 col = vec3(0),\n           p = cameraPos+l*rayDir, p_=p, \n          id = vec3(-2);                      // default = sky\n    \n    float i=0.;\n    for (; i<200.; i++) {                     // ray-march\n        d = dist2scene(p, id); \n        if (id==vec3(-2)) break;              // early exit if sky\n        if (d < .003)     break;              // \"hit\" on an object\n        p += .3*d*rayDir;\n    }\n // O = i/vec4(200,50,12,1); return;          // test: hitmap of iterations\n    \n    // --- shading\n    if ( d < .01 && id != vec3(-2) ) {        // hit\n#if FOG \n\t    float fog = pow(skyTrsp,length(p_-p)); p_=p;\n        col += transp*skyColor*(1.-fog);\n    \ttransp *= fog; \n#endif            \n        vec3 c = id != vec3(-1) \n                  ? .2*hue( hash33(id).x )    // detail color\n                  : ambient;                  // other surface: ambiant\n#if SHADED          \n        c += diffuse* shadedNormal(p,d);      // shading\n#else\n        c += diffuse* (1.-i/40.);             // pseudo-shading\n#endif\n \t    col += transp*c; transp = 0.;\n      }\n      \n   O = vec4(col+ transp*skyColor, 1.);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[945, 945, 974, 974, 1509], [1583, 1583, 1636, 1675, 2124], [5369, 5369, 5394, 5446, 5623], [5705, 5705, 5744, 5744, 6533], [6535, 6535, 6573, 6573, 8400]], "test": "untested"}
{"id": "3s2fRt", "name": "Corrugated web", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/tsBfRd]\"Iridescent bubbles\"[/url] shader.", "tags": ["raymarching"], "likes": 4, "viewed": 320, "published": 3, "date": "1590612978", "time_retrieved": "2024-07-30T21:04:39.854989", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+20.0+10.0*sin(p3.y*2.0));\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint+vec3(0.0,-iTime,-iTime);\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/500.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 533, 676], [678, 724, 751, 751, 898], [901, 901, 935, 935, 997], [1000, 1240, 1274, 1312, 1413], [1415, 1836, 1927, 1927, 2233], [2248, 2502, 2567, 2567, 2699], [2701, 2790, 2819, 2819, 3129], [3131, 3623, 3763, 3763, 4353], [4355, 4725, 4810, 4810, 5568], [5570, 5897, 5946, 5981, 6112], [6114, 6114, 6171, 6171, 7044]], "test": "untested"}
{"id": "Ws2BRt", "name": "Menger sponge fractal", "author": "kotfind", "description": "Menger sponge fractal.\nFractal can be rotated with mouse.\nDrawing depth can be changed in the beginning of the code.", "tags": ["3d", "menger", "mengersponge", "fracta", "raymarchinig", "mangersponge"], "likes": 1, "viewed": 447, "published": 3, "date": "1590612131", "time_retrieved": "2024-07-30T21:04:40.849331", "image_code": "#define DEPTH 5\n\n#define u_resolution iResolution.xy\n#define u_mouse iMouse.xy\n#define u_time iTime\n\n#define inf 1000000.0\n#define M_PI 3.1415926\n\nfloat sdbox(in vec3 p) {\n    vec3 q = abs(p) - 1.0;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdbox2d(in vec2 p) {\n    vec2 d = abs(p)-1.0;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdcross(in vec3 p) {\n    float d1 = sdbox2d(p.xy);\n    float d2 = sdbox2d(p.yz);\n    float d3 = sdbox2d(p.xz);\n    return min(d1, min(d2, d3));\n}\n\nfloat map(in vec3 p) {\n    float d = inf;\n\n    // fractal\n    float d1 = sdbox(p);\n    d = min(d, d1);\n\n    float d2 = inf;\n    float pw = 1.0;\n    for (int i = 0; i < DEPTH; ++i) {\n        vec3 r = mod(p + pw, pw * 2.0) - pw;\n        float d3 = sdcross(r / (pw / 3.0)) * (pw / 3.0);\n        pw /= 3.0;\n        d2 = min(d2, d3);\n    }\n    d = max(d, -d2);\n\n    // floor\n    float d3 = p.y - (-1.5);\n    //d = min(d, d3);\n\n    return d;\n}\n\nfloat cast_ray(in vec3 ro, in vec3 rd) {\n    float t = 0.001;\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = ro + t * rd;\n\n        float h = map(p);\n        if (h < 0.0001) break;\n        if (t > 10.0) break;\n        t += h;\n    }\n    if (t > 10.0) t = inf;\n    return t;\n}\n\nvec3 calc_normal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - u_resolution.xy / 2.0) / min(u_resolution.x, u_resolution.y);\n\n    float r     = 5.0;\n    float theta = 2.0*M_PI * (u_mouse.x / u_resolution.x - 0.25);\n    float phi   = 0.5*M_PI * (u_mouse.y / u_resolution.y + 0.000001);\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ro = ta + r * vec3(sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 rd = normalize(vec3(uv.x*uu + uv.y*vv + 1.0*ww));\n\n    vec3 col = vec3(0.0);\n\n    float t = cast_ray(ro, rd);\n    if (t < inf - 1.) {\n        vec3 p = ro + t * rd;\n        vec3 norm = calc_normal(p);\n\n        vec3 c = vec3(1.0);\n\n        vec3  sun1_dir = normalize(vec3(1.0, 2.0, 3.0));\n        float sun1_dif = clamp(dot(norm, sun1_dir), 0.0, 1.0);\n        float sun1_sha = step(inf - 1.0, cast_ray(p, sun1_dir));\n\n        vec3  sun2_dir = normalize(vec3(-1.0, 2.0, -3.0));\n        float sun2_dif = clamp(dot(norm, sun2_dir), 0.0, 1.0);\n        float sun2_sha = step(inf - 1.0, cast_ray(p, sun2_dir));\n\n        col = c * clamp(0.6 * (sun1_sha * sun1_dif + sun2_sha * sun2_dif), 0.05, 0.90);\n    }\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2BRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 171, 171, 264], [266, 266, 292, 292, 374], [376, 376, 402, 402, 527], [529, 529, 551, 551, 966], [968, 968, 1008, 1008, 1247], [1249, 1249, 1278, 1278, 1495], [1497, 1497, 1552, 1552, 2834]], "test": "untested"}
{"id": "wsBfzd", "name": "Psychedelic Spaceships", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wdBBzd]\"Space Debris\"[/url] shader.", "tags": ["raymarching"], "likes": 4, "viewed": 326, "published": 3, "date": "1590609917", "time_retrieved": "2024-07-30T21:04:41.673128", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += (p3, p3.yxz+3.1+sin(p3.x+p3.y+p3.z)/60.0);\n    return fract((p3.xxy*sin(p3.x*10.0) + p3.yxx*cos(p3.x*10.0))*p3.zyx);\n\n}\n\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/15.0;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint-vec3(0.0,0.0,iTime)*5.0;\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/10.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 533, 708], [712, 712, 746, 746, 808], [811, 1051, 1085, 1123, 1224], [1226, 1647, 1738, 1738, 2044], [2059, 2313, 2378, 2378, 2510], [2512, 2601, 2630, 2630, 2940], [2942, 3434, 3574, 3574, 4164], [4166, 4536, 4621, 4621, 5379], [5381, 5708, 5757, 5792, 5923], [5925, 5925, 5982, 5982, 6854]], "test": "untested"}
{"id": "wdBBzd", "name": "Space Debris", "author": "jarble", "description": "It's an infinite field of randomly-colored flickering particles, generated by a modified hash function.", "tags": ["raymarching", "hash"], "likes": 3, "viewed": 329, "published": 3, "date": "1590605941", "time_retrieved": "2024-07-30T21:04:42.478973", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += (p3, p3.yxz+3.1+sin(p3.x+p3.y+p3.z)/70.0);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint+vec3(0.0,0.0,iTime);\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/10.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 533, 678], [682, 682, 716, 716, 778], [781, 1021, 1055, 1093, 1190], [1192, 1613, 1704, 1704, 2010], [2025, 2279, 2344, 2344, 2476], [2478, 2567, 2596, 2596, 2906], [2908, 3400, 3540, 3540, 4130], [4132, 4502, 4587, 4587, 5345], [5347, 5674, 5723, 5758, 5889], [5891, 5891, 5948, 5948, 6820]], "test": "untested"}
{"id": "tsSBzd", "name": "Colorful bubbles", "author": "jarble", "description": "This is similar to my \"Iridescent bubbles\" shader, but the 3D hash function is slightly modified.", "tags": ["raymarching", "hash"], "likes": 1, "viewed": 313, "published": 3, "date": "1590605229", "time_retrieved": "2024-07-30T21:04:43.317731", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += (p3, p3.yxz+10.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint+vec3(0.0,0.0,iTime);\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/10.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 533, 655], [657, 703, 730, 730, 877], [880, 880, 914, 914, 976], [979, 1219, 1253, 1291, 1388], [1390, 1811, 1902, 1902, 2208], [2223, 2477, 2542, 2542, 2674], [2676, 2765, 2794, 2794, 3104], [3106, 3598, 3738, 3738, 4328], [4330, 4700, 4785, 4785, 5543], [5545, 5872, 5921, 5956, 6087], [6089, 6089, 6146, 6146, 7018]], "test": "untested"}
{"id": "wdSfRd", "name": "texture interpolation behavior", "author": "ttg", "description": "See Description", "tags": ["texture", "filter", "linear"], "likes": 2, "viewed": 689, "published": 3, "date": "1590603363", "time_retrieved": "2024-07-30T21:04:44.191395", "image_code": "/*\n\nBe careful when interpolating sRGB textures:\n OpenGL doesn't know the encoding, and interpolates linearly.\n\nHW filtering: OpenGL texture(...) behavior\nSW filtering: GLSL code for interpolating fetched values (see Common)\nConversion: sRGB to linear\n\nTop to bottom:\n- Conversion after HW filtering\n- Conversion after SW filtering\n- Conversion before SW filtering\n- HW filtering of linear buffer\n- SW filtering of linear buffer\n\n*/\n\nvoid mainImage( out vec4 fv, in vec2 fc )\n{\n  vec3 v;\n  vec2 u = fc/iResolution.xy;\n\n  vec2 m = (iMouse.x==0.)?vec2(0):iMouse.xy/iResolution.xy-.5;\n  vec2 uv = vec2(u.x/32.,0.)+vec2(.24,.136)+.1*m;\n\n  if      (u.y>.8) v = srgb_to_linear(texture(iChannel1, uv).rgb);\n  else if (u.y>.6) v = srgb_to_linear(textureLinear(iChannel1, uv).rgb);\n  else if (u.y>.4) v = textureLinearConv(iChannel1, srgb_to_linear, uv).rgb;\n  else if (u.y>.2) v = texture(iChannel0, uv*512./iResolution.xy).rgb;\n  else             v = textureLinear(iChannel0, uv*512./iResolution.xy).rgb;\n\n  fv.a=1.; fv.rgb = srgb_from_linear(v);\n  if(length(mod(u,.2))<.005) fv = vec4(0,1,0,0);\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// BEGIN Linear Filtering Shim https://www.shadertoy.com/view/tssXWf\nconst struct SAMPLERINDEX_T {\n  int iChannel0, iChannel1, iChannel2, iChannel3;\n} SAMPLERINDEX = SAMPLERINDEX_T(0,1,2,3);\n\nvec4 textureLinearPix (sampler2D sampler, vec2 U) {\n  return mix(mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,0),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,0),0),\n    fract((U).x)),mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,1),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,1),0),\n    fract((U).x)),fract((U).y));\n}\n\n#define textureLinear(sampler,P) textureLinearPix(sampler, \\\n    (P)*iChannelResolution[SAMPLERINDEX.sampler].xy-vec2(.5))\n// END Linear Filtering Shim\n\n#define textureLinearPixConv(sampler, conv, U) (         \\\n  mix(mix(                                               \\\n      (conv(texelFetch(sampler,ivec2(U)+ivec2(0,0),0))), \\\n      (conv(texelFetch(sampler,ivec2(U)+ivec2(1,0),0))), \\\n    fract((U).x)),mix(                                   \\\n      (conv(texelFetch(sampler,ivec2(U)+ivec2(0,1),0))), \\\n      (conv(texelFetch(sampler,ivec2(U)+ivec2(1,1),0))), \\\n    fract((U).x)),fract((U).y))                          \\\n  )\n\n#define textureLinearConv(sampler,conv,P) \\\n  textureLinearPixConv(sampler,conv, \\\n    (P)*iChannelResolution[SAMPLERINDEX.sampler].xy-vec2(.5))\n\n// BEGIN sRGB/linear conversion\n// Adapted from\n// https://www.shadertoy.com/view/4tXcWr\n// By https://www.shadertoy.com/user/Tynach\nvec3 srgb_from_linear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, cutoff);\n}\n\nvec3 srgb_to_linear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n\nvec4 srgb_to_linear(vec4 sRGBA)\n{\n    return vec4(srgb_to_linear(sRGBA.rgb), sRGBA.a);\n}\n// END sRGB/linear conversion\n", "buffer_a_code": "void mainImage( out vec4 fv, in vec2 fc )\n{\n    ivec2 fi = ivec2(fc);\n    fv=srgb_to_linear(texelFetch(iChannel1, fi, 0));\n}\n", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 434, 477, 477, 1090]], "test": "untested"}
{"id": "tsBfRd", "name": "Iridescent bubbles", "author": "jarble", "description": "This \"iridescent\" shimmering effect was created using a 3D hash function.", "tags": ["raymarching", "hash"], "likes": 2, "viewed": 375, "published": 3, "date": "1590602011", "time_retrieved": "2024-07-30T21:04:44.990259", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint+vec3(0.0,0.0,iTime);\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/500.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 533, 658], [660, 706, 733, 733, 880], [883, 883, 917, 917, 979], [982, 1222, 1256, 1294, 1391], [1393, 1814, 1905, 1905, 2211], [2226, 2480, 2545, 2545, 2677], [2679, 2768, 2797, 2797, 3107], [3109, 3601, 3741, 3741, 4331], [4333, 4703, 4788, 4788, 5546], [5548, 5875, 5924, 5959, 6090], [6092, 6092, 6149, 6149, 7022]], "test": "untested"}
{"id": "wdBfRd", "name": "Rings and Lines", "author": "Tezza48", "description": "Made for my website background.", "tags": ["rings", "lines", "voronoise"], "likes": 3, "viewed": 383, "published": 3, "date": "1590601914", "time_retrieved": "2024-07-30T21:04:46.187059", "image_code": "// Remove for just the noise\n#define SWEEP\n\n// Hash without Sine 2 - https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n// -\t-\t-\t-\t-\t-\t-\t-\n\nfloat calcVoro31(vec3 p)\n{\n    vec3 cellPos = fract(p);\n    vec3 cellId = floor(p);\n    \n    float len = 2.0;\n    \n    for (int z = -1; z < 2; z++)\n    for (int y = -1; y < 2; y++)\n    for (int x = -1; x < 2; x++)\n    {\n        vec3 offs = vec3(x, y, z);\n        len = min(len, length(cellPos + offs - hash33(cellId - offs)));\n    }\n    \n    return len;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    float timeScale = 20.0f;\n    \n    vec3 p = vec3(uv, iTime / timeScale);\n    \n    float res;\n    float voro = calcVoro31(p * 3.0);\n    \n    res += voro;\n    \n    //res = cla(res, 0.3);\n    res *= 2.0;\n    \n    res = abs(res - 0.4);   \n    \n    res = smoothstep(0.02, 0.025, res);\n    \n    col.rgb = mix(vec3(0.9, 0.9, 0.9), vec3(0.2, 0.4, 0.6),res);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 285, 285, 366], [368, 368, 389, 389, 476], [498, 498, 524, 524, 853], [855, 855, 912, 912, 1419]], "test": "untested"}
{"id": "tdSfRd", "name": "Flickering crystals", "author": "jarble", "description": "The scene's geometry is generated by a hash function, so it appears to \"flicker.\"", "tags": ["raymarching", "hash"], "likes": 4, "viewed": 299, "published": 3, "date": "1590599266", "time_retrieved": "2024-07-30T21:04:47.055737", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/100000.0))-sin(length(p))/3.0;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint+vec3(0.0,0.0,iTime);\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/500.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 475, 533, 658], [660, 706, 733, 733, 880], [883, 883, 917, 917, 982], [985, 1225, 1259, 1297, 1394], [1396, 1817, 1908, 1908, 2214], [2229, 2483, 2548, 2548, 2680], [2682, 2771, 2800, 2800, 3110], [3112, 3604, 3744, 3744, 4334], [4336, 4706, 4791, 4791, 5549], [5551, 5878, 5927, 5962, 6093], [6095, 6095, 6152, 6152, 7025]], "test": "untested"}
{"id": "wdSfzt", "name": "ordered dithering web palette", "author": "bgeradz", "description": "Inspired by https://www.shadertoy.com/view/4lcyzn\n\nUsing web palette with 6 values per color channel giving 216 colors.\nFirst closest and second closest color search is O(1), no loops.\nDoesn't use any YUV conversion. RGB only.\n", "tags": ["dithering"], "likes": 2, "viewed": 502, "published": 3, "date": "1590594606", "time_retrieved": "2024-07-30T21:04:47.819694", "image_code": "// Inspired by https://www.shadertoy.com/view/4lcyzn\n\n// TODO: divide by 16\nconst float threshold16[16] = float[16](\n    0., 8., 2., 10., \n    12., 4., 14., 6.,\n    3.,11.,1.,9.,\n    15.,7.,13., 5.\n);\n\n// TODO: floats, divide by 64\nconst int threshold64[64] = int[64](\n    0, 48, 12, 60, 3, 51, 15, 63,\n    32, 16, 44, 28, 35, 19, 47, 31,\n    8,  56, 4,  52, 11, 59, 7,  55,\n    40, 24, 36, 20, 43, 27, 39, 23,\n    2,  50, 14, 62, 1,  49, 13, 61,\n    34, 18, 46, 30, 33, 17, 45, 29,\n    10, 58, 6,  54, 9,  57, 5,  53,\n    42, 26, 38, 22, 41, 25, 37, 21\n);\n\n// use 8x8 or 4x4 threshold matrix\nconst bool is64 = true;\n\n// Quantize to 6 values per color channel\n// Byte values: 0, 51, 102, 153, 204, 255\n// eventually converted to range 0..1\nfloat quantizeFloor(float value) {\n    return (floor(value * 5.0) * 51.0) / 255.0;\n}\nfloat quantizeCeil(float value) {\n    return (ceil(value * 5.0) * 51.0) / 255.0;\n}\nfloat quantizeRound(float value) {\n    return (round(value * 5.0) * 51.0) / 255.0;\n}\n\n\n// value 0..1\nbool choose(int x, int y, float value) {\n    float t;\n    if (is64) {\n        t = float(threshold64[8*y+x]) / 64.;\n    } else {\n        t = threshold16[4*y+x] / 16.;\n    }\n    \n    return value < t;\n}\n\n\n// use monochrome palette\nvec3 palMonochrome(int x, int y, vec3 rgbColor) {\n    // https://en.wikipedia.org/wiki/Luma_(video)\n    float lum = dot(vec3(0.2126, 0.7152, 0.0722), rgbColor.rgb);\n    \n    float value = choose(x, y, lum) ? 0. : 1.;\n    return vec3(value);\n}\n\n// Use web palette (part of gif default palette).\n// 6 color values per channel, total of 216 colors.\nvec3 palWeb(int x, int y, vec3 rgbColor) {\n    // Two closest colors.\n    vec3 qFloor = vec3(\n        quantizeFloor(rgbColor.r),\n        quantizeFloor(rgbColor.g),\n        quantizeFloor(rgbColor.b)\n    );\n\n    vec3 qCeil = vec3(\n        quantizeCeil(rgbColor.r),\n        quantizeCeil(rgbColor.g),\n        quantizeCeil(rgbColor.b)\n    );\n\t\n    \n    float r = choose(x, y, (rgbColor.r - qFloor.r) / (qCeil.r - qFloor.r))\n        ? qFloor.r : qCeil.r;\n    \n    float g = choose(x, y, (rgbColor.g - qFloor.g) / (qCeil.g - qFloor.g))\n        ? qFloor.g : qCeil.g;\n    \n    float b = choose(x, y, (rgbColor.b - qFloor.b) / (qCeil.b - qFloor.b))\n        ? qFloor.b : qCeil.b;\n    \n    return vec3(r, g, b);\n}\n    \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n\n    // https://en.wikipedia.org/wiki/Ordered_dithering\n   \tint x = int(fragCoord.x) % (is64 ? 8 : 4);\n    int y = int(fragCoord.y) % (is64 ? 8 : 4);\n    \n    // vec3 paletteColor = palMonochrome(x,y, col.rgb);\n    vec3 paletteColor = palWeb(x,y, col.rgb);\n \n\t// Output to screen\n\tfragColor = vec4(paletteColor, 1.);\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[618, 740, 774, 774, 824], [825, 825, 858, 858, 907], [908, 908, 942, 942, 992], [995, 1009, 1049, 1049, 1209], [1212, 1238, 1287, 1337, 1480], [1482, 1584, 1626, 1653, 2285], [2292, 2292, 2347, 2397, 2795]], "test": "untested"}
{"id": "wsSBzt", "name": "In the Vortex of Spiky Things", "author": "Roninkoi", "description": "Quick doodle. Kind of makes me think of the ocean. SPIKENUM scales the number of spikes.", "tags": ["tunnel", "twister", "lattice", "spiky"], "likes": 1, "viewed": 368, "published": 3, "date": "1590590126", "time_retrieved": "2024-07-30T21:04:48.604595", "image_code": "#define SPIKENUM 1.0\n\n#define PI 3.14159265\n#define MAXIT 200\n#define EPSILON 0.08\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n \nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a, vec2 s)\n{\n\tr = rotY(r.y * sin(t * 2.)) * r;\n\tr = rotZ(atan(r.x, r.y) * (sin(t) * 1. + 1.) * SPIKENUM) * r;\n\tr = rotX(atan(r.y, r.z) * (sin(t) * 1. + 1.) * SPIKENUM) * r;\n\t\n    vec3 p = (abs(r) - a);\n\t\n    return length(max(p, 0.));\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n\tobj = mat3(1.);\n\tr.z += t * 15.;\n\t\n\tvec3 tr = rotZ(-2.*t) * vec3(3., 3., 0.);\n\tr.x += tr.x;\n\tr.y += tr.y - 10.;\n\t\n    vec3 rb1 = obj * r;\n\trb1 = rotZ(r.z*0.1) * r;\n    \n    vec2 b1 = vec2(\n        box(rotX(2. * t) * rotY(2. * t) * (mod(rb1 + 5., 10.) - 5.), vec3(1.5, 2., 1.) * 1.2, r.xy),\n        (rotX(2. * t) * rotY(2. * t) * (mod(rb1 + 5., 10.) - 5.)).z\n    );\n\n    \n    return b1;\n}\n \nvec3 matCol(vec2 o)\n{\n    if (o.y == 1.)\n        return normalize(vec3(0.7, 0.05, .1));\n    \n    return normalize(vec3(0.7, 0.05, sin(o.y) * 0.2));\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = -iTime * 0.4;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 10.0, -20.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(0.0, 1.0, 1.0);\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.0311, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.7 - 0.01 * hash(uv);\n\t\tr += rd * d.x * 0.3;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.5)\n\t\tcol.rgb *= exp(-sh * 1.3 + 1.);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 203, 203, 305], [308, 308, 328, 328, 432], [435, 435, 455, 455, 557], [571, 571, 602, 602, 630], [633, 633, 662, 662, 736], [739, 739, 776, 776, 804], [806, 806, 838, 838, 940], [942, 942, 962, 962, 1034], [1036, 1036, 1071, 1071, 1295], [1298, 1298, 1328, 1328, 1383], [1386, 1386, 1428, 1428, 1468], [1481, 1481, 1499, 1499, 1892], [1895, 1895, 1916, 1916, 2044]], "test": "untested"}
{"id": "tsBfRt", "name": "multicenters bispirale 102 chars", "author": "FabriceNeyret2", "description": "reference: [url]https://cdn.futura-sciences.com/buildsv6/images/mediumoriginal/b/b/f/bbf7f1f5c8_50163809_parcdeladistance-precht-3.jpg[/url]", "tags": ["short", "onetweet", "golf", "spirale"], "likes": 16, "viewed": 400, "published": 3, "date": "1590589130", "time_retrieved": "2024-07-30T21:04:49.388500", "image_code": "//  ---------- readable commented version at bottom\n\n// ---  -3 by iapafoto\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = u+u - R;\n    O = .5 - cos( 58.6* length( U/R.y+ (U.x>U.y?.265:-.265) )) + O*0.; }  /*\n // O += .5 - cos( 58.6* length( U/R.y+ (U.x>-U.y?.265:-.265) * vec2(1,-1) ))  /*\n\n\n\n\n\n// --- 105 chars\n\n#define mainImage(O,u)                               \\\n    vec2  R = iResolution.xy,                        \\\n          U = ( u+u - R ) / R.y;                     \\\n    U +=   U.x> U.y ? .265:-.265;                    \\\n /* U += ( U.x>-U.y ? .265:-.265 ) * vec2(1,-1); * /  \\\n     O += .5 - cos( 58.6* length(U) )               /* \n\n\n\n\n\n// --- 122 chars\n\n#define mainImage(O,u)                                \\\n    vec2  R = iResolution.xy,                         \\\n          U = ( u+u - R ) / R.y * mat2(1,-1,1,1)/1.4; \\\n    U.x += sign(U.y)*.375;                            \\\n    O += .5 - cos( 58.6* length(U) )                 /* \n\n\n\n\n\n// --- 135 chars\n\n#define mainImage(O,u)                          \\\n    vec2  R = iResolution.xy,                   \\\n          U = ( u+u - R ) / R.y                 \\\n             * mat2(cos(-.75+vec4(0,11,33,0))); \\\n    U.x += sign(U.y)*.375;                      \\\n    O += .5 - cos( 58.6* length(U) )           /* \n\n\n\n\n\n// --- 194 chars ---------- readable commented version\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y                // normalized coordinates\n             * mat2(cos(-.75+vec4(0,11,33,0))); // rot\n    float N = 7.,                               // number of row between poles\n          Z = 3., l;                            // scale\n          \n    U.x += sign(U.y)/8.*Z;                      // spiral = 1/2 circle + offset\n    l = cos( 4.*N*6.28* length(U)/Z );          // circles\n    O = vec4( .5 - l / fwidth(l) );             // antialiased strips\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 113, 113, 239]], "test": "untested"}
{"id": "3dSfzt", "name": "Belvedere", "author": "dr2", "description": "Even penguins get confused by Escher's architecture", "tags": ["illusion", "escher", "artwork", "penguin", "building", "paradox"], "likes": 25, "viewed": 504, "published": 3, "date": "1590568808", "time_retrieved": "2024-07-30T21:04:50.431710", "image_code": "// \"Belvedere\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1  // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrFlatCyl2Df (vec2 p, float rhi, float rlo);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, vuDir, vuPln;\nfloat dstFar, tCur, fAng;\nint idObj;\nconst int idFlr = 1, idPil = 2, idBal = 3, idFrz = 4, idRf = 5, idLBld = 6, idLad = 7,\n   idGrnd = 8, idStr = 9, idWal = 10, idPen = 20;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat PengDf (vec3 p, float szFac, float rot, int isSit, float dMin)\n{\n  vec3 q;\n  float d, dh;\n  dMin /= szFac;\n  p /= szFac;\n  if (isSit > 0) p.y -= 1.25;\n  else p.y -= 1.55;\n  q = p;\n  q.y -= 0.5;\n  d = PrSphDf (q, 2.5);\n  if (d < dMin) {\n    p.xz = Rot2D (p.xz, rot);\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n    q.y -= 1.5;\n    dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n    DMINQ (idPen + 1);\n    q = p;\n    q.yz -= vec2 (1.6, -0.6);\n    d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n    DMINQ (idPen + 2);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = PrSphDf (q, 0.15);\n    DMINQ (idPen + 3);\n    q = p;\n    q.x = abs (q.x);\n    if (isSit > 0) {\n      q.xy -= vec2 (0.6, -1.05);\n      q.yz = Rot2D (q.yz, -0.5 * pi);\n      q.y -= -0.6;\n    } else {\n      q.xy -= vec2 (0.4, -0.8);\n    }\n    d = PrCylDf (q.xzy, 0.12, 0.7);\n    DMINQ (idPen + 4);\n    q -= vec3 (0.1, -0.67, -0.4);\n    q.xz = Rot2D (q.xz, -0.07 * pi);\n    d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, 0.15 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, -0.3 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    DMINQ (idPen + 5);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (1.1, 0.3, -0.2);\n    q.yz = Rot2D (q.yz, -0.25 * pi);\n    q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n    d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n    DMINQ (idPen + 6);\n  } else dMin = min (dMin, d);\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat StairDf (vec3 p, float st, float w, float h)\n{\n  return 0.7 * max ((st + p.y - p.z - abs (mod (p.y + p.z, 2. * st) - st) / sqrt(2.)),\n     max (abs (p.x) - w, max (abs (p.y) - h, abs (p.z) - h)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, wb, len, wid, b, ds;\n  dMin = dstFar;\n  len = 4.;\n  wid = 1.;\n  b = 0.1;\n  wb = 0.4 * b;\n  q = p;\n  q.y -= (vuDir.y > 0.) ? 1.2 : -3.;\n  q.xz = (vuDir.y > 0.) ? q.xz : q.zx;\n  d = PrBoxDf (q, vec3 (wid + 1.5 * b, 0.1, len + 1.5 * b));\n  DMINQ (idFlr);\n  if (vuDir.y > 0.) {\n    q = p;\n    q.y -= 4.4;\n    d = abs (q.z) - (len + 1.5 * b);\n    q.z = mod (q.z + (1./3.) * len + 0.05, (2./3.) * len + 0.1) - (1./3.) * len - 0.05;\n    d = max (d, min (max (max (length (vec2 (q.yz)) - (1./3.) * len , length (q.xy) - wid - b) - 0.1,\n       0.3 - q.y), min (PrCylDf ((q - vec3 (0., 1.3, 0.)).xzy, 0.07 * (1. - 1.3 * (q.y - 1.3)), 0.35),\n       PrCylDf ((q - vec3 (0., 1.5, 0.)).xzy, 0.15, 0.03))));\n    DMIN (idRf);\n    q = p;\n    q.y = (abs (q.y - 2.4) - 1.8) * sign (q.y - 2.4);\n    d = max (PrBoxDf (q, vec3 (wid + wb, 0.5, len + wb)), - PrBox2Df (q.xz, vec2 (wid, len) - wb));\n    d = max (d, - PrFlatCyl2Df (vec2 (q.x, q.y + 0.4), wid - b - 0.7, 0.8));\n    d = max (d, - PrFlatCyl2Df (vec2 (mod (q.z + (1./3.) * len, (2./3.) * len) -\n       (1./3.) * len, q.y + 0.4), (1./3.) * len - b - 0.7, 0.8));\n    DMIN (idFrz);\n  } else {\n    q = p;\n    q.y -= -4.5;\n    d = PrBoxDf (q, vec3 (len + b, 1.4, wid + b));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (- len - b, 0.3, 0.)).yzx, 0.2, 0.6, 0.4), 0.2 - q.y));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (0.5, 0.3, - wid - b)).yxz, 0.2, 0.6, 0.4), 0.2 - q.y));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (3., -0.3, - wid - b)).yxz, 0.7, 0.5, 0.4), -0.8 - q.y));\n    d = min (d, PrBoxDf (q - vec3 (- len - b, -0.5, - wid - b - 0.5), vec3 (0.35, 0.2, 0.4)));\n    DMINQ (idLBld);\n    q = p - vec3 (-2.7, -4.1, -2.3);\n    d = StairDf (q, 0.25, 1., 1.2);\n    DMINQ (idStr);\n    q = p - vec3 (-9., -5.5, -5.);\n    d = PrBoxDf (q, vec3 (8.1, 0.4, 6.3));\n    DMINQ (idGrnd);\n    q = p - vec3 (-1., -4.7, -6.);\n    d = PrBoxDf (q, vec3 (0.1, 0.4, 5.2));\n    DMINQ (idWal);\n    q = p - vec3 (-7., -4.7, 1.2);\n    d = PrBoxDf (q, vec3 (9., 0.4, 0.1));\n    DMINQ (idWal);\n  }\n  q = p;\n  q.y -= (vuDir.y > 0.) ? 1.7 : -2.5;\n  q.xz = (vuDir.y > 0.) ? q.xz : q.zx;\n  d = max (PrBoxDf (q, vec3 (wid + wb, 0.4, len + wb)), - PrBox2Df (q.xz, vec2 (wid, len) - wb));\n  d = max (d, - PrBoxDf (q - vec3 (- wid, 0., ((vuDir.y > 0.) ? 0. : - (2./3.) * len)),\n     vec3 (0.2, 0.5, (1./3.) * len)));\n  d = max (d, - max (PrFlatCyl2Df (vec2 (q.y, mod (mod (q.z + (1./3.) * len, (2./3.) * len) -\n     (1./3.) * len + 0.2, 0.4) - 0.2), 0.17, 0.13), abs (q.z) - (len - 0.9 * b)));\n  d = max (d, - PrFlatCyl2Df (vec2 (q.y, mod (q.x + 0.2, 0.4) - 0.2), 0.17, 0.13));\n  DMIN (idBal);\n  if (vuDir.y > 0.) {\n    q = p;\n    d = max (abs (q.y - 3.) - 1.8, PrBox2Df (vec2 (abs (q.x) - wid,\n       abs (abs (q.z) - (2./3.) * len) - (1./3.) * len), vec2 (b)));\n    DMIN (idPil);\n  }\n  q = p;\n  q = vec3 (abs (q.x) - wid, q.y + 0.5, abs (abs (q.z) - 2. * len / 3.) - len / 3.);\n  d = max (PrBox2Df (q.xz, vec2 (b)), abs (q.y) - 1.6);\n  if (vuDir.y < 0.) d = max (d, - dot (q, vuPln));\n  DMIN (idPil);\n  q = p;\n  q = vec3 (abs (abs (q.x) - 2. * len / 3.) - len / 3., q.y + 1.1, abs (q.z) - wid);\n  d = max (PrBox2Df (q.xz, vec2 (b)), abs (q.y) - 2.);\n  if (vuDir.y > 0.) d = max (d, dot (q, vuPln));\n  DMIN (idPil);\n  q = p;\n  q.xy -= (vuDir.y > 0.) ? vec2 (-1.3, 1.) : vec2 (-2.39, -2.);\n  d = abs (q.y) - ((vuDir.y > 0.) ? 1.3 : 2.7);\n  q.xy = Rot2D (q.xy, 0.1 * pi);\n  d = max (d, PrBox2Df (vec2 (q.x, abs (q.z) - ((vuDir.y > 0.) ? 0.3 : 0.28)), vec2 (0.05)));\n  ds = (vuDir.y > 0.) ? max (PrCylDf (vec3 (q.x, mod (q.y + 0.1, 0.4) - 0.21, q.z), 0.03, 0.3),\n     abs (q.y + 1.) - 2.2) : max (PrCylDf (vec3 (q.x, Rot2D (vec2 (mod (q.y + 0.15, 0.4) - 0.2, q.z),\n     -0.019 * pi * (q.y + 0.9))), 0.03, 0.3), abs (q.y - 1.) - 2.2);\n  d = min (d, ds);\n  DMIN (idLad);\n  q = p - vec3 (-4.1, -4.8, -1.7);\n  dMin = PengDf (q, 0.3, 0.45 * pi, 1, dMin);\n  q = p - ((vuDir.y > 0.) ? vec3 (-0.6, 1.3, 0.9) : vec3 (-2.5, -2.9, -0.9));\n  dMin = PengDf (q, 0.35, ((vuDir.y > 0.) ? 0.6 * pi : 0.), 0, dMin);\n  q = p - ((vuDir.y > 0.) ? vec3 (0.3, 1.3, -3.3) : vec3 (3.3, -2.9, -0.3));\n  dMin = PengDf (q, 0.35, ((vuDir.y > 0.) ? 0. : -0.3 * pi), 0, dMin);\n  q = p - vec3 (-3., -5.1, -6.8);\n  q.z = (abs (q.z) - 1.33) * sign (q.z);\n  dMin = PengDf (q, 0.4, 0.7 * pi, 0, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.6 + 0.4 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec4 PengCol (vec3 p)\n{\n  vec4 col4;\n  if (idObj == idPen + 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n     vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.15, 0.15, 0.2, 0.1);\n  else if (idObj == idPen + 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n  else if (idObj == idPen + 3) col4 = vec4 (0.05, 0.15, 0.05, 0.2);\n  else if (idObj == idPen + 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n  else if (idObj == idPen + 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n  else if (idObj == idPen + 6) col4 = vec4 (0.25, 0.25, 0.3, 0.1);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec3 bgCol)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, ao;\n  fAng = -0.2 * pi + 0.15 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (8. * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idFlr) col4 = (vn.y > -0.99) ? vec4 (0.9, 0.85, 0.85, 0.1) :\n       vec4 (1., 0.3, 0., 0.2);\n    else if (idObj == idBal) col4 = vec4 (0.6, 0.3, 0.1, 0.2);\n    else if (idObj == idLBld) col4 = (abs (qHit.x) < 3.8 && abs (qHit.z) < 0.8) ?\n       vec4 (0., 0., 0.4, 0.) : vec4 (0.85, 0.8, 0.8, 0.2);\n    else if (idObj == idLad) col4 = vec4 (0.95, 0.95, 1., 0.2);\n    else if (idObj == idGrnd) col4 = vec4 (0.7, 0.8, 0.7, 0.1) *\n       (1. - 0.2 * abs (dot (floor (mod (0.75 * qHit.xz, 2.)), vec2 (1., -1.))));\n    else if (idObj == idWal) col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n    else if (idObj == idPil) col4 = vec4 (1., 0.8, 0.2, 0.1);\n    else if (idObj == idStr) col4 = (abs (qHit.x) > 0.85) ? vec4 (0.9, 0.85, 0.85, 0.2) :\n       vec4 (0.6, 0.7, 0.6, 0.1);\n    else if (idObj == idRf) col4 = vec4 (1., 0.3, 0., 0.2);\n    else if (idObj == idFrz) col4 = vec4 (0.9, 0.5, 0., 0.2);\n    else if (idObj > idPen) col4 = PengCol (ro);\n    if (idObj == idLBld || idObj == idFlr || idObj == idWal) vn = VaryNf (16. * ro, vn, 0.5);\n    ao = (idObj != idLad) ? ObjAO (ro, vn) : 1.;\n    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col *= ao;\n  } else {\n    col = bgCol;\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvec3 BgCol (vec2 uv)\n{\n  return (uv.y + 0.05 < 0.05 * Fbm1 (32. * uv.x)) ? mix (mix (vec3 (0.3, 0.5, 0.3),\n     vec3 (0.2, 0.5, 0.2), smoothstep (0.4, 0.6, Fbm2 (256. * uv))),\n     vec3 (0.85, 0.85, 1.) * (1. - 0.05 * Fbm1 (128. * uv.x)),\n     smoothstep (-0.1, -0.01, uv.y + 0.05)) : mix (vec3 (0.7, 0.7, 0.8), vec3 (0.4, 0.4, 1.),\n     uv.y + 0.05);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, bgCol, vx, vy;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.25 * pi;\n  el = 0.;\n  if (false && mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  ro = vec3 (0., - 1.5 * sign (uv.y), -10.);\n  ro.yz = Rot2D (ro.yz, - el);\n  ro.xz = Rot2D (ro.xz, - az);\n  rd = normalize (- ro);\n  vuDir = rd;\n  vx = normalize (vec3 (vuDir.z, 0., - vuDir.x));\n  vy = vec3 (0., 1., 0.) - vuDir.y * vuDir;\n  vuPln = vy;\n  zmFac = 0.15;\n  dstFar = 30.;\n  ltDir = normalize (vec3 (-0.5, 0.7, -1.));\n  bgCol = BgCol (uv);\n  if (max (abs (uv.x), abs (uv.y)) < 0.98) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (ro + vec3 (uvv.x * vx + uvv.y * vy) / zmFac, rd, bgCol);\n    }\n  } else if (abs (uv.x) < 1.) {\n    uv = abs (uv) - 0.97;\n    col = vec3 (0.8, 0.7, 0.2) * (0.5 + 0.5 * smoothstep (0., 0.03, max (uv.x, uv.y)));\n  } else col = vec3 (0.75);\n  if (false && mPtr.z > 0. && length (uv) < 0.01) col *= 0.5;\n  fragColor = vec4 (col, 1);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrFlatCyl2Df (vec2 p, float rhi, float rlo)\n{\n  return length (p - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSfzt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1056, 1056, 1126, 1126, 2826], [2828, 2828, 2880, 2880, 3032], [3034, 3034, 3056, 3056, 7376], [7378, 7378, 7411, 7411, 7594], [7596, 7596, 7617, 7617, 7872], [7874, 7874, 7906, 7906, 8109], [8111, 8111, 8134, 8134, 8652], [8654, 8654, 8701, 8701, 10280], [10282, 10282, 10304, 10304, 10635], [10637, 10637, 10693, 10693, 12198], [12200, 12200, 12232, 12232, 12332], [12334, 12334, 12367, 12367, 12456], [12458, 12458, 12491, 12491, 12518], [12520, 12520, 12562, 12562, 12613], [12615, 12615, 12674, 12674, 12764], [12766, 12766, 12817, 12817, 12883], [12885, 12885, 12920, 12920, 12982], [12984, 12984, 13029, 13029, 13132], [13134, 13134, 13191, 13191, 13274], [13276, 13276, 13306, 13306, 13419], [13453, 13453, 13477, 13477, 13530], [13532, 13532, 13556, 13556, 13668], [13670, 13670, 13695, 13695, 13841], [13843, 13843, 13868, 13868, 14054], [14056, 14056, 14078, 14078, 14232], [14234, 14234, 14255, 14255, 14410], [14412, 14412, 14441, 14441, 14653], [14655, 14655, 14694, 14694, 14874]], "test": "untested"}
{"id": "wdjBRc", "name": "Boognish", "author": "Plento", "description": "A tribute to my favorite band, Ween. \nreferenc: https://www.etsy.com/hk-en/listing/603115407/ween-boognish-decal-sticker-11\nsum songs\nhttps://www.youtube.com/watch?v=rc9mECebRxc\nhttps://www.youtube.com/watch?v=_F39uC9IlI0&list=PL52E61FD2D160DBCB&index=11\n", "tags": ["2d", "logo", "band", "recreation", "ween", "boognish"], "likes": 12, "viewed": 663, "published": 3, "date": "1590556480", "time_retrieved": "2024-07-30T21:04:51.190681", "image_code": "// A tribute to Ween //\n// By Plento\n\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat dist(vec2 uv){\n    float d = 999.;\n    uv.y += .07;\n    \n    vec2 p0 = vec2(uv.x*.9+sin(uv.y*1.)*.2, .88*uv.y-pow(uv.x, 2.)); // hair\n    vec2 p1 = vec2((uv.x-.004)*.813+cos(uv.y*15.)*.01,uv.y+sin(uv.x*15.)*.01)-vec2(0.,-.15); // head\n    vec2 p3 = vec2(abs(uv.x)-.16, uv.y+cos(uv.x*32. + 2.)*.008); // eyes\n    vec2 p4 = uv-vec2(0., -.48+exp(-uv.x*uv.x)*.3); // mouth\n    \n    float hair = abs(length(p0)- (.45-abs(cos(atan(uv.y, uv.x)*7.))*.16))-.02;\n    hair = max(hair, -(length(vec2(uv.x*.4, uv.y-.04)-vec2(0., -.5))-.51));\n    \n    d = min(abs(length(p1)-.29)-.0086, hair); // head\n    d = min(d, min(abs(length(p3)-.03)-.0002,abs(length(p3)-.001)-.001)); // eyes\n    d = min(d, abs(box(p4, vec2(.26, .12))) - 0.001); // mouth\n    \n    float teeth = 999.;\n    for(float i = 0.; i < 10.;i++){\n     \tteeth = min(teeth, line(uv, vec2(-.25+i*.05+sin(i*2.)*.01, -.5), \n                                vec2(-.25+i*.05+cos(i*5.)*.016, .5)));}\n    teeth = max(teeth, box(p4, vec2(.26, .12)));\n   \n    return min(d, teeth);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = 1.3*vec2(u.xy - .5*R.xy)/R.y;\n    uv*=1.-pow(cos(length(uv*8.) + iTime)*0.2, 2.);\n    \n    vec3 col = vec3(0);\n    \n    float d = dist(uv);\n    float thk = .008;\n    \n    col += .6+.32*cos(vec3(.5, .2, .4)*d*80.-iTime*2.+vec3(4.7, 0., 2.));\n    col *= ss(thk, thk+.006, d);\n    \n    col *= ss(1.55, .1, length(uv));\n    f = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 151, 151, 270], [271, 271, 305, 305, 385], [387, 387, 407, 407, 1415], [1417, 1417, 1457, 1457, 1812]], "test": "untested"}
{"id": "ws2fz3", "name": "Periodic + Smooth Decomposition", "author": "blackle", "description": "decomposition of an image into a periodic component and a smooth component. aims to remove the cross artifact in the DFT of an image\n\nsee: http://helios.mi.parisdescartes.fr/~moisan/papers/download.php?file=2009-11r.pdf", "tags": ["fft", "fourier", "dft", "decomposition"], "likes": 9, "viewed": 554, "published": 3, "date": "1590551204", "time_retrieved": "2024-07-30T21:04:52.092270", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nivec2 map(vec2 p) {\n    return ivec2(iChannelResolution[1].x*(fract(p)*.5 + .25));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*2.;\n    vec4 data = texture(iChannel0, uv);\n    vec4 london = texelFetch(iChannel1, map(uv),0);\n\n    vec3 original = london.xyz;\n    vec3 smooth_comp = data.xyz/data.w;\n    vec3 periodic_comp = original - smooth_comp;\n    \n    //flip between the original and the periodic component\n    fragColor.xyz=mix(original, periodic_comp, smoothstep(.2,-.2,cos(iTime*2.)));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//buf A calculates the smooth component of the periodic+smooth decomposition\n//see: http://helios.mi.parisdescartes.fr/~moisan/papers/download.php?file=2009-11r.pdf\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec2 rand_unit(float seed) {\n    float h1 = hash(seed, 4375893.44353);\n    float h2 = hash(seed, h1);\n    return normalize(tan(vec2(h1,h2))); //see https://www.shadertoy.com/view/3djyWW for an explination of this trick\n}\n\n//distance from p to the edges of a box with verticies at (0,0) and (1,1)\nfloat borders(vec2 p) {\n    p = .5-abs(p-.5);\n    return min(p.x,p.y);\n}\n\n//gradient of the above distance function\nvec2 borders_grad(vec2 p) {\n    p -= .5;\n    return abs(p.x) > abs(p.y) ? vec2(sign(p.x),0.) : vec2(0.,sign(p.y));\n}\n\n//map coordinate in box to cropped portion of london image\n//cropped because the boundaries of the original image are not good (fades to black on one edge, white on another)\n//also does wrapping\nivec2 map(vec2 p) {\n    return ivec2(iChannelResolution[1].x*(fract(p)*.5 + .25));\n}\n\n//random walk on spheres. see: https://www.shadertoy.com/view/WsXBzl\nvec3 rWoS(vec2 p, float seed) {\n    float res = iChannelResolution[1].x;\n    for (int i = 0; i < 100; i++) {\n        seed = hash(seed, seed);\n        vec2 dir = rand_unit(seed);\n        float dist = borders(p);\n        if (dist < .5/res) break;\n        p += dir*dist;\n    }\n    //boundary conditions are the difference between the colour of the image boundy\n    //and the colour of the opposite boundary, divided by 2. this is so when we\n    //subtract this from the original image, boundaries will share the same colour\n    vec3 sample_inside = texelFetch(iChannel1, map(p), 0).xyz;\n    vec3 sample_outside = texelFetch(iChannel1, map(p+borders_grad(p)/res), 0).xyz;\n    return (sample_inside-sample_outside)/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iFrame == 0) {\n        fragColor = vec4(0);\n\t}\n    if (texelFetch(iChannel1, ivec2(0), 0).x == 0.) return; //skip if iChannel1 is not loaded\n    vec2 uv = fragCoord/iResolution.xy;\n    float seed = hash(hash(uv.x, uv.y), float(iFrame));\n    fragColor += vec4(rWoS(uv, seed), 1.);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2fz3.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 213, 213, 278], [280, 280, 337, 337, 741]], "test": "untested"}
{"id": "wdjfz3", "name": "Flaming Webcam 5 (artdeco)", "author": "tomachi", "description": "cover the camera and boom. ", "tags": ["webcammultipass"], "likes": 4, "viewed": 956, "published": 3, "date": "1590544066", "time_retrieved": "2024-07-30T21:04:52.924046", "image_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define melting(g) texture(iChannel1, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define brightness 1.0001\n#define yellow vec4(0.9,0.8,0.5,0.)\n#define blackwhite vec4(1.,1.,1.,0.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \t\n    vec2 xy = fragCoord;\n    vec4 webcam = camchan(xy)*vec4(1.1);\n    vec4 melt = vec4(\n        abs(melting(xy).x)*0.025,\n        abs(melting(xy).y)*0.025,\n        abs(melting(xy).z)*0.025,\n        0.\n        );\n    vec4 presh = tex(xy);\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    float texbright = (melt.r + melt.g + melt.g) * 0.333;\n    float lumens = (webcam.r + webcam.g + webcam.g) * 0.333;\n    pressure = abs(presh.w);\n    vec4 waves = sin(tex(fragCoord).w * yellow);\n  // fragColor = herbivore + (webcam * vec4(r, g, b, 1.)) + vec4(r*brightness, g*brightness, b*brightness, 1.); //  * vec4(1.0);\n\t//fragColor = webcam  + sin(tex(fragCoord).w * blackwhite);\n    // webcam *= (lumens / pressure);\n  \n    \n    waves *= (pressure / 3.);\n\n    fragColor = melt + webcam +  waves;  \n\n\n\n\n   \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lightpressure 0.03\n#define brightness 3.99\n#define count 20\n#define radius 0.943\n#define emitSize 0.950\n#define force 0.99\n#define constraint 0.91\n#define effect 0.99\n#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n\n// v => coord x,y / s => dir\n// v => coord x,y / d => diam\n// https://github.com/aiekick/NoodlesPlate/blob/master/fluid.glsl\n//NoodlesPlate widgets\n//uniform(hidden) \tint\t\t\t(frame) \t\t\t\t\t\tuFrame;\n//uniform(hidden) \tfloat\t\t(deltatime) \t\t\t\t\tuDeltaTime;\n//uniform(hidden) \tsampler2D\t(buffer:0) \t\t\t\t\t\tbuffer;\n//uniform(hidden) \tsampler2D\t(buffer:1) \t\t\t\t\t\tbuffer1;\n//uniform(hidden) \tvec2\t\t(buffer:0) \t\t\t\t\t\tsize;\n//uniform(color) \tvec3\t\t(0:10:7.7,6.0,7.5) \t\t\t\tcolor;\n//uniform(physic) \tfloat\t\t(0.0:1.0:0.1) \t\t\t\t\tforce;\n//uniform(prism) \tfloat\t\t(0.00001:0.1:0.01) \t\t\t\tconstraint;\n//uniform(prism) \tfloat\t\t(-1.0:1.0:0.0) \t\t\t\t\teffect;\n//uniform(prism) \tfloat\t\t(0.99:1.0:1.0) \t\t\t\t\tviscosity;\n//uniform(emit) \tfloat\t\t(1.0:20.0:5.0) \t\t\t\t\temitSize;\n//uniform(emit) \tint\t\t\t(0:50:1) \t\t\t\t\t\tcount;\n//uniform(emit) \tfloat\t\t(0.0:0.5:0.3) \t\t\t\t\tradius;\n//uniform(emit) \tfloat\t\t(checkbox:true) \t\t\t\temit;\n//uniform(shape) \tint\t\t\t(combobox:circle,triangle,quad) shapeType;\n\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n\treturn tri;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\t\n\tvec2 xy = fragCoord.xy;\n\tvec4 webcam = camchan(xy);\n\t\n\tvec2 s = iResolution.xy;\n\tvec2 g = fragCoord;\n\t\n\tvec4 a = tex(g+vec2(1,0));// + webcam.r;\n\tvec4 b = tex(g+vec2(0,1));// + webcam.g;\n\tvec4 c = tex(g+vec2(-1,0));// + webcam.b;\n\tvec4 d = tex(g+vec2(0,-1));// + (webcam.r * -0.0125);\n\tfloat lumens = (webcam.r + webcam.g + webcam.b)*0.333;\n\tfloat presh = abs(tex(xy).z);\n\tfloat ink = abs(tex(xy).w);\n\t\n\t// fragColor = tex(g-tex(g).xy); // last state\n    vec4 tomachi = vec4(1.0001,1.0002,1.0003,0.0);\n\tfragColor = tex(g-tex(g).xy)* tomachi; // last state\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n\tvec4 left = camchan(xy+vec2(1,0)) + tex(xy+vec2(1,0));\n\tvec4 right = camchan(xy+vec2(0,1)) + tex(xy+vec2(0,1));\n\tvec4 up = camchan(xy+vec2(-1,0)) + tex(xy+vec2(-1,0));\n\tvec4 down = camchan(xy+vec2(0,-1))+ tex(xy+vec2(1,0));\n\tfloat magic = 0.25;\n\tfloat pressure = magic * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n\n    if (webcam.r > 0.2137 && webcam.g > 0.32) { // RED AND GREEN\n        emit(xy, vec2( 1.0 - webcam.r*-0.5,4.0 + webcam.g));\n\t\tmagic = 0.252;\n    }   \n    if (webcam.b > 0.37 ) { // BLUE \n        emit(xy, vec2(  webcam.g*0.5, 2.0 + (webcam.b)));\n        pressure *= (1. - (lumens*4.1) );\n\n    }\n\n\n    if (lumens > 0.4573531595) {\n        // pressure *= 1.321;\n        emit(xy, vec2(0., 4.0 + (lumens*-2.) ));\n\n    } else if (lumens > 0.3531595) {\n\t\temit(xy, vec2(-0.500, 2.0 + (lumens*-4.) ));\n        emit(xy, vec2( webcam.b - webcam.r*-0.5, (webcam.g * 2.) - lumens  ));\n            //gp.x = fragColor.x + webcam.r; // THIS CREATES A MAD EXPLOSION IN THE DARK!\n            //gp.y +=  fragColor.y + (0.5 - webcam.r*-0.25);\n        //pressure *= (1. - (lumens*0.1) );\n    }\n    if (lumens > 0.12467 ) {\n        if (pressure > 0.0005) {\n       \t\tfragColor.z *= 0.9;\n\t\t\tfragColor.w *= 0.9;\n            pressure *= 0.978;    \n            \n        } else {\n            pressure *= 0.9999;  // GOVERNOR  \n\n        }\n       // emit(xy, vec2(0.000500, 1. ));\n        emit(xy, vec2( webcam.b - webcam.r*-0.5, (webcam.g * 2.) - lumens  ));\n        \n    } else {\n      //\tpressure -= 0.5 - (lumens*0.6); // HELPS\n       \tpressure -= 0.5 - (lumens*0.5);\n\n     // \tpressure *= 0.8;\n        gp.x = fragColor.x + (0.5 + webcam.r*-1.); // THIS CREATES A MAD EXPLOSION IN THE DARK!\n   \t\tgp.y = fragColor.y + (0.5 + webcam.g*-1.); // mad flames\n    }\n\n\t\n\t\n\t//emit(xy, 0.005);\n\tif (abs(d.b) > 1.995 && abs(a.r) > 1.995) // governs over pressure condition\n\t{\n\t\tvec2 p = vec2( webcam.r, webcam.g);\n\t\tvec2 dir = vec2( webcam.g, webcam.b);\n\t\temit(xy, dir);\n\t\tpressure *= 0.95;\t\t\n\t} \n    if (g.x < 1. || g.y < 1. || g.x > s.x - 1. || g.y > s.y - 1.){\n        //fragColor.xy *= 0.;\n        pressure *= 0.9;\n    }\n\t\n   // gp.x = fragColor.x + webcam.r; // THIS CREATES A MAD EXPLOSION IN THE DARK!\n   // gp.y = fragColor.y + webcam.r;\n   // gp.y +=  fragColor.y - (1. - webcam.r*-0.5);\n    \n\tif ( abs(pressure) > 4.99310589015 || lumens > 0.8) {\n\t\tfragColor.w = abs(fragColor.z) -0.05;\n    } else {\n       \tfragColor.xyz = vec3(\n\t\tfragColor.x + gp.x + (webcam.r * 0.000099),\n\t\tfragColor.y + gp.y + (webcam.b * 0.000099),// + webcam.r,\n\t\tpressure\n\t\t); \n    }\n\n\n\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = vec2(fragCoord.x + 1., fragCoord.y + 2.);\n        \tvec4 webcam = camchan(xy);\n\n    float luma = abs(tex(xy).z); // pressure \n    float red = tex(xy).x *10.01;//    tex(xy).w; // ink \n    float green = tex(xy).y * 1.2;\n      \tfloat lumens = (webcam.r + webcam.g + webcam.b)*0.333;\n\n  //  if (lumens > 0.35) { \n //           red *= 1.2;\n//\n //   } else  {\n    //       green *= 1.2;\n   // }\n    \n     //fragColor = tex(fragCoord + vec2(0.01,1.5));\n  \n    fragColor = vec4(red, green, luma, luma);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 326, 326, 1134]], "test": "untested"}
{"id": "wdjBz3", "name": "Flaming Webcam 4 (shadowfire)", "author": "tomachi", "description": "watch your shadows catch fire! by TOMACHI \nhttp://www.funk.co.nz/", "tags": ["webcammultipassparticle"], "likes": 14, "viewed": 1226, "published": 3, "date": "1590541316", "time_retrieved": "2024-07-30T21:04:53.859545", "image_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define melting(g) texture(iChannel1, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define brightness 1.0001\n#define yellow vec4(0.9,0.8,0.5,0.)\n#define blackwhite vec4(1.,1.,1.,0.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \t\n    vec2 xy = fragCoord;\n    vec4 webcam = camchan(xy);\n    vec4 melt = vec4(\n        abs(melting(xy).x)*0.025,\n        abs(melting(xy).y)*0.025,\n        abs(melting(xy).z)*0.025,\n        0.\n        );\n    vec4 presh = tex(xy);\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    float texbright = (melt.r + melt.g + melt.g) * 0.333;\n    float lumens = (webcam.r + webcam.g + webcam.g) * 0.333;\n    pressure = abs(presh.w);\n    vec4 waves = sin(tex(fragCoord).w * yellow);\n  // fragColor = herbivore + (webcam * vec4(r, g, b, 1.)) + vec4(r*brightness, g*brightness, b*brightness, 1.); //  * vec4(1.0);\n\t//fragColor = webcam  + sin(tex(fragCoord).w * blackwhite);\n    \n    \n    webcam *= vec4(0.975);\n    if ( pressure > 5.9725 ) { \n       // fragColor = melt + (webcam*vec4(0.63))  + sin(tex(fragCoord).w * yellow);\n           //  fragColor = vec4(0.);\n        \n        if (lumens < 0.1) {\n            \n        \tfragColor = melt +  webcam  + (vec4(0.579) * waves);//+ sin(tex(fragCoord).w * blackwhite);\n        } else {\n           \tfragColor =  melt + webcam + (vec4(0.579) * waves);//+ sin(tex(fragCoord).w * blackwhite);\n\n        }\n\n    } else {\n        //fragColor = vec4(0.);\n        //fragColor = melt + (webcam*vec4(0.925)) * (sin(tex(fragCoord).w * yellow)); \n        fragColor = melt + (webcam*vec4(1.)) + (vec4(0.15) * waves);  \n        //fragColor = melt + (webcam*vec4(1.));// +(vec4(0.0015) * waves);  \n\n    }\n        //fragColor = melt + (webcam*vec4(1.))  + sin(tex(fragCoord).w * yellow);\n\n    // fragColor = melt +(webcam*vec4(1.5)) + sin(tex(fragCoord).w * blackwhite);  \n\n          // fragColor = melt;// + (webcam*vec4(0.5))  + sin(tex(fragCoord).w * blackwhite);\n\n   \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lightpressure 0.03\n#define brightness 3.99\n#define count 20\n#define radius 0.943\n#define emitSize 0.950\n#define force 0.99\n#define constraint 0.91\n#define effect 0.99\n#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n\n// v => coord x,y / s => dir\n// v => coord x,y / d => diam\n// https://github.com/aiekick/NoodlesPlate/blob/master/fluid.glsl\n//NoodlesPlate widgets\n//uniform(hidden) \tint\t\t\t(frame) \t\t\t\t\t\tuFrame;\n//uniform(hidden) \tfloat\t\t(deltatime) \t\t\t\t\tuDeltaTime;\n//uniform(hidden) \tsampler2D\t(buffer:0) \t\t\t\t\t\tbuffer;\n//uniform(hidden) \tsampler2D\t(buffer:1) \t\t\t\t\t\tbuffer1;\n//uniform(hidden) \tvec2\t\t(buffer:0) \t\t\t\t\t\tsize;\n//uniform(color) \tvec3\t\t(0:10:7.7,6.0,7.5) \t\t\t\tcolor;\n//uniform(physic) \tfloat\t\t(0.0:1.0:0.1) \t\t\t\t\tforce;\n//uniform(prism) \tfloat\t\t(0.00001:0.1:0.01) \t\t\t\tconstraint;\n//uniform(prism) \tfloat\t\t(-1.0:1.0:0.0) \t\t\t\t\teffect;\n//uniform(prism) \tfloat\t\t(0.99:1.0:1.0) \t\t\t\t\tviscosity;\n//uniform(emit) \tfloat\t\t(1.0:20.0:5.0) \t\t\t\t\temitSize;\n//uniform(emit) \tint\t\t\t(0:50:1) \t\t\t\t\t\tcount;\n//uniform(emit) \tfloat\t\t(0.0:0.5:0.3) \t\t\t\t\tradius;\n//uniform(emit) \tfloat\t\t(checkbox:true) \t\t\t\temit;\n//uniform(shape) \tint\t\t\t(combobox:circle,triangle,quad) shapeType;\n\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n\treturn tri;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\t\n\tvec2 xy = fragCoord.xy;\n\tvec4 webcam = camchan(xy);\n\t\n\tvec2 s = iResolution.xy;\n\tvec2 g = fragCoord;\n\t\n\tvec4 a = tex(g+vec2(1,0));// + webcam.r;\n\tvec4 b = tex(g+vec2(0,1));// + webcam.g;\n\tvec4 c = tex(g+vec2(-1,0));// + webcam.b;\n\tvec4 d = tex(g+vec2(0,-1));// + (webcam.r * -0.0125);\n\tfloat lumens = (webcam.r + webcam.g + webcam.b)*0.333;\n\tfloat presh = abs(tex(xy).z);\n\tfloat ink = abs(tex(xy).w);\n\t\n\t// fragColor = tex(g-tex(g).xy); // last state\n    vec4 tomachi = vec4(1.0001,1.0002,1.0003,0.0);\n\tfragColor = tex(g-tex(g).xy)* tomachi; // last state\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n\tvec4 left = camchan(xy+vec2(1,0)) + tex(xy+vec2(1,0));\n\tvec4 right = camchan(xy+vec2(0,1)) + tex(xy+vec2(0,1));\n\tvec4 up = camchan(xy+vec2(-1,0)) + tex(xy+vec2(-1,0));\n\tvec4 down = camchan(xy+vec2(0,-1))+ tex(xy+vec2(1,0));\n\tfloat magic = 0.25;\n\tfloat pressure = magic * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n\n    if (webcam.r > 0.2137 && webcam.g > 0.32) { // RED AND GREEN\n        emit(xy, vec2( 1.0 - webcam.r*-0.5,4.0 + webcam.g));\n\t\tmagic = 0.252;\n    }   \n    if (webcam.b > 0.37 ) { // BLUE \n        emit(xy, vec2(  webcam.g*0.5, 2.0 + (webcam.b)));\n        //emit(xy, vec2( 0., -2.5 ));\n        pressure *= (1. - (lumens*4.1) );\n\n    }\n\n\n    if (lumens > 0.531595) {\n\t\temit(xy, vec2(-0.500, 2.0 + (lumens*-4.) ));\n        emit(xy, vec2( webcam.b - webcam.r*-0.5, (webcam.g * 2.) - lumens  ));\n\n        \n            //gp.x = fragColor.x + webcam.r; // THIS CREATES A MAD EXPLOSION IN THE DARK!\n            //gp.y +=  fragColor.y + (0.5 - webcam.r*-0.25);\n\n        \n         \n        \n        // pressure *= (1. - (lumens*0.1) );\n    } if (lumens > 0.2467 ) {\n        if (pressure > 0.0005) {\n       \t    //pressure *= 0.995;    \n       \t\tfragColor.z *= 0.9;\n\t\t\tfragColor.w *= 0.9;\n        } else {\n        }\n       // emit(xy, vec2(0.000500, 1. ));\n        emit(xy, vec2( webcam.b - webcam.r*-0.5, (webcam.g * 2.) - lumens  ));\n        \n    } else {\n      \tpressure -= 0.5 - (lumens*0.5);\n      \t//pressure *=  1. - (lumens * 0.51);\n\t\t//ink = lumens *-1.; \n        gp.x = fragColor.x + webcam.r; // THIS CREATES A MAD EXPLOSION IN THE DARK!\n   \t\tgp.y = fragColor.y + (0.5 + webcam.r*-0.25);\n    }\n\n\t\n\t\n\t//emit(xy, 0.005);\n\tif (abs(d.b) > 1.995 && abs(a.r) > 1.995) // governs over pressure condition\n\t{\n\t\tvec2 p = vec2( webcam.r, webcam.g);\n\t\tvec2 dir = vec2( webcam.g, webcam.b);\n\t\temit(xy, dir);\n\t\tpressure *= 0.95;\t\t\n\t} \n    if (g.x < 1. || g.y < 1. || g.x > s.x - 1. || g.y > s.y - 1.){\n        fragColor.xy *= 0.;\n        pressure *= 0.9;\n    }\n\t\n   // gp.x = fragColor.x + webcam.r; // THIS CREATES A MAD EXPLOSION IN THE DARK!\n   // gp.y = fragColor.y + webcam.r;\n   // gp.y +=  fragColor.y - (1. - webcam.r*-0.5);\n    \n\tif ( pressure > 4.99310589015 || lumens > 0.8) {\n\t\tfragColor.w = abs(fragColor.z) -0.05;\n    } else {\n       \tfragColor.xyz = vec3(\n\t\tfragColor.x + gp.x + (webcam.r * 0.000099),\n\t\tfragColor.y + gp.y + (webcam.b * 0.000099),// + webcam.r,\n\t\tpressure\n\t\t); \n    }\n\n\n\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = vec2(fragCoord.x + 1., fragCoord.y + 2.);\n//    fragColor = tex(fragCoord + vec2(0.01,1.5));\n    float luma = abs(tex(xy).z); // pressure \n    float red = tex(xy).x *10.01;//    tex(xy).w; // ink \n    float green = tex(xy).y * 1.2;\n    fragColor = vec4(red, green, luma, luma);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 326, 326, 2023]], "test": "untested"}
{"id": "td2BR3", "name": "Day 159 [twitch]", "author": "jeyko", "description": "coded on evvvvil's stream", "tags": ["mdtmjvm"], "likes": 7, "viewed": 331, "published": 3, "date": "1590537246", "time_retrieved": "2024-07-30T21:04:54.949630", "image_code": "vec3 glow = vec3(0);\n\nvec3 glowb = vec3(0);\n\nvec3 att = vec3(1);\n\nfloat sdBox(vec3 p, vec3 s){\n  p = abs(p) - s;\n  return max(p.y,max(p.z,p.x));\n\n}\n\n#define dmin(a,b) a.x < b.x ? a :b\n  \n#define T iTime\n  \n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nvec2 map(vec3 p){\n  vec2 d = vec2(10e6);\n  \n  vec4 q = vec4(p,1);\n  \n  \n  float dpp = dot(q.xyz,q.xyz);\n  q /= dpp;  \n  \n  q.xy += sin(T)/5.;\n  \n  \n  for(int i = 0; i <13; i++){\n    float dpp = dot(q.xyz,q.xyz);\n    q = abs(q)/dpp - vec4(0.22,0.2,0.1,0);\n    \n    q.xy *= rot(0.4+sin(T)/2000.);    \n    \n  }\n  float b = sdBox(q.xyz,vec3(1.4,3.4,1.1)*q.w/4.);\n  float bb = sdBox(q.xyz-vec3(-.2,0.,0.5),vec3(1.9,3.4,1.1)*q.w/2.);\n  \n  float bc = sdBox(q.xyz-vec3(0.04,0.2,0.5),vec3(1.9,1.4,3.1));\n  \n  \n  //glowb += exp(-abs(bc)*20.);\n  \n  \n  d = dmin(d, vec2(b, 2.));\n  d = dmin(d, vec2(bb, 1.));\n  \n  glow += 0.02/(0.2+d.x*d.x*4.);\n  \n  d.x *= 0.2/q.w;\n  \n  return d;\n}\n\nvec3 getNormal(vec3 p){\n  vec2 t = vec2(0.001,0.);\n  return normalize(map(p).x - vec3(\n    map(p-t.xyy).x,\n    map(p-t.yxy).x,\n    map(p-t.yyx).x\n  ));\n}\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 col = vec3(0);\n  \n  vec3 ro = vec3(0,1.5,4.)*4.;\n  \n  vec3 lookAt = vec3(0);\n  \n  vec3 dir = normalize(lookAt - ro);\n  vec3 right = normalize(cross(vec3(0,1,0),dir));\n  vec3 up= normalize(cross(dir, right));\n  \n  vec3 rd = normalize(dir + right*uv.x+ up*uv.y);\n  \n  \n  \n  \n  vec3 p = ro; float t =0.; bool hit = false;\n  vec2 d;\n  for(int j = 0; j <1;j ++){\n  \n    for(int i = 0; i <290;i ++){\n      d = map(p);\n      if(d.x < 0.001){\n        hit = true;\n        break;\n      }\n      t += d.x;\n      p += rd*d.x;\n    }\n  }\n  \n   \n    #define AO(j) smoothstep(0.,1.,map(p+n*j).x/j)\n  vec3 l = normalize(vec3(1,-1,1));\n  if(hit ){\n    vec3 n = getNormal(p);\n    float fres = pow(1.- max(dot(n,-rd),0.),5.);\n    float antifres = smoothstep(0.,1.,(1.-fres)*0.4);\n    float diff = max(dot(n,l),0.);\n    if(d.y == 1.){\n      col +=  AO(0.3)*AO(0.04)*antifres*306.* ( 0.4*(diff+0.4)*fres)*glow*pal(0.5,0.5,vec3(1,0.2,0.1),1., length(p) + T);\n    }\n    if(d.y == 2.){\n      col += 0.1*diff*glow*pal(0.5,0.5,vec3(1,0.2,0.1),1., length(p) + T+4.);\n    }\n  \n  } else {\n  \t//col += glow*1000.2001;\n    col += 0.2*pal(0.5,0.5,vec3(1.,0.4,0.1),1.,length(uv)+T);\n    //col += glow*0.004*att;\n  }\n    //col += glow;\n  \n  col *= 1. - dot(uv,uv)*0.7;\n  //col += glowb;\n  \n  col = max(col,0.);\n  col = pow(col,vec3(0.45454));\n  fragColor = vec4(col,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2BR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 94, 94, 147], [258, 258, 275, 275, 927], [929, 929, 952, 952, 1082], [1129, 1129, 1186, 1186, 2667]], "test": "untested"}
{"id": "Ws2Bzc", "name": "Raymarching with random colors", "author": "jarble", "description": "I used a hash function to color the surface of this raymarched 3D object.", "tags": ["raymarching", "hash"], "likes": 3, "viewed": 314, "published": 3, "date": "1590532569", "time_retrieved": "2024-07-30T21:04:56.002815", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    \n    float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(samplePoint, 1.2);\n    \n    float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);\n    float ballRadius = 0.3;\n    float balls = sphereSDF(samplePoint - vec3(ballOffset, 0.0, 0.0), ballRadius);\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(ballOffset, 0.0, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, 0.0, ballOffset), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, 0.0, ballOffset), ballRadius));\n    \n    \n    \n    float csgNut = differenceSDF(intersectSDF(cube, sphere),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n    \n    return unionSDF(balls, csgNut);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/500.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2Bzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 452, 474, 532, 657], [659, 705, 732, 732, 879], [881, 927, 954, 954, 1101], [1103, 1149, 1176, 1176, 1323], [1325, 1416, 1462, 1462, 1494], [1496, 1580, 1622, 1622, 1654], [1656, 1745, 1792, 1792, 1825], [1827, 1935, 1968, 1968, 2398], [2400, 2487, 2521, 2521, 2549], [2551, 2668, 2713, 2782, 3388], [3390, 3630, 3664, 3703, 5052], [5054, 5475, 5566, 5566, 5872], [5887, 6141, 6206, 6206, 6338], [6340, 6429, 6458, 6458, 6768], [6770, 7262, 7402, 7402, 7992], [7994, 8364, 8449, 8449, 9249], [9251, 9578, 9627, 9662, 9793], [9795, 9795, 9852, 9852, 10744]], "test": "untested"}
{"id": "WsjBzc", "name": "Colored triangle", "author": "bela333", "description": "A triangle with 5 beautiful colors\nMade in collaboration with @vlams1", "tags": ["triangle", "code", "golf", "codegolf", "colroed", "nyelvtan"], "likes": 1, "viewed": 284, "published": 3, "date": "1590529813", "time_retrieved": "2024-07-30T21:04:56.827609", "image_code": "void mainImage(out vec4 o,vec2 d) {\n    o = vec4(1,0,.5,0);\n    vec2 u = (.5*iResolution.xy-d)/iResolution.y+o.yz;\n    o = 1.-sign(u.y-.866*length(u))*vec4[](o.xxxx,o.zzzx,o.xxyx,o.yyxx,o.yxxx)[int(u.y*5.)];\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Wdjfz3", "name": "Simple Egg - distance 2D", "author": "iq", "description": "Distance to an egg shape (a base circle of radius ra, a tip circle of radius rb, and two circles connecting both). It is not general enough since the height could be a parameter as well by just changing the connection points between circles.", "tags": ["2d", "sdf", "distance", "egg"], "likes": 18, "viewed": 2199, "published": 3, "date": "1590521248", "time_retrieved": "2024-07-30T21:04:57.726207", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple generaliztion of sylvain69780's shader \"Moss's EGG\":\n// https://www.shadertoy.com/view/wsBBR3\n//\n// This is also a special case of the Vesica primitive, in particular\n// this egg is just half a vesica with a circle attached at its end\n// https://www.shadertoy.com/view/XtVfRW\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and https://iquilezles.org/articles/distfunctions2d\n\n\nfloat sdEgg( in vec2 p, in float he, in float ra, in float rb )\n{\n    float ce = 0.5*(he*he-(ra-rb)*(ra-rb))/(ra-rb);\n\n    p.x = abs(p.x);\n\n    if( p.y<0.0 )             return length(p)-ra;\n    if( p.y*ce-p.x*he>he*ce ) return length(vec2(p.x,p.y-he))-rb;\n                              return length(vec2(p.x+ce,p.y))-(ce+ra);\n}\n\nfloat sdLineV( in vec2 p, in float b ) { p.y -= clamp( p.y, 0.0, b ); return length( p ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    p.y += 0.35;\n    m.y += 0.35;\n\n    // animation\n    vec2 cen = vec2(0.0,0.0);\n    float he = 0.7 + 0.3*cos(iTime*1.0+0.0);\n    float ra = 0.5;\n    float rb = 0.2;\n    float al = smoothstep( -0.5, 0.5,sin(iTime+0.1) );\n        \n    // distance\n    float d = sdEgg(p-cen, he, ra, rb);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-7.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(90.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,1.5*px,abs(d)-0.005) );\n\n    // draw primitive parameters\n    d = abs( sdLineV(p-cen,he));\n    d = min( d, abs(length(p)-ra) );\n    d = min( d, abs(length(p-vec2(0.0,he))-rb) );\n    d -= 0.003;\n\tcol = mix( col, vec3(0.0,1.0,1.0), al*(1.0-smoothstep(0.0,1.5*px,d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdEgg(m-cen, he, ra, rb);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjfz3.jpg", "access": "api", "license": "mit", "functions": [[1505, 1505, 1570, 1570, 1834], [1836, 1836, 1876, 1876, 1927], [1929, 1929, 1986, 2022, 3224]], "test": "untested"}
{"id": "WsjBR3", "name": "Cracked Bell", "author": "dr2", "description": "The bell that tolls no more", "tags": ["lighting", "corona", "godray", "fracture"], "likes": 13, "viewed": 345, "published": 3, "date": "1590514451", "time_retrieved": "2024-07-30T21:04:58.570948", "image_code": "// \"Cracked Bell\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos;\nfloat tCur, dstFar, bHt, bRd, crkOff;\nint idObj;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat CrkFun (vec3 p)\n{\n  vec3 e;\n  vec2 cs, w;\n  float s;\n  s = 1.;\n  e = normalize (p);\n  if (e.y > -0.21 * pi && e.y < 0.2 * pi) {\n    s = 1. - smoothstep (0., 0.22 * pi, e.y);\n    cs = sin (0.07 * pi * e.y + 0.2 * s * (Fbm1 (4. * pi * e.y + crkOff) - 0.5) + vec2 (0.5 * pi, 0.));\n    w = vec2 (abs (dot (p.xz, vec2 (cs.x, - cs.y))), p.z);\n    s = length (max (w, 0.)) - 0.02 * s;\n  }\n  return s;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, c;\n  dMin = dstFar;\n  q = p;\n  r = bRd;\n  r *= (1. - 0.7 * smoothstep (-0.6 * bHt, bHt + r, q.y) - 0.3 * smoothstep (- bHt, -0.4 * bHt, q.y));\n  c = 0.1 * (0.1 + 0.9 * smoothstep (- bHt, -0.8 * bHt, q.y));\n  r -= c - 0.1;\n  d = max (abs (PrCapsDf (q.xzy, r, bHt)) - c, - bHt - q.y);\n  d = max (d, - CrkFun (q));\n  DMIN (1);\n  q = p;\n  q.y -= bHt + 0.7;\n  d = PrTorusDf (q, 0.1, 0.3);\n  DMIN (2);\n  q = p;\n  q.y -= - bHt - 0.2;\n  q.xz = abs (q.xz) - 0.7 * bRd;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  d = PrBoxDf (q, vec3 (0.3, 0.2, 0.4));\n  DMIN (3);\n  d = p.y + bHt + 0.4;\n  DMIN (4);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 BallHit2 (vec3 ro, vec3 rd, float rad)\n{\n  vec3 u;\n  vec2 d2;\n  float b, d;\n  u = ro;\n  b = dot (rd, u);\n  d = b * b + rad * rad - dot (u, u);\n  d2 = vec2 (dstFar, dstFar);\n  if (d > 0.) {\n    d = sqrt (d);\n    d2 = vec2 (- b - d, - b + d);\n  }\n  return d2;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += clamp (2. * h, 0.02, 0.3);\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat CrkGlo (vec3 u)\n{\n  float t;\n  t = asin (u.y / length (u));\n  return clamp (2. * Fbm1 (128. * t - 5. * tCur + 2. * sin (t * pi * tCur)) - 0.5, 0., 1.);\n}\n\nfloat LabSym (vec2 p)\n{\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, col, vn, u, ltDir;\n  vec2 db2;\n  float dstObj, pDotR, r, rLo, rHi, sh, att, locLit, tLit;\n  bHt = 2.;\n  bRd = 2.4;\n  tLit = SmoothBump (0.25, 0.75, 0.15, mod (0.1 * tCur, 1.)) * (0.9 + 0.3 * Fbm1 (16. * tCur));\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    locLit = 0.;\n    if (idObj == 1) {\n      col4 = 1.3 * mix (vec4 (0.4, 0.2, 0.1, 0.2), vec4 (0.37, 0.27, 0.1, 0.3),\n         smoothstep (0.45, 0.55, Fbm3 (4. * ro)));\n      if (dot (vn.xz, ro.xz) > 0.) col4.rgb *= (1. - 0.2 * SmoothBump (-0.3, 0.3, 0.02, ro.y + 0.28)) *\n         (1. + 0.5 * smoothstep (-0.05, 0., LabSym (4. *\n         vec2 (mod (8. * atan (ro.z, - ro.x) / (2. * pi) + 0.5, 1.) - 0.5, 0.8 * (ro.y + 0.5)))));\n    } else if (idObj == 2) {\n      col4 = vec4 (0.5, 0.2, 0., 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.4, 0.3, 0.2, 0.1);\n    } else if (idObj == 4) {\n      r = length (ro.xz);\n      col4 = vec4 (0.2, 0.2, 0.25, 0.) * (0.95 + 0.05 * sin (2. * pi * r)) *\n         (0.8 + 0.2 * smoothstep (-0.2, 0., r - bRd));\n      locLit = 1. - smoothstep (-0.1, 0.5, r - bRd);\n      if (smoothstep (0., 0.1, CrkFun (ro)) < 1.) \n         locLit = max (2. * CrkGlo (ro) / (1. + dot (ro, ro)), locLit);\n    }\n    vn = VaryNf (32. * ro, vn, 0.5);\n    ltDir = normalize (ltPos);\n    att = 0.1 + 0.9 * smoothstep (0.97, 0.995, dot (normalize (ltPos - ro), ltDir));\n    sh = min (att, ObjSShadow (ro + 0.01 * vn, ltDir, length (ltPos - ro)));\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col += 0.6 * vec3 (1., 1., 0.5) * locLit * tLit;\n  } else {\n    col = vec3 (0.02);\n  }\n  pDotR = - dot (roo, rd);\n  rLo = 1.5;\n  rHi = 5.;\n  locLit = 0.;\n  for (float sd = float (VAR_ZERO); sd < 1.6; sd += 1. / 120.) {\n    att = 2. * min (1., 10. / (1. + 200. * sd * sd));\n    db2 = BallHit2 (roo, rd, rLo + (rHi - rLo) * sd);\n    if (db2.x < min (dstObj, dstFar) && db2.x < pDotR) {\n      u = roo + db2.x * rd;\n      if (smoothstep (0., 0.0012 * (db2.x - rLo), CrkFun (u)) < 1.) locLit = max (locLit, CrkGlo (u) * att);\n    }\n    if (db2.y < min (dstObj, dstFar) && db2.y > pDotR) {\n      u = roo + db2.y * rd;\n      if (smoothstep (0., 0.002 * (db2.x - rLo), CrkFun (u)) < 1.) locLit = max (locLit, CrkGlo (u) * att);\n    }\n  }\n  col = mix (col, vec3 (1., 1., 0.5), locLit * tLit);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, ltEl, ltAz, todCur;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.3 * pi * sin (0.03 * pi * tCur);\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 5.;\n  dstFar = 100.;\n  ltEl = -0.3 * pi * (1. + 0.15 * sin (0.1 * 2. * pi * tCur));\n  ltAz = pi + 0.2 * pi * cos (0.125 * 2. * pi * tCur);\n  ltPos = vec3 (0., 0., 50.);\n  ltPos.yz = Rot2D (ltPos.yz, ltEl);\n  ltPos.xz = Rot2D (ltPos.xz, ltAz);\n  crkOff = mod (floor (0.01 * todCur), 10.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (1.)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[628, 628, 651, 651, 1029], [1031, 1031, 1053, 1053, 1688], [1690, 1690, 1723, 1723, 1907], [1909, 1909, 1930, 1930, 2185], [2187, 2187, 2232, 2232, 2451], [2453, 2453, 2502, 2502, 2767], [2769, 2769, 2792, 2792, 2928], [2930, 2930, 2953, 2953, 3352], [3354, 3354, 3389, 3389, 5913], [5957, 5957, 6013, 6013, 7391], [7393, 7393, 7425, 7425, 7525], [7527, 7527, 7570, 7570, 7634], [7636, 7636, 7682, 7682, 7739], [7741, 7741, 7798, 7798, 7881], [7883, 7883, 7919, 7919, 8125], [8127, 8127, 8157, 8157, 8270], [8304, 8304, 8328, 8328, 8381], [8383, 8383, 8407, 8407, 8519], [8521, 8521, 8545, 8545, 8664], [8666, 8666, 8691, 8691, 8837], [8839, 8839, 8864, 8864, 9050], [9052, 9052, 9077, 9077, 9302], [9304, 9304, 9326, 9326, 9480], [9482, 9482, 9503, 9503, 9658], [9660, 9660, 9681, 9681, 9836], [9838, 9838, 9867, 9867, 10079], [10081, 10081, 10120, 10120, 10300]], "test": "untested"}
{"id": "3dSBWz", "name": "Inversive Kaleidoscope II", "author": "mla", "description": "Another inversive kaleidoscope. Enjoy the show or use mouse to move one of the inversion circles. For more controls, see code.", "tags": ["kaleidoscope", "inversion", "hyperbolic"], "likes": 17, "viewed": 439, "published": 3, "date": "1590510642", "time_retrieved": "2024-07-30T21:04:59.323442", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Inversive Kaleidoscope II\n// mla, 2020\n//\n// <mouse>: move free inversion circle\n// a: just animation\n// c: show circles\n// l: show lines\n// x: lock x coordinate for free circle\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int NCIRCLES = 4;\nconst float AA = 2.0;\nconst float R = 4.0;\n\nvec3 circles[NCIRCLES] =\n  vec3[](vec3(0,0,1),\n         vec3(-2,1,R),\n         vec3(2,1,R),\n         vec3(0,0,-5));\n         \nvec3 getcolor(vec2 z0, vec2 w) {\n  vec2 z = z0;\n  int i, N = 40;\n  bool found = true;\n  for (i = 0; i < N && found; i++) {\n    for (int j = 0; j < NCIRCLES; j++) {\n      found = false;\n      vec3 c = circles[j];\n      if (inside(z,c)) {\n        z = invert(z,c);\n        found = true;\n        break;\n      }\n    }\n  }\n  vec3 col = vec3(0);\n  if (i < N) col = hsv2rgb(vec3(float(i)/10.0,1,1));\n  if (!key(CHAR_L)) {\n    vec3 ccol = vec3(0);\n    for(int i = 0; i < NCIRCLES; i++) {\n      col = drawcircle(z,col,ccol,circles[i]);\n    }\n  }\n  if (!key(CHAR_C)) {\n    vec3 ccol = vec3(1);\n    for(int i = 0; i < NCIRCLES; i++) {\n      col = drawcircle(z0,col,ccol,circles[i]);\n    }\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 color = vec3(0);\n  float scale = 4.0;\n  vec2 w = vec2(0,-0.25) + vec2(0,cos(0.618*iTime));\n  if (iMouse.x > 0.0 && !key(CHAR_A)) {\n    w = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    w *= scale;\n    if (key(CHAR_X)) w.x = 0.0;\n  }\n  circles[0].xy = w;\n  circles[1].x += sin(0.5*iTime);\n  circles[2].x -= sin(0.5*iTime);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      z *= scale;\n      z.y += 1.0; w.y += 1.0;\n      color += getcolor(z,w);\n    }\n  }\n  color /= AA*AA;\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\n\nfloat kfact = 1.0;\nfloat lwidth = 0.01;\nvec3 draw(float d, vec3 col, vec3 ccol, float pwidth) {\n  col = mix(ccol,col,mix(1.0,smoothstep(-pwidth,pwidth,d-lwidth),kfact));\n  return col;\n}\n\nvec3 drawcircle(vec2 z, vec3 col, vec3 ccol, vec3 circle) {\n  float d = abs(length(z-circle.xy) - sqrt(abs(circle.z)));\n  return draw(d,col,ccol,fwidth(z.x));\n}\n\nvec3 drawline(vec2 z, vec3 col, vec3 ccol, vec2 line) {\n  float d = abs(dot(z,line));\n  return draw(d,col,ccol,fwidth(z.x));\n}\n\nvec2 invert(vec2 z, vec3 c) {\n  z -= c.xy;\n  float k = abs(c.z)/dot(z,z);\n  z *= k;\n  z += c.xy;\n  return z;\n}\n\nbool inside(vec2 z, vec3 c) {\n  z -= c.xy;\n  if (c.z < 0.0) return dot(z,z) > abs(c.z);\n  return dot(z,z) < abs(c.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 544, 576, 576, 1240], [1242, 1242, 1294, 1294, 1953]], "test": "untested"}
{"id": "tsBBz3", "name": "Hello Gradient - TBOS 2.0", "author": "stungeye", "description": "Chapter 2 - The Book of Shaders - Hello World\n\n", "tags": ["simple", "gradient", "tbos"], "likes": 1, "viewed": 395, "published": 3, "date": "1590498149", "time_retrieved": "2024-07-30T21:05:00.605015", "image_code": "// Working Through The Book of Shaders\n// Chapter 02 - Hello World - https://thebookofshaders.com/02/\n// 2.0 Hello Gradient\n\n// FUNCTION: gradient\n//\n// Color gradient based on a 2D coordinate.\n// Takes a vec2 (x, y) coordinate. Returns a vec4 (r, g, b, a) color.\nvec4 gradient(vec2 coord) {\n    // Normalized pixel coordinates (from 0 to 1) using the image \n    // dimensions pulled from vec2 iResolution.\n    vec2 uv = coord / iResolution.xy;\n  \n    // Return vec4 (r, g, b, a) with red gradated by the pixel's x coord.\n    // Green, blue, and alpha are kept constant.\n\treturn vec4(uv.x, 0.364, 0.499, 1.0);\n    \n    // Or, involve both the x and y axis:\n    // return vec4(uv.x, uv.y, 0.499, 1.0);\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n    \n    // Set the color of each pixel to a gradient based its coordinates.\n    fragColor = gradient(fragCoord);\n}\n\n\n// Stung Eye 2020 - Unlicense - https://unlicense.org\n// This is free and unencumbered software released into the public domain.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 264, 291, 406, 702], [704, 809, 953, 1030, 1069]], "test": "untested"}
{"id": "tsSBR3", "name": "Moving Glass Garden - fork", "author": "alvarobyrne", "description": "Looking at the garden through the glass block", "tags": ["glass", "green", "block", "garden"], "likes": 7, "viewed": 387, "published": 3, "date": "1590493712", "time_retrieved": "2024-07-30T21:05:01.447762", "image_code": "// Fork of \"Glass Garden\" by TAKUSAKU. https://shadertoy.com/view/3s2Bzy\n// 2020-05-26 11:46:54\n\nfloat rand (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(-0.370,0.200+0.0002*sin(iTime*0.1))))*757.161);\n}\n\nfloat noise (in vec2 _st) {\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(_st);\n    vec2 f = smoothstep(vec2(0.), vec2(0.5), fract(_st));\n    float m1 = mix(rand(b), rand(b + d.yx), f.x);\n    float m2 = mix(rand(b + d.xy), rand(b + d.yy), f.x);\n\treturn mix(m1, m2, f.x);\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.23 + 0.05 * sin(iTime*0.2);\n    float a = .5;\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5)+sin(iTime*0.01), -sin(0.5), acos(0.5));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 8.0;\n        a *= 0.32;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y) * 1.7;\n   \n    vec2 co = st;\n    co.x += 0.9*sin(iTime);\n    co.y += 4.;\n\n    float len;    \n    for (int i = 0; i < 3; i++) {\n        len = length(co);\n        co.x +=  sin(co.y + iTime * 0.620)*0.;\n        co.y +=  cos(co.x + iTime * 0.164)*0.1;\n    }\n    len -= 3.;\n     \n    vec3 col = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 1.0);\n    q.y = fbm( st + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(0.570,0.520)+ 0.16*iTime );\n    r.y = fbm( st + 1.0*q + vec2(0.340,-0.570)+ 0.1*iTime);\n    \n    for (float i = 0.; i < 3.; i++) {\n        r += 1.0 / abs(mod(st.xy+vec2(0.4*iTime,0.), 0.732* i) * 10.) * 1.;// Glass block grid\n    }\n    float f = fbm(st+r);\n    \n    col = mix(col, cos(len + vec3(0.0, 1.0, 0.3)), 1.0);\n    col = mix(vec3(0.562,0.680,0.482), vec3(0.357,0.518,0.600), col);\n    \n    fragColor = vec4(2.0*(f*f*f*f+.6*f*f+.5*f)*col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 123, 123, 211], [213, 213, 240, 240, 490], [492, 492, 518, 518, 829], [831, 831, 888, 888, 1872]], "test": "untested"}
{"id": "3dBBzc", "name": "Circle Color", "author": "ylan_go", "description": "Circle Color", "tags": ["circlecolor"], "likes": 5, "viewed": 418, "published": 3, "date": "1590488667", "time_retrieved": "2024-07-30T21:05:02.251613", "image_code": "#define PI 3.141592653589793\n\n#define NOTE(start, note, dura) if(time > start && cur_note == note) u += smoothstep(0.,0.25, time - start) - clamp(time - start - dura, 0.,1.);\n\n// adapted from <https://www.shadertoy.com/view/XdlSDs> by @dynamite\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    float a = atan(p.x,p.y);\n    float r = length(p)*0.75;\n    vec2 uv = vec2(a/(2.*PI),r);\n\t\n\t// get the color\n\tfloat xCol = 3. * mod(uv.x, 1.);\n\tvec3 horColour = vec3(0.25, 0.25, 0.25);\n\t\n\tif (xCol < 1.0) {\n\t\thorColour.r += 1. - fract(xCol);\n\t\thorColour.g += fract(xCol);\n\t} else if (xCol < 2.0) {\n\t\thorColour.g += 1. - fract(xCol);\n\t\thorColour.b += fract(xCol);\n\t} else {\n\t\thorColour.b += 1. - fract(xCol);\n\t\thorColour.r += fract(xCol);\n\t}\n\n\t// draw color beam\n\tuv = 2.*uv - 1.;\n\tfloat beamWidth = 1./abs(150.*uv.y);\n    \n    float time = iTime - 0.5;\n    int cur_note = int(2.5*uv.x + 5.);\n    \n    float u = 0.;\n    \n    NOTE(0., 2, .75);\n    NOTE(1., 4, .75);\n    NOTE(2., 3, .75);\n    NOTE(3., 0, .75);\n    NOTE(4., 1, .75);\n    \n    NOTE(7.0, 2, .15);\n    NOTE(7.2, 4, .15);\n    NOTE(7.4, 3, .15);\n    NOTE(7.6, 0, .15);\n    NOTE(7.8, 1, .15);\n    \n    NOTE(10.0, 2, .15);\n    NOTE(10.2, 4, .15);\n    NOTE(10.4, 3, .15);\n    NOTE(10.6, 0, .15);\n    NOTE(10.8, 1, .15);\n    NOTE(11.0, 2, .15);\n    NOTE(11.2, 4, .15);\n    NOTE(11.4, 3, .15);\n    NOTE(11.6, 0, .15);\n    NOTE(11.8, 1, .15);\n    NOTE(12.0, 2, .15);\n    NOTE(12.2, 4, .15);\n    NOTE(12.4, 3, .15);\n    NOTE(12.6, 0, .15);\n    NOTE(12.8, 1, .15);\n    NOTE(13.0, 2, .15);\n    NOTE(13.2, 4, .15);\n    NOTE(13.4, 3, .15);\n    NOTE(13.6, 0, .15);\n    NOTE(13.8, 1, .15);\n    \n    NOTE(16., 2, 1.5);\n    NOTE(18., 4, 1.5);\n    NOTE(20., 3, 1.5);\n    NOTE(22., 0, 1.5);\n    NOTE(24., 1, 2.5);\n    \n    if(time > 16.) u *= 2.;\n    \n    beamWidth *= 1. + 2.5*u*(1. - cos(5.*PI*uv.x));\n\tfragColor.xyz = beamWidth * horColour;\n    fragColor.w = 1.;\n}", "image_inputs": [], "sound_code": "// 2016 David A Roberts <https://davidar.io>\n\n#define PI 3.141592653589793\n\nfloat midi_freq(int m) {\n    // converts a MIDI note number to a frequency\n    // <http://en.wikipedia.org/wiki/MIDI_Tuning_Standard>\n    return 440. * pow(2., float(m-69)/12.);\n}\n\nfloat wav(float hz, float dB, float time) {\n    return 20. * pow(10., dB/10.) * (pow(sin(PI*hz*time), 2.) - 0.5);\n}\n\nfloat bombarde(float freq, float dura, float time) {\n    // magic numbers eyeballed from spectrogram of\n    // <http://www.organstops.org/b/Bombarde.html>\n    float u = 0.;\n    u += wav(freq*1., -36., time);\n    u += wav(freq*2., -26., time);\n    u += wav(freq*3., -37., time);\n    u += wav(freq*4., -41., time);\n    u += wav(freq*5., -38., time);\n    u += wav(freq*6., -29., time);\n    u += wav(freq*7., -23., time);\n    u += wav(freq*8., -21., time);\n    u += wav(freq*9., -24.5, time);\n    u += wav(freq*10., -19., time);\n    u += wav(freq*11., -28., time);\n    u += wav(freq*12., -26., time);\n    u += wav(freq*13., -27., time);\n    u += wav(freq*14., -33., time);\n    u += wav(freq*15., -32., time);\n    u += wav(freq*16., -35., time);\n    u += wav(freq*17., -34., time);\n    u += wav(freq*18., -37., time);\n    u += wav(freq*19., -26., time);\n    u += wav(freq*20., -31.5, time);\n    u += wav(freq*21., -31., time);\n    u += wav(freq*22., -32., time);\n    u += wav(freq*23., -35., time);\n    u += wav(freq*24., -35., time);\n    u += wav(freq*25., -36.5, time);\n    u += wav(freq*26., -42., time);\n    u += wav(freq*27., -46., time);\n    u += wav(freq*28., -46., time);\n    u += wav(freq*29., -42., time);\n    u += wav(freq*30., -49., time);\n    u += wav(freq*31., -41., time);\n    u += wav(freq*32., -43., time);\n    u += wav(freq*33., -54., time);\n    u += wav(freq*34., -60., time);\n    u += wav(freq*35., -55., time);\n    u += wav(freq*36., -55.5, time);\n    u += wav(freq*37., -54., time);\n    u += wav(freq*38., -56., time);\n    u += wav(freq*39., -56., time);\n    u += wav(freq*40., -60., time);\n    u *= smoothstep(0.,0.25, time) - clamp(time - dura, 0.,1.);\n    return u;\n}\n\n#define NOTE(start, midi, dura) if(time > start) u += bombarde(midi_freq(midi), dura, time - start);\n\nvec2 mainSound( in int samp, float time ) {\n    float u = 0.;\n    \n    NOTE(0., 38+12, .75);\n    NOTE(1., 40+12, .75);\n    NOTE(2., 36+12, .75);\n    NOTE(3., 24+12, .75);\n    NOTE(4., 31+12, .75);\n    \n    NOTE(7.0, 38+12, .15);\n    NOTE(7.2, 40+12, .15);\n    NOTE(7.4, 36+12, .15);\n    NOTE(7.6, 24+12, .15);\n    NOTE(7.8, 31+12, .15);\n    \n    NOTE(10.0, 38+12, .15);\n    NOTE(10.2, 40+12, .15);\n    NOTE(10.4, 36+12, .15);\n    NOTE(10.6, 24+12, .15);\n    NOTE(10.8, 31+12, .15);\n    NOTE(11.0, 38+12, .15);\n    NOTE(11.2, 40+12, .15);\n    NOTE(11.4, 36+12, .15);\n    NOTE(11.6, 24+12, .15);\n    NOTE(11.8, 31+12, .15);\n    NOTE(12.0, 38+12, .15);\n    NOTE(12.2, 40+12, .15);\n    NOTE(12.4, 36+12, .15);\n    NOTE(12.6, 24+12, .15);\n    NOTE(12.8, 31+12, .15);\n    NOTE(13.0, 38+12, .15);\n    NOTE(13.2, 40+12, .15);\n    NOTE(13.4, 36+12, .15);\n    NOTE(13.6, 24+12, .15);\n    NOTE(13.8, 31+12, .15);\n    \n    NOTE(16., 38, 1.5);\n    NOTE(18., 40, 1.5);\n    NOTE(20., 36, 1.5);\n    NOTE(22., 24, 1.5);\n    NOTE(24., 31, 2.5);\n    \n    if(time >= 16.) u *= 2.;\n    return vec2(u);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 303, 303, 1976]], "test": "untested"}
{"id": "WsSBzc", "name": "Multi Color", "author": "ylan_go", "description": "Multi Color", "tags": ["multicolor"], "likes": 1, "viewed": 270, "published": 3, "date": "1590488527", "time_retrieved": "2024-07-30T21:05:03.093362", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "tdjBR1", "name": "Volumetric lighting", "author": "tmst", "description": "- Just an experiment with lighting volumetric data\n- First pass computes light penetration to each voxel; second pass blends the result along the camera ray\n- Inputs: Mouse, ASDF (color, lighting, density, debug)", "tags": ["procedural", "clouds", "voxel", "volumetric", "nebula", "smoke"], "likes": 369, "viewed": 9153, "published": 3, "date": "1590471016", "time_retrieved": "2024-07-30T21:05:04.124605", "image_code": "// ========================\n// Marching through volume\n// ========================\n\n#define DATA(lmn) texture(iChannel0, vcubeFromLMN(2, lmn)).st\n\nvec2 getDataInterp(vec3 lmn) {\n    vec3 flmn = floor(lmn);\n\n    vec2 d000 = DATA( flmn );\n    vec2 d001 = DATA( flmn + vec3(0.0, 0.0, 1.0) );\n    vec2 d010 = DATA( flmn + vec3(0.0, 1.0, 0.0) );\n    vec2 d011 = DATA( flmn + vec3(0.0, 1.0, 1.0) );\n    vec2 d100 = DATA( flmn + vec3(1.0, 0.0, 0.0) );\n    vec2 d101 = DATA( flmn + vec3(1.0, 0.0, 1.0) );\n    vec2 d110 = DATA( flmn + vec3(1.0, 1.0, 0.0) );\n    vec2 d111 = DATA( flmn + vec3(1.0, 1.0, 1.0) );\n\n    vec3 t = lmn - flmn;\n    return mix(\n        mix(mix(d000, d100, t.x), mix(d010, d110, t.x), t.y),\n        mix(mix(d001, d101, t.x), mix(d011, d111, t.x), t.y),\n        t.z\n    );\n}\n\nvoid readLMN(in vec3 lmn, out float density, out float lightAmount) {\n    #ifdef SMOOTHING\n    \tvec2 data = getDataInterp(lmn);\n    #else\n    \tvec2 data = DATA(lmn);\n    #endif\n\n    bool noLight = texelFetch(iChannel2, ivec2(KEY_S,0), 0).x > 0.5;\n    lightAmount = noLight ? 1.0 : data.t;\n    lightAmount = mix(lightAmount, 1.0, 0.025);\n\n    // density = fDensity(iChannel1, lmn, iTime);\n    density = data.s;\n}\n\nvec4 march(vec3 p, vec3 nv, vec2 fragCoord) {\n    vec2 tRange;\n    float didHitBox;\n    boxClip(BOX_MIN, BOX_MAX, p, nv, tRange, didHitBox);\n    tRange.s = max(0.0, tRange.s);\n\n    vec4 color = vec4(0.0);\n    if (didHitBox < 0.5) {\n        return color;\n    }\n    \n    bool noColor = texelFetch(iChannel2, ivec2(KEY_A,0), 0).x > 0.5;\n\tbool noDensity = texelFetch(iChannel2, ivec2(KEY_D,0), 0).x > 0.5;\n    \n    float t = tRange.s + min(tRange.t-tRange.s, RAY_STEP)*hash12(fragCoord);\n    int i=0;\n    for (; i<150; i++) { // Theoretical max steps: (BOX_MAX-BOX_MIN)*sqrt(3)/RAY_STEP\n        if (t > tRange.t || color.a > QUIT_ALPHA) { break; }\n\n        vec3 rayPos = p + t*nv;\n        vec3 lmn = lmnFromWorldPos(rayPos);\n\n        float density;\n        float lightAmount;\n        readLMN(lmn, density, lightAmount);\n\n        vec3 cfrag = noColor ? vec3(1.0) : colormap(0.7*density+0.8);\n        density = noDensity ? 0.1 : density;\n\n        float calpha = density * MAX_ALPHA_PER_UNIT_DIST * RAY_STEP;\n        vec4 ci = clamp( vec4(cfrag * lightAmount, 1.0)*calpha, 0.0, 1.0);\n        color = blendOnto(color, ci);\n\n        t += RAY_STEP;\n    }\n\n    float finalA = clamp(color.a/QUIT_ALPHA, 0.0, 1.0);\n    color *= (finalA / (color.a + 1e-5));\n\n    bool showSteps = texelFetch(iChannel2, ivec2(KEY_F,0), 0).x > 0.5;\n    return showSteps ? vec4(vec3(float(i)/150.0), 1.0) : color;\n}\n\n// ================\n// Final rendering\n// ================\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n#define VIGNETTE_INTENSITY 0.25\n\nvec3 skybox(vec3 nvDir) {\n    return ( mix(0.1, 0.2, smoothstep(-0.2,0.2, nvDir.y)) )*vec3(1.0);\n}\n\nvec3 nvCamDirFromClip(vec3 nvFw, vec2 clip) {\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Camera\n    float isMousePressed = clamp(iMouse.z, 0.0, 1.0);\n    vec2 mouseAng = mix(\n        vec2(CAM_THETA, CAM_PHI),\n        PI * vec2(4.0*iMouse.x, iMouse.y) / iResolution.xy,\n        isMousePressed\n    );\n\n    vec3 camPos = 2.5 * SPHERICAL(mouseAng.x, mouseAng.y);\n    vec3 lookTarget = vec3(0.0);\n\n\tvec3 nvCamFw = normalize(lookTarget - camPos);\n    vec3 nvCamDir = nvCamDirFromClip(nvCamFw, uv*2. - 1.);\n\n    // Render\n    vec3 bgColor = skybox(nvCamDir);\n    vec4 fgColor = march(camPos, nvCamDir, fragCoord);\n    vec3 finalColor = blendOnto(fgColor, vec4(bgColor, 1.0)).rgb;\n\n    // Vignette\n    vec2 radv = vec2(0.5, 0.5) - uv;\n    float dCorner = length(radv) / INV_SQRT_2;\n    float vignetteFactor = 1.0 - mix(0.0, VIGNETTE_INTENSITY, smoothstep(0.4, 0.9, dCorner));\n\n    fragColor = vec4(vignetteFactor * finalColor, 1.0);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define PERFORMANCE_MODE\n\n// ==========================\n// Generic Helpers/Constants\n// ==========================\n\n// Keyboard input description: https://www.shadertoy.com/view/lsXGzf\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define INV_SQRT_2 0.7071067811865476\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\nfloat len2Inf(vec2 v) {\n    vec2 d = abs(v);\n    return max(d.x, d.y);\n}\n\nvoid boxClip(\n    in vec3 boxMin, in vec3 boxMax,\n    in vec3 p, in vec3 v,\n    out vec2 tRange, out float didHit\n){\n    //for each coord, clip tRange to only contain t-values for which p+t*v is in range\n    vec3 tb0 = (boxMin - p) / v;\n    vec3 tb1 = (boxMax - p) / v;\n    vec3 tmin = min(tb0, tb1);\n    vec3 tmax = max(tb0, tb1);\n\n    //t must be > tRange.s and each tmin, so > max of these; similar for t1\n    tRange = vec2(\n        max(max(tmin.x, tmin.y), tmin.z),\n        min(min(tmax.x, tmax.y), tmax.z)\n    );\n\n    //determine whether ray intersects the box\n    didHit = step(tRange.s, tRange.t);\n}\n\n// cf. Dave Hoskins https://www.shadertoy.com/view/4djSRW\n// -------------------------\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n// -------------------------\n\n// cf. iq https://www.shadertoy.com/view/ll2GD3\nvec3 colormap(float t) {\n    return .5 + .5*cos(TWOPI*( t + vec3(0.0,0.1,0.2) ));\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\n// ======================\n// Voxel packing helpers\n// ======================\n\n#define BOX_MIN vec3(-1.0)\n#define BOX_MAX vec3(1.0)\n#define BOX_N 128.0\n\nvec3 lmnFromWorldPos(vec3 p) {\n    vec3 uvw = (p - BOX_MIN) / (BOX_MAX - BOX_MIN);\n    return uvw * vec3(BOX_N-1.0);\n}\n\nvec3 worldPosFromLMN(vec3 lmn) {\n    return mix(BOX_MIN, BOX_MAX, lmn/(BOX_N-1.0));\n}\n\n// Data is organized into 3 \"pages\" of 128x128x128 voxels.\n// Each \"page\" takes up 2 faces of the 1024x1024 cubemap,\n// each face storing 8x8=64 of the 128x128 slices.\n\nvec3 vcubeFromLMN(in int page, in vec3 lmn) {\n    // subtexture within [0,8)^2\n    float l = mod(round(lmn.x), 128.0);\n    float tm = mod(l, 8.0);\n    float tn = mod((l - tm)/8.0, 8.0);\n    vec2 tmn = vec2(tm, tn);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(round(lmn.yz), 128.0);\n\n    // pixel position on 1024x1024 face\n    vec2 fragCoord = 128.0*tmn + mn + 0.5;\n    vec2 p = fragCoord*(2.0/1024.0) - 1.0;\n\n    vec3 fv;\n    if (page == 1) {\n        fv = vec3(1.0, p);\n    } else if (page == 2) {\n        fv = vec3(p.x, 1.0, p.y);\n    } else {\n        fv = fv = vec3(p, 1.0);\n    }\n\n    if (l < 64.0) {\n        return fv;\n    } else {\n        return -fv;\n    }\n}\n\nvoid lmnFromVCube(in vec3 vcube, out int page, out vec3 lmn) {\n    // page and parity, and pixel position on 1024x1024 texture\n    vec2 p;\n    float parity;\n    if (abs(vcube.x) > abs(vcube.y) && abs(vcube.x) > abs(vcube.z)) {\n        page = 1;\n        p = vcube.yz/vcube.x;\n        parity = vcube.x;\n    } else if (abs(vcube.y) > abs(vcube.z)) {\n        page = 2;\n        p = vcube.xz/vcube.y;\n        parity = vcube.y;\n    } else {\n        page = 3;\n        p = vcube.xy/vcube.z;\n        parity = vcube.z;\n    }\n    vec2 fragCoord = floor((0.5 + 0.5*p)*1024.0);\n\n    // mn within [0,128)^2\n    vec2 mn = mod(fragCoord, 128.0);\n\n    // subtexture within [0,8)^2\n    vec2 tmn = floor(fragCoord/128.0);\n\n    float lAdd;\n    if (parity > 0.0) {\n        lAdd = 0.0;\n    } else {\n        lAdd = 64.0;\n    }\n    lmn = vec3(tmn.y*8.0 + tmn.x + lAdd, mn);\n}\n\n// ===================\n// Density definition\n// ===================\n\n#define MAX_ALPHA_PER_UNIT_DIST 10.0\n#define QUIT_ALPHA 0.99\n#define QUIT_ALPHA_L 0.95\n\n#ifdef PERFORMANCE_MODE\n    #define RAY_STEP 0.035\n    #define RAY_STEP_L 0.05\n#else\n\t#define RAY_STEP 0.025\n    #define RAY_STEP_L 0.025\n\t#define SMOOTHING\n#endif\n\n#define CAM_THETA (0.2*iTime)\n#define CAM_PHI (HALFPI - 0.2)\n#define LIGHT_POS (0.9*POLAR(CAM_THETA+PI*0.15) + vec3(0.0, 2.0, 0.0))\n\n// cf. iq https://www.shadertoy.com/view/4sfGzS\nfloat noise(sampler2D randSrc, vec3 x) {\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( randSrc, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(sampler2D randSrc, vec3 p) {\n    p *= 0.6;\n    float v = noise(randSrc, p);\n\n    p *= 0.3;\n    v = mix(v, noise(randSrc, p), 0.7);\n\n    p *= 0.3;\n    v = mix(v, noise(randSrc, p), 0.7);\n\n    return v;\n}\n\nfloat fDensity(sampler2D randSrc, vec3 lmn, float t) {\n    t += 32.0;\n    \n    // Current position adjusted to [-1,1]^3\n    vec3 uvw = (lmn - vec3(63.5))/63.5;\n\n    // Value used to offset the main density\n    float d2 = fbm(randSrc,\n\t\tvec3(0.6, 0.3, 0.6)*lmn +\n\t\tvec3(0.0, 8.0*t, 0.0)\n\t);\n\n    // Main density\n    float d1 = fbm(randSrc,\n        0.3*lmn +\n        vec3(0.0, 4.0*t, 0.0) +\n        5.0*vec3( cos(d2*TWOPI), 2.0*d2, sin(d2*TWOPI) )\n    );\n    d1 = pow(d1, mix( 4.0, 12.0, smoothstep(0.6,1.0,len2Inf(uvw.xz)) ));\n\n    // Tweak density curve\n    float a = 0.02;\n    float b = 0.08;\n    return 0.02 + 0.2*smoothstep(0.0, a, d1) + 0.5*smoothstep(a, b, d1) + 0.18*smoothstep(b, 1.0, d1);\n}\n", "cube_a_code": "// ==========================\n// Store density on \"page 1\"\n// ==========================\n\nvec4 doPage1(vec3 lmn) {\n    return vec4(fDensity(iChannel1, lmn, iTime), 1.0, 1.0, 1.0);\n}\n\nvec4 getPage1(vec3 lmn) {\n    bool isInit = iFrame < 5;\n    return isInit ? doPage1(lmn) : texture(iChannel0, vcubeFromLMN(1, lmn));\n}\n\n// ===========================\n// Store lighting on \"page 2\"\n// ===========================\n\nfloat march(vec3 p, vec3 nv) {\n    float lightAmount = 1.0;\n\n    vec2 tRange;\n    float didHitBox;\n    boxClip(BOX_MIN, BOX_MAX, p, nv, tRange, didHitBox);\n    tRange.s = max(0.0, tRange.s);\n\n    if (didHitBox < 0.5) {\n        return 0.0;\n    }\n\n    float t = tRange.s + min(tRange.t-tRange.s, RAY_STEP_L)*hash13(100.0*p);\n    int i=0;\n    for (; i<150; i++) { // Theoretical max steps: (BOX_MAX-BOX_MIN)*sqrt(3)/RAY_STEP_L\n        if (t > tRange.t || lightAmount < 1.0-QUIT_ALPHA_L) { break; }\n        \n        vec3 rayPos = p + t*nv;\n        vec3 lmn = lmnFromWorldPos(rayPos);\n\n        float density = getPage1(lmn).s;\n        float calpha = clamp(density * MAX_ALPHA_PER_UNIT_DIST * RAY_STEP_L, 0.0, 1.0);\n\n        lightAmount *= 1.0 - calpha;\n\n        t += RAY_STEP_L;\n    }\n\n    return lightAmount;\n}\n\nvec4 doPage2(vec3 lmn) {\n\tfloat density = getPage1(lmn).s;\n\n\tvec3 p = worldPosFromLMN(lmn);\n    float lightAmount = march(p, normalize(LIGHT_POS - p));\n\n    return vec4(density, lightAmount, 1.0, 1.0);\n}\n\n// ==================\n// Write to cube map\n// ==================\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec3 lmn;\n    int pageDst;\n    lmnFromVCube(rayDir, pageDst, lmn);\n\n    if (pageDst == 1) {\n        fragColor = doPage1(lmn);\n    } else if (pageDst == 2) {\n        fragColor = doPage2(lmn);\n    } else {\n        discard;\n    }\n}\n", "cube_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 177, 177, 787], [789, 789, 858, 858, 1200], [1202, 1202, 1247, 1247, 2583], [2743, 2743, 2768, 2768, 2841], [2843, 2843, 2888, 2888, 3067], [3069, 3069, 3124, 3124, 4012]], "test": "untested"}
{"id": "WdBBR3", "name": "Dirac Equation", "author": "wyatt", "description": "dirac equation!", "tags": ["wave", "quantum"], "likes": 10, "viewed": 450, "published": 3, "date": "1590462412", "time_retrieved": "2024-07-30T21:05:04.928456", "image_code": "// Fork of \"Spinor Wave\" by wyatt. https://shadertoy.com/view/3dSBR3\n// 2020-05-26 02:37:41\n\nMain {\n\tQ = 4.*abs(A(U)+B(U));//sin(vec4(1,2,3,4)+4.*length(A(U)-B(U)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood2 vec4 u = B(U+vec2(0,1)), r = B(U+vec2(1,0)), d = B(U-vec2(0,1)), l = B(U-vec2(1,0)), m2 = 0.25*(u+r+d+l);\n\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))", "buffer_a_code": "Main {\n\tQ = A(U);\n    Neighborhood2;\n    \n    vec4 dy = 0.5*(u-d);\n    vec4 dx = 0.5*(r-l);\n    \n    Q.x += dx.z-dy.w;\n    Q.y += dx.w+dy.z;\n    Q.z += dx.x+dy.y;\n    Q.w += dx.y-dy.x;\n    \n    if (iFrame < 1) {Q = exp(-.01*dot(U-0.5*R,U-0.5*R))*vec4(cos(U.x),sin(-U.x),sin(U.x),cos(U.x));}\n    \n    if (iMouse.z>0.&&length(U-iMouse.xy)<13.)\n        Q.xz = vec2(-.1);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tQ = A(U);\n    Neighborhood2;\n    \n    vec4 dy = 0.5*(u-d);\n    vec4 dx = 0.5*(r-l);\n    \n    Q.x += dx.z-dy.w;\n    Q.y += dx.w+dy.z;\n    Q.z += dx.x+dy.y;\n    Q.w += dx.y-dy.x;\n    \n    if (iFrame < 1) {Q = exp(-.01*dot(U-0.5*R,U-0.5*R))*vec4(cos(U.x),sin(-U.x),sin(U.x),cos(U.x));}\n    \n    if (iMouse.z>0.&&length(U-iMouse.xy)<13.)\n        Q.xz = vec2(-.1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = A(U);\n    Q.xy *= e(-1.);\n    Q.zw *= e(-1.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = A(U);\n    Q.xy *= e(1.);\n    Q.zw *= e(1.);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3sjfWW", "name": "Stars optimised", "author": "tdo1", "description": "optimised stars generation", "tags": ["stars"], "likes": 4, "viewed": 313, "published": 3, "date": "1590450949", "time_retrieved": "2024-07-30T21:05:05.806109", "image_code": "// Stars optimised by tdo1\n\n// This content is under the MIT License.\n\nbool isInt(float n) \n{\n   return round(n) == n;\n}\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(54.90898,18.233))) * 4337.5453);\n}\n\nvec2 rand2(vec2 p)\n{\n    p = vec2(dot(p, vec2(12.9898,78.233)), dot(p, vec2(26.65125, 83.054543))); \n    return fract(sin(p) * 43758.5453);\n}\n\nfloat randomRange_float(vec2 Seed, float Min, float Max)\n{\n    float randomno =  fract(sin(dot(Seed, vec2(12.9898, 78.233)))*43758.5453);\n    return smoothstep(Min, Max, randomno);\n}\n\nbool isInPos(float size, vec2 pos, vec2 center, out float distPerc)\n{\n    distPerc = length(center - pos);\n    if(distPerc < size) \n    { \t\n        distPerc = distPerc / size;\n        return true;\n    }\n    return false;\n}\n\nvec4 starBlur(float dist)\n{\n    if(dist > 0.3)\n    {\n        return  vec4(1.0-dist); \n    }\n    else\n    {\n        return vec4(1.0); \n    }\n}\n\nvec4 generateStars(vec2 posInUniverse, float rangeColumn,float sizeForZoneStars, float speed, float seedModifierx, float seedModifiery)\n{\n    speed = trunc(speed);\n    vec2 offset = vec2(speed,speed);\n    posInUniverse += offset;\n    posInUniverse.x += seedModifierx;\n    posInUniverse.y += seedModifiery;\n   \tfloat columnPosx = abs(posInUniverse.x) / sizeForZoneStars;\n    float colomnIndexx = trunc(columnPosx);  \n    float distFromX = columnPosx - colomnIndexx;\n    bool inColumx = distFromX <= rangeColumn;\n    \n    float columnPosy = abs(posInUniverse.y) / sizeForZoneStars;\n    float colomnIndexy = trunc(columnPosy);  \n    float distFromY = columnPosy - colomnIndexy;\n    bool inColumy = distFromY <= rangeColumn;\n    \n    if(inColumx && inColumy)\n    {\n        //return vec4(1.0); \n        \n        float randomNumber = randomRange_float(vec2((colomnIndexx+seedModifierx), (colomnIndexy+seedModifiery)), 0.0f, 1.0f);\n        \n        vec2 centerCase = vec2(colomnIndexx+(rangeColumn/2.0), colomnIndexy+(rangeColumn/2.0));\n        vec2 posInCase = vec2(columnPosx, columnPosy);\n        float distanceFromCenter = -1.0;\n        \n        if(randomNumber >= 0.9965f && isInPos(0.09, posInCase, centerCase, distanceFromCenter))\n        {\n            return starBlur(distanceFromCenter);\n        }\n        else if(randomNumber >= 0.990f && isInPos(0.03, posInCase, centerCase, distanceFromCenter))\n        {\n           return starBlur(distanceFromCenter);\n        }\n        else if(randomNumber >= 0.97f && isInPos(0.02, posInCase, centerCase, distanceFromCenter))\n        {\n           return starBlur(distanceFromCenter);\n        }\n        else if(randomNumber >= 0.95f && isInPos(0.01, posInCase, centerCase, distanceFromCenter))\n        {\n           return vec4(1.0); \n        }\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n \tvec2 posInUniverse = fragCoord;\n    fragColor = generateStars(posInUniverse, 0.25f, 300.0, iTime*100.0, 0.0, 0.0);\n    if(fragColor == vec4(0.0))\n    {\n        fragColor = generateStars(posInUniverse, 0.25f, 200.0, iTime*50.0, 150.0, 0.0);\n        if(fragColor == vec4(0.0))\n        {\n \t\t\tfragColor = generateStars(posInUniverse, 0.25f, 100.0, iTime*25.0, 300.0, 580.0);\n        }\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjfWW.jpg", "access": "api", "license": "mit", "functions": [[71, 71, 93, 93, 120], [122, 122, 142, 142, 213], [215, 215, 235, 235, 356], [358, 358, 416, 416, 540], [542, 542, 611, 611, 764], [766, 766, 793, 793, 907], [909, 909, 1046, 1046, 2722], [2724, 2724, 2781, 2781, 3213]], "test": "untested"}
{"id": "ts2fRV", "name": "Weird fluid experment", "author": "wyatt", "description": "Getting back to my roots. I should do my other responsibilites too though..", "tags": ["fluid"], "likes": 6, "viewed": 407, "published": 3, "date": "1590445585", "time_retrieved": "2024-07-30T21:05:06.574056", "image_code": "Main {\n    Neighborhood;\n   \tvec3 no = normalize(vec3(e.x-w.x,n.x-s.x,2));\n\tQ = abs(sin(atan(A(U).w*.1+D(U)*vec4(1,.1,0,0))));\n    Q *= 0.7+0.3*texture(iChannel1,no);\n    Q.xyz *= 1.8*mat3(.7,1,.8,.7,.1,0,.9,.6,0.8);\n\t//Q = 10.*abs(A(U));\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0));\n#define NeighborhoodT vec4 n = T(U+vec2(0,1)), e = T(U+vec2(1,0)), s = T(U-vec2(0,1)), w = T(U-vec2(1,0));\n\n#define Main void mainImage(out vec4 Q, vec2 U)", "buffer_a_code": "Main {\n\tNeighborhood;\n    \n    vec4 dd = D(U);\n    Q = A(U);\n    // Gradient of Pressure\n    Q.xy += 0.25*vec2(w.z-e.z,s.z-n.z);\n    // Curl of Torsion\n    Q.xy += 0.25*vec2(s.w-n.w,e.w-w.w);\n    vec2 f = vec2(0);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++) if (x!=0||y!=0) {\n    \tvec4 d = D(U+vec2(x,y)); \n        f += Q.w*d.w*(A(U+vec2(x,y)).xy-Q.xy);\n    }\n    Q.xy -= f/30.*dd.x;\n    float \n        u = length(D(U+vec2(0,1)).yz),\n        r = length(D(U+vec2(1,0)).yz),\n        d = length(D(U-vec2(0,1)).yz),\n        l = length(D(U-vec2(1,0)).yz);\n\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tNeighborhood;\n    Q = A(U);\n    vec4 dd = D(U);\n    // convergence of velocity\n    Q.z += 0.25*((w.x-Q.x)-(e.x-Q.x)+(s.y-Q.y)-(n.y-Q.y));\n    // curl of velocity\n    Q.w += ((e.y-Q.y)-(w.y-Q.y)+(s.x-Q.x)-(n.x-Q.x));\n    if (dd.y<.1) Q.w *= 0.;\n    if (dd.y<1e-4) Q.z *= 0.;\n    if (R.x-U.x<1.) Q.xy*=0.;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tNeighborhood\n    Q = A(U-0.25*(n+e+s+w).xy);\n    \n        if (iMouse.z>0. && length(U-iMouse.xy)<10.||(iFrame < 1 &&length(U-0.5*R)<20.))\n        {Q.x = 1.;Q.z += 1e-2;}\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 T (vec2 U) {\n\treturn D(U-A(U).xy);\n}\nMain {\n    Neighborhood;\n    Q = T(U);\n    vec4 a = A(U),\n        u = T(U+vec2(0,1)),\n        r = T(U+vec2(1,0)),\n        d = T(U-vec2(0,1)),\n        l = T(U-vec2(1,0));\n    Q -= 0.25*(u*(n.y-a.y)-d*(s.y-a.y)+r*(e.x-a.x)-l*(w.x-a.x));\n    vec4 M = (0.25*(u+r+d+l));\n   \tQ.y = M.x;\n    if (iMouse.z>0. && length(U-iMouse.xy)<10.||(iFrame < 1 &&length(U-0.5*R)<20.)) \n        Q.xz = vec2(1,.5);\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2fRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ws2BRV", "name": "Wobbly Floor", "author": "donnerbrenn", "description": "Playing around with raymarching and learn how textures work. ", "tags": ["raymarching", "texture"], "likes": 5, "viewed": 348, "published": 3, "date": "1590442871", "time_retrieved": "2024-07-30T21:05:07.333027", "image_code": "\nvec3 color;\nfloat approx=.001;\nfloat renderDist=15.;\nfloat maxIter=500.;\n\nuniform sampler2D Texture;\nvec3 ro=vec3(0);\n\nvec3 rotate(vec3 p,vec3 t)\n{\n      float c=cos(t.x),s=sin(t.x);\n      mat3 m=mat3(vec3(1,0,0),vec3(0,c,-s),vec3(0,s,c));\n\n      c=cos(t.y);s=sin(t.y);\n      m*=mat3(vec3(c,0,s),vec3(0,1,0),vec3(-s,0,c));\n\n      c=cos(t.z);s=sin(t.z);\n      m*=mat3(vec3(c,-s,0),vec3(s,c,0),vec3(0,0,1));\n\n      return m*p;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdRoundbox( vec3 p, vec3 b, float r)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat map(vec3 p)\n{\n\n    p.z+=iTime;\n    p=rotate(p,vec3(0,0,sin(iTime*1.+p.z))*.25);\n    float plane=sdPlane(p,vec4(.0,3.14/4.,.0,.5));   \n    p.xz=mod(p.xz,2.)-1.;\n\n    float pillar=sdRoundbox(p,vec3(.1,8,.3),.1);\n    return min(plane,pillar);\n}\n\nvec3 normal(vec3 p) \n{\n    mat3 k = mat3(p,p,p) - mat3(0.005);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2])) );\n}\n\nfloat lightRender(vec3 n,vec3 l, vec3 v, float strength)\n{\n      return ((dot(n,normalize(l))*.5+.5)+pow(max(dot(v,reflect(normalize(l),n)),.0),10.))*strength;\n}\n\n\n//from https://github.com/electricsquare/raymarching-workshop\nvec3 triplanarMap(sampler2D t, vec3 p, vec3 n, float o)\n{\n        p=rotate(p,vec3(0,0,sin(iTime+p.z))*.25);\n\n    // Take projections along 3 axes, sample texture values from each projection, and stack into a matrix\n    mat3 triMapSamples = mat3(\n        texture(t, p.yz+o).rgb,\n        texture(t, p.xz+o).rgb,\n        texture(t, p.xy+o).rgb\n        );\n    triMapSamples[0] *= triMapSamples[0];\n    triMapSamples[1] *= triMapSamples[1];\n    triMapSamples[2] *= triMapSamples[2];\n \n    // Weight three samples by absolute value of normal components\n    return triMapSamples * abs(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=((fragCoord.xy/iResolution.xy)*2.-1.)*vec2(1.,iResolution.y/iResolution.x);\n    \n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=ro;\n\n    float iterations;\n    float d=1.;\n    while(distance(p,ro)<renderDist&&d>approx&&iterations<maxIter)\n    {\n        d=map(p);\n        p+=d*rd;\n        iterations++;\n    }\n    if(d<approx)\n    {\n        vec3 n=normal(p);\n        color=triplanarMap(Texture,p+vec3(0,0,iTime),n,.5);\n        color*=lightRender(n,vec3(10),rd,.5);\n        color*=pow((1.-distance(ro,p)/renderDist),2.);\n    }\n    color = pow (color, vec3 (0.45454));\n\n    fragColor=vec4(color,1.);\n\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 148, 148, 427], [429, 429, 460, 460, 494], [496, 496, 540, 540, 631], [634, 634, 653, 653, 881], [883, 883, 905, 905, 1017], [1019, 1019, 1077, 1077, 1180], [1183, 1245, 1302, 1302, 1828], [1830, 1830, 1887, 1887, 2496]], "test": "untested"}
{"id": "td2SzG", "name": "Flipping Boxes Pattern", "author": "koi", "description": "An old shader inspired by @beesandbombs on Twitter.", "tags": ["pattern", "boxes", "flipping"], "likes": 4, "viewed": 345, "published": 3, "date": "1590437519", "time_retrieved": "2024-07-30T21:05:08.128899", "image_code": "#define TAU 6.28318530718\n\nfloat flipRange(float a, float fac) {\n    return fac + a * (1.0 - 2.0*fac);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    coord *= 10.0;\n    \n    float t = iTime / 2.0;\n    float flip = step(0.5, fract(t/2.0));\n    float a = fract(t)*TAU/4.0;\n    float r = 0.5;\n    \n    vec2 fc = coord - 0.5*flip;\n    fc -= round(fc);\n    fc *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    \n    float d = abs(fc.x) + abs(fc.y);\n    \n    float fwd = fwidth(coord.x) / 2.0;\n    float val = smoothstep(-fwd, fwd, d - r);\n    val = flipRange(val, flip);\n    \n    fragColor = vec4(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2SzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 64, 64, 104], [106, 106, 163, 163, 681]], "test": "untested"}
{"id": "WsGSRG", "name": "Rainbow Tunnel of Fun", "author": "koi", "description": "A fun shader I made a while back", "tags": ["tunnel", "animation", "rainbow"], "likes": 6, "viewed": 364, "published": 3, "date": "1590437094", "time_retrieved": "2024-07-30T21:05:08.896846", "image_code": "#define TAU 6.283185\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float theta = iTime + fract(iTime/TAU) * TAU/2.0;\n    coord *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    \n    float a = atan(coord.y, coord.x);\n    \n    float n = exp((-cos(iTime)*0.5+0.5)*3.5)+1.0;\n    \n    float d = length(coord) * cos(mod(a+TAU/n/2.0, TAU/n)-TAU/n/2.0);\n    d = 1.0 / d;\n    float val = step(d, 0.5);\n    \n    fragColor = vec4(hsv2rgb(vec3(round(fract(d-iTime)*6.0)/6.0, 0.8, 1.0))*(fract(fract(d-iTime)*6.0+0.5)*0.2+0.8)/d, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 44, 44, 213], [215, 215, 272, 272, 824]], "test": "untested"}
{"id": "ws2fRK", "name": "Rainbow Sine Spiral", "author": "koi", "description": "Drag your mouse to change the scale and RGB offset\nInspired by @beesandbombs on Twitter", "tags": ["interactive", "spiral", "rainbow", "pattern"], "likes": 3, "viewed": 341, "published": 3, "date": "1590436456", "time_retrieved": "2024-07-30T21:05:09.656814", "image_code": "#define TAU 6.28318531\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float angle = mod(atan(coord.y, coord.x), TAU);\n    float len = length(coord);\n    \n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 3; i++) {\n        float o = float(i)/3.0;\n        float s = sin(angle + len*(4.0+m.y*6.0) - iTime*2.0 + o*TAU*(1.0-m.x)) * 0.5+0.5;\n        float d = 0.1 + (sin(coord.x*80.0) * 0.5+0.5)*0.4*s - abs(fract(coord.y*10.0) - 0.5) * 2.0;\n        float v = smoothstep(-fwidth(d)/2.0, fwidth(d)/2.0, d);\n        \n        col[i] = v;\n    }\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2fRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 711]], "test": "untested"}
{"id": "Wd2fzV", "name": "Locked In Glass!", "author": "dean_the_coder", "description": "Webcam 'locked in glass' - Inspired by Superman.\nThanks to Evvvvil for his awesome Twitch tutorials!", "tags": ["procedural", "3d", "raymarch", "webcam", "superman", "memix"], "likes": 34, "viewed": 1077, "published": 3, "date": "1590431109", "time_retrieved": "2024-07-30T21:05:10.416781", "image_code": "float glow = 0.0;\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    \n    return max(max(-p.y, d), p.y - h);\n}\n\nfloat sdTorus(vec3 p, float t) {\n  vec2 q = vec2(length(p.xz)-t, p.y);\n  return length(q);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRings(vec3 p, bool useGlow) {\n    p.xz *= rot(iTime * 3.0);\n    \n    p.y = abs(p.y - 1.85) - 0.8;\n    p.xy *= rot(3.1415 / 8.0);\n    \n    float d = sdTorus(p, 2.0);\n    \n    if (useGlow)\n    \tglow += 0.008 / (d * d);\n    return d;\n}\n\nvec2 glassUV;\n\nfloat sdGlass(vec3 p, bool txMap) {\n    p.y -= 2.0;\n    \n    p.xz *= rot(iTime * 0.3);\n    p.xy *= rot(sin(iTime * 0.9));\n    p.yz *= rot(sin(iTime * 0.7));\n    \n    if (txMap) {\n        ivec2 ts = textureSize(iChannel0, 0);\n        float ratio = float(ts.y) / float(ts.x);\n        glassUV = (p.xy * vec2(ratio, 1.0)  * 0.42 + 0.5);\n    }\n    \n    return sdBox(p, vec3(1.2, 1.2, 0.01));\n}\n\nvec2 map(vec3 p, bool isMapping) {\n    float d1 = sdCylinder(p, 2.0, 0.2);\n    float d2 = sdPlane(p);\n    float d3 = sdRings(p, isMapping);\n    float d4 = sdGlass(p, isMapping);\n    \n    vec2 res = d1 < d2 ? vec2(d1, 1.5) : vec2(d2, 2.5);\n    if (d3 < res.x) res = vec2(d3, 0.0);\n    if (d4 < res.x) res = vec2(d4, 3.5);\n    \n    return res;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy, false).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx, false).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy, false).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx, false).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0 / sharpness;\n    for (float d = 0.1; d < 32.0; d += h) {\n        h = max(0.0, map(p + rd * d, false).x);\n        minH = min(minH, h / d);\n        if (minH < 0.01)\n            break;\n    }\n    \n    return minH * sharpness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Raymarch.\n    vec3 ro = 5.0 * vec3(0.0, 0.4, -1.1 + (4.5 * sin(iTime * 0.5) + sin(iTime * 0.25)) * 0.1);\n    vec3 rd = getRayDir(ro, vec3(0.0, 1.4, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 128.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p, true);\n        if (h.x < 0.004 * d) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    vec3 col;\n    vec3 skyCol = vec3(0.18, 0.2, 0.22) * 0.1;\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(1.0, 1.2, -5.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float spe = 1.5 * pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 30.0);\n        vec3 mainLight = clamp(dot(n, lightToPoint), 0.01, 1.0) * lightCol;\n        vec3 backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.2 * lightCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Podium.\n            mat = vec3(0.001);\n        } else if (hit == 2) {\n            // Plane.\n            mat = vec3(0.001);\n            \n        } else if (hit == 3) {\n            // Glass.\n            mat = texture(iChannel0, glassUV).rgb;\n        }\n\n        col = mainLight * lightCol * sha;\n        col += backLight;\n        col += spe * lightCol;\n        col *= mat;\n        col = mix(col, skyCol, fog);\n    } else {\n        // Sky.\n        col = skyCol;\n    }\n    \n    // Glow\n    col += glow * 0.1;\n\n    // Output to screen\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2fzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 38, 38, 114], [116, 116, 139, 139, 157], [159, 159, 203, 203, 281], [283, 283, 315, 315, 375], [377, 377, 408, 408, 499], [501, 501, 538, 538, 741], [758, 758, 793, 793, 1146], [1148, 1148, 1182, 1182, 1491], [1493, 1493, 1540, 1540, 1745], [1747, 1747, 1775, 1793, 2021], [2023, 2023, 2081, 2081, 2383], [2385, 2385, 2442, 2442, 4187]], "test": "untested"}
{"id": "3d2fzK", "name": "Hexagon Sound Visualization", "author": "Shane", "description": "Hexagon pylon sound data visualization experiment.", "tags": ["sound", "hexagon", "pylon"], "likes": 40, "viewed": 1303, "published": 3, "date": "1590412231", "time_retrieved": "2024-07-30T21:05:11.349288", "image_code": "/*\n\n    Hexagon Sound Visualization\n    ---------------------------\n\n\tThis is just a sound data visualization experiment... It works well enough, but\n\tI'd call it a work in progress. I put it together in 2D form a while back and\n\tnever got around to the conversion, basically because I thought it'd require lots \n    of thinking. However, it wasn't as bad as I'd imagined.\n\n\tHaving said that, converting sound data to something presentable on a 2D plane \n\twasn't as straight forward as I expected it to be. I decided on a kind of quasi \n    polar representation. Wanting to put this into a single pass complicated things, \n    but it was doable. By far, the best way to do this would be to produce the sound \n    image data in a seperate buffer, then render and color it with a single texture \n    lookup. The downside to taking that route would be having to keep the texture \n    ranges within the camera's field of view.\n\n    Packed hexagons usually require four taps per pass, which can add to the amount\n\tof work the GPU has to perform... Technically, you could render just three \n    hexagons at the triangle vertices of a simplex grid. However, after setup, and so \n\tforth, it'd be a case of diminishing returns. Either way, packing 2D data\n\tinformation into the four channels of a buffer could speed things up also.\n\n\tAnyway, this was patched together pretty quickly, so I wouldn't pay it too much\n\tattention. I'll tidy up the code and comments a little later. By the way, the\n\tsound file comes from FL Studio's SoundCloud collection.\n\n\n\n*/\n\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Grayscale, for that artsy look.\n//#define GRAYSCALE\n\n// Sparkles: Left over from a previous example. They don't really work \n// here, but it's there anyway. :)\n//#define SPARKLES \n\n\n// Apply some glow. It only really looks right on larger objects, so \n// \"HEX_SCALE\" is set to 6 when this is turned on.\n#define GLOW\n\n\n// Hexagonal scale: It's based on hexagons per unit area, so larger numbers\n// give more detail. Detail allows the sound pattern to emerge, but doesn't\n// look as interesting from a 3D perspective. The default attempts to give\n// the best of both worlds.\n#ifdef GLOW\n#define HEX_SCALE 6. // Glow looks better with larger objects.\n#else\n#define HEX_SCALE 12. // No glow, so give it more definition.\n#endif\n\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Camera's XY movement. \nvec2 camXY;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// 2D texture read.\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, fract(p/4. + .5)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n)*2. - 1.;\n    return sin(p*6.2831853 + iTime*2.); \n    \n}\n\n// vec3 to float.\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.989, 78.233, 57.263)))*43758.5453);\n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n\n// Height map value, which is just some sound data converted to 2D and \n// a texture read.\nfloat hm(in vec2 p){ \n    \n     \n    float sndSc = 2.;\n    vec2 hPos = p/sndSc;\n    \n    // Test height, for debugging purposes.\n    //float ns2 = n2D3G(hPos*2. + iTime/2.)*.57 + n2D3G(hPos*4. + iTime)*.34;\n    //ns2 = ns2*.5 + .5;\n    //return ns2;\n    \n    \n    // Surface position.\n    vec2 sHPos = hPos - camXY/sndSc;\n    \n\n    // The sound texture has dimensions 512x2, with the first row containing\n    // frequency data.\n    int ci = int(length(sHPos)*256.);\n    float fft  = texelFetch(iChannel1, ivec2(ci, 0), 0).x;\n\n    // The second row is the sound wave.\n    int sTx = int(sHPos.x*280. + 256.);\n    float wave = texelFetch(iChannel1, ivec2(sTx, 1), 0 ).x;   \n\n\n    float layer = fft;\n    float intensity = fft; //mix(wave, fft, .5);\n\n    // The sound data alone has a lot of inactive periods, so we add in some \n    // background noise just to keep things visually interesting.\n    float ns = n2D3G(hPos*2.5)*.57 + n2D3G(hPos*5.)*.34;\n    ns = ns*.5 + .5;\n\n    // Blinking lights function.\n    float blink = smoothstep(0., .1, mix(ns - .5, intensity - .5, .35));\n    \n    // Mix the texture with the blink height and return.\n    return dot(getTex(p), vec3(.299, .587, .114))*1.5 + blink; \n\n\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2. );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n\n// This is a bound. Technically, it's not a proper distance field, but for\n// this example, no one will notice. :)\nfloat sHexS(in vec2 p, in vec2 b){\n    \n    p = abs(p);\n    return max(p.x*.8660254 + p.y*.5 - b.x, p.y - b.y);\n    //return max(p.y*.8660254 + p.x*.5, p.x) - b.x;;\n}\n*/\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method, which is here:\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n    \n      const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n\n      r -= sf;\n      // Polygon side.\n      return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method, which is here:\nfloat sCylS(in vec2 p, float r){\n  \n  return length(p) - r;\n    \n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    // Scale.\n    //#define STRETCH\n    #ifdef STRETCH\n\tconst vec2 scale = vec2(1./HEX_SCALE, 1./HEX_SCALE);\n     // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale.x*1.732/2., scale.y);\n    #else\n    const float scale = 1./HEX_SCALE;\n     // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale*1.732/2., scale);\n    #endif\n    \n   \n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // For block corner postions.\n    //const vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l, vec2(l.x, -l.y));\n    // Pointed top.\n    //const vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l + vec2(l.x, 0), vec2(l.x, -l.y) + vec2(l.x, 0));\n    // Flat top.\n    const vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l + vec2(0., l.y), -l, vec2(l.x, -l.y) + vec2(0., l.y));\n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy - cntr;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= (ip)*s; // New local position.\n\n       \n        // Correct positional individual tile ID.\n        vec2 idi = (ip)*s + cntr;\n \n        // The extruded block height. See the height map function, above.\n        float h = hm(idi);\n        \n        // Or just, \"h *= .1,\" for nondiscreet heights.\n        //h = floor(h*15.999)/15.*.1; \n        h *= .1;\n        \n            \n        // The hexagonal cross section. The corners are slightly rounded on this\n        // version, but they don't have to be.\n        #ifdef STRETCH\n        vec2 lu = l/vec2(1.732/2., 1);\n        vec2 pStretch = lu.x<lu.y? vec2(1, lu.x/lu.y) : vec2(lu.y/lu.x, 1);\n        float r = min(lu.x, lu.y)/2.;\n        float di2D = sHexS(p*pStretch, r - .035*r, .2*r);\n        #else\n        float di2D = sHexS(p, scale/2. + .035*scale, .2*scale);\n        //float di2D = sCylS(p, scale/2.);\n        #endif\n\n        // Boring out some of the lower boxes. I like it, but thought it\n        // confused matters.\n        //if(h<1./15.*.15 + .001) di2D = max(di2D, -(di2D + .3*scale));\n\n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h), h);\n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Not used in this example, so we're saving the calulation.\n            //boxID = float(i);\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec2 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yz; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n// Glow.\nvec3 gGlow;\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    gGlow = vec3(0);\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        \n        float ad = abs(d + (hash31(rd) - .5)*.05);\n        if(ad<1.){\n            float l2D = ad;//1./(1. + abs(ad));// t; //\n            //if(objID == 0.) \n            \tgGlow += .25*(1. - l2D)/(1. + l2D)/(1. + t);\n        }\n\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(d*d<1e-6 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7;\n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n    \n\t// Camera Setup.\n    camXY = vec2(1.732, 1)*iTime/4.;\n\tvec3 ro = vec3(camXY.x, camXY.y - 1., -2.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .07, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positionin. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.5, 1.5, 1.5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.33; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec2 svGID = gID;\n    \n    float svObjID = objID;\n    \n    vec3 svGlow = gGlow;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd)*.5), 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID, then using it in conjunction\n            // with sound files to color a height map.\n            \n            // Sound visual scale, ID, surface position.\n            const float sndSc = 2.;\n            vec2 hPos = svGID/sndSc;\n            vec2 sHPos = (hPos - camXY/sndSc);\n            vec2 hPos2 = (sp.xy - svGID)/sndSc;\n            \n            //    float eDist = hex(hPos2.xy); // Edge distance.\n            float cDist = dot(hPos2.xy, hPos2.xy); // Relative squared distance from the center.\n  \n\n\n            // The sound texture has dimensions 512x2, with the first row containing\n            // frequency data.\n            int ci = int(length(sHPos)*256.);\n            float fft  = texelFetch(iChannel1, ivec2(ci, 0), 0).x;\n\n            // The second row is the sound wave.\n            int sTx = int(sHPos.x*280. + 256.);\n            float wave = texelFetch(iChannel1, ivec2(sTx, 1), 0 ).x;   \n\n\n            float layer = fft;\n            float intensity = fft; //mix(wave, fft, .5);\n\n            // The sound data alone has a lot of inactive periods, so we add in some \n            // background noise just to keep things visually interesting.\n            float ns = n2D3G(hPos*2.5)*.57 + n2D3G(hPos*5.)*.34;\n            ns = ns*.5 + .5;\n\n            // Blinking lights function.\n            float blink = smoothstep(0., .1, mix(ns - .5, intensity - .5, .35));\n\n            // Blending.\n            float blend = n2D3G(hPos*4. + intensity*1.)*.5 + .5;\n \n \n            // Texture reads.\n            //vec3 tx = getTex(svGID);\n            // vec3 tx = getTex(sp.xz);\n            vec3 tx = tex3D(iChannel0, sp/4. - .5, sn);\n            tx = smoothstep(0., .5, tx);\n            vec3 tx2 = texture(iChannel0, hPos*1.).xyz; tx2 *= tx2;\n            tx = smoothstep(-.05, .8, tx)*vec3(1, .8, .6);\n            tx2 = smoothstep(-.05, .8, tx2)*vec3(1, .8, .6);\n            \n            // Using the information above to mix in some color.\n            // All of this is made up, so I wouldn't pay it too much attention.\n            vec3 hCol = mix(tx, tx2, .65);\n            float sh = max(1. - cDist*2., 0.);\n            //vec3 colMix = pow(vec3(1.5, 1, 1)*blend, vec3(1, 2.5, 16))*5.;//\n            vec3 colMix = mix(vec3(1, .1, .2), vec3(1, .7, .35), blend)*5.;\n            //vec3 colMix = .5 + .25*cos(6.2831*mix(.0, 1., blend) + vec3(0, 1, 2))*5.;\n            //colMix = mix(colMix.zyx, colMix.xzy*2., sin(intensity*3.14159*2.5 + 3.14159/4.)*.8 + .6);\n            colMix = mix(colMix.zyx, colMix.xzy*2., smoothstep(0., 1., n2D3G(hPos*(3. - layer/8.)))*1.25 - .125);\n            colMix = mix(colMix.zyx, colMix.xzy*2., smoothstep(.5, 1.5, sin(mix(ns - .5, intensity - .475, .5)*3.14159*5.))*1.25 - .125);\n            colMix = mix(colMix, colMix.zyx, .1);\n\n            hCol = mix(hCol/4., hCol*colMix, blink); // Blended, blinking orange.\n            hCol *= sh*.8 + .4;\n\n\n            // Putting little black borders on the hexagon faces.\n            vec2 q = hPos2;\n            float sf = .002;\n            const float sc = 1./HEX_SCALE/sndSc;\n            const float lw = sc*.1;\n            float eDist = sHexS(q, sc/2. + .035*sc, .2*sc);\n            eDist = abs(eDist) - lw;\n            float ht = hm(svGID);\n            \n            // Darker sides with a black rim.\n            //hCol = mix(hCol, vec3(0), (1. - smoothstep(0., sf, eDist))*.9);\n            //eDist = max(eDist, abs(sp.z + ht*.1*2.) - lw/1.); // No black sides.\n            hCol = mix(hCol, vec3(0), (1. - smoothstep(0., sf, eDist))); // Just the rim.\n            //float cDist2 = dot(hPos2.xy - .07, hPos2.xy - .07);\n            //hCol = mix(hCol, hCol*2., (1. - smoothstep(0., sf*2., cDist2 - max(-dot(rd, ld), 0.)*.01)));\n\n\t\t\t// A simple lined pattern along the top.\n            float pat = abs(fract((sp.y*.8860254 + sp.x*.5)*42.) - .5)*2. - .25;  \n            hCol = mix(hCol, vec3(0), (1. - smoothstep(0., .25, pat))*.5);\n                 \n            \n            texCol = hCol;\n             \n            // Greyscale value, just in case people switch to the Britney video, etc.\n            // Stylistically, the example works better with color. The Britney video\n            // looks OK, but I'm more of a Shirley Jones kind of guy. :)\n            #ifdef GRAYSCALE\n            texCol = vec3(1)*dot(texCol, vec3(.299, .587, .114));\n            #endif   \n           \n            \n\n            #ifdef SPARKLES\n            \n            // Putting some blinking colored dots in the background. I did this to liven\n            // things up a bit. It's a little quirky, but looks... interesting, I guess. :D\n            float rnd = fract(sin(dot((svGID), vec2(141.13, 289.97)))*43758.5453);\n            float rnd2 = fract(sin(dot((svGID + .037), vec2(141.13, 289.97)))*43758.5453);\n            rnd = smoothstep(.95, .97, cos(rnd*6.283 + iTime*1.)*.5 + .5);\n            vec3 rndCol = (.5 + .45*cos(6.2831*mix(0., .3, rnd2) + vec3(0, 1, 2)/1.1));\n            rndCol = mix(rndCol, rndCol.xzy, uv.y*.75 + .5);\n            rndCol = mix(vec3(1), rndCol.zyx*20., rnd);\n            \n            texCol *= rndCol;\n            \n            #endif\n            \n\n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n\n        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.3 + vec3(.2, .4, 1)*fre*0. + vec3(1, .5, .2)*spec*2.);\n        \n\n    \n        // Shading.\n        col *= ao*sh*atten;\n        \n        \n        //if(objID == 1.) svGlow *= texCol;\n        svGlow *= (ao*sh*atten*.65 + .35);\n      \n        \n\t\n\t}\n    \n\n    \n    // Applying the glow.\n    #ifdef GLOW    \n    // Applying a fiery palatte to the glow\n    vec3 glowCol = pow(vec3(1.5, 1, 1)*svGlow, vec3(1, 2, 3).zyx*2.);\n    \n    // The fiery red is a little overwhelming, so this tones it down a bit.\n    //glowCol = mix(glowCol, glowCol.zyx, max(-rd.y*.25 + .1, 0.));\n\n    // Adding the glow to the scene. Not that it's applied outsite the the object coloring\n    // block because we need to add the glow to the empty spaces as well. When I haven't applied\n    // glow for a while, I tend to forget this. :)\n    col = mix(col, glowCol, glowCol);// + glowCol*glowCol*1.5;\n    \n    #endif\n\n\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22918, "src": "https://soundcloud.com/fl-studio/saif-sameer-fulcrum-emotion-vs-energy", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2fzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2438, 2471, 2493, 2493, 2551], [2554, 2582, 2603, 2603, 2666], [2669, 2689, 2709, 3086, 3198], [3201, 3355, 3405, 3707, 4616], [4618, 4640, 4661, 5010, 5219], [5221, 5239, 5260, 5260, 5334], [5336, 5377, 5402, 5402, 5842], [5845, 5936, 5956, 5956, 7140], [7142, 7169, 7226, 7226, 7533], [7955, 8111, 8156, 8156, 8460], [8462, 8618, 8650, 8650, 8684], [12103, 12126, 12144, 12163, 12434], [12459, 12480, 12516, 12565, 13302], [13305, 13405, 13441, 13441, 13598], [13601, 13792, 13844, 13961, 15281], [15284, 15436, 15472, 15472, 15726], [15729, 15729, 15785, 15818, 25525]], "test": "untested"}
{"id": "tsSfRK", "name": "WallsToBuild", "author": "z0rg", "description": "walls to build mall grab remix\nA sunday night inspiration, while listening this cool song.", "tags": ["2d", "abstract", "worm", "vidjing"], "likes": 1, "viewed": 270, "published": 3, "date": "1590361932", "time_retrieved": "2024-07-30T21:05:12.198019", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a) {float cosa = cos(a);float sina = sin(a);return mat2(cosa, sina, -sina, cosa);}\n\nfloat lenny(vec2 p)\n{\n    return abs(p.x)+abs(p.y);\n}\n\nfloat sat(float a)\n{\n    return clamp(a,0.,1.);\n}\n\nfloat sdCir(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat cir(vec2 p, float r)\n{\n    float sharp = abs(p.y)*400.;\n    \n    return sat(sat(-sdCir(p,r) / r) * sharp);\n}\n\nfloat loz(vec2 p, float r)\n{\n\tfloat sharp = abs(p.y)*400.;\n    \n    return sat(sat(-(lenny(p)-r) / r) * sharp);\n}\n\nvec4 cirRdr(vec2 p, float sz, float borderTh)\n{\n    float mixF = sin(iTime * 0.7+p.y*5.)*.6+.4;\n    float outerCir = mix(cir(p, sz), loz(p, sz), mixF);\n    float innerCir = mix(cir(p, sz - borderTh), loz(p, sz - borderTh), mixF);\n    \n    float mask = outerCir;\n    vec3 col = mix(vec3(abs(sin(p.y+iTime))*3., sz*10.,.5)*.35,vec3(0.), sat(innerCir));\n    return vec4(col*sat(mask), sat(mask));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 color = abs(sin(iTime*0.1))*2.*vec3(0.05,0.01,0.17)*sat(1.-length(uv))+vec3(1.)*pow(sat(1.-length(uv)),3.);\n    \n    \n    float sharp = 20.;\n    float szFlare = 1.;\n    color += .1*vec3(.5,.4,.2) * sat(sat(-(lenny(uv) - szFlare) / szFlare)*sharp) * (.5+abs(sin(iTime+uv.x+uv.y)));\n    \n    int i = 0;\n    int horizSteps = 5;\n    while (i < horizSteps)\n    {\n        float fi = float(i)-(float(horizSteps)*.5);\n        int j = 0;\n        int vertSteps = 50;\n        while (j < vertSteps)\n        {\n            float fj = float(j)-(float(vertSteps)*.5);\n            vec2 p = uv - vec2(fi*.5+sin(0.1*fj+iTime)*0.05, fj*.05*sin(-iTime*0.2+fi) + 0.03*sin(iTime + fj*.5));\n            float radSnd = .05*texelFetch(iChannel0, ivec2(int(abs(fj)*1.), 0), 0).x;\n            vec4 cirColMask = cirRdr(p, radSnd+0.15+0.005*sin(2.0*fj-iTime), 0.003+0.005*fj/float(vertSteps));\n    \t\tcolor = mix(color, cirColMask.xyz* 2.*sat(pow(sat(5.*(abs(fi)+2.*sin(iTime+fi*10.))/float(vertSteps)), 1.2)+.01), cirColMask.w);\n            ++j;\n        }\n        ++i;\n    }\n    \n\tfloat szFlarePost = 1.5;\n    color += 5.*vec3(.5,.4,.2)*(mod(iTime, 0.5)*.2+0.3)*pow(sat(sat((szFlarePost-lenny(uv*vec2(1.,3.)*.3)) / szFlarePost)),10.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n    uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n    uv *= 2.+2.*(sin(iTime*.25)*.5+.5);\n    //uv = uv*r2d(2.*length(uv)+.2*sin(iTime-length(uv)));\n    vec3 col = rdr(uv);\n    col *= vec3(.0)+1.*pow(sat(iTime*.5), 5.);\n\tcol = pow(col, vec3(1./2.2));\n    col = vec3(sat(col.x), sat(col.y), sat(col.z));\n    fragColor = vec4(col.zyx,1.0);\n}", "image_inputs": [{"id": 22910, "src": "https://soundcloud.com/vapenation/kenny-needs-to-sleep", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfRK.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 416, 416, 494], [496, 496, 517, 517, 549], [551, 551, 571, 571, 600], [602, 602, 632, 632, 660], [662, 662, 690, 690, 776], [778, 778, 806, 806, 891], [893, 893, 940, 940, 1288], [2550, 2550, 2607, 2607, 2987]], "test": "untested"}
{"id": "tdBfDW", "name": "The neon demo", "author": "friol", "description": "Turn off the lights.", "tags": ["neon"], "likes": 22, "viewed": 1455, "published": 3, "date": "1590347836", "time_retrieved": "2024-07-30T21:05:13.229262", "image_code": "\n// \n// friol 2o2o\n// a night-ish trip into flashing neon lights\n// music is generated\n// sdf functions by iq\n// pModPolar by mercury\n// beware of nicolas winding refn inner jokes\n// 25.05.2020: the bassline was going nuts after the first measures. Should be fixed.\n// 25.05.2020: same thing for the saw synth\n//\n\n\nconst int sdfIterationsAmount=256;\nfloat baryyy=0.0;\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions, int mode) {\n\tfloat angle = TAU/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = mode==0?length(p):length(cos(p.x)*sin(p.y));\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\treturn c;\n}\n\n// noby\nfloat spacehash(vec3 p3)\n{\n    p3 = fract(p3*.1031);\n\tp3 += dot(p3,p3.yzx+19.19);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n// starts at 48.0, ends at 64.0\nvec3 SDFNeonGeometry(vec3 r) // triangles, quads, etc., water below\n{\n    float t=10000.0;\n    const float attenuation=15.2;\n\n    vec3 cellId=floor(vec3(r.x-3.0,0.0,r.z-3.0)/12.0);\n    float hsh=spacehash(cellId);\n    \n    vec3 c=vec3(6.0,0.0,6.0);\n    r = mod(r+0.5*c,c)-0.5*c;\n    //r=r-vec3(0.0,.0,0.0);\n    r=rotz(r,iTime*2.0*(-0.5+hsh));\n    \n    pModPolar(r.xy,abs(cellId.x)+3.0,0);\n    \n    float neonBar=sdRoundedCylinder(r-vec3(0.8,0.0,0.0),0.012,0.035,1.4);\n    //float neonBar=sdTorus(r-vec3(0.0,.4,0.0),vec2(1.1,0.05));\n    t=min(t,neonBar);\n    \n    float glow = 1. / ( 1.0 + pow(abs(t*attenuation),.63));\n    return vec3(t,2.0,glow);\n}\n\n// triangle scene with rainbow neon - 64.0 - 80.0\nvec3 SDFNeonRainbowTriangles(vec3 r)\n{\n    float t=10000.0;\n    const float attenuation=150.0;\n\n    baryyy=atan(r.z,r.y);\n    \n    vec3 cellId=floor(vec3(r.x-6.0,0.0,r.z-6.0)/12.0);\n    float hsh=spacehash(cellId);\n    \n    vec3 c=vec3(0.0,0.0,12.0);\n    r = mod(r+0.5*c,c)-0.5*c;\n    r=r-vec3(0.0,1.0,0.0);\n    r=rotz(r,3.141592/2.0+(iTime*(hsh-0.5)));\n    \n    pModPolar(r.xy,3.0,0);\n    \n    float neonBar=sdRoundedCylinder(r-vec3(0.8,0.0,0.0),0.012,0.035,1.5);\n    t=min(t,neonBar);\n    \n    float glow = 1. / ( 1.0 + pow(abs(t*attenuation),.63));\n    return vec3(t,2.0,glow);\n}\n\n// a shitload of circles\nvec3 SDFNeonCircles(vec3 r)\n{\n    const float attenuation=350.2;\n\n    vec3 cellId=floor(vec3(r.x-3.0,0.0,r.z-3.0)/12.0);\n    float hsh=spacehash(cellId);\n    \n    vec3 c=vec3(0.0,0.0,6.0);\n    r = mod(r+0.5*c,c)-0.5*c;\n    r=rotz(r,iTime*(-0.5+hsh));\n    \n    pModPolar(r.xy,17.0,2);\n    \n    // change 0.8 to 0.1 for squares\n    float neonBar=sdRoundedCylinder(r-vec3(0.8,.0,0.0),0.012,0.035,1.4);\n    \n    float t=min(10000.0,neonBar);\n    float glow = 1. / ( 1.0 + pow(abs(t*attenuation),.63));\n    return vec3(t,2.0,glow);\n}\n\n// flying birds/waveforms scene\nvec3 SDFNeon(vec3 r)\n{\n    float t=10000.0;\n    float attenuation=85.0-80.0*sin(iTime*13.0);\n\n    vec3 cellId=floor(vec3((r.x-2.0)*8.0,0.0,r.z-4.0)/8.0);\n    float hsh=spacehash(cellId);\n\n    if (iTime<16.0) r.y*=0.5;\n    vec3 c=vec3((iTime<16.0)?1.0:8.0,0.0,16.0);\n    r = mod(r+0.5*c,c)-0.5*c;\n\n    float period=(iTime<16.0)?(hsh+iTime)*6.5:iTime*2.0;\n    vec3 r1=r-vec3(0.0,0.0,1.0);\n    r1=rotz(r,3.141592/2.0+sin(period));\n    vec3 r2=r-vec3(0.0,0.0,-1.0);\n    r2=rotz(r,3.141592/2.0-sin(period));\n    \n    // birds/waves\n\n    float neonBar=sdRoundedCylinder(r1-vec3(0.0,.5,0.0),0.012,0.035,.5);\n    t=min(t,neonBar);\n    float neonBar2=sdRoundedCylinder(r2-vec3(0.0,-.5,0.0),0.012,0.035,.5);\n    t=min(t,neonBar2);\n    \n    float glow = 1. / ( 1.0 + pow(abs(t*attenuation),.63));\n    return vec3(t,2.0,glow);\n}\n\nvec3 SDFMainScene(vec3 r)\n{\n    float t=10000.0;\n\n    if (iTime>80.0) return vec3(-1.0);\n    \n    float basePlane=(iTime>48.0)?sdPlane(r-vec3(0.0,-0.1*sin(r.x*10.0)*0.1*cos(r.z*10.0),0.0),vec4(0.0,1.0,0.0,1.0)):sdPlane(r-vec3(0.0,-0.9,0.0),vec4(0.0,1.0,0.0,1.0));\n    t=min(t,basePlane);\n    \n    // for birds scene\n    float sphere=((iTime>=8.0)&&(iTime<48.0))?sdSphere(r-vec3(0.0,(iTime<16.0)?1.0:0.0,.0+(iTime*8.0)+((iTime-22.0)/2.0)),1.0):10000.0;\n    t=min(t,sphere);\n\n    if (t==basePlane) return vec3(t,1.0,0.0);\n    if (t==sphere) return vec3(t,2.0,0.0);\n    \n    return vec3(-1.0);\n}\n\n//\n//\n//\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    float fogAmount = 1.0 - exp(-dist * 0.035);\n    return mix(c, fxcol, fogAmount);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFMainScene(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec4 rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float glow=0.0;\n    float t=0.0;\n    \n    // neon bars\n    vec3 curPoint = rayOrigin+rayDir ;\n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        vec3 sdfRes = (iTime<48.0)?SDFNeon(curPoint):(iTime<64.0)?SDFNeonGeometry(curPoint):(iTime<80.0)?SDFNeonRainbowTriangles(curPoint):SDFNeonCircles(curPoint);\n        float d=distance(curPoint,rayOrigin);\n        glow+=sdfRes[2]/((d*0.08+1.0)*(d*0.08+1.0));\n        curPoint+=rayDir*sdfRes[0];\n    }\n\n    // main scene part\n    vec3 res;\n    curPoint = rayOrigin+rayDir ;\n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        res = SDFMainScene(curPoint);\n        if (res[0] < (0.00001*t))\n        {\n    \t\treturn vec4(t,res[1],glow,0.0);\n        }\n        \n        curPoint+=rayDir*res[0];\n        t+=res[0];\n    }\n    \n    return vec4(-1.0,-1.0,glow,0.0);\n}\n\nvec3 reflekt(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col=vec3(0.);\n    vec4 rayHit = rayMarch(rayOrigin, rayDir);\n\n    float glowIntensity=rayHit[2];\n    if ((iTime>=64.0)&&(glowIntensity!=0.0))\n    {\n\t\tvec3 barColor = palette(1.0-baryyy, \n                           vec3(0.5),\n                           vec3(0.5),\n                          vec3(0.5),\n                          vec3(0.,0.3+iTime*0.5,0.7));        \n\t\tcol+= vec3(glowIntensity)*barColor;\n    }\n    else if (glowIntensity!=0.0) // blue-purple neon \n    {\n        vec3 barColor=mix(vec3(.3,.1,.3),vec3(.1,.1,.3),1.0-abs(sin(iTime)));\n\t\tcol+= vec3(glowIntensity)*barColor;\n    }\n    \n    //if (iTime<2.0) col.xyz*=(iTime/2.0);\n    //col=pow(col,vec3(0.78));\n    return col;\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 fogColor=vec3(0.02,0.1,0.2);\n    vec3 col=fogColor;\n    vec3 L=normalize(vec3(0.0,.7,-5.0));\n    \n    vec4 rayHit = rayMarch(rayOrigin, rayDir);\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n\n    vec3 N=calcNormal(pHit);\n    float dotprod=max(dot(N,L),0.0);\n\n    vec3 refcol=reflekt(pHit,normalize(reflect(rayDir,N)));\n    \n    if (mat==1.0) // floor\n    {\n        col=mix(col,refcol,0.5)*0.1;\n        col=fog(col,distance(rayOrigin,pHit),fogColor);\n    }\n    else if (mat==2.0)\n    {\n        col=refcol.xyz*pow(dotprod,256.0)*8.0;\n    }\n\n    float glowIntensity=rayHit[2];\n    if ((iTime>64.0)&&(glowIntensity!=0.0)) // rainbow neon bar\n    {\n        //vec3 pBar=rayOrigin+rayDir*rayHit[3];\n\t\tvec3 barColor = palette((baryyy), \n                           vec3(0.5),\n                           vec3(0.5),\n                          vec3(0.5),\n                          vec3(0.,0.3+iTime*0.5,0.7));        \n\t\tcol+= vec3(glowIntensity)*barColor;\n        //col=fog(col,distance(rayOrigin,pBar),fogColor);\n    }\n    else if (glowIntensity!=0.0) // neon bar\n    {\n        vec3 barColor=(iTime<48.0)?mix(vec3(.5,.3,.5),vec3(.3,.3,.5),1.0-abs(sin(iTime))):mix(vec3(.3,.1,.3),vec3(.1,.1,.3),1.0-abs(sin(iTime)));\n\t\tcol+= 1.4*vec3(glowIntensity)*barColor;\n    }\n    \n    col=pow(col,vec3(0.78));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime*8.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    if (iTime<16.0) // intro, waveforms\n    {\n        camPos=vec3(8.0*sin(2.0),0.0,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,1.0+myTime);\n    }\n    else if ((iTime>=16.0)&&(iTime<24.0)) // sphere entering\n    {\n        camPos=vec3(0.0,2.0,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,1.0+myTime);\n    }\n    else if ((iTime>=24.0)&&(iTime<32.0)) // sphere from above\n    {\n        camPos=vec3(8.0*sin(-2.0),8.0*sin(2.0)-1.0,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,1.0+myTime);\n    }\n    else if ((iTime>=32.0)&&(iTime<48.0)) // rotate\n    {\n        camPos=vec3(0.0,8.0*sin((iTime-32.0)/8.0)+1.0,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,3.0+myTime);\n    }\n    else if ((iTime>=48.0)&&(iTime<52.0)) // center square\n    {\n        camPos=vec3(0.0,0.0,-5.5+myTime*1.52);\n        camTarget=vec3(0.0,0.0,3.0+myTime*1.52);\n    }\n    else if ((iTime>=52.0)&&(iTime<56.0)) // center triangle\n    {\n        camPos=vec3(6.0,0.0,-5.5+myTime*1.52);\n        camTarget=vec3(6.0,0.0,3.0+myTime*1.52);\n    }\n    else if ((iTime>=56.0)&&(iTime<60.0)) // center pentagon\n    {\n        camPos=vec3(-12.0,0.0,-5.5+myTime*1.52);\n        camTarget=vec3(-12.0,0.0,3.0+myTime*1.52);\n    }\n    else if ((iTime>=60.0)&&(iTime<64.0)) // center square\n    {\n        camPos=vec3(0.0,0.0,-5.5+myTime*1.52);\n        camTarget=vec3(0.0,0.0,3.0+myTime*1.52);\n    }\n    else\n    {\n        camPos=vec3(0.0,2.5,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,myTime);\n    }\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4((render(camPos, rayDir,uv,fragCoord).xyz),1.0);\n\n    if (iTime<2.0) finalCol.xyz*=(iTime/2.0);\n    if (iTime>=88.0) finalCol.xyz*=max((4.0-(iTime-88.0))/4.0,0.0);\n    fragColor=finalCol;\n}\n", "image_inputs": [], "common_code": "\n#define PI 3.1415926535\n#define TAU 6.2831853071\n\n// rainbow function\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a+b*cos(TAU*(c*t+d));\n}\n\n", "sound_code": "\n//\n// hand-written music.\n//\n\n// notes\nconst float nC  = 261.63;\nconst float nCs  = 277.18;\nconst float nD  = 293.66;\nconst float nDs  = 311.13;\nconst float nE  = 329.63;\nconst float nF  = 349.23;\nconst float nFs = 369.99;\nconst float nG  = 392.0;\nconst float nGs  = 415.30;\nconst float nA  = 440.0;\nconst float nAs  = 466.16;\nconst float nB  = 493.88;\n\n//\n// and's reverb\n//\n\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float tt = fract(t);\n    float tn = t - tt;\n    tt = smoothstep(0.0, 1.0, tt);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, tt);\n}\n\nfloat sine(float x)\n{\n    return sin(TAU * x);\n}\n\nvec2 sine(vec2 v) { return vec2(sine(v.x), sine(v.y)); }\n\nvec2 andBell(float t,float freq,float panning)\n{\n    vec2 w = vec2(sine(t * freq) * exp(-t * 2.5));\n    \n    vec2 r = lpnoise(t,  100.0)\n        + lpnoise(t,  550.0) * 0.2\n        + lpnoise(t, 1050.0) * 0.1 * exp(-t * 5.0);\n\n    w += sine(t * freq + r * 0.1) * exp(-t * 2.0);\n    w -= sine(t * freq          ) * exp(-t * 2.0);\n\n    w *= 1.0 - exp(-t * 800.0);\n\n    return vec2(w.x*panning,w.y*(1.0-panning))*0.25;\n}\n\n//\n// kick\n//\n\nfloat modfix(float phase) {\n    return mod(phase, TAU);\n}\n\nfloat sinf(float t, float freq) {\n\treturn sin(modfix(TAU * t * freq));\n}\n\nfloat kick(float t) \n{\n    return clamp(1.25 * sinf(t, 90. * exp(-t * 5.0)) * exp(-t * 5.), -1.0, 1.0) * smoothstep(0.001, 0.003, t);\n}\n\n\n//\n// 303-ish bass\n//\n\nfloat sinharm(float freq,float t,int nHarmonics)\n{\n    float s0 = sin(TAU*freq*t);\n    for(int i = 0; i < nHarmonics; ++i)\n    {\n        float harm = float(1 + i);\n        s0 += sin(TAU*(0.61 + freq * harm)*t) / harm;\n    }\n\n    return s0;\n}\n\n//\n// saw\n//\n\nfloat sawpitch(float p) {\n\treturn pow(1.059460646483, p) * 440.0;\n}\n\nfloat saw(float phase) \n{\n    float s = 0.0;\n    for (int k=1; k < 17; k++) {\n        s += (sin(TAU*float(k)*phase) / float(k));\n    }\n    return -(1.0/PI)*s;\n}\n\nfloat sawSynth(float t,vec3 notes)\n{\n    // good triads: 0,2,7 0,3,7 0,3,2\n    float s = 0.0;\n    float semitones[3];\n    semitones[0] = notes.x;\n    semitones[1] = notes.y;\n    semitones[2] = notes.z;\n    \n    for (int i=0;i<3;i++) \n    {\n        float f = sawpitch(semitones[i]);\n        \n        for (int u=0;u<3;u++) {\n            float fu = float(u);\n            float new_f = f + fu*sin(fu);\n    \t\ts += saw(t * new_f)*0.11111111111111;\n        }\n    }\n    \n    return s;    \n}\n\nvec2 reverbChannelS(float t,vec3 notes) \n{\n    return vec2(sawSynth(t,notes)*0.8);\n}\n\n// hi-hat\n\nvec2 hihat(float time,float panning,float triplets)\n{\n    float tb = mod(time * 2.0, 8.);\n    float hihat=(fract(cos(time * 234.523) * 7862134.) * exp(mod(tb, 1. / triplets) / 2.0 * -120.)*(fract(tb) + .2));\n    return vec2(hihat*triplets,hihat*(1.0-triplets))*0.05;\n}\n\n//\n//\n//\n\n#define bassSequence1(starttime,endtime) if ((time>=starttime)&&(time<endtime)) finalSound+=sinharm((float[](nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0)[int(mod(time,16.0)*8.0) % 16]), mod(time-starttime,16.0),16+int(8.0*sin(time)))*0.02;\n#define bassSequence2(starttime,endtime) if ((time>=starttime)&&(time<endtime)) finalSound+=sinharm((float[](nE/8.0,0.0,nE/4.0,0.0,nE/8.0,0.0,nE/4.0,0.0,nE/8.0,0.0,nE/4.0,0.0,nE/8.0,0.0,nE/4.0,0.0)[int(mod(time,16.0)*8.0) % 16]), mod(time-starttime,16.0),16+int(8.0*sin(time)))*0.02;\n#define bassSequence3(starttime,endtime) if ((time>=starttime)&&(time<endtime)) finalSound+=sinharm((float[](nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0)[int(mod(time,16.0)*8.0) % 16]), mod(time-starttime,16.0),16+int(8.0*sin(time)))*0.02;\n\n#define vibratoSynth1(starttime,endtime,notes) if ((time>=starttime)&&(time<endtime)) finalSound+=reverbChannelS(mod(time-starttime,16.0),notes)*(0.1*abs(sin((time-starttime)*36.0)))*(0.05+sin((time-starttime)/2.5));\n\n#define hihatsss(starttime,endtime,panning,triplets) if ((time>=starttime)&&(time<endtime)) finalSound+=hihat(time,panning,triplets);\n\n#define bells(starttime,pitch,panning,volume) if (time>=starttime) finalSound+=andBell(time-starttime,pitch,panning)*volume;\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 finalSound=vec2(0.0);\n    \n    //time+=48.0;\n    \n    vec4 snotes[40];\n    snotes[0]=vec4(48.0,nA*2.0,0.75,0.8);\n\n    snotes[24]=vec4(48.0,nA*1.0,0.50,0.3);\n    snotes[25]=vec4(48.25,nE*2.0,0.50,0.3);\n    snotes[26]=vec4(48.50,nA*4.0,0.50,0.2);\n    snotes[27]=vec4(48.75,nE*8.0,0.50,0.2);\n    \n    snotes[1]=vec4(49.0,nA*2.0,0.55,0.25);\n    snotes[2]=vec4(50.0,nA*2.0,0.35,0.05);\n    \n    snotes[3]=vec4(51.0,nE*2.0,0.75,0.8);\n    snotes[4]=vec4(52.0,nF*2.0,0.25,0.8);\n\n    snotes[28]=vec4(52.0,nA*1.0,0.50,0.3);\n    snotes[29]=vec4(52.25,nF*2.0,0.50,0.3);\n    snotes[30]=vec4(52.50,nC*4.0,0.50,0.2);\n    snotes[31]=vec4(52.75,nG*8.0,0.50,0.2);\n    \n    \n    snotes[5]=vec4(56.0,nC*4.0,0.75,0.8);\n\n    snotes[32]=vec4(56.0,nA*1.0,0.50,0.3);\n    snotes[33]=vec4(56.25,nG*2.0,0.50,0.3);\n    snotes[34]=vec4(56.50,nD*4.0,0.50,0.2);\n    snotes[35]=vec4(56.75,nA*8.0,0.50,0.2);\n    \n    snotes[6]=vec4(59.0,nE*4.0,0.25,0.8);\n    snotes[7]=vec4(60.0,nF*2.0,0.50,0.8);\n\n    snotes[36]=vec4(60.0,nA*1.0,0.50,0.3);\n    snotes[37]=vec4(60.25,nF*2.0,0.50,0.3);\n    snotes[38]=vec4(60.50,nC*4.0,0.50,0.2);\n    snotes[39]=vec4(60.75,nG*8.0,0.50,0.2);\n    \n    // 4 final arpeggios\n    snotes[8]=vec4(64.0,nA*1.0,0.50,0.3);\n    snotes[9]=vec4(64.25,nE*2.0,0.50,0.3);\n    snotes[10]=vec4(64.50,nA*4.0,0.50,0.2);\n    snotes[11]=vec4(64.75,nE*8.0,0.50,0.2);\n\n    snotes[12]=vec4(68.0,nA*1.0,0.50,0.3);\n    snotes[13]=vec4(68.25,nF*2.0,0.50,0.3);\n    snotes[14]=vec4(68.50,nC*4.0,0.50,0.2);\n    snotes[15]=vec4(68.75,nG*8.0,0.50,0.2);\n\n    snotes[16]=vec4(72.0,nA*1.0,0.50,0.3);\n    snotes[17]=vec4(72.25,nG*2.0,0.50,0.3);\n    snotes[18]=vec4(72.50,nD*4.0,0.50,0.2);\n    snotes[19]=vec4(72.75,nA*8.0,0.50,0.2);\n\n    snotes[20]=vec4(76.0,nA*1.0,0.50,0.3);\n    snotes[21]=vec4(76.25,nE*2.0,0.50,0.3);\n    snotes[22]=vec4(76.50,nA*4.0,0.50,0.2);\n    snotes[23]=vec4(76.75,nA*8.0,0.50,0.2);\n    \n    for (int i=0;i<40;i++)\n    {\n    \tbells(snotes[i].x,snotes[i].y,snotes[i].z,snotes[i].w);\n    }\n    \n    vibratoSynth1(16.0,16.0+8.0,vec3(0.0,3.0,7.0));\n    vibratoSynth1(16.0+8.0,16.0+16.0,vec3(0.0,3.0,10.0));\n    vibratoSynth1(16.0+16.0,16.0+16.0+8.0,vec3(0.0,3.0,2.0));\n    vibratoSynth1(16.0+24.0,16.0+31.0,vec3(0.0,3.0,7.0));\n\n    //finalSound += reverbChannelK(mod(time,0.5))*2.5;\n    finalSound += kick(mod(time,0.5))*2.5*0.12;\n    \n\thihatsss(8.0,16.0,0.50,2.0);\n\thihatsss(16.0,48.0,0.50+0.10*sin(time),2.0);\n\t//hihatsss(48.0,64.0,0.50,4.0+sin(time)*2.0); // hihat roll\n\thihatsss(48.0,64.0,0.50,4.0);\n\thihatsss(64.0,64.0+16.0,0.50,4.0);\n    \n    bassSequence1(8.0,8.0+8.0);\n    bassSequence1(16.0,16.0+8.0);\n    bassSequence2(16.0+8.0,16.0+8.0+8.0);\n    bassSequence3(16.0+16.0,16.0+16.0+8.0);\n    bassSequence1(16.0+24.0,16.0+24.0+8.0);\n\n    // bell apart\n    bassSequence1(48.0,48.0+4.0);\n    bassSequence3(52.0,52.0+4.0);\n    bassSequence1(56.0,56.0+4.0);\n    bassSequence3(60.0,60.0+4.0);\n    bassSequence1(64.0,80.0);\n    \n    if (time<8.0) finalSound*=(time)/8.0; // initial fadein\n    if (time>=88.0) finalSound*=max((4.0-(time-88.0))/4.0,0.0); // fadeout\n    return finalSound*2.2;\n}\n", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 401, 401, 512], [514, 514, 545, 545, 656], [658, 658, 689, 689, 800], [802, 802, 837, 837, 861], [863, 863, 896, 896, 929], [931, 931, 995, 995, 1112], [1114, 1114, 1174, 1174, 1399], [1401, 1409, 1435, 1435, 1528], [1530, 1562, 1631, 1631, 2211], [2213, 2263, 2301, 2301, 2845], [2847, 2872, 2901, 2901, 3400], [3402, 3434, 3456, 3456, 4250], [4252, 4252, 4279, 4279, 4844], [4856, 4856, 4898, 4898, 4985], [4987, 4987, 5014, 5014, 5260], [5262, 5262, 5306, 5306, 6123], [6125, 6125, 6168, 6168, 6863], [6865, 6865, 6932, 6932, 8281], [8283, 8283, 8343, 8343, 8594], [8596, 8596, 8642, 8642, 8766], [8768, 8768, 8825, 8825, 10650]], "test": "untested"}
{"id": "tdjBzG", "name": "2d Distance by Level Set Method", "author": "poke53281", "description": "This shader computes the signed distance function of an arbitrary designed border via the reinitialization function of the so called Level Set Method. Description in Buffer B.\n\nPress space to see the initial map, which defines interior and exterior.\n\n", "tags": ["2d", "sdf", "distance"], "likes": 5, "viewed": 530, "published": 3, "date": "1590335183", "time_retrieved": "2024-07-30T21:05:14.122872", "image_code": "const int KEY_SPACE  = 32;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (texelFetch( iChannel2, ivec2(KEY_SPACE, 0),0 ).x > 0.) {\n    \tfragColor = vec4(texture(iChannel1, uv).r + 1. * 0.5, 0., 0., 1.);\n    } else {\n        vec4 c = texture(iChannel0, uv);\n    \n        if (abs(c.r) < 1.) {\n            fragColor = vec4(1);\n        } else\n        if (c.r < 0.0) {\n            fragColor = vec4(min(-c.r*0.03, 1.), 0., 0. ,1);\n        } else\n        {\n            fragColor = vec4(0., 0., min(c.r*0.03, 1.), 1);\n        }  \n    }\n    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This buffer contains just the scene and is initialized at the beginning\n// values are either 1 or -1 and define either the interior and outerior.\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\nvec4 InitScene(in vec2 fragCoord){\n    vec2 time = vec2(iTime * 923.213456123, -iTime * 995.84367);\n\treturn vec4( fbm(fragCoord*0.01 + time)<0.?-1.:1., 0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1) {\n        vec2 step = 1. / iResolution.xy;\n        // The algorithm seems more stable when the borders are averaged.\n        fragColor = vec4(0);\n        fragColor += InitScene(fragCoord + step*vec2(-1., -1.));\n        fragColor += InitScene(fragCoord + step*vec2( 0., -1.));\n        fragColor += InitScene(fragCoord + step*vec2(-1., -1.));\n        fragColor += InitScene(fragCoord + step*vec2( 0., -0.));\n        fragColor += InitScene(fragCoord + step*vec2( 1., -0.));\n        fragColor += InitScene(fragCoord + step*vec2(-1., -0.));\n        fragColor += InitScene(fragCoord + step*vec2( 0.,  1.));\n        fragColor += InitScene(fragCoord + step*vec2( 1.,  1.));\n        fragColor += InitScene(fragCoord + step*vec2( 1.,  1.));\n        fragColor /= 9.;\n        return;\n    }\n\n    // just copy input to output. \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    return;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// A signed distance function P(x,y), satisfied the condition \n//\n// |grad P| = 1 \n//\n// or  \n//\n// L = |grad P| - 1 = 0\n//\n// This code solves the so called level set method reinitialization \n// equation \n//\n// dP/dt = - P0 * L\n//\n// with P0(x,y) containing the initial shapes. \n// The solution converges and is in a steady state when L = 0.\n//\n// To stabilize the algorithm, you have to use high order discretization schemes \n// such as WENO (https://en.wikipedia.org/wiki/WENO_methods) and\n// upwind schemes (https://en.wikipedia.org/wiki/Upwind_scheme)\n\n#define timestep 0.2\n\n#define getSign(uv)  texture(iChannel1, uv).r\n#define fetchDistance(x) texture(iChannel0, uv + step * x).r\n\n// fifth order WENO discretization or ordinary first order discretization\n#define WENO\n\n\nfloat upwind(float grad_left, float grad_right, float sign0) {\n    if ((grad_left*sign0 < -grad_right*sign0) && (grad_right*sign0 < 0.)) {\n\t    return grad_right;\n    } else \n    if ((grad_left*sign0 > 0.) && (grad_right*sign0 > -grad_left*sign0)) {\n        return grad_left;\n    }\n    return 0.;\n}\n\n// calculates the gradient using the WENO scheme\nfloat weno_gradient(\n    float Psinnn, \n    float Psinn, \n    float Psin, \n    float Psi, \n    float Psip, \n    float Psipp, \n    float Psippp,\n    float dx, bool positive)\n{\n    const float e = 1e-6;\n    float q1, q2, q3, q4, q5, is1, is2, is3, a1, a2, a3, w1, w2, w3;\n    if (positive)\n    {\n        q1 =  (Psippp-Psipp)/dx;\n        q2 =  (Psipp-Psip)/dx;\n        q3 =  (Psip-Psi)/dx;\n        q4 =  (Psi-Psin)/dx;\n        q5 =  (Psin-Psinn)/dx;\n    } else\n    {\n        q1 =  (Psinn-Psinnn)/dx;\n        q2 =  (Psin-Psinn)/dx;\n        q3 =  (Psi-Psin)/dx;\n        q4 =  (Psip-Psi)/dx;\n        q5 =  (Psipp-Psip)/dx;\n    }\n    \n    is1 = 13./12.*(q1-2.*q2+q3)*(q1-2.*q2+q3)+0.25*(q1-4.*q2+3.*q3)*(q1-4.*q2+3.*q3);\n    is2 = 13./12.*(q2-2.*q3+q4)*(q2-2.*q3+q4)+0.25*(q2-q4)*(q2-q4);\n    is3 = 13./12.*(q3-2.*q4+q5)*(q3-2.*q4+q5)+0.25*(3.*q3-4.*q4+q5)*(3.*q3-4.*q4+q5);\n    a1 = 0.1/((e+is1)*(e+is1));\n    a2 = 0.6/((e+is2)*(e+is2));\n    a3 = 0.3/((e+is3)*(e+is3));\n    w1 = a1/(a1+a2+a3);\n    w2 = a2/(a1+a2+a3);\n    w3 = a3/(a1+a2+a3);\n    return  w1*(q1/3.-7.*q2/6.+11.*q3/6.)+w2*(-q2/6.+5.*q3/6.+q4/3.)+w3*(q3/3.+5.*q4/6.-q5/6.);\n}\n\n\n// calculates gradient of the distance map\nvec2 gradient(vec2 uv, float sign0) {\n    vec2 step = 1. / iResolution.xy;\n    \n    float c   = fetchDistance(vec2( 0.,  0.));\n    float eee = fetchDistance(vec2( 3.,  0.));\n    float ee  = fetchDistance(vec2( 2.,  0.));\n    float e   = fetchDistance(vec2( 1.,  0.));\n    float w   = fetchDistance(vec2(-1.,  0.));\n    float ww  = fetchDistance(vec2(-2.,  0.));\n    float www = fetchDistance(vec2(-3.,  0.));\n    float nnn = fetchDistance(vec2( 0.,  3.));\n    float nn  = fetchDistance(vec2( 0.,  2.));\n    float n   = fetchDistance(vec2( 0.,  1.));\n    float s   = fetchDistance(vec2( 0., -1.));\n    float ss  = fetchDistance(vec2( 0., -2.));\n    float sss = fetchDistance(vec2( 0., -3.));\n\n    // using cellwidth and cellheight = 1\n#ifdef WENO \n    float gradxp = weno_gradient(www,ww,w,c,e,ee,eee, 1., true);\n    float gradxm = weno_gradient(www,ww,w,c,e,ee,eee, 1., false);\n    float gradyp = weno_gradient(nnn,nn,n,c,s,ss,sss, 1., true);\n    float gradym = weno_gradient(nnn,nn,n,c,s,ss,sss, 1., false);\n#else\n    float gradxp = (e-c); \n    float gradxm = (c-w);\n    float gradyp = (n-c);\n    float gradym = (c-s);\n#endif\n    \n    // choose the right gradient to stabilize\n    vec2 grad = vec2(upwind(gradxm, gradxp, sign0), \n                     upwind(gradym, gradyp, sign0));\n    \n    return grad;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float sign0 = getSign(uv);\n    \n    // reset signed distance function\n    if (iFrame < 1) {\n        fragColor = vec4(sign0);\n        return;\n    }\n    \n    float L = length(gradient(uv, sign0)) - 1.;\n    \n    // Two step Adams-Bashforth time integration\n    // r contains old value and g the previous right hand side.\n    float dPdt = -sign0*L;\n    vec4 old_distance = texture(iChannel0, uv);\n    float new_distance = old_distance.r + timestep * (3./2.*dPdt - 1./2.*old_distance.g);\n    \n    fragColor = vec4(new_distance, dPdt, 0., 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 599]], "test": "untested"}
{"id": "3dBfzK", "name": "Origami Kaleidescope", "author": "jayprich", "description": "Colour depends on final relative angle of a path toward the point taking steps with decreasing size where each turn is a multiples of a time varying angle.", "tags": ["iterate"], "likes": 0, "viewed": 312, "published": 3, "date": "1590333011", "time_retrieved": "2024-07-30T21:05:14.969609", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a=.6+.1*mod(.03*iTime,1.);\n    float b=sqrt(1.-a*a);\n    float c=a/b;\n    mat2 m=mat2(a,-b,b,a);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = vec2(-.6,-.2)+.7*uv;\n\tuv.x *= iResolution.x/iResolution.y;\n    for(int i=8;i>0;i--){\n     while(uv.y>0.||uv.x>c*uv.y)uv*=m;\n     uv*=.85;\n     uv+=vec2(.07,-.035);\n    }\n\tfloat d = .4+.2*atan(uv.x,uv.y);\n\tfragColor = vec4(vec3(d,d*d,1.-d),1.);\n    if(uv.x-uv.y<.05)fragColor=vec4(0.,.5,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 512]], "test": "untested"}
{"id": "3dBBzK", "name": "Emoji Roling", "author": "yasuo", "description": "Created just 10 emoji.", "tags": ["emoji"], "likes": 15, "viewed": 476, "published": 3, "date": "1590329674", "time_retrieved": "2024-07-30T21:05:15.724591", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nvec3 faceBase(vec2 p, vec3 col) {\n    float d = length(p)-0.1;\n    col = mix(col,vec3(0.9,0.8,0.0),S(d,0.0));\n    d = length(p)-0.11;\n    col = mix(col,vec3(0.9,0.9,0.0),S(d,-0.03));\n    return col;\n}\n\nvec3 shades(vec2 p, vec3 col){\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=1.3;\n    d = length(p-vec2(0.0,0.02))-0.09;\n    float d2 = length(p-vec2(0.0,0.07))-0.13;\n    d = max(-d2,d);\n\n    p = prevUV;\n    p.y*=1.1;\n    p.x = abs(p.x);\n    p.x-=0.05;\n    d2 = sdBox((p-vec2(0.0,0.01))*Rot(radians(-10.0)),vec2(0.018,0.007))-0.025;\n    d = min(d,d2);\n    p.x+=0.007;\n    d2 = sdBox((p-vec2(0.0,0.04))*Rot(radians(-10.0)),vec2(0.06,0.01));\n    d = min(d,d2);\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 upsidedown(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=1.3;\n    d = length(p-vec2(0.0,-0.03))-0.09;\n    float d2 = length(p-vec2(0.0,-0.08))-0.13;\n    d = max(-d2,d);\n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.035;\n    p.y*=0.8;\n    d2 = length(p-vec2(0.0,-0.025))-0.01;\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 nomouth(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.035;\n    p.y*=0.8;\n    d = length(p-vec2(0.0,0.015))-0.01;\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 expressionless(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x = abs(p.x);\n    p.x -= 0.03;\n    p.y*=1.8;\n    d = sdBox(p-vec2(0.0,0.02),vec2(0.01,0.005))-0.01;\n    p = prevUV;\n    p.y*=1.5;\n    float d2 = sdBox(p-vec2(0.0,-0.05),vec2(0.04,0.0001))-0.01;\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 neutral(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x = abs(p.x);\n    p.x -= 0.03;\n    p.y*=0.8;\n    d = length(p-vec2(0.0,0.015))-0.01;\n    \n    p = prevUV;\n    p.y*=1.5;\n    float d2 = sdBox(p-vec2(0.0,-0.05),vec2(0.04,0.0001))-0.01;\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 flowningface(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=1.5;\n    p.y+=0.19;\n    d = length(p-vec2(0.0,0.07))-0.09;\n    float d2 = length(p-vec2(0.0,0.02))-0.13;\n    d = max(-d2,d);\n\n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.035;\n    p.y*=0.8;\n    d2 = length(p-vec2(0.0,0.01))-0.01;\n    d = min(d,d2);\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 angly(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=2.0;\n    p.y+=0.2;\n    d = length(p-vec2(0.0,0.07))-0.08;\n    float d2 = length(p-vec2(0.0,0.02))-0.125;\n    d = max(-d2,d);\n\n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.025;\n    p.y*=0.8;\n    d2 = length(p-vec2(0.0,-0.015))-0.01;\n    d = min(d,d2);\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.03;\n    d = sdBox((p-vec2(0.0,0.012))*Rot(radians(-30.0)),vec2(0.015,0.001))-0.003;\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 disapointed(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.y*=1.2;\n    p.x*=2.0;\n    p.y+=0.21;\n    d = length(p-vec2(0.0,0.07))-0.08;\n    float d2 = length(p-vec2(0.0,0.02))-0.125;\n    d = max(-d2,d);\n\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.04;\n    d = sdBox((p-vec2(0.0,-0.02))*Rot(radians(15.0)),vec2(0.02,0.001))-0.003;\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 flushed(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=1.5;\n    d = sdBox(p-vec2(0.0,-0.065),vec2(0.025,0.001))-0.003;\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    p = prevUV;\n    \n    p.x = abs(p.x);\n    p.x -= 0.045;\n    d = sdBox((p-vec2(0.0,0.07))*Rot(radians(10.0)),vec2(0.015,0.001))-0.003;\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.045;\n    d = length(p-vec2(0.0,0.005))-0.035;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = length(p-vec2(0.0,0.005))-0.01;\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 rolingEye(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=1.5;\n    d = sdBox(p-vec2(0.0,-0.065),vec2(0.025,0.001))-0.003;\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.045;\n    d = length(p-vec2(0.0,0.005))-0.035;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = length(p-vec2(0.0,0.028))-0.013;\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 smile(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=1.3;\n    d = length(p-vec2(0.0,0.03))-0.09;\n    float d2 = length(p-vec2(0.0,0.08))-0.13;\n    d = max(-d2,d);\n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.035;\n    p.y*=0.8;\n    d2 = length(p-vec2(0.0,0.025))-0.01;\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 smile2(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=1.3;\n    p.y*=0.95;\n    d = length(p-vec2(0.0,0.02))-0.09;\n    float d2 = length(p-vec2(0.0,0.08))-0.12;\n    d = max(-d2,d);\n    d = max((prevUV.y+0.023),d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n\t\n    p.y+=0.005;\n    p.x*=1.1;\n    p.y*=1.2;\n    d = length(p-vec2(0.0,0.03))-0.09;\n    d2 = length(p-vec2(0.0,0.09))-0.135;\n    d = max(-d2,d);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevUV;\n    p.y-=0.02;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.y+=0.021;\n    p.x -= 0.035;\n    p.y*=0.8;\n    d = sdBox((p-vec2(0.0,0.025))*Rot(radians(-20.0)), vec2(0.02,0.0001))-0.001;\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 openMouth(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.035;\n    p.y*=0.8;\n    d = length(p-vec2(0.0,0.015))-0.01;\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    p = prevUV;\n    p.x*=1.1;\n    d = length(p-vec2(0.0,-0.04))-0.02;\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 tear(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p.x*=2.0;\n    p.y+=0.19;\n    d = length(p-vec2(0.0,0.07))-0.08;\n    float d2 = length(p-vec2(0.0,0.02))-0.125;\n    d = max(-d2,d);\n\n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.03;\n    p.y*=0.8;\n    d2 = length(p-vec2(0.0,0.005))-0.01;\n    d = min(d,d2);\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    p = prevUV;\n    p.y-=0.03;\n    p.x = abs(p.x);\n    p.x -= 0.035;\n    d = sdBox((p-vec2(0.0,0.012))*Rot(radians(30.0)),vec2(0.015,0.001))-0.003;\n    \n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    p = prevUV;\n    d = sdUnevenCapsule(p-vec2(-0.045,-0.06),0.02,0.002,0.04);\n    col = mix(col,vec3(0.5,0.6,1.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 tongue(vec2 p, vec3 col) {\n    vec2 prevUV = p;\n                    \n    float d;\n    col = faceBase(p,col);\n\n    p = prevUV;\n    p.x = abs(p.x);\n    p.x -= 0.035;\n    p.y*=0.8;\n    d = length(p-vec2(0.0,0.015))-0.01;\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    p = prevUV;\n    p.x*=0.6;\n    d = length(p-vec2(0.0,-0.04))-0.03;\n    d = max(p.y+0.037,d);\n    col = mix(col,vec3(0.0,0.0,0.0),S(d,0.0));\n    \n    p = prevUV;\n    p.x*=1.4;\n    p.y*=0.7;\n    d = length(p-vec2(0.0,-0.03))-0.03;\n    d = max(p.y+0.03,d);\n    col = mix(col,vec3(0.8,0.0,0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawEmoji(vec2 p, vec3 col, int num) {\n    if(num == 0) {\n        return smile(p,col);\n    } else if(num == 1){\n        return nomouth(p,col);\n    } else if(num == 2){\n        return shades(p,col);\n    } else if(num == 3){\n        return upsidedown(p,col);\n    } else if(num == 4){\n        return expressionless(p,col);\n    } else if(num == 5){\n        return neutral(p,col);\n    } else if(num == 6){\n        return flowningface(p,col);\n    } else if(num == 7){\n        return angly(p,col);\n    } else if(num == 8){\n        return disapointed(p,col);\n    } else if(num == 9){\n        return flushed(p,col);\n    } else if(num == 10){\n        return smile2(p,col);\n    } else if(num == 11){\n        return openMouth(p,col);\n    } else if(num == 12){\n        return tear(p,col);\n    } else if(num == 14){\n        return tongue(p,col);\n    }\n    \n    return rolingEye(p,col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV =uv;\n   \n    vec3 col = vec3(1.0);\n\tfloat t = iTime*0.2;\n\n\tuv.y+=t;\n    uv.x = mod(uv.x,1.25)-0.625;\n\tuv.y = mod(uv.y,1.0)-0.5;\n\n    float speed = 2.0;\n    for(int i = 0; i<32; i++) {\n        int frame = int(mod(iTime*speed+float(i),15.0));\n        float x = float(i%8)*0.25-1.0;\n        float y = floor(float(i/8))*0.25-0.38;\n        col = drawEmoji(uv-vec2(x,y),col,frame);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 210, 247, 247, 327], [329, 380, 442, 442, 681], [683, 683, 716, 716, 883], [885, 885, 915, 915, 1454], [1456, 1456, 1491, 1491, 1894], [1896, 1896, 1928, 1928, 2189], [2191, 2191, 2230, 2230, 2602], [2604, 2604, 2636, 2636, 2998], [3000, 3000, 3037, 3037, 3447], [3449, 3449, 3479, 3479, 4086], [4088, 4088, 4124, 4124, 4615], [4617, 4617, 4649, 4649, 5280], [5282, 5282, 5316, 5316, 5764], [5766, 5766, 5796, 5796, 6196], [6198, 6198, 6229, 6229, 6978], [6980, 6980, 7014, 7014, 7387], [7389, 7389, 7418, 7418, 8170], [8172, 8172, 8203, 8203, 8773], [8775, 8775, 8818, 8818, 9653], [9655, 9655, 9712, 9712, 10207]], "test": "untested"}
{"id": "tdjBzy", "name": "Just a game with colors", "author": "Vlademir", "description": "Bruh. -_-", "tags": ["test", "color", "boredom"], "likes": 2, "viewed": 432, "published": 3, "date": "1590320401", "time_retrieved": "2024-07-30T21:05:16.478574", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col1=texture(iChannel0, fragCoord/iResolution.xy) ,\n        col2=1. -(1. -col1)*(1. -col1), \n        col3=vec4(vec2(min(col2.r*0.2+col2.g*1.,1.)), col2.ba), \n        col5=vec4(vec3(1.-dot(1.-col3, 1.-col3)/sqrt(3.)),1.)\n        ;\n    fragColor=vec4(col3.rgb*1.+col5.rgb*0.1,1.);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 347]], "test": "untested"}
{"id": "tdjBRy", "name": "My 2D Clouds", "author": "takahiroando", "description": "Simplified cloud shader with my learning memo in comments\nbased on: https://www.shadertoy.com/view/4tdSWr", "tags": ["fractal", "noise", "clouds", "fbm"], "likes": 15, "viewed": 1324, "published": 3, "date": "1590315495", "time_retrieved": "2024-07-30T21:05:17.238542", "image_code": "const float cloudscale = 2.5; // 1.1\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n// <personal favorite noise funcs>\nfloat hash(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(123.45, 678.9))) * 987654.321);\n}\n\nfloat noise(vec2 uv) {\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\tvec2 b = smoothstep(0.0, 1.0, f);\n\treturn 2.0 * mix(\n\t\tmix(hash(i), hash(i + vec2(1.0, 0.0)), b.x),\n\t\tmix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), b.x), b.y) - 1.0;\n}\n// </personal favorite noise funcs>\n\n// common part of FBMs...\nfloat fbm(bool do_abs, vec2 n, float amp_init, float amp_step, float q, float base_octave) {\n    float time = iTime * speed * base_octave;\n    \n    n *= vec2(iResolution.x/iResolution.y,1.0) * cloudscale * base_octave;\n    n -= q - time;\n    \n\tfloat total = 0.0, amplitude = amp_init;\n\tfor (int i = 0; i < 7; i++) {\n        float v = noise(n) * amplitude;\n        v = do_abs ? abs(v) : v;\n        \n\t\ttotal += v;\n        \n\t\tn = m * n + time;\n\t\tamplitude *= amp_step;\n\t}\n\treturn total;\n}\n\nfloat calcF(vec2 p, float q) {\n    //ridged noise shape\n\tfloat r = fbm(true, p, 0.8, 0.7, q, 1.0);\n\n    //noise shape\n\tfloat f = fbm(false, p, 0.7, 0.6, q, 1.0);\n    \n    f *= r + f;\n    f = cloudcover + cloudalpha*f*r;\n    return f;\n}\n\nfloat calcC(vec2 p, float q) {\n    //noise colour\n    float c = fbm(false, p, 0.4, 0.6, q, 2.0);\n    \n    //noise ridge colour\n    float c1 = fbm(true, p, 0.4, 0.6, q, 3.0);\n\t\n    return c + c1;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    // f, c, q are not sure yet...\n    \n    // q is used to subtract from uv with time in fbm()...???\n    float q = fbm(false, p, 0.1, 0.4, 0.0, 1.0);\n        \n    // f part(?)\n\tfloat f = calcF(p, q);\n    \n    // c part(color?)\n    float c = calcC(p, q);\n    \n    // sky color is just a vertical screen gradietion\n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n\n    // The key strategy of shader would be here:\n    // mix sky color and cloud color by (f + c).\n    // The cloud color is calculated from darken sky color (by skytint) + cloud color.\n    // Not sure f + c meaning yet...\n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 382, 403, 403, 468], [470, 470, 492, 492, 713], [751, 777, 869, 869, 1262], [1264, 1264, 1294, 1319, 1499], [1501, 1501, 1531, 1550, 1697], [1751, 1751, 1808, 1808, 2690]], "test": "untested"}
{"id": "wd2BRG", "name": "Flaming Webcam 3 (festival vers)", "author": "tomachi", "description": "non-black webcam pixels contribute pressure waves which wash across the screen. in low light conditions, give it at least 1000 frames of processing before a wave will break out and cover the screen. Introduce a light source to speed up that process. ", "tags": ["webcam", "multipass"], "likes": 2, "viewed": 587, "published": 3, "date": "1590311752", "time_retrieved": "2024-07-30T21:05:17.999508", "image_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define melting(g) texture(iChannel1, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define brightness 1.0001\n#define yellow vec4(0.9,0.8,0.5,0.)\n#define blackwhite vec4(1.,1.,1.,0.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \t\n    vec2 xy = fragCoord;\n    vec4 webcam = camchan(xy);\n    vec4 melt = vec4(\n        abs(melting(xy).x)*0.025,\n        abs(melting(xy).y)*0.025,\n        abs(melting(xy).z)*0.025,\n        0.\n        );\n    vec4 presh = tex(xy);\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    float texbright = (melt.r + melt.g + melt.g) * 0.333;\n    float lumens = (webcam.r + webcam.g + webcam.g) * 0.333;\n    pressure = abs(presh.w);\n    vec4 waves = sin(tex(fragCoord).w * yellow);\n  // fragColor = herbivore + (webcam * vec4(r, g, b, 1.)) + vec4(r*brightness, g*brightness, b*brightness, 1.); //  * vec4(1.0);\n\t//fragColor = webcam  + sin(tex(fragCoord).w * blackwhite);\n    \n    \n    webcam *= vec4(0.975);\n    if ( pressure > 5.9725 ) { \n       // fragColor = melt + (webcam*vec4(0.63))  + sin(tex(fragCoord).w * yellow);\n           //  fragColor = vec4(0.);\n        \n        if (lumens < 0.1) {\n            \n        \tfragColor = melt +  webcam  + (vec4(0.579) * waves);//+ sin(tex(fragCoord).w * blackwhite);\n        } else {\n           \tfragColor =  melt + webcam + (vec4(0.579) * waves);//+ sin(tex(fragCoord).w * blackwhite);\n\n        }\n\n    } else {\n        //fragColor = vec4(0.);\n        //fragColor = melt + (webcam*vec4(0.925)) * (sin(tex(fragCoord).w * yellow)); \n        fragColor = melt + (webcam*vec4(1.)) + (vec4(0.15) * waves);  \n        //fragColor = melt + (webcam*vec4(1.));// +(vec4(0.0015) * waves);  \n\n    }\n        //fragColor = melt + (webcam*vec4(1.))  + sin(tex(fragCoord).w * yellow);\n\n    // fragColor = melt +(webcam*vec4(1.5)) + sin(tex(fragCoord).w * blackwhite);  \n\n          // fragColor = melt;// + (webcam*vec4(0.5))  + sin(tex(fragCoord).w * blackwhite);\n\n   \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lightpressure 0.03\n#define brightness 3.99\n#define count 20\n#define radius 0.943\n#define emitSize 0.950\n#define force 0.99\n#define constraint 0.91\n#define effect 0.99\n#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n\n// v => coord x,y / s => dir\n// v => coord x,y / d => diam\n// https://github.com/aiekick/NoodlesPlate/blob/master/fluid.glsl\n//NoodlesPlate widgets\n//uniform(hidden) \tint\t\t\t(frame) \t\t\t\t\t\tuFrame;\n//uniform(hidden) \tfloat\t\t(deltatime) \t\t\t\t\tuDeltaTime;\n//uniform(hidden) \tsampler2D\t(buffer:0) \t\t\t\t\t\tbuffer;\n//uniform(hidden) \tsampler2D\t(buffer:1) \t\t\t\t\t\tbuffer1;\n//uniform(hidden) \tvec2\t\t(buffer:0) \t\t\t\t\t\tsize;\n//uniform(color) \tvec3\t\t(0:10:7.7,6.0,7.5) \t\t\t\tcolor;\n//uniform(physic) \tfloat\t\t(0.0:1.0:0.1) \t\t\t\t\tforce;\n//uniform(prism) \tfloat\t\t(0.00001:0.1:0.01) \t\t\t\tconstraint;\n//uniform(prism) \tfloat\t\t(-1.0:1.0:0.0) \t\t\t\t\teffect;\n//uniform(prism) \tfloat\t\t(0.99:1.0:1.0) \t\t\t\t\tviscosity;\n//uniform(emit) \tfloat\t\t(1.0:20.0:5.0) \t\t\t\t\temitSize;\n//uniform(emit) \tint\t\t\t(0:50:1) \t\t\t\t\t\tcount;\n//uniform(emit) \tfloat\t\t(0.0:0.5:0.3) \t\t\t\t\tradius;\n//uniform(emit) \tfloat\t\t(checkbox:true) \t\t\t\temit;\n//uniform(shape) \tint\t\t\t(combobox:circle,triangle,quad) shapeType;\n\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n\treturn tri;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\t\n\tvec2 xy = fragCoord.xy;\n\tvec4 webcam = camchan(xy);\n\t\n\tvec2 s = iResolution.xy;\n\tvec2 g = fragCoord;\n\t\n\tvec4 a = tex(g+vec2(1,0));// + webcam.r;\n\tvec4 b = tex(g+vec2(0,1));// + webcam.g;\n\tvec4 c = tex(g+vec2(-1,0));// + webcam.b;\n\tvec4 d = tex(g+vec2(0,-1));// + (webcam.r * -0.0125);\n\tfloat lumens = (webcam.r + webcam.g + webcam.b)*0.333;\n\tfloat presh = abs(tex(xy).z);\n\tfloat ink = abs(tex(xy).w);\n\t\n\t// fragColor = tex(g-tex(g).xy); // last state\n    vec4 tomachi = vec4(1.0001,1.0002,1.0003,0.0);\n\tfragColor = tex(g-tex(g).xy)* tomachi; // last state\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n\tvec4 left = camchan(xy+vec2(1,0)) + tex(xy+vec2(1,0));\n\tvec4 right = camchan(xy+vec2(0,1)) + tex(xy+vec2(0,1));\n\tvec4 up = camchan(xy+vec2(-1,0)) + tex(xy+vec2(-1,0));\n\tvec4 down = camchan(xy+vec2(0,-1))+ tex(xy+vec2(1,0));\n\tfloat magic = 0.25;\n\tfloat pressure = magic * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n\n    if (webcam.r > 0.137 && webcam.g > 0.2) {\n        emit(xy, vec2( 1.0 - webcam.r*-0.5,3.0 - webcam.g*-0.25));\n\t\tmagic = 0.252;\n    }   \n        \n        \n    if (webcam.b > 0.0137 ) {\n        //emit(xy, vec2( 1. - webcam.g*-0.5, -4.0 + (webcam.b)));\n        emit(xy, vec2( 0., 2. ));\n                pressure *= (1. - (lumens*0.1) );\n\n    }\n\n\tif (lumens > 0.2467 ) {\n        if (pressure > 0.0005) {\n       \t    //pressure *= 0.995;    \n       \t\tfragColor.z *= 0.9;\n\t\t\tfragColor.w *= 0.9;\n        } else {\n        }\n       // emit(xy, vec2(0.000500, 1. ));\n        emit(xy, vec2( webcam.b - webcam.r*-0.5, (webcam.g * 2.) - lumens  ));\n    }  \n    if (lumens > 0.31595) {\n\t\temit(xy, vec2(-0.500, 2.0 + (lumens*-4.) ));\n\t\t// pressure += 0.0051;// (lumens*lightpressure);\n    } else {\n        pressure *= (1. - (lumens*0.1) );\n\t\t// ink = lumens *-1.;\n    }\n\n\t\n\t\n\t//emit(xy, 0.005);\n\tif (abs(d.b) > 0.995 && abs(a.r) > 0.995) // governs over pressure condition\n\t{\n\t\tvec2 p = vec2( webcam.r, webcam.g);\n\t\tvec2 dir = vec2( webcam.g, webcam.b);\n\t\temit(xy, dir);\n\t\t//pressure *= 0.95;\t\t\n\t} \n\tif (g.x < 1. || g.y < 1. || g.x > s.x - 1. || g.y > s.y - 1.) fragColor.xy *= 0.;\n\t\n    gp.x = fragColor.x + webcam.r;\n    gp.y = fragColor.y + webcam.r;\n    \n\tif ( pressure > 4.99310589015 || lumens > 0.8) {\n\t\tfragColor.w = abs(fragColor.z) -0.05;\n    } else {\n       \tfragColor.xyz = vec3(\n\t\tfragColor.x + gp.x + (webcam.r * 0.000099),\n\t\tfragColor.y + gp.y + (webcam.b * 0.000099),// + webcam.r,\n\t\tpressure\n\t\t); \n    }\n\n\n\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = vec2(fragCoord.x + 1., fragCoord.y + 2.);\n//    fragColor = tex(fragCoord + vec2(0.01,1.5));\n    float luma = abs(tex(xy).z); // pressure \n    float red = tex(xy).x *10.01;//    tex(xy).w; // ink \n    float green = tex(xy).y * 1.2;\n    fragColor = vec4(red, green, luma, luma);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2BRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 326, 326, 2023]], "test": "untested"}
{"id": "Wd2Bzy", "name": "jupiterCloud-cloud-fuzzed", "author": "alvarobyrne", "description": "simple cloud with multiple layer noise", "tags": ["noise", "cloud"], "likes": 9, "viewed": 508, "published": 3, "date": "1590300508", "time_retrieved": "2024-07-30T21:05:18.759476", "image_code": "// Fork of \"jupiterCloud-cloud\" by feefi. https://shadertoy.com/view/wtdXzN\n// 2020-05-24 06:06:35\n\nfloat N21(vec2 p){\n    float v  = dot(p,vec2(123.2,45.1+0.0001*sin(iTime)));\n    return fract(sin(v)*438.545312);\n}\n\nfloat Noise(vec2 p){\n    vec2 f = fract(p);\n    vec2 id = floor(p);\n    float a = N21(id);\n    float b = N21(id + vec2(1.,0.));\n    float c = N21(id + vec2(0.,1.));\n    float d = N21(id + vec2(1.,1.));\n    f = smoothstep(vec2(0.0),vec2(1.0),f);\n    return mix(mix(a,b,f.x),mix(c,d,f.x),f.y);\n}\nfloat fbm(vec2 p){\n    float n = Noise(p*4.-vec2(iTime*0.1,0));\n    n += Noise(p*8.+vec2(iTime*0.3,0))*0.5;\n    n+= Noise(p*16.-vec2(iTime*0.5,0))*0.25;\n\tn+= Noise(p*32.+vec2(iTime*0.8,0))*0.125;\n    n+= Noise(p*62.-vec2(iTime*2.,0))*0.0625;\n    return (n/2.);\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a),s = sin(a);\n    return mat2(c,-s,s,c);\n}\nconst float pi = 3.1415926;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    float l1 = fbm(uv+1.);\n    float l2 = fbm(rot(pi/2.)*uv+l1);\n    \n    float l3 = fbm(uv+vec2(l1,l2));\n    \n    vec3 col = vec3(0.);\n    col = mix(vec3(1.),vec3(0.985,0.800+sin(iTime),0.714),1.-l1);\n    col = mix(col,vec3(1.30,.009,0.047),l2);\n\tcol = mix(col,vec3(0.1,0.1,0.1),l3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2Bzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 118, 118, 215], [217, 217, 237, 237, 510], [511, 511, 529, 529, 773], [775, 775, 794, 794, 856], [885, 885, 942, 992, 1375]], "test": "untested"}
{"id": "Ws2fzG", "name": "Blue Noise Tex Samples", "author": "demofox", "description": "showing blue noise texture thresholding as sample points", "tags": ["bluenoise"], "likes": 4, "viewed": 610, "published": 3, "date": "1590289528", "time_retrieved": "2024-07-30T21:05:19.528420", "image_code": "const float c_sampleDensity = 0.01f;   // density of the white dots on the black background\nconst float c_pixelScale = 8.0f;       // higher numbers = zooming in\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    vec2 bnFragCoord = fragCoord / c_pixelScale;\n    vec2 bnFragCoordFract = abs(fract(bnFragCoord) - 0.5f);\n    \n\tfloat dx = fwidth(length(bnFragCoord));\n    \n    vec2 bnuv = (floor(bnFragCoord) + 0.5f) / vec2(textureSize(iChannel0, 0));\n    \n    float s = texture(iChannel0, bnuv).r > c_sampleDensity ? 0.0f : 1.0f;\n    s *= smoothstep(0.4+dx, 0.4-dx, sqrt(dot(bnFragCoordFract,bnFragCoordFract)));\n    \n    fragColor = vec4(s,s,s,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2fzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 220, 220, 707]], "test": "untested"}
{"id": "WdffWs", "name": "TV set", "author": "saticmotion", "description": "First attempt at some glitch art", "tags": ["noise", "sdf", "glitch"], "likes": 5, "viewed": 432, "published": 3, "date": "1590282516", "time_retrieved": "2024-07-30T21:05:20.283401", "image_code": "#define PI 3.14159265359\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nvec4 clamp01(vec4 val)\n{\n    return clamp(val, 0., 1.);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdCircle(vec2 uv, float size)\n{\n    return length(uv) - size;\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat knobsSdf(vec2 p)\n{\n    return min(sdCircle(p + vec2(-.9, -.3), .1), \n               sdCircle(p + vec2(-.9, -.04), .1));\n\n}\n\nfloat knobsSdf2(vec2 p)\n{\n    return min(sdCircle(p + vec2(-.9, -.3), .05), \n               sdCircle(p + vec2(-.9, -.04), .05));\n}\n\nfloat grilleSdf(vec2 p)\n{\n    float sdf = 1.;\n    for (float i = 0.; i < 10.; i++)\n    {\n        sdf = min(sdf, sdRoundBox(p + vec2(0, i/30.), vec2(.12, .008), 0.02));\n    }\n    \n    return sdf;\n}\n\nvec2 rot(vec2 p, float angle)\n{\n    angle = angle * PI / 180.;\n    mat2 rotation = inverse(mat2(cos(angle), sin(angle), -sin(angle), cos(angle)));\n\treturn rotation * p;\n}\n\nfloat legsSdf(vec2 p)\n{\n    vec2 taper = vec2(p.y, 1);\n    return min(sdRoundBox((rot(p + vec2(-0.7, .8), 20.)) / taper,\n        \t\t\tvec2(.04, .3), 0.0),\n               sdRoundBox((rot(p + vec2(0.5, .8), -20.)) / taper,\n        \t\t\tvec2(.04, .3), 0.0));\n}\n\nfloat antennaSdf(vec2 p)\n{\n    vec2 taper = vec2(1. - p.y / 1.1, 1);\n    return min(sdRoundBox((rot(p + vec2(-0.3, -.75), -30.)) / taper,\n        \t\t\tvec2(.015, .25), 0.0),\n               min(sdRoundBox((rot(p + vec2(0.1, -.75), 30.)) / taper,\n        \t\t\t\tvec2(.015, .25), 0.0),\n                   min(sdCircle(p + vec2(-0.42, -.96), .015),\n                       sdCircle(p + vec2(0.22, -.96), .015)\n                  )));\n}\n\nfloat glowColMod(float t)\n{\n    float fps = random(vec2(floor(t * 10.)));\n    float rand = random(vec2(floor(t * fps)));\n    return rand / 20. + 0.2;\n}\n\nvec2 noiseGlitch(vec2 uv)\n{\n    float strength = 15.;\n    float offset = 10. - fract(iTime / 10.) * 25.;\n    float compression = 10. * sin(iTime) + 20.;\n    \n    float x = (uv.y * compression) - offset;\n    float x2 = pow(x, 4.) - 5.*pow(x, 3.) + 5.*pow(x, 2.) + x - 5.;\n    \n    float res = (min(0., x2) / strength);\n    \n    return vec2(res, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 uvcrt = uv * pow(length(vec2(uv.x, uv.y)) + 0.3, .3);\n    \n    float crtSdf = \t\t\t-sign(\t\t\t\t\t\tsdRoundBox(uvcrt, vec2(.75, .5), 0.1));\n    float glossSdf = \t \tsign(min(crtSdf, \t\t\tsdCircle(uvcrt - vec2(-1.1, 3.7), 4.)));\n    float cabTemp = \t\t-(max(crtSdf, \t\t\t\tsdRoundBox(uv + vec2(-.1, .0), vec2(.95, .6), 0.1)));\n    float cabinetSdf = \t\tpow(clamp(cabTemp, 0., 1.) + .3, 1.);\n    float cabinetSdfSign = \tsign(cabTemp);\n    float knobSdf = \t\t-sign(\t\t\t\t\t\tknobsSdf(uv));\n    float knobSdf2 = \t\t-sign(\t\t\t\t\t\tknobsSdf2(uv));\n    float grilleSdf = \t\t-sign(\t\t\t\t\t\tgrilleSdf(uv + vec2(-.9, .15)));\n    float legsSdf = \t\t-sign(max(cabinetSdfSign, \tlegsSdf(uv)));\n    float antennaSdf = \t\t-sign(max(cabinetSdfSign, \tantennaSdf(uv)));\n    float glowSdf = \t\t-clamp(max(crtSdf,\t\t\tsdTrapezoid(uv + vec2(0., .9), 3., .72, 1.1)), -.9, .0);\n    \n    vec2 noiseGlitch = \t noiseGlitch(uv);\n    vec4 noiseCol = \t clamp01(texture(iChannel1, (uv / 2.) + noiseGlitch + vec2(0.5)) * clamp01(crtSdf));\n    vec4 fadeCol = \t\t clamp01(vec4(vec3(0), length(uv)-.3)\t* crtSdf);\n    vec4 noiseColFaded = (fadeCol + noiseCol * 1. - fadeCol.a) * crtSdf;\n    vec4 glossCol = \t clamp01(vec4(vec3(.3), 1)  \t\t\t* glossSdf * .35);\n    vec4 cabinetCol = \t clamp01(texture(iChannel0, uv * 2.) \t* cabinetSdfSign * cabinetSdf);\n    vec4 knobCol = \t\t clamp01(vec4(vec3(1), 1) \t\t\t\t* knobSdf);\n    vec4 knobCol2 =\t\t clamp01(vec4(vec3(.5), 1) \t\t\t\t* knobSdf2) * 2.75;\n    vec4 grilleCol =\t clamp01(vec4(vec3(1), 1) \t\t\t\t* grilleSdf);\n    vec4 legsCol = \t\t clamp01(texture(iChannel0, rot(uv, 90.)) * legsSdf * .15);\n    vec4 antennaCol = \t clamp01(vec4(vec3(.5), 1)\t\t\t\t* antennaSdf);\n    vec4 glowCol = \t \t clamp01(vec4(vec3(glowColMod(iTime)), 1.) * glowSdf);\n    \n    fragColor = (noiseColFaded + glossCol + cabinetCol + legsCol + antennaCol - knobCol + knobCol2 - grilleCol) * (1.-glowCol) + glowCol;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define crtFps 24.\n\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 screenNoise(in vec2 uv, float iTime)\n{\n    float framerate = crtFps;\n    float frametime = floor(iTime * framerate) / framerate;\n    \n    vec2 randseed = floor(uv * 160.) / 160. + random(vec2(frametime));\n    \n    vec3 col = vec3(random(randseed));\n    //NOTE(Satic): Add a bit of blue\n\tcol = vec3(col.r, col.g, pow(col.b, .7));\n    return col;\n}\n\nfloat clamp01(float x)\n{\n    return clamp(x, 0., 1.);\n}", "buffer_a_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 boxUv = uv + vec2(0, 1. - fract(iTime / 4.) * 2. + 0.25);\n    vec2 boxUv2 = uv + vec2(0, 1. - fract(iTime / 2.85) * 2. + 0.25);\n    float box = -sign(sdBox(boxUv, vec2(2., .1 + sin(iTime) / 20.)));\n    float box2 = -sign(sdBox(boxUv2, vec2(2., .05 + sin(iTime / 2.) / 20.)));\n    \n    vec3 boxCol = vec3(0.1) * max(box, box2);\n    \n    float glitch1Time = fract(iTime / cos(floor(iTime / 2.)));\n    vec2 glitch1 = vec2(cos(uv.x + uv.y * 2.), uv.y * uv.x) * smoothstep(.5, .6, glitch1Time);\n\n    vec3 col = screenNoise(uv + glitch1, iTime) - boxCol;\n    \n    float redGlitch =    clamp01(abs(tan(iTime * 1.5) + 2.)) / 8. + 0.875;\n    float greenGlitch =  clamp01(abs(tan(iTime * 1.2) + 2.)) / 8. + 0.875;\n    float blueGlitch =   clamp01(abs(tan(iTime * 1.1) + 2.)) / 8. + 0.875;\n    \n    fragColor = vec4(vec3(col.r * redGlitch, col.g * greenGlitch, col.b * blueGlitch), 1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdffWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 50, 50, 69], [71, 71, 95, 95, 128], [130, 130, 185, 185, 271], [273, 273, 310, 310, 342], [344, 344, 409, 409, 719], [722, 722, 746, 746, 850], [852, 852, 877, 877, 982], [984, 984, 1009, 1009, 1180], [1182, 1182, 1213, 1213, 1352], [1354, 1354, 1377, 1377, 1607], [1609, 1609, 1635, 1635, 2033], [2035, 2035, 2062, 2062, 2186], [2188, 2188, 2215, 2215, 2538], [2540, 2540, 2597, 2597, 4512]], "test": "untested"}
{"id": "3s2fRG", "name": "angel 4", "author": "Aman", "description": "mirage, the", "tags": ["the", "mirage"], "likes": 3, "viewed": 324, "published": 3, "date": "1590281877", "time_retrieved": "2024-07-30T21:05:21.054340", "image_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// S/o mercury.sexy for these ops:\n\nfloat cyl(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nmat3x3 rotationAlign( vec3  d,  vec3  z )\n{\n     vec3  v = cross( z, d );\n     float c = dot( z, d );\n     float k = 1.0f/(1.0f+c);\n\n    return mat3x3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(in vec2 p, vec2 size) {\n    vec2 halfsize = size*0.5;\n    vec2 c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    p *= mod(c,vec2(2.0))*2.0 - vec2(1);\n    return p;\n}\n\nfloat sdf(vec3 p) {\n    vec3 spp = p;\n  //  spp.z *= 2.0;\n    float sp = length(spp) - 1.2;\n  //  sp /= 2.0 * abs(dot(p, vec3(0.0, 0.0, 1.0)));\n    //sp *= \n    \n    float f = clamp(sin(iTime), 0.2, 1.0);\n  \n    float posoff = texture(iChannel1, vec2(sin(iTime * 0.1), cos(iTime * 0.1))).r;\n    float x = sin(iTime - (1.0 - f)) * 0.5 + 0.5 + posoff;\n    float y = cos(iTime - (1.0 - f)) * 0.5 + 0.5;\n   \n    p = p * rotationAlign(vec3(0.0, 1.0, 0.0), normalize(vec3(0.3 + x, 0.3 + y, -2.5)));\n    float c = cyl(p, (f - 0.5));\n    vec2 polar = vec2(length(p.xz), atan(-p.x, p.z));\n    polar.y /= (3.14159) * 0.5 ;\n    polar.x += 0.1;\n    polar.y += polar.x * f * 5.0 + polar.y * 0.1 + 0.2;\n    polar.y +=sin(iTime) * 0.5 + 0.5;\n    vec2 sampleAt = vec2(p.y * 0.5, polar.y * 0.6) * 0.3;\n    vec2 sampleAt2 = sampleAt; //pModMirror2(sampleAt, vec2(1.0));\n    float sampl = texture(iChannel1, fract(sampleAt2 + 0.1)).r;\n    sampl -= 0.1;\n    sampl *= sampl;\n    sampl *= sampl;\n    \n    \n    sampl *= 4.0;\n//    sampl *= clamp(tan(time), 0.0, 1.0);\n    c -= sampl * 0.25 ;\n    return max(sp +c*0.04, -c);\n}\n\n\n\nbool march(vec3 ro, vec3 rd, out vec3 hitPos) {\n    float over = 1.0;\n    float tot = 0.0;\n    for(int i = 0; i < 40; i++) {\n        float d = sdf(ro);\n        tot += d;\n        if(d < 0.001 * tot) {\n            hitPos = ro;\n            return true;\n        }\n        //d *= over;\n        //over *= 1;\n        ro += rd * d;\n    }\n    return false;\n}\n\nvec3 calcNormal(vec3 p, float d) {\n    vec2 eps = vec2(0.001, -0.001) * d;\n    return normalize(eps.xyy * sdf(p + eps.xyy)\n                    + eps.yyx * sdf(p + eps.yyx)\n                    + eps.yxy * sdf(p + eps.yxy)\n                    + eps.xxx * sdf(p + eps.xxx));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    uv.x /= iResolution.y / iResolution.x;\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.2));\n    vec3 col = vec3(1); //texture2D(shared1, inData.v_texcoord).rbb;\n    vec3 hitPos;\n     vec3 prev = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n   \n    \n    \n    if(march(ro, rd, hitPos)) {\n        float d = length(hitPos - ro);\n        vec3 normal = calcNormal(hitPos, d);\n        vec3 toLight = normalize(vec3(1.0, 0.9, -1) - hitPos);\n        float dif = clamp(dot(normal, toLight), 0.3, 1.0);\n        col = mix( normalize(sin(normal.rbb * 3.0) * 0.5 + 0.5), vec3(0.4, 0.4, 1.0), dif);\n        col = vec3(pow(dif, 1.5));\n        col += step(0.9, pow(dif, 6.0)) * pow(dif, 5.0);\n        vec3 keyLight = normalize(vec3(0.0, -4.0, -0.2) - hitPos);\n        col += clamp(dot(normal, keyLight), 0.0, 1.0) * vec3(1.0, 0.0, 0.0);\n       // col.g *= 0.5\n        //col.rb *= 2.0;\n            prev = texture(iChannel0, fragCoord/iResolution.xy + -(2.0 * col.rb - 1.0) * 0.005).rgb;\n        col = mix(col, prev, 0.9);\n        if(length(hitPos) < 1.14) {\n            col = mix(col, vec3(1.0, 0.7, 0.85), 0.1);\n            //col += vec3(1.0);\n        }\n    } else {\n         col = mix(col, prev, 0.9);\n    }\n    \n    fragColor = vec4(col,\n        1.0);\n}\n", "buffer_a_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 60, 110, 193]], "test": "untested"}
{"id": "Wd2fRG", "name": "angel 3", "author": "Aman", "description": "angel 3", "tags": ["the", "mirage"], "likes": 3, "viewed": 332, "published": 3, "date": "1590281444", "time_retrieved": "2024-07-30T21:05:21.806329", "image_code": "\n// S/o https://www.shadertoy.com/view/MlcGRf for the dodecahedron SDF\n// & mercury.sexy for these ops\n\nvec2 opU2(vec2 x, vec2 y) {\n    return vec2(min(x.x, y.x), x.x < y.x ? x.y : y.y);\n}\n\nvec3 polar(vec3 cart) {\n    return vec3(length(cart), atan(cart.y, cart.z), atan(cart.z, cart.x));\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n    return fOpIntersectionRound(a, -b, r);\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n    return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n    return fOpIntersectionChamfer(a, -b, r);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n    return length(vec2(a, b)) - r;\n}\n\n\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.0)) c = abs(c);\n    return c;\n}\n\nvec2 sdf(vec3 _p) {\n    vec3 p = _p;\n    p.y -= 0.2;\n    pR(p.yz, 0.7);\n    vec3 pol = polar(p);\n    float n = texture(iChannel0, pol.yz * 0.06 + vec2(0., 1.0 * 0.1)).r ;\n    float n2 = texture(iChannel0, pol.zy * (1.0 + n) + vec2(0., 1.0 * 0.2)).r;\n\n    vec3 pol2 = pol;\n    pol2.yz = mod(pol2.yz * 1.0, PI * 4.0);\n    vec3 dp = p;\n    dp.y -= 0.5;\n    pModPolar(dp.yx,2.0);\n    pR(dp.xz, sin(iTime));\n    vec2 sp = vec2(fDodecahedron(dp, 0.44), 1.0);\n    \n    pR(dp.yz, cos(iTime));\n    sp.x = fOpDifferenceRound(fDodecahedron(dp, 0.5), sp.x, 0.1);\n    \n    pR(dp.yz, sin(-iTime));\n    sp.x = fOpDifferenceRound(fDodecahedron(dp, 0.5), sp.x, 0.1);\n    \n    sp.x = fOpDifferenceRound(sp.x, sp.x * 1.34 * pol.r, 0.);\n\n    float n3 = texture(iChannel0, fract(pol.xz * 0.4 + iTime * 0.1)).r;\n    n3 = n3 * n3 * n3;\n    vec2 mirror = vec2(_p.y + 0.1 + n3 * 0.1, 0.0);\n    mirror.x = fOpIntersectionRound(length(p) - 0.8, mirror.x, 0.06);\n    \n    vec2 ring = vec2(length(p - vec3(0.0, -0.3, 0.0)) - 0.79, 1.0);\n    ring.x = fOpPipe(ring.x, mirror.x, 0.1);\n    \n    return opU2(sp, opU2(ring, mirror));\n}\n\n\nbool march(vec3 ro, vec3 rd, out vec3 hitPos, out float mat) {\n    float t = 0.0;\n    for(int i = 0; i < 50; i++) {\n        vec2 d = sdf(ro);\n        t += d.x;\n        ro += rd * d.x;\n        if(d.x < 0.001) {\n            hitPos = ro;\n            mat = d.y;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n        k.xyy * sdf(p + h * k.xyy).x +\n        k.yxy * sdf(p + h * k.yxy).x +\n        k.yyx * sdf(p + h * k.yyx).x +\n        k.xxx * sdf(p + h * k.xxx).x\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.3, -1.3);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 hitPos;\n    float mat;\n    \n    vec3 col = vec3(1.0);\n    if(march(ro, rd, hitPos, mat)) {\n        vec3 normal = estimateNormal(hitPos);\n        if(mat < 0.5) {\n          //  col = vec3(1.0, 0.0, 0.0);\n            vec3 refl = reflect(rd, normal);\n            vec3 reflHit;\n            if(march(hitPos + refl * 0.1, refl, reflHit, mat)) {\n                \n                col = estimateNormal(reflHit) * 0.5 + 0.5;\n                col.rb *= 2.0;\n                col.r = sqrt(col.r);\n                col = mix(col, vec3(1.0), 0.1);\n                //col = vec3(1.0);\n            } else {\n                col = vec3(0.0);\n                \n            }\n        } else {\n        \n            col = estimateNormal(hitPos) * 0.5 + 0.5;\n            col.rb *= 2.0;\n            float spec =  pow(clamp(dot(normal, normalize(vec3(1.0, 1.5, -1.0) - hitPos)), 0.0, 1.0), 4.0);\n            col = mix(col, vec3(1.0), spec * 4.0);\n            col.r = sqrt(col.r);\n            col.g *= 0.5;\n        }   \n        \n       \n        \n        \n    \n    }\n    \n    //if(time < 0.01) { col = vec3(1.0); }\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2fRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 131, 131, 188], [190, 190, 213, 213, 290], [292, 292, 324, 324, 369], [371, 371, 426, 426, 518], [520, 520, 574, 574, 619], [621, 621, 678, 678, 730], [732, 787, 843, 843, 890], [892, 892, 934, 934, 971], [2122, 2122, 2172, 2172, 2594], [2596, 2596, 2615, 2615, 3696], [3699, 3699, 3761, 3761, 4017], [4019, 4019, 4048, 4048, 4285], [4289, 4289, 4346, 4396, 5703]], "test": "untested"}
{"id": "wsSfzy", "name": "Hyperdodecahedron", "author": "xjorma", "description": "Hyperdodecahedron rotating in 4D space.\n\nInspired by this:\n\nhttps://twitter.com/shujihirai/status/1263450992089030656\n\nProbably my implementation is too much brute force. :(\n", "tags": ["4d", "dodecahedron", "tesseract", "hypercube", "r4"], "likes": 26, "viewed": 742, "published": 3, "date": "1590278830", "time_retrieved": "2024-07-30T21:05:22.848542", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n//#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_DIST\t\t15.\nconst float PI = radians(180.);\n\n#define THICKNESS\t0.1\n#define LIGHTHEIGHT\t1.10\n#define SCALE\t\t1.7\n\n\nmat4 rot4d;\n\nvoid init4d()\n{\n\tfloat a1 = iTime * 0.5;\n\tfloat a2 = iTime * 0.5;\n\n    vec4 x = vec4(cos(a1), -sin(a1),     0.0,     0.0);\n    vec4 y = vec4(sin(a1),  cos(a1),     0.0,     0.0);\n    vec4 z = vec4(    0.0,      0.0, cos(a2), -sin(a2));\n    vec4 w = vec4(    0.0,      0.0, sin(a2),  cos(a2));\n    rot4d = mat4(x, y, z, w);\n}\n\nvec3 transform4d(vec4 p)\n{\n    p = rot4d * p;\n\tfloat a = LIGHTHEIGHT / (p.w - LIGHTHEIGHT);\n    return p.xyz * a * SCALE;    \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\nconst float k = 25.;\n\nfloat map(vec3 p)\n{\n    p *= fromEuler(vec3(iTime * 0.12, iTime * 0.15, iTime * 0.136));\n    float sminAcc = 0.;\n    for( int i = 0; i < numVertices / 2; i++)\n    {\n        sminAcc += exp2(-k * sdCapsule(p, transform4d(vertices[i*2 + 0]), transform4d(vertices[i*2 + 1]), THICKNESS));\n    }\n\treturn -log2( sminAcc ) / k;\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    return col*col;\n}\n\n\nfloat rayMarch(in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 40; i++)\n  {\n    float h = map(ro + rd * t);\n    t += h;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.2 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float t = rayMarch(ro, rd, 4.);\n    vec3\tcol = vec3(0.07);\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);   \n        col = texture(iChannel0, reflect(rd, n)).rgb * pow(dot(rd, n), 2.);\n        col = mix(col, vec3(dot(col, vec3( 1.0 / 3.0))), 0.5);\t\t// Desaturate\n        col = applyFog(col, t, vec3(0));\n    }\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n\tcol = pow(col, vec3(0.8));\n\tcol = contrast(col, 1.2);\n\tcol = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\tinit4d();\n    fragColor = vec4(Render(ro + vec3(0.0, 0.0, 9.0), rd), 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tinit4d();\n\n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI * 0.3;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - PI / 2.;\n        vec3 ro = 9. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        tot += Render(ro ,rd);\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int numVertices = 160;\n\nconst vec4 vertices[160] = vec4[](\nvec4(0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(0.573492586613, -0.186338871717, -0.789344370365, 0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, 0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(0.573492586613, 0.789345026016, -0.186338797212, 0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(0.0, -0.603005826473, -0.78934442997, 0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(0.927930414677, -0.301502913237, -0.186338871717, 0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, 0.3), vec4(-0.573492586613, -0.186338871717, -0.789344370365, 0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, 0.3), vec4(0.0, -0.975683927536, -0.18633890152, 0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, 0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(-0.927930414677, -0.301502913237, -0.186338871717, 0.3), \nvec4(-0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(-0.573492586613, 0.789345026016, -0.186338797212, 0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(0.0, 0.975683867931, 0.18633890152, 0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, 0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, 0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, 0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, 0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, 0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, 0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, 0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, 0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, 0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(0.0, 0.975683867931, 0.18633890152, 0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, 0.3), \nvec4(0.0, 0.975683867931, 0.18633890152, 0.3), vec4(0.0, 0.603005826473, 0.78934442997, 0.3), \nvec4(-0.927930414677, 0.301502913237, 0.186338871717, 0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(-0.573492586613, -0.789345026016, 0.186338797212, 0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, 0.3), \nvec4(0.573492586613, -0.789345026016, 0.186338797212, 0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, 0.3), \nvec4(0.927930414677, 0.301502913237, 0.186338871717, 0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, 0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, 0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(0.573492586613, 0.186338871717, 0.789344370365, 0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, 0.3), \nvec4(0.354437857866, -0.48784211278, 0.78934431076, 0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, 0.3), \nvec4(-0.354437857866, -0.48784211278, 0.78934431076, 0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, -0.3), vec4(0.573492586613, -0.186338871717, -0.789344370365, -0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, -0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, -0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, -0.3), vec4(0.573492586613, 0.789345026016, -0.186338797212, -0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, -0.3), vec4(0.0, -0.603005826473, -0.78934442997, -0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, -0.3), vec4(0.927930414677, -0.301502913237, -0.186338871717, -0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, -0.3), vec4(-0.573492586613, -0.186338871717, -0.789344370365, -0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, -0.3), vec4(0.0, -0.975683927536, -0.18633890152, -0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, -0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, -0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, -0.3), vec4(-0.927930414677, -0.301502913237, -0.186338871717, -0.3), \nvec4(-0.354437857866, 0.48784211278, -0.78934431076, -0.3), vec4(-0.573492586613, 0.789345026016, -0.186338797212, -0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, -0.3), vec4(0.0, 0.975683867931, 0.18633890152, -0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, -0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, -0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, -0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, -0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, -0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, -0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, -0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, -0.3), vec4(0.0, 0.975683867931, 0.18633890152, -0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, -0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(0.0, 0.975683867931, 0.18633890152, -0.3), vec4(0.0, 0.603005826473, 0.78934442997, -0.3), \nvec4(-0.927930414677, 0.301502913237, 0.186338871717, -0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(-0.573492586613, -0.789345026016, 0.186338797212, -0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(0.573492586613, -0.789345026016, 0.186338797212, -0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(0.927930414677, 0.301502913237, 0.186338871717, -0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, -0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, -0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.573492586613, 0.186338871717, 0.789344370365, -0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(0.354437857866, -0.48784211278, 0.78934431076, -0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(-0.354437857866, -0.48784211278, 0.78934431076, -0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(0.354437857866, 0.48784211278, -0.78934431076, -0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(0.573492586613, -0.186338871717, -0.789344370365, -0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, 0.3), vec4(0.0, -0.603005826473, -0.78934442997, -0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(-0.573492586613, -0.186338871717, -0.789344370365, -0.3), \nvec4(-0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, -0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(-0.573492586613, 0.789345026016, -0.186338797212, -0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(-0.927930414677, -0.301502913237, -0.186338871717, -0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, 0.3), vec4(0.0, -0.975683927536, -0.18633890152, -0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(0.927930414677, -0.301502913237, -0.186338871717, -0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(0.573492586613, 0.789345026016, -0.186338797212, -0.3), \nvec4(0.0, 0.975683867931, 0.18633890152, 0.3), vec4(0.0, 0.975683867931, 0.18633890152, -0.3), \nvec4(-0.927930414677, 0.301502913237, 0.186338871717, 0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(-0.573492586613, -0.789345026016, 0.186338797212, 0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.573492586613, -0.789345026016, 0.186338797212, 0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.927930414677, 0.301502913237, 0.186338871717, 0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, 0.3), vec4(0.0, 0.603005826473, 0.78934442997, -0.3), \nvec4(0.573492586613, 0.186338871717, 0.789344370365, 0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.354437857866, -0.48784211278, 0.78934431076, 0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(-0.354437857866, -0.48784211278, 0.78934431076, 0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(-0.573492586613, 0.186338871717, 0.789344370365, 0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, -0.3) );\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSfzy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[323, 323, 338, 338, 647], [649, 649, 675, 675, 776], [778, 778, 830, 830, 951], [953, 953, 979, 979, 1331], [1355, 1355, 1374, 1374, 1676], [1678, 1678, 1705, 1705, 1770], [1773, 1773, 1828, 1828, 1993], [2550, 2550, 2605, 2605, 2701], [2704, 2704, 2741, 2741, 3115], [3117, 3117, 3160, 3160, 3218], [3220, 3220, 3264, 3264, 3363], [3365, 3365, 3407, 3407, 3507], [3510, 3510, 3552, 3552, 3716], [3718, 3718, 3796, 3796, 3872]], "test": "untested"}
{"id": "3tl3DH", "name": "oil003", "author": "yy2901", "description": "noise", "tags": ["noise"], "likes": 1, "viewed": 236, "published": 3, "date": "1590277281", "time_retrieved": "2024-07-30T21:05:23.605519", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 circle(in vec2 st,in vec2 pos,in float radius){\n    float d = length(st-pos);\n    return vec3(smoothstep(radius-0.1,radius,d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float dense = 0.8;\n    \n    vec2 center = uv+vec2(iTime*0.1,-iTime*0.5)+vec2(\n        1.0*noise(uv*2.0+vec2(iTime*0.1)), 1.0*noise(uv*2.0-vec2(iTime*0.1))\n    );\n    center = mod(center,vec2(dense));\n    vec2 center1 = uv+vec2(iTime*0.1,-iTime*0.5)+vec2(\n    \t1.0*noise(uv*2.0+vec2(iTime*0.1+0.1,iTime*0.1)), 1.0*noise(uv*2.0-vec2(iTime*0.1,iTime*0.1+0.1))\n    );\n    center1 = mod(center1,vec2(dense));\n    vec2 center2 = uv+vec2(iTime*0.1,-iTime*0.5)+vec2(\n    \t1.0*noise(uv*2.0+vec2(iTime*0.1+0.1)), 1.0*noise(uv*2.0-vec2(iTime*0.1+0.1))\n    );\n    center2 = mod(center2,vec2(dense));\n    vec3 circle0 = circle(center,vec2(dense/2.0),0.4);\n    vec3 circle1 = circle(center1,vec2(dense/2.0),0.4);\n    vec3 circle2 = circle(center2,vec2(dense/2.0),0.4);\n    \n    vec3 col =vec3(1.0-circle0.x,0.,0.);\n    col+=vec3(0.,1.0-circle1.x,0.);\n    col+=vec3(0.,0.,1.0-circle2.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tl3DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 163, 185, 185, 589], [591, 591, 643, 643, 725], [727, 727, 784, 834, 1957]], "test": "untested"}
{"id": "3tlGzS", "name": "mesh000", "author": "yy2901", "description": "mesh", "tags": ["noise"], "likes": 0, "viewed": 198, "published": 3, "date": "1590277274", "time_retrieved": "2024-07-30T21:05:24.362495", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    \n    st-=0.5;\n    st.x*=iResolution.x/iResolution.y;\n    st=(1.0-sin(iTime)*length(st))*st;\n    vec2 uv = st+0.2*vec2(noise(st+iTime),noise(st.yx+iTime));\n\n    // Time varying pixel color\n    vec3 col; \n    col.r = (1.0-smoothstep(length( mod((uv.y+iTime*0.5)*40.,10.0)-5.0)+0.6,0.2,1.0));\n    col.r += (1.0-smoothstep(length( mod((1.7*(uv.x+iTime*0.1)+uv.y)*25.,10.0)-5.0)+0.6,0.5,1.0));\n    col.r += (1.0-smoothstep(length( mod((-1.7*(uv.x-iTime*0.1)+uv.y)*25.,10.0)-5.0)+0.6,0.5,1.0));\n    uv.x+=0.01;\n    col.g = 0.9*(1.0-smoothstep(length( mod((uv.y+iTime*0.5)*40.,10.0)-5.0)+0.6,0.2,1.0));\n    col.g += 0.9*(1.0-smoothstep(length( mod((1.7*(uv.x+iTime*0.1)+uv.y)*25.,10.0)-5.0)+0.6,0.5,1.0));\n    col.g += 0.9*(1.0-smoothstep(length( mod((-1.7*(uv.x-iTime*0.1)+uv.y)*25.,10.0)-5.0)+0.6,0.5,1.0));\n    uv.x-=0.01;\n    uv.y+=0.01;\n    col.b = 0.9*(1.0-smoothstep(length( mod((uv.y+iTime*0.5)*40.,10.0)-5.0)+0.6,0.2,1.0));\n    col.b += 0.9*(1.0-smoothstep(length( mod((1.7*(uv.x+iTime*0.1)+uv.y)*25.,10.0)-5.0)+0.6,0.5,1.0));\n    col.b += 0.9*(1.0-smoothstep(length( mod((-1.7*(uv.x-iTime*0.1)+uv.y)*25.,10.0)-5.0)+0.6,0.5,1.0));\n    \n    uv = st+0.1*vec2(noise(2.0*st-iTime),noise(2.0*st.yx-iTime));\n    col.r += 0.5*(1.0-smoothstep(length( mod((uv.y-iTime*0.1)*120.,10.0)-5.0)+0.6,0.2,1.0));\n    col.r += 0.5*(1.0-smoothstep(length( mod((1.7*(uv.x-iTime*0.1)+uv.y)*80.,10.0)-5.0)+0.6,0.5,1.0));\n    col.r += 0.5*(1.0-smoothstep(length( mod((-1.7*(uv.x+iTime*0.1)+uv.y)*80.,10.0)-5.0)+0.6,0.5,1.0));\n    //col = vec3(1.0-smoothstep(col.r,0.5,0.6));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 163, 185, 185, 589], [591, 591, 648, 698, 2353]], "test": "untested"}
{"id": "tsK3W3", "name": "foam00000000000", "author": "yy2901", "description": "raymarch", "tags": ["raymarch"], "likes": 4, "viewed": 279, "published": 3, "date": "1590277259", "time_retrieved": "2024-07-30T21:05:25.113487", "image_code": "#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n#define OCTAVES 4\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float MAX_DIST = 150.0;\nconst float EPSILON = 0.002;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-2.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nfloat sceneSDF(vec3 sP) {\n    float d=MAX_DIST;\n    vec3 sPTorus = sP*rotateX(iTime*1.2);\n    vec3 sPT1 = (sP*rotateY(iTime)+vec3(0.2))*rotateX(-iTime*0.1);\n\tfloat torus = sdTorus(sPTorus+0.2*noise(vec3(sP.x*3.0+iTime*4.0,sP.y*2.0,sP.z)),vec2(0.5,0.2+0.2*noise(sP*2.5)));\n    float fff = sdTorus(sPT1,vec2(0.4,0.2+0.2*noise(sP*4.0+iTime*3.0)));\n    return opSmU(torus,fff,0.13);\n}\n\nfloat[4] shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float depth[4];\n    float dd=0.0;\n    int layer=0;\n    float side=1.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = side*(sceneSDF(eye + dd * marchingDirection));\n        dd += dist;\n        if (dist<EPSILON) {\n            depth[layer]=dd;\n            dd+=10.0*EPSILON;\n            side*=-1.;\n\t\t\tlayer++;\n        }else if(dist>MAX_DIST){\n            for(int l=layer;l<4-layer;l++){\n                depth[l]=0.0;\n            }\n\t\t\treturn depth;\n            break;\n        }\n        \n    }\n    return depth;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 eN(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat AO(vec3 p,vec3 n){\n    float ao =0.0;\n    float d;\n    for(int i=1;i<=2;i++){\n        d=3.0*float(i);\n        ao+=max(0.0,(d-sceneSDF(p+n*d))/d);\n    }\n    return ao;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec3 color=vec3(0.0);\n    float sdf[] = shortestDistanceToSurface(eye, dir);\n    if(sdf[0]>MAX_DIST){\n        fragColor = vec4(color, 1.0);\n        return;\n    }\n    for(int i=3;i>=0;i--){\n        float dist = sdf[i];\n        if(sdf[i]!=0.0){\n            vec3 p = eye + dist * dir;\n            vec3 N = eN(p);\n            float occ = 1.0-AO(p,N);\n\n            vec3 ref = reflect(dir,N);\n            ref=(texture( iChannel0, ref ).xyz+0.5*( abs(sin( (N+1.0)*3.1415926*vec3(1.0,1.0,1.0) )) ) )*(1.0*occ-0.0);\n\n            float blendingN =1.0-smoothstep(0.0,0.7,length(N*dir));\n            color=(1.0-blendingN)*(0.6*color+0.1*ref)+ref*blendingN;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsK3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 62, 62, 103], [105, 105, 126, 126, 470], [490, 490, 509, 509, 675], [773, 773, 804, 804, 895], [897, 897, 930, 930, 995], [997, 997, 1041, 1041, 1141], [1143, 1143, 1187, 1187, 1286], [1288, 1288, 1311, 1311, 1436], [1438, 1438, 1461, 1461, 1586], [1588, 1588, 1611, 1611, 1736], [1738, 1738, 1763, 1763, 2118], [2742, 2742, 2807, 2807, 2939], [2941, 2941, 2958, 2958, 3268], [3270, 3270, 3294, 3294, 3444], [3447, 3447, 3504, 3504, 4358]], "test": "untested"}
{"id": "wsV3WK", "name": "blood000000000", "author": "yy2901", "description": "raymarch noise", "tags": ["raymarch"], "likes": 1, "viewed": 247, "published": 3, "date": "1590277245", "time_retrieved": "2024-07-30T21:05:25.876447", "image_code": "#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n#define OCTAVES 4\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nconst int MAX_MARCHING_STEPS = 200;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-2.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nfloat sceneSDF(vec3 sP) {\n    float f = 0.5*fbm(vec3(sP.x*3.0,sP.y*0.6+iTime*1.0,sP.z*3.0+iTime*0.3))-0.25+0.02*length(fbm(vec3(sP.x*15.0,sP.y*15.0+iTime*1.0,sP.z*15.0+iTime*0.3)));\n    float d = opSmI(f,length(vec3(sP.x,sP.y+0.6-noise(vec3(sP.x*2.0+iTime,sP.z*2.0+iTime,sP.y+iTime)),sP.z))-0.5,0.1);\n    return d;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn vec2(depth,i+1);\n        }\n        depth += dist;\n        if (depth >= end) {\n            return vec2(end,0);\n        }\n    }\n    return vec2(end,0);\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    vec3 ref = reflect(p-eye,N);\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return (lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha))*0.5+0.5*texture( iChannel0, ref ).xyz);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec2 sdf = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    float dist = sdf.x;\n    float occ = 1.0-float(sdf.y)/float(MAX_MARCHING_STEPS);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    vec3 N = estimateNormal(p);\n    vec3 ref = reflect(dir,N);\n    ref=texture( iChannel0, ref ).xyz;\n    \n    vec3 color = ref;\n    \n    color*=4.0*occ-3.0;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsV3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 62, 62, 103], [105, 105, 126, 126, 470], [490, 490, 509, 509, 675], [1051, 1140, 1171, 1171, 1262], [1505, 1505, 1549, 1549, 1649], [1651, 1651, 1674, 1674, 1799], [1801, 1801, 1824, 1824, 1949], [1951, 1951, 1974, 1974, 2099], [2101, 2101, 2126, 2126, 2417], [2420, 2841, 2931, 2931, 3263], [3278, 3532, 3597, 3597, 3729], [3731, 3820, 3849, 3849, 4159], [4655, 4655, 4795, 4795, 5463], [5837, 5837, 5894, 5894, 6643]], "test": "untested"}
{"id": "tdBfzy", "name": "The Tvösunna Planet of Oceania", "author": "Yambam", "description": "This is a fork of https://www.shadertoy.com/view/tdBfRw (Simulating the Colors of the Sky) by jamelouis\nNice things to add would be rotating the sun around a viewpoint, e.g. using a geographic calculation based on different locations on Earth + a 3D scene", "tags": ["sun", "colors", "sky", "fork", "sunrise", "simulating"], "likes": 4, "viewed": 504, "published": 3, "date": "1590273366", "time_retrieved": "2024-07-30T21:05:26.807956", "image_code": "// Fork of \"Simulating the Sunrise/Sunset\" by Yambam. https://shadertoy.com/view/wdSfzm\n// 2020-05-23 21:54:19\n\nconst float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926f;\nconst float DURATION = 12.;\n\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6f);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5f;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 8u;\n    uint numSamplesLight = 8u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3.f / (16.f * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    vec3 betaRt = betaR*(1. + vec3(0.,2.,3.)*(sin(iMouse.x/iResolution.x*2.*M_PI)-.1));\n    vec3 betaMt = betaM*(1. + 16.*iMouse.y/iResolution.y);\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaRt * (opticalDepthR + opticalDepthLightR) + betaMt * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaRt * phaseR + sumM * betaMt * phaseM) * 20.;\n}\n\n#define T(p, lod) textureLod(iChannel0, p, lod).rgb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float angle = M_PI * (fract((float(iFrame)/DURATION+40.)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy  * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    float z2 = x*x + y*y;\n    \n    vec3 col = vec3(0.0);\n    float scale = .3;\n    //if(z2 <= 1.){\n        float phi = (x/2. - 10./3. * iMouse.x / iResolution.x)*2.*M_PI*scale;\n        float theta;\n        if (fract((float(iFrame)/DURATION+40.)/180.) < .5) {\n            theta = y*M_PI*scale-1.5;\n        } else {\n            theta = -(y*M_PI*scale-1.5);\n        }\n        vec3 dir = vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n        col = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir, 0., INFINITY, sunDirection);\n    //}\n    \n\n    // Output to screen\n    col = pow(col, vec3(1.0/2.5));\n    fragColor = vec4(col,1.0);\n    \n    if (uv.y < -.065) {\n        fragColor = vec4(T(fragCoord/iResolution.xy, 0.), 1.); //vec4(vec3(.3), 1.);\n    }\n}\n#undef T", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926f;\nconst float DURATION = 12.;\n\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6f);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5f;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 8u;\n    uint numSamplesLight = 8u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3.f / (16.f * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    vec3 betaRt = betaR*(1. + vec3(0.,2.,3.)*(sin(iMouse.x/iResolution.x*2.*M_PI)-.1));\n    vec3 betaMt = betaM*(1. + 16.*iMouse.y/iResolution.y);\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaRt * (opticalDepthR + opticalDepthLightR) + betaMt * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaRt * phaseR + sumM * betaMt * phaseM) * 20.;\n}\n\n\n\nconst float waveHeight = .125; // average surface height\n\nfloat spow(float x, float e)\n{\n    return pow(abs(x), e) * sign(x);\n}\n\n// 3 scrolling textures on a plane\nfloat wave(vec3 p)\n{\n//    return p.y - waveHeight + .2*spow(sin(p.x)*sin(p.z), 4.); // test bumps\n\tfloat t = iTime * .33; //0.; // scroll or don't\n    // disliked how original fudged with the texcoords\n    #define T(x,y) texture(iChannel2, (p.xz + vec2(x,y)*t) / 20.).rgb\n\tvec3 c1 = T(2., 2.);\n\tvec3 c2 = T(2.52, 5.);\n\tvec3 c3 = T(3.32, 9.);\n    #undef T\n\tc1 += c2 - c3;\n\tfloat z = (c1.x + c1.y + c1.z) / 12.;\n\treturn p.y + z;\n}\n\n// no ray marching required, just cast directly to plane\nfloat intersectWave(vec3 ro, vec3 rd) \n{\n    return (ro.y - waveHeight) / -rd.y;\n}\n\n// even fwd diff seems fine for normal\nvec3 normWave(vec3 p) \n{\n\tconst vec2 e = vec2(.25,0);\n\treturn normalize(vec3(\n\t\twave(p + e.xyy),\n\t\twave(p + e.yxy),\n\t\twave(p + e.yyx))\n      - wave(p)\n\t);\n}\n\nvec3 lightWave(vec3 ro, vec3 rd, float d)\n{\n    vec3 p = ro + rd * d; // hit point on plane\n    float sh = wave(p) - .5*waveHeight; //.25; // wave height variation\n    p.xz += 2. * sh * rd.xz; // bump offset, parallax mapping - subtle\n    sh = wave(p) - .5*waveHeight; //.25; // reeval height after bump offset\n\tvec3 n = normWave(p) // surface normal\n\t, l1 = normalize(vec3(1)); // main parallel light ('sun')\n\tfloat nv = dot(rd, n)\n\t, spc = pow(max(0., dot(reflect(l1, n), rd)), 30.) // sun specular\n    , eta = 1.003/1.3 // air vs. water\n    , waterdepth = 4.; //+ sh\n    vec3 rfd = refract(rd, n, eta);  // refract view direction\n    float depthest = -waterdepth / rfd.y; // water depth estimate along refracted path\n    \n    \n    float angle = M_PI * (fract((float(iFrame)/DURATION+40.)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n    \n    float scale = .3;\n    float phi = (0. - 10./3. * iMouse.x / iResolution.x)*2.*M_PI*scale; //.4;\n    vec2 theta = vec2(-.35, .35);\n    vec3 dir0 = vec3(sin(theta[0])*cos(phi), cos(theta[0]), sin(theta[0])*sin(phi));\n    vec3 dir1 = vec3(sin(theta[1])*cos(phi), cos(theta[1]), sin(theta[1])*sin(phi));\n\t\n    vec3 col0 = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir0, 0., INFINITY, sunDirection).rgb;\n    vec3 col1 = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir1, 0., INFINITY, sunDirection).rgb;\n    \n    vec3 ref = texture(iChannel0, reflect(rd, n)*.667).rgb // reflection environment cubemap\n    , rfa = mix(\n        col0\n        ,\n        texture(iChannel1, (p + rfd*depthest).xz / 4.).rgb\n        ,\n        .3\n    ); // regular refraction\n    // HACK the original just did everything in srgb gamma\n    // which is not correct, but it's really hard to match\n    // the look without doing basically the same thing.\n\t// gave up on good gamma correction until I can\n    // match the look better somehow.\n     //   ref = pow(ref, vec3(2.2));\n     //   rfa = pow(rfa, vec3(2.2));\n    ref *= .5;\n    rfa *= exp2(-.125 * depthest); // extinct by water depth estimate\n    vec3 c;\n//    c = n * .5 + .5; // DEBUG normal\n//    c = vec3(sh * 1.5 + .5); // DEBUG height\n//    c = vec3(exp2(-.2*d)); // DEBUG depth\n//    c = vec3(spc); // DEBUG spec only\n//    c = ref; // DEBUG just envmap reflection\n//    c = rfa; // DEBUG just refraction\n//    c = spc + rfa; // DEBUG just spec + refraction\n//    c = pow(c, vec3(1./2.2)); // HACK fix gamma - temp - for debugging\n\tc = rfa + ref + spc*col1; // sum all light - in wrong gamma\n    return mix(mix(c, col0, .0), vec3(0.), pow(2., -.125 * depthest) - .65);\n}\n\n// e^(-i*angleRadians) I guess\nvec2 cossin(float angleRadians)\n{\n\treturn sin(angleRadians + vec2(1.5708,0));\n}\n\nvoid cameraRay(vec2 p, vec2 r, out vec3 ro, out vec3 rd)\n{\n\tvec2 q = (p + p - r) * .5/r.y; // signed aspect-correct uv\n\tfloat mx = (.35 + 2.5*(iMouse.x/iResolution.x)); // mouse lookaround\n    vec3 rc = vec3(500.*cos(mx), 6, 500.*sin(mx)); // look at point, spins around\n    //if (dot(iMouse.xy, vec2(1)) < 1.5) mx = iTime * -1.; // slowly spin if unattended\n\tro = vec3(0, 0, 3).xzy; // camera rotate\n\tvec3 ww = normalize(rc - ro)\n\t, uu = normalize(cross(vec3(0,1,0), ww))\n\t, vv = normalize(cross(ww, uu));\n\trd = normalize(uu * q.x + vv * q.y + ww);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 ro, rd, c = vec3(0);\n    cameraRay(fragCoord, iResolution.xy, ro, rd);\n\tfloat d = intersectWave(ro, rd);\n\tif (d >= 0.) // didn't miss? can't, really, with this camera\n        c = lightWave(ro, rd, d); // draw water\n\t//c = pow(c, vec3(1./2.2)); // to srgb gamma for storage in display buffer\n\tfragColor = vec4(c, 1);\n}\n\n\t\t//vec3 rfa = texture(iChannel1, (p+n).xz / 6.).rgb; // extreme HACK refraction\n     //   rfa *= 1.0; // HACK brighten riverbed rocks\n        //rfa *= 8./d; // HACK fade in distance to emulate missing fresnel and water extinction\n     //   rfa *= mix(1.-pow(max(0., 1.-abs(nv)), 5.), 1., .04); // fakie fresnel\n\t    //c = (c - .5) * 1.5 + .5; // HACK increase contrast\n\n", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 466, 552, 552, 809], [811, 811, 897, 897, 3304]], "test": "untested"}
{"id": "WdBfRy", "name": "Raymarching surface coloring", "author": "rodgzilla", "description": "Very glitchy but I kinda like the effect.", "tags": ["coloring"], "likes": 2, "viewed": 442, "published": 3, "date": "1590269676", "time_retrieved": "2024-07-30T21:05:27.560943", "image_code": "#define time iTime\n\n// #define SPEED 15.\n#define SPEED 15.\n#define FLOOR 0\n#define SPH 1\n#define CAP 2\n#define EXTR 3\n#define INF 4\n\nint hit = FLOOR;\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p) {\n    float r = .7;\n    float s = 2.;\n\n    for (float i = 0.; i < 4.; i++) {\n        p.xy *= rot2d(time * .7);\n        p.yz *= rot2d(time * .5 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tvec3 c = a + ab * t;\n  \n\treturn length(p - c) - r;\n}\n\nfloat cap(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0., 1.);\n\tvec3 c = a + ab * t;\n  \n\treturn length(p - c) - r;\n}\n\n\nvec3 rep(vec3 p, vec3 r) {\n    return mod(p, r) - .5 * r;\n}\n\nfloat map(vec3 p) {\n    p.xy *= rot2d(p.z / 70.);\n//    p = rep(p, vec3(0., 0, 100.));\n    p = rep(p, vec3(0., 0, 40.));\n    vec3 pkifs = kifs(p);\n    float d = 5000.;\n    \n    hit = FLOOR;\n  \tfloat dsph = sph(pkifs - vec3(2, 0, 0), 1.);\n    d = min(d, dsph);\n    hit = (d == dsph) ? SPH : hit;\n    float dtube = tube(pkifs, vec3(0, 1, 0), vec3(2, 1, 0), .5);\n    d = min(d, dtube);\n    hit = (d == dtube) ? CAP : hit;\n    float dextr = -tube(p, vec3(0, 0, -1), vec3(0, 0, 0), 2.);\n    d = max(d, dextr);\n    hit = (d == dextr) ? EXTR : hit;\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0, 0, -30. + time * SPEED);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    vec3 p = ro;\n    float d = 0.;\n    for (int i = 0; i < 100; i++) {\n\t\tfloat ds = map(p);\n        \n        if (ds < .01 || ds > 100.) {\n            break;\n        }\n        if (ds > 100.) {\n            hit = INF;\n        }\n        p += .7 * ds * rd;\n    }\n    \n    col = vec3(length(p - ro) * .1);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n\t));\n    \n    vec3 lp = vec3(0, 0, -30. + time * SPEED);\n    float dif = dot(n, normalize(lp - p));\n    \n//    map(p);\n    col = vec3(0, 0, 1);\n    if (hit == SPH) {\n        col = vec3(0.306, 0.21 + .3 * (.5 * sin(3. * time) + 0.5), .43);\n    }\n    if (hit == CAP) {\n//        col = vec3(201. /255., 122. / 255., 30. / 255.);\n        col = vec3(1);\n    }\n    if (hit == EXTR) {\n//        255, 182, 71\n\t\tcol = vec3(255. / 255., 182. / 255., 71. / 255.);\n//        col = vec3(1., 0., 0.);\n    }\n    if (hit == INF) {\n        col = vec3(1);\n    }\n    col *= dif;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 172, 172, 243], [245, 245, 264, 264, 490], [492, 492, 520, 520, 548], [550, 550, 595, 595, 723], [725, 725, 769, 769, 920], [923, 923, 949, 949, 982], [984, 984, 1003, 1003, 1546], [1549, 1549, 1606, 1606, 2905]], "test": "untested"}
{"id": "tdSfRy", "name": "DCT Happy Dance", "author": "eiffie", "description": "3D DCT - Very simple transformation with lots of uses.", "tags": ["video", "compression", "dct"], "likes": 8, "viewed": 640, "published": 3, "date": "1590268196", "time_retrieved": "2024-07-30T21:05:28.418650", "image_code": "//DCT Happy Dance - by eiffie (video compression using a 3d discrete cosine transform)\n#define FRAME_RATE 60.\n//buffer A has some defines to play with\nvoid mainImage( out vec4 O, in vec2 U ){\n  float Z=floor(mod(iTime*FRAME_RATE,64.));\n  vec2 safeRez=floor(iResolution.xy/64.)*64.;\n  vec2 p=vec2(mod(Z,8.),floor(Z/8.))*safeRez/8.+(U/iResolution.xy)*(safeRez/8.);\n  O=texture(iChannel0,p/iResolution.xy).rbba;//original is in r, g is tranformed, b is inverse transform\n  //O=texture(iChannel0,U/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//glitch pop\n//#define JUST_PLEASE_STOP\n#define tau 6.283185\nfloat nofs(float n){return -2.0*abs(mod(n,8.0)-4.0)+3.0;}\nfloat scale(float note){//throws out dissonant tones\n float n2=mod(note,12.0);\n if((n2==1.0)||(n2==3.0)||(n2==6.0)||(n2==8.0)||(n2==11.0))note=-100.0;\n return note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;}\nfloat I(float n,float t,float bt){\n  float f=ntof(scale(n)),att=100.0;\n  if(f<12.0)return 0.0;\n  f*=t*tau;\n  float a=sin(mod(f+bt*3.14159*sin(mod(f*0.251,tau)),tau));\n  a*=(1.0-exp(-bt*att))*clamp(1.0-bt,0.,1.)*60.0/n;\n  return a;\n}\nfloat sound(float time){\n  float tim=time*6.;\n  float b=floor(tim);\n  float t0=fract(tim),t1=mod(tim,2.0)*0.5,t2=mod(tim,4.0)*0.25;\n  float n2=nofs(b*0.0625)+nofs(b*0.125)+nofs(b*0.25);\n  float n1=n2+nofs(b*0.5),n0=n1+nofs(b);\n  float a0=I(n0+72.0,time,t0);\n  float a1=I(n1+60.0,time,t0);\n  float a1h=I(n1+56.0,time,t0);\n  float a2=I(n2+24.0,time,t0);\n  float v=0.1*(a0+a1+a2+a1h);\n  return clamp(v,-1.,1.);\n}\nint imod(int a, int b){return a-a/b*b;}\nvec2 mainSound( in int samp,in float time){\n #ifdef JUST_PLEASE_STOP\n  return vec2(0);\n #endif\n  int sampy=int(time*44100.),ps=imod(sampy,16);\n  float f=0.0;\n  for(int i=0;i<16;i++){\n    f+=sound(float(sampy-ps+i)/44100.)*cos(tau/32.*(float(i)+.5)*float(ps));\n  }\n  f*=.06125;//like throwing out all but the first term of the DCT??\n  return vec2(f);\n}", "sound_inputs": [], "buffer_a_code": "//choose a quality 0-3*(N-1) higher being better quality\n#define QUALITY 1.\n//#define I_DONT_WANT_TO_SEE_A_HAPPY_DANCE_BECAUSE_IM_DEAD_INSIDE\n//the DCT cube size 4x4x4=16, 8x8x8=512 (texture lookups)\n#define N 4.\n//Frames for a video are drawn and then a 3d DCT type II transform\n//is applied on cubes. The video has low frequencies so only\n//the data in the low tet of the cube is needed. The rest is tossed\n//with a simple formula x+y+z>QUALITY.\n//Then the inverse transform is applied resulting in the happy dance! \n#define rez iResolution.xy\n#define pi 3.14159\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nfloat DE(vec2 p, float tym){//the happy dance takes more code than the 3d DCT\n  vec2 p2=abs(p);           //and rightfully so\n  p2.x-=1.;if(iTime>15.)tym+=iTime;\n  float m=abs(max(abs(p2.x)-0.25,p2.y-0.52));\n  if(abs(p.x)>0.75){p.x-=sign(p.x)*0.75;p*=2.0;}\n  float sa=sin(tym);\n  vec2 h=vec2(sa*0.1,0.8),n=vec2(sa*0.1,0.7);\n  vec2 s=vec2(sa*0.1,0.5),b=vec2(sa*0.2,0.0);\n  vec2 h1=vec2(sa*0.5-0.2,0.7+sa*0.1),h2=vec2(sa*0.5+0.2,0.7-sa*0.1);\n  vec2 e1=vec2(sa*0.25-0.3,0.4+sa*0.1),e2=vec2(sa*0.25+0.3,0.4-sa*0.1);\n  vec2 k1=vec2(sa*0.25-0.2,-0.5),k2=vec2(sa*0.25+0.2,-0.5);\n  vec2 f1=vec2(-0.4,-0.9),f2=vec2(0.4,-0.9);\n  float d=min(tube(p-e1,h1-e1),tube(p-s,e1-s));\n  d=min(d,min(tube(p-e2,h2-e2),tube(p-s,e2-s)));\n  d=min(d,min(tube(p-n,b-n),tube(p-n,h-n)-0.07));\n  d=min(d,min(tube(p-b,k1-b),tube(p-b,k2-b)));\n  d=min(d,min(tube(p-k1,f1-k1),tube(p-k2,f2-k2)));  \n  return min(d-0.04,m);\n}\nvec2 safeRez;\nvec4 get(vec3 p){//change 3d DCT addressing to 2d texture addressing\n  p=floor(p);\n  vec2 v=p.xy+vec2(.5)+vec2(mod(p.z,8.),floor(p.z/8.))*safeRez/8.;\n  return texture(iChannel0,v/rez);\n}\nvoid mainImage( out vec4 c, in vec2 p ) {\n  if(iFrame<2){c=vec4(0);return;}\n  c=texture(iChannel0,p/rez);\n  safeRez=floor(rez/64.)*64.;if(any(greaterThan(p,safeRez))){c=vec4(0);return;}\n  p=floor(p);//the frames are laid out in a 8x8 grid and need to be a multiple\n  vec2 p8=p*vec2(8)/safeRez; //of 8 in size for the 8x8x8 cubes so\n  vec2 fl=floor(p8),fr=2.0*(fract(p8)-0.5);//some bs to do that\n  float Z=fl.y*8.+fl.x;//the video frame or z depth\n  vec3 p3=vec3(floor(p-fl*safeRez/8.),Z),pk=mod(p3,vec3(N));//position in frame(s), pos in cube\n  if(iFrame<5 || iTime>15.){//draw a happy dance in front of mirrors\n    float tym=Z/(64.)*6.283;\n   #ifdef I_DONT_WANT_TO_SEE_A_HAPPY_DANCE_BECAUSE_IM_DEAD_INSIDE\n    c.x=texture(iChannel1,vec2(0.45)+fr/8.+vec2(cos(tym),sin(tym))*0.25).r;\n   #else\n    c.x=DE(fr,tym);c.x=smoothstep(0.1,0.,c.x);\n   #endif\n  }else if(iFrame==5){//build DCT II cubes NxNxN\n    c.y=0.0;\n    for(float z=.5;z<N;z+=1.)for(float y=.5;y<N;y+=1.)for(float x=.5;x<N;x+=1.){\n      vec3 pn=vec3(x,y,z),cs=cos(pi/N*pn*pk);c.y+=get(p3-pk+pn).x*cs.x*cs.y*cs.z;\n    }\n    c.y*=8./(N*N*N);\n  }else if(iFrame==6){//compress the crap out of it\n    if(pk.x+pk.y+pk.z>QUALITY)c.y=0.0;//squash the high frequencies to mimic compression\n  }else if(iFrame==7){//invert using DCT III\n    c.z=0.0;\n    for(float z=.0;z<N;z+=1.)for(float y=.0;y<N;y+=1.)for(float x=.0;x<N;x+=1.){\n      vec3 pn=vec3(x,y,z),h=vec3(.5),cs=mix(h,cos(pi/N*pn*(pk+h)),step(h,pn));\n      c.z+=get(p3-pk+pn).y*cs.x*cs.y*cs.z;\n    }\n  }//thats it!\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 151, 191, 191, 512]], "test": "untested"}
{"id": "wdSBzG", "name": "Outline 2020 Freestyle Session", "author": "blackle", "description": "coded live in 2 hours at outline online 2020 during the shader freestyle. code quality and performance is no good XD", "tags": ["freestyle"], "likes": 39, "viewed": 796, "published": 3, "date": "1590259909", "time_retrieved": "2024-07-30T21:05:29.290319", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0.,k-abs(b-a))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat box(vec4 p, vec4 d) {\n  vec4 q = abs(p)-d;\n  return length(max(q,0.)) + min(0., max(max(q.x,q.y),max(q.z,q.w)));\n}\nfloat box(vec3 p, vec3 d) {\n  vec3 q = abs(p)-d;\n  return length(max(q,0.)) + min(0., max(q.x,max(q.z,q.y)));\n}\n\nvec4 wrot(vec4 p) {\n  return vec4(dot(p,vec4(1.)), p.yzw + p.zwy - p.wyz - p.xxx)/2.;\n}\n\nfloat sep;\nfloat t;\nfloat plane;\nfloat obj;\nfloat hiddenball;\nfloat clouds(vec3 p) {\n  \n  p = erot(p,normalize(vec3(2,3,1)),2.123);\n  float d1 = length(abs(asin(sin(p))*.9))-1.;\n  p = erot(p,normalize(vec3(1,2,3)),2.453);\n  float d2 = length(abs(asin(sin(p))*.9))-1.;\n  p = erot(p,normalize(vec3(3,2,1)),0.7821);\n  float d3 = length(abs(asin(sin(p))*.9))-1.;\n  return (d1+d2+d3)/3.;\n}\n\nfloat airplane(vec3 p) {\n  float pln = linedist(p, vec3(.4,0,0), vec3(-.6,0,0))-.1-cos(p.x*2.)*.1;\n  float wingskel = linedist(p.xy, vec2(0,.6), vec2(0,-.6))-.15;\n  float wing = linedist(vec2(wingskel, p.z), vec2(-.04,0), vec2(-1,0))-.04;\n  float tail = linedist(p, vec3(-.65,0,0), vec3(-.85,0,.2))-.13;\n  float ruddskel = linedist(p.xy, vec2(-.9,.3), vec2(-.9,-.3))-.1;\n  float rudd = linedist(vec2(ruddskel, p.z), vec2(-.04,.28), vec2(-1,.28))-.03;\n  return smin(min(rudd,wing), smin(tail,pln,0.2),.1);\n}\n\nfloat blimp(vec3 p) {\n  float blmp = linedist(p, vec3(.6,0,0), vec3(-.7,0,0))-.4-cos(p.x*2.)*.1;\n  float carriage = linedist(p, vec3(.3,0,-.5), vec3(-.3,0,-.5))-.15;\n  p.yz = abs(p.yz);\n  p.yz = vec2(max(p.y,p.z),min(p.y,p.z));\n  float ruddskel = linedist(p.xy, vec2(-1.,.3), vec2(-.8,-.3))-.2;\n  float rudd = linedist(vec2(ruddskel, p.z), vec2(-.04,.0), vec2(-1,.0))-.03;\n  return min(min(carriage,blmp),rudd);\n}\n\nfloat hotair(vec3 p) {\n  p.z -= .4;\n  float ht = length(p)-.7;\n  float dimpl = linedist(p, vec3(0), vec3(0,0,-.8))-.2;\n  float hollow = linedist(p, vec3(0), vec3(0,0,-1.3))-.18;\n  float carriage = box(p-vec3(0,0,-1.3), vec3(.12))-.05;\n  carriage = -min(-carriage, box(p-vec3(0,0,-1.), vec3(.12, .12, .3)));\n  p.xy = abs(p.xy);\n  float lines = linedist(p, vec3(0.1,0.1,-.5), vec3(.1,.1,-1.3))-.01;\n  return min(-smin(-smin(ht, dimpl, 0.4),hollow,.01), min(lines,carriage));\n}\n\nfloat helicopter(vec3 p) {\n  float body = linedist(p, vec3(.2,0,0), vec3(-.2,0,0))-.35;\n  body = smin(body, linedist(p, vec3(.2,0,-.2), vec3(-1.,0,-.2))-.2, .2);\n  float tail = linedist(p, vec3(-1.1,0,-.2), vec3(-1.3,0,0))-.13;\n  body = smin(body,tail,.1);\n  vec3 p2 = p;\n  p2.x -= -1.3;\n  p2 = erot(p2, vec3(0,1,0), iTime);\n  p2.y -=0.15;\n  p2.y=abs(p2.y);\n  p2.xz = abs(p2.xz);\n  p2.zx = vec2(max(p2.x,p2.z),min(p2.x,p2.z));\n  p = erot(p, vec3(0,0,1), iTime);\n  p.z -=0.44;\n  p.yx = abs(p.yx);\n  p.yx = vec2(max(p.y,p.x),min(p.y,p.x));\n  \n  float wingskel = linedist(p.xy, vec2(0,.6), vec2(0,-.6))-.1;\n  float wing = linedist(vec2(wingskel, p.z), vec2(-.04,0), vec2(-1,0))-.04;\n  float wingskel2 = linedist(p2.xz, vec2(0,.2), vec2(0,-.23))-.06;\n  float wing2 = linedist(vec2(wingskel2, p2.y), vec2(-.04,0), vec2(-1,0))-.02;\n  return min(body,min(wing,wing2));//smin(min(rudd,wing), smin(tail,pln,0.2),.1);\n  \n}\n\nfloat scene(vec3 p) {\n  float fl = p.z + 5.;\n  \n  vec3 pp = p;\n  pp.y = asin(sin(pp.y/sep))*sep;\n  float roll = pow(sin(fract(t*.03)*3.14/2.),50.) + floor(t*.03);\n  pp = erot(pp, vec3(1,0,0),roll*acos(-1.)*2.);\n  pp = erot(pp, vec3(0,1,0),sin(t)*.4);\n  pp = erot(pp, vec3(0,0,1),cos(t*.5)*.2);\n  pp.z += cos(t)*.3;\n  pp.y += -sin(t*.5)*.2;\n  float air = airplane(pp);\n  float blmp = blimp(pp);\n  float hot = hotair(pp);\n  float heli = helicopter(pp);\n  float mixval_a = smoothstep(-.25,.25,sin((iTime+1.)/2.));\n  float mixval_b = smoothstep(-.15,.15,sin((iTime+1.)/4.));\n  plane = mix(mix(hot, heli, mixval_a), mix(blmp, air, mixval_a), mixval_b);\n  //plane = \n  \n  \n  p.x += mod(t,1000.);\n  vec3 p2 = p;\n  p2 = erot(p2, vec3(0,0,1),.31233);\n  p2.xy = asin(sin(p2.xy/3.)*.97)*3.+3.;\n  p2.z += 4.;\n  p2 = erot(p2, vec3(0,0,1),t*.3);\n  p2 = erot(p2, vec3(0,1,0),t*.2);\n  p2 = erot(p2, vec3(1,0,0),t*.1);\n  obj = length(min(1.-abs(p2),0.6))-.7;\n  \n  \n  p = erot(p,normalize(vec3(2,3,1)),2.123);\n  float d1 = dot(abs(asin(sin(p))*.9),vec3(1))/sqrt(3.)-1.;\n  p = erot(p,normalize(vec3(1,2,3)),2.453);\n  float d2 = dot(abs(asin(sin(p))*.9),vec3(1))/sqrt(3.)-1.;\n  p = erot(p,normalize(vec3(3,2,1)),0.7821);\n  float d3 = dot(abs(asin(sin(p))*.9),vec3(1))/sqrt(3.)-1.;\n  \n  \n  \n  float ground = mix((d1+d2+d3)/2.5, fl,0.2);\n  vec4 reproj = vec4(ground, asin(sin(p*5.))/5.);\n  float mx = cos(iTime*.3-fl*.3)*.5+.5;\n  mx = smoothstep(0.4,.6,mx);\n  mx = smoothstep(0.,1.,mx);\n  reproj = mix(wrot(reproj), reproj,mx);\n  ground = box(reproj,vec4(.02,.27,.27,.27))-0.04;\n  hiddenball = length(reproj+vec4(.2,0,0,0))-.2;\n  ground = min(ground, hiddenball);\n  return min(min(obj,ground), plane);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.03);\n  return normalize(scene(p)-vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord - iResolution.xy*.5)/iResolution.y;\n\n  float sc = smoothstep(.5,.6,cos(iTime/10.+3.));\n  t = pow(sin(fract(iTime*.4)*3.14/2.),70.)*2. + floor(iTime*.4)*2. + iTime*.9 + 2.;\n  sep = 2.+cos(t*.4);\n  vec3 cam = normalize(vec3(1, uv));\n  vec3 init = vec3(-5.+sin(t), 0, 0) + cam;\n  cam = erot(cam,vec3(0,1,0),.7-sc*.3);\n  init = erot(init,vec3(0,1,0),.7-sc*.3);\n  float zrot = t*.3;\n  cam = erot(cam,vec3(0,0,1),zrot);\n  init = erot(init,vec3(0,0,1),zrot); \n  init.z -= sc*4.;\n  \n\n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  bool triggered = false;\n  bool outline = false;\n  float glow = 0.;\n  for (int i = 0; i < 150 && !hit; i++) { \n    dist = scene(p);\n    glow += 1./(hiddenball*500.+1.);\n    if (!triggered) triggered = dist < 0.03;\n    if (triggered) {\n      float ol = 0.05-dist;\n      outline = ol < dist;\n      dist = min(ol,dist);\n    }\n    hit = dist*dist < 1e-6;\n    p+=cam*dist;\n  }\n  vec3 p2 = init;\n  for (int i = 0; i < 30; i++) {\n    float dd = abs(clouds(p2))+.1;\n    p2+=cam*dd;\n  }\n  float lcoudstr = distance(p2, init);\n  float fog = smoothstep(40.,10.,distance(p,init)+ lcoudstr*.5);\n  bool pl = plane == dist;\n  bool oj = obj == dist;\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float ao = smoothstep(-.1,.1,scene(p+n*.1));\n  float diff = ao*length(sin(n*vec3(3,2,2))*.5+.5)/sqrt(3.);\n  diff = floor(diff*6.)/6.+.1;\n  float spec = length(sin(r*vec3(3,2,2))*.5+.5)/sqrt(3.);\n  float fres = 1.-abs(dot(cam,n))*.9;\n  vec3 matcol = mix(vec3(0.3,0.7,0.2), vec3(0.7,0.5,0.2), smoothstep(-5.5,-4.5,p.z));\n  matcol = mix(matcol, vec3(0.7,0.75,0.9), smoothstep(-4.5,-3.5,p.z));\n  if (pl) {\n    matcol = vec3(0.9,0.8,0.3);\n    float id = floor(p.y/acos(-1.)/sep + 1.5);\n    id += floor(iTime);\n    matcol = abs(erot(matcol, vec3(1,0,0), id))*.6+.4;\n    matcol = abs(erot(matcol, vec3(0,1,0), id*2.3423))*.6+.4;\n  }\n  vec3 col = matcol*diff + pow(spec,10.)*fres*1.5;\n  if (oj) {\n    \n    float spec2 = length(sin(r*vec3(3,1,1))*.5+.5)/sqrt(3.);\n    float spec3 = length(sin(-r*vec3(3,1,1))*.5+.5)/sqrt(3.);\n    col = vec3(0.8,0.3,0.2)*floor(spec2*6.)/6.+pow(spec2,10.);\n    col += (vec3(0.1,0.3,0.8)*floor(spec3*6.)/6.+pow(spec3,10.))*.7;\n    col *=ao;\n  }\n  vec3 bgcol = vec3(0.4,0.7,0.9);\n  if (!pl) {\n    col *= 0.7;\n  } else {\n    col = col*.7+.3;\n  }\n  col = erot(col,normalize(sin(p)),.02);\n  fragColor.xyz = (hit ? mix(bgcol, col,fog) : bgcol) + pow(smoothstep(40.,5.,lcoudstr),10.)*(1.-fog);\n  if (outline) fragColor.xyz = mix(bgcol, fragColor.xyz*.2, fog);\n  fragColor.xyz = smoothstep(vec3(-.2),vec3(1.2),fragColor.xyz);\n  fragColor.xyz += (glow*vec3(0.7,0.3,0.)+glow*.9)*.4;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSBzG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 292], [294, 294, 334, 334, 422], [424, 424, 464, 464, 552], [554, 554, 593, 593, 659], [661, 661, 688, 688, 781], [782, 782, 809, 809, 893], [895, 895, 914, 914, 982], [1046, 1046, 1068, 1068, 1368], [1370, 1370, 1394, 1394, 1876], [1878, 1878, 1899, 1899, 2291], [2293, 2293, 2315, 2315, 2767], [2769, 2769, 2795, 2795, 3681], [3683, 3683, 3704, 3704, 5364], [5366, 5366, 5385, 5385, 5496], [5498, 5498, 5555, 5555, 8191]], "test": "untested"}
{"id": "tsSfRG", "name": "newton-rhapson Lissajous", "author": "asiermarzo", "description": "A newton-rhapson fractal that solves a Lissajous curves of 3 points. Some color gradients and smoothing are applied.", "tags": ["fractal", "newtonrhapson"], "likes": 4, "viewed": 396, "published": 3, "date": "1590258129", "time_retrieved": "2024-07-30T21:05:30.050287", "image_code": "#define sLenght(a) dot((a),(a))\n\nvec2 cInv(vec2 c){\n\tfloat sl = dot(c,c);\n\treturn vec2(c.x / sl, -c.y / sl);\n}\n\nvec2 cMul(vec2 a, vec2 b){\n\tvec4 t = a.xyxy * b.xyyx;\n\treturn vec2(t.x - t.y, t.z + t.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat zoom = (sin(iTime/4.0)+1.0) * 8.0 + 1.0;\n    vec2 p = -(zoom/2.0) + zoom * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\n\tfloat t = iTime/2.0;\n\t\n\t//setting roots of a third grade poly using a Lissajous curve\n    vec2 root1 = vec2(sin(t + 0.00000000) , sin(2.0 * t + 0.00000000));\n\tvec2 root2 = vec2(sin(t + 2.09439510) , sin(2.0 * t + 2.09439510));\n\tvec2 root3 = vec2(sin(t + 4.18879020) , sin(2.0 * t + 4.18879020));\n\t\n\tconst int maxIters = 16;\n\tfloat tolerance = 1e-8;\n\tvec2 r1,r2,r3;\n\tvec2 prevP = p;\n\tfloat iters = 0.0;\n\t\n\tr1 = p-root1;\n\tr2 = p-root2;\n\tr3 = p-root3;\n\n\tfor(int iterations = 0; iterations < maxIters; iterations++ ){\n\t\tprevP = p;\n\t\t//newton-rhapson method iteration\n\t\tp = p - cInv( cInv(r1) + cInv(r2) + cInv(r3) );\n\t\t\n\t\t//check how near we are from the nearest root\n\t\tr1 = p-root1;\n\t\tr2 = p-root2;\n\t\tr3 = p-root3;\n\t\tif (min(sLenght(r1),min(sLenght(r2),sLenght(r3))) < tolerance ) {break;}\n\t\titers += 1.0;\n\t}\n\tfloat co = iters;\n\t\n\t//the code could be more compact but repeating code makes changing the gradients easier\n\tfloat l1 = length(p-root1);\n\tfloat l2 = length(p-root2);\n\tfloat l3 = length(p-root3);\n\tfloat dist0,dist1;\n\tfloat tol = log(tolerance);\n    if (l1 <= l2 && l1 <= l3){\n\t\tdist0 = log(sLenght(prevP-root1));\n\t\tdist1 = log(sLenght(p-root1));\n\t\tif (dist1 < tol && dist0 > tol) { co += (tol - dist0) / (dist1 - dist0); }\n\t\tco = clamp(co/float(maxIters),0.0,1.0);\n\t\t\n\t\t//gradient for root1\n\t\tfragColor = vec4(\n\t\t\t0.5+0.89*cos(6.2831855*co+0.0),\n\t\t\t0.5+0.48000002*cos(25.132742*co+2.0734513),\n\t\t\t0.5+0.38*cos(50.265484*co+4.1469026),\n\t\t\t1.0);\n\t\t\t\n\t}else if (l2 <= l1 && l2 <= l3){\n\t\tdist0 = log(sLenght(prevP-root2));\n\t\tdist1 = log(sLenght(p-root2));\n\t\tif (dist1 < tol && dist0 > tol) { co += (tol - dist0) / (dist1 - dist0); }\n\t\tco = clamp(co/float(maxIters),0.0,1.0);\n\t\t\n\t\t//gradient for root2 \n\t\tfragColor = vec4(\n\t\t\t0.5+0.6*cos(2.0106194*co+-1.5079645),\n\t\t\t0.5+1.0*cos(4.5867257*co+2.576106),\n\t\t\t0.5+0.82*cos(3.015929*co+2.3247786),\n\t\t\t1.0);\n\t\t\t\n\t}else if (l3 <= l2 && l3 <= l1){\n\t\tdist0 = log(sLenght(prevP-root3));\n\t\tdist1 = log(sLenght(p-root3));\n\t\tif (dist1 < tol && dist0 > tol) { co += (tol - dist0) / (dist1 - dist0); }\n\t\tco = clamp(co/float(maxIters),0.0,1.0);\n\t\t\n\t\t//gradient for root3 \n\t\tfragColor = vec4( .5+.5*cos(6.2831*co+0.0),\n                         .5+.5*cos(6.2831*co+0.4),\n                         .5+.5*cos(6.2831*co+0.7),\n                         1.0 );\n\t\t\t\t\t\t \n\t}else{\n\t\tfragColor = vec4(0.0 , 0.0, 0.0, 1.0 );\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 51, 51, 110], [112, 112, 138, 138, 203], [205, 205, 260, 260, 2766]], "test": "untested"}
{"id": "tdSfRG", "name": "Day 155", "author": "jeyko", "description": "potoa", "tags": ["mdtmjvm"], "likes": 7, "viewed": 412, "published": 3, "date": "1590257710", "time_retrieved": "2024-07-30T21:05:30.812250", "image_code": "vec3 glow = vec3(0);\n\nfloat id = 0.;\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y,p.z));\n}\n\n\n    \n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define AO(j) clamp(map(p+n*j).x/j,0.,1.)\n#define SSS(j) smoothstep(0.,1.,map(p+l*j).x/j)\n\n\nfloat r11(float t){return fract(sin(t*414.125)*114.12521);}\n\nfloat valN(float t){return mix(r11(floor(t)),r11(floor(t)+1.),pow(fract(t),2.));}\nvec3 nois(float t){\n    t /= 2.;\n\treturn vec3(valN(t+200.),valN(t+10.),valN(t+50.));\n\n}\n\nvec3 n;\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    \n    \n    vec3 sz = vec3(1.,0.5,0.5)/2.;\n    \n    //p.y += sz.y;\n    \n    \n    for(int i = 0; i < 8; i++){\n    \t\n        float b = sdBox(p, sz);\n        \n        sz *= vec3(0.74,0.5,0.74);\n        if(b<=d.x){\n        \tid = float(i);\n            d.x = b;\n        }\n        p=abs(p);\n        \n        p.xy *= rot(-0.9+n.x);\n        p.yz *= rot(0.6-n.y*0.3);\n        p.xz *= rot(-0.2+n.y*0.1);\n    \tp.xy -= sz.xy*2.;\n        \n        \n    }\n    \n    //glow += exp(-d.x*20.)*pal(0.5,0.6,vec3(0.6,0.2,0.1),1.,p.x+iTime);\n    return d;\n\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0.);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    n = nois(iTime);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    \n    ro.xz = 2.*vec2(cos(n.x*6.14),sin(n.x*6.));\n    \n    \n    vec3 lookAt = vec3(0);\n    \n    vec3 dir = normalize(lookAt - ro);\n    \n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    vec3 rd = normalize(dir + right*uv.x + up*uv.y);\n    \n    \n    \n    vec3 p = ro; float t = 0.; bool hit = false;\n    \n    vec2 d;\n    \n    for(int i = 0; i < 250; i++){\n    \td = map(p);\n        \n        \n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n    \n        p += rd*d.x;\n        t += d.x;\n    }\n    \n    vec3 l = normalize(vec3(1));\n    if(hit){\n    \tvec3 n = getNormal(p);\n        \n        float ao = AO(0.6)*AO(0.1)*AO(0.3)*SSS(0.8);\n        \n        vec3 c = pal(0.5, 0.5,vec3(1.,0.4,0.2),1., iTime + length(p) +id );\n        \n        col += c*ao;\n        \n    }\n    \n    col = mix(col, vec3(0.1,0.1,0.1)/7.,smoothstep(0.,1.,t*0.1));\n    \n    if(!hit){\n    \tcol += glow*0.01;\n    \n    }    \n    \n    col *= 4.;\n    \n    \n    //col *= 1. - pow(dot(p,p), 2.);\n    \n    col = pow(max(col,0.),vec3(0.4545454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 66, 66, 117], [311, 311, 330, 330, 370], [372, 372, 392, 392, 453], [454, 454, 473, 473, 541], [552, 552, 569, 569, 1128], [1130, 1130, 1153, 1153, 1286], [1288, 1288, 1345, 1345, 2604]], "test": "untested"}
{"id": "wdSBRG", "name": "Sunakai", "author": "jeyko", "description": "\nSDF and coloring from https://www.shadertoy.com/view/WtV3Rw\nMDTMJVM = Middecembertomidjanuaryvember\nA month of coding stuff.\nCoding some of the days at http://twitch.tv/wwrighter", "tags": ["pathtracer", "mdtmjvm"], "likes": 5, "viewed": 907, "published": 3, "date": "1590255494", "time_retrieved": "2024-07-30T21:05:31.759717", "image_code": "// 4k executable graphics for Outline 2020 demoparty\n\n// Code is pretty messy\n\n// noby's \"Devour\" artwork I used as a reference to learn DOF, so there are remnants of that in the code.\n\n// Thx to fizzer for the cosineDirection()\n// Dave Hoskins for hashes\n// Krzysztof Narkowicz for the ACESFilm()\n// slerpy, noby, and Luna, whose code I learned pathtracing tricks from\n\n#define S 0.5\n\n#define resolution iResolution.xy\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\n#define M 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec4 col = vec4(0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    col = texture(iChannel0,uv);    \n    col /= col.w;\n    \n    vec2 uvs = (fragCoord / iResolution.xy - 0.5) * (resolution.x/resolution.y) * 2.0;\n\n\t\n    col *= 0.16;\n    uvs *= 0.34;\n    col *= smoothstep(1.,0.,pow(dot(uvs,uvs),1.)/1.5);\n    col.xyz = mix(col.xyz,smoothstep(0., 1., col.xyz),0.5);\n    col.xyz = ACESFilm(col.xyz);\n\tcol = pow(col, vec4(0.45));;\n    \n    fragColor = col;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define zoom 0.\n\nint BOUNCES = 3;\n\n#define MARCH_ITERATIONS 230\n\n\n#define mx (20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pmod(p,x) mod(p, x) - x*0.5\n\n#define fogCol vec3(0.12,0.15,0.2)*2.\n#define giAmt 0.4\n\n\nfloat seed;\nfloat side = 1.;\n\nvec3 fog = vec3(0.);\nvec3 prevP;\n\nvec3 attenuation = vec3(1.);\n\n\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = hash13(id + vec3(0,-1,0));\n    float ibr = hash13(id + vec3(1,-1,0));\n    float itl = hash13(id + vec3(0));\n    float itr = hash13(id + vec3(1,0,0));\n    \n    \n    float jbl = hash13(id + vec3(0,-1,1));\n    float jbr = hash13(id + vec3(1,-1,1));\n    float jtl = hash13(id + vec3(0,0, 1));\n    float jtr = hash13(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat fbm(vec3 p){\n\n    float n = 0.;\n    p *= 2.;\n    \n    float f = valueNoise(p); \n    \n    float q = valueNoise(p*2.8);\n    \n\n    n += f*1. + q*0.5;\n    \n\treturn n;\n}\n\n\nvec2 fc;\nfloat sd;\nvec2 hash2(float n){\n    vec2 rand = texelFetch(iChannel1, ivec2(mod(fc,1024.)),0).rg;\n    rand += hash(sd+float(iFrame)+n);\n    return mod(rand, 1.0);\n}\n\n\n\nMaterial materials[6] = Material[](\n\tMaterial(vec3(1.,0.4,1)*1.1,499.,0.,1.), // unused\n\tMaterial(vec3(0.,0.5,0.6)*1.,14.,0.0,0.9), // ?\n\tMaterial(vec3(1.),0.,0.,0.), \t\t\t// diffuse\n\tMaterial(vec3(1.,0.2,0.1)*1.,165.,0.9,0.1),\t// light \n\tMaterial(vec3(0.8,0.4,1.4)*3.5,0.,0.9,2.0), // xtal refractive\n\tMaterial(vec3(0.8,0.4,1.4)*3.5,0.,0.9,2.0) \t// xtal reflective\n);  \n\n\n\nfloat pmodpol(inout vec2 uv, float rep){\n    uv.xy *= rot(pi/rep);\n    float id = floor(rep*atan(uv.x,uv.y)/tau + rep*0.5);\n    uv.xy *= rot(0.5*pi);\n    uv *= rot((id+1.)/(rep)*tau + tau/rep);\n    uv.xy *= rot(-pi/rep);\n    return id;\n}\n\n\nvec3 glow = vec3(0);\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdRhombicDodecahedron( vec3 p, float s)\n{\n    vec3 q = p;\n  \tq = abs(q)- s;\n \tfloat d = max(q.y,max(q.x,q.z));\n \t\n    float sSc = 1.42;\n    \n    //d = 10e6;\n    \n    float topUnsc = 1.3;\n    \n    q = p;\n    \n    p.xy *= rot(0.25*pi);\n    p.z = abs(p.z);\n        \n    p.z -= 1.*s;\n    p.z *= topUnsc; \n    \n    \n    d = min(d,sdOctahedron(p,s*sSc));   \n    \n    p=q;\n    p=abs(p);\n    p.x-=s*1.;\n    p.yz *= rot(0.25*pi); \n    p.x *= topUnsc;\n    \n    d = min(d,sdOctahedron(p,s*sSc));    \n    \n    p=q;\n    p=abs(p);\n    p.y-=s*1.;\n    p.xz *= rot(0.25*pi); \n    p.y *= topUnsc;    \n    d = min(d,sdOctahedron(p,s*sSc));\n    \n    \n    \n\treturn d;\n}\n    \n\nfloat coolCahedron(vec3 q, float s){\n    float rhomb= sdRhombicDodecahedron(q,s*0.45);\n    float d = rhomb;\n    d= 10e7;\n    rhomb = max( sdOctahedron(q,s),-rhomb);\n    d = min(d,rhomb);\n    return d;\n}\n\nObject mapG(vec3 p){\n    Object o = NewObject;\n\n\to.d = 10e6;\n\n    o.material = 2.;\n    float octa = 10e7;\n    float sc = 1.;\n    float sep = 1.3;\n    \n    vec3 q = p;\n    float rhomb= coolCahedron(q,S*sc);\n    \n    \n    float dBalls = 10e7;\n    \n    float dXtal = 10e7;\n    \n    float reps = 4.;\n    pmodpol(p.xy,reps);\n    pmodpol(p.yz,reps);\n    pmodpol(p.xz,reps);\n    p *= 0.65;\n    \n    for(float i = 0.; i < 4. + min(float(iFrame),0.); i++){\n        \n        sc = pow(0.54, i+1.);\n        if(mod(i+2.,2.) > 0.){\n            float db = length(p)-0.4*sc;\n            if(db< dBalls){\n            \tdBalls = db;\n                materials[3].albedo = 0.5 + sin(vec3(1.,0.5,0.1)+i+2.)/2.;\n                materials[3].albedo = max(materials[3].albedo,0.);\n                \n            }\n        }\n        \n        float sepi = sep*sc;\n        p=abs(p);\n        p.x -= sepi;\n        vec3 v = p;\n    \tocta= min(octa,coolCahedron(p,S*sc));\n        \n        if(mod(i+3.,2.) < 1.){\n            float db = sdOctahedron(p,S*sc*0.9);\n            if(db< dXtal){\n            \tdXtal = db;\n                materials[4].albedo = 0.5 + sin(vec3(1.,0.5,0.1)+i+2.)/2.;\n            }\n        }\n        \n        p.x += sepi;\n        p.y -= sepi;\n        \n        vec3 b = p;\n    \tocta= min(octa,coolCahedron(p,S*sc));\n        \n        if(mod(i+3.,2.) < 1.){\n            float db = sdOctahedron(p,S*sc*0.9);\n            if(db< dXtal){\n            \tdXtal = db;\n            }\n        }\n        \n        p.y += sepi;\n        p.z -= sepi;\n    \tocta= min(octa,coolCahedron(p,S*sc));\n\n        if(mod(i+3.,2.) < 1.){\n            float db = sdOctahedron(p,S*sc*0.9);\n            vec3 q = abs(p);\n            if(i<3.){\n                q.xz *= rot(0.25*pi);\n                q.xy *= rot(0.25*pi);\n                vec3 bSz = vec3(S*sc*0.9);\n                bSz.x *= 0.05;\n                bSz.y *= 100.;\n                bSz.z *= 0.05;\n                db = min(db,sdBox(q,bSz));\n            \n            }\n            if(db< dXtal){\n                dXtal = db;\n            }\n        }\t\n    }\n    \n\n    \n    o.d = min(o.d,octa);\n    \n    o = omin(o,dBalls, 3.);\n    \n    return o;\n}\n\n\n\n// ----------------- MAP ----------------- //\nObject map(vec3 p) {\n    Object o = NewObject;\n    \n    vec3 q = p;\n    \n\tfloat off = 20.;\n    float sz = 40.;\n    \n    p.z += sz*0.25;\n    \n    p.x -= off;\n    \n    p.x += off*2.;\n    \n    p.z -= sz*.25;\n    p.x -= off;\n    \n    o = omin(o,mapG(p));\n    \n\n    vec3 y = p;    \n    p=abs(q);\n    q = y;\n    \n    \n    p.xz *= rot(0.125*pi);\n    p.xz -= 0.5;\n    \n    q.xz *= rot(-0.25*pi);\n    \n    q.x = pmod(q.x, 0.5);\n    q.z -= 1.2;\n    o = omin(o,sdBox(q,vec3(0.2,15.,0.2)), 4.);\n    \n    \n    o.didHit = true;\n    o.d *= 0.6;\n    return o;\n}\n\nObject trace(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.01;\n    float t = 0.;\n    for (int i = 0; i < MARCH_ITERATIONS ; i++) {\n    \tObject obj = map(p);\n        \n        obj.d *= side;\n    \n        float dPds = length(p - prevP);\n        \n       \n        float noise = 0.1+fbm(3.6+1.5*p+0.*p*(1.5 + smoothstep(0.,1.,p.y)/1.));\n        \n        \n            \n        float fgPw = pow(max(-p.z-10.4*0.12+p.x,0.), 2.)*1000.01;\n\n        noise = pow(noise,6.);\n        \n        float fgDens = .005/(.014+fgPw)*dPds*noise;\n        \n        float fgDensSmoothstep = smoothstep(0.,1.,fgDens*1.);\n        \n        attenuation = mix(attenuation,attenuation*fogCol,smoothstep(0.,1.,fgDensSmoothstep*1.));\n        rd = mix( rd, cosineDirection(hash13(p), rd), fgDensSmoothstep);\n        rd=normalize(rd);\n        \n        obj.d = min(obj.d, 0.1);\n        obj.d *= max(1. - fgDensSmoothstep,0.1); // to do take other d into account\n        \n    \tfog += fgDens;\n        \n        prevP = p;\n        \n        if (obj.d < 0.001) {\n            obj.d = t;\n            obj.didHit=true;\n        \treturn obj;\n        }\n        \n        if (t>50.) {\n            obj.d = t;\n            obj.didHit=false;\n        \treturn obj;\n        }\n        \n        t += obj.d;\n        p += rd*obj.d;\n    }\n\n\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 t = vec2(0.0005,0.);    \n    return normalize(vec3(\n    \tmap(p + t.xyy).d - map(p - t.xyy).d,\n    \tmap(p + t.yxy).d - map(p - t.yxy).d,\n    \tmap(p + t.yyx).d - map(p - t.yyx).d\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uvs = (fragCoord/iResolution.xy);\n    float aspect = iResolution.x/iResolution.y;\n\n    vec4 col = texture(iChannel0, uvs);\n \n    seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n    \n    vec3 accum = vec3(0);\n    \n    vec3 ro = 2.5*vec3(0.69,1.1,-0.7);\n    \n    vec3 lookAt = vec3(0,0.39,0.);\n    \n    uv = -1.0 + 2.0 * (uvs + (-1.0+2.0*hash2(3531.412))/iResolution.xy/1.5);\n    \n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    bool hitBg = false;\n    int i = 0;\n\n    vec2 rand = hash2(0.0);\n    \n    vec2 circle = vec2(cos(rand.x*tau),sin(rand.x*tau));\n    \n    float dPent = sdPentagon( circle, 1. );\n    circle -= normalize(circle)*dPent;\n    \n    float focusDistance = length(vec3(0)-ro);\n    float fov = 1.6;\n    float dof = 0.006*0.1;\n    \n    vec3 dd = dir*fov + (uv.x*right + uv.y*up);\n    vec3 focalPoint = ro + (dd)*focusDistance;\n    \n    ro += (circle.x*right+circle.y*up)*dof;\n    \n    vec3 rd = normalize(focalPoint-ro);\n    \n    \n    bool hitCrystalEarly = false;\n    \n    prevP = ro;\n    \n    for (; i < BOUNCES; i++){\n        \n        \tif (i > 7)\n                break;\n    \t\t\n        \tObject obj = trace(ro, rd);\n        \t\n        \taccum += fog*attenuation*fogCol;\n        \t\n        \n        \tif (!obj.didHit)\n                break;\n            \n            vec3 p = ro + rd * obj.d;  \t\t\t\t\n    \t\tvec3 N = getNormal(p)*side;\n            \n            float rgh = 0.4;\n        \n        \tMaterial material = materials[int(obj.material)];\n        \t\n        \n        \tif( (hitCrystalEarly &&  obj.material>=4.) || (obj.material>=4. && i < 2) ){\n            \thitCrystalEarly = true;\n                BOUNCES+=1; \n                \n                vec3 emission = material.albedo * material.emissiveness;\n\n                float dotnrd = max(dot(N,-rd),0.00);\n                float fres = pow(1.- dotnrd,5.);\n                \n                vec3 XtalCol = vec3(0.8,0.8,0.8)*1.1;\n                \n\t\t\t\tvec3 iridescenceCol = 0.5 + sin(vec3(0.2,0.8,1.8) + (dotnrd + length(sin(p*5.))*0.4)*25.)/2.;\n                \n                iridescenceCol = 0.5 * iridescenceCol * attenuation*fres;\n                \n                accum += iridescenceCol;\n                \n                attenuation *= 1.*XtalCol+iridescenceCol; // wtf this is over 1 attenuation oook\n                \n                if(obj.material == 4.){\n                    side *= -1.;\n                \trd = refract(rd,N,0.7);\n                }\n                else {\n                \trd = reflect(rd,N);\n                }\n                \n                \n                ro = p;\n                ro -= N*0.1;\n                \n            } else {\n                \n                vec3 emission = material.albedo * material.emissiveness + giAmt * fogCol;\n\n                accum += emission * attenuation;\n\n                attenuation *= material.albedo/PI;\n                ro = p;\n                rd = mix(cosineDirection(seed, N),N,material.metalness);\n            \n            }\n        \n\n            \n\n        \n    }\n    col.xyz += accum;\n    \n    if(iFrame==0) col.w = 0.;\n    \n    col.w ++;\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RAND 1\n\n    \n#define S 0.5\n\n#define PI pi\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n#if RAND == 1\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\n#elif RAND == 2\n// by Dave Hoskins\nfloat r31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash32(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n\nstruct Material {\n    vec3 albedo;\n    float emissiveness;\n\tfloat metalness; \n\tfloat roughness;\n};\n\n\nstruct Object {\n\tfloat d;\n    bool didHit;\n\tfloat material;\n};\nObject omin(Object a, float bdistance, float bmaterial) {\n    if (a.d < bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\nObject omin(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, float bdistance, float bmaterial) {\n    if (a.d > bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\n\n\n#define NewObject Object(1e8,false,0.)\n\n\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x, max(p.y,p.z));\n}\n\n// by fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[421, 421, 444, 444, 602], [616, 616, 671, 671, 1137]], "test": "untested"}
{"id": "3sBBzG", "name": "Hypnosis Trippy", "author": "workingclasshacker", "description": "Just messing around with trig functions. kinda neat :)", "tags": ["trig"], "likes": 1, "viewed": 394, "published": 3, "date": "1590234970", "time_retrieved": "2024-07-30T21:05:32.517690", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.y);\n\tuv *= sin(iTime/5.);\n    // Time varying pixel color\n    float p = 2.;\n    vec3 x = iTime/15.+vec3(sin(iTime)*.002+length((uv)/20.));\n    \n    vec3 f = cos(pow(x,vec3(p)))+sin(x*2000.)-cos(x*5215.);\n    vec3 f2 = cos(pow(x,vec3(p)))+sin(x*200.)-cos(x*5225.);\n    vec3 col = 0.5 + 0.5 * f*.2;\n    vec3 col2 = 0.5 + 0.5 * f2*.5;\n\tcol = mod(col, 2.);\n    col2 = mod(col2, 2.);\n    // Output to screen\n    fragColor = vec4(col.r-col2.r*.31, col.g*.4-col2.g, col2.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 638]], "test": "untested"}
{"id": "3sSBzG", "name": "Infinity cubes scene", "author": "kotfind", "description": "Scene with infinity figures.", "tags": ["3d"], "likes": 1, "viewed": 358, "published": 3, "date": "1590233510", "time_retrieved": "2024-07-30T21:05:33.278656", "image_code": "#define M_PI 3.1415926\n\n// SETTINGS\nconst float zFar = 200.;\nconst float zNear = 1.;\n\nconst vec3 background_color = vec3(0.2);\nconst float collision_distance = 0.00001;\nconst int marching_iterations = 100;\n\nconst float normal_partial_derivative_epsilon = 0.00001;\n\n// COLORS\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0., 0., 1.);\n\nfloat sq(in float n) {\n    return n * n;\n}\n\n// Transformations\nmat4 worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n\nvoid identity() {\n    worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n}\n\nvoid scale(in float a, in float b, in float c) {\n    worldMatrix *= mat4(a , 0., 0., 0.,\n                        0., b , 0., 0.,\n                        0., 0., c , 0.,\n                        0., 0., 0., 1.);\n}\n\nvoid trans(in vec3 v) {\n    worldMatrix *= mat4(1., 0., 0., v.x,\n                        0., 1., 0., v.y,\n                        0., 0., 1., v.z,\n                        0., 0., 0., 1.);\n}\n\nvoid rotx(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    worldMatrix *= mat4(1.,   0.,    0., 0.,\n                        0., cosa, -sina, 0.,\n                        0., sina,  cosa, 0.,\n                        0.,   0.,    0., 1.);\n}\n\nvoid roty(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    worldMatrix *= mat4( cosa, 0., sina, 0.,\n                           0., 1.,   0., 0.,\n                        -sina, 0., cosa, 0.,\n                           0., 0.,   0., 1.);\n}\n\nvoid rotz(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    worldMatrix *= mat4(cosa, -sina, 0., 0.,\n                        sina,  cosa, 0., 0.,\n                          0., 0., 1., 0.,\n                          0., 0., 0., 1.);\n}\n\n// All object functions (like sphere), scene function and functions inter,\n// union and diff returns vec4, where .rgb is color and .a is distance.\n\nvec4 inter(in vec4 a, in vec4 b) {\n    if (a.a > b.a) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nvec4 union_(in vec4 a, in vec4 b) {\n    if (a.a < b.a) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nvec4 diff(in vec4 a, in vec4 b) {\n    if (a.a > -b.a) {\n        return a;\n    } else {\n        return vec4(b.rgb, -b.a);\n    }\n}\n\nvec4 sphere(in vec3 pos, in vec3 color, in vec3 center, in float radius) {\n    return vec4(color, distance(pos, center) - radius);\n}\n\nvec4 plane(in vec3 pos, in vec3 color, in float height) {\n    return vec4(color, height - pos.y);\n}\n\nvec4 cube(in vec3 pos, in vec3 color, in vec3 coords, in vec3 size) {\n    return vec4(color, sqrt(sq(max(0., abs(pos.x - coords.x) - size.x)) +\n                            sq(max(0., abs(pos.y - coords.y) - size.y)) +\n                            sq(max(0., abs(pos.z - coords.z) - size.z))));\n}\n\nvec4 xcylinder(in vec3 pos, in vec3 color, in vec3 coords, in float radius) {\n    return vec4(color, distance(pos.yz, coords.yz) - radius);\n}\n\nvec4 ycylinder(in vec3 pos, in vec3 color, in vec3 coords, in float radius) {\n    return vec4(color, distance(pos.xz, coords.xz) - radius);\n}\n\nvec4 zcylinder(in vec3 pos, in vec3 color, in vec3 coords, in float radius) {\n    return vec4(color, distance(pos.xy, coords.xy) - radius);\n}\n\nvec4 scene(vec3 pos) {\n    pos = (vec4(pos, 1.) * worldMatrix).xyz;\n    pos = mod(pos + 5., 10.) - 5.;\n    return diff(inter(cube(pos, red, vec3(0., 0., 0.), vec3(0.9)),\n                      sphere(pos, blue, vec3(0., 0., 0.), 1.25)),\n                union_(union_(xcylinder(pos, green, vec3(0., 0., 0.), 0.8 * abs(sin(iTime / 2.))),\n                              ycylinder(pos, green, vec3(0., 0., 0.), 0.8 * abs(sin(iTime / 2.)))),\n                       zcylinder(pos, green, vec3(0., 0., 0.), 0.8 * abs(sin(iTime / 2.)))));\n}\n\nvec3 getNormal(in vec3 pos) {\n    float x, y, z;\n    float E = normal_partial_derivative_epsilon;\n    x = scene(pos + vec3(E, 0., 0.)).a - scene(pos - vec3(E, 0., 0.)).a;\n    y = scene(pos + vec3(0., E, 0.)).a - scene(pos - vec3(0., E, 0.)).a;\n    z = scene(pos + vec3(0., 0., E)).a - scene(pos - vec3(0., 0., E)).a;\n    return normalize(vec3(x, y, z));\n}\n\nvec3 ray_marching(vec3 pos, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    float mindist;\n    vec3 color;\n    vec3 norm;\n\n    for (int i = 0; i < marching_iterations; ++i) {\n        vec4 tmp = scene(pos);\n        color = tmp.rgb;\n        mindist = tmp.a;\n        norm = getNormal(pos);\n\n        if (mindist < collision_distance) return color * max(0.4, dot(normalize(vec3(0.) - pos), norm));\n        if (len > zFar) return background_color;\n\n        len += mindist;\n        pos += dir * mindist;\n    }\n    return background_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    uv.y = 1. - uv.y;\n\n    identity();\n    trans(vec3(0., 0., abs(sin(iTime / 2. + M_PI / 2.)) * -5.));\n    rotx(iTime + 2.);\n    rotz(iTime + 2.);\n    roty(iTime + 2.);\n    vec3 color = ray_marching(vec3(0.), vec3(uv - vec2(0.5), zNear));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[387, 387, 409, 409, 429], [546, 546, 563, 563, 659], [661, 661, 709, 709, 872], [874, 874, 897, 897, 1063], [1065, 1065, 1088, 1088, 1321], [1323, 1323, 1346, 1346, 1579], [1581, 1581, 1604, 1604, 1831], [1981, 1981, 2015, 2015, 2093], [2095, 2095, 2130, 2130, 2208], [2210, 2210, 2243, 2243, 2338], [2340, 2340, 2414, 2414, 2472], [2474, 2474, 2531, 2531, 2573], [2575, 2575, 2644, 2644, 2869], [2871, 2871, 2948, 2948, 3012], [3014, 3014, 3091, 3091, 3155], [3157, 3157, 3234, 3234, 3298], [3300, 3300, 3322, 3322, 3830], [3832, 3832, 3861, 3861, 4187], [4189, 4189, 4228, 4228, 4736], [4738, 4738, 4795, 4795, 5221]], "test": "untested"}
{"id": "3tsGR7", "name": "Old proto 16-seg digital clock", "author": "Yambam", "description": "Prototype for a 16-segment digital clock. Newer version here: https://www.shadertoy.com/view/tlX3DB", "tags": ["clock", "display", "digital", "segment", "prototype", "visual", "16", "seg", "sixteen"], "likes": 5, "viewed": 404, "published": 3, "date": "1590232806", "time_retrieved": "2024-07-30T21:05:34.032640", "image_code": "const float TAU = 6.28318530718;\n\n//const int[] _S = int[] (      H+4,    H+5,\n//                            D+0,        D+2,\n//                          V+1,    V+3,    V+5,\n//                                                   \n//                              H+2,    H+3,\n//                                                   \n//                          V+0,    V+2,    V+4,\n//                            D+3,        D+1,\n//                              H+0,    H+1      );\n\nvec2 distIgSegmentIt( vec2 xy, float size, vec2 dimensions )\n{\n    \n//. Ambifix is a \"notation\" I (@Yambam) invented, my goal is to make learning and making use of maths more intuitive.\n//: Comments like this these are statements in a hypothetical shader language based on ambifix, with the values omitted.\n    \n    //if (xy.x<0.-1.) return vec2(1000.,-1.);\n    xy.x = clamp(xy.x,-1.,2.); //clamp((xy.x/size+1.)/(1./size+1.),0.,1.);\n    xy.y = clamp(xy.y,0.,1.); //clamp(xy.y,-size,1.+size);\n    \n    float s = dimensions.y*round(xy.x*dimensions.x)+floor(xy.y*dimensions.y);\n    //float s = round(xy.x*dimensions.x)+(dimensions.x+1.)*floor(xy.y*dimensions.y);\n    float px = round(xy.x*dimensions.x)/dimensions.x;\n    float py = floor(xy.y*dimensions.y)/dimensions.y;\n    //4.00*clamp(-.2+1.4*iMouse.x/iResolution.x,0.,1.)\n    vec2 offset =   vec2(xy.x,           xy.y-py)\n                  - vec2(clamp(px,0.,1.),clamp(xy.y-py,0.+size,1./dimensions.y-size));\n    float d = 2.*abs(offset.x)+1.*abs(offset.y);\n    //float d = 2.*length(offset);\n    \n    //Old code:\n    //float d =  4.00*(abs(xy.x   -clamp(px,0.,1.))\n    //          +1.00* abs(xy.y-py-clamp(xy.y-py,0.+size,1./dimensions.y-size)));\n//. //float d =           (-        (clamp  ) -) (abs)\n//: //          (+ (-  -) (- (-  -) (clamp  ) -) (abs) +)\n    \n    //aligned for comparison of GLSL ES infix code versus (hypothetical) ambifix code\n    //\n   ///                   xy.x                   px                   0.,1.\n   ///                   xy.y    py             xy.y    py           0.,.5-size\n   //a  float d =   (abs(               - clamp(            ,                   )        )\n   //a             + abs(      -        - clamp(      -     ,                   )        ));\n//.//a  float d =                      (-                     (clamp            ) -) (abs)\n//://a            (+          (-    -) (-            (-    -) (clamp            ) -) (abs) +)\n   ///                   xy.x                   px                   0.,1.\n   ///                   xy.y    py             xy.y    py           0.,.5-size\n    //\n\t//\n    \n    return vec2(d,s);\n}\n\nfloat colorRefreshRateArtifact( vec2 uv )\n{\n    return clamp(.8+.2*(.5+.5*sin(TAU*(5./2.*iTime+uv.y+1./16.*uv.x))*sin(TAU*(7./2.*iTime+uv.y+1./16.*uv.x))),0.,1.);\n}\n\nvec2 digIt( vec2 xy, int state, vec2 margin, float size, vec2 dimensions )\n{\n    vec2 segmented = vec2(size,-1.);\n    vec2 segmentedBest = segmented;\n    vec2 space = -margin;\n    vec2 xyf = space +(vec2(1,1)-2.*space)*xy;\n    vec2 xyfR = vec2(xyf.y,xyf.x);\n    float diag = sqrt(.5); //1.; //\n    float sFactor = (dimensions.x+1.)*dimensions.y;\n    \n    if (xyf.x<0.-.5*size\n    ||  xyf.y<0.-.5*size\n    ||  xyf.x>1.+.5*size\n    ||  xyf.y>1.+.5*size) return segmentedBest;\n    \n    \n    /*xysym = vec2(abs(xy.y-.5)+abs(xy.x-.5),abs(abs(xy.y-.5)-abs(xy.x-.5)));\n\t//xysym = vec2((xysym.x-xysym.y)/4.+.5,(xysym.x+xysym.y)/4.+.5);\n    segmented = distIgSegmentIt(vec2(xysym.x,xysym.y),size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented+float(abs(xyf.x)>abs(xyf.y));*/\n    \n    segmented = distIgSegmentIt(xyf,size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented;\n    segmented = distIgSegmentIt(xyfR,size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented+sFactor*vec2(0.,1.);\n    \n    vec2 xyrot = xy;\n    xyrot -= vec2(.5,.5);\n    xyrot *= vec2(sign(xy.x-.5)*sign(xy.y-.5),1.);\n    xyrot = .5*(vec2( xyrot.x,-xyrot.y)\n               +vec2(-xyrot.y,-xyrot.x));\n\txyrot += vec2(.5,.5);\n    \n    segmented = distIgSegmentIt(space+(vec2(1,1)-2.*space)*vec2(xyrot.x,xyrot.y),size,dimensions);\n    segmented = vec2(segmented.x/diag,segmented.y-(sFactor-dimensions.y)/2.);\n    if (segmented.y>=0.\n    &&  segmented.y<dimensions.y\n    &&  segmented.x<=segmentedBest.x)\n        segmentedBest = vec2(segmented.x,sFactor*2.+segmented.y+(sFactor-2.*dimensions.x)*max(0.,sign(xy.x-.5)*sign(xy.y-.5)));\n    \n    return segmentedBest; // /vec2(1.,4.*sFactor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /*\n     * Display customization\n     */\n    \n    vec2 margin = vec2(.15,.15);\n    float size = .15;\n    float digitCount = 3.;\n    float skew = .1; //.1*sin(TAU/6.*iTime);\n    vec2 dimensions = vec2(2.,2.);\n    \n    //// A variety of display colors you can choose from\n    \n    vec3 colTheme = vec3(1.,.15,0.); //<-- Red\n    //vec3 colTheme = vec3(0.,1.,0.);  //<-- Green\n    //vec3 colTheme = vec3(1.,.8,0.);  //<-- Yellow\n    //vec3 colTheme = vec3(.8,1.,0.);  //<-- Neon yellowish green\n    //vec3 colTheme = vec3(1.,.6,0.);  //<-- Orange\n    vec3 colBg = vec3(0,0,0);\n    \n    float a = -atan(skew); //asin(skew);\n    mat2 m = mat2(cos(a),-sin(a),\n                  sin(a), cos(a));\n    float skewNew = cos(a)-sin(a);\n    \n    vec2 ch = fragCoord/iResolution.x;\n    //vec2 ch = (fragCoord+vec2(0.,iResolution.y/2.))/iResolution.x;\n    ch *= (digitCount-1.+skewNew); //digitCount; //\n    ch = m * ch;\n    \n    ch *= distance(vec2(0.,0.),vec2(1.,skew));\n    vec3 col;\n    ch.y -= skew*ch.x;\n    \n    /* \n     * Color gradient\n     */\n    //vec3 colTheme = (1.-ch.y)*vec3(1,.4,.4)+ch.y*vec3(.4,.4,1);\n    //vec3 colBg = vec3(1,1,1);\n    \n    float aa = iResolution.x/200.; //30.*iMouse.x/iResolution.x;\n    int i = int(floor(ch.x));\n    float crra = colorRefreshRateArtifact(uv);\n    float t;\n    \n    if (ch.x<0.\n    ||  ch.x>digitCount) col = colBg;\n    else\n    {\n        ch.x -= floor(ch.x);\n        vec2 doughdge = digIt(ch,0,margin,size,dimensions);\n        if (doughdge.y>=0.)\n        {\n            //if (((digits[0])&(1<<int(doughdge.y)))>0) //0-65536\n            //if (((1<<int(16./iResolution.x*iMouse.x))&(1<<int(doughdge.y)))>0) //0-65536\n            if ((int(iDate.w)&(1<<int(doughdge.y)))>0) //0-65536\n            //if ((int(iDate.w)&(1<<int(doughdge.y)))>0) //0-65536\n            //if (((int(iDate.w)>>(16*i))&(1<<int(doughdge.y)))>0) //0-65536\n        \t\tt = (.5+.5/15.*doughdge.y)*crra;\n            else\n        \t\tt = .15*crra;\n            t *= smoothstep(0.,1.,clamp(1.-10.*doughdge.x,0.,1./aa)*aa);\n            //t *= smoothstep(0.,1.,1.-8.*doughdge.x);\n            //t *= (1.-pow(2.,-2.+30.*doughdge.x));\n            t = clamp(t,0.,1.);\n        }\n        else\n            t = 0.;\n\n        col = (1.-t)*colBg+t*colTheme;\n    }\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[477, 477, 539, 834, 2605], [2607, 2607, 2650, 2650, 2771], [2773, 2773, 2849, 2849, 4527]], "test": "untested"}
{"id": "wd2BDm", "name": "golf Hatched Complex Spaces (396", "author": "FabriceNeyret2", "description": "golfing 952 chars [url]https://shadertoy.com/view/Ws2BW1[/url]\nreproducing Erlend Robaye's  [url]https://www.facebook.com/groups/procgenart/permalink/1991283661002453/[/url]\n", "tags": ["fractal", "complex", "short", "golf", "3tweets"], "likes": 8, "viewed": 417, "published": 3, "date": "1590221603", "time_retrieved": "2024-07-30T21:05:34.788618", "image_code": "// golfing 952 chars https://shadertoy.com/view/Ws2BW1\n// reproducing Erlend Robaye's https://www.facebook.com/groups/procgenart/permalink/1991283661002453/\n// Complex op from https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\n#define V vec2//\n#define D(Z)     mat2( Z, Z.y, -Z ) * a / dot(a,a)        //\n#define E(Z)     exp(Z).x * cos( (Z).y + V(0,11) )        //\n#define I        V( -z.y, z )                             //\nvoid mainImage(out vec4 O, vec2 u) {\n    V R  = iResolution.xy, z,a,\n    Z = 1.8 * ( u - (R-R.y)/2. ) / R.y + V(-.2,2.2);\n    if ( abs(Z.x-.7) < 1.  )\n        for( int i, k=0 ; k++ < 81;\n             abs(z.x) < .1 ? O += .012 : O\n           )\n          { z = Z +  V(k%9-2,k/9-2) *.2 / R.y;\n            for ( i=0; i++ < 4;) z = D( E(a=z) );\n            a = z; a.x--;\n            z = E(I) - E(-I);\n            for ( z = D( -.5* I ) ; i++ < 9;\n                  z = E( z + 6.*I ) )\n                z = V( log(length(z)), atan(z.y,z.x) );\n          }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2BDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[468, 468, 504, 504, 1016]], "test": "untested"}
{"id": "td2BWm", "name": "Menger squares - sorry bout that", "author": "alvarobyrne", "description": "Eazy peazy. spam", "tags": ["fractal", "menger", "sponge"], "likes": 2, "viewed": 329, "published": 3, "date": "1590202696", "time_retrieved": "2024-07-30T21:05:35.531632", "image_code": "// Fork of \"Menger squares\" by kindpotato. https://shadertoy.com/view/ttsGW8\n// 2020-05-23 02:56:09\n\n#define third 0.3333\n\nbool coloured(vec2 uv){\n    \n    return uv.x < third || uv.x > 2.*third || uv.y < third || uv.y > 2.*third;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float zoom = mod(-30.*iTime,109.);\n    uv*= pow(0.99,zoom);\n    fragColor = vec4(1);\n    float its = log(iResolution.y)/log(3.+0.5*sin(iTime));\n\n    for(float i = 0.; i < its; i+=1.){\n        if (coloured(uv)){\n            uv = fract((3.+0.1*tan(iTime/181.))*uv);\n        }\n        else{\n        \tfragColor = vec4(0,0,0,1);\n            return;\n        }\n    } \n\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2BWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 146, 146, 232], [233, 233, 290, 290, 704]], "test": "untested"}
{"id": "tdjBWm", "name": "Menger2D - broken", "author": "alvarobyrne", "description": "...", "tags": ["2d", "fractal", "menger", "mengerspone"], "likes": 4, "viewed": 379, "published": 3, "date": "1590201575", "time_retrieved": "2024-07-30T21:05:36.279632", "image_code": "// Fork of \"Menger2D\" by EvilRyu. https://shadertoy.com/view/MldXz4\n// 2020-05-23 02:26:38\n\n// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat s=0.95,a=0.006,scale=3.;\nfloat d_box(vec2 q){float d=max(abs(q.x+sin(iTime)*0.01),abs(q.y));return smoothstep(s,s+a,d)+smoothstep(s-a,s-a-a,d);}\nfloat d_sph(vec2 q,float s){float d=pow(pow(abs(q.x),3.0)+pow(abs(q.y),3.5),1./3.);return smoothstep(s,s+a,d)+smoothstep(s-a,s-a-a,d);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 col=vec3(1.0);//*d_box(q);\n    float iter = mod(floor(iTime),7.0);\n    for(int i=0;i<4;++i)\n    {\n        if(i<int(iter+0.5))\n        {\n            q=abs(q);\n            if(q.x>q.y)q.xy=q.yx;\n            s*=1.0/scale;\n            col*=d_sph(q,s*(1.+tan(iTime)));\n            q-=s*(scale-(1.+cos(iTime)));\n            if(q.x<-0.5*s*(scale-1.0))q.x+=s*(scale-(1.+sin(iTime)));\n        }\n        else\n        {\n            col*=d_sph(q,fract(iTime)*s/scale);\n        }\n    }\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBWm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[233, 233, 253, 253, 352], [353, 353, 381, 381, 488], [489, 489, 546, 546, 1114]], "test": "untested"}
{"id": "3djczd", "name": "audioFractal", "author": "okh0056", "description": "audio visualization", "tags": ["audioviz"], "likes": 12, "viewed": 918, "published": 3, "date": "1590196441", "time_retrieved": "2024-07-30T21:05:37.031621", "image_code": "const int iters = 150;\n\nint fractal(vec2 p, vec2 point) {\n\tvec2 so = (-1.0 + 2.0 * point) * 0.4;\n\tvec2 seed = vec2(0.098386255 + so.x, 0.4387662 + so.y);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t\n\t\tif (length(p) > 2.0) {\n\t\t\treturn i;\n\t\t}\n\t\tvec2 r = p;\n\t\tp = vec2(p.x * p.x - p.y * p.y, 2.0* p.x * p.y);\n\t\tp = vec2(p.x * r.x - p.y * r.y + seed.x, r.x * p.y + p.x * r.y + seed.y);\n\t}\n\t\n\treturn 0;\t\n}\n\nvec3 color(int i) {\n\tfloat f = float(i)/float(iters) * 2.0;\n\tf=f*f*2.;\n\treturn vec3((sin(f*2.0)), (sin(f*3.0)), abs(sin(f*7.0)));\n}\n\n\nfloat sampleMusicA() {\n\treturn 0.5 * (\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x + \n\t\ttexture( iChannel1, vec2( 0.30, 0.25 ) ).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec2 position = 3. * (-0.5 + fragCoord.xy / iResolution.xy );\n\tposition.x *= iResolution.x/iResolution.y;\n    \n    vec2 iFC = vec2(iResolution.x-fragCoord.x,iResolution.y-fragCoord.y);    \n    vec2 pos2 = 2. * (-0.5 + iFC.xy / iResolution.xy);\n    pos2.x*=iResolution.x/iResolution.y;\n    \n    vec4 t3 = texture(iChannel0, vec2(length(position)/2.0,0.1) );\n    float pulse = sampleMusicA()*1.8;\n\n    vec3 invFract = color(fractal(pos2,vec2(0.55+sin(iTime/3.+0.5)/2.0,pulse*.9)));\n    \n    vec3 fract4 = color(fractal(position/1.6,vec2(0.6+cos(iTime/2.+0.5)/2.0,pulse*.8)));\n\n    vec3 c = color(fractal(position,vec2(0.5+sin(iTime/3.)/2.0,pulse)));\n    \n    t3=abs(vec4(0.1,0.3,0.5,1.)-t3)*2.5;\n    \n    vec4 fract01 =  vec4( c , 1.0 );\n    \n    vec4 col = fract01 / t3 + fract01 * t3 + vec4(invFract,0.6) + vec4(fract4,0.3);\n\tfragColor = col;\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 57, 57, 395], [397, 397, 416, 416, 528], [531, 531, 553, 553, 666], [668, 668, 725, 725, 1626]], "test": "untested"}
{"id": "wdjBWD", "name": "WorleyNoise2D", "author": "im_sky", "description": "Worley noise", "tags": ["noise"], "likes": 1, "viewed": 317, "published": 3, "date": "1590169338", "time_retrieved": "2024-07-30T21:05:37.953158", "image_code": "#define PI 3.14159265359\n\n#define Interpolation 1\n#define CosineCurve 0\n#define PerlinSmoothCurve 1\n\nvec2 dirs[8] = vec2[]\n(\n    vec2(1, 0),                                                                                                                                                                                                                                       \n    vec2(0, 1),                                                                                                                                                                                                                                       \n    vec2(1, 0),                                                                                                                                                                                                                                      \n    vec2(0, 1),                                                                                                                                                                                                                                      \n    vec2(0.70711, 0.70711),                                                                                                                                                                                                                           \n    vec2(0.70711, 0.70711),                                                                                                                                                                                                                          \n    vec2(0.70711, 0.70711),                                                                                                                                                                                                                         \n    vec2(0.70711, 0.70711)\n);\n\nconst int tableSize = 512;\nconst int permutationMask = 512/2 - 1;\nconst int permutationTable[512] = int[]\n(                                                                                                                                                                                                                                          \n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170,\n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170\n);\n\nint Hash(vec2 x)\n{\n    return permutationTable[permutationTable[int(x.x) & permutationMask] + int(x.y) & permutationMask];\n}\n\nfloat SmoothCurve(float t)\n{\n#if CosineCurve\n    return (1.0 - cos(t * PI)) * 0.5;\n#elif PerlinSmoothCurve\n    return t * t * (3.0 - 2.0 * t);\n#else\n    return t;\n#endif\n}\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec2 GetGradient(vec2 x)\n{\n    return dirs[Hash(x) & 7];\n}\n\n//https://thebookofshaders.com/12/\nvec2 Random2D( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 Rotate2D(vec2 v, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    mat2 rotMat = mat2(c,s,-s,c);\n    return rotMat * v;\n}\n\n\nfloat GetWorleyNoise(vec2 uv)\n{\n    float noise = 0.0;\n    \n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    \n    float minDist = 99.0;\n    for(int x = -1; x <=1; ++x)\n    {\n        for(int y = -1; y <=1; ++y)\n        {\n            vec2 point = p + vec2(x, y);\n            \n            vec2 g;\n            vec2 v;\n\n            v = Random2D(point);\n            //v = (v + 1.0) * 0.5;\n            \n            //v = Rotate2D(v * 0.25, GetIntegerNoise(v) * iTime * 10.0 * PI);\n            //v = vec2(cos(v.x * iTime *PI), sin(v.x * iTime * PI)) * 0.25;\n\n\n            float d = distance(point + v, uv);\n            minDist = min(minDist, d);\n        }\n    }\n\n    return 1.0-minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n    //uv *= 0.5*(sin(iTime * 2.0) + 5.0) * 2.40;\n\n\tfloat noise = GetWorleyNoise(uv);\n    //noise *= GetWorleyNoise(uv * 9.0) * 1.2;\n\t//isolines\n    //noise = step(0.5, abs(sin(40.0 * noise)));\n\n\tnoise = pow(noise, 1.6);\n    vec3 color = noise * vec3(0.6, 0.15, 0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14633, 14633, 14651, 14651, 14757], [14759, 14759, 14787, 14787, 14930], [14932, 14932, 15024, 15024, 15123], [15125, 15125, 15151, 15151, 15183], [15185, 15220, 15245, 15245, 15338], [15340, 15340, 15376, 15376, 15492], [15495, 15495, 15526, 15526, 16178], [16180, 16180, 16237, 16237, 16627]], "test": "untested"}
{"id": "WsjBW1", "name": "Gradient Noise 3D", "author": "im_sky", "description": "Gradient Noise 3d first implementation.", "tags": ["noise3d"], "likes": 4, "viewed": 454, "published": 3, "date": "1590169322", "time_retrieved": "2024-07-30T21:05:38.887659", "image_code": "#define PI 3.14159265359\n\n#define CosineCurve 0\n#define PerlinSmoothCurve 1\n\nconst vec3 dirs[] = vec3[26]\n(\n    vec3(0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                 \n    vec3(0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                  \n    vec3(0.70711, 0.70711, 0),                                                                                                                                                                                                                        \n    vec3(0.70711, 0, -0.70711),                                                                                                                                                                                                                       \n    vec3(0.70711, 0, 0.70711),                                                                                                                                                                                                                        \n    vec3(1, 0, 0),                                                                                                                                                                                                                                    \n    vec3(0.57735, -0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(0.70711, -0.70711, 0),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, -0.70711),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, 0.70711),                                                                                                                                                                                                                        \n    vec3(0, 1, 0),                                                                                                                                                                                                                                    \n    vec3(0, 0, -1),                                                                                                                                                                                                                                   \n    vec3(0, 0, 1),                                                                                                                                                                                                                                    \n    //vec3(0,0,0),                                                                                                                                                                                                                           \n    vec3(0, -0.70711, -0.70711),                                                                                                                                                                                                                      \n    vec3(0, -0.70711, 0.70711),                                                                                                                                                                                                                       \n    vec3(0, -1, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(-0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(-0.70711, 0.70711, 0),                                                                                                                                                                                                                       \n    vec3(-0.70711, 0, -0.70711),                                                                                                                                                                                                                      \n    vec3(-0.70711, 0, 0.70711),                                                                                                                                                                                                                       \n    vec3(-1, 0, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, -0.57735, -0.57735),                                                                                                                                                                                                               \n    vec3(-0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                \n    vec3(-0.70711, -0.70711, 0)         \n);\n\nconst int tableSize = 512;\nconst int permutationMask = 512/2 - 1;\nconst int permutationTable[512] = int[]\n(                                                                                                                                                                                                                                          \n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170,\n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170\n);\n\nint Hash(vec3 x)\n{\n    // using ampersand to calculate modulus because-\n    // mod() for negative integers gives \"wrong\" results, for instance mod(-3, 4) = 1 and not 3\n    // the ampersand trick works only if the divisor is a power of two minus 1\n    // less operatons compared to x - y * floor(x/y)\n    return permutationTable[permutationTable[permutationTable[int(x.x) & permutationMask] + int(x.z) & permutationMask] + int(x.y) & permutationMask];\n}\n\nfloat SmoothCurve(float t)\n{\n#if CosineCurve\n    return (1.0 - cos(t * PI)) * 0.5;\n#elif PerlinSmoothCurve\n    return t * t * (3.0 - 2.0 * t);\n#else\n    return t;\n#endif\n}\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec3 GetGradient(vec3 x)\n{\n    // using % instead of & operator, below, because the divisor is not a power of two minus 1, and the divisor will never be negative here.\n    int i = Hash(x) % 26;\n    return dirs[i];\n}\n\nfloat Get3DNoise(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec3 p1 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p2 = p + vec3(1.0, 0.0, 0.0);\n    vec3 p3 = p + vec3(0.0, 1.0, 0.0);\n    vec3 p4 = p + vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p + vec3(0.0, 0.0, 1.0);\n    vec3 p6 = p + vec3(1.0, 0.0, 1.0);\n    vec3 p7 = p + vec3(0.0, 1.0, 1.0);\n    vec3 p8 = p + vec3(1.0, 1.0, 1.0);\n    \n    vec3 g1 = GetGradient(p1);\n    vec3 g2 = GetGradient(p2);\n    vec3 g3 = GetGradient(p3);\n    vec3 g4 = GetGradient(p4);\n    vec3 g5 = GetGradient(p5);\n    vec3 g6 = GetGradient(p6);\n    vec3 g7 = GetGradient(p7);\n    vec3 g8 = GetGradient(p8);\n    \n    float dot1 = dot(g1, uvw - p1);\n    float dot2 = dot(g2, uvw - p2);\n    float dot3 = dot(g3, uvw - p3);\n    float dot4 = dot(g4, uvw - p4);\n    float dot5 = dot(g5, uvw - p5);\n    float dot6 = dot(g6, uvw - p6);\n    float dot7 = dot(g7, uvw - p7);\n    float dot8 = dot(g8, uvw - p8);\n    \n    float wX = SmoothCurve(f.x);\n    float noiseY1 = mix(dot1, dot2, wX);\n    float noiseY2 = mix(dot3, dot4, wX);\n    float noiseY3 = mix(dot5, dot6, wX);\n    float noiseY4 = mix(dot7, dot8, wX);\n    \n    float wY = SmoothCurve(f.y);\n    float noiseZ1 = mix(noiseY1, noiseY2, wY);\n    float noiseZ2 = mix(noiseY3, noiseY4, wY);\n    \n    float wZ = SmoothCurve(f.z);\n    noise = mix(noiseZ1, noiseZ2, wZ);\n    \n    return noise;\n}\n\n//https://iquilezles.org/articles/fbm\n// H: Hurst Exponent, affects the integration of noise partially\nfloat fBM(vec3 x, float H, int numOctaves)\n{\n    float total = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        float frequency = pow(2.0, float(i));\n        float amplitude = pow(frequency, -H);\n        total += amplitude * Get3DNoise(x * frequency);\n    }\n\t\n    return total;\n}\n\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1/simple-pattern-examples\n// output range -1.0 to 1.0\nfloat fBM(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * Get3DNoise(x * frequency);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total;\n}\n\nfloat Turbulence(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * abs(Get3DNoise(x * frequency));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n\t\n    return total;\n}\n\nfloat HighPassFilter(float x, float threshold)\n{\n    x = max(x, threshold);\n    x -= threshold;\n    x /= (1.0 - threshold);\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n    vec3 uvw = vec3(uv, iTime * 0.1);\n\n    \n\t//float noise = fBM(uvw, 2.0, 0.4, 4);\n    //noise = 0.5 * noise + 0.5;\n    \n    float noise = 0.0;\n    {\n        float windowWidth = iResolution.x / 4.0; \n\n        if(fragCoord.x < windowWidth)\t\n        {\n            // pink noise\n            noise = fBM(uvw, 3.0, 1.0/3.0, 7);\n            noise = 0.5 * noise + 0.5;  \n        }\n        else if(fragCoord.x < 2.0 * windowWidth)\t\n        {\n            // brown noise\n            noise = fBM(uvw, 2.0, 0.5, 7);\n            noise = 0.5 * noise + 0.5;  \n        }\n        else if(fragCoord.x < 3.0 * windowWidth)\t\n        {\n            // turbulence\n            noise = Turbulence(uvw, 2.0, 0.5, 7);\n        }\n        else\n        {\n            uvw *= 2.0;\n            uvw.y *= 0.4; \n            // wood grain\n            noise = fBM(uvw, 0.02, 0.35, 2) * 10.0;\n            //noise = (sin((5.0 * noise * 100.0) * 2.0 * PI / 200.0) + 1.0) / 2.0;\n            noise = noise - floor(noise);\n        }\n    }\n    \n    noise = pow(noise, 2.2);\n    fragColor = vec4(noise, noise, noise, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19319, 19319, 19337, 19618, 19771], [19773, 19773, 19801, 19801, 19944], [19946, 19946, 20038, 20038, 20137], [20139, 20139, 20165, 20306, 20354], [20356, 20356, 20384, 20384, 21761], [21763, 21866, 21910, 21910, 22155], [22157, 22320, 22385, 22385, 22655], [22657, 22657, 22729, 22729, 23001], [23003, 23003, 23051, 23051, 23142], [23144, 23144, 23201, 23201, 24361]], "test": "untested"}
{"id": "3d2fDw", "name": "Planet Shader", "author": "mrange", "description": "License CC0: Planet Shader\nI have been experimenting with space themed shaders", "tags": ["raytracing", "space"], "likes": 21, "viewed": 797, "published": 3, "date": "1590167107", "time_retrieved": "2024-07-30T21:05:39.699488", "image_code": "// License CC0: Planet Shader\n//  I have been experimenting with space themed shaders\n#define PI           3.141592654\n#define TAU          (2.0*PI)\n\n#define TIME         (iTime)\n#define RESOLUTION   iResolution\n#define PERIOD       30.0\n#define PERIODS      4.0\n#define FADETIME     2.0\n#define TPERIOD      (mod(TIME, PERIOD))\n#define NPERIOD      (int(mod(TIME/PERIOD, PERIODS)))\n\nconst vec3  sunDirection = normalize(vec3(0.0, 0.1, -10.0));\nconst vec3  sunColor1    = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2    = vec3(1.0, 0.8, 0.9);\nconst vec3  planetPos    = vec3(0.0);\nconst float planetRadii  = 10.0;\n\nvec3 tanh3(vec3 c) {\n  return vec3(tanh(c.x), tanh(c.y), tanh(c.z));\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 center, float radius) {\n  vec3 m = ro - center.xyz;\n  float b = dot(m, rd);\n  float c = dot(m, m) - radius*radius;\n  if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n  float discr = b * b - c;\n  if(discr < 0.0) return vec2(-1.0);\n  float normalMultiplier = 1.0;\n  float s = sqrt(discr);\n  float t0 = -b - s;\n  float t1 = -b + s;;\n  return vec2(t0, t1);\n}\n\nvec3 scaleCol(vec3 c, float s, float r) {\n  float o = sqrt(s/r);\n  float i = s/o;\n  return tanh3(c*i)*o;\n}\n\nvec3 skyColor(vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  vec3 col = vec3(0.0);\n  col += scaleCol(pow(diff, 4.0*200.0)*sunColor1, 8.0, 0.25);\n  col += scaleCol(pow(diff, 4.0*50.0)*sunColor2, 1.0, 0.25);\n  return col;\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat pcos(float a) {\n  return 0.5 + 0.5*cos(a);\n}\n\nfloat spow(float v, float p) {\n  return sign(v)*pow(abs(v), p);\n}\n\nvec4 rings(vec2 p) {\n  float pl = length(p);\n  float pdf = pl-22.0;\n  pdf = abs(pdf) - 3.0;\n  pdf = abs(pdf) - 2.0;\n  pdf = abs(pdf) - 1.0;\n  vec4 pcol = vec4(1.0);\n  pcol.xyz = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 1.0, 1.0), 0.5 - 0.5*cos(15.0*pl))*sunColor1;\n  pcol.xyz = pow(pcol.xyz, vec3(0.75));\n  pcol.w = psin(20.0*pl)*psin(14.0*pl)*psin(21.0*pl);\n  pcol.w *= 0.5*step(pdf, 0.0);\n  return pcol;\n}\n\nvec4 planet(vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec2 si = raySphere(ro, rd, planetPos, planetRadii);\n  vec3 sp = ro + rd*si.x;\n  vec3 sn = normalize(sp - planetPos);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 15.0);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  float sf = (si.y - si.x)/(2.0*planetRadii);\n  float sl = (1.0-smoothstep(0.2, 0.7, sf));\n  vec3 sbeer = exp(-6.0*vec3(0.3, 0.25, 0.15)*sf)*sl;\n  float srayl = pow(1.0 - abs(dot(rd, sn)), 5.0);\n\n  float slo = atan(sp.z, sp.x);\n  float slat = PI*sp.y/planetRadii;\n  vec3 scol = vec3(0.8);\n\n  scol = mix(scol, vec3(0.7, 0.7, 0.8), pow(pcos(20.0*slat), 5.0));\n  scol = mix(scol, vec3(0.75, 0.7, 0.8), pow(pcos(14.0*slat), 20.0));\n  scol = mix(scol, vec3(0.2), pow(pcos(21.0*slat)*pcos(13.0*slat+1.0), 15.0));  \n  scol = tanh3(scol);\n  scol *= pow(sunColor1, vec3(0.66));  \n  scol += vec3(0.0, 0.0, srayl*0.5) ;\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + pow(skyCol, vec3(0.85))*sbeer + scol*pow(sdiff, 0.75);\n    col.w = 1.0;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(rd);  \n  \n  vec4 col = vec4(skyCol, 1.0);\n  float cold = 10000.0;\n\n  vec4 pcol = planet(ro, rd, skyCol, cold);\n\n  col.xyz = mix(col.xyz, pcol.xyz, pcol.w);\n\n  float rsd = (0.0 - ro.y)/rd.y;\n  vec3 rsp = ro + rd*rsd;\n  vec4 rscol = rings(rsp.xz); \n  vec3 rsn = vec3(0.0, 1.0, 0.0);\n  \n  rscol.w = pow(rscol.w, 1.0*pow(abs(dot(rd, rsn)), 0.4));\n\n  vec2 psi = raySphere(rsp, sunDirection, planetPos, planetRadii);\n  rscol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi.y - psi.x)/(2.0*planetRadii)));\n  \n  col.xyz = mix(col.xyz, rscol.xyz, rscol.w*step(rsd, cold));\n  \n  return col.xyz;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 fragment(vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float tperiod = TPERIOD;\n  int period = NPERIOD;\n  vec3 ro = vec3(0.0, 0.0, 52.0);\n  vec3 la = vec3(0.0, 0.0,0.0);\n  vec3 up = vec3(-0.0, 1.0, 0.0);\n\n  if (period == 0) {\n    ro = vec3(0.0, 0.0, 52.0);\n    ro.y += tperiod*15.0/PERIOD+2.0;\n    la = vec3(0.0, 0.0, -1000000.0);\n  } else if (period == 1) {\n    ro = vec3(00.0, 15.0, -50.0);\n    ro.y -= 10.0*tperiod/PERIOD;\n    rot(ro.xz,-2.0*tperiod/PERIOD-TAU/10.0);\n  } else if (period == 2) {\n    ro = vec3(0.0, 5.0, 30.0);\n    la = vec3(0.0, 0.0, -1000000.0);\n    ro.x += -10.0*tperiod/PERIOD;\n    ro.y += 17.0*tperiod/PERIOD;\n    ro.z += 90.0*tperiod/PERIOD;\n    up = vec3(-1.0, 1.0, 0.0);\n  } else if (period == 3) {\n    ro = vec3(00.0, 0.0, -25.0);\n    rot(ro.yz, 1.0-0.25*tperiod/PERIOD);\n    la = vec3(0.0, 0.0, 0.0);\n    up = vec3(-0.25, 1.0, 0.0);\n  }\n  \n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = (cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/  \n  col += fragment(ro, uu, vv, ww, p+o1);\n  col += fragment(ro, uu, vv, ww, p-o1);\n  col += fragment(ro, uu, vv, ww, p+o2);\n  col += fragment(ro, uu, vv, ww, p-o2);\n  \n  col*=0.25;\n\n  col = postProcess(col, q);\n \n  float fadeIn = smoothstep(0.0, FADETIME, tperiod);\n  float fadeOut = 1.0 - smoothstep(PERIOD - FADETIME, PERIOD, tperiod);\n  col *= fadeIn;\n  col *= fadeOut;\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2fDw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[613, 613, 633, 633, 683], [685, 685, 718, 718, 803], [805, 805, 866, 866, 1196], [1198, 1198, 1239, 1239, 1304], [1306, 1306, 1330, 1330, 1541], [1543, 1543, 1564, 1564, 1593], [1595, 1595, 1616, 1616, 1645], [1647, 1647, 1677, 1677, 1712], [1714, 1714, 1734, 1734, 2116], [2118, 2118, 2178, 2178, 3244], [3246, 3246, 3277, 3277, 3882], [3885, 3885, 3922, 3922, 4130], [4132, 4132, 4191, 4191, 4285], [4287, 4287, 4342, 4342, 5966]], "test": "untested"}
{"id": "Wd2BDw", "name": "Mandelbuld", "author": "kotfind", "description": "Mandelbulb fractal.", "tags": ["3d", "fractal", "mandelbulb"], "likes": 4, "viewed": 383, "published": 3, "date": "1590165518", "time_retrieved": "2024-07-30T21:05:40.561184", "image_code": "#define ROTATION\n\n#define M_PI 3.1415926\n\n// setting begin\nconst float FOV   = M_PI / 2.;\nconst float zNear = 1.;\nconst float zFar  = 10.;\n\nconst float colissiondist = 0.01;\nconst int maxIter = 100;\n// setting end\n\nvec3 viewpoint = vec3(0., 0., 6.);\n\nfloat sq(in float n) {\n    return n * n;\n}\n\nfloat f(in vec3 p) {\n    float power = 8. + sin(iTime * 1.) * 5.;\n    vec3 z = p;\n    float dr = 1.;\n    float r = 0.;\n\n    for (int i = 0; i < 10; ++i) {\n        r = length(z);\n        if (r > 4.)\n            break;\n\n        float theta = acos(z.z / r) * power;\n        float phi   = atan(z.y / z.x) * power;\n        float zr    = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat map(in vec3 p) {\n    return f(p);\n}\n\nvoid mapColor(in vec3 p, out float mind, out vec3 color, out vec3 norm) {\n    mind = map(p);\n\n    color = vec3(max(0.1, min(0.9, 1. - (1. - sin(p.x * 100.)) *\n                                        (1. - sin(p.y * 100.)) *\n                                        (1. - sin(p.z * 100.)))));\n\n    // get normal\n    const float E = 0.0001;\n    norm = normalize(vec3(f(p + vec3(E, 0., 0.)), f(p + vec3(0., E, 0.)), f(p + vec3(0., 0., E))));\n}\n\nvec3 ray_marching(vec3 orig, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    //vec3 bg = vec3(min(0.937255, max(0.2, sin(dir.x * 5.) + sin(dir.y * 10.) + cos(dir.x * dir.y * 10.))));\n    vec3 bg = vec3(0.2);\n\n    for (int i = 0; i < maxIter; ++i) {\n        float d;\n        vec3 color;\n        vec3 norm;\n        mapColor(orig, d, color, norm);\n        if (d < colissiondist) return color;\n        if (len > zFar) return bg;\n\n        len += d;\n        orig += dir * d;\n    }\n    return bg;\n}\n\nmat3 rotatey(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    return mat3(cosa,  0., sina,\n                0.,    1.,   0.,\n                -sina, 0., cosa);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    uv.y = 1. - uv.y;\n\n    #ifdef ROTATION\n        float a = iTime * 0.2;\n    #else\n        float a = 0.;\n    #endif\n    viewpoint.x = sin(a) * 3.;\n    viewpoint.z = cos(a) * 3.;\n    vec3 color = ray_marching(viewpoint, rotatey(-a + M_PI) * vec3(uv - vec2(0.5, 0.5) , zNear));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2BDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 273, 273, 293], [295, 295, 315, 315, 832], [834, 834, 856, 856, 875], [877, 877, 950, 950, 1316], [1318, 1318, 1358, 1358, 1823], [1825, 1825, 1851, 1851, 2003], [2005, 2005, 2062, 2062, 2525]], "test": "untested"}
{"id": "wdBfDw", "name": "3D Metaballs && SDF && BRDF", "author": "EvgenyNeon", "description": "description", "tags": ["3d", "raymarching", "sdf", "metaball", "brdf"], "likes": 1, "viewed": 611, "published": 3, "date": "1590158704", "time_retrieved": "2024-07-30T21:05:41.421883", "image_code": "const float EPSILON = 0.0001;\nconst float PI = 3.1415;\n\nstruct light\n{\n \tvec3 brightness;\n    vec3 location;\n    vec3 direction;\n    bool isDirected;\n};\n\nconst int lightsCount = 1;\nlight lights[lightsCount];\n\nstruct materialBRDF\n{\n  \tvec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nfloat distributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = geometrySchlickGGX(NdotV, roughness);\n    float ggx1  = geometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n} \n\nvec3 fresnelSchlick(float cosTheta, vec3 f0)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);\n} \n\nstruct lightInfo\n{\n    vec3 kS;\n    vec3 kD;\n};\n\nlightInfo cookTorrensBRDF(vec3 rayInput, vec3 rayOutput, vec3 normal, materialBRDF material)\n{\n    lightInfo result;\n    \n    vec3 N = normalize(normal);\n    vec3 V = normalize(rayOutput);\n    vec3 L = normalize(rayInput);\n    vec3 H = normalize(V + L);\n    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, material.albedo, material.metallic);\n    \n    float NDF = distributionGGX(N, H, material.roughness);       \n\tfloat G   = geometrySmith(N, V, L, material.roughness);\n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); \n    \n    vec3 kD = vec3(1.0) - F;\n    kD *= 1.0 - material.metallic;\t  \n    result.kD = kD;\n        \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001); \n    result.kS = specular;\n    \n \treturn result;   \n}\n\nstruct sphere\n{\n \tvec3 location;\n    float radius;\n    materialBRDF material;\n};\n\nconst int spheresCount = 3;\nsphere spheres[spheresCount];\n\nvoid initScene()\n{\n    spheres[0].location = vec3(0.0, 0.0, 0.0);\n    spheres[0].radius = 1.1;\n    spheres[0].material.albedo = vec3(10.0, 0.0, 0.0);\n    spheres[0].material.roughness = 0.5;\n    spheres[0].material.metallic = 0.0;\n    \n    spheres[1].location = vec3(0.0, 0.0, 0.0);\n    spheres[1].radius = 1.0;\n    spheres[1].material.albedo = vec3(0.0, 10.0, 0.0);\n    spheres[1].material.roughness = 0.5;\n    spheres[1].material.metallic = 0.0;\n    \n    spheres[2].location = vec3(0.0, 0.0, 0.0);\n    spheres[2].radius = 1.05;\n    spheres[2].material.albedo = vec3(0.0, 0.0, 10.0);\n    spheres[2].material.roughness = 0.5;\n    spheres[2].material.metallic = 0.0;\n    \n    lights[0].brightness = vec3(10.0);\n    lights[0].location = vec3(0.0);\n    lights[0].direction = normalize(vec3(1.0, 1.0, 0.0));\n    lights[0].isDirected = true;\n}\n\nvoid updateScene()\n{\n\tspheres[1].location = vec3(0.0, sin(iTime * 0.4) * 8.0, 0.0);\n    spheres[2].location = vec3(0.0, 0.0, sin(iTime * 0.8) * 8.0);\n    \n    lights[0].direction = normalize(vec3(sin(iTime), 0.0, cos(iTime)));\n}\n\nstruct resultSDF\n{\n \tfloat sdf;\n    materialBRDF material;\n};\n\nresultSDF sphereSDF(vec3 point, int sphere) \n{\n    resultSDF result;\n    result.sdf = distance(point, spheres[sphere].location) - spheres[sphere].radius;\n    result.material = spheres[sphere].material;\n    return result;\n}\n\nresultSDF sceneSphereSDF(vec3 point)\n{\n    resultSDF result;\n    result.sdf = 1000000.0;\n \tfor(int i = 0; i < spheresCount; i++)\n    {\n        resultSDF buffer = sphereSDF(point, i);\n        if(result.sdf >= buffer.sdf)\n        {\n            result.sdf = buffer.sdf;\n            result.material = buffer.material;\n        }\t   \n    }\n    \n    return result;\n}\n\nresultSDF metaballSDF(vec3 point, int sphere)\n{\n    resultSDF result;\n    result.sdf = pow(spheres[sphere].radius, 2.0) / (pow(point.x - spheres[sphere].location.x, 2.0) + \n                                        pow(point.y - spheres[sphere].location.y, 2.0) + \n                                        pow(point.z - spheres[sphere].location.z, 2.0));\n    result.material = spheres[sphere].material;\n \treturn result;\t   \n}\n\nresultSDF sceneMetaballSDF(vec3 point)\n{\n    resultSDF result;\n    result.sdf = 0.0;\n \tfor(int i = 0; i < spheresCount; i++)\n    {\n        resultSDF buffer = metaballSDF(point, i);\n     \tresult.sdf += buffer.sdf;\t\n        result.material.albedo += (buffer.sdf * buffer.material.albedo);\n        result.material.roughness += (buffer.sdf * buffer.material.roughness);\n        result.material.metallic += (buffer.sdf * buffer.material.metallic);    \n    }\n    return result;\t   \n}\n\nstruct resultRay\n{\n    vec3 location;\n    vec3 normal;\n    float distance;\n    bool isHit;\n    materialBRDF material;\n};\n\nvec3 estimateNormalSphere(vec3 point) \n{\n    resultSDF a = sceneSphereSDF(vec3(point.x + EPSILON, point.y, point.z));\n    resultSDF b = sceneSphereSDF(vec3(point.x - EPSILON, point.y, point.z));\n    resultSDF c = sceneSphereSDF(vec3(point.x, point.y + EPSILON, point.z));\n    resultSDF d = sceneSphereSDF(vec3(point.x, point.y - EPSILON, point.z));\n    resultSDF e = sceneSphereSDF(vec3(point.x, point.y, point.z  + EPSILON));\n    resultSDF f = sceneSphereSDF(vec3(point.x, point.y, point.z - EPSILON));\n    return normalize(vec3(a.sdf - b.sdf, c.sdf - d.sdf, e.sdf - f.sdf));\n}\n    \nresultRay rayMarchingSphere(vec3 originRay, vec3 directionRay)\n{\n    resultRay result;\n    \n    vec3 locationRay = originRay;\n    for(int i = 0; i < 100; i++)\n    {\t\n    \tresultSDF buffer = sceneSphereSDF(locationRay);\n        if(buffer.sdf <= 0.001)\n        {\n            result.location = locationRay;\n            result.distance = distance(originRay, locationRay);\n            result.normal = estimateNormalSphere(locationRay);\n            result.material = buffer.material;\n            result.isHit = true;\n         \tbreak;   \n        }\n        locationRay += directionRay * buffer.sdf;\n        result.isHit = false;\n    }\n    \n    return result;\n}\n\nvec3 estimateNormalMetaball(vec3 point) \n{\n    resultSDF a = sceneMetaballSDF(vec3(point.x + EPSILON, point.y, point.z));\n    a.sdf = (a.sdf - 1.0) * -1.0;\n    resultSDF b = sceneMetaballSDF(vec3(point.x - EPSILON, point.y, point.z));\n    b.sdf = (b.sdf - 1.0) * -1.0;\n    resultSDF c = sceneMetaballSDF(vec3(point.x, point.y + EPSILON, point.z));\n    c.sdf = (c.sdf - 1.0) * -1.0;\n    resultSDF d = sceneMetaballSDF(vec3(point.x, point.y - EPSILON, point.z));\n    d.sdf = (d.sdf - 1.0) * -1.0;\n    resultSDF e = sceneMetaballSDF(vec3(point.x, point.y, point.z  + EPSILON));\n    e.sdf = (e.sdf - 1.0) * -1.0;\n    resultSDF f = sceneMetaballSDF(vec3(point.x, point.y, point.z - EPSILON));\n    f.sdf = (f.sdf - 1.0) * -1.0;\n    return normalize(vec3(a.sdf - b.sdf, c.sdf - d.sdf, e.sdf - f.sdf));\n}\n\nresultRay rayMarchingMetaball(vec3 originRay, vec3 directionRay)\n{\n    resultRay result;\n    \n    vec3 locationRay = originRay;\n    for(int i = 0; i < 50; i++)\n    {\t\n    \tresultSDF buffer = sceneMetaballSDF(locationRay);\n        if(buffer.sdf >= 0.99)\n        {\n            result.location = locationRay;\n            result.distance = distance(originRay, locationRay);\n            result.normal = estimateNormalMetaball(locationRay);\n            result.material = buffer.material;\n            result.isHit = true;\n         \tbreak;   \n        }\n        locationRay += directionRay * ((buffer.sdf - 1.0) * -1.0);\n        result.isHit = false;\n    }\n    \n    return result;\n}\n\nvec3 lightingCalculation(vec3 directionRay, resultRay rayInfo)\n{   \n    vec3 result = vec3(0.0);\n    \n    for(int i = 0; i < lightsCount; i++)\n    {\n        float distance;\n        float attenuation;\n        vec3 radiance;\n        \n        if(lights[i].isDirected)\n        {\n            radiance = lights[i].brightness;\n        }\n        else\n        {\n         \tdistance = length(lights[i].location - rayInfo.location);\n        \tattenuation = 1.0 / (distance * distance);\n        \tradiance = lights[i].brightness * attenuation;\t   \n        }\n        \n     \tlightInfo buffer = cookTorrensBRDF(-lights[i].direction, -directionRay, rayInfo.normal, rayInfo.material);\t\n        float NdotL = max(dot(rayInfo.normal, -lights[i].direction), 0.0);                \n        result += (buffer.kD * rayInfo.material.albedo / PI + buffer.kS) * radiance * NdotL; \n    }\n    \n    result += 0.05 * rayInfo.material.albedo;\n \treturn result;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    float x = iMouse.x / iResolution.x - 0.5;\n    x *= aspectRatio;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= aspectRatio;\n    \n    initScene();\n    updateScene();\n    \n    vec3 originRay = vec3(-6.0, 0.0, 0.0);\n    vec3 directionRay = normalize(vec3(1.0, uv));\n    \n    resultRay result;\n    if(x >= uv.x)\n    {\n        result = rayMarchingSphere(originRay, directionRay); \n    }\n    else\n    {\n     \tresult = rayMarchingMetaball(originRay, directionRay);   \n    }\n\n    vec3 color = lightingCalculation(directionRay, result);\n    \n    color /= color + vec3(1.0);\n    color = pow(color, vec3(1.0/2.2));\n    \n    if((x < uv.x + 0.005) && (x > uv.x - 0.005))\n    {\n     \tcolor = vec3(0.0, 1.0, 0.0);\t   \n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 348, 348, 617], [619, 619, 675, 675, 832], [833, 833, 895, 895, 1113], [1116, 1116, 1162, 1162, 1219], [1271, 1271, 1365, 1365, 2122], [2265, 2265, 2283, 2283, 3103], [3105, 3105, 3125, 3125, 3333], [3398, 3398, 3444, 3444, 3620], [3622, 3622, 3660, 3660, 3981], [3983, 3983, 4030, 4030, 4405], [4407, 4407, 4447, 4447, 4884], [5008, 5008, 5048, 5048, 5586], [5592, 5592, 5656, 5656, 6244], [6246, 6246, 6288, 6288, 7042], [7044, 7044, 7110, 7110, 7717], [7719, 7719, 7783, 7783, 8648], [8650, 8650, 8707, 8707, 9543]], "test": "untested"}
{"id": "tdSBWw", "name": "Reshaping sphere", "author": "kotfind", "description": "My first glsl project.", "tags": ["raymarching3d"], "likes": 1, "viewed": 316, "published": 3, "date": "1590138871", "time_retrieved": "2024-07-30T21:05:42.249670", "image_code": "#define ROTATION\n#define LIGHT_SOURCE_ATTACHED_TO_CAMERA\n#define LIGHTING\n\n#define M_PI 3.1415926\n\n// setting begin\nconst float FOV   = M_PI / 2.;\nconst float zNear = 1.;\nconst float zFar  = 100.;\n\nconst float colissiondist = 0.00001;\nconst int maxIter = 1000;\n// setting end\n\nvec3 viewpoint = vec3(0., 0., 6.);\n\nmat3 rotatey(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    return mat3(cosa,  0., sina,\n                0.,    1.,   0.,\n                -sina, 0., cosa);\n}\n\nfloat f(in vec3 p) {\n    return distance(p, vec3(0., 0., 0.)) - 2. + sin(p.x * 10.) * sin(iTime * 2.);\n}\n\nvoid dist(in vec3 p, out float mind, out vec3 color, out vec3 norm) {\n    mind = f(p);\n    color = vec3(1., 0., 0.);\n    color = vec3(sin(p.x * 3.)  + sin(p.y * 5.)  * cos(p.z * 100.), \n                 sin(p.x * 30.) * sin(p.y * 1.)  + sin(p.z * 2.),\n                 sin(p.x * 9.)  * cos(p.y * 25.) + sin(p.z * 700.));\n    const float E = 0.000001;\n    norm = normalize(vec3(f(p + vec3(E, 0., 0.)), f(p + vec3(0., E, 0.)), f(p + vec3(0., 0., E))));\n}\n\nvec3 ray_marching(vec3 orig, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    vec3 bg = vec3(min(0.937255, max(0.2, sin(dir.x * 5.) + sin(dir.y * 10.) + cos(dir.x * dir.y * 10.))));\n\n    for (int i = 0; i < maxIter; ++i) {\n        float d;\n        vec3 color;\n        vec3 norm;\n        dist(orig, d, color, norm);\n        #ifdef LIGHTING\n            #ifdef LIGHT_SOURCE_ATTACHED_TO_CAMERA\n                if (d < colissiondist) return color * \n                    max(0.4, length(dot(norm, normalize(viewpoint - dir))));\n            #else\n                if (d < colissiondist) return color * \n                    max(0.4, length(dot(norm, normalize(vec3(0., 3., 4.) - dir))));\n            #endif\n        #else\n            if (d < colissiondist) return color;\n        #endif\n        if (len > zFar) return bg;\n\n        len += d;\n        orig += dir * d;\n    }\n    return bg;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    uv.y = 1. - uv.y;\n\n    #ifdef ROTATION\n        float a = iTime * 0.1;\n    #else\n        float a = 0.;\n    #endif\n    viewpoint.x = sin(a) * 7.;\n    viewpoint.z = cos(a) * 7.;\n    vec3 color = ray_marching(viewpoint, rotatey(-a + M_PI) * vec3(uv - vec2(0.5, 0.5) , zNear));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 339, 339, 491], [493, 493, 513, 513, 597], [599, 599, 668, 668, 1051], [1053, 1053, 1093, 1093, 1943], [1945, 1945, 2000, 2000, 2463]], "test": "untested"}
{"id": "3sSfWm", "name": "Distance wave field", "author": "LowSpecCorgi", "description": "Derived from The Book Of Shaders (https://thebookofshaders.com/07/), animated with a cosine function.\n\nCreated for school : R.P", "tags": ["wave", "circle", "distance"], "likes": 2, "viewed": 346, "published": 3, "date": "1590132187", "time_retrieved": "2024-07-30T21:05:43.116353", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st = fragCoord.xy/iResolution.xy;\n  st.x *= iResolution.x/iResolution.y;\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Make the distance field\n  d = length( abs(st)-.3 );\n  //d = length( min(abs(st)-.3,0.) );\n  //d = length( max(abs(st)-.3,0.) );\n\n  // Visualize the distance field\n  fragColor = vec4(vec3(fract(d*cos(iTime)*cos(iMouse)*20.0)),1.0);\n\n  // Drawing with the distance field\n  // gl_FragColor = vec4(vec3( step(.3,d) ),1.0);\n  // gl_FragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);\n  // gl_FragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 102, 102, 747]], "test": "untested"}
{"id": "wsjBDD", "name": "Julia Revolute on Cardioid", "author": "xjorma", "description": "Julia revolute along Mandelbrot's cardioid.\n\nInspired by: \nhttps://twitter.com/matthen2/status/1262247041238839296\n \nThank you Patapom for the ref.\n", "tags": ["julia", "mandelbrot", "cardioid", "reproduction"], "likes": 14, "viewed": 572, "published": 3, "date": "1590104299", "time_retrieved": "2024-07-30T21:05:43.957104", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_DIST\t\t13.\n#define PI radians(180.)\n\nconst int maxIterations = 7;\nconst float majorRadius = 4.;\n\nvec3 pn;\n\nvec2 csqr(vec2 v)\n{\n    return vec2(v.x * v.x - v.y * v.y, 2. * v.x * v.y );\n}\n\n// Apparently from IQ\nfloat julia2d(vec2 z, vec2 c)\n{\n\tfloat k = 1., h = 1.;    \n    for (int i = 0;i < maxIterations; i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.)\n            break;\n\t\tz = csqr(z) + c;\n    }\n\treturn sqrt(k / h) * log(k);\n}\n\nfloat map(vec3 p)\n{\n\tfloat\tt = atan(p.x, p.z) + iTime;\n    vec2\tc = vec2(0.5 * cos(t) - 0.25 * cos(2. * t), 0.5 * sin(t) - 0.25 * sin(2. * t));\t\t// Mendelbrot Cardioid\n    float\tr = length(p.xz) - majorRadius;\n    float\td = julia2d(vec2(r, p.y), c);\n\treturn  max(d, min(dot(p, pn), dot(p, pn * vec3(1, -1, -1))));\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    return col*col;\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 250; i++)\n  {\n    float h = sgn * map(ro + rd * t);\n    t += h * 0.4;\t\t\t\t\t\t// Perf killer :(\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float t = rayMarch(1., ro, rd, 1.5);\n    vec3\tcol = vec3(0.3);\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);   \n        col = texture(iChannel0, reflect(rd, n)).rgb;\n    }\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(vec3 color, float v)\n{\n    return mix(color, vec3(dot(color, color)), v);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n    col = desaturate(col, 0.5);\n\tcol = contrast(col, 1.2);\n\tcol = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n\t\t\t cos(a),\t0.0,\t\tsin(a),\n\t\t\t 0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(a),\t0.0,\t\tcos(a));\n}       \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    pn = rotY( 0.3 * (cos(iTime) + 1.) ) * vec3(0,0,1);\n    \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - 0.5;\n        vec3 ro = 7. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd);\n        \n\n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjBDD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[303, 303, 322, 322, 381], [383, 405, 436, 436, 642], [644, 644, 663, 663, 959], [961, 961, 988, 988, 1053], [1056, 1056, 1125, 1125, 1326], [1883, 1883, 1920, 1920, 2157], [2159, 2159, 2202, 2202, 2260], [2262, 2262, 2306, 2306, 2405], [2407, 2407, 2445, 2445, 2498], [2500, 2500, 2542, 2542, 2646], [2649, 2649, 2691, 2691, 2855], [2857, 2857, 2877, 2877, 2970]], "test": "untested"}
{"id": "ws2fDW", "name": "Space Warping Portals", "author": "Plento", "description": "A little experiment with some non euclidean portal stuff. Inspired by this awesome video: https://www.youtube.com/watch?v=0pmSPlYHxoY&t=85s\n", "tags": ["3d", "mouse", "portal", "noneuclidean"], "likes": 26, "viewed": 784, "published": 3, "date": "1590103791", "time_retrieved": "2024-07-30T21:05:44.797857", "image_code": "// Made by Plento\n// An experiment with messing with space in a portal like fashion\nvec2 R;\n\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define FAR 64.\n#define FAR2 12.\n\nmat2 rot(float a){return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hall(vec3 rp){\n    float d  = 999.;\n    rp.x = -abs(rp.x);\n    d = min(d, box(rp-vec3(-2., 0.0, 11.0), vec3(0.1, 2., 5.0)));\n    d = min(d, box(rp-vec3(0.0, 2.1, 11.0), vec3(2.1, 0.1, 5.0)));\n    return d;\n}\n\nvec3 b = vec3(8., 0., 0.);\n\n// distance field for hall and floor\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    vec3 p = rp;\n    p = mod(p, b)-b*0.5;\n    \n    d = min(d, 2. + rp.y);\n    d = min(d, hall(p));\n    \n    return d;\n}\n// distance field for just portals\nfloat mapPortal(vec3 rp){\n    vec3 p = rp-vec3(0., 0., 6.);\n    p = mod(p, b)-b*0.5;\n    return box(p, vec3(1.9, 2., .001));\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n// march scene for color\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;  \n    \n    for(int i = 0; i < 99; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .0025 || t > FAR) break;\n        t += d * .95;\n    }\n    \n    return t;\n}\n\n// march scene for just portals with reduced step count\nfloat tracePortal(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;  \n    \n    for(int i = 0; i < 28; i++){\n    \td = mapPortal(ro + rd*t); \t   \n        \n        if(abs(d) < .0025) break;\n        if(t > FAR2){t = FAR2; break;}\n        \n        t += d * .75;\n    }\n    return t;\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 n, vec2 u, float t){\n    vec3 lp = p+vec3(4., 16.0, -2.0);\n    vec3 ld = normalize(lp-p);\n   \tvec3 ref = reflect( rd, n );\n    \n    float lgd = length(lp - p);\n    float faloff = 1.-exp(-(4. / lgd));\n    \n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float dif = max(dot(n, ld), .025);\n    \n    vec3 col = vec3(0);    \n    vec3 lig = vec3(0);\n    \n    if(p.y <= -1.85){\n        vec2 id = floor(p.xz*1.);\n        float chk = mod(id.x+id.y, 2.);\n        col = mix(vec3(.6), vec3(0.), chk); \n    }\n    else{col = vec3(1., 1., 1.);}\n    \n    lig += .4*dom*vec3(0.2,0.1,1.0)*dom;\n    lig += 2.6*dif*vec3(1., 1., 1.) * faloff;\n    col *= lig;\n   \n    vec3 sky = mix(vec3(0.2, 0.48, 0.88), vec3(0.8, 0.48, 0.88), abs(rd.y*7.8));\n    col = mix(sky, col, exp(-t*t*t*0.00003));\n    \n\treturn col;   \n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.9));\n    vec3 ro = vec3(iTime*2., 0., 0.);\n    \n    if(iMouse.z > 0.){\n     \tro.x += m.x*42.;\n        ro.y += m.y*8.;\n    }\n    \n    vec3 p = vec3(0);\n    float t = 0.;\n    \n    vec3 col = vec3(0);\n    vec3 n = vec3(0);\n    \n    float tp = tracePortal(rd, ro);\n    \n    if(tp < FAR2){ // hit portal, do wacky stuff with ray\n    \tp = ro+rd*tp; \t   \n        \n        float id = floor(p.x/b.x);\n        float seq = floor(mod(id, 6.));\n        \n        if(seq==0.) rd.z *= 5.0;\n        else if(seq==1.) rd.z*=.1;   \n        else if(seq==2.) rd.xz*=rot(.6);     \n        else if(seq==3.) rd.xz*=rot(-.5);   \n        else if(seq==4.) rd.yz*=rot(.4);     \n        else if(seq==5.) rd.yz*=rot(-.23);     \n         \n        t = march(rd, p);\n        p += rd*t;\n        \n        n = normal(p);\n    \tcol = color(p, rd, n, u, t);\n    }\n    else{ // trace scene like normal\n        t = march(rd, ro);\n        p = ro+rd*t; \t \n        n = normal(p);\n    \tcol = color(p, rd, n, u, t);  \n    }\n    \n    col*=smoothstep(0.5, 0.0, abs(uv.y));\n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2fDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 203, 203, 249], [251, 251, 279, 279, 366], [368, 368, 388, 388, 581], [611, 648, 667, 667, 812], [813, 848, 873, 873, 974], [976, 976, 1003, 1003, 1204], [1206, 1231, 1261, 1261, 1449], [1451, 1507, 1543, 1543, 1778], [1780, 1780, 1833, 1833, 2607], [2609, 2609, 2649, 2649, 3829]], "test": "untested"}
{"id": "wd2fWD", "name": "Devil's Egg", "author": "workingclasshacker", "description": "A simple raymarcher, with a distance estimation function for the Mandelbulb fractal. I wish I could fix the artifacts though, any tips on that?", "tags": ["raymarching", "mandelbulb"], "likes": 1, "viewed": 403, "published": 3, "date": "1590099409", "time_retrieved": "2024-07-30T21:05:45.631627", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAX_STEPS 100\n#define SURFACE_DIST .001\n#define MAX_DIST 30.0\n#define MANDEL_ITERATIONS 5\n#define MANDEL_BAIL_DIST 16.\n#define MANDEL_POWER 8.0\n\nmat2 Rot2d(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, - s, s, c);\n}\n\nfloat sdMandelBulb(vec3 p){\n  vec3 z = p;\n  float dr = 1.;\n  float r = 0.;\n  for(int i = 0; i<MANDEL_ITERATIONS;i++){\n    r = length(z);\n    if(r>MANDEL_BAIL_DIST) break;\n\n    // spherical coordinates\n    float theta = acos(z.z/r);\n    float phi = atan(z.y, z.x);\n    dr = pow(r, MANDEL_POWER)*MANDEL_POWER*dr +1.0;\n\n    float zr = pow(r, MANDEL_POWER);\n    theta = theta*MANDEL_POWER;\n    phi = phi*MANDEL_POWER;\n\n    z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta))+p;\n    \n  }\n  return 0.5*log2(r)*r/dr;\n}\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n  return length(p - sphere.xyz) - sphere.w;\n}\n\nfloat sdBox(vec3 p, vec3 box) {\n  p = abs(p) - box;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n  p *= scale;\n  return abs(dot(sin(p), cos(p.zxy)) + bias) / scale - thickness;\n}\n\nfloat sdAAPlane(vec3 p){\n  return p.y;\n}\n//\nvec3 Transform(vec3 p) {\n  return p;\n}\n\nfloat GetDist(vec3 p){\n  // replace with your scene\n  float d = sdMandelBulb(p);\n    \n  return d;\n}\n\nvec3 GetNormal(vec3 p) {\n  vec2 e = vec2(0.00001, 0.);\n  float d = GetDist(p);\n  vec3 n = d-vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n  return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l - p),\n  r = normalize(cross(vec3(0, 1, 0), f)),\n  u = cross(f, r),\n  c = p+f * z,\n  i = c+uv.x * r+uv.y * u,\n  d = normalize(i - p);\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.0;\n  for(int i = 0; i < MAX_STEPS; i ++ ) {\n    vec3 p = ro + dO * rd;\n    float ds = GetDist(p);\n    dO += ds;\n    if (dO < SURFACE_DIST||dO > MAX_DIST) {\n      break;\n    }\n  }\n  return dO;\n}\n\nvec3 render(vec2 uv){\n  float t = iTime / 5.0;\n  vec3 color = vec3(0);\n  \n  // camera\n  vec3 camO = vec3(0, 0, -3);\n  vec3 lookAt = vec3(0, 0, 0);\n\n  camO.xz *= Rot2d(t/1.);\n  camO.yz *= Rot2d(t/1.);\n  vec3 rd = GetRayDir(uv, camO, lookAt, 6.*(sin(t)*.5+.5));\n  \n  // trace scene\n  float d = RayMarch(camO, rd);\n    \n  // material\n  if (d < MAX_DIST) {\n    vec3 p = camO + rd * d;\n    vec3 n = GetNormal(p);\n    float height = p.y;\n    float dif = n.y * 0.5 + 0.5+n.x*.5;    \n    //color.r = n.x;\n    //color += vec3(.0,0,0.);\n    //color += .2*n*dif*dif+dif*.5;\n    color += vec3(d*.2);\n    \n    color *= vec3(n.x*.4,0,n.y/2.);\n    color *= dif;\n  } else {\n   \tcolor = vec3(.2,0,0);\n    color *= 1.-dot(uv, uv);\n  }\n  return color*=1.7;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n  \n  vec3 color = render(uv);\n  \n  fragColor=vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2fWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 220, 220, 291], [293, 293, 320, 320, 818], [820, 820, 857, 857, 903], [905, 905, 936, 936, 1024], [1026, 1026, 1092, 1092, 1174], [1176, 1176, 1200, 1200, 1216], [1217, 1220, 1244, 1244, 1258], [1260, 1260, 1282, 1311, 1359], [1361, 1361, 1385, 1385, 1543], [1545, 1545, 1595, 1595, 1765], [1767, 1767, 1801, 1801, 2010], [2012, 2012, 2033, 2033, 2751], [2754, 2754, 2810, 2810, 2939]], "test": "untested"}
{"id": "ws2BWD", "name": "Fractal pocho", "author": "makaronsito", "description": "No saber, no reír T-T", "tags": ["3d", "fractal"], "likes": 3, "viewed": 347, "published": 3, "date": "1590098847", "time_retrieved": "2024-07-30T21:05:46.457420", "image_code": "//constantes para el march tracing\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 1000.;\nconst int MAX_MARCH = 500;\n//altura a la que se encuentra un plano que hace de suelo\nconst float groundHeight = 0.;\n//definimos una esfera con una posición y radio, debe caber en nuestra celda unidad\nconst vec3 bola = vec3(0, 1, .7);\nconst float radio = 0.5;\n//distancia entre bolas duplicadas eternamente, la arista de la celda unidad\nconst float cellS = 5.;\n\n//devuelve el resto de la división con el signo de x\nvec3 rep(vec3 pos, float spa){\n\treturn mod(pos+spa/2.,spa)-spa/2.;\n}\n\n//se encarga de hallar el punto más cercano perteneciente a cualquier objeto que se encuentre en escena\n//en este momento solo hay un plano y una esfera, la menor de las distancias es la devuelta por la función\n//también devuelte una tonalidad de rojo para distinguir un objeto de otro\nvec2 getDistance(vec3 pos){\n\tfloat diff = 0.;\n\tfloat col = 0.;\n\tfloat diffG = abs(pos.y-groundHeight);\n\t\n\tfloat diffC = length(rep(pos,cellS)-bola) - radio;\n\t\n\tif (diffC > diffG){\n        col = 1.;\n\t\tdiff = diffG;\n\t}\n\telse{\n\t\tdiff = diffC;\n\t}\n\t\t\n\treturn vec2(abs(diffC), col);\n}\n\n//calcula la distancia y con ella determina lo vivo que es el color, si se pasa de la \"rayo\" devuelve color blanco\n//si da contra algo devuelve un color que está objetivamente mal y no proporciona información así que mola\nvec3 rayMarch(vec3 dir, vec3 pos){\n\tfloat dist = 0.;\n\tfor (int i = 0; i < MAX_MARCH; i++){\n\t\tvec2 res = getDistance(pos);\n\t\tfloat surfDist = res.x;\n\t\tpos += dir * surfDist;\n\t\tdist += surfDist;\n\t\t\n\t\t//if it's\t BUT \tit's not\n\t\tif (surfDist < MIN_DIST){\n\t\t\tfloat coef = dist/MAX_DIST;\n\t\t\treturn vec3(res.y, coef, coef);\n\t\t}\n        else{\n            if (i == MAX_MARCH-1 || dist > MAX_DIST)\n\t\t\treturn vec3(1);\n        }\n\t}\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 relUV = vec2(uv.x-0.5,uv.y-0.5);\t// \"centramos\" las coordenadas UV en el centro de la textura en vez de la esquina\n    vec3 rotPixel = normalize(vec3(relUV.x*iResolution.x/iResolution.y, relUV.y, 1));\t// vector dirección para cada rayo\n    vec3 camPos = vec3(cos(iTime)*4.,sin(iTime)*4.,(iTime)*20.2);//owo y paz\t// posición cámara, mov armónico simple en relación al tiempo no tiene pérdida\n\tfragColor = vec4(rayMarch(rotPixel,camPos),1.0);\t// ahí va el colorsito\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 510, 540, 540, 578], [580, 869, 896, 896, 1147], [1149, 1374, 1408, 1408, 1795], [1797, 1797, 1855, 1905, 2434]], "test": "untested"}
{"id": "3djfDD", "name": "Turbulent waves", "author": "jarble", "description": "Based on https://www.shadertoy.com/view/3d2BWD", "tags": ["waves", "turbulence"], "likes": 1, "viewed": 361, "published": 3, "date": "1590082311", "time_retrieved": "2024-07-30T21:05:47.295179", "image_code": "//This is based on https://www.shadertoy.com/view/3d2BWD\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (100.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    //uv *= 30.*abs(1.1 + sin(iTime*0.1));\n    float len;\n    uv += sin(uv/20.0)/10.0;\n    for (int i = 0; i < 10; i++) {\n    \tlen = length(uv);\n        uv.x += sin(iTime+sin(uv.y))-len/uv.y;\n        uv.y += cos(iTime+cos(uv.x))-len/uv.x;\n    }\n    float col = cos(len);\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 513]], "test": "untested"}
{"id": "WsjBDD", "name": "Particles and Waves", "author": "wyatt", "description": "Fun experiment combining particle tracking and  wave simulating. Best sped up.", "tags": ["fakephysics"], "likes": 9, "viewed": 492, "published": 3, "date": "1590081499", "time_retrieved": "2024-07-30T21:05:48.166849", "image_code": "Main {\n\t vec4 a = A(U), d= D(U);\n    float p = exp(-length(U-a.xy));\n    Q = 0.5+0.5*sin(3.1*(p+length(d.zw))+vec4(1,2,3,4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void X (inout vec4 Q, vec2 U, vec2 r ) {\t\n   vec4 a = A(U+r);\n   if (length(U-a.xy)<length(U-Q.xy))\n       Q = a;\n}\nvoid Y (inout vec4 Q, vec2 U, float r) {\n\tX(Q,U,vec2(0,r));\n\tX(Q,U,vec2(r,0));\n\tX(Q,U,vec2(0,-r));\n\tX(Q,U,vec2(-r,0));\n}\nMain {\n\tQ = A(U);\n\tY(Q,U,1.);\n\tY(Q,U,3.);\n    \n   \tvec2 f = vec2(0);\n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++) {\n        \tvec2 r = vec2(x,y);\n            vec4 d = D(Q.xy+r);\n            f -= r*dot(d.zw,d.zw);\n        }\n    f *= 2e-2;\n    Q.zw += f;\n    Q.xy += f+Q.zw/sqrt(1.-dot(Q.zw,Q.zw));\n    \n    if (Q.x<20.) {Q.x = 20.; Q.z *= -1.;}\n    if (Q.x>R.x-20.) {Q.x = R.x-20.; Q.z *= -1.;}\n    if (Q.y<20.) {Q.y = 20.; Q.w *= -1.;}\n    if (Q.y>R.y-20.) {Q.y = R.y-20.; Q.w *= -1.;}\n    \n    if (iFrame < 1) {\n    \tQ = vec4(round(U/30.)*30.,0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    vec4 a = A(U);\n    float p = W;\n\tQ = B(U);\n    vec4 \n        l = (1./6.)*(\n        \tB(U+vec2(0,1))+\n        \tB(U+vec2(1,0))+\n        \tB(U-vec2(0,1))+\n        \tB(U-vec2(1,0))+\n            .5*(B(U+vec2(1,1))+\n            B(U+vec2(1,-1))+\n            B(U-vec2(1,1))+\n            B(U-vec2(1,-1)))\n            \n        )-Q;\n    vec2 f = Q.zw*(p+Z);\n    Q.xy += l.zw - f;\n    Q.zw += Q.xy - M*f;\n    \n    Q = clamp(Q,-2.,2.);\n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<5.)) {\n    \tQ = vec4(.1,.1,-.5,.5);\n    }\n    if (U.x <1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.zw=vec2(1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n#define W -.3/(1.+length(U-a.xy))\n#define Z .4*(abs(length(Q.zw)-.5))\n\n\n#define M 1.", "buffer_c_code": "Main {\n    vec4 a = A(U);\n    float p = W;\n\tQ = B(U);\n    vec4 \n        l = (1./6.)*(\n        \tB(U+vec2(0,1))+\n        \tB(U+vec2(1,0))+\n        \tB(U-vec2(0,1))+\n        \tB(U-vec2(1,0))+\n            .5*(B(U+vec2(1,1))+\n            B(U+vec2(1,-1))+\n            B(U-vec2(1,1))+\n            B(U-vec2(1,-1)))\n            \n        )-Q;\n    vec2 f = Q.zw*(p+Z);\n    Q.xy += l.zw - f;\n    Q.zw += Q.xy - M*f;\n    \n    Q = clamp(Q,-2.,2.);\n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<5.)) {\n    \tQ = vec4(.1,.1,-.5,.5);\n    }\n    if (U.x <1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.zw=vec2(1);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    vec4 a = A(U);\n    float p = W;\n\tQ = B(U);\n    vec4 \n        l = (1./6.)*(\n        \tB(U+vec2(0,1))+\n        \tB(U+vec2(1,0))+\n        \tB(U-vec2(0,1))+\n        \tB(U-vec2(1,0))+\n            .5*(B(U+vec2(1,1))+\n            B(U+vec2(1,-1))+\n            B(U-vec2(1,1))+\n            B(U-vec2(1,-1)))\n            \n        )-Q;\n    vec2 f = Q.zw*(p+Z);\n    Q.xy += l.zw - f;\n    Q.zw += Q.xy - M*f;\n    \n    Q = clamp(Q,-2.,2.);\n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<5.)) {\n    \tQ = vec4(.1,.1,-.5,.5);\n    }\n    if (U.x <1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.zw=vec2(1);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wsfBDS", "name": "mechanizm_yurka", "author": "yurka", "description": "mechanizm", "tags": ["mechanizm"], "likes": 6, "viewed": 164, "published": 3, "date": "1590081422", "time_retrieved": "2024-07-30T21:05:49.168172", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    InitObjects();\n    CalcForTime(iTime);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float distfactor = 10000.0;\n    for (int oi = 0; oi < objects_count; oi++)\n    {\n        float glow = 0.0;\n        if (objects[oi].points_count > 1)\n        {\n            for (int i = 0; i < objects[oi].points_count-1; i++)\n                for (int j = i+1; j < objects[oi].points_count; j++)\n                {\n                    vec2 pp = uv - objects[oi].points[i];\n                    vec2 pv = objects[oi].points[j] - objects[oi].points[i];\n\n                    float scalar = dot(pv, pp);\n                    float l2 = len2(pv);\n                    scalar /= l2;\n                    if (scalar < 0.0) scalar = 0.0;\n                    if (scalar > 1.0) scalar = 1.;\n                    float dst2 = len2(pv*scalar - pp);\n\n                    dst2 *= distfactor;\n                    if (dst2 > 1e-3)\n                        glow += 1.0 / dst2;\n                    else\n                        glow += 1000.0;\n                }\n        }\n        else if (objects[oi].points_count == 1)\n        {\n            float dst2 = len2(uv - objects[oi].points[0]);\n\n            dst2 *= distfactor;\n            if (dst2 > 1e-3)\n                glow += 1.0 / dst2;\n            else\n                glow += 1000.0;\n        }\n\n        col += glow*objects[oi].color;\n    }\n    /*\n    // stats >>\n    vec2 statbegin = vec2(0, -0.3);\n    vec3 statcol = vec3(1.0, 0.0, 0.0);\n    vec2 statvec = vec2(0.0, 0.02);\n    vec2 statend = statbegin + statvec * float(calcs);\n    \n    vec2 pp = uv - statbegin;\n    vec2 pv = statend - statbegin;\n\n    float glow = 0.0;\n    float scalar = dot(pv, pp);\n    float l2 = len2(pv);\n    scalar /= l2;\n    if (scalar < 0.0) scalar = 0.0;\n    if (scalar > 1.0) scalar = 1.;\n    float dst2 = len2(pv*scalar - pp);\n\n    dst2 *= distfactor;\n    if (dst2 > 1e-3)\n        glow += 1.0 / dst2;\n    else\n        glow += 1000.0;\n    glow *= 1.0 - fract(scalar * float(calcs));\n    col += glow*statcol;\n    // <<\n    */\n    //vec3 col = vec3(cos(uv.x*3.14*5.0 + iTime) * sin(uv.y*3.14*5.0 + iTime));\n\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_OBJ 10\n#define MAX_POINTS 4\n#define EPS 1e-20\n#define MPI 3.14159265359\nstruct obj\n{\n    int Fcnt;\n    int axis;\n    vec2 points[MAX_POINTS];\n    int point_obj[MAX_POINTS];\n    int point_point[MAX_POINTS];\n    bool point_dom[MAX_POINTS];\n    bool point_track[MAX_POINTS];\n    int points_count; \n    vec3 color;\n};\n\nobj objects[MAX_OBJ];\nint objects_count = 0;\nint calcs = 0;\n\nfloat len2(vec2 v)\n{\n    return v.x*v.x + v.y*v.y;\n}\n\nbool intersectlineancircle(float rp2, float a, float b, float c, out vec2 p1, out vec2 p2)\n{\n    float aapbb = a*a+b*b;\n\tfloat x0 = -a*c/aapbb,  y0 = -b*c/aapbb;\n    if (c*c > rp2*aapbb+EPS)\n        return false;\n    else if (abs (c*c - rp2*aapbb) < EPS) {\n        p1.x = x0;\n        p1.y = y0;\n        p2 = p1;\n    }\n    else {\n        float d = rp2 - c*c/aapbb;\n        float mult = sqrt (d / aapbb);\n        float ax,ay,bx,by;\n        ax = x0 + b * mult;\n        bx = x0 - b * mult;\n        ay = y0 - a * mult;\n        by = y0 + a * mult;\n        p1.x = ax;\n        p1.y = ay;\n        p2.x = bx;\n        p2.y = by;\n    }\n    return true;\n}\n\nbool intersect2circles(float r1p2, vec2 c1, float r2p2, vec2 c2, out vec2 p1, out vec2 p2)\n{\n    vec2 sc = c2 - c1;\n    float a = -2.0*sc.x;\n    float b = -2.0*sc.y;\n    float c = sc.x*sc.x + sc.y*sc.y + r1p2 - r2p2;\n    \n    if (intersectlineancircle(r1p2, a, b, c, p1, p2))\n    {\n        p1 += c1;\n        p2 += c1;\n        return true;\n    }\n    else\n        return false;\n}\n\nvec2 GetPerpendicularVector(vec2 Vector)\n{\n    return vec2(-Vector.y, Vector.x);\n}\n\nfloat Determinant2x2(\n                float a, float b,\n                float d, float e\n                )\n{\n    return a * e - b * d;\n}\n\nvec2 GetPosInVectorCoordinates(vec2 vx, vec2 vy, vec2 p)\n{\n    // i*x1 + j*x2 + k*x3 = x\n    // i*y1 + j*y2 + k*y3 = y\n    // i*z1 + j*z2 + k*z3 = z\n    float det = Determinant2x2(vx.x, vy.x, vx.y, vy.y);\n    \n    vec2 res = vec2(\n            \t\tDeterminant2x2(p.x, vy.x, p.y, vy.y) / det,\n    \t\t\t\tDeterminant2x2(vx.x, p.x, vx.y, p.y) / det\n        \t\t\t);\n    return res;\n}\n\nvoid CalculateDependencies()\n{\n    // calculation of dependences >>\n    bool broken = false;\n    int counttofix = 1;\n    while (counttofix > 0 && !broken)\n    {\n        counttofix = 0;\n        for (int oi = 0; oi < objects_count; oi++)\n        {\n            for (int pi = 0; pi < objects[oi].points_count; pi++)\n            {\n                int no;\n                int np;\n                calcs++;\n                if ((no = objects[oi].point_obj[pi]) >= 0 && (np = objects[oi].point_point[pi]) >= 0)\n                {\n                    counttofix++;\n                    if (objects[no].point_point[np] < -1)\n                    {\n                        vec2 shift = objects[no].points[np] - objects[oi].points[pi];\n                        for (int pi2 = 0; pi2 < objects[oi].points_count; pi2++)\n                        {\n                            objects[oi].points[pi2] += shift;\n                        }\n                        objects[oi].point_obj[pi] = -2;\n                        objects[oi].point_point[pi] = -2;\n                        objects[oi].Fcnt++;\n                        objects[oi].axis = pi;\n                        counttofix--;\n                    }\n                    else\n                    {\n                        if (objects[oi].Fcnt == 1 && objects[no].Fcnt == 1)\n                        {\n                            //objects[oi].points[pi] = vec2(0, 0);\n                            vec2 p1, p2;\n                            vec2 c1 = objects[oi].points[objects[oi].axis];\n                            vec2 c2 = objects[no].points[objects[no].axis];\n                            float r1p2 = len2(objects[oi].points[pi] - c1);\n                            float r2p2 = len2(objects[no].points[np] - c2);\n\n                            if (intersect2circles(r1p2, c1, r2p2, c2, p1, p2))\n                            {\n                                vec2 intP = p1;\n                                if (!objects[oi].point_dom[pi])\n                                    intP = p2;\n\n                                vec2 vecf1 = objects[oi].points[pi] - c1;\n                                vec2 vecf1p = GetPerpendicularVector(vecf1);\n                                vec2 vect1 = intP - c1;\n                                vec2 vect1p = GetPerpendicularVector(vect1);                                \n                                \n                                for (int pi2 = 0; pi2 < objects[oi].points_count; pi2++)\n                                    if (objects[oi].point_obj[pi2] >= -1)\n                                    {\n                                        vec2 psf1 = GetPosInVectorCoordinates(vecf1, vecf1p, objects[oi].points[pi2] - c1);\n                                        objects[oi].points[pi2] = psf1.x*vect1 + psf1.y*vect1p + c1;\n                                        objects[oi].point_obj[pi2] = -2;\n                                        objects[oi].point_point[pi2] = -2;\n                                        objects[oi].Fcnt++;\n                                        counttofix--;\n                                    }\n\n                                vec2 vecf2 = objects[no].points[np] - c2;\n                                vec2 vecf2p = GetPerpendicularVector(vecf2);\n                                vec2 vect2 = intP - c2;\n                                vec2 vect2p = GetPerpendicularVector(vect2);                                \n                                \n                                for (int pi2 = 0; pi2 < objects[no].points_count; pi2++)\n                                    if (objects[no].point_obj[pi2] >= -1)\n                                    {\n                                        vec2 psf2 = GetPosInVectorCoordinates(vecf2, vecf2p, objects[no].points[pi2] - c2);\n                                        objects[no].points[pi2] = psf2.x*vect2 + psf2.y*vect2p + c2;\n                                        objects[no].point_obj[pi2] = -2;\n                                        objects[no].point_point[pi2] = -2;\n                                        objects[no].Fcnt++;\n                                        counttofix--;\n                                    }\n                            }\n                            else\n                            {\n                                broken = true;\n                            }\n                        }\n                    }\n                }\n                else\n                    if (no == -1)\n                    \tcounttofix++;\n            }\n        }\n    }\n    // <<\n}\n\nvoid CalcForTime(float aTime)\n{\n    // movement >>\n    vec2 shift = vec2(-0.5, 0.20);\n    float rad1 = 0.085;\n    vec2 cen1 = vec2(0.09, 0.17);\n    objects[0].points[0] = shift + cen1 + vec2(sin(fract(aTime) * MPI * 2.0) * rad1, cos(fract(aTime) * MPI * 2.0) * rad1);\n    objects[1].points[0] = shift;\n    // <<\n    \n    CalculateDependencies();\n}\n\nvoid InitObjects()\n{\n    // initialazing objects >>\n    int oc = objects_count = 0;\n    int pc = 0;\n    \n    // o #0\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.2, 0.2);\n    objects[oc].point_obj[pc] = -2;\n    objects[oc].point_point[pc] = -2;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = true;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.0, 0.0, 0.3);\n    objects[oc].Fcnt = 1;\n    objects[oc].axis = 0;\n    oc = ++objects_count;\n    \n    // o #1\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = -2;\n    objects[oc].point_point[pc] = -2;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(1.0, 0.0, 0.0);\n    objects[oc].Fcnt = 1;\n    objects[oc].axis = 0;\n    oc = ++objects_count;\n    \n    // o #2\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0);\n    objects[oc].point_obj[pc] = 6;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.1, 0.1);\n    objects[oc].point_obj[pc] = 1;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0, 0.2);\n    objects[oc].point_obj[pc] = 3;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = true;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.5, 0.2, 1.0);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    \n    // o #3\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.1, 0.2);\n    objects[oc].point_obj[pc] = 0;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.1, 0.0);\n    objects[oc].point_obj[pc] = 2;\n    objects[oc].point_point[pc] = 2;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.5, 1.0, 0.1);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    \n    // o #4\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = 0;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.22);\n    objects[oc].point_obj[pc] = 5;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = true;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.1, 0.1, 1.0);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    // <<\n        \n    // o #5\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = 1;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.14, 0.0);\n    objects[oc].point_obj[pc] = 4;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(1.1, 0.1, 0.0);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    // <<\n    \n    // o #6\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = 2;\n    objects[oc].point_point[pc] = 0;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.17, 0.0);\n    objects[oc].point_obj[pc] = 7;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = true;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.2, 0.2, 0.2);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    // <<\n    \n    // o #7\n    objects[oc].points_count = 0;\n    pc = objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.17, 0.0);\n    objects[oc].point_obj[pc] = 5;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = false;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(0.0, 0.0);\n    objects[oc].point_obj[pc] = 6;\n    objects[oc].point_point[pc] = 1;\n    objects[oc].point_dom[pc] = true;\n    objects[oc].point_track[pc] = false;\n    pc = ++objects[oc].points_count;\n    objects[oc].points[pc] = vec2(-0.2, -0.2);\n    objects[oc].point_obj[pc] = -1;\n    objects[oc].point_point[pc] = -1;\n    objects[oc].point_dom[pc] = true;\n    objects[oc].point_track[pc] = true;\n    pc = ++objects[oc].points_count;\n    objects[oc].color = vec3(0.3, 0.2, 0.0);\n    objects[oc].Fcnt = 0;\n    objects[oc].axis = -1;\n    oc = ++objects_count;\n    // <<\n    \n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    InitObjects();\n    CalcForTime(iTime);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float distfactor = 10000.0;\n    // show track >>\n    for (int oi = 0; oi < objects_count; oi++)\n    {\n        float glow = 0.0;\n        for (int pi = 0; pi < objects[oi].points_count; pi++)\n            if (objects[oi].point_track[pi])\n            {\n\n                float dst2 = len2(uv - objects[oi].points[pi]);\n\n                dst2 *= distfactor;\n                if (dst2 > 1e-3)\n                    glow += 1.0 / dst2;\n                else\n                    glow += 1000.0;\n            }\n        col += glow*objects[oi].color;\n    }\n    // <<\n\t\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = 0.95*data + vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 2321]], "test": "untested"}
{"id": "3djfWW", "name": "Big Rubik Pseudosolver", "author": "dr2", "description": "Big (Rubik's Revenge) or small cubes; each shuffle is different (only pretending to solve)", "tags": ["cube", "puzzle"], "likes": 10, "viewed": 446, "published": 3, "date": "1590068902", "time_retrieved": "2024-07-30T21:05:49.983990", "image_code": "// \"Big Rubik Pseudosolver\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define SIZE4  1  // =1 for 4^3 cube; =0 for 3^3\n\n#define AA     0  // optional antialiasing\n\nmat3 VToRMat (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Hashff (float p);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 vuMat;\nvec2 qBlk;\nfloat tCur, dstFar, bSize, rSeed;\nconst float pi = 3.1415927;\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 p, mat3 m)\n{\n  vec3 rdm, v, tm, tp, u, fcBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  rdm = m * rd;\n  v = (m * ro - p) / rdm;\n  tp = bSize / abs (rdm) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < min (df, dMin)) {\n    dMin = dn;\n    fcBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rdm;\n  }\n  if (dMin < dstFar) {\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\n#if SIZE4\nconst float nbE = 4.;\nconst float nTwist = 28.;\n#else\nconst float nbE = 3.;\nconst float nTwist = 22.;\n#endif\n\nmat3 RotSeq (vec3 bId, float nt, float aRot)\n{                     // Derived rotation matrix sequence from Kali's \"Rubik\"\n  mat3 rMat, m;\n  vec3 ax[3], vSlice;\n  vec2 e;\n  float s, sa;\n  e = vec2 (1., 0.);\n  ax[0] = e.xyy;\n  ax[1] = e.yxy;\n  ax[2] = e.yyx;\n  rMat = mat3 (e.xyy, e.yxy, e.yyx);\n  for (float n = float (VAR_ZERO); n < nTwist; n ++) {\n    if (n > nt) break;\n    s = mod (n + floor (6. * Hashff (99. + rSeed)), 6.);\n    sa = sign (s - 2.5);\n    s = mod (s, 3.);\n    vSlice = (s == 0.) ? e.xyy : ((s == 1.) ? e.yxy : e.yyx);\n    if (length ((bId + 0.5 * (nbE + 1.)) * vSlice) - 1. == floor (nbE * Hashff (n + rSeed))) {\n      m = VToRMat (sa * ((s == 0.) ? ax[0] : ((s == 1.) ? ax[1] : ax[2])),\n         0.5 * pi * ((n < nt) ? 1. : aRot));\n      for (int k = 0; k < 3; k ++) ax[k] = m * ax[k];\n      rMat = m * rMat;\n      if (n < nt) bId = VToRMat (sa * vSlice, -0.5 * pi) * bId;\n    }\n  }\n  return rMat;\n}\n\nfloat LabSym (vec2 p)\n{\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatH;\n  vec4 col4, bs4;\n  vec3 col, vn, ltDir, fcBlk, bId, bidH, cc[6], de3, ld, bLab;\n  vec2 qBlkH, de;\n  float dstBlk, dstSphr, d, nt, tCyc, shSpd, tWait, aRot, dSum, sSum, bMin;\n  cc[0] = vec3 (1., 0.2, 0.2);\n  cc[1] = vec3 (1., 0.4, 0.2);\n  cc[2] = vec3 (0.2, 0.2, 1.);\n  cc[3] = vec3 (0.2, 1., 0.2);\n  cc[4] = vec3 (1., 1., 0.2);\n  cc[5] = vec3 (1., 1., 1.);\n  bSize = 0.48;\n  shSpd = 10.;\n  tWait = 3.;\n  tCyc = (nTwist + tWait) * (1. + 1. / shSpd) + tWait;\n  nt = nTwist - max (0., mod (tCur, tCyc) - tWait);\n  if (nt + tWait < 0.) nt = - shSpd * (nt + tWait);\n  aRot = smoothstep (0.1, 0.9, max (0., fract (nt) * sign (nt)));\n  nt = max (0., floor (nt));\n  rSeed = 17.77 * floor ((tCur + (nTwist + tWait) / shSpd + tWait) / tCyc + 1.);\n  bMin = 0.5 * (nbE - 1.) - 0.5;\n  bLab = vec3 (0., 0., -1.);\n  if (nbE == 4.) bLab -= 0.5;\n  dstBlk = dstFar;\n  for (float j = float (VAR_ZERO); j < nbE * nbE * nbE; j ++) {\n    bId = vec3 (mod (j, nbE), mod (floor (j / nbE), nbE), floor (j / (nbE * nbE))) - 0.5 * (nbE - 1.);\n    if (Maxv3 (abs (bId)) > bMin) {\n      rMat = RotSeq (bId, nt, aRot);\n      bs4 = BlkHit (ro, rd, bId, rMat);\n      d = bs4.x;\n      if (d < dstBlk) {\n        dstBlk = d;\n        fcBlk = bs4.yzw;\n        rMatH = rMat;\n        qBlkH = qBlk;\n        bidH = bId;\n      }\n    }\n  }\n  bs4 = SphHit (ro, rd, (nbE - 0.2) * bSize);\n  dstSphr = bs4.x;\n  if (min (dstBlk, dstSphr) < dstFar) {\n    if (dstBlk < dstSphr) {\n      ro += dstBlk * rd;\n      de = smoothstep (-0.08, 0., abs (qBlkH.xy) - bSize);\n      de3 = vec3 (0.25 * pi * de * sign (qBlkH.xy), 0.);\n      vn = normalize (fcBlk + ((fcBlk.x != 0.) ? de3.zxy : ((fcBlk.y != 0.) ? de3.xzy : de3))) * rMatH;\n      if (length (max (abs (qBlkH) - bSize + 0.12, 0.)) < 0.07) {\n        if (abs (bidH.x) > bMin && sign (bidH.x) == fcBlk.x ||\n            abs (bidH.y) > bMin && sign (bidH.y) == fcBlk.y ||\n            abs (bidH.z) > bMin && sign (bidH.z) == fcBlk.z) {\n          if      (abs (fcBlk.x) == 1.) col4.rgb = (fcBlk.x > 0.) ? cc[0] : cc[1];\n          else if (abs (fcBlk.y) == 1.) col4.rgb = (fcBlk.y > 0.) ? cc[2] : cc[3];\n          else if (abs (fcBlk.z) == 1.) col4.rgb = (fcBlk.z > 0.) ? cc[4] : cc[5];\n          col4 = vec4 (mix (col4.rgb, vec3 (0.2, 0.2, 0.2), max (de.x, de.y)), 0.2);\n        } else {\n          col4 = vec4 (0.1, 0.1, 0.1, 0.);\n        }\n        if (bidH == bLab && sign (bidH.z) == fcBlk.z)\n           col4 *= 1. - 0.6 * smoothstep (-0.05, 0., LabSym (-16. * (vec2 (0.5, 0.5) * bSize + qBlkH.yx)));\n      } else {\n        col4 = vec4 (0.2, 0.2, 0.2, 0.2);\n      }\n    } else if (dstSphr < dstFar) {\n      ro += dstSphr * rd;\n      vn = bs4.yzw;\n      col4 = vec4 (0.1, 0.1, 0.1, 0.);\n    }\n    dSum = 0.;\n    sSum = 0.;\n    ltDir = normalize (vec3 (1., 1., -0.6));\n    for (int j = 0; j < 4; j ++) {\n      ltDir.xy = Rot2D (ltDir.xy, 0.5 * pi);\n      ld = vuMat * ltDir;\n      dSum += pow (max (dot (vn, ld), 0.), 1.5);\n      sSum += pow (max (dot (normalize (ld - rd), vn), 0.), 32.);\n    }\n    col = col4.rgb * (0.2 + 0.5 * dSum) + col4.a * sSum;\n    col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  } else {\n    col = vec3 (0.6);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.04 * pi * tCur;\n    el -= 0.07 * pi * (1. + sin (0.05 * pi * tCur));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10. * nbE / 3.);\n  zmFac = 3.7;\n  dstFar = 100.;\n  if (length (uv) < 0.99) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = mix (vec3 (0.6), vec3 (0.82), smoothstep (0., 0.1, length (uv) - 0.99));\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djfWW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[511, 511, 559, 559, 1028], [1030, 1030, 1073, 1073, 1274], [1396, 1396, 1442, 1518, 2316], [2318, 2318, 2341, 2341, 2740], [2742, 2742, 2777, 2777, 5945], [5947, 5947, 6003, 6003, 7137], [7139, 7139, 7171, 7171, 7547], [7549, 7549, 7585, 7585, 7791], [7793, 7793, 7823, 7823, 7936], [7938, 7938, 7960, 7960, 7998], [8000, 8000, 8022, 8022, 8060], [8094, 8094, 8118, 8118, 8155]], "test": "untested"}
{"id": "3s2BWW", "name": "Spooky Gyration 2", "author": "workingclasshacker", "description": "Learning more and more every day!", "tags": ["gyroidraymarching"], "likes": 2, "viewed": 351, "published": 3, "date": "1590067991", "time_retrieved": "2024-07-30T21:05:50.791831", "image_code": "// Based on Art_of_code's youtube tutorial on Gyroids.\n// https://www.youtube.com/watch?v=-adHIyjIYgk\nprecision mediump float;\n\n#define MAX_STEPS 100\n#define SURFACE_DIST.001\n#define MAX_DIST 200.\n\nfloat sdSphere(vec3 p, vec4 sphere){\n  return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdBox(vec3 p, vec3 box){\n  p = abs(p)-box;\n  return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)),0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias, float xamp, float yamp){\n    p *= scale;\n    return abs(dot(sin(p)*xamp, cos(p.zxy)*yamp)-bias)/scale-thickness;\n}\nfloat GetDist(vec3 p){\n  //float box = sdSphere(p, vec4(vec3(0),3.4));\n  // p = abs(p);\n  float box = sdBox(p-vec3(0,0,0), vec3(2.5));\n  //float planed=p.y;\n  float t = iTime/12.;\n  float gyroid = sdGyroid(p, 10., min(.12,.1*sin(iTime)+.11), -1.4,2.*sin(t), cos(t));\n  // float gyroid2 = sdGyroid(p-.1, 21.);\n\n  float d = max(box, gyroid*.7);\n  // d = max(d-.05, gyroid2);\n  return d;\n}\n\nvec3 GetNormal(vec3 p){\n  vec2 e=vec2(.01,0);\n  float d=GetDist(p);\n  vec3 n=d-vec3(GetDist(p-e.xyy),GetDist(p-e.yxy),GetDist(p-e.yyx));\n  return normalize(n);\n}\n\nmat4 RotationX(float angle){\n  return mat4(1.,0,0,0,\n    0,cos(angle),-sin(angle),0,\n    0,sin(angle),cos(angle),0,\n  0,0,0,1);\n}\n\nmat4 RotationY(float angle){\n  return mat4(cos(angle),0,sin(angle),0,\n  0,1.,0,0,\n  -sin(angle),0,cos(angle),0,\n0,0,0,1);\n}\n\nmat4 RotationZ(float angle){\n  return mat4(cos(angle),-sin(angle),0,0,\n    sin(angle),cos(angle),0,0,\n    0,0,1,0,\n    0,0,0,1);\n}\n\nmat2 Rot2d(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n  float dO=0.;\n  for(int i=0;i<MAX_STEPS;i++){\n    vec3 p=ro+dO*rd;\n    float ds=GetDist(p);\n    dO+=ds;\n    if(dO<SURFACE_DIST||dO>MAX_DIST){\n      break;\n    }\n  }\n  return dO;\n}\n\nfloat GetLight(vec3 p){\n  mat4 r = RotationY(iTime);\n  vec4 lpos=vec4(1,2,3,1)*r;\n  \n  vec3 l=normalize(lpos.xyz-p);\n  vec3 n=GetNormal(p);\n  float diff=dot(n,l)*.5+.5;\n  float d=RayMarch(p+n*.02,l);\n  if(d<length(lpos.xyz-p)){\n    diff*=.4;\n  }\n  return diff;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  vec3 color=vec3(0);\n  \n  float t = iTime/10.;\n  // camera\n  vec3 ro = vec3(0, 3, -2);\n  \n    ro.yz *= Rot2d(t*3.14+1.);\n    ro.xz *= Rot2d(t*6.2831);\n  \n\n  vec3 rd=GetRayDir(uv, ro, vec3(0),1.);\n\n  // trace scene\n  float d=RayMarch(ro,rd);\n\n  // material\n  vec3 p=ro+rd*d;\n  vec3 n = GetNormal(p);\n  float diffuse=GetLight(p);\n  float o=0.;\n  color=vec3(diffuse-o);\n  color.rg += n.xy*.2-d*.05;\n  fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2BWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 234, 234, 276], [278, 278, 308, 308, 389], [391, 391, 480, 480, 570], [571, 571, 593, 658, 957], [959, 959, 982, 982, 1120], [1122, 1122, 1150, 1150, 1251], [1253, 1253, 1281, 1281, 1376], [1378, 1378, 1406, 1406, 1508], [1510, 1510, 1531, 1531, 1607], [1609, 1609, 1641, 1641, 1822], [1824, 1824, 1847, 1847, 2086], [2088, 2088, 2138, 2138, 2333], [2335, 2335, 2391, 2391, 2878]], "test": "untested"}
{"id": "wsBBWD", "name": "Spiral galaxy", "author": "mrange", "description": "Spiral galaxy\nWould benefit from anti-aliasing but looks okish when I run it in fullscreen in FF\nLots of random coding and little thought so the code is kind of messy", "tags": ["raytracing"], "likes": 56, "viewed": 1822, "published": 3, "date": "1590057425", "time_retrieved": "2024-07-30T21:05:51.630588", "image_code": "// License CC0: Spiral galaxy\n//  Would benefit from anti-aliasing but looks okish when I run it in fullscreen in FF\n//  Lots of random coding and little thought so the code is kind of messy\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TIME (iTime*0.1)\n\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n\n#define SABS(x,k)    LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define RESOLUTION   iResolution\n\nconst float twirly =2.5;\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat noise1(vec2 p) {\n  float s = 1.0;\n\n  p *= tanh(0.1*length(p));\n  float tm = TIME;\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5)+tm);\n  float d = cos(p.y*sqrt(1.5)+tm);\n\n  return a*b*c*d;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 twirl(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*twirly + a;\n  p = toRect(pp);\n  \n  p *= z;\n  \n  return p;\n}\n\nfloat galaxy(vec2 p, float a, float z) {\n  p = twirl(p, a, z);\n  \n  return noise1(p);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    //get the vector from the center of this circle to where the ray begins.\n    vec3 m = ro - center.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n    float b = dot(m, rd);\n\n    float c = dot(m, m) - radius*radius;\n\n    //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n    if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n\n    //calculate discriminant\n    float discr = b * b - c;\n\n    //a negative discriminant corresponds to ray missing sphere\n    if(discr < 0.0) return vec2(-1.0);\n\n    //ray now found to intersect sphere, compute smallest t value of intersection\n    float normalMultiplier = 1.0;\n    float s = sqrt(discr);\n    float t0 = -b - s;\n    float t1 = -b + s;;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec2(t0, t1);\n}\n\n\nvec3 stars(vec2 p) {\n  float l = length(p);\n\n  vec2 pp = toPolar(p);\n  pp.x /= (1.0+length(pp.x))*0.5;\n  p = toRect(pp);\n\n  float sz = 0.0075;\n  \n  vec3 s = vec3(10000.0);\n    \n  for (int i = 0; i < 3; ++i) {  \n    rot(p, 0.5);\n    vec2 ip = p;\n    vec2 n = mod2(ip, vec2(sz));\n    float r = rand(n);\n    vec2 o = -1.0 + 2.0*vec2(r, fract(r*1000.0));\n    s.x = min(s.x, length(ip-0.25*sz*o));\n    s.yz = n*0.1;\n  }\n  \n  return s;\n}\n\nfloat height(vec2 p) {\n  float ang = atan(p.y, p.x);\n  float l = length(p);\n  float sp = mix(1.0, pow(0.75 + 0.25*sin(2.0*(ang + l*twirly)), 3.0), tanh(6.0*l));\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  for (int i = 0; i < 11; ++i) {\n    float g = a*galaxy(p, TIME*(0.025*float(i)), f);\n    s += g;\n    a *= sqrt(0.45);\n    f *= sqrt(2.0);\n    d += a;\n  }\n  \n  s *= sp;\n  \n  return SABS((-0.25+ s/d), 0.5)*exp(-5.5*l*l);\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(0.000125, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nconst vec3 colDust = vec3(1.0, 0.9, 0.75);\n\nvec3 galaxy(vec2 p, vec3 ro, vec3 rd, float d) {\n  rot(p, 0.5*TIME);\n\n  float h = height(p);\n  vec3 s = stars(p);\n  float th = tanh(h);\n  vec3 n = normal(p);\n  \n  vec3 p3 = vec3(p.x, th, p.y);\n  float lh = 0.5;\n  vec3 lp1 = vec3(-0.0, lh, 0.0);\n  vec3 ld1 = normalize(lp1 - p3);\n  vec3 lp2 = vec3(0.0, lh, 0.0);\n  vec3 ld2 = normalize(lp2 - p3);\n\n  float l = length(p);\n  float tl = tanh(l);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n//  col += vec3(0.5)*pow(diff1, 20.0);\n  col += 0.25*pow(diff2, 4.0);\n  col += pow(vec3(0.5)*h, n.y*1.75*(mix(vec3(0.5, 1.0, 1.5), vec3(0.5, 1.0, 1.5).zyx, 1.25*tl)));\n//  col += 0.9*vec3(1.0, 0.9, 0.75)*exp(-10*l*l);\n\n\n  float sr = rand(s.yz);\n  float si = pow(th*sr, 0.25)*0.001;\n  vec3 scol = sr*5.0*exp(-2.5*l*l)*tanh(pow(si/(s.x), 2.5))*mix(vec3(0.5, 0.75, 1.0), vec3(1.0, 0.75, 0.5), sr*0.6);\n  scol = clamp(scol, 0.0, 1.0);\n  col += scol*smoothstep(0.0, 0.35, 1.0-n.y);\n  \n  float ddust = (h - ro.y)/rd.y;\n  if (ddust < d) {\n    float t = d - ddust;\n    col += 0.7*colDust*(1.0-exp(-2.0*t));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  float dgalaxy = (0.0 - ro.y)/rd.y;\n  \n  vec3 col = vec3(0);\n  \n  if (dgalaxy > 0.0) {\n    col = vec3(0.5);\n    vec3 p = ro + dgalaxy*rd;\n    \n    col = galaxy(p.xz, ro, rd, dgalaxy);\n  }\n  \n  vec2 cgalaxy = raySphere(ro, rd, vec3(0.0), 0.125);\n\n  float t;\n  \n  if (dgalaxy > 0.0 && cgalaxy.x > 0.0) {\n    float t0 = max(dgalaxy - cgalaxy.x, 0.0);\n    float t1 = cgalaxy.y - cgalaxy.x;\n    t = min(t0, t1);\n  } else if (cgalaxy.x < cgalaxy.y){\n    t = cgalaxy.y - cgalaxy.x;\n  }\n  \n  col += 1.7*colDust*(1.0-exp(-1.0*t));\n  \n  \n  return col;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.7, 2.0)*0.75;\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(-0.5, 1.0, 0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  \n  \n  vec3 col = render(ro, rd);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBWD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[424, 424, 446, 446, 490], [492, 492, 513, 513, 554], [556, 556, 592, 592, 686], [688, 688, 710, 710, 912], [914, 914, 947, 947, 1032], [1034, 1034, 1072, 1072, 1171], [1173, 1173, 1213, 1213, 1260], [1262, 1262, 1282, 1282, 1352], [1355, 1355, 1416, 1493, 2260], [2263, 2263, 2283, 2283, 2694], [2696, 2696, 2718, 2718, 3147], [3149, 3149, 3170, 3170, 3365], [3411, 3411, 3459, 3459, 4559], [4561, 4561, 4592, 4592, 5137], [5140, 5140, 5177, 5177, 5426], [5428, 5428, 5483, 5483, 5940]], "test": "untested"}
{"id": "tdSfWW", "name": "Radiation Visualizations 1", "author": "ttg", "description": "Time-dependent and time-average energy density radiated by oscillating currents.", "tags": ["dipole", "radiation", "radio", "antenna", "quadrupole"], "likes": 33, "viewed": 853, "published": 3, "date": "1590039117", "time_retrieved": "2024-07-30T21:05:52.640887", "image_code": "\n/*\n\nRadiating Sources Visualization\nCopyright 2020 Theron Tarigo\n\nVisualizes EM radiation from oscillating currents\n\n*/\n\nvec4 readctl (int ch, int n) {return vec4(0.);}\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord ) {\n\n  vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n  color = tonemap(color*.6);\n  fragData.rgb = srgbl_to_srgb(color);\n  fragData.rgb += dither(fragCoord);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#ifndef HW_PERFORMANCE\n#define SHADERTOY_COMMON_CHECK\nuniform vec3 iResolution;\n#endif\n\n// Work around Shadertoy changes\n#define iMouse vec4(iMouse.xy,sign(iMouse.z)*abs(iMouse.zw))\n\n// Collection of utilities from old shaders\n\nconst float C_pi = 3.1415927;\n\n////// BEGIN Expression Plotter by ttg https://www.shadertoy.com/view/3t3XWf\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n    } \\\n  }\n////// END Expression Plotter\n\n////// BEGIN text encoding https://www.shadertoy.com/view/Wd2SDt\nconst struct CCDS_T {\n  uint\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CCDS = CCDS_T(\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n0x7fu);\n\n#define U4CHAR4(a,b,c,d) ((CCDS.a)+(CCDS.b<<8)+(CCDS.c<<16)+(CCDS.d<<24))\n\n#define STRING16(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af) )\n\n#define STRING32(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf) )\n\n#define STRING64(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df))\n\n#define STRING80(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df,\\\n  e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df),\\\n      U4CHAR4(e0,e1,e2,e3),U4CHAR4(e4,e5,e6,e7),U4CHAR4(e8,e9,ea,eb),U4CHAR4(ec,ed,ee,ef))\n\n#define DEF_DRAW_STRING(N) \\\nfloat draw_string (sampler2D sampler,                    \\\n                   in vec2 uv, const uint[1+N] string) { \\\n  vec2 gx = dFdx(uv/32.), gy = dFdy(uv/16.);             \\\n  int i = int(uv.x);                                     \\\n  int strlen = min(int(string[0]),N*4);                  \\\n  if (uv.x<0.||i>=strlen) return 0.;                     \\\n  int code = int( (string[i/4+1]>>((i%4)*8)) &0xFFu);    \\\n  if (uv.y<0.||uv.y>1.) return 0.;                       \\\n  uv.x=fract(uv.x)/2.+.25; uv.y=1.-uv.y;                 \\\n  uv+=vec2(code%16,code/16);                             \\\n  return textureGrad(sampler,uv/16.,gx*.5,gy*.5).r;    }\nDEF_DRAW_STRING(4)\nDEF_DRAW_STRING(8)\nDEF_DRAW_STRING(16)\nDEF_DRAW_STRING(20)\n#undef DEF_DRAW_STRING\n////// END text encoding\n\n////// BEGIN spectral color tonemap https://www.shadertoy.com/view/wtGXzm\n/*\n\nSpectral tonemap (closest sRGB approximation without banding)\n\nTrying to render spectral colors into screen space with as little desaturation\nas possible given the white-level, and no color banding.\n\n\nMouse: plot R,G,B and Luminance at a horizontal slice through the image.\nHorizontal lines: limits (0 and 1)\n\nTop: Just enough white added so that color-matching RGB values are nonnegative.\nBottom: No white added, negative values get handled by tonemap.\nIn-between: gradient of white.\n\n\n*/\n\n// srgbl - linear srgb\nvec3 wavelength_to_srgbl (float l_nm ) {\n    if (l_nm<370.||l_nm>780.) return vec3(0.);\n    vec4 l = vec4(1.065, 1.014, 1.839, 0.366);\n    vec4 c = vec4(593.,556.3,449.8, 446.);\n    vec4 s = vec4(.056,.075,.051, .043);\n    if (l_nm<446.) s.a = 0.05; // fix creep from violet back to blue\n    if (l_nm>593.) s.r = 0.062; // fix creep from red back to green\n    vec4 v = (log(l_nm)-log(c))/s;\n    vec4 xyzx = l*exp(-.5*v*v);\n    vec3 xyz = xyzx.xyz+vec3(1,0,0)*xyzx.a;\n    const mat3 xyz_to_rgb = \n      mat3(3.240,-.969,.056, -1.537,1.876,-.204, -0.499,0.042,1.057);\n    vec3 rgb = xyz_to_rgb*xyz;\n    return rgb;\n}\n\nfloat rgb_to_lum (vec3 v) {\n  vec3 w = vec3(.213,.715,.072);\n  return dot(w,v);\n}\n\nvec3 rgb_to_hue (vec3 v) {\n  vec2 hv = mat3x2( 1., 0., -.5, .866, -.5,-.866) * v;\n  float h = atan(hv.y,hv.x);\n  v = .5+.5*cos(h-vec3(0,1,2)/3.*2.*C_pi);\n  v -= -log(dot(vec3(1.),exp(-v*10.)))/10.;\n  v/=rgb_to_lum(v);\n  return v;\n}\n\nfloat rgb_to_sat (vec3 v) {\n  v/=rgb_to_lum(v);\n  vec3 h = rgb_to_hue(v);\n  if (any(isnan(h))) return 0.;\n  // doesn't matter which component of (1-v)/(1-h) is used!\n  return dot(vec3(1./3.), (1.-v)/(1.-h) );\n}\n\nvec3 tonemap (vec3 color) {\n  vec3  hue = rgb_to_hue(color);\n  float sat = rgb_to_sat(color);\n  float lum = rgb_to_lum(color);\n\n  // smooth-clamp\n  sat = -log(exp(-sat*10.)+exp(-10.))/10.;\n\n  /* tonemapping options:\n       - desaturate when very bright\n       - smooth-clamp brightness to a maximum that still\n          allows some color variation                              */\n  sat = sat*(exp(-lum*lum*2.));\n  lum = .8*(1.-exp(-lum));\n\n  color = lum*mix(vec3(1.),hue,sat);\n  return color;\n}\n\nvec3 srgbl_to_srgb(vec3 linearRGB) {\n  // https://www.shadertoy.com/view/4tXcWr\n  // By https://www.shadertoy.com/user/Tynach\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n////// END spectral color tonemap\n\n////// BEGIN best integer hash https://www.shadertoy.com/view/WttXWX\nuint triple32(uint x) {\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n////// END best integer hash\n\nint C_iFrame;\n\nvec3 dither (vec2 fc) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(c.x+(c.y<<10)+(uint(C_iFrame)<<20));\n  uvec3 h = (uvec3(z)>>uvec3(0,8,16))&0xFFu;\n  return vec3(ivec3(h)-128)/128./256.;\n}\n\nvec4 paramdither (vec2 fc, int seed) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(uint(seed)+c.x+(c.y<<10)+(uint(C_iFrame)<<20));\n  uvec4 h = (uvec4(z)>>uvec4(0,8,16,24))&0xFFu;\n  return vec4(ivec4(h)-128)/128.;\n}\n\nvec4 boxmuller (vec4 r) {\n  vec4 v;\n  v.xy = sqrt(abs(2.*log(r.x+1e-4)))*vec2(cos(2.*C_pi*r.y),sin(2.*C_pi*r.y));\n  v.zw = sqrt(abs(2.*log(r.z+1e-4)))*vec2(cos(2.*C_pi*r.w),sin(2.*C_pi*r.w));\n  return v;\n}\n\nconst struct KEYCODES_T {\n  int A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,\n  _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,\n  end;\n} KEYCODES = KEYCODES_T(\n 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,\n 48,49,50,51,52,53,54,55,56,57,\n -1\n);\nconst struct KEYSTATES_T { int DOWN,PRESS,TOGGLE; }\n  KEYSTATES = KEYSTATES_T( 0, 1, 2 );\n\n#define KEYBOARD(NAME,STATE) keyboard(KEYCODES.NAME,KEYSTATES.STATE)\n\nivec4 decodeInteger (vec4 e) {\n    return floatBitsToInt(e)&0x3FFFFFFF;\n}\n\nvec4 encodeInteger (ivec4 d) {\n    return intBitsToFloat((d&0x3FFFFFFF)|0x40000000);\n}\n\nconst ivec2 ctlbuf_size = ivec2(256);\n\nvoid ctlbuf_pack (ivec2 pix, out int ch, out int n) {\n  const int bh = 8;\n  const int bw = ctlbuf_size.y/bh;\n  const int nbx = ctlbuf_size.x/bw;\n  ivec2 block = pix/ivec2(bw,bh);\n  ivec2 bpix  = pix%ivec2(bw,bh);\n  n = bpix.y+bh*bpix.x;\n  ch = block.x+nbx*block.y;\n}\n\nivec2 ctlbuf_unpack(int ch, int n) {\n  if (n<0||n>=ctlbuf_size.x) return ivec2(-1);\n  const int bh = 8;\n  const int bw = ctlbuf_size.y/bh;\n  const int nbx = ctlbuf_size.x/bw;\n  ivec2 block = ivec2(ch%nbx, ch/nbx);\n  ivec2 bpix = ivec2(n/bh, n%bh);\n  return ivec2(bw,bh)*block+bpix;\n}\n\nvec4 readctlch (sampler2D samp, int ch, int n) {\n  ivec2 pix = ctlbuf_unpack(ch,n);\n  if (pix==ivec2(-1)) return vec4(0.);\n  return texelFetch(samp, pix, 0);\n}\n\nstruct ui_win_param {\n  vec2 o,s;\n  vec3 bordercolor;\n  bool header;\n};\n\nconst float ui_win_border = 2.;\nconst float ui_win_header = 10.;\n\nvec2 ui_win_viewsize (ui_win_param p) {\n  return p.s-ui_win_border*2. -\n    vec2(0,p.header?ui_win_header:0.);\n}\n\nbool ui_win_draw ( inout vec3 v, vec2 fc, ui_win_param p,\n    out vec2 vs, out vec2 vc ) {\n  vc = fc-p.o-ui_win_border;\n  vs = ui_win_viewsize(p);\n  if (any(lessThan(fc, p.o)) || any(greaterThan(fc, p.o+p.s))) {\n    return false;\n  }\n  if (any(lessThan(fc, p.o+ui_win_border)) ||\n      any(greaterThan(fc,\n        p.o+p.s-ui_win_border-vec2(0,p.header?ui_win_header:0.)\n      ))) {\n    v = p.bordercolor;\n    return false;\n  }\n  return true;\n}\n\n#define COMMONDEF\nvec4 readctl (int ch, int n);\nivec4 readctli (int ch, int n) { return decodeInteger(readctl(ch,n)); }\n\n#define CTL_MOUSETIME 8,0\n#define CTL_MOUSEEASE 8,1\n#define CTL_FPSAVG 8,2\n#define CTL_PERFAVG 8,3\n#define CTL_RESCHG 8,4\n#define CTL_CHGTIME 8,5\n\n#define CTL_WHICHDEMO 10,0\n#define CTL_SCALE 11,0\n#define CTL_OMEGA 11,1\n#define CTL_SHAPE 11,2\n#define CTL_VIS   11,3\n#define CTL_VIEW  11,4\n\n#define CTLCH_WINGEOM 13\n#define CTLCH_WINMOUSE 14\n#define UI_WINDOWS_MAX 10\n\nui_win_param ui_win_param_read (int wid) {\n  ui_win_param p;\n  vec4 v1 = readctl(CTLCH_WINGEOM, wid*2+0);\n  vec4 v2 = readctl(CTLCH_WINGEOM, wid*2+1);\n  p.o = v1.xy; p.s = v1.zw;\n  p.bordercolor = vec3(.1);\n  p.header = false;\n  return p;\n}\n\nconst int wid_ctls_start = 3;\n\nbool windows_init (int wid, out ui_win_param p) {\n  vec2 Res = iResolution.xy;\n  if (wid==0) p = ui_win_param(Res*vec2(0.,.5),Res*vec2(.6,.5),vec3(.5),false);\n    \n  else if (wid==1) p = ui_win_param(Res*vec2(0.),Res*vec2(.6,.5),vec3(.5),false);\n  else if (wid==2) p = ui_win_param(Res*vec2(.6,0.),Res*vec2(.4,.58),vec3(.5),false);\n  else if (wid>=wid_ctls_start && wid<wid_ctls_start+5) {\n    float n = float(wid-wid_ctls_start)+1.;\n    float hs = .08;\n    float h = .06;\n    p = ui_win_param(Res*vec2(0.61,1.-hs*n),Res*vec2(.21,h),vec3(.5),false);\n  }\n  else return false;\n  return true;\n}\n\n#ifdef SHADERTOY_COMMON_CHECK\nvec4 readctl (int ch, int n) {return vec4(0.);}\n#endif\n", "buffer_a_code": "\n#define CH_SELF iChannel3\n#define CH_KEYB iChannel2\n\nvec4 readctl (int ch, int n) { return readctlch(CH_SELF, ch, n); }\nbool keyboard (int keycode, int evt) {\n  return texelFetch(CH_KEYB, ivec2(keycode,evt), 0).r>.5;\n}\n\nbool winmouse(int wid, inout vec4 f) {\n  if (wid>UI_WINDOWS_MAX) return false;\n  ui_win_param p = ui_win_param_read(wid);\n  vec3 _1;\n  vec2 vs, vc;\n  if (ui_win_draw(_1, iMouse.zw, p, vs, vc)) {\n    ui_win_draw(_1, iMouse.xy, p, vs, vc);\n    vc = max(vec2(0.),min(vec2(vs),vc));\n    f.xy = vc; f.zw = vc / vs;\n    return true;\n  }\n  return false;\n}\n\nvoid mainImage ( out vec4 f, in vec2 fc ) {\n  int ch, n;\n  ctlbuf_pack(ivec2(fc), ch, n);\n  ivec2 chn = ivec2(ch,n);\n  bool init = (iFrame<2);\n  vec4 forig = texelFetch(CH_SELF, ivec2(fc), 0);\n  f = forig;\n  ivec4 d = decodeInteger(forig);\n  // Keyboard\n  if (ch<3) { f = texelFetch(CH_KEYB, ivec2(n,ch), 0); return; }\n  \n  if (ch==CTLCH_WINGEOM) {\n    int wid = n/2;\n    int s = n%2;\n    if (wid>UI_WINDOWS_MAX) return;\n    ui_win_param p;\n    if (windows_init(wid, p)) {\n      if (s==0) f = vec4(p.o,p.s);\n    } else f=vec4(0.);\n  }\n\n  if (ch==CTLCH_WINMOUSE) {\n    int wid = n;\n    winmouse(wid, f);\n  }\n\n  int preset = -1;\n\n  if (init) {preset=1;}\n\n  if (KEYBOARD(_0,PRESS)) preset = 0;\n  if (KEYBOARD(_7,PRESS)) preset = 1;\n  if (KEYBOARD(_8,PRESS)) preset = 2;\n  if (KEYBOARD(_9,PRESS)) preset = 3;\n  if (preset==0) init = true;\n\n  if (chn==ivec2(CTL_MOUSETIME)) {\n    // x: last down, y: last up\n    if (f.x<f.y && iMouse.z>0.) f.x = iTime;\n    if (f.y<f.x && iMouse.z<0.) f.y = iTime;\n    if (init) f.xy = vec2(-101,-100);\n  }\n\n  if (chn==ivec2(CTL_MOUSEEASE)) {\n    float rate = 4.;\n    f.x = mix(f.x, float(iMouse.z>1.), rate*iTimeDelta);\n  }\n\n  if (chn==ivec2(CTL_FPSAVG)) {\n    f.x = 1./mix(1./f.x, iTimeDelta, .02);\n    if (isnan(f.x)) f.x=20.;\n    f.x=clamp(f.x,1.,500.);\n    f.y=max(f.y,f.x);\n    if (readctl(CTL_RESCHG).zw!=readctl(CTL_RESCHG).xy) f.y=f.x;\n  }\n\n  if (chn==ivec2(CTL_RESCHG)) {\n    f.zw = f.xy;\n    f.xy = iResolution.xy;\n  }\n\n  if (chn==ivec2(CTL_CHGTIME)) {\n    f.z = -1.;\n    vec2 mousetime = readctl(CTL_MOUSETIME).xy;\n    if (iResolution.xy!=readctl(CTL_RESCHG).zw || mousetime.y<mousetime.x) {\n      f.x = iTime;\n      f.z = 1.;\n    }\n  }\n\n  if (chn==ivec2(CTL_PERFAVG)) {\n    vec2 fpsavg = readctl(CTL_FPSAVG).xy;\n    float fpstarg = .9*fpsavg.y;\n    f.x *= pow(fpsavg.x/fpstarg,.1);\n    f.x=clamp(f.x,.2,4.);\n    if (init || iTime<1.) f.x=.1;\n  }\n\n  if (chn==ivec2(CTL_WHICHDEMO)) {\n    for (int i=1; i<6; i++) {\n      if (keyboard(48+i,1)) {\n        d.x = i;\n      }\n    }\n    if (init) d.x = 3;\n    if (preset==1) d.x = 2;\n  }\n\n  if (chn==ivec2(CTL_SCALE)) {\n    float rate = 2.;\n    if (KEYBOARD(A,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (KEYBOARD(S,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (init) f.x = 5.;\n    f.x = clamp(f.x, 1e-1, 5.);\n  }\n\n  if (chn==ivec2(CTL_OMEGA)) {\n    winmouse(3, f.zwxy);\n    if (init) f = vec4(.7,0,0,0);\n  }\n\n  if (chn==ivec2(CTL_SHAPE)) {\n    vec4 m;\n    if(winmouse(4, m)) f.x=m.z;\n    if(winmouse(5, m)) f.y=m.z;\n    if (init) f = vec4(0.1,0,0,0);\n  }\n\n  if (chn==ivec2(CTL_VIS)) {\n    vec4 m;\n    if(winmouse(6, m)) f.x=m.z;\n    if(winmouse(7, m)) f.y=m.z;\n    if (init) f = vec4(0.1,0,0,0);\n  }\n    \n  if (chn==ivec2(CTL_VIEW)) {\n    winmouse(2, f.zwxy);\n    if (init) f = vec4(.2,.6,0,0);\n  }\n\n  if (d!=decodeInteger(forig)) f = encodeInteger(d);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n/*\n\nRadiating Sources Visualization\nCopyright 2020 Theron Tarigo\n\nVisualizes EM radiation from oscillating currents\n\n*/\n\nconst float pi = 3.1415927;\nfloat sinc (float x) { return abs(x)<1e-4?1.:sin(x)/x; }\nfloat square (float a) { return a*a; }\nvec2 compmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 compsin(float x){return vec2(cos(x),sin(x));}\nvec2 compexp(vec2 a){return exp(a.x)*compsin(a.y);}\nvec2 compinv(vec2 a){return vec2(1,-1)*a/dot(a,a);}\nfloat comparg(vec2 a){return atan(a.y,a.x);}\nvec2 comppow(vec2 a, float n){return compsin(comparg(a)*n)*pow(length(a),n);}\n\nint getFrame() { return iFrame; }\nvec4 readctl (int ch, int n) { return readctlch(iChannel3, ch, n); }\nbool keyboard (int keycode, int evt) {\n  return texelFetch(iChannel2, ivec2(keycode,evt), 0).r>.5;\n}\n\nvec3 complex_color (vec2 v) {\n  vec2 vn = normalize(v);\n  vec3 cb = vec3(1.) + vec3(1,-.5,-.5)*vn.x + vec3(0.,.866,-.866)*vn.y;\n  return cb/dot(cb,vec3(.213,.715,.072))*dot(v,v);\n}\n\n// mat2x3 represents a complex vec3:\n// left column Real | right column Imag\n\n// vec2 represents a complex scalar\n// x Real | y Imag\n\nmat2x3 compcross(mat2x3 a, vec3 b) {\n  return mat2x3(cross(a[0],b),cross(a[1],b)); }\nmat2x3 compcross(vec3 a, mat2x3 b) { return -compcross(b,a); }\n\nmat2x3 compcross(mat2x3 a, mat2x3 b) {\n  mat2x3 reprod = compcross(a, b[0]);\n  mat2x3 improd = compcross(a, b[1]);\n  return reprod + mat2x3(-improd[1],improd[0]);\n}\n\nvec3 abscomp(mat2x3 a) { return sqrt(a[0]*a[0]+a[1]*a[1]); }\n\nmat2x3 compmul(mat2x3 a, vec2 b) {\n  return mat2x3(a[0]*b.x-a[1]*b.y,a[0]*b.y+a[1]*b.x); }\n  \nvec3 re_compmul(mat2x3 a, vec2 b) {\n  return vec3(a[0]*b.x-a[1]*b.y); }\n\nmat2x3 compmul(vec3 a, vec2 b) {\n  return mat2x3(a*b.x,a*b.y); }\n\nconst float mu0 = 1.;\nconst float c = 1.;\n\nmat2x3 Bp_dJdl (float omega, vec3 R, vec2 dI, vec3 dl) {\n  mat2x3 Jk = compmul(dl, dI);\n  float k = omega/c;\n  return mu0/(4.*pi) *\n    compmul(\n      compcross(R,Jk),\n      compmul(\n        vec2(0,1) * k / dot(R,R),\n        compexp(vec2(0,1)*k*length(R))\n      )\n    );\n  return mat2x3(0.);\n}\n\nmat2x3 Ep_dJdl (float omega, vec3 R, vec2 dI, vec3 dl) {\n  mat2x3 Bp = Bp_dJdl(omega, R, dI, dl);\n  return c*compcross(Bp,R)/length(R);\n}\n\n\nvec2 gfc = vec2(0.);\nvec2 gmouse = vec2(0.);\n\nfloat contour(float v) {\n  return max(0.,1.-abs(fract(v+.5)-.5)/fwidth(v));\n}\n\nstruct fieldparam {\n  float p0, p1, p2;\n};\n\nvoid fields (fieldparam p, int N, vec3 R, out float Sm, out float avgSm) {\n\n  mat2x3 Bp = mat2x3(0.);\n  mat2x3 Ep = mat2x3(0.);\n  \n  float b = .06;\n  vec2 dI = vec2(1,0)/(b*b)*.05;\n  \n  float omega = 1.*exp2(8.*p.p0);\n  \n  /*for (int i=0; i<N; i++) {\n    float sphi = 2.*pi*float(i)/float(N);\n    vec3 r = b*vec3(cos(sphi),sin(sphi),0.);\n    vec3 dl = b*vec3(-sin(sphi),cos(sphi),0.) * 2.*pi/float(N);\n    Bp += Bp_dJdl(omega, R-r, dI, dl);\n    Ep += Ep_dJdl(omega, R-r, dI, dl);\n  }*/\n  \n  /*for (int i=0; i<N; i++) {\n    float f = -.5+float(i)/float(N);\n    for (int is=0; is<2; is++) {\n      float s = float(is*2-1);\n      vec3 r = b*vec3(-.5*s,0.,f);\n      vec3 dl = b*vec3(0.,0.,1.)*s * 1./float(N);\n      Bp += Bp_dJdl(omega, R-r, dI, dl);\n      Ep += Ep_dJdl(omega, R-r, dI, dl);\n    }\n  }*/\n  \n  for (int i=0; i<N; i++) {\n    float f = float(i)/float(N);\n    for (int is=0; is<4; is++) {\n      float s1 = float((is%2)*2-1);\n      float s2 = float((is/2)*2-1);\n      float a1 = p.p1;\n      float a2 = p.p2;\n      vec3 r = b*vec3(-.5*s1*mix(f,1.,a1),0.,-.5*s2*mix(f,1.,a2));\n      vec3 dl = b*vec3(-.5*s1*(1.-a1),0.,-.5*s2*(1.-a2)) * 1./float(N);\n      vec2 dI = compmul(compsin(omega/c*float(i)*length(dl)),dI)*\n                 s1*s2 / length(vec2(1.-a1,1.-a2));\n      Bp += Bp_dJdl(omega, R-r, dI, dl);\n      Ep += Ep_dJdl(omega, R-r, dI, dl);\n    }\n  }\n  \n  float t = 2.*pi*fract(iTime*.4)/omega;\n  vec3 B = re_compmul(Bp, compexp(vec2(0,-1)*omega*t));\n  vec3 E = re_compmul(Ep, compexp(vec2(0,-1)*omega*t));\n  vec3 S = cross(E,B)/mu0;\n  vec3 avgS = abscomp(compcross(Ep,Bp)/mu0/2.);\n  Sm = length(S)/(omega*omega);\n  avgSm = length(avgS)/(omega*omega);\n}\n\nvec3 fieldvis(fieldparam p, vec3 R, float vscale) {\n  float Sm, avgSm;\n  int N = 32;\n  if (length(R)<1.) N=40;\n  fields(p, N, R, Sm, avgSm);\n\n  vec2 visctl = readctl(CTL_VIS).xy;\n\n  vec3 color = vec3(0.);\n  vec3 color_pnow = vscale*Sm*vec3(1.,.5,0.);\n  vec3 color_pavg = vscale*avgSm*vec3(0,.5,1);\n  color_pnow += contour(max(.5,vscale*Sm*10.))*vec3(0,.5,1)*visctl.y;\n  color_pavg += contour(max(.5,vscale*avgSm*20.))*vec3(2,0,0)*visctl.y;\n  color = mix(color_pnow, color_pavg, visctl.x);\n\n  color += .004;\n  return color;\n}\n\nvec3 fieldvol (fieldparam p, vec3 ro, vec3 rd, float vscale) {\n  float f = 0.;\n  rd/=length(rd);\n  const float zmax = 2.;\n  \n  vec2 visctl = readctl(CTL_VIS).xy;\n  \n  const float dcthres = .05;\n  float cthres1 = dcthres;\n  float cthres2 = dcthres;\n  vec3 v = vec3(0.);\n  float z=.5*paramdither(gfc, 0).x;\n  const int maxiter = 128;\n  int niter = min(maxiter,int(.25*float(maxiter)*readctl(CTL_PERFAVG).x));\n  for (int i=0; i<maxiter && i<niter; i++) {\n    vec3 R = ro+z*rd;\n    float zstep = length(R)*4./float(niter)+.01;\n    float Sm, avgSm;\n    fields(p, 4, R, Sm, avgSm);\n    float w = .1/(z*z*z);\n    if (Sm>cthres1) {\n      cthres1 += dcthres;\n      v += w*vec3(1.,.5,0.)*sqrt(1.-visctl.x)*cthres1/dcthres;\n    }\n    if (avgSm*2.>cthres2) {\n      cthres2 += dcthres;\n      v += w*vec3(0.,.5,1.)*sqrt(visctl.x)*cthres2/dcthres;\n    }\n    z+=zstep;\n  }\n  return v;\n}\n\nuint[5] ctllabels(int id) {\n  if (id==0) return STRING16(15, ome,d,sl,c,_,_,_,_,_,_,_,_,_,_,_,_);\n  if (id==1) return STRING16(15, S,h,a,p,e,_,p,a,r,a,m,_,_1,_,_,_);\n  if (id==2) return STRING16(15, S,h,a,p,e,_,p,a,r,a,m,_,_2,_,_,_);\n  if (id==3) return STRING16(15, N,o,w,_,lt,hm,gt,_,A,v,g,pe,_,_,_,_);\n  if (id==4) return STRING16(15, S,h,o,w,_,C,o,n,t,o,u,r,s,_,_,_);\n}\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord ) {\n  gmouse = iMouse.xy/iResolution.xy;  \n  vec2 Res = iResolution.xy;\n  gfc = fragCoord;\n  C_iFrame = iFrame;\n  \n  float scale = readctl(CTL_SCALE).x;\n  \n  fragData = vec4(0.);\n\n  vec3 color = vec3(0.);\n\n  float omegactl = readctl(CTL_OMEGA).x;\n  vec2 shapectl = readctl(CTL_SHAPE).xy;\n  fieldparam p = fieldparam(omegactl,shapectl.x,shapectl.y);\n  \n  ui_win_param win0 = ui_win_param_read(0);\n  ui_win_param win1 = ui_win_param_read(1);\n  ui_win_param win2 = ui_win_param_read(2);\n\n  vec2 vs, vc;\n  if (ui_win_draw(color, fragCoord, win1, vs, vc)) {\n    vec2 uv = (vc - vec2(.5,.5)*vs) / Res.y;\n    uv/=scale/16.;\n    vec3 R = vec3(uv.x, 0., uv.y);\n    color = fieldvis(p, R, 32.);\n  }\n  if (ui_win_draw(color, fragCoord, win2, vs, vc)) {\n    vec2 uv = (vc - vec2(.5,.5)*vs) / Res.y;\n    uv*=1.;\n    vec2 m = readctl(CTL_VIEW).xy;\n    float th = pi*clamp(1.-m.y,.01,.99), phi = 2.*pi*m.x;\n    vec3 ro = vec3(sin(th)*cos(phi),sin(th)*sin(phi),cos(th))*1.;\n    vec3 rc = -normalize(ro);\n    vec3 rx = cross(rc,vec3(0,0,1));\n    vec3 ry = cross(rx,rc);\n    rx = normalize(rx); ry = normalize(ry);\n    vec3 rd = rc+(uv.x*rx+uv.y*ry)/scale*5.;\n    color = fieldvol(p, ro, rd, 32.);\n    vec4 chgctl = readctl(CTL_CHGTIME);\n    if (chgctl.z<0.) {\n      float mixf;\n      if (readctl(CTL_VIS).x<.99) mixf = 4.*iTimeDelta;\n      else mixf = iTimeDelta/(iTime-chgctl.x-iTimeDelta);\n      color = mix(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, color, clamp(mixf,0.,1.));\n    }\n  }\n  if (ui_win_draw(color, fragCoord, win0, vs, vc)) {\n    vec2 uv = (vc - vec2(.5,.5)*vs) / Res.y;\n    uv/=scale;\n    vec3 R = vec3(uv.x, 0., uv.y);\n    color = fieldvis(p, R, .25);\n  }\n  for (int wid=wid_ctls_start; wid<UI_WINDOWS_MAX; wid++) {\n    int ctlid = wid-wid_ctls_start;\n    vec2 vs, vc;\n    if (ui_win_draw(color, fragCoord, ui_win_param_read(wid), vs, vc)) {\n      float v = 0.;\n      if (wid==3) v = readctl(CTL_OMEGA).x;\n      if (wid==4) v = readctl(CTL_SHAPE).x;\n      if (wid==5) v = readctl(CTL_SHAPE).y;\n      if (wid==6) v = readctl(CTL_VIS).x;\n      if (wid==7) v = readctl(CTL_VIS).y;\n      if (v>(vc/vs).x) color += vec3(.2);\n    }\n    vec2 tuv = vc/vs-vec2(1,0);\n    if (abs(tuv.y-.5)<.5 && tuv.x>0. ) {\n      if (ctlid<5)\n      color+=draw_string(iChannel1,tuv*vec2(17,1)-vec2(1.,0), ctllabels(ctlid));\n    }\n  }\n\n  //color = tonemap(color*.6);\n  //fragData.rgb = srgbl_to_srgb(color);\n  //fragData.rgb += dither(fragCoord);\n  fragData.rgb = (color);\n}\n", "buffer_d_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 152, 152, 169], [171, 171, 227, 227, 399]], "test": "untested"}
{"id": "tsBBWW", "name": "Demofox Path Tracing 1", "author": "demofox", "description": "demofox path tracing in shadertoy part 1\nBlog post at: https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/", "tags": ["pathtracing"], "likes": 45, "viewed": 8396, "published": 3, "date": "1590033865", "time_retrieved": "2024-07-30T21:05:53.490615", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 90.0f;\n\n// number of ray bounces allowed\nconst int c_numBounces = 8;\n\n// how many renders per frame - to get around the vsync limitation.\nconst int c_numRendersPerFrame = 1;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emissive;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }\n\t}    \n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.7f, 0.1f, 0.1f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.1f, 0.7f, 0.1f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n        }        \n    }\n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.albedo = vec3(0.9f, 0.9f, 0.75f);\n        hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);        \n    } \n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.albedo = vec3(0.9f, 0.75f, 0.9f);\n        hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);        \n    }    \n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.albedo = vec3(0.75f, 0.9f, 0.9f);\n        hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n    }    \n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    // initialize\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    \n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        // shoot a ray out into the world\n        SRayHitInfo hitInfo;\n        hitInfo.dist = c_superFar;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n        \n        // if the ray missed, we are done\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += texture(iChannel1, rayDir).rgb * throughput;\n            break;\n        }\n        \n\t\t// update the ray position\n        rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        \n        // calculate new ray direction, in a cosine weighted hemisphere oriented at normal\n        rayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));        \n        \n\t\t// add in emissive lighting\n        ret += hitInfo.emissive * throughput;\n        \n        // update the colorMultiplier\n        throughput *= hitInfo.albedo;      \n    }\n \n    // return pixel color\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    \n    // calculate the camera distance\n\tfloat cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);        \n    \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3((fragCoord/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n    // correct for aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n    \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    // raytrace for this pixel\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    for (int index = 0; index < c_numRendersPerFrame; ++index)\n    \tcolor += GetColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n    \n    // average the frames together\n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color = mix(lastFrameColor, color, 1.0f / float(iFrame+1));\n\n    // show the result\n    fragColor = vec4(color, 1.0f);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 163]], "test": "untested"}
{"id": "WsBfWD", "name": "Geological phenomenon", "author": "loicvdb", "description": "Or some sort of evil structure maybe", "tags": ["fractal", "dof", "bloom", "pathtracing"], "likes": 25, "viewed": 881, "published": 3, "date": "1590015331", "time_retrieved": "2024-07-30T21:05:54.331367", "image_code": "vec3 ACESFilm(vec3 x) {\n    \n    // ACES system tone scale (RTT+ODT)\n    const float a = .0245786;\n    const float b = -.000090537;\n    const float c = .983729;\n    const float d = .4329510;\n    const float e = .238081;\n    x = (x*(x+a)+b) / (x*(x*c+d)+e);\n    \n    return x;\n}\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return bloom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.15 * iResolution.y, fragCoord) * .15;\n    bloomSum += bloom(.05 * iResolution.y, fragCoord) * .07;\n    bloomSum += bloom(.02 * iResolution.y, fragCoord) * .03;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = clamp(ACESFilm(fragColor.rgb + bloomSum), vec3(0.), vec3(1.));\n    fragColor.rgb = pow(fragColor.rgb, vec3(.8));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define Bounces 4\n#define MaxSteps 256\n#define SceneRadius 2.\n#define DetailLevel 2.\n#define StepFactor 1.\n\n#define Pi 3.14159265359\n#define ORTHO( v ) abs(v.x)>abs(v.z)?vec3(-v.y,v.x,0.):vec3(0.,-v.z,v.y)\n#define HASH( seed ) fract(cos(seed)*43758.5453)\n#define RANDOM HASH(seed++)\n#define RANDOM2D vec2(RANDOM, RANDOM)\n#define HITDIST( p ) length(p-Cam.pos)/iResolution.y/Cam.focalLength/DetailLevel\n\nstruct Surface {\n    bool metallic;\n    float ior, roughness;\n    vec3 emission, diffuse;\n};\n\nstruct Camera {\n\tvec3 pos, rot;\n\tfloat focalLength, focalDistance, aperture;\n} Cam;\n\nfloat seed;\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nfloat fresnel(vec3 dir, vec3 n, float ior) {\n    float cosi = dot(dir, n);\n    float etai = 1.0;\n  \tfloat etat = ior;\n    if (cosi > 0.0) {\n         float tmp = etai;\n         etai = etat;\n         etat = tmp;\n     }\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if (sint >= 1.0) return 1.0;\n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ORTHO(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = RANDOM2D;\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n// n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation) {\n    \n    float side = sin(Pi / float(nbBlades));\n    vec2 tri = RANDOM2D;\n    if(tri.x-tri.y > 0.0) tri = vec2(tri.x-1.0, 1.0-tri.y);\n    tri *= vec2(side, -sqrt(1.0-side*side));\n    float angle = rotation + 2.*Pi*floor(RANDOM * float(nbBlades))/float(nbBlades);\n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\nvec2 sphereIntersect(vec3 pos, vec3 dir, float radius) {\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - radius * radius;\n    float discriminant = b * b - c;\n    if (discriminant < 0.) return vec2(-1.);\n\tfloat s = sqrt(discriminant);\n    return vec2(-b - s, -b + s);\n}\n\nvoid fold(inout vec3 z, vec3 o, vec3 n) {\n    z -= 2.*n*min(dot(z-o, n), 0.);\n}\n\nfloat sdfIFS(vec3 z, out Surface surf){\n    \n\tfloat scale = 2.;\n    int Iterations = 16;\n    mat3 rot = rotationMatrix(vec3(.5)*Pi);\n    \n    vec3 n1 = normalize(vec3(1., 1., -1.));\n    vec3 n2 = normalize(vec3(1., -1., -1.));\n    //vec3 n3 = normalize(vec3(1., -1., 1.));\n    \n    vec3 ot = vec3(1.);\n    for(int i = 0; i < Iterations; i++) {\n        fold(z, vec3(-.0), n1);\n        fold(z, vec3(-.25), n2);\n        //fold(z, vec3(-.25), n3);\n        n1 *= rot;\n        z = z*scale - sign(z)*(scale-1.0);\n        ot = min(abs(z), ot);\n    }\n    surf = Surface(true, 1.0, .1, vec3(0.), vec3(.8));\n    if(ot.r >= .75) surf = Surface(false, 1., .0, ot.ggb*30.*vec3(12., 2., .5), vec3(0.1));\n    return length(z) * pow(scale, float(-Iterations));\n}\n\n\nfloat sdf(in vec3 pos, out Surface surf) {\n    float sSc = length(pos)-SceneRadius;\n    float s = sdfIFS(pos * rotationMatrix(vec3(.5, .0, .0)*Pi), surf);\n    return abs(sSc) > abs(s) || s > 0. ? s : sSc;\n    \n}\n\nfloat sdf(vec3 pos){\n    Surface surf;\n    return sdf(pos, surf);\n}\n\n\nvec3 normalEstimation(vec3 pos, float hd){\n  vec2 k = vec2(hd, 0);\n  return normalize(vec3(sdf(pos + k.xyy) - sdf(pos - k.xyy),\n\t  \t\t\t\t\tsdf(pos + k.yxy) - sdf(pos - k.yxy),\n  \t\t\t\t\t\tsdf(pos + k.yyx) - sdf(pos - k.yyx)));\n}\n\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 normal, out Surface surf) {\n    vec2 ts = sphereIntersect(pos, dir, SceneRadius);\n    if(sign(ts) != vec2(-1.)) {\n        float t = max(ts.x, 0.);\n        for(int i = 0; i < MaxSteps; i++) {\n            if(t >= ts.y) break;\n            vec3 p = pos+t*dir;\n            float dist = sdf(p, surf);\n            float hd = HITDIST(p);\n            if(dist < hd) {\n                pos += (t-hd*2.) * dir;\n                normal = normalEstimation(pos, hd);\n                return true;\n            }\n            t += dist*StepFactor*(RANDOM*.5+.5);\n        }\n    }\n    pos += ts.y*dir;\n    return false;\n}\n\nvec3 background(vec3 dir) {\n    return vec3(.8, .9, .9);\n}\n\nvec3 pathTrace(vec3 pos, vec3 dir) {\n    Surface surf;\n    vec3 normal, col = vec3(0.), abso = vec3(1.);\n    for(int i = 0; i <= Bounces; i++) {\n        bool t = trace(pos, dir, normal, surf);\n        if(!t) return col + abso * background(dir);\n        vec3 difuseDir = getCosineWeightedSample(normal);\n        vec3 reflectDir = normalize(mix(reflect(dir, normal), difuseDir, surf.roughness));\n        if(surf.metallic){\n            dir = reflectDir;\n            col += abso * surf.emission;\n            abso *= surf.diffuse;\n        } else {\n            float f = fresnel(dir, normal, surf.ior);\n            col += abso * surf.emission * (1.-f);\n            if(RANDOM < f-.1e-7) {\n                dir = reflectDir;\n            } else {\n                dir = difuseDir;\n                abso *= surf.diffuse;;\n            }\n        }\n        if(abso == vec3(0.)) break;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    fragColor = iFrame == 0 ? vec4(0.) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iMouse.z > 0.) fragColor.a = 0.;\n    \n    //comment these lines if you have a good GPU, this is just to avoid timeout on my PC\n    if(sign(fragCoord.x-iResolution.x/2.) != ((iFrame&1)==0?-1.:1.)) return;\n    if(sign(fragCoord.y-iResolution.y/2.) != ((iFrame&2)==0?-1.:1.)) return;\n    \n    seed = sin(float(iFrame)) + cos(fragCoord.x) + sin(fragCoord.y);\n    \n    Cam = Camera(vec3(.0, .0, -.2), vec3(.1, -2.2, 0.), 1.5, .3, .002);\n    Cam.pos *= rotationMatrix(Cam.rot);\n    Cam.pos += vec3(-.5, 1.1, 0.5);\n    \n    vec2 uv = (fragCoord+RANDOM2D-iResolution.xy/2.) / iResolution.y;\n\n    vec3 focalPoint = vec3(uv * Cam.focalDistance / Cam.focalLength, Cam.focalDistance);\n    vec3 aperture = Cam.aperture * vec3(sampleAperture(5, 1.0), 0.0);\n    vec3 dir = normalize(focalPoint-aperture);\n    vec3 pos = aperture;\n    vec3 cdir = vec3(0., 0., 1.);\n\n    mat3 CamMatrix = rotationMatrix(Cam.rot);\n    dir *= CamMatrix;\n    cdir *= CamMatrix;\n    pos = pos*CamMatrix + Cam.pos;\n    \n    vec3 col = max(vec3(0.), pathTrace(pos, dir) * dot(dir, cdir));\n    \n    fragColor.a++;\n    fragColor.rgb = mix(fragColor.rgb, col, 1./fragColor.a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 68, 277], [402, 402, 442, 442, 733], [735, 735, 789, 789, 1207]], "test": "untested"}
{"id": "WdSBWD", "name": "Hypnotic flowers", "author": "ManuManu", "description": "experimenting with flowers / stars ...", "tags": ["2d", "flower"], "likes": 7, "viewed": 570, "published": 3, "date": "1590013839", "time_retrieved": "2024-07-30T21:05:55.079367", "image_code": "\t\t\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b * cos( 2.*3.14159 * ( c * t + d) );\n}\n\nvec3 MyPalette1( float t )\n{\n    return palette( t, vec3(.8, .5, .4), vec3(.2,.4,.2), vec3( .5), vec3( 0., .25, .25));\n}\nvec3 MyPalette2( float t )\n{\n    return palette( t, vec3(.5, .5, 5), vec3(.5, .5, .5), vec3( 1., 0.7,0.4), vec3( 0., .15, .2));\n}\nvec3 MyPalette3( float t )\n{\n    return palette( t, vec3(.5), vec3(.5), vec3( 1.), vec3( 0.3, .2, .2));\n}\nvec3 MyPalette4( float t )\n{\n    return palette( t, vec3(.5), vec3(.5), vec3( 1.,1.,0.5), vec3( 0.8, .9, .3));\n}\nvec3 MyPalette5( float t )\n{\n    return palette( t, vec3(.8, .5, .4), vec3(.2), vec3( .5,.5,0.5), vec3( 0., .9, .3));\n}\n\n// nice palettes from shane :\nvec3 MyPalette6(float t )\n{\n\treturn .8 + .2*cos(6.3*t + vec3(0, 23, 21));\n}\nvec3 MyPalette7(float t )\n{\n\treturn .5 + .4*cos(6.3*t + vec3(2, 1, 0));\n}\nvec3 MyPalette8(float t )\n{\n\treturn .6 + .4*cos(6.*t + vec3(5, 3, 1));\n}\n    // Etc.\n    //vec3 col = .5 + .4*cos(6.3*h21(d.yz) + vec3(2, 1, 0));\n    //vec3 col = .6 + .4*cos(6.*h21(d.yz) + vec3(5, 3, 1));\n\nvec3 Flower( vec2 uv, float paletteShift )\n{\n    vec2 st = vec2( atan(uv.x, uv.y), length(uv ) );\n    uv = vec2( st.x/3.14159 + iTime*.2, st.y);\n\n    float myX = mod (uv.x, .2) -.1;\n    float func = -5.*myX * myX + .2;\n    float val = func - uv.y;\n    \n    val = smoothstep( 0., 0.01, val);\n\n    return val * MyPalette1(uv.y*7. + paletteShift);\n}\n\nvec3 Flower2( vec2 uv, float paletteShift )\n{\n    vec2 st = vec2( atan(uv.x, uv.y), length(uv ) );\n    uv = vec2( st.x/3.14159 + iTime*.2, st.y);\n\n    float myX = mod (uv.x, .2) -.1;\n    float func = -10.*myX * myX + .2;\n    float val = func - uv.y;\n    \n    val = smoothstep( 0., 0.01, val);\n\n    return val * MyPalette3(uv.y*7. + paletteShift);\n}\n\nvec3 flowersField1( vec2 uv)\n{\n    uv = mod( uv, .5 ) - 0.25;\n    vec3 col = vec3(0);\n    \n    float fact = 1.;\n    float paletteShift = 0.;\n    for ( int i = 0; i < 10; i++)\n    {\n        vec3 flowerCol = Flower(uv * fact, paletteShift);\n        if ( length(flowerCol) > 0.)\n            col = flowerCol;\n        fact *= 1.1;\n        paletteShift += 1.5 + iTime*0.1;\n                \n    }\n    return col;\n}\nvec3 flowersField2( vec2 uv)\n{\n    uv = mod( uv, .5 ) - 0.25;\n    vec3 col = vec3(0);\n    \n    float fact = 1.;\n    float paletteShift = 0.;\n    for ( int i = 0; i < 10; i++)\n    {\n        vec3 flowerCol = Flower2(uv * fact, paletteShift);\n        if ( length(flowerCol) > 0.)\n            col = flowerCol;\n        fact *= 1.1;\n        paletteShift += 1.5 + iTime*0.1;\n                \n    }\n    return col;\n}\nmat2 rot( float a )\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c, s, -s, c);\n}\nvec2 moveUV( vec2 uv, float angle, float zoom, vec2 dep )\n{\n    return rot( angle ) * ( ( uv * zoom) + dep );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv  = (uv - .5)*2.;\n    uv.x  *= iResolution.x / iResolution.y;\n    \n    vec2 realUv = uv;\n\tvec3 col = length(uv*.3) *vec3(0.3,0.3,0.8);\n\n    // general camera move :\n    uv = moveUV( uv, sin(iTime*.2), .28+.13*sin(iTime*.51), vec2(cos(iTime*.001), sin(iTime*.00039)));\n\n    \n    \n    float fact = 1.;\n    const float factInc = 1.3;\n    for( float i = 0.; i < 2.; i+=1.)\n    {\n        vec2 p = moveUV( uv, sin(iTime*.2), fact, vec2(cos(iTime*.011), sin(iTime*.007)));\n    \tvec3 flower1 = flowersField1(p);\n        if (length(flower1) > 0. )\n            col = flower1;\n        p = moveUV( uv, sin(iTime*.2), fact*factInc, vec2(cos(iTime*.001), sin(iTime*.007)));\n\t\tvec3 flower2 = flowersField2(p*fact*factInc);\n        if (length(flower2) > 0. )\n            col = flower2;\n        fact = fact * factInc * factInc;\n        \n    }\n    \n    // Output to screen\n    col*=smoothstep(2.4,1.,length(realUv));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 60, 60, 115], [117, 117, 145, 145, 237], [238, 238, 266, 266, 367], [368, 368, 396, 396, 473], [474, 474, 502, 502, 586], [587, 587, 615, 615, 706], [708, 738, 765, 765, 813], [814, 814, 841, 841, 887], [888, 888, 915, 915, 960], [1095, 1095, 1139, 1139, 1441], [1443, 1443, 1488, 1488, 1791], [1793, 1793, 1823, 1823, 2200], [2201, 2201, 2231, 2231, 2609], [2610, 2610, 2631, 2631, 2708], [2709, 2709, 2768, 2768, 2820], [2823, 2823, 2880, 2930, 3908]], "test": "untested"}
{"id": "3s2BWh", "name": "Julia Glassblower 2", "author": "xjorma", "description": "Julia rotation around the center.\n\nRevisited version of https://www.shadertoy.com/view/tdjczh\n", "tags": ["julia", "glass", "revolute"], "likes": 27, "viewed": 693, "published": 3, "date": "1590013010", "time_retrieved": "2024-07-30T21:05:55.817394", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_BOUNCES     3\n#define MAX_DIST\t\t200.\n#define ABSORB\t\t\tvec3(1., 0.1, .3)\n\nconst int maxIterations = 4;\nconst float majorRadius = 4.;\n\n#define AieKick\n\n// http://www.imajeenyus.com/mathematics/20121112_distance_estimates/distance_estimation_method_for_fractals.pdf\n\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 csqr(vec2 v)\n{\n    return vec2(v.x * v.x - v.y * v.y, 2. * v.x * v.y );\n}\n\n#ifndef AieKick \n\nfloat julia2d(vec2 z, vec2 c)\n{\n    vec2 dz = vec2(1, 0);\n    for (int i = 0; i < maxIterations; i++)\n    {\n        dz = 2. * cmul(z, dz);\n        z = csqr(z) + c;\n        if(dot(z,z) > 4.)\n            break;\n    }\n    return length(z) * log(length(z)) / length(dz);\n}\n\n#else\n\n// AieKick distance fonction is faster\n\nfloat julia2d(vec2 z, vec2 c)\n{\n\tfloat k = 1., h = 1.;    \n    for (int i = 0;i < 5; i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.)\n            break;\n\t\tz = csqr(z) + c;\n    }\n\treturn sqrt(k / h) * log(k);\n}\n\n#endif\n\nfloat map(vec3 p)\n{\n\tfloat\ta = atan(p.x, p.z);\n    vec2\tc = 0.7 * vec2(mix(sin(iTime*0.592), sin(iTime*0.352), sin(a * 4.)), mix(sin(iTime*0.485), sin(iTime*0.625), sin(a * 3.)));     \n    float\tr = length(p.xz) - majorRadius;\n\treturn  julia2d(vec2(r, p.y), c);\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    return col*col;\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 300; i++)\n  {\n    float h = sgn * map(ro + rd * t);\n    t += h * 0.2;\t\t\t\t\t\t// Perf killer :(\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.001\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float sgn = 1.;\n    float cref = 0.7;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.9;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        float t = rayMarch(sgn, ro, rd, 0.02);\n        if( t> MAX_DIST)\n        {\n            col += rel * getSkyColor(rd);\n            break;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * t);\n        vec3 p = ro + rd * t;\n        vec3 n = sgn * calcNormal(p);\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n\tcol = pow(col, vec3(0.8));\n\tcol = contrast(col, 1.2);\n\tcol = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 genMat(in vec3 dir,in vec3 up)\n{\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5); // + iTime*.2;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 10. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd);\n        \n\n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2BWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[461, 461, 488, 488, 553], [555, 555, 574, 574, 633], [1205, 1205, 1224, 1224, 1468], [1470, 1470, 1497, 1497, 1562], [1565, 1565, 1634, 1634, 1835], [2393, 2393, 2430, 2430, 3671], [3673, 3673, 3716, 3716, 3774], [3776, 3776, 3820, 3820, 3919], [3921, 3921, 3963, 3963, 4063], [4066, 4066, 4108, 4108, 4272], [4274, 4274, 4311, 4311, 4447]], "test": "untested"}
{"id": "3sBfDW", "name": "Psychedelic flower", "author": "codecontemplator", "description": "Psychedelic flower", "tags": ["2d"], "likes": 0, "viewed": 383, "published": 3, "date": "1590008701", "time_retrieved": "2024-07-30T21:05:56.566391", "image_code": "#define PI 3.14159265359\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat circle(in vec2 p, in float r ) {\n    return length(p) - r;\n}\n\nfloat map(in vec2 p){    \n    float d1 = sdEquilateralTriangle(p*0.5);\n    float d2 = sdStar5(p*0.1, 1.0, 0.4);\n    float d3 = sdStar5(p*0.2, 1.0, 0.4);\n    //float d4 = sdHorseshoe(p-vec2(2.0,-0.1), vec2(0.4, -1.5), 1.5, vec2(0.750,0.25));\n    float d4 = circle(p, 8.);\n    return min(min(d1, max(d2,-d3)), -d4);\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2.0))*2.0 - vec2(1.0);\n  return c;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=vec3(0.15+0.85*pow(29.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7));  // vigneting\n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 uv = -1. + 2. * q;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float sc = 25.0;\n    vec2 p = uv*sc;\n    p = toSmith(p);\n    p = p + 0.7;\n    p = rotate(p, iTime*0.05*PI);\n    p = fromSmith(p);\n    p = toPolar(p);\n    \n    modMirror2(p, vec2(150, 2.*PI/16.));\n    p = toRect(p);\n    modMirror2(p, vec2(15, 15));\n    p = rotate(p, iTime*0.05*PI);\n    float d = map(p + vec2(0.4, 0)) / sc;\n    \n    float r = smoothstep(0.0, 0.001, d);\n    float g = smoothstep(0.0, 0.01, d);\n    float b = smoothstep(0.0, 1.0, d);\n    \n    vec3 color = vec3(r, g ,b);\n    color += mix(vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),0.5+0.5*sin(d*200.))*(0.5+0.5*sin(d*2000.));\n    //color = 1.0 - color;\n    color = postProcess(color, q);\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 49, 129, 268], [270, 270, 295, 374, 513], [515, 515, 545, 545, 641], [643, 643, 695, 695, 814], [816, 816, 853, 853, 933], [935, 935, 977, 977, 1188], [1190, 1190, 1241, 1241, 1619], [1621, 1621, 1687, 1687, 1946], [1948, 1948, 1986, 1986, 2014], [2016, 2016, 2037, 2037, 2331], [2333, 2333, 2354, 2354, 2399], [2401, 2401, 2423, 2423, 2467], [2469, 2469, 2511, 2511, 2675], [2677, 2677, 2720, 2720, 2977], [2981, 2981, 3038, 3038, 3837]], "test": "untested"}
{"id": "WsSfDW", "name": "pixel perlin noise", "author": "TheNosiriN", "description": "something random", "tags": ["procedural", "noise", "grid", "perlinnoise", "grayscale"], "likes": 4, "viewed": 266, "published": 3, "date": "1590006988", "time_retrieved": "2024-07-30T21:05:57.302423", "image_code": "#define _PerlinPrecision 0.2\n#define _PerlinOctaves 2.0\n#define _PerlinSeed 1.0\n#define RES 20.0\n\n\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\nfloat inter(float a, float b, float x)\n{\n    //return a*(1.0-x) + b*x; // Linear interpolation\n\n    float f = (1.0 - cos(x * 3.1415927)) * 0.5; // Cosine interpolation\n    return a*(1.0-f) + b*f;\n}\nfloat perlin(vec2 uv)\n{\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta---b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|   |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc---d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\n\nfloat grid(vec2 fragCoord, float space, float gridWidth)\n{\n    vec2 p  = fragCoord - vec2(.5);\n    vec2 size = vec2(gridWidth - .5);\n    \n    vec2 a1 = mod(p - size, space);\n    vec2 a2 = mod(p + size, space);\n    vec2 a = a2 - a1;\n       \n    float g = min(a.x, a.y);\n    return clamp(g, 0., 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/RES;\n\t\n    uv = floor(uv) + iTime;\n    \n    float col = perlin(uv);\n    \n    col *= clamp(grid(fragCoord, 20.0, 2.0), 0.0, 1.0);\n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 119, 119, 226], [227, 227, 267, 321, 424], [425, 425, 448, 448, 1195], [1198, 1198, 1256, 1256, 1498], [1501, 1501, 1558, 1558, 1759]], "test": "untested"}
{"id": "3sSfDW", "name": "Fireish calejdoskop", "author": "codecontemplator", "description": "Just testing", "tags": ["2d"], "likes": 7, "viewed": 491, "published": 3, "date": "1590006589", "time_retrieved": "2024-07-30T21:05:58.044439", "image_code": "#define PI 3.14159265359\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat circle(in vec2 p, in float r ) {\n    return length(p) - r;\n}\n\nfloat map(in vec2 p){    \n    float d1 = sdEquilateralTriangle(p*0.5);\n    float d2 = sdStar5(p*0.1, 1.0, 0.4);\n    float d3 = sdStar5(p*0.2, 1.0, 0.4);\n    //float d4 = sdHorseshoe(p-vec2(2.0,-0.1), vec2(0.4, -1.5), 1.5, vec2(0.750,0.25));\n    float d4 = circle(p, 8.0);\n    return min(min(d1, max(d2,-d3)), -d4);\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2.0))*2.0 - vec2(1.0);\n  return c;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=vec3(0.15+0.85*pow(29.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7));  // vigneting\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 uv = -1. + 2. * q;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float sc = 25.0;\n    vec2 p = uv*sc;\n    p = toPolar(p);\n    modMirror2(p, vec2(150., 2.*PI/16.));\n    p = toRect(p);\n    modMirror2(p, vec2(15., 15.));\n    p = rotate(p, iTime*0.5*PI);\n    float d = map(p + vec2(0.4, 0)) / sc;\n    \n    float r = smoothstep(0.0, 0.001, d);\n    float g = smoothstep(0.0, 0.01, d);\n    float b = smoothstep(0.0, 0.1, d);\n    \n    vec3 color = vec3(r, g ,b);\n    //color = 1.0 - color;\n    color = postProcess(color, q);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 56, 56, 152], [154, 154, 206, 206, 325], [327, 327, 364, 364, 444], [446, 446, 488, 488, 699], [701, 701, 752, 752, 1130], [1132, 1132, 1198, 1198, 1457], [1459, 1459, 1497, 1497, 1525], [1527, 1527, 1548, 1548, 1843], [1845, 1845, 1866, 1866, 1911], [1913, 1913, 1935, 1935, 1979], [1981, 1981, 2023, 2023, 2187], [2189, 2189, 2232, 2232, 2489], [2492, 2492, 2549, 2549, 3154]], "test": "untested"}
{"id": "3sjBRm", "name": "Rectangularity", "author": "abelu", "description": "A bunch of rotated and scaled rectangulars", "tags": ["rectangles"], "likes": 5, "viewed": 460, "published": 3, "date": "1590000130", "time_retrieved": "2024-07-30T21:05:58.782466", "image_code": "#define PI      \t3.14159265359\n#define QUARTER_PI \t0.78539816339\n\nfloat lineSegment(\n    vec2 point, \n    vec2 pointA, \n    vec2 pointB,\n    float width\n) {\n    vec2 pa = point - pointA;\n    vec2 ba = pointB - pointA;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\n    return smoothstep(width, 0.0, length(pa - ba * h));\n}\n\nfloat rect(\n    vec2 point, \n    float size, \n    float startAngle,\n    float lineWidth,\n    float index\n) {\n    float angle = startAngle;\n    float nextAngle = 0.;\n    float angleStep = PI / 2.;\n    float color = 0.;\n\n    for (int i = 0; i < 4; i++) {\n        nextAngle = angle + angleStep;\n        \n        color += lineSegment(\n            point, \n            vec2(cos(angle) * size, sin(angle) * size), \n            vec2(cos(nextAngle) * size, sin(nextAngle) * size),\n            lineWidth\n        );\n        \n        angle = nextAngle;\n    }\n    \n    return color;\n}\n\nfloat getSize(float size, float R, float iteration) {\n\treturn size * pow(\n        R,\n        iteration\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.xy - vec2(0.5);\n    \n    float d = 32. + sin(iTime) * 16.;\n    float deltaAngle = PI / d * (0.5 + 0.5 * sin(iTime * 0.5));\n    float R = sin(QUARTER_PI) / cos(QUARTER_PI - deltaAngle);\n    float D = pow(R, d / 2.);\n    float lineWidth = 1. / iResolution.x * 2.;\n    \n    float size = 0.5 / D;// + mod(iTime, 0.5 / (D * D) - 0.5 / D);\n\n    float color = 0.;\n    float angle = -iTime * 0.6;\n    \n    for (float i = 0.; i < 100.0; i += 1.) {\n        color += rect(\n            st, \n            getSize(size, R, i), \n            angle, \n            lineWidth,\n            i\n        );\n        angle += deltaAngle;\n    }\n\n    fragColor = vec4(\n        color * (.5 + sin(iTime * 0.3) * .5 - length(st)),\n        color * (.5 + cos(iTime * 0.5) * .5 - length(st)),\n        color * (.5 + sin(iTime * 1.2) * .5 - length(st)),\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 156, 156, 332], [334, 334, 442, 442, 905], [907, 907, 960, 960, 1018], [1020, 1020, 1075, 1075, 1948]], "test": "untested"}
{"id": "wdBfW1", "name": "Audio Visualizer MB", "author": "MarvelousBilly", "description": "WARNING: FLASHING LIGHTS\n\nJust a little project I wanted to work on for a while now and it was a lot easier than I thought\n\nUpdate: improved the random flashing lights to not repeat as often, due to bad randomizing.", "tags": ["sound", "music", "vis", "visualizer", "audiovisualizer"], "likes": 6, "viewed": 491, "published": 3, "date": "1589994692", "time_retrieved": "2024-07-30T21:05:59.527474", "image_code": "//for decay and attack rates, look in Buf A\n\nint barWidth = 1; //width of each bar,each bar uses the left most value inside it's bar\n\nvec3 color(float w){\n    float b = 1.-smoothstep(0. ,1.,w);\n    float g = smoothstep(-0.5,0.61,w);\n    if(w > 0.61){\n        g = 1.-smoothstep(0.61,1.,w);\n    }\n    float r = smoothstep(0.,1.,w);    \n    return vec3(r,g,b);\n}\n\nvec3 colForm(vec2 fragC){\n    vec3 col;\n    vec2 fragCoord = fragC;\n    \n    float bass;\n    bass =  texelFetch( iChannel0, ivec2(0,0), 0 ).x;\n    bass += texelFetch( iChannel0, ivec2(1,0), 0 ).x;\n    bass += texelFetch( iChannel0, ivec2(2,0), 0 ).x;\n    bass /= 6.; //average bass from first 3 values\n    bass = max(0.3,bass);\n    \n    //draw particle\n    if(bass >= 0.43){\n    \n        float T = iTime;\n        T = floor(T+(bass/10.));\n        \n        float width = iChannelResolution[1].x;\n        \n        vec2 index  = vec2(mod(float(bass+T),width),    floor(float(bass+T) / width));\n        vec2 indexP = vec2(mod(float(bass+T+1.),width), floor(float(bass+T+1.) / width));\n        \n        vec2 A = texelFetch( iChannel1, ivec2(index), 0 ).rg * iResolution.xy;\n        vec2 AP = texelFetch( iChannel1, ivec2(indexP), 0 ).rg * iResolution.xy;\n\n        vec2 B = texelFetch( iChannel1, ivec2(index), 0 ).gb * iResolution.xy;\n        vec2 BP = texelFetch( iChannel1, ivec2(indexP), 0 ).gb * iResolution.xy;\n\n        vec2 C = texelFetch( iChannel1, ivec2(index), 0 ).rb * iResolution.xy;\n        vec2 CP = texelFetch( iChannel1, ivec2(indexP), 0 ).rb * iResolution.xy;\n\n        vec2 posA = mix(A, AP, smoothstep(0.,1.,mod(iTime, 1.1)));\n        vec2 posB = mix(B, BP, smoothstep(0.,1.,mod(iTime, 1.1)));\n        vec2 posC = mix(C, CP, smoothstep(0.,1.,mod(iTime, 1.1)));\n\n\t\tcol = vec3(1.-distance(fragC, posA)/(bass*posA.x),1.-distance(fragC, posB)/(bass*posB.x),1.-distance(fragC, posC)/(bass*posC.x));\n        col = max(col,-0.65);\n    }\n    \n    fragC -= iResolution.xy/2.; //translate to center\n    fragC *= (bass*2.)+(0.7/1.75); //scale\n    fragC += iResolution.xy/2.; //translate back\n    \n    fragC = max(fragC,0.); //clamp the bars and extend them if zoomed out\n    fragC = min(fragC,iResolution.xy-vec2(1.,0.)); \n    \n    //avoid weird length bars\n    if(barWidth > 1){\n    \tfragC = floor(fragC); \n    }\n    \n    vec2 BarFragC = fragC;\n    BarFragC.x -= float(int(BarFragC.x) % barWidth); //strech each bar to be barWidth wide\n    \n    vec2 uv = BarFragC / iResolution.xy;\n    \n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    float fft;\n    float wave;\n    // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n    fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    // second row is the sound wave, one texel is one mono sample\n    wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n        \n    if(uv.y < fft/1.3){ //if showing bar, smooth color transition\n        return col + color(fft);\n    }\n    else{ //if not showing bar, draw circle (which uses the wave)\n        float bassCircSize = distance(fragCoord, iResolution.xy/2.) - (iResolution.x/2. * wave * bass); //circle size in bg\n        if(bassCircSize < 1.){ //if pixel contains circle,\n           return min(vec3(1.),col + vec3(0.8));\n        }\n        else{ //if background\n        \treturn col;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //generate bars\n    vec3 col = colForm(fragCoord);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Current song: https://soundcloud.com/teresa-tesla/operation-pyrite-arknights\n// Operation Pyrite (Arknights) - Monster Siren Records; Jason Walsh; Alan Day\n\nfloat decay = 0.02;\nfloat attack = 0.1;\nbool doDecay = true;\nbool doAttack = true;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y == 0.5){\n        vec4 ffv = texelFetch( iChannel0, ivec2(fragCoord), 0 ); \n        vec4 ffvP = texelFetch( iChannel1, ivec2(fragCoord), 0);\n        if(ffv.x < ffvP.x && doDecay){ //if new value is less than previous value (i.e. value decreases)\n            if(ffvP.x - decay >= ffv.x){ //if decreasing previous value by decay does not reach the new value,\n            \tffv.x = ffvP.x - decay; //set the new value to the decayed value\n            }\n        }\n        else if(ffv.x > ffvP.x && doAttack){ //if new value is more than previous value (i.e. value increases)\n            if(ffvP.x + attack <= ffv.x){ //if raising the previous value by attack does not surpass the new value,\n            \tffv.x = ffvP.x + attack; //set the new value to the increased value\n            }\n        }\n\n        fragColor = ffv;\n    }\n    if(fragCoord.y == 1.5){ //return wave as-is\n        vec4 wave = texelFetch( iChannel0, ivec2(fragCoord), 0 ); \n        fragColor = wave;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35508, "src": "https://soundcloud.com/teresa-tesla/operation-pyrite-arknights", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 154, 154, 359], [361, 361, 386, 386, 3294], [3296, 3296, 3353, 3376, 3473]], "test": "untested"}
{"id": "tsjfDh", "name": "EasyGrid", "author": "smkgames", "description": "EasyGrid", "tags": ["easygrid"], "likes": 3, "viewed": 1912, "published": 3, "date": "1589982005", "time_retrieved": "2024-07-30T21:06:00.265501", "image_code": "float size = 5.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 tiledUV = fract(uv*size);\n    vec2 square = abs(tiledUV*2.-1.);\n    vec2 sharpSquare = step(0.8,square);\n    float result = sharpSquare.x+sharpSquare.y;\n\n    fragColor = vec4(1.0)*result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 75, 75, 314]], "test": "untested"}
{"id": "tdjBDh", "name": "mandelb", "author": "workingclasshacker", "description": "simple implmentation", "tags": ["fractal"], "likes": 3, "viewed": 329, "published": 3, "date": "1589978932", "time_retrieved": "2024-07-30T21:06:01.236903", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\n#define MAXITER 1210\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv = uv*0.5-sin(iTime)-vec2(.05,0.);\n    float t = iTime * .0015;\n\tfloat angle = t;    \n    uv *= rotate2d(angle);\n    float scale = 1.5;\n    uv *= 1.-sin(scale);\n    uv.x -= scale * (sin(scale)/2.+.03);\n    uv.y -= scale * (sin(scale)/5.-.30);\n\tvec2 c = uv;\n    vec2 z = c;\n    int escape = 0;\n    for(int i = 0;i<MAXITER;i++){\n\t\tfloat tempx = z.x*z.x - z.y * z.y + c.x;\n        z.y = 2. * z.x * z.y + c.y;\n        z.x = tempx;\n        if(length(z)>2.){\n           escape = i;\n            break;\n        }\n    }\n    \n    float sl = (float(escape) + log2(length(z)))/float(MAXITER);\n    vec3 col = vec3(sin(sl)*2.*cos(iTime), sin(sl)/3.,cos(sl)/4.);\n    col += sl;\n    if(length(z)<2.0){\n      col = vec3(1.);   \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 97]], "test": "untested"}
{"id": "Ws2BW1", "name": "Hatched Complex Spaces", "author": "FabriceNeyret2", "description": "reproducing Erlend Robaye's  [url]https://www.facebook.com/groups/procgenart/permalink/1991283661002453/[/url]\n\ntune amount of AA ( NxN samples ).\nNB: you can stop play: no animation ! :-)\n", "tags": ["fractal", "complex"], "likes": 15, "viewed": 473, "published": 3, "date": "1589957352", "time_retrieved": "2024-07-30T21:06:01.978919", "image_code": "// reproducing Erlend Robaye's https://www.facebook.com/groups/procgenart/permalink/1991283661002453/\n\n#define AA 1    // antialiasing\n#define N  10   // NxN subsamples\n\n// --- complex op from https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\n#define CS(a)        vec2( cos(a), sin(a) )\n//#define cart2pol(U)  vec2( length(U), atan((U).y,(U).x) )\n#define pol2cart(U) ( (U).x * CS( (U).y ) )\n#define cmod(Z)      length(Z)\n#define carg(Z)      atan( (Z).y, (Z).x )\n#define cmul(A,B)  ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define cinv(Z)    ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n#define cdiv(A,B)    cmul( A, cinv(B) )\n//#define cpow(Z,v)    pol2cart( vec2( pow(cmod(Z),v) , (v) * carg(Z) ) )\n#define cpow(A,B)    cexp( cmul( B, clog(A) ) )\n#define cexp(Z)      pol2cart( vec2( exp((Z).x), (Z).y ) )\n#define clog(Z)      vec2( log(cmod(Z)), carg(Z) )\n#define imul(Z)      vec2(-(Z).y,(Z).x)\n#define csin(Z)    ( -.5* imul( cexp(imul(Z)) - cexp(-imul(Z)) ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R  = iResolution.xy, z;\n    float s = 1.8 / R.y;                // scale\n    z = ( (u-(R-R.y)/2.) * s + vec2(-.2,2.2) ) ; // x = -0.2..1.65  y = 2.2 .. 4\n    O = vec4(0);  \n    if ( z.x < -.2 || z.x > 1.65 ) return;\n    \n#if AA\n  for( int k=0; k<N*N; k++) {\n    vec2 z = z + (vec2(k%N,k/N)-.5*float((N+1)/2)) / float(N) * s;\n#endif\n        \n    for (int i=0; i<4; i++) \n        z = cdiv( cexp(z) , z );          // 4x z = (e^z)/z\n        \n    z = cdiv( csin(z) , z-vec2(1,0) );    //    z = sin(z) / (z-1)\n\n    for (int i=0; i<4; i++)                                      // should simplifies to\n        z = cpow( z, vec2(1,6) );         // 4x z = z^(1+6i)     //   z^(1+6i)⁴\n        \n#if 0\n    if ( cmod(z) < .1 ) O++;              // could do this intead of following (pretty close)\n#else\n    z = cdiv( cexp(z) , z );              //    z = (e^z)/z      // should simplifies to\n \n    z = clog( z );                        //    z = log(z)       //   z -= log(z)\n // if ( cmod(z) < exp(45.) &&   cmod(z) > exp(-45. )) O++;      // could do this intead of clog\n\n // O += vec4(!isnan(cmod(z)) && !isinf(cmod(z)));  // white if defined, otherwise black\n    if (cmod(z) < 45. ) O++;                        // simplifies to this\n#endif\n      \n#if AA\n  }\n  O /= float(N*N);                        // average subpixels\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2BW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3d2BDz", "name": "Stochastic ray marching ", "author": "michael0884", "description": "Can be used to render any implicit surface!\nWASD to move", "tags": ["random", "marching"], "likes": 22, "viewed": 696, "published": 3, "date": "1589934107", "time_retrieved": "2024-07-30T21:06:02.900456", "image_code": "//Shading \n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nfloat cos_step(float x, float a, float b)\n{\n    x = clamp((x-a)/(b-a), 0., 1.);\n    return 0.5-0.5*cos(PI*x);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    INIT\n    \n    ivec2 pi = ivec2(pos);\n    vec2 uv = (pos - R*0.5)/max(R.x,R.y);\n    \n    vec2 angles = get(ANGLE).xy;\n \tvec3 r = getRay(angles, uv);\n    vec3 p = get(POS).xyz;\n    \n    vec4 B = texel(ch1, pi);\n    float td = B.x;\n\n    p += r*td;\n    float DE = map(p);\n   \n    col.xyz = vec3(0.);\n    \n    \n    #define rescale 0.7\n    \n    if(DE > 5.*td*LOD) //sky\n    {\n        col.xyz = sky(r);\n    }\n    else\n    {\n        \n        vec4 n = normal(p, 2.*td*LOD);\n    \tmat a = mat(color(p), vec3(0), 0.5,0.);\n        \n        vec3 ld = light_d;\n        col.xyz += 10.*cos_step(B.z, -0.00, 0.02)*BRDF(-r, ld, n.xyz, a);\n        //fake GI\n        ld = normalize(mix(ld, n.xyz, 0.5));\n        col.xyz += 0.7*cos_step(B.z, -0.1*rescale, 0.1)*BRDF(-r, ld, n.xyz, a);\n        col.xyz += 0.3*cos_step(B.z, -0.2*rescale, 0.2)*BRDF(-r, ld, n.xyz, a);\n        col.xyz += 0.35*cos_step(B.z, -0.8, 0.8)*BRDF(-r, ld, n.xyz, a);\n\n      \n        col.xyz *= sky(vec3(1.,0.,0.));\n    }\n   // col.x = log(0.5*td+1.);\n   // col.y = 100.*max(abs(DE) - LOD*td,0.)*td;\n    col = vec4(HDRmapping(col.xyz, 6.),1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define bilin(a, p) texture(a, p/R, 0)\n#define get(i)  texelFetch(iChannel0, ivec2(i, 0), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n\n//random iterations\n#define RIT 4\n//marches per iteration \n#define MPI 2\n//shadow steps per iteration \n#define SMPI 2\n\n#define dt 0.001\n\n\n\n\n#define MAXD 256.\n#define MAXI 256\n#define MIND 0.0000001\n#define FOV 2.3\nfloat LOD;\nfloat time;\nvec2 R;\n\n//stochastic optimization score\nfloat score(float td, float d)\n{\n    return (td<0.)?1e10:(td + 60.*max(abs(d), LOD*td)/LOD);\n}\n\n#define INIT time = iTime; R = iResolution.xy; \\\n\t\tLOD = 1./max(iResolution.x,iResolution.y); \\\n        fshift = get(FRACSHIFT).xyz;\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n\n#define light_d vec3(sin(1.4)*cos(0.5+0.*iTime),sin(1.4)*sin(0.5+0.*iTime),cos(1.4))\n#define N_instructions 9.\n\n#define MOUSE 0\n#define ANGLE 1\n#define POS   2\n#define VEL   3\n#define LIGHT 4\n#define SPEED 5\n#define PREVANGLE 6\n#define PREVPOS 7\n#define FRACSHIFT 8\n\n/*//fractal terrain\nconst int fracit = 20;\nconst float iFracScale = 1.6;\nconst float iFracAng1 = 2.7315;\nconst float iFracAng2 = -0.2082;\nconst vec3 iFracShift = vec3(-8.92, 3.66, 5.49);\nconst vec3 iFracCol = vec3(0.3, 0.3, -0.2);\n*/\n//how much does the terrain change in large scale\n#define PERLIN_SCALE 2\n/*\n\n//Everest\nconst int fracit = 10;\nconst float iFracScale = 1.9151;\nconst float iFracAng1 = -9.8300;\nconst float iFracAng2 = -1.1600;\nconst vec3 iFracShift = vec3(-2.56, -4.53, 2.94);\nconst vec3 iFracCol = vec3(1.97, 0.11, -0.31);\n*/\nvec3 fshift;\n\n\n//mega citadel \nconst int fracit = 16;\nconst float iFracScale = 1.4731;\nconst float iFracAng1 = 0.0;\nconst float iFracAng2 = 0.0;\nconst vec3 iFracShift = vec3(-10.4, 3.28, -1.90);\nconst vec3 iFracCol = vec3(1.f, 1.f, 1.f);\n\n\n\n\n//////Random number generation part\n#define INIT_RAND(pos) seed = vec4(pos.xy, iFrame, PI*iTime); sp = pos;\n#define BLUE(pos) texture(iChannel3, pos);\nvec2 sp;\nvec4 seed;\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat rand()\n{\n    seed.x = hash11(seed.x);\n    return seed.x;\n}\n\nvec2 rand2()\n{\n    seed.xy = hash22(seed.xy);\n    return seed.xy;\n}\n\n\nvec4 rand4() \n{\n    seed = hash44(seed);\n    return seed;\n}\n\n//normally distributed random numbers\nvec2 randn2()\n{\n    vec2 rand = rand2();\n    vec2 box_muller = sqrt(-2.*min(log(max(rand.x,1e-10)), 0.))*vec2(sin(2.*PI*rand.y),cos(2.*PI*rand.y));\n    return box_muller;\n}\n\nvec4 randn4()\n{\n    vec4 rand = rand4();\n    vec2 l1 = sqrt(-2.*min(log(max(rand.xy,1e-10)), 0.));\n    vec4 angular = vec4(sin(2.*PI*rand.z), cos(2.*PI*rand.z), sin(2.*PI*rand.w), cos(2.*PI*rand.w));\n\treturn l1.xxyy*angular;\n}\n\nvec4 perlin_octave(vec2 p)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 a = vec2(0.,1.);\n   \n   vec4 a00 = hash42(pi+a.xx);\n   vec4 a01 = hash42(pi+a.xy);\n   vec4 a10 = hash42(pi+a.yx);\n   vec4 a11 = hash42(pi+a.yy);\n   \n   vec4 i1 = mix(a00, a01, pfc.y);\n   vec4 i2 = mix(a10, a11, pfc.y);\n   \n   return mix(i1, i2, pfc.x);  \n}\n\nmat2 rotat = mat2(cos(0.5), -sin(0.5), sin(0.5), cos(0.5));\n\nvec4 perlin4(vec2 p)\n{\n\tfloat a = 1.;\n\tvec4 res = vec4(0.);\n\tfor(int i = 0; i < PERLIN_SCALE; i++)\n\t{\n\t\tres += a*(perlin_octave(p)-0.5);\n        //inverse perlin\n\t\tp *= 0.6*rotat;\n\t\ta *= 1.2;\n\t}\n\treturn res;\n}\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat sdSph( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvoid mengerFold(inout vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\n\n\n\nfloat sdFract(vec3 p)\n{\n     p.xyz = p.xzy;\n  //  vec3 p0 = p.xyz;\n    float scale = 1.;\n    float c1 = cos(iFracAng1); float c2 = cos(iFracAng2);\n    float s1 = sin(iFracAng1); float s2 = sin(iFracAng2);\n\tmat2 rmZ = mat2(c1, s1, -s1, c1);\n\tmat2 rmX = mat2(c2, s2, -s2, c2);\n    \n    //p.xz = mod(p.xz + vec2(0.5), vec2(1.)) - vec2(0.5); \n\t//vec4 perlin1 = perlin4(p0.xz);\n\tvec3 shift = fshift;// + 0.35*perlin1.xyz;\n    \n\tfor (int i = 0; i < fracit; i++)\n    {\n\t\tp = abs(p);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale;\n        scale *= iFracScale;\n\t\tp += shift;\n\t}\n\treturn sdBox(p, vec3(6.))/scale;\n}\n\nvec3 col_fractal(vec3 p) \n{\n     p.xyz = p.xzy;\n    vec3 orbit = vec3(0.);\n\tfloat scale = 1.;\n    float c1 = cos(iFracAng1); float c2 = cos(iFracAng2);\n    float s1 = sin(iFracAng1); float s2 = sin(iFracAng2);\n\tmat2 rmZ = mat2(c1, s1, -s1, c1);\n\tmat2 rmX = mat2(c2, s2, -s2, c2);\n\tfor (int i = 0; i < fracit; i++)\n    {\n\t\tp = abs(p);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale;\n        scale *= iFracScale;\n\t\tp += iFracShift;\n        orbit = max(orbit, p*iFracCol);\n\t}\n\treturn tanh(abs(orbit));\n}\n\nvec3 Aarr[4] = vec3[4](vec3(0.5,0,0), vec3(0,1,0), \n                       vec3(0,0,0.3), vec3(0.4,-0.4,1.));\nvec3 Barr[4] = vec3[4](vec3(1,0,-1), vec3(-1.3,0.5,0), \n                       vec3(-0.4,-0.5,-0.7), vec3(-0.4,-0.2,0.3));\n\n//divergence free field\nvec3 CurlF(vec3 p)\n{\n    p *= 6.;\n\tvec3 A = vec3(0);\n    vec3 B = vec3(0);\n    loop(i, 4)\n    {\n        A += Aarr[i]*sin(dot(Aarr[i], p))/dot(Aarr[i],Aarr[i]);\n        B += Barr[i]*cos(dot(Barr[i], p))/dot(Barr[i],Barr[i]);\n    }\n    return cross(A,B);\n}\n\n#define H 0.0*sin(time*0.4)\n\nfloat map(vec3 p)\n{\n    //advection through a field\n    loop(i, 2)\n    {\n        p += H*CurlF(p);\n    }\n    \n    float d = sdFract(p);\n    return d;\n}\n\nvec4 normal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\tvec4 r = k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx);\n    //the normal and the averaged distance\n    return vec4(normalize(r.xyz), r.w*0.25);\n}\n\nvec3 color(vec3 p)\n{\n   return col_fractal(p);\n}\n\nstruct mat\n{\n    vec3 albedo;\n    vec3 emiss;\n    float rough;\n    float metal;\n};\n\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat NGGX(vec3 n, vec3 h, float a)\n{\n    float a2 = sqr(a);\n    return a2/(PI*sqr( sqr( max(dot(n,h),0.) )*(a2-1.) + 1.));\n}\n\nfloat GGX(vec3 n, vec3 o, float a)\n{\n    float ndoto = max(dot(n,o),0.);\n    return ndoto/mix(1., ndoto, sqr(a+1.)*0.125);\n}\n\nfloat GS(vec3 n, vec3 i, vec3 o, float a)\n{\n    return GGX(n,i,a)*GGX(n,o,a);\n}\n\nvec3 IR(float D, float k0, vec3 k1)\n{\n    //interference effect here ->\n    return (0.25+ k0*( 1. - cos(2.*PI*pow(vec3(D), -k1)) ))/D ;\n}\n\nvec3 BRDF(vec3 i, vec3 o, vec3 n, mat m)\n{\n    vec3 h = normalize(i + o);\n    vec3 F0 = mix(vec3(0.04), m.albedo, m.metal);\n    vec3 FS = F0 + (1.0 - F0) * pow(1.0 - max(dot(h, i), 0.0), 5.0);\n    vec3 DFG = NGGX(n,h,m.rough)*GS(n,i,o,m.rough)*FS;\n    float denom = max(dot(n, i), 0.001) * max(dot(n, o), 0.001);\n    return (m.albedo*(1.-FS)/PI +\n            DFG*IR(denom, 0.1, vec3(1.,1.1,1.2)))*max(0., dot(n,o));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\nvec3 sky(vec3 r)\n{\n    vec3 c = vec3(.009, .288, .828);\n\tc = mix(vec3(1.), c, .9);\n\tc *= .5;\n    float atmo = tanh(10.*(r.z-0.05))*0.4 + 0.5 + 0.1*r.z;\n    \n    vec3 g = vec3(atmo);  \n    vec3 A0 = pow(c, g);\n    vec3 B0 = 1.-pow(vec3(1.)-c, 1.-g);\n    \n    vec3 A = A0*(1.-A0);\n    vec3 B = B0*(1.-B0);\n    \n    return mix(A, B, g);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\n\n\n///Newton marching\n\nfloat btd; \nfloat bsc;\n\n\n//camera ray\nvoid march(vec3 p, vec3 r, float td0, float td1)\n{\n    float d1 = 0., d0 = map(p + td0*r) - 1.*td0*LOD;\n    loop(j, MPI)\n    {\n        d1 = map(p + td1*r) - 1.*td1*LOD;\n        float dx = td1 - td0;\n        td0 = td1;\n        td1 -= 1.*d1 * dx / (d1 - d0); //secant method\n        d0 = d1;\n    }\n\n    //score found intersection\n    float csc = score(td1, d1);\n\n    if(csc < bsc)\n    {\n        btd = td1;\n        bsc = csc;\n    }\n}\n\n//shadow marching \nvoid smarch(vec3 p, vec3 r, float td)\n{\n    float d0 = 0., d1 = 0.;\n    loop(j, SMPI)\n    {\n        d0 = map(p + (td-dt)*r);\n        d1 = map(p + (td+dt)*r);\n        td -= 0.001*td*LOD*(d1 - d0)/dt ; //gradient descent\n        if(td > MAXD) break;\n    }\n\n    //score found angle\n    float angle = 0.5*(d0+d1)/td;  \n\n    if(angle < bsc && td > 0.)\n    {\n        btd = td;\n        bsc = angle;\n    }\n}\n\n\n//usual marching \n\nfloat march1(vec3 p, vec3 r)\n{\n    float td = 0.;\n    float d;\n    for(int i = 0; i < MAXI; i++)\n    {\n        d = map(p + td*r);\n        if(d <= LOD*td) break;\n        if(td > MAXD) \n        {\n            break;\n        }\n        td += d;\n    }\n    td += d - LOD*td; //better surface\n    return td; //position and ID\n}\n\n\n\n\n\n//prev frame pos reprojection\n\nmat3 rmat;\nvec3 ppos;\n", "buffer_a_code": "/// UTILITY\n///\n/// Using the GPU as the CPU here\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INIT  \n    fragColor = vec4(0.);\n    if(fragCoord.x <= N_instructions && fragCoord.y <= 1.)\n    {\n        INIT_RAND(fragCoord);\n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = get(I);\n        vec4 mouse = get(MOUSE);\n        vec2 mousespeed = mouse.xy;\n        vec4 angles = get(ANGLE);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = get(POS);\n        vec4 vel = get(VEL);\n\t\tvec4 speed = get(SPEED);\n        vec4 norm = normal(posit.xyz, MIND);\n        \n        switch(I)\n        {\n        case MOUSE:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n    \t\tfragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(0.,0.2);\n            }\n            break;\n            \n        case POS:  //position\n            fragColor.xyz += vel.xyz*speed.x;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(0.,-11.,6.);\n            }\n           \n            break;\n         case VEL:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            fragColor.xyz *= 0.8; //slowing down\n            \n            //fractal collision detection, removing the normal velocity component \n          \t//fragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/0.04);\n            break;\n          case SPEED: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = CAMERA_SPEED;\n            }\n            break; \n          case PREVANGLE:\n            fragColor = angles;\n            break;\n          case PREVPOS:\n            fragColor = posit;\n            break;\n          case FRACSHIFT:\n            if(isKeyPressed(KEY_P))\n   \t   \t\t{\n            \tfragColor.x += 0.01;   \n            }\n            if(isKeyPressed(KEY_O))\n   \t   \t\t{\n                fragColor.x -= 0.01;\n            }\n            \n            if(isKeyPressed(KEY_L))\n   \t   \t\t{\n            \tfragColor.y += 0.01;   \n            }\n            if(isKeyPressed(KEY_K))\n   \t   \t\t{\n                fragColor.y -= 0.01;\n            }\n            \n            if(isKeyPressed(KEY_M))\n   \t   \t\t{\n            \tfragColor.z += 0.01;   \n            }\n            if(isKeyPressed(KEY_N))\n   \t   \t\t{\n                fragColor.z -= 0.01;\n            }\n           \n            if(iFrame < 1)\n            {\n                fragColor = vec4(iFracShift, 0.);\n            }\n        }   \n    } else discard; \n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//stochastic ray marching pass 1\nvec2 reprojection(vec3 p)\n{\n    vec3 dp = normalize(p - ppos);\n    float zp = FOV*dot(dp, rmat[1]);\n    vec2 prj = max(R.x,R.y)*zp*vec2(dot(dp, rmat[0]), dot(dp, rmat[2]))/(0.001+zp*zp);\n    return clamp(prj + R*0.5, vec2(0.), R); \n}\n\nfloat randomarch(vec3 p, vec3 r)\n{  \n    btd = 1e10; bsc = 1e10;\n    float ptd_guess = texel(ch1, sp).x;\n    vec2 prev_p = reprojection(ppos + r*ptd_guess);\n    float CAMd = distance(ppos, p);\n    float LODd = 10.*LOD*ptd_guess + MIND;\n    float gtd = texel(ch1, prev_p).x;\n    march(p, r, gtd - LODd-CAMd, gtd-CAMd);\n    loop(i, RIT)\n    {\n        vec4 rn4 = randn4();\n        int d = (i + 2*iFrame + int(sp.x + sp.y))%4;\n        //depth guess\n        ivec2 pp = ivec2(prev_p) + cross_distribution(d + i*int(4.*abs(rn4.x)));\n        gtd = (1. - 0.05*float(i)*abs(rn4.x))*texel(ch1, pp).x; \n        march(p, r, gtd - LODd - CAMd, gtd - CAMd);\n        prev_p = reprojection(p + r*btd);\n    }\n    \n    return btd;\n}\n\nfloat shadowmarch(vec3 p, vec3 r)\n{  \n    btd = 1e10; bsc = 1e10;\n    vec2 prev_p = reprojection(p);\n    smarch(p, r, texel(ch1, prev_p).y);\n    loop(i, RIT)\n    {\n        vec4 rn4 = randn4();\n        //depth guess\n        ivec2 pp = ivec2(prev_p) + cross_distribution(i +  int(16.*abs(rn4.x)));\n        float gtd = (1. - 0.4*rn4.y)*texel(ch1, pp).y;\n        smarch(p, r, gtd);\n    }\n    \n    return btd;\n}\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    INIT\n    INIT_RAND(pos);\n    \n    rmat = transpose(getCamera(get(PREVANGLE).xy));\n    ppos = get(PREVPOS).xyz;\n    \n   \tivec2 pi = ivec2(pos);\n    vec2 uv = (pos - R*0.5)/max(R.x,R.y);\n    \n    vec2 angles = get(ANGLE).xy;\n \tvec3 r = getRay(angles, uv);\n    vec3 p = get(POS).xyz;\n    \n   \n    float td = randomarch(p, r);\n   \n    p += (1. - 2.*LOD)*td*r;\n    \n    float DE = map(p);\n    float tds = 0.;\n   \n    if(DE > 3.*td*LOD) //use old shadow data if surface is not converged\n    {\n        vec2 prev_p = reprojection(p);\n        vec2 pp = texel(ch1, prev_p).yz;\n        tds = pp.x;\n        bsc = pp.y;\n    }\n    else\n    {\n        tds = shadowmarch(p, normalize(light_d));\n    }\n    \n    Q.xyz = vec3(td, tds, bsc);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2BDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 35, 35, 175], [177, 177, 222, 248, 362], [364, 364, 407, 407, 475]], "test": "untested"}
{"id": "tsjfzD", "name": "Shaderflix", "author": "friol", "description": "Our fave hobby during the quarantine.\nSound ON!", "tags": ["shadow", "logo", "light", "tv", "television"], "likes": 18, "viewed": 804, "published": 3, "date": "1589920899", "time_retrieved": "2024-07-30T21:06:03.830968", "image_code": "\n//\n// friol 2o2o\n// sdf functions, ao and softshadows by iq\n// 20.05.2020: removed the fadeout at the end because the preview was showing a black screen\n// ah, shadertoy...\n// 20.05.2020: 16x sort-of antialiasing \n//\n\n// undefine this if it's too slow on your system\n#define ANTIALIASING\n\n\nconst int sdfIterationsAmount=256;\nconst vec3 vollightPos=vec3(0.0,.2,-2.0);\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\n//\n//\n//\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xy)-2.0*ra+rb, abs(p.z) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r,float elx,float ely )\n{\n  vec2 d = abs(vec2(length(vec2(p.x*elx,p.y*ely)),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 SDFMainScene(vec3 r)\n{\n    vec3 origR=r;\n    float t=10000.0;\n    const float letterSegmentWidth=0.08;\n    const float letterY=0.5;\n\n    float myTime=(iTime-0.6)*4.5;\n    float timeshift=0.2;\n    \n    float szheight=0.40*sin(myTime-3.141592/4.0);\n    float hzheight=0.38*sin(myTime-3.141592/4.0-timeshift);\n    float azheight=0.36*sin(myTime-3.141592/4.0-timeshift*2.0);\n    float dzheight=0.34*sin(myTime-3.141592/4.0-timeshift*3.0);\n    float deheight=0.32*sin(myTime-3.141592/4.0-timeshift*4.0);\n    float drheight=0.30*sin(myTime-3.141592/4.0-timeshift*5.0);\n    float dtheight=0.28*sin(myTime-3.141592/4.0-timeshift*6.0);\n    float doheight=0.26*sin(myTime-3.141592/4.0-timeshift*7.0);\n    float dyheight=0.24*sin(myTime-3.141592/4.0-timeshift*8.0);\n    \n    if (myTime>3.141592) szheight=0.20;\n    if (myTime>3.141592+timeshift) hzheight=0.20;\n    if (myTime>3.141592+timeshift*2.0) azheight=0.20;\n    if (myTime>3.141592+timeshift*3.0) dzheight=0.20;\n    if (myTime>3.141592+timeshift*4.0) deheight=0.20;\n    if (myTime>3.141592+timeshift*5.0) drheight=0.20;\n    if (myTime>3.141592+timeshift*6.0) dtheight=0.20;\n    if (myTime>3.141592+timeshift*7.0) doheight=0.20;\n    if (myTime>3.141592+timeshift*8.0) dyheight=0.20;\n    \n    // bg plane\n    const float mutationTime=1.5;\n    float plz=-0.95;\n    if (iTime>mutationTime) plz=-1.12;\n\n    float bgPlane=sdPlane(r-vec3(0.0,0.0,plz),vec4(0.0,0.0,-1.0,1.0));\n    t=min(t,bgPlane);\n\n    if (iTime<0.6) if ((t==bgPlane)) return vec2(t,1.0);\n    else return vec2(-1.0,-1.0);\n\n    if ((r.x>=-0.02)&&(r.x<0.41)) {if (r.y<-0.44) r.y-=sin(r.x+1.1)*.06; }\n    else if ((r.x>=1.25)&&(r.x<1.53)) { if (r.y<-0.42) r.y-=sin(r.x+1.1)*.06; }\n    else if ((r.x<2.14)&&(r.y<-0.25)) r.y-=sin(r.x+1.1)*.06;\n        \n    // S\n\tfloat sxpos=-1.66;\n    \n    float supminusbox=sdBox(r-vec3(sxpos+0.42,-0.2,0.0),vec3(0.4,0.4,szheight+0.4521));\n    float sdwminusbox=sdBox(r-vec3(sxpos-0.38,0.2,0.0),vec3(0.4,0.4,szheight+0.4521));\n\n    float zsupcurve=sdCappedCylinder(r-vec3(sxpos,0.202,0.0),\n                                    0.212*1.12,szheight,0.9,0.83);\n    float smincurve=sdCappedCylinder(r-vec3(sxpos,0.202,0.0),\n                                    0.101*1.12,szheight+0.1,0.9,0.92);\n    zsupcurve=opSubtraction(smincurve,zsupcurve);\n    zsupcurve=opSubtraction(supminusbox,zsupcurve);\n\tt=min(t,zsupcurve);    \n\n    float zsdwcurve=sdCappedCylinder(r-vec3(sxpos,-0.21,0.0),\n                                    0.212*1.12,szheight,0.9,0.83);\n    float sdwmincurve=sdCappedCylinder(r-vec3(sxpos,-0.21,0.0),\n                                    0.101*1.12,szheight+0.1,0.9,0.92);\n    zsdwcurve=opSubtraction(sdwmincurve,zsdwcurve);\n    zsdwcurve=opSubtraction(sdwminusbox,zsdwcurve);\n\tt=min(t,zsdwcurve);    \n    \n\n    \n    // H\n    float hxpos=-1.23;\n    \n    float lh=sdBox(r-vec3(hxpos,0.0,0.0),vec3(letterSegmentWidth,letterY,hzheight));\n    t=min(t,lh);\n    float rh=sdBox(r-vec3(hxpos+3.7*letterSegmentWidth,0.0,0.0),vec3(letterSegmentWidth,letterY,hzheight));\n    t=min(t,rh);\n    float horzh=sdBox(r-vec3(hxpos+.2,0.0,0.0),vec3(2.0*letterSegmentWidth,letterSegmentWidth,hzheight));\n    t=min(t,horzh);\n    \n    // A\n    float axpos=-0.6;\n\n    float suba=sdBox(r-vec3(axpos,-0.9,0.0),vec3(1.2,0.4,azheight+0.4521));\n\tfloat subaup=sdBox(r-vec3(axpos,0.9,0.0),vec3(1.2,0.4,azheight+0.1));\n    vec3 ra1=rotz(r,-0.15);\n    float la=sdBox(ra1-vec3(axpos,-0.22,0.0),vec3(letterSegmentWidth,letterY*1.3,azheight));\n    la=opSubtraction(suba,la);\n    la=opSubtraction(subaup,la);\n    t=min(t,la);\n    vec3 ra2=rotz(r,0.15);\n    float ra=sdBox(ra2-vec3(axpos+0.25,0.04,0.0),vec3(letterSegmentWidth,letterY*1.2,azheight));\n    ra=opSubtraction(suba,ra);\n    ra=opSubtraction(subaup,ra);\n    t=min(t,ra);\n    float horza=sdBox(r-vec3(axpos+.12,-0.1,0.0),vec3(2.0*letterSegmentWidth,letterSegmentWidth,azheight));\n    t=min(t,horza);\n\n    // D\n    float dxpos=-0.02;\n    \n    float leftd=sdBox(r-vec3(dxpos,0.0,0.0),vec3(letterSegmentWidth,letterY,dzheight));\n    t=min(t,leftd);\n    \n    float dcurve=sdCappedCylinder(r-vec3(dxpos+letterSegmentWidth-0.03,0.0,0.0),0.212*1.12,dzheight,0.7,0.48);\n    float dminus=sdBox(r-vec3(dxpos-0.3,0.0,0.0),vec3(0.3,1.0,0.63));\n    float dmincurve=sdCappedCylinder(r-vec3(dxpos+letterSegmentWidth-0.06,0.0,0.0),0.22*0.7,0.43,0.7,0.48);\n    dcurve=opSubtraction(dminus,dcurve);\n    dcurve=opSubtraction(dmincurve,dcurve);\n    t=min(t,dcurve);\n    \n    // E\n    float depos=0.53;\n    \n    float lefte=sdBox(r-vec3(depos,0.0,0.0),vec3(letterSegmentWidth,letterY,deheight));\n    t=min(t,lefte);\n    float horzeup=sdBox(r-vec3(depos+.14,0.42,0.0),vec3(2.7*letterSegmentWidth,letterSegmentWidth,deheight));\n    t=min(t,horzeup);\n    float horzemid=sdBox(r-vec3(depos+.14,0.0,0.0),vec3(1.7*letterSegmentWidth,letterSegmentWidth,deheight));\n    t=min(t,horzemid);\n    float horzedwn=sdBox(r-vec3(depos+.14,-0.42,0.0),vec3(2.7*letterSegmentWidth,letterSegmentWidth,deheight));\n    t=min(t,horzedwn);\n    \n    // R\n    float drpos=1.10;\n    \n    float leftr=sdBox(r-vec3(drpos,0.0,0.0),vec3(letterSegmentWidth,letterY,drheight));\n    t=min(t,leftr);\n    \n    float rcurve=sdCappedCylinder(r-vec3(0.05+drpos+letterSegmentWidth,letterY*0.38,0.0),0.21*0.7,drheight,0.7,0.48);\n    float rmincurve=sdCappedCylinder(r-vec3(0.0+drpos+letterSegmentWidth,letterY*0.4,0.0),0.21*0.4,drheight+0.1,0.7,0.48);\n\trcurve=opSubtraction(rmincurve,rcurve);\n    t=min(t,rcurve);\n    vec3 ra3=rotz(r,0.31);\n    float rleg=sdBox(ra3-vec3(drpos+0.12,-0.75,0.0),vec3(letterSegmentWidth,letterY*0.6,drheight)); \n    float subr=sdBox(r-vec3(drpos,-0.9,0.0),vec3(1.2,0.4,drheight+0.41));\n    rleg=opSubtraction(subr,rleg);\n\tt=min(t,rleg);\n    \n    // T\n    float txpos=1.63;\n    \n    float horztup=sdBox(r-vec3(txpos+.14,0.42,0.0),vec3(3.2*letterSegmentWidth,letterSegmentWidth,dtheight));\n    t=min(t,horztup);\n    float tmid=sdBox(r-vec3(txpos+0.14,0.0,0.0),vec3(letterSegmentWidth,letterY,dtheight));\n    t=min(t,tmid);\n    \n    // O\n    float oxpos=2.24;\n    \n    float ocurve=sdCappedCylinder(r-vec3(oxpos+letterSegmentWidth,0.0,0.0),letterY*0.49,doheight,0.9,0.48);\n    float minocurve=sdCappedCylinder(r-vec3(oxpos+letterSegmentWidth,0.0,0.0),letterY*0.28,doheight+0.1,1.0,0.43);\n    ocurve=opSubtraction(minocurve,ocurve);\n    t=min(t,ocurve);\n    \n    // Y\n    float yxpos=2.86;\n    \n    float centralline=sdBox(r-vec3(yxpos-0.02,-0.3,0.0),vec3(letterSegmentWidth,letterY*0.5,dyheight));\n    t=min(t,centralline);\n\n    float suby=sdBox(r-vec3(yxpos,0.9,0.0),vec3(1.2,0.4,dyheight+0.4521));\n    const float yyangle=0.35;\n    vec3 ra4=rotz(r,-yyangle);\n    float lefty=sdBox(ra4-vec3(yxpos-0.18,1.3,0.0),vec3(letterSegmentWidth,letterY*.7,dyheight));\n    lefty=opSubtraction(suby,lefty);\n    t=min(t,lefty);\n    vec3 ra5=rotz(r,yyangle);\n    float righty=sdBox(ra5-vec3(yxpos-0.20,-0.7,0.0),vec3(letterSegmentWidth,letterY*.68,dyheight));\n    righty=opSubtraction(suby,righty);\n    t=min(t,righty);\n\n\t//    \n\n    if ((t==bgPlane)) return vec2(t,1.0);\n    if ((t==zsupcurve)||(t==zsdwcurve)) return vec2(t,2.0);\n    if ((t==lh)||(t==rh)||(t==horzh)) return vec2(t,2.0);\n    if ((t==la)||(t==ra)||(t==horza)) return vec2(t,2.0);\n    if ((t==leftd)||(t==dcurve)) return vec2(t,2.0);\n    if ((t==lefte)||(t==horzeup)||(t==horzedwn)||(t==horzemid)) return vec2(t,2.0);\n    if ((t==leftr)||(t==rcurve)||(t==rleg)) return vec2(t,2.0);\n    if ((t==horztup)||(t==tmid)) return vec2(t,2.0);\n    if ((t==ocurve)) return vec2(t,2.0);\n    if ((t==centralline)||(t==lefty)||(t==righty)) return vec2(t,2.0);\n    \n    return vec2(-1.0,-1.0);\n}\n\n//\n//\n//\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFMainScene(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec3 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t=0.0;\n    bool hit=false;\n    vec2 res;\n    float edgedist=0.0;\n    \n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        res = SDFMainScene(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n            edgedist=t;\n            hit=true;\n            break;\n        }\n\n        t+=res[0];\n    }\n    \n    if (hit==false) return vec3(-1.0);\n    return vec3(t,res[1],edgedist);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = SDFMainScene( ro + rd*t )[0];\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = SDFMainScene( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 fogColor=vec3(0.02,0.1,0.2);\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vollightPos);\n    \n    vec3 rayHit = castRay(rayOrigin, rayDir);\n    \n    #ifdef ANTIALIASING\n    const float aaraydelta=0.001;\n    const int numaarays=16;\n    vec3 aaarray[numaarays];\n    for (int r=0;r<numaarays;r++)\n    {\n    \taaarray[r] = castRay(rayOrigin, \n              vec3(rayDir.x+aaraydelta*sin(3.141592*2.0*float(r)/float(numaarays)),\n                   rayDir.y+aaraydelta*cos(3.141592*2.0*float(r)/float(numaarays)),\n                   rayDir.z));\n    }\n    #endif\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n\n    vec3 N=calcNormal(pHit);\n    float dotprod=max(dot(N,L),0.0);\n\n    vec3 shadowLight=normalize(vec3(-1.2, 1.8, -0.52));\n    const float mutationTime=1.5;\n    \n    if (mat==1.0) // bg plane\n    {\n        col=vec3(dotprod)*vec3(0.9,0.9,0.9);\n\n        #ifdef ANTIALIASING\n        float totMissed=0.0;\n        for (int r=0;r<numaarays;r++)\n        {\n            if (aaarray[r][1]==2.0) totMissed+=1.0/float(numaarays);\n        }        \n      \tif (iTime>=mutationTime) col=mix(col,vec3(244.0/255.0,6.0/255.0,16.0/255.0),totMissed);\n        #endif\n        \n        float ss=calcSoftshadow( pHit, shadowLight, 0.01, 2.5,0);\n        if (iTime<mutationTime) col=mix(col,vec3(156.0/255.0,162.0/255.0,174.0/255.0),1.0-ss);\n    }\n    else if (mat==2.0) // letters\n    {\n        if (iTime<mutationTime) \n        {\n            float lettersIntensity=0.60;\n            col=vec3(lettersIntensity)*dotprod;\n\n            #ifdef ANTIALIASING\n            float totMissed=0.0;\n            for (int r=0;r<numaarays;r++)\n            {\n                if (aaarray[r][1]==1.0) totMissed+=1.0/float(numaarays);\n            }        \n            col=mix(col,vec3(0.9),totMissed);\n            #endif\n            \n            float occ = calcAO( pHit, N );\n            col*=occ*3.1;\n            float ss=calcSoftshadow( pHit, shadowLight, 0.01, 2.5,0 );\n            col=mix(col,vec3(ss,ss,ss),0.65);\n            col=clamp(col,0.763,1.0);\n        }\n        else\n        {\n            col=vec3(244.0/255.0,6.0/255.0,16.0/255.0);\n            \n            #ifdef ANTIALIASING\n            float totMissed=0.0;\n            for (int r=0;r<numaarays;r++)\n            {\n                if (aaarray[r][1]==1.0) totMissed+=1.0/float(numaarays);\n            }        \n            col=mix(col,vec3(0.9),totMissed);\n            #endif\n        }\n    }\n    else if (mat==3.0)\n    {\n        col=vec3(0.1,0.2,0.1);\n    }\n    else if (mat==4.0)\n    {\n        col=vec3(0.01,0.1,0.3);\n    }\n    else\n    {\n        col=fogColor;\n    }\n    \n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    float fov=1.9;\n    vec2 result = fov*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float camxpos=0.75;\n    float camypos=0.0;\n\tif (iMouse.z>0.0)\n    {\n    \tvec2 mousepos=(iMouse.xy-0.5*iResolution.xy)/iResolution.x;\n        camxpos=(mousepos.x)*4.0;\n        camypos=(mousepos.y)*4.0;\n    }    \n\n    float camzadder=0.0;\n    if (iTime>=1.5) camzadder=(iTime-1.5)/8.0;\n    camPos=vec3(camxpos,camypos,-5.9-clamp(camzadder,0.0,.5));\n    camTarget=vec3(camxpos,camypos,1.0);\n    //camPos=vec3(camxpos,camypos,-3.5);\n    //camTarget=vec3(camxpos,camypos,1.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4((render(camPos, rayDir,uv,fragCoord).xyz),1.0);\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n\tvec2 coord = (uv2 - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    float rf = sqrt(dot(coord, coord)) * 0.19;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);\n    \n    vec4 src = finalCol;\n\tfragColor = vec4(src.rgb * e, 1.0);\n\n    if (iTime<0.53) fragColor=vec4(0.0);\n    if (abs(uv.y)>0.92) fragColor=vec4(0.0);\n}\n", "image_inputs": [], "sound_code": "\n//\n// basically, the shaderflix sound consists in:\n// - two kicks with reverb, shifted by 0.2s \n// - a drone/synth low note\n// - two 1 high and 1 octave down sinuses\n// (the original here is more of a reverse thingie)\n//\n\n\n#define PI 3.1415926535897932384626433832795\n\nconst float tempo=2.0;\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 897612.531);\n}\n\n// perlin noise\nfloat nse(float x)\n{\n    float y = floor(x);\n    x -= y;\n    x = x * x * (3. - 2. * x);\n    return mix(hash(y), hash(y + 1.), x) - .5;\n}\n\n// crude vowel-\"A\" instrument\nfloat voc(float t, float f, float formant)\n{\n    float x = fract(t * f) / f;\n    return (sin(x * 6. * formant) * .4 + sin(x * 12. * formant) + sin(x * 26. * formant) * .2) * min(x * 1000., 1.) * exp(x * -200.);\n}\n\n// a swarm of voc()'s\nvec2 inst2(float t, float f)\n{\n    vec2 v = vec2(0., 0.);\n    float formant = 250. * exp2(sin(t * .1));\n    for(int i = 0; i < 16; ++i)\n    {\n        float h = float(i);\n       \tfloat m = voc(t + h / 3., f + pow(2.01, (h - 8.) * .2), formant);\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .1;\n}\n\n// squarewave-ish instrument\nvec2 inst4(float t, float f)\n{\n    vec2 v = vec2(0., 0.);\n    for(int i = 0; i < 8; ++i)\n    {\n        float h = float(i) * 2. + 1.;\n        float x = h;\n       \tfloat m = sin(t * f * 2. * PI * x) * (1. + nse(h * 41. + t * 10.)) / h;\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .25;\n}\n\n// by srtuss -> https://www.shadertoy.com/view/4ddfWX\n// 2 octaves of choir + playing harmonics, which gives some symphonic qualities\nvec2 choir(float time, float n)\n{\n    float choirFrequency=175.0*1.0;\n    vec2 v = vec2(0.0);\n    v+=inst2(time, choirFrequency * pow(2., n / 12.));\n    v += inst2(-time, 2.0*choirFrequency * pow(2., n / 12. - 1.));\n\n    return v;\n}\n\n//\n// boom/kick\n//\n\nfloat boomKick(float t,float punchiness)\n{\n    float h = 0.7;\n    float tt = t;\n    float v;\n    float phs = (pow(tt, 0.5) + t) * 1.1;\n    float thekick=clamp(-1.0, 1.0, (nse(phs * punchiness) + sin(phs * 200.0) * 0.5) * \n               exp(max(0.04 - tt, 0.0) * -10.0) * exp(max(tt, 0.0) * -4.0) * 8.0) * 1.4;\n    return v+thekick;\n}\n\n//\n// sibilant\n//\n\nfloat sibilant(float t,float tstart,float octave,float volume)\n{\n    if ((t>=tstart)&&(t<=tstart+3.141592))\n    {\n\t\treturn volume*abs(sin(t-tstart))*sin((t-tstart)*460.0*octave);\n    }\n    else return 0.0;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n\tvec2 v=vec2(0.0);\n    float x;\n    \n    const float firstKickDelay=0.89;\n    const float choirDelay=firstKickDelay+0.14;\n    x = mod(time-choirDelay, 32. / tempo);\n    \n    if (time>firstKickDelay)\n    {\n        float k=boomKick(time-firstKickDelay,500.0);\n    \tv+=vec2(k*0.65,k*0.35)*0.2;\n    }\n    \n    if (time>choirDelay)\n    {\n    \tv += choir((time-choirDelay)*1.0, -15.) * clamp(x * tempo * .5, 0., 1.) * smoothstep(6. + 4., 5., x * tempo);\n        float k=boomKick(time-choirDelay,1000.0);\n    \tv+=vec2(k*0.35,k*0.65)*0.1;\n    }\n\n    v.y += sibilant(time,firstKickDelay+0.04,8.0,0.25);\n    v.x += sibilant(time,choirDelay+1.5,4.0,0.1);\n \n    if (time>7.0) return vec2(0.0);\n    \n    return v;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 401, 401, 512], [514, 514, 545, 545, 656], [658, 658, 689, 689, 800], [812, 812, 855, 855, 877], [880, 880, 932, 932, 1031], [1033, 1033, 1064, 1064, 1155], [1157, 1157, 1202, 1202, 1293], [1295, 1295, 1328, 1328, 1361], [1363, 1363, 1427, 1427, 1544], [1546, 1546, 1618, 1618, 1742], [1744, 1744, 1771, 1771, 9316], [9328, 9328, 9355, 9355, 9601], [9603, 9603, 9646, 9646, 10054], [10056, 10056, 10149, 10149, 10983], [10985, 10985, 11027, 11027, 11342], [11344, 11344, 11411, 11411, 14095], [14097, 14097, 14157, 14157, 14408], [14410, 14410, 14456, 14456, 14599], [14601, 14601, 14658, 14658, 15734]], "test": "untested"}
{"id": "3sBfW1", "name": "Millennium Clock", "author": "izutionix", "description": "My [url=https://www.shadertoy.com/view/3tKGRD]Yearclock shader[/url] extended to visualize a millennium.\nfrom the inside:\n   second\n   minute\n   hour\n   day\n   week (very inaccurate)\n   month (inaccurate)\n   year\n   decade\n   century\n   millennium", "tags": ["time", "clock", "timer", "calendar"], "likes": 13, "viewed": 641, "published": 3, "date": "1589903407", "time_retrieved": "2024-07-30T21:06:04.579965", "image_code": "#define ss(d) smoothstep(.159155/p.y*b,-.159155/p.y*b, d)\n#define sc(o) smoothstep(1.*b,-1.*b,p.y-r+o*r)\n\nvec3 pal(float g)\n{\n\treturn pow(cos(.8-g-vec3(0,.25,.5) ), vec3(12) ); //https://www.shadertoy.com/view/WsffWB\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / min(iResolution.y, iResolution.x);\n\n    vec2 p = vec2(atan(uv.x,uv.y)/6.283185+.5, length(uv));\n    \n    float b = 2./iResolution.y;\t//blur\n    float r = .9;\t//size\n    float bg = .25; //background brightness\n\t\n    \n    // millennium\n    float tmil = fract((iDate.x + iDate.y/12. + iDate.z/30./12. + iDate.w/86400./30./12.)/1000.);\n    float dmil = p.x-tmil;\n\tfloat smil = ss(dmil);\n    float cmil = sc(0.);\n    vec3 millennium = vec3(max(smil*cmil, bg*cmil) * pal(.1));\n       \n    // century\n    float tc = fract((iDate.x + iDate.y/12. + iDate.z/30./12. + iDate.w/86400./30./12.)/100.);\n    float dc = p.x-tc;\n\tfloat sc = ss(dc);\n    float cc = sc(.1);\n    vec3 century = vec3(max(sc*cc, bg*cc) * pal(.2));\n        \n    // decade\n    float tde = fract((iDate.x + iDate.y/12. + iDate.z/30./12. + iDate.w/86400./30./12.)/10.);\n    float dde = p.x-tde;\n\tfloat sde = ss(dde);\n    float cde = sc(.2);\n    vec3 decade = vec3(max(sde*cde, bg*cde) * pal(.3));\n    \n    // year\n    float ty = fract(iDate.y/12. + iDate.z/30./12. + iDate.w/86400./30./12.);\n    float dy = p.x-ty;\n\tfloat sy = ss(dy);\n    float cy = sc(.3);\n    vec3 year = vec3(max(sy*cy, bg*cy) * pal(.4));\n    \n    // month (inaccurate)\n    float tm = fract(iDate.z/30. + iDate.w/86400./30.);\n    float dm = p.x-tm;\n\tfloat sm = ss(dm);\n    float cm = sc(.4);\n    vec3 month = vec3(max(sm*cm, bg*cm) * pal(.5));\n    \n    // week (very inaccurate)\n    float tw = fract(iDate.z/4.7 + iDate.w/86400./30.);\n    float dw = p.x-tw;\n\tfloat sw = ss(dw);\n    float cw = sc(.5);\n    vec3 week = vec3(max(sw*cw, bg*cw) * pal(.6));\n\n    // day\n    float td = fract(iDate.w/86400.);\n    float dd = p.x-td;\n\tfloat sd = ss(dd);\n    float cd = sc(.6);\n    vec3 day = vec3(max(sd*cd, bg*cd) * pal(.7));\n    \n    // hour\n    float th = fract(iDate.w/3600.);\n    float dh = p.x-th;\n\tfloat sh = ss(dh);\n    float ch = sc(.7);\n    vec3 hour = vec3(max(sh*ch, bg*ch) * pal(.8));\n    \n    // minute\n    float tmi = fract(iDate.w/60.);\n    float dmi = p.x-tmi;\n\tfloat smi = ss(dmi);\n    float cmi = sc(.8);\n    vec3 minute = vec3(max(smi*cmi, bg*cmi) * pal(.9));\n    \n    //second\n    float ts = fract(iDate.w);\n    float ds = p.x-ts;\n\tfloat ss = ss(ds);\n    float cs = sc(.9);\n    vec3 second = vec3(max(ss*cs, bg*cs) * pal(1.));\n    \n    \n    vec3 col = mix(mix(mix(mix(mix(mix(mix(mix(mix(\n\tmillennium,\n\tcentury, cc),\n\tdecade, cde),\n\tyear, cy),\n\tmonth, cm),\n\tweek, cw),\n\tday, cd),\n\thour, ch),\n\tminute, cmi),\n\tsecond, cs);\n    \n    col = pow(col, vec3(1.2));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 218], [220, 220, 277, 277, 2857]], "test": "untested"}
{"id": "tdjfDR", "name": "Traced Tunnel", "author": "Shane", "description": "A multipass reflective box tunnel with some random reflective ray scattering thrown in. Basically, it's just a remake of W23's \"Path Racer\" and NuSan's \"Corridor Travel\" examples.", "tags": ["tunnel", "blur", "dof", "raytrace", "pathtrace", "square", "motion"], "likes": 151, "viewed": 3596, "published": 3, "date": "1589901012", "time_retrieved": "2024-07-30T21:06:05.510477", "image_code": "/*\n\n\tTraced Tunnel\n\t-------------\n\n\tThis initially started as a simple textured square tube, but then I took\n\ta look at W23's \"Past Racer\" example and wanted to emulate the awesome\n\treflective... pseudo-pathtraced style of that. NuSan also has a really\n\tnice example on here, based on the same, that provided inspiration as well --\n    That one is well worth a look as the coloring is beautiful.\n\n\tI wrote this from scratch, but have used elements from the aforementioned\n    examples. I love the camera \"tick\" function in Nusan's example, so stuck \n    with that, and I like the way W23 gave certain random tiles more of an \n    opaque factor than others, so continued with that theme.\n\n\tIn regard to my own elements, I abandoned the box formula for four simple\n\tplane traces, since I needed a bit more control. I've also put in squarish \n    polar mapped textures to give more of a wrapped feel. Other than that, I \n    haven't brought anything particularly new to the table.\n\n\tI initially went to the trouble to raytrace octagonal walls, only to \n    discover that light bounces off rectangular walls in a cleaner -- and more \n    interesting -- way, so reverted back to the original arrangement.\n\n    This contains elements of path tracing, but I won't go as far as to call it\n\tthat, so I'll simply call it a reflective ray scattering demonstration. I've \n    basically patched in code here and there, but here's a quick explanation as \n    to what's happening:\n\n    I think most know how to raytrace a square tunnel with a single pass or \n    more -- Raytrace, retrieve the hit point, then use that to color the pixel.\n    With extra reflective passes, you calculate the reflected unit direction \n    ray at the hit point (ref = relflect(r, n)), raytrace to the surface again \n    from there, retrieve the color at the new hit point, then combine it with \n    the previous color -- How you do that is up to you; addition, mixing, or \n    whatever you choose. If you want more bounces, continue the process. Simple.\n    \n    However, pure reflections don't really reflect (no pun intended) the way real \n    surfaces behave. As you could imagine, they're rough at a microscopic level,\n\tso don't perfectly reflect rays in one direction; There's some randomness\n\tto it. Essentially, rough surfaces scatter the reflective rays in a way that \n    give the appearance of graded opaqueness, and smoother polished surfaces look \n    more reflective. There's more to it, but that's the gist of it.\n\n    To put this into practice, you simply add some randomness to the reflected \n    ray, which is based on the roughness of the surface. In a similar way to W23 \n    and NuSan's examples, I've textured square grids to the walls of the tunnel, \n    then randomly assigned roughness levels to each. This causes each grid cell \n    to look opaque, completely reflective, or somewhere in-between. The\n    reflected rays on the right-angled geometry gives a see-through impression, \n    but that's not the case.\n\t\n\n\tInspired largely by the following:\n\n    // The simple renderer is great, but it's the camera work that I love most.\n    past racer by jetlag - w23\n\thttps://www.shadertoy.com/view/Wts3W7\n\n    // Simple, but georgeous lighting and colors.\n\tCorridor Travel - NuSan\n    https://www.shadertoy.com/view/3sXyRN\n\n*/\n\n\n// Pure reflections looks pretty cool, and clean, but lack the subtlety of a\n// randomly reflected ray.\n//#define PURE_REFLECTION\n\n// Full rotational movement.\n//#define CAM_ROTATION\n\n// Camera swing.\n#define CAM_SWING\n\n// Depth of field.\n#define DEPTH_OF_FIELD\n\n// Motion blur: Temporal blending of samples.\n//#define MOTION_BLUR\n\n\n\n// Sample number: Higher is better, but slower. Eight is enough. :)\nconst int sampleNum = 8;\n\n\n// 2D rotation.\nmat2 r2(float a){ return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n// Random functions: All based on IQ's originals.\n\n// vec2 to float hash.\nfloat hash21(vec2 p) {\n  return fract(sin(dot(p, vec2(425.215, 714.388)))*45758.5453);\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(72.927, 98.283)), dot(p, vec2(41.295, 57.263))))\n                  *vec2(43758.5453, 23421.6361));\n}\n\n// vec2 to vec3 hash.\nvec3 hash23(vec2 p){\n    return fract(sin(vec3(dot(p, vec2(12.989, 78.233)), dot(p, vec2(51.898, 56.273)),\n                      dot(p, vec2(41.898, 57.263)))) *vec3(43758.5453, 23421.6361, 65426.6357));\n}\n\n// Also from NuSan's example. I tried other variations, but\n// this just seems to work better.\nfloat tick(float t, float d) {\n  \n  float m = fract(t/d);\n  m = smoothstep(0., 1., m);\n  m = smoothstep(0., 1., m);\n  return (floor(t/d) + m)*d;\n}\n\n// NuSan's cool camera tick function.\nfloat tickTime(float t){ return t*2. + tick(t, 4.)*.75; }\n\n\n// Camera movement. Adapted from NuSan's example.\nvoid cam(inout vec3 p, float tm, float tTime) {\n  \n    #ifdef CAM_ROTATION\n    p.xy *= r2(tm/4.);\n    p.xz *= r2(tm/2.);\n    #endif\n    \n    #ifdef CAM_SWING\n  \tp.xz *= r2(sin(tTime*.3)*.4);\n  \tp.xy *= r2(sin(tTime*.1)*2.);\n    #endif\n    \n}\n\n// Plane intersection: Old formula, and could do with some tidying up.\n// The tiny \"9e-7\" figure is something I hacked in to stop near plane \n// artifacts from appearing. I don't like it at all, but not a single \n// formula I found deals with the problem. There definitely has to be\n// a better way, so if someone knows of a more robust formula, I'd \n// love to use it.\nfloat rayPlane(vec3 ro, vec3 rd, vec3 n, float d){\n\n\n    float t = 1e8;\n    //float retval = 0.; // Inside or outside the object. Not used here.\n\n\tfloat ndotdir = dot(rd, n);\n     \n\tif (ndotdir < 0.){\n\t\n\t\tfloat dist = (-d - dot(ro, n) + 9e-7)/ndotdir;\t// + 9e-7\n   \t\t\n\t\tif (dist>0. && dist<t){ \n            t = dist; \n            //retval = 1.;\n\t\t}\n\t}\n    \n    return t;\n\n}\n\nfloat udBox(in vec2 p, in vec2 b){\n\treturn length(max(abs(p) - b + .1, 0.)) - .1;\n}\n\n// Used for polar mapping various shapes.\nfloat uvShape(vec2 p){\n    // Polar mapping a square wall.\n    p = abs(p);\n    return max(p.x, p.y);\n    \n    // Mapping hexagon walls.\n    //p *= r2(-3.14159/12.);\n    //p = abs(p);\n    //return max(p.x*.8660254 + p.y*.5, p.y);\n    \n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n  \n    // Aspect correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n\n    // Depth of field (DOF) amount, and the DOF distance. In this\n    // case, a figure of 3 will bring everything into focus three units \n    // down the tunnel, but camera blur things around it.\n    const float DOF = .05, DOFDist = 3.;\n    \n    // Global time, and tick time, which in this case is regular time, with\n    // a lurching tick on it. I think it's great, but it might not be for\n    // those who are prone to motion sickness.\n    float tm = iTime;\n    float tickTm = tickTime(tm);\n    \n    // Initial camera position. The tick time variable gives the camera a\n    // slight lurching motion along Z.\n    vec3 ca = vec3(0, 0, tickTm);\n    \n    \n    // Initialize the scene color to zero.\n     vec3 col = vec3(0);\n\n\n    // Taking a few samples, which is not much different to standard antialiasing. The main \n    // difference is that you set up your unit direction ray with UV coordinates randomly \n    // sampled around the pixel area. The average of all returned colors gives you a nice \n    // antialiased look... provided you take enough costly samples, of course. In this case, \n    // we're taking just 8 -- Not ideal, but good enough for the purpose of this example.\n    for(int j = 0; j<sampleNum; j++) {\n\n        // Pixel offset.\n        vec2 offs = hash22(uv + float(j)*74.542 + 35.877) - .5;\n\n        #ifdef MOTION_BLUR\n        // Motion blur: Just a simple temporal blending of samples. In case it isn't\n        // obvious, you're advancing global time a little with each sample, which results \n        // in frames further in time being blended with the present. You could go \n        // backwards instead, if the idea of looking into the future bothers you. :D\n        tm = iTime + float(j)*.05/float(sampleNum);\n        tickTm = tickTime(tm);\n        #endif\n \n        vec3 ro = vec3(0);\n        #ifdef DEPTH_OF_FIELD\n        // Depth of field. Spreading out the sample, according to screen depth.\n        ro.xy += offs*DOF;\n        vec3 r = normalize(vec3(uv - offs*DOF/DOFDist, 1));\n        #else\n        vec3 r = normalize(vec3(uv - offs/iResolution.y, 1));\n        #endif\n\n        // Camera movement. Rotation, swivle, etc.\n        cam(ro, tm, tickTm);\n        cam(r, tm, tickTm);\n        \n        \n        ro.z += ca.z;\n\n        // Alpha, for blending layers.\n        float alpha = 1.;\n\n        // Fog distance.\n        float fogD = 1e5;\n\n\n        // Reflective bounces. Just three here.\n        for(int i = 0; i<3; i++) {\n\n\n            // Tracing the four planes, then determining the closet.\n            // I'll tidy this up later.; \n            //\n            vec4 pl; // Vector storage for the four planes.\n            pl.x = rayPlane(ro, r, vec3(0, 1, 0), 1.); // Bottom.\n            pl.y = rayPlane(ro, r, vec3(0, -1, 0), 1.); // Top.\n            pl.z = rayPlane(ro, r, vec3(1, 0, 0), 1.); // Left.\n            pl.w = rayPlane(ro, r, vec3(-1, 0, 0), 1.); // Right.\n           \n            // Minimum plane distance.\n            float d = min(min(pl.x, pl.y), min(pl.z, pl.w));\n    \n            // Set the fog distance on the first pass.\n            if(i==0) fogD = d;\n\n            // Hit position.\n            vec3 p = ro + r*d;\n            // Determine the UV coordinates for texturing, and the normal,\n            // for lighting and other things.\n            //\n            // Set the normal and UVs to the bottom or top planes.\n            vec3 n = vec3(0,  pl.x<pl.y? 1 : -1, 0);\n            vec2 tuv = p.xz + vec2(0, n.y);\n\n            // If we've hit the side walls instead, change the normal and \n            // UVs accordingly.\n            if(min(pl.z, pl.w)<min(pl.x, pl.y)) {\n             \n                n = vec3(pl.z<pl.w? 1 : -1, 0, 0);\n                \n                tuv = p.yz + vec2(n.x, 0); // Left walls.\n            }\n\n            // Texture scaling for texturing.\n            const float sc = 12.;\n            tuv *= sc;\n            \n            \n            // Sample color.\n            vec3 sampleCol = vec3(1);\n            \n            // Grid square ID and local coordinates.\n            vec2 id = floor(tuv);\n            tuv -= id + .5;\n            \n   \n             /////\n            // Use the UV coordinates to create a whitish colored rounded box grid.\n            float patDist = udBox(tuv, vec2(.4));\n            // Use the square grid shape for shading.\n            float sh = clamp(.5 - patDist/.2, 0., 1.);\n       \n            // Subtle coloring.\n            vec3 sqCol = .85 + .3*cos((hash21(id + .2)*2.)*6.2831 + vec3(0, 1, 2));\n            sampleCol = mix(vec3(0), sqCol*sh, (1. - smoothstep(0., .005, patDist)));\n \n            ////\n            // Perform a squarish polar mapping (of sorts), read in to some textures, then\n            // color them up, etc.\n            //\n            // Quantized squarish polar mapping.\n            const vec2 txSc = vec2(2, 1./2.); // Texture scale.\n            vec3 ip3 = (floor(p*sc) + .0)/sc; // Quantizing... as opposed to continuous values.\n            float ang = atan(ip3.x, ip3.y)/6.2831; // Angle of grid cell from the tube center.\n            vec2 tnuv = vec2(uvShape(ip3.xy)*ang*txSc.x, ip3.z*txSc.y); // Square polar UVs.\n            //\n            // Smooth squarish polar mapping.\n            const vec2 txSc2 = vec2(1, 1./4.); // Texture scale.\n    \t\tvec3 p3 = mix(p, (floor(p*sc) + .0)/sc, .8); // Slightly smooth quantized values.\n            float ang2 = atan(p3.x, p3.y)/6.2831; // Angle of grid cell from the tube center.\n            vec2 tnuv2 = vec2(uvShape(p3.xy)*ang2*txSc2.x + p3.z*.075, p3.z*txSc2.y);  // Square polar UVs.\n\n            // Reading the texel values, and manipulating a bit. Note the squaring of the value,\n            // (tx *= tx) which is a rough sRGB to linear conversion.\n            vec3 tx = texture(iChannel0, fract(tnuv - .5 - vec2(iTime/(sc)/2., 0))).xyz; tx *= tx;\n            tx = mix(tx, vec3(dot(tx, vec3(.299, .587, .114))), .75);\n            tx = smoothstep(.1, .55, tx);\n\n            vec3 tx2 = texture(iChannel1, fract(tnuv2 - .5 - vec2(iTime/(sc)/2., 0))).xyz; tx2 *= tx2;\n            tx2 = smoothstep(.18, .5, tx2);//*vec3(1.1, 1, .9); \n            \n            // Apply the textures to the sample color. \n            sampleCol *= tx*tx2*4.; \n            \n            // Some fakish point lighting. \n            // Light direction vector. The light is 3 units up from the camera, which\n            // coincides with the depth of field distance.\n            vec3 ld = normalize(ca + vec3(0, 0, 3) - p);\n            float dif = max(dot(ld, n), 0.); // Diffuse.\n            float spe = pow(max(dot(reflect(ld, -n), -r), 0.), 8.); // Specular.\n            float fre = pow(max(1. - abs(dot(r, n))*.5, 0.), 1.); // Fresnel.\n            \n            sampleCol *= (dif + vec3(1, .9, .7)*spe*4. + vec3(.5, .7, 1)*fre);\n                \n            /*\n            // W23's chromatic effect. It looks good in his artsy black and white\n            // example, but there's too much color here for it to be effective.\n            \n            float patDistL = udBox(tuv - vec2(.05, 0), vec2(.4));\n            float patDistR = udBox(tuv - vec2(0, .05), vec2(.4));\n            sampleCol *= step(0., -vec3(patDistL, patDist, patDistR) - .025);\n            */\n            \n            // Applying some fog.\n            sampleCol *= 1.35/(1. + fogD*fogD*.05);\n         \n\n            \n            // Add the sample color to overall accumulated scene color.\n            //col += sampleCol*alpha*fre*exp(-fogD*.2);\n            col += sampleCol*alpha*fre;\n            \n            // Reduce the alpha factor by a bit and mix in the Fresnel factor as well.\n            alpha *= 0.9;\n\n   \n            // Calculate the reflection vector for the next pass.\n            \n            #ifdef PURE_REFLECTION\n            \n            // Pure reflection overide. It's definitely cleaner, but less interesting.\n            r = reflect(r,n);\n            \n            #else\n            \n            // Just some randomized reflection, based on certain heuristics. There are\n            // various ways to create a randomized relective vector, but it's mainly\n            // common sense. \n            float h = hash21(id)*smoothstep(0., .005, -patDist + .15);\n          \n            // Purely reflected vector.\n            vec3 ref = reflect(r,n);\n            // Random vector.\n            r = normalize(hash23(uv + float(j)*74.524 + float(i)*35.712) - .5);\n            // Mixing the purely reflected vector with the random vector according\n            // to some heuristics. In this case, a random opaque factor for the \n            // tile, the tile shade, pattern border, fog... I made it up as I \n            // went along. :)\n            r = normalize(mix(ref, r, (hash21(tuv)*.0 + h*.1*sh)*exp(-fogD*.05)));\n            \n            // Ensuring random reflection. I normally use other logic, but it works\n            // well enough in W23 and Nusan's examples, so it'll do. :)\n            r = dot(r, n)<0.? -r : r;\n            #endif\n\n            // Advance the position to the new hit point. Also be sure to bump\n            // the ray off the surface to avoid self collision... If I had a\n            // dollar for every time I've forgotten to do this... :)\n            ro = p + n*.0011;\n        }\n\n    }\n    \n    // Divide by the total number of samples.\n    col /= float(sampleNum);\n    \n\n    // Use this to tone down highlight extrema... However, if you like to live on\n    // the edge and burn your eyes, then leave it as is. :D\n    //col = 1. - exp(-col);\n    \n    \n    // Gamma correction and screen presentation.\n    fragColor = vec4(pow(max(col, 0.), vec3(0.4545)), 1);\n    \n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3745, 3761, 3778, 3778, 3826], [3879, 3902, 3924, 3924, 3990], [3992, 4014, 4035, 4035, 4172], [4174, 4196, 4216, 4216, 4401], [4403, 4498, 4528, 4528, 4644], [4646, 4684, 4708, 4708, 4741], [4744, 4794, 4841, 4841, 5035], [5037, 5407, 5457, 5457, 5780], [5782, 5782, 5816, 5816, 5865], [5867, 5909, 5931, 5967, 6149], [6151, 6151, 6205, 6251, 15952]], "test": "untested"}
{"id": "wdsfWX", "name": "Colourful Apollonian III", "author": "mla", "description": "Apollonian gasket from [url]https://www.shadertoy.com/view/tsXBRf[/url] by sl2c\n\nMouse + various key controls, see code header. Using mouse stops animation (restart with 'm' key).", "tags": ["inversion", "apollonian", "gasket"], "likes": 15, "viewed": 631, "published": 3, "date": "1589878945", "time_retrieved": "2024-07-30T21:06:06.254488", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Colourful Apollonian III, mla, 2020\n//\n// Another Apollonian Gasket - this is the same as the one in\n// https://www.shadertoy.com/view/tsXBRf by sl2c, but constructed in a\n// slightly different way that brings out the 3-fold symmetry. A\n// notable feature is inversion in a circle of imaginary radius.\n//\n// <mouse>: apply inversion\n// <up>/<down>: zoom in/out\n// a,b,c,d,r,s,t: various controls for colouring\n// m: mouse action\n// x: show inversion circles\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nconst int N = 3; // Any odd N >= 3 will work\nconst float D = 1.0/cos(PI/float(N)); // Centre distance of outer circles\nconst float R = D*sin(PI/float(N));   // Radius of outer circles\nconst float K = D-R;                  // Radius squared of centre circle.\n\nvec3 getcircle(int i) {\n  float t = 2.0*PI*float(i)/float(N);\n  return vec3(D*vec2(sin(t),cos(t)),R*R);\n}\n\nvec3 pcolor(vec2 z) {\n  int nsteps = 50;\n  int step = 0;\n  for (step = 0; step < nsteps; step++) {\n    if (length(z) < K) break;\n    float k = K/dot(z,z);\n    z *= -k; // Imaginary radius\n    for (int i = 0; i < N; i++) {\n      vec3 c = getcircle(i);\n      if (dot(z-c.xy,z-c.xy) < c.z) {\n        z -= c.xy;\n        z *= c.z/dot(z,z);\n        z += c.xy;\n        break;\n      }\n    }\n  }\n  if (step == nsteps) return vec3(0);\n  vec3 col = vec3(1);\n  if (key(CHAR_A)) col *= vec3(step%2);\n  if (key(CHAR_B)) col *= vec3(1-step%2);\n  if (!key(CHAR_C)) col *= hsv2rgb(vec3(float(step)/6.0,1,1));\n  if (key(CHAR_D)) col *= (step%2==0) ? vec3(0,0,1): vec3(1,0,0);\n  if (key(CHAR_R)) col = 1.0-col;\n  if (key(CHAR_S)) col = mix(vec3(1),col,0.5);\n  if (!key(CHAR_T)) col *= 1.0-length(z)/K;\n  return col;\n}\n\nvec3 getcolor(vec2 z, vec2 w) {\n  if (!key(CHAR_M) && iMouse.x > 0.0) {\n    z = invertto(z,w);\n  } else if (true) {\n    float k = 1.618*sin(0.5*iTime);\n    z.y += k;\n    z = invert(z,vec3(0,0,1.0));\n    z = invert(z,vec3(0,k,1));\n  }\n  vec3 color = pcolor(z);\n  if (key(CHAR_X)) {\n    float lwidth = 0.01;\n    float pwidth = 2.0*fwidth(z.x);\n    vec3 ccolor = 0.8*vec3(1,1,0);\n    color = mix(ccolor,color,smoothstep(0.5*lwidth,lwidth,abs(length(z)- sqrt(abs(K)))));\n    for (int i = 0; i < N; i++) {\n      vec3 c = getcircle(i);\n      color = mix(ccolor,color,smoothstep(0.5*lwidth,lwidth,abs(length(z-c.xy)-sqrt(c.z))));\n    }\n  }\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float AA = 2.0;\n  vec3 color = vec3(0);\n  float scale = 1.0;\n  scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec2 w = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n      z *= scale; //w *= scale;\n      color += getcolor(z,w);\n    }\n  }\n  color /= AA*AA;\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 invert(vec2 z, vec3 c) {\n  z -= c.xy;\n  z *= c.z/dot(z,z);\n  z += c.xy;\n  return z;\n}\n\nvec2 invertto(vec2 z, vec2 m) {\n  float X = dot(m,m);\n  m /= X;\n  return invert(z,vec3(m,(1.0-X)/X));\n}\n\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2(code,2),0).x != 0.0)\n\n#define store(i,j) (texelFetch(iChannel2, ivec2(i,j),0))\n\n#define keycount(key) (int(store(0,key).x))\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[918, 918, 941, 941, 1023], [1025, 1025, 1046, 1046, 1823], [1825, 1825, 1856, 1856, 2475], [2477, 2477, 2529, 2529, 3027]], "test": "untested"}
{"id": "tsjBWR", "name": "Shattering", "author": "luchong", "description": "Image shattering effect, with parameters to animate construction/destruction", "tags": ["2d", "wip", "bitmap"], "likes": 2, "viewed": 407, "published": 3, "date": "1589856822", "time_retrieved": "2024-07-30T21:06:06.998499", "image_code": "#define DEBUG\n#define ANIM\n\nconst int numOfHorizontal = 8;\nconst int numOfVertical = 8;\nconst int diagSpacing = 50;\nconst int diagOffset = -5;\nint displacement = 50;\n\n/*\n\n2D array representing square positions.\nOriginal image indexes:\n\n    56,57,58,59,60,61,62,63,\n    48,49,50,51,52,53,54,55,\n    40,41,42,43,44,45,46,47,\n    32,33,34,35,36,37,38,39,\n    24,25,26,27,28,29,30,31,\n    16,17,18,19,20,21,22,23,\n     8, 9,10,11,12,13,14,15,\n     0, 1, 2, 3, 4, 5, 6, 7\n\nShuffle this for shattering effect\n\n*/\n\nint grid[numOfHorizontal*numOfVertical] = int[numOfHorizontal*numOfVertical](\n\t14,52,45, 4, 2, 8,44,21,\n\t55,23, 6,28,29,61,35,17,\n   \t57,56,12,13,59,41,49,18,\n     7,22,58,20,43, 1,32, 5,\n   \t11,51,62,34,60,39,38,10,\n   \t24,54,33,36,63,48,19,30,\n   \t16,40,42, 3,25,15,31,26,\n   \t46,37, 9,47, 0,50,27,53\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef ANIM    \n    displacement = int(cos(iTime * 2.5) * float(displacement/2) + float(displacement/2));\n#endif\n    \n    ivec2 pixelCoord = ivec2(fragCoord);\n    \n    \n    //Find out which diagonal segment the pixel belongs to\n    \n    int i = int(floor(float(pixelCoord.y - pixelCoord.x - diagOffset) / float(diagSpacing)));\n    \n#ifdef DEBUG\n    //Draw diagonal bounds\n    \n    if(pixelCoord.y == pixelCoord.x + i * diagSpacing + diagOffset) {\n        fragColor = vec4(0,0,1,1);\n    \treturn;\n    }\n#endif\n    \n    //Displace pixel diagonally\n    \n    int dir = (2 * (abs(i) % 2) - 1);\n    pixelCoord += displacement * dir * ivec2(1,1);\n    \n    //If out of viewport render transparent\n    \n    if(lessThan(pixelCoord, ivec2(0,0)) != bvec2(false, false)\n       || greaterThan(pixelCoord, ivec2(iResolution)) != bvec2(false, false)) {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    int rectHeight = int(iResolution.y) / numOfHorizontal;\n    int rectWidth = int(iResolution.x) / numOfVertical;\n    \n#ifdef DEBUG\n    //Draw horizontal and vertical bounds\n    \n    if(pixelCoord.y > 0 && pixelCoord.y % rectHeight == 0) {\n        fragColor = vec4(1,0,0,1);\n        return;\n    }\n    \n    if(pixelCoord.x > 0 && pixelCoord.x % rectWidth == 0) {\n        fragColor = vec4(1,0,0,1);\n        return;\n    }\n#endif\n    \n    //Find out position in grid for displaced pixel\n    \n    int gridX = pixelCoord.x / rectWidth;\n    int gridY = pixelCoord.y / rectHeight;\n    int remainX = pixelCoord.x % rectWidth;\n    int remainY = pixelCoord.y % rectHeight;\n    \n    // If grid does not fit perfectly in resolution, render borders transparent\n    \n    if(gridX >= numOfHorizontal || gridY >= numOfVertical) {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    // Get texture coordinates for corresponding square\n    vec2 tex = vec2(\n        grid[numOfHorizontal*(numOfVertical-gridY-1)+gridX] % numOfHorizontal * rectWidth + remainX,\n       \tgrid[numOfHorizontal*(numOfVertical-gridY-1)+gridX] / numOfVertical * rectHeight + remainY\n    );\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = tex/iResolution.xy;\n\n    // Sample from texture\n    \n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[815, 815, 872, 872, 3104]], "test": "untested"}
{"id": "wl3XR8", "name": "Jumper Wires", "author": "Plento", "description": "This shader is running on a breadboard.", "tags": ["3d", "mouse", "raymarch", "breadboard"], "likes": 15, "viewed": 442, "published": 3, "date": "1589856720", "time_retrieved": "2024-07-30T21:06:07.744504", "image_code": "// Plento\n// \"Jumper Wires\"\n\n// Raymarched breadboard model with some literal jumping wires\n\n\n#define ShowWires\n\nvec2 R;\nconst float pi = 3.14159;\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define FAR 100.\n#define ss(a, b, t) smoothstep(a, b, t)\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n// https://iquilezles.org/articles/distfunctions\nfloat smoothsub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    rp.xz*=rot(iTime*.5 -1.);\n    \n    vec3 rp2 = rp;\n    \n    rp.x = -abs(rp.x);\n    \n    float board = box(rp-vec3(0., -.98, 0.), vec3(1., .05, 2.5)) - .05;\n    \n    d = min(d, board);\n    d = smoothsub(box(rp-vec3(0., -.84, 0.), vec3(.03, .05, 3.)),d, .06);\n    \n    vec3 b = vec3(.07, .2, .07);\n    vec3 rrp = rp - vec3(.09, 0., .07);\n    rrp = mod(rrp, b)-b*.5;\n    \n    float rep = max(box(rrp, vec3(.013, .4, .013)),\n        box(rp-vec3(-.36, -1., 0.), vec3(.22, .15, 2.5))\n    );    \n    \n    d = smoothsub(rep, d, .03);\n    \n    float rep2 = max(box(rrp, vec3(.013, .04, .013)),\n        box(rp-vec3(-.89, -1., 0.), vec3(.05, .15, 2.36))\n    );  \n    \n    d = smoothsub(rep2, d, .03);\n    \n    vec3 p = rp2-vec3(0., -1.0, 1.);\n    p = mod(p, vec3(0., 0., 0.4))-vec3(0., 0., 0.4)*0.5;\n    \n    p.yz *= rot(pi/2.);\n    \n    vec3 irp = rp2-vec3(iTime+1.2,-0.5,0.);\n    irp = mod(irp, vec3(4.5,0.,0.))-vec3(4.5,0.,0.)*0.5;\n    irp.xz*=rot(pi/4.);\n    \n    #ifdef ShowWires\n    d = min(d, max(torus(p, vec2(0.5, 0.02)), box(irp, vec3(0.8, 0.5, 2.4))));\n    #endif\n    \n    return d;\n}\n\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .0015 || t > 60.) break;\n        \n        t += d * .75;\n    }\n    return t;\n}\n\n\nvec3 color(vec3 p, vec3 rd, vec3 n, float t){\n    vec3 lp = vec3(6., 9.0, -5.0);\n    vec3 ld = normalize(lp-p);\n   \tvec3 ref = reflect( rd, n );\n    \n    float faloff = 1.-exp(-(4. / length(lp - p)));\n    \n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 12.);\n    float dif = max(dot(n, ld), .05);\n    \n    p.xz*=rot(iTime*.5-1.);\n    p.x = abs(p.x);\n    \n    vec3 col = vec3(0);\n    float mat = step(0.865, abs(p.y));\n    \n    float id = floor(p.z/ 0.4 - 0.5);\n    vec3 wire = hash31(id*346.24);\n    \n    vec3 board = vec3(.95, .7, .4);\n    float bnd = ss(2.382, 2.383, abs(p.z));\n    board = mix(vec3(.6, 0., 0.), board, ss(0.01, 0.015, abs(p.x-.99)+bnd));\n    board = mix(vec3(0., .1, .6), board, ss(0.01, 0.015, abs(p.x-.78)+bnd));\n    \n    col = mix(wire, board, mat);\n    \n    col *= 2.*dif*vec3(1., 1., 1.) * faloff;\n    col += vec3(0.8, 0.8, 0.8) * spec * .25;\n    \n    col = mix(vec3(0), col, 1.-step(50., t));\n     \n\treturn col;   \n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    float zm = max(5.- (iTime * 7.), 0.8);\n    vec3 rd = normalize(vec3(uv, zm));\n    //vec3 ro = vec3(0., m.y*10., m.x*10. - 3.);\n    vec3 ro = vec3(0., 0.5, -2.9);\n    \n    if(iMouse.z>0.) ro.zy += m*3.; \n    \n    rd.yz*=rot(0.65);\n    \n    float t = march(rd, ro);\n    \n    vec3 n = normal(ro + rd*t);\n    vec3 col = color(ro + rd*t, rd, n, t);\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 285, 285, 418], [419, 419, 438, 438, 490], [492, 492, 520, 520, 607], [609, 609, 639, 639, 704], [705, 754, 802, 802, 903], [905, 905, 924, 924, 2037], [2041, 2041, 2068, 2068, 2269], [2271, 2271, 2301, 2301, 2494], [2497, 2497, 2542, 2542, 3458], [3462, 3462, 3502, 3502, 3976]], "test": "untested"}
{"id": "WdjBDz", "name": "Asteroid Belt Data Links", "author": "blackle", "description": "playing with 4d modelling and the \"empty domains\" trick. see [url]https://www.shadertoy.com/view/tsjfRw[/url]", "tags": ["asteroids"], "likes": 8, "viewed": 460, "published": 3, "date": "1589854313", "time_retrieved": "2024-07-30T21:06:08.490510", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is mostly a remix of https://www.shadertoy.com/view/tsjfRw but\n//extending to the 4th dimension so we can do 4d rotations and get neat slices\n\n//returns a vector pointing in the direction of the closest neighbouring cell\nvec3 quadrant(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x >= max(ap.y, ap.z)) return vec3(sign(p.x),0.,0.);\n    if (ap.y >= max(ap.x, ap.z)) return vec3(0.,sign(p.y),0.);\n    if (ap.z >= max(ap.x, ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\nbool domain_enabled(vec3 id) {\n    //repeat random number along z axis so every active cell has at least one active neighbour\n    id.z = floor(id.z/2.); \n    return hash(id.x, hash(id.y, id.z)) < .5;\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec4 p, vec4 a, vec4 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec4 wrot(vec4 p) {\n    return vec4(dot(p,vec4(1)), p.yzw + p.wyz - p.zwy - p.xxx)/2.;\n}\n\nfloat box(vec4 p, vec4 d) {\n    vec4 q = abs(p)-d;\n    return length(max(q,0.))+min(0.,max(max(q.x,q.w),max(q.y,q.z)));\n}\n\nvec4 smin(vec4 a, vec4 b, float k) {\n    vec4 h = max(vec4(0),-abs(a-b)+k)/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat weird_obj(vec4 p) {\n    p.xyz = erot(p.xyz, normalize(sin(p.xyz)), iTime/4.);\n    p = wrot(p);\n    p = sqrt(p*p+0.001);\n    p = wrot(p);\n    p.w+=.5;\n    p = sqrt(p*p+0.001);\n    p = wrot(p);\n    //p = smin(p,wrot(p),0.01);\n    return box(p, vec4(1.2))-.2;\n}\n\nfloat ball;\nfloat pipe;\nfloat scene(vec3 p) {\n    p.x+=sin(p.z/5.); p.y+=cos(p.z/5.);\n    p.y+=sin(p.x/7.); p.z+=cos(p.x/7.);\n    float w = sin(p.x/8.+iTime)*sin(p.y/8.+iTime)*sin(p.z/8.+iTime)*3.;\n    vec4 p4 = vec4(p,w);\n    p4 = mix(p4, wrot(p4), .2);\n    float scale = 8.;\n    vec3 id = floor(p.xyz/scale);\n    p4.xyz = (fract(p.xyz/scale)-.5)*scale;\n    if (!domain_enabled(id)) {\n        //return distance to sphere in adjacent domain\n        p4 = abs(p4);\n        if (p4.x > p4.y) p4.xy = p4.yx;\n        if (p4.y > p4.z) p4.yz = p4.zy;\n        if (p4.x > p4.y) p4.xy = p4.yx;\n        p4.z -= scale;\n        pipe = length(p4)-.2;\n        return weird_obj(p4);\n    }\n    float dist = weird_obj(p4);\n    ball = dist;\n    vec3 quad = quadrant(p4.xyz);\n    if (domain_enabled(id+quad)) {\n        //add pipe\n\t\tpipe = linedist(p4, vec4(0), vec4(quad,0.)*scale)-.2;\n        dist = min(dist, pipe);\n    } else {\n        pipe = length(p4)-.2;\n    }\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat stars(vec3 dir) {\n    dir = erot(dir,normalize(vec3(1)),.2);\n    float str = length(sin(dir*vec3(120,120,210)));\n    dir = erot(dir,normalize(vec3(1,2,3)),.4);\n    str += length(sin(dir*vec3(320,230,140)));\n    dir = erot(dir,normalize(vec3(2,3,1)),.3);\n    str += length(sin(dir*vec3(230,280,138)));\n    return smoothstep(2.,1.5,str);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam  = normalize(vec3(1,uv));\n    float time = (floor(iTime/3.)+pow(sin(fract(iTime/3.)*3.14/2.),20.))*5. + iTime*2.; //accelerates every 3 seconds\n    cam = erot(cam, vec3(1,0,0), time/20.);\n    cam = erot(cam, vec3(0,0,1), .4+cos(time/8.)*.1);\n    vec3 init = vec3(time*2.-50.,-time,time)+cam;\n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    float glow = 1000.;\n    float glowdist = 0.;\n    //raymarching\n    for (int i = 0; i < 150; i++) {\n        dist = scene(p);\n        if (pipe < glow) {\n            glow = pipe;\n            glowdist = distance(p,init);\n        }\n        hit = dist*dist < 1e-6;\n        p += cam*dist;\n        if (distance(p,init) > 250.) break;\n    }\n    //shading\n    glow = smoothstep(0.5, 0.,glow);\n    float fog = pow(smoothstep(250.,50.,distance(p,init)),2.);\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float diff = max(0., dot(n, normalize(vec3(1,-1,1))))  + length(sin(n*vec3(3,2,1))*.5+.5)/sqrt(3.)*.1;\n    float spec = max(0., dot(r, normalize(vec3(1,-1,1))))  + length(sin(r*vec3(3,2,1))*.5+.5)/sqrt(3.)*.1;\n    float fresnel = 1.-abs(dot(n,r))*.98;\n    vec3 matcol = vec3(0.3,.2,.2);\n    vec3 col = matcol*matcol*diff*diff + pow(spec,2.)*fresnel + .005;\n    vec3 glowcol = glow*.5 + abs(erot(vec3(.7,.4,.2), vec3(0,0,1), glowdist*.1))*glow;\n    float glowfog = pow(smoothstep(250.,50.,glowdist),2.);\n    vec3 bg = vec3(stars(cam));\n    fragColor.xyz = sqrt(hit ? mix(bg, col, fog) : bg) + glowfog*glowcol;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBDz.jpg", "access": "api", "license": "cc0-1.0", "functions": [[344, 422, 445, 445, 678], [680, 680, 710, 710, 779], [781, 781, 811, 906, 982], [984, 984, 1024, 1024, 1116], [1118, 1118, 1158, 1158, 1250], [1252, 1252, 1271, 1271, 1340], [1342, 1342, 1369, 1369, 1463], [1465, 1465, 1501, 1501, 1576], [1578, 1578, 1616, 1616, 1682], [1684, 1684, 1709, 1709, 1948], [1974, 1974, 1995, 1995, 2914], [2916, 2916, 2935, 2935, 3050], [3052, 3052, 3075, 3075, 3395], [3397, 3397, 3454, 3454, 4993]], "test": "untested"}
{"id": "3d2BWz", "name": "glowing video waffle", "author": "mds2", "description": "I heard people were obsessed with this \"trypophobia\" concept, so I decided to try out a shader riffing on the idea.\n\nThen I changed my mind and decided to make it a webcam filter", "tags": ["raycast", "subsurface", "holes"], "likes": 5, "viewed": 1008, "published": 3, "date": "1589843750", "time_retrieved": "2024-07-30T21:06:09.246488", "image_code": "#define MAX_DIST 4.0\n\n#define SUPERSAMPLE 0 // per IQ, enable at your own risk\n// #define SUPERSAMPLE 1 // it's a boolean\n\nfloat length_1 = 0.4;\nconst float crinkle = 0.00375; // make this smaller to make grid finer\n\nvec2 bright_clamp = vec2(0.0, 1.0); // ramp brightness values in this range to 0.0,1.0\n\n#define HOLES_OR_RODS 1 // 1 for holes, 0 for rods\n\nconst vec3 light_dir = normalize(vec3(0.05, 0.05, -0.15));\n\nfloat do_bright_clamp(in float x) {\n#if !HOLES_OR_RODS\n    // return clamp((x-bright_clamp.y)/(bright_clamp.x - bright_clamp.y), 0.0, 1.0);\n\treturn smoothstep(bright_clamp.y, bright_clamp.x, x);\n#else\n    // return clamp((x-bright_clamp.x)/(bright_clamp.y - bright_clamp.x), 0.0, 1.0);\n    return smoothstep(bright_clamp.x, bright_clamp.y, x);\n#endif\n}\n\nfloat core_sdf(in vec3 pt) {\n    const vec3 p1 = vec3(0.0, 0.45, 0.7);\n    const vec3 p2 = -vec3(0.0, -0.1, 0.7);\n    float d1 = length((pt - p1)* vec3(1.6)) - 3.1 * length_1;\n    // float d1 = dot(pt - p1, normalize(p2 - p1)) - 1.85 * length_1;\n    // float d2 = length((pt - p2) * vec3(1.6)) - 3.0 *  length_1;\n    float d2 = dot(pt - p2, normalize(p1 - p2)) - 1.9 * length_1;\n    // float d1 =  length((pt.xy + vec2(0.0, -0.15))) -0.8 *  length_1;\n    return smooth_max(d1, d2, 0.05);\n}\n\nfloat wavefront(vec3 p) {\n    return (1.0 - length_1) * smoothstep(0.0, length_1, abs(mod(p.x, 2.0 * length_1) - length_1))\n        + length_1 * smoothstep(0.0, length_1, p.y * (p.x + p.y));\n}\n\nfloat sdf(in vec3 pt) {\n    float result = core_sdf(pt);\n    if (abs(result) < 14.0 * crinkle) {\n        vec3 cell_rel = mod(pt, vec3(2.0 * crinkle)) - 1.0 * vec3(crinkle);\n        cell_rel.z = 0.5 * result;\n        vec3 cell_center = pt - cell_rel;\n        cell_rel.xy = abs(cell_rel.xy);\n        vec2 uv = cell_center.xy * 2.0 * iResolution.yx/iResolution.x + vec2(0.5, 0.0);\n        float max_hole_size = crinkle * 1.0;\n        float hole_size = max_hole_size * do_bright_clamp(dot(texture(iChannel0, uv).rgb, 0.8 * vec3(1.0, 0.75, 0.75)));\n        float in_image = step(0.0, uv.x) * step(0.0, uv.y) * step(uv.x, 1.0) * step(uv.y, 1.0);\n        hole_size = mix(max_hole_size, hole_size, in_image);\n        cell_rel.xy = max(vec2(0.0), cell_rel.xy - vec2(0.5 * hole_size));\n        float hole_dist = 0.5 * hole_size - length(cell_rel.xy);\n#if HOLES_OR_RODS\n        result = smooth_max(result, hole_dist, 0.05 * max_hole_size);\n#else\n        result = smooth_max(result, -hole_dist, 0.05 * max_hole_size);\n#endif\n       // result -= crinkle * smoothstep(0.0, 0.8, simple_noise(32.0 * pt, 28.1));\n    }\n    return result;\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return h_inv *\n        vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n             sdf(pt + vec3(0.0, h, 0.0)) - f,\n             sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\n\n\nfloat raymarch(in vec3 pt, in vec3 dir, out float sumdist) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = sdf(pt);\n    sumdist = 0.0;\n    for(int i = 0; i < 512; ++i) {\n        if (accum > MAX_DIST || s < 1.0e-3) {\n            return accum;\n        }\n        accum += 0.25 * s;\n        p = pt + accum * d;\n        s = sdf(p);\n        sumdist = sumdist + 0.25 * s / max(s, 1.0e-3);\n    }\n    if (s > 1.0e-3) {\n        return MAX_DIST + 1.0;\n    }\n    return accum;\n}\n\nfloat raymarch_out(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float total_step = 0.0;\n    float accum = 0.0;\n    float s = core_sdf(pt);\n    for(int i = 0; i < 256; ++i) {\n        if (total_step > MAX_DIST) {\n            return accum;\n        }\n        float curr_step = 0.75 * max(abs(s), 1.0e-3);\n        total_step += curr_step;\n        accum += curr_step * step(s, 0.0); \n        p = pt + total_step * d;\n        s = core_sdf(p);\n    }\n    return accum;\n}\n\nfloat ramp(in float a, in float b, in float x) {\n    float p = (x-a)/(b-a);\n    return clamp(p, 0.0, 1.0);\n}\n\nvec4 color_at(in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 6.0));\n    \n    vec3 orig = vec3(0.0, 0.25, -1.5);\n    \n    float theta = 0.0625 * sin(0.25 * iTime) + 3.141592654;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    mat3 spin = mat3(ct, 0.0, st,\n                     0.0, 1.0, 0.0,\n                     -st, 0.0, ct);\n    \n    theta = 0.25 * sin(iTime);\n    vec2 trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.8 * trigs.x - 0.6 * trigs.y;\n    st = 0.6 * trigs.x + 0.8 * trigs.y;\n\ttheta = 0.25 * sin(1.21 * iTime);\n    trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.6 * trigs.x - 0.8 * trigs.y;\n    st = 0.8 * trigs.x + 0.6 * trigs.y;\n    \n    \n    theta = 0.25 * sin(0.93 * iTime);\n    trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.8 * trigs.x - 0.6 * trigs.y;\n    st = 0.6 * trigs.x + 0.8 * trigs.y;\n    \n    orig = spin * orig;\n    dir = spin * dir;\n    \n    float cloud_integral = 0.0;\n    \n    float dist = raymarch(orig, dir, cloud_integral);\n    \n    vec3 color_mul = vec3(1.0);\n    \n    \n    vec3 col = vec3(0.0);\n    vec3 refl_color = 1.0 * vec3(0.8, 1.0, 0.5);\n    vec3 trans_color = 1.0 * vec3(1.0, 0.1, 0.5); // 1.0 , 0.5, 0.4);\n    float thru_dist = 1000.0;\n    vec3 n = dir;\n    if (dist < MAX_DIST) {\n        vec3 pt = orig + dir * dist;\n        thru_dist = raymarch_out(pt, light_dir);\n        n = normalize(sdf_grad(pt));\n        dir = normalize(reflect(dir, n));\n  \n\n    \n    \tcol = (0.8 * smoothstep(0.99, 1.0, dot(dir, light_dir)) + 0.5 * smoothstep(0.2, 1.0, dot(n, light_dir)))*\n        \trefl_color;\n    \n\t    float pen_length = 0.1 * length_1; //  10.25 * crinkle;\n    \tfloat soften_subsurface = 1.0;\n    \n\t    col += ( soften_subsurface * pen_length / max(abs(soften_subsurface *  thru_dist), pen_length)) * trans_color;\n    \n    }\n    float sweep = 20.0 * fragCoord.x / iResolution.x + smoothstep(0.0, iResolution.y, fragCoord.y);\n    float cloud_modulate = 0.25; //  + 0.25 * sin(1.71 * iTime + sweep);\n    float cloud_contrib =  0.05 * cloud_modulate * cloud_integral;\n    // cloud_contrib *= smoothstep(0.4, 0.6, cloud_contrib);\n    col +=  1.0 * vec3(-1.0, 1.0, 1.0) * cloud_contrib;\n\n    // col = vec3(freckles, 0.0);\n    // Output to screen\n    return  vec4(color_mul * col,1.0);\n}\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // length_1 += 0.05 * length_1 * sin(0.11 * iTime);\n    \n \n\tvec4 col_out = color_at(fragCoord);\n#if SUPERSAMPLE\n    col_out *= 0.25;\n    const float scatter_scale = 0.8;\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.6, 0.8));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(-1.0, 0.0));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.0, -1.0));\n#endif\n    fragColor = col_out;\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nfloat smooth_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nvec3 smooth_max(in vec3 x, in vec3 y, float s) {\n\treturn vec3(smooth_max(x.x, y.x, s),\n                smooth_max(x.y, y.y, s),\n                smooth_max(x.z, y.z, s));\n}\n\nfloat smooth_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nvec3 smooth_min(in vec3 x, in vec3 y, float s) {\n\treturn vec3(smooth_min(x.x, y.x, s),\n                smooth_min(x.y, y.y, s),\n                smooth_min(x.z, y.z, s));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2BWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 452, 452, 769], [771, 771, 799, 799, 1260], [1262, 1262, 1287, 1287, 1454], [1456, 1456, 1479, 1479, 2578], [2580, 2580, 2607, 2607, 2854], [2858, 2858, 2918, 2918, 3361], [3363, 3363, 3408, 3408, 3856], [3858, 3858, 3906, 3906, 3966], [3968, 3968, 4003, 4053, 6385], [6391, 6391, 6448, 6504, 6886]], "test": "untested"}
{"id": "tljSRm", "name": "Particle sketch", "author": "Lallis", "description": "Some particles spinning around and doing random walks.\nJust another 2d sketch I had laying around from some time ago and was unpublished for some reason.\nPay no attention to the uncommented and unreadable code. ;)", "tags": ["2d", "particles", "multipass"], "likes": 10, "viewed": 520, "published": 3, "date": "1589841343", "time_retrieved": "2024-07-30T21:06:10.090232", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec3 col = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    float pls = texelFetch(iChannel0, ivec2(iResolution)-ivec2(2,1), 0).r;\n    //float pls = texture(iChannel2, vec2(0.0078125,0.25)).r;\n    //pls*=pls*pls;\n    pls = 1.0-pls;\n    col = smoothstep(0.025*pls+0.01,0.10*pls+0.05,col);\n    \n    \n    col = pow(col,vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(iResolution)-1, 0);\n    if( int(fragCoord.x) == int(iResolution.x)-1 \n       && int(fragCoord.y) == int(iResolution.y)-1 ) {\n        \n        float dt = time - data.z;\n    \tfragColor = vec4(iResolution.x, iResolution.y, time, dt);\n        return;\n    }\n    \n    float pls = texture(iChannel2, vec2(0.0078125,0.25)).r;\n    if( int(fragCoord.x) == int(iResolution.x)-2 \n       && int(fragCoord.y) == int(iResolution.y)-1 ) {\n\t\t\n        fragColor = vec4(pls);\n        return;\n    }\n\n    \n    int idx = int(fragCoord.x) + int(fragCoord.y)*int(iResolution.x);\n    \n    if( idx >= nParticles || iFrame == 0 || iResolution.x != data.x || iResolution.y != data.y) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    float dt = data.w;\n    \n    vec4 res = vec4(0.0); \n    vec4 state = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec3 r = hash3(uint(idx+nParticles*int(time*0.5)));\n    \n    \n\n    float v = r.y*0.25+0.05;\n    \n    float phi;\n    \n    phi = r.x*2.0*PI;//+PI/8.0*(2.0*r.z*r.z-1.0)*time*25.0*v;\n    res.z = phi;\n    \n    if(fract(time/16.0) > 0.25) {\n        vec3 r2 = hash3(uint(time/16.0));\n       \n        float xi = r2.x*2.0-1.0;\n        float dir = sign(xi);\n        \n        //float rot = 2.0*PI*abs(xi);\n        \n        vec2 ps = state.xy;\n        \n        phi = atan(ps.y,ps.x);\n           \n        float n = floor(r2.z*6.0)*0.5 + 1.5;\n       \n\n        float inw = r2.y > 0.75 ? 1.0 : 0.0;\n        \n        if(abs(xi) < 0.5)\n        \tphi = (floor(phi/(PI/n)) + 0.5 + 0.5*dir*inw )*(PI/n);\n \n        \n        phi += PI*0.5*dir;\n \t\t//phi = r.x*2.0*PI+PI/8.0*fract(time)*25.0;\n    }\n    \n    \n    res.xy = state.xy + vec2( cos(phi), sin(phi) )*v*dt;\n    \n\n    \n    float sx = iResolution.x/iResolution.y;\n    if(res.x > sx)\n        res.x = sx;\n    if(res.y > sx)\n        res.y = sx;\n    if(res.x < -sx)\n        res.x = -sx;\n    if(res.y < -sx)\n        res.y = -sx;\n    \n    \n    fragColor = res;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define time iTime*2.0\n#define PI 3.14159265359\n\nconst int nParticles = 512;\n\n// Integer Hash\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n", "buffer_b_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = 2.0*uv-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n\tfloat pls = texelFetch(iChannel0, ivec2(iResolution)-ivec2(2,1), 0).r;\n    pls = smoothstep(0.8,1.0,pls);\n    float a = pls*PI/8.0;\n    \n    p = vec2(cos(a)*p.x+sin(a)*p.y, -sin(a)*p.x+cos(a)*p.y);\n    \n    vec3 col = vec3(0.011);\n    \n    vec4 data = texelFetch(iChannel0, ivec2(iResolution)-1, 0);\n    \n    float dt = data.w;\n    \n    for(int i = 0; i < nParticles; ++i) {\n        ivec2 idx = ivec2( i % int(iResolution.x), i / int(iResolution.x));\n    \tvec4 state = texelFetch(iChannel0, idx, 0);\n        \n        float d = length(p-state.xy);\n        float cd = length(state.xy);\n        \n        vec3 c = mix(vec3(0.5,sin(time*0.1)*0.5+0.5,0.2), vec3(0.2,0.3,0.6), clamp(0.0,1.0,cd*0.78));\n        col += smoothstep(0.01, 0.005, d)*c;\n    }\n\tvec3 old = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    col = mix(col, old,(1.0-dt));\n    col = clamp(col,vec3(0.0),vec3(1.0));\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 436]], "test": "untested"}
{"id": "3sjBWR", "name": "Basic powder thing", "author": "Plento", "description": "Wanted to try something powder like but I'm sure there's better ways to do something like this. Use mouse to add powder and hold Q to delete powder. ", "tags": ["2d", "simulation", "buffer", "cellularautomata", "powder"], "likes": 8, "viewed": 509, "published": 3, "date": "1589834750", "time_retrieved": "2024-07-30T21:06:10.828259", "image_code": "// Use mouse to add powder. Q to remove powder\nvec2 R;\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    \n    f = vec4(vec3(texelFetch(iChannel0, ivec2(u), 0).x), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(p) texelFetch(iChannel0, ivec2(p), 0)\n#define KEY(v,m) texelFetch(iChannel1, ivec2(v, m), 0).x\nmat2x4 N(vec2 u){\n    return mat2x4(\n        vec4(\n            A(u+vec2(0., 1.)).x,\n        \tA(u+vec2(0., -1.)).x, \n        \tA(u+vec2(1., 0.)).x, \n        \tA(u+vec2(-1., 0.)).x\n        ),\n        vec4(\n            A(u+vec2(-1., 1.)).x,\n        \tA(u+vec2(-1., -1.)).x,\n        \tA(u+vec2(1., 1.)).x,\n        \tA(u+vec2(1., -1.)).x\n        )\n    );\n}\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec4 bA = A(u);\n    mat2x4 n = N(u);\n        \n    if(n[0].x == 1. && bA.x == 0.)bA.x = 1.;\n    else if(bA.x == 1. && n[0].y == 0.)bA.x = 0.;\n    \n    if(n[0].x == 0.){\n    \tif(n[1].x + n[0].w + n[1].y == 3.) bA.x = 1.;\n    \tif(n[1].z + n[0].z + n[1].w == 3.) bA.x = 1.;\n    }\n    \n    if(length(iMouse.xy-u) < 30. && iMouse.z > 1.) bA.x = 1.-KEY(81., 0.);\n    if(iFrame < 4) bA = vec4(0);\n    \n    f = bA;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 95, 95, 189]], "test": "untested"}
{"id": "WdjBWR", "name": "大龙猫 - Quicky#036", "author": "totetmatt", "description": "Nothing special just random imbrication of function", "tags": ["quicky"], "likes": 2, "viewed": 352, "published": 3, "date": "1589830287", "time_retrieved": "2024-07-30T21:06:11.677987", "image_code": "mat2 r(float f){\n    float c=cos(f),s=sin(f);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy) / iResolution.y;\n    vec2 uuv = uv*.5;\n    uv*=r(atan(uv.x,uv.y)*2.5)*r(sign(cos(length(sin(uv*r(iTime)*10.)*3.)))*iTime);\n    for(float i=0.;i<=4.;i++){\n        uv = abs(uv)-.5;\n        uv *=r(sign(sin(length(uv*5.)))*length(uuv));\n    }\n    float d = smoothstep(-1.,1.9-length(uv-uv)*4.,tan(-iTime+cos(iTime)*5.+10.*(uv.y+uv.x))/tan(iTime-sin(-iTime)*5.+10.*(uv.y-uv.x))  );\n    vec3 col = vec3(d);\n    col = mix(vec3(.1/length(uv),.1,.1/length(uv)),vec3(.1,.2+.1/length(uv),length(uuv)+length(uv)),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 74], [75, 75, 130, 130, 719]], "test": "untested"}
{"id": "wsBfDz", "name": "Solar Grains - Suns Set to Music", "author": "Yambam", "description": "Music visualization fork of https://www.shadertoy.com/view/wdSfzm (Simulating the Sunrise/Sunset) by myself\nWhich is a fork of https://www.shadertoy.com/view/tdBfRw (Simulating the Colors of the Sky) by jamelouis", "tags": ["sunset", "sun", "colors", "sky", "fork", "sunrise", "sunrise", "granular", "simulating"], "likes": 6, "viewed": 621, "published": 3, "date": "1589829952", "time_retrieved": "2024-07-30T21:06:12.523726", "image_code": "const float INFINITY = 3.402823466e+38;\n//const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926;\nconst float DURATION = 2.;\n\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 3u;\n    uint numSamplesLight = 3u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3. / (16. * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    vec3 betaRt = betaR*(1.-(iMouse.y/iResolution.y) + vec3(0.,2.,3.)*(iMouse.x/iResolution.x-.2));\n    vec3 betaMt = betaM*(1. + 16.*0.); //iMouse.y/iResolution.y);\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaRt * (opticalDepthR + opticalDepthLightR) + betaMt * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaRt * phaseR + sumM * betaMt * phaseM) * 20.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x_spectro_free = (fragCoord.x/iResolution.x*20.);\n    /*float x_spectro = .2+.6*x_spectro_free/16.;\n    float fft  = (texture( iChannel0, vec2(x_spectro,0.0) - .2 ).x)*.5-.3;*/\n    \n    float x_spectro_floor = floor(x_spectro_free);\n    float x_spectro_ceil = ceil(x_spectro_free);\n    vec2 x_spectro = .2+.6*vec2(x_spectro_floor,x_spectro_ceil)/20.;\n    float fft  = mix(\n        (texture( iChannel0, vec2(x_spectro.x,0.0) - .2 ).x)\n        ,\n        (texture( iChannel0, vec2(x_spectro.y,0.0) - .2 ).x)\n        ,\n        min((x_spectro_free-x_spectro_floor)*3.,1.) // /(x_spectro_ceil-x_spectro_floor)\n    );\n    //fft = .4-.8*iMouse.x/iResolution.x;\n    //fft = 0.;\n    \n    float daylightCycleSpeed = 1./60.; //0.; //\n    \n    float angle = M_PI * (.0 + 2.*M_PI*(-.0185+.02*sin(2.*M_PI*(iTime*daylightCycleSpeed-.775))+pow(.2835-.1*fft, 2.))); //fract((float(iFrame)/DURATION+40.)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy  * 2.0 - 1.0;\n    bool reflection;\n    if (uv.y<0.) {\n        uv.y = -uv.y;\n        reflection = true;\n    } else {\n        uv.y = .65*uv.y;\n        reflection = false;\n    }\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float scale = .3;\n    float y_scale = 1.;\n    \n    float x = 0.+.5/y_scale*uv.x + .15*iTime + .7*sin(.2*iTime);//float(iFrame)/60.;\n    \n    float y = -.5 * (1. - (.0115*2.4*(-.25 //+ 4.*iMouse.y/iResolution.y\n  + pow(4.+\n        1.000*sin(x*M_PI*1.)\n      + 1.000*sin(x*M_PI*3.)\n      + 0.512*sin(x*M_PI*5.)\n      + 0.512*sin(x*M_PI*7.)\n      + 0.640*sin(x*M_PI*9.)\n      + 0.640*sin(x*M_PI*11.)\n        ,\n        .35\n    )) + .5/y_scale*mod(uv.y, y_scale)));\n    \n    /*y = -.4885 - .0115*2.4*(-1.5 //+ 4.*iMouse.y/iResolution.y\n  + pow(4.+\n        1.000*sin(x*M_PI*1.)\n      + 1.000*sin(x*M_PI*3.)\n      + 0.512*sin(x*M_PI*5.)\n      + 0.512*sin(x*M_PI*7.)\n      + 0.640*sin(x*M_PI*9.)\n      + 0.640*sin(x*M_PI*11.)\n        ,\n        .5\n    )) + .5/y_scale*mod(uv.y, y_scale);*/\n    \n    if (y < -.47) {\n    \ty = mix(y, -.5, min((-.47 - y)/.03*3., 1.));\n    }\n    \n    float z2 = x*x + y*y;\n    \n    vec3 col = vec3(0.0);\n    //if(z2 <= 1.){\n        float phi = x*M_PI*scale;\n        float theta;\n        if (fract(x)*scale > .5) { //<-- Makes the sun rise and set on the same position\n        //if (fract((float(iFrame)/DURATION+40.)/180.) < .5) {\n            theta = y*M_PI*scale-1.125;\n        } else {\n            theta = -(y*M_PI*scale-1.125);\n        }\n        vec3 dir = vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n        col = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir, 0., INFINITY, sunDirection);\n    //}\n    \n\n    // Output to screen\n    //fft  = texture( iChannel0, vec2(x_spectro,0.0) ).x*9.+0.2;\n    //col = pow(col, vec3(1./.6/2.6));\n    col = pow(col, vec3(1./.6/y_scale/(1.5/y_scale+.85/y_scale*(reflection?1.:0.))));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22949, "src": "https://soundcloud.com/wojtek-szczepanik/the-day-after", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 393, 479, 479, 735], [737, 737, 823, 823, 3247], [3249, 3249, 3306, 3306, 6296]], "test": "untested"}
{"id": "WdjBzW", "name": "Pong(?)", "author": "rblb", "description": "Raytraced pong game ( ͡° ͜ʖ ͡°)\nUP & DOWN arrows to take control of one paddle (it turns green).", "tags": ["game"], "likes": 0, "viewed": 1116, "published": 3, "date": "1589825472", "time_retrieved": "2024-07-30T21:06:13.571923", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v_rgbNW;\n\tvec2 v_rgbNE;\n\tvec2 v_rgbSW;\n\tvec2 v_rgbSE;\n\tvec2 v_rgbM;\n\n\ttexcoords(fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\t\n\tfragColor = fxaa(iChannel0, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n//\tfragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n\n\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "precision highp float;\nprecision highp sampler2D;\nprecision highp samplerCube;\nprecision highp int;\n\n// HELPERS\n#define PI 3.14159265\n\n\nmat4 mat4_rotationFromAngleAxis(in float angle, in vec3 v){\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 mat4_translation(in vec3 v){\n    float x=v.x;\n    float y=v.y;\n    float z=v.z;\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n// Scene\nstruct Camera{\n\tvec3 pos;\n    vec3 dir;\n   \tvec3 right;\n    vec3 up;\n};\n    \n    \nstruct Ray{\n  \tvec3 origin;\n  \tvec3 direction;\n};\n    \n    \nvoid Camera_setDirection(inout Camera cam,in vec3 up,in vec3 direction){\n    cam.dir=direction;\n    cam.right=normalize(cross(up, cam.pos));\n   \tcam.up = cross(cam.dir, cam.right);\n}\n\nvoid Camera_lookAt(inout Camera cam,in vec3 up,in vec3 target){\n    Camera_setDirection(cam,up,normalize(target-cam.pos));\n}\n\nvec3 getCameraOrigin(float time){\n    \n           float m_x = time*0.01;\n        float m_y = (sin(time)*0.5+0.5)*-0.1;    \n    vec3 cameraOrigin = vec3(5.0 * sin(m_x * PI * 2.), m_y * 10.0-1., 5.0 * cos(m_x * PI * 2.));\n\treturn cameraOrigin;\n}\n\nCamera Camera_new(in vec3 pos){\n\tCamera cam;\n    cam.pos=pos;\n    Camera_setDirection(cam,vec3(0,1,0),vec3(0,0,1));\n\treturn cam;\n    \n    \n}\n\nCamera Camera_newDemo(in float time){\n\tvec3 pos=getCameraOrigin(time);   \n    return Camera_new(pos);\n}\n\n\n\n\n\n\n\nRay Ray_fromCam(in Camera cam,in vec2 fragCoord,in vec2 iResolution){\n\tRay ray;\n\n    vec2 uv=(fragCoord.xy / iResolution.xy);\n    \n \tvec2 screenPos=uv*2.-1.;\n    screenPos.x*=iResolution.x/iResolution.y;\n    \n    ray.origin=cam.pos;\n    ray.direction=normalize(cam.right * screenPos.x + cam.up * screenPos.y + cam.dir);\n    return ray;\n    \n}\n    \n    \n// Shapes\nstruct Sphere{\n    vec3 pos;\n    float radius;\n    mat4 rot;\n\n};   \n    \nstruct Box{\n    vec3 pos;\n    vec3 size;\n\tmat4 rot;\n};  \n    \n    \n\n\n// Raytracing\nstruct IRes {\n  \tvec3 pos;\n    vec3 norm;\n    float tmin;\n    bool hit;\n};\n    \n    \n\n        \n\n\n// https://iquilezles.org/articles/boxfunctions\nIRes raytrace(in Ray ray,in Box box ){\n  \tIRes res;\n    res.hit=false;\n  \tres.tmin=-1.;\n\n    vec3 ro=ray.origin;\n    vec3 rd=ray.direction;\n    \n    vec3 rad=box.size;\n    \n    mat4 rot = box.rot;\n\tmat4 tra = mat4_translation(box.pos);\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\n    \n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return res;\n       \n    \n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = normalize((txi * vec4(nor,0.0)).xyz);\n    \n\tres.hit=true;\n    res.pos=ro + tN*rd;\n    res.norm=nor;\n    res.tmin=tN;\n    res.hit=res.tmin>0.;\n\treturn res;\n}\n\n\n\n// Ray-Sphere intersection\nIRes raytrace( in Ray ray,in Sphere sphere ){\n    IRes res;\n\tres.hit=false;\n    res.tmin=-1.;    \n    vec3 ro=ray.origin;\n    vec3 rd=ray.direction;\n    vec4 sph=vec4(sphere.pos,sphere.radius);\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return res;\n    float tN=-b - sqrt( h );   \n    res.pos=ro + tN*rd;\n    res.norm= normalize(res.pos-sphere.pos);\n    res.tmin=tN;\n    res.hit=tN>0.; \n    return res;\n}\n\n\n\n// RENDER\n\nvoid packFb(inout vec4 fb,in Ray ray,in vec3 pos,in vec3 norm,in float material){\n    float dpos=distance(ray.origin,pos);\n    fb.r=dpos;\n    fb.g=floor(material*10.);\n    \n    vec3 n=norm*.5+.5;\n    fb.g+=n.x;\n\tfb.b=n.y;\n    \n}\n\n\nvoid unpackFb(in vec4 fb,in Ray ray,out vec3 pos,out vec3 norm,out float material){\n   pos=ray.origin+ray.direction*fb.r;\n   material=floor(fb.g/10.);\n\n    norm.x=fb.g-(material*10.);\n    norm.y=fb.b;\n    norm.xy=norm.xy*2.-1.;\n    norm.z = sqrt(1.-clamp(dot(norm.xy, norm.xy),0.,1.)); // Reconstruct Z\n        \n}\n\n\nvoid packFb2(inout vec4 fb,in Ray ray,in vec3 pos,in vec3 norm,in float material){\n    fb.a=material;\n}\n\n\n\nvoid unpackFb2(in vec4 fb,in Ray ray,out vec3 pos,out vec3 norm,out float material){\n   material=fb.a;    \n}\n\n\n\n// GAME LOGIC\n\n#define PLAYER1 0\n#define PLAYER2 1\n\n\n\n#define GAME_SPEED 1.\n#define BALL_SPEED 240.\n#define PADDLE_SPEED 200.\n#define PADDLE_SIZE vec2(10,60)\n#define BALL_SIZE vec2(15,15)\n\n\n\n#define SHAPE_RECT 0\n\n\n#define GROUND_SIZE vec2(800,450)\n\nstruct State{\n    vec2 paddle1Pos;\n  \tvec2 paddle2Pos;\n    bool paddle1UnderControl;\n  \tvec2 ballPos;\n  \tvec2 ballDir;\n    float score;\n};\n    \n    \nstruct Paddle{\n    vec2 pos;\n    float speed;    \n    vec2 size;\n    int shape;\n    int playerId;\n    bool underControl;\n};\n\nstruct Ball{\n \tvec2 pos;\n    vec2 speed;\n    vec2 size;\n    int shape;\n};\n\n  \n#define MEMORY_REGION_PADDLE1POS ivec2(0,0)\n#define MEMORY_REGION_PADDLE2POS ivec2(1,0)\n#define MEMORY_REGION_BALLPOS ivec2(2,0)\n#define MEMORY_REGION_BALLDIR ivec2(3,0)\n#define MEMORY_REGION_SCORE1 ivec2(4,0)\n#define MEMORY_REGION_SCORE2 ivec2(5,0)\n    \n#define limitMemoryRegion() if(fragCoord.y>=1.||fragCoord.x>=6.)return;\n#define isInPaddle1ActionRegion() (ivec2(fragCoord.xy)==MEMORY_REGION_PADDLE1POS)\n#define isInPaddle2ActionRegion() (ivec2(fragCoord.xy)==MEMORY_REGION_PADDLE2POS)\n    \n    \n#define _write(at,value) { if(ivec2(fragCoord)==at)fragColor=value; };\n#define _load(at) texelFetch(iChannel1, at, 0)\nvoid writeState(in vec2 fragCoord,in State state,out vec4 fragColor){\n\t_write(ivec2(0,0),vec4(state.paddle1Pos.x,state.paddle1Pos.y,0.,0.));\n\t_write(ivec2(1,0),vec4(state.paddle2Pos.x,state.paddle2Pos.y,0.,0.));\n\t_write(ivec2(2,0),vec4(state.ballPos.x,state.ballPos.y,0.,0.));\n\t_write(ivec2(3,0),vec4(state.ballDir.x,state.ballDir.y,0.,0.));\n\t_write(ivec2(4,0),vec4(state.score,0.,0.,0.));\n\t_write(ivec2(5,0),vec4(state.paddle1UnderControl?1.:0.,0.,0.,0.));\n    \n}\n\nState loadState(in sampler2D iChannel1){\n    State state;\n    state.paddle1Pos=_load(ivec2(0,0)).xy;\n    state.paddle2Pos=_load(ivec2(1,0)).xy;\n    state.ballPos=_load(ivec2(2,0)).xy;\n    state.ballDir=_load(ivec2(3,0)).xy;\n    state.score=_load(ivec2(4,0)).x;\n    state.paddle1UnderControl=_load(ivec2(5,0)).x==1.;\n    return state;\n}\n\n\n\nPaddle getPaddle(in int playerId,in State state){\n\tPaddle paddle;\n    if(playerId==PLAYER1){\n    \tpaddle.pos=state.paddle1Pos;   \n        paddle.underControl=state.paddle1UnderControl;\n    }else{\n     \tpaddle.pos=state.paddle2Pos;  \n        paddle.underControl=false;\n    }\n    paddle.playerId=playerId;    \n    paddle.speed=PADDLE_SPEED*GAME_SPEED;\n    paddle.size=PADDLE_SIZE;\n    paddle.shape=SHAPE_RECT;\n    \n    return paddle;   \n}\n\n\n\nBall getBall(in State state){\n\tBall ball;\n   \n    ball.pos=state.ballPos;\n    ball.speed=state.ballDir*BALL_SPEED*GAME_SPEED;\n\tball.size=BALL_SIZE;\n    ball.shape=SHAPE_RECT;\n    \n    return ball;   \n}\n\n\nvoid setPaddle(inout State state,in Paddle paddle){\n    if(paddle.playerId==PLAYER1){\n    \tstate.paddle1Pos=paddle.pos;   \n    \tstate.paddle1UnderControl=paddle.underControl;\n    }else{\n        state.paddle2Pos=paddle.pos;   \n    }\n    \n}\n\n\nvoid setBall(inout State state,in Ball ball){\n\tstate.ballPos=ball.pos;   \n   \tstate.ballDir=normalize(ball.speed);   \n}\n\n\n\n\n#define MATERIAL_GROUND 1.\n#define MATERIAL_PADDLE 2.\n#define MATERIAL_PADDLE_CONTROLLED 4.\n#define MATERIAL_BALL 3.\n#define MATERIAL_SKY 5.\n\n// fxaa\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n--\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\nCopyright (c) 2011 by Armin Ronacher.\nSome rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent \n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture(tex, v_rgbSE).xyz;\n    vec4 texColor = texture(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n        texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n\t\t\tout vec2 v_rgbNW, out vec2 v_rgbNE,\n\t\t\tout vec2 v_rgbSW, out vec2 v_rgbSE,\n\t\t\tout vec2 v_rgbM) {\n\tvec2 inverseVP = 1.0 / resolution.xy;\n\tv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n\tv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n\tv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n\tv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n\tv_rgbM = vec2(fragCoord * inverseVP);\n}\n\n", "buffer_a_code": "// GAME LOGIC\n\n#define KEY_PLAYER1_UP 38\n#define KEY_PLAYER1_DOWN 40\n\n#define isKey(key) (texelFetch(iChannel0, ivec2(key, 0), 0).x==1.)\n#define isInRect(point,at,size)(point.x>at.x&&point.y>at.y&& point.x<at.x+size.x&&point.y<at.y+size.y)\n\n\nbool ballPaddleCollide(in Ball ball,in Paddle paddle){\n    return isInRect(ball.pos,paddle.pos,paddle.size);\n}\n\nbool ballEdgesCollide(in Ball ball) {\n    return((ball.pos.y>GROUND_SIZE.y||ball.pos.y<0.));\n}\n\nint ballGoal(in Ball ball){\n    return (ball.pos.x>GROUND_SIZE.x?PLAYER1:ball.pos.x<0.?PLAYER2:-1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    limitMemoryRegion();\n    \n    State state=loadState(iChannel1);\n    \n    Paddle paddle1=getPaddle(PLAYER1,state);\n    Paddle paddle2=getPaddle(PLAYER2,state);\n    \n    Ball ball=getBall(state);\n        \n    \n    int goal=ballGoal(ball);\n\n  \n    paddle1.pos.x=0.;\n    paddle2.pos.x=GROUND_SIZE.x-paddle2.size.x;\n    \n    \n    if(isKey(KEY_PLAYER1_UP)){\n        paddle1.pos.y=paddle1.pos.y+paddle1.speed*iTimeDelta;\n        paddle1.underControl=true;\n    }else if(isKey(KEY_PLAYER1_DOWN)){\n        paddle1.pos.y=paddle1.pos.y-paddle1.speed*iTimeDelta;\n        paddle1.underControl=true;\n    }\n    \n    \n    \n    \n    bool reset=length(ball.speed)==0.;\n    \n    if(goal!=-1){\n     \treset=true;\n        if(goal==PLAYER1)state.score++;   \n    }\n    \n    \n    if(reset){\n    \tball.pos=GROUND_SIZE.xy/2.;\n        ball.speed=texture(iChannel2,vec2(iTime,iTime)).rg*2.-1.;\n        ball.speed+=vec2(0.2*sign( ball.speed.x),0);// bias on X\n        ball.speed=normalize(ball.speed);\n        ball.speed*=BALL_SPEED*GAME_SPEED;            \n    }\n\n\n    if(ballEdgesCollide(ball)) ball.speed.y*=-1.;    \t   \n    \n    \n    if(isInPaddle2ActionRegion()){\n    \tfloat d=GROUND_SIZE.x-ball.pos.x;\n        if(d>0.){\n       \t\tpaddle2.pos.y+=sign(ball.pos.y-paddle2.pos.y)*paddle2.speed*iTimeDelta;\n        }        \n    }else if(isInPaddle1ActionRegion()&&!paddle1.underControl){\n    \tfloat d=GROUND_SIZE.x-ball.pos.x;\n        if(d>0.){\n       \t\tpaddle1.pos.y+=sign(ball.pos.y-paddle1.pos.y)*paddle1.speed*iTimeDelta;\n        }        \n    }\n    \n    \n    \n   \n    if(ballPaddleCollide(ball,paddle1)) {\n\t\tif(ball.speed.x<0.)ball.speed.x*=-1.;\n    }else if(ballPaddleCollide(ball,paddle2)){\n    \tif(ball.speed.x>0.)ball.speed.x*=-1.;\n    }\n        \n        \n    ball.pos+=ball.speed*iTimeDelta;\n    \n    \n    paddle1.pos.y=clamp(paddle1.pos.y,0.,GROUND_SIZE.y-paddle1.size.y);\n    paddle2.pos.y=clamp(paddle2.pos.y,0.,GROUND_SIZE.y-paddle2.size.y);\n\n    \n    setPaddle(state,paddle1);\n    setPaddle(state,paddle2);\n    setBall(state,ball);\n    \n    \n    writeState(fragCoord,state,fragColor);\n\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// RENDERER\n\n\nstruct RenderContext{\n  IRes lastMerge;\n};\n    \nRenderContext RenderContext_new(){\n\tRenderContext ctx;\n    ctx.lastMerge.hit=false;\n    ctx.lastMerge.tmin=-1.;\n    return ctx;\n}\n\n    \nbool merge(inout RenderContext ctx,in IRes a){\n    bool m=a.hit&&(!ctx.lastMerge.hit||ctx.lastMerge.tmin>a.tmin);\n\tif(m){\n    \tctx.lastMerge.tmin=a.tmin;\n    \tctx.lastMerge.hit=a.hit;\n \t}   \n\treturn m;\n}\n    \n\n\n#define GROUND_HEIGHT 5.\n#define PADDLE_HEIGHT 32.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    fragColor=vec4(0);\n\n\n    RenderContext ctx=RenderContext_new();\n\n    State state=loadState(iChannel1);\n\n    Paddle paddle1=getPaddle(PLAYER1,state);\n    Paddle paddle2=getPaddle(PLAYER2,state);\n\n\n\n            \n\n    Camera cam=Camera_newDemo(iTime);\n    Camera_lookAt(cam,vec3(0,1,0),vec3(0,0,0));\n    \n\n   \n\n       \n            \n    Ray r=Ray_fromCam(cam,fragCoord.xy,iResolution.xy);\n\n    IRes res;\n\n    packFb(fragColor,r,r.direction*1000.,-r.direction,MATERIAL_SKY);\n    packFb2(fragColor,r,r.direction*1000.,-r.direction,MATERIAL_SKY);\n\n\n\n     const float scale=0.010;\n                \n    vec3 groundExt=(vec3(GROUND_SIZE.x,GROUND_HEIGHT,GROUND_SIZE.y)/2.)*scale;\n\n    mat4 baseRot=mat4_rotationFromAngleAxis(0.,vec3(0,1,0));\n\n\n    \n    vec3 paddleExt=(vec3(PADDLE_SIZE.x,PADDLE_HEIGHT,PADDLE_SIZE.y)/2.)*scale;\n\n    \t\n    vec3 paddle1Pos=vec3(paddle1.pos.x,GROUND_HEIGHT,paddle1.pos.y)*scale;\n    paddle1Pos.x-=groundExt.x;\n    paddle1Pos.z-=groundExt.z;\n    paddle1Pos.y-=paddleExt.y*2.;\n    paddle1Pos.x+=paddleExt.x;\n    paddle1Pos.z+=paddleExt.z;\n\n    Box paddle1Shape=Box(paddle1Pos,paddleExt,baseRot);\n    res=raytrace(r,paddle1Shape);\n\n    if(merge(ctx,res)){\n        packFb(fragColor,r,res.pos,res.norm,paddle1.underControl?MATERIAL_PADDLE_CONTROLLED:MATERIAL_PADDLE);\n    }\n    \n\n   \n        \t\n    vec3 paddle2Pos=vec3(paddle2.pos.x,GROUND_HEIGHT,paddle2.pos.y)*scale;\n    paddle2Pos.x-=groundExt.x;\n    paddle2Pos.z-=groundExt.z;\n    paddle2Pos.y-=paddleExt.y*2.;\n    paddle2Pos.x+=paddleExt.x;\n    paddle2Pos.z+=paddleExt.z;\n    Box paddle2Shape=Box(paddle2Pos,paddleExt,baseRot);\n\n    res=raytrace(r,paddle2Shape);\n\n    if(merge(ctx,res)){\n        packFb(fragColor,r,res.pos,res.norm,MATERIAL_PADDLE);\n    }\n\n    Ball ball=getBall(state);\n\n    vec3 ballPos=vec3(ball.pos.x,GROUND_HEIGHT-(ball.size.x),ball.pos.y);\n    ballPos*=scale;\n    ballPos=ballPos-groundExt;\n\n\n    Sphere ballShape=Sphere( ballPos,ball.size.x*scale,baseRot);\n    res=raytrace(r,ballShape);\n    if(merge(ctx,res)){\n        packFb(fragColor,r,res.pos,res.norm,MATERIAL_BALL);\n    }\n\n    \n    \n    Box groundShape=Box(vec3(0.,0.,0.),groundExt,baseRot);\n\n    IRes groundHit=raytrace(r,groundShape);\n\n    if(merge(ctx,groundHit)){\n    \tfloat mat=MATERIAL_GROUND;\n            packFb(fragColor,r,groundHit.pos,groundHit.norm,MATERIAL_GROUND);\n\n        Ray reflection;\n        reflection.origin=groundHit.pos;\n        reflection.direction=reflect(r.direction, groundHit.norm);\n\n        res=raytrace(reflection,paddle1Shape);\n        if(merge(ctx,res)){\n            packFb2(fragColor,r,groundHit.pos,groundHit.norm,paddle1.underControl?MATERIAL_PADDLE_CONTROLLED:MATERIAL_PADDLE);\n        }\n        \n        res=raytrace(reflection,paddle2Shape);\n        if(merge(ctx,res)){\n            packFb2(fragColor,r,res.pos,res.norm,MATERIAL_PADDLE);\n        }\n        \n \t\tres=raytrace(reflection,ballShape);\n        if(merge(ctx,res)){\n            packFb2(fragColor,r,res.pos,res.norm,MATERIAL_BALL);\n        }\n        \n        \n\n    }\n\n     \n    \n}", "buffer_b_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\nvec4 getDisplacement(in vec3 pos,in float displacementStrength){\n        vec4 disp=texture(iChannel2,pos.xz*vec2(2,1))*displacementStrength;\nreturn disp;\n}\nvoid lighting(in vec3 pos,in vec3 norm,in vec3 color,in float reflectionStrength,in float displacementStrength,inout vec4 fragColor){\n    \n\tconst float specularStrength=12.4;\n    const vec3 lightDir = normalize(vec3(0.0, -1.0, -0.4));\n    const vec3 lightColor=vec3(1);\n\n    \n    //vec4 disp=texture(iChannel2,pos.xz*vec2(2,1))*displacementStrength;\n\tvec4 disp=getDisplacement(pos,displacementStrength);\n    \n    vec3 cameraOrigin=getCameraOrigin(iTime);\n    \n    \n\tvec3 viewDir = normalize(cameraOrigin - pos)+disp.xyz;\n\t\n    \n    float diff = max(dot(norm, lightDir), 0.0);\n\tvec3 diffuse = diff * lightColor;\n\n    \n    \n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    vec3 specular = specularStrength * spec * lightColor;  \n    \n    \n    vec3 R = reflect(viewDir, normalize(norm));\n    \n    \n    vec3 reflection=texture(iChannel3,R).rgb;\n    \n    vec3 result = ( reflection*reflectionStrength+diffuse*(1.-reflectionStrength) + specular) *color;\n    \n  \n\tfragColor = vec4(result, 1.0);  \n    \n}\n\nvoid shadeBall(in vec3 pos,in vec3 norm,inout vec4 fragColor){\n  \tlighting(pos,norm,vec3(1,1,0),0.4,0.6,fragColor);\n}\n\nvoid shadeGround(in vec3 pos,in vec3 norm,inout vec4 fragColor){\n\n\tlighting(pos,norm,vec3(1),.7,0.1,fragColor);\n    \n}\n\nvoid shadePaddle(in vec3 pos,in vec3 norm,inout vec4 fragColor,bool controlled){\n   \tlighting(pos,norm,vec3(1,0,0),.3,0.3,fragColor);    \n   if(controlled) fragColor.g=1.;    \n}\n\nvoid shadeSky(in Ray ray,in vec3 pos,in vec3 norm,inout vec4 fragColor){        \n\n    fragColor=texture(iChannel3,-ray.direction);\n}\n\n\n//Random number [0:1] without sine\n#define HASHSCALE1 .1031\nfloat hash(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nvoid edges(in Ray r,in vec3 pos,in vec3 norm,in float mat,in vec2 fragCoord,inout vec4 fragColor){\n    float edge=0.;\n    const int SAMPLES=32;\n    const float maxDist=6.;\n\tfor( int i=0; i<SAMPLES; i++ ){\n\t\tvec2 rand=(vec2(hash(float(i)),hash(float(i)+10000.))*2.-1.)*maxDist;       \n    \tvec3 pos2;\n        vec3 norm2;\n        float matx2;\n    \tunpackFb(texelFetch(iChannel0,ivec2(fragCoord+rand),0), r,pos2, norm2, matx2);\n       \tvec3 cameraOrigin=getCameraOrigin(iTime);\n\n        float d1=distance(pos,cameraOrigin);\n        float d2=distance(pos2,cameraOrigin);\n        \n        edge += d2 >= d1 || matx2==mat?1.0:0.0;\n    }\n    \n    edge=clamp(edge/float(SAMPLES),0.,1.);\n    fragColor*=edge;\n}\n\nvoid shade(in Camera cam,in Ray ray,in vec3 pos,in vec3 norm,in float mat,out vec4 fragColor,in bool sky,in bool ground){\n    if(ground&&mat==MATERIAL_GROUND){\n        shadeGround(pos,norm,fragColor);      \n    }else if(mat==MATERIAL_BALL){\n        shadeBall(pos,norm,fragColor);\n    }else if(mat==MATERIAL_PADDLE){\n        shadePaddle(pos,norm,fragColor,false);\n    }else if(mat==MATERIAL_PADDLE_CONTROLLED){\n        shadePaddle(pos,norm,fragColor,true);\n    }else if(sky&&mat==MATERIAL_SKY){\n        shadeSky(ray,pos,norm,fragColor);\n    }else{\n        fragColor=vec4(0);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    fragColor=vec4(0,0,0,1);\n    \n        \n    Camera cam=Camera_newDemo(iTime);\n    Camera_lookAt(cam,vec3(0,1,0),vec3(0,0,0));\n    Ray r=Ray_fromCam(cam,fragCoord.xy,iResolution.xy);\n\n      \n    vec3 pos;\n    vec3 norm;\n    float mat;\n    unpackFb(texelFetch(iChannel0,ivec2(fragCoord),0),r, pos, norm, mat);\n   \n    vec3 rpos;\n    vec3 rnorm;\n   \tfloat rmat;\n    vec4 refDisp= getDisplacement( pos,1.);\n\n    unpackFb2(texelFetch(iChannel0,ivec2(fragCoord),0),r, rpos, rnorm, rmat);\n    \n    vec4 c=vec4(0);\n    shade(cam,r,pos,norm,mat,c,true,true);\n    if(mat==MATERIAL_GROUND){        \n\n      vec4 ref=vec4(0); \n       shade(cam,r,pos,rnorm,rmat,ref,false,false);\n       if(length(ref)>0.)c=mix(c,ref,.5*refDisp.x);\n    }\n    fragColor.rgb=c.rgb;\n    fragColor.a=1.;\n\n    edges(r,pos,norm,mat,fragCoord,fragColor);\n\n}", "buffer_c_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v_rgbNW;\n\tvec2 v_rgbNE;\n\tvec2 v_rgbSW;\n\tvec2 v_rgbSE;\n\tvec2 v_rgbM;\n\n\ttexcoords(fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\t\n    //vec2 uv=fragCoord/iResolution.xy;\n   // fragColor=texture(iChannel0,uv);\n    \n    fragColor = fxaa(iChannel0, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n    //vec4 previousFrame=texelFetch(iChannel1,ivec2(fragCoord),0);\n   \tvec4 previousFrame = fxaa(iChannel1, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n\tfragColor.b=mix(fragColor.b,previousFrame.b,0.4);\n\t//fragColor.r=mix(fragColor.r,previousFrame.b,0.1);\n\t//fragColor.g=mix(fragColor.g,previousFrame.b,0.2);\n////\tfragColor.g=mix(fragColor.g,previousFrame.g,0.8);\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 385]], "test": "untested"}
{"id": "wsBBWR", "name": "TRUMP CARD", "author": "yasuo", "description": "nothing special about this.", "tags": ["trump"], "likes": 5, "viewed": 396, "published": 3, "date": "1589812957", "time_retrieved": "2024-07-30T21:06:14.423646", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 16.\n#define SURF_DIST .002\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat heart(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    p.y-=0.05;\n    float d = sdVesica(p,0.15,0.05);\n    d = max(p.y,d);\n    p.x = abs(p.x);\n    p.x -=0.05;\n    float d2 = length(p)-0.05;\n    d = min(d,d2);\n    return d;\n}\n\nfloat spades(vec2 p, vec3 col) {\n    vec2 prevP = p;\n\n    float sc = mix(1.5,0.1,smoothstep(-0.2,0.6,p.y));\n    p.x*=sc;\n    p.y*=1.3;\n    float d = sdTriangle(p,vec2(0.1,0.0),vec2(0.0,0.15),vec2(-0.1,0.0));\n  \tp = prevP;\n    p.x = abs(p.x);\n    p.x -=0.05;\n    p.y +=0.02;\n    float d2 = length(p)-0.05;\n    d = opSmoothUnion(d,d2,0.06);\n    \n    p = prevP;\n    float d3 = sdTriangle(p,vec2(0.03,-0.1),vec2(0.0,-0.04),vec2(-0.03,-0.1));\n    d = min(d,d3);\n    \n    return d;\n}\n\nfloat clover(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    float d = length(p-vec2(0.0,0.05))-0.05;\n    p.x = abs(p.x);\n    p.x -=0.047;\n    p.y +=0.02;\n    float d2 = length(p)-0.05;\n    d = min(d,d2);\n    \n    p = prevP;\n    float d3 = sdTriangle(p,vec2(0.03,-0.1),vec2(0.0,-0.04),vec2(-0.03,-0.1));\n    d = min(d,d3);\n    return d;\n}\n\nfloat diamond(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = sdRhombus(p,vec2(0.05,0.1));\n    return d;\n}\n\nfloat trumpIcon(vec2 p, vec3 col, int type) {\n    float d = heart(p,col);\n  if(type == 2){\n        d = spades(p,col);\n    } else if(type == 3){\n        d = clover(p,col);\n    } else if(type == 4){\n        d = diamond(p,col);\n    }\n    return d;\n}\n\nvec3 trumpTex(vec2 p, vec3 col, int num, int type) {\n    vec2 prevP = p;\n    float d = 0.0;\n    if(num == 1) {\n        d = trumpIcon(p,col,type);\n    } else if(num == 2) {\n        p.y = mod(p.y,0.8)-0.4;\n        d = trumpIcon(p,col,type);\n        p = prevP;\n        d = max(p.y-0.8,d);\n        d = max(-p.y-0.8,d);\n    } else if(num == 3) {\n        p.y+=-0.2;\n    p.y = mod(p.y,0.4)-0.2;\n        d = trumpIcon(p,col,type);\n    p = prevP;\n        d = max(p.y-0.6,d);\n        d = max(-p.y-0.6,d);\n    } else if(num == 4) {\n        p.x = abs(p.x);\n        p.x-=0.2;\n    p.y = mod(p.y,0.8)-0.4;\n        d = trumpIcon(p,col,type);\n        p = prevP;\n        d = max(p.y-0.8,d);\n        d = max(-p.y-0.8,d);\n    } else if(num == 5) {\n        float d2 = trumpIcon(p,col,type);\n    p.x = abs(p.x);\n        p.x-=0.2;\n    p.y = mod(p.y,0.8)-0.4;\n        d = trumpIcon(p,col,type);\n        d = min(d,d2);\n        p = prevP;\n        d = max(p.y-0.8,d);\n        d = max(-p.y-0.8,d);\n    } else if(num == 6) {\n        p.x = abs(p.x);\n        p.x-=0.2;\n        p.y+=-0.2;\n    p.y = mod(p.y,0.4)-0.2;\n        d = trumpIcon(p,col,type);\n    p = prevP;\n        d = max(p.y-0.6,d);\n        d = max(-p.y-0.6,d);\n    } else if(num == 7) {\n        float d2 = trumpIcon(p-vec2(0.0,0.2),col,type);\n        p.x = abs(p.x);\n        p.x-=0.2;\n        p.y+=-0.2;\n    p.y = mod(p.y,0.4)-0.2;\n        d = trumpIcon(p,col,type);\n        d = min(d,d2);\n    p = prevP;\n        d = max(p.y-0.6,d);\n        d = max(-p.y-0.6,d);\n    } else if(num == 8) {\n    float d2 = trumpIcon(p-vec2(0.0,0.2),col,type);\n        float d3 = trumpIcon(p-vec2(0.0,-0.2),col,type);\n        p.x = abs(p.x);\n        p.x-=0.2;\n        p.y+=-0.2;\n    p.y = mod(p.y,0.4)-0.2;\n        d = trumpIcon(p,col,type);\n        d = min(d,min(d2,d3));\n    p = prevP;\n        d = max(p.y-0.6,d);\n        d = max(-p.y-0.6,d);\n    } else if(num == 9) {\n        float d2 = trumpIcon(p,col,type);\n    p.x = abs(p.x);\n        p.x-=0.2;\n    p.y = mod(p.y,0.27)-0.135;\n        d = trumpIcon(p,col,type);\n        d = min(d,d2);\n    p = prevP;\n        d = max(p.y-0.55,d);\n        d = max(-p.y-0.55,d);\n    } else if(num == 10) {\n        float d2 = trumpIcon(p-vec2(0.0,0.25),col,type);\n        float d3 = trumpIcon(p-vec2(0.0,-0.25),col,type);\n    p.x = abs(p.x);\n        p.x-=0.2;\n    p.y = mod(p.y,0.27)-0.135;\n        d = trumpIcon(p,col,type);\n        d = min(d,min(d2,d3));\n    p = prevP;\n        d = max(p.y-0.55,d);\n        d = max(-p.y-0.55,d);\n    }\n    p = prevP;\n    p*=1.5;\n    float d2 = trumpIcon(p-vec2(0.6,0.95),col,type);\n    p.y*=-1.0;\n    float d3 = trumpIcon(p-vec2(-0.6,0.95),col,type);\n    d = min(d,min(d2,d3));\n    col = mix(col,vec3(0.7,0.0,0.0),S(d,0.0));\n    return col;\n}\n\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    vec2 uv = p.xy;\n    uv.y-=1.25;\n    uv*=0.5;\n    \n    p.z+=iTime*10.0;\n    p.z = mod(p.z,4.0)-0.2;\n\n    float y = 0.25;\n\n    // card\n    vec3 size = vec3(1.0,1.5,0.001);\n    float edge = 0.02;\n    float card = sdBox(p-vec3(0.0,1.0+y,0.0),size)-edge;\n    vec3 col = trumpTex(uv,vec3(1.0),1,1);\n    vec4 resA = vec4(col,card);\n\t\n    float card2 = sdBox(p-vec3(0.0,1.0+y,1.0),size)-edge;\n    vec3 col2 = trumpTex(uv,vec3(1.0),3,2);\n    vec4 resB = vec4(col2,card2);\n\t\n    float card3 = sdBox(p-vec3(0.0,1.0+y,2.0),size)-edge;\n    vec3 col3 = trumpTex(uv,vec3(1.0),5,3);\n    vec4 resC = vec4(col3,card3);\n\t\n    float card4 = sdBox(p-vec3(0.0,1.0+y,3.0),size)-edge;\n    vec3 col4 = trumpTex(uv,vec3(1.0),7,4);\n    vec4 resD = vec4(col4,card4);\n\t\t\n    float card5 = sdBox(p-vec3(0.0,1.0+y,4.0),size)-edge;\n    vec3 col5 = trumpTex(uv,vec3(1.0),9,2);\n    vec4 resE = vec4(col5,card5);\n    \n    vec4 model = combine(resA,combine(resB,combine(resC,combine(resD,resE))));\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.5;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 8, -4.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    ro.xz *= Rot(t*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(0.0,0.6,0.3);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 671, 707, 707, 749], [751, 751, 780, 780, 864], [866, 915, 967, 967, 1066], [1068, 1119, 1149, 1149, 1229], [1231, 1282, 1349, 1349, 1914], [1916, 1967, 2009, 2009, 2166], [2168, 2219, 2248, 2248, 2276], [2277, 2277, 2319, 2319, 2514], [2516, 2516, 2547, 2547, 2741], [2743, 2743, 2775, 2775, 3220], [3222, 3222, 3254, 3254, 3561], [3563, 3563, 3596, 3596, 3675], [3677, 3677, 3722, 3722, 3923], [3925, 3925, 3977, 3977, 6646], [6649, 6649, 6671, 6671, 7682], [7684, 7684, 7717, 7717, 7970], [7972, 7972, 7996, 7996, 8197], [8199, 8199, 8222, 8222, 8522], [8524, 8524, 8566, 8566, 8761], [8763, 8763, 8820, 8820, 9533]], "test": "untested"}
{"id": "WdSfWz", "name": "Video displacement map", "author": "Mipmap", "description": "TomF's Displacement map on rast mesh with video for displacement map\n([url]https://www.shadertoy.com/view/wsSBzw[/url]) ", "tags": ["animated", "displacementmap", "rasterize", "mesh"], "likes": 5, "viewed": 742, "published": 3, "date": "1589801204", "time_retrieved": "2024-07-30T21:06:15.256420", "image_code": "// TomF's Displacement map on rast mesh with video for displacement map\n// (https://www.shadertoy.com/view/wsSBzw) \n\n#define BACKFACE_CULL false\n#define TEXTURED true\n#define PHASES false\n\n\nstruct Vertex\n{\n    vec4 Pos;\n    vec3 Uvh;\n};\n    \n\n// Test a position against a triangle and return\n// the perspective-correct barycentric coordinates in the triangle\n// Note the z value in the vertex is ignored, it's the w that matters.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    if ( BACKFACE_CULL && ( scale < 0.0 ) )\n    {\n        return vec2 ( -1.0, -1.0 );\n    }\n\n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;\n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    // Now interpolate the canonical coordinates (0,0,1,v1.w), (1,0,1,v2.w) and (0,1,1,v3.w)\n    // with perspective correction\n    // So we project all three by their respective w:\n    // (0,0,v1.w) -> (0,     0,     1/v1.w)\n    // (1,0,v2.w) -> (1/v2.w,0,     1/v2.w)\n    // (0,1,v3.w) -> (0,     1/v3.w,1/v3.w)\n    // Then interpolate those values linearly to produce (nx,ny,nw),\n    // then divide by nw again.\n    vec3 recipw = vec3 ( 1.0/v1.Pos.w, 1.0/v2.Pos.w, 1.0/v3.Pos.w );\n    \n    float baryk = 1.0 - baryi - baryj;\n    float newi = recipw.y * baryi;\n    float newj = recipw.z * baryj;\n    //float neww = recipw.x * baryk + recipw.y * baryi + recipw.z * baryj;\n    float neww = recipw.x * baryk + newi + newj;\n    \n    // ...and project back.\n    float rneww = 1.0/neww;\n    float perspi = newi * rneww;\n    float perspj = newj * rneww;\n        \n    return vec2 ( perspi, perspj );\n}\n\nconst int GridW = 4;\nconst int GridH = 4;\nconst int NumVerts = GridH*GridW*2;\nconst int NumTris = (GridH-1)*(GridW-1)*2*2 + ((GridH-1)*2+(GridW-1)*2)*2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NDC (-1 to +1)\n    vec2 uv = -1.0 + 2.0f * (fragCoord/iResolution.xy);\n    \n    int Phase = 0;\n    if(PHASES)\n    {\n    \tPhase = (int(floor(0.2*(iTime-1.0*fragCoord.x/iResolution.x))))%3;\n    }\n    \n    \n    float wobble = 0.0;//float(iTime);\n    \n    // Create the mesh. This would of course be done offline.\n    Vertex Verts[NumVerts];\n    for ( int w = 0; w < GridW; w++ )\n    {\n        for ( int h = 0; h < GridH; h++ )\n        {\n            Vertex Vert0, Vert1;\n            Vert0.Pos.x = float(w - GridW/2);\n            Vert0.Pos.y = float(h - GridH/2);\n            float wf = -2.0 + float(w);\n            float hf = -3.0 + float(h);\n            float d = sqrt(wf*wf + hf*hf);\n            Vert0.Pos.z = 0.3 * cos (d * 0.8 + wobble) - 1.0;\n            Vert0.Pos.w = 1.0f;\n            Vert0.Uvh.x = float(w) / float(GridW-1);\n            Vert0.Uvh.y = float(h) / float(GridH-1);\n            Vert0.Uvh.z = 0.0;\n            \n            Vert1.Pos = Vert0.Pos;\n            Vert1.Pos.z += 1.0;\n            Vert1.Uvh = Vert0.Uvh;\n            Vert1.Uvh.z = 1.0;\n            \n            int Index = (w*GridH+h)*2;\n            Verts[Index+0] = Vert0;\n            Verts[Index+1] = Vert1;\n        }\n    }\n\n    int Indices0[NumTris];\n    int Indices1[NumTris];\n    int Indices2[NumTris];\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        for ( int h = 0; h < GridH-1; h++ )\n        {\n            int VertIndex = (w*GridH+h)*2;\n            int TriIndex = (w + (GridH-1)*h) * 2 * 2;\n            Indices0[TriIndex+0] = VertIndex  ;\n            Indices1[TriIndex+0] = VertIndex  +GridH*2;\n\t\t\tIndices2[TriIndex+0] = VertIndex  +2;\n            Indices0[TriIndex+1] = VertIndex+1;\n            Indices2[TriIndex+1] = VertIndex+1+GridH*2;\n\t\t\tIndices1[TriIndex+1] = VertIndex+1+2;\n            \n            Indices2[TriIndex+2] = VertIndex  +GridH*2;\n            Indices0[TriIndex+2] = VertIndex  +GridH*2+2;\n\t\t\tIndices1[TriIndex+2] = VertIndex  +2;\n            Indices1[TriIndex+3] = VertIndex+1+GridH*2;\n            Indices0[TriIndex+3] = VertIndex+1+GridH*2+2;\n\t\t\tIndices2[TriIndex+3] = VertIndex+1+2;\n        }\n    }\n    // Now do the edges.\n    int CurTri  = (GridH-1)*(GridW-1)*2*2;\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        int VertIndex = (w*GridH)*2;\n        Indices0[CurTri+0] = VertIndex;\n        Indices1[CurTri+0] = VertIndex+1;\n\t\tIndices2[CurTri+0] = VertIndex+GridH*2;\n        Indices0[CurTri+1] = VertIndex+1;\n        Indices1[CurTri+1] = VertIndex+GridH*2;\n\t\tIndices2[CurTri+1] = VertIndex+GridH*2+1;\n\n        VertIndex = (w*GridH+GridH-1)*2;\n        Indices0[CurTri+2] = VertIndex;\n        Indices1[CurTri+2] = VertIndex+1;\n\t\tIndices2[CurTri+2] = VertIndex+GridH*2;\n        Indices0[CurTri+3] = VertIndex+1;\n        Indices1[CurTri+3] = VertIndex+GridH*2;\n\t\tIndices2[CurTri+3] = VertIndex+GridH*2+1;\n        \n        CurTri += 4;\n    }\n    for ( int h = 0; h < GridH-1; h++ )\n    {\n        int VertIndex = (h)*2;\n        Indices0[CurTri+0] = VertIndex;\n        Indices1[CurTri+0] = VertIndex+1;\n\t\tIndices2[CurTri+0] = VertIndex+2;\n        Indices0[CurTri+1] = VertIndex+1;\n        Indices1[CurTri+1] = VertIndex+2;\n\t\tIndices2[CurTri+1] = VertIndex+2+1;\n\n        VertIndex = (h+GridH*(GridW-1))*2;\n        Indices0[CurTri+2] = VertIndex;\n        Indices1[CurTri+2] = VertIndex+1;\n\t\tIndices2[CurTri+2] = VertIndex+2;\n        Indices0[CurTri+3] = VertIndex+1;\n        Indices1[CurTri+3] = VertIndex+2;\n\t\tIndices2[CurTri+3] = VertIndex+2+1;\n        \n        CurTri += 4;\n    }\n   \n    \n    float hfov = 0.6;\n    float vfov = hfov * iResolution.y / iResolution.x;\n    float zfar = 10.0f;\n    float znear = 1.0f;\n    float q = zfar/(zfar-znear);\n    \n    mat4 ProjMat;\n    ProjMat[0] = vec4 ( 1.0/hfov, 0.0f, 0.0f, 0.5f );\n    ProjMat[1] = vec4 ( 0.0f, 1.0/vfov, 0.0f, 0.5f );\n    ProjMat[2] = vec4 ( 0.0f, 0.0f, q, 1.0f );\n    ProjMat[3] = vec4 ( 0.0f, 0.0f, -q*znear, 0.0f );\n    \n    \n    mat4 TotalMat;\n    mat4 ObjMat1;\n    mat4 ObjMat2;\n    \n    // Mouse -> eye\n    float a1 = iMouse.x * 0.01 + 3.0;\n    float a2 = iMouse.y * 0.01 + 2.8;\n    float zdist = 4.0;\n    \n    ObjMat1[0] = vec4 ( cos(a1),  sin(a1), 0.0, -0.8 );\n    ObjMat1[1] = vec4 ( sin(a1), -cos(a1), 0.0, 0.8 );\n    ObjMat1[2] = vec4 ( 0.0,          0.0, 1.0, 0.0 );\n    ObjMat1[3] = vec4 ( 0.0,          0.0, 0.0, 1.0 );\n    ObjMat2[0] = vec4 ( 1.0, 0.0,          0.0, 0.0 );\n    ObjMat2[1] = vec4 ( 0.0, cos(a2),  sin(a2), 0.0 );\n    ObjMat2[2] = vec4 ( 0.0, sin(a2), -cos(a2), zdist );\n    ObjMat2[3] = vec4 ( 0.0, 0.0,          0.0, 1.0 );\n    \n    TotalMat = ObjMat1 * ObjMat2;\n    TotalMat = TotalMat * ProjMat;\n\n    // Background colour\n    vec3 col;\n    //col.xy = uv.xy;\n    col.x = 0.7;\n    col.y = 0.7;\n    col.z = 0.7;\n\n    Vertex ScreenVert[NumVerts];\n    for ( int VertNum = 0; VertNum < NumVerts; VertNum++ )\n    {\n        vec4 Pos = Verts[VertNum].Pos;\n        \n        vec4 ScrPos = Pos * TotalMat;\n        float rw = 1.0/ScrPos.w;\n        ScrPos.x *= rw;\n        ScrPos.y *= rw;\n        ScrPos.z *= rw;\n        \n        ScreenVert[VertNum].Pos = ScrPos;\n        ScreenVert[VertNum].Uvh = Verts[VertNum].Uvh;\n    }\n    \n    float NearestZ = 10000000.0f;\n    float FarthestZ = -10000000.0f;\n    vec3 NearUvh;\n    vec3 FarUvh;\n    \n    for ( int TriNum = 0; TriNum < NumTris; TriNum++ )\n    {\n        Vertex v1 = ScreenVert[Indices0[TriNum]];\n        Vertex v2 = ScreenVert[Indices1[TriNum]];\n        Vertex v3 = ScreenVert[Indices2[TriNum]];\n        vec3 bary;\n        bary.xy = BaryTri3D ( uv, v1, v2, v3 );\n        bary.z = 1.0 - bary.x - bary.y;\n\n        vec3 uvh = bary.z * v1.Uvh + bary.x * v2.Uvh + bary.y * v3.Uvh;\n        \n        if ( ( bary.x >= 0.0 ) &&\n             ( bary.y >= 0.0 ) &&\n             ( bary.z >= 0.0 ) &&\n             ( uvh.x + uvh.y + uvh.z > -1000.0 ) ) // see above\n        {\n            // Interpolate Z\n            // Note this is linear Z, not the strange Z that most rasteriser use\n            // In this case, that's fine.\n            float Z = bary.z * v1.Pos.z + bary.x * v2.Pos.z + bary.y * v3.Pos.z;\n            if ( NearestZ >= Z )\n            {\n                NearestZ = Z;\n                NearUvh = uvh;\n                \n                if ( Phase == 1 )\n                {\n                    // Wireframe!\n                    float maxbary = min ( bary.x, min ( bary.y, bary.z ) );\n                    maxbary = maxbary * 100.0;\n                    if ( maxbary < 1.0 )\n                    {\n                        col.x = 1.0 - maxbary;\n                    }\n                }  \n            }\n            \n            if ( FarthestZ <= Z )\n            {\n                FarthestZ = Z;\n                FarUvh = uvh;\n            }\n            \n        }        \n    }\n    \n    if ( NearestZ < FarthestZ )\n    {\n        if ( Phase == 0 )\n        {\n            // Now \"trace\" from NearUV to FarUV and\n            // see where it intersects the heightfield.\n            // Ideally the heightfield would store an SDF rather than a simple height,\n            // so you could step through it quickly, but I don't have that, so this is\n            // just a brute-force step, although it is at leats proportional to the\n            // number of texels to traverse.\n            float Dist = length(NearUvh.xy - FarUvh.xy);\n            int NumSteps = int(Dist*64.0+5.0); // texture size?\n            vec3 LastUvh = NearUvh;\n            float LastTexH = NearUvh.z;\n            for ( int StepNum = 0; StepNum <= NumSteps; StepNum++ )\n            {\n                float Lerp = float(StepNum)/float(NumSteps);\n                vec3 uvh = NearUvh + (FarUvh-NearUvh)*Lerp;\n                float height = 1.0 - texture ( iChannel0, uvh.xy ).x;\n                if ( uvh.z >= height )\n                {\n                    // We crossed from one side to the other,\n                    // so interpolate to the intersection.\n                    float h0 = LastUvh.z - LastTexH;\n                    float h1 = uvh.z - height;\n                    float ThisLerp = h0 / (h0-h1);\n                    vec3 uvh2 = LastUvh + (uvh-LastUvh)*ThisLerp;\n                    vec4 tex2 = texture ( iChannel0, uvh2.xy ).xxxx * texture ( iChannel1, uvh2.xy );\n                    col.xyz = tex2.xyz;\n                    break;\n                }\n                else\n                {\n                    LastUvh = uvh;\n                    LastTexH = height;\n                }\n            }\n        }\n        else if ( Phase == 1 )\n        {\n            //col.xyz = NearUvh.xyz;\n        }\n        else if ( Phase == 2 )\n        {\n            col.xyz = texture ( iChannel0, NearUvh.xy ).xxx;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 430, 492, 492, 1835]], "test": "untested"}
{"id": "3sBfDR", "name": "Water Falling", "author": "dr2", "description": "Dynamic version of Escher's \"Waterval\" - a source of perpetual energy.", "tags": ["illusion", "escher", "penrose", "paradox"], "likes": 36, "viewed": 708, "published": 3, "date": "1589795161", "time_retrieved": "2024-07-30T21:06:16.360467", "image_code": "// \"Water Falling\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Started from the simplified image in NuSan's \"Waterfall\" and borrowed the main \n  geometrical features; new version includes motion, color and transparency, and\n  other visual changes (cf. original).\n  \n  Use the mouse to see how the scene is built; however, there is only one correct\n  view; note the parallel projection, and the shifting / duplication / truncation\n  of certain elements. Click in corners for alternative images.\n*/\n\n#define AA  0    // optional antialiasing (slow)\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrRoundFlatCylAnDf (vec3 p, float rhi, float rlo, float w, float h, float rc);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, sunDir, vuDir, vuPln;\nfloat dstFar, tCur, flDir;\nbool isMono, isPoly;\nint idObj;\nconst int idWChan = 1, idWWhl = 2, idMBldg = 3, idRBldg = 4, idFBldg = 5, idLBldg = 6,\n   idStair = 7, idFenc = 8, idUBldg = 9, idUBldgX = 10, idRoof = 11, idPilr = 12,\n   idPlat = 13, idTop = 14, idArch = 15, idWater = 16;\nfloat pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat UBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, rc, rs;\n  rs = sin (4. * pi * p.x);\n  q = p - vec3 (-8., 3., -3.);\n  d = PrBoxDf (q, vec3 (5., 8., 3.));\n  d = max (d, - PrBoxDf (q - vec3 (-5.4, 2.2, -1.8), vec3 (1., 1.5, 0.7)));\n  d = max (d, - PrBoxDf (q - vec3 (-5.5, 2.8, 1.), vec3 (1., 0.8, 1.2)));\n  d = max (d, - PrBoxDf (q - vec3 (-3., 5.3, -3.5), vec3 (1.2, 0.5, 1.)));\n  q.z = - abs (q.z);\n  rc = dot (vec2 (q.y - 8. - 0.02 * rs, q.z), vec2 (-0.4, 0.2));\n  d = max (d, - rc);\n  DMINQ (idUBldg);\n  d = max (abs (rc) - 0.04, PrBox2Df (q.xz, vec2 (5.5, 3.5)));\n  DMINQ (idRoof);\n  q = p - vec3 (-12., 11.7, -4.3);\n  d = 0.7 * PrBoxDf (q, vec3 (vec2 (0.6 - 0.15 * smoothstep (-0.2, 0.2, q.y)), 1.5).xzy);\n  DMINQ (idUBldgX);\n  q.z = - abs (q.z);\n  d = max (abs (dot (vec2 (q.y - 1.95 - 0.02 * rs, q.z), vec2 (-0.7, 0.7))) - 0.04,\n     PrBox2Df (q.xz, vec2 (0.7)));\n  DMINQ (idRoof);\n  return dMin;\n}\n\nfloat SpltBldgDf (vec3 p, float zHi, float dMin)\n{\n  vec3 q;\n  vec2 s1, s2, b1, b2;\n  float d;\n  s1 = vec2 (-9., -6.);\n  s2 = vec2 (-13.5, -4.);\n  b1 = vec2 (5.5, 8.5);\n  b2 = vec2 (3., 6.5);\n  q = p;\n  d = min (PrBoxDf (q - vec3 (s1, -0.5).xzy, vec3 (b1, 4.2).xzy),\n     PrBoxDf (q - vec3 (s2, 2.8).xzy, vec3 (b2, 0.9).xzy));\n  d = max (d, - PrFlatCylDf ((q - vec3 (-6.7, -1.5, -13.3)).yxz, 2., 1.7, 2.));\n  q.x -= -16.5;\n  d = max (d, - min (PrBox2Df (q.xy, vec2 (2., 3.3 - 0.8 * q.x)),\n     max (PrBox2Df (q.xy, vec2 (2., 3.4)), 0.2 - abs (mod (q.z + 1., 2.) - 1.))));\n  d = max (d, zHi);\n  DMINQ (idMBldg);\n  q = p - vec3 (-19.5, -5., -4.);\n  d = min (d, max (PrBoxDf (q, vec3 (5., 4., 5.)),\n     - PrBoxDf (q - vec3 (0., 4.2, 0.), vec3 (4.5, 0.8, 4.5))));\n  q.y -= 3.1;\n  q.xz = abs (q.xz) - 2.1;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.8, 0., 0.8), 1.));\n  d = max (d, zHi);\n  DMIN (idLBldg);\n  q = p;\n  d = min (PrCylDf (vec3 (mod (q.xz + 0.5, 1.) - 0.5, q.y - 4.5), 0.14, 0.8),\n     max (abs (mod (q.y - 0.55, 0.7) - 0.35) - 0.05, abs (q.y - 4.7) - 0.8));\n  d = max (d, abs (min (PrBox2Df (q.xz - s1, b1 - 0.5),\n     PrBox2Df (q.xz - s2, b2 - 0.5))) - 0.15);\n  d = max (d, - PrBox2Df (q.xz - vec2 (-2., -10.), vec2 (4., 1.4)));\n  d = max (d, zHi);\n  DMIN (idFenc);\n  return dMin;\n}\n\nfloat StairDf (vec3 p, float st, float w, float h)\n{\n  return 0.7 * max ((st + p.y - p.z - abs (mod (p.y + p.z, 2. * st) - st) / sqrt(2.)),\n     max (abs (p.x) - w, max (abs (p.y) - h, abs (p.z) - h)));\n}\n\nfloat FBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p - vec3 (3.4, 0.5, -15.);\n  d = max (PrBoxDf (q, vec3 (3.4, 3.2, 4.)),\n     - PrBoxDf (q - vec3 (0., 4.7, 0.), vec3 (2.9, 2., 3.5)));\n  d = min (d, PrRoundBoxDf (q - vec3 (0., 2.4, 0.), vec3 (0.9, 0., 1.5), 1.));\n  d = max (d, - PrBoxDf (q - vec3 (-3.4, 1.3, -1.6), vec3 (0.5, 0.7, 0.5)));\n  d = max (d, - PrFlatCylDf ((q - vec3 (-2., -0.8, 2.2)).yzx, 1.7, 1., 2.));\n  DMIN (idRBldg);\n  q = p - vec3 (3., 0.7, -22.);\n  d = max (PrBoxDf (q, vec3 (3.5, 6.2, 3.5)),\n     - PrBoxDf (q - vec3 (0., 7.2, 0.), vec3 (3, 1.5, 3)));\n  d = max (d, - PrBoxDf (q - vec3 (-3.4, 3.8, 0.5), vec3 (0.5, 1., 1.)));\n  DMIN (idRBldg);\n  q = p - vec3 (-10., -5., -26.);\n  d = max (PrBoxDf (q, vec3 (20., 4., 15.)),\n     - min (PrBoxDf (q - vec3 (-4., 5.5, 10.5), vec3 (10., 2.5, 4.)),\n     PrBoxDf (q - vec3 (1.5, 6., -3.), vec3 (7., 5., 9.))));\n  DMIN (idFBldg);\n  q = p - vec3 (-2.5, -2.6, -22.2);\n  d = min (StairDf (q, 0.35, 0.8, 2.), StairDf (q - vec3 (-2., 1.3, 7.), 0.35, 0.4, 2.));\n  DMIN (idStair);\n  return dMin;\n}\n\nfloat IcoDodDf (vec3 p, float typ)\n{\n  vec3 q, dv, vc;\n  float cp, sp, scl;\n  scl = 1.2;\n  p /= scl;\n  cp = cos (pi / 5.);\n  sp = sqrt (0.75 - cp * cp);\n  vc = vec3 (-0.5, - cp, sp);\n  for (int j = 0; j < 5; j ++) {\n    p.xy = abs (p.xy);\n    p -= 2. * min (0., dot (p, vc)) * vc;\n  }\n  q = p - ((typ < 0.) ? normalize (vec3 (sp, 0., 0.5)) : normalize (vec3 (0., sp, cp)));\n  dv = vec3 (length (q - min (0., q.x) * vec3 (1., 0., 0.)), \n     length (q - min (0., q.y) * vec3 (0., 1., 0.)),\n     length (q - min (0., dot (q, vc)) * vc));\n  return scl * (Minv3 (dv) - 0.15);\n}\n\nfloat WatChanDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  vec2 b;\n  float d, dw, s;\n  b = vec2 (-5.);\n  q = p - vec3 (0., 3., -10.);\n  qq = q;\n  for (float j = 0.; j <= 3.; j ++) {\n    if (j > 0.) qq.xz = b + qq.zx ;\n    q = vec3 (abs (vec2 (abs (qq.x) - 5., qq.z)) - 1., qq.y - 1.).xzy;\n    d = max (PrBoxDf (q, vec3 (0.2, 5., 0.2)), dot (qq, vuPln) - 1.);\n    DMINQ (idPilr);\n  }\n  dw = min (PrBoxDf (p - vec3 (-7.5, 4., -9.9), vec3 (2.9, 0.3, 1.1)),\n     PrBoxDf (qq - vec3 (5., 0.23, -2.), vec3 (0.82, 0.3, 1.9)));\n  s = - qq.x;\n  q = vec3 (abs (vec2 (abs (qq.x) - 5., qq.z)) - 1., qq.y).xzy;\n  d = PrBoxDf (q, vec3 (0.2, 5., 0.2));\n  DMINQ (idPilr);\n  qq.x = - qq.x;\n  qq.xz = vec2 (15., 0.) - qq.xz;\n  qq.xz = mix (qq.xz, qq.zx, step (qq.x, qq.z));\n  qq.xy -= vec2 (10., 1.);\n  qq.xz = mix (qq.xz, qq.zx, step (qq.x, qq.z));\n  qq.x = - qq.x;\n  dw = min (dw, PrBoxDf (qq, vec3 (10.8, max (0., 0.95 - 0.03 * s), 0.65)));\n  q = p - vec3 (0., 3., -10.);\n  d = max (PrBoxDf (q - vec3 (-7.4, 0.95, 0.1), vec3 (3.5, 0.25, 1.7)), - dw);\n  DMINQ (idWChan);\n  for (float j = 0.; j <= 3.; j ++) {\n    if (j > 0.) q.xz = b + q.zx;\n    s = 0.1 * step (1., q.x);\n    d = max (PrBoxDf (q - vec3 (0., - s, 0.), vec3 (6., 1.2 - 0.2 * j - s, 1.)), - dw);\n    DMINQ (idWChan);\n  }\n  d = max (PrBoxDf (q - vec3 (5., -0.15, -2.2), vec3 (1., 0.4, 1.2)), - dw);\n  DMINQ (idWChan);\n  s = sign (q.x);\n  q.x = abs (q.x) - 5.;\n  d = isPoly ? IcoDodDf (q - vec3 (0., 6.4, 0.), s) : PrSphDf (q - vec3 (0., 6.2, 0.), 1.);\n  DMIN (idTop);\n  d = PrBoxDf (q - vec3 (0., 5.1, 0.), vec3 (1.5, 0.1, 1.5));\n  DMIN (idPlat);\n  d = 6. - abs (q.y);\n  q.y = mod (q.y - 2.1, 5.6) - 1.7;\n  d = max (max (PrBoxDf (q - vec3 (0., 0.5, 0.), vec3 (1.15, 0.7, 1.15)),\n     0.85 - min (length (q.xy), length (q.zy))), - d);\n  q = p - vec3 (5., 1., 0.);\n  d = min (d, max (PrBoxDf (q - vec3 (0., 0.5, 0.), vec3 (1.15, 0.7, 1.15)),\n     0.85 - min (length (q.xy), length (q.zy))));\n  DMIN (idArch);\n  return dMin;\n}\n\nfloat WWheelDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p - vec3 (-7.8, 5.2, -6.2);\n  d = PrCylDf (q, 1., 0.2);\n  DMIN (idUBldgX);\n  q.z -= -2.3;\n  d = PrCylDf (q, 0.5, 2.2);\n  q.z -= -1.5;\n  d = min (d, PrCylAnDf (q, 1.1, 0.15, 0.7));\n  DMIN (idWWhl);\n  q.xy = Rot2D (q.xy, -0.8 * tCur * flDir);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (14. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 14.);\n  q.x -= -1.3;\n  d = PrBoxDf (q, vec3 (0.7, 0.07, 0.6));\n  DMIN (idWWhl);\n  return dMin;\n}\n\nfloat WatSurfDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 b;\n  float d;\n  b = vec2 (-5.);\n  q = p - vec3 (0., 3., -10.);\n  d = PrBoxDf (q - vec3 (-7.5 , 0.1, 0.1), vec3 (3., 0.8, 1.1));\n  DMINQ (idWater);\n  for (int j = 0; j <= 3; j ++) {\n    if (j > 0) q.xz = b + q.zx;\n    d = PrBoxDf (q, vec3 (6., 0.8 - 0.2 * float (j) - 0.02 * q.x, 0.75));\n    DMINQ (idWater);\n  }\n  q.xz = - q.zx;\n  q -= vec3 (2.1, -0.05, -5.);\n  d = max (PrBoxDf (q, vec3 (1.3, 0.15, 0.75)), q.x + 4. * q.y - 1.5);\n  DMINQ (idWater);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = UBldgDf (p - vuDir * 35., dMin);\n  dMin = SpltBldgDf (p - vuDir * 35., p.z - 99., dMin);\n  dMin = SpltBldgDf (p, p.z + 8.7, dMin);  \n  dMin = FBldgDf (p, dMin);\n  dMin = WWheelDf (p, dMin);\n  dMin = WatChanDf (p, dMin);\n  dMin = WatSurfDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  q = p - vec3 (-8., 7.6, -9.8);\n  return max (PrRoundFlatCylAnDf (q.yxz, 5.6, 1.5, 0.1, 0.5, 0.1),  q.x - 0.1);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat BCylHit (vec3 ro, vec3 rd, float rad)\n{\n  float a, b;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  return (- b + sqrt (b * b - a * (dot (ro.xz, ro.xz) - rad * rad))) / a;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colW, roo, vn, q;\n  vec2 vf, c;\n  float dstObj, dstFWat, sh, a, s, spec;\n  dstObj = ObjRay (ro, rd);\n  roo = ro;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj <= idRBldg) {\n      if (idObj == idWChan) col = mix (vec3 (0.9, 0.4, 0.2), vec3 (0.7, 0.3, 0.4),\n         step (qHit.y, -0.4)) * (1. - 0.3 * step (0.95, sin (8. * pi * qHit.y)));\n      else if (idObj == idWWhl) col = vec3 (0.8, 0.5, 0.1);\n      else if (idObj == idMBldg) col = (qHit.y > 3.69) ? vec3 (0.7, 0.7, 0.8) : \n         ((qHit.y < 3.35 && qHit.x < 1.9) ? vec3 (0.8, 0.7, 0.5) : vec3 (0.6, 1., 1.));\n      else /*if (idObj == idRBldg)*/ col = vec3 (0.7, 0.5, 0.3);\n    } else if (idObj <= idFenc) {\n      if (idObj == idFBldg) col = vec3 (0.75, 0.45, 0.3);\n      else if (idObj == idLBldg) col = vec3 (0.7, 0.5, 0.35);\n      else if (idObj == idStair) col = (vn.x > -0.01) ? vec3 (0.8, 0.8, 0.5) :\n         vec3 (0.75, 0.45, 0.3);\n      else /*if (idObj == idFenc)*/ col = vec3 (1., 0.9, 0.4);\n    } else if (idObj <= idPilr) {\n      if (idObj == idUBldg) col = (max (abs (qHit.x) - 4.7, abs (qHit.z) - 2.7) < 0.) ?\n         vec3 (0.2, 0.5, 0.3) : vec3 (0.9, 0.8, 0.5);\n      else if (idObj == idUBldgX) col = vec3 (0.9, 0.8, 0.5);\n      else if (idObj == idRoof) col = vec3 (0.8, 0.1, 0.2) * (1. - 0.2 * step (0.5,\n         sin (16. * pi * qHit.y)));\n      else /*if (idObj == idPilr)*/ col = vec3 (0.9, 0.8, 0.7) * (1. -\n         0.1 * step (0.7, sin (4. * pi * qHit.y)));\n    } else /*if (idObj <= idWater)*/ {\n      if (idObj == idPlat) col = vec3 (0.7, 0.6, 0.5);\n      else if (idObj == idTop) col = vec3 (0.5, 0.6, 1.);\n      else if (idObj == idArch) {\n        c = (1. - 0.2 * step (0.8, cos (4. * pi * qHit.xz)));\n        col = vec3 (0.9, 0.8, 0.7) * c.x * c.y;\n      } else /*if (idObj == idWater)*/ {\n        q = qHit;\n        s = 1. - smoothstep (0., 2., abs (q.x) - 3.);\n        q.x -= tCur * flDir;\n        col = vec3 (0.7, 0.8, 1.) * (0.96 - 0.04 * s * sin (2. * pi * q.x));\n      }\n    }\n    if (idObj != idWWhl && idObj != idFenc) {\n      if (idObj == idWater) {\n        vf = vec2 (0.);\n        if (vn.y > 0.5) {\n          vf = vec2 (4., 2.);\n          spec = 0.2;\n        }\n      } else {\n        vf = vec2 (16., 0.5);\n        q = ro;\n      }\n      if (vf.x > 0.) vn = VaryNf (vf.x * q, vn, vf.y);\n    }\n    sh = (idObj != idPilr && idObj != idWater) ? ObjSShadow (ro, sunDir) : 1.;\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       spec * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else {\n    ro += BCylHit (ro + vec3 (-20., 0., 10.), rd, 100.) * rd;\n    a = (atan (ro.z, - ro.x) + 0.3 * floor (0.5 * ro.y)) / (2. * pi);\n    col = (1. + 0.2 * ro.y / 100.) * mix (vec3 (0.3, 0.5, 0.2) * (1. -\n       0.1 * smoothstep (0.25, 0.3, mod (360. * a + 0.5, 1.) - 0.5)), vec3 (0.4, 0.6, 0.3) *\n       (1. - 0.1 * Noisefv2 (256. * vec2 (4. * a, ro.y))), step (0.65, mod (0.5 * ro.y, 1.)));\n  }\n  ro = roo;\n  dstFWat = TrObjRay (ro, rd);\n  if (dstFWat < min (dstObj, dstFar)) {\n    ro += dstFWat * rd;\n    vn = TrObjNf (ro);\n    q = ro;\n    q.y += 2. * tCur * flDir;\n    vn = VaryNf (8. * q, vn, 4.);\n    colW = mix (vec3 (0.8, 0.9, 1.), 0.9 * vec3 (0.7, 0.8, 1.),\n       smoothstep (0., 1., ro.y - 13.5)) * (0.6 + 0.4 * max (dot (vn, sunDir), 0.)) +\n       0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    col = mix (col, colW, sqrt (Maxv3 (colW)) * (1. - 0.3 * step (0., sin (16. * pi * ro.z)) *\n       (1. - 0.4 * step (0., sin (2. * pi * q.y)))));\n  }\n  if (isMono) col = vec3 (1., 0.7, 0.3) * Maxv3 (col);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vx, vy;\n  vec2 canvas, uv, ut, uvv;\n  float el, az, zmFac, asp, sr;\n  bool inCorn, flipVu;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  flDir = 1.;\n  isMono = false;\n  flipVu = false;\n  isPoly = false;\n  ut = vec2 (abs (mPtr.x), abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5;\n  inCorn = (mPtr.z > 0. && min (ut.x, ut.y) > 0.);\n  if (inCorn) {\n    if (mPtr.x > 0. && mPtr.y > 0.) isPoly = true;\n    if (mPtr.x > 0. && mPtr.y < 0.) flDir = -1.;\n    if (mPtr.x < 0. && mPtr.y > 0.) flipVu = true;\n    if (mPtr.x < 0. && mPtr.y < 0.) isMono = true;\n  }\n  az = 0.2501 * pi;\n  el = -0.143 * pi;\n  if (mPtr.z > 0. && ! inCorn) {\n    az += 2. * pi * smoothstep (0.05, 0.2, abs (mPtr.x)) * mPtr.x;\n    el += 0.5 * pi * smoothstep (0.05, 0.2, abs (mPtr.y)) * mPtr.y;\n  }\n  ro = vec3 (0., 0., -70.);\n  ro.yz = Rot2D (ro.yz, - el);\n  ro.xz = Rot2D (ro.xz, - az);\n  rd = normalize (vec3 (0., 4., 0.) - ro);\n  vuDir = rd;\n  vx = normalize (vec3 (vuDir.z, 0., - vuDir.x));\n  if (flipVu) vx *= -1.;\n  vy = vec3 (0., 1., 0.) - vuDir.y * vuDir;\n  vuPln = vy;\n  zmFac = 0.065;\n  dstFar = 200.;\n  sunDir = normalize (vec3 (-2., 3., -1.));\n  if (max (abs (uv.x), abs (uv.y)) < 0.97) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (ro + vec3 (uvv.x * vx + uvv.y * vy) / zmFac, rd);\n    }\n  } else if (abs (uv.x) < 1.) {\n    col = vec3 (0.2, 0.4, 0.6);\n  } else {\n    col = vec3 (0.75);\n  }\n  if (mPtr.z > 0. && min (abs (uv.x) - asp, abs (uv.y) - 1.) > -0.1)\n     col = mix (col, vec3 (1., 1., 0.), 0.3);\n  fragColor = vec4 (col, 1);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrRoundFlatCylAnDf (vec3 p, float rhi, float rlo, float w, float h, float rc)\n{\n  vec2 q;\n  q = abs (vec2 (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, p.z)) - vec2 (w, h);\n  return length (vec2 (max (q, 0.))) - rc;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfDR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1633, 1633, 1669, 1669, 2547], [2549, 2549, 2599, 2599, 3837], [3839, 3839, 3891, 3891, 4043], [4045, 4045, 4081, 4081, 5113], [5115, 5115, 5151, 5151, 5688], [5690, 5690, 5728, 5728, 7656], [7658, 7658, 7695, 7695, 8144], [8146, 8146, 8184, 8184, 8668], [8670, 8670, 8692, 8692, 8999], [9001, 9001, 9034, 9034, 9217], [9219, 9219, 9240, 9240, 9495], [9497, 9497, 9521, 9521, 9646], [9648, 9648, 9683, 9683, 9867], [9869, 9869, 9892, 9892, 10149], [10151, 10151, 10188, 10188, 10417], [10419, 10419, 10464, 10464, 10606], [10608, 10608, 10643, 10643, 14299], [14301, 14301, 14357, 14357, 16405], [16407, 16407, 16439, 16439, 16539], [16541, 16541, 16574, 16574, 16663], [16665, 16665, 16711, 16711, 16758], [16760, 16760, 16793, 16793, 16820], [16822, 16822, 16864, 16864, 16915], [16917, 16917, 16970, 16970, 17031], [17033, 17033, 17092, 17092, 17182], [17184, 17184, 17269, 17269, 17420], [17422, 17422, 17444, 17444, 17482], [17484, 17484, 17506, 17506, 17544], [17546, 17546, 17576, 17576, 17689], [17691, 17691, 17722, 17722, 17786], [17820, 17820, 17844, 17844, 17956], [17958, 17958, 17983, 17983, 18169], [18171, 18171, 18200, 18200, 18412], [18414, 18414, 18453, 18453, 18633]], "test": "untested"}
{"id": "tsjfRw", "name": "Jungle Gym", "author": "blackle", "description": "domain repetition with a twist: some of the domains are empty!", "tags": ["sdf"], "likes": 58, "viewed": 1186, "published": 3, "date": "1589754259", "time_retrieved": "2024-07-30T21:06:17.183268", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//antialising\n#define AA_SAMPLES 1\n//percentage of domains filled\n#define DENSITY 0.35\n\n//returns a vector pointing in the direction of the closest neighbouring cell\nvec3 quadrant(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x >= max(ap.y, ap.z)) return vec3(sign(p.x),0.,0.);\n    if (ap.y >= max(ap.x, ap.z)) return vec3(0.,sign(p.y),0.);\n    if (ap.z >= max(ap.x, ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\nbool domain_enabled(vec3 id) {\n    //repeat random number along z axis so every active cell has at least one active neighbour\n    id.z = floor(id.z/2.); \n    return hash(id.x, hash(id.y, id.z)) < DENSITY;\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat ball;\nfloat scene(vec3 p) {\n    float scale = 5.;\n    vec3 id = floor(p/scale);\n    p = (fract(p/scale)-.5)*scale;\n    if (!domain_enabled(id)) {\n        //return distance to sphere in adjacent domain\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= scale;\n        return length(p)-1.;\n    }\n    float dist = length(p)-1.;\n    ball = dist;\n    vec3 quad = quadrant(p);\n    if (domain_enabled(id+quad)) {\n        //add pipe\n        dist = min(dist, linedist(p, vec3(0), quad*scale)-.2);\n    }\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nfloat smoothstairs(float p, float scale) {\n    p *= scale;\n    p = smoothstep(0.9, 1., fract(p)) + floor(p);\n    return p/scale;\n}\n\nconst float PI = acos(-1.);\nvec3 pixel_color(vec2 uv) {\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tvec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(iTime,0,0);\n\n    float yrot = 0.;\n    float zrot = 0.;\n    if (iMouse.z > 0.) {\n        yrot += smoothstep(-PI/2., PI/2., -4.*mouse.y)*PI-PI/2.;\n        zrot += 4.*mouse.x;\n    } else {\n        yrot += cos(iTime*.2)*.6;\n        zrot += sin(iTime*.2)*.6;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    bool triggered = false;\n    bool outline = false;\n    bool type = false;\n    float dist;\n    //ray marching\n    for (int i = 0; i < 150 && !hit; i++) {\n        dist = scene(p);\n        float outline_radius = 0.1*sqrt(distance(p,init))/3.;\n        if (dist < outline_radius*.9 && !triggered) {\n            triggered = true;\n            type = dist == ball;\n        }\n        if (triggered) {\n            float line = (outline_radius-dist);\n            outline = line < dist || type != (dist == ball);\n\t\t\tdist = min(line, dist);\n        }\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>90.) break;\n    }\n    if (!hit) return vec3(0.4);\n    bool is_ball = dist == ball;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n \t\n    //add outline to sharp edges\n    outline = outline || scene(p+n*.1) < 0.09;\n    float fog = smoothstep(80.,60., distance(p,init));\n\n    //shading\n    float ao = smoothstep(.0, .5, scene(p+n*.5));\n    float fact = ao*length(sin(r*vec3(3.,-2.,2.))*.5+.5)/sqrt(3.);\n    float lod = smoothstep(90.,50.,distance(p,init))*5.; //make the shading simpler in the distance\n    fact = smoothstairs(fact, lod)+.1;\n    vec3 ballcol = abs(erot(srgb(0.6,0.7,0.8), normalize(cos(p*.5)), .3));\n    vec3 matcol = is_ball ? ballcol : srgb(0.6,0.65,0.7);\n    vec3 col = matcol*fact + mix(vec3(1), matcol, .4)*pow(fact, 10.)*1.5;\n    col *= smoothstep(0.,.25,abs(dot(cam, n)));\n    col = mix(vec3(.6), outline ? vec3(0.) : col, fog);\n    if (isnan(length(col))) return vec3(.6); //i have no idea where this nan is coming from\n    return col;\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    for (int i = 0; i < AA_SAMPLES; i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n        fragColor += vec4(pixel_color(uv2), 1.);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjfRw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[282, 360, 383, 383, 616], [618, 618, 648, 648, 717], [719, 719, 749, 844, 925], [927, 927, 967, 967, 1059], [1073, 1073, 1094, 1094, 1671], [1673, 1673, 1692, 1692, 1809], [1811, 1811, 1849, 1849, 1915], [1917, 1917, 1955, 1955, 1987], [1989, 1989, 2031, 2031, 2119], [2149, 2149, 2176, 2176, 4269], [4271, 4271, 4292, 4292, 4351], [4353, 4353, 4410, 4410, 4699]], "test": "error"}
{"id": "tlX3DB", "name": "Draft proto 16-seg digital clock", "author": "Yambam", "description": "Prototype for a 16-segment digital clock. Can't figure out how to link the decimals/segments with the clock... please help anyone? I also don't know how to get the segments (array). Another version can be found here: https://www.shadertoy.com/view/3tsGR7", "tags": ["clock", "display", "digital", "segment", "prototype", "visual", "16", "seg", "sixteen"], "likes": 3, "viewed": 346, "published": 3, "date": "1589746499", "time_retrieved": "2024-07-30T21:06:17.926281", "image_code": "\nconst float TAU = 6.28318530718;\n\n\n/***/                                                        /*  /\n/** / Let's use something like this perhaps, to store digits /** /\n/*  /                                                        /***/\n\nconst int H = 0;\nconst int V = H+6;\nconst int D = V+6;\nconst int E = D+4;\n\nconst int[] _S = int[] (      H+4,    H+5,\n                            D+0,        D+2,\n                          V+1,    V+3,    V+5,\n                                                   \n                              H+2,    H+3,\n                                                   \n                          V+0,    V+2,    V+4,\n                            D+3,        D+1,\n                              H+0,    H+1      );\n\nconst int[] line_table_gOffset = int[] (0,  2,  4,    7,  9,    12, 14  ); const int[] _o = line_table_gOffset;\nconst int[] line_table_gLen =    int[] (2,  2,  3,    2,  3,    2,  2   );\n\nconst int[] index_table_gLine_gOffset =\nint[]\n(\n    _o[0],_o[0],\n    _o[1],_o[1],\n    _o[2],_o[2],_o[2],\n    _o[3],_o[3],\n    _o[4],_o[4],_o[4],\n    _o[5],_o[5],\n    _o[6],_o[6]\n);\n\nconst int[] z =\nint[]\n(\n       1,      1,              0,      0,              1,      1,              1,      1,              0,      0,              1,      1,              1,      1,              1,      1,              1,      1,              1,      1,       \n     1,          0,          0,          1,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          1,          0,          0,          0,          0,     \n   1,      0,      1,      0,      0,      1,      0,      0,      1,      0,      0,      1,      1,      0,      1,      1,      0,      0,      1,      0,      0,      0,      0,      0,      1,      0,      1,      1,      0,      1,   \n                                                                                                                                                                                                                                                \n       0,      0,              0,      0,              0,      1,              0,      1,              1,      1,              1,      1,              1,      1,              0,      0,              1,      1,              1,      1,       \n                                                                                                                                                                                                                                                \n   1,      0,      1,      0,      0,      1,      0,      0,      0,      0,      0,      1,      0,      0,      1,      0,      0,      1,      1,      0,      1,      0,      0,      0,      1,      0,      1,      0,      0,      1,   \n     0,          1,          0,          0,          1,          0,          0,          0,          0,          0,          0,          0,          0,          0,          1,          0,          0,          0,          0,          0,     \n       1,      1,              0,      0,              1,      1,              1,      1,              0,      0,              1,      1,              1,      1,              0,      0,              1,      1,              1,      1       \n);                                                                                                                                                                                                                                               \n\n\n/***/            /*  /\n/** / Digit code /** /\n/*  /            /***/\n\nvec2 distIgSegmentIt( vec2 xy, float size, vec2 dimensions )\n{\n    \n    xy.x = clamp(xy.x,-1.,2.);\n    xy.y = clamp(xy.y,0.,1.);\n    \n    float s = dimensions.y*round(xy.x*dimensions.x)+floor(xy.y*dimensions.y);\n    float px = round(xy.x*dimensions.x)/dimensions.x;\n    float py = floor(xy.y*dimensions.y)/dimensions.y;\n    vec2 offset =   vec2(xy.x,           xy.y-py)\n                  - vec2(clamp(px,0.,1.),clamp(xy.y-py,0.+size,1./dimensions.y-size));\n    float d = 2.*abs(offset.x)+1.*abs(offset.y);\n    \n    return vec2(d,s);\n}\n\nfloat colorRefreshRateArtifact( vec2 uv )\n{\n    return clamp(.8+.2*(.5+.5*sin(TAU*(5./2.*iTime+uv.y+1./16.*uv.x))*sin(TAU*(7./2.*iTime+uv.y+1./16.*uv.x))),0.,1.);\n}\n\nvec2 digIt( vec2 xy, int state, vec2 margin, float size, vec2 dimensions )\n{\n    vec2 segmented = vec2(size,-1.);\n    vec2 segmentedBest = segmented;\n    vec2 space = -margin;\n    vec2 xyf = space +(vec2(1,1)-2.*space)*xy;\n    vec2 xyfR = vec2(xyf.y,xyf.x);\n    float diag = sqrt(.5); //1.; //\n    float sFactor = (dimensions.x+1.)*dimensions.y;\n    \n    if (xyf.x<0.-.5*size\n    ||  xyf.y<0.-.5*size\n    ||  xyf.x>1.+.5*size\n    ||  xyf.y>1.+.5*size) return segmentedBest;\n    \n    \n    segmented = distIgSegmentIt(xyf,size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented;\n    segmented = distIgSegmentIt(xyfR,size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented+sFactor*vec2(0.,1.);\n    \n    vec2 xyrot = xy;\n    xyrot -= vec2(.5,.5);\n    xyrot *= vec2(sign(xy.x-.5)*sign(xy.y-.5),1.);\n    xyrot = .5*(vec2( xyrot.x,-xyrot.y)\n               +vec2(-xyrot.y,-xyrot.x));\n\txyrot += vec2(.5,.5);\n    \n    segmented = distIgSegmentIt(space+(vec2(1,1)-2.*space)*vec2(xyrot.x,xyrot.y),size,dimensions);\n    segmented = vec2(segmented.x/diag,segmented.y-(sFactor-dimensions.y)/2.);\n    if (segmented.y>=0.\n    &&  segmented.y<dimensions.y\n    &&  segmented.x<=segmentedBest.x)\n        segmentedBest = vec2(segmented.x,sFactor*2.+segmented.y+(sFactor-2.*dimensions.x)*max(0.,sign(xy.x-.5)*sign(xy.y-.5)));\n    \n    return segmentedBest; // /vec2(1.,4.*sFactor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /*\n     * Display customization\n     */\n    \n    vec2 margin = vec2(.15,.15);\n    float size = .15;\n    float digitCount = 3.;\n    float skew = .1; //.1*sin(TAU/6.*iTime);\n    vec2 dimensions = vec2(2.,2.);\n    \n    //// A variety of display colors you can choose from\n    \n    vec3 colTheme = vec3(1.,.15,0.); //<-- Red\n    //vec3 colTheme = vec3(0.,1.,0.);  //<-- Green\n    //vec3 colTheme = vec3(1.,.8,0.);  //<-- Yellow\n    //vec3 colTheme = vec3(.8,1.,0.);  //<-- Neon yellowish green\n    //vec3 colTheme = vec3(1.,.6,0.);  //<-- Orange\n    vec3 colBg = vec3(0,0,0);\n    \n    float a = -atan(skew); //asin(skew);\n    mat2 m = mat2(cos(a),-sin(a),\n                  sin(a), cos(a));\n    float skewNew = cos(a)-sin(a);\n    \n    vec2 ch = fragCoord/iResolution.x;\n    //vec2 ch = (fragCoord+vec2(0.,iResolution.y/2.))/iResolution.x;\n    ch *= (digitCount-1.+skewNew); //digitCount; //\n    ch = m * ch;\n    \n    ch *= distance(vec2(0.,0.),vec2(1.,skew));\n    vec3 col;\n    ch.y -= skew*ch.x;\n    \n    /* \n     * Color gradient\n     */\n    //vec3 colTheme = (1.-ch.y)*vec3(1,.4,.4)+ch.y*vec3(.4,.4,1);\n    //vec3 colBg = vec3(1,1,1);\n    \n    float aa = iResolution.x/200.; //30.*iMouse.x/iResolution.x;\n    int i = int(floor(ch.x));\n    float crra = colorRefreshRateArtifact(uv);\n    float t;\n    \n    if (ch.x<0.\n    ||  ch.x>digitCount) col = colBg;\n    else\n    {\n        ch.x -= floor(ch.x);\n        vec2 doughdge = digIt(ch,0,margin,size,dimensions);\n        if (doughdge.y>=0.)\n        {\n            //if (((digits[0])&(1<<int(doughdge.y)))>0) //0-65536\n            if (((1<<int(16./iResolution.x*iMouse.x))&(1<<int(doughdge.y)))>0) //0-65536\n            //if ((int(iDate.w)&(1<<int(doughdge.y)))>0) //0-65536\n            //if ((int(iDate.w)&(1<<int(doughdge.y)))>0) //0-65536\n            //if (((int(iDate.w)>>(16*i))&(1<<int(doughdge.y)))>0) //0-65536\n        \t\tt = (.5+.5/15.*doughdge.y)*crra;\n            else\n        \t\tt = .15*crra;\n            \n            t *= smoothstep(0.,1.,clamp(1.-10.*doughdge.x,0.,1./aa)*aa);\n            //t *= smoothstep(0.,1.,1.-8.*doughdge.x);\n            //t *= (1.-pow(2.,-2.+30.*doughdge.x));\n            \n            t = clamp(t,0.,1.);\n        }\n        else\n            t = 0.;\n\n        col = (1.-t)*colBg+t*colTheme;\n    }\n    \n    fragColor = vec4(col,1.);\n}\n\n/***/                                        /*  /\n/** / created by Imanuel Habekotté (@Yambam) /** /\n/*  /                                        /***/", "image_inputs": [], "common_code": "/***/                  /*  /\n/** / comment template /** /\n/*  /                  /***/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlX3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3614, 3614, 3676, 3676, 4148], [4150, 4150, 4193, 4193, 4314], [4316, 4316, 4392, 4392, 5745], [5747, 5747, 5804, 5804, 8162]], "test": "untested"}
{"id": "3d2fRm", "name": "Inversive Kaleidoscope", "author": "mla", "description": "Iterated inversion & reflection makes nice patterns. Use mouse to move free inversion circle around.", "tags": ["kaleidoscope", "inversion", "apollonian", "hyperbolic"], "likes": 10, "viewed": 447, "published": 3, "date": "1589743752", "time_retrieved": "2024-07-30T21:06:18.672286", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Inversive Kaleidoscope\n// mla, 2020\n//\n// <mouse>: move free inversion circle\n// c: show circles\n// l: show lines\n// m: mouse\n////////////////////////////////////////////////////////////////////////////////\n\nint P = 7;\nvec3 getcolor(vec2 z0, vec2 w) {\n  z0 += 1e-2;\n  vec2 z = z0;\n  float r2 = 2.0-cos(time);\n  float theta = PI/float(P);\n  vec2 l0 = vec2(0,1);\n  vec2 l1 = vec2(sin(theta),-cos(theta));\n  vec3 c0 = vec3(0,0,r2);\n  vec3 c1 = vec3(w,1.0);\n  int i, N = 40;\n  for (i = 0; i < N; i++) {\n    for (int j = 0; j < P; j++) {\n      if (dot(z,l0) < 0.0) z = reflect(z,l0);\n      else if (dot(z,l1) < 0.0) z = reflect(z,l1);\n      else break;\n    }\n    if (inside(z,c1)) z = invert(z,c1);\n    else if (inside(z,c0)) z = invert(z,c0);\n    else break;\n  }\n  if (i == N) return vec3(0);\n  vec3 col = vec3(1);\n  col = hsv2rgb(vec3(float(i)/10.0,1,1));\n  if (!key(CHAR_L)) {\n    vec3 ccol = vec3(0);\n    col = drawline(z,col,ccol,l0);\n    col = drawline(z,col,ccol,l1);\n    col = drawcircle(z,col,ccol,c0);\n    col = drawcircle(z,col,ccol,c1);\n  }\n  if (!key(CHAR_C)) {\n    vec3 ccol = vec3(1);\n    col = drawline(z0,col,ccol,l0);\n    col = drawline(z0,col,ccol,l1);\n    col = drawcircle(z0,col,ccol,c0);\n    col = drawcircle(z0,col,ccol,c1);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float AA = 2.0;\n  vec3 color = vec3(0);\n  float scale = 2.0;\n  time = iTime - 5.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 z = scale*(2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec2 w = vec2(2.0,0.25)+vec2(-0.25*sin(0.618*time),0.5*cos(0.618*time));\n      if (iMouse.x > 0.0 && !key(CHAR_M)) w = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n      color += getcolor(z,w);\n    }\n  }\n  color /= AA*AA;\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.1415927;\nfloat time;\n\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst int CHAR_C = 67;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\n\nvec2 invert(vec2 z, vec3 c) {\n  z -= c.xy;\n  float k = c.z/dot(z,z);\n  z *= k;\n  z += c.xy;\n  return z;\n}\n\nbool inside(vec2 z, vec3 c) {\n  z -= c.xy;\n  return dot(z,z) < abs(c.z);\n}\n\nfloat kfact = 0.8;\nfloat lwidth = 0.01;\nvec3 draw(float d, vec3 col, vec3 ccol, float pwidth) {\n  pwidth *= 0.1; //0.25;\n  col = mix(ccol,col,mix(1.0,smoothstep(0.5*lwidth,max(pwidth,lwidth),d),kfact));\n  //col = mix(ccol,col,mix(1.0,smoothstep(-pwidth,pwidth,d-lwidth),kfact));\n  return col;\n\n}\n\nvec3 drawcircle(vec2 z, vec3 col, vec3 ccol, vec3 circle) {\n  float d = abs(length(z-circle.xy) - sqrt(abs(circle.z)));\n  return draw(d,col,ccol,fwidth(z.x));\n}\n\nvec3 drawline(vec2 z, vec3 col, vec3 ccol, vec2 line) {\n  float d = abs(dot(z,line));\n  return draw(d,col,ccol,fwidth(z.x));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2fRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 335, 335, 1346], [1348, 1348, 1400, 1400, 1946]], "test": "untested"}
{"id": "Ws2BRw", "name": "Blue Noise RT Shadows TAA: Dir 2", "author": "demofox", "description": "Showing blue noise being used for soft shadows. Drag mouse to move camera.\nRight = shadow term dithered to fight banding from limited blue noise samples.\nTop = Raw, Bottom = TAA with alpha 0.1, 3x3 neighborhood color clamp, halton sub pixel jitter.", "tags": ["arealight", "bluenoise", "stochastic"], "likes": 6, "viewed": 884, "published": 3, "date": "1589730508", "time_retrieved": "2024-07-30T21:06:19.719486", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pixelColor = texture(iChannel0, uv).rgb;\n\n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // make a dividing line between the panels\n    vec2 dist2d = abs(fragCoord - iResolution.xy * 0.5f);\n    float dist = min(dist2d.x, dist2d.y);\n    dist = smoothstep(2.0f, 1.0f, dist);\n    pixelColor = mix(pixelColor, vec3(1.0f, 1.0f, 0.0f), dist);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);        \n    \n}\n\n/*\n\nTODO: try it with lower ray count, to see if that is really what is causing banding\n\n*/", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// white noise, from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// analytically mipmapped checkerboard pattern from inigo quilez\n// https://iquilezles.org/articles/morecheckerfiltering\nvec2 p( in vec2 x )\n{\n    vec2 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\n// return a filtered checkers pattern\nfloat checkersGradTriangle( in vec2 uv )\n{\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (p(uv+w)-2.0*p(uv)+p(uv-w))/(w*w); // analytical integral (triangle filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;    \n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n};\n    \nbool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }\n    \n    return false;\n}\n    \nbool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > 0.0f && dist < info.dist)\n        {\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.diffuse = diffuse;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool RayVsQuad(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 diffuse, bool doubleSided)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (doubleSided && dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }    \n    \n    return false;\n}\n\nSRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_rayMaxDist;\n\n    // the floor\n    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))\n    {\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        vec2 uv = hitPos.xz / 100.0f;\n        float shade = mix(0.8f, 0.4f, checkersGradTriangle(uv));\n        hitInfo.diffuse = vec3(shade, shade, shade);\n    }\n    \n    // some floating spheres to cast shadows\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 10.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 20.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 50.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f));\n    \n    return hitInfo;\n}\n\nvec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance, int panel, in vec2 pixelPos)\n{\n    // trace primary ray\n\tSRayHitInfo hitInfo = RayVsScene(rayPos, rayDir);\n    \n    // set the hitDistance out parameter\n    hitDistance = hitInfo.dist;\n    \n    if (hitInfo.dist == c_rayMaxDist)\n        return texture(iChannel0, rayDir).rgb;\n    \n    // calculate where the pixel is in world space\n\tvec3 hitPos = rayPos + rayDir * hitInfo.dist;\n    hitPos += hitInfo.normal * c_hitNormalNudge;\n    \n    int frame = 0;\n    #if ANIMATE_NOISE\n    \tframe = iFrame % 64;\n    #endif\n    \n    // use the screen space blue noise texture and golden ratio * frame number to\n    // get a \"random number\" to convert to an angle for how much to rotate\n    // the blue noise sample positions for this pixel\n    float blueNoise = texture(iChannel1, pixelPos / 1024.0f).r;\n    blueNoise = fract(blueNoise + c_goldenRatioConjugate * float(frame));\n    float theta = blueNoise * 2.0f * c_pi;\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    // shoot some shadow rays\n    float shadowTerm = 0.0f;\n    vec3 lightTangent = normalize(cross(c_lightDir, vec3(0.0f, 1.0f, 0.0f)));\n    vec3 lightBitangent = normalize(cross(lightTangent, c_lightDir));\n    for (int shadowRayIndex = 0; shadowRayIndex < c_numShadowRays; ++shadowRayIndex)\n    {\n        // calculate a ray direction to a random point on a disk in the direction of the light.\n        // AKA pick a random point on the sun and shoot a ray at it.\n        vec3 shadowRayDir;\n        {\n            vec2 diskPoint;\n            \n            // we only have 64 blue noise samples\n            // We could make more blue noise samples, but gotta set the limit somewhere since it's a constant array of vec2s.\n            if (shadowRayIndex >= 64)\n                break;\n\n            // get a blue noise sample position\n            vec2 samplePos = BlueNoiseInDisk[shadowRayIndex];\n\n            // rotate it\n            diskPoint.x = samplePos.x * cosTheta - samplePos.y * sinTheta;\n            diskPoint.y = samplePos.x * sinTheta + samplePos.y * cosTheta;\n\n            // scale it by the disk size\n            diskPoint *= c_lightRadius;            \n\n\n            // calculate the normalized vector to the random point on the disk\n            shadowRayDir = normalize(c_lightDir + diskPoint.x * lightTangent + diskPoint.y * lightBitangent);\n        }\n\n        // trace shadow ray\n        SRayHitInfo shadowHitInfo = RayVsScene(hitPos, shadowRayDir);\n        shadowTerm = mix(shadowTerm, ((shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f), 1.0f / float(shadowRayIndex+1));\n\t}\n    \n    // Dither the shadow term to fight banding due to having only 64 samples max, rotated 256 different ways\n\tif ((panel%2) == 1)\n    {\n        float blueNoiseDither = texture(iChannel1, fract(pixelPos + vec2(237, 111)) / 1024.0f).r;\n        shadowTerm += (blueNoiseDither - 0.5f) / float(c_numShadowRays);\n    }\n    \n    // do diffuse lighting\n    float dp = clamp(dot(hitInfo.normal, c_lightDir), 0.0f, 1.0f);\n\treturn c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);    \n    \n    // calculate sub pixel jitter for anti aliasing\n    vec2 subPixelJitter = (fragCoord.y < iResolution.y * 0.5f) ? halton(iFrame % 16 + 1) - 0.5f : vec2(0.0f, 0.0f);\n    \n    // calculate the ray direction for this pixel\n    vec2 uv = (fragCoord + subPixelJitter)/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    int panel = 0;\n    vec3 rayDir;\n    {   \n        panel = int(dot(floor(uv*2.0f), vec2(1.0f, 2.0f)));\n        \n\t\tvec2 screen = fract(uv*2.0f) * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // do rendering for this pixel\n    float rayHitTime;\n    vec3 pixelColor = GetColorForRay(cameraPos, rayDir, rayHitTime, panel, fragCoord);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // get the neighborhood min / max from this frame's render\n    vec3 center = texture(iChannel0, uv).rgb;\n    vec3 minColor = center;\n    vec3 maxColor = center;\n    for (int iy = -1; iy <= 1; ++iy)\n    {\n        for (int ix = -1; ix <= 1; ++ix)\n        {\n            if (ix == 0 && iy == 0)\n                continue;\n            \n           \n            vec2 offsetUV = ((fragCoord + vec2(ix, iy)) / iResolution.xy);\n            vec3 color = texture(iChannel0, offsetUV).rgb;\n            minColor = min(minColor, color);\n            maxColor = max(maxColor, color);\n        }\n    }\n    \n    // get last frame's pixel and clamp it to the neighborhood of this frame\n    vec3 old = texture(iChannel1, uv).rgb;    \n    old = max(minColor, old);\n    old = min(maxColor, old);\n    \n    // interpolate from the clamped old color to the new color.\n    // Reject all history when the mouse moves.\n    float lerpAmount = (iMouse.z > 0.0 || uv.y > 0.5f) ? 1.0f : 0.1f;\n    vec3 pixelColor = mix(old, center, lerpAmount);        \n    fragColor = vec4(pixelColor, 1.0f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ANIMATE_NOISE 1\n\nconst int c_numShadowRays = 16;  // blue noise will use 64 samples max. white noise will use however many you specify here.\n#define c_lightDir normalize(vec3(0.3f, 1.0f, -0.5f))\nconst vec3 c_lightColor = vec3(1.0f, 0.8f, 0.5f);\nconst vec3 c_lightAmbient = vec3(0.05f, 0.05f, 0.05f);\nconst float c_lightRadius = 0.1f; // radius of light disk at 1 unit away\n\n\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n\nconst float c_FOV = 90.0f; // in degrees\nconst float c_cameraDistance = 100.0f;\nconst float c_minCameraAngle = c_pi / 2.0f;\nconst float c_maxCameraAngle = c_pi;\nconst vec3 c_cameraAt = vec3(0.0f, 20.0f, 0.0f);\nconst float c_rayMaxDist = 10000.0f;\n\nconst vec2 c_defaultMousePos = vec2(0.0f / 800.0f, 250.0f / 450.0f);\n\nconst float c_hitNormalNudge = 0.1f;\n\n// This \"blue noise in disk\" array is blue noise in a circle and is used for sampling the\n// sun disk for the blue noise.\n// these were generated using a modified mitchell's best candidate algorithm.\n// 1) It was not calculated on a torus (no wrap around distance for points)\n// 2) Candidates were forced to be in the unit circle (through rejection sampling)\nconst vec2 BlueNoiseInDisk[64] = vec2[64](\n    vec2(0.478712,0.875764),\n    vec2(-0.337956,-0.793959),\n    vec2(-0.955259,-0.028164),\n    vec2(0.864527,0.325689),\n    vec2(0.209342,-0.395657),\n    vec2(-0.106779,0.672585),\n    vec2(0.156213,0.235113),\n    vec2(-0.413644,-0.082856),\n    vec2(-0.415667,0.323909),\n    vec2(0.141896,-0.939980),\n    vec2(0.954932,-0.182516),\n    vec2(-0.766184,0.410799),\n    vec2(-0.434912,-0.458845),\n    vec2(0.415242,-0.078724),\n    vec2(0.728335,-0.491777),\n    vec2(-0.058086,-0.066401),\n    vec2(0.202990,0.686837),\n    vec2(-0.808362,-0.556402),\n    vec2(0.507386,-0.640839),\n    vec2(-0.723494,-0.229240),\n    vec2(0.489740,0.317826),\n    vec2(-0.622663,0.765301),\n    vec2(-0.010640,0.929347),\n    vec2(0.663146,0.647618),\n    vec2(-0.096674,-0.413835),\n    vec2(0.525945,-0.321063),\n    vec2(-0.122533,0.366019),\n    vec2(0.195235,-0.687983),\n    vec2(-0.563203,0.098748),\n    vec2(0.418563,0.561335),\n    vec2(-0.378595,0.800367),\n    vec2(0.826922,0.001024),\n    vec2(-0.085372,-0.766651),\n    vec2(-0.921920,0.183673),\n    vec2(-0.590008,-0.721799),\n    vec2(0.167751,-0.164393),\n    vec2(0.032961,-0.562530),\n    vec2(0.632900,-0.107059),\n    vec2(-0.464080,0.569669),\n    vec2(-0.173676,-0.958758),\n    vec2(-0.242648,-0.234303),\n    vec2(-0.275362,0.157163),\n    vec2(0.382295,-0.795131),\n    vec2(0.562955,0.115562),\n    vec2(0.190586,0.470121),\n    vec2(0.770764,-0.297576),\n    vec2(0.237281,0.931050),\n    vec2(-0.666642,-0.455871),\n    vec2(-0.905649,-0.298379),\n    vec2(0.339520,0.157829),\n    vec2(0.701438,-0.704100),\n    vec2(-0.062758,0.160346),\n    vec2(-0.220674,0.957141),\n    vec2(0.642692,0.432706),\n    vec2(-0.773390,-0.015272),\n    vec2(-0.671467,0.246880),\n    vec2(0.158051,0.062859),\n    vec2(0.806009,0.527232),\n    vec2(-0.057620,-0.247071),\n    vec2(0.333436,-0.516710),\n    vec2(-0.550658,-0.315773),\n    vec2(-0.652078,0.589846),\n    vec2(0.008818,0.530556),\n    vec2(-0.210004,0.519896) \n);\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2BRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 661]], "test": "untested"}
{"id": "tdBfzm", "name": "Proto maximally even5b", "author": "Yambam", "description": "A prototype for playing maximally even musical scales (of 12 tones, but you can choose other equal divisions).", "tags": ["music", "b", "prototype", "scales", "musical", "even", "maximally", "five"], "likes": 8, "viewed": 565, "published": 3, "date": "1589724055", "time_retrieved": "2024-07-30T21:06:20.537300", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = texture(iChannel0,uv);\n    //f = 1.-smoothstep(f,f+0.01, vec4(1));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float TAU = 6.28318530718;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n//  Ambifix is a \"notation\" I (@Yambam) invented, my goal is to make learning and making use of maths more intuitive.\n//  Comments like this these are statements in a hypothetical shader language based on ambifix, with the values omitted.\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = vec2(iMouse.x,iMouse.y)/iResolution.xy;\n    vec2 uv_t = uv; //.5*uv+.5*mouse;\n    //uv_t = vec2(pow(abs(uv_t.x-.5),1.3)*8.*sign(uv_t.x-.5)+.5,uv_t.y);\n    \n    //float x = iResolution.x/iResolution.y * (1.*uv.x-.5) + .5;\n    float x = mod(.5+2.*uv_t.x,1.);\n    \n    float ed = 12.+floor(24.*mouse.x); //floor(1. + 35. * mouse.y); //sin(TAU/16. * iTime);\n    float n = ceil(ed*uv_t.y);\n    float nt = 1.+ed*uv_t.y-n;\n    float d = ed;\n    float t = -10000.;\n    float fr = mod(float(iFrame)/1.61803398875,ceil(n/(ed+1.-n))); //clamp((mouse.x-.25)*2.,0.,1.); //.5*min(3.,floor(iTime)); //1.*mod(1.*iTime,1.); //mod(8.*iTime,2.*d*d)-d*d;\n    vec2 sa = mod((-floor(floor(-x  * vec2(n+0.,n+1.)     + fr          )  * d     / vec2(n,n+1.)                   )  / d),       1. );\n//  float s =                      (*              *) (+    +) (floor) (*   *) (/              /) (floor) (negate) (/   /) (mod    )\n    float s = (1.-nt)*sa[0]+(nt)*sa[1];\n    \n    float a = mod((mod(s  - x,        1. )  + .5  ),     1. )  - .5;\n//  float a =            (-   -) (mod    ) (+    +) (mod    ) (-    -)\n    //a *= 50.;\n    //a = -log(abs(a))-3.; //*mouse.y);\n    //float t = a+2.5*sin(TAU/4.*iTime);\n    \n    float tn = 1.*(1.-500.*abs(a)); //+1.*sin(TAU/12.*iTime));\n    if (tn > t) {\n        t = tn;\n    }\n    //t = 1.+float(t>.95)-1.*t*t;\n    //t = clamp(t,       0.,1. );\n//  //t =         (clamp       )\n    vec3 colGrad = (1.  - uv.x  )  * vec3(1,.4,.4)     + uv.x  * vec3(.4,.4,1);\n//  vec3 colGrad =     (-      -) (*               *) (+      (*               *) +)\n    vec3 col = (1. - t  )  * colGrad     + t  * vec3(1,1,1);\n//                (-   -) (* colGrad *) (+   (*             *) +)\n    //vec3 col = t*vec3(1,1,1);\n    \n    vec4 colBuf = texture(iChannel0,uv);\n    //fragColor = vec4(col,1.);\n    fragColor = max(vec4(col,1.),colBuf);\n    if (iTime<.25\n    ||  iMouse.w>0.) { //.5*iResolution.y) {\n    \tfragColor = mix(fragColor,vec4(0,0,0,1),.0625);\n    \t//fragColor = mix(vec4(col,1.),vec4(0,0,0,1),.1);\n        //fragColor *= vec4(.99,.99,.99,1.);\n        //fragColor += vec4(.01,.01,.01,0.);\n    }\n    //fragColor *= 0.;\n    /*if (mod(x,1./d)<.005) {\n        fragColor.b = .2;\n    }*/\n    /*if (mod(iTime,2.)<.5) {\n        fragColor *= vec4(.9,.9,.9,1.);\n    }*/\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 189]], "test": "untested"}
{"id": "wdSfzm", "name": "Simulating the Sunrise/Sunset", "author": "Yambam", "description": "This is a fork of https://www.shadertoy.com/view/tdBfRw (Simulating the Colors of the Sky) by jamelouis\nNice things to add would be rotating the sun around a viewpoint, e.g. using a geographic calculation based on different locations on Earth + a 3D scene", "tags": ["sun", "colors", "sky", "fork", "sunrise", "simulating"], "likes": 17, "viewed": 1170, "published": 3, "date": "1589723112", "time_retrieved": "2024-07-30T21:06:21.452852", "image_code": "const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926f;\nconst float DURATION = 12.;\n\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6f);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5f;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 8u;\n    uint numSamplesLight = 8u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3.f / (16.f * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    vec3 betaRt = betaR*(1. + vec3(0.,2.,3.)*(iMouse.x/iResolution.x-.1));\n    vec3 betaMt = betaM*(1. + 16.*iMouse.y/iResolution.y);\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaRt * (opticalDepthR + opticalDepthLightR) + betaMt * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaRt * phaseR + sumM * betaMt * phaseM) * 20.;\n}\n\n#define T(p, lod) textureLod(iChannel0, p, lod).rgb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float angle = M_PI * (fract((float(iFrame)/DURATION+40.)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy  * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    float z2 = x*x + y*y;\n    \n    vec3 col = vec3(0.0);\n    float scale = .3;\n    //if(z2 <= 1.){\n        float phi = (x/2. - 10./3. * iMouse.x / iResolution.x)*2.*M_PI*scale;\n        float theta;\n        if (fract((float(iFrame)/DURATION+40.)/180.) < .5) {\n            theta = y*M_PI*scale-1.5;\n        } else {\n            theta = -(y*M_PI*scale-1.5);\n        }\n        vec3 dir = vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n        col = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir, 0., INFINITY, sunDirection);\n    //}\n    \n\n    // Output to screen\n    col = pow(col, vec3(1.0/2.5));\n    fragColor = vec4(col,1.0);\n    \n    if (uv.y < -.065) {\n        fragColor = vec4(T(fragCoord/iResolution.xy, 0.), 1.); //vec4(vec3(.3), 1.);\n    }\n}\n#undef T", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926f;\nconst float DURATION = 12.;\n\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6f);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5f;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 8u;\n    uint numSamplesLight = 8u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3.f / (16.f * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    vec3 betaRt = betaR*(1. + vec3(0.,2.,3.)*(iMouse.x/iResolution.x-.1));\n    vec3 betaMt = betaM*(1. + 16.*iMouse.y/iResolution.y);\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaRt * (opticalDepthR + opticalDepthLightR) + betaMt * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaRt * phaseR + sumM * betaMt * phaseM) * 20.;\n}\n\n\n\nconst float waveHeight = .125; // average surface height\n\nfloat spow(float x, float e)\n{\n    return pow(abs(x), e) * sign(x);\n}\n\n// 3 scrolling textures on a plane\nfloat wave(vec3 p)\n{\n//    return p.y - waveHeight + .2*spow(sin(p.x)*sin(p.z), 4.); // test bumps\n\tfloat t = iTime * .33; //0.; // scroll or don't\n    // disliked how original fudged with the texcoords\n    #define T(x,y) texture(iChannel2, (p.xz + vec2(x,y)*t) / 20.).rgb\n\tvec3 c1 = T(2., 2.);\n\tvec3 c2 = T(2.52, 5.);\n\tvec3 c3 = T(3.32, 9.);\n    #undef T\n\tc1 += c2 - c3;\n\tfloat z = (c1.x + c1.y + c1.z) / 12.;\n\treturn p.y + z;\n}\n\n// no ray marching required, just cast directly to plane\nfloat intersectWave(vec3 ro, vec3 rd) \n{\n    return (ro.y - waveHeight) / -rd.y;\n}\n\n// even fwd diff seems fine for normal\nvec3 normWave(vec3 p) \n{\n\tconst vec2 e = vec2(.25,0);\n\treturn normalize(vec3(\n\t\twave(p + e.xyy),\n\t\twave(p + e.yxy),\n\t\twave(p + e.yyx))\n      - wave(p)\n\t);\n}\n\nvec3 lightWave(vec3 ro, vec3 rd, float d)\n{\n    vec3 p = ro + rd * d; // hit point on plane\n    float sh = wave(p) - .5*waveHeight; //.25; // wave height variation\n    p.xz += 2. * sh * rd.xz; // bump offset, parallax mapping - subtle\n    sh = wave(p) - .5*waveHeight; //.25; // reeval height after bump offset\n\tvec3 n = normWave(p) // surface normal\n\t, l1 = normalize(vec3(1)); // main parallel light ('sun')\n\tfloat nv = dot(rd, n)\n\t, spc = pow(max(0., dot(reflect(l1, n), rd)), 30.) // sun specular\n    , eta = 1.003/1.3 // air vs. water\n    , waterdepth = 4.; //+ sh\n    vec3 rfd = refract(rd, n, eta);  // refract view direction\n    float depthest = -waterdepth / rfd.y; // water depth estimate along refracted path\n    \n    \n    float angle = M_PI * (fract((float(iFrame)/DURATION+40.)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n    \n    float phi = .4;\n    vec2 theta = vec2(-.35, .35);\n    vec3 dir0 = vec3(sin(theta[0])*cos(phi), cos(theta[0]), sin(theta[0])*sin(phi));\n    vec3 dir1 = vec3(sin(theta[1])*cos(phi), cos(theta[1]), sin(theta[1])*sin(phi));\n\t\n    vec3 col0 = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir0, 0., INFINITY, sunDirection).rgb;\n    vec3 col1 = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir1, 0., INFINITY, sunDirection).rgb;\n    \n    vec3 ref = texture(iChannel0, reflect(rd, n)*.667).rgb // reflection environment cubemap\n    , rfa = mix(\n        col0\n        ,\n        texture(iChannel1, (p + rfd*depthest).xz / 4.).rgb\n        ,\n        .3\n    ); // regular refraction\n    // HACK the original just did everything in srgb gamma\n    // which is not correct, but it's really hard to match\n    // the look without doing basically the same thing.\n\t// gave up on good gamma correction until I can\n    // match the look better somehow.\n     //   ref = pow(ref, vec3(2.2));\n     //   rfa = pow(rfa, vec3(2.2));\n    ref *= .5;\n    rfa *= exp2(-.125 * depthest); // extinct by water depth estimate\n    vec3 c;\n//    c = n * .5 + .5; // DEBUG normal\n//    c = vec3(sh * 1.5 + .5); // DEBUG height\n//    c = vec3(exp2(-.2*d)); // DEBUG depth\n//    c = vec3(spc); // DEBUG spec only\n//    c = ref; // DEBUG just envmap reflection\n//    c = rfa; // DEBUG just refraction\n//    c = spc + rfa; // DEBUG just spec + refraction\n//    c = pow(c, vec3(1./2.2)); // HACK fix gamma - temp - for debugging\n\tc = rfa + ref + spc*col1; // sum all light - in wrong gamma\n    return mix(mix(c, col0, .0), vec3(0.), pow(2., -.125 * depthest) - .65);\n}\n\n// e^(-i*angleRadians) I guess\nvec2 cossin(float angleRadians)\n{\n\treturn sin(angleRadians + vec2(1.5708,0));\n}\n\nvoid cameraRay(vec2 p, vec2 r, out vec3 ro, out vec3 rd)\n{\n\tvec2 q = (p + p - r) * .5/r.y; // signed aspect-correct uv\n\tfloat mx = (.35 + 2.5*(iMouse.x/iResolution.x)); // mouse lookaround\n    vec3 rc = vec3(500.*cos(mx), 6, 500.*sin(mx)); // look at point, spins around\n    //if (dot(iMouse.xy, vec2(1)) < 1.5) mx = iTime * -1.; // slowly spin if unattended\n\tro = vec3(0, 0, 3).xzy; // camera rotate\n\tvec3 ww = normalize(rc - ro)\n\t, uu = normalize(cross(vec3(0,1,0), ww))\n\t, vv = normalize(cross(ww, uu));\n\trd = normalize(uu * q.x + vv * q.y + ww);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 ro, rd, c = vec3(0);\n    cameraRay(fragCoord, iResolution.xy, ro, rd);\n\tfloat d = intersectWave(ro, rd);\n\tif (d >= 0.) // didn't miss? can't, really, with this camera\n        c = lightWave(ro, rd, d); // draw water\n\t//c = pow(c, vec3(1./2.2)); // to srgb gamma for storage in display buffer\n\tfragColor = vec4(c, 1);\n}\n\n\t\t//vec3 rfa = texture(iChannel1, (p+n).xz / 6.).rgb; // extreme HACK refraction\n     //   rfa *= 1.0; // HACK brighten riverbed rocks\n        //rfa *= 8./d; // HACK fade in distance to emulate missing fresnel and water extinction\n     //   rfa *= mix(1.-pow(max(0., 1.-abs(nv)), 5.), 1., .04); // fakie fresnel\n\t    //c = (c - .5) * 1.5 + .5; // HACK increase contrast\n\n", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 354, 440, 440, 697], [699, 699, 785, 785, 3179]], "test": "untested"}
{"id": "ts2BRh", "name": "Blue Noise RT Shadows TAA: Point", "author": "demofox", "description": "Showing blue noise being used for soft shadows. Drag mouse to move camera.\nLeft = white noise, Right = blue noise\nTop = Raw, Bottom = TAA with alpha 0.1, 3x3 neighborhood color clamp, halton sub pixel jitter.", "tags": ["arealight", "bluenoise", "stochastic"], "likes": 8, "viewed": 1087, "published": 3, "date": "1589692252", "time_retrieved": "2024-07-30T21:06:22.381369", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pixelColor = texture(iChannel0, uv).rgb;\n\n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // make a dividing line between the panels\n    vec2 dist2d = abs(fragCoord - iResolution.xy * 0.5f);\n    float dist = min(dist2d.x, dist2d.y);\n    dist = smoothstep(2.0f, 1.0f, dist);\n    pixelColor = mix(pixelColor, vec3(1.0f, 1.0f, 0.0f), dist);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);        \n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// white noise, from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// analytically mipmapped checkerboard pattern from inigo quilez\n// https://iquilezles.org/articles/morecheckerfiltering\nvec2 p( in vec2 x )\n{\n    vec2 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\n// return a filtered checkers pattern\nfloat checkersGradTriangle( in vec2 uv )\n{\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (p(uv+w)-2.0*p(uv)+p(uv-w))/(w*w); // analytical integral (triangle filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;    \n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n};\n    \nbool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }\n    \n    return false;\n}\n    \nbool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > 0.0f && dist < info.dist)\n        {\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.diffuse = diffuse;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool RayVsQuad(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 diffuse, bool doubleSided)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (doubleSided && dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }    \n    \n    return false;\n}\n\nSRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir, bool shadowRay)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_rayMaxDist;\n\n    // the floor\n    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))\n    {\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        vec2 uv = hitPos.xz / 100.0f;\n        float shade = mix(0.8f, 0.4f, checkersGradTriangle(uv));\n        hitInfo.diffuse = vec3(shade, shade, shade);\n    }\n    \n    // some floating spheres to cast shadows\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 10.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 20.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 50.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f));\n    \n    // the light\n    if(!shadowRay)\n        RayVsSphere(rayPos, rayDir, hitInfo, vec4(c_lightPos, c_lightRadius), c_lightColor);\n    \n    return hitInfo;\n}\n\nvec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance, int panel, in vec2 pixelPos)\n{\n    // trace primary ray\n\tSRayHitInfo hitInfo = RayVsScene(rayPos, rayDir, false);\n    \n    // set the hitDistance out parameter\n    hitDistance = hitInfo.dist;\n    \n    if (hitInfo.dist == c_rayMaxDist)\n        return texture(iChannel0, rayDir).rgb;\n    \n    // calculate where the pixel is in world space\n\tvec3 hitPos = rayPos + rayDir * hitInfo.dist;\n    hitPos += hitInfo.normal * c_hitNormalNudge;\n    \n    int frame = 0;\n    #if ANIMATE_NOISE\n    \tframe = iFrame % 64;\n    #endif\n    \n    // use the screen space blue noise texture and golden ratio * frame number to\n    // get a \"random number\" to convert to an angle for how much to rotate\n    // the blue noise sample positions for this pixel\n    float blueNoise = texture(iChannel1, pixelPos / 1024.0f).r;\n    blueNoise = fract(blueNoise + c_goldenRatioConjugate * float(frame));\n    float theta = blueNoise * 2.0f * c_pi;\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    // shoot some shadow rays\n    vec3 toLight = (c_lightPos - hitPos);\n    vec3 lightDir = normalize(toLight);\n    float lightDistance = length(toLight);\n    float lightRadius = c_lightRadius / lightDistance;\n    float shadowTerm = 0.0f;\n    vec3 lightTangent = normalize(cross(lightDir, vec3(0.0f, 1.0f, 0.0f)));\n    vec3 lightBitangent = normalize(cross(lightTangent, lightDir));\n    for (int shadowRayIndex = 0; shadowRayIndex < c_numShadowRays; ++shadowRayIndex)\n    {\n        // calculate a ray direction to a random point on a disk in the direction of the light.\n        // AKA pick a random point on the sun and shoot a ray at it.\n        vec3 shadowRayDir;\n        {\n            vec2 diskPoint;\n            if ((panel%2) == 0)\n            {\n                // get white noise\n                vec2 rng = hash23(vec3(pixelPos, float(frame * c_numShadowRays + shadowRayIndex)));\n\n                // calculate disk point\n                float pointRadius = lightRadius * sqrt(rng.x);\n                float pointAngle = rng.y * 2.0f * c_pi;\n                diskPoint = vec2(pointRadius*cos(pointAngle), pointRadius*sin(pointAngle));\n\n            }\n            else //if ((panel%2) == 1)\n            {\n                // we only have 64 blue noise samples\n                // We could make more blue noise samples, but gotta set the limit somewhere since it's a constant array of vec2s.\n                if (shadowRayIndex >= 64)\n                    break;\n                \n                // get a blue noise sample position\n                vec2 samplePos = BlueNoiseInDisk[shadowRayIndex];\n\n                // rotate it\n                diskPoint.x = samplePos.x * cosTheta - samplePos.y * sinTheta;\n                diskPoint.y = samplePos.x * sinTheta + samplePos.y * cosTheta;\n\n                // scale it by the disk size\n                diskPoint *= lightRadius;\n            }\n\n            // calculate the normalized vector to the random point on the disk\n            shadowRayDir = normalize(lightDir + diskPoint.x * lightTangent + diskPoint.y * lightBitangent);\n        }\n\n        // trace shadow ray\n        SRayHitInfo shadowHitInfo = RayVsScene(hitPos, shadowRayDir, true);\n        shadowTerm = mix(shadowTerm, ((shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f), 1.0f / float(shadowRayIndex+1));\n    }\n    \n    // do diffuse lighting\n    float dp = clamp(dot(hitInfo.normal, lightDir), 0.0f, 1.0f);\n\treturn c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm / (lightDistance*lightDistance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);    \n    \n    // calculate sub pixel jitter for anti aliasing\n    vec2 subPixelJitter = (fragCoord.y < iResolution.y * 0.5f) ? halton(iFrame % 16 + 1) - 0.5f : vec2(0.0f, 0.0f);\n    \n    // calculate the ray direction for this pixel\n    vec2 uv = (fragCoord + subPixelJitter)/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    int panel = 0;\n    vec3 rayDir;\n    {   \n        panel = int(dot(floor(uv*2.0f), vec2(1.0f, 2.0f)));\n        \n\t\tvec2 screen = fract(uv*2.0f) * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // do rendering for this pixel\n    float rayHitTime;\n    vec3 pixelColor = GetColorForRay(cameraPos, rayDir, rayHitTime, panel, fragCoord);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // get the neighborhood min / max from this frame's render\n    vec3 center = texture(iChannel0, uv).rgb;\n    vec3 minColor = center;\n    vec3 maxColor = center;\n    for (int iy = -1; iy <= 1; ++iy)\n    {\n        for (int ix = -1; ix <= 1; ++ix)\n        {\n            if (ix == 0 && iy == 0)\n                continue;\n            \n           \n            vec2 offsetUV = ((fragCoord + vec2(ix, iy)) / iResolution.xy);\n            vec3 color = texture(iChannel0, offsetUV).rgb;\n            minColor = min(minColor, color);\n            maxColor = max(maxColor, color);\n        }\n    }\n    \n    // get last frame's pixel and clamp it to the neighborhood of this frame\n    vec3 old = texture(iChannel1, uv).rgb;    \n    old = max(minColor, old);\n    old = min(maxColor, old);\n    \n    // interpolate from the clamped old color to the new color.\n    // Reject all history when the mouse moves.\n    float lerpAmount = (iMouse.z > 0.0 || uv.y > 0.5f) ? 1.0f : 0.1f;\n    vec3 pixelColor = mix(old, center, lerpAmount);        \n    fragColor = vec4(pixelColor, 1.0f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ANIMATE_NOISE 1\n\nconst int c_numShadowRays = 16;  // blue noise will use 64 samples max. white noise will use however many you specify here.\nconst vec3 c_lightPos = vec3(0.0f, 60.0f, 40.0f);\nconst float c_lightRadius = 5.0f;\nconst vec3 c_lightColor = vec3(1.0f, 0.8f, 0.5f) * 5000.0f;\nconst vec3 c_lightAmbient = vec3(0.05f, 0.05f, 0.05f);\n\n\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n\nconst float c_FOV = 90.0f; // in degrees\nconst float c_cameraDistance = 100.0f;\nconst float c_minCameraAngle = c_pi / 2.0f;\nconst float c_maxCameraAngle = c_pi;\nconst vec3 c_cameraAt = vec3(0.0f, 20.0f, 0.0f);\nconst float c_rayMaxDist = 10000.0f;\n\nconst vec2 c_defaultMousePos = vec2(0.0f / 800.0f, 250.0f / 450.0f);\n\nconst float c_hitNormalNudge = 0.1f;\n\n// This \"blue noise in disk\" array is blue noise in a circle and is used for sampling the\n// sun disk for the blue noise.\n// these were generated using a modified mitchell's best candidate algorithm.\n// 1) It was not calculated on a torus (no wrap around distance for points)\n// 2) Candidates were forced to be in the unit circle (through rejection sampling)\nconst vec2 BlueNoiseInDisk[64] = vec2[64](\n    vec2(0.478712,0.875764),\n    vec2(-0.337956,-0.793959),\n    vec2(-0.955259,-0.028164),\n    vec2(0.864527,0.325689),\n    vec2(0.209342,-0.395657),\n    vec2(-0.106779,0.672585),\n    vec2(0.156213,0.235113),\n    vec2(-0.413644,-0.082856),\n    vec2(-0.415667,0.323909),\n    vec2(0.141896,-0.939980),\n    vec2(0.954932,-0.182516),\n    vec2(-0.766184,0.410799),\n    vec2(-0.434912,-0.458845),\n    vec2(0.415242,-0.078724),\n    vec2(0.728335,-0.491777),\n    vec2(-0.058086,-0.066401),\n    vec2(0.202990,0.686837),\n    vec2(-0.808362,-0.556402),\n    vec2(0.507386,-0.640839),\n    vec2(-0.723494,-0.229240),\n    vec2(0.489740,0.317826),\n    vec2(-0.622663,0.765301),\n    vec2(-0.010640,0.929347),\n    vec2(0.663146,0.647618),\n    vec2(-0.096674,-0.413835),\n    vec2(0.525945,-0.321063),\n    vec2(-0.122533,0.366019),\n    vec2(0.195235,-0.687983),\n    vec2(-0.563203,0.098748),\n    vec2(0.418563,0.561335),\n    vec2(-0.378595,0.800367),\n    vec2(0.826922,0.001024),\n    vec2(-0.085372,-0.766651),\n    vec2(-0.921920,0.183673),\n    vec2(-0.590008,-0.721799),\n    vec2(0.167751,-0.164393),\n    vec2(0.032961,-0.562530),\n    vec2(0.632900,-0.107059),\n    vec2(-0.464080,0.569669),\n    vec2(-0.173676,-0.958758),\n    vec2(-0.242648,-0.234303),\n    vec2(-0.275362,0.157163),\n    vec2(0.382295,-0.795131),\n    vec2(0.562955,0.115562),\n    vec2(0.190586,0.470121),\n    vec2(0.770764,-0.297576),\n    vec2(0.237281,0.931050),\n    vec2(-0.666642,-0.455871),\n    vec2(-0.905649,-0.298379),\n    vec2(0.339520,0.157829),\n    vec2(0.701438,-0.704100),\n    vec2(-0.062758,0.160346),\n    vec2(-0.220674,0.957141),\n    vec2(0.642692,0.432706),\n    vec2(-0.773390,-0.015272),\n    vec2(-0.671467,0.246880),\n    vec2(0.158051,0.062859),\n    vec2(0.806009,0.527232),\n    vec2(-0.057620,-0.247071),\n    vec2(0.333436,-0.516710),\n    vec2(-0.550658,-0.315773),\n    vec2(-0.652078,0.589846),\n    vec2(0.008818,0.530556),\n    vec2(-0.210004,0.519896) \n);\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2BRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 656]], "test": "untested"}
{"id": "WsBBRw", "name": "Corroding Arbitrary SDF (2D)", "author": "blackle", "description": "this is the technique in [url]https://www.shadertoy.com/view/td2fRD[/url] but a 3d SDF mapping to a 2d sdf, instead of a 4d to a 3d. should be easier to understand.", "tags": ["sdf"], "likes": 13, "viewed": 648, "published": 3, "date": "1589661702", "time_retrieved": "2024-07-30T21:06:23.188212", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is the technique in https://www.shadertoy.com/view/td2fRD\n//but a 3d SDF mapping to a 2d sdf, instead of a 4d to a 3d.\n//should be easier to understand.\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\n//return the SDF for a sphere, or the SDF for an empty region surrounded by spheres\nfloat gated_domain(vec3 p, float scale, bool gated) {\n    if (!gated) {\n        p.xy = abs(p.xy);\n        if (p.x > p.y) p.xy = p.yx;\n        p.y -= 1./scale;\n    }\n    return length(p)-.2;\n}\n\nfloat scene3d(vec3 p) {\n    float scale = 2.;\n    vec2 id = floor(p.xy*scale);\n    p.xy = (fract(p.xy*scale)-0.5)/scale;\n    bool gated = hash(id.x, id.y) > 0.;\n    return gated_domain(p, scale, gated);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nint pittingtype;\nfloat scene2d(vec2 p) {\n    float circle = length(p)-1.;\n\n    float top = circle;\n    float last = circle;\n    for (int i = 0; i < 5; i++) {\n        float scale = 1./float(i+1);\n        //map 3d coordinates to 4d using the distance to the SDF\n    \tvec3 p3d = vec3(p, last)/scale;\n\t\t//cut out mapped spheres from SDF\n        float holes = scene3d(p3d)*scale;\n    \ttop = max(top, -holes);\n\n        if (pittingtype == 0) last = holes; //add pitting to existing pits\n        if (pittingtype == 1) last = top; //add pitting everywhere\n        if (pittingtype == 2) last = circle; //add pitting only to original surface\n    }\n    return top;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene3d(p)-vec3(scene3d(k[0]),scene3d(k[1]),scene3d(k[2])));\n}\n\nvec3 render3d(vec2 uv) {\n    \n    vec3 cam = normalize(vec3(2,uv));\n    vec3 init = vec3(-5,0,2);\n    \n    cam = erot(cam,vec3(0,1,0), .3);\n    cam = erot(cam,vec3(0,0,1), iTime*.1);\n    \n    vec3 p = init; \n    bool hit = false;\n    //raymarch\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene3d(p);\n        hit = dist*dist < 1e-6;\n        p+=cam*dist*.9;\n        if (distance(p,init) > 100.) break;\n    }\n    //shading\n    vec3 n = norm(p);\n    return hit ? sin(n)*.5+.5 : vec3(0.1);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvec3 render2d(vec2 uv, vec2 mouse) {\n    uv *= 3.; mouse *= 3.;\n    vec3 col = shadeDistance(scene2d(uv));\n    \n    float mousedist = scene2d(mouse);\n    if (iMouse.z > 0.) {\n        col *= antialias(distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    pittingtype = int(iTime)%3;\n    \n    if (uv.x > .0) {\n        fragColor.xyz = render3d(uv-vec2(0.45,0.));\n    } else {\n        fragColor.xyz = render2d(uv+vec2(0.45,0.), mouse+vec2(0.45,0.));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBBRw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[410, 410, 440, 440, 520], [522, 606, 659, 659, 797], [799, 799, 822, 822, 1003], [1005, 1005, 1043, 1043, 1107], [1126, 1126, 1149, 1149, 1763], [1765, 1765, 1784, 1784, 1906], [1908, 1908, 1932, 1932, 2416], [2418, 2418, 2447, 2447, 2755], [2757, 2757, 2783, 2783, 2874], [2876, 2876, 2912, 2912, 3146], [3148, 3148, 3205, 3205, 3530]], "test": "ok"}
{"id": "3sBBRw", "name": "Abstract galaxy", "author": "mrange", "description": "License CC0: Abstract Galaxy\nBeen working on scifi shaders, while this is not \"realistic\" looking I find it nice to look at\n", "tags": ["2d", "fbm"], "likes": 5, "viewed": 453, "published": 3, "date": "1589660626", "time_retrieved": "2024-07-30T21:06:23.926239", "image_code": "// License CC0: Abstract Galaxy\n//\tBeen working on scifi shaders, while this is not \"realistic\" looking I find it nice to look at\n#define PI           3.141592654\n#define TAU          (2.0*PI)\n\n#define TIME         (iTime*0.2)\n#define RESOLUTION   iResolution\n\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n\n#define SABS(x,k)    LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat noise1(vec2 p) {\n  float s = 1.0;\n\n  p *= tanh(0.1*length(p));\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5));\n  float d = cos(p.y*sqrt(1.5));\n\n  return a*b*c*d;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat galaxy(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*3.0 + a;\n  p = toRect(pp);\n  \n  p *= z;\n  \n  return noise1(p);\n}\n\nfloat height(vec2 p) {\n  p *= 0.75;\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  for (int i = 0; i < 3; ++i) {\n    float g = a*galaxy(p, -0.5*TIME + TIME*(0.2*pow(float(i), 1.0)), f);\n    s += g;\n    a *= sqrt(0.5);\n    f *= sqrt(2.0);\n    d += a;\n  }\n  \n  float l = length(p);\n  \n  return SABS((-0.25+ s/d), 0.5)*exp(-5.5*l*l);\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(0.000125, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  vec3 lp1 = vec3(-2.0, 0.5, 2.0);\n  vec3 ld1 = normalize(lp1 - vec3(p.x, 0.0, p.y));\n  vec3 lp2 = vec3(2.0, 0.5, 2.0);\n  vec3 ld2 = normalize(lp2 - vec3(p.x, 0.0, p.y));\n\n  float l = length(p);\n  float tl = tanh(l);\n\n  float h = height(p);\n  float th = tanh(h);\n  vec3 n = normal(p);\n  \n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n  col += 0.5*pow(diff1, 10.0);\n  col += 0.25*pow(diff2, 2.0);\n  col += pow(vec3(0.5)*h, n.y*1.75*(mix(vec3(0.5, 1.0, 1.5), vec3(0.5, 1.0, 1.5).zyx, 1.25*tl)));\n  col += 0.9*vec3(1.0, 0.9, 0.75)*exp(-10.0*l*l);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBRw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[363, 363, 385, 385, 429], [431, 431, 452, 452, 493], [495, 495, 531, 531, 625], [627, 627, 649, 649, 826], [828, 828, 861, 861, 946], [948, 948, 988, 988, 1092], [1094, 1094, 1116, 1116, 1450], [1452, 1452, 1473, 1473, 1668], [1670, 1670, 1707, 1707, 1956], [1958, 1958, 2013, 2013, 2809]], "test": "untested"}
{"id": "td2fRD", "name": "Corroding Arbitrary SDF", "author": "blackle", "description": "a technique to add pitting to an SDF in a controlled way. cycles between three different \"modes\". see [url]https://www.shadertoy.com/view/WsBBRw[/url] for the 2d case", "tags": ["sdf"], "likes": 30, "viewed": 1007, "published": 3, "date": "1589658757", "time_retrieved": "2024-07-30T21:06:24.697178", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this shader is an experiment with mapping a 4 dimensional SDF onto a 3 dimensional one, by\n//using the components of 3d space plus the distance to a given SDF. this can be used to\n//map domain-repeated spheres onto the surface of an SDF, and use those spheres to cut holes\n//into it, much like pitted metal. Becase these spheres are restrained to the surface of the\n//SDF, we can control exactly what part of the SDF gets pitted. This shader cycles through 3\n//possibilities. pitting everything, only pitting inside existing pits, or only pitting\n//outside existing pits. There is no visible domain repetition pattern because I am also using\n//a modified version of domain repetition where some of the domains are \"disabled\" such that\n//they report the distance as if the neighbour domains are filled, but it is empty. this means\n//you can make an arbitrary percentage of domains empty, and therefore no holes will appear\n\n//see https://www.shadertoy.com/view/WsBBRw for the 2d case\n\n//return the SDF for a sphere, or the SDF for an empty region surrounded by spheres\nfloat gated_domain(vec4 p, float scale, bool gated) {\n    if (!gated) {\n        p.yzw = abs(p.yzw);\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.z > p.w) p.zw = p.wz;\n        if (p.y > p.z) p.yz = p.zy;\n        p.w -= scale;\n    }\n    return length(p)-scale/2.2;\n}\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nint pittingtype;\nfloat scene(vec3 p) {\n    float sphere = length(p)-1.;\n    float cut = p.z;\n    \n    float top = sphere;\n    float last = sphere;\n    for (int i = 0; i < 5; i++) { //5 octaves of noise\n        //random rotations\n        p = erot(p, normalize(vec3(1,2,3)), .2);\n        p = erot(p, normalize(vec3(1,3,2)), .51);\n\n    \tfloat scale = .5/pow(float(i+1),1.5);\n\n        //create 4d coordinates where the first coordinate is the distance to the SDF\n    \tvec4 p4d = vec4(last,p);\n\n        //domain repetition *only* along the yzw axes\n    \tvec3 id = floor(p4d.yzw/scale);\n    \tp4d.yzw = (fract(p4d.yzw/scale)-0.5)*scale;\n\n        //disable 50% of spheres. see https://www.shadertoy.com/view/WsSBRD for another example of this technique\n    \tbool gated = hash(id.x, hash(id.y, id.z)) > 0.;\n        float holes = gated_domain(p4d, scale, gated);\n        top = -smin(-top, holes, 0.04*sqrt(scale));\n\n        if (pittingtype == 0) last = holes; //add pitting to existing pits\n        if (pittingtype == 1) last = top; //add pitting everywhere\n        if (pittingtype == 2) last = sphere; //add pitting only to original surface\n    }\n    \n    return max(top,-cut);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    pittingtype = int(iTime)%3;\n\n    vec3 cam = normalize(vec3(2,uv));\n    vec3 init = vec3(-5,0,0);\n\n   \tfloat yrot = 0.5;\n    float zrot = 4.5;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    } else {\n        yrot += cos(iTime)*.2;\n        zrot += sin(iTime)*.2;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init; \n    bool hit = false;\n    //raymarch\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=cam*dist*.9;\n        if (distance(p,init) > 10.) break;\n    }\n    //shading\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    ao *= smoothstep(-.2,.2,scene(p+n*.2));\n    ao*=ao;\n    float diff = length(sin(n*2.)*.5+.5)/sqrt(3.);\n    float spec = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    float fresnel = 1.-abs(dot(cam,n))*.98;\n    vec3 col = abs(erot(vec3(0.1,0.04,0.03),r,0.05))*diff*diff*ao + pow(spec, 10.)*fresnel*ao;\n    fragColor.xyz = sqrt((hit ? col : vec3(0.))*2.) + abs(hash(iTime, hash(uv.x,uv.y)))*.04;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2fRD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1180, 1264, 1317, 1317, 1533], [1590, 1590, 1620, 1620, 1700], [1702, 1702, 1740, 1740, 1802], [1804, 1804, 1843, 1843, 1914], [1933, 1933, 1954, 1954, 3086], [3088, 3088, 3107, 3107, 3221], [3223, 3223, 3280, 3280, 4629]], "test": "ok"}
{"id": "MddXzN", "name": "Math fun.", "author": "WojtaZam", "description": "Animation based on tan function.", "tags": ["2d", "math"], "likes": 7, "viewed": 339, "published": 3, "date": "1589658340", "time_retrieved": "2024-07-30T21:06:25.510005", "image_code": "#define st( fun ) smoothstep( 0.99, 1.0, fun )\n\nconst vec4 red = vec4( 1.0, 0.0, 0.0, 1.0 );\nconst vec4 blue = vec4( 0.0, 0.0, 1.0, 1.0 );\n\n#define fun(x) tan(100.0*x)/20.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n    p = 2.0 * p - 1.0;\n    p *=  vec2( iResolution.x / iResolution.y, 1.0 );\n    \n\tvec4 color = vec4( 1.0 );\n    float timeFactor = sin( iTime );\n    vec2 p2 = vec2( fun(p.x), fun(p.y) );\n    float f = st( length( p ) + length(p2) * timeFactor );\n\tcolor = mix( red, color, f );\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 231, 231, 580]], "test": "untested"}
{"id": "ts2fRD", "name": "Shinier... easier refresh rate!", "author": "Yambam", "description": "repurposed shader, based on my previous Blurravison effect: https://www.shadertoy.com/view/3djBz1", "tags": ["video", "blur", "animation", "image", "motion", "frames", "stroboscope", "overlayed"], "likes": 5, "viewed": 446, "published": 3, "date": "1589653179", "time_retrieved": "2024-07-30T21:06:26.358735", "image_code": "// Fork of \"Less pixels to draw+motion blur!\" by Yambam. https://shadertoy.com/view/tsjfRD\n// 2020-05-16 18:13:23\n\n// Fork of \"Stroboscopic motion image\" by Yambam. https://shadertoy.com/view/wsjfzW\n// 2020-05-16 17:00:31\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    U /= iResolution.xy;\n    O = texture(iChannel0, U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BLURINESS 1.     //Nice values between 0.8 and 0.99\n#define CHROMA_THRESH .4  //Nice values between .25 and .65\n\n#define ZOOM0 1.\n#define DITHER0 .012\n\n#define ZOOM1 1.\n#define DITHER1 .006 //.01 //\n\n#define MOTION_BLUR 8.    //Nice values between 0. and 10.\n\n#define PASS_COUNT 20.\n\nvoid mainImage( out vec4 final_O, in vec2 _U )\n{\n    vec2 U = _U / iResolution.xy;\n    vec2 origin = vec2(.5,.35);\n    \n    final_O = vec4(0.,0.,0.,1.);\n    for (float j=0.; j<PASS_COUNT; j++) {\n        vec4 O = vec4(0.,0.,0.,1.);\n        \n        float shift = (_U.x)/1.22074408461 +\n                      (_U.y)/1.4902161201 +\n                      ((float(iFrame)*PASS_COUNT+j)/1.61803398875)*pow(iResolution.x,.5)/60./1.8191725134; // * iMouse.x/iResolution.x; //\n       \t\n        float shift_y = mod(shift/1.32471795724,1.);\n        float shift_x = mod(shift/1.75487766623,1.);\n        \n\t\tbool off = shift_x*shift_x + shift_y*shift_y > 1./DITHER1/MOTION_BLUR*DITHER1;\n        //bool off = shift_x*shift_x + shift_y*shift_y > 1.;\n        \n        \n        vec4 tex0, tex1;\n        \n        //if (!off) {\n            vec2 Ut0 = (U-origin)/ZOOM0+origin+DITHER0*vec2(-1.+2.*(mod(shift_x,1.)),\n                                                            -1.+2.*(mod(shift_y,1.)));\n            tex0 = texture(iChannel0, Ut0);\n        //}\n        if (j>=1.\n        &&  iMouse.z>0.) {\n            //Fun sharpness adjustment!\n        \ttex0 = mix(tex0, mix(vec4(.0,.0,.0,1.), final_O, 1./j), -1.5+4.*iMouse.x/iResolution.x);\n        }\n\n\n        if (!off) {\n            vec2 Ut1 = (U-origin)/ZOOM1+origin-DITHER1*vec2(-1.+2.*(mod(shift_x,1.)),\n                                                            -1.+2.*(mod(shift_y,1.)));\n            tex1 = texture(iChannel1, Ut1); //U); //\n        }\n\n\n        float chroma = 1.; //(max(distance(vec3(tex1.r,tex1.g,tex1.b), vec3(13./255., 163./255., 37./255.)), CHROMA_THRESH)-CHROMA_THRESH)/(1.-CHROMA_THRESH);\n        \n        //O = tex0;\n        vec4 bg_col = vec4(0.085 + 0.085*cos(iTime+U.xyx+vec3(0,2,4)), 1.); //vec4(.25,.0,.4,0.) //\n        O = mix(tex0, bg_col, 1.-BLURINESS); //mix(O, bg_col, 1.-BLURINESS);\n        if (!off) {\n        \tO = mix(O, tex1, (0.+1.*chroma));\n        }\n        //O = O - vec4(.01,.01,.01,.0);\n        \n    \tfinal_O += O;\n    }\n    \n    final_O = mix(vec4(.0,.0,.0,1.), final_O, 1./PASS_COUNT);\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2fRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 264, 264, 322]], "test": "untested"}
{"id": "wsjfRD", "name": "Simple LoDless Volumetric Clouds", "author": "42yeah", "description": "Dissecting iq's clouds - https://www.shadertoy.com/view/XslGRr and here's what I get by far. No fancy lods or textures. There aren't even lighting! But I am kinda satisfied with this, and will post a lighted up one next morning :P", "tags": ["raymarching", "simple", "clouds", "volumetric", "iq", "lodless"], "likes": 28, "viewed": 2107, "published": 3, "date": "1589650755", "time_retrieved": "2024-07-30T21:06:27.295231", "image_code": "// Created by 42yeah - 42yeah/2020\n// Ripped off from inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Simple LoDless Volumetric clouds. It does NOT perform level of detail (LOD) for faster rendering\n\n// A white noise function.\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n\n// A perlin noise function. Since we are not using textures, we am gonna sample 8 corners of a cube.\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n\n// The fbm function. iq unrolled the loop, so I am doing it too.\n// If you wonder what fbm is, check this out: https://thebookofshaders.com/13/\nfloat fbm(vec3 p) {\n    vec3 off = vec3(0.0, 0.1, 1.0) * iTime;\n    vec3 q = p - off;\n    \n    // fbm\n    float f = 0.5 * perlin(q); q *= 2.0;\n    f += 0.25 * perlin(q); q *= 2.0;\n    f += 0.125 * perlin(q); q *= 2.0;\n    f += 0.06250 * perlin(q); q *= 2.0;\n    f += 0.03125 * perlin(q);\n    return clamp(f - p.y, 0.0, 1.0);\n}\n\n// volmetric raymarching, which is kinda like the core algorithm.\n// I ripped lighting calculations and other stuffs off, so this is bare bones raymarching\nvec3 volumetricTrace(vec3 ro, vec3 rd) {\n    // at first there's no depth\n    float depth = 0.0;\n    \n    // and the color's black\n    vec4 sumColor = vec4(0.0);\n    \n    // then we begin to march\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + depth * rd;\n        \n        // and we get the cloud density at said position\n        float density = fbm(p);\n        // if there is an unignorable amount of density (the cloud is thick enough) then\n        if (density > 1e-3) {\n            // we estimate the color with density (the thicker, the whiter)\n            vec4 color = vec4(mix(vec3(0.0), vec3(1.0), density), density);\n            // and we multiply it by a factor so it makes the clouds softer\n            color.w *= 0.4;\n            color.rgb *= color.w;\n            // sumColor.w will rise steadily, which stands for when the ray hits thick enough cloud,\n            // its color won't change anymore\n            sumColor += color * (1.0 - sumColor.a);\n        }\n        // we march forward\n        depth += max(0.05, 0.02 * depth);\n    }\n    return clamp(sumColor.rgb, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // standard raymarching routine\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    vec3 ro = vec3(0.0, 1.0, 5.0);\n    vec3 center = vec3(0.0);\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    \n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n\n    vec3 objColor = volumetricTrace(ro, rd);\n    \n    // gamma correction (yeah, that's definitely not needed here)\n    objColor = pow(objColor, vec3(0.4545));\n\n    fragColor = vec4(objColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[266, 293, 313, 313, 398], [400, 501, 523, 523, 1092], [1094, 1238, 1257, 1257, 1564], [1566, 1722, 1762, 1795, 2824], [2826, 2826, 2881, 2917, 3669]], "test": "untested"}
{"id": "tsjfRD", "name": "Less pixels to draw+motion blur!", "author": "Yambam", "description": "You can use this shader to speed up the rendering of your current shader! Just put your real shader in Buffer A. :)\n\nrepurposed shader, based on my previous Blurravison effect: https://www.shadertoy.com/view/3djBz1", "tags": ["video", "blur", "animation", "image", "motion", "frames", "stroboscope", "overlayed"], "likes": 4, "viewed": 628, "published": 3, "date": "1589650531", "time_retrieved": "2024-07-30T21:06:28.371354", "image_code": "// Fork of \"Stroboscopic motion image\" by Yambam. https://shadertoy.com/view/wsjfzW\n// 2020-05-16 17:00:31\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    U /= iResolution.xy;\n    O = texture(iChannel0, U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BLURINESS 1.     //Nice values between 0.8 and 0.99\n#define CHROMA_THRESH .4  //Nice values between .25 and .65\n\n#define ZOOM0 1.\n#define DITHER0 .0\n\n#define ZOOM1 1.\n#define DITHER1 .0003 //.01 //\n\n#define MOTION_BLUR 4.    //Nice values between 0. and 10.\n\n#define PASS_COUNT 12.\n\nvoid mainImage( out vec4 final_O, in vec2 _U )\n{\n    vec2 U = _U / iResolution.xy;\n    vec2 origin = vec2(.5,.35);\n    \n    final_O = vec4(0.,0.,0.,1.);\n    for (float j=0.; j<PASS_COUNT; j++) {\n        vec4 O = vec4(0.,0.,0.,1.);\n        \n        float shift = (_U.x)/1.22074408461 +\n                      (_U.y)/1.4902161201 +\n                      ((float(iFrame)*PASS_COUNT+j)/1.61803398875)*pow(iResolution.x,.5)/60./1.8191725134; // * iMouse.x/iResolution.x; //\n       \t\n        float shift_y = mod(shift/1.32471795724,1.);\n        float shift_x = mod(shift/1.75487766623,1.);\n        \n\t\tbool off = shift_x*shift_x + shift_y*shift_y > 1./DITHER1/MOTION_BLUR*DITHER1;\n        //bool off = shift_x*shift_x + shift_y*shift_y > 1.;\n        \n        \n        vec4 tex0, tex1;\n        \n        //if (!off) {\n            vec2 Ut0 = (U-origin)/ZOOM0+origin+DITHER0*vec2(-1.+2.*(mod(shift_x,1.)),\n                                                            -1.+2.*(mod(shift_y,1.)));\n            tex0 = texture(iChannel0, Ut0);\n        //}\n        if (j>=1.\n        &&  iMouse.z>0.) {\n            //Fun sharpness adjustment!\n        \ttex0 = mix(tex0, mix(vec4(.0,.0,.0,1.), final_O, 1./j), -1.5+4.*iMouse.x/iResolution.x);\n        }\n\n\n        if (!off) {\n            vec2 Ut1 = (U-origin)/ZOOM1+origin-DITHER1*vec2(-1.+2.*(mod(shift_x,1.)),\n                                                            -1.+2.*(mod(shift_y,1.)));\n            tex1 = texture(iChannel1, Ut1); //U); //\n        }\n\n\n        float chroma = 1.; //(max(distance(vec3(tex1.r,tex1.g,tex1.b), vec3(13./255., 163./255., 37./255.)), CHROMA_THRESH)-CHROMA_THRESH)/(1.-CHROMA_THRESH);\n        \n        //O = tex0;\n        vec4 bg_col = vec4(0.085 + 0.085*cos(iTime+U.xyx+vec3(0,2,4)), 1.); //vec4(.25,.0,.4,0.) //\n        O = mix(tex0, bg_col, 1.-BLURINESS); //mix(O, bg_col, 1.-BLURINESS);\n        if (!off) {\n        \tO = mix(O, tex1, (0.+1.*chroma));\n        }\n        //O = O - vec4(.01,.01,.01,.0);\n        \n    \tfinal_O += O;\n    }\n    \n    final_O = mix(vec4(.0,.0,.0,1.), final_O, 1./PASS_COUNT);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 149, 149, 207]], "test": "untested"}
{"id": "wsjfzW", "name": "Stroboscopic motion image", "author": "Yambam", "description": "repurposed shader, based on my previous Blurravison effect: https://www.shadertoy.com/view/3djBz1", "tags": ["video", "blur", "animation", "image", "motion", "frames", "stroboscope", "overlayed"], "likes": 9, "viewed": 521, "published": 3, "date": "1589643852", "time_retrieved": "2024-07-30T21:06:29.597078", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    U /= iResolution.xy;\n    O = texture(iChannel0, U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BLURINESS .999      //Nice values between 0.8 and 0.99\n#define CHROMA_THRESH .4  //Nice values between .25 and .65\n\n#define ZOOM0 .999\n#define DITHER0 .0\n\n#define ZOOM1 1.\n#define DITHER1 0.00045724737 //.003 //\n\n#define MOTION_BLUR 1.    //Nice values between 0. and 100.\n\n#define PASS_COUNT 6.\n\nvoid mainImage( out vec4 final_O, in vec2 _U )\n{\n    vec2 U = _U / iResolution.xy;\n    vec2 origin = vec2(.5,.8);\n    \n    final_O = vec4(0.,0.,0.,1.);\n    for (float j=0.; j<PASS_COUNT; j++) {\n        vec4 O = vec4(0.,0.,0.,1.);\n        \n        float shift = (_U.x)/1.22074408461 +\n                      (_U.y)/1.4902161201 +\n                      ((float(iFrame)*PASS_COUNT+j)/1.61803398875)*pow(iResolution.x,.5)/60./1.8191725134; // * iMouse.x/iResolution.x; //\n       \t\n        float shift_y = mod(shift/1.32471795724,1.);\n        float shift_x = mod(shift/1.75487766623,1.);\n        \n\t\tbool off = shift_x*shift_x + shift_y*shift_y > .01/DITHER1/MOTION_BLUR;\n        //bool off = abs(shift_x) + abs(shift_y) < .01;\n        \n        \n        vec4 tex0, tex1;\n        \n        //if (!off) {\n            vec2 Ut0 = (U-origin)/ZOOM0+origin+DITHER0*vec2(-1.+2.*(mod(shift_x,1.)),\n                                                            -1.+2.*(mod(shift_y,1.)));\n            tex0 = texture(iChannel0, Ut0);\n        //}\n        if (j>=1.\n        &&  iMouse.z>0.) {\n            //Fun sharpness adjustment!\n        \ttex0 = mix(tex0, mix(vec4(.0,.0,.0,1.), final_O, 1./j), -1.5+4.*iMouse.x/iResolution.x);\n        }\n\n        \n        if (!off) {\n            vec2 Ut1 = (U-origin)/ZOOM1+origin-DITHER1*vec2(-1.+2.*(mod(shift_x,1.)),\n                                                            -1.+2.*(mod(shift_y,1.)));\n            tex1 = texture(iChannel1, Ut1); //U); //\n        }\n\n        float chroma = (max(distance(vec3(tex1.r,tex1.g,tex1.b), vec3(13./255., 163./255., 37./255.)), CHROMA_THRESH)-CHROMA_THRESH)/(1.-CHROMA_THRESH);\n        \n        //O = tex0;\n        vec4 bg_col = vec4(0.085 + 0.085*cos(iTime+U.xyx+vec3(0,2,4)), 1.); //vec4(.25,.0,.4,0.) //\n        O = mix(tex0, bg_col, 1.-BLURINESS); //mix(O, bg_col, 1.-BLURINESS);\n        if (!off) {\n        \tO = mix(O, tex1, (0.+1.*chroma));\n        }\n        //O = O - vec4(.01,.01,.01,.0);\n        \n    \tfinal_O += O;\n    }\n    \n    final_O = mix(vec4(.0,.0,.0,1.), final_O, 1./PASS_COUNT);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 99]], "test": "untested"}
{"id": "ws2BRW", "name": "Square + Circle Construction", "author": "blackle", "description": "how the square + circle shape is built", "tags": ["construction"], "likes": 7, "viewed": 353, "published": 3, "date": "1589640104", "time_retrieved": "2024-07-30T21:06:30.366021", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat antialias(float x) {\n    float pixelsize = 4./iResolution.y;\n    return smoothstep(pixelsize, 0., x);\n}\n\nconst float PI = acos(-1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=3.; mouse*=3.;\n    \n    \n    float col = 0.;\n    float animlen = 27.;\n    float timeline = abs(asin(sin(iTime*PI/animlen/2.))*animlen/PI*2.);\n    \n    float radius = 1.;\n    float sharpness = pow(asin(sin(max(4.7, timeline*1.2)))/PI+1.,8.);\n    float offset = sin(iTime*0.65)*0.25+0.25;\n    \n    float axis_fade = smoothstep(0., 1., timeline);\n    float sphere_fade = smoothstep(2., 3., timeline);\n    float point_fade = smoothstep(17., 16., timeline);\n    float mirror_fade = smoothstep(9., 10., timeline)*smoothstep(20., 19., timeline);\n    float cut_fade = abs(uv.x) > uv.y ? smoothstep(14., 13., timeline) : 1.;\n    float rep_fade = smoothstep(16., 17., timeline+uv.y*.1);\n    float sector_pulse = smoothstep(.5,0.,abs(timeline-13.5));\n    \n    col += antialias(min(abs(uv.x), abs(uv.y)))*.33*axis_fade; //axes\n    col += antialias(abs(abs(uv.x)-abs(uv.y))/sqrt(2.))*.66*mirror_fade; //mirror axes\n    col += antialias(abs(uv.x)-uv.y)*.2*sector_pulse; //sector to be mirrored\n    col += antialias(length(uv+vec2(0, sharpness))-.01)*sphere_fade*point_fade; //circle center\n\tcol += antialias(abs(length(uv+vec2(0, sharpness))-radius-sharpness))*sphere_fade*cut_fade*(1.-rep_fade); //circle\n    vec2 uv_mapped = abs(uv); if (uv_mapped.x > uv_mapped.y) uv_mapped = uv_mapped.yx;\n    col += antialias(abs(length(uv_mapped+vec2(0, sharpness))-radius-sharpness))*rep_fade; //mirrored circle\n\n\tfragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BRW.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 220, 220, 303], [333, 333, 390, 390, 1936]], "test": "untested"}
{"id": "3s2fR1", "name": "Truchet experimentations", "author": "ManuManu", "description": "some try with Truchet ", "tags": ["2d", "truchet", "layers"], "likes": 6, "viewed": 428, "published": 3, "date": "1589637601", "time_retrieved": "2024-07-30T21:06:31.106042", "image_code": "\nfloat hash21(vec2 p)\n{\n    float v = fract(sin( p.x*1234.68 + p.y * 98765.543)*753.159);\n    return v;\n}\n\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b * cos( 2.*3.14159 * ( c * t + d) );\n}\n\n// Different tries with palettes :\nvec3 MyPalette1( float t )\n{\n    return palette( t, vec3(.8, .5, .4), vec3(.2,.4,.2), vec3( .5), vec3( 0., .25, .25));\n}\nvec3 MyPalette2( float t )\n{\n    return palette( t, vec3(.5, .5, 5), vec3(.5, .5, .5), vec3( 1., 0.7,0.4), vec3( 0., .15, .2));\n}\nvec3 MyPalette3( float t )\n{\n    return palette( t, vec3(.5), vec3(.5), vec3( 1.), vec3( 0.3, .2, .2));\n}\nvec3 MyPalette4( float t )\n{\n    return palette( t, vec3(.5), vec3(.5), vec3( 1.,1.,0.5), vec3( 0.8, .9, .3));\n}\nvec3 MyPalette5( float t )\n{\n    return palette( t, vec3(.8, .5, .4), vec3(.2), vec3( .5,.5,0.5), vec3( 0., .9, .3));\n}\n\n\nvec3 MyPalette( float t )\n{\n    return MyPalette3(t);\n}\n\nfloat full_width = 0.09;\nfloat fade_width = 0.1;\n\nvec3 insideBoxDraw2( vec2 uv )\n{\n    vec3 col;\n    float d = min( abs(uv.x), abs(uv.y));\n    float val = smoothstep( fade_width, 0.,  d - full_width);\n    col = vec3(val);\n    return col;\n}\nvec3 insideBoxDraw3( vec2 uv )\n{\n    vec3 col;\n    float d = abs(abs(uv.x + uv.y) -.5);\n    float val = smoothstep( fade_width, 0.,  d - full_width);\n    col = vec3(val);\n    return col;\n}\n\nvec3 circle( vec2 uv, vec2 center, float rad, float width, vec3 color )\n{\n    float d = length(uv - center );\n    float val = smoothstep(  fade_width, 0., abs( d-rad) - full_width );\n    return val * color;\n}\n\nvec3 insideBoxDraw( vec2 uv )\n{\n    vec3 col = vec3(0.);\n    \n    vec2 center = vec2(.5,.5);\n    vec2 center2 = vec2(-.5,-.5);\n    \n    col  = circle( uv, center, .5, 0.05, vec3( 1.,1.,1.));\n    col += circle( uv, center2, .5, 0.05, vec3( 1.,1.,1.));\n    return col;\n}\n\nfloat truchet(vec2 p )\n{\n    float returnVal = 0.;\n    \n    vec2 boxCoord = fract(p)-.5;\n    vec2 id = floor(p);\n    \n    \n    //col = vec3( 1.-length(boxCoord) );\n    \n    float rnd = hash21( id );\n    if ( rnd < .5)\n        boxCoord.x = -boxCoord.x;\n    \n    float rnd2 = mod(rnd, .5 ) * 2.; \n    if ( rnd2 < .33)\n\t    returnVal = insideBoxDraw2(boxCoord).x;\n    else\n        if ( rnd2 < .66)\n\t\t\treturnVal = insideBoxDraw(boxCoord).x;\n        else\n            returnVal = insideBoxDraw3(boxCoord).x;\n        \n     \n    return returnVal;    \n    /*\n    if ( boxCoord.x > 0.48 || boxCoord.y > 0.48 )\n        col = vec3(1., 0.,0.);\n    //*/\n}\n\nmat2 rot( float a )\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c, s, -s, c);\n}\nvec2 moveUV( vec2 uv, float angle, float zoom, vec2 dep )\n{\n    return rot( angle ) * ( ( uv * zoom) + dep );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec2 realUv = uv;\n\tvec3 col = length(uv*.3) *vec3(0.3,0.3,0.8);\n\n    // general camera move :\n    uv = moveUV( uv, sin(iTime*.2), 1.1+.2*sin(iTime*.51), vec2(cos(iTime*.1), sin(iTime*.07)));\n    \n    float nbLayers = 10.;\n    for( float i = 0.; i < nbLayers; i+= 1.)\n    {\n        vec2 coord = moveUV( uv, iTime/(.3*i+1.), (nbLayers-i)*2., (nbLayers-i)*vec2(cos(iTime*5./(i+1.)), sin(iTime*3./(i+1.))) );\n        float truchetVal = truchet(coord);\n        \n        \n        float timeFactorPal = .5;\n        vec3 paletteColor1= mix( MyPalette1( length(coord )*2.), MyPalette5( length(coord )*.5), .5+.5*sin(iTime*timeFactorPal)) ;\n        vec3 paletteColor2 = mix( MyPalette1( length(coord )*2.), MyPalette3( length(coord )*3.), .5+.5*sin(iTime*timeFactorPal)) ;\n        \n        //vec3 paletteColor = mix( paletteColor1, paletteColor2, i/nbLayers);\n        vec3 paletteColor = paletteColor1;\n    \n        vec3 layerCol = paletteColor * ( i) / nbLayers;\n        col = mix( col,  layerCol, truchetVal);\n    }\n    \n    // Output to screen\n    //vignetting :\n    col*=smoothstep(2.5,1.,length(realUv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 105], [107, 107, 164, 164, 219], [221, 256, 284, 284, 376], [377, 377, 405, 405, 506], [507, 507, 535, 535, 612], [613, 613, 641, 641, 725], [726, 726, 754, 754, 845], [848, 848, 875, 875, 903], [955, 955, 987, 987, 1144], [1145, 1145, 1177, 1177, 1333], [1335, 1335, 1408, 1408, 1543], [1545, 1545, 1576, 1576, 1813], [1815, 1815, 1839, 1839, 2456], [2458, 2458, 2479, 2479, 2556], [2557, 2557, 2616, 2616, 2668], [2670, 2670, 2727, 2777, 4008]], "test": "untested"}
{"id": "3s2Bzz", "name": "Neon Jellyfish", "author": "friol", "description": "Relax, we'll see the vast ocean again.\n(control the lightsource with mouse)", "tags": ["waves", "sea", "volumetric", "jellyfish", "vacation"], "likes": 22, "viewed": 911, "published": 3, "date": "1589627218", "time_retrieved": "2024-07-30T21:06:32.285888", "image_code": "\n//\n// friol 2o2o\n// This time I wanted to do something more immediate\n// I started modeling a jellyfish and then added godrays \n// The technique described in this article helped a lot for volumetric light:\n// https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n// some sdf functions by iq\n// Music by Ashamaluevmusic\n// 16/5/2020: switched to a better noise function by iq\n//\n\nconst int sdfIterationsAmount=128;\nconst int GODRAYS_RAYMARCH_STEPS=16; // higher gives more accurate volumetrics, but is slower\n\nvec3 sunPos=vec3(0.0,20.,18.0);\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\n//\n//\n//\n\nfloat noise(in vec2 p)\n{\n    float height = mix(texture(iChannel0, p / 810.0, -100.0).x,1.0,0.85);\n    float height2 = mix(texture(iChannel1, p / 700.0, -200.0).x,0.0,-3.5);\n    return height2-height-0.179;\n}\n\nfloat iqnoise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//\n//\n//\n\nfloat sdSeaBox( vec3 p, vec3 b )\n{\n    float ns=getwaves(p.xz*0.1,iTime);\n    p.y-=ns/1.0;\n\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\n// by the demogroup mercury - https://mercury.sexy/hg_sdf/\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = 2.0*3.141592/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n\nfloat sdTentacles( vec3 p, float xb )\n{\n    //p=rotx(p,3.141592);\n    p.y+=3.1;\n    //p=roty(p,(p.y*sin(iTime)*.02));\n    //p.x/=.82-(p.y*0.01);\n    //p=rotz(p-vec3(.2,.0,0.0),1.0*(sin(sin(iTime)*1.0*p.y+iTime/2.0)));\n    p.xy+=.104*(sin(-iTime-p.y*2.0))*sin(iTime*1.0);  \n    //p=p-vec3((.1*p.y*(sin(iTime)))*.4,0.0,0.0);\n    p=p-vec3(1.0-p.y/5.0,0.0,0.0);\n\n    float height=3.0*(0.8+0.25*sin(iTime+3.151592));    \n    p.y-=3.0-height;\n\n    float divvv=32.0*xb;\n    vec3 q = abs(p) - vec3(p.y/divvv,height,p.y/divvv);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//\n//\n//\n\nfloat mapHemisphere(vec3 p,vec3 jfpos)\n{\n    vec3 medusaCenter=vec3(.0,0.0,0.0);\n    \n    p-=jfpos;\n    p.y*=0.8+0.25*sin(iTime+3.151592);\n    p.x*=1.15+.03*(cos(iTime));\n    \n\t//bool s = (abs(p.z) > abs(p.x));\n    //float rangle=mix(3.141592/2.0 + atan(p.z,p.x), atan(p.x,p.z), s);\n    float rangle=atan(abs(p.z),p.x);\n    //rangle+=0.1;\n    \n    //float rangle=atan(abs(p.z)/-p.x);\n    //p.x+=0.5+.01*sin(rangle*3.141592*12.0);\n    float d=distance(p.xz,medusaCenter.xz);\n    //p.y+=0.1*sin(d);\n    //p.y-=0.2*d+.4*sin(iTime);\n    \n    if ((p.y)>abs(0.26+0.04*sin((iTime/14.0+rangle)*3.141592*8.05)))\n    {\n        float rad=1.2+abs(cos(abs(p.y))*sin(abs(p.y)));\n        rad+=.162*sin(rangle*3.141592*3.0);\n        rad+=sin(3.141592*d*1.5-iTime*4.0)*0.032; // pump\n        return (length(p)-rad);\n    }\n    \n    return 10000.0;\n}\n\nfloat mapTentacles(vec3 r)\n{\n    float t=100000.0;\n\n    pModPolar(r.xz,11.0,1.0);\n    float cap=sdTentacles(r-vec3(-.02,.5+.1*sin(iTime),.0),2.0);\n    t=min(t,cap);\n    \n    return t;\n}\n\nfloat mapJelly(vec3 r,vec3 jfpos)\n{\n    float t=10000.0;\n    //vec3 jfpos=vec3(0.1*sin(iTime),(jellyy+8.0)+cos((iTime/8.0)+3.141592)*4.0,29.0);\n    float hemi=mapHemisphere(r,jfpos);\n    float tent=mapTentacles(r-jfpos);\n    t=min(t,hemi);\n    t=min(t,tent);\n\n    return t;\n}\n\nvec2 SDFMainScene(vec3 r)\n{\n    vec3 origR=r;\n    float t=10000.0;\n\n    float seaPlane=sdSeaBox(r-vec3(0.0,12.2,0.0),vec3(10000.0,.002,10000.0));\n    t=min(t,seaPlane);\n    \n    /*vec3 c=vec3(16.0,20.0,80.0);\n    r = mod(r+0.5*c,c)-0.5*c;*/\n\n    float jelleyfish1=mapJelly(r,vec3(0.1*sin(iTime),cos((iTime/8.0)+3.141592)*4.0,8.0));\n    t=min(t,jelleyfish1);\n\n\tfloat jelleyfish2=mapJelly(r,vec3(-7.5,(-5.0+sin((iTime+3.141592)/6.0)*16.0),33.0));\n    t=min(t,jelleyfish2);\n\n\tfloat jelleyfish3=mapJelly(r,vec3(9.0,(-8.0+abs(sin((iTime+3.141592*0.666)/6.0))*16.0),33.0));\n    t=min(t,jelleyfish3);\n\n\tfloat jelleyfish4=mapJelly(r,vec3(-7.5,(-5.0+sin((iTime+3.141592)/6.0)*16.0),13.0));\n    t=min(t,jelleyfish4);\n\n\tfloat jelleyfish5=mapJelly(r,vec3(9.0,(-8.0+abs(sin((iTime+3.141592*0.666)/6.0))*16.0),13.0));\n    t=min(t,jelleyfish5);\n    \n    if (t==seaPlane) return vec2(t,2.0);\n    else if ((t==jelleyfish1)||(t==jelleyfish2)||(t==jelleyfish3)||(t==jelleyfish4)||(t==jelleyfish5)) return vec2(t,1.0);\n\n    return vec2(-1.0,-1.0);\n}\n\nvec2 SDFScatteringGrid(vec3 r)\n{\n    vec3 origR=r;\n    float t=1000.0;\n\n    /*r.x+=iTime;\n    r.z+=iTime;\n    vec3 c=vec3(4.0);\n    r.xz = mod(r.xz+0.5*c.xz,c.xz)-0.5*c.xz;*/\n    \n\t//float abox=sdBox(r-vec3(0.0,2.2,0.0),vec3(1.2,1.2,1.2));\n\t//float abox=sdSphere(r-vec3(hash13(r),2.2,0.0),hash13(r)*2.6);\n    //t=min(t,abox);\n    \n    //if (t==abox) return vec2(t,5.0);\n    //if (t==abox)     return vec2(hash13(r),5.0);\n\n\tfloat jelleyfish1=mapJelly(r,vec3(0.1*sin(iTime),cos((iTime/8.0)+3.141592)*4.0,8.0));\n    t=min(t,jelleyfish1);\n\n\tfloat jelleyfish2=mapJelly(r,vec3(-7.5,(-5.0+sin((iTime+3.141592)/6.0)*16.0),33.0));\n    t=min(t,jelleyfish2);\n\n\tfloat jelleyfish3=mapJelly(r,vec3(9.0,(-8.0+abs(sin((iTime+3.141592*0.666)/6.0))*16.0),33.0));\n    t=min(t,jelleyfish3);\n\n\tfloat jelleyfish4=mapJelly(r,vec3(-7.5,(-5.0+sin((iTime+3.141592)/6.0)*16.0),13.0));\n    t=min(t,jelleyfish4);\n\n\tfloat jelleyfish5=mapJelly(r,vec3(9.0,(-8.0+abs(sin((iTime+3.141592*0.666)/6.0))*16.0),13.0));\n    t=min(t,jelleyfish5);\n    \n    float plane=sdPlane(r-vec3(0.0,10.,0.0),vec4(0.0,-1.0,0.0,1.0));\n    t=min(t,plane);\n\n    if ((t==jelleyfish1)||(t==jelleyfish2)||(t==jelleyfish3)||(t==jelleyfish4)||(t==jelleyfish5)) return vec2(t,1.0);\n    if (t==plane) return vec2(t,5.0);\n    \n    return vec2(-1.0,-1.0);\n}\n\n//\n//\n//\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    float FOG_DENSITY = 0.035;\n    vec3 FOG_COLOR = fxcol.xyz;\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.2), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.3,.6,1.0)) );\n}\n\nvec3 traceSun(vec3 dir,vec3 l) \n{\n\tfloat sun = dot(dir,l);\n\tsun+=1.; \n    sun*=.498; \n    sun= pow(sun,64.0);\n\treturn vec3(sun)*vec3(0.7413,0.65,0.8);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFMainScene(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec3 calcNormalScattering(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFScatteringGrid(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\n// returns 1.0 - light blocked by noise, 666.0 light blocked by jelley, 999.0 light reached\nfloat scatteringRay(vec3 rayOrigin,vec3 rayDir)\n{\n    float t=0.0;\n    bool hit=false;\n    vec2 res;\n    \n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        res = SDFScatteringGrid(rayOrigin + rayDir * t);\n        if ((res[0]!=-1.0)&&(res[0] < (0.001*t)))\n        {\n            hit=true;\n            break;\n        }\n\n        t += res[0];\n    }\n\n    if (res[1]==1.0) return 666.0;\n    //if (res[1]==5.0) return fract(noise((rayOrigin+rayDir*t).xz-(iTime/4.0)))<0.35761?1.0:999.0;\n    if (res[1]==5.0) return fract(iqnoise2((rayOrigin+rayDir*t).xyz-(iTime/4.0)))<0.2861?1.0:999.0;\n    return 999.0;\n}\n\nvec3 castRay(vec3 rayOrigin, vec3 rayDir,out float accum )\n{\n    accum=0.0;\n    float t=0.0;\n    bool hit=false;\n    vec2 res;\n    \n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        res = SDFMainScene(rayOrigin + rayDir * t);\n        //if (t>=maxDistance) return vec3(-1.0);\n        if (res[0] < (0.001*t))\n        {\n            hit=true;\n            break;\n        }\n\n        t += res[0]*.5;\n       \taccum += 0.015; \n        //t+=res[0];\n    }\n    \n    if (hit==false) return vec3(-1.0);\n    \n    const int rayMarchSteps=GODRAYS_RAYMARCH_STEPS;\n    float totalRayLight=0.0;\n    vec3 pHit=rayOrigin+t*rayDir;\n\n    float startRayOffset = hash13(pHit);\n    for (int s=0;s<rayMarchSteps;s++)\n    {\n        vec3 marchingPoint = rayOrigin + (rayDir * t * ((float(s)+startRayOffset) / float(rayMarchSteps)));\n        \n        float lightContrib=scatteringRay(marchingPoint,normalize(sunPos-marchingPoint));\n        if (lightContrib==999.0)\n        {\n            totalRayLight+=(1.0/float(rayMarchSteps));\n        }\n        else if (lightContrib==666.0)\n        {\n            totalRayLight=clamp(totalRayLight-(2.0/float(rayMarchSteps)),0.0,1.0);\n        }\n    }\n\n    return vec3(t,res[1],totalRayLight);\n}\n\n// beautiful dust function by Yilin Yan - https://www.shadertoy.com/user/greenbird10\nvec2 bubble(vec2 uv, float scale) {\n    if(uv.y > 0.2) return vec2(0.);\n    float t = iTime/4.;\n    vec2 st = uv * scale;\n    vec2 _st = floor(st);\n    vec2 bias = vec2(0., 4. * sin(_st.x*128. + t));\n    float mask = smoothstep(0.1, 0.2, -cos(_st.x*128. + t));\n    st += bias;\n    vec2 _st_ = floor(st);\n    st = fract(st);\n    float size = noise(_st_)*0.07+0.01;\n    vec2 pos = vec2(noise(vec2(t, _st_.y*64.1)) * 0.8 + 0.1, 0.5);\n    if(length(st.xy - pos) < size) {\n        return (st + pos) * vec2(.1, .2) * mask;\n    }\n    return vec2(0.);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 fogColor=vec3(0.02,0.1,0.2);\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(0.33,.201,-1.0));\n    \n    float accum=0.0;\n    vec3 rayHit = castRay(rayOrigin, rayDir,accum);\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    \n    vec3 N=calcNormal(pHit);\n    float dotprod=max(dot(N,L),0.0);\n    //float NoR = -dot(N, rayDir);\n    //NoR = max(NoR, 0.0);    \n    //vec3 R=reflect(rayDir,N);\n    //vec4 ref=reflekkt(pHit,R,uv,fragCoord);\n\n    if (mat==1.0) // jellEyfishes\n    {\n        vec3 q=N;\n        vec2 matuv = vec2( atan(N.x,N.z), acos(N.y ) );\n        \n        col+=vec3(0.0,1.6,3.0)*vec3(accum)*(1.862-exp(1.0-pow(rayHit[0], 3.0)));;\n        //col+=vec3(0.1);\n    \tcol*=accum*1.5*vec3(.24,0.1,0.24);\n\n        vec2 qp = (matuv);\n        float intensity=sin(qp.y*32.0);\n        if ((intensity>=.71)&&(N.y<1.1))\n        {\n            float tt=-iTime+3.141592/8.0;\n            //tt*=.5;\n            col*=vec3(.5,0.5,0.5);\n            if ((N.y>=cos(-tt))&&(N.y<cos(-tt-0.31)))\n            {\n                col/=2.*mix(col,vec3(0.22,0.92,0.92)*(abs(N.y)*abs(cos(tt)))*abs(N.y-1.0),0.1);\n            }\n        }\n        \n        col=fog(col,distance(rayOrigin,pHit),fogColor);\n        //col=vec3(0.0);\n    }\n    else if (mat==2.0) // sea\n    {\n        col=vec3(0.24,0.436,0.746)*vec3(accum*1.5)*(0.22-exp(1.-rayHit[0]));;\n        //dotprod=pow(dotprod,22.0);\n        //col=vec3(0.224,0.536,0.946)*dotprod;//*(0.22-exp(1.-rayHit[0]));;\n        //col/=Sky(rayDir);\n        vec3 refRay=refract(rayDir,N,0.92);\n        col+=traceSun(refRay,normalize(sunPos));\n        float d=distance(pHit,rayOrigin);\n        //if (d>210.0) col/=d*0.2*iTime*0.2;\n        //col=vec3(1.0,0.0,0.0);\n        col*=distance(pHit,rayOrigin)*.2;\n        col=fog(col,distance(pHit,rayOrigin),fogColor);\n    }\n    /*else if (mat==5.0) // debug\n    {\n        vec3 N=calcNormalScattering(pHit);\n        vec3 theL=normalize(vec3(-0.33,-2.2,-1.0));\n        float dp=max(dot(N,theL),0.0);\n        col=vec3(dp);\n    }*/\n    else\n    {\n        //if (rayDir.y>0.1) col=Sky(rayDir);\n        //if (abs(rayDir.y)<.000002) col+=traceSun(rayDir,normalize(vec3(2.0,.2,5.0)));\n        //col+=traceSun(rayDir,normalize(sunPos));\n        //col+=fogColor;\n        //if (distance(rayOrigin,pHit)<10.0) col/=accum;\n    }\n    \n    if (rayHit[2]>=0.0) col*=rayHit[2];\n    \n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    float fov=1.9;\n    vec2 result = fov*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime/2.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n    uv += bubble(uv, 12.) + bubble(uv, 24.);\n\n    vec3 camPos,camTarget;\n\n    if (iMouse.z>0.0)\n    {\n    \tvec2 mousepos=(iMouse.xy-0.5*iResolution.xy)/iResolution.x;\n        sunPos.x=(mousepos.x)*40.0;\n        sunPos.z=15.0+(-mousepos.y)*40.0;\n    }\n    \n    //float fft = texture( iChannel2, vec2(0.0,0.00) ).x;\n\n    //camPos=vec3(0.0,-2.6,20.0);\n    //camTarget=vec3(0.0,-2.6,21.0);\n\n    \n    camPos=vec3(0.0,-2.6,0.0);\n    camTarget=vec3(0.0,-1.9,1.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4((render(camPos, rayDir,uv,fragCoord).xyz),1.0);\n\n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22732, "src": "https://soundcloud.com/ashamaluevmusic2/relaxing-ambient", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// wave functions by afl_ext - https://www.shadertoy.com/user/afl_ext\n\n#define ITERATIONS_RAYMARCH 12\n#define DRAG_MULT 0.048\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, float itm){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<ITERATIONS_RAYMARCH;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, itm);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2Bzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 591, 591, 702], [704, 704, 735, 735, 846], [848, 848, 879, 879, 990], [1002, 1002, 1026, 1026, 1210], [1212, 1212, 1241, 1241, 1451], [1453, 1453, 1476, 1476, 1579], [1591, 1591, 1625, 1625, 1773], [1775, 1775, 1806, 1806, 1897], [1899, 1899, 1932, 1932, 1965], [1967, 2026, 2086, 2086, 2293], [2295, 2295, 2334, 2360, 2879], [2891, 2891, 2931, 2931, 3722], [3724, 3724, 3752, 3752, 3909], [3911, 3911, 3946, 3946, 4186], [4188, 4188, 4215, 4215, 5217], [5219, 5219, 5251, 5251, 6511], [6523, 6523, 6565, 6565, 6739], [6741, 6741, 6763, 6763, 6844], [6846, 6846, 6879, 6879, 6998], [7000, 7000, 7027, 7027, 7273], [7275, 7275, 7312, 7312, 7563], [7565, 7657, 7706, 7706, 8263], [9474, 9559, 9594, 9594, 10104], [10106, 10106, 10173, 10173, 12582], [12584, 12584, 12644, 12644, 12895], [12897, 12897, 12943, 12943, 13086], [13088, 13088, 13145, 13145, 13854]], "test": "untested"}
{"id": "WsjBRW", "name": "Turbulence noise test", "author": "exandro", "description": "Turbulence noise test for cineshader", "tags": ["test", "cineshader"], "likes": 23, "viewed": 35714, "published": 3, "date": "1589609621", "time_retrieved": "2024-07-30T21:06:33.114672", "image_code": "\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    //fragColor = vec4(1.0, 1.0, 1.0, noise);\n    \n    for(float i = 1.0; i < 8.0; i++){\n    uv.y += i * 0.1 / i * \n      sin(uv.x * i * i + iTime * 0.5) * sin(uv.y * i * i + iTime * 0.5);\n  \t}\n    \n   vec3 col;\n   col.r = uv.y + noise - 0.1;\n   col.g = uv.y + noise + 0.3;\n   col.b = uv.y + noise + 0.95;\n    \n    fragColor = vec4(col,noise);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Turbulence noise\",\n\t\"description\": \"probando shadertoy a cineshader\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [191, 191, 212, 212, 2194], [2196, 2196, 2217, 2217, 2435], [2437, 2437, 2494, 2494, 3156]], "test": "untested"}
{"id": "tsBfRD", "name": "Quadratic Bezier - 3D BBox", "author": "iq", "description": "Computing the exact bounding box to a quadratic Bezier curve.   See  [url]http://iquilezles.org/articles/bezierbbox/bezierbbox.htm[/url] for the derivation.", "tags": ["3d", "bezier", "bbox"], "likes": 28, "viewed": 1100, "published": 3, "date": "1589589118", "time_retrieved": "2024-07-30T21:06:33.861674", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical computation of the exact bounding box for a cubic bezier segment\n//\n// See https://iquilezles.org/articles/bezierbbox\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (https://iquilezles.org/articles/bezierbbox)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    // extremes\n    vec3 mi = min(p0,p2);\n    vec3 ma = max(p0,p2);\n\n    // p = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n    // dp/dt = 2(t-1)*p0 + 2(1-2t)*p1 + 2t*p2 = t*(2*p0-4*p1+2*p2) + 2*(p1-p0)\n    // dp/dt = 0 -> t*(p0-2*p1+p2) = (p0-p1);\n\n    vec3 t = clamp((p0-p1)/(p0-2.0*p1+p2),0.0,1.0);\n    vec3 s = 1.0 - t;\n    vec3 q = s*s*p0 + 2.0*s*t*p1 + t*t*p2;\n\n    mi = min(mi,q);\n    ma = max(ma,q);\n    \n    return bound3( mi, ma );\n}\n\n\n// ray-ellipse intersection\nfloat iEllipse( in vec3 ro, in vec3 rd,         // ray: origin, direction\n             in vec3 c, in vec3 u, in vec3 v )  // disk: center, 1st axis, 2nd axis\n{\n\tvec3 q = ro - c;\n\tvec3 r = vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), rd ),\n\t\tdot( cross(v,q), rd ) ) / \n        dot( cross(v,u), rd );\n    \n    return (dot(r.yz,r.yz)<1.0) ? r.x : -1.0;\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nfloat length2( in vec3 v ) { return dot(v,v); }\n\nvec3 iSegment( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p =  a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( th, length2( p-q ) );\n    \n}\n\n\nfloat iBezier( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, in float width)\n{\n    const int kNum = 50;\n    \n    float hit = -1.0;\n    float res = 1e10;\n    vec3 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        vec3 b = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n        vec3 r = iSegment( ro, rd, a, b );\n        if( r.z<width*width )\n        {\n            res = min( res, r.x );\n            hit = 1.0;\n        }\n        a = b;\n    }\n    \n    return res*hit;\n    \n    \n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // bezier animation\n    float time = iTime*0.5;\n    vec3 p0 = vec3(0.8,0.6,0.8)*sin( time*0.7 + vec3(3.0,1.0,2.0) );\n    vec3 p1 = vec3(0.8,0.6,0.8)*sin( time*1.1 + vec3(0.0,6.0,1.0) );\n    vec3 p2 = vec3(0.8,0.6,0.8)*sin( time*1.3 + vec3(4.0,2.0,3.0) );\n\tfloat thickness = 0.01;\n        \n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace bezier\n    float t = iBezier( ro, rd, p0, p1, p2, thickness);\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3);\n\t}\n\n    // compute bounding box for bezier\n    bound3 bbox = BezierAABB( p0, p1, p2 );\n    bbox.mMin -= thickness;\n    bbox.mMax += thickness;\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBfRD.jpg", "access": "api", "license": "mit", "functions": [[1807, 2061, 2118, 2134, 2551], [2554, 2582, 2741, 2741, 2943], [2946, 2983, 3047, 3085, 3365], [3367, 3367, 3395, 3395, 3414], [3416, 3416, 3479, 3479, 3870], [3873, 3873, 3965, 3965, 4396], [4398, 4398, 4424, 4424, 4491]], "test": "ok"}
{"id": "wsBfzW", "name": "Chaturanga", "author": "eiffie", "description": "Almost playable Chaturanga. See code for rules.", "tags": ["game"], "likes": 20, "viewed": 507, "published": 3, "date": "1589583153", "time_retrieved": "2024-07-30T21:06:34.889925", "image_code": "//Almost Playable Chaturanga - by eiffie (because you almost want to play Chaturanga don't you)\n//Chaturanga is chess before there was chess. I'm not sure of all the rules but following wikipedia...\n//ROOKS, KNIGHTS and KINGS move as in chess\n//PAWNS move one forward or diagonally forward to capture\n//QUEENS just move 1 diagonally (they should probably also move as rooks)\n//BISHOPS jump 2 diagonally or orthogonally or move 1 diagonally or 1 forward.\n\n//This is more of an experiment than an actual game. The end game is non-existent.. literally.\n\n#define PAWN 1.\n#define ROOK 4.\n#define KNIGHT 3.\n#define BISHOP 5.\n#define QUEEN 2.\n#define KING 15.\n#define get(v) texture(iChannel0,(v+vec2(.5))/iResolution.xy)\n#define STATEVEC vec2(iResolution.x-1.,iResolution.y-1.)\n\nvec4 B[4],sel;//packed board, cell selection\nvoid loadBoard(){//load board into memory\n  for(int i=0;i<4;i++)B[i]=get(vec2(i,0));\n}\nvec4 gB(float i){return i<1.?B[0]:i<2.?B[1]:i<3.?B[2]:B[3];}//hacks for const array index\nfloat gC(float i,vec4 b){return i<1.?b.x:i<2.?b.y:i<3.?b.z:b.w;}\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits\nfloat getB(vec2 v){//unpack 6 bits per cell,4 cells per float, 16 cells per pixel\n  v=floor(v);\n  vec2 av=abs(v-vec2(3.5));//if(max(av.x,av.y)>4.)return -32.;\n  float cell=v.y*8.+v.x;\n  vec4 b=gB(cell/16.);\n  float c=gC(mod(cell/4.,4.),b);\n  return gb(c,mod(cell,4.)*6.,6.)-16.;\n}\nfloat pc2tp(float b){//piece#(1-16) to score/type (scores must be unique per type)\n  b=abs(b);\n  if(b<1.)return 0.;\n  else if(b<9.)return PAWN;\n  else if(b<11.)return ROOK;\n  else if(b<13.)return KNIGHT;\n  else if(b<15.)return BISHOP;\n  else if(b<16.)return QUEEN;\n  return KING;\n}\nvec3 mcol=vec3(0.0); \nfloat DE(vec3 p0){ \n  vec3 p=vec3(fract(p0.x)-0.5,p0.y,fract(p0.z)-0.5); \n  float mx=0.65-max(abs(p.x),abs(p.z)); \n  if(max(abs(p0.x),abs(p0.z))>4.)return mx; \n  float ts=getB(p0.xz+4.),tp=pc2tp(ts);\n  if(tp==0.)return mx;//don't step too far into the next square \n  float f0=0.46,f1=2.7,f2=0.0,f3=0.25,f4=0.66,f5=-1.,f6=2.;//base config \n  float da=1.0,ds=1.0;//bits to add and subtract to the dif type pieces \n  if(tp!=QUEEN && tp<BISHOP){p.y+=0.15;f6*=1.5;} \n  p*=f6;\n  float r=length(p.xz); \n  if(p.y>0.8){f5=1.;f0=0.;//swap base for head config \n    if(tp==PAWN || tp==BISHOP){//pawns and bishop \n      f1=3.3;f2=1.1;f3=(tp<4.?.3:.22);f4=1.57; \n      if(tp==PAWN)da=length(p-vec3(0.,1.56,0.))-0.08;//pawn \n      else ds=max(-p.y+1.0,abs(p.z-p.y*0.5+.5)-0.05); \n    }else if(tp==ROOK){//rook \n      f1=2.6;f2=8.;f3=.5;f4=1.3; \n      ds=max(-p.y+1.,min(r-.37,min(abs(p.x),abs(p.z))-0.09)); \n    }else if(tp==QUEEN || tp==KING){//queen and king \n      f1=3.3;f2=0.81;f3=.28;f4=1.3; \n      if(tp==QUEEN){//queen \n        da=length(vec3(abs(p.x)-.19,p.y-1.33,abs(p.z)-.19))-0.1; \n      }else{ \n        da=max(p.y-1.75,min(r-0.02,max(abs(p.x)-.2,length(p.yz-vec2(1.59,0.))-0.02))); \n      } \n    }else{//knight \n      f1=2.,f2=3.4,f3=.31,f4=1.5; \n      float az=abs(p.z)-(p.y-1.)*0.18; \n      da=max(az-.16-p.x*.25,max(abs(p.x+.2-az*.17)-.34,abs(p.y-p.x*.16-1.19-az*.24)-.29-p.x*.16*2.)); \n      ds=min(length(p.xy-vec2(-.53,1.09)),length(p.xy-vec2(0.,1.3)))-.07; \n    } \n  }  \n  float d=r-f0+sin(p.y*f1+f2)*f3; \n  d=max(d,p.y*f5-f4); \n  da=min(da,length(max(vec2(r-0.28,abs(p.y-0.8)),0.))-0.05); \n  d=max(min(d,da),-ds); \n  if(mcol.x>0.)mcol+=ts<0.?vec3(0.4,0.45,0.5):vec3(1.); \n  return min(0.8*d/f6,mx); \n} \nvec3 normal(vec3 p, float d){vec2 e=vec2(d,0.);\n  return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n} \nfloat spow(float a,float p){return sign(a)*pow(abs(a),p);} \nvec4 sky(vec3 ro, vec3 rd, vec3 L){ \n  vec3 bgr=vec3(0.2,0.35,0.25); \n  if(rd.y>0.){ \n    return vec4(bgr,100.0); \n  }else{ \n    float t=(-0.33-ro.y)/rd.y; \n    vec2 v=(ro.xz+rd.xz*t);//a silly way to make antialiased checks  \n    if(abs(v.x)>4. || abs(v.y)>4.)return vec4(bgr,t); \n    vec3 glow=vec3(0.);vec2 fv=floor(v+vec2(4.)); \n    if(fv.x==sel.x && fv.y==sel.y)glow=vec3(0.6,0.6,0.0); \n    if(fv.x==sel.z && fv.y==sel.w)glow=vec3(0.0,0.75,0.2); \n    v=abs(fract(vec2(v.x-v.y,v.x+v.y)*0.5)-0.5);//turn 45 deg, fract, re-center \n    v=vec2(v.x-v.y,v.x+v.y);//turn again and multiply x*y \n    float d=spow(v.x*v.y,sqrt(t)*0.03);///(1.0+t*t*0.008); \n    return vec4(glow+vec3(clamp(d,0.,1.)),t); \n  } \n} \nfloat rnd; \nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);} \nfloat DES(vec3 p){return min(DE(p),p.y+0.33);} \nfloat ShadAO(in vec3 ro, in vec3 rd){  \n float t=0.01*rnd,s=1.0,d,mn=0.01; \n for(int i=0;i<12;i++){ \n  d=max(DES(ro+rd*t),mn); \n  s=min(s,d/t+t*0.5); \n  t+=d; \n } \n return s; \n} \nvec3 scene(vec3 ro, vec3 rd){ \n  vec3 L=normalize(vec3(0.4,0.25,0.5)); \n  vec4 col=vec4(0.,0.,0.,1.);float px=1.0/iResolution.x; \n  float d,t=length(ro)-6.0; \n  ro+=t*rd;t=DE(ro)*rnd; \n  vec4 bcol=sky(ro,rd,L); \n  for(int i=0;i<99;i++){ \n    t+=d=DE(ro+rd*t); \n    if(t>bcol.w || d<px*t)break; \n  } \n  bool bHit=d<px*t?true:false; \n  if(bHit || rd.y<0.){\n    vec3 so,N,scol; \n    if(bHit){ \n      mcol=vec3(0.001); \n      so=ro+rd*t; \n      N=normal(so,px*t);if(N!=N)N=-rd; \n      scol=mcol/6.; \n    }else{ \n      t=bcol.w; \n      so=ro+rd*t;so.y+=0.01; \n      N=vec3(0.,1.,0.); \n      scol=bcol.xyz; \n    } \n    float dif=0.5+0.5*dot(N,L); \n    float spec=pow(max(dot(reflect(rd,N),L),0.),12.0); \n    float shad=ShadAO(so,L); \n    col=vec4((scol*dif+vec3(0.5,0.4,.2)*spec)*shad,0.); \n  } \n  col.xyz+=bcol.xyz*col.w; \n  return col.xyz; \n} \nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=(U.xy-0.5*iResolution.xy)/iResolution.x; \n  randomize(U);\n  vec4 st=get(STATEVEC);\n  loadBoard();\n  float viewAng0=gb(st.y,0.,4.)*0.0625*6.283,viewAng1=0.1+gb(st.y,4.,4.)*0.0625;\n  vec3 rd=normalize(vec3(uv,3.));\n  vec3 ro=vec3(sin(viewAng0)*cos(viewAng1),sin(viewAng1),cos(viewAng0)*cos(viewAng1))*33.;\n  vec3 fw=normalize(vec3(0.,-0.5,0.)-ro),rt=normalize(cross(fw,vec3(0.0,1.0,0.0))),up=cross(rt,fw);\n  sel=vec4(gb(st.w,0.,4.),gb(st.w,4.,4.),gb(st.w,8.,4.),gb(st.w,12.,4.));\n  O=vec4(scene(ro,mat3(rt,up,fw)*rd),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//comment this for a 3 move look ahead (which seems one less buggy)\n#define FOURMOVES\n\n//The idea was to flatten a min-max search tree by assigning each pixel a series of moves to attempt.\n//That idea went south pretty fast but I was able to cram a 4 move look ahead in one frame.\n//Thats 146410000 moves analyzed in 83187.5 pixels!\n//What follows is a bunch of hideous 24 bit, bit manipulation of vec4 structures. \n//... like freezing your GPU and using it as a hammer. Enjoy!  \n#define KEY_RIGHT 37.\n#define KEY_UP 38.\n#define KEY_LEFT 39.\n#define KEY_DOWN 40.\n#define PAWN 1.\n#define ROOK 4.\n#define KNIGHT 3.\n#define BISHOP 5.\n#define QUEEN 2.\n#define KING 15.\n#define ILLEGAL -32.\n#define MOVES 110.\n#define wid 8.\n#define zero 0.\n#define one 1.\n#define two 2.\n#define get(v) texture(iChannel0,(v+vec2(.5))/iResolution.xy)\n#define same(x,y) all(equal(x,y))\n#define STATEVEC vec2(iResolution.x-one,iResolution.y-one)\n#define ENDFRAME 9.\n#define ssgn(x) ((x)-.1>0.?1.:(x)+.1<0.?-1.:0.)\n#define FL(x) floor((x)+.5)\n#define VEC2ID(U) (U.y*iResolution.x+U.x-7.)*16.\n#define NOSEL 2056.\n//packed board, pieces and moves\nvec4 B[4],P[3],M[14];\nvoid Init(){\n  B[0]=vec4(274759,1589376,3199887,2134667);B[1]=vec4(4260880,4260880,4260880,4260880);\n  B[2]=vec4(4260880,4260880,4260880,4260880);B[3]=vec4(5321873,6387093,8247001,6932384);\n  P[0]=vec4(328452,67074,983047,789774);P[1]=vec4(592395,3145736,3355185,3552564);\n  P[2]=vec4(4143159,3817017,3947325,0);//B=pc6,  P=x3,y3,dead2,  M=pc4,dx4,dy4\n  M[0]=vec4(5309728,5379376,5444881,5317922);M[1]=vec4(5387570,5453075,5326116,5395764); \n  M[2]=vec4(5461269,5334310,5403958,5469463);M[3]=vec4(2589288,2720392,2851496,2982600);\n  M[4]=vec4(7505448,9603112,11700776,13798440);M[5]=vec4(2593385,2724489,2855593,2986697);\n  M[6]=vec4(7509545,9607209,11704873,13802537);M[7]=vec4(3449914,237898,1089562,4301578);\n  M[8]=vec4(3454011,241995,1093659,4305675);M[9]=vec4(3392812,1163580,4375324,2409548);\n  M[10]=vec4(180300,2146316,5428236,1299261);M[11]=vec4(3264797,4510765,315981,53293);\n  M[12]=vec4(4248077,1303358,3268894,3404591);M[13]=vec4(1307199,1175855,3273247,2228768);\n}\nbool Key(in float key){return (texture(iChannel1,vec2((key+0.5)/256.0, 0.25)).x>0.0);}\nvoid loadBoard(){for(int i=0;i<4;i++)B[i]=get(vec2(i,0));}//load to edit\nvoid loadPieces(){for(int i=0;i<3;i++)P[i]=get(vec2(i+4,0));}\nvec4 gB(float i){return i<1.?B[0]:i<2.?B[1]:i<3.?B[2]:B[3];}//hacks for const array index\nvec4 gP(float i){return i<1.?P[0]:i<2.?P[1]:P[2];}\nfloat gC(float i,vec4 b){return i<1.?b.x:i<2.?b.y:i<3.?b.z:b.w;}//get channel\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(two,start)),pow(two,bits));}//get bits\n#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(two,s)\n//set the bits of a vec4 field (xyzw), should be sb(B[m][n].. but for loop \"constants\" don't work on fields\nvoid sVb(inout vec4 b, float field, float start, float bits, float value){//yuk\n  if(field<1.)sb(b.x,start,bits,value); //i love a good hack, this isn't one of them\n  else if(field<2.)sb(b.y,start,bits,value);\n  else if(field<3.)sb(b.z,start,bits,value);\n  else sb(b.w,start,bits,value);\n}\nfloat pc2s(float b){//piece#(1-16) to score/type (scores must be unique as they are reused as type)\n  float ab=abs(b),s=16.;\n  if(ab<9.)s=PAWN;\n  else if(ab<11.)s=ROOK;\n  else if(ab<13.)s=KNIGHT;\n  else if(ab<15.)s=BISHOP;\n  else if(ab<16.)s=QUEEN;\n  return s*sign(b);\n}\nfloat getB(vec2 v){//unpack 6 bits per cell, 4 cells per float, 16 cells per pixel\n  v=FL(v);\n  vec2 av=abs(v-vec2(3.5));if(max(av.x,av.y)>4.)return ILLEGAL;\n  float cell=v.y*8.+v.x;\n  vec4 b=gB(cell/16.);\n  float c=gC(mod(cell/4.,4.),b);\n  return gb(c,mod(cell,4.)*6.,6.)-16.;\n}\nvoid putB(float pc, vec2 v){//repackage yikes! webgl didn't expect this\n  pc=floor(pc+16.5);v=FL(v);\n  vec2 av=abs(v-vec2(3.5));if(max(av.x,av.y)>4.)return;// ILLEGAL\n  float cell=v.y*8.+v.x;\n  int i=int(cell/16.);\n  float c=mod(cell/4.,4.),start=mod(cell,4.)*6.;\n  //sb(B[i][int(c)],start,6.,pc);//when var index is allowed (outside webgl) this should work but doesn't!\n  for(int n=0;n<4;n++)if(n==i){  //the field index requires a TRUE constant (not even a for loop works)\n    sVb(B[n],c,start,6.,pc);return; //when passing inout\n  }\n}\nvec2 getP(float pc){//get a piece's position, unpack 3 bits x, 3 y and 2 status (dead)\n  pc=floor(pc+16.5);\n  vec4 b=gP(pc/12.);\n  float c=gC(mod(pc/3.,4.),b);\n  float start=mod(pc,3.)*8.;\n  float dead=gb(c,start+6.,1.);\n  if(dead>0.)return vec2(-2);\n  return vec2(gb(c,start,3.),gb(c,start+3.,3.));\n}\nvoid putP(float pc, vec2 p){//update a piece\n  pc=floor(pc+16.5);p=FL(p);//from -16,16 to 0,32\n  float f=p.x<0.?64.:p.x+8.*p.y;//value to store\n  int i=int(pc/12.);\n  float start=mod(pc,3.)*8.,c=mod(pc/3.,4.);\n  for(int n=0;n<3;n++)if(n==i){sVb(P[n],c,start,7.,f);return;}\n}\nvoid putBP(float pc, vec2 v){putB(pc,v);putP(pc,v);}//why not do both\nvec3 getM(float id){id=floor(id);//unpack move, 4 bits piece #, 4 delta x, 4 delta y\n  int i=int(id/8.);float j=mod(id/2.,4.),start=mod(id,2.)*12.;//vec4,chan,startbit\n  for(int n=0;n<14;n++)if(n==i){\n    float c=gC(j,M[n]);\n    return vec3(gb(c,start,4.)+1.,gb(c,start+4.,4.)-2.,gb(c,start+8.,4.)-2.);\n  }\n  return vec3(ILLEGAL);\n}\nfloat getS(float id){//unpack a 6 bit score, each pixel holds 16 scores for series of moves\n  float pid=floor(id/16.)+7.;\n  vec4 b=get(vec2(mod(pid,iResolution.x),floor(pid/iResolution.x)));//pixel\n  float c=gC(mod(id/4.,4.),b);//channel\n  return gb(c,mod(id,4.)*6.,6.)-32.;//bits\n}\nvec4 bestLvlScore(float p, vec2 U, float lvl){//the minmax part\n  float bs=ILLEGAL*-p,bid=0.;//player -1 wants high score\n  for(float i=0.;i<MOVES;i+=one){\n    float s;\n    if(lvl==two)s=getS(U.x*MOVES+(U.y-1.)*(MOVES*MOVES)+i);\n    else{\n      vec2 v=vec2(i,U.y);if(lvl==0.)v=vec2(0.,i+1.);\n      s=get(v).x;\n    }\n    if(abs(s)>31.)continue;//illegal move\n    float rs=sin(iTime+i)+s;\n    if((p>0. && rs<bs) || (p<0. && rs>bs)){bs=s;bid=i;}\n  }\n  return vec4(bs,bid,0,0);\n}\n\nfloat legalS(float t, float p, vec2 p1, vec2 p2){//is the move legal and was a piece captured?\n  if(p2.x<zero||p2.x>=wid||p2.y<zero||p2.y>wid)return ILLEGAL;//off board\n  if(same(p1,p2))return ILLEGAL;\n  float cap=getB(p2);\n  if(cap!=zero){//not empty \n    if(sign(cap)==p)return ILLEGAL;//landed on own piece  \n  }//cap=abs(cap);\n  if(t!=PAWN && t!=ROOK)return cap;//these cannot be blocked and have no special rules\n  if(t==PAWN){//pawn needs special checks for diag capture\n    vec2 a=abs(p2-p1);\n    if((a.x==one && cap==zero) || (a.x==zero && cap!=zero))return ILLEGAL;//only captures diag \n    else return cap;\n  }\n  vec2 d=vec2(ssgn(p2.x-p1.x),ssgn(p2.y-p1.y)),w=p1+d;\n  for(int i=0;i<8;i++){//that leaves the rook that can be blocked (this works for chess bishops/queens as well)\n    if(same(w,p2))break;//not blocked\n    if(getB(w)!=zero)return ILLEGAL;//blocked\n    w+=d;\n  }\n  return cap;\n}\nfloat legalC(float t, float p, vec2 p1, vec2 p2){//check the human more carefully\n  float cap=legalS(t,p,p1,p2);\n  if(cap==ILLEGAL) return cap;//this covers offboard, cap own piece, blocked\n  vec2 a=abs(p2-p1);\n  float dy=p2.y-p1.y,mna=min(a.x,a.y),mxa=max(a.x,a.y);\n  if(t==PAWN){if(dy!=-p || a.x>1.)return ILLEGAL;}//capture handled in legalS\n  else if(t==ROOK){if(mna>0.)return ILLEGAL;}\n  else if(t==KNIGHT){if(mxa!=2. || mna != 1.)return ILLEGAL;}\n  else if(t==BISHOP){if(mxa>2. || (a.x==1. && a.y==0.) || (a.x==0. && dy==p) || (mna>0. && a.x!=a.y))return ILLEGAL;}\n  else if(t==QUEEN){if(mna==0. || mxa>1.)return ILLEGAL;}\n  else if(mxa>1.)return ILLEGAL;//king\n  return cap;\n}\nvec3 getLvlMove(float id, int lvl){return getM(mod(lvl==2?id:lvl==1?id/MOVES:id/(MOVES*MOVES),MOVES));}\nvec2 deltaMove(float p, vec2 p1, vec2 m){//the moves store a delta but some are absolute\n  if(m.y==3.)m.y=-p;//move player's forward \n  else if(m.y>=4.)m.y=m.y-4.-p1.y; //rook slides are absolute \n  if(m.x>=4.)m.x=m.x-4.-p1.x;\n  return p1+m;\n}\nfloat doMove(float p, float id, int lvl){//the id determines a series of moves, do 1\n  float score=0.;\n  vec3 m=getLvlMove(id,lvl);//get the move for this level from the id (coord)\n  if(m.x==ILLEGAL)return ILLEGAL;//not used\n  m.x*=p;\n  vec2 p1=getP(m.x);//get the position of the piece\n  if(p1.x<0.)return ILLEGAL;//end of branch, piece is captured\n  vec2 p2=deltaMove(p,p1,m.yz);\n  float cap=legalS(abs(pc2s(m.x)),p,p1,p2);\n  if(cap==ILLEGAL)return ILLEGAL;//end of branch, bad move\n  if(cap!=0.){\n    score=pc2s(cap);\n    putP(cap,vec2(-2));//wipe piece off board\n  }\n  putB(0.,p1);putB(m.x,p2);putP(m.x,p2);//remove from old position and set at new\n  return score;\n}\nvec4 doMoves(float player, vec2 U){//p=player -1,1, each pixel holds 16 scores (do a bunch)\n  vec4 sc=vec4(0);\n  float id=VEC2ID(U);\n  if(id>MOVES*MOVES*MOVES)return sc;//returns 16 illegal scores -32\n  for(float i=0.;i<16.;i+=one){//the pixel is filled with 16 scores\n    loadBoard();loadPieces();//reset the board and pieces\n    float p=player,score=0.;\n    for(int lvl=0;lvl<3;lvl++){//do a series of moves flipping players and keeping score\n      float s=doMove(p,id+i,lvl);\n      if(s==ILLEGAL){score=ILLEGAL;break;}else {\n        score+=s;\n        if(abs(s)==KING)break;//should have better end game now\n      }\n      p=-p;\n    }\n    //find worst (min) of next moves for 4th level (play as human)\n#ifdef FOURMOVES\n    if(abs(score)<KING){//we never made it 4 moves if score==illegal or king taken\n      float ws=-ILLEGAL;vec2 p1,p2;\n      for(float id=zero;id<MOVES;id+=one){\n        vec3 m=getM(id);\n        p1=getP(m.x);//player 1 hardcoded\n        if(p1.x>=zero){//piece is on board\n          p2=deltaMove(1.,p1,m.yz);//player 1 hardcoded\n          float cap=legalS(abs(pc2s(m.x)),1.,p1,p2);//cap will be negative\n          if(cap!=ILLEGAL && cap!=zero){cap=pc2s(cap);if(cap<ws)ws=cap;}\n        }\n      }\n      if(abs(ws)<31.)score+=ws;\n    }\n#endif\n    sVb(sc,i/4.,mod(i,4.)*6.,6.,score+32.);\n  }\n  return sc;\n}\nvec2 getMouseCell(float y){//find clicked on square  \n  float viewAng0=gb(y,0.,4.)*0.0625*6.283,viewAng1=0.1+gb(y,4.,4.)*0.0625;\n  vec2 uv=(iMouse.xy-0.5*iResolution.xy)/iResolution.x; \n  vec3 rd=normalize(vec3(uv,3.));\n  vec3 ro=vec3(sin(viewAng0)*cos(viewAng1),sin(viewAng1),cos(viewAng0)*cos(viewAng1))*33.;\n  vec3 fw=normalize(vec3(0.,-0.5,0.)-ro),rt=normalize(cross(fw,vec3(0.0,1.0,0.0))),up=cross(rt,fw);\n  rd=mat3(rt,up,fw)*rd;\n  float t=(-0.33-ro.y)/rd.y;\n  vec2 v=(ro.xz+rd.xz*t);  \n  if(max(abs(v.x),abs(v.y))>4.)return vec2(8.); \n  return floor(v+vec2(4.));\n}\nvoid mainImage(out vec4 O, vec2 U){\n  U=floor(U);Init();\n  O=get(U);//maintain pixels by default\n  if(same(U,STATEVEC)){//state vector rez.x,viewangles,frame,selections\n    if(O.x!=iResolution.x){O.x=iResolution.x;O.y=128.;O.z=zero;O.w=NOSEL;}\n    else{//game state loop\n      if(O.z==zero || O.z==two){//check for user's selected cells\n        if(iMouse.z>0.){//wait for mouse down\n          vec2 v=getMouseCell(O.y);\n          if(O.z==zero)O.w=NOSEL;//clear selection\n          else {//validate move\n            loadBoard();\n            vec2 p1=vec2(gb(O.w,0.,4.),gb(O.w,4.,4.));\n            float pc=getB(p1);if(pc<=0.){O.z=zero;O.w=NOSEL;return;}//clicked empty or black piece\n            float cap=legalC(abs(pc2s(pc)),1.,p1,v);\n            if(cap==ILLEGAL){O.z=zero;O.w=NOSEL;return;}\n          }\n          sb(O.w,O.z*4.,8.,v.x+v.y*16.);\n          if(v.x<8.)O.z+=one;\n        }else if(Key(KEY_DOWN))sb(O.y,4.,4.,clamp(gb(O.y,4.,4.)-one,0.,15.));\n        else if(Key(KEY_UP))sb(O.y,4.,4.,clamp(gb(O.y,4.,4.)+one,0.,15.));\n        else if(Key(KEY_LEFT))sb(O.y,0.,4.,mod(gb(O.y,0.,4.)-one,16.));//touchy :)\n        else if(Key(KEY_RIGHT))sb(O.y,0.,4.,mod(gb(O.y,0.,4.)+one,16.));\n      }else if(O.z==one || O.z==3.){//wait for mouse up\n        if(iMouse.z<=0.)O.z+=one;\n      }else if(O.z<ENDFRAME)O.z+=one;\n      else {//loop back to zero\n        O.z=zero;\n        vec3 m=getM(get(vec2(0,1)).y);loadPieces();\n        vec2 p1=getP(-m.x),p2=deltaMove(-1.,p1,m.yz);//player -1 hardcoded\n        O.w=p1.x+p1.y*16.+p2.x*256.+p2.y*4096.;//show to/from\n      }\n    }\n    return;//done with state\n  }\n  vec4 st=get(STATEVEC);\n  if(U.y==zero && U.x<7.){//board and pieces\n    if(iFrame==0){if(U.x<4.)O=gB(U.x);else O=gP(U.x-4.);}//save setup board and pieces\n    else if(st.z==4. || st.z==ENDFRAME){\n      loadBoard();loadPieces();//load the board and pieces to edit them\n      if(st.z<ENDFRAME){//the users move is packed in st.w\n        vec2 p1=vec2(gb(st.w,0.,4.),gb(st.w,4.,4.)),p2=vec2(gb(st.w,8.,4.),gb(st.w,12.,4.));\n        float pc=getB(p1),cap=getB(p2);\n        if(cap<0.)putP(cap,vec2(-2));//wipe piece from board\n        putB(0.,p1);putB(pc,p2);putP(pc,p2);\n      }else{//the best silicon move is in vec2(0,1).y\n        vec2 id=get(vec2(0,1)).xy;\n        float s=doMove(-1.,id.y,2);//do move #id 0-110\n        //if(s==ILLEGAL){}//debug\n      }\n      if(U.x<4.)O=gB(U.x);else O=gP(U.x-4.);//save board and pieces\n    }\n    return;//done with board and pieces\n  }else if(U.y*iResolution.x+U.x-7.>7.*MOVES*MOVES)return;//not used\n  if(st.z<5. || st.z>=ENDFRAME)return;//nothing to do\n  else if(st.z==5.)O=doMoves(-1.,U);//score the moves\n  else if(U.y>=1. && U.y<MOVES+one && U.x<MOVES){//best score box\n    float lvl=8.-st.z;//2,1,0\n    if(lvl<two && U.x>0.5)return;//just a column of pixels left\n    if(lvl<one && U.y>1.5)return;//just 1 pixel left to do the work\n    O=bestLvlScore(lvl==one?1.:-1.,U,lvl);//find best moves in 110x110 grid, row then column\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[787, 818, 835, 859, 904], [905, 905, 922, 922, 965], [965, 995, 1020, 1020, 1059], [1060, 1060, 1103, 1103, 1152], [1152, 1163, 1182, 1244, 1443], [1444, 1444, 1465, 1526, 1725], [1748, 1748, 1766, 1766, 3456], [3458, 3458, 3487, 3487, 3606], [3608, 3608, 3636, 3636, 3666], [3668, 3668, 3703, 3703, 4373], [4387, 4387, 4413, 4413, 4487], [4489, 4489, 4507, 4507, 4535], [4537, 4537, 4574, 4574, 4714], [4716, 4716, 4745, 4745, 5554], [5556, 5556, 5594, 5594, 6127]], "test": "untested"}
{"id": "wsjfzh", "name": "RayMarching - BasicExample", "author": "SimonParschat", "description": "Shader test: Implemented n_reflections based on object normal. Also, have Lightsource and shadows which are based on the distance to the object. A camera with basic functionality has also been implemented. Very inefficient..", "tags": ["raymarching"], "likes": 1, "viewed": 297, "published": 3, "date": "1589582677", "time_retrieved": "2024-07-30T21:06:35.639920", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST  1000.\n#define SURF_DIST .01\n#define N_SPHERES 2\n#define N_PLANES 1\n#define N_BOXES 0\n#define N_REFLECTIONS 0\n#define SOURCE_TO_CAM_DISTANCE 10.\n#define M_PI 3.1415926535897932384626433832795\n\nstruct Sphere  {    \n    vec3  spherePosition;\n    vec3  sphereColor;\n    float sphereRadius;\n};\n    \nstruct Plane {\n    vec3  planeColor;\n    float planeY;\n};\n\nstruct Box {\n    vec3 boxPosition;\n    vec3 boxSize;\n    vec3 boxColor;\n};\n\nfloat GetSphereDistance(in Sphere spheres[N_SPHERES], in vec3 p, out int sphereID) {\n    float minLen = 10000.;\n    sphereID = 0;\n    for (int i = 0; i < N_SPHERES; i++) {\n        float sLen = length(p - spheres[i].spherePosition) - spheres[i].sphereRadius;\n        minLen = min(minLen, sLen);\n        sphereID = (minLen == sLen) ? i : sphereID;\n    }\n    return minLen;\n}\n\nfloat GetPlaneDistance(in Plane planes[N_PLANES], in vec3 p, out int planeID) {\n    float minLen = 10000.;\n    planeID = 0;\n    for (int i = 0; i < N_PLANES; i++) {\n        float pLen = abs(p.y - planes[i].planeY);\n        minLen     = min(minLen, pLen);\n        planeID    = (minLen == pLen) ? i : planeID;\n    }\n    return minLen;\n}\n\nfloat GetBoxDistance(in Box box, in vec3 p) {\n    return length(max(abs(p) - box.boxSize, 0.));\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n   \n    return mat2(c, -s, s, c);\n}\n\nvec3 RotateAboutNormal(in vec3 rayNorm, in vec3 objNorm) {\n    float angle     =  M_PI;\n    rayNorm         = -rayNorm;\n    vec3   paraComp = (dot(rayNorm,objNorm) / dot(objNorm,objNorm))*objNorm;\n    vec3   perpComp =  rayNorm - paraComp;\n    vec3   w        =  cross(objNorm, perpComp);\n    float  x1       =  cos(angle) / length(perpComp);\n    float  x2       =  sin(angle) / length(w);\n    \n    vec3 perpObjAng =  length(perpComp) * (x1 * perpComp + x2 * w);\n    vec3 rotVec     =  perpObjAng + paraComp;\n    return rotVec;\n}\n\nfloat GetDist(in vec3 p, out vec3 objColor) {\n    int sphereID = 0;\n    int planeID = 0;\n    \n    Sphere sphere[N_SPHERES] = Sphere[N_SPHERES](\n        \tSphere(vec3( -.5,  1.,  0.),  vec3(0.5,0.8,0.5),  .4),\n    \t\tSphere(vec3(  .5,  1.,  0.),  vec3(0.5,0.5,0.8),    .4) );\n        \n    Plane  plane[N_PLANES] = Plane[N_PLANES](\n        \tPlane(vec3(1.,1.,1.), \t\t\t 0.  ));\n    //Box    box \t = Box(   vec3(-5., 2., 5.), vec3(.5, .5, .5), vec3(1.,.8,.8) );\n    \n    float SphereDist  = GetSphereDistance(sphere, p, sphereID);\n    float PlaneDist   = GetPlaneDistance(plane, p, planeID); \n    float d = min(SphereDist, PlaneDist);\n    \n    if (d == SphereDist)     { objColor = sphere[sphereID].sphereColor; }\n    else if (d == PlaneDist) { objColor = plane[planeID].planeColor; }\n    //else if (d == BoxDistance) { objColor = box.boxColor; }\n        \n    return d;\n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, out vec3 objCol) {\n\tfloat pointPos = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * pointPos;\n        float dS = GetDist(p, objCol);\n        pointPos += dS;\n        \n        if ( pointPos > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return pointPos;\n}\n\nvec3 GetNormal(in vec3 p) {\n    vec3 cOlDummy = vec3(0);\n    float d = GetDist(p, cOlDummy);\n    vec2  e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy, cOlDummy),\n        GetDist(p - e.yxy, cOlDummy),\n        GetDist(p - e.yyx, cOlDummy));\n    return normalize(n);\n}\n\nfloat GetLight(in vec3 p) {\n    vec3 cOlDummy = vec3(0.);\n    vec3 lightPosition = vec3(0,5,0);\n    lightPosition.xz += vec2(sin(iTime * .5) * 10.,cos(iTime * .5) * 10.);\n    \n    vec3 l = normalize(lightPosition - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n*SURF_DIST*1.5, l, cOlDummy);\n    \n    if (d < length(lightPosition - p)) dif *= 0.3* clamp(d, 0.,1.);\n\treturn dif;\n}\n\nvec3 RayDirection(in vec3 pixelPos, in vec3 intermediatePlane) {    \n    vec3 rDir = normalize(pixelPos - intermediatePlane);\n    return rDir;\n}\n\nfloat RayReflection(in vec3 p, in vec3 rayNorm, out vec3 refCol, in int N){\n    float d = 0.;\n    for (int i = 0; i < N; i++) {\n        vec3 objNormal = GetNormal(p);\n        vec3 refNormal = RotateAboutNormal(rayNorm, objNormal);\n       \tvec3 coL = vec3(0.);    \n       \t\n        d = RayMarch(p + objNormal*SURF_DIST*1.6, refNormal, coL);\n        refCol += (coL * 1./ float(N))*.9;\n        p += refNormal*d;\n    }\n        \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 colorOfPixel = vec3(0.);\n    \n    vec3 cameraPosition = vec3(0.,5.,-20.);\n    vec3 viewNorm = normalize(vec3(0.,1.,0.) - cameraPosition);\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 camRightNorm = normalize(cross(vec3(0.,-1.,0.), viewNorm));\n    vec3 camUpNorm = normalize(cross(camRightNorm, viewNorm));\n\n    vec3 ro = (-camRightNorm*uv.x)+(camUpNorm*uv.y) + cameraPosition;\n    vec3 ri = (-camRightNorm*uv.x * 0.5) + (camUpNorm*uv.y * 0.5) + cameraPosition + viewNorm * (-SOURCE_TO_CAM_DISTANCE*.5);\n    vec3 rd = RayDirection(ro, ri);\n    \n    float d = RayMarch(ro, rd, colorOfPixel);\n    vec3 p = ro + rd*d;\n    vec3 dumCol = colorOfPixel;\n    if (N_REFLECTIONS != 0) {\n    \tfloat dRef = RayReflection(p, rd, dumCol, N_REFLECTIONS);\n    \tcolorOfPixel = (colorOfPixel + dumCol) * (1./float(N_REFLECTIONS)) ;\n    }\n        \n\tfloat dif = GetLight(p);\n    \n    fragColor = vec4(colorOfPixel,1.0) * dif;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[469, 469, 553, 553, 841], [843, 843, 922, 922, 1177], [1179, 1179, 1224, 1224, 1276], [1278, 1278, 1297, 1297, 1377], [1379, 1379, 1437, 1437, 1908], [1910, 1910, 1955, 1955, 2773], [2775, 2775, 2832, 2832, 3100], [3102, 3102, 3129, 3129, 3391], [3393, 3393, 3420, 3420, 3831], [3833, 3833, 3897, 3897, 3977], [3979, 3979, 4054, 4054, 4418], [4420, 4420, 4477, 4477, 5422]], "test": "untested"}
{"id": "WsSBRD", "name": "Bubble Machine", "author": "blackle", "description": "playing with domain repetition where some domains are empty", "tags": ["bep"], "likes": 15, "viewed": 532, "published": 3, "date": "1589566731", "time_retrieved": "2024-07-30T21:06:36.386923", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//return the SDF for a sphere, or the SDF for an empty region surrounded by spheres\nfloat gated_sphere(vec3 p, float scale, bool gate) {\n    if (!gate) {\n        p = abs(p);\n        if(p.x < p.y) p.xy = p.yx;\n        if(p.y < p.z) p.yz = p.zy;\n        if(p.x < p.y) p.xy = p.yx;\n        p.x -= scale;\n    }\n    return length(p);\n}\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat component(vec3 p) {\n    float scale = 3.;\n    vec3 id = floor(p/scale);\n    p = (fract(p/scale)-0.5)*scale;\n    //make 99.5% of domains be empty\n    bool gate = hash(hash(id.x, id.y), id.z)*.5+.5 > 0.995;\n    return gated_sphere(p, scale, gate)-1.;\n}\n\nfloat scene(vec3 p) {\n    float dist = component(p);\n    float distortion = sin(p.x*5.+iTime)*.01 + sin(p.y*6.+iTime*2.)*.01 + sin(p.z*4.+iTime*3.)*.01;\n    p.z-=iTime*2.;\n    dist = min(dist, component(p+10.));\n    return dist + distortion;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nfloat skybox(vec3 p) {\n    return texture(iChannel0, p.xzy).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n\tvec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-5,0,0) + cam;\n\n    float yrot = -sin(iTime/8.);\n    float zrot = cos(iTime/8.);\n    if (iMouse.z > 0.) {\n        yrot = clamp(-4.*mouse.y, -3.14/2., 3.14/2.);\n        zrot =  4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n\t\n    init.z -= iTime;\n    vec3 p = init;\n    int hits = 0;\n    vec3 points[10];\n    for (int i = 0; i < 200; i++) {\n        float dist = scene(p);\n        p+=cam*dist;\n        if (dist*dist < 1e-6) {\n            if (hits >= 10) break;\n            points[hits] = p;\n            hits += 1;\n            p += cam*2.5;\n        }\n        if (distance(p,init) > 100.) break;\n    }\n    vec3 col = vec3(0.);\n    float atten = 1.;\n    for (int i = 0; i < hits; i++) {\n        p = points[i];\n    \tvec3 n = norm(p);\n    \tvec3 r = reflect(cam, n);\n    \tfloat fres = 1.-abs(dot(cam,n))*.98;\n        float dist = distance(p,init);\n        float fog = smoothstep(100.,80.,dist);\n        //fake iridescence\n    \tvec3 col_front = vec3(sin(p*7.+iTime)*0.3+0.7)*pow(skybox(r),3.);\n    \tvec3 col_back = vec3(sin(p*5.+iTime)*0.3+0.7)*pow(skybox(reflect(n,r)),3.);\n        col += (col_front + col_back)*atten*smoothstep(0.05,0.05+dist*0.02,abs(dot(cam,n)))*fog;\n        atten*=mix(1., .9, fog);\n    }\n    fragColor.xyz = sqrt(col*.25) + skybox(cam)*atten;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBRD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 278, 330, 330, 524], [581, 581, 611, 611, 691], [693, 693, 718, 718, 949], [951, 951, 972, 972, 1194], [1196, 1196, 1215, 1215, 1330], [1332, 1332, 1370, 1370, 1436], [1438, 1438, 1476, 1476, 1508], [1510, 1510, 1532, 1532, 1574], [1576, 1576, 1633, 1633, 3120]], "test": "untested"}
{"id": "WdSfzD", "name": "Underwater Boids", "author": "michael0884", "description": "Boids algorithm in 3D (kinda). Voronoi particle tracking 3D.\nif you have the plugin:\nuse acceleration 4x", "tags": ["voronoi", "simulation", "interactive", "fluid", "particles", "sph"], "likes": 86, "viewed": 3033, "published": 3, "date": "1589564080", "time_retrieved": "2024-07-30T21:06:37.468032", "image_code": "// Fork of \"Super SPH \" by michael0884. https://shadertoy.com/view/tdXBRf\n// 2020-05-09 15:47:15\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale+2.).rgb;\n    \n    return bloom;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n     vec3 bloomSum = vec3(0.);\n    //bloomSum += bloom(.4 * R.y, pos) * .07;\n    //bloomSum += bloom(.2 * R.y, pos) * .07;\n    \n    fragColor.xyz = texel(ch2, pi).xyz + 1.*bloomSum;\n    fragColor.xyz = HDRmapping(fragColor.xyz, 3.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22728, "src": "https://soundcloud.com/grey-houston/gray-houston-atlantic-drift-ocean-waves-whales-with-relaxing-alpha-waves", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define dt 3.\n#define loop(i,x) for(int i = min(0, iFrame); i < x; i++)\n\n//rendering scale\n#define SC 3.\n\n#define smoothR 2.5\n#define density 0.01\n\n\n#define fog_depth 0.003\n//from 0 to 1\n#define god_ray_step 0.15\n#define wcol vec3(33,98,227)/255.\n\n//render range\n#define range 500.\n#define FOV 2.\n#define camd 300.\n\n//sim stuff\nstruct obj\n{\n    int id; //ID\n    vec3 X; //position\n    float Rho; //neighbor density\n    vec3 V; //velocity\n    float Pressure; //pressure\n    vec3 Color;\n    float Scale;\n};\n    \nfloat Force(float d)\n{\n    return 0.2*exp(-0.05*d)-2.*exp(-0.5*d);\n}\n\nstruct mat\n{\n    vec3 albedo;\n    vec3 emiss;\n    float rough;\n    float metal;\n};\n\n//60% of the buffer used for particles\n#define P 0.6\n#define SN ivec2(6, 2)\n\nivec2 N; //buffer size\nivec2 sN; //buffer single element size\nint TN; //buffer length\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(2*(i/4))) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sqr(float x)\n{\nreturn x*x + 1e-2;\n}\n\n//hash funcs\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = round(dot(F, uv + c)); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\n\nmat4 getPerspective(float fov, float aspect, float n, float f)\n{   \n    float scale = tan(fov * PI / 360.) * n; \n    float r = aspect * scale, l = -r; \n    float t = scale, b = -t; \n\n\t\n    return mat4(2. * n / (r - l), 0, 0, 0,\n                0, 2. * n / (t - b), 0, 0,\n                (r + l) / (r - l), (t + b) / (t - b), -(f + n) / (f - n), -1,\n                0, 0, -2. * f * n / (f - n), 0);\n}\n\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1,     0,        0,\n                         0,  cos(a.y), sin(a.y), \n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x),  sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0,            0,    1); \n   return phi_rot*theta_rot;\n}\n\n\nfloat NGGX(vec3 n, vec3 h, float a)\n{\n    float a2 = sqr(a);\n    return a2/(PI*sqr( sqr( max(dot(n,h),0.) )*(a2-1.) + 1.));\n}\n\nfloat GGX(vec3 n, vec3 o, float a)\n{\n    float ndoto = max(dot(n,o),0.);\n    return ndoto/mix(1., ndoto, sqr(a+1.)*0.125);\n}\n\nfloat GS(vec3 n, vec3 i, vec3 o, float a)\n{\n    return GGX(n,i,a)*GGX(n,o,a);\n}\n\nvec3 IR(float D, float k0, vec3 k1)\n{\n    //interference effect here ->\n    return (0.25/D + k0*( 1. - cos(2.*PI*pow(vec3(D), -k1)) )) ;\n}\n\nvec3 BRDF(vec3 i, vec3 o, vec3 n, mat m)\n{\n    vec3 h = normalize(i + o);\n    vec3 F0 = mix(vec3(0.04), m.albedo, m.metal);\n    vec3 FS = F0 + (1.0 - F0) * pow(1.0 - max(dot(h, i), 0.0), 5.0);\n    vec3 DFG = NGGX(n,h,m.rough)*GS(n,i,o,m.rough)*FS;\n    float denom = max(dot(n, i), 0.001) * max(dot(n, o), 0.001);\n    return (m.albedo*(1.-FS)/PI +\n            DFG*IR(denom, 0.1, vec3(1.,1.1,1.2)))*max(0., dot(n,o));\n}\n\n\n", "buffer_a_code": "//L1 particle buffer - simulation\n//L2 directional neighbor graph 4x - sort\n\nint ID;\nobj O; //this object\n\n//sort arrays\nvec4 lnk0, lnk1;\nvec4 d0, d1;\n\n//L3\nvec4 EA[SN.x]; //element array\n\nvoid insertion_sort(float t, int id);\nobj getObj(int id); vec4 saveObj(int i);\nbool iscoincidenceEA(int id);\nvoid sort0(int idtemp, int D); void sort1(int idtemp, int D);\n\nfloat Kernel(float d, float h)\n{\n    return exp(-sqr(d/h))/(PI*sqr(h));\n}\n\nfloat KernelGrad(float d, float h)\n{\n    return 2.*d*Kernel(d,h)/sqr(h);\n}\n\nvec2 borderF(vec2 p)\n{\n    \n    float d = min(min(p.x,p.y),min(R.x-p.x,R.y-p.y));\n    return exp(-max(d,0.)*max(d,0.))*((d==p.x)?vec2(1,0):(\n    \t\t(d==p.y)?vec2(0,1):(\n            (d==R.x-p.x)?vec2(-1,0):vec2(0,-1))));\n}\n\nvoid UpdateParticle()\n{\n    vec3 g = -5e-9*O.X*length(O.X); \n    vec3 F = g; \n    \n    float scale = 0.14*pow(density,-0.333); //radius of smoothing\n    float Rho = Kernel(0., scale);\n    float avgP = 0.;\n\tvec3  avgC = vec3(O.Color);\n\n    loop(j,6)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,3)\n        {\n            if(nb[i] < 0. || nb[i] > float(TN)) continue;\n            obj nbO = getObj(int(nb[i]));\n\n            float d = distance(O.X, nbO.X);\n            vec3 dv = (nbO.V - O.V); //delta velocity\n            vec3 dx = (nbO.X - O.X); //delta position \n            vec3 ndir = dx/(d+1e-3); //neighbor direction\n            //SPH smoothing kernel\n            float K = Kernel(d, scale);\n\n            vec3 pressure = -0.5*( nbO.Pressure/sqr(nbO.Rho) + \n                                     O.Pressure/sqr(O.Rho) )*ndir*K;//pressure gradient\n            vec3 viscosity = 0.6*ndir*dot(dv,ndir)/(d+1.);\n           \n            Rho += K;\n            avgC += nbO.Color;\n            avgP += nbO.Pressure*K;\n\n            F += pressure + viscosity;\n        }\n    }\n\n    O.Rho = Rho;\n    \n    //O.Scale = scale; //average distance\n    \n    float r = 1.;\n    float D = 1.;\n    float waterP = 0.02*(pow(abs(O.Rho/density), r) - D);\n    O.Pressure = min(waterP,1.);\n\n    O.V += F*dt;\n    O.V = 0.15*normalize(O.V);\n    O.X += O.V*dt; //advect\n\n    //color diffusion\n\n    //O.Color = ;\n}\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    //4 pix per layer, 3 layers\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    int S = 3; //log2(sN.x)\n    \n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    O = getObj(ID);\n    d0 = vec4(1e6); d1 = vec4(1e6);\n    lnk0 = vec4(-1); lnk1 = vec4(-1);\n    \n    switch(sid.z)\n    {\n    case 0: //particle\n        if(sid.z >= 3) discard;\n        float sk = 0.;\n        \n        UpdateParticle();\n        \n        if(iFrame<10 || O.Scale != 5.)\n        {\n            O.X = 300.*(hash32(pos) - 0.5);\n\t\t\tO.V = 0.1*(hash32(3.14159*pos) - 0.5);\n            O.Color = hash32(3.14159*pos);\n            O.Pressure = 0.;\n            O.Scale = 5.;\n            O.Rho = 5.;\n        }\n\n        Q = saveObj(sid.y);\n        return;\n        \n    case 1: //dir graph\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        loop(i,4)\n        {\n            sort0(int(nb0[i]), sid.y);  //sort this\n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = texel(ch0, i2xy(ivec3(nb0[i], (iFrame+ID)%4, 1)));\n            loop(j,2)\n            {\n                sort0(int(nb1[j]), sid.y);  \n            }\n        }\n        \n        //random sorts\n        loop(i,4) sort0(int(float(TN)*hash13(vec3(iFrame, ID, i))), sid.y);\n        \n        Q = lnk0;\n        return;\n    }\n     \n}\n\nvec4 saveObj(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(O.X, O.Rho);\n    case 1:\n        return vec4(O.V, O.Pressure);\n    case 2:\n        return vec4(O.Color, O.Scale);\n    }\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.Rho = a.w;\n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.V = a.xyz; o.Pressure = a.w; \n    a = texel(ch0, i2xy(ivec3(id, 2, 0))); \n    o.Color = a.xyz; o.Scale = a.w;\n \n    o.id = id;\n    return o;\n}\n\nvoid insertion_sort(float t, int id)\n{\n\tif(d0.x > t)\n    {\n        d0 = vec4(t, d0.xyz);\n        lnk0 = vec4(id, lnk0.xyz);\n    }else if(d0.y > t && d0.x < t)\n    {\n        d0.yzw = vec3(t, d0.yz);\n        lnk0.yzw = vec3(id, lnk0.yz);\n    }else if(d0.z > t&& d0.y < t)\n    {\n        d0.zw = vec2(t, d0.z);\n        lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t && d0.z < t)\n    {\n        d0.w = t;\n        lnk0.w = float(id);\n    }\n}\n\nbool iscoincidence(int id)\n{\n    return (id < 0) || \n      \t   (id == ID) ||\n           any(equal(lnk0,vec4(id)));\n}\n\nvoid sort0(int idtemp, int D) //sort closest objects in sN.x directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec3 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xyz; \n   \n    vec3 dx = nbX - O.X;\n    int dir = int(inverseSF(dx, float(sN.x)).x);\n    \n    if(dir != D) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//voronoi 3d particle tracking + graph augmented\n\nmat4 rotat; //rotation matrix\nmat4 model; //model matrix\nmat4 imat;\n\n\nvec3 ray; vec3 cpos;\nfloat d;\nvec3 ip;\nint id;\nvec2 p; //screen coord\nvec2 angles;\n\nfloat sphere_intersection(vec3 r, vec3 p, vec4 sphere)\n{\n\tp = p - sphere.xyz;\n\tif(p == vec3(0)) return sphere.w;\n\t\n\tfloat b = dot(p, r);\n\tfloat c = sphere.w*sphere.w - dot(p,p);\n\tfloat d = b*b + c;\n\t\n\tif((d <= 0.)) //if no intersection\n\t{\n\t\treturn -length(cross(r, p)); //return closest dist\n\t}\n\telse\n\t{\n\t\treturn -sqrt(d) - b; //use closest solution in the direction of the ray\n\t}\n}\n\nvec4 ppos(int id)\n{\n\treturn vec4(texel(ch0, i2xy(ivec3(id, 0, 0))).xyz,1.);\n}\n\nvec3 getRay(vec2 pos)\n{\n    mat3 rmat = getRot(angles);\n    vec2 uv = FOV*(pos - R*0.5)/R.x;\n    return normalize(rmat[0]*uv.x + rmat[1]*uv.y + rmat[2]);\n}\n\nfloat zrange(float z)\n{\n    return clamp(z/range,0.,1.);\n}\n\nvec4 point_distance(int id, float r)\n{\n    vec4 X = ppos(id);\n    float cd = sphere_intersection(ray, cpos, vec4(X.xyz,r));\n    if(cd > 0.)\n    {\n        return vec4(cpos + cd*ray, zrange(cd));\n    }\n    else\n    {\n        return vec4(cpos + 1e8*ray, 1.+abs(cd));\n    }\n}\n\nvoid sort(int utemp)\n{\n    if(utemp < 0) return; \n   \tvec4 dtemp = point_distance(utemp, 1.5);\n    if(dtemp.w < d) //sorting\n    {\n        d = dtemp.w;\n        ip = dtemp.xyz;\n        id = utemp;\n    }\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    d = 1e10;\n    id = 1;\n    p = pos;\n    ip = vec3(1e10);\n    ivec2 pi = ivec2(floor(pos));\n    \n   \n    //set up camera \n    angles = (iMouse.z>0.)?(iMouse.xy/R)*vec2(2.*PI, PI):vec2(0.15*iTime, PI*0.2+0.5*sin(0.15*iTime));\n    ray = getRay(pos); \n    cpos = -camd*getRay(R*0.5);\n    \n    /// sort pixels\n    sort(int(texel(ch1, pi).x));\n    \n    int ID = id;\n    loop(j,12)\n    {\n        \n        int nbid = int(texel(ch1, pi+cross_distribution(j)).x);\n        sort(nbid);\n    }\n    \n    loop(j,int(sN.x))\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,4)\n    \t{ \n            sort(int(nb[i]));  //sort this\n        }\n    }\n    \n    loop(i,4) //random sort\n    {\n        sort(int(float(TN)*hash13(vec3(iFrame, pi.x, pi.y*i))));\n    }\n    ///\n    \n    \n    //save\n   \tQ = vec4(id, ip);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "///SHADING\n\nvec3 ray; vec3 cpos; vec2 angles;\nmat3 rmat;\nvec2 p;\nvec3 getRay(vec2 pos)\n{\n    rmat = getRot(angles);\n    vec2 uv = FOV*(pos - R*0.5)/R.x;\n    return normalize(rmat[0]*uv.x + rmat[1]*uv.y + rmat[2]);\n}\n\n\n// iq's smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.Rho = a.w;\n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.V = a.xyz; o.Pressure = a.w; \n    a = texel(ch0, i2xy(ivec3(id, 2, 0))); \n    o.Color = a.xyz; o.Scale = a.w;\n \n    o.id = id;\n    return o;\n}\n\nfloat lstr(vec3 p)\n{\n    return 0.5*(tanh(0.001*p.z + 0.4) + 1.);\n}\n\nvec3 projection(vec3 p)\n{\n    vec3 dp = normalize(p - cpos);\n    float zp = FOV*dot(dp, rmat[2]);\n    vec2 prj = zp*R.x*vec2(dot(dp, rmat[0]), dot(dp, rmat[1]))/(0.001+zp*zp);\n    return vec3(prj + 0.5*R, sign(zp)); \n}\n\nbool inbouds(vec2 p)\n{\n    return p.x > 0. && p.y > 0. && R.x - p.x > 0. && R.y - p.y > 0.;\n}\n\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\n#define light vec3(0,0,1)\n#define sm 5.\n\n//ray screen bound intersection\nfloat screen_max( in vec2 ro, in vec2 rd ) \n{   \n    vec2 m = 1.0/rd;\n    vec2 n = m*ro;\n    vec2 t = vec2(max(- n.x, R.x*m.x - n.x),max(- n.y, R.y*m.y - n.y));\n\tfloat tN = min(t.x, t.y);\n\treturn tN;\n}\n\nfloat god_ray(float d)\n{\n    //ligth position in camera plane\n    vec3 lp = projection(light*10000.);\n    vec2 r = lp.z*normalize(lp.xy - p + vec2(0.001)); \n    float xl = min(screen_max(p, r),distance(lp.xy, p));\n    float dx = 1. + (1. + xl*god_ray_step)*InterleavedGradientNoise(p, iFrame);\n    float occ = 0.; float esum = 0.001;\n    for(float x = 0.; x < xl; x += dx)\n    {\n        float cd = length(cpos - texel(ch1, ivec2(p + r*x)).yzw);\n        occ += mix(1.,(0.5*tanh(0.2*(cd/d - 1.)) + 0.5), exp(-0.5*fog_depth*cd))*dx;\n        esum += dx;\n    }\n    occ /= esum;\n    return mix(1., occ*occ, pow(abs(0.5*(ray.z + 1.)),0.5));\n}\n\nvec4 water_fog(float d, vec3 dir)\n{\n    float alpha = 1. - exp(-fog_depth*d);\n    float b = (pow(abs(0.5*(dir.z + 1.)),14.) + \n               0.075*pow(abs(0.5*(dir.z + 1.2)),0.3));\n\treturn vec4(b*wcol, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    p = pos;\n    //setup camera\n    angles = (iMouse.z>0.)?(iMouse.xy/R)*vec2(2.*PI, PI):vec2(0.15*iTime, PI*0.2+0.5*sin(0.15*iTime));\n    cpos = -camd*getRay(R*0.5);\n    ray = getRay(pos); \n    \n    \n    vec4 A = texel(ch1, pi);\n    int ID = int(A.x); \n    vec3 ip = A.yzw; //intersection point\n\tobj o = getObj(ID);\n    mat pmat = mat(o.Color, vec3(0.), 0.25, 0.3);\n    \n    vec3 n = normalize(ip - o.X); //normal\n    vec3 r = reflect(ray, n);\n    float d = min(distance(ip, cpos), 1e6); \n    \n    vec3 col = vec3(0.);\n    float shadow = god_ray(d);\n    vec4 wfog = water_fog(d, ray);\n    if(d < 1e6)\n    {\n        float b = lstr(ip);\n        col += b*wcol*BRDF(-ray, light, n, pmat);//light\n        col += b*0.3*wcol*BRDF(-ray, n, n, pmat);//ambient\n    }\n    vec3 ncol = shadow*mix(col, wfog.xyz, wfog.w);\n    // Output to screen\n \tvec3 pcol = texel(ch2, pi).xyz;\n    fragColor = vec4(mix(pcol,ncol,0.9),1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 122, 122, 262], [264, 264, 309, 335, 449], [575, 575, 615, 615, 909], [912, 912, 963, 963, 1298]], "test": "untested"}
{"id": "WdBBzD", "name": "Continued Fraction Ford Circles", "author": "mla", "description": "A nice way of drawing Ford Circles. Mouse selects zoom point.", "tags": ["circles", "fraction", "ford", "continued"], "likes": 8, "viewed": 420, "published": 3, "date": "1589563811", "time_retrieved": "2024-07-30T21:06:38.238971", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Ford Circles\n// mla, 2020\n////////////////////////////////////////////////////////////////////////////////\n\nint ford(vec2 z) {\n  float x = z.x;\n  mat2 m = mat2(1);\n  for (int i = 0; i < 20; i++) {\n    m *= mat2(floor(x),1,1,0);\n    x = 1.0/fract(x);\n    float p = m[0].x, q = m[0].y;\n    float x1 = p/q;\n    float r = 1.0/(2.0*q*q);\n    if (z.y > 2.0*r) return -1;\n    if (distance(z,vec2(x1,r)) < r) return i;\n  }\n  return -1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec3 col = vec3(0);\n  int AA = 2;\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (fragCoord.xy+vec2(i,j)/float(AA))/iResolution.x;\n      float t = 0.5*sqrt(5.0)-0.5;\n      if (iMouse.x > 0.0) t = iMouse.x/iResolution.x;\n      z.x -= t;\n      z *= exp(-mod(0.5*iTime,19.0));\n      z.x += t;\n      int k = ford(z);\n      if (k >= 0) col += hsv2rgb(vec3(float(k)/6.0,0.8,1));\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "vec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 210, 210, 513], [515, 515, 571, 571, 1075]], "test": "untested"}
{"id": "WsSBzW", "name": "Downscale aliasing methods - for", "author": "alvarobyrne", "description": "test SF downscale", "tags": ["downscale"], "likes": 3, "viewed": 452, "published": 3, "date": "1589547702", "time_retrieved": "2024-07-30T21:06:39.097675", "image_code": "// Fork of \"Downscale aliasing methods\" by DarkZeros. https://shadertoy.com/view/3sSBzW\n// 2020-05-15 12:58:35\n\nvec3 getTexture(vec2 uv){\n\treturn texture(iChannel0, uv).rgb;\n}\n\nvec3 down_scaler(vec2 uv)\n{\n    vec2 origSize = iResolution.xy;\n    // Calculate the size of a texel in the original texture\n    vec2 origTexelOffset = vec2(1.0, 1.0) / origSize;\n\n    // Find out the coordinates for the nearest point in between pixels\n    vec2 texCoordsCentrePoint = round(uv*origSize)/origSize;\n\n    // Move our texture lookup coordinates one up and to the left\n    vec2 topLeftTexCoords = texCoordsCentrePoint - origTexelOffset;\n    \n    // Get all 4 centrepoints\n    vec3 topLeftColor = getTexture(topLeftTexCoords);\n    vec3 topRightColor = getTexture(topLeftTexCoords + (origTexelOffset*vec2(2.0, 0.0)));\n    vec3 botLeftColor = getTexture(topLeftTexCoords + (origTexelOffset*vec2(0.0, 2.0)));\n    vec3 botRightColor = getTexture(topLeftTexCoords + (origTexelOffset*vec2(2.0, 2.0)));\n\n    // Perform bilinear again\n    vec2 a = (uv - topLeftTexCoords) / (vec2(2.0, 2.0)*origTexelOffset);\n    vec3 topColor = mix(topLeftColor, topRightColor, a.x);\n    vec3 botColor = mix(botLeftColor, botRightColor, a.x);\n\n    return mix(topColor, botColor, a.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if (uv.y < 0.2)\n\t  fragColor = vec4(getTexture(uv),1.0);\n    else if (uv.y < 0.4)\n      fragColor = vec4(getTexture(round(uv*320.0)/320.0),1.0);\n    else if (uv.y < 0.6)\n      fragColor = vec4(getTexture(round(uv*160.0)/160.0),1.0);\n    else if (uv.y < 0.8)\n      fragColor = vec4(getTexture(round(uv*80.0)/80.0),1.0);\n    else\n      fragColor = vec4(down_scaler((uv*80.0)/80.0),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(vec3((1.0+sin(uv.x*uv.x*640.0))/2.0),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 137, 137, 175], [177, 177, 204, 204, 1248], [1250, 1250, 1307, 1307, 1740]], "test": "untested"}
{"id": "WsBfRW", "name": "when you squares", "author": "ReeceGames", "description": "when you SQUARES", "tags": ["trippy", "squares"], "likes": 1, "viewed": 321, "published": 3, "date": "1589546883", "time_retrieved": "2024-07-30T21:06:39.926460", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    \n    vec2 sq = vec2(uv.x/(iResolution.y/iResolution.x),uv.y);\n    \n    float dist = distance(sq,vec2(cos(iTime),sin(iTime))/3.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(sin((sq.x+sq.y*max(sin(iTime),cos(iTime*1.2)))*32.0),cos((sin(iTime*1.2)+sq.y+sin(iTime+sq.x*2.0))*8.0),sin(dist*31.0-iTime*2.0));\n\t\n    if (col.r>0.8&&col.g>0.8)\n    {\n    vec3 col2 = vec3(col.r*0.,col.g*0.2,1.0);\n    col = mix(col,col2 - col.b,mix((col.g-0.8)*3.0,(col.r-0.8)*3.0,0.5));\n    }\n    col = mix(-col,col,sin(iTime)/2.0+0.5)+vec3(0.2,0.2,0.5);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 756]], "test": "untested"}
{"id": "wdjfzh", "name": "Frosted Glass / Noise Blur", "author": "3ck5t3r", "description": "Variation of frosted glass effect.\n\nUPD1: slightly reworked", "tags": ["noise", "blur", "glass", "frosted"], "likes": 2, "viewed": 682, "published": 3, "date": "1589520670", "time_retrieved": "2024-07-30T21:06:40.801120", "image_code": "//float centStepRnd(vec2 st, float steps)\n//{\n//    return floor(random(st) * steps);\n//}\n\n//float normStepRnd(vec2 st, float steps)\n//{\n//    return floor(random(st) * steps) / (steps - 1.0);\n//}\n\n//float random (vec2 st)\n//{\n//    return fract(sin(dot(st.xy,\n//                         vec2(12.9898,78.233)))*\n//        43758.5453123);\n//}\n\nfloat difRandom (vec2 st, float seedShift)\n{\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        (43758.5453123 + seedShift * 30.0));\n}\n\nfloat rndCentered(vec2 st, float steps, float seedShift)\n{\n    return floor(difRandom(st, seedShift) * steps) * 2.0\n        - steps / 2.0;\n}\n\nvec2 rndField(vec2 st, float steps, float seedShift)\n{\n    return vec2(rndCentered(st, steps, seedShift), \n                rndCentered(st, steps, seedShift - 500.0));\n}\n\nvec2 shiftSt(vec2 fragCoord, vec2 shift)\n{\n    return (fragCoord.xy + shift) / iResolution.xy;\n}\n\nvec4 rndNoise (vec2 fragCoord, vec2 st,\n                     float steps, float accuracy)\n{\n    vec4 clr;\n    vec4 color;\n\n    for (float i; i < accuracy; i++)\n    {\n        clr = texture(iChannel0, shiftSt(\n            fragCoord, rndField(st, steps, i)));\n        color += clr;\n    }\n    \n\treturn color / accuracy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float accuracy = 30.0;\n\tfloat steps = 50.0;\n    vec2 st = fragCoord.xy / iResolution.xy; \n\tvec4 color = texture(iChannel0, st);\n    float lightness = (color.x + color.y + color.z) / 3.0;\n    float difference = abs(lightness - 0.7);\n\tvec4 lightedNoise = (rndNoise(fragCoord, st, steps, accuracy) + vec4(1.0, 1.0, 1.0, 9.0)) / 2.0;\n    fragColor = color;\n//\tfragColor = color * 0.2 + rndNoise(fragCoord, st, steps, accuracy) * 0.8;\n    fragColor = color * (1.0 - difference) + lightedNoise * difference;\n}\n\n\n\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 387, 387, 515], [517, 517, 575, 575, 657], [659, 659, 713, 713, 827], [829, 829, 871, 871, 925], [927, 927, 1018, 1018, 1244], [1246, 1246, 1303, 1303, 1811]], "test": "untested"}
{"id": "tsjfRh", "name": "Blue Noise RT Shadows TAA: Spot", "author": "demofox", "description": "Showing blue noise being used for soft shadows. Drag mouse to move camera.\nLeft = white noise, Right = blue noise\nTop = Raw, Bottom = TAA with alpha 0.1, 3x3 neighborhood color clamp, halton sub pixel jitter.", "tags": ["arealight", "bluenoise", "stochastic"], "likes": 26, "viewed": 1639, "published": 3, "date": "1589514565", "time_retrieved": "2024-07-30T21:06:41.861286", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pixelColor = texture(iChannel0, uv).rgb;\n\n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // make a dividing line between the panels\n    vec2 dist2d = abs(fragCoord - iResolution.xy * 0.5f);\n    float dist = min(dist2d.x, dist2d.y);\n    dist = smoothstep(2.0f, 1.0f, dist);\n    pixelColor = mix(pixelColor, vec3(1.0f, 1.0f, 0.0f), dist);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);        \n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// white noise, from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// analytically mipmapped checkerboard pattern from inigo quilez\n// https://iquilezles.org/articles/morecheckerfiltering\nvec2 p( in vec2 x )\n{\n    vec2 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\n// return a filtered checkers pattern\nfloat checkersGradTriangle( in vec2 uv )\n{\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (p(uv+w)-2.0*p(uv)+p(uv-w))/(w*w); // analytical integral (triangle filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;    \n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n};\n    \nbool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }\n    \n    return false;\n}\n    \nbool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > 0.0f && dist < info.dist)\n        {\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.diffuse = diffuse;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool RayVsQuad(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 diffuse, bool doubleSided)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (doubleSided && dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }    \n    \n    return false;\n}\n\nSRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir, bool shadowRay)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_rayMaxDist;\n\n    // the floor\n    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))\n    {\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        vec2 uv = hitPos.xz / 100.0f;\n        float shade = mix(0.8f, 0.4f, checkersGradTriangle(uv));\n        hitInfo.diffuse = vec3(shade, shade, shade);\n    }\n    \n    // some floating spheres to cast shadows\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 10.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 20.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 50.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f));\n    \n    // the light\n    if(!shadowRay)\n    {\n\t\tif(RayVsSphere(rayPos, rayDir, hitInfo, vec4(c_lightPos, c_lightRadius), c_lightColor))\n        {\n            vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n            vec3 toLight = (c_lightPos - hitPos);\n            vec3 lightDir = normalize(toLight);\n    \t\tfloat angleAtten = dot(lightDir, -c_lightDir);\n    \t\tangleAtten = smoothstep(c_cosThetaOuter, c_cosThetaInner, angleAtten);\n            hitInfo.diffuse *= angleAtten;\n        }\n    }\n    \n    return hitInfo;\n}\n\nvec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance, int panel, in vec2 pixelPos)\n{\n    // trace primary ray\n\tSRayHitInfo hitInfo = RayVsScene(rayPos, rayDir, false);\n    \n    // set the hitDistance out parameter\n    hitDistance = hitInfo.dist;\n    \n    if (hitInfo.dist == c_rayMaxDist)\n        return texture(iChannel0, rayDir).rgb;\n    \n    // calculate where the pixel is in world space\n\tvec3 hitPos = rayPos + rayDir * hitInfo.dist;\n    hitPos += hitInfo.normal * c_hitNormalNudge;\n    \n    int frame = 0;\n    #if ANIMATE_NOISE\n    \tframe = iFrame % 64;\n    #endif\n    \n    // use the screen space blue noise texture and golden ratio * frame number to\n    // get a \"random number\" to convert to an angle for how much to rotate\n    // the blue noise sample positions for this pixel\n    float blueNoise = texture(iChannel1, pixelPos / 1024.0f).r;\n    blueNoise = fract(blueNoise + c_goldenRatioConjugate * float(frame));\n    float theta = blueNoise * 2.0f * c_pi;\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n        \n    // shoot some shadow rays\n    vec3 toLight = (c_lightPos - hitPos);\n    vec3 lightDir = normalize(toLight);\n    float lightDistance = length(toLight);\n    float lightRadius = c_lightRadius / lightDistance;\n    float shadowTerm = 0.0f;\n    \n    float angleAtten = dot(lightDir, -c_lightDir);\n    \n    angleAtten = smoothstep(c_cosThetaOuter, c_cosThetaInner, angleAtten);\n    \n    vec3 lightTangent = normalize(cross(lightDir, vec3(0.0f, 1.0f, 0.0f)));\n    vec3 lightBitangent = normalize(cross(lightTangent, lightDir));\n    for (int shadowRayIndex = 0; shadowRayIndex < c_numShadowRays; ++shadowRayIndex)\n    {\n        // calculate a ray direction to a random point on a disk in the direction of the light.\n        // AKA pick a random point on the sun and shoot a ray at it.\n        vec3 shadowRayDir;\n        {\n            vec2 diskPoint;\n            if ((panel%2) == 0)\n            {\n                // get white noise\n                vec2 rng = hash23(vec3(pixelPos, float(frame * c_numShadowRays + shadowRayIndex)));\n\n                // calculate disk point\n                float pointRadius = lightRadius * sqrt(rng.x);\n                float pointAngle = rng.y * 2.0f * c_pi;\n                diskPoint = vec2(pointRadius*cos(pointAngle), pointRadius*sin(pointAngle));\n\n            }\n            else //if ((panel%2) == 1)\n            {\n                // we only have 64 blue noise samples\n                // We could make more blue noise samples, but gotta set the limit somewhere since it's a constant array of vec2s.\n                if (shadowRayIndex >= 64)\n                    break;\n                \n                // get a blue noise sample position\n                vec2 samplePos = BlueNoiseInDisk[shadowRayIndex];\n\n                // rotate it\n                diskPoint.x = samplePos.x * cosTheta - samplePos.y * sinTheta;\n                diskPoint.y = samplePos.x * sinTheta + samplePos.y * cosTheta;\n\n                // scale it by the disk size\n                diskPoint *= lightRadius;\n            }\n\n            // calculate the normalized vector to the random point on the disk\n            shadowRayDir = normalize(lightDir + diskPoint.x * lightTangent + diskPoint.y * lightBitangent);\n        }\n\n        // trace shadow ray\n        SRayHitInfo shadowHitInfo = RayVsScene(hitPos, shadowRayDir, true);\n        shadowTerm = mix(shadowTerm, ((shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f), 1.0f / float(shadowRayIndex+1));\n    }\n    \n    // do diffuse lighting\n    float dp = clamp(dot(hitInfo.normal, lightDir), 0.0f, 1.0f);\n\treturn c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm / (lightDistance*lightDistance) * angleAtten;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);    \n    \n    // calculate sub pixel jitter for anti aliasing\n    vec2 subPixelJitter = (fragCoord.y < iResolution.y * 0.5f) ? halton(iFrame % 16 + 1) - 0.5f : vec2(0.0f, 0.0f);\n    \n    // calculate the ray direction for this pixel\n    vec2 uv = (fragCoord + subPixelJitter)/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    int panel = 0;\n    vec3 rayDir;\n    {   \n        panel = int(dot(floor(uv*2.0f), vec2(1.0f, 2.0f)));\n        \n\t\tvec2 screen = fract(uv*2.0f) * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // do rendering for this pixel\n    float rayHitTime;\n    vec3 pixelColor = GetColorForRay(cameraPos, rayDir, rayHitTime, panel, fragCoord);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // get the neighborhood min / max from this frame's render\n    vec3 center = texture(iChannel0, uv).rgb;\n    vec3 minColor = center;\n    vec3 maxColor = center;\n    for (int iy = -1; iy <= 1; ++iy)\n    {\n        for (int ix = -1; ix <= 1; ++ix)\n        {\n            if (ix == 0 && iy == 0)\n                continue;\n            \n           \n            vec2 offsetUV = ((fragCoord + vec2(ix, iy)) / iResolution.xy);\n            vec3 color = texture(iChannel0, offsetUV).rgb;\n            minColor = min(minColor, color);\n            maxColor = max(maxColor, color);\n        }\n    }\n    \n    // get last frame's pixel and clamp it to the neighborhood of this frame\n    vec3 old = texture(iChannel1, uv).rgb;    \n    old = max(minColor, old);\n    old = min(maxColor, old);\n    \n    // interpolate from the clamped old color to the new color.\n    // Reject all history when the mouse moves.\n    float lerpAmount = (iMouse.z > 0.0 || uv.y > 0.5f) ? 1.0f : 0.1f;\n    vec3 pixelColor = mix(old, center, lerpAmount);        \n    fragColor = vec4(pixelColor, 1.0f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ANIMATE_NOISE 1\n\nconst int c_numShadowRays = 16;  // blue noise will use 64 samples max. white noise will use however many you specify here.\nconst vec3 c_lightPos = vec3(0.0f, 60.0f, 40.0f);\nconst float c_lightRadius = 5.0f;\n// direction of the spotlight\n#define c_lightDir (normalize(vec3(0.0f, -1.0f, -1.0f)))\nconst float c_cosThetaInner = 0.8f;  // direction to light, dotted by -c_lightDir. light starts to fade here.\nconst float c_cosThetaOuter = 0.7f; // direction to light, dotted by -c_lightDir. light finishes fading here.\nconst vec3 c_lightColor = vec3(1.0f, 0.8f, 0.5f) * 5000.0f;\nconst vec3 c_lightAmbient = vec3(0.05f, 0.05f, 0.05f);\n\n\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n\nconst float c_FOV = 90.0f; // in degrees\nconst float c_cameraDistance = 100.0f;\nconst float c_minCameraAngle = c_pi / 2.0f;\nconst float c_maxCameraAngle = c_pi;\nconst vec3 c_cameraAt = vec3(0.0f, 20.0f, 0.0f);\nconst float c_rayMaxDist = 10000.0f;\n\nconst vec2 c_defaultMousePos = vec2(90.0f / 800.0f, 250.0f / 450.0f);\n\nconst float c_hitNormalNudge = 0.1f;\n\n// This \"blue noise in disk\" array is blue noise in a circle and is used for sampling the\n// sun disk for the blue noise.\n// these were generated using a modified mitchell's best candidate algorithm.\n// 1) It was not calculated on a torus (no wrap around distance for points)\n// 2) Candidates were forced to be in the unit circle (through rejection sampling)\nconst vec2 BlueNoiseInDisk[64] = vec2[64](\n    vec2(0.478712,0.875764),\n    vec2(-0.337956,-0.793959),\n    vec2(-0.955259,-0.028164),\n    vec2(0.864527,0.325689),\n    vec2(0.209342,-0.395657),\n    vec2(-0.106779,0.672585),\n    vec2(0.156213,0.235113),\n    vec2(-0.413644,-0.082856),\n    vec2(-0.415667,0.323909),\n    vec2(0.141896,-0.939980),\n    vec2(0.954932,-0.182516),\n    vec2(-0.766184,0.410799),\n    vec2(-0.434912,-0.458845),\n    vec2(0.415242,-0.078724),\n    vec2(0.728335,-0.491777),\n    vec2(-0.058086,-0.066401),\n    vec2(0.202990,0.686837),\n    vec2(-0.808362,-0.556402),\n    vec2(0.507386,-0.640839),\n    vec2(-0.723494,-0.229240),\n    vec2(0.489740,0.317826),\n    vec2(-0.622663,0.765301),\n    vec2(-0.010640,0.929347),\n    vec2(0.663146,0.647618),\n    vec2(-0.096674,-0.413835),\n    vec2(0.525945,-0.321063),\n    vec2(-0.122533,0.366019),\n    vec2(0.195235,-0.687983),\n    vec2(-0.563203,0.098748),\n    vec2(0.418563,0.561335),\n    vec2(-0.378595,0.800367),\n    vec2(0.826922,0.001024),\n    vec2(-0.085372,-0.766651),\n    vec2(-0.921920,0.183673),\n    vec2(-0.590008,-0.721799),\n    vec2(0.167751,-0.164393),\n    vec2(0.032961,-0.562530),\n    vec2(0.632900,-0.107059),\n    vec2(-0.464080,0.569669),\n    vec2(-0.173676,-0.958758),\n    vec2(-0.242648,-0.234303),\n    vec2(-0.275362,0.157163),\n    vec2(0.382295,-0.795131),\n    vec2(0.562955,0.115562),\n    vec2(0.190586,0.470121),\n    vec2(0.770764,-0.297576),\n    vec2(0.237281,0.931050),\n    vec2(-0.666642,-0.455871),\n    vec2(-0.905649,-0.298379),\n    vec2(0.339520,0.157829),\n    vec2(0.701438,-0.704100),\n    vec2(-0.062758,0.160346),\n    vec2(-0.220674,0.957141),\n    vec2(0.642692,0.432706),\n    vec2(-0.773390,-0.015272),\n    vec2(-0.671467,0.246880),\n    vec2(0.158051,0.062859),\n    vec2(0.806009,0.527232),\n    vec2(-0.057620,-0.247071),\n    vec2(0.333436,-0.516710),\n    vec2(-0.550658,-0.315773),\n    vec2(-0.652078,0.589846),\n    vec2(0.008818,0.530556),\n    vec2(-0.210004,0.519896) \n);\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 656]], "test": "untested"}
{"id": "3sjfz1", "name": "3DS Homebrew", "author": "lambmeow", "description": "Recreated the background for the 3ds homebrew channel. \nThis one was a lot of fun.", "tags": ["3ds", "homebrew"], "likes": 4, "viewed": 465, "published": 3, "date": "1589505519", "time_retrieved": "2024-07-30T21:06:42.668129", "image_code": "#define time iTime\n\nfloat wave(float x)\n{\n    return sin(x * 10.0 + time)* 0.5 * sin(x * 0.5 + time) * .2 + 0.5;\n}\n\n\n//stolen from iq\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedBox( vec2 p, vec2 b, vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n\nfloat drawBox(vec2 uv, vec2 p, vec2 s)\n{\n    return step(1.0,1.0-sdRoundedBox(uv - p, vec2(.23,.35) * s * 0.7, vec4(0.1) * length(s * 0.7)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.2, .5,1);\n    \n    float line = step( .99, 1.0 - (abs(wave(uv.x) - uv.y )));\n    col += line * vec3(0, .4, 0);\n    float grad = step(uv.y, wave(uv.x)) + line/2.0;\n    float b = drawBox(uv, vec2(sin(time * 0.5) * .4 + 0.5, mod(time, 2.0)) , vec2(.23));\n    for(int i = 1; i < 101; i++)\n    {\n        b += drawBox(uv, vec2((sin(float(i))) + sin(time * 5.0 + float(i)) * .09 + 0.5, \n                              mod((time* clamp(((14.0/float(i))),6.0, 20.0) )/float(i), 2.0)) , vec2(.23)) * clamp(1.3-uv.y * 1.25, 0.,1.0);\n    }\n    b*= 0.12;\n    fragColor = vec4( col  +b + grad * vec3(0.1 ,.2, 1),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 41, 41, 114], [117, 184, 230, 230, 387], [390, 390, 430, 430, 533], [535, 535, 592, 592, 1262]], "test": "untested"}
{"id": "3djBz1", "name": "BlurraVision", "author": "Yambam", "description": "motion blur effect (uses the plastic ratio)", "tags": ["2d", "video", "video", "blur", "effect", "old", "mtv"], "likes": 13, "viewed": 856, "published": 3, "date": "1589501375", "time_retrieved": "2024-07-30T21:06:43.523841", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    U /= iResolution.xy;\n    O = texture(iChannel0, U);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BLURINESS .85     //Nice values between 0.8 and 0.99\n#define CHROMA_THRESH .5  //Nice values between .25 and .65\n\n#define ZOOM0 1.05\n#define DITHER0 .01\n\n#define ZOOM1 1.\n#define DITHER1 .0 //.003 //\n\n#define PASS_COUNT 12.\n\nvoid mainImage( out vec4 final_O, in vec2 _U )\n{\n    vec2 U = _U / iResolution.xy;\n    vec2 origin = vec2(.5,.35);\n    \n    final_O = vec4(0.,0.,0.,1.);\n    for (float j=0.; j<PASS_COUNT; j++) {\n        vec4 O = vec4(0.,0.,0.,1.);\n        \n        float shift = (_U.x)/1.22074408461 +\n                      (_U.y)/1.4902161201 +\n                      ((float(iFrame)*PASS_COUNT+j)/1.61803398875)*pow(iResolution.x,.5)/60./1.8191725134; // * iMouse.x/iResolution.x; //\n       \t\n        float shift_y = mod(shift/1.32471795724,1.);\n        float shift_x = mod(shift/1.75487766623,1.);\n        \n\t\tbool off = shift_x*shift_x + shift_y*shift_y > 1.;\n        \n        \n        vec4 tex0;\n        \n        if (!off) {\n            vec2 Ut0 = (U-origin)/ZOOM0+origin+DITHER0*vec2(-1.+2.*(mod(shift_x,1.)),\n                                                            -1.+2.*(mod(shift_y,1.)));\n            tex0 = texture(iChannel0, Ut0);\n        }\n        if (j>=1.\n        &&  iMouse.z>0.) {\n            //Fun sharpness adjustment!\n        \ttex0 = mix(tex0, mix(vec4(.0,.0,.0,1.), final_O, 1./j), -1.5+4.*iMouse.x/iResolution.x);\n        }\n\n\n        vec2 Ut1 = (U-origin)/ZOOM1+origin-DITHER1*vec2(-1.+2.*(mod(shift_x,1.)),\n                                                        -1.+2.*(mod(shift_y,1.)));\n        vec4 tex1 = texture(iChannel1, Ut1); //U); //\n\n\n        float chroma = (max(distance(vec3(tex1.r,tex1.g,tex1.b), vec3(13./255., 163./255., 37./255.)), CHROMA_THRESH)-CHROMA_THRESH)/(1.-CHROMA_THRESH);\n        \n        //O = tex0;\n        vec4 bg_col = vec4(0.085 + 0.085*cos(iTime+U.xyx+vec3(0,2,4)), 1.); //vec4(.25,.0,.4,0.) //\n        O = off ? bg_col : mix(tex0, bg_col, 1.-BLURINESS); //mix(O, bg_col, 1.-BLURINESS);\n        O = mix(O, tex1, (0.+1.*chroma));\n        //O = O - vec4(.01,.01,.01,.0);\n        \n    \tfinal_O += O;\n    }\n    \n    final_O = mix(vec4(.0,.0,.0,1.), final_O, 1./PASS_COUNT);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 99]], "test": "untested"}
{"id": "wsyGzt", "name": "3D voxel traversal", "author": "ich", "description": "render a voxel scene with 3 dimensional voxel traversal", "tags": ["3dvoxeltraversaltraverse"], "likes": 7, "viewed": 583, "published": 3, "date": "1589483058", "time_retrieved": "2024-07-30T21:06:44.385537", "image_code": "#define TRAVERSAL_MAX_IT 256\n\nfloat n21(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat n31(vec3 n)\n{\n\treturn fract(sin(dot(n, vec3(12.9898,78.233,12.5429))) * 43758.5453);\n}\n\nfloat on21(vec2 uv, float i, float m) {\n    m = pow(.5, i - 1. + m);\n    float c = 0.;\n    for (float j = 0.; j < i; ++j)\n    \tc += n21(floor(uv * m / pow(.5, j))) * pow(.5, j);\n    \n    return c / 2.;\n}\n\nmat3 look_at(vec3 d, vec3 u)\n{\n    vec3 r = normalize(cross(u, d));\n    u = normalize(cross(d, r));\n\treturn mat3(r, u, d);\n}\n\nmat3 rotX(float a)\n{\n\treturn mat3(\n    \tcos(a), -sin(a), 0,\n        sin(a), cos(a), 0,\n        0, 0, 1\n    );\n}\n\nvec3 perspective_ray(vec2 uv, float fov)\n{\n\treturn normalize(vec3(uv, fov));\n}\n\nfloat grid(vec3 uv)\n{\n    /*const float sz = 64.;\n    return false \n        || uv.x < 0. || uv.y < 0. || uv.z < 0.\n        || uv.x > sz || uv.y > sz || uv.z > sz\n        || ((abs(uv.z) == sz / 2. || abs(uv.z) == floor(sz / 1.25) || abs(uv.z) == floor(sz / 1.1)) && n31(uv) < .1)\n        || (uv.x < sz / 2. && uv.y < sz / 2. && uv.z > sz / 2.)\n        ? 1. : 0.;\n    */\n    \n    return on21(uv.xz, 4., 0.) * 32. > uv.y ? 1. : 0.;\n    \n\t//return n31(uv + 5.) < .001 ? 1. : 0.;\n}\n\nbool traverse_voxel(vec3 ro, vec3 rd, out vec3 id, out vec3 n)\n{\n    // this magic is nesseccary for the algorithm to work. don't ask me why lol\n    rd = normalize(1. / rd);\n    \n    //const int size = 16;\n    int x = int(floor(ro.x));\n    int y = int(floor(ro.y));\n    int z = int(floor(ro.z));\n    int stepX = int(sign(rd.x));\n    int stepY = int(sign(rd.y));\n    int stepZ = int(sign(rd.z));\n    //int outX = size * stepX;\n    //int outY = size * stepY;\n    float tDeltaX = abs(rd.x);\n    float tDeltaY = abs(rd.y);\n    float tDeltaZ = abs(rd.z);\n    float tMaxX = tDeltaX - fract(ro.x * sign(rd.x)) * tDeltaX;\n    float tMaxY = tDeltaY - fract(ro.y * sign(rd.y)) * tDeltaY;\n    float tMaxZ = tDeltaZ - fract(ro.z * sign(rd.z)) * tDeltaZ;\n    int status = -1; // unresolved\n    int i = 0;\n    \n    do {\n        if(tMaxX < tMaxY) {\n            if (tMaxX < tMaxZ) {\n            \ttMaxX += tDeltaX;\n            \tx += stepX;\n                n = vec3(-stepX, 0, 0);\n            } else {\n            \ttMaxZ += tDeltaZ;\n            \tz += stepZ;\n                n = vec3(0, 0, -stepZ);\n            }\n        } else {\n            if (tMaxY < tMaxZ) {\n            \ttMaxY += tDeltaY;\n            \ty += stepY;\n                n = vec3(0, -stepY, 0);\n            } else {\n            \ttMaxZ += tDeltaZ;\n            \tz += stepZ;\n                n = vec3(0, 0, -stepZ);\n            }\n        }\n        \n        if (grid(vec3(x, y, z)) == 1.) {\n            status = 0; // hit\n            id = vec3(x, y, z);\n        }\n        \n        //if (x == outX || y == outY) status = 1; // outside\n    } while(status == -1 && i++ < TRAVERSAL_MAX_IT);\n    \n\treturn status == 0;\n}\n\nvec3 grass(vec2 uv) {\n    float n = on21(uv * iResolution.y, 4., 0.);\n    uv += n * vec2(9., 17.) / iResolution.y;\n    float t = iTime * 10.;\n    vec3 c = vec3(0);\n    \n    c += on21(uv * iResolution.y, 4., 0.);\n    c *= vec3(.9, 1., .35);\n    c *= on21(uv * iResolution.y, 3., -3.);\n    return c;\n}\n\nvec3 dirt(vec2 uv) {\n    float n = on21(uv * iResolution.y, 4., 0.);\n    uv += n * vec2(9., 17.) / iResolution.y;\n    float t = iTime * 10.;\n    vec3 c = vec3(0);\n    \n    c += on21(uv * iResolution.y, 4., 0.);\n    c *= vec3(1., .7, .35);\n    c *= on21(uv * iResolution.y, 4., 0.);\n    return c;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    vec2 uv = (frag_coord - iResolution.xy * .5) / iResolution.y;\n    vec2 m = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    //vec3 ro = vec3(vec2(iTime * .5), 0);\n    vec3 ro = vec3(vec2(0, 32) - m * 64., 0) + .001;\n    mat3 l = look_at(normalize(vec3(m * 2., 1)), vec3(0, 1, 0));\n    vec3 rd = l * perspective_ray(uv, .5);\n    \n    {\n    \tvec3 id, n;\n        if (traverse_voxel(ro, rd, id, n)) {\n        \tcol.b += (smoothstep(float(TRAVERSAL_MAX_IT), 0., length(id - ro))  * .5 + .5) * clamp(dot(rd, -n), 0., 1.);\n        }\n    }\n\n    frag_color = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 49, 49, 114], [116, 116, 135, 135, 208], [210, 210, 249, 249, 413], [415, 415, 445, 445, 539], [541, 541, 561, 561, 652], [654, 654, 696, 696, 732], [734, 734, 755, 1102, 1210], [1212, 1212, 1276, 1356, 2866], [2868, 2868, 2889, 2889, 3167], [3169, 3169, 3189, 3189, 3466], [3468, 3468, 3525, 3525, 4130]], "test": "untested"}
{"id": "tsGGR3", "name": "2D voxel traversal", "author": "ich", "description": "traversing a 2 dimensional grid of voxels with a line. said line reflects on non-empty cells.\nuse mouse determine the starting position", "tags": ["2dvoxeltraversaltraverse"], "likes": 7, "viewed": 488, "published": 3, "date": "1589482976", "time_retrieved": "2024-07-30T21:06:45.357937", "image_code": "float n21(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rot(float a)\n{\n\treturn mat2(\n    \tcos(a), -sin(a),\n        sin(a), cos(a)\n    );\n}\n\nfloat grid(vec2 uv)\n{\n\treturn n21(uv) < .1 ? 1. : 0.;\n}\n\nfloat line(vec2 uv, vec2 lo, vec2 ld)\n{\n    uv -= lo;\n\tvec2 p = dot(uv, ld) / dot(ld, ld) * ld;\n    return length(p - uv);\n}\n\nfloat line_segment(vec2 uv, vec2 lo, vec2 ld)\n{\n\tuv -= lo;\n\tvec2 p = dot(uv, ld) / dot(ld, ld) * ld;\n    float l = clamp(length(p), 0., length(ld));\n    p = normalize(ld) * l;\n    return length(p - uv);\n}\n\nvec2 line_intersect_line(vec2 s1, vec2 v1, vec2 s2, vec2 v2)\n{\n    float b = (-s1.y - v1.y * ((s2.x - s1.x) / v1.x) + s2.y) / (v2.x / v1.x * v1.y - v2.y);\n    return s2 + v2 * b;\n}\n\nvoid cube_line(vec2 n, out vec2 o, out vec2 d)\n{\n\td = -n.yx;\n    o = clamp(n, vec2(0, 0), vec2(1, 1));\n}\n\nbool traverse_voxel(vec2 ro, vec2 rd, out vec2 id, out vec2 p, out vec2 n)\n{\n    const int len = 128;\n    //const int size = 16;\n    int x = int(floor(ro.x));\n    int y = int(floor(ro.y));\n    int stepX = int(sign(rd.x));\n    int stepY = int(sign(rd.y));\n    int cstepX = clamp(stepX, 0, 1);\n    int cstepY = clamp(stepY, 0, 1);\n    //int outX = size * stepX;\n    //int outY = size * stepY;\n    float tDeltaX = abs(rd.y);\n    float tDeltaY = abs(rd.x);\n    float tMaxX = tDeltaX - fract(ro.x * sign(rd.x)) * tDeltaX;\n    float tMaxY = tDeltaY - fract(ro.y * sign(rd.y)) * tDeltaY;\n    int status = -1; // unresolved\n    int i = 0;\n    \n    do {\n        if(tMaxX < tMaxY) {\n            tMaxX += tDeltaX;\n            x += stepX;\n            n = vec2(-stepX, 0);\n        } else {\n            tMaxY += tDeltaY;\n            y += stepY;\n            n = vec2(0, -stepY);\n        }\n        \n        if (grid(vec2(x, y)) == 1.) {\n            status = 0; // hit\n            id = vec2(x, y);\n        }\n        \n        //if (x == outX || y == outY) status = 1; // outside\n    } while(status == -1 && i++ < len);\n    \n    if (status == 0) {\n        vec2 lo, ld;\n        cube_line(n, lo, ld);\n        p = line_intersect_line(ro, rd, id + lo, ld);\n        \n        return true;\n    }\n    return false;\n}\n\nvoid bounce(vec2 uv, vec2 ro, vec2 rd, vec2 id, float scale, inout vec3 col)\n{\n    for (int i = 0; i < 8; i++) {\n        vec2 pid, p, n;\n        col.rg += traverse_voxel(ro, rd, pid, p, n) ? (id == pid ? 1. : 0.) : 0.;\n        col.b += smoothstep(scale / iResolution.y * 2., .0, line_segment(uv, ro, rd * length(p - ro)));\n        ro = p + n * .001;\n        rd = reflect(rd, n);\n    }\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    float scale = 32.;\n    vec2 uv = frag_coord / iResolution.y * scale;\n    vec2 id = floor(uv);\n    vec3 col = vec3(0);\n    \n    vec2 ro = iMouse.xy / iResolution.y * scale + .001;\n    vec2 rd = rot(iTime * .1) * normalize(vec2(5, 1) + .001);\n    \n    /*\n    vec2 pid, p, n;\n    col.rg += traverse_voxel(ro, rd, pid, p, n) ? (id == pid ? 1. : 0.) : 0.;\n    col.r += smoothstep(.23, .2, length(uv - p));\n    vec2 co, cd;\n    cube_line(n, co, cd);\n    col.r += smoothstep(scale / iResolution.y * 2., .0, line(uv, pid + co, cd));\n    col.rg += smoothstep(scale / iResolution.y * 2., .0, line(uv, pid, n));\n    */\n    \n    col.g += grid(id) * .3;\n    col.bg += smoothstep(.23, .2, length(uv - ro));\n    bounce(uv, ro, rd, id, scale, col);\n\n    frag_color = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 84], [86, 86, 105, 105, 173], [175, 175, 196, 196, 230], [232, 232, 271, 271, 356], [358, 358, 405, 405, 562], [564, 564, 626, 626, 744], [746, 746, 794, 794, 850], [852, 852, 928, 928, 2141], [2143, 2143, 2221, 2221, 2529], [2531, 2531, 2588, 2588, 3360]], "test": "untested"}
{"id": "3sjBRh", "name": "clouding of reason", "author": "avin", "description": "filter experiment", "tags": ["filter"], "likes": 3, "viewed": 442, "published": 3, "date": "1589480578", "time_retrieved": "2024-07-30T21:06:46.103942", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]], "test": "untested"}
{"id": "wsSBz1", "name": "Into Red Ashes", "author": "Leria", "description": "Cool stuff, wanted to share ;)\nI use noise to make this effect. ", "tags": ["noise", "red", "particle", "ashes"], "likes": 1, "viewed": 326, "published": 3, "date": "1589476078", "time_retrieved": "2024-07-30T21:06:46.911783", "image_code": "#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t21.\n#define RAY_TRACING 0\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n    mat4 projection;\n \tvec3 pos; //position\n    vec3 focal_point; //focal point = target point\n    float vfov; //vertical fov\n};\n\n///////////////////////////////////////////////\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.);\nvec3 J = vec3(0., 1., 0.);\nvec3 K = vec3(0., 0., 1.);\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_camera(vec3 pos, vec3 target, float theta /*degree*/)\n{\n    cam = Camera(mat4(1), pos, target, theta);\n}\n\nvoid init_camera(void)\n{\n    set_camera(vec3(.05, 2.8, 25.), vec3(0., 0., -10.), 60.); \n}\n\n\nfloat sdf_plane(vec3 pXp0, vec3 n)\n{\n\treturn dot(pXp0,n.xyz);   \n}\n\nfloat sdf_circle(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    vec3 p = ray_interpolation(r, k);\n    for(float s = k; s < 16.; s+=k)\n    {              \n        if( sdf_circle(p-vec3(0., 0., -15.), RADIUS) >= 0. && sdf_plane(vec3(0., 0., -15.), vec3(-.25, 1., 0.)) == 0.)\n        {\n        \tvec4 tex = texture(iChannel0, p/4.+0.1*(iTime));\n        \tc = max(c, tex.rrr*vec3(0.9, 0.5, 0.4));\n        }\n        \n        p += r.dir * s;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = -(2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n\n    ray_march_scene(Ray(cam.pos, vec3(uv, -1.)), .5, color);\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[487, 487, 528, 528, 564], [566, 566, 630, 630, 679], [681, 681, 705, 705, 770], [773, 773, 809, 809, 839], [841, 841, 884, 884, 924], [926, 926, 978, 978, 1360], [1362, 1362, 1419, 1419, 1640]], "test": "untested"}
{"id": "wdSfzh", "name": "[TWITCH] Monster Things", "author": "evvvvil", "description": "Monster Things - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["tunnel", "demoscene", "glow", "alien", "organic", "life", "monster", "creature", "disgusting", "spine", "twitch", "horn", "improv"], "likes": 84, "viewed": 5846, "published": 3, "date": "1589474229", "time_retrieved": "2024-07-30T21:06:47.751537", "image_code": "// Monster Things - Result of an improvised live code session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: https://www.twitch.tv/evvvvil_\n// Thankx to Haptix and canadianCornDog for the suggestions!\n// Music by OddJohn / HANDSOME HOOLIGANS - https://soundcloud.com/oddjohnofficial\n\n// \"Motherfuckers stole my 80s style!\" - Steven Spielberg\n\nvec2 z,v,e=vec2(.01,-.01);float t,tt,g,gg;vec3 sp,tp,ep,op,hp,po,no,ld,al;//Global vars. About as boring as conspiracy theorists conspiring to make conspriacy theories\nfloat smin(float a,float b,float h){float k=clamp((a-b)/h*.5+.5,0.,1.); return mix(a,b,k)-k*(1.-k)*h;} //Add geometries with smooth blend. Yeah this is what Sade talks about in the song \"Smoothhhhhhh Operatooooor\"\nfloat smax(float d1,float d2,float k){float h=clamp(0.5-0.5*(d2+d1)/k,0.,1.);return mix(d2,-d1,h)+k*h*(1.0-h);}//Remove geometries with smooth blend. yeah sorry couldn't make a lamer joke than the one above...\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//Rotate function. Short and sweet, just like how Kim Jung Un could be, if he had been given enough attention as a child.\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; //Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}\nvec2 mp( vec3 p )\n{ \n  op=p;//Remember original position in op\n  p.z=mod(p.z+tt*6.,78.)-39.;//Modulo and animate everything else along the z axis\n  tp=p;//Tunnel position is moduloed and animated (line above) but NOT twisted along z axis (next line)    \n  p.xy*=r2(sin(op.z*.2+tt*2.)*.5);//Twist everything else along the z axis and animnate\n  sp=p;//Sp is spine position used everywhere for monster\n  float dis=sin(op.z*.2+tt*1.2)*1.+sin(op.z*.1+tt*.6)*.5; //dis is deformer / displacement along z axis with sin\n  float zf=sin(p.z*15.)*0.03; //zf is z axis frill adding nice details like rib cage and crest\n  float xf=sin(p.x*15.)*0.03; //xf is x axis frill adding nice details on edges etc\n  float tnoi=texNoise(p.yz*.1).r*.8; //tnoi is texture noise displacement by sampling texture and making perlin, adds great curnchy organic details\n  float fft=texture( iChannel1, vec2(min(abs(op.z*.002)*.15,5.),0)).x; //Audio sync along z limited to first 5 fft samples (bass)\n  sp.xy+=dis;//add deformer to spine position\n  vec2 h,t=vec2(length(sp.xy+xf)-(2.-dis+tnoi),5); //make main spline with deformer also influencing the radius not just position + texture displacement\n  t.x=smin(t.x,length(abs(sp.xy+xf)-(1.5-dis))-(.5+tnoi),.5); //Add 4 cylinder to create edges again with deformer and texture displacement\n  t.x=smin(t.x,length(abs(sp.xy+zf)-vec2(0,2.1-dis))-(.5+tnoi),.5);  //CREST made of two cylinder above and bellow with deformer and texture displacement\n  t.x=smax((length(abs(sp.xy+zf)-vec2(2.-dis,0))-(1.-dis+tnoi)),t.x,.3);//RIBS made by carving out 2 cylinders on side and adding x axis frill\n  hp=ep=sp; //horn positions and electricitings position\n  hp.z=mod(hp.z,3.)-1.5; //modulo horn position along z to have loads of them on the crest\n  t.x=smax(length(abs(hp-vec3(0,0,.2))-vec3(0,2.1-dis,0))-(.6+tnoi-dis*.4),t.x,.5); //HOLES FOR HORNS by reusing hp and shifting a bit\n  hp.z-=min(pow(hp.y*.1,2.)*5.,5.);//HORN DEFORMER. Bend them forward menacingly. This could also be said in a BDSM scenario, involving people, also wearing horns.\n  h=vec2(length(hp.xz+xf)-(.5+tnoi-dis*.4-abs(pow(hp.y*.09,2.)*4.)),6);  //HORNS made using hp postion and horn deformer\n  h.x*=0.7; //We gotta increase the definition of horn geometry as they are deformed a lot, this avoids artifact\n  t=t.x<h.x?t:h; //Add horns geometry to the scene while retinaing material id\n  sp.y*=0.5;//EGGS position is reusing spine position but scaled along y to make spheres a taller egg shape\n  sp.z=mod(sp.z,3.)-1.5; //Modulo along z to create many eggs along z axis, it's the same modulo frequency as for the horn position to align holes, horns and eggs. \"Align holes, horns and eggs\" sounds like a very good Peter Greenaway film!\n  h=vec2(length(sp)-(max(.8,1.-dis*.5)),6);  //Make the actual eggs geometry and use displacement variable to change radius\n  g+=0.1/(0.1+h.x*h.x*40.);//Add eggs distance field to red glow variable (added at the end)\n  t=t.x<h.x?t:h;  //Add eggs to the scene\n  for(int i=0;i<2;i++){//ELECTRICITINGS KIFS\n   ep=abs(ep)-2.;//Each iter pull apart by 2 on xyz \n   ep.xy*=r2(-.3); //Rotate bit on XY\n   ep.yz*=r2(.5);  //Rotate more on YZ\n  }\n  h=vec2(length(ep.xz+tnoi*5.),3);  //Make electricitings, please note the lack of radius, -0 in fact so ignored, that is how you get pure LASER. let's be pedantic about these things, this isn't Stepney Green Bingo Hall\n  gg+=0.4/(0.1+h.x*h.x*1.+1.*abs(sin(ep.y*.4-tt*2.)));//Add electricitings distance field to blue glow variable (added at the end)\n  t=t.x<h.x?t:h;  //Add electricitings to scene  \n  h=vec2(length(tp.xy)-27.,6);  //OUTTER CYLINDER FOR TUNNEL\n  tnoi=texNoise(vec2(abs(atan(tp.x,tp.y)),tp.z*.1-76.)*(.07)).r*14.;//REDEFINE texture noise with polar uvs\n  h.x=max(h.x,-(length(tp.xy)-14.+tnoi+fft*3.)); //CUT HOLE IN TUNNEL\n  h.x=smax((length(abs(tp)-vec3(0,15.-fft*2.,0))-(4.+tnoi)),h.x,1.);//HOLES FOR BLUE SPHERES\n  h.x*=0.8; t=t.x<h.x?t:h; //Tweak disitance field to remove artifact and add to the scene\n  h=vec2((length(abs(tp)-vec3(0,15.-fft*2.,0))-(3.+tnoi)),7);//BLUE SPHERES \n  gg+=0.4/(0.1+h.x*h.x*1.+1.*abs(sin(ep.y*.4-tt*2.-.7))); //Add blue spheres distance field to blue glow variable (added right at end)\n  t=t.x<h.x?t:h; //Add blue spheres to scene \n  t.x*=0.6; return t;\n}\nvec2 tr( vec3 ro, vec3 rd) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.00001||t.x>120.) break;//Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>120.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.82);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  v=mix(vec2(3.,8.8),vec2(12.,16.),ceil(cos(tt*.4)));//Reuse the v variable as holder of camera variables\n  vec3 ro=vec3(cos(tt*.4)*7.,sin(tt*.4)*7.,-10.),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0,0,cos(tt*.6)*8.)-ro),cu=normalize(cross(cw,vec3(sin(tt*.3)*.5,1,0))),cv=normalize(cross(cu,cw)), //camera forward, left and up vector.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.5,-.3));//ld=light direction\n  co=fo=vec3(.1)-length(uv)*.1;//background is dark with vignette\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying to throw a spear at a pig. We wouldnt have survive the ice age with you and your nerdy mates.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many brain cells I lost during my mid 2000s raving haydays.\n    al=mix(vec3(.4,.5,.6),vec3(.6,.3,.2),.5+.5*sin(tp.z*.3-1.5));//albedo is base colour by default it's greyish to redish gradient\n    if(z.y<5.) al=vec3(0); //material system if less than 5 make it black\n    if(z.y>5.) al=vec3(1); //material system if more than 5 make it white\n    if(z.y>6.)al=vec3(.1,.2,.4);//Material Id more than 6 makes it blue\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),50.);//Sp=specular, stolen from shane\n    co=mix(sp+al*(a(.1)*a(.3)+.2)*(vec3(.5,.2,.1)*dif+s(.5)*1.5),fo,min(fr,.5));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.00007*t*t*t)); //Fog soften things, but it won't stop your annoying uncle from thinking \"Bloody fiddling with bloody numbers, ain't gonna get you a job, son. Real graft is what ye need, wee man.\"(last sentence read with Scottish accent if you can)\n  }\n  fragColor = vec4(pow(co+g*.2*vec3(.5,.2,.1)+gg*.1*vec3(.1,.2,.4),vec3(.55)),1); //Add glow at the end. g & gg are red and blue glow global variables containg distance fields see lines 42,50,58\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22714, "src": "https://soundcloud.com/jonathan-colonieu/monster-things", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 550, 586, 586, 652], [653, 764, 802, 802, 875], [875, 974, 991, 991, 1034], [1034, 1156, 1179, 1179, 1488], [1489, 1489, 1508, 1508, 5746], [5747, 5747, 5828, 5828, 6596], [6686, 6686, 6815, 6815, 9668]], "test": "untested"}
{"id": "3lKSDG", "name": "Cosmic horizon", "author": "z0rg", "description": "A small experiment for dnb visuals.", "tags": ["abstract", "liquid", "dnb"], "likes": 38, "viewed": 873, "published": 3, "date": "1589462531", "time_retrieved": "2024-07-30T21:06:48.629191", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\nfloat _cir(vec2 uv, float sz)\n{\n  return length(uv)-sz;\n}\n\nfloat _loz(vec2 uv,float sz)\n{\n  return lenny(uv)-sz;\n}\n\nvec3 tunnel(vec2 uv,float sz)\n{\n  //uv += vec2(sin(length(uv)),cos(length(uv)))*.1;\n  float a = sz*atan(uv.y,uv.x)/PI;\n  float d = .021*iTime+.01/length(uv);\n  vec3 col = texture(iChannel0,vec2(d,a)).xxx;\n  return sat(1.-length(uv*.2))*col*sat(length(uv*20.))*mix(vec3(.28+abs(uv.x),.34,sat(.17+length(uv))),vec3(.8,.5,.7),length(uv)-.9);\n}\n\nvec3 rdrLand(vec2 uv)\n{\n  vec3 back;\n  vec3 col;\n  col += 2.*tunnel(uv,1.);\n // col += 1.5*tunnel(uv*.8*r2d(iTime*.2),.2);\n  col += tunnel(uv*5.2*r2d(iTime*.2),.2);\n\n  for (int i = 0;i<8;++i)\n  {\n    float fi= float(i);\n    float sz = 5./(fi+1.);\n    float szc = 7.*mod(sz+iTime*.1,1./9.);\n    float cut = _cir(uv, szc-szc/10.);\n    float ci = _cir(uv, szc);\n    float cir = 1.-sat(_sub(ci,cut)*20.);\n    col += vec3(.53,.94,.58)*(cir)*(sz-.1)*.1;\n  }\n\n  return back+col*.5;\n}\n\nvec3 rdrSqr(vec2 uv)\n{\n  uv = uv *r2d(PI/4.);\n  vec3 acc;\n  for (int i = 0; i < 16; i++)\n  {\n     vec2 suv = uv;\n     suv = suv*r2d(.8*smoothstep(0.,.9,mod(iTime+float(i)*.5,.9)));\n     vec3 col;\n\n     float an = iTime*.1+.15*float(i)+atan(uv.y, uv.x)/PI;\n     float sz = mod(iTime/(float(i+1)*.7),1.);\n     float sqr = _sub(_loz(suv, sz),_loz(suv,sz*.999));\n     col = vec3(1.,float(i)/10.,uv.y*.5+.2)*((1.-sat(sqr*200.))+.7*(1.-sat(sqr*15.)))*sat(float((mod(an,.05)-.015))*20.);\n     acc += col;\n  }\n    return acc;\n}\n\nvec3 rdrScn(vec2 uv)\n{\n  float maskLand = 1.-sat(_cir(uv,.5)*50.);\n\n  vec3 land = rdrLand(uv).zyx;\n  land += rdrSqr(uv)*sat(lenny(uv*2.))*.7;\n  return land;\n}\n\nvec3 rdr2(vec2 uv)\n{\n    vec2 ouv = uv;\n    ouv.y *= 1.+cos((ouv.x*PI));\n    vec3 col = rdrScn(ouv);\n  \tcol *= vec3(.7, .34, .89)*sat(1.-lenny(uv))*2.;\n    vec3 col2;\n    col2 += 2.*vec3(.7, .54, .89).zyx*sat(1.-lenny(uv*vec2(1., 8.)));\n    col2 += vec3(.7, .54, .89).zyx*sat(1.-lenny(uv*vec2(.5, 90.)));\n    col2 += .9*vec3(.7, .54, .89).zyx*sat(1.-lenny((uv*r2d(PI/4.)*vec2(.5, 10.))));\n    col2 += .5*vec3(.7, .54, .89).zyx*sat(1.-lenny((uv*r2d(PI/4.)*vec2(.5, 2.))));\n    col2 += .5*vec3(.7, .54, .89).zyx*sat(1.-lenny(((uv+vec2(-.2, -.5))*r2d(PI/4.)*vec2(.5, 90.))));\n    col2 += .5*vec3(.7, .54, .89).zyx*sat(1.-lenny(((uv+vec2(-.2, .3))*r2d(PI/4.)*vec2(.5, 5.))));\n    \n    vec3 halo = vec3(.6,.7,.9)*(1.-sat(_sub(_cir(uv, .65), _cir(uv, .6))*15.));\n    return col+col2*.5+halo*.4;\n}\n\nvec3 rdrPost(vec2 uv)\n{\n    vec2 dir = uv*.05;\n    float r = rdr2(uv+dir).x;\n    float g = rdr2(uv).y;\n    float b = rdr2(uv-dir).z;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv*= 1.5;\n  vec3 col = rdrPost(uv);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKSDG.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[426, 426, 444, 444, 505], [507, 507, 528, 528, 558], [559, 559, 579, 579, 606], [607, 607, 625, 625, 671], [672, 672, 702, 702, 724], [725, 725, 756, 756, 782], [784, 784, 814, 814, 839], [841, 841, 872, 924, 1181], [1183, 1183, 1206, 1206, 1659], [2182, 2182, 2204, 2204, 2340], [2342, 2342, 2362, 2362, 3132], [3134, 3134, 3157, 3157, 3292], [3294, 3294, 3351, 3351, 3512]], "test": "untested"}
{"id": "ws2fzz", "name": "SPH 3D", "author": "michael0884", "description": "The 3d sequel. Voronoi particle tracking 3D.\nif you have the plugin:\nuse acceleration 4x", "tags": ["voronoi", "simulation", "interactive", "fluid", "particles", "sph"], "likes": 38, "viewed": 1487, "published": 3, "date": "1589453100", "time_retrieved": "2024-07-30T21:06:49.692348", "image_code": "// Fork of \"Super SPH \" by michael0884. https://shadertoy.com/view/tdXBRf\n// 2020-05-09 15:47:15\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale+2.).rgb;\n    \n    return bloom;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n     vec3 bloomSum = vec3(0.);\n    //bloomSum += bloom(.4 * R.y, pos) * .07;\n    //bloomSum += bloom(.2 * R.y, pos) * .07;\n    \n    fragColor.xyz = texel(ch2, pi).xyz + 1.*bloomSum;\n    fragColor.xyz = ACESFilm(2.*fragColor.xyz);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define dt 1.\n#define loop(i,x) for(int i = min(0, iFrame); i < x; i++)\n\n//rendering scale\n#define SC 3.\n\n#define smoothR 2.5\n#define density 0.05\n\n//sim stuff\nstruct obj\n{\n    int id; //ID\n    vec3 X; //position\n    float Rho; //neighbor density\n    vec3 V; //velocity\n    float Pressure; //pressure\n    vec3 Color;\n    float Scale;\n};\n    \nfloat Force(float d)\n{\n    return 0.2*exp(-0.05*d)-2.*exp(-0.5*d);\n}\n\n//40% of the buffer used for particles\n#define P 0.5\n#define SN ivec2(6, 2)\n\nivec2 N; //buffer size\nivec2 sN; //buffer single element size\nint TN; //buffer length\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sqr(float x)\n{\nreturn x*x + 1e-2;\n}\n\n//hash funcs\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = round(dot(F, uv + c)); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\n\nmat4 getPerspective(float fov, float aspect, float n, float f)\n{   \n    float scale = tan(fov * PI / 360.) * n; \n    float r = aspect * scale, l = -r; \n    float t = scale, b = -t; \n\n\t\n    return mat4(2. * n / (r - l), 0, 0, 0,\n                0, 2. * n / (t - b), 0, 0,\n                (r + l) / (r - l), (t + b) / (t - b), -(f + n) / (f - n), -1,\n                0, 0, -2. * f * n / (f - n), 0);\n}\n\nmat4 getRot(vec2 a)\n{\n    \n   mat4 theta_rot = mat4(1, 0, 0, 0,\n                         0, cos(a.y), sin(a.y), 0,\n                         0, -sin(a.y), cos(a.y), 0,\n                         0, 0, 0, 1); \n        \n   mat4 phi_rot = mat4(cos(a.x), sin(a.x), 0, 0,\n        \t\t       -sin(a.x), cos(a.x), 0, 0,\n        \t\t        0, 0, 1, 0,\n                      \t0, 0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nmat4 getModel(vec3 dx)\n{\n   return transpose(mat4(1, 0, 0, dx.x,\n        \t   0, 1, 0, dx.y,\n               0, 0, 1, dx.z,\n               0, 0, 0, 1)); ;\n}\n", "buffer_a_code": "//L1 particle buffer - simulation\n//L2 directional neighbor graph 4x - sort\n\nint ID;\nobj O; //this object\n\n//sort arrays\nvec4 lnk0, lnk1;\nvec4 d0, d1;\n\n//L3\nvec4 EA[SN.x]; //element array\n\nvoid insertion_sort(float t, int id);\nobj getObj(int id); vec4 saveObj(int i);\nbool iscoincidenceEA(int id);\nvoid sort0(int idtemp, int D); void sort1(int idtemp, int D);\n\nfloat Kernel(float d, float h)\n{\n    return exp(-sqr(d/h))/(PI*sqr(h));\n}\n\nfloat KernelGrad(float d, float h)\n{\n    return 2.*d*Kernel(d,h)/sqr(h);\n}\n\nvec2 borderF(vec2 p)\n{\n    \n    float d = min(min(p.x,p.y),min(R.x-p.x,R.y-p.y));\n    return exp(-max(d,0.)*max(d,0.))*((d==p.x)?vec2(1,0):(\n    \t\t(d==p.y)?vec2(0,1):(\n            (d==R.x-p.x)?vec2(-1,0):vec2(0,-1))));\n}\n\nvoid UpdateParticle()\n{\n    vec3 g = -1e-5*O.X; \n    vec3 F = g; \n    \n    float scale = 0.21/density; //radius of smoothing\n    float Rho = Kernel(0., scale);\n    float avgP = 0.;\n\tvec3  avgC = vec3(O.Color);\n\n    loop(j,6)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,3)\n        {\n            if(nb[i] < 0. || nb[i] > float(TN)) continue;\n            obj nbO = getObj(int(nb[i]));\n\n            float d = distance(O.X, nbO.X);\n            vec3 dv = (nbO.V - O.V); //delta velocity\n            vec3 dx = (nbO.X - O.X); //delta position \n            vec3 ndir = dx/(d+1e-3); //neighbor direction\n            //SPH smoothing kernel\n            float K = Kernel(d, scale);\n\n            vec3 pressure = -0.5*( nbO.Pressure/sqr(nbO.Rho) + \n                                     O.Pressure/sqr(O.Rho) )*ndir*K;//pressure gradient\n            vec3 viscosity = 3.*ndir*dot(dv,ndir)*K;\n           \n            Rho += K;\n            avgC += nbO.Color;\n            avgP += nbO.Pressure*K;\n\n            F += pressure + viscosity;\n        }\n    }\n\n    O.Rho = Rho;\n    \n    O.Scale = scale; //average distance\n    \n    float r = 7.;\n    float D = 1.;\n    float waterP = 0.08*density*(pow(abs(O.Rho/density), r) - D);\n    O.Pressure = min(waterP,0.03);\n\n    O.V += F*dt;\n    O.V -= O.V*(0.5*tanh(8.*(length(O.V)-1.5))+0.5);\n    O.X += O.V*dt; //advect\n\n    //color diffusion\n\n    //O.Color = ;\n}\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    //4 pix per layer, 3 layers\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    int S = 3; //log2(sN.x)\n    \n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    O = getObj(ID);\n    d0 = vec4(1e6); d1 = vec4(1e6);\n    lnk0 = vec4(-1); lnk1 = vec4(-1);\n    \n    switch(sid.z)\n    {\n    case 0: //particle\n        if(sid.z >= 3) discard;\n        float sk = 0.;\n        \n        UpdateParticle();\n        \n        if(iFrame<10)\n        {\n            O.X = 40.*(hash32(3.14159*pos) - 0.5);\n\t\t\tO.V = 0.*(hash32(3.14159*pos) - 0.5);\n            O.Color = hash32(3.14159*pos);\n            O.Pressure = 0.;\n            O.Scale = 5.;\n            O.Rho = 5.;\n        }\n\n        Q = saveObj(sid.y);\n        return;\n        \n    case 1: //dir graph\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        loop(i,4)\n        {\n            sort0(int(nb0[i]), sid.y);  //sort this\n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = texel(ch0, i2xy(ivec3(nb0[i], (iFrame+ID)%4, 1)));\n            loop(j,2)\n            {\n                sort0(int(nb1[j]), sid.y);  \n            }\n        }\n        \n        //random sorts\n        loop(i,4) sort0(int(float(TN)*hash13(vec3(iFrame, ID, i))), sid.y);\n        \n        Q = lnk0;\n        return;\n    }\n     \n}\n\nvec4 saveObj(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(O.X, O.Rho);\n    case 1:\n        return vec4(O.V, O.Pressure);\n    case 2:\n        return vec4(O.Color, O.Scale);\n    }\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.Rho = a.w;\n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.V = a.xyz; o.Pressure = a.w; \n    a = texel(ch0, i2xy(ivec3(id, 2, 0))); \n    o.Color = a.xyz; o.Scale = a.w;\n \n    o.id = id;\n    return o;\n}\n\nvoid insertion_sort(float t, int id)\n{\n\tif(d0.x > t)\n    {\n        d0 = vec4(t, d0.xyz);\n        lnk0 = vec4(id, lnk0.xyz);\n    }else if(d0.y > t && d0.x < t)\n    {\n        d0.yzw = vec3(t, d0.yz);\n        lnk0.yzw = vec3(id, lnk0.yz);\n    }else if(d0.z > t&& d0.y < t)\n    {\n        d0.zw = vec2(t, d0.z);\n        lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t && d0.z < t)\n    {\n        d0.w = t;\n        lnk0.w = float(id);\n    }\n}\n\nbool iscoincidence(int id)\n{\n    return (id < 0) || \n      \t   (id == ID) ||\n           any(equal(lnk0,vec4(id)));\n}\n\nvoid sort0(int idtemp, int D) //sort closest objects in sN.x directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec3 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xyz; \n   \n    vec3 dx = nbX - O.X;\n    int dir = int(inverseSF(dx, float(sN.x)).x);\n    \n    if(dir != D) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//voronoi 3d particle tracking + graph augmented\n\nmat4 rotat; //rotation matrix\nmat4 model; //model matrix\nmat4 imat;\n\n//render range\n#define range 300.\n#define FOV 2.\n\nvec3 ray;\nfloat d;\nvec3 ip;\nint id;\nvec2 p; //screen coord\n\nfloat sphere_intersection(vec3 r, vec3 p, vec4 sphere)\n{\n\tp = p - sphere.xyz;\n\tif(p == vec3(0)) return sphere.w;\n\t\n\tfloat b = dot(p, r);\n\tfloat c = sphere.w*sphere.w - dot(p,p);\n\tfloat d = b*b + c;\n\t\n\tif((d <= 0.)) //if no intersection\n\t{\n\t\treturn -length(cross(r, sphere.xyz)); //return closest dist\n\t}\n\telse\n\t{\n\t\treturn -sqrt(d) - b; //use closest solution in the direction of the ray\n\t}\n}\n\nvec4 ppos(int id)\n{\n\treturn vec4(texel(ch0, i2xy(ivec3(id, 0, 0))).xyz,1.);\n}\n\nvoid getRay()\n{\n    vec2 uv = (p - R*0.5)/R.x;\n    ray = normalize(vec3(FOV*uv, 1.));\n}\n\nfloat zrange(float z)\n{\n    return clamp(z/range,0.,1.);\n}\n\nvec4 point_distance(int id, float r)\n{\n    vec4 X = model*rotat*ppos(id);\n    float cd = sphere_intersection(ray, vec3(0), vec4(X.xyz,r));\n    if(cd > 0.)\n    {\n        return vec4((imat*vec4(cd*ray,1.)).xyz, zrange(cd));\n    }\n    else\n    {\n        return vec4(vec3(1e10), 1.+abs(cd));\n    }\n}\n\nvoid sort(int utemp)\n{\n    if(utemp < 0) return; \n   \tvec4 dtemp = point_distance(utemp, 0.75);\n    if(dtemp.w < d) //sorting\n    {\n        d = dtemp.w;\n        ip = dtemp.xyz;\n        id = utemp;\n    }\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    d = 1e10;\n    id = 1;\n    p = pos;\n    ip = vec3(1e10);\n    ivec2 pi = ivec2(floor(pos));\n    \n    getRay(); \n    //set up camera \n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/R)*vec2(2.*PI, PI):vec2(0.3*iTime, PI*0.5+0.5*sin(0.5*iTime));\n    rotat = getRot(angles);\n    model = getModel(vec3(0.,0.,100.));\n    imat = inverse(model*rotat);\n    \n    /// sort pixels\n    sort(int(texel(ch1, pi).x));\n    \n    int ID = id;\n    loop(j,16)\n    {\n        \n        int nbid = int(texel(ch1, pi+cross_distribution(j)).x);\n        sort(nbid);\n    }\n    \n    loop(j,int(sN.x))\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,2)\n    \t{ \n            sort(int(nb[i]));  //sort this\n        }\n    }\n    \n    loop(i,4) //random sort\n    {\n        sort(int(float(TN)*hash13(vec3(iFrame, pi.x, pi.y*i))));\n    }\n    ///\n    \n    \n    //save\n   \tQ = vec4(id, ip);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// iq's smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.Rho = a.w;\n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.V = a.xyz; o.Pressure = a.w; \n    a = texel(ch0, i2xy(ivec3(id, 2, 0))); \n    o.Color = a.xyz; o.Scale = a.w;\n \n    o.id = id;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    vec4 A = texel(ch1, pi);\n    int ID = int(A.x); \n    vec3 ip = A.yzw;\n\tobj o = getObj(ID);\n    vec3 n = normalize(ip - o.X);\n    vec3 col = o.Color*(0.5*n.x + .8);\n    vec3 ncol = (length(ip) < 1e6)?col:vec3(0.);\n    // Output to screen\n \tvec3 pcol = texel(ch2, pi).xyz;\n    fragColor = vec4(mix(pcol,ncol,0.26),1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2fzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 121, 121, 261], [386, 386, 426, 426, 720], [723, 723, 774, 774, 1106]], "test": "untested"}
{"id": "WsSBR1", "name": "short ray-marching of SDF : tuto", "author": "FabriceNeyret2", "description": "The principle is at the base of sphere-marching / sphere-surfing of scenes using optimization 3D structure  which coarse voxels contains biggest sphere radius not intersecting geometry. When scene is directly defined with SDF, it's even more direct :-)", "tags": ["raymarching", "sdf", "short"], "likes": 8, "viewed": 604, "published": 3, "date": "1589439593", "time_retrieved": "2024-07-30T21:06:50.568007", "image_code": "// variant of https://shadertoy.com/view/XsdBW8\n\n#define PI     3.1415927\n#define rot(a)  mat2(cos(a + vec4(0,PI/2.,-PI/2.,0) ) )         // rotation matrix.  golf: https://www.shadertoy.com/view/XlsyWX\n#define hue(v) ( .5 + .5 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage(out vec4 O, vec2 u) {\n    \n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;                  // normalized screen coordinates\n    vec3  D = normalize ( vec3(U, -3) ),           // ray direction. 3 = zoom (narrow opening angle)\n          P = vec3(0,0,5),                         // camera pos, then marching point along ray \n          q,a;\n    \n    mat2 M = rot(.5*iTime);\n    P.xy*= M, P.yz *= M; D.xy*= M, D.yz *= M;     // camera transform\n    \n    float d = 1e5,_d, id, obj = -1., i;\n    for ( i=0.; i < 100.  && d > .01 ; i++ )       // === march the ray\n    {\n        q = P;                                     // --- transforms\n      //q.xy*= M, q.yz *= M;                       // inv camera transform better factored out of loop\n        id = dot(floor((q+5.)/10.),vec3(1,17.3,27.1));  // obj id (random hash of 3D tile position )\n        q  = mod(q+5.,10.) - 5.;                        // tiling space with shapes\n        q.xy*= rot(id), q.yz *= rot(id);           // object rotation (different for each)\n      //q += sin(id);                              // object translation\n        \n        _d = d;                                    // --- dist to closest geometry\n        d = length(q) - 1.;                        // dist to SDF to sphere\n        d = max(d, - ( length(q) - .8 ) );         // max(-): substract: SDF to smaller sphere\n        a = abs(q);\n      //d = min(d,  max(a.x,max(a.y,a.z)) - .7 );  // min: add. SDF to box\n      //d = max(d,  max(a.x,max(a.y,a.z)) - .7 );  // max(+): intersect. SDF to box\n        d = max(d,  min(a.x,min(a.y,a.z)) - .1 );  // max(+): intersect. SDF to antibox\n        if (d!=_d) obj = id;                       // obj = closest object id\n        \n        P += d*D;                                  // --- step forward = dist to closest obj\n    }\n    O =    hue(obj)                                // coloring = hue( object id ).\n        * ( 1.-i/67.);                             // pseudo-shading = 1. - iterations\n                   // since the less iterations, the most facing object ( distance vect parallel to ray )\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 345, 345, 2418]], "test": "untested"}
{"id": "WsBBzh", "name": "GLSL bug when factoring .y", "author": "FabriceNeyret2", "description": "On OpenGL(linux) I see a gradient on left half and a step on right half while both should be gradients.\n\nbug report: [url]https://bugs.chromium.org/p/chromium/issues/detail?id=1082622[/url]", "tags": ["glsl", "bug"], "likes": 1, "viewed": 387, "published": 3, "date": "1589435047", "time_retrieved": "2024-07-30T21:06:51.366871", "image_code": "void mainImage(out vec4 fragColor,vec2 fragCoords)   {\n    vec2  U = fragCoords - .5*iResolution.xy,                             \n          w = 50.+ (U-U);\n        //w = vec2(50.);         //  works       \n    float v;\n    \n#if 1\n    if (U.x<0.) v = smoothstep(-w.y,w.y, U.y );     // works\n    else        v = smoothstep(-w  ,w  , U   ).y;   //  bug !  <<<---\n // else        v = smoothstep(-w.y,w.y, U   ).y;   // works\n#else\n    if (U.x<0.) v = smoothstep(-w.y,0.,  U.y );     // works\n    else        v = smoothstep(-w , R-R, U   ).y;   // works   \n#endif\n    \n    fragColor = vec4(v);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 591]], "test": "untested"}
{"id": "3dSBRh", "name": "2D Fractal Brownian Motion Noise", "author": "Zi7ar21", "description": "This is one of my first shaders, thanks to FabriceNeyret and manu210404 for offering advice when I was new to Shadertoy!", "tags": ["2d", "fractal", "noise", "fbm", "brownian", "motion"], "likes": 4, "viewed": 1591, "published": 3, "date": "1589417517", "time_retrieved": "2024-07-30T21:06:52.307357", "image_code": "// ####### 2D Fractal Brownian Motion Noise #######\n// Made by Jacob Bingham (Zi7ar21) on August 1st, 2021 (Original from May 14th, 2020)\n\n// If you found this anywhere except Shadertoy, the orignal (and possibly updated version) can be found at:\n// https://www.shadertoy.com/view/3dSBRh\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.141592653589793\n\n// Rotate a vec2\nvec2 rotate(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(vec.x*c-vec.y*s, vec.x*s+vec.y*c);\n}\n\n// Hash13 Hash without Sine: https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p, float t)\n{\n    vec3 p3 = vec3(p, t);\n    p3  = fract(p3*0.1031);\n    p3 += dot(p3, p3.zyx+31.32);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n// Value Noise\n/*\nfloat noise(vec2 p, float t)\n{\n    vec2 f = smoothstep(0.0, 1.0, fract(p));\n    p = floor(p);\n    float t0 = hash(vec2(0.0, 0.0)+p, t);\n    float t1 = hash(vec2(1.0, 0.0)+p, t);\n    float t2 = hash(vec2(0.0, 1.0)+p, t);\n    float t3 = hash(vec2(1.0, 1.0)+p, t);\n    return mix(mix(t0, t1, f.x), mix(t2, t3, f.x), f.y);\n}\n*/\n\n// manu210404's Improved Version\nfloat noise(vec2 p, float t)\n{\n    vec4 b = vec4(floor(p), ceil(p));\n    vec2 f = smoothstep(0.0, 1.0, fract(p));\n    return mix(mix(hash(b.xy, t), hash(b.zy, t), f.x), mix(hash(b.xw, t), hash(b.zw, t), f.x), f.y);\n}\n\n// Number of FBM Octaves\n#define num_octaves 16\n\n// Fractal Brownian Motion Noise\nfloat fbm(vec2 pos)\n{\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n    float t = 0.0;\n    for(int i = 0; i < num_octaves; i++)\n    {\n        t += atten;\n        value += noise(pos*scale, float(i))*atten;\n        scale *= 2.0;\n        atten *= 0.5;\n        pos = rotate(pos, 0.125*pi);\n    }\n    return value/t;\n}\n\n// Traditional Uniform Identifiers\n#define resolution iResolution\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(gl_FragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Render the Frame\n    vec3 color = vec3(fbm(10.0*uv));\n\n    // Output the Rendered Frame\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 434, 468, 468, 559], [561, 628, 657, 657, 782], [1127, 1160, 1190, 1190, 1376], [1427, 1460, 1481, 1481, 1796], [1865, 1896, 1951, 1980, 2199]], "test": "untested"}
{"id": "tsjBzz", "name": "Perlin Noise Example", "author": "peterekepeter", "description": "Perlin noise implementation", "tags": ["noise"], "likes": 4, "viewed": 726, "published": 3, "date": "1589411625", "time_retrieved": "2024-07-30T21:06:53.178029", "image_code": "\n// Defines\n\n#define COLOR_SKY vec3(.1,.2,.6)\n#define COLOR_CLOUDS vec3(.98,.96,.92)\n#define COLOR_LIGHT_SOMETHING vec3(.01,0.1,.11)*.1\n#define COLOR_DARK_SOMETHING vec3(.41,.71,.81)*2.0\n#define SCREEN_GAMMA 2.2\n\n// Function prototypes\n\nfloat hash(float value); // Produces random values\nfloat hash(vec2 value); // Produces random values\nmat2 rotate2D(float a); // Returns 2D rotation matrix\nfloat perlin_noise(vec2 position); // Single layer of perlin noise\nfloat fractal_perlin_noise(vec2 position, int octaves); // Multiple layers\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 position = uv;\n    \n\t// Rotate and translate the camera using some random sine waves\n\tposition*=rotate2D(iTime*.1)*pow(2.0,sin(iTime*.1));\n\tposition = position*7.0+sin(vec2(iTime, iTime+2.0));\n    \n    // This is where the texture is sampled.\n\tfloat noise_value = fractal_perlin_noise(position*.25, 16);\n\n    // Apply gradient 1 which makes it look like clouds\n    vec3 col = mix(COLOR_CLOUDS, COLOR_SKY, smoothstep(.2,.5,noise_value));\n\n    // Apply another gradient\n    vec3 col2 = mix(COLOR_LIGHT_SOMETHING, COLOR_DARK_SOMETHING, \n\t\tmix(noise_value,pow(abs(fract(noise_value*16.0+iTime*.5)-(.5))*2.0,16.0),.5));\n    \n    // Mix between the two gradients\n\tcol=mix(col,col2, smoothstep(-.4,.4, sin(iTime+uv.x*.2))); // comment out for clouds only\n    \n    // Gamma correction\n\tcol=pow(col, vec3(1.0/SCREEN_GAMMA));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nmat2 rotate2D(float a){\n\tfloat c=cos(a), s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat fractal_perlin_noise(vec2 position, int octaves){\n\tfloat value = 0.0;\n    // Sum together various layers of noise\n\tfor (int i=1; i<octaves; i++)\n\t{\n\t\tfloat scale = pow(2.0,float(i)); // At different scales\n\t\tfloat contrib = 1.0/scale; // Weighted accordint to scale\n\t\tvalue += perlin_noise(position*scale)*contrib;\n\t}\n\treturn value;\n}\n\n// https://en.wikipedia.org/wiki/Perlin_noise\nfloat perlin_noise(vec2 position){\n    // Fractional part is used for interpolation\n\tvec2 fractional_part = fract(position);\n    // Integral part is used for sampling the hash function\n\tvec2 integral_part = position-fractional_part;\n    \n    // Positon of the 4 nearest grid points\n\tvec2 pos_00 = integral_part+vec2(0,0);\n\tvec2 pos_10 = integral_part+vec2(1,0);\n\tvec2 pos_11 = integral_part+vec2(1,1);\n\tvec2 pos_01 = integral_part+vec2(0,1);\n\n\t// Random gradient angle for each point\n\tconst float pi = 3.1415926535;\n\tfloat ang_00=hash(pos_00)*2.0*pi;\n\tfloat ang_10=hash(pos_10)*2.0*pi;\n\tfloat ang_11=hash(pos_11)*2.0*pi;\n\tfloat ang_01=hash(pos_01)*2.0*pi;\n\n\t// Gradient vector for each point\n\tvec2 grad_00 = vec2(cos(ang_00), sin(ang_00));\n\tvec2 grad_10 = vec2(cos(ang_10), sin(ang_10));\n\tvec2 grad_11 = vec2(cos(ang_11), sin(ang_11));\n\tvec2 grad_01 = vec2(cos(ang_01), sin(ang_01));\n\n\t// Distance to each point\n\tvec2 dist_00 = vec2(0,0) - fractional_part;\n\tvec2 dist_10 = vec2(1,0) - fractional_part;\n\tvec2 dist_11 = vec2(1,1) - fractional_part;\n\tvec2 dist_01 = vec2(0,1) - fractional_part;\n\n\t// Dot products and interpolation\n\treturn mix(\n\t\tmix(dot(dist_00, grad_00),dot(dist_10, grad_10),smoothstep(0.0, 1.0, fractional_part.x)),\n\t\tmix(dot(dist_01, grad_01),dot(dist_11, grad_11),smoothstep(0.0, 1.0, fractional_part.x)),\n\t\tsmoothstep(0.0, 1.0, fractional_part.y)\n\t)*.5+.5;\n}\n\nfloat hash(vec2 v) \n{ \n    // Random numbers thrown together to produce other random numbers\n    return fract(hash(v.x*.97+v.y*.98)*143.94213); \n}\n\nfloat hash(float v) \n{ \n    // Even more pseudo randomness\n    return fract(fract(v*11.3334)*fract(v*91.73362341)*43.123*429.32234643);  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 535, 592, 628, 1551], [1553, 1553, 1576, 1576, 1629], [1631, 1631, 1686, 1686, 1971], [1973, 2019, 2053, 2102, 3397], [3399, 3399, 3420, 3491, 3545], [3547, 3547, 3569, 3605, 3686]], "test": "untested"}
{"id": "tdjfzR", "name": "costasArray2", "author": "ollj", "description": "hmmm i would need a 3d costas array?\n\nhttps://en.wikipedia.org/wiki/Primitive_root_modulo_n", "tags": ["dither", "costas", "costasarray"], "likes": 2, "viewed": 479, "published": 3, "date": "1589409695", "time_retrieved": "2024-07-30T21:06:54.031749", "image_code": "//self: https://www.shadertoy.com/view/tdjfzR\n/*\ncostas array is pattern free\nIn theory ideal for dithering\nThe greyscaling gradient is BASIC, and can easily be more distorted\n,by adding any ;u.x+=u.y*b; b!=0 offset\n*/\n\n#define base1 2.\n#define period 29.\n//the pairs (3,5) (3,7) (5,7)  make costas arrays\n//the pairs (2,11) (2,13) (2,29) look a lot like they make costas arrays\n//the function below fails for too large [base1] values\n//and it breaks for period>=37\n#define base2 base1\n\n#define zoom (iResolution.y/period)\n\n//welch-construction of costas array both inputs are primes.\n//original by ollj, faster variant by FabriceNeyret2 \n//because foercing i into type int is irrelevant \n//within the small precision of pow() in 32 bit.\nfloat CostasWelch(float x,float b){\n // return mod( round(      exp2(mod(x,period)) ) , period );\n   return mod( round(     pow(b,mod(x,period)) ) , period );      // not exactly indentical\n // return float(int( .5 + pow(b,mod(x,period)) ) % int(period));  // not exactly indentical\n // return float(int(round(pow(b,mod(x,period)))) % int(period));  // original\n}\n\nvoid mainImage(out vec4 O, vec2 u\n){//u=u.yx\n ;float c=0.\n ;if(u.x<(period-1.)*zoom\n   &&u.y<(period-1.)*zoom\n ){\n  ;u=floor(u/zoom)\n  ;c=CostasWelch(u.x,base1)\n  ;if(mod(floor(iTime),2.)==1.\n  ){if(u.y+1.==c)c=period-1.;else c=0.;}//monochrome\n  else  c=mod(-c+u.y,period+1.)       //greyscale\n  ;\n  ;\n  ;if(mod(floor(iTime),3.)==1.\n  ){ \n  ;\n  ;//+1 iteration to break the linear gradient\n  ;c=CostasWelch(c,base2)//maybe a different base, that is a costas array (of same period)\n  ;if(mod(floor(iTime),2.)==1.\n  ){if(u.y+1.==c)c=period-1.;else c=0.\n   ;}\n  else  c=mod(-c+u.y,period+1.)\n  ;}\n/**/\n  ;\n  ;c=c/(period-2.)//gradient\n  ;}\n ;O=vec4(c,c,c,1.0)\n ;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[524, 738, 773, 835, 1101], [1103, 1103, 1139, 1147, 1764]], "test": "untested"}
{"id": "td2fRR", "name": "PixelScreenTest", "author": "3ck5t3r", "description": "Buffer A is a 301's Fire Shader - Remix 3 (https://www.shadertoy.com/view/4ttGWM)\n\nMy first shader", "tags": ["flame", "fire", "screen", "pixelate"], "likes": 19, "viewed": 956, "published": 3, "date": "1589397464", "time_retrieved": "2024-07-30T21:06:54.928348", "image_code": "//This block of colorspace conversion from https://gist.github.com/prusnak/15e01f0d2b525c0fda416e6d5a77cce6\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//----------------------------------------------------------------------\n\nfloat pixelSize = 10.0;\nfloat pixelPrecision = 3.0;\n\nvec4 pix(vec2 fragCoord)\n{   \n    vec2 st = vec2(0.0);\n    vec4 color = vec4(0.0);\n    vec4 thisColor = vec4(0.0);\n    vec2 pixel = fragCoord - vec2(ivec2(fragCoord.xy) % int(pixelSize));\n    float precisePixel = floor(pixelSize / pixelPrecision);\n    \n    for(float i = 0.0; i < pixelPrecision; i++)\n    {     \n    \tst = (pixel + precisePixel * i) / iResolution.xy;\n        thisColor = texture(iChannel0, st);\n        color += thisColor;\n    }\n    \n    color = color / pixelPrecision;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = pix(fragCoord);\n    \n        //Desaturation\n    vec3 F = vec3(.2126, .7152, .0722);\n    vec3 frg = fragColor.rgb;\n    fragColor = vec4(vec3(dot(frg,F)), 1);\n    \n    \t//Color\n    fragColor *= vec4(0.3, 0.9, 1.0, 1.0) * 1.0;\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    hsv.y = -exp2((fragColor.z + 0.0) * 1.0) + 2.3;\n    fragColor = vec4(hsv2rgb(hsv), 0.1) * 2.3;\n\n    \t//Pixel frames\n    vec4 border = vec4(0.0);\n    if ((int(fragCoord.y) % int(pixelSize) == int(0)) || (int(fragCoord.x) % int(pixelSize) == int(0)))\n    {\n        border = texture(iChannel0, (fragCoord.xy + vec2(2.0)) / iResolution.xy);\n        fragColor -= vec4(border.xyz*0.8, 1.0);\n    }\n    \n    fragColor *= 0.4;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// I started working a bit on the colors of Remix 2, ended up with something like this. :)\n// Remix 2 here: https://www.shadertoy.com/view/MtcGD7\n// Remix 1 here: https://www.shadertoy.com/view/llc3DM\n// Original here: https://www.shadertoy.com/view/XsXXRN\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 0.6;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.7;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(0.1, 0.9);\n    float shift = 1.327+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p += sin(p.yx*4.0+vec2(.2,-.3)*iTime)*0.04;\n    p += sin(p.yx*8.0+vec2(.6,+.1)*iTime)*0.01;\n    \n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.3+1.0*sin(iTime+0.5)/2.0);\n    float qb = fbm(p - iTime * 0.4+0.1*cos(iTime)/2.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/2.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/15.0)-4.0;\n    float q4 = fbm(p - iTime * 1.4 - 20.0*sin(iTime)/14.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(1.0/(pow(c+1.61,vec3(4.0))) * cos(shift * fragCoord.y / iResolution.y));\n    \n    color=vec3(1.0,.2,.05)/(pow((r.y+r.y)* max(.0,p.y)+0.1, 4.0));;\n//    color += (texture(iChannel0,uv*0.6+vec2(.5,.1)).xyz*0.01*pow((r.y+r.y)*.65,5.0)+0.055)*mix( vec3(.9,.4,.3),vec3(.7,.5,.2), uv.y);\n    color = color/(1.0+max(vec3(0),color));\n    fragColor = vec4(color.x, color.y, color.z, alpha);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2fRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 131, 131, 462], [464, 464, 486, 486, 655], [784, 784, 810, 810, 1289]], "test": "untested"}
{"id": "td2BRR", "name": "Value Noise Example", "author": "peterekepeter", "description": "Useful primitive for texturing.", "tags": ["noise2d"], "likes": 3, "viewed": 312, "published": 3, "date": "1589396395", "time_retrieved": "2024-07-30T21:06:55.840909", "image_code": "// Defines\n\n#define COLOR_SKY vec3(.1,.2,.6)\n#define COLOR_CLOUDS vec3(.98,.96,.92)\n#define COLOR_DARK_SOMETHING vec3(.1,.01,.1)\n#define SCREEN_GAMMA 2.2\n\n// Function prototypes\n\nfloat hash(float value); // Produces random values\nfloat hash(vec2 value); // Produces random values\nfloat noise(vec2 position); // A single layer of noise\nfloat value_noise(vec2 position, int octaves); // Multiple layers of noise\nmat2 rotate2D(float a); // Returns 2D rotation matrix\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 position = uv;\n    \n\t// Rotate and translate the camera using some random sine waves\n\tposition*=rotate2D(iTime*.1)*pow(2.0,sin(iTime*.1));\n\tposition = position*7.0+sin(vec2(iTime, iTime+2.0));\n    \n    // Add some distorsion, often used for chaging the texture\n\tfloat distort_amount = sin(iTime*.3)*.5+.5; // set to 0 to disable distorsion\n    position = position + distort_amount*vec2(\n        2.0*value_noise(position*.23+iTime*.1, 8),\n        4.0*value_noise(position*.14-iTime*.1, 8));\n    \n    // This is where the texture is sampled.\n\tfloat noise_value = value_noise(position, 16);\n\tnoise_value=mix(noise_value, value_noise(position*.2+4.0, 16),.5);\n\n    // Apply gradient 1 which makes it look like clouds\n    vec3 col = mix(COLOR_CLOUDS, COLOR_SKY, smoothstep(.2,.7,noise_value));\n\n    // Apply another gradient\n    vec3 col2 = mix(COLOR_CLOUDS, COLOR_DARK_SOMETHING, pow(abs(noise_value-(sin(iTime*2.0)*.1+.5))*2.0,.2));\n    \n    // Mix between the two gradients\n\tcol=mix(col,col2, smoothstep(-.2,.2, sin(iTime+uv.x*.2))); // cooment out for clouds only\n    \n    // Gamma correction\n\tcol=pow(col, vec3(1.0/SCREEN_GAMMA));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nmat2 rotate2D(float a){\n\tfloat c=cos(a), s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\n// https://en.wikipedia.org/wiki/Value_noise\nfloat value_noise(vec2 position, int octaves){\n\tfloat value = 0.0;\n    // Sum together various layers of noise\n\tfor (int i=1; i<octaves; i++)\n\t{\n\t\tfloat scale = pow(2.0,float(i)); // At different scales\n\t\tfloat contrib = 1.0/scale; // Weighted accordint to scale\n\t\tvalue += noise(position*scale)*contrib;\n\t}\n\treturn value;\n}\n\nfloat noise(vec2 position){\n    // Fractional part is used for interpolation\n\tvec2 fractional_part = fract(position);\n    // Integral part is used for sampling the hash function\n\tvec2 integral_part = position-fractional_part;\n    \n    // Generate 4 sample points\n\tfloat sample_00=hash(integral_part);\n\tfloat sample_10=hash(integral_part+vec2(1,0));\n\tfloat sample_11=hash(integral_part+vec2(1,1));\n\tfloat sample_01=hash(integral_part+vec2(0,1));\n    \n    // Interpolate them so we have nice and stable continuous texture\n\treturn mix(\n\t\tmix(sample_00, sample_10, fractional_part.x),\n\t\tmix(sample_01, sample_11, fractional_part.x),\n\t\tfractional_part.y\n\t);\n}\n\nfloat hash(vec2 v) \n{ \n    // Random numbers thrown together to produce other random numbers\n    return fract(hash(v.x*.97+v.y*.98)*143.94213); \n}\n\nfloat hash(float v) \n{ \n    // Even more pseudo randomness\n    return fract(fract(v*11.3334)*fract(v*91.73362341)*43.123*429.32234643);  \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2BRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 522, 558, 1796], [1798, 1798, 1821, 1821, 1874], [1876, 1921, 1967, 1967, 2245], [2247, 2247, 2274, 2323, 2901], [2903, 2903, 2924, 2995, 3049], [3051, 3051, 3073, 3109, 3190]], "test": "untested"}
{"id": "3dlfDs", "name": "Cube + Sphere SDF", "author": "blackle", "description": "generalization of a cube and a sphere, complete with closest-point calculation!", "tags": ["sdf"], "likes": 12, "viewed": 735, "published": 3, "date": "1589378062", "time_retrieved": "2024-07-30T21:06:56.737511", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 nonzero_sign(vec3 p) {\n    return max(sign(p),vec3(0))*2.-1.;\n}\n\nmat3 sort(vec3 p) {\n    mat3 perm = mat3(1);\n    //there must be a more elegant way to do this...\n    if (p.x > p.y) { p.xy = p.yx; perm *= mat3(0,1,0,1,0,0,0,0,1); }\n    if (p.y > p.z) { p.yz = p.zy; perm *= mat3(1,0,0,0,0,1,0,1,0); }\n    if (p.x > p.y) { p.xy = p.yx; perm *= mat3(0,1,0,1,0,0,0,0,1); }\n    return perm;\n}\n\nvec4 rounded_square(vec3 p, float radius, float sharpness, float offset) {\n    //first we abs and sort the vector so we can work with the cube symmetries\n    vec3 sgn = nonzero_sign(p);\n    p = abs(p);\n    mat3 perm = sort(p);\n    p *= perm;\n    p.z += sharpness;\n\n    //get closest point on defining sphere for this axis\n    float rad = sharpness + radius;\n    vec3 closest = normalize(p)*rad;\n\n    //normalize the closest point so it lies within the axis\n    if (closest.y > closest.z-sharpness) {\n        float a = closest.x;\n        float d = closest.y+closest.z;\n        float k = sharpness;\n        float z = (k + sqrt(d*d*(2.*rad*rad-k*k)/(2.*a*a+d*d)))/2.;\n        float y = z - k;\n        float x = a*(2.*z-k)/d;\n        closest = vec3(x,y,z);\n    \tif (closest.x > closest.z-sharpness) {\n            z = (2.*k + sqrt(3.*rad*rad - 2.*k*k))/3.;\n        \ty = z - k;\n            x = z - k;\n        \tclosest = vec3(x,y,z);\n    \t}\n    }\n    //calculate the distance\n    float side = sign(length(p)-rad);\n    float dist = length(p-closest)*side;\n\n    //map the closest point back to global coordinates\n    closest += normalize(p-closest)*offset*side;\n    if (side == 0.) closest = p;\n    vec3 closest_global = (closest-vec3(0,0,sharpness))*transpose(perm)*sgn;\n\n\treturn vec4(dist-offset, closest_global);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r, g*g, b*b);\n}\nvec3 srgb(float k) {\n    return vec3(k*k);\n}\n\nfloat PI = acos(-1.);\nvec3 objcol_glob;\nfloat scene(vec3 p) {\n    float radius = sin(iTime*1.2)*0.2+0.7;\n    float sharpness = pow(asin(sin(iTime*0.7))/PI+1.,8.);\n    float offset = 1.-radius;\n    float dist = rounded_square(p, radius, sharpness, offset).x;\n\tobjcol_glob = srgb(0.5,0.35,0.6);\n    \n    vec3 probe = normalize(vec3(cos(iTime*2.), sin(iTime*2.), cos(iTime*.7)*.3+.3))*2.;\n    vec3 closest = rounded_square(probe, radius, sharpness, offset).yzw;\n    float closestball = length(p-closest)-0.1;\n    float probeball = length(p-probe)-0.1;\n    float probeline = linedist(p, probe, closest) - 0.03;\n    \n    if (closestball < dist) {\n        objcol_glob = srgb(0.2,0.6,0.3);\n        dist = closestball;\n    }\n    if (probeball < dist) {\n        objcol_glob = srgb(0.6,0.2,0.1);\n        dist = probeball;\n    }\n    if (probeline < dist) {\n        objcol_glob = srgb(0.3);\n        dist = probeline;\n    }\n\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(scene(p)- vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\n\nvec3 shade(vec3 n, vec3 r, vec3 cam, float harmonic, vec3 col, vec3 rot) {\n    float ang = length(rot); vec3 ax = normalize(rot);\n    \n    col = abs(erot(col, vec3(0,0,1), ang*0.1));\n    float fresnel = 1.-abs(dot(cam,n))*0.98;\n    r = erot(r, ax, -ang);\n    float spec = length(sin(r*harmonic)*0.5+0.5)/sqrt(3.);\n    return col*pow(spec+.2,3.) + pow(spec, 12.)*fresnel*1.6;\n}\n\nfloat bayer(vec2 uv) {\n    return (texelFetch(iChannel0, ivec2(uv)%8, 0).x - 0.5)/128.;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.6, uv));\n    vec3 init = vec3(-7,0,0);\n\n   \tfloat yrot = 0.5;\n    float zrot = 2.5;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n    }\n    vec3 objcol = objcol_glob;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    \n    vec3 l1 = vec3(0,0,.1);\n    vec3 l2 = vec3(0,1.,0);\n    vec3 l3 = vec3(4.,0,0);\n\n    vec3 col = shade(n, r, cam, 2., objcol, l1);\n    vec3 bg = shade(cam, cam, vec3(0), 2., srgb(0.3), l1);\n    col += shade(n, r, cam, 3.3, objcol, l2)*.6;\n    bg += shade(cam, cam, vec3(0), 3.3, srgb(0.1), l2)*.6;\n    col += shade(n, r, cam, 4., objcol, l3)*.3;\n    bg += shade(cam, cam, vec3(0), 4., srgb(0.3), l3)*.3;\n    fragColor.xyz = sqrt(hit ? col : bg*.4) + bayer(fragCoord);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfDs.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 221, 221, 262], [264, 264, 283, 283, 587], [589, 589, 663, 742, 1897], [1899, 1899, 1939, 1939, 2030], [2032, 2032, 2070, 2070, 2104], [2105, 2105, 2125, 2125, 2149], [2191, 2191, 2212, 2212, 3081], [3083, 3083, 3102, 3102, 3221], [3223, 3223, 3261, 3261, 3327], [3330, 3330, 3404, 3404, 3706], [3708, 3708, 3730, 3730, 3797], [3799, 3799, 3825, 3825, 3916], [3918, 3918, 3975, 3975, 5207]], "test": "untested"}
{"id": "tssBDX", "name": "cartoonish fire", "author": "yuntaRobo", "description": "Fire effect with curl noise.\nBy using POW to compose the buffer, I was able to get a cartoonish look.\nHowever, the adjustment of the values is very sensitive.", "tags": ["2d", "noise", "cartoon", "fire", "curl"], "likes": 48, "viewed": 1354, "published": 3, "date": "1589370716", "time_retrieved": "2024-07-30T21:06:57.607186", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).xyz, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI = 3.1415926;\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat anim(float f, float speed)\n{\n    return sin(f * PI * 2.0 + iTime * speed) * 0.5 + 0.5;\n}\n\nfloat noiseValue2D(vec2 p, float s, float speed)\n{\n    p *= s;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * f * (f * (6.0 * f - 15.0) + 10.0);\n    float r1 = anim(hash12(i + vec2(0.0, 0.0)), speed);\n    float r2 = anim(hash12(i + vec2(1.0, 0.0)), speed);\n    float r3 = anim(hash12(i + vec2(0.0, 1.0)), speed);\n    float r4 = anim(hash12(i + vec2(1.0, 1.0)), speed);\n    return mix(mix(r1, r2, f.x), mix(r3, r4, f.x), f.y);\n}\n\nfloat noiseValueFbm2D(vec2 p, float s, float speed, int octaves, float amplitude)\n{\n    float o, mx = 0.0;\n    for(int i = 0; i >= 0; i++)\n    {\n        if(i >= octaves)\tbreak;\n        float a = pow(amplitude, float(i));\n        o += a * noiseValue2D(p, s * exp2(float(i)), speed);\n        mx += a;\n    }\n    return o / mx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = iResolution.xy;\n\n\tvec2 p = (fragCoord * 2.0 - r) / r.y;\n\tvec2 uv = fragCoord / r;\n\n\t// curl noise\n//\tfloat e = 10.0 / r.y;\n    float e = 0.0225; \n\tfloat s = 4.0;\n\tfloat speed = 6.0;\n\tint octaves = 5;\n    float amplitude = 0.5;\n\tfloat f1 = noiseValueFbm2D(p + vec2(e, 0.0), s, speed, octaves, amplitude);\n\tfloat f2 = noiseValueFbm2D(p + vec2(-e, 0.0), s, speed, octaves, amplitude);\n\tfloat f3 = noiseValueFbm2D(p + vec2(0.0, e), s, speed, octaves, amplitude);\n\tfloat f4 = noiseValueFbm2D(p + vec2(0.0, -e), s, speed, octaves, amplitude);\n\tvec2 v = vec2(f3 - f4, -f1 + f2) * 0.01;\n\tv.y += 0.00225;\n\tv += normalize(p) * length(p) * 0.001;\n\n    // distance field\n    vec2 center = p + vec2(sin(iTime+PI), 0.0);\n    float radius = 0.7;\n\tfloat a = atan(center.y, center.x);\n\tfloat d1 = abs(length(center) - radius / 2.0) - 0.0075;\n    float offset = smoothstep(0.5, 1.0, sin((a + sin(iTime) / radius) * 10.0)) * 0.05;\n\tfloat d2 = abs(length(center) - radius + offset) - 0.01;\n    d2 = min(d2, abs(p.y + radius) - 0.002);\n\n\t// coloring\n\tvec3 c = vec3(smoothstep(0.02, -0.02, d1)) * vec3(0.4, 0.6, 1.0);\n\tc += vec3(smoothstep(0.02, -0.02, d2)) * vec3(1.0, 0.7, 0.5);\n    \n    // buffer composition\n\tc += pow(texture(iChannel0, uv - v).xyz, vec3(1.75));\n\n\tfragColor=vec4(min(c, 1.0), 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 135]], "test": "untested"}
{"id": "tsGXDG", "name": "template_matching", "author": "ich", "description": "see how similar (green) regions of a gray scale image (red) are compared to a user defined region (blue) (use mouse).\nsplit into 3 sections (algorithms):\nleft: absolute difference\ncenter: maximum difference\nright: euclidean difference", "tags": ["templatematching"], "likes": 3, "viewed": 389, "published": 3, "date": "1589365049", "time_retrieved": "2024-07-30T21:06:58.644413", "image_code": "#define pi 3.141\n\n#define SENSITIVITY 1.0\n#define FILTER_SIZE 0.02\n\nfloat absolute_difference(vec2 uv, vec2 tr, vec2 to)\n{\n\tfloat sum = 0.;\n    float count = 0.;\n    for (float x = -tr.x; x < tr.x; x += 1. / iResolution.x) {\n        for (float y = -tr.y; y < tr.y; y += 1. / iResolution.y) {\n            vec2 o = vec2(x, y);\n            float c0 = texture(iChannel0, uv + o).r;\n            float c1 = texture(iChannel0, to + o).r;\n       \t\tsum += abs(c0 - c1);\n            ++count;\n        }\n    }\n    return sum / count;\n}\n\nfloat maximum_difference(vec2 uv, vec2 tr, vec2 to)\n{\n\tfloat m = 0.;\n    for (float x = -tr.x; x < tr.x; x += 1. / iResolution.x) {\n        for (float y = -tr.y; y < tr.y; y += 1. / iResolution.y) {\n            vec2 o = vec2(x, y);\n            float c0 = texture(iChannel0, uv + o).r;\n            float c1 = texture(iChannel0, to + o).r;\n       \t\tm = max(m, abs(c0 - c1));\n        }\n    }\n    return m;\n}\n\nfloat euclidean_difference(vec2 uv, vec2 tr, vec2 to)\n{\n\tfloat sum = 0.;\n    float count = 0.;\n    for (float x = -tr.x; x < tr.x; x += 1. / iResolution.x) {\n        for (float y = -tr.y; y < tr.y; y += 1. / iResolution.y) {\n            vec2 o = vec2(x, y);\n            float c0 = texture(iChannel0, uv + o).r;\n            float c1 = texture(iChannel0, to + o).r;\n       \t\tsum += (c0 - c1) * (c0 - c1);\n            ++count;\n        }\n    }\n    return pow(sum, .5) / count;\n}\n\nfloat rect(vec2 uv)\n{\n\tuv = abs(uv);\n    return max(uv.x, uv.y);\n}\n\nfloat line(vec2 uv, float a)\n{\n\tvec2 d = vec2(cos(a), sin(a));\n\tfloat l = dot(uv, d);\n\treturn abs(l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 tr = vec2(FILTER_SIZE);\n    //vec2 to = vec2(sin(iTime * .1) * .3);\n    vec2 to = iMouse.xy / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    float d = 0.;\n    float a = atan(uv.x, uv.y);\n    if (uv.x < 1. / 3.)\n   \t\td = absolute_difference(uv, tr, to) * 5.;\n    else if (uv.x < 2. / 3.)\n    \td = maximum_difference(uv, tr, to) * 1.9;\n    else\n    \td = euclidean_difference(uv, tr, to) * 90.;\n    \n    col.r += texture(iChannel0, uv).r;\n    col.g += smoothstep(SENSITIVITY, 0., d);\n    col.rg += smoothstep(.005, 0., line(uv - vec2(1./3., 0), 0.));\n    col.rg += smoothstep(.005, 0., line(uv - vec2(2./3., 0), 0.));\n    \n    col.b += rect((uv - to) / tr) - 1. < 0. ? 1. : 0.;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 122, 122, 523], [525, 525, 578, 578, 929], [931, 931, 986, 986, 1405], [1407, 1407, 1428, 1428, 1473], [1475, 1475, 1505, 1505, 1578], [1580, 1580, 1637, 1637, 2410]], "test": "untested"}
{"id": "wsBfzz", "name": "fracdemo3", "author": "okh0056", "description": "self modifying formula", "tags": ["fractaldemo"], "likes": 2, "viewed": 381, "published": 3, "date": "1589356092", "time_retrieved": "2024-07-30T21:06:59.682637", "image_code": "\n#define time iTime\nmat2 mm2(in float a){float c = cot(a), s = sin(a);return mat2(c,-s,s,c);}\n\n\nfloat f(vec2 p, float featureSize)\n{\n\tp.x = cos(p.x*1.3+time*0.09)*tanh(time+p.x*0.13)*2.;\t\n    p += csc(p.x*3.5)*0.4;\n    return smoothstep(-0.01,featureSize,abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    float featureSize = 175./((iResolution.x*aspect+iResolution.y));\n\n    vec2 p = fragCoord.xy / iResolution.xy*2.5;\n\tp.x *= aspect;\n\tp.y = abs(p.y);\n\t\n\tvec3 col = vec3(0);\n\tfor(float i=2.;i<36.;i+=.33)\n\t{\n\t\tvec3 col2 = (cos(vec3(4.5,2.5,3.6)-i*0.45)*0.85)*(1.-f(p,featureSize));\n\t\tcol = max(col,col2);\n\t\t\n        p.x -= XOFF;\n        p.y -= tanh(time*1.81)*3.5;\n\t\tp*= mm2(i*DELTA+ANGLE);\n\t\t\n        vec2 pa = vec2(abs(p.x-0.9),abs(p.y));\n        vec2 pb = vec2(p.x,abs(p.y));\n        \n        p = mix(pa,pb,smoothstep(-.57,.67,log2(time*3.14)-2.1));\n\t}\n\tfragColor = vec4(col,.0);\n}", "image_inputs": [], "common_code": "float sech(float ang) {\n    return 1./cosh(ang);\n}\n\nvec2 sech(vec2 ang) {\n    return 1./cosh(ang);\n}\n\nfloat csch(float ang) {\n    return 1./sinh(ang);\n}\n\nvec2 csch(vec2 ang) {\n    return 1./sinh(ang);\n}\n\nfloat coth(float ang) {\n    return 1./tanh(ang);\n}\n\nvec2 coth(vec2 ang) {\n    return 1./tanh(ang);\n}\n\n#define ANGLE 1.25\n#define DELTA 0.00315\n#define XOFF .99\n\nfloat crd(float ang) {\n    return 2.*sin(ang/2.);\n}\nvec2 crd(vec2 ang) {\n    return 2.*sin(ang/2.);\n}\n\nfloat sec(float ang) {\n    return 1./cos(ang);\n}\nvec2 sec(vec2 ang) {\n    return 1./cos(ang);\n}\n\nfloat csc(float ang) {\n    return 1./sin(ang);\n}\nvec2 csc(vec2 ang) {\n    return 1./sin(ang);\n}\n\nfloat cot(float ang) {\n    return 1./tan(ang);\n}\nvec2 cot(vec2 ang) {\n    return 1./tan(ang);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 41, 41, 93], [96, 96, 132, 132, 267], [269, 269, 326, 326, 958]], "test": "untested"}
{"id": "3dBBzz", "name": "Social Distancing Festival", "author": "positronmusic", "description": "Waiting for the live performance", "tags": ["cineshader"], "likes": 0, "viewed": 16721, "published": 3, "date": "1589334427", "time_retrieved": "2024-07-30T21:07:00.792669", "image_code": "\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    fragColor = vec4(1.0, 1.0, 1.0, noise);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Social Distancing Festival\",\n\t\"description\": \"Counting down to live show.,..\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [191, 191, 212, 212, 2194], [2196, 2196, 2217, 2217, 2435], [2437, 2437, 2494, 2494, 2856]], "test": "untested"}
{"id": "tslfWs", "name": "Rubik's Ball", "author": "tdhooper", "description": "Looping sequence of moves on a 2x2 Rubik's cube, with some follow through animation and sound. I've jumbled the parts so it looks a little more interesting.\n\nUncomment '#define AA' if it's running slow", "tags": ["sound", "animation", "momentum", "rubiks"], "likes": 137, "viewed": 7608, "published": 3, "date": "1589320602", "time_retrieved": "2024-07-30T21:07:02.090200", "image_code": "\n#if HW_PERFORMANCE==1\n#define AA 2\n#endif\n\n\n//========================================================\n// Utils\n//========================================================\n\n// HG_SDF\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// Easings\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nfloat almostIdentity(float x) {\n    return x*x*(2.0-x);\n}\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// rotate on axis, blackle\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//========================================================\n// Animation\n//========================================================\n\n// see common tab for a list of moves (rotations)\n\nbool lightingPass;\nfloat time;\n\nvoid applyMomentum(inout vec4 q, float time, int i, vec4 move) {\n\n    float turns = move.w;\n    vec3 axis = move.xyz;\n\n    float duration = abs(turns);\n    float rotation = PI / 2. * turns * .75;\n\n    float start = float(i + 1);\n    float t = time * MOVE_COUNT;\n    float ramp = range(start, start + duration, t);\n    float angle = circularOut(ramp) * rotation;\n    vec4 q2 = rotate_angle_axis(angle, axis);\n    q = qmul(q, q2);\n}\n\nvoid applyMove(inout vec3 p, int i, vec4 move) {\n\n    float turns = move.w;\n    vec3 axis = move.xyz;\n\n    float rotation = PI / 2. * turns;\n\n    float start = float(i);\n    float t = time * MOVE_COUNT;\n    float ramp = range(start, start + 1., t);\n    ramp = pow(almostIdentity(ramp), 2.5);\n    float angle = ramp * rotation;\n    \n    bool animSide = vmax(p * -axis) > 0.;\n    if (animSide) {\n    \tangle = 0.;\n    }    \n\n    p = erot(p, axis, angle);\n}\n\nvec4 momentum(float time) {\n    vec4 q = QUATERNION_IDENTITY;    \n    applyMomentum(q, time, 5, moves[5]);\n    applyMomentum(q, time, 4, moves[4]);\n    applyMomentum(q, time, 3, moves[3]);\n    applyMomentum(q, time, 2, moves[2]);\n    applyMomentum(q, time, 1, moves[1]);\n    applyMomentum(q, time, 0, moves[0]);\n    return q;\n}\n\nvec4 momentumLoop(float time) {\n    vec4 q;\n    \n    // end state\n    q = momentum(3.);\n    q = q_conj(q);\n    q = q_slerp(QUATERNION_IDENTITY, q, time);\n    \n    // next loop\n    q = qmul(momentum(time + 1.), q);\n   \n\t// current loop\n\tq = qmul(momentum(time), q);\n    \n    return q;\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nvec4 mapBox(vec3 p) {\n\n    // shuffle blocks\n    pR(p.xy, step(0., -p.z) * PI / -2.);\n    pR(p.xz, step(0., p.y) * PI);\n\tpR(p.yz, step(0., -p.x) * PI * 1.5);\n    \n    // face colors\n    vec3 face = step(vec3(vmax(abs(p))), abs(p)) * sign(p);\n    float faceIndex = max(vmax(face * vec3(0,1,2)), vmax(face * -vec3(3,4,5)));\n    vec3 col = spectrum(faceIndex / 6. + .1 + .5);\n    \n    // offset sphere shell\n    float thick = .033;\n    float d = length(p + vec3(.1,.02,.05)) - .4;\n    d = max(d, -d - thick);\n    \n    // grooves\n    vec3 ap = abs(p);\n    float l = sqrt(sqrt(1.) / 3.);\n    vec3 plane = cross(abs(face), normalize(vec3(1)));\n    float groove = max(-dot(ap.yzx, plane), dot(ap.zxy, plane));\n    d = smax(d, -abs(groove), .01);\n    \n    float gap = .005;\n    \n    // block edge\n    float r = .05;\n    float cut = -fBox(abs(p) - (1. + r + gap), vec3(1.)) + r;\n    d = smax(d, -cut, thick / 2.);\n\n    // adjacent block edge bounding\n    float opp = vmin(abs(p)) + gap;\n    opp = max(opp, length(p) - 1.);\n    if (opp < d) {\n        return vec4(opp, vec3(-1));\n    }\n\n    return vec4(d, col * .4);\n}\n\nvec4 map(vec3 p) {\n\n    if (iMouse.x > 0.) {\n    \tpR(p.yz, ((iMouse.y / -iResolution.y) * 2. + 1.) * 2.);\n    \tpR(p.xz, ((iMouse.x / -iResolution.x) * 2. + 1.) * 4.);\n    }\n\n    //p.z *= -1.;\n    pR(p.xz, time * PI * 2.);\n    //pR(p.yz, time * PI * -2.);\n    //pR(p.xy, PI);\n    \n    vec4 q = momentumLoop(time);\n    p = rotate_vector(p, q);\n\n    applyMove(p, 5, moves[5]);\n    applyMove(p, 4, moves[4]);\n    applyMove(p, 3, moves[3]);\n    applyMove(p, 2, moves[2]);\n    applyMove(p, 1, moves[1]);\n    applyMove(p, 0, moves[0]);\n       \n    return mapBox(p);\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\n\n\n// origin sphere intersection\n// returns entry and exit distances from ray origin\nvec2 iSphere( in vec3 ro, in vec3 rd, float r )\n{\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\n    // iq optimisation, stop looking for occluders when we\n    // exit the bounding sphere for the model\n    vec2 bound = iSphere(ro, rd, .55);\n    tmax = min(tmax, bound.y);\n    \n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<100; i++ )\n    {\n        vec4 hit = map( ro + rd*t );\n        float h = hit.x;\n        if (hit.y > 0.) { // don't create shadows from bounding objects\n            res = min( res, 10.0*h/t );\n        }\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render(vec2 p) {\n    \n    vec3 col = vec3(.02,.01,.025);\n    \n    // raymarch\n\n    vec3 camPos = vec3(0,0,2.);\n    mat3 camMat = calcLookAtMatrix( camPos, vec3(0,0,-1), 0.);\n    vec3 rd = normalize( camMat * vec3(p.xy, 2.8) );\n    vec3 pos = camPos;\n    \n    vec2 bound = iSphere(pos, rd, .55);\n    if (bound.x < 0.) {\n    \treturn col;\n    }\n\n    lightingPass = false;\n    float rayLength = bound.x;\n    float dist = 0.;\n    bool background = true;\n    vec4 res;\n\n    for (int i = 0; i < 200; i++) {\n        rayLength += dist;\n        pos = camPos + rd * rayLength;\n        res = map(pos);\n        dist = res.x;\n\n        if (abs(dist) < .001) {\n            background = false;\n            break;\n        }\n\n        if (rayLength > bound.y) {\n            break;\n        }\n    }\n\n    // shading\n    // https://www.shadertoy.com/view/Xds3zN\n    \n    lightingPass = true;\n    \n    if ( ! background) {\n        \n        col = res.yzw;\n        vec3 nor = calcNormal(pos);        \n        vec3 lig = normalize(vec3(-.33,.3,.25));\n        vec3 lba = normalize( vec3(.5, -1., -.5) );\n        vec3 hal = normalize( lig - rd );\n        float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n        // iq optimisation, skip shadows when we're facing away\n        // from the light\n\t\tif( dif > .001) dif *= softshadow( pos, lig, 0.001, .9 );\n        \n        float occ = 1.;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n            dif *\n            (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 2.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 1.55*bac*vec3(0.25,0.25,0.25)*occ*vec3(2,0,1);\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n        col = col*lin;\n\t\tcol += 5.00*spe*vec3(1.10,0.90,0.70);\n    }\n\n    return col;\n}\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float mTime = (iTime + TIME_OFFSET) / LOOP_DURATION;\n    \n    //mTime = .38;\n    time = mTime;    \n    \n    vec2 o = vec2(0);\n    vec3 col = vec3(0);\n\n    // AA and motion blur from iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    \ttime = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n\t\t\n        time = mod(time, 1.);\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.y;\n    \tcol += render(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n    \n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4(col, 0);\n}\n", "image_inputs": [], "common_code": "\n#define LOOP_DURATION 5.\n#define MOVE_COUNT 6.\n#define TIME_OFFSET .3\n\n// axisX, axisY, axisZ, turns \nvec4 moves[6] = vec4[6](\n    vec4(1,0,0, 2.),\n    vec4(0,1,0, -1.),\n    vec4(0,-1,0, -3.),\n    vec4(0,0,-1, 2.),\n    vec4(0,-1,0, -1.),\n    vec4(0,1,0, -3.)\n);\n\n\n// Quaternions\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\n\n#define QUATERNION_IDENTITY vec4(0, 0, 0, 1)\n\n#define PI 3.1415926\n\n// Quaternion multiplication\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 qmul(vec4 q1, vec4 q2) {\n\treturn vec4(\n\t\tq2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n\t\tq1.w * q2.w - dot(q1.xyz, q2.xyz)\n\t);\n}\n\n// Vector rotation with a quaternion\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 rotate_vector(vec3 v, vec4 r) {\n\tvec4 r_c = r * vec4(-1, -1, -1, 1);\n\treturn qmul(r, qmul(vec4(v, 0), r_c)).xyz;\n}\n\n// A given angle of rotation about a given axis\nvec4 rotate_angle_axis(float angle, vec3 axis) {\n\tfloat sn = sin(angle * 0.5);\n\tfloat cs = cos(angle * 0.5);\n\treturn vec4(axis * sn, cs);\n}\n\nvec4 q_conj(vec4 q) {\n\treturn vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 q_slerp(vec4 a, vec4 b, float t) {\n    // if either input is zero, return the other.\n    if (length(a) == 0.0) {\n        if (length(b) == 0.0) {\n            return QUATERNION_IDENTITY;\n        }\n        return b;\n    } else if (length(b) == 0.0) {\n        return a;\n    }\n\n    float cosHalfAngle = a.w * b.w + dot(a.xyz, b.xyz);\n\n    if (cosHalfAngle >= 1.0 || cosHalfAngle <= -1.0) {\n        return a;\n    } else if (cosHalfAngle < 0.0) {\n        b.xyz = -b.xyz;\n        b.w = -b.w;\n        cosHalfAngle = -cosHalfAngle;\n    }\n\n    float blendA;\n    float blendB;\n    if (cosHalfAngle < 0.99) {\n        // do proper slerp for big angles\n        float halfAngle = acos(cosHalfAngle);\n        float sinHalfAngle = sin(halfAngle);\n        float oneOverSinHalfAngle = 1.0 / sinHalfAngle;\n        blendA = sin(halfAngle * (1.0 - t)) * oneOverSinHalfAngle;\n        blendB = sin(halfAngle * t) * oneOverSinHalfAngle;\n    } else {\n        // do lerp if angle is really small.\n        blendA = 1.0 - t;\n        blendB = t;\n    }\n\n    vec4 result = vec4(blendA * a.xyz + blendB * b.xyz, blendA * a.w + blendB * b.w);\n    if (length(result) > 0.0) {\n        return normalize(result);\n    }\n    return QUATERNION_IDENTITY;\n}\n", "sound_code": "\nvec2 rand(vec2 n) {\n    return fract(sin(n) * 43758.5453123) * 2. - 1.;\n}\n\nvec2 srand(vec2 n, float hard) {\n\tvec2 nf = floor(n);\n    vec2 nc = ceil(n);\n    return mix(rand(nf), rand(nc), smoothstep(.5 * hard, 1. - .5 * hard, fract(n)));\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    time += TIME_OFFSET;\n    // shift time to stop clipping at start of move\n    float index = floor((time + .05) / LOOP_DURATION * MOVE_COUNT);\n    float moveIndex = mod(index - 1., MOVE_COUNT);\n    float turns = abs(moves[int(moveIndex)].w);\n    float volume = pow(turns / 3., 1.5);\n    \n    float t = mod(time, LOOP_DURATION);\n    t = mod(t, LOOP_DURATION / MOVE_COUNT);\n    vec2 s = srand(vec2(t * 2.5, t * 2. + .02) * 1000., .0) * exp(-100. * t);\n    s += sin(vec2(t * 5000.) / mix(1.1, 1., rand(vec2(index+.2)).x) / (1. + t * .5)) * exp(-30. * t) * .1;\n\n    return s * volume;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 216, 216, 261], [263, 263, 283, 283, 318], [320, 320, 340, 340, 375], [377, 377, 405, 405, 486], [488, 488, 526, 526, 637], [639, 639, 678, 678, 709], [723, 723, 773, 773, 831], [833, 833, 864, 864, 890], [892, 892, 920, 920, 952], [1017, 1017, 1085, 1085, 1128], [1130, 1130, 1154, 1154, 1252], [1254, 1281, 1319, 1319, 1381], [1598, 1598, 1662, 1662, 2028], [2030, 2030, 2078, 2078, 2483], [2485, 2485, 2512, 2512, 2812], [2814, 2814, 2845, 2845, 3099], [3234, 3234, 3255, 3278, 4341], [4343, 4343, 4361, 4361, 4903], [5038, 5038, 5102, 5102, 5280], [5282, 5328, 5353, 5353, 5631], [5634, 5716, 5765, 5765, 5933], [5935, 5976, 6050, 6050, 6627], [6629, 6629, 6650, 6650, 8680], [8682, 8682, 8702, 8702, 8726]], "test": "untested"}
{"id": "wssfDl", "name": "Blue Noise Stochastic Alpha TAA", "author": "demofox", "description": "Showing blue noise being used for stochastic alpha. Drag mouse to move camera.\nLeft = white noise, Middle = blue noise, Right = interleaved gradient noise\nTop = Raw, Bottom = TAA with alpha 0.1, 3x3 neighborhood color clamp, halton sub pixel jitter.", "tags": ["bluenoise", "stochastictransparency"], "likes": 14, "viewed": 1109, "published": 3, "date": "1589317401", "time_retrieved": "2024-07-30T21:07:03.145379", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pixelColor = texture(iChannel0, uv).rgb;\n\n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // make dividing lines between the panels   \n    float dist2dX = min(abs(fragCoord.x - iResolution.x * 1.0f / 3.0f), abs(fragCoord.x - iResolution.x * 2.0f / 3.0f));\n    float dist2dY = abs(fragCoord.y - iResolution.y * 1.0f / 2.0f);\n    float dist = min(dist2dX, dist2dY);\n    dist = smoothstep(2.0f, 1.0f, dist);\n    pixelColor = mix(pixelColor, vec3(1.0f, 1.0f, 0.0f), dist);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);        \n    \n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// white noise, from https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\n// analytically mipmapped checkerboard pattern from inigo quilez\n// https://iquilezles.org/articles/morecheckerfiltering\nvec2 p( in vec2 x )\n{\n    vec2 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\n// return a filtered checkers pattern\nfloat checkersGradTriangle( in vec2 uv )\n{\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (p(uv+w)-2.0*p(uv)+p(uv-w))/(w*w); // analytical integral (triangle filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;    \n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n};\n    \nbool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }\n    \n    return false;\n}\n    \nbool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > 0.0f && dist < info.dist)\n        {\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.diffuse = diffuse;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool RayVsQuad(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 diffuse, bool doubleSided)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (doubleSided && dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }    \n    \n    return false;\n}\n\nSRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir, int panel, in vec2 pixelPos)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_rayMaxDist;\n    \n    // get a screen space random number to use for stochastic transparency\n    float rng;\n    {\n        int frame = 0;\n        #if ANIMATE_NOISE\n            frame = iFrame % 64;\n        #endif    \n        if ((panel%3) == 0)\n        {\n            // white noise\n            rng = hash13(vec3(pixelPos, float(frame)));\n        }\n        else if ((panel%3) == 1)    \n        {\n            // blue noise\n            rng = texture(iChannel1, pixelPos / 1024.0f).r;\n            rng = fract(rng + c_goldenRatioConjugate * float(frame));\n        }\n        else // if ((panel%3) == 2)\n        {\n            // interleaved gradient noise\n            rng = InterleavedGradientNoise(pixelPos, frame);\n        }\n    }\n\n    // the floor\n    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))\n    {\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        vec2 uv = hitPos.xz / 100.0f;\n        float shade = mix(0.8f, 0.4f, checkersGradTriangle(uv));\n        hitInfo.diffuse = vec3(shade, shade, shade);\n    }\n        \n    // some floating spheres\n\tSRayHitInfo oldHitInfo;\n    \n    oldHitInfo = hitInfo;\n    if (RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f)))\n    {\n        float alpha = 0.2f;\n        if (rng > alpha)\n            hitInfo = oldHitInfo;\n    }\n    \n    oldHitInfo = hitInfo;\n    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f)))\n    {\n        float alpha = 0.4f;\n        if (rng > alpha)\n            hitInfo = oldHitInfo;\n    }\n    \n    oldHitInfo = hitInfo;\n    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f)))\n    {\n        float alpha = 0.6f;\n        if (rng > alpha)\n            hitInfo = oldHitInfo;\n    }        \n    \n    oldHitInfo = hitInfo;\n    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f)))\n    {\n        float alpha = 0.8f;\n        if (rng > alpha)\n            hitInfo = oldHitInfo;\n    }        \n    \n    oldHitInfo = hitInfo;\n    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f)))\n    {\n        float alpha = clamp((sin(float(iFrame % 120) / 120.0f * 2.0f * c_pi) * 0.75f + 0.5f), 0.0f, 1.0f);\n        if (rng > alpha)\n            hitInfo = oldHitInfo;\n    }        \n\n    \n    return hitInfo;\n}\n\nvec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance, int panel, in vec2 pixelPos)\n{\n    // trace primary ray\n\tSRayHitInfo hitInfo = RayVsScene(rayPos, rayDir, panel, pixelPos);\n    \n    // set the hitDistance out parameter\n    hitDistance = hitInfo.dist;\n    \n    if (hitInfo.dist == c_rayMaxDist)\n        return texture(iChannel0, rayDir).rgb;\n    \n    // calculate where the pixel is in world space\n\tvec3 hitPos = rayPos + rayDir * hitInfo.dist;\n    hitPos += hitInfo.normal * c_hitNormalNudge;\n\n    // shoot a shadow ray    \n    SRayHitInfo shadowHitInfo = RayVsScene(hitPos, c_lightDir, panel, pixelPos);\n    float shadowTerm = (shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f;\n    \n    // do diffuse lighting\n    float dp = clamp(dot(hitInfo.normal, c_lightDir), 0.0f, 1.0f);\n\treturn c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);    \n    \n    // calculate sub pixel jitter for anti aliasing\n    vec2 subPixelJitter = (fragCoord.y < iResolution.y * 0.5f) ? halton(iFrame % 16 + 1) - 0.5f : vec2(0.0f, 0.0f);\n    \n    // calculate the ray direction for this pixel\n    vec2 uv = (fragCoord + subPixelJitter)/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    int panel = 0;\n    vec3 rayDir;\n    {   \n        panel = int(dot(floor(uv*3.0f), vec2(1.0f, 3.0f)));\n        \n\t\tvec2 screen = fract(uv*vec2(3.0f, 2.0f)) * 2.0f - 1.0f;\n        screen.y *= 3.0f / (2.0f * aspectRatio);\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // do rendering for this pixel\n    float rayHitTime;\n    vec3 pixelColor = GetColorForRay(cameraPos, rayDir, rayHitTime, panel, fragCoord);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 center = texture(iChannel0, uv).rgb;\n    \n    // top half of the screen shouldn't get TAA\n    if (uv.y > 0.5f)\n    {\n        fragColor = vec4(center, 1.0f);\n        return;\n    }\n\n    // get the neighborhood min / max from this frame's render\n    vec3 minColor = center;\n    vec3 maxColor = center;\n    for (int iy = -1; iy <= 1; ++iy)\n    {\n        for (int ix = -1; ix <= 1; ++ix)\n        {\n            vec2 offsetUV = ((fragCoord + vec2(ix, iy)) / iResolution.xy);\n            vec3 color = texture(iChannel0, offsetUV).rgb;\n            minColor = min(minColor, color);\n            maxColor = max(maxColor, color);\n        }\n    }\n    \n    // get last frame's pixel and clamp it to the neighborhood of this frame\n    vec3 old = texture(iChannel1, uv).rgb;    \n    old = max(minColor, old);\n    old = min(maxColor, old);\n    \n    // interpolate from the clamped old color to the new color.\n    // Forget all history when the mouse moves though.\n    float lerpAmount = (iMouse.z > 0.0f) ? 1.0f : 0.1f;\n    vec3 pixelColor = mix(old, center, lerpAmount);        \n    fragColor = vec4(pixelColor, 1.0f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ANIMATE_NOISE 1\n\nconst int c_numShadowRays = 16;  // blue noise will use 64 samples max. white noise will use however many you specify here.\n#define c_lightDir normalize(vec3(0.3f, 1.0f, -0.5f))\nconst vec3 c_lightColor = vec3(1.0f, 0.8f, 0.5f);\nconst vec3 c_lightAmbient = vec3(0.05f, 0.05f, 0.05f);\nconst float c_lightRadius = 0.1f; // radius of light disk at 1 unit away\n\n\n\n\n\n\n\n// =================================================================\n\nconst float c_pi = 3.14159265359f;\nconst float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n\nconst float c_FOV = 90.0f; // in degrees\nconst float c_cameraDistance = 100.0f;\nconst float c_minCameraAngle = c_pi / 2.0f;\nconst float c_maxCameraAngle = c_pi;\nconst vec3 c_cameraAt = vec3(0.0f, 20.0f, 0.0f);\nconst float c_rayMaxDist = 10000.0f;\n\nconst vec2 c_defaultMousePos = vec2(0.0f / 800.0f, 250.0f / 450.0f);\n\nconst float c_hitNormalNudge = 0.1f;\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssfDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 792]], "test": "untested"}
{"id": "3slfDl", "name": "Sepia Effect Filter", "author": "rasool_ghana", "description": "Sepia effect gives your images a warm brownish tone.\n\nthis code is written based on FFMPEG's colorchannelmixer filter\nFFMPEG command line for same effect : \ncolorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131\n", "tags": ["filter", "sepia", "ffmpeg"], "likes": 3, "viewed": 1827, "published": 3, "date": "1589298149", "time_retrieved": "2024-07-30T21:07:03.987128", "image_code": "// Writer : Rasool Ghana <rasool.ghana@gmail.com>\n// Sepia effect gives your images a warm brownish tone.\n// Sepia filter improves the general look and feel of your image.\n// Sepia tone photos appear hazy, warm, and a bit sentimental.\n\n// this code is written based on FFMPEG's colorchannelmixer filter\n// FFMPEG command line for same effect : \n// colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    vec4 texColor = texture(iChannel0,xy);\n    \n    float rr = .3;\n    float rg = .769;\n    float rb = .189;\n    float ra = 0.0;\n    \n    float gr = .3;\n    float gg = .686;\n    float gb = .168;\n    float ga = 0.0;\n    \n    float br = .272;\n    float bg = .534;\n    float bb = .131;\n    float ba = 0.0;\n    \n    float red = (rr * texColor.r) + (rb * texColor.b) + (rg * texColor.g) + (ra * texColor.a);\n    float green = (gr * texColor.r) + (gb * texColor.b) + (gg * texColor.g) + (ga * texColor.a);\n    float blue = (br * texColor.r) + (bb * texColor.b) + (bg * texColor.g) + (ba * texColor.a);\n    \n    texColor = vec4(red,green,blue,1.0);\n    \n    fragColor = texColor;\n\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[416, 416, 473, 473, 1191]], "test": "untested"}
{"id": "tdsfWl", "name": "circles, push, pull", "author": "elenzil", "description": "was working on something else and made this instead.", "tags": ["circles", "pushing", "pulling"], "likes": 8, "viewed": 429, "published": 3, "date": "1589297459", "time_retrieved": "2024-07-30T21:07:04.957533", "image_code": "\n\n\nmat2 rot(in float rads) {\n    return mat2(sin(rads), cos(rads), -cos(rads), sin(rads));\n}\n\nfloat trapezoid(in float t) {\n    /*\n            t    f(t)\n            0    0\n            1    1\n            2    1\n            3    0\n    */\n\n    if (t < 1.0) {\n        return t;\n    }\n    if (t < 2.0) {\n        return 1.0;\n    }\n    if (t < 3.0) {\n        return 1.0 - (t - 2.0);\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    RGBA.a   = 1.0;\n\n    // float rad = (sin(iTime * 0.1) * 0.5 + 0.5) * 200.0 + 100.0;\n\n    vec2 md = abs(iMouse.xy - iResolution.xy / 2.0) / (iResolution.xy / 2.0);\n    if (length(iMouse.xy) < 50.0) {\n        md = vec2(0.8, 0.8);\n    }\n    float rad = mix(10.0, 80.0, md.x);\n    \n    float cd = length(XY - iResolution.xy / 2.0) / (iResolution.x / 2.0);\n    rad *= mix(1.0, 0.5, cd);\n\n    float lw  = 5.0;\n\n    XY -= iResolution.xy * 0.5;\n    XY *= rot(-iTime * 0.02);\n\n    vec3 cot = vec3(0.7);\n    vec3 cin = vec3(0.8);\n\n    vec2 xy = XY;\n    int it = int(iTime);\n    if (XY.x > -rad / 2.0 && XY.x < rad / 2.0) {\n        cin = vec3(1.0);\n        xy.y += rad * trapezoid(mod(iTime      , 4.0)) - 0.5;\n    }\n    if (XY.y > -rad / 2.0 && XY.y < rad / 2.0) {\n        cin = vec3(1.0);\n        xy.x += rad * trapezoid(mod(iTime + 1.0, 4.0)) - 0.5;\n    }\n\n    /*\n    ivec2 ij = ivec2(xy / rad);\n    if (ij.x == ij.y && ij.x == 0) {\n        cin = vec3(1.0, 0.0, 0.0);\n    }\n    */\n\n\n    // cin *= sin(length(xy) * 0.1) * 0.2 + 0.8;\n\n    // xy.y += sin((XY.x / rad + 0.5) * 3.1415 * 5.0 + iTime) * 2.0;\n    // xy.x += sin((XY.y / rad + 0.5) * 3.1415 * 5.0 + iTime) * 2.0;\n\n    vec2 uv = (mod(xy - rad/2.0, rad) - rad/2.0) * 2.0;\n\n\n    float c = smoothstep(0.0, lw, abs(rad - length(uv) - 2.0 * lw / 2.0));\n    vec3 rgb = vec3(c);\n\n    if (length(uv) > rad - lw) {\n        rgb *= cot;\n    }\n    else if (length(uv) < rad - lw) {\n        rgb *= cin;\n    }\n\n    \n\n    RGBA.rgb = rgb;\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 28, 28, 92], [94, 94, 123, 235, 399], [401, 401, 444, 444, 1922]], "test": "untested"}
{"id": "3slBDl", "name": "Square + Circle SDF", "author": "blackle", "description": "an exact SDF that generalizes the circle and the square. it can also give the closest point on the surface!", "tags": ["sdf"], "likes": 9, "viewed": 634, "published": 3, "date": "1589286687", "time_retrieved": "2024-07-30T21:07:05.765373", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec2 nonzero_sign(vec2 p) {\n    return max(sign(p),vec2(0))*2.-1.;\n}\n\nmat2 sort(vec2 p) {\n    if (p.x > p.y) return mat2(0,1,1,0);\n    return mat2(1);\n}\n\nconst float PI = acos(-1.);\nvec3 rounded_square(vec2 p, float radius, float sharpness, float offset) {\n    //first we abs and sort the vector so we can work with the symmetries of the square\n    vec2 sgn = nonzero_sign(p);\n    p = abs(p);\n    mat2 perm = sort(p);\n    p *= perm;\n    p.y += sharpness;\n\n    //get closest point on defining sphere for axis\n    float rad = sharpness + radius;\n    vec2 closest = normalize(p)*rad;\n\n    //normalize the closest point so it lies within the axis\n    if (closest.x > closest.y-sharpness) {\n        float k = sharpness;\n        float y = closest.y;\n        closest.y = (k + sqrt(2.*rad*rad-k*k))/2.;\n        closest.x = closest.y - k;\n    }\n\n    //calculate the distance\n    float side = sign(length(p)-rad);\n    float dist = length(p-closest)*side;\n\n    //map the closest point back to global coordinates\n    closest += normalize(p-closest)*offset*side;\n    if (side == 0.) closest = p;\n    vec2 closest_global = (closest-vec2(0,sharpness))*transpose(perm)*sgn;\n    return vec3(dist-offset, closest_global);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=3.; mouse*=3.;\n    \n    float radius = sin(iTime)*0.25+0.75;\n    float sharpness = pow(asin(sin(iTime*2.5))/PI+1.,8.);\n    float offset = sin(iTime*0.65)*0.25+0.25;\n    \n    float dist = rounded_square(uv, radius, sharpness, offset).x;\n    fragColor = vec4(shadeDistance(dist), 1.);\n\n    float mousedist = rounded_square(mouse, radius, sharpness, offset).x;\n    vec2 mousepoint = rounded_square(mouse, radius, sharpness, offset).yz;\n    if (iMouse.z > 0.) {\n        float pixelsize = 3./iResolution.y;\n        fragColor *= antialias(distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n        fragColor = mix(vec4(1,0,0,0), fragColor, antialias(distance(mousepoint, uv) - 0.03));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slBDl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 221, 221, 262], [264, 264, 283, 283, 346], [376, 376, 450, 538, 1399], [1401, 1401, 1430, 1430, 1743], [1745, 1745, 1771, 1771, 1862], [1864, 1864, 1921, 1921, 2735]], "test": "untested"}
{"id": "3dsfWl", "name": "Booze Cruise", "author": "dr2", "description": "Easy sailing with a favorite drink (impossible now)", "tags": ["refraction", "ocean", "glass", "beer", "bottle"], "likes": 23, "viewed": 707, "published": 3, "date": "1589278530", "time_retrieved": "2024-07-30T21:07:06.700872", "image_code": "// \"Booze Cruise\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0    // optional antialiasing (longer compile time)\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct {\n  vec3 pCont;\n  float rCont, hCont, hSurf, hCap, hLab;\n} cnf;\n\nvec3 sunDir, ltDir;\nfloat dstFar, tCur, rTbl, hTbl;\nint idObj;\nbool inCont, chkLbl, doBott;\nconst int idCap = 1, idBal = 2, idLbl1 = 3, idLbl2 = 4, idLbl3 = 5, idStir = 6, idStirB = 7,\n   idFom = 8, idTbl = 9, idFlr = 10, idRail = 11, idWal = 12;\n\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat TObjDf (vec3 p)\n{\n  vec3 pp, q;\n  float dMin, d, r, bf, s, rb, hb;\n  dMin = dstFar;\n  pp = p - cnf.pCont;\n  r = length (pp.xz);\n  if (doBott) {\n    bf = 0.95;\n    s = bf * cnf.rCont;\n    q = pp;\n    rb = cnf.rCont * (bf + (1. - bf) * smoothstep (0., 0.2 * cnf.rCont, q.y + cnf.hCont) -\n       0.65 * smoothstep (0., 1.5 * cnf.rCont, q.y - cnf.hCont) +\n       0.05 * smoothstep (0.,  0.1 * cnf.rCont, q.y - 2. * cnf.hCont - 0.7 * cnf.rCont));\n    d = inCont ? rb - r : r - rb;\n    d = max (d, max (q.y - 2. * cnf.hCont - cnf.rCont, - q.y - cnf.hCont));\n    hb = cnf.hCont + 0.3 * (r * r / (s * s) - 1.);\n    d = min (d, max (r - bf * cnf.rCont, abs (q.y + hb - 0.02) - 0.02));\n    dMin = d;\n  } else {\n    bf = 0.95;\n    q = pp;\n    rb = cnf.rCont * (bf + (1. - bf) * smoothstep (0., 0.2 * cnf.rCont, q.y + cnf.hCont) +\n       0.4 * smoothstep (0., 2.8 * cnf.rCont, q.y + 0.75 * cnf.hCont));\n    d = inCont ? rb - r : r - rb;\n    d = max (d, abs (q.y) - cnf.hCont);\n    q.y -= - cnf.hCont + 0.05;\n    d = min (d, PrCylDf (q.xzy, bf * cnf.rCont, 0.05));\n    dMin = d;\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pp, q;\n  float dMin, d, r, rm, a, s, db;\n  dMin = dstFar;\n  pp = p - cnf.pCont;\n  r = length (pp.xz);\n  rm = 1.4 * cnf.rCont;\n  if (doBott) {\n    q = pp;\n    q.y -= cnf.hCap;\n    d = PrCylDf (q.xzy, 0.4 * cnf.rCont + 0.4 - min (0.4 * (q.y + 0.4) * (q.y + 0.4), 1.), 0.4);\n    DMIN (idCap);\n    if (inCont) {\n      q = pp;\n      q.x = abs (q.x) - 0.7;\n      q.y -= - cnf.hCont + 0.9;\n      d = PrSphDf (q, 0.6);\n      DMIN (idBal);\n    }\n    if (! inCont && chkLbl) {\n      q = pp;\n      q.y -= cnf.hLab;\n      db = abs (r - cnf.rCont - 0.02) - 0.01;\n      a = atan (q.z, - q.x);\n      d = max (db, length (vec2 (r * a, q.y)) - 2.);\n      DMIN (idLbl1);\n      d = max (db, max (abs (2. * (mod (a, 2. * pi) - pi)), abs (q.y)) - 2.);\n      DMIN (idLbl2);\n    }\n  } else {\n    if (! inCont && chkLbl) {\n      q = pp;\n      q.y -= cnf.hLab;\n      d = max (abs (r - rm - 0.02) - 0.01, length (vec2 (r * atan (- q.x, - q.z), q.y)) - 1.5);\n      DMIN (idLbl3);\n    }\n    q = pp;\n    q.xz = Rot2D (q.xz, 0.3 * pi);\n    q.xy = Rot2D (q.xy - vec2 (1.2, 1.6), 0.05 * pi);\n    d = PrCylDf (q.xzy, 0.2, cnf.hCont + 1.5);\n    DMIN (idStir);\n    q.y -= cnf.hCont + 1.5;\n    d = PrSphDf (q, 0.3);\n    DMIN (idStirB);\n    q = pp;\n    s = r / rm;\n    s = 0.2 * (1. - s * s);\n    q.y -= cnf.hCont - 0.1 + s;\n    d = PrCylDf (q.xzy, rm - 0.03, 0.2 + s);\n    DMIN (idFom);\n  }\n  if (! inCont) {\n    q = p;\n    q.y -= hTbl - 0.1;\n    d = PrCylDf (q.xzy, rTbl, 0.1);\n    DMIN (idTbl);\n    q = p;\n    q.y -= 0.5 * hTbl;\n    d = PrCylDf (q.xzy, 1., 0.5 * hTbl);\n    q = p;\n    q.z -= 17.;\n    d = min (d, max (q.y, q.z));\n    DMIN (idFlr);\n    q.y = abs (abs (q.y - 8.) - 4.) - 2.;\n    q.z -= -0.5;\n    d = length (q.yz) - 0.3;\n    q = p;\n    q.x = mod (q.x + 5., 10.);\n    q -= vec3 (5., 6.5, 16.5);\n    d = min (d, PrCylDf (q.xzy, 0.3, 7.5));\n    DMIN (idRail);\n    d = max (max (61. - length (p.xz), abs (p.y - 20.) -20.1), p.z - 15.);\n    DMIN (idWal);\n  }\n  return 0.8 * dMin;\n}\n\nfloat TObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = TObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 CObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat LabSym (vec2 p)\n{\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nvec4 ObjCol (vec3 p)\n{\n  vec4 c, colLb1, colLb2, colLb3, colLb4;\n  vec3 q;\n  vec2 w;\n  float r, a, s;\n  colLb1 = vec4 (0., 0.7, 0.4, 0.1);\n  colLb2 = vec4 (0., 0., 0.5, 0.1);\n  colLb3 = vec4 (1., 1., 0.2, 0.3);\n  colLb4 = vec4 (0.7, 0.7, 0.7, 0.);\n  q = p - cnf.pCont;\n  r = length (q.xz);\n  if (doBott) {\n    a = atan (q.z, - q.x);\n    if (idObj == idCap) {\n      c = colLb1 + 0.1;\n      if (r < 1.4) {\n        if (q.y > cnf.hCap - 0.1) {\n          s = LabSym (1.3 * q.xz);\n          c = mix (mix (c, colLb2, smoothstep (-0.05, -0.01, s)), colLb3, smoothstep (0.01, 0.05, s));\n        } else c *= 0.5;\n      } else c *= 1. - 0.3 * sin (16. * a);\n    } else if (idObj == idLbl1) {\n      w = vec2 ((cnf.rCont + 0.1) * a, q.y - cnf.hLab);\n      c = mix (colLb1, colLb2, smoothstep (0., 0.05, length (w) - 1.9));\n      s = LabSym (0.9 * w);\n      c = mix (mix (c, colLb2,\n         smoothstep (-0.05, -0.01, s)), colLb3, smoothstep (0.01, 0.05, s));\n      if (r < cnf.rCont + 0.01) c = mix (c, colLb4, 0.8);\n    } else if (idObj == idLbl2) {\n      w = vec2 ((cnf.rCont + 0.1) * (mod (a, 2. * pi) - pi), q.y - cnf.hLab);\n      c = mix (colLb1, colLb2, smoothstep (0., 0.05, max (abs (w.x) - 2.95, abs (w.y) - 1.9)));\n      w = mod (w + vec2 (0., 0.5), vec2 (3., 2.2)) - 0.5 * vec2 (3., 2.2);\n      s = LabSym (1.5 * w);\n      c = mix (mix (c, colLb2,\n         smoothstep (-0.05, -0.01, s)), colLb3, smoothstep (0.01, 0.05, s));\n      if (r < cnf.rCont + 0.01) c = mix (c, colLb4, 0.8);\n    } else if (idObj == idBal) {\n      c = vec4 (0.9, 0.9, 1., 0.2); \n    }\n  } else {\n    if (idObj == idLbl3) {\n      w = vec2 ((1.4 * cnf.rCont + 0.1) * atan (- q.x, - q.z), q.y - cnf.hLab);\n      c = mix (colLb1, colLb2, smoothstep (0., 0.05, length (w) - 1.4));\n      s = LabSym (1.4 * w);\n      c = mix (mix (c, colLb2, smoothstep (-0.05, -0.01, s)), colLb3, smoothstep (0.01, 0.05, s));\n      if (r < 1.4 * cnf.rCont + 0.01) c = mix (c, colLb4, 0.8);\n    } else if (idObj == idFom) {\n      c = vec4 (1., 1., 1., 0.3) * (1. - 0.1 * Fbm2 (8. * q.xz));\n    } else if (idObj == idStir) {\n      q.xz = Rot2D (q.xz, 0.3 * pi);\n      q.xy = Rot2D (q.xy - vec2 (1.2, 1.6), 0.05 * pi);\n      c = mix (vec4 (0.8, 0.9, 0.8, 0.1), vec4 (0.9, 0.7, 0., 0.1), step (0., sin (4. * pi * q.y)));\n    } else if (idObj == idStirB) {\n      c = vec4 (0.9, 0.3, 0.3, 0.1);\n    }\n  }\n  if (idObj == idTbl) {\n    c = vec4 (0.85, 0.95, 0.9, 0.2);\n    if (p.y > hTbl - 0.1) c = (mix (vec4 (0.5, 0.7, 0.4, 0.1), c, \n       smoothstep (0.02, 0.03, abs (Fbm2 (vec2 (0.5, 0.2) * p.xz) - 0.4)))) *\n       (0.7 + 0.3 * smoothstep (0.2, 0.5, r - cnf.rCont));\n  } else if (idObj == idFlr) {\n    c = vec4 (0.5, 0.3, 0.1, 0.1) * (0.7 + 0.3 * SmoothBump (0.1, 3.9, 0.05, mod (p.z + 2., 4.))) *\n       (0.8 + 0.2 * smoothstep (0.1, 0.2, length (p.xz) - rTbl));\n  } else if (idObj == idRail) {\n    c = vec4 (0.8, 0.8, 0.9, 0.1);\n  } else if (idObj == idWal) {\n    c = vec4 (0.9, 0.9, 0.85, 0.1);\n  }\n  return c;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.5 * p + vec2 (1.5, 0.) * tCur;\n  h = 0.5 * sin (dot (q, vec2 (-0.05, 1.))) + 0.3 * sin (dot (q, vec2 (0.1, 1.2)));\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    q *= qRot;\n    t4 = q.xyxy * wFreq + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return h;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.5;\n  return normalize (vec3 (0.3 * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx))), e.x)).xzy;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float sd, a, f, ff, fd, h;\n  a = atan (rd.z, rd.x) - 0.005 * tCur;\n  h = Fbm1 (32. * a);\n  if (rd.y < 0.02 * h * h + 0.005) {\n    col = mix (vec3 (0.3, 0.32, 0.3), vec3 (0.4, 0.43, 0.43), 0.5 +\n       0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n       (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    q = 0.01 * (ro.xz + vec2 (0., 8.) * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = 0.7 * (0.7 + 0.5 * ff) * (vec3 (1.) - vec3 (0.2, 0.2, 0.1) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix ((vec3 (0.7, 0.7, 0.75)), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol, 0.1 + 0.9 * f * fd);\n    sd = pow (max (dot (rd, sunDir), 0.), 256.);\n    col += (0.1 * sd + 0.3 * pow (sd, 4.)) * vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvoid SetParm (int cnfId)\n{\n  hTbl = 6.;\n  rTbl = 12.;\n  if (cnfId == 0) {\n    cnf.rCont = 3.;\n    cnf.hCont = 2. * cnf.rCont;\n    cnf.pCont = vec3 (2.5 * cnf.rCont, cnf.hCont + hTbl + 0.2, 0.);\n    cnf.hSurf = 2.8 * cnf.hCont + hTbl;\n    cnf.hCap = 2. * cnf.hCont + cnf.rCont + 0.1;\n    cnf.hLab = 0.3 * cnf. hCont;\n  } else {\n    cnf.rCont = 2.5;\n    cnf.hCont = 2.5 * cnf.rCont;\n    cnf.pCont = vec3 (-2.5 * cnf.rCont, cnf.hCont + hTbl + 0.2, 0.);\n    cnf.hSurf = 2. * cnf.hCont + hTbl - 0.1;\n    cnf.hLab = 0.65 * cnf.hCont;\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, rdo, rdd, vn, vnW, colD, colR, col, row, rdw;\n  vec2 vf;\n  float dstObj, dstCont, dstContW, dstSurf, rdDotN, eta, hMenisc, dw, s, rFac;\n  bool contHit, inLiq, inLiqW;\n  SetParm (doBott ? 0 : 1);\n  eta = 1.33;\n  roo = ro;\n  rdo = rd;\n  inCont = false;\n  chkLbl = true;\n  dstCont = TObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  dstContW = dstCont;\n  hMenisc = 0.;\n  rdDotN = 0.;\n  inLiq = false;\n  contHit = (dstCont < min (dstObj, dstFar));\n  if (contHit) {\n    ro += dstCont * rd;\n    vn = CObjNf (ro);\n    vnW = vn;\n    rdDotN = - dot (rd, vn);\n    if (ro.y < cnf.hSurf) {\n      rd = refract (rd, vn, 1. / eta);\n      inLiq = true;\n      inLiqW = true;\n    }\n    hMenisc = max (0., ro.y - cnf.hSurf);\n    ro += 0.01 * rd;\n    inCont = true;\n    dstSurf = dstFar;\n    if (inLiq && rd.y > 0. || ! inLiq && rd.y < 0.) dstSurf = - (ro.y - cnf.hSurf) / rd.y;\n    dstCont = TObjRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n    if (dstSurf < min (min (dstCont, dstObj), dstFar)) {\n      ro += dstSurf * rd;\n      if (inLiq) {\n        vn = vec3 (0., -1., 0.);\n        rdd = refract (rd, vn, eta);\n        if (length (rdd) > 0.) {\n          rd = rdd;\n          inLiq = false;\n        } else {\n          rd = reflect (rd, vn);\n        }\n      } else {\n        vn = vec3 (0., 1., 0.);\n        rd = refract (rd, vn, 1. / eta);\n        inLiq = true;\n        inLiqW = true;\n      }\n      ro += 0.01 * rd;\n      dstCont = TObjRay (ro, rd);\n      dstObj = ObjRay (ro, rd);\n    }\n    if (dstCont < min (dstObj, dstFar)) {\n      ro += dstCont * rd;\n      vn = CObjNf (ro);\n      if (inLiq) {\n        rdd = refract (rd, vn, eta);\n        if (length (rdd) > 0.) {\n          rd = rdd;\n          inCont = false;\n          inLiq = false;\n        } else {\n          rd = reflect (rd, vn);\n        }\n      } else inCont = false;\n      hMenisc = min (hMenisc, max (ro.y - cnf.hSurf, 0.));\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col4 = ObjCol (ro);\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == idFom) vf = vec2 (16., 1.);\n    else if (idObj == idWal) vf = vec2 (128., 0.2);\n    else if (idObj == idFlr) {\n      s = mod (ro.z + 2., 4.);\n      vn.yz = Rot2D (vn.yz, 0.2 * pi * SmoothBump (0.2, 0.3, 0.05, abs (s)) * sign (s - 2.));\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    colD = col4.rgb * (0.2 + 0.2 * max (- dot (ltDir, vn), 0.) + 0.8 * max (dot (ltDir, vn), 0.) +\n       col4.a * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 32.));\n  } else {\n    row = ro;\n    rdw = rd;\n    rFac = 1.;\n    if (rd.y < 0.) {\n      dw = - row.y / rdw.y;\n      row += dw * rdw;\n      rdw = reflect (rdw, WaveNf (row, dw));\n      rFac = 0.9;\n    }\n    colD = rFac * BgCol (row, rdw);\n  }\n  colR = vec3 (0.);\n  if (contHit) {\n    ro = roo;\n    rd = rdo;\n    ro += dstContW * rd;\n    rd = reflect (rd, vnW);\n    ro += 0.01 * rd;\n    inCont = false;\n    chkLbl = false;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      col4 = ObjCol (ro);\n      vn = ObjNf (ro);\n      colR = col4.rgb * (0.2 + 0.2 * max (- dot (ltDir, vn), 0.) + 0.8 * max (dot (ltDir, vn), 0.) +\n         col4.a * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 32.));\n    } else {\n      row = ro;\n      rdw = rd;\n      rFac = 1.;\n      if (rd.y < 0.) {\n        dw = - row.y / rdw.y;\n        row += dw * rdw;\n        rdw = reflect (rdw, WaveNf (row, dw));\n        rFac = 0.9;\n      }\n      colR = rFac * BgCol (row, rdw);\n    }\n  }\n  if (contHit) {\n    if (inLiqW) hMenisc = 0.;\n    col = mix (vec3 (0.8, 0.7, 0.2), vec3 (1.), smoothstep (0., 0.2, hMenisc)) * colD;\n    if (eta != 1.) col = mix (colR, col, 0.2 + 0.8 * smoothstep (0., 0.9, rdDotN));\n  } else col = colD;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    //float t = mod (0.01 * tCur, 2.);\n    //az += 0.2 * pi * SmoothBump (0.3, 0.7, 0.1, mod (t, 1.)) * sign (t - 1.);\n    //el -= 0.03 * pi * sin (0.007 * pi * tCur);\n  }\n  el = clamp (el, -0.25 * pi, 0.03 * pi);\n  az = clamp (az, -0.3 * pi, 0.3 * pi);\n  if (abs (abs (az) - 0.5 * pi) < 0.19 * pi) az = (0.5 + 0.19 * sign (abs (az) - 0.5 * pi)) * pi * sign (az);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 15., -55.);\n  zmFac = 3.5;\n  dstFar = 150.;\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n  sunDir = normalize (vec3 (1., 1., -1.));\n  doBott = (sign (abs (mod (az + 2. * pi, 2. * pi) - pi) - 0.5 * pi) == sign (uv.x));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsfWl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[977, 977, 1000, 1000, 2075], [2077, 2077, 2099, 2099, 4064], [4066, 4066, 4100, 4100, 4285], [4287, 4287, 4320, 4320, 4504], [4506, 4506, 4528, 4528, 4784], [4786, 4786, 4807, 4807, 5062], [5064, 5064, 5087, 5087, 5486], [5488, 5488, 5510, 5510, 8449], [8451, 8451, 8474, 8474, 9134], [9136, 9136, 9167, 9167, 9348], [9350, 9350, 9381, 9381, 10342], [10344, 10344, 10370, 10370, 10877], [10879, 10879, 10914, 10914, 14716], [14718, 14718, 14774, 14774, 16238], [16240, 16240, 16273, 16273, 16300], [16302, 16302, 16344, 16344, 16395], [16397, 16397, 16442, 16442, 16545], [16547, 16547, 16604, 16604, 16687], [16689, 16689, 16725, 16725, 16931], [16933, 16933, 16963, 16963, 17076], [17110, 17110, 17134, 17134, 17187], [17189, 17189, 17213, 17213, 17325], [17327, 17327, 17352, 17352, 17498], [17500, 17500, 17525, 17525, 17711], [17713, 17713, 17735, 17735, 17889], [17891, 17891, 17912, 17912, 18067], [18069, 18069, 18098, 18098, 18310], [18312, 18312, 18351, 18351, 18531]], "test": "untested"}
{"id": "wdXBDs", "name": "infinite stairs - helix 1d (215)", "author": "FabriceNeyret2", "description": ".golfing [url]https://shadertoy.com/view/tdlfWX[/url]\n\ncould it be shorter ? :-)\n", "tags": ["raymarching", "sdf", "spiral", "helix", "2tweets", "short", "golf", "helicoid"], "likes": 20, "viewed": 486, "published": 3, "date": "1589267968", "time_retrieved": "2024-07-30T21:07:07.539630", "image_code": "// golfing 278 chars https://shadertoy.com/view/tdlfWX ( see comments there )\n\n// --- now entering obfuscating zone. More readable versions below.\n\n#define S sin( atan(p.z,p.x) - .3*iTime//\nvoid mainImage(out vec4 O, vec2 U) {\n    vec3  R = iResolution, p = 30./R;  p.y -= iTime;\n/*  p -= 23.*fract(4e4*sin(dot(U,vec2(100,17.1)))) *P;  */\n    for ( O++; O.x * O.a > .01 ; O-=.015 )\n        p -= ( O.a = max( max( S-      p + 2.   ),\n                               S- ceil(p*4.)/4. )  ),\n                               abs( length(p.xz) -6.) -2.).y ) \\\n             * vec3( .5*R.xy - U , R ) / R.x;\n} /*\n\n\n\n\n\n// --- 219 chars\n\n#define mainImage(O,U)                               \\\n    vec3  R = iResolution, p = 30./R,                \\\n          t = R/R, T = iTime *t, z;                  \\\n    for ( O++; O.x * t.x > .01 ; O-=.015 )           \\\n        z = p.y - T,                                 \\\n        t = atan(p.z,p.x) - .3*T,                    \\\n        t = max( max( sin( t -      z + 2.   ),      \\\n                      sin( t - ceil(z*4.)/4. )  ),   \\\n                      abs( length(p.xz) -6.) -2.),   \\\n        p -= t * vec3( .5*R.xy - U , R ) / R.x      /*\n\n\n\n\n\n// --- 221 chars\n\n#define mainImage(O,U)                                 \\\n    float T = iTime, t=1.,z;                           \\\n    vec3  R = iResolution, p = 30./R;                  \\\n    for ( O++; O.x * t > .01 ; O-=.015 )               \\\n        z = p.y - T,                                   \\\n        t = atan(p.z,p.x) - .3*T,                      \\\n        t = max( max( sin( t -      z + 2.   ),        \\\n                      sin( t - ceil(z*4.)/4. )  ),     \\\n                      abs( length(p.xz) -6.) -2. ),    \\\n        p += t * vec3( U-.5*R.xy, -R ) / R.x          /*\n\n\n\n\n\n// --- 227 chars\n\n#define mainImage(O,U)                                 \\\n    float T = iTime, t=1.,a,z;                         \\\n    vec3  q = iResolution,                             \\\n          D = vec3( U-.5*q.xy, -q ) / q.x,             \\\n          p = 30./q;                                   \\\n    for ( O++; O.x * t > .01 ; O-=.015 )               \\\n        z = p.y - T,                                   \\\n        a = atan(p.z,p.x) - .3*T,                      \\\n        t = max( max( sin( a -      z + 2.   ),        \\\n                      sin( a - ceil(z*4.)/4. )  ),     \\\n                      abs( length(p.xz) -6.) -2. ),    \\\n        p += t*D                                      /*\n\n\n\n\n\n// --- 235 chars\n\n#define mainImage(O,U)                                 \\\n    float T = iTime, t=1.,a,z;                         \\\n    vec3  q = iResolution,                             \\\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),             \\\n          p = 30./q;                                   \\\n    for ( O++; O.x * t > .01 ; O-=.015 )               \\\n        z = p.y - T,                                   \\\n        a = atan(p.z,p.x) - .3*T,                      \\\n        t = max( sin(a-z+2.), sin(a-ceil(z*4.)/4. ) ), \\\n        t = max( t, abs(length(p.xz)-6.)-2. ),         \\\n        p += t*D                                      /*\n\n\n\n\n\n// --- 243 chars\n\n#define mainImage(O,U)                            \\\n    float T = iTime, t=1.,a,z;                    \\\n    vec3  q = iResolution,                        \\\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        \\\n          p = 30./q;                              \\\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )    \\\n        z = p.y - T,                              \\\n        t = abs(length(p.xz)-6.)-2.,              \\\n        a = atan(p.z,p.x) - .3*T,                 \\\n        t = max(t, sin(a-ceil(z*4.)/4. )),        \\\n        t = max(t, sin(a-z+2.) ),                 \\\n        p += t*D                                 /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdXBDl", "name": "LCD smoothed screenshot scaling", "author": "ttg", "description": "Enlarged screenshots of text usually appear colorful due to subpixel font smoothing ([url]https://www.shadertoy.com/view/3sXfDs[/url])\nProposed is very simple adjustment to resampling to undo the bias.\nSpace - Toggle adjustment\nS - Toggle font smoothing\n", "tags": ["text", "rgb", "lcd"], "likes": 7, "viewed": 704, "published": 3, "date": "1589264657", "time_retrieved": "2024-07-30T21:07:08.409305", "image_code": "/*\n\nEnlarged screenshots of text usually appear colorful due to subpixel font smoothing\n(https://www.shadertoy.com/view/3sXfDs)\nProposed is very simple adjustment to resampling to undo the bias.\n\nKeyboard:\nSpace - Toggle adjustment\n    F - Toggle filtering (linear)\n    S - Toggle font smoothing of source\n\n*/\n\nvoid mainImage( out vec4 fv, in vec2 fp ) {\n  ivec2 R = ivec2(iResolution.xy);\n  ivec2 fi = ivec2(fp);\n  int scale = 3;\n  \n  vec3 v = vec3(0.);\n  ivec2 m = ivec2(iMouse.xy);\n  if (m==ivec2(0)) {\n    m = (ivec2(6,7)*2+1)*16;\n    if (iResolution.y<256.) m -= 128; // preview fix\n  }\n\n  int split = min(512,R.x*2/3);\n  if (fi.x<split) v = texelFetch(iChannel0, fi, 0).rgb;\n  else {\n    for (int ch=0; ch<3; ch++) {\n      int o = 1-ch;\n      // SPACE: toggle correction\n      if (texelFetch(iChannel1, ivec2(32,2), 0).r>.5) o = 0;\n      ivec2 ii = (fi/scale+ivec2(o,0))/3;\n      v[ch] = texelFetch(iChannel0,\n        ii+m-ivec2(split+R.x,R.y)/(6*scale), 0)[ch];\n      if (texelFetch(iChannel1, ivec2(70,2), 0).r<.5) {\n        // F: toggle filtering\n        vec2 ip = (fp/float(scale)+vec2(o,0))/3.;\n        v[ch] = texture(iChannel0,\n          ( ip+vec2(m)-vec2(ivec2(split+R.x,R.y)/(6*scale)) )\n          / iResolution.xy )[ch];\n      }\n    }\n  }\n\n  fv = vec4(pow(v,vec3(1./2.2)),1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fv, in vec2 fp ) {\n  vec3 v;\n\n  if (iResolution.y<256.) fp += 128.; // preview fix\n\n  for (int ch=0; ch<3; ch++) {\n    vec2 fp = fp;\n    if (texelFetch(iChannel1, ivec2(83,2), 0).r<.5)\n      fp += vec2(1./3.,0.)*float(ch-1);\n    vec2 uv = fp/512.;\n    v[ch] = 1.-texture(iChannel0, uv).r;\n  }\n\n  fv.rgb = v;\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 354, 354, 1295]], "test": "untested"}
{"id": "wdXfWs", "name": "BinarySubDivPolar - antialiased", "author": "FabriceNeyret2", "description": "Antialiased golfed version of jt's [url]https://shadertoy.com/view/XdcGzS[/url]\n\nvariant:  w < .5 ? instead of  l < 7. ? autoadjust to thinnest reachable resolution.\n\nsee also: [url]https://www.shadertoy.com/view/WsX3Rl[/url]", "tags": ["antialiasing", "radial", "polar", "2tweets", "subdivision", "short", "short", "binarytree", "golf", "loopless", "dyadicseries"], "likes": 7, "viewed": 486, "published": 3, "date": "1589261174", "time_retrieved": "2024-07-30T21:07:09.155310", "image_code": "// antialiased golfed version of https://shadertoy.com/view/XdcGzS\n\n// --- 225 by Fab\n//                                                          k-- : not ok on Angle\n#define t(k) smoothstep(-3.,3., R*l/exp2(l)*(abs( fract( exp2(ceil(l)k) * atan(U.y,U.x)/6.283 + iTime ) -.5 ) - .25) ) //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy, U = u+u - R,\n          l = 7.* length(U)/R;\n    l.y < 7. ? O += mix( t(-1.), t(), min( fract(l) *R/14., 1. ) ).y : O;\n} /*\n\n\n\n\n\n\n// --- 231 by coyote\n//                       -w , w : bug on OpenGL       k-- : not ok on Angle\n#define t(k) smoothstep(-w.y,w.y, abs( fract( exp2(k+ceil(l)) * atan(U.y,U.x)/6.283 + iTime ) -.5 ) - .25 ) //\n#define mainImage(O,u)                                                     \\\n    vec2  R = iResolution.xy, U = u+u - R,                                 \\\n          l = 7.* length(U)/R, w = 3.* exp2(l)/l / R;                      \\\n    l.y < 7. ? O += mix( t(-1.), t(), min( fract(l) *R/14., 1. ) ).y : O  /*\n\n\n\n\n\n\n// --- 235 by coyote\n\n#define t(l) smoothstep(-w,w, abs( fract( exp2(ceil(l)) * atan(U.y,U.x)/6.283 + iTime) -.5) -.25) //\n#define mainImage(O,u)                                                     \\\n    vec2  R = iResolution.xy, U = u+u - R;                                 \\\n    float l = 7.* length(U) / R.y ,                                        \\\n          w = 3.* exp2(l)/l / R.y;                                         \\\n    l < 7. ? O += mix( t(l-1.), t(l), min( 1., fract(l) *R.y/14. ) ) : O  /*\n\n\n\n\n\n        \n// --- 243 chars\n\n#define t(l) smoothstep(-w,w, abs( fract( exp2(l) * a + iTime ) -.5 ) - .25 ) //\n#define mainImage(O,u)                                                         \\\n    vec2  R = iResolution.xy, U = u+u - R;                                     \\\n    float l = 7.* length(U) / R.y , a = atan(U.y,U.x) / 6.283,                 \\\n          L = ceil(l) , w = 3.* exp2(l)/l / R.y;                               \\\n    l < 7. ? O += mix( t(L-1.), t(L), min( 1., fract(l) *R.y/14. ) ) : O      /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 290, 326, 326, 476]], "test": "untested"}
{"id": "wsXBWs", "name": "Sphere Inversion of Objects", "author": "blackle", "description": "inverting an SDF using knighty's normalization trick. see the conversation here: https://www.shadertoy.com/view/tdfBW2", "tags": ["3d", "sdf", "inversion"], "likes": 18, "viewed": 608, "published": 3, "date": "1589258239", "time_retrieved": "2024-07-30T21:07:09.898323", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//uncomment to enable SDF resampling, see comment inside ifdef\n//#define RESAMPLE_SDF\n\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return length(max(q, 0.)) + min(0., max(q.x,max(q.y,q.z)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\n//multiplication by the quaternion (.5,.5,.5,.5), see https://www.shadertoy.com/view/wdXBD2\nvec4 rot4d(vec4 p) {\n    return vec4(dot(p,vec4(1)), p.yzw + p.zwy - p.wyz - p.xxx)/2.;\n}\n\nfloat box(vec4 p, vec4 d) {\n    vec4 q = abs(p)-d;\n    return length(max(q, 0.)) + min(0., max(max(q.x,q.w),max(q.y,q.z)));\n}\n\nfloat weirdshape_1(vec3 p) {\n    vec4 p4d = vec4(p, 0.);\n    p4d = rot4d(p4d);\n    return box(p4d, vec4(.1));\n}\n\nfloat weirdshape_2(vec3 p) {\n    vec4 p4d = vec4(p, 0.);\n    p4d = rot4d(p4d);\n    p4d = sqrt(p4d*p4d+0.0001); //smooth abs\n    p4d = rot4d(p4d);\n    p4d = rot4d(p4d);\n    return box(p4d, vec4(.1));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat scene2(vec3 p) {\n    p -= vec3(0.,0.,0.5);\n    p = erot(p, vec3(0,1,0), iTime);\n    p = erot(p, vec3(0,0,1), iTime/2.);\n    p = erot(p, vec3(1,0,0), iTime/3.);\n    float time = iTime*0.674;\n    float mixval_a = smoothstep(-.25,.25,sin(time));\n    float mixval_b = smoothstep(-.15,.15,sin(time/2.));\n    float bx = box(p, vec3(0.1));\n    float ln = linedist(p, vec3(0.1), vec3(-0.1))-.05;\n    float weird_1 = weirdshape_1(p);\n    float weird_2 = weirdshape_2(p);\n    return mix(mix(ln, bx, mixval_a), mix(weird_2, weird_1, mixval_a), mixval_b);\n}\n\nvec3 circle_invert(vec3 p) {\n    return p/dot(p,p);\n}\n\nfloat fix_dist(vec3 p, float d) {\n    //normalize the inverted distance. thanks @knighty!\n\treturn dot(p,p)*d/(1.+length(p)*abs(d));\n}\n\nfloat scene(vec3 p) {\n    p += vec3(0,0,2.5);\n\tfloat d = scene2(circle_invert(p));\n\td = fix_dist(p, d);\n\n#ifdef RESAMPLE_SDF\n    for (int i = 0; i < 5; i++) {\n        vec3 circ_front = circle_invert(p-normalize(p)*d);\n        vec3 circ_back = circle_invert(p+normalize(p)*d);\n        //resample the SDF at the true center of the inverted circle centered at p of radius d.\n        //this improves the SDF quality by a very small amount and is not needed.\n        //I just decided to keep it here because it does indeed improve thngs\n    \tvec3 p_new = (circ_front + circ_back)/2.;\n\t\td = scene2(p_new);\n\t\td = fix_dist(p, d);\n    }\n#endif\n\n    //the SDF goes to zero at the origin, which is a concequence of the circle inversion\n    //to prevent a sphere from appearing there, we intersect with a sphere around our inverted object\n\treturn max(d-0.05, length(p-vec3(0,0,2.5))-1.5);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.4,uv));\n    vec3 init = vec3(-4,0,-.3);\n\n    float yrot = 0.35;\n    float zrot = 0.;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n    //raymarching\n    for (int i = 0; i < 160 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n    }\n    //shading\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float fact1 = length(sin(r*2.)*0.5+0.5)/sqrt(3.);\n    float fact2 = length(sin(-r*3.)*0.5+0.5)/sqrt(3.);\n    vec3 col1 = vec3(0.1,0.2,0.8)*fact1 + pow(fact1, 10.);\n    vec3 col2 = vec3(0.5,0.2,0.1)*fact2 + pow(fact2, 10.);\n    fragColor.xyz = sqrt(hit ? col1+col2 : vec3(0.01));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBWs.jpg", "access": "api", "license": "cc0-1.0", "functions": [[282, 282, 309, 309, 398], [400, 400, 440, 440, 531], [533, 625, 645, 645, 714], [716, 716, 743, 743, 841], [843, 843, 871, 871, 954], [956, 956, 984, 984, 1156], [1158, 1158, 1196, 1196, 1260], [1262, 1262, 1284, 1284, 1813], [1815, 1815, 1843, 1843, 1868], [1870, 1870, 1903, 1959, 2003], [2005, 2005, 2026, 2026, 2883], [2885, 2885, 2904, 2904, 3020], [3022, 3022, 3079, 3079, 4118]], "test": "ok"}
{"id": "3sfBWs", "name": "Blue Noise RT Shadows TAA: Dir", "author": "demofox", "description": "Showing blue noise being used for soft shadows. Drag mouse to move camera.\nLeft = white noise, Right = blue noise\nTop = Raw, Bottom = TAA with alpha 0.1, 3x3 neighborhood color clamp, halton sub pixel jitter.", "tags": ["arealight", "bluenoise", "stochastic"], "likes": 26, "viewed": 3195, "published": 3, "date": "1589253215", "time_retrieved": "2024-07-30T21:07:10.872718", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 pixelColor = texture(iChannel0, uv).rgb;\n\n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // make a dividing line between the panels\n    vec2 dist2d = abs(fragCoord - iResolution.xy * 0.5f);\n    float dist = min(dist2d.x, dist2d.y);\n    dist = smoothstep(2.0f, 1.0f, dist);\n    pixelColor = mix(pixelColor, vec3(1.0f, 1.0f, 0.0f), dist);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);        \n    \n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// white noise, from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// analytically mipmapped checkerboard pattern from inigo quilez\n// https://iquilezles.org/articles/morecheckerfiltering\nvec2 p( in vec2 x )\n{\n    vec2 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\n// return a filtered checkers pattern\nfloat checkersGradTriangle( in vec2 uv )\n{\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (p(uv+w)-2.0*p(uv)+p(uv-w))/(w*w); // analytical integral (triangle filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;    \n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n};\n    \nbool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }\n    \n    return false;\n}\n    \nbool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > 0.0f && dist < info.dist)\n        {\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.diffuse = diffuse;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool RayVsQuad(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 diffuse, bool doubleSided)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (doubleSided && dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }    \n    \n    return false;\n}\n\nSRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_rayMaxDist;\n\n    // the floor\n    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))\n    {\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        vec2 uv = hitPos.xz / 100.0f;\n        float shade = mix(0.8f, 0.4f, checkersGradTriangle(uv));\n        hitInfo.diffuse = vec3(shade, shade, shade);\n    }\n    \n    // some floating spheres to cast shadows\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 10.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 20.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 50.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f));\n    \n    return hitInfo;\n}\n\nvec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance, int panel, in vec2 pixelPos)\n{\n    // trace primary ray\n\tSRayHitInfo hitInfo = RayVsScene(rayPos, rayDir);\n    \n    // set the hitDistance out parameter\n    hitDistance = hitInfo.dist;\n    \n    if (hitInfo.dist == c_rayMaxDist)\n        return texture(iChannel0, rayDir).rgb;\n    \n    // calculate where the pixel is in world space\n\tvec3 hitPos = rayPos + rayDir * hitInfo.dist;\n    hitPos += hitInfo.normal * c_hitNormalNudge;\n    \n    int frame = 0;\n    #if ANIMATE_NOISE\n    \tframe = iFrame % 64;\n    #endif\n    \n    // use the screen space blue noise texture and golden ratio * frame number to\n    // get a \"random number\" to convert to an angle for how much to rotate\n    // the blue noise sample positions for this pixel\n    float blueNoise = texture(iChannel1, pixelPos / 1024.0f).r;\n    blueNoise = fract(blueNoise + c_goldenRatioConjugate * float(frame));\n    float theta = blueNoise * 2.0f * c_pi;\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    // shoot some shadow rays\n    float shadowTerm = 0.0f;\n    vec3 lightTangent = normalize(cross(c_lightDir, vec3(0.0f, 1.0f, 0.0f)));\n    vec3 lightBitangent = normalize(cross(lightTangent, c_lightDir));\n    for (int shadowRayIndex = 0; shadowRayIndex < c_numShadowRays; ++shadowRayIndex)\n    {\n        // calculate a ray direction to a random point on a disk in the direction of the light.\n        // AKA pick a random point on the sun and shoot a ray at it.\n        vec3 shadowRayDir;\n        {\n            vec2 diskPoint;\n            if ((panel%2) == 0)\n            {\n                // get white noise\n                vec2 rng = hash23(vec3(pixelPos, float(frame * c_numShadowRays + shadowRayIndex)));\n\n                // calculate disk point\n                float pointRadius = c_lightRadius * sqrt(rng.x);\n                float pointAngle = rng.y * 2.0f * c_pi;\n                diskPoint = vec2(pointRadius*cos(pointAngle), pointRadius*sin(pointAngle));\n\n            }\n            else //if ((panel%2) == 1)\n            {\n                // we only have 64 blue noise samples\n                // We could make more blue noise samples, but gotta set the limit somewhere since it's a constant array of vec2s.\n                if (shadowRayIndex >= 64)\n                    break;\n                \n                // get a blue noise sample position\n                vec2 samplePos = BlueNoiseInDisk[shadowRayIndex];\n\n                // rotate it\n                diskPoint.x = samplePos.x * cosTheta - samplePos.y * sinTheta;\n                diskPoint.y = samplePos.x * sinTheta + samplePos.y * cosTheta;\n\n                // scale it by the disk size\n                diskPoint *= c_lightRadius;\n            }\n\n            // calculate the normalized vector to the random point on the disk\n            shadowRayDir = normalize(c_lightDir + diskPoint.x * lightTangent + diskPoint.y * lightBitangent);\n        }\n\n        // trace shadow ray\n        SRayHitInfo shadowHitInfo = RayVsScene(hitPos, shadowRayDir);\n        shadowTerm = mix(shadowTerm, ((shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f), 1.0f / float(shadowRayIndex+1));\n    }\n    \n    // do diffuse lighting\n    float dp = clamp(dot(hitInfo.normal, c_lightDir), 0.0f, 1.0f);\n\treturn c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);    \n    \n    // calculate sub pixel jitter for anti aliasing\n    vec2 subPixelJitter = (fragCoord.y < iResolution.y * 0.5f) ? halton(iFrame % 16 + 1) - 0.5f : vec2(0.0f, 0.0f);\n    \n    // calculate the ray direction for this pixel\n    vec2 uv = (fragCoord + subPixelJitter)/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    int panel = 0;\n    vec3 rayDir;\n    {   \n        panel = int(dot(floor(uv*2.0f), vec2(1.0f, 2.0f)));\n        \n\t\tvec2 screen = fract(uv*2.0f) * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // do rendering for this pixel\n    float rayHitTime;\n    vec3 pixelColor = GetColorForRay(cameraPos, rayDir, rayHitTime, panel, fragCoord);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // get the neighborhood min / max from this frame's render\n    vec3 center = texture(iChannel0, uv).rgb;\n    vec3 minColor = center;\n    vec3 maxColor = center;\n    for (int iy = -1; iy <= 1; ++iy)\n    {\n        for (int ix = -1; ix <= 1; ++ix)\n        {\n            if (ix == 0 && iy == 0)\n                continue;\n            \n           \n            vec2 offsetUV = ((fragCoord + vec2(ix, iy)) / iResolution.xy);\n            vec3 color = texture(iChannel0, offsetUV).rgb;\n            minColor = min(minColor, color);\n            maxColor = max(maxColor, color);\n        }\n    }\n    \n    // get last frame's pixel and clamp it to the neighborhood of this frame\n    vec3 old = texture(iChannel1, uv).rgb;    \n    old = max(minColor, old);\n    old = min(maxColor, old);\n    \n    // interpolate from the clamped old color to the new color.\n    // Reject all history when the mouse moves.\n    float lerpAmount = (iMouse.z > 0.0 || uv.y > 0.5f) ? 1.0f : 0.1f;\n    vec3 pixelColor = mix(old, center, lerpAmount);        \n    fragColor = vec4(pixelColor, 1.0f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ANIMATE_NOISE 1\n\nconst int c_numShadowRays = 16;  // blue noise will use 64 samples max. white noise will use however many you specify here.\n#define c_lightDir normalize(vec3(0.3f, 1.0f, -0.5f))\nconst vec3 c_lightColor = vec3(1.0f, 0.8f, 0.5f);\nconst vec3 c_lightAmbient = vec3(0.05f, 0.05f, 0.05f);\nconst float c_lightRadius = 0.1f; // radius of light disk at 1 unit away\n\n\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n\nconst float c_FOV = 90.0f; // in degrees\nconst float c_cameraDistance = 100.0f;\nconst float c_minCameraAngle = c_pi / 2.0f;\nconst float c_maxCameraAngle = c_pi;\nconst vec3 c_cameraAt = vec3(0.0f, 20.0f, 0.0f);\nconst float c_rayMaxDist = 10000.0f;\n\nconst vec2 c_defaultMousePos = vec2(0.0f / 800.0f, 250.0f / 450.0f);\n\nconst float c_hitNormalNudge = 0.1f;\n\n// This \"blue noise in disk\" array is blue noise in a circle and is used for sampling the\n// sun disk for the blue noise.\n// these were generated using a modified mitchell's best candidate algorithm.\n// 1) It was not calculated on a torus (no wrap around distance for points)\n// 2) Candidates were forced to be in the unit circle (through rejection sampling)\nconst vec2 BlueNoiseInDisk[64] = vec2[64](\n    vec2(0.478712,0.875764),\n    vec2(-0.337956,-0.793959),\n    vec2(-0.955259,-0.028164),\n    vec2(0.864527,0.325689),\n    vec2(0.209342,-0.395657),\n    vec2(-0.106779,0.672585),\n    vec2(0.156213,0.235113),\n    vec2(-0.413644,-0.082856),\n    vec2(-0.415667,0.323909),\n    vec2(0.141896,-0.939980),\n    vec2(0.954932,-0.182516),\n    vec2(-0.766184,0.410799),\n    vec2(-0.434912,-0.458845),\n    vec2(0.415242,-0.078724),\n    vec2(0.728335,-0.491777),\n    vec2(-0.058086,-0.066401),\n    vec2(0.202990,0.686837),\n    vec2(-0.808362,-0.556402),\n    vec2(0.507386,-0.640839),\n    vec2(-0.723494,-0.229240),\n    vec2(0.489740,0.317826),\n    vec2(-0.622663,0.765301),\n    vec2(-0.010640,0.929347),\n    vec2(0.663146,0.647618),\n    vec2(-0.096674,-0.413835),\n    vec2(0.525945,-0.321063),\n    vec2(-0.122533,0.366019),\n    vec2(0.195235,-0.687983),\n    vec2(-0.563203,0.098748),\n    vec2(0.418563,0.561335),\n    vec2(-0.378595,0.800367),\n    vec2(0.826922,0.001024),\n    vec2(-0.085372,-0.766651),\n    vec2(-0.921920,0.183673),\n    vec2(-0.590008,-0.721799),\n    vec2(0.167751,-0.164393),\n    vec2(0.032961,-0.562530),\n    vec2(0.632900,-0.107059),\n    vec2(-0.464080,0.569669),\n    vec2(-0.173676,-0.958758),\n    vec2(-0.242648,-0.234303),\n    vec2(-0.275362,0.157163),\n    vec2(0.382295,-0.795131),\n    vec2(0.562955,0.115562),\n    vec2(0.190586,0.470121),\n    vec2(0.770764,-0.297576),\n    vec2(0.237281,0.931050),\n    vec2(-0.666642,-0.455871),\n    vec2(-0.905649,-0.298379),\n    vec2(0.339520,0.157829),\n    vec2(0.701438,-0.704100),\n    vec2(-0.062758,0.160346),\n    vec2(-0.220674,0.957141),\n    vec2(0.642692,0.432706),\n    vec2(-0.773390,-0.015272),\n    vec2(-0.671467,0.246880),\n    vec2(0.158051,0.062859),\n    vec2(0.806009,0.527232),\n    vec2(-0.057620,-0.247071),\n    vec2(0.333436,-0.516710),\n    vec2(-0.550658,-0.315773),\n    vec2(-0.652078,0.589846),\n    vec2(0.008818,0.530556),\n    vec2(-0.210004,0.519896) \n);\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 661]], "test": "untested"}
{"id": "3sXfDs", "name": "LCD Font Smoothing", "author": "ttg", "description": "Demonstrates how text rendering is typically optimized for RGB LCD subpixel layout to reduce color aliasing at edges and somewhat improve horizontal resolution.\n\nLeft: Rendering | Right: Close-up view of LCD screen\nKeyboard: Space toggles optimization.", "tags": ["text", "rgb", "lcd"], "likes": 11, "viewed": 697, "published": 3, "date": "1589246768", "time_retrieved": "2024-07-30T21:07:11.715465", "image_code": "void mainImage( out vec4 fv, in vec2 fp ) {\n  ivec2 R = ivec2(iResolution.xy);\n  ivec2 fi = ivec2(fp);\n  int scale = 3;\n  ivec2 ii = (fi/scale)/3;\n  int ch = (fi.x/scale)%3;\n  \n  vec3 v = vec3(0.);\n  ivec2 m = ivec2(iMouse.xy);\n  if (m==ivec2(0)) {\n    m = (ivec2(6,7)*2+1)*16;\n    if (iResolution.y<256.) m -= 128; // preview fix\n  }\n\n  int split = min(512,R.x*2/3);\n  if (fi.x<split) v = texelFetch(iChannel0, fi, 0).rgb;\n  else\n    v[ch] = texelFetch(iChannel0,\n      ii+m-ivec2(split+R.x,R.y)/(6*scale), 0)[ch]*.99+.01;\n\n  fv = vec4(pow(v,vec3(1./2.2)),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fv, in vec2 fp ) {\n  vec3 v;\n\n  if (iResolution.y<256.) fp += 128.; // preview fix\n\n  for (int ch=0; ch<3; ch++) {\n    vec2 fp = fp;\n    if (texelFetch(iChannel1, ivec2(32,2), 0).r<.5)\n      fp += vec2(1./3.,0.)*float(ch-1);\n    vec2 uv = fp/512.;\n    v[ch] = 1.-texture(iChannel0, uv).r;\n  }\n\n  fv.rgb = v;\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 564]], "test": "untested"}
{"id": "WdXfDs", "name": "yellow filter", "author": "mds2", "description": "Really simple video color filter to give everything a more yellow-brown tone.\n\nOriginally inspired by reading articles like https://matadornetwork.com/read/yellow-filter-american-movies/ this filter allows you to apply a similar effect to your own home.", "tags": ["simple", "video", "filter"], "likes": 4, "viewed": 622, "published": 3, "date": "1589243622", "time_retrieved": "2024-07-30T21:07:12.461470", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // webcam pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // simple colorspace transforms\n    mat3 rot = mat3(-0.3999643 ,  0.82848493, -0.39197103,\n       0.74160659,  0.04123861, -0.6695663 ,\n       0.53856125,  0.55849092,  0.63090386);\n    mat3 rot_inv = mat3(-0.3999643 ,  0.74160659,  0.53856125,\n       0.82848493,  0.04123861,  0.55849092,\n       -0.39197103, -0.6695663 ,  0.63090386);\n    vec3 cent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n    \n    vec3 rel = rot * (col - cent);\n\n    rel.xy *= 0.5 * rel.xy * rel.xy; // damp these channels, but especially for values near\n    // the color centroid\n    rel.z *= 1.0 + 0.5 * step(0.0,rel.z); // bump up these values where above centroid\n    vec3 new_col = (rot_inv * rel) + cent + vec3(0.15, 0.05, -0.1);\n    // take inverse of color transform, add colorspace center back in, add yellow offset\n\n    float weight = step(fragCoord.x, iMouse.x - 10.0);\n\n    col = mix(new_col, col, weight);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1217]], "test": "untested"}
{"id": "3dffDX", "name": "Angler v:0.0.0", "author": "Chris_M_Thomasson", "description": "An experiment in eliminating the field array. There is no global state. This is different than me previous work that actually used a damn global array to store vector field points! Yikes... ;^o This one scales much better!\n\nBeware of some Epilepsy...", "tags": ["fractal", "field", "vector", "vector", "angle"], "likes": 6, "viewed": 558, "published": 3, "date": "1589229373", "time_retrieved": "2024-07-30T21:07:13.250361", "image_code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson ver:0.0.4\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n\n-- Removed the global array! :^)\n\n-- Removed Create an attractor by clicking and dragging it around.\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 16\n\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    vec2 g = vec2(0.0, 0.0);\n    \n    const int imax = CT_N;\n    \n    float abase = 6.28318 / float(imax);\n    float rbase = 1. / float(imax);\n    \n    for (int i = 0; i < imax * 2; ++i)\n    {\n        float angle = abase * float(i);\n        float radius = rbase * float(i);\n        \n        angle += sin(iTime * .5) * 3.1459;\n       \n        vec2 vp = vec2(\n            cos(angle) * radius * (1. + abs(sin(iTime))), \n            sin(angle) * radius * (1. + abs(cos(iTime)))\n        );\n        \n        float vm = -1.;\n        \n        vec2 dif = vp - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        \n      \tg[0] = g[0] + vm * dif[0] / mass;\n      \tg[1] = g[1] + vm * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    vec2 vn = ct_vfield_normal(z, npow);\n    \n    float a = cos(iTime * .1) * 3.14; // Humm...\n    \n    float npi = ct_normal_pi(vn, a);\n    \n    float scale = float(CT_N);\n    \n    float color = mod(npi * scale, 1.0);\n    \n    if (color < .5)\n    {\n        //color /= .5;\n        //return vec4(color, 0, color, 1.0);\n    }\n    \n    return vec4(color, color, color, 1.0);\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){  \n    return ct_vpixel(c, c, 128, 2.);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0.0, \n        0.0, \n        0.1 + abs(sin(iTime * .1)) * 4.9\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dffDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[486, 486, 538, 538, 698], [805, 805, 857, 857, 1546], [1549, 1549, 1611, 1611, 1719], [1722, 1785, 1840, 1840, 2615], [2618, 2618, 2671, 2671, 2773], [2776, 2802, 2882, 2882, 3256], [3259, 3279, 3334, 3334, 3375], [3378, 3392, 3453, 3453, 3789]], "test": "untested"}
{"id": "wslBWf", "name": "infinite stairs - helix 1d4", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "short", "helicoid"], "likes": 6, "viewed": 395, "published": 3, "date": "1589213506", "time_retrieved": "2024-07-30T21:07:14.017310", "image_code": "// variant of https://shadertoy.com/view/tslBWf\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,a;\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        // ray direction\n          p = 30./q;                              // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.xzy - vec3(0,0,T),\n        t = abs(length(q.xy)-6.)-2.,              // bounding hollow cylinder\n        a = atan(q.y,q.x) - .3*T,\n        t = max(t, sin(a-floor(q.z*4.)/8. )),     // helix: stairs side\n        t = max(t,-sin(a-floor(q.z*4.+.3)/8.)+.04 ),  // helix: roof side\n        p += .8*t*D;                              // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 722]], "test": "untested"}
{"id": "tslBWf", "name": "infinite stairs - helix 1d3", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "short", "helicoid"], "likes": 7, "viewed": 363, "published": 3, "date": "1589213122", "time_retrieved": "2024-07-30T21:07:14.977743", "image_code": "// variant of https://shadertoy.com/view/tdlfWX\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,a;\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        // ray direction\n          p = 30./q;                              // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.xzy - vec3(0,0,T),\n        t = abs(length(q.xy)-6.)-2.,              // bounding hollow cylinder\n        a = atan(q.y,q.x) - .3*T,\n        t = max(t, sin(a-floor(q.z*4.)/8. )),     // helix: stairs side\n        t = max(t, sin(a-floor(q.z*4.)/8.+3.) ),  // helix: roof side\n        p += .8*t*D;                              // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 718]], "test": "untested"}
{"id": "wdlfDX", "name": "infinite stairs - helix 1d2", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "short", "helicoid"], "likes": 6, "viewed": 368, "published": 3, "date": "1589211340", "time_retrieved": "2024-07-30T21:07:15.840436", "image_code": "// variant of https://shadertoy.com/view/tdlfWX\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,a;\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        // ray direction\n          p = 30./q;                              // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.xzy - vec3(0,0,T),\n        t = abs(length(q.xy)-6.)-2.,              // bounding hollow cylinder\n        a = atan(q.y,q.x) - .3*T,\n        t = max(t, abs(fract(a*24./6.283+.6)-.3)*6.283/24. -.05),\n        t = max(t, sin(a-floor(q.z*4.)/4.*1.047 )),  // helix: stairs side\n        t = max(t, sin(a-q.z*1.047+3.) ),            // helix: roof side\n        p += t*D;                                 // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 790]], "test": "untested"}
{"id": "WslBDf", "name": "Day 144 - Fourier Series", "author": "jeyko", "description": "Thanks for the 3blue1brown video https://www.youtube.com/watch?v=r6sGWTCMz2k\n", "tags": ["fourier", "maths", "series", "mdtmjvm"], "likes": 3, "viewed": 414, "published": 3, "date": "1589211070", "time_retrieved": "2024-07-30T21:07:16.748009", "image_code": "// The code is rather messy and there could be mistakes in the implementation. \n// I recommend trying to do it yourself.\n\n// Fourier Series \n\n// 3b1b video: https://www.youtube.com/watch?v=r6sGWTCMz2k\n\n// Buffer A calculates an and bn and they are integrated here.\n\n\n\n\n// Thanks to mla/iq for smooth plotting function!\n\n// Plotting width\nconst float W = 0.01; \n// Plots a fn\nconst float eps = 0.005;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,W*width*0.5, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\nfloat fourierSeries (vec2 fragCoord){\n    \n    float a0 = T(vec2(fragCoord.x/iResolution.x,0.)).x;\n    \n    \n    // Here is the equation for reference https://en.wikipedia.org/wiki/Fourier_series\n    // It's calculated here.\n    \n    // an and bn are stored in x and y of Buffer B\n    // They are integrated in the following for() loop\n    \n    float Integral = 0.;\n    \n    \n    \n    for(float n = 0.; n < DISCRETE_STEPS_N; n++){\n        vec2 luv = vec2(\n\t\t\tfragCoord.x/iResolution.x,\n\t\t\tn/DISCRETE_STEPS_N\n\t\t);\n        vec4 p = T(luv); \n        \n    \tfloat an = p.x;\n    \tfloat bn = p.y;\n        \n        Integral += an*dxn + bn*dxn;\n    }\n\t\n    \n    // why is a0 /1. instead of /2. ? I don't know\n    float FS = a0/1. + Integral*1./pi;\n    return FS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*8.;\n    vec2 uvs = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0);\n    \n    // functions \n\n    float term = 0.88; \n\tcol += graph( uv.y, fn(term*uv.x/tau),fn(term*uv.x/tau+eps),vec3(0.,0.2,0.1),1.);\n    \n    // draw bn\n    col += T(uvs).y/80.*vec3(0.7,0.2,0.1);\n    \n\t\n    col += graph( uv.y,  fourierSeries (fragCoord),fourierSeries(fragCoord+vec2(eps*iResolution.x,0.)),vec3(0.8,0.2,0.1), 0.5 );\n    \n    // plotlines\n    \n    //float uvxmod = abs( (fract((uv.x+offs*7.+pi/3.)*2./3.14) -pi/5.)*pi/2.  );\n    float uvxmod = abs( (fract((uv.x+offs*pi*2.25+pi/3.)*2./3.14) -pi/5.)*pi/2.  );\n    col += graph(uvxmod + eps,0.01,0.02,vec3(1,1,1)/2.,0.75)*smoothstep(W,W*0.003,abs(uv.y)-0.1);\n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1)/2.,0.5);\n    \n    // gamma correction\n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define offs \t\t(iTime*0.25)\n\n//#define fn(j) \t\t( sin((j+offs)*FREQ*tau) +1.*cos((j+offs)*FREQ*2.*tau)  )\n//#define fn(j) \t\t( fract(j+offs)*FREQ )\n#define fn(j) \t\t( sin((j+offs)*FREQ*tau+1.*cos((j+offs)*FREQ/2.*tau) +7.*cos((j+offs)*FREQ/2.*tau)) +1.*cos((j+offs)*FREQ*2.*tau)  )\n\n\n#define FREQ 2.\n#define PERIOD 2.\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define DISCRETE_STEPS_N min(200.,iResolution.y)\n\n\n#define dxn (FREQ/DISCRETE_STEPS_N)\n\n\n\n#define T(uv) texture(iChannel0,uv)\n\n", "buffer_b_code": "// This buffer calculates bn and ba\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord/iResolution.xy;\n  \n    vec2 p = vec2(0);\n     \n    float P = PERIOD;\n    float n = floor(uv.y*DISCRETE_STEPS_N)/DISCRETE_STEPS_N;\n    \n    \n    // Why do I have to offset with P*3. here ? I get bad result if I remove it\n    \n    float x = P*6. + P*uv.x;\n    \n    float an = (fn(x)*cos(tau*x*n/P));\n    \n    float bn = (fn(x)*sin(tau*x*n/P));\n    \n    \n    fragColor = vec4(an,bn,0.,0.);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslBDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 465, 465, 580], [582, 582, 619, 619, 1337], [1339, 1339, 1396, 1396, 2311]], "test": "untested"}
{"id": "wssfWX", "name": "infinite stairs - helix 1e", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "short", "helicoid"], "likes": 6, "viewed": 348, "published": 3, "date": "1589209539", "time_retrieved": "2024-07-30T21:07:17.919876", "image_code": "// variant of https://shadertoy.com/view/tdlfWX\n// variant of https://shadertoy.com/view/XsdBW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,a;\n    mat2  R = mat2( cos(-.3*T +vec4(0,33,11,0)) );\n    vec3  q = iResolution, A,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        // ray direction\n          p = 30./q;                              // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.xzy - vec3(0,0,T),\n        q.xy *= R,\n        A = abs(q), t = abs(max(A.x,A.y)-6.)-2.,  // bounding hollow box\n        a = atan(q.y,q.x),\n        t = max(t, sin(a-floor(q.z*4.)/4.*1.047)),// helix: stairs side\n        t = max(t, sin(a-q.z*1.047+2.3) ),        // helix: roof side\n        p += .7*t*D;                              // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 133, 133, 827]], "test": "untested"}
{"id": "tdlfWX", "name": "infinite stairs - helix 1d", "author": "FabriceNeyret2", "description": "NB: golfed here: [url]https://www.shadertoy.com/view/wdXBDs[/url]", "tags": ["raymarching", "sdf", "spiral", "helix", "short", "helicoid"], "likes": 10, "viewed": 402, "published": 3, "date": "1589207849", "time_retrieved": "2024-07-30T21:07:18.662889", "image_code": "// variant of https://shadertoy.com/view/XsdBW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,a;\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        // ray direction\n          p = 30./q;                              // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.xzy - vec3(0,0,T),\n        t = abs(length(q.xy)-6.)-2.,              // bounding hollow cylinder\n        a = atan(q.y,q.x) - .3*T,\n        t = max(t, sin(a-floor(q.z*4.)/4. )),     // helix: stairs side\n        t = max(t, sin(a-q.z+2.3) ),              // helix: roof side\n        p += t*D;                                 // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 718]], "test": "untested"}
{"id": "wslBWX", "name": "gradation map effect", "author": "yasuo", "description": "effect experiment", "tags": ["gradationmap"], "likes": 2, "viewed": 544, "published": 3, "date": "1589206350", "time_retrieved": "2024-07-30T21:07:19.581433", "image_code": "const float Epsilon = 1e-10;\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec3 RGBtoHCV(vec3 RGB)\n{\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + Epsilon) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\nvec3 RGBtoHSL(vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + Epsilon);\n    return vec3(HCV.x, S, L);\n}\n\nvec3 HUEtoRGB(float H)\n{\n    float R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B),0.,1.);\n}\n\nvec3 HSLtoRGB(vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1. - abs(2. * HSL.z - 1.)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n\tp*=1.6;\n    vec2 prevP = p;\n\n    float t = iTime*0.1;\n    float dist = 1.0;\n    p.x+=cos(t)*dist;\n    p.y+=sin(t)*dist;\n    p*= cnoise(p*0.5);\n    float d = length(p)-0.6;\n    \n    dist = 1.3;\n    p.x-=cos(-t*1.2)*dist;\n    p.y-=sin(-t*1.2)*dist;\n    p*= cnoise(p*0.9);\n    float d2 = length(p)-0.7;\n    \n    p = prevP;\n    p.y+=iTime*0.1;\n    float n = cnoise(p*2.5)+min(d,d2);\n\t//n = min(d,d2);\n    \n    // tone curve\n    float toneval = 0.5;\n    vec3 originalCol = vec3(pow(n,toneval));\n    \n    // gradient map\n    vec3 gradientCol1 = vec3(0.7,0.3,0.6);\n    vec3 gradientCol2 = vec3(0.7,0.7, .3);\n    \n    vec3 hsl = RGBtoHSL(originalCol);\n    \n    float r = gradientCol1.r+(gradientCol2.r-gradientCol1.r)*hsl.z;\n    float g = gradientCol1.g+(gradientCol2.g-gradientCol1.g)*hsl.z;\n    float b = gradientCol1.b+(gradientCol2.b-gradientCol1.b)*hsl.z;\n    \n    vec3 gradientMapResult = RGBtoHSL(vec3(r,g,b));\n    \n    // hue\n    float hueVal = 0.02;\n    gradientMapResult.x+=hueVal;\n    \n    // brightness\n    float brightness = 0.5;\n    \n    vec3 resRGB = HSLtoRGB(gradientMapResult)*brightness;\n    \n    float threthold =  0.21;\n    fragColor = vec4(vec3(step(resRGB.r,threthold),step(resRGB.g,threthold),step(resRGB.b,threthold)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslBWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 119, 138, 138, 174], [175, 175, 196, 196, 233], [235, 235, 256, 256, 1333], [1335, 1335, 1360, 1360, 1644], [1646, 1646, 1671, 1671, 1825], [1827, 1827, 1851, 1851, 2001], [2003, 2003, 2028, 2028, 2149], [2151, 2151, 2208, 2208, 3533]], "test": "untested"}
{"id": "3dsBWX", "name": "Hougyokou ", "author": "butadiene", "description": "Hougyoku  means jewels in Japanese", "tags": ["raymarching", "reflection"], "likes": 11, "viewed": 614, "published": 3, "date": "1589183685", "time_retrieved": "2024-07-30T21:07:20.394260", "image_code": "//Copyright (c) 2020 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec4 bcolz = texture(iChannel0,uv);\n    vec2 e= 0.1*bcolz.w*vec2(1,0);\n    vec4 bcol1 = texture(iChannel0,uv+e);\n    vec4 bcol2 = texture(iChannel0,uv-e);\n    vec4 bcol3 = texture(iChannel0,uv+e.yx);\n    vec4 bcol4 = texture(iChannel0,uv-e.yx);\n    vec3 col =\t (bcol1.xyz+bcol2.xyz+bcol3.xyz+bcol4.xyz)/4.;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float offset = 3.6+8.5;\nfloat sts = 0.;\n\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat hati(vec3 p,float s){\n  return dot(abs(p),normalize(vec3(1,1,1)))-s;\n}\n\nvec4 dist(vec3 p){\n  vec3 sp = p;\n  for(int i =0;i<4;i++){\n    sp = abs(sp)-vec3(0.1,0.03,0.1);\n    sp.xz *= rot(0.7);\n    sp.yz *= rot(0.7);\n  }\n  float d2 = hati(sp,0.4);\n  sp =p;\n  p.xy *= rot(0.5);\n  for(int i = 0;i<5;i++){\n    p = abs(p)-0.3;\n    p.xy *= rot(1.+(iTime*sts+offset)*0.2);\n    p.xz *= rot(0.3+(iTime*sts+offset)*0.2);\n    \n  }\n  float k = 0.2;\n  p.z = mod(p.z,k)-0.5*k;\n  float d= box(p,vec3(0.11,0.11,0.005));\n  p =sp;\n  for(int i = 0;i<5;i++){\n    p = abs(p)-0.5;\n    p.xy *= rot(0.7);\n    p.xz *= rot(0.4);\n    \n  }\n  k = 0.2;\n  p.z = mod(p.z,k)-0.5*k;\n  float d3= box(p,vec3(0.21,0.005,0.21));\n  d = min(d,d3);\n  \n  vec3 col = vec3(0.1,0.4,0.9);\n  vec3 col2 = 5.*vec3(0.7,0.1,0.3);\n  float sss = 0.;\n  if(d>0.2)sss=1.;\n  col = mix(col,col2,step(d2,d+1.2*sss));\n  return vec4(col,min(d,d2));\n}\n\nvec3 getnormal(vec3 p){\n  vec2 e = vec2(0.001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\n    \n    float rs = 2.3;\n    float kt = (iTime+offset)*.3;\n    vec3 ro =vec3(cos(kt)*rs,rs*sin(kt*0.2+0.2),sin(kt)*rs);\n    vec3 ta = vec3(0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+0.9*cdir);\n    float d,t= 0.;\n    vec4 vd;\n    vec3 ac = vec3(0.);\n    for(int i =0;i<77;i++){\n      vd =dist(ro+rd*t);\n      d = vd.w;\n      t += d;\n      ac += vd.xyz*exp(-2.*d);\n      if(d<0.001||t>100.)break;\n    }\n    float skt = length(ro+rd*t);\n    vec3 col = vec3(0);\n    if(d<0.001){\n      vec3 normal = getnormal(ro+rd*t);\n      float alp = 0.3;\n      float dif = pow(alp*max(dot(normal,normalize(vec3(1,1,1))),0.)+1.-0.3,2.);\n      col=vec3(dif*0.4);\n\n      t= 0.1;\n      rd = reflect(rd,normal);\n      vec3 ac2 = vec3(0.);\n      for(int i =0;i<27;i++){\n      vd =dist(ro+rd*t);\n      d = vd.w;\n      t += d;\n      ac2 += vd.xyz*exp(-2.*d);\n      if(d<0.001||t>100.)break;\n      }\n      if(d<0.001){\n      normal = getnormal(ro+rd*t);\n      alp = 0.3;\n      dif = pow(alp*max(dot(normal,normalize(vec3(1,1,1))),0.)+1.-0.3,2.);\n      col += 0.4*dif+0.05*ac2;\n\n      }\n    }\n    col += 0.05*ac;\n\n\tfragColor = vec4(col,clamp(skt-0.6,0.,100.)/100.);\n    \n \n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBWX.jpg", "access": "api", "license": "mit", "functions": [[115, 115, 172, 172, 615]], "test": "untested"}
{"id": "WsfBDf", "name": "Blue Noise Fog", "author": "demofox", "description": "Showing how blue noise can be used to make up for low step count ray marching through participating media.\nhttps://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\nDrag mouse to control camera.\nLL = no noise\nLR = white\nUL = blue\nUR = IGN", "tags": ["fog", "bluenoise", "stochastic"], "likes": 88, "viewed": 5910, "published": 3, "date": "1589171663", "time_retrieved": "2024-07-30T21:07:21.323775", "image_code": "#define ANIMATE_NOISE 1\n\nconst float c_pi = 3.14159265359f;\nconst float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n\nconst float c_FOV = 90.0f; // in degrees\nconst float c_cameraDistance = 80.0f;\nconst float c_minCameraAngle = 0.0f;\nconst float c_maxCameraAngle = c_pi;\nconst vec3 c_cameraAt = vec3(0.0f, 40.0f, 0.0f);\nconst float c_rayMaxDist = 10000.0f;\n\n#define c_lightDir normalize(vec3(0.0f, 0.0f, 0.2f))\nconst vec3 c_lightColor = vec3(1.0f, 0.8f, 0.5f);\nconst vec3 c_lightAmbient = vec3(0.05f, 0.05f, 0.05f);\n\nconst vec2 c_defaultMousePos = vec2(200.0f / 800.0f, 275.0f / 450.0f);\n\nconst float c_hitNormalNudge = 0.1f;\n\nconst int c_numRayMarchSteps = 16;\n\nconst float c_fogDensity = 0.002f;\nconst vec3 c_fogColorLit = vec3(1.0f, 1.0f, 1.0f);\nconst vec3 c_fogColorUnlit = vec3(0.0f, 0.0f, 0.0f);\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;    \n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n};\n    \nbool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }\n    \n    return false;\n}\n    \nbool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > 0.0f && dist < info.dist)\n        {\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.diffuse = diffuse;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool RayVsQuad(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 diffuse, bool doubleSided)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (doubleSided && dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > 0.0f && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.diffuse = diffuse;        \n        return true;\n    }    \n    \n    return false;\n}\n\nSRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_rayMaxDist;\n\n    // the floor\n    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))\n    {\n        // uncomment this for a checkerboard floor\n        /*\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        vec2 uv = floor(hitPos.xz / 100.0f);\n        float shade = mix(0.6f, 0.2f, mod(uv.x + uv.y, 2.0f));\n        hitInfo.diffuse = vec3(shade, shade, shade);\n\t\t*/\n    }\n    \n    // some floating spheres to cast shadows\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f));\n    RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f));\n    \n    // back wall\n    {\n        vec3 scale = vec3(100.0f, 40.0f, 1.0f);\n        vec3 offset = vec3(0.0f, 0.0f, 10.0f);\n        vec3 A = vec3(-1.0f, 0.0f, 0.0f) * scale + offset;\n        vec3 B = vec3(-1.0f, 1.0f, 0.0f) * scale + offset;\n        vec3 C = vec3( 1.0f, 1.0f, 0.0f) * scale + offset;\n        vec3 D = vec3( 1.0f, 0.0f, 0.0f) * scale + offset;\n    \tRayVsQuad(rayPos, rayDir, hitInfo, A, B, C, D, vec3(1.0f, 0.0f, 1.0f), true);\n\t}     \n    \n    return hitInfo;\n}\n\n\nvec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance)\n{\n    // trace primary ray\n\tSRayHitInfo hitInfo = RayVsScene(rayPos, rayDir);\n    \n    // set the hitDistance out parameter\n    hitDistance = hitInfo.dist;\n    \n    if (hitInfo.dist == c_rayMaxDist)\n        return texture(iChannel0, rayDir).rgb;\n    \n    // trace shadow ray\n    vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n    hitPos += hitInfo.normal * c_hitNormalNudge;\n    SRayHitInfo shadowHitInfo = RayVsScene(hitPos, c_lightDir);\n    float shadowTerm = (shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f;\n    \n    // do diffuse lighting\n    float dp = clamp(dot(hitInfo.normal, c_lightDir), 0.0f, 1.0f);\n\treturn c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm;\n}\n\n// ray march from the camera to the depth of what the ray hit to do some simple scattering\nvec3 ApplyFog(in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, in float rayHitTime, in int panel, in vec2 pixelPos)\n{         \n    // Offset the start of the ray between 0 and 1 ray marching steps.\n    // This turns banding into noise.\n    int frame = 0;\n    #if ANIMATE_NOISE\n    \tframe = iFrame % 64;\n    #endif\n    \n    float startRayOffset = 0.0f;\n    if (panel == 0)\n    {\n        startRayOffset = 0.5f;\n    }\n    else if (panel == 1)\n    {\n        // white noise\n        startRayOffset = hash13(vec3(pixelPos, float(frame)));\n    }\n    else if (panel == 2)\n    {\n        // blue noise\n        startRayOffset = texture(iChannel1, pixelPos / 1024.0f).r;\n        startRayOffset = fract(startRayOffset + float(frame) * c_goldenRatioConjugate);\n    }    \n    else if (panel == 3)\n    {\n        // interleaved gradient noise\n        startRayOffset = InterleavedGradientNoise(pixelPos, frame);\n    }\n    \n    // calculate how much of the ray is in direct light by taking a fixed number of steps down the ray\n    // and calculating the percent.\n    // Note: in a rasterizer, you'd replace the RayVsScene raytracing with a shadow map lookup!\n    float fogLitPercent = 0.0f;\n    for (int i = 0; i < c_numRayMarchSteps; ++i)\n    {\n        vec3 testPos = rayPos + rayDir * rayHitTime * ((float(i)+startRayOffset) / float(c_numRayMarchSteps));\n        SRayHitInfo shadowHitInfo = RayVsScene(testPos, c_lightDir);\n        fogLitPercent = mix(fogLitPercent, (shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f, 1.0f / float(i+1));\n    }\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent);\n    float absorb = exp(-rayHitTime * c_fogDensity);\n    return mix(fogColor, pixelColor, absorb);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);    \n    \n    // calculate the ray direction for this pixel\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    int panel = 0;\n    vec3 rayDir;\n    {   \n        panel = int(dot(floor(uv*2.0f), vec2(1.0f, 2.0f)));\n        \n\t\tvec2 screen = fract(uv*2.0f) * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // do rendering for this pixel\n    float rayHitTime;\n    vec3 pixelColor = GetColorForRay(cameraPos, rayDir, rayHitTime);\n    \n    // apply fog\n    pixelColor = ApplyFog(cameraPos, rayDir, pixelColor, rayHitTime, panel, fragCoord);\n    \n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);        \n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[831, 962, 985, 985, 1157], [1159, 1159, 1195, 1195, 1326], [1328, 1328, 1357, 1357, 1531], [1811, 1857, 1880, 1880, 1983], [1985, 1985, 2089, 2089, 2786], [2868, 2868, 2975, 3049, 3989], [3995, 3995, 4100, 4100, 4492], [4494, 4494, 4538, 4538, 4572], [4574, 4574, 4725, 4783, 6520], [6522, 6522, 6578, 6578, 8069], [8072, 8072, 8148, 8173, 8853], [10654, 10654, 10711, 10741, 11921]], "test": "untested"}
{"id": "tsXfDX", "name": "Yin Yang Biological Simulation", "author": "tomachi", "description": "automaton", "tags": ["multipass"], "likes": 5, "viewed": 616, "published": 3, "date": "1589165143", "time_retrieved": "2024-07-30T21:07:22.193450", "image_code": "#define herbtex(g) texture(iChannel0, (g)/iResolution.xy)\n#define amoebatex(g) texture(iChannel1, (g)/iResolution.xy)\n#define webcam(g) texture(iChannel2, (g)/iResolution.xy)\n#define width int 100\n#define height int 100\n#define cellCol[height] uniform float \n#define toxic 10000.0\n#define toxfactor 0.001\n#define brightness 1.01\n#define blueness 0.25\nfloat sigmoid(float a, float f)\n{\n\treturn 1.0/(1.0+exp(-f*a));\n}\n\n//void mainImage(out vec4 fragColor, vec2 fragCoord)\n//{\n  //  edgeStrength = sigmoid(edgeStrength - 0.2, 32.0); \n//}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    // x,y => pos\n\t// z => pressure\n\t// w => ink\t\n\n   \tvec4 aa = herbtex(fragCoord+vec2(1,0)); // look to the left\n\tvec4 bb = herbtex(fragCoord+vec2(0,1)); // right\n\tvec4 cc = herbtex(fragCoord+vec2(-1,0));// up\n\tvec4 dd = herbtex(fragCoord+vec2(0,-1));// down\n\tvec4 herb = herbtex(fragCoord);\n\tvec4 amoeba = amoebatex(fragCoord);\n\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    float biomass = abs( aa.w + bb.w +  cc.w + dd.w) + abs(aa.z + bb.z + cc.z + dd.z); // abs converts to positive\n\tfloat pollenSpeed = max(max(abs(aa.x) , abs(bb.x)),max(abs(cc.x) , abs(dd.x)));   \n\n    r = (abs(herbtex(fragCoord).x)) + (herbtex(fragCoord).w) + biomass;\n    g = abs(herbtex(fragCoord).z);// +   herbtex(fragCoord).w;\n    b = (abs(herbtex(fragCoord).y)) * (herbtex(fragCoord).w ) ;// * 0.00016);\n    \n    rh = herb.r + 0.5; // RED\n    gh = (herb.g*0.5) + rh; // GREEN \n    bh = (herb.b*0.5)+ rh; // BLUE\n    if (rh < 0.5) { rh=1.; r=1.; } // 10X BRIGHTEN\n    if (gh > 0.5) { gh*=2.; g+=0.1; } // BRIGHTEN\n    if (amoeba.r > 0.025) { r+=brightness; }\n    if (amoeba.g > 0.025) { g+=brightness; }\n    if (amoeba.b > 0.025) { b+=brightness; }\n\n   // if (herb.r < 0.5) { r+=0.95; }\n    //if (herb.g < 0.5) { g+=0.25; }\n    //if (herb.b < 0.5) { b+=0.25; }\n    \n \tfloat amb = sigmoid( 10., amoeba.z)*0.25;// amoeba.z) ;\n \tfloat hrb = sigmoid( 10., herb.z)*0.5 ;\n    \n\tvec4 apixel = vec4( amb*1.99, amb*1.9, amb*0.05, 0.);\n    vec4 hpixel = vec4( hrb* 0.1, hrb* 0.9, hrb* 0.30, 0.);\n    \n    fragColor = apixel + hpixel;\n    \n //\tfragColor = amoeba*0.5;// + (herb*0.25);// + amoeba;\n \t//fragColor = vec4(herb);// + amoeba;\n \t// fragColor = vec4(amoeba);// + amoeba;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// VEGETATION LAYER\n#define magic 0.27\n#define border 60.\n#define count 28\n#define herbtex(g) texture(iChannel0, (g)/iResolution.xy)\n#define amoebatex(g) texture(iChannel1, (g)/iResolution.xy)\n#define topspeed 1000.76\n#define tides 0.0833\n#define rotation 0.2583\n#define expansion 0.001\n#define radius 0.943\n#define emitSize 2.\n#define force 1.01\n#define constraint 0.51\n#define effect 0.99\n#define toxic 1000.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define s iResolution.xy\n#define theTides(offset) 0.003951*(sin((iTime*tides)+offset+30.)-0.5)\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n    return tri;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // x,y => pos\n\t// z => pressure\n\t// w => ink\n\tvec2 xy = fragCoord;\n\tvec2 g = fragCoord;\n\n    vec4 a = herbtex(xy+vec2(1,0));\n\tvec4 b = herbtex(xy+vec2(0,1));\n\tvec4 c = herbtex(xy+vec2(-1,0));\n\tvec4 d = herbtex(xy+vec2(0,-1));\n    vec4 herb = herbtex(xy);\n    \n  //  float red = herb.r;\n    float green = herb.g;\n    float blue = herb.b;\n    \n    \n\tvec4 tomachiBoost = vec4(1.0001,1.0001,1.0001,0.99);\n\tvec4 tomachiSuppress = vec4(-0.999,-0.999,0.99,0.99);\n    vec4 tomachi = tomachiBoost;\n   // vec4 herbi = herbtex(xy);\n    vec4 amoeba = amoebatex(xy);\n\n    // LOAD PREVIOUS COLOUR FROM TEXTURE\n\t//fragColor = tex(g-tex(g).xy) * tomachi; // last state\n    //fragColor.r += webcamPixel.r;\n    fragColor = herb;\n    //fragColor.b += webcamPixel.b;\n\n    \n\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n    float sidepresh = abs(gp.x);\n    float vertpresh = abs(gp.y);\n    \n\t// ANYTHING ABOVE 0.25 CREATES BEAUTIFUL CHAOS. 0.2499 BORING. \n    //float pressure = (0.259519-theTides()) * ((a.z + b.z + c.z + d.z) - 0.05) * (c.x - a.x + d.y - b.y);\n    gp += vec2(theTides(1.), theTides(0.)); // TIDES GENTLY MOVE SHIT\n\tfloat pressure =  magic  * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n    float population = abs(pressure);\n    // float pressure = 0.2499 * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n    if (sidepresh > toxic || vertpresh > toxic || abs(pressure) > 0.26 ) {\n            \tpressure *= 0.89751;\n    }// OVERPRESSURE VALVE\n    if (population > 0.75) { // OVERPRESSURE VALVE. 0.5 was a good value\n    \tpopulation *= 0.89751;\n    \t//pressure *= 0.34; // <----- VERY GOOD\n \n    } else if (population < 0.25) {\n     population *= 0.79;\n        //gp.x = 2.1;\n      \tgp.y += 2.5;\n\n    }\n    if (abs(gp.x) > topspeed) { // OVERSPEED VALVE\n      // gp.x *= 0.1;\n       pressure *= 0.999;\n    } \n    if (abs(gp.y) > topspeed) {\n      // gp.x *= 0.1;\n       population *= 0.999;\n    }\n    \n  \n    \n   if (iFrame < 5) {\n      emit(fragCoord, vec2(pressure, population));\n  //    fragColor = vec4(\n   //  \t sin(fragCoord.x*0.05)*0.01,\n    // \t sin(fragCoord.y*0.05)*0.01,\n    // \t 500.5,\n   // \t  500.0\n    //  );\n    }\n\t\n   // if (xy.x < 1. || xy.y < 1. || xy.x > s.x - 1. || xy.y > s.y - 1.) fragColor.xy *= -0.5;\n    if (xy.x < border || xy.y < border || xy.x > s.x - border || xy.y > s.y - border) {\n       //fragColor.z *= 0.78941;\n       fragColor.z *= 0.7;\n      // fragColor.xy *= 0.59;\n       fragColor.xy *= vec2(0.95);\n       pressure *= 0.95;\n    }\n\t//if (xy.x < 1. || xy.y < 1. || xy.x > s.x - 1. || xy.y > s.y - 1.) fragColor.xy *= 0.95;\n\t\n    if (herb.z > 10.1) { \n     \tpressure -=  0.8* amoeba.z;\n     \tpopulation -=  0.8* amoeba.z;\n    }\n    if (amoeba.z > 1.951) { \n     \tpressure *= 0.95;\n     \tpopulation *= 0.95;\n    }\t\n    \tfragColor = vec4(\n\t\tfragColor.x + (gp.x*  0.4) ,// less horizontal\n\t\tfragColor.y + (gp.y* 0.5),// 1.0001),// gives vertical bias\n        pressure,\n        population);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// THE AMOEBA LIKES TO EAT THE HERB\n#define herbtex(g) texture(iChannel0, (g)/iResolution.xy)\n#define amoebatex(g) texture(iChannel1, (g)/iResolution.xy)\n#define toxic 12.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.z = 1.0\n#define emitSize 1.950\n#define force 0.99\nfloat sigmoid(float a, float f)\n{\n\treturn 1.0/(1.0+exp(-f*a));\n}\n\nfloat smoothbump(float center, float width, float x) {\n  float w2 = width/2.0;\n  float cp = center+w2;\n  float cm = center-w2;\n  float c = smoothstep(cm, center, x) * (1.0-smoothstep(center, cp, x));\n  return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n// xy = direction vec2\n//  z = pressure float\n//  w = ? \n    vec2 left  =  vec2(1,0);\n\tvec2 right =  vec2(0,1);\n\tvec2 up   =  vec2(-1,0);\n\tvec2 down =  vec2(0,-1);\n\n        \n\n    \n    vec2 g = fragCoord;\n    vec4 amoeba = amoebatex(g);\n    vec4 herb = herbtex(g);\n    vec2 direction = amoeba.xy; // direction\n    float pressure = amoeba.z; // pressure\n    float population = amoeba.r*0.4296; // pop\n    // SAMPLE THE HERBIVORE\n    vec4 a = herbtex(g+left);\n\tvec4 b = herbtex(g+right);\n\tvec4 c = herbtex(g+up);\n\tvec4 d = herbtex(g+down);\n    \n    float curl = a.r + b.r + c.r + d.r; // amoeba IS STORED IN THE RED CHANNEL\n    // SAMPLE THE 'erb\n    vec4 ll = herbtex(fragCoord+vec2(1,0));\n\tvec4 rr = herbtex(fragCoord+vec2(0,1));\n\tvec4 uu = herbtex(fragCoord+vec2(-1,0));\n\tvec4 dd = herbtex(fragCoord+vec2(0,-1));\n    \n    if (iFrame < 2) {\n\t\tpopulation = 0.;\n\t\tfragColor = vec4(0.0);\n        return;\n    } else if (iFrame < 5) {\n        population =  sin(g.x )*0.01;\n        fragColor = vec4(0.2);\n\t\treturn;\n    }\n    \n    // IF CURRENT AREA CONTAINS HERBIVORES (RED PIXELS),\n    // DECIDE WHICH WAY TO MOVE AND PARTY \n    if (population > 0.) {\n     float avg = (ll.z +  rr.z + uu.z + dd.z)*0.25; //average herb health to expect / beat\n        // RIGHT\n        if (rr.z > avg && a.r == 0.) { // IF THE BEST AND NOT OCCUPIED\n            emit(right, population);\n            fragColor.z = population;\n        // DOWN \n        } else if (dd.z > avg && b.r == 0.) { // IF THE BEST AND NOT OCCUPIED\n            emit(down, population);\n\n            // LEFT\n        } else if (up.g > avg && c.r == 0.) { // IF THE BEST AND NOT OCCUPIED\n            emit(left, population);\n\n            // UP\n        } else if (down.g >= avg && d.r == 0.) { // IF THE BEST AND NOT OCCUPIED\n            emit(up, population);\n\n        }\n        \n            \n    } else {\n     \temit(g, 0.1);\n        pressure += 1.1;\n        fragColor = vec4(population);\n\t\t//return;\n    }\n    \n    // PULL LAST STATE:\n \t//tomachiAmp += herbtex(g-herbtex(g).xy); // last state\n \t//pressure += population + pressure; // last state\n    \n    // ANALYSE THE SAMPLE\n    pressure = 0.250919 * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n    float biomass =abs( a.w + b.w +  c.w + d.w + a.z + b.z + c.z + d.z); // abs converts to positive\n  \n    // GENESIS\n    if (abs(pressure) > 5.99) {\n    \tpopulation -= 1.1;\n    }\n\n    // support mouse clicks \n    float mouseX = iMouse.x;\n    float mouseY = iMouse.y;\n    float mouseZ = iMouse.z;\n    float mouseW = iMouse.w;\n    \n    //float food = a.z + b.z + c.z + d.z;\n    float food = a.r + b.g+ c.z + d.z;\n    if ( food < 0.10 ) {\n     \tpressure = 0.;   \n     \tpopulation = 0.;   \n     \tdirection.x = 0.;   \n     \tdirection.y = 0.;  \n        amoeba.z = 0.;\n    }\n    \n  vec2  uv = (fragCoord.xy / iResolution.xy);\n  vec4  m  = iMouse / iResolution.xyxy;\n  float m0 = 0.;//(m.z > 0.0) ? 0.1 : 0.2;\n  float m1 = smoothbump(abs(m.z),0.1,uv.x) *\n             smoothbump(abs(m.w),0.1,uv.y);\n  float m2 = smoothbump(m.x,0.05,uv.x) *\n             smoothbump(m.y,0.05,uv.y);\n\t\tvec4 mouseClick = vec4(m1,m1,0.,0.5);\n\n    \n    \n   // tomachiAmp *= m1+m0+m2;\n    \n    if (iFrame < 400) {\n//population += 0.5;\n       //emit(left, vec2(10.));\n\n    }\n    \n    \n   // fragColor = vec4(population);\n    \n   \t//emit(uv,m.z);\n    fragColor = vec4(\n    \tdirection.x,\n    \tdirection.y,\n    \tpressure,\n    \therb.z\n    );\n    \n   fragColor = vec4(abs(amoeba*0.1)) + (vec4(pressure, herb.z,herb.x,1.)*0.1);\n  //  fragColor = vec4(abs(pressure) +m1, 0., 0.25, 0.);\n   // fragColor = vec4(m1, m2, m0, 0.);\n\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 384, 384, 415], [417, 535, 592, 649, 2261]], "test": "untested"}
{"id": "tdXBWX", "name": "Fake Smooth Sine SDF", "author": "blackle", "description": "tried to create a smooth sine wave SDF using standard SDF building techniques like space folding and smooth min. not exactly sine, but sure looks like it. real sine (with bounding planes) on the left, fake on the right", "tags": ["sdf"], "likes": 2, "viewed": 445, "published": 3, "date": "1589161623", "time_retrieved": "2024-07-30T21:07:22.982340", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat scene(vec2 p, bool real) {\n    float scale = mix(1., 20., sin(iTime)*.5+.5);\n    if (real) {\n        float d1 = (p.y+sin(p.x*scale))/scale/sqrt(2.);\n        return max(min(d1,p.y+1.),p.y-1.);\n    } else {\n    \tp.x = asin(sin(p.x*scale)*.9)/scale;\n    \tfloat d1 = dot(p, normalize(vec2(scale,1)));\n    \treturn -smin(1.-p.y, -smin(d1, p.y+1., 1./sqrt(scale)), 1./sqrt(scale));\n    }\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(clamp(log(abs(d)+1.0)*1.5, 0.0, 1.0));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    if (d > 0.0) {\n        //red tint\n        color *= vec3(1.0,0.56,0.4);\n    } else {\n        //blue tint\n        color *= vec3(0.4,0.9,1.0);\n        \n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=4.; mouse*=4.;\n    bool real = uv.x < 0.;\n    \n    float mousedist = scene(mouse, mouse.x < 0.);\n    fragColor = vec4(shadeDistance(scene(uv, real)), 1.);\n    if (iMouse.z > 0.) {\n        float pixelsize = 3./iResolution.y;\n        fragColor *= smoothstep(-pixelsize, pixelsize, distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBWX.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 233, 233, 304], [306, 306, 338, 338, 694], [696, 696, 725, 725, 1151], [1153, 1153, 1210, 1210, 1675]], "test": "untested"}
{"id": "WdXBWf", "name": "Voronoi on sphere attempt", "author": "Veggiebob", "description": "attempt to put voronoi on sphere", "tags": ["sdf"], "likes": 2, "viewed": 566, "published": 3, "date": "1589149403", "time_retrieved": "2024-07-30T21:07:23.719370", "image_code": "#define E 0.001\n#define balls 30\nstruct RayHit {\n    vec3 end;\n    float dist;\n    int steps;\n};\nvec2 rotate2D (vec2 p, float angle) {\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\n//most random stuff stolen from https://www.shadertoy.com/view/wdffWj\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) {\n    seed = s;\n}\nint rand(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return (seed >> 16) & 32767;\n}\n// --------------------------------------\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n ) {\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec3 randomOnSphere( void ) {\n    float theta = (6.283185 / 32767.0) * float(rand());\n    float u = (2.0 / 32767.0) * float(rand()) - 1.0;\n    return vec3(sqrt(1.0 - u * u) * vec2(cos(theta), sin(theta)), u);\n}\nvec3 randomUnitSphere (int t) {\n    return (vec3(\n        hash(t),\n        hash(t+8),\n        hash(t+10)\n       ) - 0.5\n    );\n}\nfloat sphere (vec3 p, float radius) {\n    return length(p) - radius;\n}\nfloat shell (float sdf, float thickness) {\n    return abs(sdf) - thickness / 2.;\n}\nfloat hollowSphere (vec3 p, float outerRadius, float thickness) {\n    //return abs(sphere(p, outerRadius - thickness / 2.)) - thickness / 2.;\n    return shell(sphere(p, outerRadius - thickness / 2.), thickness);\n}\nfloat comp (vec3 a, vec3 b) {\n    return dot(a, b) / length(b);\n}\nfloat voronoi (vec3 p) {\n    float vdist = 1000.;\n    float last_dist = vdist;\n    vec3 point = vec3(0.);\n    vec3 last_point = vec3(0.);\n    for (int i = 0; i<balls; i++) {\n        vec3 pos = 1.0 * normalize(randomUnitSphere(i));\n        float newDist = length(p-pos);\n        if (newDist < vdist) {\n            last_dist = vdist;\n            last_point = point;\n       \t\tvdist = newDist;\n            point = pos;\n        } else if (newDist < last_dist) {\n            last_dist = newDist;\n            last_point = pos;\n        }\n    }\n    //see https://www.shadertoy.com/view/3sfBDf\n    /*\n    float max_dist = length(point - last_point) / 2.;\n    float dist = comp2(uv-point, last_point - point);\n    float h = max_dist - dist;\n    float hp = h / max_dist;\n    vec3 col = vec3(smoothstep(0.0, 0.01, h));\n*/\n    float max_dist = length(point - last_point) / 2.;\n    float dist = comp(p-point, last_point-point);\n    float vd = abs(max_dist - dist);\n    return vd;\n}\nfloat sdf (vec3 p) {\n    float d = 10000.;\n    \n    float thickness = 0.03;\n    float radius = 0.7;\n    float wall_dist = voronoi(p) - 0.03;\n        //-sphere(p-point * (radius-thickness/2.), thickness*2.);\n    float hollow_sphere = \n        //abs(p.x) - 0.1;\n        hollowSphere(p, radius, thickness);\n   \td = min(d, max(wall_dist, hollow_sphere));\n    d = min(p.y - length(sin(p.xz * 2.)) * 0.2 + 2.5, d);\n    return d;\n}\nRayHit raymarch (vec3 origin, vec3 ray) {\n    vec3 p = origin;\n    int steps = 0;\n    float dist = 0.;\n    for (int i = 0; i<64; i++) {\n        p = origin + ray * dist;\n        float d = sdf(p);\n        dist += d * 0.8;\n        steps ++;\n    }\n    return RayHit(p, dist, steps);\n}\nvec3 estimateNormal (vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x+E, p.y, p.z))-sdf(vec3(p.x-E, p.y, p.z)),\n        sdf(vec3(p.x, p.y+E, p.z))-sdf(vec3(p.x, p.y-E, p.z)),\n        sdf(vec3(p.x, p.y, p.z+E))-sdf(vec3(p.x, p.y, p.z-E))\n    ));\n}\nvec3 getRay (vec3 cam, vec3 focusPoint, vec3 UP, float xFOV, float yFOV, vec2 uv) {\n    vec3 forward = normalize(focusPoint - cam);\n    vec3 right = cross(forward, UP);\n    vec3 up = cross(right, forward);\n    vec3 down = -up;\n    vec3 left = -right;\n    right = normalize(mix(forward, right, xFOV));\n    left = normalize(mix(forward, left, xFOV));\n    up = normalize(mix(forward, up, yFOV));\n    down = normalize(mix(forward, down, yFOV));\n    return normalize(mix(left, right, uv.x) + mix(down, up, uv.y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 realUV = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    float aspect = iResolution.y / iResolution.x;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    uv.x-=iResolution.x/iResolution.y/2.;\n    uv.y-=0.5;\n    uv*=2.0;\n    float perspective = 0.8;\n    vec3 cam = vec3(1., 0., 0.);\n    cam.xy = rotate2D(cam.xy, -mouse.y*5.0);\n    cam.xz = normalize(rotate2D(cam.xz, mouse.x*10.0));\n    cam.y = clamp(cam.y, -0.8, 0.8);\n    cam *= 2.;\n    \n    float fov = 0.8;\n    vec3 ray = getRay(cam, vec3(0.), vec3(0., 1., 0.), fov, fov * aspect, realUV);\n    \n    RayHit hit = raymarch(cam, ray);\n    vec3 normal = estimateNormal(hit.end);\n    \n    vec3 col = vec3(1.0);\n    vec3 ambient = vec3(0.5);\n    vec3 lightDir = normalize(vec3(1.0));\n    vec3 lightCol = vec3(1.0);\n    float diffuse = max(dot(normal, lightDir), 0.);\n    float specular = pow(max(dot(reflect(ray, normal), lightDir), 0.), 4.);\n   \tvec3 outCol = col * ambient + lightCol * (diffuse * 0.3 + specular * 0.2);\n    //if (hit.dist > 10.) outCol = vec3(0.);\n    outCol *= 1. / (1. + 0.01 * pow(hit.dist, 2.));\n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 134, 134, 216], [425, 425, 445, 445, 461], [462, 462, 478, 478, 551], [595, 746, 765, 765, 841], [886, 886, 915, 915, 1096], [1097, 1097, 1128, 1128, 1225], [1226, 1226, 1263, 1263, 1296], [1297, 1297, 1339, 1339, 1379], [1380, 1380, 1445, 1521, 1593], [1594, 1594, 1623, 1623, 1659], [1660, 1660, 1684, 1684, 2626], [2627, 2627, 2647, 2647, 3051], [3052, 3052, 3093, 3093, 3332], [3333, 3333, 3363, 3363, 3588], [3589, 3589, 3672, 3672, 4099], [4100, 4100, 4157, 4157, 5326]], "test": "untested"}
{"id": "tdfBW2", "name": "Experiment: Circle Inversion", "author": "blackle", "description": "a failed experiment in mapping SDFs using circle inversion. I thought that because circle inversion preserves circles, then we could map a signed distance in the same way. unfortunately, it only works locally", "tags": ["experiment", "inversion", "failed"], "likes": 10, "viewed": 605, "published": 3, "date": "1589142109", "time_retrieved": "2024-07-30T21:07:24.465375", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a, b-a)/dot(b-a,b-a);\n    return distance(p, mix(a, b, clamp(k, 0., 1.)));\n}\n\nvec2 proj(vec2 p) {\n    return p/dot(p,p);\n}\n\nfloat box(vec2 p, vec2 d) {\n    vec2 q = abs(p)-d;\n    return length(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nmat2 rot(float ro) {\n    float c = cos(ro);\n    float s = sin(ro);\n    return mat2(c,-s,s,c);\n}\n\nfloat scene2(vec2 p) {\n    p = rot(iTime)*(p-vec2(0.4,0.));\n    float ln = linedist(p, vec2(0.,.1), vec2(0.,-.1))-0.05;\n    float bx = box(p, vec2(.1));\n    return mix(ln, bx, smoothstep(-.2,.2,sin(iTime*0.5)));\n}\n\nfloat scene(vec2 p) {\n    vec2 p2 = proj(p);\n    float d = scene2(p2);\n    //since the centre of a circle doesn't map to the centre of its image,\n    //we need to iteratively update our estimate with the correct centre\n    for (int i = 0; i < 10; i++) {\n        //get the projected circle's centre\n    \tp2 = (proj(p-normalize(p)*d) + proj(p+normalize(p)*d))/2.;\n    \td = scene2(p2);\n        d = d/(dot(p2,p2)-d*d);\n    \td = clamp(d, -1.,1.); //if I don't clamp here, the distance estimate goes wild\n    }\n    return d;\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(clamp(log(abs(d)+1.0)*1.5, 0.0, 1.0));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    if (d > 0.0) {\n        //red tint\n        color *= vec3(1.0,0.56,0.4);\n    } else {\n        //blue tint\n        color *= vec3(0.4,0.9,1.0);\n        \n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=3.;\n    mouse*=3.;\n    uv.x += 1.8;\n    mouse.x += 1.8;\n\n    float mousedist = scene(mouse);\n    vec3 col = shadeDistance(scene(uv));\n    vec3 col2 = shadeDistance(scene2(uv));\n    if (iMouse.z > 0.) {\n        float pixelsize = 3./iResolution.y;\n        col *= smoothstep(-pixelsize, pixelsize, distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n    }\n\n    if (length(uv)>1.) {\n    \tfragColor = vec4(col,1.0);\n    } else {\n    \tfragColor = vec4(col2,1.0);\n    }\n    fragColor *= smoothstep(0.005, .015, abs(length(uv)-1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfBW2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 234, 234, 331], [333, 333, 352, 352, 377], [379, 379, 406, 406, 484], [486, 486, 525, 525, 596], [598, 598, 618, 618, 693], [695, 695, 717, 717, 908], [910, 910, 931, 931, 1430], [1432, 1432, 1461, 1461, 1887], [1889, 1889, 1946, 1996, 2649]], "test": "untested"}
{"id": "tssfW2", "name": "ShATI-Ombre: golfed (412 chars)", "author": "FabriceNeyret2", "description": "golfing  Flopine's [url]https://shadertoy.com/view/3slBDS[/url]  1279 chars.\n\ncould it be shorter ? :-)", "tags": ["raymarching", "animation", "isometric", "short", "golf", "3tweets", "motiondesign"], "likes": 4, "viewed": 391, "published": 3, "date": "1589133348", "time_retrieved": "2024-07-30T21:07:25.366964", "image_code": "// golfing Flopine's 1279 chars https://shadertoy.com/view/3slBDS\n\n// --- now in obfuscated golfing phase ( more readable in versions below )\n\n#define R      *= mat2( cos(  vec4(0,11,33,0)                               //\n#define B(b,c) m = length( max( q = abs( P = mod(P+b, b+b) - b ) - c , Z ))  \\\n                 + min( s = max(q.x,max(q.y,q.z)), Z ) ,                     \\\n               m > d ? d=m,S=q-s : S//\nvoid mainImage(out vec4 O, vec2 U) {\n    float  d=1., m,s, Z=0.,                                                  \\\n    t = iTime -.785,\n    a = sin(t);\n    vec3 q,S, P = iResolution,\n    p =  vec3( ( U+U - P.xy ) / P.y * ( sin(t-2.) < Z ? 2. : 9. ) , -20 );\n    for ( ; ++O.a < 66. && d > .01 ; p.z += d )\n        P = p,\n        P.yz R-.62 )),\n        P.xz R+.785)),   d = Z,\n        B(  P  , 5. ),\n        B( 2.5 , 2. ),\n        B(  .25, .2 + a * sqrt( .02/a - .01 )   );\n    d < .01 && S.x < Z ? O += S.z < Z ? 1. : .44 : O;\n} /*\n\n\n\n\n\n// --- 422 chars (from now getting a bit obfuscated )\n\n#define R      mat2( cos(  vec4(0,11,33,0)                                  //\n#define B(b,c) m = length( max( q = abs( P = mod(P -b, b+b) - b ) - c , 0.)) \\\n                 + min( s = max(q.x,max(q.y,q.z)), 0. ) ,                    \\\n               m > d ? d=m,Q=q,S=s : S//\n#define mainImage( O, U )                                                    \\\n    float  d=1., m,s,S,                                                      \\\n    t = iTime -.785,                                                         \\\n    a = sin(t);                                                              \\\n    vec3 q,Q, P = iResolution,                                               \\\n    p =  vec3( ( U+U - P.xy ) / P.y * ( sin(t-2.) < 0. ? 2. : 9. ) , -20 );  \\\n    for ( ; ++O.a < 66. && d > .01 ; p.z += d )                              \\\n        P = p,                                                               \\\n        P.yz *= R-.62 )),                                                    \\\n        P.xz *= R+.785)),   d = 0.,                                          \\\n        B(  P  , 5.  ),                                                      \\\n        B( 2.5 , 2.  ),                                                      \\\n        B(  .25, .2 + .1 * a * sqrt( 2./abs(a) - 1. )   );                   \\\n    d < .01 && S > Q.x ? O += S > Q.z ? 1. : .44 : O                        /*\n\n\n\n\n\n// --- 438 chars\n\n#define r(a)   mat2( cos( a + vec4(0,11,33,0) ) )                           //\n#define B(b,c) m = length( max( q = abs( P = mod(P -b, b+b) - b ) - c , 0.)) \\\n                 + min( s = max(q.x,max(q.y,q.z)), 0. ) ,                    \\\n               m > d ? d=m,Q=q,S=s : S                                      //\n#define mainImage( O, U )                                                    \\\n    float  d=1., i=d, m,s,S,                                                 \\\n    t = iTime -.785,                                                         \\\n    a = sin(t);                                                              \\\n    vec3 q,Q, P = iResolution,                                               \\\n    p =  vec3( ( U+U - P.xy ) / P.y * ( sin(t-2.) < 0. ? 2. : 9. ) , -20 );  \\\n    for ( ; ++i < 66. && d > .01 ; p.z += d )                                \\\n        P = p,                                                               \\\n        P.yz *= r(-.62),                                                     \\\n        P.xz *= r(.785),   d = 0.,                                           \\\n        B(  P  , 5.  ),                                                      \\\n        B( 2.5 , 2.  ),                                                      \\\n        B(  .25, .2 + .1 * sign(a) * sqrt( abs(a+a) - a*a )   );             \\\n    d < .01 && S != Q.x ? O += S==Q.y ? 1. : .44 : O                        /*\n\n\n\n\n\n// --- 504 chars\n\n#define r(a)    mat2(cos(a+vec4(0,11,33,0)))                            //\n#define B(p,c)  q = abs(p)-c,                                            \\\n                m = min(0.,s=max(q.x,max(q.y,q.z))) + length(max(q,0.)), \\\n                m>M? M=m,Q=q,S=s :S\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float  d=1., i=d,M,m,s,S,\n    t = mod( iTime -.785, 6.283 ),\n    a = sin( t );\n    a = sign(a) * sqrt( abs(a+a) - a*a );\n    vec3  q,Q,P,o, R = iResolution,\n    p =  vec3( ( U+U - R.xy ) / R.y * mix(2.,9.,ceil(sin(t-2.))), -20 );\n    \n    for ( O-=O ; ++i<66. && d>.01 ; p.z += d = M )\n        o = p,\n        o.yz *= r(-.62),\n        o.xz *= r(.785), M=0.,\n        B( o , 5.),\n        B( P = mod(o -2.5, 5.) - 2.5 , 2.      ),\n        B(     mod(P-.25,  .5) - .25 , .2+a*.1 );\n\n    d<.01 ? O +=  S==Q.x? 0. : S==Q.y? 1. : .44\n          : O;\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssfW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3dsfRs", "name": "Tribute - Sky", "author": "Iris_", "description": "base on work https://www.shadertoy.com/view/llfXW8 and https://www.shadertoy.com/view/XtS3DD", "tags": ["raymarching"], "likes": 3, "viewed": 260, "published": 3, "date": "1589130406", "time_retrieved": "2024-07-30T21:07:26.311439", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n// float tasd[1] = {0.1};\n\nfloat kernel[7] = float[7](0.017649,\t0.02324,\t0.027413,\t0.028964,\t0.027413,\t0.02324,\t0.017649);\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 c = texture(iChannel0, uv);\n\t\t\n    //declare stuff\n    const int mSize = 7;\n    const int kSize = (mSize-1)/2;\n    //float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy + 1. *vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec3 bgcolor1 = texture(iChannel1, uv).rgb;\n    vec3 bgcolor = mix(bgcolor1, c.rgb, c.g);\n    \n    float luma = (bgcolor.r + bgcolor.g + bgcolor.b) * 0.1;\n    bgcolor -= (luma) * vec3(.9, .5, .0) * clamp(uv.y - 0.5, 0.0, 1.0);\n    \n    bgcolor += vec3(.2, 0.2, 0.3) * abs(clamp(uv.y - 0.5, -1.0, .0));\n\n\n    fragColor = vec4(final_colour/(Z*Z) * 0.2 + bgcolor, 1.0);\n    \n    // fragColor += vec4(texture(iChannel1, uv));\n\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Cloud Ten\n//by nimitz 2015 (twitter: @stormoid)\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n// https://www.shadertoy.com/view/XtS3DD\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat noise(float t){return textureLod(iChannel0,vec2(t,.0)/iChannelResolution[0].xy,0.0).x;}\nfloat moy = 0.;\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\nfloat path(in float x){ return sin(x*0.01-3.1415)*28.+6.5; }\nfloat map(vec3 p){\n    return p.y*0.07 + (fbm(p*0.3)-0.1) + sin(p.x*0.24 + sin(p.z*.01)*7.)*0.22+0.15 + sin(p.z*0.08)*0.15;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n    float precis = 0.3;\n    float h= 1.;\n    float d = 0.;\n    for( int i=0; i<17; i++ )\n    {\n        if( abs(h)<precis || d>70. ) break;\n        d += h;\n        vec3 pos = ro+rd*d;\n        pos.y += .5;\n\t    float res = map(pos)*7.;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 lgt = vec3(0);\nfloat mapV( vec3 p ){ return clamp(-map(p), 0., 1.);}\nvec4 marchV(in vec3 ro, in vec3 rd, in float t, in vec3 bgc)\n{\n\tvec4 rz = vec4( 0.0 );\n\t\n\tfor( int i=0; i<150; i++ )\n\t{\n\t\tif(rz.a > 0.99 || t > 200.) break;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n        float den = mapV(pos);\n        \n        vec4 col = vec4(mix( vec3(.85,.85,.90), vec3(.0), den ),den);\n        col.xyz *= mix(bgc*bgc*2.5,  mix(vec3(0.1,0.2,0.35),vec3(.1,.85,.9),moy*0.4), clamp( -(den*40.+0.)*pos.y*.03-moy*0.5, 0., 1. ) );\n        col.rgb += clamp((1.-den*6.) + pos.y*0.13 +.55, 0., 1.)*0.35*mix(bgc,vec3(1),0.7); //Fringes\n        col += clamp(den*pos.y*.15, -.02, .0); //Depth occlusion\n        col *= smoothstep(0.2+moy*0.05,.0,mapV(pos+1.*lgt))*.85+0.15; //Shadows\n        \n\t\tcol.a *= .95;\n\t\tcol.rgb *= col.a;\n\t\trz = rz + col*(1.0 - rz.a);\n\n        t += max(.3,(2.-den*30.)*t*0.011);\n\t}\n\n\treturn clamp(rz, 0., 1.);\n}\n\nfloat pent(in vec2 p){    \n    vec2 q = abs(p);\n    return max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y), -p.y*1.237)*1.;\n}\n\nvec3 lensFlare(vec2 p, vec2 pos)\n{\n\tvec2 q = p-pos;\n    float dq = dot(q, q);\n    vec2 dist = p*(length(p))*0.75;\n\tfloat ang = atan(q.x,q.y);\n    vec2 pp = mix(p, dist, 0.5);\n    float sz = 0.01;\n    float rz = 0.;\n\n\trz += clamp(sz-pow(pent(pp + 0.15*pos),1.55),.0, 1.)*5.0;\n\trz += clamp(sz-pow(pent(pp + 0.1*pos),2.4),.0, 1.)*4.0;\n\trz += clamp(sz-pow(pent(pp - 0.05*pos),1.2),.0, 1.)*4.0;\n    rz += clamp(sz-pow(pent((pp + .5*pos)),1.7),.0, 1.)*4.0;\n    rz += clamp(sz-pow(pent((pp + .3*pos)),1.9),.0, 1.)*3.0;\n    rz += clamp(sz-pow(pent((pp - .2*pos)),1.3),.0, 1.)*4.0;\n    return vec3(clamp(rz,0.,1.));\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tfloat asp =iResolution.x/iResolution.y;\n    p.x *= asp;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n    mo = vec2(0., 0.);\n\tmoy = mo.y;\n    float st = 0.; //sin(time*0.3-1.3)*0.2;\n    vec3 ro = vec3(0.,0.,time*10.);\n    ro.x = path(ro.z);\n    vec3 ta = ro + vec3(0,0,1);\n    vec3 fw = vec3(0,0,1); //normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), fw ));\n    vec3 vv = normalize(cross(fw,uu));\n    const float zoom = 1.;\n    vec3 rd = normalize( p.x*uu + p.y*vv + -zoom*fw );\n    \n    float rox = 2.9; //sin(time*0.2)*0.6+2.9;\n    rox += smoothstep(0.6,1.2,sin(time*0.25))*3.5;\n   \tfloat roy = 0.; //sin(time*0.5)*0.2;\n    mat3 rotation = rot_x(-roy)*rot_y(3.14 + st*1.5)*rot_z(st);\n\tmat3 inv_rotation = rot_z(-st)*rot_y(-3.14-st*1.5)*rot_x(roy);\n    rd *= rotation;\n    rd.y -= dot(p,p)*0.06;\n    rd = normalize(rd);\n    \n    vec3 col = vec3(0.);\n    lgt = normalize(vec3(-0.3,mo.y+0.1,1.));  \n    float rdl = clamp(dot(rd, lgt),0.,1.);\n\n    col = texture(iChannel1,q - 0.001 * vec2(ro.x, 0.)).xyz;\n    vec3 bgc = col;\n    \n    float rz = march(ro,rd);\n    \n    if (rz < 70.)\n    {   \n        vec4 res = marchV(ro, rd, rz-5., vec3(0.6));\n        // if(res.w > 0.5) col = res.xyz;\n        \n    \tcol = mix(res.xyz, col, 1. - res.w);\n    }\n    \n    vec3 proj = (-lgt*inv_rotation);\n    col += 5.*vec3(0.7,0.7,0.4)*clamp(lensFlare(p,-proj.xy/proj.z*zoom + vec2( 0.35, 0.15))*proj.z,0., 1.);\n    \n    float g = smoothstep(0.03,.97,mo.x);\n    col = mix(mix(col,col.brg*vec3(1,0.75,1),clamp(g*2.,0.0,1.0)), col.bgr, clamp((g-0.5)*2.,0.0,1.));\n    \n\tcol = clamp(col, 0., 1.);\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col); //saturation\n    col = pow(col, vec3(0.416667))*1.055 - 0.055; //sRGB\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n\n\tfragColor = vec4( col, 1.0 );\n    fragColor += vec4(.54, 0.54, 0.54, 0.0) * abs(clamp(rd.y, -1.0, .0));\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// what the hell did iq use in graphtoy?\nfloat noise( float x )\n{\n    return sin(x * 6.0) * 0.1 + sin(x * 3.0) * 0.1 + sin(x * 1.5) * 0.1;\n}\n\n\nfloat random1(vec2 p) {\n  return fract(sin(dot(p, vec2(456.789, 20487145.123))) * 842478.5453);\n}\n\nfloat random1( vec3 p ) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\nfloat interpNoise3D1(vec3 p) {\n  vec3 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec3(1.0,0.0,0.0));\n  float ulb = random1(floor(p) + vec3(0.0,1.0,0.0));\n  float urb = random1(floor(p) + vec3(1.0,1.0,0.0));\n\n  float llf = random1(floor(p) + vec3(0.0,0.0,1.0));\n  float lrf = random1(floor(p) + vec3(1.0,0.0,1.0));\n  float ulf = random1(floor(p) + vec3(0.0,1.0,1.0));\n  float urf = random1(floor(p) + vec3(1.0,1.0,1.0));\n\n  float lerpXLB = mySmootherStep(llb, lrb, pFract.x);\n  float lerpXHB = mySmootherStep(ulb, urb, pFract.x);\n  float lerpXLF = mySmootherStep(llf, lrf, pFract.x);\n  float lerpXHF = mySmootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = mySmootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = mySmootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return mySmootherStep(lerpYB, lerpYF, pFract.z);\n}\n\nfloat Worley(vec2 P)\n{\n    float Dist = 1.;\n    vec2 I = floor(P);\n    vec2 F = fract(P);\n    \n    for(int X = -1; X<=1; X++)\n    for(int Y = -1; Y<=1; Y++)\n    {\n        float D = distance(random2(I+vec2(X,Y))+vec2(X,Y),F);\n        Dist = min(Dist,D);\n    }\n    return Dist;\n\t\n}\n\nfloat fbm(vec3 p, float octaves) {\n  float amp = 0.5;\n  float freq = 8.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise3D1(p * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\n\nfloat basicline1(float x)\n{\n    return clamp(2.0*(1. - abs(x)), 0., 1.);\n}\n\nfloat basicline2(float x)\n{\n    return pow(pow(noise(x * 4.0) + noise(x * 0.3) * 4.0, 2.0), 1.5) * basicline1(x * 0.6) * 0.8;\n}\n\nfloat basicline3(float x)\n{\n    return pow(1.0 - abs(x), 2.0) * basicline1(x * 1.2);\n}\n\nfloat basicline4(float x)\n{\n    // mountain\n    float t = 4.0*sin(x * 0.9)/x+0.03*sin(x*10.0)+0.02*sin(x*20.0); \n    x *= 0.7;\n    // noise\n    t += basicline2(x*3.0)*1.8 + basicline2(x* 0.2);\n    t += basicline3(x * 3.0) * 2.4 + basicline3(x * 5. - 2.) * 0.6;\n    return t;\n}\n\nfloat basicline5(float x)\n{\n    return abs(x) * 0.3 + 4. + noise(x * 0.2) * 0.5;\n}\n\nfloat drawcloud(vec2 uv)\n{\n    float t = basicline5(uv.x);\n    //if(t > uv.y) return 1.;\n    float m = uv.y - t;\n    m = clamp(m*0.25, 0., 1.) + 0.1;\n    m = m * m * (3. - 2.*m);\n    return mix(fbm(vec3(uv * 0.02, iTime * 0.1), 8.), 1., m);\n}\n    \nvec3 drawCastle(vec2 uv)\n{\n    if(uv.y + 2.1 < basicline4(uv.x * 0.8)) return vec3(169., 197., 211.0) / 255. * 0.9;\n    return mix(vec3(1.) * 0.95, vec3(169., 197., 211.0) / 255. * 0.95 , drawcloud(uv) * 0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/res.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p = (p) * 9.0;\n    \n\n\n    fragColor = vec4(drawCastle(p), 1.);\n    \n    float luma = (fragColor.r + fragColor.g + fragColor.b) * 0.1;\n    fragColor -= (luma) * vec4(.9, .5, .0, 1.) * clamp(p.y * 0.1 - 0.05, 0.0, 1.0);\n    \n}", "buffer_b_inputs": [], "buffer_c_code": "// https://www.shadertoy.com/view/llfXW8\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nconst float mouseRotateSpeed = 5.0;\n\nstruct sdObject\n{\n    vec3 pos;\n    float rad;\n    int index;\n};\n\n// Amount of butterflies    \n#define OBJECTS 40\n    \nsdObject sdObjects[OBJECTS];    \n\n// objects that will be potentially hit, found at prestep\n#define CACHED 5\nsdObject cachedObjects[CACHED];\n\nint maxCacheIndex = 0;\n    \n// distance functions from https://iquilezles.org/articles/distfunctions\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n//// \n\nconst float MATERIAL_BODY = 0.0;\nconst float MATERIAL_WING = 1.0;\n\n\nconst float OBJECT_SIZE = 0.5;    \nvec2 getModel(in vec3 pos, int index)\n{\n    float phase = float(index);\n    float l = length(pos);\n\t\n    float bl = (sin(pos.z * 12.0 - 5.0) * 0.5 + 0.5) + 0.3;\n        \n\n    float wx = max(abs(l * 6. + .2) - .4, 0.0);\n    float sl = 1.5* abs(sin(wx)) + 0.05;\n    \n    vec3 wing = vec3(OBJECT_SIZE * 0.5, OBJECT_SIZE * 0.01, OBJECT_SIZE * 0.25 * sl);\n    \n    float w1 = udBox(rotz(sin(iTime * 10.0 + phase)) * pos - vec3(OBJECT_SIZE * 0.5, OBJECT_SIZE * 0., 0.0), wing);\n    float w2 = udBox(rotz(-sin(iTime * 10.0 + phase)) * pos + vec3(OBJECT_SIZE * 0.5, OBJECT_SIZE * 0., 0.0), wing);\n    \n    float w3 = sdSphere(pos - vec3(OBJECT_SIZE * 0.5, OBJECT_SIZE * 0., 0.0), 0.07);\n    \n    float id = MATERIAL_BODY;\n\n    id = MATERIAL_WING;\n    \n    \n    float m = min(w1, w2);\n    if(index % 3 != 0)\n        m = w3;\n    \n    return vec2(m, id);\n            \n}\n\n// return vec2(distance, id)\n\nvec2 map(in vec3 rp, in sdObject[CACHED] objects, inout vec3 localPos, inout int index)\n{\n    float m = 9999.0;\n    vec2 ret = vec2(m, 0.0);\n    \n    for (int i = 0; i < CACHED; ++i)\n    {\n        if ( i <= maxCacheIndex)\n        {\n            vec3 lp = rp - objects[i].pos;\n            vec2 mat = getModel(lp, objects[i].index);     \n            float a = min(mat.x, m);\n            if (a < m)\n            {\n                m = a;\n                ret = mat;\n                localPos = lp;\n                index = objects[i].index;\n            }\n        }\n    }    \n    return ret;\n}\n\n/**\n * In the pre-step function I find objects that will be potentially hit.\n * I will check only against these objects at later steps.\n */\nfloat prestep(in vec3 ro, in vec3 rp, in vec3 rd, in vec3 rd90degXAxis, in vec3 rd90degYAxis)\n{\n    maxCacheIndex = -1;\n    float m = 99999.0;\n    for (int i = 0; i < OBJECTS; ++i)\n    {\n        vec3 sp = -ro + sdObjects[i].pos;\n        \n        float distToPlaneY = abs(dot(rd90degYAxis, sp));\n    \tfloat distToPlaneX = abs(dot(rd90degXAxis, sp));\n        \n        float distanceToPlanes = max(distToPlaneY, distToPlaneX);\n        distanceToPlanes = distanceToPlanes - sdObjects[i].rad;\n\n        vec2 mat = getModel(rp - sdObjects[i].pos * (1.0 + distanceToPlanes), sdObjects[i].index);\n        float l = mat.x;\n        m = min(m, l);\n        \n        if(distanceToPlanes <= 0.0 && ++maxCacheIndex < CACHED)\n        {\n            if (maxCacheIndex == 0) cachedObjects[0] = sdObjects[i];\n            else if (maxCacheIndex == 1) cachedObjects[1] = sdObjects[i];\n            else if (maxCacheIndex == 2) cachedObjects[2] = sdObjects[i];\n            else if (maxCacheIndex == 3) cachedObjects[3] = sdObjects[i];\n            else if (maxCacheIndex == 4) cachedObjects[4] = sdObjects[i];\n            else return m;    \n            \n        }\n    }\n    \n    return m;\n}\n\n\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 ro = rp;\n    float travel = 0.0;\n    const int STEPS = 50;\n    // build orthonormal frame to get right and up vectors to be used in distance calculations \n    vec3 tmp = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(rd, tmp));\n    vec3 right = cross(rd, up);\n    \n    // pre-step and move ray\n    travel = prestep(ro, rp, rd, right, up);\n    rp += travel * rd;\n    \n    vec3 local = vec3(0.0);\n    int hitindex = 0;\n    \n    for (int i = 0; i < STEPS; ++i)\n    {\n       vec2 mat = map(rp, cachedObjects, local, hitindex);\n       float dist = mat.x;\n        \n       if(dist <= 0.0)\n       {\n           float id = mat.y;\n           float indx = float(hitindex);\n           float c1 = sin(indx * 10.) * 0.5;\n           float c2 = abs(cos(abs(local.z * 15.0)) + sin(abs(local.x) * 15.0));\n           float c3 = cos(indx * 0.4);\n           // color = vec4(mat.y, c2 * mat.y + 0.5, c1 * mat.y, 1.0) * abs(sin(indx * 0.1));\n           float t = mix(1.1, 1. - abs(rd.y - 0.5), 0.3) + 0.2 * c1;\n           color = vec4(1, 1, 0.8, 1) * t;\n           color.a = 1.0;\n               \n           return;\n       }\n       float dst = max(0.01, dist);\n       travel += dst;\n       rp += rd * dst;\n       if(travel > 30.0) return;\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= vec2(0.5);\n    mouse = vec2(0);\n    \n    if(mouse.xy == vec2(-0.5))\n    {\n        mouse = vec2(0.0);\n    }\n    \n    mouse *= mouseRotateSpeed;\n    \n\n    for (int i = 1; i < OBJECTS; ++i)\n    {\n        float times = 0.45f;\n        if(i % 3 != 0) times = 0.3f;\n        vec3 p = (texture(iChannel0, sin(times * iTime * 0.001) + 0.21 * vec2(float(i))) - vec4(0.5)).rgb;\n        p *= roty(iTime * 2.0 * times);\n        p.z += (sin(iTime * times) * 0.25 + 0.5) * 1.0 + 0.6;\n        p.x *= 1.0 + (sin(iTime * 0.051 * times) * 0.5 + 0.5) * 0.25;\n        p.y *= 1.0 + (cos(iTime * 0.051 * times) * 0.5 + 0.5) * 0.25 + sin(times * iTime / 10.);\n      \n        sdObjects[i] = sdObject(p * 10.0, OBJECT_SIZE * 1. , i);\n    }\n    \n    vec3 rp = vec3(0.0, .0, 1.0);\n    vec3 rd = normalize(vec3(uv, 0.3));\n    \n    rd *= rotx(mouse.y);\n    rd *= roty(mouse.x);\n    \n    trace(rp, rd, fragColor);\n    fragColor = mix(fragColor, vec4(0,0,0,0), 1.0 - fragColor.a);\n    \n\n    \n    // float luma = (fragColor.r + fragColor.g + fragColor.b) * 0.1;\n    // fragColor -= (luma) * vec4(.9, .5, .0, 1.) * clamp(rd.y - 0.05, 0.0, 1.0);\n    \n    // fragColor += vec4(.4, 0.4, 0.0, 0.0) * abs(clamp(rd.y, -1.0, .0));\n\t\n    // frame\n    // fragColor = mix(fragColor, vec4(0.0), 1.0 - smoothstep(0.5, 0.45, abs(uv.x)));\n    // fragColor = mix(fragColor, vec4(0.0), 1.0 - smoothstep(0.28, 0.2, abs(uv.y)));\n    \n}", "buffer_c_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\n\nvec3 rotateX(in vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k - abs(a - b), 0.0f)/k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\nfloat planeSDF(vec3 samplePoint)\n{\n    samplePoint = rotateZ(samplePoint, -1.57 + sin(iTime * 0.1 + 1.57));\n    samplePoint = rotateY(samplePoint, sin(iTime*1.25 + 1.57) * 0.1 - 1.57);\n    samplePoint *= 4.;\n    const float k = 0.03; // or some other amount\n    vec3 p = samplePoint;\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m * p.xz;\n    vec3  q = vec3(xz.x,p.y,xz.y);\n    samplePoint = q;\n\n    float t1 = udTriangle(samplePoint, vec3(0,0.05,0), vec3(2,0,0), vec3(0,1,-0.05));\n    float t2 = udTriangle(samplePoint, vec3(0,-0.05,0), vec3(2,0,0), vec3(0,-1,-0.05));\n    float t3 = udTriangle(samplePoint, vec3(0,-0.05,0), vec3(2,0,0), vec3(-0.2,0,-0.5));     \n    float t4 = udTriangle(samplePoint, vec3(0,0.05,0), vec3(2,0,0), vec3(-0.2,0,-0.5));\n\n    \n    return min(min(t1, t2), min(t3, t4)) / 4.; \n}\n\nfloat traceSDF(vec3 samplePoint)\n{\n    samplePoint = rotateX(samplePoint, 1.57 );\n    \n    float k = 0.05 * abs(samplePoint.y) * sin(iTime * 0.1 + samplePoint.y * 0.3 + 1.57);\n    float k2 = 0.02 * abs(samplePoint.y) * sin(iTime * 1.25 + samplePoint.y * 0.3 + 2.5);\n\n    samplePoint.x += k;\n    samplePoint.z += k2;\n    \n    float t1 = sdCone(samplePoint + vec3(0, 0.4, 0), vec2(1., 0.01), 20.);\n    float t2 = sdCone(samplePoint + vec3(0, 2, 0), vec2(1., 0.08), 20.);\n    return smin(t1, t2, 0.1);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float t1 = planeSDF(samplePoint);\n    float t2 = traceSDF(samplePoint);\n    \n    // return blend(t1, t5);\n    return min(t1, t2);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nfloat calculateTrace(vec3 p, vec3 dir)\n{\n    float t = 1.0;\n    float dis = 0.2;\n    for (int i = 0; i < 10; i++) {\n        p += dir * dis;\n        float dist = traceSDF(p);\n        dist = min(dist, 0.);\n        t += dist * 3.;\n    }\n    t = max(t, 0.01);\n    return 1. - t;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvoid coordinateSystem(const vec3 v1, out vec3 v2, out vec3 v3) {\n    \n    if (abs(v1.x) > abs(v1.y)) {\n        v2 = vec3(-v1.z, 0, v1.x) / length(v1.xz);\n    }\n    else {\n        v2 = vec3(0, v1.z, -v1.y) / length(v1.yz);\n    }\n    v3 = cross(v1, v2);\n}\n\nvec2 random2(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\n\nconst int AO_SAMPLES = 50; \nfloat computeAO(vec3 p, vec3 n, float dist) {\n    // return planeSDF(p + n * dist) * 100.;\n    float aoSum = 0.0;\n    // Sample a few points in the hemisphere around n at p\n    vec3 t, b;\n    // Make a tangent and bitangent vector\n    coordinateSystem(n, t, b);\n    for(int i = 0; i < AO_SAMPLES; ++i) {\n        // Generate a pair of random [0, 1] floats\n        vec2 xi = random2(p + float(i) * 203.1);\n        // Convert the xi pair to a vector in the hemisphere\n        float len = sqrt(xi.y);\n        float rx = len * cos(6.2831 * xi.x);\n        float ry = len * sin(6.2831 * xi.x);\n        float rz = sqrt(1.0 - xi.y); // z = sqrt(1 - x*x - y*y)\n        vec3 dir = vec3(rx * t + ry * b + rz * n);\n        aoSum += planeSDF(p + dir * dist);\n    }\n    return aoSum / float(AO_SAMPLES);\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, vec3 N) {\n\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    vec3 N = estimateNormal(p);\n    vec3 ambientLight = vec3(1.0, 1.0, 1.0);\n    ambientLight *= computeAO(p, N, 0.1) * 10. + 0.2;\n    \n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(0.0, 0.0, 10.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4) * 10.;\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity, N);\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/res.xy;\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(sin(iTime / 10. + 1.57), 0.7, 7.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    vec4 bgcolor = texture(iChannel0,uv);\n    // bgcolor = vec4(1, 0, 0, 1);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = bgcolor;\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    vec4 color;\n    if(traceSDF(p) < EPSILON)\n    {\n        float m = calculateTrace(p, dir);\n        color = vec4(1.0);\n        color.a = abs(uv.y) * 10. * m + 0.05;\n        // color.a = 1.0;\n    }\n    else\n    {\n        vec3 K_a = vec3(0.2, 0.2, 0.2) * 5.;\n        vec3 K_d = vec3(0.8, 0.8, 0.8);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 5.0;\n\n        color = vec4(phongIllumination(K_a, K_d, K_s, shininess, p, eye), 0.8);\n    }\n    \n    fragColor = mix(bgcolor, vec4(color.xyz, 1.0), color.a);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 211, 211, 264], [267, 267, 324, 324, 1488]], "test": "untested"}
{"id": "3slfW2", "name": "Raymarched Moonscape", "author": "dean_the_coder", "description": "Raymarching a lunar landscape.\nIf anyone has any hints and tips they could suggest, they would be welcome! I'm trying to learn. :)", "tags": ["procedural", "3d", "raymarching", "moon"], "likes": 14, "viewed": 459, "published": 3, "date": "1589126996", "time_retrieved": "2024-07-30T21:07:27.071407", "image_code": "// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat hash(vec2 p) { return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3); }\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p),\n\t     f = fract(p);\n\tfloat a = hash(i),\n\t      b = hash(i + vec2(1, 0)),\n\t      c = hash(i + vec2(0, 1)),\n\t      d = hash(i + vec2(1));\n\tf = f * f * (3. - 2. * f);\n\treturn mix(a, b, f.x) + (c - a) * f.y * (1. - f.x) + (d - b) * f.x * f.y;\n}\n\nfloat fbm(vec2 p) {\n\tfloat f = 0.;\n\tf += .5 * noise(p * 1.1);\n\tf += .22 * noise(p * 2.3);\n\tf += .155 * noise(p * 3.9);\n\tf += .0625 * noise(p * 8.4);\n\tf += .03125 * noise(p * 15.);\n\treturn f;\n}\n\nfloat smoothBounds(float a, float b, float v) {\n\tfloat midPoint = a + (b - a) * .5;\n\treturn smoothstep(a, midPoint, v) * smoothstep(b, midPoint, v);\n}\n\nfloat stars(vec2 uv) { return smoothBounds(.195, .2, fbm(uv * 1e2)); }\n\nfloat rfbm(vec2 xz) { return abs(2. * fbm(xz) - 1.); }\n\nfloat sdEarth(vec3 p) { return length(p - vec3(0, -.8, 2)) - .7; }\n\nfloat sdTerrain(vec3 p) {\n\tif (p.y > 0.) return 1e10;\n\tfloat h = rfbm(p.xz * .2);\n\tp.xz += vec2(1);\n\th += .5 * rfbm(p.xz * .8);\n\th += .25 * rfbm(p.xz * 2.);\n\th += .03 * rfbm(p.xz * 16.1);\n\th *= .7 * fbm(p.xz);\n\th -= .7;\n\treturn abs(p.y - h) * .6;\n}\n\nvec2 map(vec3 p) {\n\tfloat d1 = sdTerrain(p),\n\t      d2 = sdEarth(p);\n\treturn d1 < d2 ? vec2(d1, 1) : vec2(d2, 2);\n}\n\nvec3 calcNormal(vec3 p) {\n\tconst vec2 e = vec2(1, -1) * 29e-5;\n\treturn normalize(e.xyy * map(p + e.xyy).x + e.yyx * map(p + e.yyx).x + e.yxy * map(p + e.yxy).x + e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 origin, vec3 lightOrigin) {\n\tfloat s = 1.,\n\t      d = .1;\n\tvec3 rayDir = normalize(lightOrigin - origin);\n\twhile (d < 10. && s > 0.) {\n\t\tfloat distToObj = map(origin + rayDir * d).x;\n\t\ts = min(s, distToObj / d);\n\t\td += clamp(distToObj, .2, 1.);\n\t}\n\treturn smoothstep(0., 1., s);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec3 p, col,\n\t     rd = normalize(vec3(uv, 1));\n\tfloat d = .01,\n\t      id = 0.;\n\tfor (float steps = 0.; steps < 80.; steps++) {\n\t\tp = vec3(0, 0, -3) + rd * d;\n\t\tvec2 h = map(p);\n\t\tif (abs(h.x) < .004 * d) {\n\t\t\tid = h.y;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (d > 5.) break;\n\t\td += h.x;\n\t}\n\n\tif (id < .5) col = vec3(stars(uv));\n\telse {\n\t\tvec3 sunPos = vec3(8. - 16. * iMouse.x / iResolution.x, 6. - cos(iTime * .2), -1. - iMouse.y / 18.),\n\t\t     n = calcNormal(p),\n\t\t     mainLight = vec3(1.82, 1.8, 1.78) * dot(n, normalize(sunPos - p));\n\t\tif (id > 1.5) {\n\t\t\tcol = mix(mix(mix(vec3(.05, .05, .8), vec3(.05, .25, .05), smoothstep(.4, .52, fbm(n.xy * 3.1 + vec2(iTime * .05, 0)))), vec3(1), smoothstep(.8, .95, n.y) * smoothstep(.1, .8, fbm(n.xz * 10. + vec2(iTime * .1, 0)))), vec3(.3, .5, .95), smoothstep(-.5, 0., n.z));\n\t\t\tcol *= mainLight;\n\t\t}\n\t\telse if (id > .5) col = vec3(.5) * mainLight * pow(calcShadow(p, sunPos), 2.);\n\t}\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 116, 116, 176], [178, 178, 199, 199, 460], [462, 462, 481, 481, 654], [656, 656, 703, 703, 806], [808, 808, 830, 830, 878], [880, 880, 901, 901, 934], [936, 936, 959, 959, 1002], [1004, 1004, 1029, 1029, 1252], [1254, 1254, 1272, 1272, 1369], [1371, 1371, 1396, 1396, 1561], [1563, 1563, 1612, 1612, 1865], [1867, 1867, 1919, 1919, 2943]], "test": "untested"}
{"id": "tdsBDB", "name": "psychedelic fractal", "author": "unnick", "description": "while i was making the [url=https://www.shadertoy.com/view/3dfBWj]laser show[/url] shader, i made this sort-of fractal that uses the same algorithm but i use it with broken inputs.", "tags": ["2d"], "likes": 3, "viewed": 480, "published": 3, "date": "1589126581", "time_retrieved": "2024-07-30T21:07:27.841349", "image_code": "#define res iResolution.xy\n#define tau 6.283\n#define eps .01\n\nfloat sdf(vec2 p) {\n    float dist = length(p) - .5;\n    dist = min(dist, p.y + 1.);\n    dist = min(dist, 1. - p.y);\n    dist = min(dist, p.x + res.x/res.y);\n    dist = min(dist, res.x/res.y - p.x);\n    return dist;\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y;\n    for(int i = 0; i < 32; i++) {\n        float dist = sdf(pos)*2.;\n        if(abs(dist) < .01) break;\n        pos += dist * vec2(sin((vec2((i+1)*(i+1))*iTime*.001 + vec2(0,.25)) * tau));\n    }\n    col = vec4(normalize(pos) * .5 + .5, 0, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 81, 81, 279], [281, 281, 326, 326, 613]], "test": "untested"}
{"id": "WsByzK", "name": "Raymarching plane height map", "author": "ciphered", "description": "A great shader if you are used to manipulate 2d textures and want to add depth to your renders.\nhttps://instagram.com/ciphrd", "tags": ["raymarchingheightmapplanedepth"], "likes": 16, "viewed": 1353, "published": 3, "date": "1589122849", "time_retrieved": "2024-07-30T21:07:28.681104", "image_code": "// @author ciphered <https://ciphrd.com>\n// @license MIT\n//\n// -----------\n//\n// This shader was made to be working with a vertical plane, parallel to the view screen,\n// passing by (0;0;0). This constraint allows for great optimizations, because this shader \n// is intended to be working along texture manipulations to play with the surface.\n//\n// 2 parallel planes are defined in the space, in front of the camera, with a gap between\n// them corresponding to the DEPTH parameter. For each ray casted from the camera, we first\n// find the intersection between the ray and the first plane. From there, we start marching\n// along the ray and sample the height map at each step to find if whether we're in the\n// volume or not. Once we reach a point within the volume, we can find the point that belongs\n// to the surface and light it accordingly by computing the height map gradient.\n//\n// This is basically a fancy 3d texture renderer\n//\n// If you change the input texture, adjust the DEPTH accordingly\n//\n// Keep in mind that the textures do not represent to height of the elements within, only\n// the default one works correctly for this example\n//\n//\n// LIMITATIONS\n//\n// I coudln't find a way to get soft shadows, if you do feel free to make me know in the comments\n// This version does not provide a COLOR MAP, however it's pretty easy to color the surface using a\n// color map, just copy the getHeightMapValue function to sample from a color map instead of a depthmap\n//\n\n#define PI 3.14159265359\n#define MAX_ITERATIONS 200\n\n// needs to be adujested to match the input texture\n#define DEPTH 0.6\n\n// the step size for the ray marching\n#define PRECISION 0.006\n\n// the lower this is, the more precise the normals get (too much precision results in the\n// apparition of normal artifacts\n#define EPSILON 0.002\n\n\n\n// returns the intersection point between the ray and the hightest point on the plane\nvec3 boundsSDF (vec3 ro, vec3 rd, float h) {\n    // the z length of the target vector\n    float dz = ro.z - h;\n    float t = dz / rd.z;\n    return vec3(\n    \tro.x - rd.x * t,\n        ro.y - rd.y * t,\n        ro.z - rd.z * t\n    );\n}\n\n// returns the height map value of any point in space\n// this is done by projecting the point on the vertical plane\nfloat getHeightMapValue (vec3 p) {\n    // yes this is a projection\n    vec2 tuv = p.xy;\n    tuv.x+= iTime * .1;\n    tuv = fract(tuv - .5);\n    \n    vec3 hm = texture(iChannel0, tuv).rgb;\n    \n    return .9 * (hm.r+hm.g+hm.b)/3. + 0.1;\n}\n\nvec3 calcNormal (vec3 p) {\n\tfloat hx1 = getHeightMapValue(vec3(p.x - EPSILON, p.y, 0.0)) * DEPTH;   \n    float hx2 = getHeightMapValue(vec3(p.x + EPSILON, p.y, 0.0)) * DEPTH;\n    vec3 pu = normalize(vec3(2.0 * EPSILON, 0.0, hx2 - hx1));\n    \n    float hy1 = getHeightMapValue(vec3(p.x, p.y, 0.0)) * DEPTH;\n    float hy2 = getHeightMapValue(vec3(p.x, p.y + EPSILON, 0.0)) * DEPTH;\n    vec3 pv = normalize(vec3(0.0, EPSILON, hy2 - hy1));\n    \n    return cross(pu, pv);\n}\n\nvec3 calcLight( in vec3 pos , in vec3 lightp, in vec3 lightc, in vec3 camdir, float spec)\n{    \n\tvec3 normal = calcNormal(pos);\n    vec3 lightdir = normalize(pos - lightp);\n    float cosa = pow(0.5+0.5*dot(normal, -lightdir), 3.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, normal)), 0.0);\n    \n    vec3 ambiant = vec3(0.1);\n    vec3 diffuse = vec3(0.5 * cosa);\n    vec3 phong = vec3(0.1 * pow(cosr, spec)) * .4;\n    \n    return lightc * (ambiant + diffuse + phong);\n}\n\nvec4 raymarching (vec3 p, vec3 dir) {\n    vec3 prev = p;\n    vec3 curr = p;\n    float lastD = p.z;\n    float hmap = 0.;\n    float df = 0.;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n    \tprev = curr;\n        curr = prev + dir * PRECISION;\n        \n        if (curr.z < 0.0) {\n        \treturn vec4(0, 0, 1, 0);    \n        }\n        \n        hmap = getHeightMapValue(curr);\n        // distance to the displaced surface\n        float df = curr.z - hmap * DEPTH;\n        \n        // if we have an intersection\n        if (df < 0.0) {\n        \t// linear interpolation to find more precise df\n            float t = lastD / (abs(df)+lastD);\n            vec3 pi = prev + t * (curr - prev);\n            float h = getHeightMapValue(pi);\n            return vec4(pi, h);\n        } else {\n         \tlastD = df;\n        }\n    }\n    \n    return vec4(0, 0, 1, 0);\n}\n\n// computes a sharp shadow for a given point p of the surface\nfloat shadow (vec3 p, vec3 lpos) {\n    vec3 dir = normalize(lpos - p);\n    vec3 curr = p;\n    float hmap;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n    \tcurr+= dir * PRECISION;\n        \n        if (curr.z < 0.0) {\n            return 0.0;\n        }\n        \n        hmap = getHeightMapValue(curr);\n        \n        // distance to the displaced surface\n        float df = curr.z - hmap * DEPTH;\n        \n        if (df < 0.0) {\n            return 1.0;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    float camZ = 1.2;// + cos(iTime*.1) * .1;\n    \n    vec3 ro = vec3(0.0, 0.0, camZ);\n    vec3 cw = normalize(vec3(0.0, 0.0, 0.0) - ro);\n    vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = mat3(cu, cv, cw) * normalize(vec3(uv, 1.0));\n    \n    vec4 col = vec4(0, 0, 0, 1);\n    \n    // the intersection to the highest plane\n    vec3 inter = boundsSDF(ro, rd, DEPTH);\n    \n    // the raymarching\n    vec4 rm = raymarching(inter.xyz, rd);\n    \n    if (rm.w > 999.0) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec3 normal = calcNormal(rm.xyz);\n    \n    vec3 lpos = vec3(cos(iTime)*20., sin(iTime)*20., 7.0);\n    //vec3 lpos = vec3(4.0, 4.0, 2.0);\n    \n    col.rgb = calcLight(rm.xyz , lpos, vec3(1.0, 1.0, 1.0), rd, 0.5);\n    \n    // we get the shadow\n    float shad = shadow(rm.xyz, lpos);\n    col.rgb*= 0.5 + .5 * (1. - shad);\n    \n    //col.rgb = normal;\n   \n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByzK.jpg", "access": "api", "license": "mit", "functions": [[1814, 1900, 1944, 1985, 2132], [2134, 2250, 2284, 2316, 2486], [2488, 2488, 2514, 2514, 2956], [2958, 2958, 3049, 3049, 3436], [3438, 3438, 3475, 3475, 4297], [4299, 4361, 4395, 4395, 4838], [4840, 4840, 4897, 4947, 6011]], "test": "untested"}
{"id": "wdlfWj", "name": "Beatspectipolar", "author": "Flexi", "description": "Mashup from Smoke and Mirrors [Bipolar Mix] https://www.shadertoy.com/view/wdfBRj\nand Beating rotozoom on blur level 5 https://www.shadertoy.com/view/tsjXzD\n\nMusic by B1tyze - International Clash\nhttps://soundcloud.com/b1tyze/b1tyze-international-clash", "tags": ["2d", "spectrum", "blur", "stack", "gaussian", "milkdrop", "glitchhop"], "likes": 8, "viewed": 865, "published": 3, "date": "1589122724", "time_retrieved": "2024-07-30T21:07:30.002571", "image_code": "/* This shadertoy features a basic Milkdrop 2.0 shader pipeline clone\n * Get the original Winamp plugin here: http://www.geisswerks.com/about_milkdrop.html\n *\n * Here's a sketch of the basic blurring pipeline:\n * https://twitter.com/Flexi23/status/686583437814317057\n *\n * Buf D not only contains the Buf A and B blur level stack but also a smoothened spectrum pyramid\n * Bind your sound input in Buf D. Currently playing: B1tyze - International Clash\n * There's a certain frame history for the spectrum curves for difference analysis. One smoothing operation costs one frame latency.\n * Access the multiple Gaussian levels by calling BlurA and BlurB with a level index int 0..6\n *\n * Uncomment the #bypass or the prepared blur level stack view statement near the end of this document.\n *\n * You can also find a wastefully implemented store for 4096 vec4 values. Just don't overuse them I suppose.\n *\n * Includes Quadratic Bezier Stroke (fork) code and Gaussian kernel parameters from mattdesl: https://www.shadertoy.com/view/lts3Df\n *\n * 2020, https://twitter.com/Flexi23\n */\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvec4 vol(int t){\n    float lo = bass(t, iChannel3);\n    float mi = mid(t, iChannel3);\n    float hi = treb(t, iChannel3);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nfloat spectrum2D(vec2 uv, float thickness, int level)\n{\n    return spectrum2D(uv, thickness, level, iChannel3);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    return BlurA(uv, level, iChannel0, iChannel3);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    return BlurB(uv, level, iChannel1, iChannel3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 uv = fragCoord.xy * pixelSize;\n    vec2 uv_aspect = 0.5 + (uv - 0.5)*aspect.yx;\n    vec2 uv_orig = uv;\n    \n\tvec4 C18 = Cell(18); // last one from the Verlet integrated spring simulation support points\n    //vec2 uv_warped = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw/90., iResolution);\n    \n    vec4 rnd0 = Cell(10);\n    vec4 rnd1 = Cell(11);\n    vec4 normalizedVolume = Cell(21)*0.2 + 0.75;\n\tvec4 volume = vol(0, iChannel3);\n    \n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n\tvec4 beat_residual = Cell(4);\n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n    \n    vec4 noise1 = Cell(10)-0.5;\n    vec4 noise2 = Cell(11)-0.5;\n    noise1 = mix(noise2, noise1, beat_relative);\n    \n    float c1 = smoothcircle(uv - aspect.yx*0.5 + rnd1.xy*aspect.yx, aspect, 0.03, 600.);\n    float c2 = smoothcircle(uv - aspect.yx*0.5 + rnd0.xy*aspect.yx, aspect, 0.015, 800.);\n    float c3 = smoothcircle(uv - aspect.yx*0.5 + mix(rnd0.xy, rnd1.xy, beat_relative)*aspect.yx, aspect, 0.005, 1400.);\n    \n    float bassBox = unit_square(0.5 + (uv-vec2(0.125, volume.x)) * 32. * aspect);\n    float midBox = unit_square(0.5 + (uv-vec2(0.5, volume.y)) * 32. * aspect);\n    float trebBox = unit_square(0.5 + (uv-vec2(0.875, volume.z)) * 32. * aspect);\n    \n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n \n    bassBox = unit_square(0.5 + (uv-vec2(0.25, normalizedVolume.x)) * 128. * aspect);\n    midBox = unit_square(0.5 + (uv-vec2(0.5, normalizedVolume.y)) * 128. * aspect);\n    trebBox = unit_square(0.5 + (uv-vec2(0.75, normalizedVolume.z)) * 128. * aspect);\n\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n     \n    vec4 integratedVolume = Cell(19);\n\n    bassBox = unit_square(0.5 + (uv-vec2(0.125, integratedVolume.x)) * 64. * aspect);\n    midBox = unit_square(0.5 + (uv-vec2(0.5, integratedVolume.y)) * 64. * aspect);\n    trebBox = unit_square(0.5 + (uv-vec2(0.875, integratedVolume.z)) * 64. * aspect);\n  \n    vec4 fader = Cell(22)*8.;\n    \n    float bassFader = knob(0.5 + (uv-vec2(0.25,0.75))*5., aspect, 0.42, 0.5, fader.x);\n    float midFader = knob(0.5 + (uv-vec2(0.5,0.75))*5., aspect, 0.42, 0.5, fader.y);\n    float trebFader = knob(0.5 + (uv-vec2(0.75,0.75))*5., aspect, 0.42, 0.5, fader.z);\n\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n    \n    bassBox = unit_square(0.5 + (uv-vec2(0.125, 1.-abs(integratedVolume.x-volume.x))) * 64. * aspect);\n    midBox = unit_square(0.5 + (uv-vec2(0.5, 1.-abs(integratedVolume.y-volume.y))) * 64. * aspect);\n    trebBox = unit_square(0.5 + (uv-vec2(0.875, 1.-abs(integratedVolume.z-volume.z))) * 64. * aspect);\n\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n  \n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassFader);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midFader);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebFader);\n    \n\n    float speed = 0.0225;\n    vec2 rotate_uv = rotozoom(uv, -2.*fader.y*speed, 1., aspect);\n\tvec2 bipolar_uv = wrap_flip(uv_bipolar(0.5 + (rotate_uv-0.5)*2.33*aspect , vec2(0.5,0.), vec2(0.0,0.5), 2., 0.3, fader.xz*speed));\n\n\n    //fragColor = mix(fragColor, vec4(1), BlurB(uv, 0));\n    \n    fragColor =  mix(fragColor, vec4(1.), BlurB(bipolar_uv, 0));\n    //fragColor =  mix(fragColor, vec4(1.), BlurA(bipolar_uv, 0));\n\n    uv = rotozoom(uv + noise1.xy*pixelSize*16., noise1.z/4., 1. - noise1.w/4., aspect);\n    \n    fragColor =  mix(fragColor, vec4(1.15), BlurA(uv, 0));\n    \n    vec4 C12 = Cell(12);\n    vec4 C13 = Cell(13);\n    vec2 s0 = C12.xy;\n    vec2 s1 = C12.zw;\n\tvec2 s2 = C13.xy;\n    vec2 s = C13.zw; // avg of 3\n    \n    bassBox = unit_square(0.5 + (uv+s1) * 64. * aspect);\n    midBox = unit_square(0.5 + (uv+s0) * 64. * aspect);\n    trebBox = unit_square(0.5 + (uv+s2) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n\n    vec4 C25 = Cell(25);\n    float box = unit_square((uv-vec2(0.95, 0.5 + C25.x)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    box = unit_square((uv-vec2(0.93, 0.5 + C25.y)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    box = unit_square((uv-vec2(0.91, 0.5 + C25.z)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    box = unit_square((uv-vec2(0.89, 0.5 + C25.w)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    float puller = (integratedVolume.x - integratedVolume.z)/2.;\n    box = unit_square((uv-vec2(0.97, 0.5 + puller)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    //fragColor = vec4(0);\n    \n    /*\n    fragColor =  mix(fragColor, vec4(0.1), spectrum2D(uv, 0.05, 0));\n    fragColor =  mix(fragColor, vec4(0.2), spectrum2D(uv, 0.04, 1));\n    fragColor =  mix(fragColor, vec4(0.3), spectrum2D(uv, 0.03, 2));\n    fragColor =  mix(fragColor, vec4(0.5), spectrum2D(uv, 0.02, 3));\n    fragColor =  mix(fragColor, vec4(0.8), spectrum2D(uv, 0.01, 4));\n    */\n    \n    fragColor = mix(fragColor, vec4(1), rainbowSpectra(uv, iChannel3));\n    \n//    fragColor = vec4(spectrum(uv.x, 0, 3));\n//    fragColor =  mix(fragColor, vec4(1), texture(iChannel3, uv)); // blur level stack\n\n//    fragColor = Cell(2);\n//    fragColor = texture(iChannel2, uv); // see, the upper right quarter is not used yet\n//    fragColor = vec4(1.) * BlurA(uv, 0).z; // single channel\n\n    vec4 vol = Cell(9);\n    float beat = vol.x;\n\tvec4 C22 = Cell(22);\n\tvec4 C23 = Cell(23);\n    vec2 p_bass = C12.xy;\n    vec2 p_mid = C12.zw;\n    vec2 p_treb = C13.xy;\n    vec2 p_vol = C13.zw;\n    \n\tfloat c4 = smoothcircle(uv_aspect - aspect.yx*0.5 + p_bass*aspect.yx, aspect, 0.0025, 800.);\n    float c5 = smoothcircle(uv_aspect - aspect.yx*0.5 + p_mid*aspect.yx, aspect, 0.0025, 800.);\n    float c6 = smoothcircle(uv_aspect - aspect.yx*0.5 + p_treb*aspect.yx, aspect, 0.0025, 800.);\n    \n    float c8 = smoothcircle(uv, aspect, 0.25, 800.)*0.;\n    \n    //fragColor *= (1.-beat_relative)*0.75+0.25;\n    \n    //fragColor =  mix(fragColor, vec4(0.5), mix(BlurB(uv, 1).x*0.5, BlurB(uv, 0).x, c8*0.75));\n    fragColor =  mix(fragColor, vec4(1), c8*0.166);\n    \n    //vec4 rainbow = vec4(hsl2rgb(fract(iTime), 1., 0.5), 0.);\n    //fragColor *= 0.;\n    \n    //fragColor *= 0.;\n    fragColor =  mix(fragColor, vec4(1.-c8), c1*0.5);\n    fragColor =  mix(fragColor, vec4(1.-c8), c2*0.66);\n    fragColor =  mix(fragColor, vec4(1.-c8), c3*0.75);\n    \n    //fragColor *= 0.;\n    fragColor =  mix(fragColor, vec4(1,1,0,0), c4);\n    fragColor =  mix(fragColor, vec4(1,0,1,0), c5);\n    fragColor =  mix(fragColor, vec4(0,1,1,0), c6);\n    \n    vec4 p1 = Cell(14);\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    vec4 p4 = Cell(18);\n        \n\tfloat c_p1 = smoothcircle(uv_aspect - aspect.yx*0.5 + p1.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p2 = smoothcircle(uv_aspect - aspect.yx*0.5 + p2.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p3 = smoothcircle(uv_aspect - aspect.yx*0.5 + p3.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p4 = smoothcircle(uv_aspect - aspect.yx*0.5 + p4.xy*aspect.yx, aspect, 0.0025, 800.);\n    \n    //fragColor *= 0.;\n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_p1);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_p2);\n    fragColor =  mix(fragColor, vec4(0,1,0,0), c_p3); \n\tfragColor =  mix(fragColor, vec4(1), c_p4);\n\n    //fragColor =  mix(fragColor, fragColor*vec4(2.,1.,0,0), beat*1.);\n    \n    // overlaySpline(fragColor, uv, vec4(1,1,1,0.618), p_vol.xy, p1.xy, p2.xy, iResolution);\n    //uv = bipolar_uv;\n    overlaySpline(fragColor, uv, vec4(1,1,0,0.618), p_bass.xy, p1.xy, p2.xy, iResolution);\n    overlaySpline(fragColor, uv, vec4(1,0,1,0.618), p_mid.xy, p1.xy, p2.xy, iResolution);\n    overlaySpline(fragColor, uv, vec4(0,1,1,0.618), p_treb.xy, p1.xy, p2.xy, iResolution);\n    overlaySpline(fragColor, uv, vec4(1,1,1,0.618), p2.xy, p3.xy, p4.xy, iResolution);\n    \n    \n    //fragColor = mix(fragColor, vec4(1) - fragColor, min(vec4(1), max(vec4(0), pow(c,vec4(1.15)))));\n    \n    \n    \n    // blur level stack\n\t//fragColor =  mix(fragColor*0., vec4(1), texture(iChannel3, uv));\n    \n    \n    // #bypass\n\n    //fragColor = BlurA(uv, 0);\n    //fragColor = BlurB(uv, 0);\n    //fragColor = BlurB(bipolar_uv, 0);\n    //fragColor = texture(iChannel3, uv_orig);\n    //fragColor = mix(fragColor*0., vec4(1), texture(iChannel3, uv_orig).a);\n    \n    fragColor = mix(fragColor, vec4(1), BlurB(uv, 0).a*0.25);\n    //fragColor = mix(fragColor*0., vec4(1), BlurB(bipolar_uv, 0));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// HSL to RGB converter code from http://www.gamedev.net/topic/465948-hsl-shader-glsl-code/\nfloat Hue_2_RGB(float v1, float v2, float vH )\n{\n    float ret;\n    if ( vH < 0.0 )\n        vH += 1.0;\n    if ( vH > 1.0 )\n        vH -= 1.0;\n    if ( ( 6.0 * vH ) < 1.0 )\n        ret = ( v1 + ( v2 - v1 ) * 6.0 * vH );\n    else if ( ( 2.0 * vH ) < 1.0 )\n        ret = ( v2 );\n    else if ( ( 3.0 * vH ) < 2.0 )\n        ret = ( v1 + ( v2 - v1 ) * ( ( 2.0 / 3.0 ) - vH ) * 6.0 );\n    else\n        ret = v1;\n    return ret;\n}\n\nvec3 hsl2rgb(float H, float S, float L){\n    float var_2, var_1, R, G, B;\n    if (S == 0.0)\n    {\n        R = L;\n        G = L;\n        B = L;\n    }\n    else\n    {\n        if ( L < 0.5 )\n        {\n            var_2 = L * ( 1.0 + S );\n        }\n        else\n        {\n            var_2 = ( L + S ) - ( S * L );\n        }\n\n        var_1 = 2.0 * L - var_2;\n\n        R = Hue_2_RGB( var_1, var_2, H + ( 1.0 / 3.0 ) );\n        G = Hue_2_RGB( var_1, var_2, H );\n        B = Hue_2_RGB( var_1, var_2, H - ( 1.0 / 3.0 ) );\n    }\n    return vec3(R,G,B);\n}\n\nbool is_onscreen(vec2 uv){\n    return (uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.);\n}\n\n#define pi2_inv 0.159154943091895335768883763372\n#define pi 3.14159265359\n\nvec2 lower_left(vec2 uv)\n{\n    uv = fract(uv);\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    uv = fract(uv);\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    uv = fract(uv);\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n//    uv = fract(uv);\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level, sampler2D bufA, sampler2D bufD)\n{\n    uv = fract(uv);\n    if(level <= 0)\n    {\n        return texture(bufA, uv);\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv);\n}\n\nvec4 BlurB(vec2 uv, int level, sampler2D bufB, sampler2D bufD)\n{\n    uv = fract(uv);\n    if(level <= 0)\n    {\n        return texture(bufB, uv);\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level, sampler2D bufA, sampler2D bufD){\n    vec4 dX = BlurA(uv + vec2(1.,0.)*d, level, bufA, bufD) - BlurA(uv - vec2(1.,0.)*d, level, bufA, bufD);\n    vec4 dY = BlurA(uv + vec2(0.,1.)*d, level, bufA, bufD) - BlurA(uv - vec2(0.,1.)*d, level, bufA, bufD);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec2 GradientB(vec2 uv, vec2 d, vec4 selector, int level, sampler2D bufB, sampler2D bufD){\n    vec4 dX = BlurB(uv + vec2(1.,0.)*d, level, bufB, bufD) - BlurB(uv - vec2(1.,0.)*d, level, bufB, bufD);\n    vec4 dY = BlurB(uv + vec2(0.,1.)*d, level, bufB, bufD) - BlurB(uv - vec2(0.,1.)*d, level, bufB, bufD);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nfloat unit_square(vec2 uv, vec2 aspect){\n    uv = 0.5 + (uv - 0.5)/aspect.yx;\n    return (uv.x > 0. && uv.x < 1. && uv.y > 0. && uv.y < 1. ) ? 1. : 0.;\n}\n\nvec2 rot90(vec2 vector){\n    return vector.yx*vec2(1,-1);\n}\n\nvec2 wrap_flip(vec2 uv){\n\treturn vec2(1.)-abs(fract(uv*.5)*2.-1.);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 rotozoom(vec2 uv, float ang, float zoom, vec2 aspect){\n    vec2 rot = vec2(cos(ang), sin(ang))*zoom;    \n    return 0.5 + complex_mul((uv - 0.5)*aspect, rot)/aspect;\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nvec2 mobius(vec2 domain, vec2 zero_pos, vec2 asymptote_pos){\n\treturn complex_div( domain - zero_pos, domain - asymptote_pos);\n}\n\n// see https://stackoverflow.com/a/26070411\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(pi/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec2 uv_polar(vec2 domain, vec2 center){\n   vec2 c = domain - center;\n   float rad = length(c);\n   float ang = atan2(c.y, c.x);\n   return vec2(ang, rad);\n}\n\nvec2 uv_polar_logarithmic(vec2 domain, vec2 center, float fins, float log_factor, vec2 coord){\n   vec2 polar = uv_polar(domain, center) * vec2(pi2_inv, 1);\n   return vec2(polar.x * fins + coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nvec2 uv_bipolar(vec2 domain, vec2 northPole, vec2 southPole, float fins, float log_factor, vec2 coord){\n   vec2 help_uv = mobius(domain, northPole, southPole);\n   return uv_polar_logarithmic(help_uv, vec2(0.5), fins, log_factor, coord);\n}\n\nfloat unit_square(vec2 uv){\n\treturn float((uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.));\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat knob(vec2 domain, vec2 aspect, float innerRadius, float outerRadius, float angle){\n    float knob =  sigmoid((circle(domain, aspect, 2./outerRadius) - circle(domain, aspect, 2./innerRadius))/(outerRadius-innerRadius));\n    knob = mix(knob, 1., circle(domain + vec2(sin(angle), cos(angle))*0.4*aspect.yx, aspect, 8./outerRadius));\n    return knob;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp, vec3 iResolution)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16., iResolution) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp, iResolution);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 20.;\n\n    float d = 0.075;\n\n    vel *= aspect;\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(rot90(vel))/aspect;\n        p1 = pos + normal * d / 2.;\n        p2 = pos - normal * d / 2.;\n    }\n\n    float w = l*32.;\n\n    // two overlapping rotations that would annihilate if they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)), iResolution);\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)), iResolution);\n    return (circle1 + circle2) / 2.;\n}\n \nfloat border(vec2 domain, float thickness){\n   vec2 uv = fract(domain-vec2(0.5));\n   uv = min(uv,1.-uv)*2.;\n   return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);\n}\n\n// Buf D contains an N x N array\nfloat N = 32.;\n\n// in the rectangle region between 2 points\nvec2 p1 = vec2(0.75);\nvec2 p2 = vec2(1.);\n\nvec4 Cell(int index, sampler2D bufD)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n    \n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n    \n    return texture(bufD, center);\n}\n\nvec2 mouseDelta(vec3 iResolution, vec4 iMouse, sampler2D bufD){\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    vec4 oldMouse = Cell(2, bufD);\n    vec4 nowMouse = vec4(iMouse.xy * pixelSize.xy, iMouse.zw * pixelSize.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\n// sampling from spectrogram\n\nfloat spectrum(float domain, int t, int level, sampler2D bufD)\n{\n    float sixty_fourth = 1./32.;\n    vec2 uv = vec2(float(t)*3.*sixty_fourth + sixty_fourth, domain);\n    uv = upper_right(uv); level++;\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv).x;\n}\n\nfloat spectrum2D(vec2 uv, float thickness, int level, sampler2D bufD)\n{\n    float val = spectrum(uv.x, 0, level, bufD);\n    return (abs(uv.y - val) < thickness/2.) ? (1.-abs(uv.y - val)*2./thickness) : 0.;\n}\n\nvec4 rainbowSpectra(vec2 uv, sampler2D bufD)\n{\n    float thickness = 0.015;\n    // make this a loop?\n    vec4 spectra =         vec4(0.25,0,0.5,0)* spectrum2D(uv, thickness, 7, bufD);\n    spectra = mix(spectra, vec4(0.5,0,1.,0), spectrum2D(uv, thickness, 6, bufD));\n    spectra = mix(spectra, vec4(0,0.5,1,0), spectrum2D(uv, thickness, 5, bufD));\n    spectra = mix(spectra, vec4(0,1.,0.5,0), spectrum2D(uv, thickness, 4, bufD));\n    spectra = mix(spectra, vec4(1,1,0,0), spectrum2D(uv, thickness, 3, bufD));\n    spectra = mix(spectra, vec4(0.6,0.25,0,0), spectrum2D(uv, thickness, 2, bufD));\n    spectra = mix(spectra, vec4(0.85,0,0,0), spectrum2D(uv, thickness, 1, bufD));\n    spectra = mix(spectra, vec4(1), spectrum2D(uv, thickness, 0, bufD));\n    \n    return spectra*unit_square(uv);\n}\n\nfloat bass(int t, sampler2D bufD){\n    return spectrum(0.125, t, 3, bufD);\n}\n\nfloat mid(int t, sampler2D bufD){\n    return spectrum(0.5, t, 3, bufD);\n}\n\nfloat treb(int t, sampler2D bufD){\n    return spectrum(0.875, t, 3, bufD);\n}\n\nvec4 vol(int t, sampler2D bufD){\n    float lo = bass(t, bufD);\n    float mi = mid(t, bufD);\n    float hi = treb(t, bufD);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nvec4 BlurSpectrogram(vec2 uv, int level, sampler2D bufD)\n{\n    uv = upper_right(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv); // Buf D in Texture C\n}\n\n// the following lines are copied from mattdesl's Quadratic Bezier Stroke (fork)\n// https://www.shadertoy.com/view/lts3Df\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 closestPointInSegment( vec2 a, vec2 b )\n{\n  vec2 ba = b - a;\n  return a + ba*clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );\n}\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n\t\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  \n  if( abs(2.0*a+b+d) < 1000.0 ) return closestPointInSegment(b0,b2);\n\t\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘–= ð‘(ð‘¡Ì…)\n\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n// extracted from mainImage\nvec4 overlaySpline(inout vec4 rgba, vec2 uv, vec4 strokeCol, vec2 p1, vec2 p2, vec2 p3, vec3 iResolution){\n\tfloat d = approx_distance((1. - uv)*iResolution.xy, p1*iResolution.xy, p2*iResolution.xy, p3*iResolution.xy);\n\tfloat thickness = 1.0;\n\tfloat a;\n\tif(d < thickness) {\n\t  a = 1.;\n\t} else {\n\t  a = 1. - smoothstep(d, thickness, thickness+0.5);\n\t}\n    rgba = mix(rgba, strokeCol, a * strokeCol.a); \n    return rgba;\n}\n\n// end of fork from https://www.shadertoy.com/view/lts3Df", "buffer_a_code": "// beat detection debug view\n// vortex (pair) warp from the end of the spring chain simulation is applied here\n\nvec4 BlurA(vec2 uv, int level)\n{\n    return BlurA(uv, level, iChannel0, iChannel3);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    return BlurB(uv, level, iChannel1, iChannel3);\n}\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 uv = fragCoord.xy * pixelSize;\n    vec2 uv_aspect = 0.5 + (uv - 0.5)*aspect.yx;\n    \n    vec4 noise = (texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime))-0.5)*2.;\n    \n    vec2 mouseV = mouseDelta(iResolution, iMouse, iChannel3);\n    vec4 volume = vol(0, iChannel3);\n    \n    vec4 C18 = Cell(18); // last one from the Verlet integrated spring simulation support points\n\n    //uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV, iResolution);\n    uv = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw/128., iResolution);\n    vec4 poiToy = -C18+0.5;\n    float mask = smoothcircle(uv - poiToy.xy/aspect.xy, aspect, 0.1,64.); //\n    vec2 _c = 0.5 + poiToy.xy/aspect.xy;\n    float _w = 0.5*asin(1.);\n    float z = 1.1;\n    //uv = _c + complex_mul((uv-_c)*aspect, mix(vec2(1.,0.), vec2(cos(_w),-sin(_w))*z, mask)) / aspect;\n    \n    fragColor = BlurA( 0.5 + (uv - 0.5)*vec2(1.006,1.) + vec2(2,0)*pixelSize + vec2(0,iTime*0.0), 0, iChannel0, iChannel3)*1.0- 0./256.;\n    \n    vec4 v0 = Cell(0, iChannel3);\n    vec4 v1 = Cell(1, iChannel3);\n    vec4 v3 = Cell(3, iChannel3);\n    vec2 uv_v0 =vec2(0.95, v0.w);\n    vec2 uv_v3 =vec2(0.95, v3.w*4. + 0.25);\n    vec4 beat_residual = Cell(4);\n    float energy = (v0.w - v1.w);\n    vec2 uv_v1 = vec2(0.95, energy +0.05);\n    \n    // here we print the thick beat bar\n    if(uv.x >= 0.95 - 1./256.){\n        fragColor = vec4(1,1,1,0)*Cell(9).x;\n    }\n    \n    fragColor = mix(fragColor, vec4(0,1,0,0), circle(uv - uv_v0+0.5, aspect, 256.));\n    //fragColor = mix(fragColor, vec4(1,0,0,0), circle(uv - uv_v1+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,1,1,0), circle(uv - uv_v3+0.5, aspect, 256.));\n\n    //fragColor = mix(fragColor, vec4(1,1,1,0), mask);\n\n    vec2 uv_v4 =vec2(0.95, beat_residual.w*0.5);\n    fragColor = mix(fragColor, vec4(0,1,1,0), circle(uv - uv_v4+0.5, aspect, 256.));\n\n    vec4 last_beat_min = Cell(7, iChannel3);\n    vec4 last_beat_max = Cell(8, iChannel3);\n\n    vec2 uv_lo =vec2(0.95, last_beat_min.w*0.5);\n    vec2 uv_hi =vec2(0.95, last_beat_max.w*0.5);\n\n    fragColor = mix(fragColor, vec4(1,0,1,0), circle(uv - uv_lo+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,1,0,0), circle(uv - uv_hi+0.5, aspect, 256.));\n\n    vec4 C12 = Cell(12);\n\tvec4 C13 = Cell(13);\n    vec2 p_bass = C12.xy;\n    vec2 p_mid = C12.zw;\n    vec2 p_treb = C13.xy;\n    vec2 p_vol = C13.zw;\n    \n\t//float c4 = smoothcircle(uv - aspect.yx*0.5 + p_bass*aspect.yx, aspect, 0.0025, 800.);\n    //float c5 = smoothcircle(uv - aspect.yx*0.5 + p_mid*aspect.yx, aspect, 0.0025, 800.);\n    //float c6 = smoothcircle(uv - aspect.yx*0.5 + p_treb*aspect.yx, aspect, 0.0025, 800.);\n    float c7 = smoothcircle(uv - aspect.yx*0.5 + Cell(17, iChannel3).xy*aspect.yx, aspect, 0.0025, 800.);    \n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n    \n    //fragColor *= beat_relative;\n    //fragColor =  mix(fragColor, vec4(.45), mix(BlurA(uv, 1).x*0.175, BlurA(uv, 0).x*0.1, c8*0.75));\n    //fragColor =  mix(fragColor, vec4(1), BlurA(uv, 0)*0.);\n    //fragColor =  mix(fragColor, vec4(1,1,0,0), c6);\n//        fragColor =  mix(fragColor, vec4(1,0,1,0), c4);\n    //fragColor =  mix(fragColor, vec4(0,1,1,0), c5);\n//    fragColor =  mix(fragColor, vec4(1.), c7);\n//    fragColor =  mix(fragColor, vec4(1), c8);\n    \n    vec4 p1 = Cell(14);\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    vec4 p4 = C18;\n        \n\tfloat c_p1 = smoothcircle(uv_aspect - aspect.yx*0.5 + p1.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p2 = smoothcircle(uv_aspect - aspect.yx*0.5 + p2.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p3 = smoothcircle(uv_aspect - aspect.yx*0.5 + p3.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p4 = smoothcircle(uv_aspect - aspect.yx*0.5 + p4.xy*aspect.yx, aspect, 0.0025, 800.);\n        \n    float c_bass = circle(uv - vec2(0.8,-0.4 + volume.x*0.5)*aspect.yx, aspect, 256.);\n    float c_mid = circle(uv - vec2(0.8,-0.4 + volume.y*0.5)*aspect.yx, aspect, 256.);\n    float c_treb = circle(uv - vec2(0.8,-0.4 + volume.z*0.5)*aspect.yx, aspect, 256.);\n    float c_vol = circle(uv - vec2(0.8,-0.4 + volume.w*0.5)*aspect.yx, aspect, 256.);\n    \n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_p1);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_p2);\n    fragColor =  mix(fragColor, vec4(.0,1,0,0), c_p3);\n\tfragColor =  mix(fragColor, vec4(1), c_p4);\n\n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_bass);\n    fragColor =  mix(fragColor, vec4(0,1,0,0), c_mid);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_treb);\n    fragColor =  mix(fragColor, vec4(1,1,1,0), c_vol);\n    \n    fragColor =  mix(fragColor, vec4(0,0,0,0), border(uv, 0.04));\n    \n    \n    fragColor = clamp(fragColor, 0., 1.);\n  \n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 BlurA(vec2 uv, int level)\n{\n    return BlurA(uv, level, iChannel0, iChannel3);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    return BlurB(uv, level, iChannel1, iChannel3);\n}\n\nvec4 rainbowSpectra(vec2 uv)\n{\n    return rainbowSpectra(uv, iChannel3);\n}\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    vec2 uv_orig = uv;\n    vec4 noise = texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime));\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    \n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n\tvec4 beat_residual = Cell(4);\n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n    if( last_beat_max.w - last_beat_min.w != 0.)\n    {\n        beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n    }\n \n   \n    // zoom mix\n    vec2 uv_spectra = uv;\n    fragColor = BlurB( 0.5 + (uv - 0.5)*1.025 + vec2(0,0.02)*sin(iTime*0.1), 1);\n    \n    fragColor = mix(fragColor*((254./256.-beat_relative*0.025)), vec4(1), rainbowSpectra(uv_spectra));\n    \n    vec4 C18 = Cell(18); // last one from the Verlet integrated spring simulation support points\n\n    //uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV, iResolution);\n    uv = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw/128., iResolution);\n    \n    // following code in alpha was copiued from blue in Buffer B from https://www.shadertoy.com/view/tsjXzD\n    \n    vec4 noise1 = Cell(10)-0.5;\n    vec4 noise2 = Cell(11)-0.5;\n    noise1 = mix(noise2, noise1, beat_relative);\n    uv = (rotozoom(uv + noise1.xy*pixelSize*16., noise1.z/4., 1. - noise1.w/4., aspect));\n    \n    fragColor.a = BlurB(uv, 0).a;\n    fragColor.a += (BlurB(uv , 1).a - BlurB(uv, 5).a) * 0.25; // Turing Pattern\n    fragColor.a += + 0./256. + (noise.r-0.5)*96./256.;\n    \n    fragColor = max(vec4(0), min( vec4(1), fragColor));\n    //fragColor = noise;\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// resolution reduction and horizontal blur\n\n// shout-outs to https://twitter.com/mattdesl\n// https://github.com/mattdesl/lwjgl-basics/wiki/shaderlesson5\n\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.0162162162;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.0540540541;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.1216216216;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.1945945946;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.2270270270;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.1945945946;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.1216216216;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.0540540541;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.0162162162;\n\n    return sum;\n}\n\n// see a sketch of the downsampling pipeline here: https://twitter.com/Flexi23/status/686583437814317057\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(iChannel3, uv1) * 0.0162162162;\n    sum += texture(iChannel3, uv2) * 0.0540540541;\n    sum += texture(iChannel3, uv3) * 0.1216216216;\n    sum += texture(iChannel3, uv4) * 0.1945945946;\n    sum += texture(iChannel3, uv5) * 0.2270270270;\n    sum += texture(iChannel3, uv6) * 0.1945945946;\n    sum += texture(iChannel3, uv7) * 0.1216216216;\n    sum += texture(iChannel3, uv8) * 0.0540540541;\n    sum += texture(iChannel3, uv9) * 0.0162162162;\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(iChannel0, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(iChannel1, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// bind in iChannel1 misc\n// https://soundcloud.com/generate/kettel-candace-bouvard\n\n// vertical blur (second pass)\n\n// see https://github.com/mattdesl/lwjgl-basics/wiki/shaderlesson5\n// by https://twitter.com/mattdesl\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.0162162162;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.0540540541;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.1216216216;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.1945945946;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.2270270270;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.1945945946;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.1216216216;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.0540540541;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.0162162162;\n    return sum;\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.0162162162;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.0540540541;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.1216216216;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.1945945946;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.2270270270;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.1945945946;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.1216216216;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.0540540541;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.0162162162;\n    return sum;\n}\n\n// see a sketch of the downsampling pipeline here: https://twitter.com/Flexi23/status/686583437814317057\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            uv1 = upper_left(uv1);\n            uv2 = upper_left(uv2);\n            uv3 = upper_left(uv3);\n            uv4 = upper_left(uv4);\n            uv5 = upper_left(uv5);\n            uv6 = upper_left(uv6);\n            uv7 = upper_left(uv7);\n            uv8 = upper_left(uv8);\n            uv9 = upper_left(uv9);\n        }\n        else\n        {\n            uv1 = lower_left(uv1);\n            uv2 = lower_left(uv2);\n            uv3 = lower_left(uv3);\n            uv4 = lower_left(uv4);\n            uv5 = lower_left(uv5);\n            uv6 = lower_left(uv6);\n            uv7 = lower_left(uv7);\n            uv8 = lower_left(uv8);\n            uv9 = lower_left(uv9);\n        }\n    }\n    else\n    {\n        vec2 uv_s = upper_right(uv*2.)*2.;\n        uv1 = clamp(vec2(uv_s.x, uv_s.y - 4.0*v), 0., 1.);\n        uv2 = clamp(vec2(uv_s.x, uv_s.y - 3.0*v), 0., 1.);\n        uv3 = clamp(vec2(uv_s.x, uv_s.y - 2.0*v), 0., 1.);\n        uv4 = clamp(vec2(uv_s.x, uv_s.y - 1.0*v), 0., 1.);\n        uv5 = clamp(vec2(uv_s.x, uv_s.y + 0.0*v), 0., 1.);\n        uv6 = clamp(vec2(uv_s.x, uv_s.y + 1.0*v), 0., 1.);\n        uv7 = clamp(vec2(uv_s.x, uv_s.y + 2.0*v), 0., 1.);\n        uv8 = clamp(vec2(uv_s.x, uv_s.y + 3.0*v), 0., 1.);\n        uv9 = clamp(vec2(uv_s.x, uv_s.y + 4.0*v), 0., 1.);\n        depth--;\n        uv1 = upper_right(uv1);\n        uv2 = upper_right(uv2);\n        uv3 = upper_right(uv3);\n        uv4 = upper_right(uv4);\n        uv5 = upper_right(uv5);\n        uv6 = upper_right(uv6);\n        uv7 = upper_right(uv7);\n        uv8 = upper_right(uv8);\n        uv9 = upper_right(uv9);\n    }\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n    if(uv.x > 0.5 && uv.y > 0.5)\n    {\n        //return vec4(0);\n        sum += texture(iChannel3, uv1) * 0.0162162162;\n        sum += texture(iChannel3, uv2) * 0.0540540541;\n        sum += texture(iChannel3, uv3) * 0.1216216216;\n        sum += texture(iChannel3, uv4) * 0.1945945946;\n        sum += texture(iChannel3, uv5) * 0.2270270270;\n        sum += texture(iChannel3, uv6) * 0.1945945946;\n        sum += texture(iChannel3, uv7) * 0.1216216216;\n        sum += texture(iChannel3, uv8) * 0.0540540541;\n        sum += texture(iChannel3, uv9) * 0.0162162162;\n    }\n    else\n    {\n        sum += texture(iChannel2, uv1) * 0.0162162162;\n        sum += texture(iChannel2, uv2) * 0.0540540541;\n        sum += texture(iChannel2, uv3) * 0.1216216216;\n        sum += texture(iChannel2, uv4) * 0.1945945946;\n        sum += texture(iChannel2, uv5) * 0.2270270270;\n        sum += texture(iChannel2, uv6) * 0.1945945946;\n        sum += texture(iChannel2, uv7) * 0.1216216216;\n        sum += texture(iChannel2, uv8) * 0.0540540541;\n        sum += texture(iChannel2, uv9) * 0.0162162162;\n    }\n    return sum; // normalize\n}\n\nvoid set_cell(inout vec4 bufD, vec2 uv, int index, vec4 value)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n\n\n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n\n    // store\n    if(abs(uv - center).x <= cell_size.x*0.5 && abs(uv - center).y <= cell_size.y*0.5)\n    {\n        bufD = value;\n    }\n}\n\nvoid spring(float force, inout vec4 p1, inout vec4 p2) {\n    vec2 f = (p2.xy-p1.xy) * force;\n    p1.zw += f;\n    p2.zw -= f;\n}\n\nvoid resist(float friction, inout vec4 p){\n    float dampeningFactor = 0.9;\n    // hit right border\n    if(p.x > 1. && p.z > 0.){\n        p.z = - p.z * dampeningFactor;\n    }\n    // hit left border\n    if(p.x < 0. && p.z < 0.){\n        p.z = - p.z * dampeningFactor;\n    }\n    // hit lower border\n    if(p.y < 0. && p.w < 0.){\n        p.w = - p.w * dampeningFactor;\n    }\n    // hit upper border\n    if(p.y > 1. && p.w > 0.){\n        p.w = - p.w * dampeningFactor;\n    }\n\n    friction = max(0., 1. - length(p.zw)*friction);\n    p.zw *= friction;\n}\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvec4 vol(int t){\n    float lo = bass(t, iChannel3);\n    float mi = mid(t, iChannel3);\n    float hi = treb(t, iChannel3);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1./iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(iChannel2, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(iChannel2, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }\n        uv_half = fract(uv_orig*2.);\n\n        if(uv_orig.y > 0.5)\n        {\n            if(uv_half.x < pixelSize.x *128.)\n            {\n                fragColor = texture(iChannel1, uv_half.yx);\n            }else{\n                fragColor = texture(iChannel3, uv_orig - vec2(64.,0.) * pixelSize);\n                //fragColor = vec4(0);\n            }\n        }\n    }\n\n    // volume from current frame and one frame ago\n    vec4 v0 = vol(0, iChannel3);\n    vec4 v0_prev = Cell(20);\n    vec4 v1 = vol(1);\n\n    set_cell(fragColor, uv, 0, v0);\n    set_cell(fragColor, uv, 1, v1);\n    set_cell(fragColor, uv, 2, vec4(iMouse.xy * pixelSize, iMouse.zw * pixelSize));\n\n    vec4 v2 = vol(2);\n    vec4 attack = v2 + v0 - 2.*v1;\n    set_cell(fragColor, uv, 3, attack);\n\n    vec4 old_beat_residual = Cell(4);\n    vec4 beat_residual = old_beat_residual*0.96 + max(attack*4., 0.);\n    set_cell(fragColor, uv, 4, beat_residual);\n    set_cell(fragColor, uv, 5, old_beat_residual);\n\n    attack = beat_residual - old_beat_residual;\n    set_cell(fragColor, uv, 6, attack );\n\n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n    \n    float frames_since_last_beat = Cell(9).y;\n    bool beat = (v0.w-v0_prev.w)*2. > 4./frames_since_last_beat;// || ((last_beat_min.w < 0.01) && attack.w > 0.05) || ((frames_since_last_beat > 120.) && attack.w > 0.15);\n    beat = beat && (frames_since_last_beat > 15.);\n    \n    vec4 noise = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy + fract(vec2(42,56)*iTime));\n\n    if(beat)\n    {\n        set_cell(fragColor, uv, 7, old_beat_residual);\n        set_cell(fragColor, uv, 8, beat_residual);\n        set_cell(fragColor, uv, 11, Cell(10));\n        set_cell(fragColor, uv, 10, noise);\n        frames_since_last_beat = 1.;\n    }\n    else\n    {\n        set_cell(fragColor, uv, 7, min(last_beat_min, beat_residual));\n        set_cell(fragColor, uv, 8, max(last_beat_max, beat_residual));\n        set_cell(fragColor, uv, 10, Cell(10));\n        set_cell(fragColor, uv, 11, Cell(11));\n        frames_since_last_beat += 1.;\n    }\n\n    set_cell(fragColor, uv, 9, vec4(beat, frames_since_last_beat, 0, 0));\n    \n    // #puller\n    vec4 integratedVolume = Cell(19);\n    vec4 v = integratedVolume * 0.5;\n    vec2 c = vec2( 0.5, 0.5 );\n    vec2 s0 = c + vec2(v.x + v0.x*0.25, +v.x - v.z- v.y);\n\tvec2 s1 = c + vec2(v.x - v.z, - v.y*0.5 - v0.y*0.5);\n    vec2 s2 = c + vec2(-v.z - v0.z*0.25, -v.z + v.x- v.y);\n    \n    vec4 p_bass = vec4(s0, 0, 0);\n    vec4 p_mid = vec4(s1, 0, 0);\n    vec4 p_treb = vec4(s2, 0, 0);\n    vec4 p_vol = vec4((s0 + s1 + s2)/3., 0, 0);\n\n    float drinkMe = 1.;\n    if(drinkMe == 1.){\n        vec2 centerOffset = (p_vol.xy - vec2(0.5,0.5))*vec2(-0.5,-0.5);\n        p_bass.xy -= centerOffset;\n        p_mid.xy  -= centerOffset;\n        p_treb.xy -= centerOffset;\n    }\n    \n    vec2 centerOffset = vec2(0.,0.3);\n    p_bass.xy -= centerOffset;\n    p_mid.xy  -= centerOffset;\n    p_treb.xy -= centerOffset;\n    \n\n    set_cell(fragColor, uv, 12, vec4(p_bass.xy, p_mid.xy));\n    set_cell(fragColor, uv, 13, vec4(p_treb.xy, p_vol.xy));\n    // p_.xy = pos, p_.zw = velocity\n    \n    vec4 p0 = Cell(17);\n    vec4 p1 = Cell(14);\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    vec4 p4 = Cell(18);\n    \n    float force = 1.666;\n    float friction = 0.0005;\n    float speed = 0.0066;\n    float grav = 0.1;\n    \n    float impactfactor = 128.;\n    spring(force * impactfactor, p0, p_bass);\n    spring(force * impactfactor, p0, p_mid);\n    spring(force * impactfactor, p0, p_treb);\n    spring(force, p0, p1);\n    spring(force, p1, p2);\n    spring(force, p2, p3);\n    spring(force, p3, p4);\n    \n    resist(friction, p0);\n    resist(friction, p1);\n    resist(friction, p2);\n    resist(friction, p3);\n    resist(friction, p4);\n    \n    p1.w += grav;\n    p2.w += grav;\n    p3.w += grav;\n    p4.w += grav;\n    \n    // Verlet integration\n    p0.xy += p0.zw * speed;\n    p1.xy += p1.zw * speed;\n    p2.xy += p2.zw * speed;\n    p3.xy += p3.zw * speed;\n    p4.xy += p4.zw * speed;\n    \n    if(iFrame < 2){\n\t    p0.xy = p_vol.xy;\n\t    p1.xy = p_vol.xy;\n    \tp2.xy = p_vol.xy;\n    \tp3.xy = p_vol.xy;\n    \tp4.xy = p_vol.xy;\n    }\n\n    set_cell(fragColor, uv, 17, p0);\n    set_cell(fragColor, uv, 14, p1);\n    set_cell(fragColor, uv, 15, p2);\n    set_cell(fragColor, uv, 16, p3);\n    set_cell(fragColor, uv, 18, p4);\n    \n    set_cell(fragColor, uv, 19, integratedVolume*0.92 + v0*0.1);\n    set_cell(fragColor, uv, 20, v0);\n    \n    float volMin = min(integratedVolume.x, min(integratedVolume.y, integratedVolume.z));\n    float volMax = max(integratedVolume.x, max(integratedVolume.y, integratedVolume.z));\n    \n    vec4 normalizedVolume = (integratedVolume - volMin*vec4(1))/(volMax - volMin);\n    if(volMax - volMin != 0.){\n    \tset_cell(fragColor, uv, 21, normalizedVolume);\n        set_cell(fragColor, uv, 22, Cell(22) - (normalizedVolume-0.5)*1.33*iTimeDelta);\n    }\n    \n    set_cell(fragColor, uv, 23, vec4(s1,s0));\n    set_cell(fragColor, uv, 24, vec4(s0,s2));\n    \n    vec4 C25 = Cell(25); // 1D spring <s0, v0, v1, s1>\n    float ff = iTimeDelta*0.75; // force factor\n    float vf = 0.25; // velocity factor\n    float puller = (integratedVolume.x - integratedVolume.z)/2.;\n    C25.yz *= 0.99; // dampen\n    // accelerate\n    C25.y += (C25.w - C25.x * 2. + puller) * ff;\n    C25.z += (C25.x - C25.w) * ff;\n    // Verlet integration\n    C25.x += C25.y * vf;\n    C25.w += C25.z * vf;\n    \n    set_cell(fragColor, uv, 25, C25);\n    \n    vec4 C26 = Cell(26); // fractal swimmer <x, y, bending, orientation>\n    vec4 C27 = Cell(27); // previous frame fractal swimmer\n    set_cell(fragColor, uv, 27, C26);\n    \n    // now we can update C26\n    \n    float rollMoment = C26.w - C27.w;\n    vec2 velocity = C26.xy - C27.xy;\n    float bendForce = C26.z- C27.z;\n    float forwardFriction = 0.99;\n    float turnFriction = 0.99;\n    \n    float inputForce = -abs(C25.w - puller)*iTimeDelta*24.;\n\t\n    vec2 velocityPolar = uv_polar(velocity, vec2(0)); // <ang, rad>\n    \n    velocityPolar.y = velocityPolar.y * forwardFriction;\n    velocity = vec2(cos(velocityPolar.x), sin(velocityPolar.x)) * velocityPolar.y;\n    \n    float w = C26.w;\n    velocity += vec2(cos(w), sin(w))*inputForce/256.;\n    \n    //velocity = vec2(- pixelSize.x*4., 0.);\n    //velocity = vec2(0., - pixelSize.x*4.);\n    //velocity = vec2(0);\n    \n    float spineBending = -(C25.x * 0.5 + C25.w* 0.5 - puller) * 2.;\n   \tC26.z = spineBending;\n    C26.xy += velocity;\n    C26.w += rollMoment * turnFriction - velocityPolar.y * C26.z * 2.;\n    \n    //C26.w += 0.*(C25.w - puller)*iTimeDelta*24.; // todo: multiply with forward velocity\n    set_cell(fragColor, uv, 26, C26);\n        \n}", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22703, "src": "https://soundcloud.com/b1tyze/b1tyze-international-clash", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1078, 1078, 1099, 1099, 1136], [1138, 1138, 1154, 1154, 1311], [1313, 1313, 1368, 1368, 1426], [1428, 1428, 1460, 1460, 1513], [1515, 1515, 1547, 1547, 1600], [1602, 1602, 1659, 1659, 10866]], "test": "untested"}
{"id": "wdlBWj", "name": "Taylor Series (any function)", "author": "jeyko", "description": "Based on 3blue1brown video https://www.youtube.com/watch?v=3d6DsjIBzJ4&t=691s", "tags": ["tutorial", "taylor", "maths", "series"], "likes": 9, "viewed": 410, "published": 3, "date": "1589120495", "time_retrieved": "2024-07-30T21:07:30.973973", "image_code": "// Thanks to mla for the smooth plotting function! \n\n\n// Taylor Series\n\n// This version works for any function\n// Check the other version for f() defined as cos(): https://www.shadertoy.com/view/WdlBD2\n// The other one is better for learning how it works\n\n// j = 0.\n// f(j) = cos(j)\n// T(x) = f(j) + x*f(j)'/1! + x^2*f(j)''/2! + x^3*f'''/3! +  x^4*f''''/4! ... etc\n\n\n// This is a series, which approximates a given function around a point\n// by matching its value and derivatives at that point.\n\n// The derivatives are measured at the point, then scaled by x^n  divided by a n! \n// This is done, so you negate the extra terms you get when deriving the equation.\n\n\n// Thanks to 3blue1brown for his video from which I learned this! \n// https://www.youtube.com/watch?v=3d6DsjIBzJ4&t=691s\n\n// And thanks to mla for the smooth plotting function! \n\n\n// You can change the amount of derivatives in the taylor(function)\n\n\nfloat factorial(float x){float res = 1.;for(float i = 1.; i <= x;i++){res*=i;}return res;}\n\n#define dj 0.03\n\n#define offs \t\t(iTime)\n\n#define fn(j) \t\t(cos(j+offs)+sin( (j+offs)*2. ))\n\n#define deriv(j) \t(fn(j+dj)-fn(j))/dj\n#define deriv2(j) \t(deriv(j+dj)-deriv(j))/dj\n#define deriv3(j) \t(deriv2(j+dj*4.)-deriv2(j))/dj/4.\n#define deriv4(j) \t(deriv3(j+dj*8.)-deriv3(j))/dj/8.*0.\n\n\nfloat taylor(float j){\n\tfloat res = 0.;\n\t\n    res += fn(0.);\n    res += deriv(0.)  *j \t\t/ factorial(1.);\n    res += deriv2(0.) *j*j \t\t/ factorial(2.);\n    res += deriv3(0.) *j*j*j \t/ factorial(3.);\n    //res += deriv4(0.) *j*j*j*j \t/ factorial(4.);\n    \n    return res;\n}\n\n// Plotting width\nconst float W = 0.025; \n// Plots a fn\nconst float eps = 0.01;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,W*width*0.5, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*5.;\n\n    vec3 col = vec3(0);\n    \n    // functions \n\n\tcol += graph( uv.y, fn(uv.x),\t  fn(uv.x+eps),     vec3(0.,0.2,0.1), 1. );\n    col += graph( uv.y, deriv(uv.x),  deriv(uv.x+eps),  vec3(0.0,0.02,0.0), 1. );\n    col += graph( uv.y, deriv2(uv.x), deriv2(uv.x+eps), vec3(0.02,0.0,0.0), 1. );\n    col += graph( uv.y, deriv3(uv.x), deriv3(uv.x+eps), vec3(0.0,0.0,0.04), 1. );\n    col += graph( uv.y, taylor(uv.x), taylor(uv.x+eps), vec3(0.9,0.1,0.1), 1. );\n\t\n    \n    \n    // plotlines\n    \n    float pi = acos(-1.);\n    float uvxmod = abs( (fract((uv.x+offs+pi/3.)*2./3.14) -pi/5.)*pi/2.  );\n    col += graph(uvxmod + eps,0.01,0.02,vec3(1,1,1)/2.,0.75)*smoothstep(W,W*0.003,abs(uv.y)-0.1);\n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1)/2.,0.5);\n    \n    // gamma correction\n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[914, 914, 939, 939, 1004], [1291, 1291, 1313, 1313, 1562], [1644, 1644, 1709, 1709, 1824], [1827, 1827, 1884, 1884, 2798]], "test": "untested"}
{"id": "WssfD2", "name": "SPACEMYFIRST", "author": "Gerych", "description": "#Space\n#my first shader\n", "tags": ["spacemyfirst"], "likes": 1, "viewed": 329, "published": 3, "date": "1589119536", "time_retrieved": "2024-07-30T21:07:31.788795", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec2 xy = fragCoord/iResolution.xy;\nxy.y = xy.y+iTime/5.0;\n\nvec4 texColor = texture(iChannel0,xy);\nvec2 col= 0.5*sin(iTime+xy.xy);\ntexColor.rg-=col.rg+0.5;\n\nfragColor=texColor;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 237]], "test": "untested"}
{"id": "WdlBD2", "name": "Taylor Series (cosinus)[Day 143]", "author": "jeyko", "description": "Based on 3blue1brown video https://www.youtube.com/watch?v=3d6DsjIBzJ4&t=691s", "tags": ["tutorial", "taylor", "maths", "series"], "likes": 15, "viewed": 428, "published": 3, "date": "1589119331", "time_retrieved": "2024-07-30T21:07:32.698363", "image_code": "// Thanks to mla for the smooth plotting function! \n\n\n// Taylor Series\n\n// This version is defined for cos()\n// Check the other version for any function as input: https://www.shadertoy.com/view/wdlBWj\n// This one is better for learning how it works\n\n\n// j = 0.\n// f(j) = cos(j)\n// T(x) = f(j) + x*f(j)'/1! + x^2*f(j)''/2! + x^3*f'''/3! +  x^4*f''''/4! ... etc\n\n\n// This is a series, which approximates a given function around a point\n// by matching its value and derivatives at that point.\n\n// The derivatives are measured at the point, then scaled by x^n and divided by n! \n// This is done, so you negate the extra terms you get when deriving the equation.\n\n\n// Thanks to 3blue1brown for his video from which I learned this! \n// https://www.youtube.com/watch?v=3d6DsjIBzJ4&t=691s\n\n\n// You can change the amount of derivatives in the taylor(function)\n// Uncomment around line 78 to plot the derivatives\n\n\nfloat factorial(float x){float res = 1.;for(float i = 1.; i <= x;i++){res*=i;}return res;}\n\n\n#define offs \t\t(iTime)\n\n#define fn(j) \t\tcos(j+offs)\n\n#define deriv(j) \t-sin(j+offs)\n#define deriv2(j) \t-cos(j+offs)\n#define deriv3(j) \tsin(j+offs)\n\n\nfloat taylor(float j){\n\tfloat res = 0.;\n\t\n    res += fn(0.);\n    res += deriv(0.)  *j \t\t/ factorial(1.);\n    res += deriv2(0.) *j*j \t\t/ factorial(2.);\n    res += deriv3(0.) *j*j*j \t/ factorial(3.);\n    res += fn(0.)     *j*j*j*j \t/ factorial(4.); // cos(x) is the 4th derivatine of cos(x)\n    \n    return res;\n}\n\n// Plotting width\nconst float W = 0.03; \n// Plots a fn\nconst float eps = 0.01;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,dFdy(y)*W*width, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*5.;\n\n    vec3 col = vec3(0);\n    \n    // functions \n\tcol += graph( uv.y, fn(uv.x),\t  fn(uv.x+eps),     vec3(0.,0.2,0.1), 1. );\n    col += graph( uv.y, deriv(uv.x),  deriv(uv.x+eps),  vec3(0.0,0.02,0.0), 1. );\n    col += graph( uv.y, deriv2(uv.x), deriv2(uv.x+eps), vec3(0.02,0.0,0.0), 1. );\n    col += graph( uv.y, deriv3(uv.x), deriv3(uv.x+eps), vec3(0.0,0.0,0.04), 1. );\n    col += graph( uv.y, taylor(uv.x), taylor(uv.x+eps), vec3(0.9,0.1,0.1), 1. );\n\t\n    \n    \t\n    \n    \n    // plotlines\n    \n    float pi = acos(-1.);\n    float uvxmod = abs( (fract((uv.x+offs+pi/3.)*2./3.14) -pi/5.)*pi/2.  );\n    col += graph(uvxmod + eps,0.01,0.02,vec3(1,1,1)/2.,0.75)*smoothstep(W,W*0.003,abs(uv.y)-0.1);\n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1)/2.,0.5);\n    \n    \n    // gamma correction\n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[905, 905, 930, 930, 995], [1147, 1147, 1169, 1169, 1458], [1539, 1539, 1604, 1604, 1723], [1725, 1725, 1782, 1782, 2711]], "test": "untested"}
{"id": "3dlBDj", "name": "Box of Madness", "author": "Zauwara", "description": "Wanted to toy around with quadtree uvs and made a neat little visualisation.\n\nHash functions from David Hoskins https://www.shadertoy.com/view/4djSRW", "tags": ["2d", "crt", "tiling", "quadtree"], "likes": 25, "viewed": 658, "published": 3, "date": "1589104671", "time_retrieved": "2024-07-30T21:07:33.595963", "image_code": "float shiftStr = 1.5;\nfloat timeScale = 0.8;\n\nfloat noiseScale = 1.0;\n\nfloat scanLineWidth = 5.0;\nfloat scanLineSpeed = 20.0;\nfloat scanLineIntensity = 0.05;\n\nvec2 quadTreeUV(vec2 uv, float depth, float hash) {\n    \n    vec2 ret = uv;\n    \n    for(float i = 1.0; i < depth; i++) {\n        \n        ret = mod(ret, vec2(0.5)) * 2.0;\n        \n        float x = pow(2.0, i);\n        \n        if (hash12(floor(uv * x) * 1000.0) > 0.6) {\n            \n            return ret;\n        }\n    }\n    \n    return ret;\n}\n\nfloat fill(vec2 fragCoord) {\n    float sideLength = min(iResolution.x,iResolution.y) * 0.9;\n    vec2 sqMin = (iResolution.xy - vec2(sideLength)) / 2.0;\n    vec2 sqMax = (iResolution.xy + vec2(sideLength)) / 2.0;\n    \n    if(any(lessThan(fragCoord,sqMin)) || any(greaterThan(fragCoord, sqMax))) {\n        return 1.0;\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - sqMin) / vec2(sideLength);\n    \n    float t = 1.0 - mod(iTime * timeScale, 1.0);\n\t\n    vec2 qTuv = quadTreeUV(uv, 6.0, 0.0);\n    \n    float distS = max(abs(qTuv.x - 0.5), abs(qTuv.y - 0.5)) * 2.0; \t\t// for squares\n    //float distC = length(qTuv - 0.5) * 2.0;\t\t\t\t\t\t\t// for circles\n    //float distD = (abs(qTuv.x - 0.5) + abs(qTuv.y - 0.5)) * 2.0;\t\t// for diamonds\n    //float distO = max(distS, distD / 1.5);\t\t\t\t\t\t\t// for octagons\n    \n    \n    float o = pow(distS, 5.0);\n    float i = pow(distS, 2.0);\n    \n    float outer = 1.0 - step(o, 0.8) * (1.0 - step(o, 0.1));\n    float inner = step(i, t * 0.6 - 0.1) * (1.0 - step(i, t * 0.6 - 0.2));\n    \n    return outer - inner;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fC )\n{\n    // compute base img colorshifted\n    fragColor = vec4(\n        fill(fC + vec2(-shiftStr, -shiftStr)),\n        fill(fC + vec2( 0.0,  shiftStr)),\n        fill(fC + vec2( shiftStr, -shiftStr)),\n        1.0\n    );\n    \n    // add noise\n    fragColor += vec4((vec3(hash12(floor(fC / noiseScale) + iTime)) - 0.5) * 0.4, 1.0);\n    \n    // scanlines\n    fragColor *= floor(mod(fC.y + iTime * scanLineSpeed, scanLineWidth * 2.0) / scanLineWidth) * scanLineIntensity + (1.0 - scanLineIntensity);\n    \n    // vignette\n    float cd = pow(length(abs(fC / iResolution.xy - vec2(0.5, 0.5)) * 1.25), 3.0);\n    fragColor -= vec4(vec3(cd), 0.0);\n    \n}", "image_inputs": [], "common_code": "// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 210, 210, 507], [509, 509, 537, 537, 1595], [1597, 1597, 1647, 1684, 2286]], "test": "untested"}
{"id": "wdXBD2", "name": "4 Dimensional Modelling", "author": "blackle", "description": "various objects that can be made by applying a handful of operations to a 4 dimensional vector before passing it into a 4 dimensional cube.", "tags": ["4d"], "likes": 12, "viewed": 502, "published": 3, "date": "1589098187", "time_retrieved": "2024-07-30T21:07:34.590304", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nint INSTRUCTIONS;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//this is a multiplication by the quaternion (.5, .5, .5, .5)\n//somehow this results in a good rotation\nvec4 rot4d(vec4 b) {\n    return vec4(dot(b,vec4(1)), b.yzw + b.zwy - b.wyz - b.xxx)*0.5;\n}\n\nfloat super(vec4 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec4 p, vec4 d) {\n    vec4 q = abs(p)-d;\n    return super(max(q,0.))+min(0.,max(max(q.x,q.w),max(q.y,q.z)));\n}\n\nvec4 smin(vec4 a, vec4 b, float k) {\n    vec4 h = max(vec4(0),-abs(a-b)+k)/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat scene(vec3 p) {\n    int inst = INSTRUCTIONS;\n    int off = inst % 3; inst /= 3;\n    vec4 pp = vec4(p,vec3(1.,0.5,0.)[off]);\n    for (int i = 0; i < 6; i++) {\n    \tint op = inst % 3; inst /= 2;\n        if (op == 0) pp = sqrt(pp*pp+0.001); //smooth abs\n        if (op == 1) pp = rot4d(pp); //fixed 4d rotation\n        if (op == 2) pp.x -= 0.25; //offset\n    }\n    pp = smin(pp,rot4d(pp),0.1);\n    float b1 = box(pp,vec4(1.))-0.1;\n    return b1;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nfloat bayer(vec2 uv) {\n    return texelFetch(iChannel0,ivec2(uv)%8,0).x/128.;\n}\n\nint hash(int x) {\n    x += 45758;\n    for (int i = 0; i < 16; i++) {\n    \tx ^= x << 13;\n\t\tx ^= x >> 7;\n\t\tx ^= x << 17;\n    }\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INSTRUCTIONS = hash(int(iTime));\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.2,uv));\n    vec3 samplepos = erot(vec3(-10,0,0), vec3(0,0,1), iTime*.2);\n    float radius = 10.-scene(samplepos);\n    vec3 init = vec3(-radius-4.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 250 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.1,.1,scene(p+vec3(.1)));\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    float diff = mix(length(sin(n*3.5)*0.5+0.5)/sqrt(3.),ss,.3)*ao*1.5;\n    float spec = length(sin(r*3.)*0.5+0.5)/sqrt(3.);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n    vec3 col = mix(srgb(0.05,0.01,0.),srgb(0.45,0.6,0.8), diff) + pow(spec,5.)*frens;\n    vec3 bg = vec3(smoothstep(1.5,0.,length(uv))*.1);\n    fragColor.xyz = (hit ? col : bg) + bayer(fragCoord);\n    fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBD2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[213, 213, 251, 251, 313], [315, 419, 439, 439, 509], [511, 511, 532, 532, 564], [566, 566, 593, 593, 686], [688, 688, 724, 724, 799], [801, 801, 822, 822, 1251], [1253, 1253, 1272, 1272, 1388], [1390, 1390, 1428, 1428, 1460], [1462, 1462, 1484, 1484, 1541], [1543, 1543, 1560, 1560, 1683], [1685, 1685, 1742, 1742, 3177]], "test": "untested"}
{"id": "wdffDj", "name": "This is a good sin copy", "author": "RubinReality", "description": "This is a copy of \"this is a good sin :0\" by gurudevbk", "tags": ["sin"], "likes": 1, "viewed": 286, "published": 3, "date": "1589071876", "time_retrieved": "2024-07-30T21:07:35.462971", "image_code": "// Copy of \"this is a good sign :0\" by gurudevbk\n// returns true if a point [uv] is within the circle defined by [origin, radius]\nbool circle(vec2 uv, vec2 origin, float radius) {\n \treturn (length(uv-origin) < radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float thickness = 0.1;\n    float radius = 0.3;\n    vec2 origin = vec2(0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0.5,0.5,0.36);\n    \n    // Time varying pixel color\n    if (abs(length(uv-origin) - radius) < abs(sin(iTime)/3.)) {\n    \tcol = 0.5 + 0.5*cos(iTime+length(uv-radius)+col);\n    \tcol.r += sin(iTime)+cos(iTime);\n    }\n    \n    else {\n    \tcol = 0.5 + 0.5*sin(iTime+length(uv-radius)+col);\n        col.r += sin(iTime)+cos(iTime);\n    }\n    \n    col.g /= col.r;\n    \n    col.g *= 0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdffDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 130, 179, 179, 220], [222, 222, 279, 279, 912]], "test": "untested"}
{"id": "WssfzS", "name": "rayMarch_sphere+heart", "author": "elle", "description": "SDF   -> https://iquilezles.org/articles/distfunctions/distfunctions.htm\nheart -> https://www.youtube.com/watch?v=aNR4n0i2ZlM", "tags": ["raymarch", "sphere", "heart"], "likes": 6, "viewed": 528, "published": 3, "date": "1589069117", "time_retrieved": "2024-07-30T21:07:36.533110", "image_code": "#define PI\t\t3.14159265\n#define EPS\t0.001\n#define MAX_STEPS 200\n#define MAX_DIST 100.0\n#define BOARD_SQUARE 1.0\n#define SPHERE1 0\n#define SPHERE2 1\n#define SPHERE3 2\n#define HEART\t3\n#define PLANE\t4\n\n\nstruct Intersect {\n    int\t\tidx;\n    float\tdist;};\n\nstruct Point\t{\n\tvec3\tpos;\n    vec3\tcol;};\n    \nvec3 diffCol[] = vec3[](vec3(0.0, 0.0, 1.0),\n\t\t\t\t\t\tvec3(1.0, 0.0, 1.0),\n\t\t\t\t\t\tvec3(0.0, 1.0, 0.3),\n\t\t\t\t\t\tvec3(1.0, 0.1, 0.1));\n\nfloat diff[] =  float[](0.4, 0.5,  0.4,  0.8,  0.7);\nfloat spec[] =  float[](0.9, 1.2,  1.1,  1.9,  0.3);\nfloat specPow[]=float[](8.0, 16.0, 16.0, 32.0, 4.0);\n\nvec3 lightPos = vec3(-3.0, 3.0, 5.0);\n\nfloat sphereDist(in vec3 pos, in float radius, in vec3 center)\n{\n    return (length(pos + center) - radius);\n}\n\nfloat planeDist(in vec3 pos, in vec4 normal)\n{\n    return (dot(pos, normal.xyz) + normal.w);\n}\n\nfloat heartDist(vec3 q, float r)\n{\n    float ani = pow(0.5 + 0.5 * sin(7.0 * iTime + q.y / 20.0), 4.0);\n    q *= 1.0 - 0.2 * vec3(1.0,0.5,1.0)*ani;\n    q.y -= 0.2 * ani;\n    float x = abs(q.x);\n        \n    float y = q.y;\n    float z = q.z;\n    y = -0.5 + y * 1.2 - x * sqrt(max((5.0 - x) / 10.0, 0.0));\n    float res = sqrt(x*x + y*y + z*z) - r;\n    return res;\n}\n\n\nIntersect sceneDist(vec3 pos)\n{\n\tfloat SINt = sin(iTime);\n    float SINt03 = sin(iTime * 0.3);\n    float COSt03 = cos(iTime * 0.3);\n    float sphereD1_1 = sphereDist(pos, 1.8, vec3(0, 0.1, 0));\n\tfloat sphereD1_2 = sphereDist(pos, 1.8, vec3(0, 0.1 - 2.0*(0.5 + 0.5 * SINt), 0));\n    float sphereD2 = sphereDist(pos, 0.7, vec3(2.8 * COSt03, SINt, 2.8 * SINt03));\n    float sphereD3 = sphereDist(pos, 0.5, vec3(3.8 * SINt03, cos(iTime), 3.8 * COSt03));\n    float planeD = planeDist(pos, vec4(0.0, 1.0, 0.0, 2.2));\n    float heartD = heartDist(pos, 0.5);\n    Intersect res;\n    \n    // hollow sphere\n\tsphereD1_1 = abs(sphereD1_1) - 0.03;\n\tsphereD1_1 = max(sphereD1_1, pos.y);\n\tsphereD1_2 = abs(sphereD1_2) - 0.03;\n\tsphereD1_2 = max(sphereD1_2, - (pos.y - 2.0 * (0.5 + 0.5 * SINt)));\n\n    res.dist = min(min(min(min(min(sphereD1_1, sphereD1_2), sphereD2), sphereD3), planeD), heartD);\n    if (res.dist == sphereD1_1 || res.dist == sphereD1_2)\n        res.idx = SPHERE1;\n    else if (res.dist == sphereD2)\n\t\tres.idx = SPHERE2;\n    else if (res.dist == sphereD3)\n\t\tres.idx = SPHERE3;\n    else if (res.dist == heartD)\n        res.idx = HEART;     \n    else\n        res.idx = PLANE;\n    return (res);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    sceneDist(vec3(p.x + EPS, p.y, p.z)).dist - sceneDist(vec3(p.x - EPS, p.y, p.z)).dist,\n    sceneDist(vec3(p.x, p.y + EPS, p.z)).dist - sceneDist(vec3(p.x, p.y - EPS, p.z)).dist,\n    sceneDist(vec3(p.x, p.y, p.z  + EPS)).dist - sceneDist(vec3(p.x, p.y, p.z - EPS)).dist));\n}\n\nIntersect rayMarch(vec3 ro, vec3 rd)\n{\n    Intersect d;\n    Intersect intersect;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        d = sceneDist(ro + intersect.dist * rd);\n        intersect.dist += d.dist;\n        if (intersect.dist < EPS || intersect.dist >= MAX_DIST)\n            break;\n    }\n    intersect.idx = d.idx;\n    return (intersect);\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float min_t, in float max_t, in float k)\n{\n    float res = 1.0;\n    for (float t = min_t; t < max_t;)\n    {\n        float dist = sceneDist(ro + rd * t).dist;\n        if (dist < EPS)\n            return 0.0;\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return (res);\n}\n\nvec3 boardColor(vec3 p)\n{\n    vec3 pos = vec3(p.x, p.y, p.z - (0.7 * iTime));\n    \n    if ((mod(pos.x,(BOARD_SQUARE * 2.0)) < BOARD_SQUARE && mod(pos.z,(BOARD_SQUARE * 2.0)) > BOARD_SQUARE) ||\n        (mod(pos.x,(BOARD_SQUARE * 2.0)) > BOARD_SQUARE && mod(pos.z,(BOARD_SQUARE * 2.0)) < BOARD_SQUARE))\n\t\treturn vec3(1.0);\n    else\n\t\treturn vec3(0.0);\n}\n\nvec3 getLight(int idx, vec3 pos, vec3 eye)\n{\n    vec3 diffuseCol;\n    if (idx == PLANE)\n        diffuseCol = boardColor(pos);\n    else\n        diffuseCol = diffCol[idx];\n    vec3 specularCol = vec3(1.0);\n    vec3 Norm = getNormal(pos);\n    vec3 Ldir = normalize(lightPos - pos);\n    vec3 View = normalize(eye - pos);\n    vec3 Refl = normalize(reflect(-Ldir, Norm));\n\n    float dotLN = dot(Ldir, Norm);\n    float dotRV = dot(Refl, View);\n\n    // light not visible\n    if (dotLN < 0.0)\n        return vec3(0.0);\n\n    // light reflection in opposite direction, apply only diffuse lighting\n    if (dotRV < 0.0)\n        return 1.7 * (diffuseCol * dotLN) * diff[idx];\n\n    vec3 half_direction = normalize(normalize(Ldir) + View);\n    float specular = pow(max(dot(half_direction, Norm), 0.0), specPow[idx]);\n    return 1.7 * diffuseCol * dotLN * diff[idx] + specularCol * specular * spec[idx];\n}\n\nPoint getColor(vec3 ro, vec3 rd, vec3 eye)\n{\n    Point point;\n    Intersect intersect = rayMarch(ro, rd);\n    point.pos = ro + intersect.dist * rd;\n    if (intersect.dist > MAX_DIST - EPS)\n        point.col = vec3(0.0, 0.0, 1.0 - 2.0 * rd.y); //background\n    else\n    {    \n\t\t//ambient\n        vec3 ambientCol = vec3(0.2, 0.4, 0.7);    \n    \tvec3 ambientLight = 0.25 * vec3(1.0);\n    \tpoint.col = ambientLight * ambientCol;\n\n    \t//shadow\n    \tvec3 shadowDir = normalize(lightPos - point.pos);\n    \tfloat shadow = getShadow(point.pos + shadowDir, shadowDir, 0.0, MAX_DIST, 8.0);\n\n    \t//diffuse + specular\n    \tvec3 blinn_phong = getLight(intersect.idx, point.pos, eye) * shadow;\n    \tpoint.col += blinn_phong;\n    }\n    return point;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 ro = vec3(mouse.x, mouse.y, 8.0);\n\n    Point point = getColor(ro, rd, ro);\n\tvec3 color = point.col;   \n    \n    vec3 rd1 = rd - (2.0 * dot(rd, getNormal(point.pos)) * getNormal(point.pos));\n    Point point2 = getColor(point.pos + rd1, rd1, ro);\n    color = mix(color, point2.col, 0.22);\n    \n    vec3 rd2 = rd1 - (2.0 * dot(rd1, getNormal(point2.pos)) * getNormal(point2.pos));\n    Point point3 = getColor(point2.pos + rd2, rd2, ro);\n    color = mix(color, point3.col, 0.12);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 625, 689, 689, 735], [737, 737, 783, 783, 831], [833, 833, 867, 867, 1197], [1200, 1200, 1231, 1231, 2393], [2395, 2395, 2419, 2419, 2724], [2726, 2726, 2764, 2764, 3077], [3079, 3079, 3164, 3164, 3410], [3412, 3412, 3437, 3437, 3763], [3765, 3765, 3809, 3809, 4653], [4655, 4655, 4699, 4699, 5392], [5395, 5395, 5450, 5450, 6202]], "test": "untested"}
{"id": "WdlfRs", "name": "Whitney Umbrella", "author": "mla", "description": "Raymarched Whitney Umbrella - a singular surface. See header for controls etc.", "tags": ["whitney", "umbrella", "singularity"], "likes": 6, "viewed": 372, "published": 3, "date": "1589064349", "time_retrieved": "2024-07-30T21:07:37.383835", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Whitney Umbrella\n//\n// Matthew Arcus, mla, 2020.\n//\n// Wanted to see how some classic singularities came out with raymarching\n// the implicit equation - seems to work OK, even with numeric gradient,\n// with even the 'handle' coming out alright.\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <left>/<right>: fog distance\n// f: fog\n// l: light transform\n// r: autorotation\n// \n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nfloat AA = 2.0;\nint maxsteps = 100;\nfloat maxdist = 5.0;\nfloat precis = 0.0005;\n\nbool dorotate = true; // Autorotate\n\nfloat eval(vec3 p) {\n  float x = p.x, y = p.y, z = p.z;\n  return y*y - x*x*z; // Whitney Umbrella\n}\n\n// To see how numeric gradient works change #if\n// This might be a good place to use dual numbers.\nvec3 cgrad(vec3 p) {\n#if 1\n  float x = p.x, y = p.y, z = p.z;\n  return vec3(-2.0*x*z,2.0*y,-x*x);\n#else\n  // Numeric gradient\n  float eps = 1e-2;\n  vec2 e = vec2(eps,0);\n  vec3 tt = vec3(eval(p+e.xyy)-eval(p-e.xyy),\n                 eval(p+e.yxy)-eval(p-e.yxy),\n                 eval(p+e.yyx)-eval(p-e.yyx));\n  return tt/(2.0*eps);\n#endif\n}\n\nfloat rosign;   // sign of implict equation at ray origin\nfloat getdist(vec3 p) {\n  float d = eval(p)/length(cgrad(p));\n  d *= rosign;\n  return d;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for(int i = 0; i < maxsteps; i++) {\n    vec3 p = ro + t*rd;\n    float d = getdist(p);\n    t += d;\n    if (t > maxdist || abs(d) < t*precis) break;\n  }\n  return t;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return v * mix( vec3(1.0), rgb, s);\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel2, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dorotate = !key(CHAR_R);\n  float camera = 2.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  maxdist = 2.0*camera;\n  maxdist *= exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)));\n  vec3 ro = vec3(0,0,-camera);\n  ro = transform(ro);\n  vec3 light = vec3(1,2,-3);\n  // Leaving the light fixed (untransformed) is more dramatic but\n  // may make things harder to see.\n  if (key(CHAR_L)) light = transform(light);\n  light = normalize(light);\n  rosign = sign(eval(ro));\n  vec3 aacol = vec3(0);\n  vec3 fogcol = vec3(1,1,0.5); //mix(vec3(1),basecol,0.75);\n  vec3 basecol = hsv2rgb(0.1+0.01*iTime,1.0,1.0); //vec3(1,0.5,0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 rd = vec3(uv,2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      float t = march(ro, rd);\n      vec3 col = fogcol;\n      if (t < maxdist) {\n        col = basecol;\n        vec3 p = ro+t*rd;\n        int parity = int(dot(floor(2.0*p+1e-3),vec3(1)));\n        if (mymod(parity,2) == 1) col *= 0.8;\n        vec3 n = rosign*cgrad(p);\n        if (dot(n,rd) > 0.0) n = -n;\n        n = normalize(n);\n        float diffuse = mix(1.0,max(dot(n,light),0.0),0.6);\n        float intensity = 1.2;\n        col *= diffuse*intensity;\n        float fog = key(CHAR_F) ? 0.0 : t/maxdist;\n        col = mix(col,fogcol,fog);\n      }\n      aacol += col;\n    }\n  }\n  aacol = pow(aacol/(AA*AA),vec3(0.4545));\t// gamma correction\n  fragColor = vec4(aacol,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 716, 716, 795], [797, 896, 916, 916, 1236], [1254, 1296, 1319, 1319, 1386], [1388, 1388, 1419, 1419, 1603], [1605, 1605, 1641, 1641, 1693], [1695, 1695, 1722, 1722, 2051], [2053, 2053, 2094, 2094, 2264], [2266, 2266, 2291, 2331, 2386], [2684, 2684, 2709, 2709, 2757], [2759, 2759, 2782, 2782, 2814], [2816, 2816, 2836, 2836, 2896], [2898, 2898, 2950, 2950, 4499]], "test": "untested"}
{"id": "wdfBWj", "name": "VisionI- Uffizi- Uffizi -Visions", "author": "tester1963", "description": "Visioni- Uffizi-1 Uffizi -Visions", "tags": ["visioniuffizivisions"], "likes": 4, "viewed": 256, "published": 3, "date": "1589061381", "time_retrieved": "2024-07-30T21:07:38.370198", "image_code": "\nconst int MAX_MARCHING_STEPS=2048;\nconst float MIN_DIST=.02;\nconst float MAX_DIST=10.;\nconst float EPSILON=.00001;\nconst float PI = 3.141;\n\n// Primitives from https://iquilezles.org/articles/distfunctions \n \n\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdRoundBox(vec3 p,vec3 b,float r)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-r;\n}\n\nfloat sdVerticalCapsule(vec3 p,float h,float r)\n{\n    p.y-=clamp(p.y,2.,h);\n    return length(p)-r;\n}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 pa=p-a,ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*h)-r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat opUnion(float d1,float d2){return min(d1,d2);}\n\nfloat opSubtraction(float d1,float d2){return max(-d1,d2);}\n\nfloat opIntersection(float d1,float d2){return max(d1,d2);}\n\nfloat opSmoothUnion(float d1,float d2,float k){\n    float h=clamp(.5+.5*(d2-d1)/k,0.,1.);\nreturn mix(d2,d1,h)-k*h*(1.-h);}\n\nfloat opSmoothSubtraction(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2+d1)/k,0.,1.);\nreturn mix(d2,-d1,h)+k*h*(1.-h);}\n\nfloat opSmoothIntersection(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2-d1)/k,0.,1.);\nreturn mix(d2,d1,h)+k*h*(1.-h);}\n\nvec3 rotateX(vec3 p,float angle){\n    return vec3(mat4(\n           1,0,0,0,\n            0,cos(angle),-sin(angle),0,\n            0,sin(angle),cos(angle),0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 rotateY(vec3 p,float angle){\n    return vec3(mat4(\n            cos(angle),0,sin(angle),0,\n            0,1,0,0,\n            -sin(angle),0,cos(angle),0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 rotateZ(vec3 p,float angle){\n    return vec3(mat4(\n            cos(angle),-sin(angle),0,0,\n            sin(angle),cos(angle),0,0,\n            0,0,1,0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 repeat(in vec3 p,in vec3 c){\n    return mod(p+.5*c,c)-.5*c;\n}\n\nvec3 twist(in vec3 p,float k){\n    float c=cos(k*p.y);\n    float s=sin(k*p.y);\n    mat2 m=mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 cheapBend(in vec3 p,float k){\n    float c=cos(k*p.x);\n    float s=sin(k*p.x);\n    mat2 m=mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 cameraTransform(vec3 p) {\n    return rotateY(rotateX(p,.3+sin(iTime*.2)*.4), iTime*0.2);\n}\n\nfloat grimace(in vec3 p) {\n    return opSmoothUnion(\n        sdRoundBox(cheapBend(p,sin(iTime*3.)),vec3(1.1,.2,.4),.05),\n        sdRoundBox(cheapBend(rotateY(p, 3.141*.5),cos(iTime*3.)),vec3(1.1,.2,.4),.05),\n        .4\n    );\n}\n\nfloat displace(in vec3 p) {\n    return sin(5.*p.x+iTime)*sin(5.*p.y+iTime*.9)*sin(5.*p.z+iTime*.8)*.1;\n}\n\nfloat sceneSDF2(in vec3 p){\n    return sdSphere(p, .6 + sin(iTime*.1)*.7);\n}\n\n\nfloat sceneSDF(in vec3 p){\n    return opSmoothUnion(opSmoothIntersection(grimace(p), sceneSDF2(p), .1), opSmoothSubtraction(\n\t\topSmoothUnion(\n        \topSmoothUnion(\n            \tsdCylinder(p, vec3(0,0,.5)),\n            \tsdCylinder(rotateZ(p, PI*.5), vec3(0,0,.5)),\n                .03\n        \t),\n        \tsdCylinder(rotateX(p, PI*.5), vec3(0,0,.5)),\n            .03\n    \t),\n    \topSmoothIntersection(\n    \t\tsdSphere(p, 1.),\n        \tsdBox(p, vec3(.75)),\n            .05\n    \t),.05\n    ),.5);\n}\n\nfloat march(in vec3 ro,in vec3 rd){\n    float depth=MIN_DIST;\n    int cost=MAX_MARCHING_STEPS;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        float dist=sceneSDF(ro+depth*rd);\n        if(dist<EPSILON){\n            cost=i;\n            break;\n        }\n        depth+=dist;\n        if(depth>=MAX_DIST){\n            cost=i;\n            depth=MAX_DIST;\n            break;\n        }\n    }\n    return depth;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float h = 0.0002; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h ) + \n                      k.yyx*sceneSDF( p + k.yyx*h ) + \n                      k.yxy*sceneSDF( p + k.yxy*h ) + \n                      k.xxx*sceneSDF( p + k.xxx*h ) );\n}\n\n\nvec4 normalColor( in vec3 pos)\n{\n\treturn vec4(calcNormal(pos)*0.5+0.5, 4.);    \t\n}\n\nvec4 aoColor(in vec3 pos, in vec3 rd) {\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd,nor);\n\n    float outer = march(pos, ref);\n    vec3 reflection = texture( iChannel0, ref ).xyz * clamp(outer-3.,0.,.5);\n    vec3 ambient = texture( iChannel1, ref ).xyz * clamp(outer-1.,.5,.1);\n\n    vec3 n = normalize(pos);\n\tvec2 uv = vec2( atan( n.z, n.x ), asin(n.y) );\n    \n    vec3 col = (texture( iChannel2, uv ).xyz) * clamp(march(pos, normalize(vec3(.1, 2., .2))), .2, 2.);\n\treturn vec4(ambient *col + reflection,60.);\n}\n\n\n\nvec4 render(in vec3 ro,in vec3 rd){\n    float depth=march(ro, rd);\n    if(depth>MAX_DIST-EPSILON){\n        return texture( iChannel0, rd);\n    }\n    return aoColor(ro + rd * depth, rd);\n    \n}\n\nvec3 rayDirection(float fieldOfView,vec2 size,vec2 fragCoord){\n    vec2 xy=fragCoord-size/2.;\n    float z=size.y/tan(radians(fieldOfView)/2.);\n    return normalize(vec3(xy,-z));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    fragColor=render(\n        cameraTransform(vec3(1.,0.,5.)),// ray origin\n        cameraTransform(rayDirection(60.,iResolution.xy,fragCoord))\n    );\n}\n\nvoid mainVR(out vec4 fragColor,in vec2 fragCoord,in vec3 fragRayOri,in vec3 fragRayDir)\n{\n    fragColor=render(\n        fragRayOri+vec3(3.,1.,4.),\n    fragRayDir);\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 242, 242, 268], [270, 270, 298, 298, 381], [383, 383, 424, 424, 509], [511, 511, 560, 560, 612], [614, 614, 661, 661, 765], [767, 767, 803, 803, 837], [840, 840, 873, 873, 892], [894, 894, 933, 933, 953], [955, 955, 995, 995, 1014], [1016, 1016, 1063, 1063, 1138], [1140, 1140, 1193, 1193, 1269], [1271, 1271, 1325, 1325, 1400], [1402, 1402, 1435, 1435, 1605], [1607, 1607, 1640, 1640, 1811], [1813, 1813, 1846, 1846, 2017], [2019, 2019, 2052, 2052, 2085], [2087, 2087, 2117, 2117, 2223], [2225, 2225, 2259, 2259, 2365], [2367, 2367, 2397, 2397, 2462], [2464, 2464, 2490, 2490, 2691], [2693, 2693, 2720, 2720, 2797], [2799, 2799, 2826, 2826, 2875], [2878, 2878, 2904, 2904, 3373], [3375, 3375, 3410, 3410, 3782], [3784, 3784, 3812, 3812, 4128], [4131, 4131, 4163, 4163, 4213], [4215, 4215, 4254, 4254, 4739], [4743, 4743, 4778, 4778, 4935], [4937, 4937, 4999, 4999, 5116], [5118, 5118, 5171, 5171, 5324], [5326, 5326, 5415, 5415, 5491]], "test": "untested"}
{"id": "3dXfD2", "name": "Planetary SPH", "author": "michael0884", "description": "Using the equation of state for water!\nif you have the plugin:\nuse acceleration 4x", "tags": ["simulation", "interactive", "fluid", "particles", "sph"], "likes": 34, "viewed": 977, "published": 3, "date": "1589057322", "time_retrieved": "2024-07-30T21:07:39.395457", "image_code": "// Fork of \"Super SPH \" by michael0884. https://shadertoy.com/view/tdXBRf\n// 2020-05-09 15:47:15\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale+2.).rgb;\n    \n    return bloom;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n     vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.4 * R.y, pos) * .07;\n    bloomSum += bloom(.2 * R.y, pos) * .07;\n    \n    fragColor.xyz = texel(ch2, pi).xyz + 1.*bloomSum;\n    fragColor.xyz = ACESFilm(fragColor.xyz);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define dt 2.\n#define loop(i,x) for(int i = min(0, iFrame); i < x; i++)\n\n//rendering scale\n#define SC 0.8\n\n#define smoothR 2.5\n#define density 0.05\n\n//sim stuff\nstruct obj\n{\n    int id; //ID\n    vec2 X; //position\n    vec2 V; //velocity\n    float Pressure; //pressure\n    float Rho; //neighbor density\n    float SScale; //smooth scale\n    float Scale; //average distance to neighbors\n    vec4 Y; //additional data\n};\n    \nfloat Force(float d)\n{\n    return 0.2*exp(-0.05*d)-2.*exp(-0.5*d);\n}\n\n//40% of the buffer used for particles\n#define P 0.5\n#define SN ivec2(4, 2)\n\nivec2 N; //buffer size\nivec2 sN; //buffer single element size\nint TN; //buffer length\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sqr(float x)\n{\nreturn x*x + 1e-2;\n}\n\n//hash funcs\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}", "buffer_a_code": "//L1 particle buffer - simulation\n//L2 directional neighbor graph 4x - sort\n\nint ID;\nobj O; //this object\n\n//sort arrays\nvec4 lnk0, lnk1;\nvec4 d0, d1;\n\n//L3\nvec4 EA[SN.x]; //element array\n\nvoid insertion_sort(float t, int id);\nobj getObj(int id); vec4 saveObj(int i);\nbool iscoincidenceEA(int id);\nvoid sort0(int idtemp, int D); void sort1(int idtemp, int D);\n\nfloat Kernel(float d, float h)\n{\n    return exp(-sqr(d/h))/(PI*sqr(h));\n}\n\nfloat KernelGrad(float d, float h)\n{\n    return 2.*d*Kernel(d,h)/sqr(h);\n}\n\nvec2 borderF(vec2 p)\n{\n    \n    float d = min(min(p.x,p.y),min(R.x-p.x,R.y-p.y));\n    return exp(-max(d,0.)*max(d,0.))*((d==p.x)?vec2(1,0):(\n    \t\t(d==p.y)?vec2(0,1):(\n            (d==R.x-p.x)?vec2(-1,0):vec2(0,-1))));\n}\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    //4 pix per layer, 3 layers\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    int S = 3; //log2(sN.x)\n    \n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    O = getObj(ID);\n    d0 = vec4(1e6); d1 = vec4(1e6);\n    lnk0 = vec4(-1); lnk1 = vec4(-1);\n    \n    switch(sid.z)\n    {\n    case 0: //particle\n        if(sid.z >= 3) discard;\n        float sk = 0.;\n        \n        //scale /=sk;\n        vec2 F =-0.001*(O.X - R*0.5)/(pow(length(O.X - R*0.5),1.)+1.); \n        vec2 Fp = vec2(0);\n        float avgP = 0.;\n     \n         float scale = 0.21/density; //radius of smoothing\n        float Div = 0.;\n        float Rho = Kernel(0., scale);\n           vec2 avgV = vec2(O.V)*Rho;\n        vec3 avgCol = vec3(O.Y.xyz);\n        float Gsum = 1.;\n        float curscale = 1e10;\n        float avgSc = 0.;\n        \n        loop(j,4)\n        {\n            vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n            loop(i,4)\n            {\n                if(nb[i] < 0. || nb[i] > float(TN)) continue;\n                obj nbO = getObj(int(nb[i]));\n                \n               \n                float d = distance(O.X, nbO.X);\n                vec2 dv = (nbO.V - O.V); //delta velocity\n                vec2 dx = (nbO.X - O.X); //delta position \n                vec2 ndir = dx/(d+0.001); //neighbor direction\n                //SPH smoothing kernel\n                float K = Kernel(d, scale);\n                float dK = KernelGrad(d, scale);\n               \n                //Gkernel\n                float G = 1./(d*d+0.01);\n                float dotv = dot(ndir, dv); //divergence\n                vec2 pressure = -0.5*(nbO.Pressure/sqr(nbO.Rho) + \n                                    O.Pressure/sqr(O.Rho))*ndir*K;//pressure gradient\n                curscale = min(curscale, d);\n                Gsum += 1.;\n                Div += dotv*K; // local divergence\n                Rho += K;\n                avgCol += nbO.Y.xyz;\n                avgP += nbO.Pressure*K;\n                avgV += nbO.V*K;\n                \n                F += pressure + 3.*ndir*dotv*K    \n                    + 0.00*ndir*exp(-0.05*density*d)*(1.-K); //surfacce tension\n                Fp += ndir*(-exp(-smoothR*d/scale));\n            }\n        }\n        \n         //border conditions\n        \n        /*Fp += 0.5*borderF(O.X);\n        F += 0.1*borderF(O.X);\n       \n        vec2 bdf = borderF(O.X);\n        O.V -= 0.05*length(bdf)*O.V;\n        \n        if(R.x - O.X.x < 2.) O.V.x = -abs(O.V.x);\n        if(O.X.x < 2.) O.V.x = abs(O.V.x);\n        if(R.y - O.X.y < 2.) O.V.y = -abs(O.V.y);\n        if(O.X.y < 2.) O.V.y = abs(O.V.y);*/\n        \n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, O.X);\n            O.Y.xyz += 3.*(0.5+0.5*sin(vec3(1,2,3)*iTime))/(0.2*d*d+2.);\n            F += 0.01*(iMouse.xy - iMouse.zw)/(0.2*d*d+2.);\n        }\n        \n        O.Rho = Rho;\n        O.Scale = curscale; //average distance\n        O.SScale = avgSc/Gsum; //average average distance\n        \n        float r = 7.;\n        float D = 1.;\n        float waterP = 0.05*density*(pow(abs(O.Rho/density), r) - D);\n        float gasP = 0.4*O.Rho;\n        O.Pressure = min(waterP,0.03);\n        if(iFrame > 20) O.Pressure += 0.*(avgP/O.Rho - O.Pressure);\n        \n        \n        O.V += F*dt;\n        O.V -= O.V*(0.5*tanh(8.*(length(O.V)-1.5))+0.5);\n        O.X += (O.V)*dt; //advect\n        \n        \n        \n        \n        \n        //color diffusion\n        \n        O.Y.xyz = 0.999*mix(avgCol/Gsum, O.Y.xyz,0.9995)\n        + 0.05*(exp(-0.1*distance(O.X,R*0.3))*sin(vec3(1,2,3)*iTime)\n             + exp(-0.1*distance(O.X,R*0.7))*sin(vec3(2,3,1)*iTime));\n        \n        \n        \n        if(iFrame<10)\n        {\n            O.X = R*vec2(i2xy(ivec3(ID,0,0)))/vec2(N*sN);\n            O.X += 0.*sin(10.*O.X.x/R.x)*sin(10.*O.X.y/R.y);\n\t\t\tO.V = 0.*(hash22(3.14159*pos) - 0.5);\n            O.Y = 0.*texture(ch1,O.X/R);\n            O.Pressure = 0.;\n            O.Scale = 5.;\n            O.Rho = 5.;\n            O.SScale = 1.;\n        }\n\n        Q = saveObj(sid.y);\n        return;\n        \n    case 1: //dir graph\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        loop(i,4)\n        {\n            sort0(int(nb0[i]), sid.y);  //sort this\n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = texel(ch0, i2xy(ivec3(nb0[i], (iFrame+ID)%4, 1)));\n            loop(j,2)\n            {\n                sort0(int(nb1[j]), sid.y);  \n            }\n        }\n        \n        //random sorts\n        loop(i,4) sort0(int(float(TN)*hash13(vec3(iFrame, ID, i))), sid.y);\n        \n        Q = lnk0;\n        return;\n    }\n     \n}\n\nvec4 saveObj(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(O.X, O.V);\n    case 1:\n        return vec4(O.Pressure, O.Rho, O.SScale, O.Scale);\n    case 2:\n        return O.Y;\n    case 3:\n        return vec4(0.);\n    }\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    \n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.Pressure = a.x;\n    o.Rho = a.y;\n    o.SScale = a.z;\n    o.Scale = a.w;\n    \n    o.Y = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid insertion_sort(float t, int id)\n{\n\tif(d0.x > t)\n    {\n        d0 = vec4(t, d0.xyz);\n        lnk0 = vec4(id, lnk0.xyz);\n    }else if(d0.y > t && d0.x < t)\n    {\n        d0.yzw = vec3(t, d0.yz);\n        lnk0.yzw = vec3(id, lnk0.yz);\n    }else if(d0.z > t&& d0.y < t)\n    {\n        d0.zw = vec2(t, d0.z);\n        lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t && d0.z < t)\n    {\n        d0.w = t;\n        lnk0.w = float(id);\n    }\n}\n\nbool iscoincidence(int id)\n{\n    return (id < 0) || \n      \t\t(id == ID) ||\n           any(equal(lnk0,vec4(id)));\n}\n\nvoid sort0(int idtemp, int D) //sort closest objects in sN.x directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec2 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xy; \n   \n    vec2 dx = nbX - O.X;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n    \n    if(dir != D) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//voronoi particle tracking + graph augmented\n\nvec2 sc(vec2 p)\n{\n    return SC*(p - 0.5*R) + 0.5*R;\n}\n\nfloat d;\nint id;\nvec2 p;\n\nfloat particleDistance(int i)\n{\n    return distance(p, sc(texel(ch0, i2xy(ivec3(i, 0, 0))).xy));\n}\n\nvoid sort(int utemp)\n{\n    if(utemp < 0) return; \n   \tfloat dtemp = particleDistance(utemp);\n    if(dtemp < d) //sorting\n    {\n        d = dtemp;\n        id = utemp;\n    }\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    d = 1e10;\n    id = 1;\n    p = pos;\n    ivec2 pi = ivec2(floor(pos));\n    \n    sort(1+0*int(texel(ch1, pi).x));\n    \n    int ID = id;\n    loop(j,8)\n    {\n        \n        int nbid = int(texel(ch1, pi+cross_distribution(j)).x);\n        sort(nbid);\n    }\n    \n    loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,4)\n    \t{ \n            sort(int(nb[i]));  //sort this\n        }\n    }\n    \n    loop(i,4) //random sort\n    {\n        sort(int(float(TN)*hash13(vec3(iFrame, pi.x, pi.y*i))));\n    }\n    \n   \tQ = vec4(id, d, 0, 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec2 sc(vec2 p)\n{\n    return SC*(p - 0.5*R) + 0.5*R;\n}\n\n// iq's smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    \n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.Pressure = a.x;\n    o.Rho = a.y;\n    o.SScale = a.z;\n    o.Scale = a.w;\n    \n    o.Y = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    int ID = int(texel(ch1, pi).x); \n    obj O = getObj(ID);\n    float d =distance(pos, sc(O.X));\n    float d1 = float(d < 0.2/density);\n    float d2 = 10.*O.Y.x;\n   \n    /*loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,4)\n    \t{\n            if(nb[i] < 0.) continue;\n            vec2 nbX = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xy; \n        \td1 += exp(-0.5*distance(pos, sc(nbX)));\n    \t}\n    }*/\n    d1*=1.;\n    // Output to screen\n \tvec3 pcol = texel(ch2, pi).xyz;\n    vec3 ncol = d1*O.Y.xyz+0.02*d1*hsv2rgb(vec3(atan(O.V.x,O.V.y)/PI, 2.*length(O.V),20.*length(O.V)));\n    fragColor = vec4(mix(pcol,ncol,0.05),1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 121, 121, 261], [386, 386, 426, 426, 720], [723, 723, 774, 774, 1099]], "test": "untested"}
{"id": "3dfBWj", "name": "laser show", "author": "unnick", "description": "i recently learned about an algorithm for solving pdes, and after playing around a bit with it i made this. (more info in the code comment)", "tags": ["2d", "montecarlo", "laser", "pde", "wos"], "likes": 8, "viewed": 738, "published": 3, "date": "1589050283", "time_retrieved": "2024-07-30T21:07:40.160411", "image_code": "/* i first learned about this algorithm from this shader:\n * https://www.shadertoy.com/view/WsXBzl\n *\n * the algorithm works by basically\n * doing a bunch of random walks\n * and walking until it hits a laser\n * or one of the sides of the buffer,\n * and then it averages the results of these walks.\n *\n * random walks are very slow though, so how can this run\n * at 60 fps (!) on my geforce gt 610? (which was released in 2012!)\n *\n * the answer is simple, it uses an sdf to speed things up!\n * a random walk is equally likely to hit any point\n * of a sphere, so we can skip a bunch of unnecessary steps\n * by just picking a random point on a sphere\n *\n * the method i described above solves the laplace equation,\n * but it can be generalized to solve a lot of other pdes.\n * but if you want to know how that works, go read the original paper :^)\n *\n * http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n * \"Monte Carlo Geometry Processing: A Grid-Free Approach to PDE-Based Methods on Volumetric Domains\"\n * by rohan sawhney and keenan crane\n */\n\n//buffer A: boundary conditions & sdf\n//          xyz = color, w = sdf\n//buffer B: solver (the output is split into 4 quadrants)\n//          xyz = color, w = # of sucessful samples\n//buffer C: merging & smoothing\n//          xyz = color, w = 1\n//this buffer: applying symmetries + displaying\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y;\n    #ifdef symmetric\n    pos = abs(pos);\n    if(pos.y > pos.x) pos.yx = pos.xy;\n    #endif\n    col = texture(iChannel0, (pos * vec2(res.y/res.x, 1.) + 1.) * .5);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float linesdf(vec2 p, vec2 start, vec2 dir) {\n    vec2 p2 = p - start;\n    float h = clamp(dot(p2, dir) / dot(dir, dir), 0., 1.);\n    return length(p2 - h*dir);\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y;\n    \n    col.w = bignum; col.xyz = vec3(0);\n    col.w = min(col.w, (        coord.x) / res.y);\n    col.w = min(col.w, (res.x - coord.x) / res.y);\n    col.w = min(col.w, (        coord.y) / res.y);\n    col.w = min(col.w, (res.y - coord.y) / res.y);\n    \n    /*#ifdef symmetric\n    pos = abs(pos);\n    if(pos.y > pos.x) pos.yx = pos.xy;\n    #endif*/\n    #ifdef symmetric\n    if(pos.y > pos.x + eps) discard;\n    if(pos.y < 0.) discard;\n    #endif\n    \n    int lrng = hash(int(iTime * laser_chspeed + laser_choffs));\n    int crng = hash(int(iTime * color_chspeed) ^ 0x80000000);\n    int frng = hash(int(iFrame) ^ 0xC0000000);\n    for(int i = 0; i < laser_num; i++) {\n        float tmp = rand1f(lrng) * tau;\n        float rot = (float(rand(lrng) >> 30) * 2. - 1.) * laser_speed;\n        float fft_ch = rand1f(lrng);\n        float amp = pow(texture(iChannel0, vec2(fft_ch,0)).x, fft_adjust);\n        \n        #ifdef symmetric\n        vec2 start = rand2f(lrng);\n        #else\n        vec2 start = (rand2f(lrng) * 2. - 1.) * vec2(res.x/res.y, 1.);\n        #endif\n        \n        vec2 dir = cossin(tmp + iTime * rot) * mix(amp*fft_laser_len, laser_base_len, fft_baselen_mix);\n        \n        vec3 lcol  = vec3(rand2f(crng), 1).xzy;\n        lcol *= laser_brightness + amp * fft_brightness_factor;\n        \n        float ldist = linesdf(pos, start, dir) - eps;\n        if(ldist < col.w) {\n            col.w = ldist;\n            col.xyz = lcol;\n        }\n    }\n    \n    col.w *= .95;\n    col.w -= eps;\n}\n", "buffer_a_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//constants\n\n#define tau 6.283\n#define res iResolution.xy\n#define ires ivec2(res)\n#define eps (1.5/res.y)\n#define bignum 1e4\n\n\n\n//parameters\n\n#define symmetric\n#define laser_num 32\n\n#define laser_brightness .5\n\n//laser beam rotation rate\n//lower = slower\n#define laser_speed 5.\n\n//speed of light decay\n//lower = faster\n#define laser_decay -15.\n\n//color & laser pos change rate\n//lower = slower\n#define color_chspeed 2.5\n#define laser_chspeed (color_chspeed / 8.)\n//change offset\n#define laser_choffs (-1./16.)\n\n#define fft_adjust 3.\n#define fft_brightness_factor 2.\n#define fft_laser_len 2.\n#define laser_base_len .3\n#define fft_baselen_mix .3\n\n//lower = better quality, but slightly slower\n#define render_darkness_cutoff -2.\n\n#define render_samples 16\n#define render_max_steps 32\n\n#define render_block_offs 2\n#define render_block_size 5\n\n\n\n//functions\n\n#define unsplitFetch(ch, pos) texelFetch(ch, ((pos) >> 1) + ((pos) & 1) * (ires >> 1), 0)\n\nvec2 cossin(float a) {\n    return vec2(cos(a), sin(a));\n}\n\nint hash(int x) {\n    x ^= 0x4AB10B90;\n    x *= 0x5F02BC5D;\n    x ^= x >> 16;\n    x *= 0xE3105FD3;\n    x ^= x >> 16;\n    return x;\n}\n\nint hash4(ivec4 v) {\n    return hash(v.x ^ hash(v.y) ^ hash(v.z ^ hash(v.w)));\n}\n\nint rand(inout int x) {\n    x *= 0xB315C74D;\n    x += 0x7B1922B9;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand1f(inout int x) {\n    return (float(rand(x) >> 7) + .5) / 16777216.;\n}\n\nvec2 rand2f(inout int x) {\n    vec2 vec;\n    vec.x = rand1f(x);\n    vec.y = rand1f(x);\n    return vec;\n}\n\nvec3 rand3f(inout int x) {\n    vec3 vec;\n    vec.x = rand1f(x);\n    vec.y = rand1f(x);\n    vec.z = rand1f(x);\n    return vec;\n}\n", "buffer_b_code": "vec4 sdf(vec2 p) {\n    #ifdef symmetric\n    p = abs(p);\n    if(p.y > p.x) p.yx = p.xy;\n    #endif\n    return texture(iChannel0, (p * vec2(res.y/res.x, 1.) + 1.) / 2.);\n}\n\n/*vec4 sdf(vec2 p) {\n    vec4 col;\n    col.x = normalize(p).x * .5 + .5;\n    col.yz = vec2(sin(sin(sin(p*tau)*tau)*tau));\n    //col.xyz = vec3(1);\n    col.w = length(p) - .5;\n    float dist = 10000.;\n    dist = min(dist, p.y + 1.);\n    dist = min(dist, 1. - p.y);\n    dist = min(dist, p.x + res.x/res.y);\n    dist = min(dist, res.x/res.y - p.x);\n    col.w = min(col.w, dist);\n    if(dist < .01) col.xyz = vec3(0);\n    return col;\n}*/\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    ivec2 ipos = ivec2(coord);\n    ivec2 shuffled;\n    shuffled.x = (ipos.x<<1) % ires.x + ((ires.x & 1) ^ 1) * (ipos.x > (ires.x>>1) ? 1 : 0);\n    shuffled.y = (ipos.y<<1) % ires.y + ((ires.y & 1) ^ 1) * (ipos.y > (ires.y>>1) ? 1 : 0);\n    \n    vec2 pos = (vec2(shuffled) * 2. + 1. - res) / res.y;\n    #ifdef symmetric\n    if(shuffled.y - (ires.y >> 1) > shuffled.x - (ires.x >> 1) + 1) discard;\n    if(shuffled.y - (ires.y >> 1) < 0) discard;\n    #endif\n    \n    col = vec4(0,0,0,.01); // xyz = color, w = sample count\n    for(int samp = 0; samp < render_samples; samp++) {\n        int rng = hash4(ivec4(\n            iFrame,\n            (ivec2(coord) + samp * render_block_offs) >> render_block_size,\n            samp\n        ));\n        vec2 p = pos; float lmul = 0.;\n        for(int i = 0; i < render_max_steps; i++) {\n            vec4 val = sdf(p);\n            float dist = val.w;\n            if(dist < eps) {\n                col += vec4(val.xyz * exp(lmul), 1);\n                break;\n            }\n            if(lmul < render_darkness_cutoff) {\n                col += vec4(0,0,0, 1);\n                break;\n            }\n            p += dist * cossin(rand1f(rng) * tau);\n            lmul += dist*dist * laser_decay;\n            //add += dist*dist;\n        }\n    }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//smoothing\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    ivec2 ipos = ivec2(coord);\n    #ifdef symmetric\n    if(ipos.y - (ires.y >> 1) > ipos.x - (ires.x >> 1) + 1) discard;\n    if(ipos.y - (ires.y >> 1) < 0) discard;\n    #endif\n    \n    col  = unsplitFetch(iChannel0, ipos + ivec2(0,0));\n    col += unsplitFetch(iChannel0, ipos + ivec2(1,0));\n    col += unsplitFetch(iChannel0, ipos + ivec2(0,1));\n    col += unsplitFetch(iChannel0, ipos + ivec2(1,1));\n    col /= col.w;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1368, 1368, 1413, 1413, 1620]], "test": "untested"}
{"id": "3sfBW2", "name": "color shift video", "author": "FabriceNeyret2", "description": ".", "tags": ["video", "color"], "likes": 4, "viewed": 416, "published": 3, "date": "1589045885", "time_retrieved": "2024-07-30T21:07:41.184673", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = texture(iChannel0, U/iResolution.xy);\n    float l = length(O.rgb+1e-5);                  // luminance\n    vec4  C = acos(O/l*2.-1.);                     // color phases\n    \n    O = .5 + .5*l* cos(iTime + C);                 // offset and recompose\n  //O = l * ( .5 + .5* cos(iTime + C) );           // more logic, but get dark\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 376]], "test": "untested"}
{"id": "3sffDj", "name": "tangents (epilepsy warning)", "author": "gurudevbk", "description": "fullscreen for best results....results vary on diff monitors and diff resolution (restart if pattern converges, considering you actually watched for that long)", "tags": ["tangent"], "likes": 1, "viewed": 353, "published": 3, "date": "1589043518", "time_retrieved": "2024-07-30T21:07:42.305675", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float thickness = 0.1;\n    float t_usec = (iTime+70.) * .0001;\n    vec2 origin = vec2(.4)+t_usec;\n    const float pi = 3.14159265;\n    \n    // rotation matrix for funzies\n   \t\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - 0.5;\n    uv.x -= .29;\n    \n    \n    //uv = mat2(sin(t_usec), cos(t_usec), sin(t_usec), -cos(t_usec)) * uv;\n    float radius = .5*atan(uv.x*uv.y,pow(t_usec,3.))/pow(sin(t_usec),2.4);\n    \n    vec3 col = vec3(t_usec+.1, .5*(cos(iTime)*.5+.5),.5); //color \n    vec3 color_scale = length(uv-radius)*col.rgb;\n    \n    col.rgb = 0.5*sin(length(uv*radius)+col.rgb);\n    \n    col *= length(uv*origin)*color_scale;\n    \n    // Time varying pixel color\n  \t//col += 0.4*cos(iTime)+col;\n   \tcol.g += sin(iTime*.02);\n    col.r -= .2*cos(iTime*.02);\n    col.g += pow(sin(iTime*.2),2.);\n\n\n    col.g += atan(sin(iTime),abs(cos(iTime)));\n    \n    col.rgb += mix(col.rbg, col.bgr, length(uv-origin)/2.);\n    \n   // col.g *= 0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.-length(uv-origin));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sffDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1124]], "test": "untested"}
{"id": "WdffDj", "name": "Audio Glitch Blobs", "author": "itgaz", "description": "Playing around making an audio visualiser thing", "tags": ["audio", "glitch"], "likes": 4, "viewed": 564, "published": 3, "date": "1589042223", "time_retrieved": "2024-07-30T21:07:43.092571", "image_code": "\nvec2 rotate(vec2 v, float a, vec2 origin) {\n    v = v - origin;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn (m * v) + origin;\n}\n\nfloat circleDistance( in vec2 origin, float r, in vec2 p ) {\n  float dis = distance(origin, p);\n  return dis < r ? 1.0 : dis;\n}\n\nbool circle( in vec2 origin, float r, in vec2 p ) {\n  return distance(origin, p) < r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // read frequency info (for le bass)\n    vec4 bassFFT1 = texture( iChannel0, vec2(0.05, 0.25) );\n    vec4 bassFFT2 = texture( iChannel0, vec2(0.10, 0.25) );\n    vec4 bassFFT3 = texture( iChannel0, vec2(0.15 , 0.25) );\n    \n\t// Mirror\n    uv = uv.x > 0.5 ? vec2(1.0 - uv.x, uv.y) : uv.xy;\n    \n    // Rotate around the center\n    uv = rotate(uv,(2.0 * sin(iTime * 0.5)) + (bassFFT1.x), vec2(0.0, 0.0));\n    \n    // Mirror again <3\n    uv = uv.y > 0.5 ? vec2(uv.x, 1.0 - uv.y) : uv.xy;\n    \n    // Zoom/Repeat effect\n    uv = fract(uv + cos(iTime / 8.0) + ((bassFFT2.x * bassFFT1.x) / 2.0));\n    \n    // read frequency data from texture\n    vec4 fft = texture( iChannel0, vec2(uv.x, uv.y) );\n    \n    vec3 targetColour = vec3(fft.x * sin(sqrt(uv.y)), fft.x * cos(iTime), fft.x * sin(iTime * 4.0));\n    \n    vec3 baseColour = vec3(1.0) - targetColour; //vec3(0.0, 0.0, 0.0);\n    \n    vec3 col = mix(baseColour, targetColour, sqrt(uv.y));\n    \n    float stencil = circleDistance( vec2(0.3, 0.3), 0.1 * bassFFT2.x + fft.x * 0.1, uv.xy ) +\n                    circleDistance( vec2(0.7, 0.3), 0.1 * bassFFT2.x + fft.x * 0.1, uv.xy ) +\n        \t\t\tcircleDistance( vec2(0.3, 0.7), 0.1 * bassFFT2.x + fft.x * 0.1, uv.xy ) +\n        \t\t\tcircleDistance( vec2(0.7, 0.7), 0.1 * bassFFT2.x + fft.x * 0.1, uv.xy )\n        \t\t\t/ 4.0;\n    \n    vec3 backgroundColour = vec3(0.0, 0.0, 0.0);\n    // vec3 backgroundColour = vec3(0.8) - targetColour;\n    col = mix(backgroundColour, col, stencil);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n \n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdffDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 44, 44, 159], [161, 161, 221, 221, 288], [290, 290, 341, 341, 377], [379, 379, 436, 486, 2071]], "test": "untested"}
{"id": "3dffDj", "name": "Strobo-filter", "author": "avin", "description": "epiteptic igniter", "tags": ["filter", "strobo", "stroboscope", "epiteptic"], "likes": 5, "viewed": 485, "published": 3, "date": "1589041880", "time_retrieved": "2024-07-30T21:07:43.934321", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n           \n    vec3 col = texture(iChannel0, uv).xyz;      \n    \n    float colM = (col.r+col.g+col.b)*.33;\n    \n    colM = step(.5, fract(iTime*(10.) + colM));\n    \n    fragColor = vec4(colM);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dffDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 297]], "test": "untested"}
{"id": "WdfBDj", "name": "Water-Gas phase transition SPH ", "author": "michael0884", "description": "Finally implemented a proper SPH fluid\nif you have the plugin:\nuse acceleration 4x", "tags": ["fluid", "particles"], "likes": 24, "viewed": 788, "published": 3, "date": "1589039313", "time_retrieved": "2024-07-30T21:07:45.031388", "image_code": "// Fork of \"Super SPH \" by michael0884. https://shadertoy.com/view/tdXBRf\n// 2020-05-09 15:47:15\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    fragColor = texel(ch2, pi);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define dt 3.\n#define loop(i,x) for(int i = min(0, iFrame); i < x; i++)\n\n//rendering scale\n#define SC 1.\n\n#define smoothR 2.5\n#define density 0.05\n\n//sim stuff\nstruct obj\n{\n    int id; //ID\n    vec2 X; //position\n    vec2 V; //velocity\n    float Pressure; //pressure\n    float Rho; //neighbor density\n    float SScale; //smooth scale\n    float Scale; //average distance to neighbors\n    vec4 Y; //additional data\n};\n    \nfloat Force(float d)\n{\n    return 0.2*exp(-0.05*d)-2.*exp(-0.5*d);\n}\n\n//40% of the buffer used for particles\n#define P 0.5\n#define SN ivec2(4, 2)\n\nivec2 N; //buffer size\nivec2 sN; //buffer single element size\nint TN; //buffer length\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sqr(float x)\n{\nreturn x*x + 1e-2;\n}\n\n//hash funcs\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}", "buffer_a_code": "//L1 particle buffer - simulation\n//L2 directional neighbor graph 4x - sort\n\nint ID;\nobj O; //this object\n\n//sort arrays\nvec4 lnk0, lnk1;\nvec4 d0, d1;\n\n//L3\nvec4 EA[SN.x]; //element array\n\nvoid insertion_sort(float t, int id);\nobj getObj(int id); vec4 saveObj(int i);\nbool iscoincidenceEA(int id);\nvoid sort0(int idtemp, int D); void sort1(int idtemp, int D);\n\nfloat Kernel(float d, float h)\n{\n    return exp(-sqr(d/h))/(PI*sqr(h));\n}\n\nfloat KernelGrad(float d, float h)\n{\n    return 2.*d*Kernel(d,h)/sqr(h);\n}\n\nvec2 borderF(vec2 p)\n{\n    \n    float d = min(min(p.x,p.y),min(R.x-p.x,R.y-p.y));\n    return exp(-max(d,0.)*max(d,0.))*((d==p.x)?vec2(1,0):(\n    \t\t(d==p.y)?vec2(0,1):(\n            (d==R.x-p.x)?vec2(-1,0):vec2(0,-1))));\n}\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    //4 pix per layer, 3 layers\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    int S = 3; //log2(sN.x)\n    \n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    O = getObj(ID);\n    d0 = vec4(1e6); d1 = vec4(1e6);\n    lnk0 = vec4(-1); lnk1 = vec4(-1);\n    \n    switch(sid.z)\n    {\n    case 0: //particle\n        if(sid.z >= 3) discard;\n        float sk = 0.;\n        \n        //scale /=sk;\n        vec2 F =5e-4*vec2(0.,-1.);//-0.001*(O.X - R*0.5)/(pow(length(O.X - R*0.5),1.)+1.); \n        vec2 Fp = vec2(0);\n        float avgP = 0.;\n     \n         float scale = 0.21/density; //radius of smoothing\n        float Div = 0.;\n        float Rho = Kernel(0., scale);\n           vec2 avgV = vec2(O.V)*Rho;\n        vec3 avgCol = vec3(O.Y.xyz);\n        float Gsum = 1.;\n        float curscale = 1e10;\n        float avgSc = 0.;\n        \n        loop(j,4)\n        {\n            vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n            loop(i,4)\n            {\n                if(nb[i] < 0. || nb[i] > float(TN)) continue;\n                obj nbO = getObj(int(nb[i]));\n                \n               \n                float d = distance(O.X, nbO.X);\n                vec2 dv = (nbO.V - O.V); //delta velocity\n                vec2 dx = (nbO.X - O.X); //delta position \n                vec2 ndir = dx/(d+0.001); //neighbor direction\n                //SPH smoothing kernel\n                float K = Kernel(d, scale);\n                float dK = KernelGrad(d, scale);\n               \n                //Gkernel\n                float G = 1./(d*d+0.01);\n                float dotv = dot(ndir, dv); //divergence\n                vec2 pressure = -(nbO.Pressure/sqr(nbO.Rho) + \n                                    O.Pressure/sqr(O.Rho))*ndir*dK;//pressure gradient\n                curscale = min(curscale, d);\n                Gsum += 1.;\n                Div += dotv*K; // local divergence\n                Rho += K;\n                avgCol += nbO.Y.xyz;\n                avgP += nbO.Pressure*K;\n                avgV += nbO.V*K;\n                \n                F += pressure + 5.*ndir*dotv*K    \n                    + 0.00*ndir*exp(-0.05*density*d)*(1.-K); //surfacce tension\n                Fp += ndir*(-exp(-smoothR*d/scale));\n            }\n        }\n        \n         //border conditions\n        \n        Fp += 0.5*borderF(O.X);\n        F += 0.1*borderF(O.X);\n       \n        vec2 bdf = borderF(O.X);\n        O.V -= 0.05*length(bdf)*O.V;\n        \n        if(R.x - O.X.x < 2.) O.V.x = -abs(O.V.x);\n        if(O.X.x < 2.) O.V.x = abs(O.V.x);\n        if(R.y - O.X.y < 2.) O.V.y = -abs(O.V.y);\n        if(O.X.y < 2.) O.V.y = abs(O.V.y);\n        \n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, O.X);\n            O.Y.xyz +=(0.5+0.5*sin(vec3(1,2,3)*iTime))/(0.2*d*d+2.);\n            F += 0.01*(iMouse.xy - iMouse.zw)/(0.2*d*d+2.);\n        }\n        \n        O.Rho = Rho;\n        O.Scale = curscale; //average distance\n        O.SScale = avgSc/Gsum; //average average distance\n        \n        float r = 7.;\n        float D = 1.;\n        float waterP = 0.03*density*(pow(abs(O.Rho/density), r) - D);\n        float gasP = O.Rho;\n        O.Pressure = mix(gasP, waterP, 0.5*tanh(5.*sin(0.5*iTime))+0.5);\n        if(iFrame > 20) O.Pressure += 0.*(avgP/O.Rho - O.Pressure);\n        \n        \n        O.V += F*dt;\n        O.V -= O.V*(0.5*tanh(8.*(length(O.V)-1.5))+0.5);\n        O.X += (O.V)*dt; //advect\n        \n        \n        \n        \n        \n        //color diffusion\n        \n        O.Y.xyz = 0.995*mix(avgCol/Gsum, O.Y.xyz,0.995)\n        + 0.01*(exp(-0.1*distance(O.X,R*0.3))*(0.5*sin(vec3(1,2,3)*iTime)+0.5)\n             + exp(-0.1*distance(O.X,R*0.7))*(0.5*sin(vec3(2,3,1)*iTime))+0.5);\n        \n        \n        \n        if(iFrame<10)\n        {\n            O.X = R*vec2(i2xy(ivec3(ID,0,0)))/vec2(N*sN);\n            O.X += 0.*sin(10.*O.X.x/R.x)*sin(10.*O.X.y/R.y);\n\t\t\tO.V = 0.*(hash22(3.14159*pos) - 0.5);\n            O.Y = texture(ch1,O.X/R);\n            O.Pressure = 0.;\n            O.Scale = 5.;\n            O.Rho = 5.;\n            O.SScale = 1.;\n        }\n\n        Q = saveObj(sid.y);\n        return;\n        \n    case 1: //dir graph\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        loop(i,4)\n        {\n            sort0(int(nb0[i]), sid.y);  //sort this\n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = texel(ch0, i2xy(ivec3(nb0[i], (iFrame+ID)%4, 1)));\n            loop(j,2)\n            {\n                sort0(int(nb1[j]), sid.y);  \n            }\n        }\n        \n        //random sorts\n        loop(i,4) sort0(int(float(TN)*hash13(vec3(iFrame, ID, i))), sid.y);\n        \n        Q = lnk0;\n        return;\n    }\n     \n}\n\nvec4 saveObj(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(O.X, O.V);\n    case 1:\n        return vec4(O.Pressure, O.Rho, O.SScale, O.Scale);\n    case 2:\n        return O.Y;\n    case 3:\n        return vec4(0.);\n    }\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    \n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.Pressure = a.x;\n    o.Rho = a.y;\n    o.SScale = a.z;\n    o.Scale = a.w;\n    \n    o.Y = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid insertion_sort(float t, int id)\n{\n\tif(d0.x > t)\n    {\n        d0 = vec4(t, d0.xyz);\n        lnk0 = vec4(id, lnk0.xyz);\n    }else if(d0.y > t && d0.x < t)\n    {\n        d0.yzw = vec3(t, d0.yz);\n        lnk0.yzw = vec3(id, lnk0.yz);\n    }else if(d0.z > t&& d0.y < t)\n    {\n        d0.zw = vec2(t, d0.z);\n        lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t && d0.z < t)\n    {\n        d0.w = t;\n        lnk0.w = float(id);\n    }\n}\n\nbool iscoincidence(int id)\n{\n    return (id < 0) || \n      \t\t(id == ID) ||\n           any(equal(lnk0,vec4(id)));\n}\n\nvoid sort0(int idtemp, int D) //sort closest objects in sN.x directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec2 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xy; \n   \n    vec2 dx = nbX - O.X;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n    \n    if(dir != D) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//voronoi particle tracking + graph augmented\n\nvec2 sc(vec2 p)\n{\n    return SC*(p - 0.5*R) + 0.5*R;\n}\n\nfloat d;\nint id;\nvec2 p;\n\nfloat particleDistance(int i)\n{\n    return distance(p, sc(texel(ch0, i2xy(ivec3(i, 0, 0))).xy));\n}\n\nvoid sort(int utemp)\n{\n    if(utemp < 0) return; \n   \tfloat dtemp = particleDistance(utemp);\n    if(dtemp < d) //sorting\n    {\n        d = dtemp;\n        id = utemp;\n    }\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    d = 1e10;\n    id = 1;\n    p = pos;\n    ivec2 pi = ivec2(floor(pos));\n    \n    sort(1+0*int(texel(ch1, pi).x));\n    \n    int ID = id;\n    loop(j,4)\n    {\n        int nbid = int(texel(ch1, pi+cross_distribution(j)).x);\n        sort(nbid);\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        sort(int(nb[0]));  //sort this\n    }\n    \n    loop(i,32) //random sort\n    {\n        sort(int(float(TN)*hash13(vec3(iFrame, pi.x, pi.y*i))));\n    }\n    \n   \tQ = vec4(id, d, 0, 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec2 sc(vec2 p)\n{\n    return SC*(p - 0.5*R) + 0.5*R;\n}\n\n// iq's smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    \n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.Pressure = a.x;\n    o.Rho = a.y;\n    o.SScale = a.z;\n    o.Scale = a.w;\n    \n    o.Y = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    int ID = int(texel(ch1, pi).x); \n    obj O = getObj(ID);\n    float d =distance(pos, sc(O.X));\n    float d1 = exp(-sqr(d/3.)) +  0.*exp(-0.1*d);\n    float d2 = 10.*O.Y.x;\n   \n    /*loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,4)\n    \t{\n            if(nb[i] < 0.) continue;\n            vec2 nbX = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xy; \n        \td1 += exp(-0.5*distance(pos, sc(nbX)));\n    \t}\n    }*/\n    d1*=1.;\n    // Output to screen\n \tvec3 pcol = texel(ch2, pi).xyz;\n    vec3 ncol = 0.*sin(vec3(1,2,3)*d2*0.3) + 0.4*d1 + 0.2*hsv2rgb(vec3(atan(O.V.x,O.V.y)/PI, 2.*length(O.V),20.*length(O.V)))*d1;\n    fragColor = vec4(mix(pcol,ncol,0.4),1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 149, 149, 283]], "test": "untested"}
{"id": "3dfBDj", "name": "really all in Common", "author": "FabriceNeyret2", "description": "hack for golfing:\nmainImage is factored once for all in Common, but still knows in which Buffer it runs.\n\nThis one is 23 chars longer than [url]https://www.shadertoy.com/view/3dXfWj[/url] variant, but here buffers are really empty :-)", "tags": ["tuto", "golf"], "likes": 6, "viewed": 341, "published": 3, "date": "1589038145", "time_retrieved": "2024-07-30T21:07:45.858177", "image_code": "void mainImage(out vec4 O, vec2 U) { mi }", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy//\n#define T texture(iChannel0,//\n#define mi \\\n    O = T U/R);                                         \\\n    float B = T .5/R).a,      /* BuffId */              \\\n          y = 3.*U.y/R.y;                               \\\n    O =   B<2. ?   vec4( y>2., 0,0,0)       /* buffA */ \\\n        : B<3. ? O+vec4(0, y>1.&&y<2., 0,0) /* buffB */ \\\n               : O+vec4(0,0, y<1., 0);      /* Image */ \\\n    U-.5==R-R ? O.a = ++B :B; // inc BuffId", "buffer_a_code": "void mainImage(out vec4 O, vec2 U) { mi }", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 O, vec2 U) { mi }", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3dXfWj", "name": "all in Common", "author": "FabriceNeyret2", "description": "hack for golfing:\nmainImage is factored once for all in Common, but still knows in which Buffer it runs.\n\nNote that the [url]https://www.shadertoy.com/view/3dfBDj[/url] variant do same with really empty buffers (but 24 chars longer).", "tags": ["tuto", "golf"], "likes": 0, "viewed": 338, "published": 3, "date": "1589038096", "time_retrieved": "2024-07-30T21:07:46.628119", "image_code": "int B=0;\nvoid mainImage(out vec4 O, vec2 U) { mi }", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy//\n#define mi                               \\\n    O = texture(iChannel0,U/R);          \\\n    int y = int(3.*U.y/R.y);             \\\n    O =   B>1 ?   vec4( y>1, 0,0,0)      \\\n        : B>0 ? O+vec4(0, y>0&&y<2, 0,0) \\\n              : O+vec4(0,0, y<1, 0);", "buffer_a_code": "int B=2;\nvoid mainImage(out vec4 O, vec2 U) { mi }", "buffer_a_inputs": [], "buffer_b_code": "int B=1;\nvoid mainImage(out vec4 O, vec2 U) { mi }", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WsXfWj", "name": "Flaming Webcam 2", "author": "tomachi", "description": "wave some light at the camera, then make it very dark. the flames freeze into light crystals!!", "tags": ["webcam"], "likes": 4, "viewed": 642, "published": 3, "date": "1589036545", "time_retrieved": "2024-07-30T21:07:47.410028", "image_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define melting(g) texture(iChannel1, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define brightness 1.0001\n#define yellow vec4(0.16,0.18,0.02,0.)\n#define blackwhite vec4(1.,1.,1.,0.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \t\n    vec2 xy = fragCoord;\n    vec4 webcam = camchan(xy);\n    vec4 melt = vec4(\n        abs(melting(xy).x)*0.5,\n        abs(melting(xy).y)*0.025,\n        abs(melting(xy).z)*0.025,\n        0.\n        );\n    vec4 presh = tex(xy);\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    float texbright = (melt.r + melt.g + melt.g) * 0.333;\n    float lumens = (webcam.r + webcam.g + webcam.g) * 0.333;\n    pressure = presh.w;\n  // fragColor = herbivore + (webcam * vec4(r, g, b, 1.)) + vec4(r*brightness, g*brightness, b*brightness, 1.); //  * vec4(1.0);\n\t//fragColor = webcam  + sin(tex(fragCoord).w * blackwhite);\n    if ( pressure > 1.5 ) { \n        fragColor = melt + (webcam*vec4(0.2))  + sin(tex(fragCoord).w * yellow);\n    } else if (pressure > 0.5 && lumens < 0.25) {\n        fragColor = melt +(webcam*vec4(3.2)) + (sin(tex(fragCoord).w * vec4(0.)));  \n    } else {\n       fragColor = melt + (webcam*vec4(1.))  + sin(tex(fragCoord).w * yellow);\n    }\n\n   \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lightpressure 0.03\n#define brightness 3.99\n#define count 20\n#define radius 0.943\n#define emitSize 0.950\n#define force 0.99\n#define constraint 0.91\n#define effect 0.99\n#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n\n// v => coord x,y / s => dir\n// v => coord x,y / d => diam\n// https://github.com/aiekick/NoodlesPlate/blob/master/fluid.glsl\n//NoodlesPlate widgets\n//uniform(hidden) \tint\t\t\t(frame) \t\t\t\t\t\tuFrame;\n//uniform(hidden) \tfloat\t\t(deltatime) \t\t\t\t\tuDeltaTime;\n//uniform(hidden) \tsampler2D\t(buffer:0) \t\t\t\t\t\tbuffer;\n//uniform(hidden) \tsampler2D\t(buffer:1) \t\t\t\t\t\tbuffer1;\n//uniform(hidden) \tvec2\t\t(buffer:0) \t\t\t\t\t\tsize;\n//uniform(color) \tvec3\t\t(0:10:7.7,6.0,7.5) \t\t\t\tcolor;\n//uniform(physic) \tfloat\t\t(0.0:1.0:0.1) \t\t\t\t\tforce;\n//uniform(prism) \tfloat\t\t(0.00001:0.1:0.01) \t\t\t\tconstraint;\n//uniform(prism) \tfloat\t\t(-1.0:1.0:0.0) \t\t\t\t\teffect;\n//uniform(prism) \tfloat\t\t(0.99:1.0:1.0) \t\t\t\t\tviscosity;\n//uniform(emit) \tfloat\t\t(1.0:20.0:5.0) \t\t\t\t\temitSize;\n//uniform(emit) \tint\t\t\t(0:50:1) \t\t\t\t\t\tcount;\n//uniform(emit) \tfloat\t\t(0.0:0.5:0.3) \t\t\t\t\tradius;\n//uniform(emit) \tfloat\t\t(checkbox:true) \t\t\t\temit;\n//uniform(shape) \tint\t\t\t(combobox:circle,triangle,quad) shapeType;\n\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n\treturn tri;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\t\n\tvec2 xy = fragCoord.xy;\n\tvec4 webcam = camchan(xy);\n\tvec2 s = iResolution.xy;\n\tvec2 g = fragCoord;\n\tvec4 a = tex(g+vec2(1,0));// + webcam.r;\n\tvec4 b = tex(g+vec2(0,1));// + webcam.g;\n\tvec4 c = tex(g+vec2(-1,0));// + webcam.b;\n\tvec4 d = tex(g+vec2(0,-1));// + (webcam.r * -0.0125);\n\tfloat lumens = (webcam.r + webcam.g + webcam.b)*0.333;\n\tfloat presh = abs(tex(xy).z);\n\tfloat ink = abs(tex(xy).w);\n\t\n\t// fragColor = tex(g-tex(g).xy); // last state\n    vec4 tomachi = vec4(1.0001,1.0002,1.0003,0.0);\n\t\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n\tvec4 left = camchan(xy+vec2(1,0)) + tex(xy+vec2(1,0));\n\tvec4 right = camchan(xy+vec2(0,1)) + tex(xy+vec2(0,1));\n\tvec4 up = camchan(xy+vec2(-1,0)) + tex(xy+vec2(-1,0));\n\tvec4 down = camchan(xy+vec2(0,-1))+ tex(xy+vec2(1,0));\n\t//vec2 presh = vec2(left.z-right.z,up.z-down.z); // pressure gradient\n\tfloat magic = 0.25;\n    fragColor = tex(g-tex(g).xy)* tomachi; // last state\n\n\tif (lumens > 2.5 || webcam.r > 0.7 || webcam.g > 0.57) {\n\t\t//emit(xy, vec2( 0.8995+(webcam.r*-0.76), 0.4+(webcam.g*-0.95) + (webcam.b*-0.5)));\n\t\t//emit(vec2(1.+lumens*-0.5,1.+lumens*-0.5), vec2(1.+lumens*-0.5,1.+lumens*-0.5));\n\t\temit(xy, vec2(0.1+lumens*-0.05,4.+lumens*-2.));\n\n        magic = 0.252;\n\t}  \n\tfloat pressure = magic * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n\t\n\tif (lumens < 0.67 ) {\n        if (pressure < 0.0005) {\n       \t   // pressure *= 0.5;    \n       \t\tfragColor.z *= 0.9;\n\t\t\tfragColor.w *= 0.9;\n\t\t\t//fragColor.xy *= 1.001;\n\t\t\t//fragColor.xy *= vec2(1.0001);\n        } else {\n         \tpressure *= 1.000069;   \n        }\n    }  \n    if (lumens > 0.0595) {\n\t\t//emit(xy, vec2(-0.500, 2.0 + (lumens*-4.) ));\n\t\tpressure += (lumens*lightpressure);\n    } else {\n        pressure *= (lumens*0.92);\n\t\tink = lumens *-1.;\n    }\n\n\t\n\t\n\t//emit(xy, 0.005);\n\tif (abs(d.b) > 0.995 && abs(a.r) > 0.995) // governs over pressure condition\n\t{\n\t\tvec2 p = vec2( webcam.r, webcam.g);\n\t\tvec2 dir = vec2( webcam.g, webcam.b);\n\t\temit(xy, p*dir);\n    \t//emit(xy, dir);\n\t\t//emit(vec2(0.1+lumens*-0.05,2.+lumens*-0.5), vec2(1.+lumens*-0.5,1.+lumens*-0.5));\n\n\t\t//emit(p, dir);\n\t\t//mit(vec2(xy.y,3.), p);\n\t\t//emit(vec2(xy.y,3.), dir);\n\t\t//emit(vec2(xy.y,3.), dir);\n\t\tpressure *= 0.96;\t\t\n\t} \n\tif (g.x < 0.9 || g.y < 0.9 || g.x > s.x - 0.9 || g.y > s.y - 0.9) fragColor.xy *= 0.;\n\t\n\tif ( pressure > 4.99310589015 || lumens > 0.8) {\n\t\tfragColor.w = abs(fragColor.z) -0.05;\n\t\t//fragColor.xy = vec2(0.,0.);\n\t} \n    if ( pressure > 12.5) {\n        pressure *= 0.9;\n\n    }\n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\tfragColor.xyz = vec3(\n\t\tfragColor.x + gp.x + (webcam.r * 0.0099),\n\t\tfragColor.y + gp.y + (webcam.b * 0.0099),// + webcam.r,\n\t\tpressure\n\t);\n    \n//\tfragColor.xyz = vec3(\n//\t\tfragColor.x + gp.x ,\n//\t\tfragColor.y + gp.y ,// + webcam.r,\n//\t\tpressure\n//\t);\n    \n    // + webcam.r;\n\t\n  \t//if (fragCoord.x > 0.9) fragColor = vec4(0.);\n\t//if (fragCoord.x < 0.2) fragColor = vec4(0.);\n\t//if (fragCoord.y < 0.8) fragColor = vec4(0.);\n\t//if (fragCoord.y < 0.2) fragColor = vec4(0.);\n\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = vec2(fragCoord.x + 1.1, fragCoord.y -3.1);\n//    fragColor = tex(fragCoord + vec2(0.01,1.5));\n    float luma = abs(tex(xy).z); // pressure \n    float red = tex(xy).x;//    tex(xy).w; // ink \n    float green = tex(xy).y;\n    fragColor = vec4(red, green, luma, luma);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 329, 329, 1292]], "test": "untested"}
{"id": "WdXBWj", "name": "Vision-15052020 Artifex V.N.", "author": "tester1963", "description": "visioni", "tags": ["vision"], "likes": 1, "viewed": 374, "published": 3, "date": "1589034561", "time_retrieved": "2024-07-30T21:07:48.254770", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// modificato tester1963 - online9-052020\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nfloat hash1( vec2 p )\n{\n    return fract(sin(p.x+131.1*p.y)*1751.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// ripped from Kali's Lonely Tree shader\nmat3 rotationMat(vec3 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (2.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n                (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n                (2.0 - c) * v.x * v.z - s * v.y, (2.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvec3 axis = normalize( vec3(-0.3,-1.,-0.4) );\n\nvec2 map( vec3 p )\n{\n    // animation\n    float atime = iTime+10.0;\n    vec2 o = floor( 0.9 + p.xz/50.0  );\n    float o1 = hash( o.x*57.0 + 12.1234*o.y );\n    float f = sin( 1.0 + (2.0*atime + 31.2*o1)/2.0 );\n    p.y -= 2.0*(atime + f*f);\n    p = mod( (p+25.0)/50.0, 1.0 )*50.0-25.0;\n    if( abs(o.x)>0.5 )  p += (-1.0 + 2.0*o1)*10.0;\n    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );\n    // modeling\n\tfor( int i=0; i<16; i++ )\n\t{\n        p = roma*abs(p);\n        p.y-= 1.0;\n    }\n\tfloat d = length(p*vec3(1.0,0.1,1.0))-0.75;\n    float h = 0.5 + p.z;\n    return vec2( d, h );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 140.0;\n    float precis = 0.001;\n    float t = 0.0;\n    float d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<200; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis||t>maxd ) break;\n        t += 0.6*min( res.x, 5.0 );\n        d = res.y;\n    }\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.2,0.0,0.0);\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.9 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ )\n    {\n        vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*0.5;\n        float dd = clamp( map( aopos ).x*1.0, 2.0, 3.0 );\n        totao += dd;\n    }\n    totao /= 16.0;\n    return clamp( totao*totao*1.5, 0.0, 2.0 );\n}\n\nvec3 lig = normalize(vec3(-0.5,0.7,-1.0));\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fc )\n{\n    // render\n    vec3 bgc = 0.6*vec3(0.3,0.9,2.0)*(0.5 + 0.3*rd.y);\n    vec3 col = bgc;\n    // raymarch\n    vec3 tmat = intersect(ro,rd);\n    float dis = tmat.x;\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        // material\n        vec3 mate = 0.5 + 0.5*mix( sin( vec3(1.2,2.2,1.0)*tmat.y*3.0 ),\n                                  sin( vec3(1.2,2.1,1.0)*tmat.y*6.0 ),\n                                  1.0-abs(nor.y) );\n        // lighting\n        float occ = calcAO( pos, nor );\n        float amb = 0.4+ 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.001*nor, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        // lights\n        vec3 brdf = vec3(0.0);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        brdf += 1.0*occ*vec3(1.00,0.70,0.30)*occ*max(dot(-nor,lig),0.0)*pow(clamp(dot(rd,lig),0.0,1.0),64.0)*tmat.y*2.0;\n        // surface-light interacion\n        col = mate * brdf;\n        // fogt\n        col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*tmat.x*tmat.x ),0.0,1.0) );\n    }\n    else\n    {\n        // sun\n        vec3 sun = vec3(1.0,0.8,0.5)*pow( clamp(dot(rd,lig),0.0,1.0), 60.0 );\n        col += sun;\n        dis = 140.0;\n    }\n    \n    // god rays\n    #if 0\n    float gr = 0.0;\n    float t = 10.1 * hash1(fc);\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float dt = clamp(0.3*t,1.0,10.0);\n        gr += dt*softshadow( pos, lig, 0.01, 128.0 );\n        t  += dt;\n        if( t>dis ) break;\n    }\n    col += vec3(1.0,0.9,0.7)*pow(gr*0.004,2.0) - 0.02;\n    #endif\n    \n    // sun scatter\n    col += 0.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    // postprocessing\n    // gamma\n    col = pow( col, vec3(0.45) );\n    // contrast/brightness\n    col = 1.3*col-0.2;\n    // tint\n    col *= vec3( 1.0, 1.04, 1.0);\n\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    // camera\n    float an = 2.5 + 0.12*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),12.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 3.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.2*ww );\n    vec3 col = render( ro, rd, fragCoord );\n    // vigneting\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 3.0, 1.0, 14.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, fragCoord );\n    fragColor = vec4( col, 9.0 );\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[167, 167, 190, 190, 228], [230, 230, 253, 253, 303], [305, 305, 328, 328, 422], [424, 465, 504, 504, 886], [935, 935, 955, 972, 1544], [1546, 1546, 1588, 1588, 1931], [1933, 1933, 1965, 1965, 2180], [2182, 2182, 2247, 2247, 2501], [2503, 2503, 2545, 2545, 2893], [2939, 2939, 2990, 3004, 5241], [5243, 5243, 5300, 5300, 6111], [6113, 6113, 6207, 6207, 6364]], "test": "untested"}
{"id": "tssBWB", "name": "Flaming Webcam 1", "author": "tomachi", "description": "Should make bright colours on fire. ", "tags": ["webcam"], "likes": 3, "viewed": 653, "published": 3, "date": "1589026659", "time_retrieved": "2024-07-30T21:07:49.153367", "image_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define melting(g) texture(iChannel1, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define brightness 1.0001\n#define yellow vec4(0.9,0.8,0.5,0.)\n#define blackwhite vec4(1.,1.,1.,0.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \t\n    vec2 xy = fragCoord;\n    vec4 webcam = camchan(xy);\n    vec4 melt = vec4(\n        abs(melting(xy).x)*0.025,\n        abs(melting(xy).y)*0.025,\n        abs(melting(xy).z)*0.025,\n        0.\n        );\n    vec4 presh = tex(xy);\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    float texbright = (melt.r + melt.g + melt.g) * 0.333;\n    float lumens = (webcam.r + webcam.g + webcam.g) * 0.333;\n    pressure = presh.w;\n  // fragColor = herbivore + (webcam * vec4(r, g, b, 1.)) + vec4(r*brightness, g*brightness, b*brightness, 1.); //  * vec4(1.0);\n\t//fragColor = webcam  + sin(tex(fragCoord).w * blackwhite);\n    if ( pressure > 6.9725 ) { \n       // fragColor = melt + (webcam*vec4(0.63))  + sin(tex(fragCoord).w * yellow);\n            // fragColor = vec4(0.);\n        \tfragColor = webcam  ;//+ sin(tex(fragCoord).w * blackwhite);\n\n\n    } else {\n        //fragColor = vec4(0.);\n        fragColor = melt + (webcam*vec4(0.925)) + (sin(tex(fragCoord).w * yellow));  \n    }\n        //fragColor = melt + (webcam*vec4(1.))  + sin(tex(fragCoord).w * yellow);\n\n    // fragColor = melt +(webcam*vec4(1.5)) + sin(tex(fragCoord).w * blackwhite);  \n\n          // fragColor = melt;// + (webcam*vec4(0.5))  + sin(tex(fragCoord).w * blackwhite);\n\n   \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lightpressure 0.03\n#define brightness 3.99\n#define count 20\n#define radius 0.943\n#define emitSize 0.950\n#define force 0.99\n#define constraint 0.91\n#define effect 0.99\n#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n\n// v => coord x,y / s => dir\n// v => coord x,y / d => diam\n// https://github.com/aiekick/NoodlesPlate/blob/master/fluid.glsl\n//NoodlesPlate widgets\n//uniform(hidden) \tint\t\t\t(frame) \t\t\t\t\t\tuFrame;\n//uniform(hidden) \tfloat\t\t(deltatime) \t\t\t\t\tuDeltaTime;\n//uniform(hidden) \tsampler2D\t(buffer:0) \t\t\t\t\t\tbuffer;\n//uniform(hidden) \tsampler2D\t(buffer:1) \t\t\t\t\t\tbuffer1;\n//uniform(hidden) \tvec2\t\t(buffer:0) \t\t\t\t\t\tsize;\n//uniform(color) \tvec3\t\t(0:10:7.7,6.0,7.5) \t\t\t\tcolor;\n//uniform(physic) \tfloat\t\t(0.0:1.0:0.1) \t\t\t\t\tforce;\n//uniform(prism) \tfloat\t\t(0.00001:0.1:0.01) \t\t\t\tconstraint;\n//uniform(prism) \tfloat\t\t(-1.0:1.0:0.0) \t\t\t\t\teffect;\n//uniform(prism) \tfloat\t\t(0.99:1.0:1.0) \t\t\t\t\tviscosity;\n//uniform(emit) \tfloat\t\t(1.0:20.0:5.0) \t\t\t\t\temitSize;\n//uniform(emit) \tint\t\t\t(0:50:1) \t\t\t\t\t\tcount;\n//uniform(emit) \tfloat\t\t(0.0:0.5:0.3) \t\t\t\t\tradius;\n//uniform(emit) \tfloat\t\t(checkbox:true) \t\t\t\temit;\n//uniform(shape) \tint\t\t\t(combobox:circle,triangle,quad) shapeType;\n\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n\treturn tri;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\t\n\tvec2 xy = fragCoord.xy;\n\tvec4 webcam = camchan(xy);\n\t\n\tvec2 s = iResolution.xy;\n\tvec2 g = fragCoord;\n\t\n\tvec4 a = tex(g+vec2(1,0));// + webcam.r;\n\tvec4 b = tex(g+vec2(0,1));// + webcam.g;\n\tvec4 c = tex(g+vec2(-1,0));// + webcam.b;\n\tvec4 d = tex(g+vec2(0,-1));// + (webcam.r * -0.0125);\n\tfloat lumens = (webcam.r + webcam.g + webcam.b)*0.333;\n\tfloat presh = abs(tex(xy).z);\n\tfloat ink = abs(tex(xy).w);\n\t\n\t// fragColor = tex(g-tex(g).xy); // last state\n    vec4 tomachi = vec4(1.0001,1.0002,1.0003,0.0);\n\tfragColor = tex(g-tex(g).xy)* tomachi; // last state\n\t\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n\t\n\t//fragColor.xyz = vec3(\n\t//\tfragColor.x + gp.x,\n\t//\tfragColor.y + gp.y,\n\t//\t0.25 * (a.z + b.z + c.z + d.z) - 0.25 * (c.x - a.x + d.y - b.y));\n\t\n\t\n\tvec4 left = camchan(xy+vec2(1,0)) + tex(xy+vec2(1,0));\n\tvec4 right = camchan(xy+vec2(0,1)) + tex(xy+vec2(0,1));\n\tvec4 up = camchan(xy+vec2(-1,0)) + tex(xy+vec2(-1,0));\n\tvec4 down = camchan(xy+vec2(0,-1))+ tex(xy+vec2(1,0));\n\t//vec2 presh = vec2(left.z-right.z,up.z-down.z); // pressure gradient\n\tfloat magic = 0.25;\n\tif (lumens > 2.5 || webcam.r > 0.7 || webcam.g > 0.57) {\n\t\t//emit(xy, vec2( 0.8995+(webcam.r*-0.76), 0.4+(webcam.g*-0.95) + (webcam.b*-0.5)));\n\t\t//emit(vec2(1.+lumens*-0.5,1.+lumens*-0.5), vec2(1.+lumens*-0.5,1.+lumens*-0.5));\n\t\tmagic = 0.252;\n\t}  \n\tfloat pressure = magic * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n\t\n\tif (lumens < 0.67 ) {\n\t\t\n        if (pressure < 0.0005) {\n       \t    //pressure *= 0.5;    \n       \t\tfragColor.z *= 0.9;\n\t\t\tfragColor.w *= 0.9;\n\t\t\t//fragColor.xy *= 1.001;\n\t\t\t//fragColor.xy *= vec2(1.0001);\n        } else {\n         \tpressure *= 1.000069;   \n        }\n    }  \n    if (lumens > 0.00595) {\n\t\t//emit(xy, vec2(-0.500, 2.0 + (lumens*-4.) ));\n\t\tpressure += (lumens*lightpressure);\n    } else {\n        //pressure *= (lumens*1.92);\n\t\tink = lumens *-1.;\n    }\n\n\t\n\t\n\t//emit(xy, 0.005);\n\tif (abs(d.b) > 0.995 && abs(a.r) > 0.995) // governs over pressure condition\n\t{\n\t\tvec2 p = vec2( webcam.r, webcam.g);\n\t\tvec2 dir = vec2( webcam.g, webcam.b);\n\t\temit(xy, dir);\n\t\tpressure *= 0.95;\t\t\n\t} \n\tif (g.x < 1. || g.y < 1. || g.x > s.x - 1. || g.y > s.y - 1.) fragColor.xy *= 0.;\n\t\n\tif ( pressure > 4.99310589015 || lumens > 0.8) {\n\t\t//pressure *= 0.995;\n\t\tfragColor.w = abs(fragColor.z) -0.05;\n\t\t//fragColor.xy = vec2(0.,0.);\n\t} \n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\tfragColor.xyz = vec3(\n\t\tfragColor.x + gp.x + (webcam.r * 0.000099),\n\t\tfragColor.y + gp.y + (webcam.b * 0.000099),// + webcam.r,\n\t\tpressure\n\t);// + webcam.r;\n\t\n  \t//if (fragCoord.x > 0.9) fragColor = vec4(0.);\n\t//if (fragCoord.x < 0.2) fragColor = vec4(0.);\n\t//if (fragCoord.y < 0.8) fragColor = vec4(0.);\n\t//if (fragCoord.y < 0.2) fragColor = vec4(0.);\n\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = vec2(fragCoord.x + 1., fragCoord.y + 2.);\n//    fragColor = tex(fragCoord + vec2(0.01,1.5));\n    float luma = abs(tex(xy).z); // pressure \n    float red = tex(xy).x;//    tex(xy).w; // ink \n    float green = tex(xy).y;\n    fragColor = vec4(red, green, luma, luma);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 326, 326, 1571]], "test": "untested"}
{"id": "tdsfDS", "name": "大龙猫 - Radioaktivität", "author": "totetmatt", "description": "Rip Florian Schneider \nhttps://www.youtube.com/watch?v=Nzzw94lrytg", "tags": ["kraftwerk"], "likes": 3, "viewed": 392, "published": 3, "date": "1589023148", "time_retrieved": "2024-07-30T21:07:49.982151", "image_code": "\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat vexel(vec3 p,vec3 b, float r) {\n\n        vec3 q = abs(p) -b;\n        return length(max(q,0.0) + min(max(q.x,max(q.y,q.z)),0.0)) - r;\n}\n#define ITER 64.\n#define PI 3.141592\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat stripes(vec3 p) {\n     \n    float s = sin(atan(p.x,p.y)*21.) > 0.85 && p.z <-0.15 && sin(8.*iTime+p.z*50.) >-0.5 ? -sdCappedCylinder(p,vec3(0.,0.,1.),vec3(0.,0.,-1.),.89) : 10000.;\n    return s;\n\n}\nfloat radiologo(vec3 p) {\n    \n    float side = 100000.;\n    for(float i=0.;i<3.; i++){\n        \n        vec3 pos = p;\n        pos.xy*=r(i*(2.*PI/3.));\n        pos+=vec3(0,.5,-0.);\n         \n         \n        \n        side = min(side,sdTriPrism(pos,vec2(.51,.1) ));\n    }\n    \n    \n    side = max(-sdCappedCylinder(p,vec3(0,0,-.20),vec3(0,0,.20),.15),side);\n    \n    float border = max( sdCappedCylinder(p,vec3(0,0,-.20),vec3(0,0,.20),.89), -sdCappedCylinder(p,vec3(0,0,-.25),vec3(0,0,.25),.75)) ;\n    side = max(side,-border);\n    float center = sdCappedCylinder(p,vec3(0,0,-.10),vec3(0,0,.10),.1);\n    return min(min(side,center),stripes(p));\n}\n\n\nfloat SDF(vec3 p) {\n \n     return radiologo(p+vec3(0.,0.,-4.0));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=.5;\n    vec3 ro =vec3(0.01,0.01,-3.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0);\n  \n    float shad = 0.;\n    bool hit = false;\n    \n    for(float i=0.;i < ITER; i++) {\n      float d = SDF(p);\n        if(d< 0.001) {\n            hit = true;\n            shad = i / ITER;\n            break;\n        }\n        p += d*rd;\n    }\n    \n bool anim = mod(iTime,3.) >1.;\n    bool subanim = mod(iTime,3.) >2.;\n    if(hit) {\n     if(anim) {\n        col = vec3(1.-shad,1.-shad,.1);\n        } else {\n            col = vec3(0);\n        } \n        \n    } else {\n       if(anim) {\n             if(subanim) {\n           col = vec3(0);}\n           else {\n           col = vec3(.9,0.,0.);\n           }\n        } else {\n           \n            col = vec3(1.-shad,1.-shad,.1);\n        } \n    }\n     \n     \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 163, 220, 220, 556], [557, 557, 593, 593, 676], [677, 677, 714, 714, 797], [799, 799, 836, 836, 939], [978, 978, 1009, 1009, 1096], [1097, 1097, 1150, 1150, 1209], [1210, 1210, 1226, 1226, 1284], [1285, 1285, 1318, 1344, 1375], [1376, 1376, 1399, 1399, 1579], [1580, 1580, 1605, 1605, 2226], [2229, 2229, 2248, 2248, 2295], [2296, 2296, 2351, 2351, 3259]], "test": "untested"}
{"id": "wdlBWS", "name": "DTMF Decoder", "author": "blackle", "description": "I was wondering if you could decode data from soundcloud audio, and it looks like DTMF decoding is possible!\nif you're on mac or linux, change SAMPLE_RATE in buffer A to be 44100. this is a workaround to a bug in shadertoy.", "tags": ["dtmf", "dsp"], "likes": 3, "viewed": 423, "published": 3, "date": "1589010238", "time_retrieved": "2024-07-30T21:07:50.814924", "image_code": "// ^^^^^^^^^^ make sure soundcloud is playing in Buffer A!\n// if you're on mac or linux, change SAMPLE_RATE in buffer A to be 44100. this is a workaround to a bug in shadertoy.\n\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat seven_segment(vec2 uv, mat3 char) {\n    float mx = 1000.;\n    for (int i = -1; i < 2; i++) {\n        for (int j = -1; j < 2; j++) {\n            if (char[j+1][i+1] == 0.) continue;\n            vec2 a;\n            vec2 b;\n            if (i==0) {\n                a = vec2(i-1,j);\n                b = vec2(i+1,j);\n            } else {\n                a = vec2(i,j);\n                b = vec2(i,0);\n            }\n            float ln = linedist(uv, a*vec2(1.,2.), b*vec2(1.,2.));\n            mx = min(ln, mx);\n        }\n    }\n    return smoothstep(0.5,0.0,mx);\n}\n\nconst int CHARS[112] = int[112](\n    0,0,1, 0, 0,0,1, //1\n    0,1,1, 1, 1,1,0, //2\n    0,1,1, 1, 0,1,1, //3\n    1,1,1, 1, 1,0,1, //A\n    1,0,1, 1, 0,0,1, //4\n    1,1,0, 1, 0,1,1, //5\n    1,1,0, 1, 1,1,1, //6\n    1,0,0, 1, 1,1,1, //B\n    0,1,1, 0, 0,0,1, //7\n    1,1,1, 1, 1,1,1, //8\n    1,1,1, 1, 0,1,1, //9\n    1,1,0, 0, 1,1,0, //C\n    0,0,0, 1, 0,0,0, //*\n    1,1,1, 0, 1,1,1, //0\n    0,1,0, 1, 0,1,0, //#\n    0,0,1, 1, 1,1,1  //D\n);\n\nfloat bayer_dither(vec2 fragCoord) {\n    return texelFetch(iChannel1, ivec2(fragCoord) % 8, 0).x/128.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*vec2(1,-1);\n    vec2 corner = vec2(-0.4);\n    vec2 scale = vec2(20.,15.);\n    uv -= corner;\n    ivec2 id = ivec2(floor(uv*scale));\n    ivec2 res = ivec2(16,12);\n    \n    if (id.x < 0 || id.y < 0 || id.x >= res.x || id.y >= res.y) {\n        fragColor = vec4(smoothstep(2.,0.,length(uv))*0.1+0.1) + bayer_dither(fragCoord);\n        return;\n    }\n    int place = id.x + id.y*res.x + 1;\n    ivec2 datares = ivec2(iChannelResolution[0]);\n    ivec2 datacrds = ivec2(place % datares.x, place / datares.x);\n\n    vec2 crds = (fract(uv*scale)-0.5)/scale*scale.y;\n    \n    vec4 data = texelFetch(iChannel0, datacrds, 0);\n    \n    mat3 char = mat3(0);\n    if (data.z > 0.) {\n        int d = int(data.x*16.);\n        char = mat3(CHARS[d*7],CHARS[d*7+1],CHARS[d*7+2],0,CHARS[d*7+3],0,CHARS[d*7+4],CHARS[d*7+5],CHARS[d*7+6]);\n    }\n    fragColor = vec4(1,0,0,0)*seven_segment(crds*8.,char);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//note: on linux and mac SAMPLE_RATE must be 44100\n#define SAMPLE_RATE 48000.\n#define NO_UNROLL(k) (k+min(0,iFrame))\n\nfloat freq(float fq) {\n    float cs = 0.;\n    float sn = 0.;\n    for (int i = 0; i < NO_UNROLL(64); i++) {\n        float smp = texelFetch( iChannel0, ivec2(i*8,1), 0 ).x - 0.5;\n        float t = float(i*8)/SAMPLE_RATE;\n        float window = float(i)/64.;\n        smp *= pow((1.-window)*window*4.,2.);\n        cs += cos(t*fq*3.1415*2.)*smp;\n        sn += sin(t*fq*3.1415*2.)*smp;\n    }\n    return length(vec2(cs,sn))/4.;\n}\n\nint max_index(vec4 p) {\n    float m = p.x;\n    int mi = 0;\n    for (int i = 1; i < 4; i++) {\n        if (p[i] > m) {\n            m = p[i];\n            mi = i;\n        }\n    }\n    return mi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int place = int(fragCoord.x) + int(fragCoord.y)*512;\n    vec4 state = texelFetch(iChannel1, ivec2(0,0), 0);\n    vec4 data = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    bool is_state = place == 0;\n    bool is_active = int(state.x) == 1;\n    int next_idx = int(state.y);\n    \n    if (!is_state && place != next_idx+1) {\n    \tfragColor = data;\n        return;\n    }\n\n    vec4 low = vec4(freq(697.), freq(770.), freq(852.), freq(941.));\n    vec4 high = vec4(freq(1209.), freq(1336.), freq(1447.), freq(1633.));\n    bool trigger = length(low) + length(high) > 1.;\n\n    if (!is_active && trigger) {\n        next_idx += 1;\n        if (place == next_idx) {\n            int low_idx = max_index(low);\n            int high_idx = max_index(high);\n            int decoded = low_idx*4 + high_idx;\n            data = vec4(float(decoded)/16., 0, 1, 0);\n        }\n    }\n\n\tis_active = trigger;\n    if (is_state) {\n        data = vec4(float(is_active), float(next_idx), 0, 0);\n    }\n\n    if (iFrame < 10) {\n        data = vec4(0);\n    }\n\n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22555, "src": "https://soundcloud.com/blackle-mori/dtmf-interesting", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBWS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[372, 372, 412, 412, 503], [505, 505, 546, 546, 1067], [1506, 1506, 1542, 1542, 1610]], "test": "untested"}
{"id": "wdlfWS", "name": "this is a good sin :0", "author": "gurudevbk", "description": "its bloops", "tags": ["periodic"], "likes": 1, "viewed": 310, "published": 3, "date": "1589009020", "time_retrieved": "2024-07-30T21:07:51.574893", "image_code": "// returns true if a point [uv] is within the circle defined by [origin, radius]\nbool circle(vec2 uv, vec2 origin, float radius) {\n \treturn (length(uv-origin) < radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float thickness = 0.1;\n    float radius = 0.3;\n    vec2 origin = vec2(0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0.5,0.5,0.36);\n    \n    // Time varying pixel color\n    if (abs(length(uv-origin) - radius) < abs(sin(iTime)/3.)) {\n    \tcol = 0.5 + 0.5*cos(iTime+length(uv-radius)+col);\n    \tcol.r += sin(iTime)+cos(iTime);\n    }\n    \n    else {\n    \tcol = 0.5 + 0.5*sin(iTime+length(uv-radius)+col);\n        col.r += sin(iTime)+cos(iTime);\n    }\n    \n    col.g /= col.r;\n    \n    col.g *= 0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 81, 130, 130, 171], [173, 173, 230, 230, 863]], "test": "untested"}
{"id": "tdlfWS", "name": "ID - Genizm (+Music Visualizer)", "author": "gurudevbk", "description": "https://soundcloud.com/genizm/id-supra-identity", "tags": ["fractal", "experimentation", "audio", "abstract", "visualizer", "soundcloud"], "likes": 2, "viewed": 409, "published": 3, "date": "1589008398", "time_retrieved": "2024-07-30T21:07:52.324887", "image_code": "#define freq(f) texture(iChannel0, vec2(f, 0.25)).x * 0.8\n\n\nfloat avgFreq(float start, float end, float step) {\n    float div = 0.0;\n    float total = 0.0;\n    for (float pos = start; pos < end; pos += step) {\n        div += 1.0;\n        total += freq(pos);\n    }\n    return total / div;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n       \n    float aspect = iResolution.y/iResolution.x; //aspect ratio of viewport\n    float value; //var\n\tvec2 uv = fragCoord.xy / iResolution.x; //vec ratio of fragment coordinate to width of viewport\n \n    float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.85);\n    float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\n    float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.85);\n   \n    float rot = radians(45.0); // radians(45.0*sin(iTime)); //radians(45.0)\n    float rot2 = radians(45.0*sin(iTime)); // radians(45.0*sin(iTime)); //radians(45.0)\n    \n    uv -= vec2(0.5, 0.5*aspect); //transform\n\n\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \tuv  = m * uv;\n    uv *= vec2(1., 1.7*aspect);\n    uv.y+=0.01*(2.0-aspect);\n    vec2 pos = 200.0*uv;\n    vec2 rep = fract(-0.9*tan(rot2)+cos(rot2/2.0)*pos);\n    float dist = min(min(rep.x, rep.x), min(rep.y, 1.0-rep.y));\n    float squareDist = length((floor(pos)+vec2(0.5)) - vec2(1.0) );\n    \n    float edge = 4.*sin(squareDist)*0.5+0.5;\n    \n    edge = ((iTime+bassFreq+medFreq)/20.-squareDist*((iTime*medFreq+topFreq)/50000.))*0.5;\n    edge = medFreq*4.0*fract(edge*squareDist);\n    value = medFreq*abs(dist-bassFreq);\n    //value = pow(dist, 2.0);\n    value = fract (dist*2.0);\n    value = mix(value, 1.0-value, step(1.0, edge));\n    //value *= 1.0-0.5*edge;\n    edge = pow(abs(1.0-edge), 2.0);\n    \n    //edge = abs(1.0-edge);\n    value = smoothstep( edge-0.25, edge, 0.55*value);\n    \n    \n    value += squareDist*.1;\n    //fragColor = vec4(value);\n    fragColor = mix(vec4(1.0,edge/2.,value/4.,1.0)*(cos(rot2)/4.0),vec4(0.5,0.75,1.0,1.), edge);\n    fragColor.a = 0.25*clamp(edge, 0.0, 1.0);\n    fragColor.b += sin(iTime+medFreq)*.5+.5;\n    fragColor.r /= .5*bassFreq+sin(iTime+medFreq)*.1+.2;\n    fragColor.g += topFreq*.1;\n}", "image_inputs": [{"id": 29478, "src": "https://soundcloud.com/genizm/id-supra-identity", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 111, 111, 289], [292, 292, 349, 349, 2145]], "test": "untested"}
{"id": "tdXfDB", "name": "tartan weave brickwork chord 2", "author": "ollj", "description": "patching up of: \nhttps://www.shadertoy.com/view/4ttBD4\n\ngrandpoarent: \nhttps://www.shadertoy.com/view/4ttBD4", "tags": ["starguitar", "irrationalstride", "arpshepardtone", "ditherhairlinequantize", "chromaticscalecordtartanweave", "euclideanbeats", "euclideanrythm"], "likes": 3, "viewed": 438, "published": 3, "date": "1588976645", "time_retrieved": "2024-07-30T21:07:53.543629", "image_code": "/*\nthis is a different approach to a [*stride] pMod segment\nthis rasterizes any interval perfectly with modulo arithmetic (and scales it by viewZoom)\nthe issue is, that you need multitapping for kerning\n,but this shows how far you can get with a single tap\nthis can do any chord and apreggio with single taps\narpeggios with overlapping notes may need a 4d to 2d fold.\n*/\n\n//this is a namespoace merger of 2 parents:e\n//https://www.shadertoy.com/view/4ttBD4  : tartan weave brickwork chord 1\n//https://www.shadertoy.com/view/3l2GDR  : ReTrAdUi amalgations2 (automatic differentiation)\n\n//circle radius\n#define radius 1.\n\n//#define hl2 290.*8.\n//https://www.shadertoy.com/view/4ttBD4 is pixel perfecrt, iff(viewZoom==hl2/floor(i))\n//zooming is just for a debug focus.\n#define viewzoom (.2)\n//(hl2/floor(mix(1.,hl2*.1,u5(-cos(iTime)))    ))\n//hl2*mix(9.,99.,(-sin(cos(iTime))))))\n//(mix(1./hl2,hl2,(-sin(cos(iTime)))))\n//#define viewZoom (hl2)\n//#define hl (viewZoom/hl2)\n#define hl (viewzoom/hl2)\n//blur of all the lines\n#define hl2 min(iResolution.x,iResolution.y)\n\n//#define fra(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n//float ss(vec1 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(float u,vec2 m){return smoothstep(m.x,m.y,u);}\nvec2  ss(vec2 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(vec1 a){return ss(a,vec2(1,-1)*hl);}\nvec2  ss(vec2 a){return ss(a,vec2(1,-1)*hl);}\n\n//return square tesselaion grod for [u]fragmentPos\n//float grid(vec2 u){u=fract(u);u=ss2t(u);float r=1.-min(u.x,u.y);return smoothstep(hl,-hl,abs(r-1.)-hl);}\n\n//domain-general pmod(), and 4 instanciated domain verisons:\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n//repetitive only for less repetitive legacy namespace support.\n//because this shader scales and rounds (translates) one invertal into another (quantized) inverval:\n//it takes an excursion into; Maxwellian dimensional relativism:\n#define coVelEm 2.99792458e8\n#define lightspeed coVelEm\n//commonly known as \"speed of light\" or \"c\"; in in length/second==velocity\n//a better term would be [Electromagnetic velocity]\n//this is a maximum velocity in a vacuum. Usually a straight direct path is obstructed by mass\n//, cuvring spacetime, deforming a straight and shootrest path into a longer line.\n//Without a maximum velocity, causality over time is nonlinear/discontinuous.\n#define coPlanck 6.62607004e-34\n//smallest EM-observable quantity, smallest physically EM-percievable interval \n//;in joule*second==newton*length*second==length*length*kilogram/second/second == length*kilogram*acceleration\n//==length*kilogram*acceleration\n#define coPlanckR (coPlanck/pi/2.)\n//==1.0545718e-34\n//\"reduced PlanckConstant\" is a common scalar, where EM interferrences are about [fourier butterflies]\n//this involves the issue of [squaring an (epi)circle], within limited resolution of DFT|FFT\n#define coGravity 6.674e-11\n//gravitational constant; in newton/kilogram/kilogram/length/length\n//spacetime curvature over inverse_squared_distance to mass\n//gravity is not a force, but an effect of curving spacetime, poportional to squared mass and inverse squared distance.\n//you can model gravity as if it is a force, but that model will not be relativistic.\n#define coPlanckT sqrt(coPlanckR*coGravity/coVelEm/coVelEm/coVelEm/coVelEm/coVelEm)\n//PlanckTime; smallest EM-ovservavle interval over time\n//;5.3911252e-44 == sqrt(1.0545718e-34*6.674e-11/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8)\n//minimum time that information takes to traverse length(coPlanck) in coMaVelEm\n//whilst smaller units of time can exist, they are so small their effect on our existence is negligible\n#define planckT .0001    \n//smallest measurable distance to an asymptote\n//smallest measurable angle between 1 non-parallel lines\n//smallest feasible epsilon, regardles of contextual scaling, to evade divisions by 0.\n//an ideall model defines planck==coPlanckT or planck=coPlanck, depending on context of your model\n//, but 32bit float precision is not good enough for this.\n//so we chose to scale our model resolution down significantly, with less addressSpace/precision\n// PlanckLengt/PlanckTime =coMaxSpeed\n//[u]FragmentPos, [m]=start [n]=end\n\n//pmod-tartan-octave-key:\n//pmod fraction with epsilon\n#define pmodfe2(a,b,e) (fract(((a)/(b))+.5)-.5-(e))*(b)\n//...within floor quantizing\n#define pmodfq2(u,n,f,e) floor(pmodfe2(floor((u)+.5),(n)/(max(f,1.+(e))-1.),e)+.5)\n//...offset by m\n#define pmodfM2(u,n,m,f,e) pmodfq2(((u)-(m)),((n)-(m)),f,e)\n//...m is quantized (this is \"tartan basis\", and you check if returned all() any() values are <e.\n#define pmodfm2(u,n,m,f,e) pmodfM2(u,n,floor((m)+.5),f,e) \n//return distance of [u] to line srgment from [a] to [b]\n//pmod fraction with epsilon\n#define pmodfe(a,b,e) (fract(((a)/(b))+.5)-.5-(e))*(b)\n//...within floor quantizing\n#define pmodfq(u,n,f,e) floor(pmodfe(floor((u)+.5),(n)/(max(f,1.+(e))-1.),e)+.5)\n//...offset by m\n#define pmodfM(u,n,m,f,e) pmodfq(((u)-(m)),((n)-(m)),f,e)\n//...m is quantized (this is \"tartan basis\", and you check if returned all() any() values are <e.\n#define pmodfm(u,n,m,f,e) pmodfM(u,n,floor((m)+.5),f,e)\n//uv,start,end,segmentswithin [start,end],epsilonPlanck\n\nfloat dotList(vec2 u,vec2 m,vec2 n,float i//todo, no longer used function. i want to generalize with pmod\n){float s=segment(u,m,n)\n ;vec2 a=abs(m-n)\n ;//if(a.x-a.y<1.)\n ;a=pmodfm2(u,m,n,4.,planckT)\n ;s=sat(4.-s)\n ;return sat(8.-length(a))\n ;return min(sat(8.-length(a)),s)\n ;}//above without rotation, below is rotated and constrained by lineSegmentation\n\n//input [i] sets number of dots in line segment! (does not loop over i)\n//hacky overly general solution, still need to chose what to specialize this on.\n//set radius to 1 or whatever your zoom factors are.\n//or just floor the dot at the circle centers (without a hole)\nfloat dotListp(vec2 u,vec2 m,vec2 n,float i//todo, no longer used function. i want to generalize with pmod\n){vec2 a=(n-m)\n ;//min of 2 shapes, vars descripte dottedlineparams; linesegment thichmess=torRadius!\n ;float radi=8. //(length(m-n)+1.)\n ;float thickness=radi-6.//-6 is size of a hole insote the dot. must be <radi\n ;float r=-atan(a.y,a.x)     \n ;float s=segment(u,m,n)//line segment\n ;s=sat(radi-s)\n ;u=roth(u,r)\n ;m=roth(m,r)\n ;n=roth(n,r)\n ;a=pmodfm2(u,m,n,i,planckT)//[i] sets number of dots in line segment!\n ;//a.x=pmodfm2(length(u-n),length(m-n),length(n-n),4.,planckT)//niced try, very false\n ;a.x=abs(length(abs(vec2(a.x,-u.y+m.y)))-radi+thickness)\n ;a.x=(sat(thickness-a.x))\n ;float b=2.\n ;if(u.x<m.x||u.x>n.x)b=min(abs(length(m-u)-radi+thickness)\n                           ,abs(length(n-u)-radi+thickness))\n ;b=(sat(thickness-b))//2 half circle caps\n ;//return b\n ;//return a.x\n ;//return (a.x+s)*.2\n ;return max(min(a.x,s),b)\n ;}//this function is lame and hacky, the caps are smooth, but all else is not!\n\n//remember this identity for tartan domain folds:\n//;if(min(v.x,v.y)<0.)\n//==\n//;//if(v.x<0.||v.y<0.)\n//==\n//;//if(any(lessThan(v,vec2(0))))\n//above is for lines, below is for dots\n//;if(max(v.x,v.y)<0.)\nvec3 TartanPeriodVariating(vec2 u,vec2 m,vec2 n//uv,start,end\n){vec3 c=vec3(0)\n ;vec2 b3=pmodfm(u,n,m, 5.,planckT)//rasterized fold\n ;vec2 b5=pmodfm(u,n,m, 7.,planckT)//rasterized fold\n ;vec2 b7=pmodfm(u,n,m,13.,planckT)//rasterized fold\n ;if(any(lessThan(abs(b3),vec2(planckT))))c.xy+=1.//rasterized octave lines\n ;if(all(lessThan(abs(b3),vec2(planckT))))c.xy+=.5//rasterized octave dots     \n ;if(any(lessThan(abs(b7),vec2(planckT))))c.zx+=1.//rasterized octave lines\n ;if(any(lessThan(abs(b7),vec2(planckT))))c.zx+=1.//rasterized octave lines\n ;if(all(lessThan(abs(b5),vec2(planckT))))c.yz+=.5//rasterized octave dots\n ;if(all(lessThan(abs(b5),vec2(planckT))))c.yz+=.5//rasterized octave dots\n ;return c/4.5;}\n\n#define FRA(u) ((u-.5*iResolution.xy)*viewzoom)\n\nvec4 mainImage3(in vec2 U\n){vec3 c=vec3(0)\n ;float vZ=.2//resolution\n ;vec2 u=FRA(U)\n ;vec4 mouse=iMouse;mouse=iMouseZwFix(mouse,true)\n ;vec2 m=FRA(mouse.zw)\n ;vec2 n=FRA(mouse.xy)\n ;if(iMouse.z<0.\n ){\n  ;//vec2 rr=iResolution.xy*vZ//vec2(.3,.1)//.x is average radius .y is distance from averate\n  ;n=vec2(cos(iTime),sin(iTime*.61))*iResolution.xy*.5*viewzoom\n  ;m=vec2(cos(iTime*.61),sin(iTime))*iResolution.xy*.5*viewzoom\n  ;}/**/\n     //note, this is the lame screenspace transform that left-aligns a square.\n //3 splitscreen contexts test 2 of the above functions, as this is all very experimental.\n ;c =TartanPeriodVariating(u,m,n)\n ;c+=dotListp(u,m,n,12.)\n ;return vec4(c,1.)\n ;}\n\n\nvoid mainImage(out vec4 o,vec2 u\n){//o=image(u,iMouse.xyzw,iResolution.xy,iTime)//fm synth shader vis\n ;o+=mainImage3(u)\n ;//o*=.5\n ;}\n//vec2 mainSound( in int samp,float t){return sound(t);}\n\n\n\n\n\n", "image_inputs": [], "common_code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#define vec1 float\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nvec2 c2p(vec2 a){return vec2(length(a),atan(a.y,a.x));}\nvec2 p2c(vec2 a){return cs(a.y)*a.x;}\nvec2 roth(vec2 u,float b){u=c2p(u);u.y+=b;return p2c(u);}//rotate u by b\n\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n//floor offset,centred \n#define flc(a) floor(a+.5)\n\n/*pixelation && tartan weave intervals\nparent: https://www.shadertoy.com/view/4ttBD4\nself  : https://www.shadertoy.com/view/tdXfDB\nuseful for brickworkPatterns\nhttps://en.wikipedia.org/wiki/Brickwork#Load-bearing_bonds\nhttps://www.shadertoy.com/results?query=tartan\n- dither, pixelation, tiling, quantum, fold, fibonacci, weave, pmod, tartan, hairline, dotted, notekey, starguitar, chord,arpeggio\ndiscarded tags: bokeh (it used to be a bit bokeh-ish and theres some bokeh-context utility)\n- that is, pixerlation is reciprocal of bokeh.\n- that is, calculating bokeh within a bayer-matrix context\n- , not for all pixel, but for a regular interval of pixels, for better performance.\nMoire aliasing includes the fraction that defines black piano key distribution:\nhttps://en.wikipedia.org/wiki/Aliasing\nhttps://en.wikipedia.org/wiki/Moir%C3%A9_pattern\nmaking 2 dots at start and end of a line, set by mouse.\nmaking 3rd dot at half way point.\nfloor the points with flc() to get minor or major chords.\nthis may extend\nhttp://mercury.sexy/hg_sdf/\nthe same can also floor(pModInterval1()) \nto tell which of every 12 piano keys are black.\n*/\n\n\n\n//todo, fract() lacks AD code\n//todo, many lack the option to only calculate 2 derivatives (over n domains)== types d00,d11,d22,d33\n\n/*\n//Scene2D just shows a 3d scene of brush strokes: https://www.shadertoy.com/view/ltj3Wc\n#define Scene2D\n\n//else, there are 2 3d scenes:\n#ifndef Scene2D\n //[temporal reprojection] makes (even moving) images better over time, but it is a slow process.\n #define SceneTR\n#endif\n*/\n//do TemporalReprojection (slow brdf code and a fullscreen buffer that is slow, even while it is not visible)\n//#define SceneTR\n//disaabled while it keeps crashing the parser iff i run all code at once.\n//yay, reaching a limit is fun!\n\n//memo, make SceneTR faster, by diminishing brdf complexits, reflectionCount or whatever.\n\n#define kifsFungusIter 13\n#define kifsFungusSeed .55\n\n/**/ // start: shadertoy-iChannel-pattern\n/* \nThis amalgation uses the shadertoy-iChannel-pattern:\na-abcd,b-abcd,c-abcd,d-abcd,i-abcd\nUnless a an unnecessary pointer is changed to something more important\n- like KeyboarIn, CubeMapA, a staric distanceField to Glyphs, or a blueNoise Texture.\nthe ichannels of all frasmeBuffers are identical:\niChannel0<-BuffA\niChannel1<-BuffB\niChannel2<-BuffC\niChannel3<-BuffD\nTo have [plugin]s that are rarely more than 1 iChannel FrameBuffer\n[plugin] names are like iChannels, because thats what they point to.\nThis stucture lets me define global modifiable buffer pointers \nfor a plugin-HotSwap option\nwith #ifdef iDiegeticUI contexts for missing-plugin cases:\nEach [plugin] is one seperate FrameBufferObject, summarizing what they buffer:\niDiegeticUI, a lot of object parameters, to be drag and droppable, currently just 2d points.\niAD        , no DoubleBuffer, functions cannot read buffers from commonTab (shadertoy is a bit suilly here)\niCanBez    , no DoubleBuffer, this is the final composite out.\n*/\n/*\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iVoid0      iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n*/\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iRe         iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n#define bufDrag(x) texture(iDiegeticUI,(vec2(x,0.)+.5)/iResolution.xy)\n\n/**/ // end__: shadertoy-iChannel-pattern\n/**/ // start: compatibilityCore \n\n//todo this commontab does not have a c2p() p2c() carthesianToPolar bijection-function-set, add that!\n\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau (pi*2.)\n#define sat(x)clamp(x,0.,1.)\n#define u2(a) su(mu(a,2.),1.)\n#define u5(a) su(mu(a,.5),.5)\n#define cosu5(a) u5(co(a))\n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n/*\nself  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\nparent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\nvery common subroutines|aliases assert:\n- structure aliases listed below, where:\n- - Array index starts with 0:\n- - - f(x,y)=x*y  ;has [x} as its [0th parameter] and [y] as its [1th parameter]\n- - - A formulaOne race car has 0 drivers and 3 tires\n- - - The fastest racer of a race always achieves 0th place of a race\n- - - 2-dimensional spacetime (minkovski diagram) has 0 time domains and 2 space domains\n- - - the length of an array is equal to the position of its last entry\nv*   = linear matrix = vector  with [*]         fields\nm*   = square matrix           with [*]-squared fields\nd*** = single variate calculus over [*] domains down to [tally of *] derivatives\nC*** = multivatiate   calculus over [*] domains down to [tally of *] derivatives\n[tally of *] == [stick counting], in a base1System\n- https://en.wikipedia.org/wiki/Unary_numeral_system\n- https://en.wikipedia.org/wiki/Repdigit\n/**/\n\n#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n\n/**/ // start: compatibilityCore \n//self  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\n//parent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled \"experimental*\"\n//therefore we only care if (VER <300)\n#if VER <300\n//outerproduct is glES300 exclusive\nm2 outerProduct(v2 a,v2 b){return m2(a*b.x,a*b.y,a*b.z);}//i may have swapped a and b wrongly here.\n//sign(int) is gles300 exclusive\ni0 sign(i0 a){return i0(sign(v0(a)));}\n//abs(int) is gles300 exclusive\ni0 abs(i0 a){return (a)*sign(a);}\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nv3 tf(sampler2D a,v1 b,v2 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nv3 tf(sampler2D a,v1 b,v2 r){return texelFetch(a,i1(b),0) ;}\n#endif\nm3 rotationAxisAngle(v2 v,v0 r//axis,angle\n){v0 s=sin(r),c=cos(r)\n ;return m3(m2(c)+outerProduct(v,v)*(1.-c)+m2(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)+m3(1)-m3(m2(1));}\nm3 translate(v2 t){m3 m=m3(1);m[3]=v3(t.xyz,1);return m;}\n\n/**/ //end__: compatibilityCore\n/**/ // start: openGl NaN-precision\n/*\nexponent ==255 is reserved for Inf and NaN\nmantissa ==0   is   is Inf*(signBit*2-1)\nmantissa !=0        is NaN //(sign is irrelevant in opengl)\nNaN implies that you got too close to an asymptote\nsome languages use different NaN mantissas to differentiate between types/signs of asymptotes\nopengl is not such a language. All opengl NaN are created equal.\n\n32bit signed float bounds: //calculated with win7 64bit calculator:\nLargest  positive  2.-pow(2.,-23.)*pow(2., 127.)==3.4028234663852885981170418348451e38\nSmallest positive    normal        pow(2.,-126.)==1.1754943508222875079687365372222e-38\nSmallest positive subnormal        pow(2.,-150.)==7.0000000000000000000000000000000e-46 \nSmallest negative           = -1*(1+.5+.25+.125+...+ pow(2,-23)*pow(2.^127.)\n                           ~=-pow(2,128) //sum rounds up to 2. in the given precision?\n                            =-3.403e38\nlargest negative normal     =-pow(2.,-127.) //safe assertion???\n//useless for calculations with any predictive property.\n\n#define exp2(a) pow(2.,a) [2<<a]\nhttps://en.wikipedia.org/wiki/Machine_epsilon\ngives an upper bound on the relative rounding error in floating point arithmetic\nmake [exponent] SMALLER, to make [epsilon] larger\n*/\n#define Exponent floor(8. )  //comment values are for exponent=8.\n#define Mantissa floor(23.)  //comment values are for mantissa=23.\nconst v0 mEpsilon   =exp2(-Mantissa);//=1.1920928955078125000000000000000e-7\nconst v0 mEpsilonRec=exp2(+Mantissa);//=8388608.;  \nconst v0  epsilon   =exp2(-Mantissa+Exponent);//=0.000030517578125 ==pow(2.,-23.+8.)\nconst v0  epsilonRec=exp2(+Mantissa-Exponent);//=32768.=mEpsilonRec/pow(2.,8.)=pow(2.,23.-8.)\n#define zFar epsilonRec\n//abs(safeInt)==v0(i0(abs(safeInt)))\nconst v0  safeInt   =exp2(+Mantissa+max(Exponent,8.));//=2147483648.=8388608.*pow(2.,8.)\nconst v0  safeIntRec=exp2(-Mantissa-max(Exponent,8.));//=4.656612873077392578125e-10 ;\n#undef Exponent\n#undef Mantissa\n\n/**/ // end__: openGl NaN-precision\n/**/ //start AD structure\n/*\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a v3 trough many functions:\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dt²=+2th derivative (and dt)\n[d***]dt³=+3th derivative (and dt adnd dt²)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n/**/\n//struct d(v0 a;);//just use v0 instead of a [d]  struct\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt²,dt³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt²,dt³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt²,dt³\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00 D00(v2   a){return d00(a.x,a.y,a.z);}\nv2   V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0 D0(v1  a){return d0(a.x,a.y);}\nv1 V1(d00 a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\nST c0  {d0   x                     ;};//1 domains t,dt\nST c00 {d00  x                     ;};//1 domains t,dt,dt²\nST c000{d000 x                     ;};//1 domains t,dt²dt³ \nST c1  {d1   x;d1   y              ;};//2 domains t,dt    \nST c11 {d11  x;d11  y              ;};//2 domains t,dt,dt² \nST c111{d111 x;d111 y              ;};//2 domains t,dt,dt²dt³ \nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST c22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dt² \nST c222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dt²dt³  \nST c3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST c33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dt²   \nST c333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dt²,dt³  \n//above structure may be inefficient, but its user friendlyness first\n//I tried many other structures for AD, this one still wins\n//I am still not perfectly sure about above srtucture\n//i think it enables you to define:\n//-  https://en.wikipedia.org/wiki/Multivariable_calculus#Applications_and_uses\n//-  https://en.wikipedia.org/wiki/Differential_dynamic_programming\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\nv2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n//struct ADm2{v2 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n//a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct cN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\nc000 da_domain3(v0 p){return c000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nc111 da_domain3(v1 p){return c111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nc222 da_domain3(v2 p){return c222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.y,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nc333 da_domain3(v3 p){return c333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\n\nc00  da_domain2(v0 p){return c00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nc11 da_domain2(v1 p){return c11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nc22 da_domain2(v2 p){return c22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nc33 da_domain2(v3 p){return c33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\nc0   da_domain1(v0 p){return c0(d0  (p,1.));}//1 derivatives over 1d\nc1 da_domain1(v1 p){return c1//1 derivatives over 2d [wikipedia contour_Line]\n (d1(p.x,v1(1,0))\n ,d1(p.y,v1(0,1)));}\nc2 da_domain1(v2 p){return c2//1 derivatives over 3d\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))\n,d2(p.z,v2(0,0,1)));}\nc3 da_domain1(v3 p){return c3//1 derivatives over 4d\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))\n,d3(p.w,v3(0,0,0,1)));}\n/*\nimplementation example for the d2,d222 structs\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize\n ;c2 u=suab(p,s)//u=abs(p)-s \n ;return ma(u)  //return max(u.x,u.y);}//for 1 derivative over 3d space\nd222 fBoxCheap(c2 p,v2 s){;return ma(suab(p,s));}//for 3 derivatives over 3d space\n*/\n/**/ // end__: AD structure\n/**/ // start: AD-functions \n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\nFor a monadic structure, we imply prefix notation for everything:\nInfix notation is a 2000 year old dumb idea;\nGood enough for abacuss multiplication, bad for log((a+b)/(c-d))\nmemo to self: initially I liked to sort functions by number of input params, but this fails\n- atan() takes 1 input, but its subroutines ad()po()di() take more than 1 input./**/\n\n//negation identity: max(a,b)=-min(-a,-b), makes definition of negation the top oriority\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\nc0   ne(c0   a){return c0  (ne(a.x));}\nc00  ne(c00  a){return c00 (ne(a.x));}\nc000 ne(c000 a){return c000(ne(a.x));}\nc1   ne(c1   a){return c1  (ne(a.x),ne(a.y));}\nc11  ne(c11  a){return c11 (ne(a.x),ne(a.y));}\nc111 ne(c111 a){return c111(ne(a.x),ne(a.y));}\nc2   ne(c2   a){return c2  (ne(a.x),ne(a.y),ne(a.z));}\nc22  ne(c22  a){return c22 (ne(a.x),ne(a.y),ne(a.z));}\nc222 ne(c222 a){return c222(ne(a.x),ne(a.y),ne(a.z));}\nc3   ne(c3   a){return c3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc33  ne(c33  a){return c33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc333 ne(c333 a){return c333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n//floor(a) is a basis-function for mod() and fract()\n//because mod() is a mess, so i needed a trueMod(fract())\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies above 2 lines to 2 defines\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to lultiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0   fl(d0   a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1   fl(d1   a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2   fl(d2   a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3   fl(d3   a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n\n//also, since mod(a,1.) NEVER returns 1 (its a halfoven interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\n/*    //residue from AD16 on mod() derivatives                   \n//mo() ideally should be replaced by fractd(), but that adds 1dvd() and 1muld()\n//... but chain rule division (reciprocal product rule) on a custom type is so bad.\n//... that for derivative arithmetic, mod(a,b) outperforms mu(fractd(divd(a,b)),b)\n//v4 mod(v4 a,v4 b){return v4(mod(a.x,b.x),mod(a.yzw,1.));}\n//v4 mod(v4 a,v1 b){return v4(mod(a.x,b  ),mod(a.yzw,1.));}\n//v4 mod(v1 a,v4 b){return v4(mod(a  ,b.x),0,0,0        );}\n//#define modo(a,b) fract(a/b)*b /*what mod(a,b) actually does\n#define may fract(a.b));}\n#define maz mod(a.a,b),may\n#define mab mod(a.a,b.a)\n//v0 mo(v0 a,v0 b){return mod(a,b);}                        \nd2 mo(d2 a,v0 b){return d2(maz\nd1 mo(d1 a,v0 b){return d1(maz\nd0 mo(d0 a,v0 b){return d0(maz\nd0 mo(d0 a,d0 b){return d0(mab,may\nd2 mo(d2 a,d0 b){return d2(mab,may\nd2 mo(d2 a,d2 b){return d2(mab,may\nd2 mo(d2 a,d1 b){return d2(mab,may\nd2 mo(d0 a,d2 b){return d2(mab,v2(0));}\nd2 mo(d1 a,d2 b){return d2(mab,v2(0));}\nd2 mo(v0 a,d2 b){return d2(mo(a,b.a),v2(0));}\nd1 mo(v0 a,d1 b){return d1(mo(a,b.a),v1(0));}\nd0 mo(v0 a,d0 b){return d0(mo(a,b.a),   0.);}\n*/                     \nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,v3 o){v0 O=a.c*o.x\n ;return D000(o.xyyy*v3(1.,a.b,a.c,a.d)\n +v3(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\n//above so far is only useful for sin() or cos()\nv3 siD(v0 a){return v3(+si(a),+co(a),-si(a),-co(a));}\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\n\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nd111 si(d111 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd111 co(d111 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=si(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd222 co(d222 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=co(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd333 si(d333 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=si(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=si(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\nd333 co(d333 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=co(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=co(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\n//once more a clear sign of my structure extending poorly.\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//c111 si(c111 a){return c111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n/*\n//atan is implemented, but further below, it needs more subroutines:\ntodo, all the trigonometry functions with glES100 to gles300 porting\n*/\nv0 rec(v0 a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n\n\n//single parameter operations are MUCH simpler here:\nv0 sr(v0 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\n\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n\n//ex(d00) seems to be fine\nd00 ex(d00 a){return d00(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n);}\n//exp2() is not THAT simple here???\n\n//ex(d000) seems to be fine\nd000 ex(d000 a){return d000(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b\n+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}\n//exp2() is not THAT simple here.\n\n#define Omg(f,x) x=f(d00(a.a,a.b.x,a.c.x))\n#define OMg(f,x) x=f(d000(a.a,a.b.x,a.c.x,a.d.x))\nd11 ex(d11 a){\n ;d00 Omg(ex,x)\n ;d00 Omg(ex,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ex(d22 a){\n ;d00 Omg(ex,x)\n ;d00 Omg(ex,y)\n ;d00 Omg(ex,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ex(d33 a){\n ;d00 Omg(ex,x)\n ;d00 Omg(ex,y)\n ;d00 Omg(ex,z)\n ;d00 Omg(ex,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\n\nd111 ex(d111 a){d000 OMg(ex,x);d000 OMg(ex,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ex(d222 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ex(d333 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z);d000 OMg(ex,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd1 ln(d1 a){return d1(log(a.a),a.b/a.a);}\nd2 ln(d2 a){return d2(log(a.a),a.b/a.a);}\n//        pow (x,y) ex(   ln(x)*y )//wait till we define mu()\n//#define powd(x,y) ex(mu(ln(x),x))//wait till we define mu()\n\n//ln() 2nd and 3rd derivative imply quotientRule\n//i hope i did this corretcly. last time i did this 15 years ago.\nd00 ln(d00 a){return d00(\n ln(a.a) //t\n,a.b/a.a //dt\n,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dt²\nd000 ln(d000 a){return d000(\n ln(a.a)//t\n,a.b/a.a//dt\n,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dt²\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))\n /(a.a*a.a*a.a*a.a)//dt³\n    //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() overlaps a lot with di() the a are only off by 1.\n //ln() is a special case of di() == one antiderivative higher.\n\nd111 ln(d111 a){d000 OMg(ln,x);d000 OMg(ln,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ln(d222 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ln(d333 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z);d000 OMg(ln,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\nv0 sg(v0 a){return sign(a);}\nv1 sg(v1 a){return sign(a);}\nv2 sg(v2 a){return sign(a);}\nv3 sg(v3 a){return sign(a);}\nd0   sg(d0   a){return   d0(sign(a.a),0.);}\nd00  sg(d00  a){return  d00(sign(a.a),0.,0.);}\nd000 sg(d000 a){return d000(sign(a.a),0.,0.,0.);}//super trivial (if you ignore the discontinuity)\nd111 sg(d111 a){d000 OMg(sg,x);d000 OMg(sg,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 sg(d222 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 sg(d333 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z);d000 OMg(sg,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nd2 sg(d2 a){\n   ;d0 x=sg(d0(a.a,a.b.x))\n   ;d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z))      \n   ;return d2(x.a,v2(x.b,y.b,z.b));}\n\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd00 ab(d00 a){return d00(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\nd000 ab(d000 a){return d000(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}\nd111 ab(d111 a){d000 OMg(ab,x);d000 OMg(ab,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ab(d222 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ab(d333 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z);d000 OMg(ab,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n//ST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nc2 ab(c2 a){\n ;d2 x=ab(a.x)\n ;d2 y=ab(a.y)\n ;d2 z=ab(a.z)\n ;return c2(x,y,z);}\n\n//i am not too sure about my implementation on fractd();\n//the hell, just use mod() instead, mod() has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)==0.0)\nv0 djum(v0 a){return mix(a,-1.,step(fract(a),0.)*step(0.,fract(a)));}\nv1 djum(v1 a){return v1(djum(a.x),djum(a.y));}\nv2 djum(v2 a){return v2(djum(a.x),djum(a.y),djum(a.z));}\n//i should definitely define this by fract, and not by floor.\n//because fm-modulation taught me that i need fract() a lot more than floor()\nd2 fractd(d2 a){return d2(floor(a.a),djum(a.b));}\nd1 fractd(d1 a){return d1(floor(a.a),djum(a.b));}\nd0 fractd(d0 a){return d0(floor(a.a),djum(a.b));}\n//very slightly lower precision? rarely relevant. fract() has great precision on float!\n#define floord(a) subd(a,fractd(a))\n\n//todo, higher derivatives for fract()\n\n/*\nmathematical ifentity\nof fract(x) \nis mod(x,1.)\nis mod(x,1.)\n*/\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mod() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\n\n#define sux b){return a-b;}\n#define sun(n,f,g) n f(n a,v0 g n f(v0 a,n g n f(n a,n g\n\nsun(v1,su,sux)\nsun(v2,su,sux)\nsun(v3,su,sux)     \nv0 su(v0 a,v0 sux\nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\nd3 su(v0 a,d3 b){return d3(a  -b.a,-b.b);}\nd3 su(d3 a,d3 b){return d3(a.a-b.a,-b.b);}\n//this d000 to d222 structure hints at inefficient structure\n//glide-translations along multiple domains:\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n/*\nc3333 su(c3 p,v3 s){return c333\n(su(p.x,s.x)//su(d3,v0)\n.su(p.y,s.y)//su(d3,v0)\n,su(p.z,s.z)//su(d3,v0)\n,su(p.w,s.w));}//su(d3,v0)*/\nd000 su(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³\n#define omG(f,x) f(d000(a.a,a.b.x,a.c.x,a.d.x),d000(b.a,b.b.x,b.c.x,b.d.x))\nd111 su(d111 a,d111 b){d000 xa=omG(su,x);d000 ya=omG(su,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 su(d222 a,d222 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n#define oMG(f) f(p.x,s.x),f(p.y,s.y)\nc3 su(c3 p,v3 s){return c3(oMG(su),su(p.z,s.z),su(p.w,s.w));}\nc2 su(c2 p,v2 s){return c2(oMG(su),su(p.z,s.z));}\nc1 su(c1 p,v1 s){return c1(oMG(su));}\nc0 su(c0 p,v0 s){return c0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\nd3 suab(d3 p,v0 s){return su(ab((p)),s);}                     \nd2 suab(d2 p,v0 s){return su(ab((p)),s);}\nd1 suab(d1 p,v0 s){return su(ab((p)),s);}\nd0 suab(d0 p,v0 s){return su(ab((p)),s);}\n\nc3 suab(c3 p,v3 s){return c3(suab(p.x,s.x),\n                                   suab(p.y,s.y),\n                                   suab(p.z,s.z),\n                                   suab(p.w,s.w));}\nc2 suab(c2 p,v2 s){return c2(suab(p.x,s.x),\n                                   suab(p.y,s.y),\n                                   suab(p.z,s.z));}\nc1 suab(c1 p,v1 s){return c1(suab(p.x,s.x),\n                                   suab(p.y,s.y));}\nc0 suab(c0 p,v0 s){return c0(suab(p.x,s));}\n//addition is negated substraction:\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\n#define mux b){return a*b;}\nsun(v1,mu,mux)\nsun(v2,mu,mux)\nsun(v3,mu,mux)      \nv0 mu(v0 a,v0 mux\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\n#define mutal(f) b){return f(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 mutal(d0)\nd1 mu(d1 a,d1 mutal(d1)\nd1 mu(d0 a,d1 mutal(d1)\nd1 mu(d1 a,d0 mutal(d1)\nd2 mu(d2 a,d2 mutal(d2)\nd2 mu(d2 a,d0 mutal(d2)\nd2 mu(d0 a,d2 mutal(d2)\n\nd3 mu(v0 a,d3 b){return d3(a  *b.a,a  *b.a+a  *b.b);}\nd3 mu(d3 a,d3 b){return d3(a.a*b.a,a.b*b.a+a.a*b.b);}\nc2 mu(c2 p,v2 s){return c2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nc1 mu(c1 p,v1 s){return c1(mu(p.x,s.x),mu(p.y,s.y));}\nc0 mu(c0 p,v0 s){return c0(mu(p.x,s));}\nc2 mu(c2 p,v0 s){return mu(p,v2(s));}//special utility cases come last\nd000 mu(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\nd111 mu(d111 a,d111 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 mu(d222 a,d222 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n\n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\n#define dix b){return a/b;}\nsun(v1,di,dix)\nsun(v2,di,dix)\nsun(v3,di,dix)      \nv0 di(v0 a,v0 dix\nd3 di(d3 a,v0 b){return d3(atc\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd3 di(v0 a,d3 b){return d3(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\nd3 di(d3 a,d3 b){return d3(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n//d2 divd(d2 a,d1 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//d2 divd(d2 a,d  b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n\nd000 di(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\nd111 di(d111 a,d111 b){d000 xa=omG(di,x);d000 ya=omG(di,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 di(d222 a,d222 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),x))\n\n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\n\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.       \n#define xmi b){return min(a,b);}\n#define ma(a,b) ne(mi(ne(a),ne(b)))\nv0 mi(v0 a,v0 xmi\nv1 mi(v1 a,v1 xmi\nv2 mi(v2 a,v2 xmi\nv3 mi(v3 a,v3 xmi\n//component-wise min() aliases: \nv0 mi(v1 a){return mi(a.x,a.y);}\nv0 mi(v3 a){return mi(mi(a.xy),mi(a.zw));}\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n\nd000 mi(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\nd111 mi(d111 a,d111 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 mi(d222 a,d222 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n\nc2 mi(c2 a,v2 p){return c2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nc2 madm(c2 a,v2 p){return c2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\nc2 madm(c2 a,v0 p){return madm(a,v2(p));}\nc2 mi(c2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(c2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(c2 a){return madm(a.x,a.y,a.z);}\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n#define p2(a) mu(a,a)\n//#define p2(a) ex(a,2.)\n//#define p3(a) ex(a,3.)\n#define p3(a) mu(a,mu(a,a))\n#define p4(a) ex(a,4.)\n//In terms of 3rd derivatives, it is deinitely slower    to do ex(a,2.), than mu(a,a)\n//In terms of 3rd derivatives, it is likely    slower    to do ex(a,3.), than mu(a,mu(a,a))\n//In terms of 3rd derivatives, it is possibly  faster(!) to do ex(a,4.), than mu(mu(a,a),mu(a,a))\n//- the exponentRule is less complex than the productRule, even with only one derivative\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)\n//- ProductRule 3rd derivative   is  7add+15mult+0pow()  \n//- ProductRule 3rd derivative*2 is 14add+30mult+0pow()  \n//- ProductRule 3rd derivative*3 is 21add+45mult+0pow()\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)                 \n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\n\n/**/\nv0 dt(v0 a,v0 b){return dot(a,b);}v0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}v0 dt(v3 a,v3 b){return dot(a,b);}\n\nd000 dt(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\nd111 dt(d111 a,d111 b){d000 xa=omG(dt,x);d000 ya=omG(dt,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 dt(d222 a,d222 b){d000 xa=omG(dt,x);d000 ya=omG(dt,y);d000 za=omG(dt,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n/*\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt²,dt³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt²,dt³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt²,dt³\n\nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\n/**/                           \n //;d2 c=p2(p.z) //1 derivative over 3 domains\n //;3 domain-1stDerivatives are stored in .b\n //.a is a 1d point? how does that make sense?                       \n                           \n/*\n//dotProduct of a and b, 1 derivative over 1 domain\n//the mindMelter here is that a dorProduct folds to 1 domain\n//but the inputs likely have more domains than that\nd0 dt(c0 a,c0 b){\n   ;d0 r=\n    return a; //totally false function\n;}//dotProduct of a and b, 1 derivative over 1 domain\n\n                           /*\n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(c1 a,c1 b\n){d0 r=D0(v1(    \n    dot(a.a,b.a)\n             ,0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 2 domains\n                           \n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(c2 a,c2 b\n){d0 r=D0(v1(dot(a.a,b.a),0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 3 domains \n                           \n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(d3 a,d3 b\n){d0 r=D0(v1(dot(a.a,b.a),0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 4 domains\n                        \n/**/\n                           \n#define dd(a) dt(a,a)\n                           \n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(c1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(c2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){v0 q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(c2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n//atan2() is a bit tricky, thankfully commonly only defined for v1.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n//wrapping for namespace sake, for automatic differentiation:\n//first defivative of f(x)=atan(x) is f´(x)=1/x*x+1\nd2 ata(d2 a\n){v0 b=atan(a.a)\n ;d2 e=mu(a,a)\n ;e=ad(e,1.)\n ;e=di(1.,e)//e=divd(1.,addd(mu(a,a),1.));\n ;return d2(b,e.b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(y/x);\n if(y >0.)return  pi*.5-atan(x/y);\n if(0.>y )return -pi*.5-atan(x/y);\n if(0.>x )return  pi   +atan(y/x);\n return 0.;}\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\n//d1 atand(d1 a,d1 b){return a;\n\n//branching code is always faster than branchless code\n//, but the branchless code*s step() can be made into a smoothstep.\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(a> 0)?b:c\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(a< 0)?b:c\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(a==0)?b:c\n#define equals(a,b,c)    mix(b,a,step2\n//(a!=0)?b:c\n#define unequal(a,b,c)   mix(a,b,step2\n//(a>=0)?b:c  \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(a<=0)?b:c  \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n\n#define sM b){return smoothstep(b,-b,a);}\nv0 ss(v0 a,v0 sM                 \nv1 ss(v1 a,v0 sM\nv2 ss(v2 a,v0 sM\nv3 ss(v3 a,v0 sM\nv3 ss(v3 a,v3 sM\nv3 ss(v0 a,v3 b){return smoothstep(b,-b,v3(a));}\n\nv0 add(v1 a){return a.x+a.y;}\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}v0 suv(v1 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n#define segment2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))\n//sqared orthogonal projection ,segment()subroutine ,is squared distance\n#define segments(a,b,c) (segment2((a-b),(c-b)))\n//offset segment2(a,c) by -b\n#define segment(a,b,c) sqrt(segments(a,b,c))\n//pointAdistance to (diagonal) lineSegment from B to C\n\nv0 sh4(v0 x){return x*x*x*(x*(x*6.-15.)+10.);}\n\nm1 rot2D(v0 r){v0 c = cos(r), s = sin(r);return m1(c, s, -s, c);}\n\n//hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nv1 hash(v1 p){p=v1(dot(p,v1(127.1,311.7)),dot(p,v1(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}//returns -.5 to 1.5. i think.\nv0 noise(in v1 p\n){const v0 K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const v0 K2 = 0.211324865 // (3-sqrt(3))/6;\n ;v1 i=floor(p+(p.x+p.y)*K1)\n ;v1 a=p-i+(i.x+i.y)*K2\n ;v1 o=(a.x>a.y) ? v1(1.0,0.0) : v1(0.0,1.0) //v1 of = 0.5 + 0.5*v1(sign(a.x-a.y), sign(a.y-a.x));\n ;v1 b=a-o+K2\n ;v1 c=a+u2(K2)\n ;v2 h=max( 0.5-v2(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;v2 n=h*h*h*h*v2( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, v2(70.0));}\nv0 noise01(v1 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\nv0 dtoa(v0 d,v0 a){return sat(1./(clamp(d,1./a,1.)*a));}\n\nv0 sdAxisAlignedRect(v1 uv, v1 tl, v1 br//rounded rectangle\n){v1 d = max(tl-uv, uv-br)\n ;return length(max(v1(0.0), d)) + min(0.0, max(d.x, d.y));}\n\n\n\n\n// 0-1 1-0\nv0 smoothstep4(v0 e1, v0 e2, v0 e3, v0 e4, v0 val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\nv0 rand(v1 co){return fract(sin(dot(co.xy ,v1(12.9898,78.233))) * 43758.5453);}\nv0 rand(v0 n){return fract(cos(n*89.42)*343.42);}\nv0 paperbleed(v1 u){return (2.+rand(u.y)+rand(u.x))*30.;}//ink bleeds on papyrus.\n\n/**/ // end__: common aliases\n/**/ // start: iDiegeticUI v2 header:\n/*\n\nself  : https://www.shadertoy.com/view/WtfGDM\nparent: https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\nparent: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\nparent: https://www.shadertoy.com/view/4dtSRn (multiple dots)\nparent: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\nreusable drag and drop framework. \n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\n\n/**/ //end__ diecetic_UI_2 header\n/**/ //start diecetic_UI_2 \n/*\n\n/*\nmodifiables for diecetic_UI_2\nare used by the buffer [iDiegeticUI]\n*/\nconst v0 maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst v0 UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst v0 statePos = maxCount;\nconst v0 offsetPos = maxCount + 1.;\nconst v3 deleteRect=v3(0.,0.,40.,40.);\n\n\nbool inRect(v1 u, v3 b\n){b.xyzw-=u.xyxy\n ;return mi(b.zy-b.xw)<mi(b)\n ;return min(b.z-b.x,b.y-b.w)<mi(b) ;}\n\nvoid rToD(v0 d,inout v0 r,inout v3 state,inout v0 f,inout v3 o,v3 center,v3 m\n){if(d<r\n ){r=d\n  ;state.x=f\n  ;o=center-m;}}\n\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*v2(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nv2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nv2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbowt(v0 a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(v2(1.),sat(a(-c.x)),c.y);}\nv2 angleToColor(v2 c){ToRgb(rainbow)//cos-mix\n//v2 hsv2rgb(v2 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nv2 hsv2rgb(const v2 c){return c.z*mix(v2(1),sat(abs(fract(c.x+v2(3,2,1)/3.)*6.-3.)-1.),c.y);}\nv2 rgb2hsv(v2 a){v3 K=v3(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;v3 P=mix(v3(a.bg,K.wz),v3(a.gb,K.xy),step(a.b,a.g));v3 Q=mix(v3(P.xyw,a.r),v3(a.r,P.yzx),step(P.x,a.r))\n ;v0 D=Q.x-min(Q.w,Q.y),E=1e-10;return v2(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n\n#define tiny .00001\n\nv1 gLLxX(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;if (dotperp==0.)return A\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nv1 gLLxX0(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;//if (dotperp==0.)return A\n ;//dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n#define Over 0.\n#define Atop 1.\n//#define ut(a,b) (a*(1.-b))\nv3 ut(v3 a,v0 b){return a*(1.-b);}\nv2 ut(v2 a,v0 b){return a*(1.-b);}\nv1 ut(v1 a,v0 b){return a*(1.-b);}\nv0 ut(v0 a,v0 b){return a*(1.-b);}\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//v3 pdOut(v31 a,v31 b){return ut(b,a.b);}\n\nv3 pdOut(v3 a,v3 b){return ut(b,a.w);}\nv3 pdOver(v3 a,v3 b){return ut(b,a.w)+a;}\nv3 pdAtop(v3 a,v3 b){return ut(b,a.w)+a*b.w;}\nv3 pdXor(v3 a,v3 b){return ut(b,a.w)+v3(ut(a,b.w));}\nv3 pdIn(v3 a,v3 b){return v3(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//https://en.wikipedia.org/wiki/Alpha_compositing\nv3 aOverB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a+b*(1.-a));}\n//v1 aOverB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nv3 aXorB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a*(1.-b)+b*(1.-a));}\n//v1 aXorB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a*(1.-b)+b*(1.-a));}\n//return color corrected r\nv2 ff_filmic_gamma3(v2 r){v2 x=max(v2(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}     \n\n                          \n//project point [a] onto line trough vecN(0) and vecN([b])\nv1 project(v1 a,v1 b){return b*dot(a,b)/dd(b);}\nv1 projectS(v1 a,v1 b){return b*sat(dot(a,b)/dd(b));}\n//v2 project(v2 a,v2 b){return a*dot(a,b)/dd(b);}\n//v3 project(v3 a,v3 b){return a*dot(a,b)/dd(b);}\n//shortest distance between point [a] and line trough vecN(0) and vecN([b])\n//v1 dLine(v1 a,v1 b){return a*dot(a,b)/dd(b);}\n\n//get 2/3 roots by http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  add(sign(b)*pow(abs(b),v1(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((v1(1,-1)*sqrt(d)-q)*.5) )\nv1 solveCubic2b(v0 a,v0 b,v0 c//https://www.shadertoy.com/view/XtdyDn\n){v1 p=v1(b-a*a/3.,a)\n ;v0 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(v1(a),b,c)//both return values are identical\n ;v0 v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return v1(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nv1 solveCubic2b(v2 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nv1 dQBezierSub(inout v1 u,inout v1 a,inout v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+v1(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(v2(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b))\n ;}\n\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(v1 a,v1 b,v1 c){return length(norma(a-b)-norma(a-c))<.001;}\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadParabola(v1 u,v1 a,v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuad(v1 u, v1 a, v1 b, v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadGeneral(v1 u, v1 a, v1 b, v1 c,v1 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) m1(cos(a),sin(a),-sin(a),cos(a) )\n\n//return p1 of quadratic bezier, when given start, end and arclength\nv1 knee(v1 p0,v1 p2,v0 L//https://www.shadertoy.com/view/4ltyWr\n){v1 l = p2-p0\n ;v0 h = sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L)\n ;return (p0+p2)/2.+sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L)*norma( v1(-l.y,l.x) )     \n ;}\n                          \n/**/ //--- start AD-/mercury.sexy/hd_sdf\n\n//Below are translations of the hg_sdf library\n//to use the above [Derivative Arithmetic]\n//mostly just in prefix-notation\n//but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics.\n\n//return distance to unit sphere\nd2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);;}\n//return distance to infinite line segment\nd2 fRay(c2 p){p.x.a=mix(0.,p.x.a,step(p.x.a,0.));\n d2 q=sd(p.x,p.y,p.z);return su(q,1.);}//this might be \"broken\" now.\n//fRay() was an error that I chose to keep.\n\n//return distance to box size (s),\n//... corners extrude, keeping all agngles, underestimating distances.\nv0 fBoxCheap(v2 p,v2 b\n){v2 q=abs(p);q=q-p//mirror clamp\n ;return max(max(q.x,q.y),q.z);}\nd2 fBoxCheap(c2 p,v2 s\n){c2 u=suab(p,s)//mirror clamp\n ;return madm(u);}  \n//return distance to box size (s), corners extrude to rounded spheres.\nv0 fBox(v2 p,v2 s\n){v2 d=abs(p)-s//mirror clamp\n ;v0 a=length(max(d,0.))//rounded corners\n ;v2 q=min(d,0.)//clamp\n ;v0 b=max(max(q.x,q.y),q.z)//keep largest of 3\n ;return a+b;}//add //hg_sdf\nd2 fBox(c2 p,v2 s){//v3 s=v3(1.5,.5,1.5);\n c2 d=suab(p,s);//mirror clamp\n d2 a=sd(ma(d,0.));//rounded corners\n c2 q=mi(d,0.);//clamp\n d2 b=madm(q);//keep largest of 3\n return ad(a,b);}//add\n\nv0 fOpUnionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz.\nv0 fOpIntersectionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,v0 r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\nv0 pMod1(inout v0 p,v0 s){p/=s\n;v0 c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//v3 c=floord4(p);//c=subd(c,.5);//v0 c=floor((p)+.5);\n;p=ad(p,.5);p=fractd(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}\n       \n/*\nhttps://en.wikipedia.org/wiki/Holonomic_function\nhave closed forms in derivatives and antiderivatives.\n*/\n\n//Goursat Surface is an implicit surface with VERY high [rootMultiplicity\n//it is THE goto if you want high exponents, high precision and high performance\n//because it excessively pow(a,2.) and pow(a,4.) over 3 domains\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n//goursat has not good LipschitzContinuity, scales with distance to singularities!\nd2 sdGoursat(c2 p,v3 m//https://www.shadertoy.com/view/XlV3Dy\n){d2 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d2 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d2 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n                    \nd3 sdGoursat(c3 p,v3 m//4d goursat surface or some sort of shadow?\n){d3 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d3 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d3 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n\n//explicit type dual_v0 dd()\n#define dd2(a,b) ad(p2(a),p2(b))\n\n//known bug:                          \n//r.y==0. results in nan-noise on many cases.//sdUnterprim() has the preprocessor sdUberprim()             \n//yeah, because r.y then sets the thickness of a wall\n\n                          \nd2 sdUnterprim(c2 u,v2 r,v3 m//m is [s]Uberprim\n){c2 d=su(ab(u),m.xyz)\n  //sadly this lower bound for thickness must be this high (for many shape-cases)\n ;if(abs(r.y)<.0004)r.y=.0004//worksafe: abs(wall thickness)>=mEpsilon\n ;v0 t=mu(-2.,m.z)\n ;v0 s=t\n ,w=dd2(r.z,t)\n ;//w=ma(w,.1)\n ;t=di(t,w)\n ;w=di(r.z,w)\n ;d2 q=dd2(ma(d.x,0.),ma(d.y,0.))\n ;q=sr(ab(q))\n ;q=su(q,r.x)\n ;q=ad(q,mi(0.,ma(d.x,d.y))) \n ;//hole support: without this line, all results are convexHulls/holeLess\n #ifndef CONVEX    \n ;q=ab(q)\n ;q=su(q,m.w)\n #endif \n ;d2 f=su(u.z,m.z)\n ;d2 i=mu(q,w)\n ;i=ad(i,mu(f,t))  \n ;i=mi(i,1.)\n ;i=ma(i,0.)\n ;d2 x=su(q,mu(r.z,i))\n ;d2 y=su(f,mu(s,i))\n ;d2 h=ad(u.z,m.z)\n ;d2 g=ma(su(q,r.z),0.)\n ;d2 e=ma(q,0.)\n ;d2 c=dd2(x,y)//dot(diag,diag)\n ;d2 a=dd2(g,h)//dot(h0,h0)\n ;d2 b=dd2(f,e)//dot(h1,h1) //f is read alone later on\n ;a=mi(a,b)\n ;a=mi(a,c)\n ;a=sr(ab(a))\n ;b=su(mu(f,w),mu(q,t))//is a dot()\n ;b=ma(b,d.z)\n ;b=sg(b)\n ;a=mu(a,b)\n ;return su(a,r.y);}\n// m: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nd2 sdUberprim(c2 p,v3 m,v2 r\n){m.xy=m.xy-r.x\n #ifdef CONVEX  \n ;r.x=su(r.x,r.y)\n #else\n ;r.x=su(r.x,m.w);m.w=su(m.w,r.y)\n #endif\n ;m.z=su(m.z,r.y)\n ;return sdUnterprim(p,r,m);}//https://www.shadertoy.com/view/MsVGWG\n                          \nv0 brushNoise(v1 v,v2 r//https://www.shadertoy.com/view/ltj3Wc\n){v+=(noise01(v)-.5)*.02\n ;v+=cos(v.y*3.)*.009\n ;v+=(noise01(v*5.)-.5)*.005\n ;v+=(noise01(v*min(r.y,r.x)*.18)-.5)*.0035\n ;return v.x;}\n\n//\"Magic Fractal\" for fungus/splatters (on metaball), by dgreensp\n//aka MAGIC_BOX-fractal: https://www.shadertoy.com/view/4ljGDd\nv0 fractalFungus(v2 p){p=1.-abs(1.-mod(p,2.));v2 f=v2(0,length(p),0)\n ;for(int i=kifsFungusIter;i>0;i--      \n ){p=abs(p)/(f.y*f.y)-kifsFungusSeed;f.z=length(p);f=v2(f.x+abs(f.z-f.y),f.zz);}return f.x;}\nv0 fractalFungus(v1 u\n){return fractalFungus(m2( .28862355854826727,.6997227302779844 , .6535170557707412\n                         , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                         ,-.9548821651308448 ,.26025457467376617, .14306504491456504)*v2(u,0));}         \n\n//lazy gradient debugger for sweep brush strokes  https://www.shadertoy.com/view/ltj3Wc\n//to be replaced with some smarter stuff\nv2 debugDist(v0 u){v2 r\n //;u*=pi *100.\n ;if(u>0.)r=mix(v2(0, 0,.5),v2(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.\n ;else    r=mix(v2(1,.5,.5),v2(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.\n ;r = mix(r,v2(0),sat(abs(u)))// falloff\n ;return r;}\n\n/*\nlazy animated checkerboard\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac v1 h){h=fract(h)\n#define gthv greaterThan(h,v1\n#define floatbool2);return v0(b.x==b.y);}\nv0 checkerBool(hfrac;return v0(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nv0 checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nv0 checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n/**/\n\n                          \n                          \n//pluginName= iCanvas\n//self: https://www.shadertoy.com/view/ltj3Wc   (brush stroke experiments)\n//crunched by ollj, minor featuures removed.\n//slowly assimilation, to be merged with BuffD\n//duroing that it lives in the sump of the commontap\n//produce a line with brush strokes. the inputs are such\n//that you can apply it to pretty much any line; the geometry is separated from this function.\nv2 colorBrushStroke(v1 u,v2 r,v3 m,v1 p,v0 w, v0 sdGeometry, v2 inpColor, v3 bc//brushColor\n){w=(u.y/w)// position along the line. in the line is 0-1.\n ;if(false ){ //important for uv debugging\n  ;//return mix(inpColor, v2(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n  ;//return mix(inpColor, debugDist(u.y), dtoa(sdGeometry, 1000.));// reveal Y\n  ;//return mix(inpColor, debugDist(w), dtoa(sdGeometry, 1000.));// reveal pos in line.\n  ;return mix(inpColor, debugDist(u.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n ;if(w>0.   // warp position-in-line, to control the curve of the brush falloff.\n ){v0 mouseX=m.x==0.?.2:(m.x/r.x)\n  ;w = pow(w, (pow(mouseX,2.)*15.)+1.5);}\n ;v0 n=0.//bleed noise\n +noise01(u*v1(min(r.y,r.x)*.2, 1.))//tiny\n +noise01(u*v1(79,1))//fine\n +noise01(u*v1(14,1))//coarse\n ;n*=dtoa(sdGeometry, 300.)/3.// keep stroke texture inside geometry.\n ;n=max(.08,n)//null-evasion\n ;v0 a=pow(n,max(0.,w)+.09)//add allows bleeding\n ;if(w>0.)a=max(0.,a-pow(w,0.5))//optioonal more fading\n ;a=sh4(a)+.4*smoothstep(17.,18.5,fractalFungus(v2(p,u.x)))//hermite+fungalFreckles\n ;bc.a=sat(a*bc.a*dtoa(sdGeometry,paperbleed(p)))\n ;return mix(inpColor,bc.xyz,bc.a);}\nv2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w\n){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align\n ;m1 rotMat =rot2D(lineAngle)\n ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.\n ;v1 T=m.xy*rotMat// top left\n ;v1 B=T+v1(0,W)// bottom right\n ;v1 l=u*rotMat\n ;l.x+=(noise01(l*1.)-.5)*.02\n ;l.x+=cos(l.y*3.)*.009//lp wave\n ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around\n ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.\n ;return colorBrushStroke((T-l)*v1(1,-1),r,M,u,W,d,c,b);}\n//https://en.wikipedia.org/wiki/Enso\n//japanese zen glyph, dualism-enlightenment circle, a signature that captures a moment in time.\nv2 humanizeEnso(v1 u,v2 R,v0 r,v0 lineLength//return: xy=u, z = radius\n){v1 v=u\n ;v.x+=v.y*.24/lineLength//offset circle along its path for a twisting effect.\n ;r+=(noise01(u*1.)-.5)*.04\n ;r+=sin(u.y*3.)*.019//lp wave\n ;v.x+=sin(u.x*30.)*.02\n ;v0 b=min(R.y,R.x)*.18\n ;v.x+=(noise01(u*b )-.5)*.0035//HP random noise makes it look less scientific\n ;v.x+=(noise01(u*5.)-.5)*.005 //random waviness like individual strands are moving around\n ;return v2(v,r);}\n//sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. \n//1=whole circle. 0=just a point.\n//u,canvasColor,brushColor,n,angle,sweepAmt,lineWidth\nv2 enso(v1 u,v2 R,v3 M,v2 c, v3 b,v1 o,v0 n, v0 a, v0 sweepAmt, v0 w\n){v1 v=u-o\n ;//v2 R=iResolution\n ;//v3 M=iMouse\n ;v0 angle = mod(atan(v.x, v.y)-a,tau)\n ;v0 d=n*tau//is far from euclidean due to all noise below. \n ;v=v1(n-length(v),angle* d/tau)\n ;v0 lineWidth1=w*mix(1.,.9,smoothstep(0.,d,v.y))//narrow end\n ;v2 h=humanizeEnso(v,R,n,d)\n ;v0 e=max(-length(u-o)+h.z,length(u-o)-h.z)\n ;e-=lineWidth1*.5// round off\n ;v2 r=v2(1),r2=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n ;if(angle>pi //modifies h, so above line cant go below\n ){v.y-=d\n  ;h=humanizeEnso(v,R,n,d)\n  ;v1 strokeStartPos=o+v1(sin(a),cos(a))*h.z      \n  ;e=length(u-strokeStartPos)-w*.5*1.// round off things just like in the line routine.\n  ;r=colorBrushStroke(h.xy,R,M,u,d,e,c,b);}\n ;return min(r,r2);}\nv2 brushCircle(v1 u,v2 r,v3 m,v2 c\n){return enso(u*v1(1),r,m,c,v3(0,0,0,.9)\n                           ,v1(0,0),// origin\n                            .6,.2,.5,.3)// radius, angle of brush start, sweep amt 0-1, width\n;}    \nv2 redline0(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return strokeLine(u,r,m,c,v3(v2(.8,.1,0),.9),v3(-1.4,yo-.4,2.6,yo-.4),.3);}\nv2 redline1(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),.4),v3(1.3,yo,-2.9,yo),.03);}\nv2 redline2(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),0.52),\n                           v3(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}\n//shitty subroutine is shitty\nv1 getuv_centerX(v1 fragCoord,v2 r, v1 newTL, v1 newSize\n){v1 ret = v1(fragCoord.x / r.x, (r.y - fragCoord.y)/r.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;v0 aspect = r.x / r.y\n ;ret.x *= aspect// orig aspect ratio\n ;v0 newWidth = newSize.x * aspect\n ;return ret + v1(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\nv3 ltj3Wc(v3 o, in v1 u,v2 r,v3 m\n){//v2 r=iResolution\n ;//v3 m=iMouse\n ;//o=v3(.01*magicBox(v2(u/iResolution.xy,iMouse.x)));return;//debug hash\n ;v1 uv=(u/ r.y * 2.0) - 1.\n ;u = getuv_centerX(u,r, v1(-1,-1), v1(2,2))// 0-1 centered\n ;v2 c=v2(1.,1.,0.875)// bg\n ;v0 dist\n ;// geometry on display...\n ;v0 yo = sin(-u.x*pi*0.5)*0.2\n ;c=redline0(u,r,m,c,yo)\n ;c=redline1(u,r,m,c,yo)\n ;c=redline2(u,r,m,c,yo)\n ;c=brushCircle(u,r,m,c)\n ;// paint blotches\n ;v0 blotchAmt = smoothstep(20.,50.,fractalFungus((u+12.)*2.))// smoothstep(40.,40.5, fractalFungus((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;c*=1.-blotchAmt\n ;// signature/stamp code removed\n ;c.rgb+=(rand(u)-.5)*.08// grain\n ;c.rgb=sat(c.rgb)//clamp\n ;v1 uvScreen=(u /r.xy * 2.)-1.\n ;//c*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return v3(c,1);}\n//note to self, this shader uses amt in leu of amount\n//, so the term \"sweep amt\" is somewhat coined in a new context\n                          \n\n//bellow code is RE7:\n                          /*\nrelativistic engine, with mutable/slower speedOfLight\nsimulates:\n- Delayed view of far objects\n- Doppler Red/blue shifts of color\n- Field of view distortion\n- Relativistic Length Contractions\n- Relativistic Time Dilation + (Doppler & proper velocity consequences)\n- blue-shifted light in the movement direction\n- , and red-shifted behind you. Because of doppler effect.\n- - hard shadows, that may move slower trough spacetime\n- Relativistic simultaneity view (SimultaneousEvents = 1. & cLag = 0.)\n- - To better see the train paradox:\n- - - put cLag & FOVAberrationOfLight to zero\n- - Explanations : While at rest in front of the tunnel\n- - ,watch the shrinked train entering and fitting in the tunnel\n- - ,But if you move along with the train, this one won't be shrinked\n- - ,but the tunnel will be\n- - ,the train will no longer fits in the tunnel. \n- - But... what happens if one close the tunnel doors at this time ?\n- Twin Paradox :\n- - Waiting for the train at a corner to make a whole return trip \n- - will take more time than moving along with it.\n-See the result of a blinking light, slowly drawing waves on the walls.\n-see correctly distorted field of view \n- ,by moving along with the train and notice\n- ,that it is not distorted anymore but the rest is\n- ,by setting the speed of light to a large number\n- ,the train will be exactly the same.\nblatantly false\n- shadows are unaffected by gravity\n- the black hole is a physical pitch black sphere, and as such it casts a SHARP shadow\nDoes not simulate:\n- Doppler additionnal shift when space is contracted, not sure...\n- The rotating object in the middle of the scene is not really affected by doppler color shifting\n- Mass of object\n/**/\n//ESDF keyboard layout is more compatible with more layputs (french)\n#define KEY_E 69.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_F 70.5\n//light settings\n#define cSpe 2.5\n//SpeedOfLight in meter/second\n//divides by /(cSpe*cSpe), so do not make it too large!\n#define cLag 1.\n//PhotonLatency [0..1]; zero=instant vision,makes easier to see how relativity affect time & space\n#define FOVAberrationOfLight 1.\n//take relative velocity of photons to camera & distort field of view\n//optical settings\n#define dopplerFactor .5\n//take player/object/light vel to shift color\n#define repeatDoppler 0\n//relativity\n#define LgthContraction  1.\n//shrink map along velocity vector at high speed\n#define TimeDilation 1.\n//speed map frame time at high speed\n#define SimultaneousEvents 1.\n//see past behind you, futur foward at high speed (not supposed to be observed)\n#define relativisticDoppler .2\n//take light source speed into account and their own time dilation\n//black hole\n#define BlackHoleMassFactor 2.\n#define AccretionDisk 2.\n//player and cam\n#define fishEye false\n#define FOV 1.3\n//1.57 = 90\n#define maxSpeed 2.4\n//do not go over speed of light it breaks time & space\n#define thrustForce 15.\n//player acceleration\n#define RayPrecision 1.\n#define MaxRayDist 9.0\n#define numMats 7\n#define numLights 3\n#define GI 1.3\n#define GIDist 2.5\n#define gravity v2(0.,-3.,0.)\n\n#define ab012(a,b)(a+b*v2(0,1,2))//desaturation.rgb kernel;b scales offset\n//v2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbow2(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\n//v2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbow2(v0 a){return rainbow2(a,1./3.);}\n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID == processedMaterial || processedMaterial == -1) { nextMat = matID; lastrDist = o;\n#define endMaterial() } if (o != lastrDist) rayMat = nextMat;  \n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\ni0 nextMat;\ni0 rayMat;\ni0 rayObj;\nv0 matSize;\nv0 lastrDist;\nv0 lastrDistObj;\nv3 volumetricCol;\n//BuffCoords of [RE] must be\n//- the same for [Re] and [Image] (therefore commonTab)\n//- mutually exclusive (within [Re] buffer]\n//- 0<=x<Resolution.xy\n#define RePos   0.\n#define RePosD  1.\n#define ReQua   2.\n#define RePosDD 3.  //not used by Image\n#define ReQuaD  4.  //not used by Image\n#define ReTime  5.\n#define ReCol   6.  //not used by Image\n#define ReCamR  7.  //not used by Image\n#define RePosDP 8.  //not used by Image\nv0 varWdth=1.;\n//#define ReTraT  9.  \n//v0 PROPER_D_POS = 8.;\n//v0 TRAIN_TIME = 9.;\n\n//v0 varWdth = 5.;\n/*\nv0 POS = 0.;\nv0 D_POS = 1.;\nv0 DD_POS = 2.;\nv0 QUAT = 3.;\nv0 D_QUAT = 4.;\nv0 TIME = 5.;\nv0 COLLISION = 6.;\nv0 CAM_PITCHYAW = 7.;\nv0 PROPER_D_POS = 8.;\nv0 TRAIN_TIME = 9.;\n*/\n//webgl1==openglEs100 does not allow arrays of structs (classes)\n//structs are replaced by namespace-wasting arrays of structparams: \n#define objNum 7\n//object array enum labels objectId\n#define oCam        0\n#define oCubeChil   1\n#define oCubeMy     2\n#define oBlackHole  3\n#define oTrain      4\n#define oTunnel     5\n#define oTunnelDoor 6\n//for below object properties;\nv3 [objNum] objRot;//rotation\nv2 [objNum] objPos;//position\nv2 [objNum] objVel;//velocity\nv2 [objNum] objSca;//scale\n//v0[objNum] objRad;//radius optimization\n//\n//lights have no labels\nv3 [numLights] oliCol;//colorIntensity;\nv2 [numLights] oliPos;//position\nv0[numLights] oliHal;//HaloResult\n//v0[numLights] oliSiz;//size\nv0 maxGISize;//what is this?\nv0 lorentzF;\n//mat3x3 LZLgthContract;\nv2 pos;\n//v2 dpos;\nv0 playerTime;\nint curObj = 0;//es100 error , first class array\nint minObjDepth = -1; \n    \n//Quaternions\n/*\n//asserting that length of quaternions are close to 1\n//we can norma() by dividing by the squaredLength dot(a,a)! \nv3 qn(v3 q){return q/dot(q,q);}\n/**/\nv3 qn(v3 q){return q/dot(q,q);}\nv3 aa2q(v0 b,v2 a// b must be normalized!\n){b*=.5;return qn(v3(a*sin(b),cos(b)));}\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nv3 q2aa(v3 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nv3 qm(v3 a, v3 b\n){v3 res= v3(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return norma(res);}\nv2 qr(v3 q,v2 v\n){v2 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n//RayMarchingPrimitivesBasic\nv0 sphere(v3 ray,v2 u, v0 radius\n){maxGISize = max(maxGISize,radius*ray.w)\n ;return ray.w*(length(ray.xyz-u)-radius);}\nv0 cylinderY(v3 ray,v2 u, v0 radius, v0 height\n){maxGISize=max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xz-u.xz)\n -radius, abs(ray.y-u.y)-height));}\nv0 cylinderZ(v3 ray,v2 u, v0 radius, v0 height\n){maxGISize = max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xy-u.xy)\n -radius, abs(ray.z-u.z)-height));}\nv0 cube(v3 ray, v2 u, v0 size\n){maxGISize = max(maxGISize,size*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}\nv0 line(v3 ray, v2 u, v0 size\n){maxGISize = max(maxGISize,size*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(ray.z,ray.y);}\nv0 box(v3 ray, v2 u, v2 size\n){maxGISize = max(maxGISize,length(size)*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}\n//DopplerShift\nv0 GetMatch(v2 c,v2 s,v0 t //col,shiftedFreq,targetFreq\n){s=log2(s)-t\n #if repeatDoppler >0  \n ;s=fract(s)\n ;c*=max(max(v2(0),1.-abs(s)*3.),1.-abs(s-1.)*3.)\n #else\n ;c*=max(v2(0),1.-abs(s)*3.)\n #endif\n ;return c.x+c.y+c.z;}\n//dopplerShiftFactor\nv2 dsf(v2 c,v2 f//all values of f are identical.\n){f*=v2(1.,1.257,1.58)\n ;v2 r=v2(1,2,4)/3.\n ;return v2(GetMatch(c,f,0. )+GetMatch(c,f,1.)*.3+GetMatch(c,f,-r.x)*.2\n             ,GetMatch(c,f,r.x) \n             ,GetMatch(c,f,r.y)+GetMatch(c,f,1.)*.5+GetMatch(c,f,r.z)*.25);}\nv2 dsf(v2 c,v0 f){return dsf(c,v2(f));}\n//v2 DopplerShift(v2 c,v0 s//color,speed\n//){return dsf(c,v2(cSpe/(cSpe-s*dopplerFactor)));}\nv3 Transform(int i,v3 p\n){p.xyz=objPos[i]-p.xyz\n ;p.xyz=qr(objRot[i],p.xyz)\n ;p.xyz/=objSca[i]\n ;p.w*=dot(v2(1),abs(objSca[i]))/3.//distance field dilation approx\n ;return p;}\nvoid ProcessCamPos(v2 u, v3 rot\n){objPos[oCam]= u\n ;objRot[oCam]=rot;}//es100 error , no array of class allowed\nv0 LorentzFactor(v0 v//velocity\n){v=(v*v)/(cSpe*cSpe)\n ;return 1./(sqrt(1.-min(v,.9999)));}\nv2 dpos;//relevant for each pixel of [RE] and [Image] \nvoid ProcessObjectPos(v0 time\n){objPos[oCubeMy]=v2(0) \n ;objRot[oCubeMy]=aa2q(time*2.,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oCubeMy]=v2(.8)//es100 error , no array of class allowed\n ;objPos[oBlackHole]=v2(5.,sin(time*0.2),-5.)//es100 error , no array of class allowed\n ;objRot[oBlackHole]=aa2q(time*2.,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oBlackHole]=v2(1)//es100 error , no array of class allowed\n ;objPos[oCubeChil]=v2(1)//es100 error , no array of class allowed\n ;objRot[oCubeChil]=aa2q(time*1.,norma(objPos[oCubeChil]))//es100 error , no array of class allowed\n ;//o_myCubeChildren.rot = v3(0,0,0,1)\n ;objSca[oCubeChil]=v2(.4)//es100 error , no array of class allowed\n ;v0 trainV = 2.2\n ;objVel[oTrain]= v2((floor(mod(trainV*time/16.,2.))*2.-1.)*trainV,0,0)//es100 error , no array of class allowed\n ;v0 trainDir = 1.\n ;if (objVel[oTrain].x < 0.)trainDir = -1.//es100 error , no array of class allowed\n ;objPos[oTrain]=v2(abs(1.-mod(trainV*time/16.,2.))*16.-8.,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTrain]=aa2q(pi*.5,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTrain]= v2(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,cLag))\n ;//objects[o_train].b.x = 0.//es100 error , no array of class allowed\n ;objPos[oTunnel]=v2(0,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTunnel]=aa2q(pi*.5,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTunnel]=v2(1.,1.,1)//es100 error , no array of class allowed\n ;objPos[oTunnelDoor]=objPos[oTunnel]//es100 error , no array of class allowed\n ;objRot[oTunnelDoor]=objRot[oTunnel]//es100 error , no array of class allowed\n ;v0 open = clamp((1.-abs(3.*objPos[oTrain].x))*2.,0.,1.)//es100 error , no array of class allowed\n ;objSca[oTunnelDoor]= v2(open,open,1);}//es100 error , no array of class allowed\n//es100 error , no array of class allowed\nvoid ProcessLightValue(v0 t\n){oliPos[0]=v2(6.,1.,sin(t))\n ;oliCol[0]=3.*v3(0.2,1.,.2,1)\n ;oliPos[1]=v2(-3,-2.2,sin(t*.3)*8.)\n ;oliCol[1]=2.*v3(1,1,0.5,1)\n ;oliPos[2]=v2(9.5,1.8,9.5)\n ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*v3(1,.2,1,1);}\nvoid SetTime(v0 t){ProcessLightValue(t);ProcessObjectPos(t);}//es100 error , no array of class allowed\n#define beginObj(objID,var) Transform(objID,var); curObj=objID;  lastrDistObj = o;\n#define endObj() if(o!=lastrDistObj)rayObj=curObj;lastrDistObj=o;\n#define ADD(f) o=min(o, f);\n#define SUB(f) o=max(o,-f);\n#define VOL(func)  if (func < rDist)\n//volume marching accumulator, used for blackHoleAccretionDisk\nv0 vma=0.;\nv0 map(v2 pos, int processedMaterial\n){v0 o = 0. //0. if first operation is a SUB(), 1e10 otherwise\n ;maxGISize = 0.\n ;rayObj = 0\n ;v3 w = v3(pos,1)//worldSpace\n ;beginMaterial(0)\n ;SUB(box(w,v2(0,0,0),v2(10,2.5,10)))\n ;ADD(cylinderY(w,v2(-6,0,-2.),0.1,3.))\n ;ADD(cylinderY(w,v2(5,0,-2.),0.1,3.))\n ;endMaterial()\n ;v3 c=beginObj(oCubeMy,w)//cubespace, not color\n ;//ADD(box(c,v2(0,0,0),v2(1)))\n ;//c.xz = abs(c.xz)\n ;for(int i=0;i<4;i++\n ){beginMaterial(i)\n  ;ADD(sphere(c,v2(0,0,0),1.))\n  ;endMaterial()\n  ;c=abs(c)\n  ;c=beginObj(oCubeChil,c);}\n ;v3 blackHoleSpace = beginObj(oBlackHole,w)\n ;beginMaterial(8)\n ;ADD(sphere(blackHoleSpace,v2(0,0,0),.5))\n ;endMaterial()\n ;v3 tunnelSpace = beginObj(oTunnel,w)\n ;beginMaterial(3)\n ;ADD(box(tunnelSpace,v2(0,.5,0),v2(.2,.1,1.5)))\n ;ADD(box(tunnelSpace,v2(0,-.5,0),v2(.2,.1,1.5)))\n ;endMaterial()\n ;v3 tunnelDoorSpace = beginObj(oTunnelDoor,w)\n ;beginMaterial(4)\n ;ADD(box(tunnelDoorSpace,v2(0,0,1.4),v2(.2,.4,0.1)))\n ;ADD(box(tunnelDoorSpace,v2(0,0,-1.4),v2(.2,.4,0.1)))\n ;endMaterial()\n ;v3 trainSpace = beginObj(oTrain,w)\n ;beginMaterial(7)\n ;ADD(box(trainSpace,v2(0,0,-.8),v2(.1,.1,.18)))\n ;ADD(box(trainSpace,v2(0,0,-.4),v2(.1,.1,.18)))\n ;ADD(box(trainSpace,v2(0)      ,v2(.1,.1,.18)))\n ;ADD(box(trainSpace,v2(0,0, .4),v2(.1,.1,.18)))\n ;ADD(box(trainSpace,v2(0,0,.68),v2(.1,.1,.06)))\n ;ADD(cylinderZ(trainSpace,v2(0,.04,.8),.07,.18))\n ;endObj()\n ;endMaterial()\n ;v0 temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))\n ;v0 tmpGauss = length(blackHoleSpace.xz)-1.5\n ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))\n ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)\n ;vma+=(1.-vma)*temp*AccretionDisk\n ;for(int L=0; L<3; L++\n ){\n  ;ADD(sphere(w,oliPos[L]\n              //o_lights[L].b\n              ,0.001))\n  ;\n  ;v2 relPos = oliPos[L]-pos//o_lights[L].b\n  ;oliHal[L]//o_lights[L].haloResult \n      += o*(0.02/(dot(relPos,relPos)+0.01))\n  ;}\n ;return o;}\nv3 GetNormal(v2 u\n){v1 e = v1(0.003,0.)\n ;v0 o=map(u,-1)\n ;return v3(norma(v2(map(u+e.xyy,-1)\n                    ,map(u+e.yxy,-1)\n                    ,map(u+e.yyx,-1))-o),o);}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1065, 1184, 1209, 1209, 1239], [1240, 1240, 1264, 1264, 1294], [1295, 1295, 1312, 1312, 1340], [1341, 1341, 1358, 1358, 1386], [5278, 5278, 5386, 5386, 5554], [5634, 5903, 6012, 6012, 6852], [6930, 7134, 7198, 7198, 7846], [7897, 7897, 7925, 7925, 8582], [8585, 8585, 8620, 8686, 8719]], "test": "untested"}
{"id": "wslfzX", "name": "Pathtraced Volumetrics", "author": "demofox", "description": "Ray marching participating media in a path tracer.\nDrag mouse to move camera and see different scenes.\nUsing Henyey-Greenstein phase function, importance sampled.", "tags": ["fog", "pathtracing", "scatter", "participatingmedia"], "likes": 16, "viewed": 1110, "published": 3, "date": "1588976406", "time_retrieved": "2024-07-30T21:07:54.662637", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// get the linear color of the pixel\n    vec3 pixelColor = texture( iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    \n    // add in bloom\n    pixelColor += BloomPass2(fragCoord.xy, iResolution.xy, iChannel1);\n    \n    // apply exposure\n    pixelColor *= c_exposure;\n    \n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// =======================================================================\n// Constants\n// =======================================================================\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\nconst float c_goldenRatioConjugate = 0.61803398875; // 1 / goldenRatio\nconst float KEY_SPACE = 32.5/256.0;\n\n// =======================================================================\n// Parameters\n// =======================================================================\n\n// camera parameters\nconst vec3 c_cameraAt = vec3(0.0f, 40.0f, 0.0f);\nconst float c_cameraDistance = 80.0f;\nconst float c_apertureRadius = 0.4f;  // in world units. 0 for pinhole camera.\nconst float c_focalPlaneDistance = 80.0f; // in world units. How far from the camera things are in focus at.\nconst float c_minCameraAngle = c_pi / 2.0f - 0.125f;\nconst float c_maxCameraAngle = (c_pi - 0.01f);\nconst float c_exposure = 2.0f;  // +1 fstops of exposure\nconst float c_FOV = 90.0f; // in degrees\n\n// the place to put the mouse if it hasn't moved yet (aka the default view)\nconst vec2 c_defaultMousePos = vec2(314.0f / 800.0f, 100.0f / 450.0f);\n\n// bloom parameters\nconst vec3 c_bloomMin = vec3(1.0f, 1.0f, 1.0f);\n// The array below is a 1d gaussian which starts at index 0.\n// A nice gaussian calculator is at http://dev.theomader.com/gaussian-kernel-calculator/\n// Just calculate a kernel that is (c_radius * 2 + 1) large and use the second half of the result (including the center).\n// That should give you an array that is (c_radius+1) items large.\n//const int c_bloomRadius = 3;\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.383103, 0.241843, 0.060626, 0.00598); // sigma 1.0\nconst int c_bloomRadius = 5;\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.382925, 0.24173, 0.060598, 0.005977, 0.000229, 0.000003); // sigma 1.0\nconst float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.163053, 0.150677, 0.118904, 0.080127, 0.046108, 0.022657); // sigma 2.5\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.109317, 0.107159, 0.100939, 0.091364, 0.079465, 0.066414); // sigma 5.0    \n\n// scene parameters\nconst float c_skyboxMultiplier = 0.2f; // for the cube map, if visible.\n\n// ray tracing parameters\nconst int c_numBounces = 8;\nconst float c_minimumRayHitTime = 0.1f;\nconst float c_superFar = 10000.0f;\n\n// ray marching parameters\nconst int c_numSteps = 256;\nconst float c_minStepDistance = 0.1f;\nconst int c_numStepsVolumetric = 32;  // how many steps are taken between the camera and the first solid object down a ray. uniform sampling but randomly offset [0,1] steps\nconst float c_maxDistanceVolumetric = 200.0f; // maximum depth to ray march for volumetric data.\n\n// other parameters\nconst float c_rayPosNormalNudge = 0.01f; // after a hit, it moves the ray this far along the normal away from a surface\n\n// =======================================================================\n// Display Adaptation Functions\n// =======================================================================\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\n// =======================================================================\n// Bloom Functions\n// =======================================================================\n\nvec3 BloomPass1(in vec2 pixelPos, in vec2 resolution, in sampler2D linearImage)\n{\n    // horizontal & conditional\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    for (int ix = -c_bloomRadius; ix <= c_bloomRadius; ++ix)\n    {\n        vec3 pixelColor = texture( linearImage, (pixelPos + vec2(ix, 0))/resolution.xy).rgb;\n        vec3 bloomColor = clamp(pixelColor - c_bloomMin, 0.0f, 1.0f);\n        \n        bloomColor = (dot(bloomColor, c_bloomMin) > 0.0f ? bloomColor : vec3(0.0f, 0.0f, 0.0f));\n\n        float weight = c_bloomKernel[abs(ix)];\n        sum += bloomColor * weight;\n    }\n    \n    return sum;\n}\n\nvec3 BloomPass2(in vec2 pixelPos, in vec2 resolution, in sampler2D bloomImage)\n{\n    // vertical\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    for (int iy = -c_bloomRadius; iy <= c_bloomRadius; ++iy)\n    {\n        vec3 bloomColor = texture( bloomImage, (pixelPos + vec2(0, iy))/resolution.xy).rgb;\n        float weight = c_bloomKernel[abs(iy)];\n        sum += bloomColor * weight;\n    }\n    \n    return sum;\n}\n\n// =======================================================================\n// RNG Functions\n// =======================================================================\n\n// from \"Hash without Sine\" https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// =======================================================================\n// Misc Functions\n// =======================================================================\n\nfloat MaxComp(vec3 v)\n{\n    return max(v.x, max(v.y, v.z));\n}\n\nint MaxCompIndex(vec3 v)\n{\n    if (v.x > v.y)\n    {\n        if (v.x > v.z)\n            return 0;\n        else\n            return 2;\n    }\n    else\n    {\n        if (v.y > v.z)\n            return 1;\n        else\n            return 2;\n    }\n}\n\nfloat Bias(float x, float bias)\n{\n  return (x / ((((1.0f/bias) - 2.0f)*(1.0f - x))+1.0f));\n}\n\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\n// =======================================================================\n// Distance Functions 2D\n// https://iquilezles.org/articles/distfunctions2d\n// =======================================================================\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n// =======================================================================\n// Distance Functions 3D\n// https://iquilezles.org/articles/distfunctions\n// =======================================================================\n\nfloat SphereDistance(in vec4 sphere, in vec3 point)\n{\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat PlaneDistance(in vec4 plane, in vec3 point)\n{\n    return (dot(plane.xyz, point) - plane.w) / dot(plane.xyz, plane.xyz);\n}\n\nfloat BoxDistance(in vec3 boxPos, in vec3 boxRadius, in float width, in vec3 point)\n{\n    point -= boxPos;\n    width = max(width, 0.01f);  // fix for a problem i didn't investigate :P\n    \n    // from https://www.youtube.com/watch?reload=9&v=62-pRVZuS5c\n    // rounding the box from https://www.youtube.com/watch?v=s5NGeUV2EyU\n    vec3 q = abs(point) - boxRadius;\n    return length(max(q,vec3(0.0f,0.0f,0.0f))) + min(MaxComp(q), 0.0f) - width;\n}\n\nfloat LineDistance(in vec3 A, in vec3 B, float width, in vec3 point, out vec3 normal)\n{\n\tvec3 AP = point - A;\n    vec3 AB = B - A;\n    \n    // from https://www.youtube.com/watch?v=PMltMdi1Wzg\n    // added normal calculation though\n    float h = min(1.0f, max(0.0f, dot(AP, AB) / dot(AB, AB)));\n    vec3 closestPoint = A + h * AB;\n    normal = normalize(point - closestPoint);\n    return length(point - closestPoint) - width;\n}\n\nfloat BezierDistance( in vec3 pos, in vec3 A, in vec3 B, in vec3 C, in float width)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res ) - width;\n}\n\n// =======================================================================\n// Object Intersection Helpers for Ray Marching\n// =======================================================================\n\n#define OBJECTPASS_RAYTRACE           0\n#define OBJECTPASS_RAYMARCH           1\n#define OBJECTPASS_RAYMARCHVOLUMETRIC 2\n\nstruct SMaterial\n{\n    vec3 diffuse;\n    vec3 specular;\n\tfloat roughness;\n    vec3 emissive;    \n};\n\nstruct SRayHitInfo\n{\n    bool hitAnObject;\n    int objectPass;\n    float dist;\n    vec3 normal;\n    SMaterial material;\n};\n    \nstruct SRayVolumetricInfo\n{\n    float scatterProbability; // per unit distance\n    // for phase function. should be in (-1, 1)\n    // positive numbers scatter rays in the direction they were traveling.\n    // negative numbers scatter them backwards, back to where they came from.\n    // zero for uniformly random scattering.\n\tfloat anisotropy;\n    \n    // Note: emissive and absorption will happen even if scatterProbability is zero.\n    vec3 emissive;            // per unit distance\n    vec3 absorption;          // per unit distance    \n};\n    \nvoid TestSphereMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)\n{\n    float dist = SphereDistance(sphere, rayPos);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;        \n        info.normal = normalize(rayPos - sphere.xyz);\n        info.material = material;\n    }    \n}\n\nvoid TestPlaneMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 plane, in SMaterial material)\n{\n    float dist = PlaneDistance(plane, rayPos);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;        \n        info.normal = plane.xyz;\n        info.material = material;\n    }    \n}\n\nvoid TestBoxMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 boxPos, in vec3 boxRadius, in float width, in SMaterial material)\n{\n    float dist = BoxDistance(boxPos, boxRadius, width, rayPos);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;\n        \n        vec3 relPos = max(abs(rayPos - boxPos) - boxRadius, 0.0f);\n        int maxIndex = MaxCompIndex(relPos);\n        if (maxIndex == 0)\n        {\n            info.normal = (rayPos.x < boxPos.x) ? vec3(-1.0f, 0.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);\n        }\n        else if(maxIndex == 1)\n        {\n            info.normal = (rayPos.y < boxPos.y) ? vec3(0.0f, -1.0f, 0.0f) : vec3(0.0f, 1.0f, 0.0f);\n        }\n        else\n        {\n            info.normal = (rayPos.z < boxPos.z) ? vec3(0.0f, 0.0f, -1.0f) : vec3(0.0f, 0.0f, 1.0f);\n        }\n        \n        info.material = material;\n    }    \n}\n\nvoid TestLineMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in float width, in SMaterial material)\n{   \n    vec3 normal;\n    float dist = LineDistance(A, B, width, rayPos, normal);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;        \n        info.normal = normal;\n        info.material = material;\n    }    \n}\n\nvoid TestBezierMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in vec3 C, in float width, in SMaterial material)\n{\n    float dist = BezierDistance(rayPos, A, B, C, width);\n    if (dist < info.dist)\n    {\n        info.objectPass = OBJECTPASS_RAYMARCH;\n        info.dist = dist;    \n        info.normal = vec3(1.0f, 0.0f, 0.0f); // TODO: figure out the normal, if you ever need it! finite differences? dunno.\n        info.material = material;\n    }    \n}\n\n// =======================================================================\n// Object Intersection Helpers for Ray Tracing\n// =======================================================================\n\nbool TestPlaneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in SMaterial material)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > c_minimumRayHitTime && dist < info.dist)\n        {\n            info.hitAnObject = true;\n            info.objectPass = OBJECTPASS_RAYTRACE;\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.material = material;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in SMaterial material)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.objectPass = OBJECTPASS_RAYTRACE;\n        info.dist = dist;        \n        info.normal = normal;\n\t\tinfo.material = material;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.objectPass = OBJECTPASS_RAYTRACE;\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.material = material;        \n        return true;\n    }\n    \n    return false;\n}\n\n// Tests against a vertical cylinder without caps\n// Derived from the sphere function and not super optimal but whatever.\nbool TestCylinderTrace(in vec3 rayPos_, in vec3 rayDir_, inout SRayHitInfo info, in vec3 pos, in float radius, in float height, in SMaterial material)\n{\n    vec3 relativeRayPos = rayPos_ - pos;\n    vec3 projectedRayPos = vec3(relativeRayPos.x, 0.0f, relativeRayPos.z);\n    vec3 projectedRayDir = vec3(rayDir_.x, 0.0f, rayDir_.z);\n    \n    float lengthCorrection = length(projectedRayDir);\n    projectedRayDir /= lengthCorrection;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = projectedRayPos;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, projectedRayDir);\n\n\tfloat c = dot(m, m) - radius * radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n\n    // adjust distance\n    dist /= lengthCorrection;\n\n    // enforce height - note we may be invalid height for the first distance but not the second.\n    vec3 relativeHitPos = relativeRayPos + rayDir_ * dist;\n    if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)\n    {\n        dist = -b + sqrt(discr);\n        dist /= lengthCorrection;\n        relativeHitPos = relativeRayPos + rayDir_ * dist;\n        if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)\n      \t\treturn false;\n    }\n        \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.objectPass = OBJECTPASS_RAYTRACE;\n        info.dist = dist;        \n        info.normal = normalize(vec3(relativeHitPos.x, 0.0f, relativeHitPos.z)) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.material = material;        \n        return true;\n    }\n    \n    return false;\n}\n\n/*\n============================================\n\nNon PBR Path tracer version 2.\nBranched from https://www.shadertoy.com/view/tdXBW8\n\nRaymarched volumetrics. Every point in space can have these properties:\n* scatter chance (particle density)\n* isotropy (for henyey-greenstein phase function, which is importance sampled)\n* emission\n* absoprtion\n\nThis allows for fogs/clouds, subsurface scattering, and also just areas with emission or absorption but no scattering (like a block of jello)\nTransparents / refraction not yet supported though, so you can't make an absorbing jello that also has a shiny surface.\n\nhttp://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Volume_Scattering.html\nhttps://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\nhttps://shaderbits.com/blog/creating-volumetric-ray-marcher\nhttps://www.shadertoy.com/view/tsScDG\nhttps://dai.fmph.uniba.sk/upload/f/f9/Ris_lesson07.pdf\nhttps://www.csie.ntu.edu.tw/~cyy/courses/rendering/09fall/lectures/handouts/chap17_volume_4up.pdf\n\n============================================\n\nNon PBR Path tracer version 1.\n\n* ray traced objects & ray marched objects\n * many analystical ray vs object tests are from \"real time collision detection\" by Christer Ericson\n* thin lens simulation (depth of field and bokeh) with a circular aperture.\n* bloom\n\n============================================\n\nneed to make a \"path tracing on shadertoy for dummies\" series focusing on simplicity over convergence speed.\n\n============================================\n\nImprovements for future versions (other shadertoys)...\n\n* blue noise for low sample counts. maybe low discrepancy sequences too for more than low sample counts.\n\n* spectral path tracing - different material properties for different wavelengths of light.\n\n* transparency & refraction?\n * would need ot be able to be inside of objects. maybe only allow for raytracing?\n * maybe combine this with subsurface scattering?\n\n* subsurface scattering\n * which i think is just denser participating media\n * https://my.eng.utah.edu/~darais/classes/cs6620/project/index.html\n * https://www.fxguide.com/fxfeatured/pixar-deep-dive-on-sss-siggraph-preview/\n\n* panini projection for wider angle shots\n * https://wiki.panotools.org/The_General_Panini_Projection\n * or barrel distortion: https://www.decarpentier.nl/lens-distortion\n\n* make a skybox function in Buffer A instead of the hard coded cube map lookup.\n * it could take ray direction (only) as input and return a vec3.\n * could be cool for making procedural skyboxes, including constant color, gradient, and cube map lookups.\n\n* lens flare\n* motion blur\n* fresnel\n* clear coat (multiple shading lobe materials)\n\n* importance sample cos(theta) for diffuse instead of weighting the sample by it.\n * easy to do, just have to re-org how it calculates the next ray direction a bit.\n\n*/", "buffer_a_code": "// =======================================================================\n// Scene Descriptions - both ray tracing and ray marched objects. Also participating media.\n// =======================================================================\n\n#define SCENE_FOG1         0  // a ball casting a shadow into an isotropic fog\n#define SCENE_FOG2         1  // a ball casting a shadow into a fog with -0.5 backscattering (left) and 0.5 forward scattering (right)\n#define SCENE_ABSORPTION1  2  // a ball with absorption (left) vs same ball without (right)\n#define SCENE_ABSORPTION2  3  // a ball with absorption (left) vs same ball without (right) - no scattering\n#define SCENE_EMISSION     4  // a ball with emission (left) vs same ball without (right)\n#define SCENE_LIGHTINFOG1  5  // a fog ball with a light inside of it\n#define SCENE_LIGHTINFOG2  6  // a fog ball with a light inside of it - but with soft edges\n#define SCENE_MULTIFOG     7  // multiple types and colors of fog\n#define SCENE_ORGANICFOG   8  // using 3d noise for fog density\n\n#define SCENE SCENE_FOG1\n\nvoid RayTraceScene(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{\n    // floor\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.5f, 0.5f, 0.5f);\n        material.specular = vec3(0.3f, 0.3f, 0.3f);\n        material.roughness = 0.02f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    \tif (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 1.0f, 0.0f)), 0.0f), material))\n        {\n            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;\n            vec2 uv = floor(intersectPos.xz / 20.0f);\n            float shade = mix(0.2f, 0.6f, mod(uv.x + uv.y, 2.0f));\n            material.roughness = mix(0.02f, 0.2f, mod(uv.x + uv.y, 2.0f));\n            hitInfo.material.diffuse = vec3(shade, shade, shade);\n        }\n    }\n    \n    // walls\n    {\n    \tSMaterial material;\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.02f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        \n        vec3 offset = vec3(0.0f, 80.0f, -80.0f);\n        vec3 scale = vec3(80.0f, 80.0f, 1.0f);\n        vec3 A = vec3( 1.0f,  1.0f, 0.0f) * scale + offset;\n        vec3 B = vec3(-1.0f,  1.0f, 0.0f) * scale + offset;\n        vec3 C = vec3(-1.0f, -1.0f, 0.0f) * scale + offset;\n        vec3 D = vec3( 1.0f, -1.0f, 0.0f) * scale + offset;\n        \n        // back wall\n\t\tmaterial.diffuse = vec3(0.9f, 0.9f, 0.9f);\n        TestQuadTrace(rayPos, rayDir, hitInfo, A.xyz, B.xyz, C.xyz, D.xyz, material);\n        \n        // left wall\n        material.diffuse = vec3(0.9f, 0.1f, 0.1f);\n        TestQuadTrace(rayPos, rayDir, hitInfo, A.zyx, B.zyx, C.zyx, D.zyx, material);\n        \n        // right wall\n        material.diffuse = vec3(0.1f, 0.9f, 0.1f);\n        vec3 multiplier = vec3(-1.0f, 1.0f, 1.0f);\n        TestQuadTrace(rayPos, rayDir, hitInfo, A.zyx * multiplier, B.zyx * multiplier, C.zyx * multiplier, D.zyx * multiplier, material);\n    }\n    \n    #if SCENE == SCENE_FOG1 || SCENE == SCENE_FOG2\n    \n        // shadow casting ball\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.9f, 0.9f, 0.9f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n            material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            TestSphereTrace(rayPos, rayDir, hitInfo, vec4( 0.0f, 40.0f, -30.0f, 15.0f), material);\n        }\n\n        // light source\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n\n            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;\n            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 80.0f, -30.0f, 5.0f), material);        \n        }        \n    \n    #elif SCENE == SCENE_ABSORPTION1 || SCENE == SCENE_ABSORPTION2 || SCENE == SCENE_MULTIFOG || SCENE == SCENE_ORGANICFOG\n    \n        // light source\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n\n            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;\n            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 80.0f, -30.0f, 5.0f), material);        \n        }  \n    \n    #elif SCENE == SCENE_EMISSION\n    \n    \t// none!\n    \n    #elif SCENE == SCENE_LIGHTINFOG1 || SCENE == SCENE_LIGHTINFOG2\n    \n        // light source\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n\n            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;\n            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 40.0f, -30.0f, 5.0f), material);        \n        }     \n    \n    #endif\n}\n\n// from https://www.shadertoy.com/view/XsX3RB\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel3, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel3, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel3, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel3, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;    \n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvoid TestSceneVolumetric(in vec3 rayPos, out SRayVolumetricInfo info)\n{   \n    info.scatterProbability = 0.0f;\n    info.anisotropy = 0.0f;\n    info.emissive = vec3(0.0f, 0.0f, 0.0f);\n    info.absorption = vec3(0.0f, 0.0f, 0.0f);\n    \n    #if SCENE == SCENE_FOG1 || SCENE == SCENE_FOG2\n    \n    \tfloat dist = BoxDistance(vec3(0.0f, 25.0f, -30.0f), vec3(60.0f, 25.0f, 30.0f), 0.0f, rayPos);\n    \tinfo.scatterProbability = step(dist, 0.01f) * 0.02f;\n    \n    \t#if (SCENE == SCENE_FOG2)\n    \t\tif (rayPos.x > 0.0f)\n                info.anisotropy = 0.5f;\n    \t\telse\n                info.anisotropy = -0.5f;\n        #endif\n    \n    #elif SCENE == SCENE_ABSORPTION1 || SCENE == SCENE_ABSORPTION2\n    \tif (step(SphereDistance(vec4( -25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n            #if SCENE == SCENE_ABSORPTION1\n            \tinfo.scatterProbability = 0.1f;\n            #endif\n            info.absorption = vec3(0.0f, 0.4f, 0.9f) * 0.1;\n        }\n    \n    \tif (step(SphereDistance(vec4( 25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n            info.scatterProbability = 0.1f;\n        }\n    \n    #elif SCENE == SCENE_EMISSION\n    \tif (step(SphereDistance(vec4( -25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n           \tinfo.scatterProbability = 0.1f;\n            info.emissive = vec3(0.0f, 0.4f, 0.9f) * 0.05f;\n        }\n    \n    \tif (step(SphereDistance(vec4( 25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n            info.scatterProbability = 0.1f;\n        }\n    \n    #elif SCENE == SCENE_LIGHTINFOG1\n    \n    \tif (step(SphereDistance(vec4( 0.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)\n        {\n           \tinfo.scatterProbability = 0.1f;            \n            info.absorption = vec3(1.0f, 1.0f, 1.0f) * 0.05f;\n        }\n    \n    #elif SCENE == SCENE_LIGHTINFOG2\n    \n \t\tfloat dist = length(rayPos - vec3(0.0f, 40.0f, -30.0f));\n\n        float fogAmount = smoothstep(25.0f, 15.0f, dist);\n    \tinfo.scatterProbability = fogAmount * 0.1f;\n    \tinfo.absorption = vec3(1.0f, 1.0f, 1.0f) * 0.05f * fogAmount;\n    \n    #elif SCENE == SCENE_MULTIFOG\n    \n    \tfloat weight = 0.0f;\n    \n    \tif (BezierDistance(rayPos, vec3(10.0f, 0.0f, -30.0f), vec3(10.0f, 40.0f, -30.0f), vec3(50.0f, 50.0f, -30.0f), 7.0f) < 0.0f)\n        {\n            weight += 1.0f;\n            info.scatterProbability += 0.2f;\n        }\n    \n    \tif (BezierDistance(rayPos, vec3(-50.0f, 40.0f, 0.0f), vec3(-10.0f, 50.0f, 10.0f), vec3(0.0f, 0.0f, 10.0f), 7.0f) < 0.0f)\n        {\n            weight += 1.0f;\n            info.scatterProbability += 0.05f;\n            info.absorption = vec3(0.1f, 0.1f, 0.05f) * 2.0f;\n        }    \n    \n    \tif (BezierDistance(rayPos, vec3(-40.0f, 0.0f, -40.0f), vec3(-40.0f, 40.0f, -20.0f), vec3(-20.0f, 60.0f, 0.0f), 7.0f) < 0.0f)\n        {\n            weight += 1.0f;\n            info.scatterProbability += 0.1f;\n            info.emissive = vec3(1.0f, 1.0f, 0.125f) * 0.1f;\n        }\n        \n    \tif (BoxDistance(vec3(30.0f, 10.0f, -20.0f), vec3(15.0f, 10.0f, 15.0f), 5.0f, rayPos) < 0.0f)\n        {\n            weight += 1.0f;\n            info.absorption = vec3(0.1f, 0.4f, 0.9f) * 0.25f;\n        }\n    \n    \tif (weight > 0.0f)\n        {\n            info.scatterProbability /= weight;\n            info.absorption /= weight;\n            info.emissive /= weight;\n        }\n    #elif SCENE == SCENE_ORGANICFOG\n    \n    \tfloat density = noise((rayPos + vec3(10.0f, 0.0f, 0.0f)) / 25.0f);\n    \tconst float threshold = 0.6f;\n    \n    \tdensity = clamp((density - threshold) / (1.0f - threshold), 0.0f, 1.0f);\n    \tinfo.scatterProbability = density * 0.075f;\n    #endif\n}\n\nSRayHitInfo TestSceneMarch(in vec3 rayPos)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.hitAnObject = false;\n    hitInfo.dist = c_superFar;\n    return hitInfo;\n}\n\n// =======================================================================\n// Ray Marching\n// =======================================================================\n\nvoid RayMarchScene(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo oldHitInfo)\n{\n    SMaterial dummyMaterial = SMaterial(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), 0.0f, vec3(0.0f, 0.0f, 0.0f));\n    \n    float rayDistance = c_minimumRayHitTime;\n    float lastRayDistance = c_minimumRayHitTime;\n    \n    float lastHitInfoDist = 0.0f;\n    \n    SRayHitInfo newHitInfo = oldHitInfo;\n    newHitInfo.hitAnObject = false;\n    \n    for (int stepIndex = 0; stepIndex < c_numSteps; ++stepIndex)\n    {\n        vec3 rayPos = startingRayPos + rayDistance * rayDir;\n        \n        newHitInfo = TestSceneMarch(rayPos);\n        \n        // these two lines are so that the material code goes away when the test functions are inlined\n        newHitInfo.normal = vec3(0.0f, 0.0f, 0.0f);\n        newHitInfo.material = dummyMaterial;\n        \n        newHitInfo.hitAnObject = newHitInfo.dist < 0.0f;\n        if (newHitInfo.hitAnObject)\n            break;\n        \n        lastRayDistance = rayDistance;\n        rayDistance += max(newHitInfo.dist, c_minStepDistance);\n\n        lastHitInfoDist = newHitInfo.dist;\n        \n        if (rayDistance > oldHitInfo.dist)\n            break;\n    }\n    \n    if (newHitInfo.hitAnObject)\n    {\n\t\tfloat refinedHitPercent = lastHitInfoDist / (lastHitInfoDist - newHitInfo.dist);\n        newHitInfo.dist = mix(lastRayDistance, rayDistance, refinedHitPercent);\n        \n        if (newHitInfo.dist < oldHitInfo.dist)\n            oldHitInfo = newHitInfo;\n    }\n}\n\n// http://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Vectors.html#CoordinateSystem\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3)\n{\n    if (abs(v1.x) > abs(v1.y))\n        v2 = vec3(-v1.z, 0.0f, v1.x) /\n              sqrt(v1.x * v1.x + v1.z * v1.z);\n    else\n        v2 = vec3(0, v1.z, -v1.y) /\n              sqrt(v1.y * v1.y + v1.z * v1.z);\n    v3 = cross(v1, v2);\n}\n\n// http://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Working_with_Radiometric_Integrals.html#SphericalDirection\nvec3 SphericalDirection(float sinTheta, float cosTheta, float phi, vec3 x, vec3 y, vec3 z) {\n    return sinTheta * cos(phi) * x +\n           sinTheta * sin(phi) * y + cosTheta * z;\n}\n\nvoid RayMarchVolumetric(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, out vec3 absorption, inout uint rngState, in vec2 fragCoord)\n{\n    float searchDistance = hitInfo.hitAnObject ? min(hitInfo.dist, c_maxDistanceVolumetric) : c_maxDistanceVolumetric;\n    float stepSize = searchDistance / float(c_numStepsVolumetric);\n\n    // random starting offset up to a step size for each ray, to make up for lower step count ray marching.\n    float t = RandomFloat01(rngState) * stepSize;\n    \n    float scatterRoll = RandomFloat01(rngState);\n    float scatterCum = 1.0f;\n    absorption = vec3(1.0f, 1.0f, 1.0f);\n    vec3 emissive = vec3(0.0f, 0.0f, 0.0f);\n\n    SRayVolumetricInfo volumetricInfo;\n    bool scattered = false;\n    \n    for (int i = 0; i < c_numStepsVolumetric; ++i)\n    {\n\t\tvec3 rayPos = startingRayPos + rayDir * t;\n        TestSceneVolumetric(rayPos, volumetricInfo);  // we could maybe try averaging the volumetricInfo with the last step or something.\n        \n        float desiredScatter = scatterRoll / scatterCum;  // this is how much we need to multiply scatterCum by to get to scatterRoll\n        \n        scatterCum *= exp(-volumetricInfo.scatterProbability * stepSize);               \n        if (scatterCum < scatterRoll)\n        {\n            float lastT = t - stepSize;\n            \n            // using inverted beer's law to find the time between steps to get the right scatter amount.\n            // beer's law is   y = e^(-p*x)\n            // inverted, it is x = 1/p * ln(1/y)\n            float stepT = (1.0f / volumetricInfo.scatterProbability) * log(1.0f / desiredScatter);\n            t = lastT + stepT;\n            \n            // absorption and emission over distance\n            absorption *= exp(-volumetricInfo.absorption * stepT);\n            emissive += volumetricInfo.emissive * stepT;\n            \n            scattered = true;\n            break;\n        }\n        \n        // absorption and emission over distance\n        absorption *= exp(-volumetricInfo.absorption * stepSize);       \n        emissive += volumetricInfo.emissive * stepSize;\n        \n        // go to next ray position\n        t += stepSize;\n    }\n    \n    if (!scattered)\n    {\n        // emissive over distance should happen even when there's no scattering\n        hitInfo.material.emissive += emissive;\n        return;\n    }\n    \n    hitInfo.hitAnObject = true;\n    hitInfo.objectPass = OBJECTPASS_RAYMARCHVOLUMETRIC;\n    hitInfo.dist = t;\n    \n    // importance sample Henyey Greenstein phase function to get the next ray direction and put it in the normal.\n    // http://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Volume_Scattering.html\n    // https://www.csie.ntu.edu.tw/~cyy/courses/rendering/09fall/lectures/handouts/chap17_volume_4up.pdf\n    {\n        float g = volumetricInfo.anisotropy;\n        \n        vec2 rand = vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n        \n        float cosTheta;\n\t\tif (abs(g) < 1e-3)\n    \t\tcosTheta = 1.0f - 2.0f * rand.x;\n\t\telse\n        {\n    \t\tfloat sqrTerm = (1.0f - g * g) /\n                    \t\t(1.0f - g + 2.0f * g * rand.x);\n    \t\tcosTheta = (1.0f + g * g - sqrTerm * sqrTerm) / (2.0f * g);\n\t\t}\n        \n        float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));\n\t\tfloat phi = c_twopi * rand.y;\n\t\tvec3 v1, v2;\n\t\tCoordinateSystem(rayDir, v1, v2);\n\t\thitInfo.normal = SphericalDirection(sinTheta, cosTheta, phi, v1, v2, -rayDir);\n    }\n        \n    hitInfo.material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n    hitInfo.material.specular = vec3(0.0f, 0.0f, 0.0f);\n    hitInfo.material.roughness = 0.0f;\n    hitInfo.material.emissive = emissive;\n}\n\n// =======================================================================\n// Iterative bounce path tracing - the main loop.\n// =======================================================================\n    \nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState, in vec2 fragCoord)\n{\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 colorMultiplier = vec3(1.0f, 1.0f, 1.0f);\n    \n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n       \n    for (int i = 0; i <= c_numBounces; ++i)\n    {\n        SRayHitInfo hitInfo;\n\t\thitInfo.hitAnObject = false;\n        hitInfo.dist = c_superFar;\n        \n        // ray trace first, which also gives a maximum distance for ray marching\n        RayTraceScene(rayPos, rayDir, hitInfo);\n        \n        // ray march next\n        RayMarchScene(rayPos, rayDir, hitInfo);\n        \n        // Volumetric ray march after that\n        vec3 absorption;\n        RayMarchVolumetric(rayPos, rayDir, hitInfo, absorption, rngState, fragCoord);\n        \n        // apply absorption to the color multiplier before shading the object or sampling the skybox\n        colorMultiplier *= absorption;\n        \n\t\t// handle ray misses by sampling a skybox and exiting the loop\n        if (!hitInfo.hitAnObject)\n        {\n            ret += texture(iChannel1, rayDir).rgb * c_skyboxMultiplier * colorMultiplier;\n            break;\n        }\n                      \n        // update the ray position\n        rayPos += rayDir * hitInfo.dist;\n               \n        // get the material info if it was a ray marched object\n        if (hitInfo.objectPass == OBJECTPASS_RAYMARCH)\n\t\t\thitInfo = TestSceneMarch(rayPos);\n                \n\t\t// add in emissive lighting\n        ret += hitInfo.material.emissive * colorMultiplier;\n        \n        // set up the next ray direction       \n        if (hitInfo.objectPass == OBJECTPASS_RAYMARCHVOLUMETRIC)\n        {            \n            // volumetrics set up their own raydir in the normal\n\t\t\trayDir = hitInfo.normal;\n        }\n        else\n        {\n            // figure out whether we are going to shoot out a specular or diffuse ray.\n            // If neither, exit\n            float diffuseLength = length(hitInfo.material.diffuse);        \n            float specularLength = length(hitInfo.material.specular);\n            if (diffuseLength + specularLength == 0.0f)\n                break;\n            float specularWeight = specularLength / (diffuseLength + specularLength);       \n            float doSpecular = float(RandomFloat01(rngState) < specularWeight);\n            \n        \tfloat roughness = mix(1.0f, hitInfo.material.roughness, doSpecular);\n        \tvec3 reflectDir = reflect(rayDir, hitInfo.normal);\n            \n\t\t\tvec3 randomDir = RandomUnitVector(rngState);\n        \trayDir = normalize(mix(reflectDir, randomDir, roughness));\n        \tif (dot(rayDir, hitInfo.normal) < 0.0f)\n            \trayDir *= -1.0f;        \n        \n        \t// move the ray away from the surface it hit a little bit\n        \trayPos += hitInfo.normal * c_rayPosNormalNudge;\n            \n            // Attenuate diffuse by the dot product of the outgoing ray and the normal (aka multiply diffuse by cosine theta or N dot L)\n            hitInfo.material.diffuse *= dot(hitInfo.normal, rayDir);\n            \n            // Make all future light affected be modulated by either the diffuse or specular reflection color\n            // depending on which we are doing.\n            colorMultiplier *= mix(hitInfo.material.diffuse, hitInfo.material.specular, doSpecular);                 \n        }\n        \n        // Russian Roulette\n        // Randomly terminate a path with a probability inversely equal to the throughput\n        {\n        \tfloat p = max(colorMultiplier.r, max(colorMultiplier.g, colorMultiplier.b));\n        \tif (RandomFloat01(rngState) > p)\n            \tbreak;\n\n        \t// Add the energy we 'lose' by randomly terminating paths\n        \tcolorMultiplier *= 1.0f / p;            \n        }\n    }\n    \n    return ret;\n}\n\n// =======================================================================\n// Orbit Camera\n// =======================================================================\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;\n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\n// =======================================================================\n// Main function\n// =======================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // add sub pixel jitter for anti aliasing\n    vec2 fragCoordJittered = fragCoord + (vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f);\n    \n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);\n    \n    // calculate the ray direction for this pixel\n    vec2 uvJittered = fragCoordJittered/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    vec3 rayDir;\n    {   \n\t\tvec2 screen = uvJittered * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // simulate a thin lens (depth of field and circular bokeh)\n    if (c_apertureRadius > 0.0f)\n    {\n        // calculate point on the focal plane\n        vec3 focalPlanePoint = cameraPos + rayDir * c_focalPlaneDistance;\n        \n        // calculate a random point on the aperture\n        float angle = RandomFloat01(rngState) * 2.0f * c_pi;\n\t\tfloat radius = sqrt(RandomFloat01(rngState)) * c_apertureRadius;\n\t\tvec2 offset = vec2(cos(angle), sin(angle)) * radius;\n        \n        // update the camera pos\n        cameraPos += offset.x * cameraRight + offset.y * cameraUp;\n        \n        // update the ray direction\n        rayDir = normalize(focalPlanePoint - cameraPos);  \n    }\n    \n    // get the linear color of the ray\n    vec3 color = GetColorForRay(cameraPos, rayDir, rngState, fragCoord);\n    \n    // integrate color with previous frame.\n    // incremental averaging: https://blog.demofox.org/2016/08/23/incremental-averaging/\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    vec4 oldColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (oldColor.a == 0.0f || iMouse.z > 0.0 || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / oldColor.a));\n    color = mix(oldColor.rgb, color, blend);    \n    fragColor = vec4(color, blend);\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Does first pass of Bloom (horizontal & conditional)\n    fragColor = vec4(BloomPass1(fragCoord.xy, iResolution.xy, iChannel0), 1.0f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslfzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 93, 572]], "test": "untested"}
{"id": "tdXBD7", "name": "frac demo2", "author": "okh0056", "description": "fractal using hyperbolic tangent", "tags": ["fractal"], "likes": 3, "viewed": 390, "published": 3, "date": "1588970960", "time_retrieved": "2024-07-30T21:07:55.436567", "image_code": "#define ANGLE 1.275\n#define DELTA 0.01315\n#define XOFF 0.9699\n\nfloat crd(float ang) {\n    return 2.*sin(ang/2.);\n}\nvec2 crd(vec2 ang) {\n    return 2.*sin(ang/2.);\n}\n\nfloat sec(float ang) {\n    return 1./cos(ang);\n}\nvec2 sec(vec2 ang) {\n    return 1./cos(ang);\n}\n\nfloat csc(float ang) {\n    return 1./sin(ang);\n}\nvec2 csc(vec2 ang) {\n    return 1./sin(ang);\n}\n\nfloat cot(float ang) {\n    return 1./tan(ang);\n}\nvec2 cot(vec2 ang) {\n    return 1./tan(ang);\n}\n\n#define time iTime\nmat2 mm2(in float a){float c = cot(a), s = sin(a);return mat2(c,-s,s,c);}\n\n\nfloat f(vec2 p, float featureSize)\n{\n\tp.x = cos(p.x*1.3+time*0.09)*tanh(time+p.x*0.13)*2.;\t\n    p += csc(p.x*3.5)*0.4;\n    return smoothstep(-0.01,featureSize,abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    float featureSize = 135./((iResolution.x*aspect+iResolution.y));\n\n    vec2 p = fragCoord.xy / iResolution.xy*4.5-1.5;\n\tp.x *= aspect;\n\tp.y = abs(p.y);\n\t\n\tvec3 col = vec3(0);\n\tfor(float i=2.;i<36.;i+=.33)\n\t{\n\t\tvec3 col2 = (cos(vec3(4.5,2.5,3.6)-i*0.45)*0.65+0.24)*(1.-f(p,featureSize));\n\t\tcol = max(col,col2);\n\t\t\n        p.x -= XOFF;\n        p.y -= tanh(time*0.31+1.5)*1.5+1.5;\n\t\tp*= mm2(i*DELTA+ANGLE);\n\t\t\n        vec2 pa = vec2(abs(p.x-0.9),abs(p.y));\n        vec2 pb = vec2(p.x,abs(p.y));\n        \n        p = mix(pa,pb,smoothstep(-.97,.97,log2(time*3.14)-1.1));\n\t}\n\tfragColor = vec4(col,.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 85, 85, 114], [115, 115, 135, 135, 164], [166, 166, 188, 188, 214], [215, 215, 235, 235, 261], [263, 263, 285, 285, 311], [312, 312, 332, 332, 358], [360, 360, 382, 382, 408], [409, 409, 429, 429, 455], [476, 476, 497, 497, 549], [552, 552, 588, 588, 723], [725, 725, 782, 782, 1431]], "test": "untested"}
{"id": "wsfBDB", "name": "Blurring Over SDF Surface", "author": "blackle", "description": "using the fancy PDE solving technique to blur across the surface of an SDF, could be useful to simulate subsurface scattering...\n\nVERY slow with ANGLE on chrome for some reason, sorry!", "tags": ["sdf"], "likes": 11, "viewed": 998, "published": 3, "date": "1588970111", "time_retrieved": "2024-07-30T21:07:56.359101", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define NO_UNROLL(k) (k+min(0,iFrame))\nconst float blur_strength = 0.1;\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(vec3(0), q)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat domino(vec3 p, mat3 topholes, mat3 bottomholes) {\n    float body = box(p, vec3(0.0,0.4,0.9))-0.2;\n    float holes = linedist(p, vec3(.2,0.45,0), vec3(0.2,-0.45,0))-0.04; //divider\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec2 holepos = vec2(float(i-1), float(j-1))*0.3;\n            if (topholes[i][j] == 1.) {\n                holes = min(holes, length(p-vec3(.2,holepos+vec2(0.,0.55)))-0.08);\n            }\n            if (bottomholes[i][j] == 1.) {\n                holes = min(holes, length(p-vec3(.2,holepos+vec2(0.,-0.55)))-0.08);\n            }\n        }\n    }\n    return -smin(-body, holes, 0.05);\n}\n\nfloat scene(vec3 p) {\n    float table = box(p-vec3(0,0,-1.2), vec3(3,3,0.05))-0.05;\n    float d1 = domino(erot(p-vec3(-1,0,0),vec3(0,0,1),3.1415-0.05), mat3(1,1,1,0,0,0,1,1,1), mat3(1,0,1,0,1,0,1,0,1));\n    float d2 = domino(erot(p-vec3(1,0,0),vec3(0,0,1),3.1415+0.1), mat3(1,0,1,0,0,0,1,0,1), mat3(0,0,1,0,0,0,1,0,0));\n    float dominos = min(d1,d2);\n    return min(dominos,table);\n}\n\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 norm(vec3 pos) {\n    vec3 eps = vec3(.01, 0, 0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++) {\n        nor += scene(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nvec3 srgb(float k) {\n    return vec3(k*k);\n}\n\nvec3 trilinear_texture(vec3 p, vec3 n) {\n    return mix(mix(texture(iChannel0,p.xz), texture(iChannel0,p.yz), n.x*n.x), texture(iChannel0,p.xy), n.z*n.z).xyz;\n}\n\nvec3 shade(vec3 p, vec3 cam) {\n\tvec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float ao = smoothstep(-1.,1.,scene(p+n*0.1)/.1);\n    float specao = smoothstep(0.,1.,scene(p+r*0.3)/.3)*0.5;\n\n    vec3 tex = trilinear_texture(p*.2,n);\n    float specmix = smoothstep(0.4,0.6,tex.y);\n    float specex = mix(50.,20.,specmix);\n\n    float diff = ao*length(sin(n*2.5)*0.5+0.5)/sqrt(3.)*0.9+0.1;\n    float spec = length(sin(r*2.5)*0.5+0.5)/sqrt(3.);\n    return tex*diff + pow(spec, specex)*specao;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    float blur_level = pow(0.5-cos(iTime)*0.5,2.);\n    if (fragCoord.y < 10.) {\n        float grad = sin(fragCoord.y/10.*3.14);\n        float bright = pow(clamp(sin(fragCoord.y/15.*3.14),0.,1.),20.);\n        float barpos = smoothstep(-1., 1., blur_level*iResolution.x - fragCoord.x);\n        fragColor.xyz = grad*mix(vec3(.1), vec3(.9,0.1,0), barpos) + bright*0.3;\n        return;\n    }\n\n    vec3 cam = normalize(vec3(2.,uv));\n    vec3 init = vec3(-10,0,0);\n\n   \tfloat yrot = 0.6;\n    float zrot = 0.9;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 500 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p, init) > 100.) break;\n    }\n\n    vec4 col = vec4(0);\n    vec3 n = norm(p);\n    float maxdist = max(scene(p+n*blur_strength),0.);\n    float seed = hash(hash(uv.x,uv.y), float(iFrame));\n    for (int i = 0; i < NO_UNROLL(10); i++) {\n        float blurfactor = mix(0.0,maxdist,blur_level);\n        vec3 p2 = p + n*blurfactor;\n        for (int v = 0; v < NO_UNROLL(5); v++) {\n            float h1 = hash(seed, hash(float(i),float(v)));\n            float h2 = hash(h1,h1);\n            float h3 = hash(h2,h2);\n            vec3 dir = normalize(tan(vec3(h1,h2,h3))-n);\n            float dist = scene(p2);\n            p2 += dir*dist;\n        }\n        col += vec4(shade(p2,cam), 1.);\n    }\n    fragColor.xyz = hit ? col.xyz/col.w : vec3(0.);\n    fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfBDB.jpg", "access": "api", "license": "cc0-1.0", "functions": [[322, 322, 352, 352, 431], [433, 433, 454, 454, 486], [488, 488, 515, 515, 610], [612, 612, 652, 652, 744], [746, 746, 784, 784, 848], [850, 850, 889, 889, 960], [962, 962, 1017, 1017, 1614], [1616, 1616, 1637, 1637, 2000], [2109, 2109, 2130, 2130, 2392], [2394, 2394, 2432, 2432, 2464], [2466, 2466, 2486, 2486, 2510], [2512, 2512, 2552, 2552, 2672], [2674, 2674, 2704, 2704, 3167], [3169, 3169, 3226, 3226, 5074]], "test": "untested"}
{"id": "wsXBWS", "name": "Comic Blobs", "author": "blackle", "description": "fiddling with different sampling methods to get cool effects", "tags": ["blobs", "npr", "comic"], "likes": 78, "viewed": 3492, "published": 3, "date": "1588966557", "time_retrieved": "2024-07-30T21:07:57.179907", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat bayer(ivec2 uv) {\n    return texelFetch(iChannel0,uv % 8,0).x;\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 k) {\n  int x = FK(k.x);int y = FK(k.y);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat hash3(vec3 k) {\n  float h1 = hash(k.xy);\n  return hash(vec2(h1, k.z));\n}\n\nvec3 hash33(vec3 k) {\n  float h1 = hash3(k);\n  float h2 = hash3(k*h1);\n  float h3 = hash3(k*h2);\n  return vec3(h1, h2, h3);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec3 sphercoord(vec2 p) {\n  float l1 = acos(p.x);\n  float l2 = acos(-1.)*p.y;\n  return vec3(cos(l1), sin(l1)*sin(l2), sin(l1)*cos(l2));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(p,ax);\n}\n\nfloat comp(vec3 p, vec3 ro, float t) {\n  vec3 ax = sphercoord(ro.xy);\n  p.z -= t;\n  p = erot(p, ax, ro.z*acos(-1.));\n  float scale = 4. + hash(ro.xz)*0.5+0.5;\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p) - 0.8;\n}\n\nfloat scene(vec3 p) {\n  float rad = 3.+p.z+sin(p.y/2.+iTime)+cos(p.x/3.+iTime*0.9);\n  float dist = 10000.;\n  for (int i = 0; i < 4; i++) {\n    vec3 rot = hash33(vec3(float(i+1), cos(float(i)), sin(float(i))));\n    float d = comp(p, rot, iTime/2.*(float(i+1)));\n    dist = smin(dist, d, 1.);\n  }\n  return mix(dist, rad, mix(0.3,0.8+sin(iTime)*0.2, 0.1));\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.1);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat march(vec3 p, vec3 bias, float seed) {\n    for (int i = 0; i < 10; i++) {\n        p += normalize(bias+tan(hash33(vec3(float(i),seed,2.))))*scene(p);\n    }\n    return sqrt(smoothstep(0.0,2.0,scene(p)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \n  vec3 cam = normalize(vec3(4.,uv));\n  vec3 init = vec3(-50,0,sin(iTime*0.37)*1.4);\n  cam = erot(cam, vec3(0,1,0), -0.5);\n  init = erot(init, vec3(0,1,0), -0.5);\n\n  vec3 p = init;\n  bool hit = false;\n  bool trig = false;\n  bool outline = false;\n  for (int i = 0; i < 500 && !hit; i++) {\n    float dist = scene(p);\n    if (dist<0.08) trig = true;\n    if (trig) {\n      float odist = 0.09-dist;\n      outline = odist<dist;\n      dist = min(dist,odist);\n    }\n    hit = dist*dist < 1e-6;\n    p += dist*cam;\n  }\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  vec2 ao = vec2(0);\n  for (int i = 0; i < 8; i++) {\n    ivec2 id = (ivec2(fragCoord/16.+vec2(iTime*10.,iTime*20.)) % 2)*2-1;\n    ao += vec2(march(p+n*0.1, r, bayer(ivec2(fragCoord)+i+ivec2(i/4,0))) , 1.);\n  }\n  ao.x/=ao.y;\n\n  fragColor.xyz = hit&&!outline ? vec3(ao.x) : vec3(0.);\n  fragColor.xyz = pow(smoothstep(vec3(0),vec3(1),sqrt(fragColor.xyz)),vec3(1.7,1.6,1.5));\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBWS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 217, 217, 264], [321, 321, 341, 341, 420], [422, 422, 443, 443, 500], [502, 502, 523, 523, 627], [629, 629, 670, 670, 756], [758, 758, 783, 783, 895], [897, 897, 935, 935, 999], [1001, 1001, 1039, 1039, 1221], [1580, 1580, 1599, 1599, 1709], [1711, 1711, 1755, 1755, 1920], [1923, 1923, 1980, 1980, 3050]], "test": "untested"}
{"id": "tdfBWB", "name": "point alignment", "author": "ich", "description": "see if points are aligned using hough transformation (hesse normal form)", "tags": ["huoughtransformationhessenormalformalignpoint"], "likes": 2, "viewed": 383, "published": 3, "date": "1588962708", "time_retrieved": "2024-07-30T21:07:57.935885", "image_code": "#define pi 3.141\n#define pi2 (pi * 2.f)\n\nfloat line(vec2 uv, float a) {\n\tvec2 d = vec2(cos(a), sin(a));\n\tfloat l = dot(uv, d);\n\treturn abs(l);\n}\n\nfloat line_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat circle(vec2 uv) {\n\treturn length(uv);\n}\n\nfloat hesse_normal_form(vec2 p, float a) {\n    float r = dot(vec2(1), p * vec2(cos(a), sin(a)));\n    return r;\n}\n\nvec3 render_color(vec3 l, float w, float b) {\n\treturn smoothstep(w, 0.f, l) * b;\n}\n\nvoid mainImage(out vec4 color, in vec2 output_coord) {\n\tif (output_coord.x >= iResolution.x || output_coord.y >= iResolution.y) return;\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\t// max distance to center in screen space\n\tfloat max_distance = length(vec2(aspect_ratio, 1));\n\n\t// coord in screen space (-.5, -.5) to (.5, .5)\n\tvec2 uv = (output_coord - iResolution.xy * .5) / iResolution.y;\n\n\t// mouse\n\tvec2 m = vec2(vec2(iMouse.xy) - iResolution.xy * .5) / iResolution.y;\n\n\t// rendering setup\n\tvec3 c = vec3(0); // output color\n\tvec3 l  = vec3(max_distance); // distance to closest rendered object\n\tfloat pixel_size = 1.f / iResolution.y; // size of a pixel in screen space\n\tfloat w = pixel_size * 2.f; // minimum width of rendered objects\n\n\t// render coordinate system\n\tl = min(l, line(uv, 0.f));\n\tl = min(l, line(uv, pi * .5));\n    // generate color from distance\n\tc += render_color(l, w, .3f);\n    // clear distance\n    l = vec3(max_distance);\n\n\t// angle of lines\n\tfloat a = iTime * .2f;\n\ta = mod(a, pi2);\n\n\t// define points\n\tvec2 ps[] = vec2[] (\n\t\tm,\n\t\tvec2(.5, .1),\n\t\tvec2(-.4, -.2)\n\t);\n\n\tfor (int i = 0; i < 3; ++i) {\n\t\t// render all points\n\t\tl[i] = min(l[i], circle(uv - ps[i]) - w * 2.f);\n\t\t// render all lines\n\t\tl[i] = min(l[i], line(uv - ps[i], a));\n\n        // hesse normal form dots\n        float r = hesse_normal_form(ps[i], a);\n\t\tvec2 pos = vec2(a / pi2 - .5f, r);\n        // normalize to screen space\n    \tpos.x *= aspect_ratio;\n        pos.y /= max_distance;\n        // render\n    \tl[i] = min(l[i], circle(uv - pos) - w * 2.f);\n    }\n    \n    // generate color from distance\n\tc += render_color(l, w, 1.f);\n    // clear distance\n    l = vec3(max_distance);\n        \n    for (int i = 0; i < 3; ++i) {\n        // hesse normal form lines\n        float resolution = 16.f;\n        vec2 prev_pos;\n        for (float j = 0.f; j < resolution; ++j) {\n            float a = j / (resolution - 1.f) * pi2;\n            float r = hesse_normal_form(ps[i], a);\n            vec2 pos = vec2(a / pi2 - .5f, r);\n            // normalize to screen space\n            pos.x *= aspect_ratio;\n            pos.y /= max_distance;\n            // render\n            if (j > 0.f) {\n    \t\t\t//l[i] = min(l[i], circle(uv - pos) - w * 2.f);\n            \tl[i] = min(l[i], line_segment(uv, pos, prev_pos));\n            }\n            prev_pos = pos;\n        }\n\t}\n    \n    // generate color from distance\n\tc += render_color(l, w, .3f);\n    // clear distance\n    l = vec3(max_distance);\n\t\n\tcolor = vec4(c, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 71, 71, 144], [146, 146, 190, 190, 309], [311, 311, 334, 334, 356], [358, 358, 400, 400, 470], [472, 472, 517, 517, 554]], "test": "untested"}
{"id": "WslfzS", "name": "Raymarched CRT", "author": "dean_the_coder", "description": "'Old skool' CRT monitor developed using raymarching.\n(Still getting the hang of occlusion and shadows...)", "tags": ["procedural", "3d", "raymarching", "crt", "webcam"], "likes": 10, "viewed": 522, "published": 3, "date": "1588957951", "time_retrieved": "2024-07-30T21:07:58.768659", "image_code": "float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\n// Smooth noise generator.\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    f = f * f * (3.0 - 2.0 * f); // smoothstep with no clamp.\n    \n    return mix(a, b, f.x) +\n           (c - a) * f.y * (1.0 - f.x) +\n           (d - b) * f.x * f.y;\n}\n\nmat2 rot(float ang) {\n\tfloat c = cos(ang);\n    float s = sin(ang);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdIntersect(float d1, float d2) { return max(d1, d2); }\n\nfloat sdFrame(vec3 p) {\n    float ang = 0.2;\n    \n    vec3 q = p;\n    q.y = abs(q.y);\n    \n    float tb = length((q.yz * rot(-ang)).x - 1.0);\n\n    q = p;\n    q.x = abs(q.x);\n    float lr = length((q.xz * rot(-ang)).x - 1.0);\n    \n    float d = smin(lr, tb, 0.05); // Smooth corners.\n    float dp = length(p.z) - 0.75; // Clip frame front/back.\n    \n    float surface = noise((p.xy + p.yz) * 60.0);\n    return sdIntersect(d, dp) - surface * 0.001;\n}\n\nfloat length6( vec3 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y+p.z,1.0/6.0); }\n\nfloat sdScreen(vec3 p) {\n    float d = length(p) - 1.1;\n    float d2 = length6(p) - 1.1;\n\n    float surface = noise((p.xy + p.yz) * 200.0);\n    return mix(d, d2, 0.8) - surface * 0.0001;\n}\n\nvec2 map(vec3 p) {\n    float d1 = sdFrame(p);\n    float d2 = sdScreen(p);\n    return d1 < d2 ? vec2(d1, 0.5) : vec2(d2, 1.5);\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks community! I didn't fancy deriving this...\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.0);\n        n += e * map(p + 0.0005 * e).x;\n    }\n    \n    return normalize(n);\n}\n\nfloat calcShadow(vec3 origin, vec3 lightOrigin, float fuzziness) {\n    float s = 1.0;\n    \n    vec3 rayDir = normalize(lightOrigin - origin);\n    float d = 1.0;\n    while (d < 20.0 && s > 0.0) {\n        float distToObj = map(origin + rayDir * d).x;\n        s = min(s, 0.5 + 0.5 * distToObj / (fuzziness * d));\n        d += clamp(distToObj, 0.2, 1.0);\n    }\n    \n    return smoothstep(0.0, 1.0, s);\n}\n\nfloat calcOcclusion(vec3 origin, vec3 n, float unu) {\n    float occ = 0.0;\n    float d = 0.01;\n    for (int i = 1; i < 5; i++) {\n        float h = map(origin + n * d).x;\n        occ += d - h;\n        d += 0.15;\n    }\n    \n    return 1.0 - clamp(occ * 0.5, 0.0, 1.0);\n}\n\nfloat calcSpec(vec3 rd, vec3 n, vec3 l)\n{\n    vec3 h = normalize(l - rd);\n    return pow(max(dot(h, n), 0.0), 100.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0); // z = -3.0\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec3 lightPos = normalize(vec3(5.0, 10.0, -10.0));\n    \n    float d = 0.01;\n    vec2 hit;\n    vec3 p;\n    for(float steps = 0.0; steps < 64.0; steps++) {\n        p = ro + rd * d;\n        vec2 dist = map(p);\n        if (abs(dist.x) < 0.001 * d) {\n\t\t\thit = dist;\n            break;\n        }\n        if (d > 8.0)\n            break;// todo - limit max dist\n        \n        d += dist.x;\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (hit.y > 0.0) {\n        vec3 n = calcNormal(p);\n        float mainLight = clamp(dot(n, lightPos), 0.2, 1.0);\n\t\tfloat occ = calcOcclusion(p, n, 0.5);\n        vec3 rearLight = vec3(0.1, 1.0, 0.1) * clamp(dot(n, vec3(0.0, 0.0, -1.0)), 0.0, 1.0);\n            \n        if (hit.y > 1.0) {\n            // Hit screen.\n            vec2 t = uv * 0.85;\n            t.x *= mix(1.0, 2.0, pow(abs(t.x) / 0.5, 5.0));\n            vec3 tex = texture(iChannel0, t + 0.5).rgb;\n            float lum = 0.2126 * tex.r + 0.7152 * tex.g + 0.0722 * tex.b;\n            float scanline = 0.3 + 0.7 * floor(mod(t.y * iResolution.y * 0.3 / cos(p.x * 0.5), 2.0));\n            col = vec3(0.1, 1.0, 0.1) * pow(lum * 2.0, 1.7) * pow(mainLight, 3.0) * scanline;\n        } else {\n            // Hit frame.\n\t        col = vec3(mainLight);\n            col *= calcShadow(p + 0.01 * d, lightPos, 1.0);\n\t        col += rearLight;\n        }\n        \n        col *= pow(occ, 2.0);\n        col += calcSpec(rd, n, lightPos) * 0.3;\n    }\n    \n    fragColor = vec4(pow(col , vec3(0.4545)), 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 84], [86, 113, 134, 134, 498], [500, 500, 521, 521, 598], [600, 600, 641, 641, 725], [727, 727, 766, 766, 788], [790, 790, 813, 813, 1238], [1240, 1240, 1265, 1265, 1316], [1318, 1318, 1342, 1342, 1506], [1508, 1508, 1526, 1526, 1635], [1637, 1637, 1665, 1722, 1937], [1939, 1939, 2005, 2005, 2338], [2340, 2340, 2393, 2393, 2608], [2610, 2610, 2651, 2651, 2729], [2731, 2731, 2788, 2788, 4421]], "test": "untested"}
{"id": "wsXfWS", "name": "Euler Spoiler", "author": "qwert33", "description": "Inspired by:\nhttps://www.youtube.com/watch?v=qu04xLNrk94\nhttps://youtu.be/ovaZ-YlAjHY?list=PLIwiAebpd5CIEPbQua9XO3iodtZ4bjWa-&t=1373\n", "tags": ["euler", "numberphile", "spoiler"], "likes": 5, "viewed": 434, "published": 3, "date": "1588957160", "time_retrieved": "2024-07-30T21:07:59.578493", "image_code": "const vec4 background = vec4(.2, .2, .2, 1.);\n\n// generated with https://medialab.github.io/iwanthue/\n// ordered to minimize travelling salesman distance.\nconst vec3[11] colors = vec3[11](\n    vec3(115./255., 124./255., 208./255.),\n    vec3(89./255., 51./255., 151./255.),\n    vec3(74./255., 154./255., 93./255.),\n    vec3(104./255., 180./255., 61./255.),\n    vec3(155./255., 149./255., 52./255.),\n    vec3(208./255., 133./255., 59./255.),\n    vec3(221./255., 78./255., 67./255.),\n    vec3(147./255., 56./255., 41./255.),\n    vec3(189./255., 74./255., 124./255.),\n    vec3(200./255., 90./255., 197./255.),\n    \n    vec3(115./255., 124./255., 208./255.) // first one repeated\n);\n\nint[100] outer = int[100](\n    6,7,8,0,1,2,3,4,5,9,\n    1,4,7,5,2,0,9,6,8,3,\n    3,6,4,1,8,9,5,7,0,2,\n    5,3,0,7,9,4,6,8,2,1,\n    2,8,6,9,3,5,7,1,4,0,\n    7,5,9,2,4,6,0,3,1,8,\n    4,9,1,3,5,8,2,0,6,7,\n    9,0,2,4,7,1,8,5,3,6,\n    8,1,3,6,0,7,4,2,9,5,\n    0,2,5,8,6,3,1,9,7,4 );\n\nint[100] inner = int[100](\n    4,5,6,7,8,0,1,2,3,9,\n    7,9,3,6,1,4,2,0,8,5,\n    9,2,5,0,3,1,8,7,6,4,\n    1,4,8,2,0,7,6,5,9,3,\n    3,7,1,8,6,5,4,9,0,2,\n    6,0,7,5,4,3,9,8,2,1,\n    8,6,4,3,2,9,7,1,5,0,\n    5,3,2,1,9,6,0,4,7,8,\n    2,1,0,9,5,8,3,6,4,7,\n    0,8,9,4,7,2,5,3,1,6 );\n\nvec3 color_cycled(int i) {\n    i = (i + int(iTime)) % 10;\n\t// Here we assume colors has the first one repeated rather than doing the usual mod 10;\n    float t = fract(iTime);\n    t = mix(t, smoothstep(0., 1., t), .2);\n    return mix(colors[i], colors[i+1], t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // put things into a square\n    uv.x -= .5;\n    uv.x /= iResolution.y / iResolution.x;\n    uv.x += .5;\n    \n    if (uv.x < .0 || uv.x > 1.) {\n        fragColor = background;\n        return;\n    }\n    \n    // 10x10 grid.\n    vec2 grid = uv * 10.;\n    uv = fract(grid); \n    \n    // center-based coordinates\n    uv -= .5;\n    uv = abs(uv*2.);\n    \n    vec3 col = background.rgb;\n    \n    \n    if (max(uv.x, uv.y) < 0.50) col.rgb = color_cycled(outer[int(grid.x) + 10*int(grid.y)]);\n    if (max(uv.x, uv.y) < 0.25) col.rgb = color_cycled(inner[int(grid.x) + 10*int(grid.y)]);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1239, 1239, 1265, 1265, 1501], [1503, 1503, 1560, 1610, 2291]], "test": "untested"}
{"id": "wdXfWS", "name": "Adam Bomb", "author": "yasuo", "description": "reference images:https://thehundreds.com/products/adam-bomb-puzzle?variant=31914407297098", "tags": ["reproduction"], "likes": 11, "viewed": 384, "published": 3, "date": "1588952867", "time_retrieved": "2024-07-30T21:08:00.393315", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 lineTex(vec2 uv)\n{\n    float stripeSize = 50.0;\n    float t = iTime*10.0;\n    return vec3(tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize);\n}\n\nvec3 bom(vec2 p, vec3 col){\n    vec2 prevP = p;\n    col = mix(col,vec3(0.0),S( length(p)-0.25,0.0)); // bg\n    \n    p.x*=0.95;\n    col = mix(col,vec3(0.0),S( length(p-vec2(0.0,0.27))-0.07,0.0));\n    \n\tp = prevP;\n    float d = abs(length(p)-0.25)-0.005;\n    \n    vec2 p2 = p-vec2(0.0,0.3);\n    p2.y*=1.7;\n    \n    d = max(-sdBox(p-vec2(0.0,0.25),vec2(0.07,0.05)),d);\n    \n    float d2 = abs(length(p2)-0.07)-0.006;\n    d = min(d,d2);\n    \n    vec2 p3 = p-vec2(0.0,0.25);\n    float d3 = abs(sdBox(p3,vec2(0.07,0.05)))-0.006;\n    d3 = max(-(length(p2)-0.07),d3);\n    d = min(d,d3);\n    \n    vec2 p4 = p-vec2(0.0,0.2);\n    p4.y*=1.7;\n    float d4 = abs(length(p4)-0.07)-0.006;\n    d4 = max((p4.y),d4);\n    d = min(d,d4);\n    d = max(-(length(p4)-0.065),d);\n    \n    vec2 p5 = p-vec2(0.02,0.03);\n    p5*=Rot(radians(-20.0));\n    p5.x*=2.0;\n    \n    float d5 = length(p5)-0.07;\n    d = min(d,d5);\n    \n    vec2 p6 = p-vec2(0.013,0.05);\n    p6*=Rot(radians(-20.0));\n    p6.x*=3.0;\n    p6.y*=1.8;\n    \n    float d6 = length(p6)-0.07;\n    d = max(-d6,d);\n    \n    vec2 p7 = p-vec2(0.12,0.09);\n    p7*=Rot(radians(-20.0));\n    p7.x*=2.0;\n    p7.y*=1.1;\n    \n    float d7 = length(p7)-0.07;\n    d = min(d,d7);\n    \n    vec2 p8 = p-vec2(0.115,0.105);\n    p8*=Rot(radians(-20.0));\n    p8.x*=3.2;\n    p8.y*=2.0;\n    \n    float d8 = length(p8)-0.07;\n    d = max(-d8,d);\n    \n    float d9 = length(p)-0.22;\n    p.y*=0.8;\n    float d10 = length(p)-0.2;\n    d9 = max(-d10,d9);\n    d9 = max(p.x,d9);\n    p = prevP;\n    \n    float d11 = sdBox((p-vec2(0.0,0.15))*Rot(radians(-20.0)),vec2(0.3,0.015));\n    d9 = max(-d11,d9);\n    \n    d = min(d,d9);\n\n    vec2 p9 = p-vec2(0.1,-0.14);\n    p9*=Rot(radians(-40.0));\n    p9.y*=2.0;\n    float d12 = length(p9)-0.08;\n    \n    vec2 p10 = p-vec2(0.16,-0.17);\n    p10*=Rot(radians(0.0));\n    p10.x*=2.0;\n    float d13 = length(p10)-0.08;\n    d12 = max(-d13,d12);\n    \n    d = min(d,d12);\n    \n    vec2 p11 = p-vec2(-0.04,0.2);\n    float d14 = sdBox(p11,vec2(0.007,0.028));\n    d = min(d,d14);\n        \n    vec2 p12 = p-vec2(-0.04,0.255);\n    float d15 = sdBox(p12,vec2(0.007,0.011));\n    d = min(d,d15);\n    \n    \n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    \n    vec2 p13 = p-vec2(0.0,0.37);\n    const float k = 3.0;\n    float c = cos(k*p13.y);\n    float s = sin(k*p13.y);\n    mat2  m = mat2(c,-s,s,c);\n    \n    \n    d = sdBox((p13*m)*Rot(radians(10.0)),vec2(0.022,0.07));\n    col = mix(col,lineTex(p),S(d,0.0));\n    \n    return col;\n}\n\nvec3 fire(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = sdTriangle(p,vec2(0.0,0.2),vec2(0.1,-0.2),vec2(-0.1,-0.2));\n    \n    p.x = abs(p.x);\n    vec2 p2 = (p-vec2(0.15,-0.1));\n    p2*=Rot(radians(45.0));\n    \n    float d2 = sdTriangle(p2,vec2(0.0,0.15),vec2(0.1,-0.1),vec2(-0.1,-0.1));\n    d = min(d,d2);\n    \n    p2 = (p-vec2(0.15,-0.2));\n    p2*=Rot(radians(100.0));\n    d2 = sdTriangle(p2,vec2(0.0,0.3),vec2(0.06,-0.1),vec2(-0.06,-0.1));\n    d = min(d,d2);\n    \n    p2 = (p-vec2(0.15,-0.25));\n    p2*=Rot(radians(110.0));\n    d2 = sdTriangle(p2,vec2(0.0,0.1),vec2(0.03,-0.1),vec2(-0.03,-0.1));\n    d = min(d,d2);\n    \n    p2 = (p-vec2(0.15,-0.3));\n    p2*=Rot(radians(130.0));\n    d2 = sdTriangle(p2,vec2(0.0,0.23),vec2(0.06,-0.1),vec2(-0.06,-0.1));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.8,0.7,0.0),S(d,0.0));\n    \n    col = mix(col,vec3(0.7,0.3,0.0),S(abs(d)-0.01,0.0));\n    return col;\n}\n\nvec3 chara(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    p*=1.0+sin(iTime*6.0)*0.05;\n    col = fire(p-vec2(0.0,0.43),col);\n    \n    p = prevP;\n    col = bom(p,col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 prevUV = uv;\n    vec3 col = vec3(0.0);\n\tfloat t = iTime*0.1;\n    \n    uv-=t;\n    uv*=1.5;\n    uv.x = mod(uv.x,0.52)-0.26;\n    uv.y = mod(uv.y,1.1)-0.55;\n    col = bom(uv,col);\n    uv = prevUV;\n    \n    uv-=t;\n    uv*=1.5;\n    uv.x += 0.26;\n    uv.x = mod(uv.x,0.52)-0.26;\n    \n    uv.y -= 0.55;\n    uv.y = mod(uv.y,1.1)-0.55;\n    \n    col = bom(uv,col);\n    \n    uv = prevUV;\n    uv*=1.5;\n    col = chara((uv-vec2(0.7,0.35))*Rot(radians(120.0)),col);\n    \n    uv = prevUV;\n    uv*=1.2;\n    col = chara((uv-vec2(-0.6,0.2))*Rot(radians(200.0)),col);\n        \n    uv = prevUV;\n    uv*=1.3;\n    col = chara((uv-vec2(0.85,-0.35))*Rot(radians(260.0)),col);\n    \n    uv = prevUV;\n    col = chara(uv-vec2(0.0,-0.2),col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 210, 247, 247, 327], [329, 380, 447, 447, 1012], [1014, 1014, 1037, 1037, 1277], [1279, 1279, 1306, 1306, 3736], [3738, 3738, 3767, 3767, 4649], [4651, 4651, 4681, 4681, 4836], [4838, 4838, 4895, 4895, 5732]], "test": "untested"}
{"id": "WsffWB", "name": "halftweet Rainbow (68/82 ch)", "author": "izutionix", "description": " ", "tags": ["rainbow", "short", "onetweet", "halftweet"], "likes": 9, "viewed": 298, "published": 3, "date": "1588942634", "time_retrieved": "2024-07-30T21:08:01.284931", "image_code": "//68 chars, sacrificing resolution independency\n//#define mainImage(O, U) O = pow( cos( U.y/2e2-vec4(.5, .75, 1, 0) ), vec4(16) )\n\n//82 chars\nvoid mainImage(out vec4 O, vec2 U) { O = pow( cos( 1.5*U.y/iResolution.y-vec4(.5, .75, 1, 0) ), vec4(16) ); }\n\n/*\n//98 chars\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O = pow(cos( 1.5*U.y/iResolution.y-vec4(.5, .75, 1, 0) ), vec4(16) );\n}\n\n//172 chars\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float R = iResolution.y;\n    float g = (2.5*fragCoord.y-R)/R;\n    \n    vec3 col = cos(g-vec3(0,.25,.5));\n\n    fragColor = vec4(pow(col, vec3(8)),1);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsffWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 142, 178, 178, 251]], "test": "untested"}
{"id": "3sfBWB", "name": "Zoom blur filter", "author": "luluco250", "description": "Attempt to replicate the effect in GOG Galaxy 2.0's background images.", "tags": ["2d", "blur", "zoom", "filter", "bloom"], "likes": 3, "viewed": 697, "published": 3, "date": "1588937846", "time_retrieved": "2024-07-30T21:08:02.168569", "image_code": "const float BlurZoom = 5.0;\nconst float BlurZoomInv = 1.0 / BlurZoom;\n\nconst int BlendMode_Mix = 0;\nconst int BlendMode_Screen = 1;\n\nconst int BlendMode = BlendMode_Mix;\nconst float BlendAmount = 0.5;\n\n#define scale_uv(uv, scale, center) ((uv - center) * scale + center)\n\nvec3 blend_screen(vec3 a, vec3 b, float w)\n{\n    return 1.0 - (1.0 - a) * (1.0 - b * w);\n}\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color = texture(iChannel0, uv);\n    \n    vec3 blur = texture(iChannel1, scale_uv(uv, BlurZoomInv, 0.5)).rgb;\n    \n    if (BlendMode == BlendMode_Mix)\n        color.rgb = mix(color.rgb, blur, BlendAmount);\n    else if (BlendMode == BlendMode_Screen)\n        color.rgb = blend_screen(color.rgb, blur, BlendAmount);\n    \n    // Switch doesn't work for some machines.\n    /*switch (BlendMode)\n    {\n        case BlendMode_Mix:\n    \t\tcolor.rgb = mix(color.rgb, blur, BlendAmount);\n        \tbreak;\n        case BlendMode_Screen:\n        \tcolor.rgb = blend_screen(color.rgb, blur, BlendAmount);\n        \tbreak;\n    }*/\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    color = texture(iChannel0, coord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const float Pi = 3.14159;\nconst float DoublePi = Pi * 2.0;\n\nconst int BlurSamples = 27;\nconst float BlurSigma = 7.0;\nconst float BlurScale = 2.0;\n\nfloat gaussian(float x, float sigma)\n{\n    float o = sigma * sigma;\n    return\n        (1.0 / sqrt(DoublePi * o)) *\n        exp(-((x * x) / (2.0 * o)));\n}\n\nvec3 blur(sampler2D sp, vec2 uv, vec2 dir, int samples)\n{\n    float halfSamples = float(samples) * 0.5;\n    uv -= dir * halfSamples;\n    \n    float x = -halfSamples;\n    float weight = gaussian(abs(x++), BlurSigma);\n    vec4 color = vec4(texture(sp, uv).rgb, 1.0) * weight;\n    \n    for (int i = 1; i < samples; ++i)\n    {\n        uv += dir;\n        weight = gaussian(abs(x++), BlurSigma);\n        color += vec4(texture(sp, uv).rgb, 1.0) * weight;\n    }\n    \n    color.rgb /= color.a;\n    return color.rgb;\n}\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    \n    color.rgb = blur(\n        iChannel0,\n        coord * ps,\n        vec2(ps.x * BlurScale, 0.0),\n        BlurSamples);\n    color.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const float Pi = 3.14159;\nconst float DoublePi = Pi * 2.0;\n\nconst int BlurSamples = 27;\nconst float BlurSigma = 7.0;\nconst float BlurScale = 2.0;\n\nfloat gaussian(float x, float sigma)\n{\n    float o = sigma * sigma;\n    return\n        (1.0 / sqrt(DoublePi * o)) *\n        exp(-((x * x) / (2.0 * o)));\n}\n\nvec3 blur(sampler2D sp, vec2 uv, vec2 dir, int samples)\n{\n    float halfSamples = float(samples) * 0.5;\n    uv -= dir * halfSamples;\n    \n    float x = -halfSamples;\n    float weight = gaussian(abs(x++), BlurSigma);\n    vec4 color = vec4(texture(sp, uv).rgb, 1.0) * weight;\n    \n    for (int i = 1; i < samples; ++i)\n    {\n        uv += dir;\n        weight = gaussian(abs(x++), BlurSigma);\n        color += vec4(texture(sp, uv).rgb, 1.0) * weight;\n    }\n    \n    color.rgb /= color.a;\n    return color.rgb;\n}\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    \n    color.rgb = blur(\n        iChannel0,\n        coord * ps,\n        vec2(0.0, ps.y * BlurScale),\n        BlurSamples);\n    color.a = 1.0;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 316, 316, 362], [364, 364, 408, 408, 1093]], "test": "untested"}
{"id": "3dffDS", "name": "Satanic Torture Ball", "author": "blackle", "description": "Fibonacci lattice on a sphere defines the locations of the prongs on this strange device. who's inside the ball? is this justice?", "tags": ["ball"], "likes": 30, "viewed": 829, "published": 3, "date": "1588936520", "time_retrieved": "2024-07-30T21:08:03.135982", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//uncomment for fake reflections\n//#define FAKEREF\n//uncomment for outlines\n//#define OUTLINES\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 q = abs(p)-b;\n    return super(max(q,0.))+min(0.,max(q.x,q.y));\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p)-b;\n    return super(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec3 local;\nfloat brt;\nfloat scene(vec3 p) {\n    local = p;\n    float bump = smoothstep(0.5,0.,length(sin(p*10.))/sqrt(3.));\n    float sphere = length(p)-1.+bump*0.02;\n    brt = 1.;\n\n    vec2 uvs = map_from_sphere(p);\n    vec4 data = texelFetch(iChannel0, ivec2(uvs*iChannelResolution[0].xy), 0);\n    vec3 closest = data.xyz;\n\n    float rot = hash(closest.z,closest.y)*PI*2.;\n    float off = smoothstep(-0.9,0.9,sin(hash(rot,closest.x)*PI*2.+iTime*8.))*0.4-0.2;\n\n    //map to box coordinates\n    p -= closest;\n    vec3 b1 = normalize(cross(closest,vec3(0,0,1)));\n    vec3 b2 = cross(b1, closest);\n    vec3 crds = vec3(dot(p,closest), dot(p,b1), dot(p,b2));\n    crds = erot(crds,vec3(1,0,0),rot);\n    float hole = box(vec2(crds.x,box(crds.yz, vec2(0.04))-.01),vec2(0.01))-.01;\n    if(hole < sphere) brt = 0.4;\n    sphere = smin(sphere, hole, 0.05);\n    \n    crds.x -= off;\n    float obj = box(crds,vec3(0.3,0.005,0.005));\n    vec3 xcrd = abs(crds-vec3(.3,0,0));\n    xcrd.yz = vec2(max(xcrd.y,xcrd.z),min(xcrd.y,xcrd.z));\n    obj = smin(obj, box(xcrd,vec3(0.005,0.1,0.005)), 0.01);\n    obj = smin(obj, length(xcrd-vec3(0,.1,0))-0.02, 0.01);\n    obj = smin(obj, length(crds-vec3(0.34,0,0))-0.02, 0.01);\n    obj -= 0.02;\n    if (obj < sphere) {\n        brt = 0.7 * smoothstep(-0.2,0.3,crds.x);\n    \tlocal = crds+rot*10.;\n    } else if (sphere < 0.01) {\n    \tvec2 uvs2 = map_from_sphere(closest)-uvs;\n        brt *= smoothstep(0.0,0.02, length(uvs2*vec2(2,0.5)+vec2(0,.01))-uvs2.y*0.1)*0.5+0.5;\n    }\n    return min(sphere, obj*0.9);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.0001);\n    return normalize(scene(p)- vec3(scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nfloat trilinear(vec3 p, vec3 n) {\n    \n    float xy = texture(iChannel1, p.xy).x;\n    float zy = texture(iChannel1, p.zy).x;\n    float xz = texture(iChannel1, p.xz).x;\n    return mix(mix(xy,zy, n.x*n.x),xz,n.y*n.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    //fragColor.xyz = cos(texelFetch(iChannel0, ivec2(fragCoord),0)*80.).xxx*0.5+0.5;\n    //return;;\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-5,0,0);\n\n   \tfloat yrot = asin(sin(iTime*2.3)*0.95)*0.3;\n    float zrot = 3.5-asin(sin(iTime*0.54)*0.99)*1.5;\n    if (iMouse.z > 0.) {\n        yrot = -4.*mouse.y;\n        zrot = 4.*mouse.x+3.5;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n#ifdef OUTLINES\n    bool triggered = false;\n    bool outline = false;\n#endif\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n#ifdef OUTLINES\n        if (dist < 0.009) triggered = true;\n        if (triggered) {\n            float odist = 0.01-dist;\n            outline = odist < dist;\n            dist = min(odist, dist);\n        }\n#endif\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if(distance(p,init)>7.)break;\n    }\n#ifdef OUTLINES\n    if (outline) {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec3 l = local;\n    float lbrt = brt;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    vec2 uvs = map_from_sphere(p);\n    vec4 data = texture(iChannel0, uvs);\n    float str = smoothstep(0.1,0.0,data.w);\n\n#ifdef FAKEREF\n\tvec2 ao = vec2(0);\n    for (int i = 0; i < 10; i++) {\n        vec3 p2 = p+n*.1;\n        for (int j = 0; j < 10; j++) {\n            float h1 = hash(float(i),float(j));\n            float h2 = hash(h1, h1);\n            float h3 = hash(h1, h2);\n            p2 += normalize(tan(vec3(h1,h2,h3))+r*2.)*scene(p2)*.9;\n        }\n        ao += vec2(smoothstep(-0.1,0.1,scene(p2)),1.);\n    }\n    ao.x/=ao.y;\n#else\n    vec2 ao = vec2(1);\n#endif\n    \n    float tex = trilinear(l*2.+data.w, n)*smoothstep(0.7,0.4,trilinear(l*0.1+2., n));\n    float tex2 = trilinear(l*0.25, n);\n    float spexex = mix(15.,5.,tex);\n    float spec = ao.x*length(sin(r*2.5)*0.5+0.5)/sqrt(3.)*(1.-pow(dot(r,n),2.)*.1);\n    float diff = lbrt*mix(length(sin(n*2.5)*0.5+0.5)/sqrt(3.), spec,0.95);\n\n    \n    vec3 col = mix(srgb(0.1,0.03,0.01), srgb(0.5,0.3,0.3), diff) + pow(spec, spexex)*1.5;\n\n    col = abs(erot(col, normalize(p.zyx), tex2*0.2));\n    col = abs(erot(col, normalize(p), str*0.1));\n    fragColor.xyz = sqrt(hit ? col : smoothstep(1.,0.,length(uv))*vec3(0.1));\n    fragColor.xyz = smoothstep(vec3(-0.2),vec3(1.2),fragColor.xyz) + hash(hash(uv.x,uv.y),float(iFrame))*0.02;\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592653;\nconst int NUM_POINTS = 50;\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvec3 map_to_sphere(vec2 p)\n{\n    float theta = (p.x-0.5)*PI*2.;\n    float phi = (p.y-0.5)*PI*2.;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec2 map_from_sphere(vec3 p)\n{\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\n    if (iFrame != 0) {\n        fragColor = texelFetch(iChannel0,ivec2(iResolution.xy),0);\n    }\n    \n    float dist = 10000.;\n    vec3 closest = vec3(0);\n\n\tfloat gr = (sqrt(5.0) + 1.0) / 2.0;\n    float ga = (2.0 - gr) * (2.0*PI);\n\n    vec3 uvs = map_to_sphere(uv);\n    for (int i = 0; i < NUM_POINTS; i++) {\n        float lat = asin(-1.0 + 2.0 * float(i+1) / float(NUM_POINTS+1));\n        float lon = ga * float(i+1);\n\n        vec3 p = vec3(sin(lon)*cos(lat), cos(lon)*cos(lat),sin(lat));\n        float d = distance(p,uvs);\n        if (d < dist) {\n            closest = p;\n        }\n        dist = smin(dist,d,0.01);\n    }\n    fragColor = vec4(closest, dist);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dffDS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[290, 290, 328, 328, 394], [396, 396, 417, 417, 449], [451, 451, 472, 472, 504], [506, 506, 533, 533, 608], [610, 610, 637, 637, 721], [778, 778, 808, 808, 887], [912, 912, 933, 933, 2419], [2421, 2421, 2440, 2440, 2557], [2559, 2559, 2597, 2597, 2629], [2631, 2631, 2664, 2664, 2848], [2850, 2850, 2907, 2907, 5538]], "test": "untested"}
{"id": "WdsBzS", "name": "Loopless Conic Envelope", "author": "mla", "description": "Draw a net of lines tangent to a conic section and passing through a \"baseline\" that follows the mouse (end  points to baseline shown). The lines nearest the pixel point are calculated completely looplessly.", "tags": ["envelope", "conic", "projective", "loopless"], "likes": 9, "viewed": 412, "published": 3, "date": "1588924976", "time_retrieved": "2024-07-30T21:08:03.953795", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Loopless Conic Envelopes\n// Matthew Arcus, mla, 2020\n//\n// A demo of drawing envelopes of conic curves looplessly\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nconst float PI = 3.1415927;\nint AA = 2;\n\n// With homogeneous coordinates, (x,y,z) corresponds to the Euclidean\n// point (x/z,y/z), so (kx,ky,kz) represents the same point for any\n// k. z can be regarded as a \"scaling\" parameter, so (x,y,0)\n// represents a point infinitely far away (like a vanishing point in a\n// perspective drawing it can be regarded as a pure direction), in\n// fact, a point on the \"line at infinity\", equation z = 0.\n//\n// Lines also are represented as l = vec3(a,b,c) with point p being on line l\n// just when dot(l,p) = 0, again, multiples of (a,b,c) represent the\n// same line, so (a,b,c) represents the Euclidean line ax+by+c = 0.\n//\n// If l1 and l2 are lines, join(l1,l2) is their intersection, and if p1,p2 are\n// points, then join(p1,p2) is the line between them. join is just\n// cross product:\n\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Actually drawing a point or a line or a conic involves Euclidean notions of\n// scale and distance, so we need to convert to Euclidean points (or do something\n// equivalent), so to draw a point, we need the distance between the pixel point\n// and the point being drawn (we can look on this as mapping both points to the\n// z=1 plane and measuring distances there):\n\nfloat point(vec3 p, vec3 q) {\n  return distance(p.xy/p.z,q.xy/q.z);\n}\n\n// We can short circuit the calculations a little:\n// If p = (x,y,z) and l = (a,b,c) then (x/z,y/z) is the Euclidean point\n// and if |(a,b)| = 1, then the distance to the line is ax+by+c:\nfloat line(vec3 p, vec3 l) {\n  return abs(dot(p,l)/(p.z*length(l.xy)));\n}\n\n// For a line given by two points, just join the points into a line:\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\n// A conic curve is represented by a 3x3 symmetric matrix A and p is on the\n// conic just when dot(p,A*p) = dot(p*A,p) = 0. Lines tangent to the conic then\n// satisfy dot(l,inverse(A)*l) = dot(l*inverse(A),l) = 0 (points and lines\n// are dual).\n//\n// For simple conics where the matrix is diagonal, we can just use a\n// a vector to represent the conic, the code is much the same:\n//\n// To turn the conic equation into a distance function, we need to\n// divide by the magnitude of the gradient, and the gradient at p is\n// just 2.0*A*p (analogous to dx^2/dx = 2x):\nfloat conic(vec3 p, mat3 A) {\n  float s = dot(p,A*p);\n  vec3 ds = 2.0*A*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\n// Note, this is solving at^2 + 2bt + c = 0, so the discriminant is\n// b^2 - ac, not b^2 - 4ac.\nbool quadratic(float a, float b, float c, out float t1, out float t2) {\n  // Assumes we have checked for a == 0 or c == 0\n  float disc = b*b-a*c;\n  if (disc < 0.0) return false;\n  if (b >= 0.0) {\n    // Try to avoid rounding error.\n    t1 = -b-sqrt(disc);\n    t2 = c/t1; t1 /= a;\n  } else {\n    t2 = -b+sqrt(disc);\n    t1 = c/t2; t2 /= a;\n  }\n  return true;\n}\n\n// Find the intersections of the line through p0,p1 with the conic\n// defined by A by solving a quadratic equation.\n// (or dually, find the tangent lines to A through join of lines p0,p1).\nbool intersection(vec3 p0, vec3 p1, mat3 A, out vec3 q0, out vec3 q1) {\n  // Any line through p0, p1 is expressible as p0+t*p1,\n  // so solve (p0 + t*p1)A((p0 + t*p1) = 0 =>\n  // p0*A*p0 + 2*t*p0*A*p1 + t^2*p1*A*p1 = 0\n  // We have a quadratic equation:\n  float a = dot(p1,A*p1), b = dot(p0,A*p1), c = dot(p0,A*p0);\n  // a==0 or c==0 indicate p1 or p0 are actually on conic\n  if (a == 0.0) { q0 = q1 = p1; return true; }\n  if (c == 0.0) { q0 = q1 = p0; return true; }\n  float t1,t2;\n  if (!quadratic(a,b,c,t1,t2)) return false;\n  q0 = p0 + t1*p1;\n  q1 = p0 + t2*p1;\n  return true;\n  \n}\n\n// Find the tangents to a conic from the point z, since this involves\n// solving a quadratic equation, there may be no (real) solution, so\n// return a boolean to indicate success or otherwise.\nbool tangents(vec3 z, mat3 A, out vec3 tan1, out vec3 tan2) {\n  // Construct two lines through the point - assuming that z is not at\n  // infinity, l1 and l2 will be distinct.\n  vec3 l1 = join(z,vec3(1,0,0));\n  vec3 l2 = join(z,vec3(0,1,0));\n  return intersection(l1,l2,A,tan1,tan2);\n}\n\n// crossratio(infinity,p,q,r) = pr/pq\n// Assumes p,q,r are collinear.\n// -1 if p is midpoint of q and r\n// r = p + k(q-p) or r = (1-k)p + kq where k = ratio(p,q,r)\nfloat ratio(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z;\n  return dot(r-p,q-p)/dot(q-p,q-p);\n}\n\nvec3 getcolor(vec3 z, vec3 pointer) {\n  // This is just a plain unit circle, which seems very dull,\n  mat3 A = mat3(1,0,0,\n                0,1,0,\n                0,0,-1);\n  // until we rotate it in projective space, when it transitions\n  // to ellipse, parabola, hyperbola, then back to parabola,\n  // ellipse and circle.\n  float t = iTime;\n  mat3 rot = mat3(cos(t),0,sin(t),\n                  0,1,0,\n                  -sin(t),0,cos(t));\n  A = A*rot;\n\n  // We use the inverse of the conic matrix to find lines.\n  mat3 Ainv = inverse(A);\n\n  float dconic = conic(z,A); // The distance to the conic\n\n  // Draw the grid of tangent lines to the conic, with lines\n  // passing through a baseline:\n  vec3 base0 = vec3(-1,0,1);\n  vec3 base1 = pointer;\n  vec3 baseline = join(base0,base1);\n  vec3 tan1, tan2; // Put tangent solutions here\n  float ldist = dconic; // This will be minimum distance to a line,\n  float pdist = 1e8; // and the minimum distance to a point\n  pdist = min(pdist,point(z,2.0*base0-base1)); // Opposite baseline end\n  if (tangents(z,Ainv,tan1,tan2)) {\n    // Find where the tangents hit the baseline\n    vec3 z1 = join(tan1,baseline); \n    vec3 z2 = join(tan2,baseline);\n    float k1 = ratio(base0,base1,z1);\n    float k2 = ratio(base0,base1,z2); \n    float N = 16.0;\n    float t = 0.0;//0.1*iTime;\n    k1 = round(N*(k1+t))/N-t;\n    k2 = round(N*(k2+t))/N-t;\n    // If the rounded baseline point is in the right range (and the\n    // tangent from there is defined) then draw it. Since there will\n    // be two tangents from the baseline point, we need to make sure\n    // we use the right one - if baseline point and the pixel point\n    // are on the same side of the conic, then use the same quadratic\n    // root for both, otherwise use different roots. We find which\n    // side the points are with the ratio function.\n    //\n    // If line l is a tangent to the conic A, then the intersection\n    // point of the tangent is Ainv*l (and the tangent line at point\n    // p is A*p). A is symmetric, so A*p = p*A and Ainv*l = l*Ainv.\n    vec3 tan11,tan12;\n    if (abs(k1) <= 1.0 && tangents(base0+k1*(base1-base0),Ainv,tan11,tan12)) {\n      vec3 t1 = Ainv*tan1; // The point of tan1 on the conic\n      if (ratio(t1,z1,z) > 0.0) ldist = min(ldist,line(z,tan11));\n      else ldist = min(ldist,line(z,tan12));\n    }\n    vec3 tan21,tan22;\n    if (abs(k2) <= 1.0 && tangents(base0+k2*(base1-base0),Ainv,tan21,tan22)) {\n      vec3 t2 = Ainv*tan2; // The point of tan2 on the conic\n      if (ratio(t2,z2,z) > 0.0) ldist = min(ldist,line(z,tan22));\n      else ldist = min(ldist,line(z,tan21));\n    }\n  }\n  ldist = min(ldist,line(z,baseline));\n  pdist = min(pdist,point(z,pointer));\n  vec3 col = vec3(0.75+0.25*cos(20.0*dconic),1,1);\n  col *= smoothstep(0.01,max(fwidth(z.x),0.02),ldist);\n  col *= smoothstep(0.08,0.1,pdist);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 col = vec3(0);\n  float scale = 5.0;\n  vec2 pointer;\n  if (iMouse.x > 0.0) pointer = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  else pointer = cos(0.5*iTime-vec2(0,0.4*PI));\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      col += getcolor(vec3(scale*z,1),vec3(scale*pointer,1));\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1111, 1111, 1138, 1138, 1161], [1531, 1531, 1560, 1560, 1600], [1602, 1790, 1818, 1818, 1863], [1865, 1934, 1970, 1970, 2000], [2002, 2566, 2595, 2595, 2727], [2729, 2825, 2896, 2946, 3184], [3186, 3375, 3446, 3628, 3960], [3962, 4155, 4216, 4330, 4440], [4442, 4606, 4643, 4643, 4713], [4715, 4715, 4752, 4814, 7561], [7563, 7563, 7615, 7615, 8106]], "test": "untested"}
{"id": "Wslfzl", "name": "tube_yurka", "author": "yurka", "description": "Travel through a pipe", "tags": ["tube"], "likes": 4, "viewed": 247, "published": 3, "date": "1588924356", "time_retrieved": "2024-07-30T21:08:04.888296", "image_code": "#define DELTA_DISTANCE  1e-10\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (in float _st) {\n    return fract(sin(dot(vec2(_st, 0.0),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat timescale = 0.5;\n\nvec3 ProjectPointOnLine(vec3 a, vec3 v, vec3 pos)\n{\n \tvec3 p = pos-a;\n\n\tfloat l_l = length(v);\n\tfloat l_p = length(p);\n\n\tif (l_l<DELTA_DISTANCE)\n\t\treturn a;\n\tif (l_p<DELTA_DISTANCE)\n\t\treturn a;\n\n\tvec3 l_u = normalize(v);\n\n\treturn a + l_u*dot(v,p)/l_l;\n}\n\nbool intersectPlaneAndLine(vec3 planePoint, vec3 planeVector, vec3 linePoint, vec3 lineVector, out vec3 p)\n{\n    float planeD = -(planeVector.x*planePoint.x + planeVector.y*planePoint.y + planeVector.z*planePoint.z);\n    p = vec3(0);\n    float temp = planeVector.x * lineVector.x + planeVector.y * lineVector.y + planeVector.z * lineVector.z;\n    if (abs(temp) < 1E-40)\n        return false;\n    float t = (-planeD - planeVector.x * linePoint.x - planeVector.y * linePoint.y - planeVector.z * linePoint.z) / temp;\n    p.x = lineVector.x * t + linePoint.x;\n    p.y = lineVector.y * t + linePoint.y;\n    p.z = lineVector.z * t + linePoint.z;\n    return true;\n}\n\nvec2 GetTotal(float atime)\n{\n    \n    vec2 dprev = vec2(random(floor(atime * timescale) - 1.0) - 0.5, random(floor(atime * timescale) - 1.0 + 0.4) - 0.5);\n    vec2 d     = vec2(random(floor(atime * timescale)) - 0.5, random(floor(atime * timescale) + 0.4) - 0.5);\n    vec2 dnext = vec2(random(floor(atime * timescale) + 1.0) - 0.5, random(floor(atime * timescale) + 1.0 + 0.4) - 0.5);\n    float prg = fract(atime * timescale);\n    //float pd = 1.0 - abs(prg - 0.5);\n    //float pdprev = max(0.0, 0.5 - prg);\n    //float pdnext = max(0.0, prg - 0.5);\n    \n    float ddd = pow(2.0*(prg - 0.5), 2.0) * 0.5;\n    float pd = 1.0 - ddd;\n    float pdprev = ddd;\n    float pdnext = ddd;\n    if (prg < 0.5)\n        pdnext = 0.0;\n    else\n        pdprev = 0.0;\n    \n    vec2 dtotal = dprev * pdprev + d * pd + dnext * pdnext;\n    return dtotal * 1.5;\n}\n\nfloat length2(vec3 v){\n        return v.x*v.x+v.y*v.y+v.z*v.z;               \n}\n\nfloat GetAngle(vec3 v1, vec3 v2)\n{\n    float cosval = dot(v1, v2) / (length(v1) * length(v2));\n    if (cosval < -1.0)\n        cosval = -1.0;\n    if (cosval > 1.0)\n        cosval = 1.0;\n    return acos(cosval);\n}\n\nvec3 RotateVectorAroundVector(vec3 axe, vec3 v, float angle)\n{\n    vec3 res;\n    float a [3 * 3];\n\n    float c = cos(angle);\n    float s = sin(angle);\n    axe = normalize(axe);\n    a[0*3+0] = c + (1.0 - c) * axe.x * axe.x;\n    a[0*3+1] = (1.0 - c) * axe.y * axe.x - s * axe.z;\n    a[0*3+2] = (1.0 - c) * axe.z * axe.x + s * axe.y;\n    a[1*3+0] = (1.0 - c) * axe.x * axe.y + s * axe.z;\n    a[1*3+1] = c + (1.0 - c) * axe.y * axe.y;\n    a[1*3+2] = (1.0 - c) * axe.z * axe.y - s * axe.x;\n    a[2*3+0] = (1.0 - c) * axe.x * axe.z - s * axe.y;\n    a[2*3+1] = (1.0 - c) * axe.y * axe.z + s * axe.x;\n    a[2*3+2] = c + (1.0 - c) * axe.z * axe.z;\n    res.x = v.x * a[0*3+0] + v.y * a[0*3+1] + v.z * a[0*3+2];\n    res.y = v.x * a[1*3+0] + v.y * a[1*3+1] + v.z * a[1*3+2];\n    res.z = v.x * a[2*3+0] + v.y * a[2*3+1] + v.z * a[2*3+2];\n    return res;\n}\n\nvec4 raymarch(vec3 ro, vec3 rd) {\n    \n    vec3 path = vec3(0, 0, 0);\n    path.y += 0.0;\n    float stp = 0.004;\n    float radius = 0.2;\n    float crT = iTime;\n    float maxdist = 0.0;\n    float maxdistT = crT;\n    vec3 maxdistProj = vec3(0);\n    vec3 maxdistProjV = vec3(0);\n    vec3 pathzd = vec3(GetTotal(iTime), 1.0);\n    vec3 forward = vec3(0, 0, 1);\n    vec3 axis = cross(pathzd, forward);\n    float angle = GetAngle(pathzd, forward);\n    for (int i = 0; i < 1000; i++) {\n        float crstp = stp * pow(2.0, (crT - iTime)*0.5);\n        crT += crstp;\n        vec3 pathd = vec3(GetTotal(crT), 1.0);\n        pathd = RotateVectorAroundVector(axis, pathd, angle);\n        //pathd.x -= pathzd.x;\n        //pathd.y -= pathzd.y;\n        path += pathd * crstp * timescale;\n        \n        //vec3 prj = ProjectPointOnLine(ro, rd, path);\n        vec3 prj;\n        \n        if (intersectPlaneAndLine(path, pathd, ro, rd, prj) && length2(path - prj) > maxdist)\n        {\n            maxdist = length2(path - prj);\n            maxdistT = crT;\n            maxdistProj = prj;\n            maxdistProjV = path - prj;\n            vec3 axis_ = cross(pathd, forward);\n            float angle_ = GetAngle(pathd, forward);\n            maxdistProjV = RotateVectorAroundVector(axis_, maxdistProjV, angle_);\n        }\n        if (maxdist > radius*radius)\n        {\n            break;\n        }\n    }\n    float freq = 5.0;\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    if (maxdist > radius*radius)\n    {\n\n        float an = GetAngle(maxdistProjV, vec3(1, 0, 0));\n        vec3 c3 = vec3(\n        cos(an * 5.0) * sin(fract(maxdistT) * 3.14 * 3.0),\n        -cos(an * 5.0) * sin(fract(maxdistT) * 3.14 * 3.0),\n        abs(cos(an * 5.0) * sin(fract(maxdistT) * 3.14 * 3.0))\n    \t);\n        \n        c = (c3 ) / 1.0;\n\t\t\n    }\n    return vec4(c, 1.0);\n}\n\nvec4 raymarch_test(vec3 ro, vec3 rd) {\n    \n\n vec3 path = vec3(0, 0, 0);\n\n    vec3 c = vec3(0.0, 0.0, 0.0);\n\n    return vec4(c, 1.0);\n}\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - iResolution.xy/2.0) / iResolution.y * 2.0;\n\n    //vec4 col = vec4(vec3(dot(uv, GetTotal(iTime))), 1.0);\n    \n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    //rd.yz *= rotate(3.14*0.5);\n    //ro.y += -2.8;\n    //ro.z += 1.5;\n    vec4 col = raymarch(ro, rd);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wslfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 59, 59, 167], [169, 169, 198, 198, 314], [340, 340, 391, 391, 593], [595, 595, 703, 703, 1253], [1255, 1255, 1283, 1283, 2096], [2098, 2098, 2120, 2120, 2177], [2179, 2179, 2213, 2213, 2390], [2392, 2392, 2454, 2454, 3234], [3236, 3236, 3269, 3269, 5054], [5056, 5056, 5094, 5094, 5191], [5193, 5193, 5215, 5215, 5291], [5294, 5294, 5351, 5351, 5696]], "test": "untested"}
{"id": "3sfBDS", "name": "bicubic-smoothed pixel-art scale", "author": "sh1boot", "description": "Another attempt at using bicubic interpolation to straighten, rather than smooth, boundaries between pixels.\n\nBroadly; smooth with bicubic, and then threshold to adjacent pixels.  Bicubic's context allows some limited contour following for the threshold.", "tags": ["scaling", "pixelartinterpolation"], "likes": 4, "viewed": 569, "published": 3, "date": "1588923802", "time_retrieved": "2024-07-30T21:08:05.661230", "image_code": "// Smaller values relax similarity threshold between neighbours.\nconst float score_weight = 4.0;\n\n// Probably needs tweaking to match scale factor.\nconst float sharpen_threshold = 0.8;\n\n// Standard is -0.5, lower is blurrier and gives smoother diagonals.\nconst float cubic_blur = -0.9;\nconst float lancz_cutoff = 0.95;\nconst bool bicubic_mode = true;\n#define WIN 4\n\n// Alternate textures to try (from browser js console):\n// gShaderToy.SetTexture(0, {mSrc:'https://i.postimg.cc/2m6hY0vm/test-original.gif', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n// gShaderToy.SetTexture(0, {mSrc:'https://i.postimg.cc/csh04MYG/r-place.png', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n// (somebody else's scaling of above: https://i.redd.it/3nsc7940appy.png )\n\nvec2 zoom(vec2 uv, vec2 resolution) {\n    vec2 window = vec2(32.,18.) * (1.0 + sin(iTime * 0.3) * 0.2);\n    vec2 range = max(vec2(1.), resolution - window);\n    vec2 t = vec2(4.0, 4.1) * iTime / resolution;\n\tuv = uv * window;\n    uv += (vec2(sin(t.x), cos(t.y)) + vec2(1.)) * 0.5 * range;\n    return uv;\n}\n\nfloat cubic(float t) {\n    const float a = cubic_blur;\n    t = abs(t);\n    float t3 = t * t * t;\n    float t2 = t * t;\n    if (t <= 1.) return (a + 2.) * t3 - (a + 3.) * t2 + 1.;\n    if (t < 2.) return a * t3 - 5. * a * t2 + 8. * a * t - 4. * a;\n    return 0.;\n}\n\nvoid cubic(out float w[4], float t) {\n    w[0] = cubic(t + 1.);\n    w[1] = cubic(t + 0.);\n    w[2] = cubic(t - 1.);\n    w[3] = cubic(t - 2.);\n}\n\nvec4 interpolate(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\n    float w[4];\n    cubic(w, t);\n    return p0 * w[0] + p1 * w[1] + p2 * w[2] + p3 * w[3];\n}\n\nfloat lanczos2(vec2 uv) {\n    float t = length(uv);\n    if (t == 0.) return 1.;\n    float w = t * 3.141592653 / float(WIN / 2);\n    float s = t * 3.141592653 * lancz_cutoff;\n    w = max(0.0, sin(w) / (w));\n    return w * sin(s) / (s);\n}\n\nvec4 interpolate(vec4 n[WIN * WIN], vec2 uv) {\n    if (bicubic_mode) {\n        vec4 e[4];\n        const int o = WIN * (WIN - 3) / 2 - 2;\n        for (int j = 0; j < 4; ++j) {\n            e[j] = interpolate(n[o + j], n[o + WIN + j],\n                               n[o + WIN * 2 + j], n[o + WIN * 3 + j],\n                               fract(uv.y));\n        }\n        return interpolate(e[0], e[1], e[2], e[3], fract(uv.x));\n    } else {\n        vec4 r = vec4(0.);\n        for (int i = 0; i < WIN; ++i) {\n            for (int j = 0; j < WIN; ++j) {\n                vec2 ij = float(WIN / 2) - 1. - vec2(float(j), float(i));\n                r += n[i * WIN + j] * lanczos2(uv + ij);\n            }\n        }\n        return r;\n    }\n}\n\nfloat score(vec4 a, vec4 b) {\n    // TODO: be smarter\n    a = (a - b);\n#if 0\n    float Y = dot(a.rgb, vec3(0.299, 0.587, 0.114));\n    vec2 UV = (a.rb - vec2(Y)) * vec2(0.492, 0.877);\n    UV *= vec2(0.3);\n\treturn 1.0 - min(score_weight * length(vec3(Y, UV)), 1.0);\n#else\n\treturn 1.0 - min(score_weight * length(a.rgb), 1.0);\n#endif\n}\n\nvec4 palettise(vec4 c[4], vec4 p) {\n    return vec4(score(c[0], p),\n                score(c[1], p),\n                score(c[2], p),\n                score(c[3], p));\n}\n\nvec4 unpalettise(vec4 c[4], vec4 p) {\n    return c[0] * p.x\n         + c[1] * p.y\n         + c[2] * p.z\n         + c[3] * p.w;\n}\n\nfloat aacmp(float a, float b) {\n    float delta = 0.7 * fwidth(b - a);\n    return smoothstep(-delta, delta, b - a);\n}\n\nvec4 sharpen(vec4 p) {\n    float w;\n    vec4 o;\n    w = aacmp(p.x, p.y);\n    p.x = mix(p.x, p.y, w);\n    o.xy = vec2(1.0 - w, w);\n    w = aacmp(p.z, p.w);\n    p.z = mix(p.z, p.w, w);\n    o.zw = vec2(1.0 - w, w);\n    w = aacmp(p.x, p.z);\n    o *= vec2(1.0 - w, w).xxyy;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = zoom(fragCoord / iResolution.xy, iChannelResolution[0].xy);\n    ivec2 iuv = ivec2(floor(mod(uv, iChannelResolution[0].xy))) - WIN / 2;\n\n    // pick up all the pixels we'll need.\n    vec4 n[WIN * WIN];\n    for (int i = 0; i < WIN; ++i) {\n        for (int j = 0; j < WIN; ++j) {\n            int k = i * WIN + j;\n            n[k] = texelFetch(iChannel0, iuv + ivec2(j, i), 0);\n        }\n    }\n\n    // Save the four corners relevant to the region being interpolated\n    vec4 c[4];\n\n    ivec2 odd = iuv & 1;\n    odd.y *= WIN;\n    // TODO: separate the even and odd rows and columns and put them in\n    // consistent slots, so we don't get those hairline artefacts.\n    c[0] = n[WIN * (WIN + 1) / 2 - WIN + odd.y - 1 + odd.x];\n    c[1] = n[WIN * (WIN + 1) / 2 - WIN + odd.y - odd.x];\n    c[2] = n[WIN * (WIN + 1) / 2 - odd.y - 1 + odd.x];\n    c[3] = n[WIN * (WIN + 1) / 2 - odd.y - odd.x];\n\n    // Convert into a palette of comparisons with the four corners\n    for (int i = 0; i < WIN * WIN; ++i) {\n        n[i] = palettise(c, n[i]);\n    }\n\n    // Interpolate in the paletted space\n    vec4 smoosh = interpolate(n, fract(uv));\n    vec4 sharp = sharpen(smoosh);\n    vec4 result = unpalettise(c, sharp);\n\n    // DEBUG\n#if 1\n    vec4 m = iMouse;\n#if 1\n    // nearest neighbour\n    vec4 peek = fract(uv.y) < 0.5\n                ? fract(uv.x) < 0.5 ? c[0] : c[1]\n                : fract(uv.x) < 0.5 ? c[2] : c[3];\n#else\n    vec4 peek = fragCoord.x * 2.0 < iResolution.x ? smoosh : sharp;\n\n    // Since colours represent proximity to corners, it's clearer if we\n    // flip alternate rows and columns so corners are consistently coloured\n    // in adjacent squares.\n    if (fract(.5 * uv.x) >= 0.5) peek = peek.yxwz;\n    if (fract(.5 * uv.y) >= 0.5) peek = peek.zwxy;\n#endif\n    m.w = abs(m.w);  // discard click event\n    if (m.z > 0. && m.w > 0.) {\n        m = vec4(min(m.xy, m.zw), max(m.xy, m.zw));\n        if (m.x < fragCoord.x && fragCoord.x < m.z\n            && m.y < fragCoord.y && fragCoord.y < m.w) {\n            result = peek;\n            // mark the box selected by mouse\n            vec2 box = smoothstep(0.05, 1.10, abs(fragCoord - m.xy))\n                     * smoothstep(0.05, 1.10, abs(fragCoord - m.zw));\n            result *= box.x * box.y;\n        }\n    }\n    // Draw a grid over everything (lines cross through centres of pixels)\n    if (texelFetch(iChannel3, ivec2(16, 0), 0).x >= 0.5) {\n        vec2 grid = smoothstep(0.05, 0.10, fract(uv));\n        result *= grid.x * grid.y;\n    }\n#endif\n\n    fragColor = result;\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[898, 898, 935, 935, 1203], [1205, 1205, 1227, 1227, 1467], [1469, 1469, 1506, 1506, 1612], [1614, 1614, 1677, 1677, 1770], [1772, 1772, 1797, 1797, 2008], [2010, 2010, 2056, 2056, 2737], [2739, 2739, 2768, 2792, 3071], [3073, 3073, 3108, 3108, 3239], [3241, 3241, 3278, 3278, 3369], [3371, 3371, 3402, 3402, 3488], [3490, 3490, 3512, 3512, 3774], [3776, 3776, 3833, 3833, 6376]], "test": "untested"}
{"id": "Wd2yRV", "name": "My Improved Raytracer", "author": "mrmcsoftware", "description": "Here's an improved raytracer I wrote which is a GLSL version of a trimmed down C version of my C raytracer (trimmed down version was the basis for my assembly language versions (my own CPU design and x86)) - now with reflection/refraction by using a loop.", "tags": ["raytracer", "animation"], "likes": 1, "viewed": 372, "published": 3, "date": "1588917739", "time_retrieved": "2024-07-30T21:08:06.578776", "image_code": "//#version 130\n//#extension GL_EXT_gpu_shader4 : enable\n\n//#define GAMMAC 1.0/2.2   // Uncomment this line to apply gamma correction\n#define SPEED 4.0  // speed adjustment - MODIFY AS NEEDED\n#define MAXLEVEL 2  // ray trace depth - MODIFY AS DESIRED\n\n#define SMALL .001\n#define SMALL3 .000001\n\n#define SPHERE 0\n#define PLANE 1\n#define LIGHT 2\n\nstruct Ray\n\t{\n\tvec3 p;\n\tvec3 v;\n\t};\n\nstruct Rgb\n\t{\n\tfloat r,g,b;\n\t};\n\nstruct View\n\t{\n\tvec3 e,a,u;\n\t};\n\nstruct Light\n\t{\n\tvec3 p;\n\tfloat k,dist,r;\n\tRgb i;\n\t};\n\nstruct Info\n\t{\n\tvec3 v1,v2,v3,v4;\n\tfloat f1,f2,f3;\n\t};\n\nstruct Object\n\t{\n\tint type,id;\n\tRgb amb,diff,spec,tran;\n\tfloat ka,ks,kd,kn,kr,kt,n;\n\tInfo info;\n\t};\n\nstruct Hit\n\t{\n\tObject object;\n\tvec3 normal,pt;\n\tfloat t;\n\tRgb col;\n\t};\n\n#define MAXFLOAT\t3.37E+38\n\nView V;\nint xres,yres;\nint CXc,CYc,xc,yc;\nRgb bg=Rgb(0.0,0.0,0.0),ambient;\nint numlights=0;\nLight light[2];\nint numobj=0;\nObject objs[10];\nfloat ka=.15,ks=.10,kd=.415,kn=8.0,kr=0.0,textoff=32.0,gn=1.0,ior,kt=0.0;\nRgb diff,spec,tran;\nHit hit;\nvec3 pol[3];\nfloat flengthx=1150.0,flengthy=1150.0,min_weight=.05;\nvec3 dir,right;\nInfo infoblank;\nRgb gat;\nfloat gt;\nvec3 gpt;\n\nRgb trace(Ray);\nvoid pushobj(int,Info);\n\n/* I'll use GLSL's functions instead, but these do work */\n/*\n\nfloat Dot(vec3 v1,vec3 v2)\n{\nfloat f;\n\nf=v1.x*v2.x+v1.y*v2.y+v1.z*v2.z;\nreturn(f);\n}\n\nfloat Mag(vec3 v1)\n{\nfloat d;\n\nd=sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);\nreturn(d);\n}\n\nvec3 Normalize(vec3 v1)\n{\nfloat d;\nvec3 res;\n\nd=sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);\nres.x=v1.x/d;\nres.y=v1.y/d;\nres.z=v1.z/d;\nreturn(res);\n}\n\nvec3 CrossProduct(vec3 v2,vec3 v3)\n{\nvec3 res;\n\nres.x=v2.y*v3.z-v2.z*v3.y;\nres.y=v2.z*v3.x-v2.x*v3.z;\nres.z=v2.x*v3.y-v2.y*v3.x;\nreturn(res);\n}\n\n*/\n\nbool sphereinter(Object obj,Ray ray)\n{\nfloat a,b,c,d,spht0,spht1,t;\nvec3 P;\n\nP=ray.p-obj.info.v1;\nc=dot(P,P)-obj.info.f1*obj.info.f1;\nb=2.0*dot(ray.v,P);\na=dot(ray.v,ray.v);\nd=b*b-4.0*a*c;\nif (d<=0.0) { return(false); }\nd=sqrt(d);\nif (a==0.0) { return(false); }\nspht0=(-b+d)/(a+a);\nspht1=(-b-d)/(a+a);\nif ((spht1<spht0)&&(spht1>SMALL)) t=spht1;\nelse t=spht0;\nif (t>SMALL)\n\t{\n\tgpt=P+t*ray.v;\n\tgt=t;\n\treturn(true);\n\t}\nreturn(false);\n}\n\nvec3 spherenorm(Object obj,Ray ray)\n{\nvec3 n,pt;\n\nn=gpt;\ngpt+=obj.info.v1;\nn=normalize(n);\nreturn(n);\n}\n\nbool triinter(Object obj,Ray ray)\n{\nfloat in1,in2,f1,t;\n\nf1=dot(obj.info.v3,ray.v);\nif (abs(f1)<SMALL) return(false);\nin1=obj.info.f3;\nin2=dot(obj.info.v3,ray.p);\nt=(in1-in2)/f1;\nif (t<SMALL) return(false); /* ?? */\ngpt=ray.p+t*ray.v;\nreturn(true);\n}\n\nvec3 trinorm(Object obj,Ray ray)\n{\nvec3 n,pt;\n\nreturn(obj.info.v3);\n}\n\nvoid planarobj(int t)\n{\nInfo info;\n\ninfo=infoblank;\ninfo.v1=pol[1]-pol[0];\ninfo.v2=pol[2]-pol[0];\ninfo.v3=cross(info.v1,info.v2);\ninfo.v3=normalize(info.v3);\ninfo.v4=pol[0];\ninfo.f1=dot(info.v1,info.v1);\ninfo.f2=dot(info.v2,info.v2);\ninfo.f3=dot(info.v3,info.v4);\npushobj(t,info);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\nInfo info;\nfloat r,g,b;\nRay eye_ray;\nfloat xf,yf;\nRgb col;\n\nnumobj=0;\nV.a=vec3(0,0,0);\nV.e=vec3(1,10,20);\nV.u=vec3(0,1,0);\nCXc=(xres/2); CYc=(yres/2);\ndir=V.a-V.e;\ndir=normalize(dir);\nright=cross(V.u,dir);\nright=normalize(right);\nV.u=cross(dir,right);\nV.u=normalize(V.u);\n\n\t/* magenta sphere */\nka=.1; ks=0.0; kd=.6; kn=40.0; ambient=Rgb(.99,.99,.99);\nspec=Rgb(255.0,255.0,255.0);\nks=.5;\ninfo.v1=vec3(1.0,1.0,0.0); info.f1=1.0;\ndiff=Rgb(255.0,0.0,255.0);\nkr=.5;\npushobj(SPHERE,info);\n\t/* green sphere */\nks=0.0;\ninfo.v1=vec3(-1.0,1.0,2.0);\ndiff=Rgb(0.0,255.0,0.0);\nkt=1.0; /*.58;*/ ior=1.75; kd=.07; ks=.4; kr=.26; /*0;*/ /*.1;*/ kn=100.0;\ntran=Rgb(0.0,255.0,0.0);\nka=0.0;\n/* adjust to no refraction possible */\n//kt=0.0; ka=.1; kd=.6;\nkr=0.0;\npushobj(SPHERE,info);\n\t/* yellow sphere */\nkt=0.0; kd=.6; ks=0.0; /*.5;*/ kr=.5; kn=40.0;\nka=.1;\ninfo.v1=vec3(.75,1.0,3.25);\ndiff=Rgb(255.0,255.0,0.0);\npushobj(SPHERE,info);\n\t/* light 1 */\nlight[numlights].p=vec3(-2.0,6.0,8.0);\nlight[numlights].i=Rgb(.2,.2,.2);\nlight[numlights].k=0.0; light[numlights].dist=9.0; light[numlights].r=.25;\n//normalize(light[numlights].p); light[numlights].r=0;\ninfo.v1=light[numlights].p;\ninfo.f1=light[numlights].r;\npushobj(LIGHT,info);\nnumlights++;\n\t/* light 2 */\nlight[numlights].p=vec3(2.0,8.0,7.0);\nlight[numlights].i=Rgb(.99,.99,.99);\nlight[numlights].k=0.0; light[numlights].dist=9.0; light[numlights].r=.25;\n//normalize(light[numlights].p); light[numlights].r=0;\ninfo.v1=light[numlights].p;\ninfo.f1=light[numlights].r;\npushobj(LIGHT,info);\nnumlights++;\n\t/* plane */\ndiff=Rgb(255.0,255.0,255.0); ks=.8; kd=.4;\npol[0]=vec3(0.0,0.0,0.0);\npol[1]=vec3(0.0,0.0,1.0);\npol[2]=vec3(1.0,0.0,0.0);\n//kr=0;\nplanarobj(PLANE);\n\n\t/* adjust movements through time */\nfloat iGlobalTime=iTime-1.0;\nif (iGlobalTime<0.0) { iGlobalTime=0.0; }\niGlobalTime*=SPEED;\n//iGlobalTime=0.0;\nobjs[0].info.v1+=vec3(0,0,(iGlobalTime)*.2);\nobjs[1].info.v1+=vec3((iGlobalTime)*-.1,0,0);\nobjs[2].info.v1+=vec3((iGlobalTime)*.2,0,0);\nlight[1].p+=vec3((iGlobalTime)*-1.0,0,0);\n\nCXc=int(iResolution.x/2.0);\nCYc=int(iResolution.y/2.0);\nvec2 q=fragCoord.xy;\nq.y=iResolution.y-q.y-1.0;\nxc=int(q.x); yc=int(q.y);\nflengthx=flengthy=iResolution.y/1.5*750.0/256.0;\n//flengthx=flengthy=150.0/256.0*5.0;\nxf=float(CXc-xc)/flengthx;\nyf=float(CYc-yc)/flengthy;\neye_ray.v=dir+xf*right+yf*V.u;\neye_ray.p=V.e;\ncol=trace(eye_ray);\nr=clamp(col.r/255.0,0.0,1.0);\ng=clamp(col.g/255.0,0.0,1.0);\nb=clamp(col.b/255.0,0.0,1.0);\n#ifdef GAMMAC\nr=pow(r,GAMMAC);\ng=pow(g,GAMMAC);\nb=pow(b,GAMMAC);\n#endif\nfragColor=vec4(r,g,b,1);\n}\n\nfloat shadow(Object obj,vec3 p,vec3 vv,float vd)\n{\nRay v;\nfloat t;\nint j;\nbool i;\n\nv.p=p;\nv.v=vv;\nfor (j=0;j<numobj;j++)\n\t{\n\tObject ptr=objs[j];\n\tif ((ptr.id!=obj.id)&&(ptr.type!=LIGHT)&&(ptr.type!=PLANE))\n\t\t{\n\t\tif (ptr.type==SPHERE) { i=sphereinter(ptr,v); }\n\t\telse { i=false; }\n\t\tif (i)\n\t\t\t{\n\t\t\tif (t<vd)\n\t\t\t\t{\n\t\t\t\tif (ptr.kt<min_weight) { return(0.0); }\n\t\t\t\tgat.r*=ptr.kt*ptr.tran.r/255.0;\n\t\t\t\tgat.g*=ptr.kt*ptr.tran.g/255.0;\n\t\t\t\tgat.b*=ptr.kt*ptr.tran.b/255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn(1.0);\n}\n\nRgb shade(Ray ray,Object obj,vec3 N,vec3 pt)\n{\nRgb color,dcol;\nfloat t2,f;\nfloat t,t3;\nint i;\nvec3 L;\nRay R,T;\nfloat light_dist=0.0; /* ?? */\nRgb at;\n\ndcol=hit.col;\nif (obj.type==LIGHT) { color.r=color.g=color.b=0.0; return(color); }\ncolor.r=obj.ka*obj.amb.r*dcol.r;\ncolor.g=obj.ka*obj.amb.g*dcol.g;\ncolor.b=obj.ka*obj.amb.b*dcol.b;\n\nfor (i=0;i<numlights;i++)\n\t{\n\tL=light[i].p-pt;\n\tlight_dist=length(L);\n\tL=normalize(L);\n\tf=dot(N,L);\n\tgat.r=gat.g=gat.b=1.0;\n\tif (shadow(obj,pt,L,light_dist)>0.0)\n\t\t{\n\t\tt3=light[i].dist/(light_dist+light[i].k);\n\t\tif ((f>0.0)||(obj.kt>min_weight))\n\t\t\t{\n\t\t\tt=t3*f*obj.kd;\n\t\t\tif ((obj.kt>min_weight)&&(f<0.0)) { t=-t; }\n\t\t\tcolor.r+=light[i].i.r*dcol.r*t*gat.r;\n\t\t\tcolor.g+=light[i].i.g*dcol.g*t*gat.g;\n\t\t\tcolor.b+=light[i].i.b*dcol.b*t*gat.b;\n\t\t\tt2=2.0*f;\n\t\t\tR.v=t2*N-L;\n\t\t\tt2= -dot(R.v,ray.v);\n\t\t\tif (t2>0.0)\n\t\t\t\t{\n\t\t\t\tt2=t3*pow(t2,obj.kn)*obj.ks;\n\t\t\t\tcolor.r+=light[i].i.r*obj.spec.r*t2*gat.r;\n\t\t\t\tcolor.g+=light[i].i.g*obj.spec.g*t2*gat.g;\n\t\t\t\tcolor.b+=light[i].i.b*obj.spec.b*t2*gat.b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn(color);\n}\n\nbool intersect(Ray ray)\n{\nObject ptr,p;\nint j;\nbool inter=false,i=false;\nfloat t;\nvec3 pt,gpts;\nfloat mint=MAXFLOAT;\nRgb col,colm;\n\nfor (j=0;j<numobj;j++)\n\t{\n\tptr=objs[j];\n\tif (ptr.type==SPHERE) { i=sphereinter(ptr,ray); }\n\telse if (ptr.type==PLANE) { i=triinter(ptr,ray); }\n\telse { i=false; }\n\tif (i)\n\t\t{\n\t\tinter=true;\n\t\tif (gt<mint)\n\t\t\t{\n\t\t\tp=ptr; mint=gt; gpts=gpt;\n\t\t\tcolm=ptr.diff;\n\t\t\t}\n\t\t}\n\t}\nif (inter)\n\t{\n\thit.object=p;\n\thit.t=mint;\n\tgpt=gpts;\n\tif (p.type==SPHERE) { hit.normal=spherenorm(p,ray); }\n\telse if (p.type==PLANE) { hit.normal=trinorm(p,ray); }\n\thit.pt=gpt;\n\tif (p.type==PLANE)\n\t\t{\n\t\tint ibx,ibz;\n\n\t\tibx=int(gpt.x+textoff);\n\t\tibz=int(gpt.z+textoff);\n\t\tif (((ibx+ibz)%2)==1) { colm.r=colm.g=colm.b=128.0; }\n\t\telse { colm.r=colm.g=colm.b=255.0; }\n\t\t}\n\thit.col=colm;\n\t}\nreturn(inter);\n}\n\nRgb trace(Ray ray)\n{\nvec3 pt,N;\nObject obj;\nRgb col,dcol,colt;\nint level;\nvec3 k;\nfloat f,t,t2,t3;\n\nray.v=normalize(ray.v);\ncol=Rgb(0.0,0.0,0.0);\nk=vec3(1.0,1.0,1.0);\nfor (level=0;level<=MAXLEVEL;level++)\n\t{\n\tif (intersect(ray))\n\t\t{\n\t\tobj=hit.object;\n\t\tdcol=hit.col;\n\t\tN=hit.normal;\n\t\tpt=hit.pt;\n\t\tcolt=shade(ray,obj,N,pt);\n\t\tcol.r+=colt.r*k.x;\n\t\tcol.g+=colt.g*k.y;\n\t\tcol.b+=colt.b*k.z;\n\t\tk=vec3(1.0,1.0,1.0);\n\t\tif (obj.kr>min_weight)\n\t\t\t{\n\t\t\tf= -2.0*dot(N,ray.v);\n\t\t\tray.v=f*N+ray.v;\n\t\t\tray.p=pt+SMALL3*ray.v;\n\t\t\tk=vec3(obj.kr,obj.kr,obj.kr);\n\t\t\t}\n\t\telse if (obj.kt>min_weight)\n\t\t\t{\n\t\t\tfloat n;\n\t\n\t\t\tf=dot(N,ray.v);\n\t\t\tif (f<0.0) { n=gn/obj.n; f= -f; }\n\t\t\telse { n=obj.n/gn; N=-N; }\n\t\t\tt=n*f;\n\t\t\tt3=1.0-n*n*(1.0-f*f);\n\t\t\tk=vec3(obj.kt*dcol.r/255.0,obj.kt*dcol.g/255.0,obj.kt*dcol.b/255.0);\n\t\t\tif (t3<0.0) // TIR\n\t\t\t\t{\n\t\t\t\tf= -2.0*dot(N,ray.v);\n\t\t\t\tray.v=f*N+ray.v;\n\t\t\t\tray.p=pt+SMALL3*ray.v;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tt2=t-sqrt(t3);\n\t\t\t\tray.v=t2*N+n*ray.v;\n\t\t\t\tray.p=pt+SMALL3*ray.v;\n\t\t\t\t}\n\t\t\t}\n\t\telse { break; }\n\t\t}\n\telse\n\t\t{\n\t\tcol.r+=bg.r*k.x;\n\t\tcol.g+=bg.g*k.y;\n\t\tcol.b+=bg.b*k.z;\n\t\treturn(col);\n\t\t}\n\t}\nreturn(col);\n}\n\nvoid pushobj(int type,Info info)\n{\nobjs[numobj].id=numobj;\nobjs[numobj].type=type;\nif (type!=LIGHT)\n\t{\n\tobjs[numobj].ka=ka;\n\tobjs[numobj].ks=ks;\n\tobjs[numobj].kd=kd;\n\tobjs[numobj].kn=kn;\n\tobjs[numobj].kr=kr;\n\tobjs[numobj].kt=kt;\n\tobjs[numobj].n=ior;\n\tobjs[numobj].diff=diff;\n\tobjs[numobj].tran=tran;\n\tobjs[numobj].amb.r=ambient.r;\n\tobjs[numobj].amb.g=ambient.g;\n\tobjs[numobj].amb.b=ambient.b;\n\tobjs[numobj].spec=spec;\n\t}\nobjs[numobj].info=info;\nnumobj++;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1695, 1695, 1733, 1733, 2127], [2129, 2129, 2166, 2166, 2232], [2234, 2234, 2269, 2269, 2484], [2486, 2486, 2520, 2520, 2555], [2557, 2557, 2580, 2580, 2839], [2841, 2841, 2895, 2895, 5443], [5445, 5445, 5495, 5495, 5942], [5944, 5944, 5990, 5990, 6998], [7000, 7000, 7025, 7025, 7801], [7803, 7803, 7823, 7823, 8922], [8924, 8924, 8958, 8958, 9380]], "test": "untested"}
{"id": "wssBzs", "name": "Rainbow Jungle", "author": "jarble", "description": "This is a version of my [url=https://www.shadertoy.com/view/3slfzs]\"Jungle fractal\"[/url] with even more colors!", "tags": ["fractal", "rainbow", "jungle", "rainforest"], "likes": 0, "viewed": 380, "published": 3, "date": "1588901497", "time_retrieved": "2024-07-30T21:08:07.436483", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    float time1 = -iTime/10.0;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y))/5.0);\n        col /= sin(uv.x+time1);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    fragColor = vec4(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0,0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 558]], "test": "untested"}
{"id": "tdsBzs", "name": "tetrahedra tunnels", "author": "abje", "description": "stolen a lot from [url]https://www.shadertoy.com/view/MdSBRc[/url].\na voxel grid with 5 tetrahedra in each voxel.", "tags": ["3d", "marchingtetrahedra"], "likes": 3, "viewed": 399, "published": 3, "date": "1588900966", "time_retrieved": "2024-07-30T21:08:08.279230", "image_code": "#define FAR 100.0\n\n#define antialiasing 16\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n#define sqr(a) (a*a)\n#define dot2(a) dot(a,a)\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 pln, float d) {\n    \n    float a = dot(ro,pln)-d;\n    float b = dot(rd,pln);\n    \n    if (a*b < 0.0 && b < 0.0) {\n        return -a/b;\n    }\n    \n    return FAR;\n}\n\nvec2 path(float time) {\n    time *= 0.1;\n    //random sine waves that move the camera\n    vec2 a = vec2(sin(time),cos(time*3.0));\n    a += vec2(sin(time*0.1)*5.0,cos(time*1.0)*3.0);\n    a *= sin(time*0.05);\n    a *= 4.0;\n    \n    return a;\n}\n\nfloat isoMap(vec3 p, vec3 ro){\n    \n    p += 0.001;\n    \n    float l;\n    \n    vec2 path1 = p.xy;\n    vec2 path2 = path(p.z)-p.xy;\n    \n    float tunnel = 7.0-smin(length(path1),length(path2), 3.0);\n    \n    l = tunnel;\n    \n    vec3 p2 = p*0.2;\n    \n    p2.x += iTime*0.1;\n    p.z += 2.0;\n    \n\tp2 = cos(p2*0.315*1.25 + sin(p2.zxy)); // 3D sinusoidal mutation.\n    \n    float n = dot(p2,vec3(1)); // Spherize. The result is some mutated, spherical blob-like shapes.\n    \n    l = smax(l,n-1.5, 3.0);\n    \n    return l;\n    \n}\n\n// Interpolating along the edge connecting vertices v1 and v2 with respect to the isovalue.\nvec3 inter(in vec3 p1, in vec3 p2, float v1, float v2){\n    // The interpolated point will fall somewhere between the vertex points p1 and p2.\n    // Obviously if the isovalue is closer to p1, then the interpolated point will be\n    // closer to p1, and vice versa.\n    return mix(p2, p1, v2/(v2 - v1));\n}\n\nfloat ray(vec3 ro, vec3 rd, inout vec3 normal, float maxdist)\n{\n    \n    vec3 fro = floor(ro);\n    vec3 lro = ro-fro;\n    vec3 srd = sign(rd);\n    vec3 ird = srd/rd;\n    float d = 0.0;\n    vec3 dists = abs((srd*0.5+0.5)-lro)*ird;\n    vec3 n = vec3(0);\n    \n    mat4x3 tetraf = mat4x3(\n        vec3( 1, 1, 1),\n        vec3(-1, 1,-1),\n        vec3(-1,-1, 1),\n        vec3( 1,-1,-1));\n    \n    vec3 p = lro-0.5;\n    vec3 flip = 1.0-mod(fro,2.0)*2.0;\n    \n    vec4 tetra1 = vec4(\n        dot(rd,tetraf[0]),\n        dot(rd,tetraf[1]),\n        dot(rd,tetraf[2]),\n        dot(rd,tetraf[3]));\n    \n    vec4 tetra3 = 1.0/max(abs(tetra1),0.001);\n    \n    vec4 tetra2 = vec4(\n        dot(ro,tetraf[0]),\n        dot(ro,tetraf[1]),\n        dot(ro,tetraf[2]),\n        dot(ro,tetraf[3]));\n    \n    vec4 tetra = abs((sign(tetra1)+1.0)-mod(tetra2,2.0))*tetra3;\n    \n    vec4 tetrac = step(0.5,vec4(\n        dot(p,tetraf[0]*flip),\n        dot(p,tetraf[1]*flip),\n        dot(p,tetraf[2]*flip),\n        dot(p,tetraf[3]*flip)));\n    \n    vec4 a = (1.0-2.0*tetrac);\n\n    mat4x3 sp = 0.5-0.5*mat4x3(\n        tetraf[0]*flip*a.x,\n        tetraf[1]*flip*a.y,\n        tetraf[2]*flip*a.z,\n        tetraf[3]*flip*a.w);\n    \n    vec4 ps = vec4(\n        isoMap(fro+sp[0], ro),\n        isoMap(fro+sp[1], ro),\n        isoMap(fro+sp[2], ro),\n        isoMap(fro+sp[3], ro));\n    \n    int i2 = 0;\n    \n    for (int i = 0; i < 400; i++)\n    {\n        \n        int index = int(dot(step(ps,vec4(0.0)),vec4(1,2,4,8)));\n            /*(ps[0] < 0.0 ? 1 : 0)\n             +(ps[1] < 0.0 ? 2 : 0)\n             +(ps[2] < 0.0 ? 4 : 0)\n             +(ps[3] < 0.0 ? 8 : 0);*/\n        \n        vec3 mask;\n        if (dists.x < dists.y)\n            if (dists.x < dists.z)\n                mask = vec3(1,0,0);\n            else\n                mask = vec3(0,0,1);\n        else\n            if (dists.y < dists.z)\n                mask = vec3(0,1,0);\n            else\n                mask = vec3(0,0,1);\n        \n        \n        vec4 maskt;\n        if (tetra.x < tetra.y)\n            if (tetra.x < tetra.z)\n                if (tetra.x < tetra.w)\n                    maskt = vec4(1,0,0,0);\n                else\n                    maskt = vec4(0,0,0,1);\n            else\n                if (tetra.z < tetra.w)\n                    maskt = vec4(0,0,1,0);\n                else\n                    maskt = vec4(0,0,0,1);\n        else\n            if (tetra.y < tetra.z)\n                if (tetra.y < tetra.w)\n                    maskt = vec4(0,1,0,0);\n                else\n                    maskt = vec4(0,0,0,1);\n            else\n                if (tetra.z < tetra.w)\n                    maskt = vec4(0,0,1,0);\n                else\n                    maskt = vec4(0,0,0,1);\n        \n        float lv = dot(dists,mask);\n        float lt = dot(maskt,tetra);\n        \n        float l = min(lv,lt);\n        \n        if (index != 0)\n        {\n            if (index != 15)\n            {\n                ivec3 v1, v2;\n                float f = -1.0;\n                if (index > 7) {\n                    f = -f;\n                    index = 15-index;\n                }\n                \n                if(index == 1)\n                {\n                    v1 = ivec3(0,0,0);\n                    v2 = ivec3(1,2,3);\n                }    \n                // Vertex 1 only is inside or outside.\n                else if(index == 2)\n                {\n                    v1 = ivec3(1,1,1);\n                    v2 = ivec3(0,3,2);\n                }\n                // Vertex 2 only is inside or outside.\n                else if(index == 4)\n                {\n                    v1 = ivec3(2,2,2);\n                    v2 = ivec3(0,1,3);\n                } \n                // Vertex 3 only is inside or outside.\n                else if(index == 7)\n                {\n                    v1 = ivec3(3,3,3);\n                    v2 = ivec3(0,1,2);\n                }\n                // Vertices 0 and 1 are inside or vertices 2 and 3 are inside.\n                else if(index == 3)\n                {\n                    v1 = ivec3(0,0,1);\n                    v2 = ivec3(2,3,3);\n                }\n                // Vertices 0 and 2 are inside or vertices 1 and 3 are inside.   \n                else if(index == 5)\n                {\n                    v1 = ivec3(0,2,0);\n                    v2 = ivec3(1,3,3);\n                } \n                // Vertices 1 and 2 are inside or vertices 0 and 3 are inside.\n                else if(index == 6)\n                {\n                    v1 = ivec3(0,1,2);\n                    v2 = ivec3(1,3,3);\n                }\n                \n        \t\tmat3 v = mat3(\n                    inter(sp[v1.x], sp[v2.x], ps[v1.x], ps[v2.x]),\n                    inter(sp[v1.y], sp[v2.y], ps[v1.y], ps[v2.y]),\n                    inter(sp[v1.z], sp[v2.z], ps[v1.z], ps[v2.z]));\n                \n                vec3 n = cross(v[1]-v[0],v[2]-v[0])*f*(+dot(tetrac,vec4(1))*2.0-1.0)*flip.x*flip.y*flip.z;\n                \n                float pln = plane(lro-v[0],rd,n,0.0);\n                \n                if (pln < l)\n                {\n                    normal = n;\n                    d += pln;\n                    return d;\n                }\n            }\n        }\n          \n        d += l;\n        lro += rd*l;\n        \n        dists -= l;\n        tetra -= l;\n        \n        int j;\n        \n        if (lv < lt)\n        {\n            normal = -mask*sign(rd);\n            \n            dists = dists+mask*ird;\n            lro -= srd*mask;\n            fro += srd*mask;\n            \n            vec3 p = lro-0.5;\n            \n            flip *= 1.0-mask*2.0;\n            \n            for (int j = 0; j < 4; j++)\n            {\n            \tsp[j] = abs(mask-sp[j]);\n            }\n            \n            j = int(abs(dot(mask,vec3(-7,-5,2))+dot(tetrac,vec4(0,1,2,3))))%4;\n            // mask.x  mask.y  mask.z\n            //  w 3     y 1     z 2   tetrac.x\n            //  z 2     x 0     w 3   tetrac.y\n            //  y 1     w 3     x 0   tetrac.z\n            //  x 0     z 2     y 1   tetrac.w\n        }\n        else\n        {\n            vec4 mask = maskt;\n            \n            if (flip.x > 0.0) {\n                mask = mask.wzyx;\n            }\n            \n            if (flip.y > 0.0) {\n                mask = mask.yxwz;\n            }\n            \n            if (flip.z > 0.0) {\n                mask = mask.zwxy;\n            }\n            \n            tetra += tetra3*maskt*2.0;\n            tetrac = abs(tetrac-mask);\n            \n            \n        \tj = int(dot(mask,vec4(0,1,2,3)));\n            // maskt.x maskt.y maskt.z maskt.w\n            //   0       1       2       3\n            \n            sp[j] = 1.0-sp[j];\n        }\n        ps[j] = isoMap(fro+sp[j], ro);\n        \n        if (d > maxdist) return maxdist;\n    }\n    \n    return d;\n    \n    \n    /*vec4 dists = vec4(\n        plane(ro,rd,vec3( 1, 1, 1),1.0),\n        plane(ro,rd,vec3( 1,-1,-1),1.0),\n        plane(ro,rd,vec3(-1, 1,-1),1.0),\n        plane(ro,rd,vec3(-1,-1, 1),1.0));\n    \n    return vec4(min(min(min(dists.x,dists.y),dists.z),dists.w),0,0,0);*/\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.131, .130, .1973)\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//shading\nvec3 shade(vec3 p, vec3 d, vec3 n, float material, float num, float dist) {\n    vec3 color = vec3(1);\n    \n    //vec3 f = floor(p*0.01+sin(p.yzx)+sin(p.zxy));\n    //color = sin(f+sin(p))*(sin(p)*0.25+0.5)+0.5;\n    \n    vec3 light = vec3(0,sin(iTime)*4.0,iTime*4.0+8.0);\n    \n    vec3 ldir = light-p;\n    float llen = length(ldir);\n    ldir /= llen;\n    \n    float shadow = dot(ldir,n)*0.8;\n    shadow /= llen*llen*0.02+1.0;\n    \n    if (shadow > 0.0) {\n        vec3 nothing;\n        float l = ray(p+ldir*0.001,ldir, nothing, llen);\n        if (l < llen) shadow *= 0.0;\n    }\n    \n    shadow = max(shadow,0.02);\n    \n    color *= shadow;\n    float fog = max(4.0-dist/FAR*4.0,0.0);\n    color *= fog;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(path(iTime*4.0),iTime*4.0);\n    \n    vec3 rd = normalize(vec3(uv,1)+0.001);\n    \n    if (length(iMouse.xy) < 50.0) {\n        vec3 lookat = vec3(path(iTime*4.0+2.0),iTime*4.0+2.0);\n        vec3 forward = normalize(lookat-ro);\n        vec3 left = normalize(cross(vec3(path(iTime*4.0+1.0),0),forward));\n        vec3 up = cross(forward,left);\n        \n        rd = rd.x*left+rd.y*up+rd.z*forward;\n        \n    } else {\n        rd.zy *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n        rd.zx *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    int id = 3;\n    float tetranum;\n    vec3 cell;\n    vec3 nor;\n    float d = ray(ro,rd, nor, FAR);\n    nor = normalize(nor);\n    \n    // Output to screen\n    vec3 sun = normalize(vec3(1));\n    vec3 col = vec3(0);\n    if (d < FAR)\n    {\n        vec3 p = ro+rd*d;\n        \n        col = shade(p, rd, nor, cell.x+cell.y*0.348+cell.z*0.483, tetranum, d);\n    } else {\n        float sunl = max(dot(sun,rd),0.0);\n        sunl = pow(sunl,100.0);\n        \n        col = vec3(0);//mix(vec3(0.2,0.2,0.8),vec3(1.2,1.0,0.2),sunl);\n    }\n    \n    \n    col = clamp(col,0.0,1.0);\n    col = pow(col,vec3(1.0/2.2));\n    fragColor = vec4(sqrt(col),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 364, 402, 402, 483], [485, 708, 746, 746, 823], [825, 825, 875, 875, 1023], [1025, 1025, 1048, 1048, 1266], [1268, 1268, 1298, 1298, 1793], [1795, 1887, 1942, 2152, 2192], [2194, 2194, 2257, 2257, 9278], [9280, 9280, 9305, 9305, 9430], [9545, 9545, 9567, 9567, 9685], [9687, 9697, 9772, 9772, 10419], [10421, 10421, 10478, 10528, 11792]], "test": "untested"}
{"id": "3sXBzs", "name": "Rippling Pool", "author": "natethegreat2525", "description": "Drag mouse around to make waves in the pool.  Comment line 1 to see just the fluid simulation.", "tags": ["reflection", "raymarch", "water", "ripple", "pool"], "likes": 6, "viewed": 562, "published": 3, "date": "1588898577", "time_retrieved": "2024-07-30T21:08:09.095049", "image_code": "#define raymarch 1\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF 0.01\n#define EP 0.01\n#define PI 3.14159\n\nmat2 rot(float a) {\n    float x = sin(a);\n    float y = cos(a);\n    return mat2(y, x, -x, y);\n}\n\nfloat sdRect(vec3 p, vec3 s) {\n    return max(max(p.x-s.x, p.y-s.y), max(max(p.z-s.z, -p.x-s.x), max(-p.y-s.y, -p.z-s.z)));\n}\n\nfloat sdPlaneBumpy(vec3 p) {\n    p.x+=4.;\n    p.z+=4.;\n    float b = texture(iChannel0, p.xz*.1).z*.1;\n    return abs(p.y-b* .8)-.002;\n}\n\nvec2 getDist(vec3 p) {\n    float sphere = length(p-vec3(2,0,-2)) - 1.;\n    \n    float plane = sdPlaneBumpy(p-vec3(0,0,0));\n    float planeBox = sdRect(p-vec3(0,0,0), vec3(6));\n    plane = max(plane, planeBox);\n    \n    float wall1 = sdRect(p-vec3(-5,-.8,0), vec3(1, 1, 6));\n    float wall2 = sdRect(p-vec3(7,-.8,0), vec3(1, 1, 6));\n    float wall3 = sdRect(p-vec3(0,-.8,-5), vec3(6, 1, 1));\n    float wall4 = sdRect(p-vec3(1,-.8,7), vec3(7, 1, 1));\n    float wall = min(min(wall1, wall2), min(wall3, wall4));\n    \n    float floorD = sdRect(p-vec3(1, -2.8, 1), vec3(7, 1, 7));\n    \n    vec2 ret = vec2(plane, 0);\n    if (wall < ret.x) {\n        ret = vec2(wall, 1);\n    }\n    if (floorD < ret.x) {\n        ret = vec2(floorD, 2);\n    }\n    return ret;\n}\n\nvec2 getRayDist(vec3 rp, vec3 rd) {\n    float d = 0.;\n    vec3 p = rp;\n    vec2 ret;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        p = rp + rd*d;\n        ret = getDist(p);\n        d += ret.x*.6;\n        if(ret.x <= SURF || d > MAX_DIST) break;\n    }\n    ret.x = d;\n    return ret;\n}\n\nvec3 getNorm(vec3 p) {\n    float c = getDist(p).x;\n    vec2 ep = vec2(EP,0);\n    vec3 norm;\n    vec3 eps[3] = vec3[3](ep.xyy, ep.yxy, ep.yyx);\n    for (int i = min(0,iFrame); i < 3; i++) {\n        norm[i] = getDist(p+eps[i]).x-c;\n    }\n    return normalize(norm);\n}\n\nvec3 reflectRay(vec3 ray, vec3 norm) {\n    float d = dot(ray, norm);\n    vec3 side = ray - d*norm;\n    return -d*norm + side;\n}\n\nvec3 getColor(vec3 rp, vec3 rd) {\n    vec2 refD = getRayDist(rp, rd);\n    vec3 refP = rp + rd*refD.x;\n    vec3 refCol = vec3(0);\n    if (refD.x > 99.) {\n        return vec3(0);\n    }\n    vec3 norm = getNorm(refP);\n    float refShade = clamp(dot(vec3(0,1,0), norm), .3, 1.);\n    vec3 refl = reflect(rd, norm);\n    float reflSparkle = clamp(dot(vec3(0,1,0), refl), 0., 1.);\n    vec3 color;\n    if (refD.y < .5) {\n        vec2 refractD = getRayDist(refP+rd*.1, refract(rd, norm, .8));\n        vec3 refractP = refP+rd*.1+refractD.x*rd;\n        vec3 refractColor = vec3(0);\n        if (refractD.x < 50.) {\n            refractColor = texture(iChannel1, refractP.xz*.2 + refractP.zy*.2).rgb;\n            if (refractD.y > 1.5 && refractD.y < 2.5) {\n        \t\trefractColor = texture(iChannel2, refractP.xz*.2).rgb;\n    \t\t}\n        }\n        float transparency = -dot(rd, norm);\n        color = mix(vec3(.1, .5, .8), refractColor, pow(transparency, 2.));\n    }\n    if (refD.y > .5 && refD.y < 1.5) {\n        color = texture(iChannel1, refP.xz*.2).rgb;\n        //color = vec3(.3, .3, .3);\n    }\n    if (refD.y > 1.5 && refD.y < 2.5) {\n        color = texture(iChannel0, refP.xz*.2).rgb;\n    }\n    refCol = refShade*color + pow(reflSparkle, 22.) * vec3(1);\n    return refCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef raymarch\n    vec2 uv = (fragCoord*2.-iResolution.xy)/(iResolution.x);\n\n    float time = iTime*.3;\n    //vec3 rp = vec3(1.+cos(iTime)*3.,7,-5.+sin(iTime)*2.);\n    vec3 rp = vec3(1.+8.*sin(time), 7,1.+8.*cos(time));\n    //rp.xz = vec2(sin(iTime)*8., -cos(iTime)*8.);\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    rd.yz *= rot(-.7);\n    rd.xz *= rot(time+3.1415);\n    //rd.xz *= rot(iMouse.x*.01);\n    \n    vec3 col = getColor(rp, rd);\n    \n    fragColor = vec4(col,1.0);\n    #else\n    float tex = texture(iChannel0, fragCoord/iResolution.xy).z;\n    fragColor = vec4(.5-tex, 0, tex, 1);\n    #endif\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 10) {\n        fragColor.z = .4*texture(iChannel1, fragCoord/iResolution.xy).r-.1;\n        return;\n    }\n    \n    ivec2 pos = ivec2(fragCoord);\n    vec4 cur = texelFetch(iChannel0, pos, 0);\n    \n    if (length(iMouse.xy - fragCoord) < 10.) {\n    \tcur = vec4(0,0,1,0);   \n    }\n    \n    vec4 left = texelFetch(iChannel0, pos+ivec2(-1,0), 0);\n    vec4 right = texelFetch(iChannel0, pos+ivec2(1,0), 0);\n    vec4 up = texelFetch(iChannel0, pos+ivec2(0,1), 0);\n    vec4 down = texelFetch(iChannel0, pos+ivec2(0,-1), 0);\n    float targ = (left.z + right.z + up.z + down.z) * .25;\n    float diff = targ - cur.z;\n    cur.x += diff*.2 - cur.z*.001;\n    cur.x *= .9999;\n    cur.z += cur.x;\n    \n    //cur.z = clamp(cur.z, 0., 1.);\n    //cur.x = clamp(cur.x, -1., 1.);\n    \n    fragColor = cur;\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord);\n    vec4 cur = texelFetch(iChannel0, pos, 0);\n    \n    if (length(iMouse.xy - fragCoord) < 10.) {\n    \tcur = vec4(0,0,1,0);   \n    }\n    \n    vec4 left = texelFetch(iChannel0, pos+ivec2(-1,0), 0);\n    vec4 right = texelFetch(iChannel0, pos+ivec2(1,0), 0);\n    vec4 up = texelFetch(iChannel0, pos+ivec2(0,1), 0);\n    vec4 down = texelFetch(iChannel0, pos+ivec2(0,-1), 0);\n    float targ = (left.z + right.z + up.z + down.z) * .25;\n    float diff = targ - cur.z;\n    cur.x += diff*.2 - cur.z*.001;\n    cur.x *= .9999;\n    cur.z += cur.x;\n    \n    //cur.z = clamp(cur.z, 0., 1.);\n    //cur.x = clamp(cur.x, -1., 1.);\n    \n    fragColor = cur;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord);\n    vec4 cur = texelFetch(iChannel0, pos, 0);\n    \n    if (length(iMouse.xy - fragCoord) < 10.) {\n    \tcur = vec4(0,0,1,0);   \n    }\n    \n    vec4 left = texelFetch(iChannel0, pos+ivec2(-1,0), 0);\n    vec4 right = texelFetch(iChannel0, pos+ivec2(1,0), 0);\n    vec4 up = texelFetch(iChannel0, pos+ivec2(0,1), 0);\n    vec4 down = texelFetch(iChannel0, pos+ivec2(0,-1), 0);\n    float targ = (left.z + right.z + up.z + down.z) * .25;\n    float diff = targ - cur.z;\n    cur.x += diff*.2 - cur.z*.001;\n    cur.x *= .9999;\n    cur.z += cur.x;\n    \n    //cur.z = clamp(cur.z, 0., 1.);\n    //cur.x = clamp(cur.x, -1., 1.);\n    \n    fragColor = cur;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord);\n    vec4 cur = texelFetch(iChannel0, pos, 0);\n    \n    if (length(iMouse.xy - fragCoord) < 10.) {\n    \tcur = vec4(0,0,1,0);   \n    }\n    \n    vec4 left = texelFetch(iChannel0, pos+ivec2(-1,0), 0);\n    vec4 right = texelFetch(iChannel0, pos+ivec2(1,0), 0);\n    vec4 up = texelFetch(iChannel0, pos+ivec2(0,1), 0);\n    vec4 down = texelFetch(iChannel0, pos+ivec2(0,-1), 0);\n    float targ = (left.z + right.z + up.z + down.z) * .25;\n    float diff = targ - cur.z;\n    cur.x += diff*.2 - cur.z*.001;\n    cur.x *= .9999;\n    cur.z += cur.x;\n    \n    //cur.z = clamp(cur.z, 0., 1.);\n    //cur.x = clamp(cur.x, -1., 1.);\n    \n    fragColor = cur;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 138, 138, 214], [216, 216, 246, 246, 341], [343, 343, 371, 371, 479], [481, 481, 503, 503, 1232], [1234, 1234, 1269, 1269, 1519], [1521, 1521, 1543, 1543, 1786], [1788, 1788, 1826, 1826, 1915], [1917, 1917, 1950, 1950, 3182], [3184, 3184, 3241, 3241, 3848]], "test": "untested"}
{"id": "wslBzl", "name": "Minimal Voronation", "author": "wyatt", "description": "Image minimization", "tags": ["triangulation"], "likes": 11, "viewed": 458, "published": 3, "date": "1588892560", "time_retrieved": "2024-07-30T21:08:09.948766", "image_code": "// Fork of \"Voronoi Triangulation\" by wyatt. https://shadertoy.com/view/WtcSz7\n// 2020-05-07 21:16:34\n\nMain {\n    Q = D(U)*(1.-max(0.,sin(iTime))*exp(-2.*length(U-B(U).xy)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,floor(U)/R)\n#define B(U) texture(iChannel1,floor(U)/R)\n#define C(U) texture(iChannel2,floor(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tif (length(a-b)<1e-3) return 1e3; // ignore self\n\tfloat l = (length(p-a-(b-a)*i));\n    if (l < 1.) return length(a-b);\n    return l;\n}\nfloat mp (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn dot(p-m,b-m)/dot(b-m,b-m); // pojection\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat tri (vec2 u, vec2 a, vec2 b, vec2 c) {\n\tfloat ab = sg(u,a,b);\n\tfloat bc = sg(u,b,c);\n    float ca = sg(u,c,a);\n    return min(ab,min(bc,ca));\n}", "buffer_b_code": "// Nearest Individual\nvoid X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = B(U+r);\n    float ln = length(n.xy-U), la = length(Q.xy-U),\n         l = abs(sg(U,Q.xy,Q.zw)),\n         o = abs(sg(U,Q.xy,n.zw)),\n         o1 = abs(sg(U,Q.xy,n.xy));\n    if (ln<la) {\n    \tQ.xy = n.xy;\n    }\n    if (o<l) {\n    \tQ.zw = n.zw;\n    }\n    if (o1<l) {\n    \tQ.zw = n.xy;\n    }\n}\nvoid Xr (inout vec4 Q, vec2 U, float r) {\n\t X(Q,U,vec2(r,0));\n     X(Q,U,vec2(0,r));\n     X(Q,U,vec2(0,-r));\n     X(Q,U,vec2(-r,0));\n}\nvec2 grad (vec2 u) {\n\tvec4\n        n = D(u+vec2(0,1)),\n        e = D(u+vec2(1,0)),\n        s = D(u-vec2(0,1)),\n        w = D(u-vec2(1,0));\n    return vec2(e.w-w.w,n.w-s.w);\n}\nMain {\n\tQ = B(U);\n    Xr(Q,U,1.);\n    Xr(Q,U,2.);\n    Xr(Q,U,3.);\n    Xr(Q,U,4.);\n    float err = D(Q.xy).w;\n    Q.xy -= grad(Q.xy)*err;\n    Q.zw = B(Q.zw).xy;\n    vec2 f = vec2(0);\n    for (int x = -2; x<=2;x++) {\n        for (int y = -2; y<=2;y++) {\n        \t vec4 b1 = B(Q.xy+vec2(x,y));\n        \tvec2 r = b1.zw-Q.xy;\n            float l = length(r);\n            if (l>0.) \tf += .001*r/l/l/(1e-3+err);\n        }\n    }\n    Q.xy += f;\n    if (iFrame%6==int((U.x*+R.x*U.y))%6&&D(U).w>.2) Q.xy = U;\n    Init {\n    \tU = floor(U/100.+0.5)*100.;\n        Q = vec4(U,0,0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = vec4(0);\n    vec4 b = B(U);\n    Q += 2.*A(b.xy)/(.1+dot(U-b.xy,U-b.xy));\n    for (int x = -3; x<=3;x++) {\n        for (int y = -3; y<=3;y++) {\n        \t vec4 b1 = B(b.xy+3.*vec2(x,y));\n            Q += A(b1.zw)/(.1+2.*dot(U-b1.zw,U-b1.zw));\n            b1 = B(b.zw+4.*vec2(x,y));\n            Q += A(b1.xy)/(.1+2.*dot(U-b1.zw,U-b1.zw));\n        }\n    }\n    Q /= 1e-4+Q.w;\n    // Error\n    vec3 a = A(U).xyz;\n    Q.w = 10.*dot(a-Q.xyz,a-Q.xyz);\n    vec4 m = 0.25*(D(U+vec2(0,1))+D(U+vec2(1,0))+D(U-vec2(0,1))+D(U-vec2(1,0)));\n    Q.w = mix(m.w,Q.w,0.1);\n}", "buffer_d_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Wdlfzs", "name": "Weyl sequences", "author": "blackle", "description": "weyl sequences in 1,2,3,4, and 9 dimensions\ncode to help generate it from: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/", "tags": ["weyl"], "likes": 7, "viewed": 437, "published": 3, "date": "1588885209", "time_retrieved": "2024-07-30T21:08:10.710729", "image_code": "//based on https://www.shadertoy.com/view/4dtBWH\n//see \"Common\" for the weyl functions\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat sphere(vec3 p) {\n    return length(p)-1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x*2.;\n    bool fix = uv.x > 0.;\n    uv.x = fract(uv.x)-0.5;\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-5,0,0);\n    cam = erot(cam, vec3(0,1,0), cos(iTime));\n    init = erot(init, vec3(0,1,0), cos(iTime));\n    cam = erot(cam, vec3(0,0,1), iTime);\n    init = erot(init, vec3(0,0,1), iTime);\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100; i++) {\n        float dist = sphere(p);\n        if (dist*dist < 0.00001) {hit = true; break;}\n        p+=dist*cam;\n    }\n    \n    if (hit) {\n        vec2 uv = map_from_sphere(p);\n        if (fix) {\n    \t\tfragColor = vec4(1)-texture(iChannel0, uv);\n        } else {\n    \t\tfragColor = vec4(1)-texture(iChannel1, uv);\n        }\n    } else {\n        fragColor.xyz = vec3(1.0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float weyl_1d(int n) {\n    return fract(float(n*10368871)/exp2(24.));\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nvec3 weyl_3d(int n) {\n    return fract(vec3(n*13743434, n*11258243, n*9222443)/exp2(24.));\n}\n\nvec4 weyl_4d(int n) {\n    return fract(vec4(n*14372619, n*12312662, n*10547948, n*9036162)/exp2(24.));\n}\n\nmat3 weyl_9d(int n) {\n    return mat3(fract(vec3(n*15595598, n*14497202, n*13476166)/exp2(24.)),\n                fract(vec3(n*12527041, n*11644764, n*10824624)/exp2(24.)),\n                fract(vec3(n*10062247, n*9353565,  n*8694794 )/exp2(24.)));\n}\n\nconst float PI = 3.141592653;\nvec3 map_to_sphere(vec2 p)\n{\n    float theta = (p.x-0.5)*PI*2.;\n    float phi = (p.y-0.5)*PI*2.;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec2 map_from_sphere(vec3 p)\n{\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}\n\nvec4 bufferImage( vec2 uv, vec4 data, int frame, bool type ) {\n    for (int i = 0; i < 10; i++) {\n        vec3 point;\n        if (type) {\n            vec2 weyl = weyl_2d(frame*10+i)*2.-1.;\n            float theta = 3.1415*weyl.x;\n            float yy = sqrt(1.-weyl.y*weyl.y);\n            point = vec3(weyl.y, yy*cos(theta), yy*sin(theta));\n        } else {\n            point = normalize(tan(weyl_3d(frame*10+i)*2.-1.));\n        }\n        vec3 proj = map_to_sphere(uv);\n        data *= smoothstep(0.01, 0.015, distance(point, proj));\n    }\n    return data;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iFrame == 0) data = vec4(1.);\n    \n    fragColor = bufferImage(uv, data, iFrame, false);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iFrame == 0) data = vec4(1.);\n    \n    fragColor = bufferImage(uv, data, iFrame, true);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdlfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 126, 126, 192], [194, 194, 216, 216, 243], [245, 245, 302, 352, 1172]], "test": "untested"}
{"id": "3dsfzs", "name": "Melting Webcam 3", "author": "tomachi", "description": "Turns each pixel into a fluid dynamics simulation. You could say the effect is highly non-linear. That would be an under-statement.", "tags": ["webcam"], "likes": 6, "viewed": 736, "published": 3, "date": "1588884663", "time_retrieved": "2024-07-30T21:08:11.673156", "image_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define melting(g) texture(iChannel1, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define brightness 1.0001\n#define yellow vec4(20.,19.9,19.0,19.0)\n#define blackwhite vec4(1.,0.9,0.01,2.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \t\n    vec2 xy = fragCoord;\n    vec4 webcam = camchan(xy);\n    vec4 melt = melting(xy);\n    vec4 herbivore = tex(xy);\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    float texbright = (melt.r + melt.g + melt.g) * 0.333;\n    float lumens = (webcam.r + webcam.g + webcam.g) * 0.333;\n  // fragColor = herbivore + (webcam * vec4(r, g, b, 1.)) + vec4(r*brightness, g*brightness, b*brightness, 1.); //  * vec4(1.0);\n\t//fragColor = webcam  + sin(tex(fragCoord).w * blackwhite);\n    if ( lumens < 0.95 ) { \n        \tfragColor = melt + webcam  + sin(tex(fragCoord).w * blackwhite);\n    } else {\n        \tfragColor = webcam  + sin(tex(fragCoord).w * blackwhite);\n    }\n\t//fragColor = melt + webcam + tex(fragCoord).w;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define brightness 3.99\n#define count 20\n#define radius 0.943\n#define emitSize 0.950\n#define force 0.99\n#define constraint 0.91\n#define effect 0.99\n#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n\n// v => coord x,y / s => dir\n// v => coord x,y / d => diam\n// https://github.com/aiekick/NoodlesPlate/blob/master/fluid.glsl\n//NoodlesPlate widgets\n//uniform(hidden) \tint\t\t\t(frame) \t\t\t\t\t\tuFrame;\n//uniform(hidden) \tfloat\t\t(deltatime) \t\t\t\t\tuDeltaTime;\n//uniform(hidden) \tsampler2D\t(buffer:0) \t\t\t\t\t\tbuffer;\n//uniform(hidden) \tsampler2D\t(buffer:1) \t\t\t\t\t\tbuffer1;\n//uniform(hidden) \tvec2\t\t(buffer:0) \t\t\t\t\t\tsize;\n//uniform(color) \tvec3\t\t(0:10:7.7,6.0,7.5) \t\t\t\tcolor;\n//uniform(physic) \tfloat\t\t(0.0:1.0:0.1) \t\t\t\t\tforce;\n//uniform(prism) \tfloat\t\t(0.00001:0.1:0.01) \t\t\t\tconstraint;\n//uniform(prism) \tfloat\t\t(-1.0:1.0:0.0) \t\t\t\t\teffect;\n//uniform(prism) \tfloat\t\t(0.99:1.0:1.0) \t\t\t\t\tviscosity;\n//uniform(emit) \tfloat\t\t(1.0:20.0:5.0) \t\t\t\t\temitSize;\n//uniform(emit) \tint\t\t\t(0:50:1) \t\t\t\t\t\tcount;\n//uniform(emit) \tfloat\t\t(0.0:0.5:0.3) \t\t\t\t\tradius;\n//uniform(emit) \tfloat\t\t(checkbox:true) \t\t\t\temit;\n//uniform(shape) \tint\t\t\t(combobox:circle,triangle,quad) shapeType;\n\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n\treturn tri;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\t\n\tvec2 xy = fragCoord.xy;\n\tvec4 webcam = camchan(xy);\n\t\n\tvec2 s = iResolution.xy;\n\tvec2 g = fragCoord;\n\t\n\tvec4 a = tex(g+vec2(1,0));// + webcam.r;\n\tvec4 b = tex(g+vec2(0,1));// + webcam.g;\n\tvec4 c = tex(g+vec2(-1,0));// + webcam.b;\n\tvec4 d = tex(g+vec2(0,-1));// + (webcam.r * -0.0125);\n\tfloat lumens = (webcam.r + webcam.g + webcam.b)*0.333;\n\tfloat presh = abs(tex(xy).z);\n\tfloat ink = abs(tex(xy).w);\n\t\n\t// fragColor = tex(g-tex(g).xy); // last state\n    vec4 tomachi = vec4(1.0001,1.0002,1.0003,0.0);\n\tfragColor = tex(g-tex(g).xy)* tomachi; // last state\n\t\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n\t\n\t//fragColor.xyz = vec3(\n\t//\tfragColor.x + gp.x,\n\t//\tfragColor.y + gp.y,\n\t//\t0.25 * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y));\n\t\n\t\n\tvec4 left = camchan(xy+vec2(1,0)) + tex(xy+vec2(1,0));\n\tvec4 right = camchan(xy+vec2(0,1)) + tex(xy+vec2(0,1));\n\tvec4 up = camchan(xy+vec2(-1,0)) + tex(xy+vec2(-1,0));\n\tvec4 down = camchan(xy+vec2(0,-1))+ tex(xy+vec2(1,0));\n\t//vec2 presh = vec2(left.z-right.z,up.z-down.z); // pressure gradient\n\tfloat magic = 0.25;\n\tif (lumens > 2.5 || webcam.r > 0.7 || webcam.g > 0.57) {\n\t\temit(xy, vec2( 0.8995+(webcam.r*-0.76), 0.4+(webcam.g*-0.95) + (webcam.b*-0.5)));\n\t\tmagic = 0.251;\n\t}  \n\tfloat pressure = magic * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n\t\n\tif (lumens < 0.6594 ) {\n\t\tfragColor.z *= 0.9;\n\t\tfragColor.w *= 0.9;\n\t\t//fragColor.xy *= 1.001;\n\t\t//fragColor.xy *= vec2(1.0001);\n        if (lumens < 0.1) {\n           pressure *= 0.1;\n\n        } else {\n         \tpressure *= 1.00069;   \n        }\n    } else if (lumens > 0.99) {\n\t\t//emit(xy, vec2(0.00, 0.2));\n\t\tpressure *= 1.069;\n\t}\n\t\n\tif (abs(presh) < 1.1) {\n\t\tif (lumens > brightness*0.3159 ) {\n\t\t\temit(xy, 0.991);\n\t\t}\n\t} \n\t\n\t//emit(xy, 0.005);\n\tif (d.b > 0.95 && a.r > 0.95)\n\t{\n\t\tvec2 p = vec2( webcam.r, webcam.g);\n\t\tvec2 dir = vec2( webcam.g, webcam.b);\n\t\t//emit(xy, float (iFrame) * 0.01);\n\t\tpressure = 0.;\t\t\n\t} \n\tif (g.x < 1. || g.y < 1. || g.x > s.x - 1. || g.y > s.y - 1.) fragColor.xy *= 0.;\n\t\n\tif ( abs(pressure) > 4.99310589015 || lumens > 0.8) {\n\t\tpressure *= 0.8;\n\t\tfragColor.w = abs(fragColor.z) -0.05;\n\t\t//fragColor.xy = vec2(0.,0.);\n\t} \n\t// x,y => pos\n\t// z => pressure\n\t// w => ink\n\tfragColor.xyz = vec3(\n\t\tfragColor.x + gp.x + (webcam.r * 0.000099),\n\t\tfragColor.y + gp.y + (webcam.b * 0.000099),// + webcam.r,\n\t\tpressure\n\t);// + webcam.r;\n\t\n\t// if (iFrame < 1) fragColor = vec4(0);\n\t\n\n\t\n\t\n\t\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define webcam(g) texture(iChannel2, (g)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord;\n    vec4 campix = webcam(xy);\n    vec4 particle = tex(xy);\n    // float r, g, b;\n   \tvec4 a = tex(xy+vec2(1,0)) * campix.r; // LEFT\n    vec4 b = tex(xy+vec2(0,1)) + campix.g; // RIGHT\n\tvec4 c = tex(xy+vec2(-1,0)) + campix.b;// UP\n\tvec4 d = tex(xy+vec2(0,-1)) + (campix.r * -0.0125);//DOWN\n  \tfloat lumens = (campix.r + campix.g + campix.b)*0.333;\n\tfloat presh = particle.z;\n    \n    if (presh < 0.2) {\n         \tfragColor = tex(fragCoord); // last state\n\n    } else {\n            fragColor = campix * vec4(a.r,a.r,a.r,a.r);\n\n    }\n    \n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 333, 333, 1050]], "test": "untested"}
{"id": "3slfzs", "name": "Jungle fractal", "author": "jarble", "description": "It's a jungle!", "tags": ["fractal", "jungle", "rainforest"], "likes": 0, "viewed": 334, "published": 3, "date": "1588884324", "time_retrieved": "2024-07-30T21:08:12.542830", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    float time1 = -iTime/10.0;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y))/5.0);\n        col /= sin(uv.x+time1);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    fragColor = vec4(0.5,col2.x,0.5,0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 536]], "test": "untested"}
{"id": "3ssfRs", "name": "大龙猫 - Тетрис", "author": "totetmatt", "description": "Got inspired by the loading animation in Tetris 99", "tags": ["tetris"], "likes": 12, "viewed": 441, "published": 3, "date": "1588881660", "time_retrieved": "2024-07-30T21:08:13.357652", "image_code": "\n#define ITER 64.\n#define PI acos(-1.)\n#define v(p) vexel(p,vec3(.095),.01)\n#define us- 0.22\n#define ux vec3(us,0.,0.)\n#define uy vec3(0.,us,0.)\n#define uz vec3(0.,0.,us)\nvec3 global_color = vec3(1.,0.,0.);\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n    \n    \n}\nfloat vexel(vec3 p,vec3 b, float r) {\n\n        vec3 q = abs(p) -b;\n        return length(max(q,0.0) + min(max(q.x,max(q.y,q.z)),0.0)) - r;\n}\n\n\n\nfloat b(vec3 p,float rot, vec2 offset){\nif(rot == PI) {\n        p.xy*=r(rot);\n        p.x -=us*3.;\n\n    }\n    else if(rot == PI/2.) {\n        p.xy*=r(rot);\n     \n    }\n    else if(rot == 3.*PI/2.) {\n        p.xy*=r(rot);\n        p.x -=us*3.;\n    }\n     global_color = vec3(.0,0.9,0.9);\n    return min(min(v(p),v(p+ux)),min(v(p+ux*3.),v(p+ux*2.)));\n}\nfloat t(vec3 p, float rot, vec2 offset){\n     p += mod(vec3(offset,0.),2.)*us;\n\n   if(rot == PI) {\n        p.xy*=r(rot);\n        p.x -=us*2.;\n        p.y -=us;\n    }\n    else if(rot == PI/2.) {\n        p.xy*=r(rot);\n        p.y -=us;\n    }\n    else if(rot == 3.*PI/2.) {\n        p.xy*=r(rot);\n        p.x -=us*2.;\n    }\n    global_color = vec3(.7,0.,1.);\n    return min(min(v(p),v(p+ux)),\n               min(v(p+(ux+uy)),v(p+ux*2.)));\n}\nfloat sq(vec3 p, float rot, vec2 offset){\n    global_color = vec3(.9,.8,.0);\n    return min(min(v(p),v(p+ux)),\n               min(v(p+(ux+uy)),v(p+uy)));\n}\nfloat l(vec3 p,float rot, vec2 offset){\n if(rot == PI) {\n        p.xy*=r(rot);\n        p.x -=us;\n        p.y -=us*2.;\n    }\n    else if(rot == PI/2.) {\n        p.xy*=r(rot);\n        p.y -=us*2.;\n    }\n    else if(rot == 3.*PI/2.) {\n        p.xy*=r(rot);\n        p.x -=us;\n    }\n    global_color = vec3(.9,0.5,.0);\n    return min(min(v(p),v(p+ux)),\n               min(v(p+(uy)*2.),v(p+uy)));\n\n}\nfloat j(vec3 p,float rot, vec2 offset){\nif(rot == PI) {\n        p.xy*=r(rot);\n        p.x -=us;\n        p.y -=us*2.;\n    }\n    else if(rot == PI/2.) {\n        p.xy*=r(rot);\n        p.y -=us*2.;\n    }\n    else if(rot == 3.*PI/2.) {\n        p.xy*=r(rot);\n        p.x -=us;\n    }\n     global_color = vec3(.0,0.,.8);\n    return min(min(v(p+ux),v(p)),\n               min(v(p+ux+(uy)*2.),v(p+ux+uy)));\n\n}\nfloat s(vec3 p,float rot,vec2 offset){\n if(rot == PI) {\n        p.xy*=r(rot);\n        p.x -=us*2.;\n        p.y -=us;\n    }\n    else if(rot == PI/2.) {\n        p.xy*=r(rot);\n        p.y -=us;\n    }\n    else if(rot == 3.*PI/2.) {\n        p.xy*=r(rot);\n        p.x -=us*2.;\n    }\n    global_color = vec3(.0,0.8,.0);\n    return min(min(v(p),v(p+ux)),\n               min(v(p+(uy)+ux),v(p+uy+ux*2.)));\n\n}\nfloat z(vec3 p,float rot,vec2 offset){\n if(rot == PI) {\n        p.xy*=r(rot);\n        p.x -=us*2.;\n        p.y -=us;\n    }\n    else if(rot == PI/2.) {\n        p.xy*=r(rot);\n        p.y -=us;\n    }\n    else if(rot == 3.*PI/2.) {\n        p.xy*=r(rot);\n        p.x -=us*2.;\n    }\n    global_color = vec3(.8,0.0,.0);\n    return min(min(v(p+ux),v(p+ux*2.)),\n               min(v(p+(uy)),v(p+uy+ux)));\n\n}\n// 1D random numbers\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n\n\nbool activate=false;\n\nfloat fig(vec3 p) {\n             p.x -= us + us*.5;\n             p.y -= us + us*.5;\n            activate=false;\n            float choice = mod(floor(iTime),2.0);\n            float choiceFig = mod(ceil(iTime),7.0);\n            float selected;\n       \n              \n             float rot = 0.;\n             if(mod(floor(iTime*2.),4.0)==1.0){\n                rot = PI;\n             } else if(mod(floor(iTime),4.0)==2.0) {\n                rot = PI/2.;\n             } else if(mod(floor(iTime),4.0)==3.0) {\n                rot = 3.*PI/2.;\n             }\n             vec3 pp = p;\n             //pp.xy *=r(PI);\n             float rnd = floor(rand(choice+iTime*.00001)*6.);\n             float rnd2= floor(rand(choice-iTime*.00001)*6.);\n             if(choiceFig == 1.0) {\n              selected =  s(pp,rot,vec2(rnd,rnd2));\n             } else if(choiceFig == 2.0){\n                selected =  l(pp,rot,vec2(rnd,rnd2));\n             }else if(choiceFig == 3.0){\n                selected =  j(pp,rot,vec2(rnd,rnd2));\n             }else if(choiceFig == 4.0){\n                selected =  sq(pp,rot,vec2(rnd,rnd2));\n             }else if(choiceFig == 5.0){\n                selected =  b(pp,rot,vec2(rnd,rnd2));\n             }else if(choiceFig == 6.0){\n                selected =  t(pp,rot,vec2(rnd,rnd2));\n             } else {\n             selected =  z(pp,rot,vec2(rnd,rnd2));\n             }\n             float g = 100000.;\n             for(float y=0.;y<=3.;y++){\n                    for(float x=0.;x<=3.;x++){\n                         vec3 offset = vec3(ux.x*x,uy.y*y,0.);\n                         float cube = v(p+offset);\n                         g = min(g,cube); \n                     \n                    }\n             }\n             if(abs(g-selected) <=.00001){\n                activate = true;\n             }\n             return min(g,selected)*.9;\n            \n         \n}\nfloat SDF(vec3 p) {\n     \n      p.xz *=r(.5*cos(iTime+p.y));\n       p.yz*=r(.5*sin(iTime+p.x));\n       //p.xy *= r(iTime);\n     \n     return fig(p);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro =vec3(0.0001,0.00001,-1.5),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0);\n  \n    float shad = 0.;\n    bool hit = false;\n    \n    for(float i=0.;i < ITER; i++) {\n      float d = SDF(p);\n        if(d< 0.00001) {\n        \n            hit = true;\n            shad = i / ITER;\n            break;\n        }\n        p += d*rd;\n    }\n    \n    if(hit) {\n        if(activate) {\n        \n          \n            col = global_color;\n        } else {\n            col = vec3(1.-+shad);\n        }\n        \n    }\n   \n     \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 223, 223, 291], [292, 292, 329, 329, 432], [436, 436, 475, 475, 785], [786, 786, 826, 826, 1222], [1223, 1223, 1264, 1264, 1378], [1379, 1379, 1418, 1418, 1772], [1773, 1773, 1812, 1812, 2171], [2172, 2172, 2210, 2210, 2570], [2571, 2571, 2609, 2609, 2969], [2970, 2991, 3012, 3012, 3056], [3082, 3082, 3101, 3101, 4955], [4956, 4956, 4975, 4975, 5106], [5107, 5107, 5162, 5162, 5800]], "test": "untested"}
{"id": "3slfRs", "name": "Voronoi Montecarlo ", "author": "michael0884", "description": "this thing is good for voronoi interpolation too\nused https://www.shadertoy.com/view/WdXfzl as reference", "tags": ["triangulation"], "likes": 18, "viewed": 639, "published": 3, "date": "1588881052", "time_retrieved": "2024-07-30T21:08:14.181449", "image_code": "// Fork of \"Voronoi Triangulation\" by wyatt. https://shadertoy.com/view/WtcSz7\n// 2020-05-07 18:27:07\n\nMain {\n   Q = A(U);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,floor(U)/R)\n#define B(U) texture(iChannel1,floor(U)/R)\n#define C(U) texture(iChannel2,floor(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat mp (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn dot(p-m,b-m)/dot(b-m,b-m); // pojection\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat tri (vec2 u, vec2 a, vec2 b, vec2 c) {\n\tfloat ab = sg(u,a,b);\n\tfloat bc = sg(u,b,c);\n    float ca = sg(u,c,a);\n    return min(ab,min(bc,ca));\n}", "buffer_b_code": "// Nearest Individual\nvoid X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = B(U+r);\n    float ln = length(n.xy-U), la = length(Q.xy-U),\n         l = abs(mp(U,Q.xy,Q.zw)),\n         o = abs(mp(U,Q.xy,n.zw)),\n         o1 = abs(mp(U,Q.xy,n.xy));\n    if (ln<la) {\n    \tQ.xy = n.xy;\n    }\n    if (o<l) {\n    \tQ.zw = n.zw;\n    }\n    if (o1<l) {\n    \tQ.zw = n.xy;\n    }\n}\nvoid Xr (inout vec4 Q, vec2 U, float r) {\n\t X(Q,U,vec2(r,0));\n     X(Q,U,vec2(0,r));\n     X(Q,U,vec2(0,-r));\n     X(Q,U,vec2(-r,0));\n}\nvec2 grad (vec2 u) {\n\tvec4\n        n = D(u+vec2(0,1)),\n        e = D(u+vec2(1,0)),\n        s = D(u-vec2(0,1)),\n        w = D(u-vec2(1,0));\n    return vec2(e.w-w.w,n.w-s.w);\n}\nMain {\n\tQ = B(U);\n    Xr(Q,U,1.);\n    Xr(Q,U,2.);\n    Xr(Q,U,3.);\n    Xr(Q,U,4.);\n    Q.xy += 10.*grad(Q.xy);\n    Q.zw += 10.*grad(Q.zw);\n    if (iFrame%10==0&&D(U).w>.6) Q.xy = U;\n    Init {\n    \tU = floor(U/100.+0.5)*100.;\n        Q = vec4(U,0,0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = B(U);\n\tvec2 a = Q.xy, b = Q.zw;\n    vec4 col1 = A(a),\n         col2 = A(b);\n    Q = mix(col1,col2,(0.5+0.5*mp(U,a,b)));\n    vec2 u = (vec2(U-a.xy));\n    u = normalize(u)*(1.+.1*length(u));\n    u = vec2(-u.y,u.x);\n    vec4 m = 0.5*(D(U+u)+D(U-u));\n    vec4 d = Q-A(U);\n    Q = mix(m,Q,.1);\n    Q.w = mix((m.w),abs(dot(d,vec4(0.25))),0.9);\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat map(vec2 p)\n{\n    return distance(B(p).xy, p);\n}\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\n// --------------------------------------\n\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec2 randomInCircle( void )\n{\n    float an = 6.283185*float(rand())/32767.0;\n    return vec2(cos(an),sin(an));\n}\n\n// WoS\nvec3 march( in vec2 p )\n{\n    float h = 0.0;\n\tfor( int i=0; i<2; i++ )\n    {\n        h = 1.*map(p);\n        if( h<0.) break;\n        p = p + h*randomInCircle();\n    }\n    return C(B(p).xy).xyz/(0.4*h+0.1);\n}\n\n\nMain {\n    // init randoms\n    vec2 p0 = U;\n    ivec2 qqq = ivec2(U);\n    srand( hash(qqq.x+hash(qqq.y+hash(iFrame))));\n    \n    vec3 col = march(p0);\n    vec4 prev = texelFetch(iChannel0, qqq, 0);\n    Q = vec4(mix(col,prev.xyz,0.95),1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3dsfzl", "name": "Understanding Coordinates", "author": "zktosu", "description": "understand point, color, coordinates, relation between pixels and coloring etc.", "tags": ["vector", "points", "coordinate", "relations"], "likes": 2, "viewed": 455, "published": 3, "date": "1588877492", "time_retrieved": "2024-07-30T21:08:14.942414", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y; //[x,y] -> (0..1<, 0..1) 1:1 aspect ratio.\n    vec2 mv = iMouse.xy/iResolution.y;\n    \n   \n    vec3 col = vec3(uv.xy, 0.0); // (r, g , 0) - Color: Hor.-> red, Vert.-> green\n    \n    // Create a cirle as mouse pointer!\n    col = vec3(distance(uv, mv));\n\n    // float r1 = (uv.y - mv.y)* 5.0 * (1.0 + abs(sin(iTime))); // done!\n    // float g1 = (uv.x - mv.x)* 5.0 * (1.0 + abs(sin(iTime))); // done!\n    \n    vec2 c1 = (uv.yx - mv.yx)* 10.0 * (1.0 + abs(sin(iTime)) ); // abs(sin(iTime)) -> scaler! \n    \n    // imagine vectors as height information.\n    // using operation \t\t+ get higher, \n    // \t\t\t\twith\t- get lower.\n    // linear combinations makes black and white, on and off, etc.\n    // for instance:\n    col.xy = mod(c1,4.0) * 4.0; // multiply mod by 4 to get the brightness back!\n    // combinational operation!\n    col = (smoothstep(0.01, 0.09, col) - smoothstep(0.09, 0.17, col));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1026]], "test": "untested"}
{"id": "3dsBzl", "name": "Function Bending", "author": "zktosu", "description": "simple function plot bender. ", "tags": ["function", "plot", "bend"], "likes": 0, "viewed": 294, "published": 3, "date": "1588875007", "time_retrieved": "2024-07-30T21:08:15.753246", "image_code": "float plot (vec2 st, float pct){\n  return  smoothstep( pct-0.1, pct, st.y) - smoothstep( pct, pct+0.1, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.y);\n    \n    float fn = 0.5 + 0.5* sin(iTime) * sin(8.0*iTime)* sin(uv.x*55.0);\n    float col = plot(uv, fn );\n    fragColor = vec4( 0.0, 1.0 - col, 0.0 , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 111], [113, 113, 170, 170, 373]], "test": "untested"}
{"id": "wdXBzs", "name": "[TWITCH] Friday Giro Fever", "author": "evvvvil", "description": "Friday Giro Fever - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "abstract", "glow", "reflections", "rotation", "gyroscope", "circular", "spaceship", "gyro", "structure", "industrial", "twitch", "improv"], "likes": 32, "viewed": 1029, "published": 3, "date": "1588873891", "time_retrieved": "2024-07-30T21:08:16.810420", "image_code": "// Friday Giro Fever - Result of an improvised live code session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Being on the dole doesn't have to be dull.\" - William Shakespeare\n\nvec2 z,v,e=vec2(.05,-.05);float t,tt,spo,g,gg;vec3 np,bp,pp,cp,po,no,al,ld;//global vars. About as boring as being stuck in lockdown with your wife and kids.\nfloat cy(vec3 p,vec3 r){return max(abs(length(p.xz)-r.x)-r.y,abs(p.y)-r.z/2.);} //my own primitive function which I didn't steal from IQ. Not bad for an ageing bitter skateboarder. It makes a hollow tube\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//rotate function. Short and sweet, just like Napoleon before his megalomaniac fit.\nvec2 fb( vec3 p,float s,float m) // fb \"fucking bit\" function make a base geometry which we use to make gyro and flying objects\n{\n  for(int i=0;i<4;i++){//bullshit kifs rotation cloner. \"Friday Giro Fever\" is a reference to the UK umemployment benefits, the \"giro\". It usually lands on friday, meaning there is always a party for everyone, every friday, in England.\n    p=abs(p);//People against unemployment benefit are heartless like people annoyed at my humourous comments are boring\n    p.xy*=r2(.48);//clone along xy axis with rotation\n    p.yz*=r2(s*sin(p.z*.5)*.3);//this tweaks the gyro into much different shape for flying objects\n  }\n  vec2 h,t=vec2(cy(p,vec3(2,.3,.4)),m);//Make thin hollow tube either yellow or blue \n  h=vec2(cy(p,vec3(2,.1,.6)),6); //Make white hollow tube\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  h=vec2(cy(p,vec3(2.,.4,.2)),3); //Make black hollow tube\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  return t;\n}\nvec2 road( vec3 p) //Road is yellow circular bit in middle. Nah it doesn't lead to Rome, it leads to an industrial estate in Birmingham. What? You got something against burnt cars and the smell of petrol?\n{ \n  vec2 h,t=vec2(cy(p,vec3(6,.5,1)),8);//Use my fancy fucking hollow tube primitive function, I know some clever bastard probably thought about it before but this is me we're talking about: I once got into an argument with the neighbour's dog and lost.\n  h=vec2(cy(p,vec3(6,.5,5)),3);//Make another hollow toob, this time black and...\n  h.x=abs(h.x)-.1;//...whip that fucker into shape, push it against the edges, and other sexual innuendos...\n  h.x=max(h.x,abs(p.y)-.6); //croperoo the fuckeroo and whatch it groove\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  t.x=max(t.x,-(abs(p.z)-.3)); //remove middle bit, otherwise it's full circle and so this way you can see it rotate more. Simple and easy like daddy in mommy\n  h=vec2(cy(p,vec3(6.9,0,.1)),6); //One more hollow tube this time around the whole shit, make it glow, so it's nice a central focal point to the composition (look at me talking like I actually know what I'm doing... fucking hipster)\n  g+=0.1/(0.1+h.x*h.x*100.);//Glow trick by Balkhan, which I tend to rinse and use as a party trick.\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  return t;\n}\nvec2 mp( vec3 p )\n{ \n  bp=np=cp=pp=p; //GYROBULLSHIT starts here\n  bp.xy*=r2(tt); //We make two positions bp and np, one rotate clockwise the other anti-clockwise\n  np.xy*=r2(-tt); //None of those positions are either right or wrong in terms of movements direction, get out of your hemisphere-centric bubble, Steve.\n  vec2 h,t=fb(bp*.6,0.,5.); //Make first gyro bit and spin the fucker\n  t.x/=0.6; //Since we scale the pos we must tweak domain into shape to avoid artifact\n  t.x=max(t.x,-(abs(p.z)-.3)); //remove middle bit of outter gyro\n  h=fb(np,0.,5.); //Make another fucking gyro and make it spin\n  t=t.x<h.x?t:h;  //Mege both spinning gyros, bit like \"Mr Speaker\" trying to order the parliament with both parties spinning out of control around their own lame centre of political gravity\n  h=fb(bp*1.7,0.,5.);h.x/=1.7;t=t.x<h.x?t:h; //Yeah yeah one more gyro, blah blah blah, something about distance fucking fields, man I'm so borded when is football restarting, being a geek is cool, but hooliganism is more rewarding.\n  h=vec2(length(p)-.4);//Dumb fucking sphere in middle, make it glow, call the Tate Modern, tell them about my struggle as a child in our anonymous post-post-modern society and give me the Turner Prize.\n  g+=0.1/(0.1+h.x*h.x*40.);t=t.x<h.x?t:h;//Make said dumb sphere glow, call Tate Modern again, explain I wasn't myself when I sent \"that\" email and and it's all due to Donald Trump's rage at China. Collect Turner Prize.\n  h=vec2(length(p.xz+sin(p.y*20.)*.03)-(2.-cos(p.y*.15)*2.3));//Middle pointy erections. What? Yeah broh they are errected, so they are erections... You need to get laid more ma broski.\n  h.x*=0.7; t=t.x<h.x?t:h; //Add those middle pointy erections... Mind where you sit.\n  h=road(p);t=t.x<h.x?t:h; //Whole road thingy is added here.  \n  pp.xz*=r2(tt);//Objects flying around, there is actually a sick position trick in there\n  pp.xy=abs(pp.xy);//Rotate first, then abs symetry on xy axis\n  pp+=vec3(cos(-3.+sin(tt))*6.,-2.,sin(-3.+sin(tt))*6.); //push position along circle\n  pp.xz*=r2(sin(tt));//Rotate the fucking whole thing back and forth\n  h=fb(pp*3.5,3.,7.);//And that's how we get satisfying pandular action. Please note \"satisfying pandular action\" is also what wives want.\n  h.x*=0.15;  t=t.x<h.x?t:h;//since we scaled position, tweak back domain\n  h=vec2(length(pp)-.2);//Blue glow sphere inside flying objects\n  gg+=0.2/(0.1+h.x*h.x*(50.-sin(pp.z*.5+tt*2.)*48.)); //Make it glow and collect some Italia'90 football cards for your meak effort\n  t=t.x<h.x?t:h; //Merge geom together, retain material ID \n  h=fb(p*.165,3.,7.); //Big outter shell is made of flying object body\n  h.x*=3.0; t=t.x<h.x?t:h; //Scaled position means tweak domain. Should have gone to Stockton to become a tweaker when i had the opportunity back in 2010.\n  h=vec2(length(p.xy)-.2+abs(p.z*.02)); //Long white line, usually taken on fridays, through a straw, while talking about how great a drummer Zach Hill really is.\n  g+=0.2/(0.1+h.x*h.x*(50.-sin(pp.z*.2+tt*2.)*45.)); //Glow the fat white line along z axis, I know, I know, it is inviting. Who doesn't like to buy a gram of fun and chat shit to their friends?\n  t=t.x<h.x?t:h;//Merge it all, get into rehab and become a \"hero\" for saving your own skin.\n  return t; //I'm done commenting this and can go back to pointing menacingly at the neighbour's dog\n}\nvec2 tr( vec3 ro, vec3 rd,float _max,int iter) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<iter;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.00001||t.x>_max) break;//Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>_max) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.82);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  v=mix(vec2(3.,8.8),vec2(12.,16.),ceil(cos(tt*.4)));//Reuse the v variable as holder of camera variables\n  vec3 ro=mix(vec3(1),vec3(-1,-.8,-1),ceil(sin(tt*.4)))*vec3(cos(tt*.2)*v.y,v.x+sin(tt*.4)*2.,sin(tt*.2)*v.y),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)), //camera forward, left and up vector.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.5,-.1)); //ld=light direction\n  co=fo=vec3(.09)-length(uv*.8)*.107;//background is dark with vignette\n  z=tr(ro,rd,50.,128);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying to throw a spear at a pig. We wouldnt have survive the ice age with you and your nerdy mates.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    spo=20.+20.*exp2(10.*texNoise(vec2(bp.z,dot(bp.xy,vec2(.7)))*.3).r);//spo is specular power and refraction index\n    al=vec3(1.,.5,0);//albedo is base colour by default it's yellow \n    if(z.y<5.) spo=40.,al=vec3(0); //material system if less than 5 make it black, with specular power 40 and no reflections\n    if(z.y>5.) spo=40.,al=vec3(1); //material system if more than 5 make it white, with specular power 40 and no reflections\n    if(z.y>6.) al=mix(vec3(.1,.2,.4),vec3(.1,.35,.6),sin(cp*.5)*.5+.5); //Material Id more than 6 makes it blue / green gradient\n    if(z.y>7.) al=vec3(1.,.5,0),spo=20.+20.*exp2(10.*texNoise(vec2(cp.z,dot(cp.xy,vec2(.7)))*.3).r); //Material ID more than 7 makes it yellow and we re adapt the specular power and refraction index\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);//Sp=specular, stolen from shane\n    co=mix(sp+mix(vec3(.8),vec3(1.),abs(rd))*al*(a(.1)*a(.2)+.2)*(dif+s(13.)),fo,min(fr,0.2));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    if(z.y>7.||z.y==5.){ //If material id is 5 or more than 7 then we do reflections\n      rd=refract(rd,-no,1.-(spo*.0005));//reflect rd with refraction\n      z=tr(po+rd*0.01,rd,50.,80); //Throw another ray from surface, shift ray start position a bit and shoot\n      if(z.y>0.){ //If we hit something in reflection ray... (optimization and cleanup this)\n        po=po+rd*z.x; //Get where we at\n        no=no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);//More broing normals calculations\n        al=vec3(1.,.5,0);//Gotta give it the material id thing so we know how to colour what\n        if(z.y<5.) al=vec3(0);//ya ya give it back the colours\n        if(z.y>5.) al=vec3(1);//Still pretty boring shit\n        if(z.y>6.) al=vec3(.1,.2,.4);//Did you know Louis Theroux had interviewed Tiger King before he went to prison?\n        if(z.y>7.) al=vec3(1.,.5,0); \n        float dif=max(0.,dot(no,ld));\n        co=co+(dif*al*fr);\n      }\n    }\n    co=mix(fo,co,exp(-.0001*t*t*t)); //Fog soften things, but it won't stop your mother from being unimpressed by your current girlfriend\n  } \n  fragColor = vec4(pow(co+g*.2+gg*.3*vec3(.0,.1,.7),vec3(.45)),1);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 415, 439, 439, 494], [495, 619, 636, 636, 679], [679, 763, 892, 892, 1861], [1862, 1862, 2068, 2068, 3331], [3332, 3332, 3351, 3351, 6674], [6675, 6675, 6776, 6776, 7545], [7546, 7657, 7680, 7680, 7884], [7974, 7974, 8103, 8103, 12151]], "test": "untested"}
{"id": "WdlfRl", "name": "mandelbrot_yurka", "author": "yurka", "description": "Mandelbrot set", "tags": ["mandelbrotset"], "likes": 0, "viewed": 101, "published": 3, "date": "1588872067", "time_retrieved": "2024-07-30T21:08:17.568393", "image_code": "vec3 mandelbrot(vec2 a)\n{\n    vec2 r = vec2(0.0, 0.0);\n    int s = 0;\n    int mx = 100;\n    while (s < mx && r.x*r.x + r.y*r.y < 20.0)\n    {\n        r += a;\n        r = vec2(r.x*r.x - r.y*r.y, 2.0*r.x*r.y);\n        s++;\n    }\n    vec3 res = vec3(0);\n\tif (r.x*r.x + r.y*r.y > 4.0)\n    {\n        res.g = float(s) / float(mx);\n        res.b = sqrt(float(s) / float(mx)); \n        res.r = 0.0;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0)/iResolution.y;\n\t//uv -= vec2(0.5, 0.5);\n    uv *= 2.0;\n    uv.x -= 0.5;\n    // Time varying pixel color\n    vec3 col = mandelbrot(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 413], [415, 415, 472, 522, 764]], "test": "untested"}
{"id": "tsXBzs", "name": "Cubeworld", "author": "mla", "description": "A World consisting of a single cube. Looking or moving out through the cube walls just comes back to the cube through a different wall. The grey sphere is you.", "tags": ["manifold", "cubeworld"], "likes": 12, "viewed": 481, "published": 3, "date": "1588868175", "time_retrieved": "2024-07-30T21:08:18.419119", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Cubeworld\n// Matthew Arcus, mla, 2020\n//\n// The entire world consists of a single cube, each wall of the cube is just a\n// passage back into the cube, through a different wall.\n//\n// Mouse to look around. Haven't worked out the details of doing lighting yet,\n// so just uses fogging to indicate distance.\n//\n// Came out of thinking about tmst's excellent \"Non-Euclidean World\":\n// https://www.shadertoy.com/view/WsXcWn\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\nfloat AA = 2.0;\nfloat maxdist = 15.0;\nint maxiterations = 30;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat stepsize(vec3 p, vec3 r) {\n  // Want least k such that p + kr has coordinate 1 in some dimension\n  // eg. p.x+kr.x = 1 => k = (1-p.x)/r.x\n  // eg. p.x+kr.x = 0 => k = -p.x/r.x\n  // Want k positive, so assuming p.x is 0 < p.x < 1, depends on r.\n  float k = 1e8;\n  if (r.x > 0.0) k = (1.0-p.x)/r.x;\n  else if (r.x < 0.0) k = min(k,-p.x/r.x);\n  if (r.y > 0.0) k = min(k,(1.0-p.y)/r.y);\n  else if (r.y < 0.0) k = min(k,-p.y/r.y);\n  if (r.z > 0.0) k = min(k,(1.0-p.z)/r.z);\n  else if (r.z < 0.0) k = min(k,-p.z/r.z);\n  return k; // What if we cross 2 boundaries?\n}\n\nint gethitside(vec3 p) {\n  if (p.x > 1.0) return 0;\n  if (p.x < 0.0) return 1;\n  if (p.y > 1.0) return 2;\n  if (p.y < 0.0) return 3;\n  if (p.z > 1.0) return 4;\n  if (p.z < 0.0) return 5;\n  return -1;\n}\n\nvoid nextdir(int hitside, inout vec3 r) {\n  if (hitside == 0) { r.yz = vec2(r.z,-r.y); r.xz = r.zx; } // Reflection in x=y\n  if (hitside == 1) { r.yz = vec2(r.z,-r.y); r.xz = vec2(-r.z,r.x); } // Rotation by 90 deg\n  if (hitside == 4) { r.xz = vec2(r.z,-r.x); r.yz = vec2(-r.z,r.y); } // Opposite rotation by 90 deg\n  if (hitside == 5) { r.xz = r.zx; r.yz = vec2(-r.z,r.y); } // Reflection in x=y\n}\n\nvoid nextpos(int hitside, inout vec3 p) {\n  if (hitside == 0) p.x -= 1.0;\n  if (hitside == 1) p.x += 1.0;\n  if (hitside == 2) p.y -= 1.0;\n  if (hitside == 3) p.y += 1.0;\n  if (hitside == 4) p.z -= 1.0;\n  if (hitside == 5) p.z += 1.0;\n  if (hitside == 0) { p.yz = vec2(p.z,1.0-p.y); p.xz = p.zx; } // Reflection in x=y\n  if (hitside == 1) { p.yz = vec2(p.z,1.0-p.y); p.xz = vec2(1.0-p.z,p.x); } // Rotation by 90 deg\n  if (hitside == 4) { p.xz = vec2(p.z,1.0-p.x); p.yz = vec2(1.0-p.z,p.y); } // Opposite rotation by 90 deg\n  if (hitside == 5) { p.xz = p.zx; p.yz = vec2(1.0-p.z,p.y); } // Reflection in x=y\n}\n\nbool traceray(inout vec3 p, inout vec3 r, out vec3 n, out int type, out float totaldist) {\n  totaldist = 0.0;\n  vec3 p0 = p;\n  for (int i = 0; i < maxiterations; i++) {\n    if (i > 0) {\n      // find intersection with sphere at p0\n      vec3 q = p-p0;\n      //(q+kr).(q+kr) = r2\n      float A = dot(r,r);\n      float B = dot(q,r);\n      float r = 0.05;\n      float r2 = r*r;\n      float C = dot(q,q)-r2;\n      float D = B*B-A*C;\n      if (D >= 0.0) {\n        float t = (-B-sqrt(D))/A;\n        totaldist += t;\n        n = q+t*r;\n        type = 6;\n        return true;\n      }\n    }\n    float eps = 1e-3;\n    float k = stepsize(p,r)+eps;\n    p += k*r;\n    totaldist += k;\n    if (totaldist > maxdist) return false;\n    // determine the hit side\n    int hitside = gethitside(p);\n    type = hitside;\n    vec3 border = min(p,1.0-p);\n    // Have we hit the wall frames?\n    if (hitside/2 == 0 && min(border.y,border.z) < 0.05) { n = vec3(1,0,0); return true; }\n    if (hitside/2 == 1 && min(border.z,border.x) < 0.05) { n = vec3(0,1,0); return true; }\n    if (hitside/2 == 2 && min(border.x,border.y) < 0.05) { n = vec3(0,0,1); return true; }\n    // Advance p and r\n    nextpos(hitside,p);\n    nextdir(hitside,r);\n  }\n  return false;\n}\n\nvoid moveforward(inout vec3 p, inout vec3 r, vec3 dir, float t) {\n  for (int i = 0; i < 50; i++) {\n    float k = stepsize(p,dir) ;\n    float eps = 1e-3;\n    if (t <= k) break;\n    k += eps;\n    p += k*dir;\n    t -= k;\n    int hitside = gethitside(p);\n    nextpos(hitside,p);\n    nextdir(hitside,dir);\n    nextdir(hitside,r);\n  }\n  p += t*dir;\n}\n\nvec3 getcolor(int type) {\n  if (type == 0) return vec3(1,0,0);\n  if (type == 1) return vec3(0,1,0);\n  if (type == 2) return vec3(0,0,1);\n  if (type == 3) return vec3(1,1,0);\n  if (type == 4) return vec3(1,0,1);\n  if (type == 5) return vec3(0,1,1);\n  return vec3(0.2);\n}\n\nvec3 raycolor(vec3 p, vec3 r) {\n    int type; vec3 n; float totaldist;\n    vec3 bgcol = vec3(1,1,0.5);\n    //vec3 bgcol = vec3(1);\n    if (!traceray(p,r,n,type,totaldist)) return bgcol;\n    vec3 basecolor = getcolor(type);\n    vec3 color = basecolor;\n    color *= 0.5;\n    color = mix(color,bgcol,totaldist/maxdist);\n    return color;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (false) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n    p.xy = rotate(p.xy,iTime * 0.125);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,2);\n      vec3 p = vec3(0.5);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      moveforward(p,r,vec3(0,0,1),mod(0.2*iTime,4.0));\n      vec3 c = raycolor(p,r);\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[702, 702, 723, 723, 749], [751, 751, 783, 1000, 1316], [1318, 1318, 1342, 1342, 1519], [1521, 1521, 1562, 1562, 1919], [1921, 1921, 1962, 1962, 2529], [2531, 2531, 2621, 2621, 3760], [3762, 3762, 3827, 3827, 4106], [4108, 4108, 4133, 4133, 4377], [4379, 4379, 4410, 4410, 4715], [4717, 4717, 4747, 4747, 4796], [4798, 4798, 4825, 4825, 5153], [5155, 5155, 5212, 5212, 5743]], "test": "untested"}
{"id": "tdXfRs", "name": "crashing shader", "author": "FabriceNeyret2", "description": "if I uncomment line 7,\r\nthis shader crash the tab on Firefox & Chrome / Ubuntu18 / Nvidia.\r\nA more complex on  log me out ( probably crashing X11 ) on Chrome !\r\n\r\nbug report: [url]https://bugs.chromium.org/p/chromium/issues/detail?id=1079309[/url]", "tags": ["glsl", "bug"], "likes": 0, "viewed": 842, "published": 3, "date": "1588859438", "time_retrieved": "2024-07-30T21:08:19.398500", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist = 1. / length(fragCoord);\n    \n // if ( fragCoord.x > 0.) dist *= 2.;\n    \n    fragColor = vec4(dist);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 177]], "test": "untested"}
{"id": "wdXBzl", "name": "value noise - 234 chars", "author": "FabriceNeyret2", "description": "re-golfing 277 chars [url]https://shadertoy.com/view/MlsXDr[/url]", "tags": ["2d", "noise", "perlin", "2tweets", "short"], "likes": 8, "viewed": 503, "published": 3, "date": "1588853375", "time_retrieved": "2024-07-30T21:08:20.164452", "image_code": "// re-golfing 277 chars https://shadertoy.com/view/MlsXDr\n// ( quadrilin version of Perlin noise with marble modifier. See more there. )\n\n\n// -14 by xor \n\nvoid mainImage(out vec4 O, vec2 I)   \n{\n    for(float s = 1.;s<9.;s+=s)\n    {\n        vec4 m = (I/iResolution.y*8.-vec2(7,4)).xyxy*s, c;\n        m -= c = floor(m);  m.xy = 1.-m.xy; m *= m*(3.-m-m);\n        O += dot(m*m.yzwx,fract(sin(vec4(0,1,158,157) + c.x+157.*c.y)*57.))/s;\n    }\n\tO = sin(O/.1+iTime);\n} /*\n\n\n\n\n// +18 now that the #define mainimage is no longer allowed\n\n\n\n\n// -11 by coyote\n\n#define h fract( 57.*sin( vec2(0,157) + dot( u*s-r, vec2(1,157) )//\nvoid mainImage(out vec4 O, vec2 U) {\n    for(vec2 m,r, u = 8.*U/iResolution.y-vec2(7,4), s=vec2(1);\n        s.x<16.; s+=s )\n          r = m = fract(u*s),\n          m *= m*(3.-m-m),\n          r  = mix( h)), h+1.)), m.x )/s,\n          O += mix(r.xx,r,m).y ;\n    O = sin(O/.1+iTime);\n} /*\n\n\n\n\n\n\n// --- 244 chars\n\n#define h(n) fract( sin( n+vec2(0,157) ) *57. )   //\n#define mainImage(O,U)                             \\\n    vec2 m,r, u = 8.*U/iResolution.y-vec2(7,4);    \\\n    for(float l,s=1.; s<16.; s+=s )                \\\n          m = fract(u*s),                          \\\n          l = dot( u*s-m, vec2(1,157) ),           \\\n          m *= m*(3.-m-m),                         \\\n          r  = mix( h(l), h(++l), m.x ),           \\\n          O += mix(r.xx,r,m).y /s ;                \\\n    O = sin(O/.1+iTime)                           /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 194, 194, 461]], "test": "untested"}
{"id": "wsXBzl", "name": "PerlinNosie", "author": "Yann1210", "description": "Sample Perlin Nosie", "tags": ["study"], "likes": 3, "viewed": 277, "published": 3, "date": "1588852674", "time_retrieved": "2024-07-30T21:08:21.121893", "image_code": "//Perlin噪声、Simplex噪声和Value噪声在性能上大致满足：Perlin噪声 > Value噪声 > Simplex噪声，\n//Simplex噪声性能最好。Perlin噪声和Value噪声的复杂度是O(2n)O(2n)，其中n是维数，\n//但Perlin噪声比Value噪声需要进行更多的乘法（点乘）操作。而Simplex噪声的复杂度为O(n2)O(n2)\n//https://blog.csdn.net/candycat1992/article/details/50346469\n\n//计算顶点梯度向量\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)));\n\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(p)*43758.5453123);\n}\n\nfloat hash21(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\n\n//简单perlin noise\nfloat noise(vec2 p)\n{\n    vec2 pi = floor(p);//向下取整得到晶格结构的左下点，方便得到输入点对应的晶体结构\n    vec2 pf = p - pi;\n\n    vec2 w = pf * pf * (3.0 - 2.0 * pf); //s(t)=3t2−2t3\n    \n    //vec2 w = pf * pf * pf* (6.0 * pf * pf -15.0 * pf + 10.0); //s(t)=6t5−15t4+10t3\n\t\n    //使用缓和曲线（ease curves）来计算它们的权重和\n   // return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n   //                dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n    //           mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n   //                dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n  //             w.y);\n    \n    \n    //计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘\n    float dis1 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float dis2 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float dis3 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float dis4 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    float m1 = mix(dis1, dis2, w.x);\n    float m2 = mix(dis3, dis4, w.x);        \n    \n    return mix(m1,m2,w.y);\n                  \n}\n\n\n//简单value noise\nfloat value_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\n    //vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    vec2 w = pf * pf * pf* (6.0 * pf * pf -15.0 * pf + 10.0); //s(t)=6t5−15t4+10t3\n\n    \n    float m1 = mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x);\n    float m2 = mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x);\n    \n   // return mix(mix(hash22(pi + vec2(0.0, 0.0)), hash22(pi + vec2(1.0, 0.0)), w.x),\n     //          mix(hash22(pi + vec2(0.0, 1.0)), hash22(pi + vec2(1.0, 1.0)), w.x),\n       //        w.y);\n        \n       return mix(m1,m2,w.y);\n}\n\n//simplex noise\nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat perlin_noise_sum(vec2 p)\n{\n    float f = 0.0;\n    //叠加了5层，并把初始化采样距离设置为4\n    p = p * 2.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n    f += 0.2500 * noise(p); p = 2.0 * p;\n    f += 0.1250 * noise(p); p = 2.0 * p;\n    f += 0.0625 * noise(p); p = 2.0 * p;\n\n   return f;\n}\n\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat perlin_noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 2.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(noise(p)); p = 2.0 * p;\n\n    return f;\n}\n\n\n//分形布朗运动  sin(x+|noise(p)|+12|noise(2p)|+14|noise(4p)|+...)\nfloat perlin_noise_sum_abs_sin(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(noise(p)); p = 2.0 * p;\n    f = sin(f + p.x/32.0);\n    return f;\n}\n\n//==============================================================================\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat value_noise_sum(vec2 p)\n{\n    float f = 0.0;\n    //叠加了5层，并把初始化采样距离设置为4\n    p = p * 2.0;\n    f += 1.0000 * value_noise(p); p = 2.0 * p;\n    f += 0.5000 * value_noise(p); p = 2.0 * p;\n    f += 0.2500 * value_noise(p); p = 2.0 * p;\n    f += 0.1250 * value_noise(p); p = 2.0 * p;\n    f += 0.0625 * value_noise(p); p = 2.0 * p;\n\n   return f;\n}\n\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat value_noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 2.0;\n    f += 1.0000 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(value_noise(p)); p = 2.0 * p;\n\n    return f;\n}\n\n\n//分形布朗运动  sin(x+|noise(p)|+12|noise(2p)|+14|noise(4p)|+...)\nfloat value_noise_sum_abs_sin(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(value_noise(p)); p = 2.0 * p;\n    f = sin(f + p.x/32.0);\n    return f;\n}\n\n\n//==============================================================================\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat simplex_noise_sum(vec2 p)\n{\n    float f = 0.0;\n    //叠加了5层，并把初始化采样距离设置为4\n    p = p * 2.0;\n    f += 1.0000 * simplex_noise(p); p = 2.0 * p;\n    f += 0.5000 * simplex_noise(p); p = 2.0 * p;\n    f += 0.2500 * simplex_noise(p); p = 2.0 * p;\n    f += 0.1250 * simplex_noise(p); p = 2.0 * p;\n    f += 0.0625 * simplex_noise(p); p = 2.0 * p;\n\n   return f;\n}\n\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat simplex_noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 2.0;\n    f += 1.0000 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(simplex_noise(p)); p = 2.0 * p;\n\n    return f;\n}\n\n\n//分形布朗运动  sin(x+|noise(p)|+12|noise(2p)|+14|noise(4p)|+...)\nfloat simplex_noise_sum_abs_sin(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(simplex_noise(p)); p = 2.0 * p;\n    f = sin(f + p.x/32.0);\n    return f;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv *= 2.0;\n    float n =  simplex_noise_sum_abs_sin(uv);\n    //float noise = noise_itself(uv);\n    \n    fragColor = vec4(n,n,n,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 432, 453, 453, 590], [592, 592, 615, 615, 772], [774, 774, 796, 825, 1078], [1081, 1102, 1123, 1123, 2363], [2366, 2386, 2413, 2413, 2999], [3001, 3017, 3046, 3046, 3570], [3573, 3634, 3666, 3666, 3983], [3985, 4046, 4082, 4082, 4365], [4368, 4440, 4480, 4480, 4789], [4791, 4933, 4964, 4964, 5311], [5313, 5374, 5409, 5409, 5722], [5725, 5797, 5836, 5836, 6175], [6178, 6320, 6353, 6353, 6710], [6712, 6773, 6810, 6810, 7133], [7136, 7208, 7249, 7249, 7598], [7602, 7602, 7659, 7709, 7885]], "test": "untested"}
{"id": "WdXfRs", "name": "Day 107 ( 666 chars )", "author": "FabriceNeyret2", "description": "simplifying bufA of \"Day 107\"  by jeyko ( 1480 chars ). [url]https://shadertoy.com/view/3dByR1[/url]", "tags": ["mograph", "motiongraphics"], "likes": 12, "viewed": 353, "published": 3, "date": "1588851872", "time_retrieved": "2024-07-30T21:08:22.005530", "image_code": "// simplifying bufA:\"Day 107\" ( 1480 chars )  by jeyko. https://shadertoy.com/view/3dByR1\n\n// Ease from https://necessarydisorder.wordpress.com/\nfloat E(float p) {\n    return   p < 0.  ? 0.\n           : p > .5  ? 1.\n           : p > .25 ? p = 1.-p-p , 1. - 2.*p*p\n           :           8.*p*p; \n}\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, p,\n         U = ( u - .5*R ) / R.y;\n\n    float t = mod(iTime*.8, 3.5), r=1.57, x = U.x, z,m, i = 0.,\n          A = E(t), B = E(t-1.), C = E(t-2.),\n          b = r + .1*(A-C);\n    \n    U *= mat2( cos( r*( A+C + vec4(0,-1,1,0) ) ))\n      * ( 1. - dot(U,U)*.05 );   \n    U.x += .2* (A -B-B + C);\n    \n  //vec3 p = vec3(U,1) / dot(U,U);   \n    z = dot(U,U); p = U/z;\n    p.x -= sin( r* (A -B-B -C) ) *5.9;\n    \n    for(; i < 20.; i++) {\n        p *= m = (2. - i/20. ) / clamp( dot(p,p), .1, 20. );\n        z /= m;\n        p = abs( mod(p.yx - b, b+b)  - b );\n        if(i == 2.) p.x -= 1.1 + ( B+C - pow(A,.6)*2. ) /4.; \n    }\n    \n    t *= 1.8;\n#define S(v) smoothstep(0.,.5/R.y, .0015 - length(v*z) )\n    O =   S( p.x ) * vec4(1.9,.9,.6,0)   \n        + S( min(p.y, p.x) )\n          * pow( abs( sin( ( U.x + sin( (U.y-U.x)/.1 - t) ) /1.8) ), 6.)\n          * max( 2.* sin( vec4(8,8,5,0) + sin(x + t) ) , 0. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 145, 163, 163, 297], [298, 298, 336, 336, 1272]], "test": "untested"}
{"id": "3dXBzs", "name": "bicubic nearest neigbour", "author": "sh1boot", "description": "Thought it might be the beginning of a simple pixel art scaler.\n\nDrag mouse to compare with nearest neighbour.  Hold shift for a grid.", "tags": ["pixelartscaler"], "likes": 4, "viewed": 380, "published": 3, "date": "1588833744", "time_retrieved": "2024-07-30T21:08:22.854261", "image_code": "float score(vec4 a, vec4 b, float d) {\n    // TODO: be smarter\n\treturn distance(a, b);\n}\n\nvec2 zoom(vec2 uv) {\n    float scale = 1.0 + sin(iTime * 0.4) * 0.2;\n    vec2 window = vec2(32.,18.) * scale;\n    vec2 range = max(vec2(1.), iResolution.xy - window);\n    vec2 t = vec2(4.0, 4.1) * iTime / iResolution.xy;\n\tuv = uv * window / iResolution.xy;\n    uv += (vec2(sin(t.x), cos(t.y)) + vec2(1.)) * 0.5 * range;\n    return uv;\n}\n\nvec4 cubic(vec4 A, vec4 B, vec4 C, vec4 D, float t) {\n\tfloat t2 = t * t;\n    float t3 = t * t * t;\n    vec4 a = .5 * (-A + 3. * B - 3. * C + D);\n    vec4 b = A - 2.5 * B + 2. * C - .5 * D;\n    vec4 c = .5 * (C - A);\n   \tvec4 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\nfloat aacmp(float a, float b) {\n    float delta = 0.7 * fwidth(a - b);\n    return smoothstep(-delta, delta, a - b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = zoom(fragCoord);\n\n    vec4 n[20];\n    float d[20];\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            int k = i * 5 + j;\n            vec2 ij = vec2(float(j), float(i)) - vec2(2.0);\n            n[k] = texture(iChannel0, (floor(uv + ij) + 0.5) / iChannelResolution[0].xy);\n            d[k] = distance(floor(uv + ij) + 1., uv);\n        }\n        // TODO: save the real colours somewhere, and then \"palettise\" this\n        // buffer with similarity metrics from each of the four corners.\n        // This should result in the bicubic interpolation explicitly interpolating\n        // between corners rather than passing through an arbitrary space and using\n        // arbitrary distance metrics.  Then the final blend may be each corner weighted\n        // by the interpolated similarities, or something like that.\n        n[i * 5 + 4] = cubic(n[i * 5 + 0], n[i * 5 + 1], n[i * 5 + 2], n[i * 5 + 3], fract(uv.x));\n    }\n    vec4 interp = cubic(n[4], n[9], n[14], n[19], fract(uv.y));\n    n[0] = n[6];\n    n[1] = n[7];\n    n[2] = n[11];\n    n[3] = n[12];\n    d[0] = d[6];\n    d[1] = d[7];\n    d[2] = d[11];\n    d[3] = d[12];\n\n    float s[4];\n    for (int i = 0; i < 4; ++i) {\n        s[i] = score(interp, n[i], d[i]);\n    }\n\n    float w, vs[4];\n    w = aacmp(s[0], s[1]);\n    s[0] = mix(s[0], s[1], w);\n    n[0] = mix(n[0], n[1], w);\n    w = aacmp(s[2], s[3]);\n    s[2] = mix(s[2], s[3], w);\n    n[2] = mix(n[2], n[3], w);\n\n    vec4 o = mix(n[0], n[2], aacmp(s[0], s[2]));\n\n    vec4 m = iMouse;\n    m.w = abs(m.w);  // discard click event\n    if (m.z > 0. && m.w > 0.) {\n        m = vec4(min(m.xy, m.zw), max(m.xy, m.zw));\n        if (m.x < fragCoord.x && fragCoord.x < m.z\n            && m.y < fragCoord.y && fragCoord.y < m.w) {\n#if 1\n            o = fract(uv.y) < 0.5\n                ? fract(uv.x) < 0.5 ? n[6] : n[7]\n                : fract(uv.x) < 0.5 ? n[11] : n[12];\n#else\n            o = vec4(fract(uv.y) < 0.5\n                ? fract(uv.x) < 0.5 ? d[6] : d[7]\n                : fract(uv.x) < 0.5 ? d[11] : d[12]);\n#endif\n            vec2 box = smoothstep(0.05, 1.10, abs(fragCoord - m.xy))\n                     * smoothstep(0.05, 1.10, abs(fragCoord - m.zw));\n            o *= box.x * box.y;\n        }\n    }\n    if (texelFetch(iChannel3, ivec2(16, 0), 0).x >= 0.5) {\n        vec2 grid = smoothstep(0.05, 0.10, fract(uv));\n        o *= grid.x * grid.y;\n    }\n    fragColor = o;\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 62, 88], [90, 90, 110, 110, 426], [428, 428, 481, 481, 700], [702, 702, 733, 733, 819], [821, 821, 878, 878, 3307]], "test": "untested"}
{"id": "Wsffzl", "name": "Random-walk Based Area Lighting", "author": "blackle", "description": "inspired by iq's experiments with monte carlo PDE solving https://www.shadertoy.com/view/WsXBzl", "tags": ["lighting", "area", "montecarlo"], "likes": 28, "viewed": 1258, "published": 3, "date": "1588828862", "time_retrieved": "2024-07-30T21:08:23.708975", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(sqrt(texture(iChannel0, uv).x)) + abs(hash(hash(uv.x,uv.y),iTime))*0.1;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define METAL 0.\n#define SMOOTHNESS 3.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat noise(vec3 p) {\n    p.z -=iTime*0.1;\n    return smoothstep(0.99, 1.0, sin(dot(sin(p*8.), cos(p*6.+2.))*4.));\n}\n\nfloat checker(vec3 p) {\n    return smoothstep(0.0,0.01, sin(p.x)*sin(p.y)*sin(p.z-iTime*2.));\n}\n\nvec3 warp(vec3 p) {\n    p = sqrt(p*p+0.01)-0.4;\n    p.z = asin(sin(p.z*3.)*0.95)/3.;\n    return p;\n}\n\nfloat rings(vec3 p) {\n    p = erot(p,vec3(0,1,0),radians(45.+iTime*9.));\n    p = erot(p,vec3(1,0,0),radians(45.+iTime*5.));\n    return length(vec2(length(p.xy)-0.45,p.z))-0.05;\n}\n\nfloat scene(vec3 p) {\n    p = warp(p);\n    return min(length(p)-0.35, rings(p));\n}\n\nfloat scenecol(vec3 p) {\n    float r = rings(warp(p));\n    if (r > 0.005) return 0.0;\n    return mix(noise(p)*2., checker(p*10.), smoothstep(0.0,.1,sin(iTime+p.z*0.5)));\n}\n\nvec3 normal(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ) );\n}\n\n\nfloat march(vec3 p, float seed, vec3 bias) {\n    vec3 init = p;\n    for (int i = 0; i < 50; i++) {\n        float dist = scene(p);\n        if (dist*dist < 1e-6) break;\n        vec3 rnd = rndvec(seed,i) + rndvec(seed,i+100) + rndvec(seed,i+200);\n        vec3 jump = tan(rnd/3.+bias)*SMOOTHNESS;\n        p+=jump*dist;\n    }\n    return scenecol(p);\n}\n\nvec2 map(vec2 uv) {\n    return (uv*iResolution.y+0.5*iResolution.xy)/iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-4,0,0);\n\n    float yrot = 0.4;\n    float zrot = iTime*0.3;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for(int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n    }\n    \n    float color = 0.;\n    float seed = hash(iTime, hash(uv.x,uv.y));\n    if (hit) {\n        vec3 n = normal(p);\n   \t\tvec3 r = reflect(cam, n);\n    \tvec2 smp = vec2(0);\n        vec3 bias = mix(n,r,METAL)*0.2;\n    \tfor (int i = 0; i < 30 && hit; i++) {\n        \tfloat seed = hash(float(i), seed);\n        \tsmp += vec2(march(p+n*0.01, seed, bias), 1.);\n    \t}\n        color = smp.x/smp.y+scenecol(p)*0.6;\n    }\n    fragColor.x = color;\n    float prev = texture(iChannel0, map(uv)).x;\n    fragColor.x = mix(fragColor.x, prev, .5);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 rndvec(float seed, int i) {\n    float h1 = hash(seed, float(i));\n    float h2 = hash(h1, float(i));\n    float h3 = hash(h2, float(i));\n    return vec3(h1,h2,h3);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsffzl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 251, 251, 386]], "test": "untested"}
{"id": "3sfBRs", "name": "SDF Box", "author": "leftofzen", "description": "Signed-distance field to show a box. Took me a while but I finally figured out the branchless version :)", "tags": ["2d", "simple", "sdf", "box"], "likes": 1, "viewed": 2781, "published": 3, "date": "1588826876", "time_retrieved": "2024-07-30T21:08:24.680378", "image_code": "float box(vec2 uv, vec2 topLeft, vec2 bottomRight)\n{\n    return uv.x > topLeft.x && uv.x < bottomRight.x && uv.y < topLeft.y && uv.y > bottomRight.y ? 1. : 0.;\n}\n\nfloat sdfBox(vec2 p, vec2 size)\n{\n    vec2 d = abs(p) - size;  \n\treturn length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdfCircle(vec2 p, vec2 size)\n{\n    //vec2 d = abs(p) - size;  \n\t//return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n    return distance(p, size);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col;\n    \n    // sdf box\n    float f = sdfBox(uv, vec2(0.2, 0.2));\n    \n    //if (f < 0.)\n   \t//    col = vec3(1., 0., 1.);\n    \n    // branchless version of the above if\n    col += vec3(1., 0., 1.) * -sign(f);\n    \n    // circle\n    col += distance(uv, vec2(0, 0));\n    \n\n    // old-school box for comparison\n    //if (abs(uv.x) < 0.01 && abs(uv.y) < 0.01)\n     //col = vec3(1.f, 1.f, 1.f);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 161], [163, 163, 196, 196, 287], [289, 289, 325, 418, 450], [452, 452, 509, 559, 1106]], "test": "untested"}
{"id": "3dfBRs", "name": "I don't know why I did this", "author": "sh1boot", "description": "From that broken oil lamp but trying to add a rounding effect after the interference patterns.", "tags": ["palettesaturateblurpalette"], "likes": 2, "viewed": 341, "published": 3, "date": "1588823959", "time_retrieved": "2024-07-30T21:08:25.650784", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec4 b = texture(iChannel0, uv);\n    vec4 c = texture(iChannel1, uv);\n    b = pal(b);\n //   c = pal(c);\n    b = m.y > uv.y ? b : c;\n    fragColor = b;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 pal(in vec4 i) {\n    // Convert saturated (ie., approximately binary) xyzw values\n    // into a 16-colour palette.  In this case, an approximation\n    // of the C64 colour palette.  Why the C64?  I do not know.\n    // I just wanted to do away with that RGB-filter look that\n    // comes out otherwise.\n    vec4 j = vec4(1.) - i;\n    return (j.x * j.y * j.z * j.w) * vec4(0., 0., 0., 0.)\n         + (j.x * j.y * j.z * i.w) * vec4(1., 1., 1., .7)\n         + (j.x * j.y * i.z * j.w) * vec4(0., 1., 0., 0.)\n         + (j.x * j.y * i.z * i.w) * vec4(.5, 0., 0., .5)\n         + (j.x * i.y * j.z * j.w) * vec4(.6, 1., .9, .3)\n         + (j.x * i.y * j.z * i.w) * vec4(.7, .3, .7, 1.)\n         + (j.x * i.y * i.z * j.w) * vec4(0., .7, .4, .3)\n         + (j.x * i.y * i.z * i.w) * vec4(0., 0., .6, 0.)\n         + (i.x * j.y * j.z * j.w) * vec4(.9, .9, .5, .9)\n         + (i.x * j.y * j.z * i.w) * vec4(.8, .5, .3, .3)\n         + (i.x * j.y * i.z * j.w) * vec4(1., .5, .5, 0.)\n         + (i.x * j.y * i.z * i.w) * vec4(.2, .2, .2, 1.)\n         + (i.x * i.y * j.z * j.w) * vec4(.5, .5, .5, 0.)\n         + (i.x * i.y * j.z * i.w) * vec4(.6, 1., .7, 1.)\n         + (i.x * i.y * i.z * j.w) * vec4(0., .5, 1., .7)\n         + (i.x * i.y * i.z * i.w) * vec4(.8, .8, .8, .2);\n}\n\nfloat random(in float x) {\n    x = log2(abs(x) + 0.000001);\n    x = fract(sin(x) * 21.56789 + cos(x) * 11.98765);\n    return fract(x + 2.0);\n}\n\nfloat random(in float x, in float y) {\n    return random(sin(x * 7.1010101) + cos(y * 9.3131313) + 2.1);\n}\n", "buffer_a_code": "// Mostly a generic framebuffer feedback thing, with some\n// scribbling over the top.\n// To help edge towards rounded shapes, the smoothed and\n// sharpened buffer is fed back into this as well, so that\n// it gradually sharpens itself as it mixes and the shapes\n// should become progressively rounder from frame to frame\n// (if not for the stirring).\n\nvec2 fuzz(in vec2 seed) {\n    return vec2(random(seed.x, iTime), random(seed.y, iTime));\n}\n\nvec2 fuzz() {\n    return fuzz(vec2(123.,456.));\n}\n\nvec4 scribble(in vec4 col, in vec2 uv) {\n    // randomly sweeping path\n    vec2 m = vec2(sin(iTime * 0.3), cos(iTime * 0.25))\n           * vec2(cos(iTime * 0.2501), -sin(iTime * 0.11111))\n           * 0.35 + 0.5;\n    // with a little fluttery jitter\n    m += 0.03 * fuzz();\n\n    // random colour\n    vec4 colour = vec4(\n        smoothstep(0.2, 0.3, random(0.123, iTime)),\n        smoothstep(0.2, 0.3, random(0.234, iTime)),\n        smoothstep(0.2, 0.3, random(0.345, iTime)),\n        smoothstep(0.2, 0.3, random(0.456, iTime)));\n\n    // reduce to a dot (distance from current pixel to m)\n    float d = length(uv - m);\n    // plotted only for 1 second out of 10\n    if (fract(iTime * 0.05) > 0.2) d = 1.0;\n    return mix(vec4(colour), col, smoothstep(0.01,0.02, d));\n}\n\n// Just some random perturbation of the coordinates to make things swirl.\nvec2 f(in vec2 uv) {\n    const vec2 centre = vec2(0.35, 0.35);\n    const float th = 0.003;\n    const float r = 0.9995;\n    float c = cos(th), s = sin(th);\n    uv = (uv - centre) * mat2(c, s, -s, c) * r + centre;\n    vec2 wiggle = vec2(sin(iTime + uv.y * 15.1), cos(uv.x * 14.1));\n    uv += wiggle * 0.002;\n\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    vec2 vu = uv.yx;\n    uv = f(uv);\n    vu = f(vu).yx;\n    vec4 q = 0.5 * vec4(texture(iChannel1, uv).xz,\n                        texture(iChannel1, vu).yw).xzyw;\n    vec4 col = vec4(texture(iChannel0, uv).xz,\n                    texture(iChannel0, vu).yw).xzyw;\n\n    col = mix(col, q, 0.008);\n    \n    // Try to enlarge colour fringes a bit.\n    col *= vec4(1.005, 0.995, 0.995, 1.005);\n\n    fragColor = scribble(col, uv);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Read a blurred Buffer A (blurring aims to represent surface tension),\n// and quantise it according to the average of the previous frame.\n// The idea is that the average of the result should seek the median\n// weight of Buffer A so that half the buffer is lit.\n// This is fed back into buffer A to encourage it to gradually gain\n// more defined edges and the expected weight, while still being able\n// to move and blur.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Sample the main framebuffer with a whole lot of smoothing.\n    // Simply using the LOD bias on its own produces horrible artefacts,\n    // so try to do the smoothing manually here.\n    // TODO: make a better approximation of Gaussian blur\n    vec4 colour = 0.50 * texture(iChannel0, uv, 6.5)\n                + 0.25 * texture(iChannel0, uv, 4.5)\n                + 0.16 * texture(iChannel0, uv, 2.5);\n                + 0.09 * texture(iChannel0, uv, 0.5);\n\n#if 0\n    // Take the average of the whole of the previous output;\n    // if this is low then too few pixels were 'set', and\n    // if it is high then too many pixels were 'set'.\n    vec4 threshold = texture(iChannel1, uv, 100.5);\n#else\n    // Take the average of the whole of the current input;\n    // This divides the output into above and below average,\n    // which is not the same as the median, but I think it will\n    // seek the median more stably than above.\n    vec4 threshold = texture(iChannel0, uv, 100.5);\n#endif\n    \n    // I didn't really think this through.  We need to make an informed\n    // guess at where the correct threshold should be, but it's fiddly\n    // trying to be stateful about previous guesses, so I just mashed\n    // the keyboard until the flashing and blinking didn't happened so\n    // much.\n    threshold = mix(threshold, vec4(0.7), 0.1);\n    colour = smoothstep(-0.005, 0.005, colour - threshold);\n\n    fragColor = colour;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 colour = texture(iChannel0, uv);\n    // probably need to use a more appropriate palette, here.\n    colour = pal(colour);\n    fragColor = colour;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Sample the main framebuffer with a whole lot of smoothing.\n    // Simply using the LOD bias on its own produces horrible artefacts,\n    // so try to do the smoothing manually here.\n    // TODO: make a better approximation of Gaussian blur\n    vec4 colour = 0.50 * texture(iChannel0, uv, 6.5)\n                + 0.25 * texture(iChannel0, uv, 4.5)\n                + 0.16 * texture(iChannel0, uv, 2.5);\n                + 0.09 * texture(iChannel0, uv, 0.5);\n\n    vec4 threshold = texture(iChannel0, uv, 100.5);\n    \n    threshold = mix(threshold, vec4(0.7), 0.1);\n    colour = smoothstep(-0.005, 0.005, colour - threshold);\n\n    fragColor = colour;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 297]], "test": "untested"}
{"id": "WdXfzl", "name": "Montecarlo PDE (2)", "author": "iq", "description": "Playing with [url]http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]. Used contour lines from [url]https://www.shadertoy.com/view/XdKGDW[/url]", "tags": ["2d", "montecarlo", "pde"], "likes": 63, "viewed": 7985, "published": 3, "date": "1588821050", "time_retrieved": "2024-07-30T21:08:26.854566", "image_code": "// Playing with Keenan Crane's latest paper in collab with\n// Rohan Sawhney: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]\n//\n// Used contour lines from https://www.shadertoy.com/view/XdKGDW\n//\n// See https://www.shadertoy.com/view/WsXBzl for a simpler example\n//\n// Change the define in line 397 of \"Buffer A\" in order to see the\n// actual color contour curves.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = vec4(data.xyz/data.w, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// https://iquilezles.org/articles/distfunctions\nvoid sdLine(inout vec4 dis_col, in vec2 p, vec2 a, vec2 b, vec3 cu,vec3 cv)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    if( d<dis_col.x )\n    {\n        float s = pa.x*ba.y-pa.y*ba.x;\n        dis_col = vec4(d,(s<0.0)?cu:cv);\n    }\n}\n\n// https://iquilezles.org/articles/distfunctions\nvoid sdLine(inout vec4 dis_col,in vec2 p, vec2 a, vec2 b,vec3 cu0,vec3 cv0,vec3 cu1,vec3 cv1)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    if( d<dis_col.x )\n    {\n        float s = pa.x*ba.y-pa.y*ba.x;\n        h = 1.0-h;\n        dis_col = vec4(d,(s<0.0)?mix(cu0,cu1,h):mix(cv0,cv1,h));\n    }\n}\n\n// image contour SDF\nvec4 map( in vec2 pos )\n{    \n  vec4 dis_col = vec4(1e20,0.0,0.0,0.0);\n\n  // data copied and transformed from https://www.shadertoy.com/view/XdKGDW\n  sdLine(dis_col,pos,vec2( 0.032566, 0.636419),vec2(-0.140558, 0.554919),vec3(0.802,0.563,0.443),vec3(0.865,0.792,0.690));\n  sdLine(dis_col,pos,vec2( 0.157917, 0.667506),vec2( 0.032586, 0.636408),vec3(0.824,0.575,0.453),vec3(0.869,0.804,0.702));\n  sdLine(dis_col,pos,vec2( 0.292774, 0.683634),vec2( 0.157637, 0.667307),vec3(0.849,0.600,0.467),vec3(0.871,0.804,0.702));\n  sdLine(dis_col,pos,vec2( 0.462459, 0.681116),vec2( 0.293026, 0.683576),vec3(0.890,0.647,0.488),vec3(0.871,0.804,0.700));\n  sdLine(dis_col,pos,vec2( 0.532097, 0.663221),vec2( 0.462281, 0.681257),vec3(0.931,0.692,0.510),vec3(0.871,0.804,0.698));\n  sdLine(dis_col,pos,vec2( 0.679623, 0.589789),vec2( 0.532148, 0.663353),vec3(0.951,0.712,0.518),vec3(0.871,0.804,0.698));\n  sdLine(dis_col,pos,vec2( 0.737901, 0.539194),vec2( 0.680024, 0.589419),vec3(0.951,0.712,0.512),vec3(0.871,0.804,0.698));\n  sdLine(dis_col,pos,vec2( 0.816252, 0.438381),vec2( 0.737331, 0.539616),vec3(0.933,0.700,0.502),vec3(0.871,0.804,0.696));\n  sdLine(dis_col,pos,vec2( 0.855568, 0.362220),vec2( 0.816666, 0.437574),vec3(0.920,0.684,0.486),vec3(0.871,0.802,0.694));\n  sdLine(dis_col,pos,vec2( 0.914063, 0.195570),vec2( 0.855412, 0.362903),vec3(0.904,0.667,0.467),vec3(0.871,0.800,0.694));\n  sdLine(dis_col,pos,vec2( 0.906394,-0.050806),vec2( 0.914184, 0.195399),vec3(0.876,0.637,0.437),vec3(0.871,0.800,0.692));\n  sdLine(dis_col,pos,vec2( 0.847684,-0.254043),vec2( 0.906304,-0.051022),vec3(0.841,0.600,0.402),vec3(0.871,0.800,0.688));\n  sdLine(dis_col,pos,vec2( 0.753134,-0.419097),vec2( 0.847548,-0.253827),vec3(0.808,0.571,0.373),vec3(0.871,0.798,0.686));\n  sdLine(dis_col,pos,vec2( 0.655326,-0.537575),vec2( 0.752991,-0.419390),vec3(0.796,0.557,0.357),vec3(0.871,0.796,0.686),vec3(0.698,0.439,0.271),vec3(0.871,0.796,0.686));\n  sdLine(dis_col,pos,vec2( 0.589686,-0.601779),vec2( 0.655427,-0.537635),vec3(0.698,0.439,0.271),vec3(0.871,0.796,0.686),vec3(0.592,0.298,0.149),vec3(0.871,0.796,0.686));\n  sdLine(dis_col,pos,vec2( 0.485769,-0.673529),vec2( 0.589993,-0.601259),vec3(0.553,0.269,0.131),vec3(0.871,0.796,0.684));\n  sdLine(dis_col,pos,vec2( 0.420683,-0.695361),vec2( 0.485736,-0.673833),vec3(0.506,0.247,0.124),vec3(0.876,0.806,0.692));\n  sdLine(dis_col,pos,vec2( 0.289074,-0.705976),vec2( 0.420341,-0.695230),vec3(0.482,0.275,0.155),vec3(0.876,0.806,0.692));\n  sdLine(dis_col,pos,vec2( 0.261794,-0.694878),vec2( 0.289218,-0.706199),vec3(0.459,0.284,0.173),vec3(0.871,0.796,0.680));\n  sdLine(dis_col,pos,vec2( 0.234336,-0.652438),vec2( 0.261805,-0.694874),vec3(0.443,0.249,0.153),vec3(0.871,0.796,0.678));\n  sdLine(dis_col,pos,vec2( 0.229172,-0.613117),vec2( 0.234298,-0.652477),vec3(0.420,0.184,0.116),vec3(0.871,0.796,0.678));\n  sdLine(dis_col,pos,vec2( 0.211059,-0.573956),vec2( 0.229373,-0.612721),vec3(0.404,0.145,0.094),vec3(0.871,0.796,0.678),vec3(0.384,0.090,0.059),vec3(0.631,0.506,0.447));\n  sdLine(dis_col,pos,vec2( 0.794264, 0.332819),vec2( 0.820637, 0.237829),vec3(0.961,0.525,0.318),vec3(0.941,0.394,0.175));\n  sdLine(dis_col,pos,vec2( 0.791799, 0.406427),vec2( 0.794099, 0.333239),vec3(0.967,0.565,0.365),vec3(0.941,0.388,0.163));\n  sdLine(dis_col,pos,vec2( 0.773116, 0.456365),vec2( 0.791677, 0.406208),vec3(0.973,0.596,0.406),vec3(0.941,0.382,0.153));\n  sdLine(dis_col,pos,vec2( 0.691214, 0.542967),vec2( 0.772875, 0.456604),vec3(0.980,0.631,0.455),vec3(0.941,0.375,0.139));\n  sdLine(dis_col,pos,vec2( 0.584748, 0.612130),vec2( 0.691856, 0.543066),vec3(0.988,0.675,0.510),vec3(0.941,0.367,0.124));\n  sdLine(dis_col,pos,vec2( 0.523270, 0.633009),vec2( 0.583850, 0.612122),vec3(0.994,0.702,0.543),vec3(0.941,0.361,0.114));\n  sdLine(dis_col,pos,vec2( 0.416081, 0.649827),vec2( 0.523622, 0.632948),vec3(0.996,0.710,0.553),vec3(0.941,0.357,0.110),vec3(0.965,0.596,0.420),vec3(0.941,0.353,0.094));\n  sdLine(dis_col,pos,vec2( 0.328754, 0.652317),vec2( 0.416523, 0.649811),vec3(0.955,0.573,0.390),vec3(0.941,0.349,0.090));\n  sdLine(dis_col,pos,vec2( 0.152437, 0.628754),vec2( 0.328509, 0.652168),vec3(0.945,0.549,0.361),vec3(0.941,0.345,0.086),vec3(0.918,0.671,0.486),vec3(0.929,0.404,0.192));\n  sdLine(dis_col,pos,vec2(-0.058755, 0.562422),vec2( 0.152170, 0.628817),vec3(0.918,0.671,0.486),vec3(0.929,0.404,0.192),vec3(0.847,0.643,0.471),vec3(0.910,0.478,0.325));\n  sdLine(dis_col,pos,vec2(-0.152258, 0.413501),vec2(-0.073990, 0.418056),vec3(0.322,0.165,0.318),vec3(0.839,0.357,0.294),vec3(0.325,0.161,0.341),vec3(0.875,0.427,0.400));\n  sdLine(dis_col,pos,vec2(-0.166656, 0.426903),vec2(-0.152256, 0.413325),vec3(0.325,0.161,0.341),vec3(0.875,0.427,0.400),vec3(0.329,0.157,0.361),vec3(0.929,0.510,0.518));\n  sdLine(dis_col,pos,vec2(-0.150301, 0.459101),vec2(-0.167019, 0.427044),vec3(0.327,0.155,0.355),vec3(0.902,0.504,0.522));\n  sdLine(dis_col,pos,vec2(-0.118651, 0.485569),vec2(-0.150151, 0.459146),vec3(0.322,0.151,0.329),vec3(0.892,0.510,0.522));\n  sdLine(dis_col,pos,vec2(-0.002352, 0.524810),vec2(-0.118560, 0.485419),vec3(0.302,0.141,0.253),vec3(0.918,0.525,0.484));\n  sdLine(dis_col,pos,vec2( 0.031055, 0.523623),vec2(-0.002648, 0.525035),vec3(0.329,0.161,0.216),vec3(0.927,0.531,0.443));\n  sdLine(dis_col,pos,vec2( 0.698487, 0.039536),vec2( 0.691611,-0.011391),vec3(0.241,0.084,0.069),vec3(0.894,0.271,0.043));\n  sdLine(dis_col,pos,vec2( 0.719461, 0.087611),vec2( 0.698093, 0.039144),vec3(0.208,0.076,0.112),vec3(0.892,0.271,0.041));\n  sdLine(dis_col,pos,vec2( 0.756735, 0.118077),vec2( 0.719793, 0.087918),vec3(0.180,0.078,0.149),vec3(0.890,0.271,0.037));\n  sdLine(dis_col,pos,vec2( 0.781480, 0.121070),vec2( 0.756822, 0.117813),vec3(0.208,0.100,0.151),vec3(0.890,0.271,0.035));\n  sdLine(dis_col,pos,vec2( 0.801014, 0.097611),vec2( 0.781005, 0.120993),vec3(0.220,0.114,0.149),vec3(0.888,0.269,0.033));\n  sdLine(dis_col,pos,vec2( 0.823724, 0.024839),vec2( 0.801409, 0.097493),vec3(0.210,0.129,0.149),vec3(0.886,0.267,0.029));\n  sdLine(dis_col,pos,vec2( 0.823815,-0.104922),vec2( 0.823541, 0.024940),vec3(0.247,0.180,0.135),vec3(0.882,0.265,0.024));\n  sdLine(dis_col,pos,vec2( 0.812986,-0.134971),vec2( 0.823897,-0.104904),vec3(0.275,0.206,0.120),vec3(0.878,0.263,0.018));\n  sdLine(dis_col,pos,vec2( 0.781477,-0.159956),vec2( 0.813047,-0.134843),vec3(0.275,0.182,0.102),vec3(0.876,0.263,0.014));\n  sdLine(dis_col,pos,vec2( 0.742899,-0.136473),vec2( 0.781414,-0.160083),vec3(0.273,0.161,0.084),vec3(0.873,0.261,0.010));\n  sdLine(dis_col,pos,vec2( 0.707845,-0.099381),vec2( 0.742671,-0.136282),vec3(0.278,0.145,0.071),vec3(0.871,0.259,0.006));\n  sdLine(dis_col,pos,vec2( 0.692791,-0.057184),vec2( 0.707941,-0.099276),vec3(0.278,0.127,0.057),vec3(0.869,0.259,0.002));\n  sdLine(dis_col,pos,vec2( 0.691497,-0.011596),vec2( 0.692977,-0.057240),vec3(0.269,0.114,0.049),vec3(0.859,0.257,0.000));\n  sdLine(dis_col,pos,vec2( 0.649558,-0.424193),vec2( 0.570243,-0.515577),vec3(0.394,0.220,0.129),vec3(0.763,0.245,0.125));\n  sdLine(dis_col,pos,vec2( 0.691564,-0.410217),vec2( 0.649794,-0.424293),vec3(0.408,0.216,0.118),vec3(0.800,0.247,0.122),vec3(0.635,0.341,0.208),vec3(0.773,0.318,0.176));\n  sdLine(dis_col,pos,vec2( 0.696625,-0.423080),vec2( 0.691171,-0.410166),vec3(0.635,0.341,0.208),vec3(0.773,0.318,0.176),vec3(0.569,0.345,0.220),vec3(0.749,0.416,0.251));\n  sdLine(dis_col,pos,vec2( 0.689415,-0.442915),vec2( 0.697144,-0.422830),vec3(0.529,0.343,0.227),vec3(0.729,0.441,0.273));\n  sdLine(dis_col,pos,vec2( 0.593770,-0.551001),vec2( 0.689147,-0.443398),vec3(0.441,0.322,0.225),vec3(0.688,0.429,0.271));\n  sdLine(dis_col,pos,vec2( 0.555892,-0.565232),vec2( 0.593883,-0.550881),vec3(0.431,0.282,0.198),vec3(0.665,0.351,0.220));\n  sdLine(dis_col,pos,vec2( 0.551358,-0.559085),vec2( 0.555731,-0.565064),vec3(0.471,0.263,0.180),vec3(0.663,0.310,0.192),vec3(0.345,0.263,0.192),vec3(0.659,0.271,0.169));\n  sdLine(dis_col,pos,vec2( 0.570349,-0.515707),vec2( 0.551420,-0.559235),vec3(0.343,0.257,0.188),vec3(0.661,0.257,0.157));\n  sdLine(dis_col,pos,vec2( 0.139656, 0.051930),vec2( 0.125174,-0.011939),vec3(0.212,0.176,0.188),vec3(0.773,0.251,0.153),vec3(0.322,0.298,0.314),vec3(0.831,0.376,0.290));\n  sdLine(dis_col,pos,vec2( 0.156524, 0.072534),vec2( 0.139337, 0.052148),vec3(0.322,0.298,0.314),vec3(0.831,0.376,0.290),vec3(0.455,0.388,0.420),vec3(0.863,0.510,0.447));\n  sdLine(dis_col,pos,vec2( 0.207624, 0.092959),vec2( 0.156443, 0.072549),vec3(0.455,0.388,0.420),vec3(0.863,0.510,0.447),vec3(0.608,0.612,0.635),vec3(0.902,0.635,0.588));\n  sdLine(dis_col,pos,vec2( 0.277523, 0.089856),vec2( 0.208031, 0.092954),vec3(0.608,0.612,0.635),vec3(0.902,0.635,0.588),vec3(0.792,0.820,0.851),vec3(0.945,0.776,0.753));\n  sdLine(dis_col,pos,vec2( 0.342574, 0.060277),vec2( 0.277521, 0.089925),vec3(0.792,0.820,0.851),vec3(0.945,0.776,0.753),vec3(0.851,0.867,0.894),vec3(0.988,0.914,0.910));\n  sdLine(dis_col,pos,vec2( 0.395896, 0.011487),vec2( 0.342325, 0.060273),vec3(0.851,0.867,0.894),vec3(0.988,0.914,0.910),vec3(0.816,0.769,0.788),vec3(0.973,0.792,0.769));\n  sdLine(dis_col,pos,vec2( 0.426593,-0.056929),vec2( 0.395983, 0.010998),vec3(0.816,0.769,0.788),vec3(0.973,0.792,0.769),vec3(0.784,0.690,0.702),vec3(0.953,0.675,0.624));\n  sdLine(dis_col,pos,vec2( 0.429756,-0.097479),vec2( 0.426646,-0.056343),vec3(0.784,0.690,0.702),vec3(0.955,0.676,0.627));\n  sdLine(dis_col,pos,vec2( 0.211977, 0.039860),vec2( 0.152329, 0.066394),vec3(0.251,0.255,0.322),vec3(0.573,0.522,0.557),vec3(0.239,0.251,0.325),vec3(0.612,0.620,0.655));\n  sdLine(dis_col,pos,vec2( 0.253875,-0.009396),vec2( 0.212258, 0.039555),vec3(0.224,0.235,0.298),vec3(0.627,0.651,0.694));\n  sdLine(dis_col,pos,vec2( 0.304442,-0.112422),vec2( 0.254010,-0.009088),vec3(0.190,0.196,0.251),vec3(0.629,0.653,0.704));\n  sdLine(dis_col,pos,vec2( 0.333171,-0.133931),vec2( 0.303949,-0.112429),vec3(0.178,0.169,0.220),vec3(0.612,0.620,0.671));\n  sdLine(dis_col,pos,vec2( 0.374078,-0.127448),vec2( 0.333105,-0.133826),vec3(0.222,0.190,0.220),vec3(0.629,0.629,0.675));\n  sdLine(dis_col,pos,vec2( 0.429594,-0.097757),vec2( 0.374129,-0.127644),vec3(0.278,0.229,0.237),vec3(0.678,0.659,0.694));\n  sdLine(dis_col,pos,vec2( 0.128499,-0.076818),vec2( 0.113227,-0.128679),vec3(0.131,0.071,0.118),vec3(0.986,0.927,0.737));\n  sdLine(dis_col,pos,vec2( 0.214776,-0.207363),vec2( 0.168035,-0.203218),vec3(0.982,0.796,0.496),vec3(0.124,0.039,0.092));\n  sdLine(dis_col,pos,vec2( 0.238606,-0.218984),vec2( 0.215027,-0.207500),vec3(0.990,0.782,0.447),vec3(0.153,0.033,0.057));\n  sdLine(dis_col,pos,vec2( 0.252587,-0.370868),vec2( 0.218651,-0.371118),vec3(0.441,0.100,0.059),vec3(0.845,0.380,0.137));\n  sdLine(dis_col,pos,vec2( 0.276234,-0.360153),vec2( 0.252950,-0.370523),vec3(0.496,0.124,0.057),vec3(0.847,0.412,0.163));\n  sdLine(dis_col,pos,vec2( 0.296842,-0.316514),vec2( 0.275936,-0.360588),vec3(0.533,0.141,0.055),vec3(0.847,0.431,0.180),vec3(0.643,0.192,0.051),vec3(0.910,0.561,0.271));\n  sdLine(dis_col,pos,vec2( 0.296875,-0.238281),vec2( 0.296875,-0.316406),vec3(0.643,0.192,0.051),vec3(0.910,0.561,0.271),vec3(0.741,0.239,0.047),vec3(0.953,0.678,0.357));\n  sdLine(dis_col,pos,vec2(-0.018745,-0.009492),vec2(-0.023346,-0.023500),vec3(0.984,0.665,0.482),vec3(0.824,0.235,0.180));\n  sdLine(dis_col,pos,vec2( 0.004475, 0.004419),vec2(-0.019006,-0.009652),vec3(0.976,0.686,0.506),vec3(0.798,0.210,0.153));\n  sdLine(dis_col,pos,vec2( 0.078024,-0.000098),vec2( 0.004545, 0.004548),vec3(0.935,0.696,0.480),vec3(0.792,0.229,0.122));\n  sdLine(dis_col,pos,vec2( 0.129006,-0.035229),vec2( 0.078225,-0.000073),vec3(0.902,0.686,0.447),vec3(0.788,0.243,0.102),vec3(0.937,0.769,0.545),vec3(0.769,0.255,0.059));\n  sdLine(dis_col,pos,vec2( 0.214680,-0.370938),vec2( 0.167824,-0.202999),vec3(0.263,0.220,0.243),vec3(0.941,0.643,0.373));\n  sdLine(dis_col,pos,vec2( 0.117434,-0.128738),vec2(-0.023211,-0.023293),vec3(0.718,0.698,0.690),vec3(0.984,0.867,0.718));\n  sdLine(dis_col,pos,vec2(-0.027606,-0.023401),vec2(-0.250232, 0.058604),vec3(0.369,0.376,0.439),vec3(0.824,0.357,0.349));\n  sdLine(dis_col,pos,vec2( 0.224314,-0.490840),vec2( 0.214794,-0.371444),vec3(0.110,0.076,0.102),vec3(0.553,0.102,0.061));\n  sdLine(dis_col,pos,vec2( 0.210828,-0.578506),vec2( 0.224257,-0.490867),vec3(0.118,0.094,0.114),vec3(0.467,0.108,0.084));\n  sdLine(dis_col,pos,vec2(-0.738216, 0.577331),vec2(-0.835883, 0.550764),vec3(0.647,0.639,0.914),vec3(0.859,0.780,0.682));\n  sdLine(dis_col,pos,vec2(-0.428590, 0.601696),vec2(-0.738185, 0.577395),vec3(0.698,0.680,0.884),vec3(0.865,0.778,0.667));\n  sdLine(dis_col,pos,vec2(-0.257866, 0.593737),vec2(-0.428754, 0.601618),vec3(0.763,0.733,0.845),vec3(0.876,0.775,0.645));\n  sdLine(dis_col,pos,vec2(-0.136723, 0.554703),vec2(-0.257809, 0.593759),vec3(0.808,0.769,0.820),vec3(0.878,0.775,0.657));\n  sdLine(dis_col,pos,vec2(-0.910838, 0.948616),vec2(-0.980469, 0.968751),vec3(0.782,0.753,0.910),vec3(0.486,0.422,0.769));\n  sdLine(dis_col,pos,vec2(-0.849120, 0.905236),vec2(-0.910830, 0.948608),vec3(0.771,0.741,0.908),vec3(0.494,0.431,0.773));\n  sdLine(dis_col,pos,vec2(-0.805151, 0.844085),vec2(-0.849092, 0.905222),vec3(0.751,0.724,0.904),vec3(0.494,0.431,0.773));\n  sdLine(dis_col,pos,vec2(-0.792960, 0.808567),vec2(-0.805191, 0.844089),vec3(0.741,0.714,0.902),vec3(0.494,0.431,0.773));\n  sdLine(dis_col,pos,vec2(-0.660730, 0.350115),vec2(-0.687380, 0.324080),vec3(0.569,0.539,0.929),vec3(0.625,0.612,0.963));\n  sdLine(dis_col,pos,vec2(-0.581342, 0.390737),vec2(-0.660931, 0.350300),vec3(0.610,0.565,0.941),vec3(0.671,0.641,0.963));\n  sdLine(dis_col,pos,vec2(-0.519169, 0.405706),vec2(-0.581260, 0.390541),vec3(0.653,0.590,0.953),vec3(0.722,0.671,0.963));\n  sdLine(dis_col,pos,vec2(-0.325640, 0.410142),vec2(-0.519014, 0.405733),vec3(0.708,0.624,0.969),vec3(0.784,0.706,0.965));\n  sdLine(dis_col,pos,vec2(-0.265662, 0.386779),vec2(-0.325886, 0.410329),vec3(0.767,0.661,0.982),vec3(0.847,0.741,0.965));\n  sdLine(dis_col,pos,vec2(-0.890704, 0.394153),vec2(-0.996080, 0.374882),vec3(0.576,0.569,0.918),vec3(0.635,0.637,0.951));\n  sdLine(dis_col,pos,vec2(-0.808329, 0.393799),vec2(-0.890754, 0.394278),vec3(0.575,0.569,0.922),vec3(0.635,0.635,0.955));\n  sdLine(dis_col,pos,vec2(-0.746093, 0.374902),vec2(-0.808295, 0.393687),vec3(0.573,0.569,0.924),vec3(0.635,0.629,0.961));\n  sdLine(dis_col,pos,vec2(-0.691314, 0.328133),vec2(-0.746006, 0.375002),vec3(0.571,0.569,0.927),vec3(0.635,0.624,0.969));\n  sdLine(dis_col,pos,vec2(-0.713022, 0.223982),vec2(-0.699215, 0.078105),vec3(0.443,0.404,0.831),vec3(0.490,0.471,0.855),vec3(0.486,0.455,0.871),vec3(0.576,0.573,0.929));\n  sdLine(dis_col,pos,vec2(-0.687633, 0.328193),vec2(-0.713148, 0.224068),vec3(0.502,0.473,0.884),vec3(0.590,0.586,0.943));\n  sdLine(dis_col,pos,vec2(-0.962077,-0.021061),vec2(-0.984470,-0.062241),vec3(0.567,0.553,0.914),vec3(0.506,0.502,0.843));\n  sdLine(dis_col,pos,vec2(-0.929730, 0.012170),vec2(-0.962095,-0.021151),vec3(0.563,0.543,0.914),vec3(0.508,0.514,0.829));\n  sdLine(dis_col,pos,vec2(-0.842855, 0.056023),vec2(-0.929597, 0.011852),vec3(0.555,0.527,0.914),vec3(0.506,0.522,0.804));\n  sdLine(dis_col,pos,vec2(-0.740058, 0.072302),vec2(-0.842912, 0.056291),vec3(0.549,0.518,0.914),vec3(0.502,0.522,0.788),vec3(0.537,0.498,0.914),vec3(0.431,0.412,0.788));\n  sdLine(dis_col,pos,vec2(-0.648617, 0.066357),vec2(-0.739962, 0.072359),vec3(0.531,0.486,0.912),vec3(0.406,0.369,0.786));\n  sdLine(dis_col,pos,vec2(-0.599562, 0.052212),vec2(-0.648693, 0.066421),vec3(0.522,0.465,0.912),vec3(0.390,0.339,0.776));\n  sdLine(dis_col,pos,vec2(-0.523674,-0.011767),vec2(-0.599782, 0.051913),vec3(0.510,0.443,0.912),vec3(0.416,0.371,0.761));\n  sdLine(dis_col,pos,vec2(-0.216909, 0.467215),vec2(-0.261703, 0.386747),vec3(0.943,0.525,0.555),vec3(0.851,0.796,0.924));\n  sdLine(dis_col,pos,vec2(-0.140684, 0.554868),vec2(-0.216981, 0.467356),vec3(0.898,0.506,0.527),vec3(0.851,0.786,0.865));\n  sdLine(dis_col,pos,vec2(-0.294609, 0.328762),vec2(-0.320297, 0.253955),vec3(0.945,0.480,0.496),vec3(0.655,0.545,0.908));\n  sdLine(dis_col,pos,vec2(-0.261515, 0.386675),vec2(-0.294411, 0.328660),vec3(0.953,0.482,0.498),vec3(0.678,0.576,0.945),vec3(0.953,0.482,0.494),vec3(0.776,0.694,0.961));\n  sdLine(dis_col,pos,vec2(-0.320312, 0.152344),vec2(-0.320312, 0.250000),vec3(0.227,0.159,0.249),vec3(0.892,0.455,0.476));\n  sdLine(dis_col,pos,vec2(-0.285102, 0.093592),vec2(-0.320160, 0.152217),vec3(0.194,0.129,0.220),vec3(0.878,0.441,0.463));\n  sdLine(dis_col,pos,vec2(-0.249821, 0.058499),vec2(-0.285083, 0.093620),vec3(0.206,0.137,0.220),vec3(0.861,0.422,0.445));\n  sdLine(dis_col,pos,vec2(-0.370886, 0.200884),vec2(-0.296881, 0.058849),vec3(0.210,0.208,0.296),vec3(0.506,0.441,0.829));\n  sdLine(dis_col,pos,vec2(-0.371080, 0.218669),vec2(-0.370863, 0.200571),vec3(0.216,0.208,0.275),vec3(0.539,0.473,0.853));\n  sdLine(dis_col,pos,vec2(-0.320338, 0.250030),vec2(-0.371125, 0.218779),vec3(0.214,0.182,0.245),vec3(0.573,0.504,0.873));\n  sdLine(dis_col,pos,vec2(-0.318397, 0.038871),vec2(-0.296987, 0.058686),vec3(0.408,0.345,0.751),vec3(0.235,0.243,0.371));\n  sdLine(dis_col,pos,vec2(-0.335799, 0.000126),vec2(-0.318147, 0.038906),vec3(0.394,0.337,0.686),vec3(0.225,0.229,0.355));\n  sdLine(dis_col,pos,vec2(-0.457045, 0.015479),vec2(-0.343771, 0.003763),vec3(0.404,0.341,0.757),vec3(0.714,0.702,0.792),vec3(0.427,0.369,0.796),vec3(0.478,0.443,0.510));\n  sdLine(dis_col,pos,vec2(-0.524601,-0.011832),vec2(-0.457157, 0.015632),vec3(0.427,0.369,0.796),vec3(0.478,0.443,0.510),vec3(0.475,0.424,0.792),vec3(0.627,0.596,0.741));\n  sdLine(dis_col,pos,vec2(-0.567845,-0.048929),vec2(-0.524475,-0.011939),vec3(0.475,0.424,0.792),vec3(0.627,0.596,0.741),vec3(0.545,0.490,0.871),vec3(0.522,0.490,0.647));\n  sdLine(dis_col,pos,vec2(-0.687512,-0.202819),vec2(-0.567697,-0.048786),vec3(0.545,0.490,0.871),vec3(0.522,0.490,0.647),vec3(0.749,0.706,0.980),vec3(0.702,0.651,0.710));\n  sdLine(dis_col,pos,vec2(-0.738370,-0.246033),vec2(-0.687782,-0.202852),vec3(0.749,0.706,0.980),vec3(0.702,0.651,0.710),vec3(0.690,0.651,0.929),vec3(0.259,0.235,0.337));\n  sdLine(dis_col,pos,vec2(-0.819820,-0.267858),vec2(-0.738322,-0.246131),vec3(0.690,0.651,0.929),vec3(0.259,0.235,0.337),vec3(0.631,0.604,0.933),vec3(0.380,0.333,0.416));\n  sdLine(dis_col,pos,vec2(-0.925652,-0.360953),vec2(-0.819489,-0.267857),vec3(0.631,0.604,0.933),vec3(0.380,0.333,0.416),vec3(0.525,0.502,0.808),vec3(0.243,0.188,0.333));\n  sdLine(dis_col,pos,vec2(-0.924077,-0.382938),vec2(-0.926012,-0.360824),vec3(0.525,0.502,0.808),vec3(0.243,0.188,0.333),vec3(0.506,0.478,0.733),vec3(0.541,0.486,0.631));\n  sdLine(dis_col,pos,vec2(-0.908709,-0.396678),vec2(-0.923914,-0.383129),vec3(0.502,0.473,0.714),vec3(0.524,0.476,0.637));\n  sdLine(dis_col,pos,vec2(-0.877801,-0.327818),vec2(-0.908834,-0.396482),vec3(0.498,0.467,0.694),vec3(0.506,0.467,0.643),vec3(0.584,0.565,0.894),vec3(0.490,0.439,0.659));\n  sdLine(dis_col,pos,vec2(-0.850665,-0.306523),vec2(-0.877737,-0.328046),vec3(0.584,0.565,0.894),vec3(0.490,0.439,0.659),vec3(0.553,0.510,0.765),vec3(0.329,0.278,0.439));\n  sdLine(dis_col,pos,vec2(-0.842943,-0.336355),vec2(-0.850644,-0.306423),vec3(0.553,0.510,0.765),vec3(0.329,0.278,0.439),vec3(0.518,0.478,0.761),vec3(0.537,0.494,0.643));\n  sdLine(dis_col,pos,vec2(-0.646520,-0.253453),vec2(-0.842985,-0.336477),vec3(0.518,0.478,0.761),vec3(0.537,0.494,0.643),vec3(0.671,0.620,0.957),vec3(0.467,0.392,0.565));\n  sdLine(dis_col,pos,vec2(-0.613162,-0.227037),vec2(-0.646645,-0.253104),vec3(0.651,0.602,0.945),vec3(0.469,0.398,0.555));\n  sdLine(dis_col,pos,vec2(-0.561901,-0.162148),vec2(-0.613081,-0.227201),vec3(0.594,0.549,0.910),vec3(0.476,0.429,0.539));\n  sdLine(dis_col,pos,vec2(-0.500240,-0.050707),vec2(-0.562155,-0.162105),vec3(0.557,0.514,0.886),vec3(0.482,0.455,0.533),vec3(0.443,0.408,0.812),vec3(0.286,0.267,0.369));\n  sdLine(dis_col,pos,vec2(-0.464788,-0.030266),vec2(-0.500093,-0.050719),vec3(0.443,0.408,0.812),vec3(0.286,0.267,0.369),vec3(0.408,0.376,0.780),vec3(0.157,0.114,0.267));\n  sdLine(dis_col,pos,vec2(-0.439427,-0.045861),vec2(-0.464616,-0.030239),vec3(0.408,0.376,0.780),vec3(0.157,0.114,0.267),vec3(0.455,0.427,0.784),vec3(0.416,0.353,0.435));\n  sdLine(dis_col,pos,vec2(-0.421871,-0.081990),vec2(-0.439501,-0.045912),vec3(0.443,0.418,0.773),vec3(0.404,0.369,0.437));\n  sdLine(dis_col,pos,vec2(-0.386711,-0.105557),vec2(-0.421868,-0.082119),vec3(0.431,0.408,0.761),vec3(0.392,0.384,0.439),vec3(0.357,0.349,0.655),vec3(0.376,0.427,0.447));\n  sdLine(dis_col,pos,vec2(-0.339923, 0.003866),vec2(-0.386802,-0.101587),vec3(0.200,0.196,0.267),vec3(0.345,0.333,0.365));\n  sdLine(dis_col,pos,vec2(-0.407061,-0.201258),vec2(-0.386665,-0.105627),vec3(0.361,0.341,0.624),vec3(0.792,0.812,0.751));\n  sdLine(dis_col,pos,vec2(-0.403323,-0.268221),vec2(-0.406911,-0.201492),vec3(0.363,0.329,0.606),vec3(0.771,0.769,0.724));\n  sdLine(dis_col,pos,vec2(-0.390770,-0.273672),vec2(-0.403673,-0.268054),vec3(0.384,0.333,0.643),vec3(0.771,0.749,0.704));\n  sdLine(dis_col,pos,vec2(-0.345881,-0.060745),vec2(-0.386656,-0.101656),vec3(0.776,0.835,0.784),vec3(0.361,0.400,0.427),vec3(0.792,0.839,0.780),vec3(0.145,0.176,0.227));\n  sdLine(dis_col,pos,vec2(-0.328983,-0.056141),vec2(-0.345818,-0.060743),vec3(0.792,0.839,0.780),vec3(0.145,0.176,0.227),vec3(0.808,0.847,0.780),vec3(0.220,0.251,0.310));\n  sdLine(dis_col,pos,vec2(-0.252749,-0.126588),vec2(-0.329397,-0.055845),vec3(0.837,0.859,0.775),vec3(0.227,0.247,0.306));\n  sdLine(dis_col,pos,vec2(-0.230481,-0.160125),vec2(-0.252484,-0.126757),vec3(0.867,0.871,0.769),vec3(0.235,0.243,0.302),vec3(0.859,0.851,0.749),vec3(0.161,0.153,0.204));\n  sdLine(dis_col,pos,vec2(-0.226341,-0.219167),vec2(-0.230372,-0.160222),vec3(0.882,0.869,0.757),vec3(0.151,0.133,0.180));\n  sdLine(dis_col,pos,vec2(-0.277439,-0.343654),vec2(-0.226534,-0.219015),vec3(0.906,0.886,0.765),vec3(0.141,0.114,0.157),vec3(0.929,0.898,0.761),vec3(0.251,0.212,0.239));\n  sdLine(dis_col,pos,vec2(-0.331270,-0.274257),vec2(-0.390414,-0.273335),vec3(0.076,0.061,0.096),vec3(0.808,0.780,0.714));\n  sdLine(dis_col,pos,vec2(-0.307108,-0.285553),vec2(-0.331497,-0.274239),vec3(0.075,0.059,0.094),vec3(0.829,0.806,0.718));\n  sdLine(dis_col,pos,vec2(-0.285269,-0.316297),vec2(-0.307202,-0.285572),vec3(0.075,0.059,0.094),vec3(0.835,0.820,0.722));\n  sdLine(dis_col,pos,vec2(-0.277101,-0.348165),vec2(-0.284918,-0.316904),vec3(0.075,0.059,0.094),vec3(0.831,0.820,0.722),vec3(0.086,0.063,0.102),vec3(0.620,0.584,0.522));\n  sdLine(dis_col,pos,vec2( 0.191818,-0.655109),vec2( 0.210666,-0.574643),vec3(0.137,0.122,0.129),vec3(0.729,0.608,0.541),vec3(0.145,0.133,0.133),vec3(0.804,0.737,0.616));\n  sdLine(dis_col,pos,vec2( 0.177802,-0.664657),vec2( 0.191779,-0.655002),vec3(0.145,0.133,0.133),vec3(0.804,0.737,0.616),vec3(0.063,0.059,0.075),vec3(0.796,0.753,0.620));\n  sdLine(dis_col,pos,vec2( 0.168515,-0.738957),vec2( 0.178126,-0.664256),vec3(0.096,0.092,0.100),vec3(0.812,0.759,0.625));\n  sdLine(dis_col,pos,vec2( 0.155592,-0.752345),vec2( 0.168584,-0.738793),vec3(0.104,0.100,0.102),vec3(0.824,0.757,0.627));\n  sdLine(dis_col,pos,vec2( 0.132513,-0.757861),vec2( 0.155207,-0.752647),vec3(0.073,0.069,0.073),vec3(0.820,0.747,0.624));\n  sdLine(dis_col,pos,vec2( 0.086261,-0.759725),vec2(-0.023197,-0.695559),vec3(0.157,0.141,0.184),vec3(0.063,0.055,0.067),vec3(0.286,0.275,0.325),vec3(0.055,0.043,0.055));\n  sdLine(dis_col,pos,vec2( 0.132843,-0.757744),vec2( 0.086059,-0.759407),vec3(0.286,0.275,0.325),vec3(0.055,0.043,0.055),vec3(0.761,0.722,0.522),vec3(0.059,0.043,0.059));\n  sdLine(dis_col,pos,vec2(-0.008536,-0.523957),vec2(-0.113095,-0.546922),vec3(0.761,0.722,0.522),vec3(0.051,0.033,0.051));\n  sdLine(dis_col,pos,vec2( 0.028417,-0.535309),vec2(-0.008810,-0.523762),vec3(0.792,0.767,0.563),vec3(0.055,0.041,0.057));\n  sdLine(dis_col,pos,vec2( 0.049655,-0.559962),vec2( 0.028517,-0.535386),vec3(0.798,0.782,0.580),vec3(0.076,0.065,0.073));\n  sdLine(dis_col,pos,vec2( 0.071714,-0.659300),vec2( 0.049649,-0.559687),vec3(0.771,0.751,0.557),vec3(0.082,0.073,0.080));\n  sdLine(dis_col,pos,vec2( 0.062107,-0.673453),vec2( 0.072068,-0.659420),vec3(0.731,0.704,0.520),vec3(0.088,0.080,0.088));\n  sdLine(dis_col,pos,vec2(-0.019664,-0.695497),vec2( 0.061596,-0.673865),vec3(0.722,0.694,0.514),vec3(0.090,0.082,0.090),vec3(0.722,0.690,0.502),vec3(0.220,0.216,0.180));\n  sdLine(dis_col,pos,vec2(-0.103143,-0.577233),vec2(-0.113704,-0.546335),vec3(0.078,0.063,0.094),vec3(0.669,0.586,0.406));\n  sdLine(dis_col,pos,vec2(-0.128872,-0.656514),vec2(-0.102680,-0.578043),vec3(0.078,0.063,0.094),vec3(0.643,0.573,0.396),vec3(0.078,0.063,0.094),vec3(0.545,0.506,0.349));\n  sdLine(dis_col,pos,vec2(-0.110341,-0.684318),vec2(-0.132708,-0.656415),vec3(0.090,0.076,0.129),vec3(0.712,0.680,0.494));\n  sdLine(dis_col,pos,vec2(-0.065097,-0.698489),vec2(-0.110606,-0.684138),vec3(0.106,0.094,0.133),vec3(0.712,0.680,0.494));\n  sdLine(dis_col,pos,vec2(-0.023516,-0.695404),vec2(-0.065017,-0.698593),vec3(0.124,0.112,0.137),vec3(0.718,0.686,0.498));\n  sdLine(dis_col,pos,vec2(-0.356409,-0.396602),vec2(-0.363344,-0.417840),vec3(0.667,0.684,0.514),vec3(0.086,0.073,0.102));\n  sdLine(dis_col,pos,vec2(-0.329514,-0.372734),vec2(-0.356301,-0.396902),vec3(0.678,0.694,0.525),vec3(0.098,0.086,0.110),vec3(0.796,0.792,0.624),vec3(0.075,0.059,0.094));\n  sdLine(dis_col,pos,vec2(-0.304495,-0.384405),vec2(-0.329372,-0.372760),vec3(0.794,0.786,0.625),vec3(0.073,0.055,0.094));\n  sdLine(dis_col,pos,vec2(-0.304686,-0.445287),vec2(-0.304686,-0.384176),vec3(0.792,0.780,0.627),vec3(0.071,0.051,0.094),vec3(0.678,0.667,0.541),vec3(0.071,0.047,0.094));\n  sdLine(dis_col,pos,vec2(-0.329703,-0.471680),vec2(-0.304762,-0.445327),vec3(0.678,0.667,0.541),vec3(0.071,0.047,0.094),vec3(0.533,0.522,0.427),vec3(0.071,0.051,0.094));\n  sdLine(dis_col,pos,vec2(-0.352235,-0.461623),vec2(-0.329757,-0.471344),vec3(0.504,0.494,0.406),vec3(0.071,0.051,0.094));\n  sdLine(dis_col,pos,vec2(-0.363307,-0.418071),vec2(-0.352136,-0.462043),vec3(0.475,0.467,0.384),vec3(0.071,0.051,0.094),vec3(0.561,0.565,0.439),vec3(0.129,0.118,0.137));\n  sdLine(dis_col,pos,vec2(-0.276110,-0.521710),vec2(-0.289045,-0.550497),vec3(0.641,0.637,0.478),vec3(0.035,0.033,0.063));\n  sdLine(dis_col,pos,vec2(-0.258075,-0.516729),vec2(-0.275890,-0.521970),vec3(0.684,0.682,0.514),vec3(0.047,0.045,0.075));\n  sdLine(dis_col,pos,vec2(-0.206378,-0.541564),vec2(-0.258683,-0.516738),vec3(0.706,0.706,0.529),vec3(0.047,0.047,0.078),vec3(0.792,0.788,0.600),vec3(0.051,0.055,0.063));\n  sdLine(dis_col,pos,vec2(-0.187895,-0.563812),vec2(-0.206382,-0.541493),vec3(0.757,0.753,0.576),vec3(0.063,0.057,0.078));\n  sdLine(dis_col,pos,vec2(-0.189739,-0.573083),vec2(-0.187133,-0.563528),vec3(0.735,0.731,0.561),vec3(0.075,0.059,0.094));\n  sdLine(dis_col,pos,vec2(-0.251815,-0.589992),vec2(-0.189995,-0.573544),vec3(0.749,0.745,0.569),vec3(0.075,0.059,0.094),vec3(0.498,0.502,0.345),vec3(0.075,0.063,0.098));\n  sdLine(dis_col,pos,vec2(-0.272446,-0.579505),vec2(-0.251715,-0.590033),vec3(0.514,0.518,0.363),vec3(0.075,0.063,0.098));\n  sdLine(dis_col,pos,vec2(-0.289115,-0.550792),vec2(-0.272717,-0.579388),vec3(0.549,0.551,0.398),vec3(0.086,0.075,0.106));\n  sdLine(dis_col,pos,vec2(-0.192736,-0.469520),vec2(-0.277483,-0.347082),vec3(0.108,0.076,0.120),vec3(0.065,0.057,0.090));\n  sdLine(dis_col,pos,vec2(-0.113128,-0.547007),vec2(-0.192449,-0.470244),vec3(0.080,0.045,0.080),vec3(0.063,0.047,0.073));\n  sdLine(dis_col,pos,vec2(-0.399689,-0.363777),vec2(-0.390465,-0.273580),vec3(0.355,0.292,0.675),vec3(0.088,0.075,0.112));\n  sdLine(dis_col,pos,vec2(-0.414173,-0.390763),vec2(-0.399958,-0.363772),vec3(0.347,0.288,0.651),vec3(0.090,0.075,0.110));\n  sdLine(dis_col,pos,vec2( 0.402104,-0.164371),vec2( 0.429754,-0.097640),vec3(0.237,0.182,0.180),vec3(0.784,0.296,0.143));\n  sdLine(dis_col,pos,vec2( 0.366996,-0.206976),vec2( 0.401848,-0.164337),vec3(0.210,0.145,0.145),vec3(0.778,0.304,0.147));\n  sdLine(dis_col,pos,vec2( 0.296913,-0.238165),vec2( 0.367225,-0.206912),vec3(0.194,0.118,0.120),vec3(0.743,0.304,0.149));\n  sdLine(dis_col,pos,vec2( 0.167900,-0.203204),vec2( 0.113213,-0.128975),vec3(0.706,0.690,0.678),vec3(0.145,0.110,0.157));\n  sdLine(dis_col,pos,vec2( 0.454448,-0.085567),vec2( 0.429490,-0.097974),vec3(0.898,0.478,0.357),vec3(0.945,0.643,0.580));\n  sdLine(dis_col,pos,vec2( 0.501070,-0.040927),vec2( 0.454701,-0.085293),vec3(0.898,0.475,0.349),vec3(0.941,0.631,0.561),vec3(0.902,0.439,0.278),vec3(0.910,0.525,0.416));\n  sdLine(dis_col,pos,vec2( 0.536751, 0.019080),vec2( 0.501035,-0.040870),vec3(0.904,0.425,0.247),vec3(0.902,0.502,0.384));\n  sdLine(dis_col,pos,vec2( 0.554739, 0.081950),vec2( 0.536789, 0.018991),vec3(0.906,0.412,0.216),vec3(0.900,0.508,0.390));\n  sdLine(dis_col,pos,vec2( 0.535861, 0.166934),vec2( 0.554677, 0.082064),vec3(0.906,0.412,0.216),vec3(0.906,0.537,0.427),vec3(0.906,0.416,0.224),vec3(0.925,0.647,0.557));\n  sdLine(dis_col,pos,vec2( 0.419826, 0.338301),vec2( 0.535615, 0.166647),vec3(0.906,0.414,0.220),vec3(0.920,0.614,0.524));\n  sdLine(dis_col,pos,vec2( 0.406078, 0.390921),vec2( 0.419883, 0.338831),vec3(0.906,0.412,0.216),vec3(0.910,0.565,0.473));\n  sdLine(dis_col,pos,vec2( 0.146477, 0.567224),vec2( 0.031189, 0.523314),vec3(0.863,0.475,0.404),vec3(0.963,0.447,0.278));\n  sdLine(dis_col,pos,vec2( 0.238636, 0.574102),vec2( 0.146891, 0.567233),vec3(0.869,0.484,0.425),vec3(0.957,0.427,0.241));\n  sdLine(dis_col,pos,vec2( 0.276654, 0.562718),vec2( 0.238421, 0.574198),vec3(0.876,0.496,0.445),vec3(0.949,0.400,0.192));\n  sdLine(dis_col,pos,vec2( 0.328054, 0.527362),vec2( 0.276439, 0.562762),vec3(0.880,0.508,0.463),vec3(0.939,0.382,0.165));\n  sdLine(dis_col,pos,vec2( 0.407058, 0.213498),vec2( 0.371072, 0.195345),vec3(0.988,0.973,0.969),vec3(0.992,0.855,0.831));\n  sdLine(dis_col,pos,vec2( 0.458303, 0.213407),vec2( 0.407282, 0.213566),vec3(0.988,0.973,0.969),vec3(0.992,0.855,0.831));\n  sdLine(dis_col,pos,vec2( 0.481278, 0.196816),vec2( 0.457990, 0.213665),vec3(0.988,0.973,0.967),vec3(0.992,0.855,0.829));\n  sdLine(dis_col,pos,vec2( 0.499009, 0.163011),vec2( 0.481392, 0.196333),vec3(0.988,0.973,0.965),vec3(0.992,0.855,0.827));\n  sdLine(dis_col,pos,vec2( 0.503604, 0.090461),vec2( 0.499073, 0.163192),vec3(0.988,0.971,0.965),vec3(0.990,0.855,0.827));\n  sdLine(dis_col,pos,vec2( 0.489446, 0.076448),vec2( 0.503554, 0.090238),vec3(0.988,0.969,0.963),vec3(0.986,0.847,0.816));\n  sdLine(dis_col,pos,vec2( 0.443782, 0.062339),vec2( 0.489220, 0.076528),vec3(0.986,0.969,0.961),vec3(0.986,0.845,0.814));\n  sdLine(dis_col,pos,vec2( 0.378683, 0.066466),vec2( 0.443770, 0.062469),vec3(0.984,0.969,0.959),vec3(0.988,0.851,0.822));\n  sdLine(dis_col,pos,vec2( 0.339578, 0.097522),vec2( 0.378706, 0.066500),vec3(0.984,0.967,0.957),vec3(0.986,0.851,0.820));\n  sdLine(dis_col,pos,vec2( 0.329906, 0.140698),vec2( 0.339788, 0.097651),vec3(0.984,0.965,0.955),vec3(0.984,0.851,0.818));\n  sdLine(dis_col,pos,vec2( 0.349815, 0.180720),vec2( 0.329907, 0.140407),vec3(0.984,0.965,0.953),vec3(0.982,0.849,0.814));\n  sdLine(dis_col,pos,vec2( 0.371027, 0.195457),vec2( 0.349730, 0.180934),vec3(0.984,0.965,0.953),vec3(0.982,0.849,0.814));\n  sdLine(dis_col,pos,vec2(-0.117425, 0.341220),vec2(-0.074257, 0.417986),vec3(0.847,0.318,0.216),vec3(0.794,0.425,0.357));\n  sdLine(dis_col,pos,vec2(-0.131058, 0.286069),vec2(-0.117280, 0.341245),vec3(0.847,0.318,0.216),vec3(0.814,0.429,0.355));\n  sdLine(dis_col,pos,vec2(-0.120979, 0.239269),vec2(-0.131229, 0.286301),vec3(0.847,0.318,0.216),vec3(0.831,0.435,0.355));\n  sdLine(dis_col,pos,vec2(-0.094915, 0.195662),vec2(-0.120748, 0.238869),vec3(0.853,0.308,0.194),vec3(0.847,0.439,0.355));\n  sdLine(dis_col,pos,vec2(-0.058454, 0.163892),vec2(-0.094941, 0.195621),vec3(0.861,0.296,0.171),vec3(0.861,0.439,0.351));\n  sdLine(dis_col,pos,vec2( 0.096154, 0.101755),vec2(-0.058568, 0.164000),vec3(0.855,0.304,0.188),vec3(0.884,0.443,0.349));\n  sdLine(dis_col,pos,vec2( 0.148627, 0.066296),vec2( 0.096309, 0.101713),vec3(0.845,0.316,0.214),vec3(0.906,0.447,0.349));\n  sdLine(dis_col,pos,vec2( 0.238337,-0.218583),vec2( 0.296931,-0.238114),vec3(0.188,0.059,0.055),vec3(0.941,0.714,0.384));\n  sdLine(dis_col,pos,vec2( 0.356732, 0.495659),vec2( 0.328217, 0.527093),vec3(0.475,0.510,0.604),vec3(0.418,0.445,0.533));\n  sdLine(dis_col,pos,vec2( 0.406416, 0.390930),vec2( 0.356795, 0.496206),vec3(0.475,0.510,0.604),vec3(0.398,0.414,0.496));\n  sdLine(dis_col,pos,vec2( 0.351847, 0.563942),vec2( 0.328272, 0.527247),vec3(0.439,0.475,0.569),vec3(0.725,0.459,0.408),vec3(0.443,0.475,0.569),vec3(0.882,0.420,0.259));\n  sdLine(dis_col,pos,vec2( 0.386954, 0.567493),vec2( 0.352309, 0.564131),vec3(0.431,0.453,0.537),vec3(0.884,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.434360, 0.555848),vec2( 0.386390, 0.567397),vec3(0.420,0.431,0.506),vec3(0.886,0.412,0.235),vec3(0.361,0.341,0.396),vec3(0.882,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.481493, 0.527439),vec2( 0.434614, 0.555661),vec3(0.376,0.353,0.406),vec3(0.882,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.556668, 0.460958),vec2( 0.481472, 0.527483),vec3(0.392,0.365,0.416),vec3(0.882,0.416,0.247),vec3(0.522,0.502,0.557),vec3(0.882,0.412,0.247));\n  sdLine(dis_col,pos,vec2( 0.568077, 0.433950),vec2( 0.556441, 0.461051),vec3(0.524,0.506,0.563),vec3(0.880,0.414,0.247));\n  sdLine(dis_col,pos,vec2( 0.550912, 0.394412),vec2( 0.568131, 0.433870),vec3(0.494,0.480,0.541),vec3(0.880,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.490768, 0.382274),vec2( 0.550937, 0.394469),vec3(0.422,0.425,0.496),vec3(0.882,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.406039, 0.390810),vec2( 0.490402, 0.382519),vec3(0.375,0.382,0.457),vec3(0.882,0.418,0.253));\n  sdLine(dis_col,pos,vec2( 0.330744, 0.478846),vec2( 0.328238, 0.527133),vec3(0.908,0.586,0.498),vec3(0.475,0.510,0.604));\n  sdLine(dis_col,pos,vec2( 0.365538, 0.422127),vec2( 0.330688, 0.479010),vec3(0.910,0.588,0.498),vec3(0.475,0.510,0.604));\n  sdLine(dis_col,pos,vec2( 0.406309, 0.390576),vec2( 0.365537, 0.422123),vec3(0.910,0.588,0.498),vec3(0.475,0.502,0.592));\n  sdLine(dis_col,pos,vec2( 0.037170, 0.502175),vec2( 0.031325, 0.523294),vec3(0.357,0.220,0.255),vec3(0.725,0.404,0.349),vec3(0.357,0.220,0.255),vec3(0.914,0.506,0.408));\n  sdLine(dis_col,pos,vec2( 0.009112, 0.456598),vec2( 0.036991, 0.502416),vec3(0.357,0.220,0.255),vec3(0.900,0.484,0.404));\n  sdLine(dis_col,pos,vec2(-0.014264, 0.437994),vec2( 0.009264, 0.456398),vec3(0.357,0.220,0.255),vec3(0.882,0.457,0.398));\n  sdLine(dis_col,pos,vec2(-0.074384, 0.418060),vec2(-0.014479, 0.438192),vec3(0.357,0.220,0.255),vec3(0.873,0.443,0.394));\n  sdLine(dis_col,pos,vec2(-0.034865, 0.469095),vec2(-0.074326, 0.418051),vec3(0.357,0.220,0.255),vec3(0.325,0.153,0.310));\n  sdLine(dis_col,pos,vec2( 0.031160, 0.519567),vec2(-0.034850, 0.469051),vec3(0.357,0.220,0.255),vec3(0.312,0.147,0.269));\n  sdLine(dis_col,pos,vec2(-0.476788,-0.270699),vec2(-0.413803,-0.390958),vec3(0.400,0.333,0.724),vec3(0.529,0.406,0.447));\n  sdLine(dis_col,pos,vec2(-0.515771,-0.226315),vec2(-0.477190,-0.270110),vec3(0.439,0.367,0.784),vec3(0.571,0.437,0.476));\n  sdLine(dis_col,pos,vec2(-0.548925,-0.216192),vec2(-0.515512,-0.226748),vec3(0.475,0.408,0.808),vec3(0.588,0.451,0.490),vec3(0.580,0.529,0.878),vec3(0.404,0.282,0.416));\n  sdLine(dis_col,pos,vec2(-0.563920,-0.221379),vec2(-0.548931,-0.216115),vec3(0.580,0.529,0.878),vec3(0.404,0.282,0.416),vec3(0.671,0.635,0.937),vec3(0.533,0.455,0.702));\n  sdLine(dis_col,pos,vec2(-0.487346,-0.300005),vec2(-0.564121,-0.221089),vec3(0.671,0.635,0.937),vec3(0.533,0.455,0.702),vec3(0.502,0.459,0.749),vec3(0.522,0.392,0.561));\n  sdLine(dis_col,pos,vec2(-0.456709,-0.351242),vec2(-0.487322,-0.300058),vec3(0.502,0.459,0.749),vec3(0.522,0.392,0.561),vec3(0.396,0.349,0.639),vec3(0.412,0.290,0.471));\n  sdLine(dis_col,pos,vec2(-0.437438,-0.426111),vec2(-0.456570,-0.351699),vec3(0.396,0.349,0.639),vec3(0.412,0.290,0.471),vec3(0.294,0.243,0.537),vec3(0.553,0.475,0.596));\n  sdLine(dis_col,pos,vec2(-0.426103,-0.437341),vec2(-0.437819,-0.425625),vec3(0.294,0.243,0.537),vec3(0.553,0.475,0.596),vec3(0.380,0.345,0.600),vec3(0.659,0.600,0.761));\n  sdLine(dis_col,pos,vec2(-0.137942,-0.735671),vec2(-0.234693,-0.652174),vec3(0.390,0.329,0.331),vec3(0.078,0.075,0.145));\n  sdLine(dis_col,pos,vec2(-0.101453,-0.787596),vec2(-0.137531,-0.736006),vec3(0.376,0.318,0.302),vec3(0.067,0.067,0.141),vec3(0.729,0.698,0.671),vec3(0.051,0.055,0.137));\n  sdLine(dis_col,pos,vec2(-0.093467,-0.816814),vec2(-0.101262,-0.787835),vec3(0.729,0.698,0.671),vec3(0.051,0.055,0.137),vec3(0.592,0.549,0.522),vec3(0.059,0.059,0.141));\n  sdLine(dis_col,pos,vec2(-0.101072,-0.835520),vec2(-0.094078,-0.816636),vec3(0.592,0.549,0.522),vec3(0.059,0.059,0.141),vec3(0.427,0.369,0.341),vec3(0.067,0.067,0.145));\n  sdLine(dis_col,pos,vec2(-0.120105,-0.842187),vec2(-0.100815,-0.835333),vec3(0.427,0.369,0.341),vec3(0.067,0.067,0.145),vec3(0.541,0.467,0.439),vec3(0.129,0.129,0.192));\n  sdLine(dis_col,pos,vec2(-0.139116,-0.832593),vec2(-0.120099,-0.842135),vec3(0.541,0.467,0.439),vec3(0.129,0.129,0.192),vec3(0.651,0.561,0.541),vec3(0.220,0.212,0.298));\n  sdLine(dis_col,pos,vec2(-0.182775,-0.748898),vec2(-0.139277,-0.832422),vec3(0.651,0.561,0.541),vec3(0.220,0.212,0.298),vec3(0.176,0.090,0.090),vec3(0.329,0.290,0.529));\n  sdLine(dis_col,pos,vec2(-0.242482,-0.691315),vec2(-0.182860,-0.748982),vec3(0.176,0.090,0.090),vec3(0.329,0.290,0.529),vec3(0.376,0.247,0.227),vec3(0.247,0.212,0.412));\n  sdLine(dis_col,pos,vec2(-0.376186,-0.507215),vec2(-0.414107,-0.390583),vec3(0.341,0.347,0.365),vec3(0.071,0.061,0.108));\n  sdLine(dis_col,pos,vec2(-0.334872,-0.560660),vec2(-0.375961,-0.507315),vec3(0.347,0.353,0.337),vec3(0.061,0.051,0.096));\n  sdLine(dis_col,pos,vec2(-0.234322,-0.652779),vec2(-0.334981,-0.561046),vec3(0.333,0.337,0.322),vec3(0.059,0.047,0.090),vec3(0.251,0.251,0.255),vec3(0.067,0.063,0.098));\n  sdLine(dis_col,pos,vec2(-0.443668,-0.478495),vec2(-0.425835,-0.437392),vec3(0.365,0.322,0.592),vec3(0.392,0.392,0.510),vec3(0.353,0.310,0.580),vec3(0.235,0.227,0.365));\n  sdLine(dis_col,pos,vec2(-0.439128,-0.529675),vec2(-0.443433,-0.478735),vec3(0.353,0.310,0.580),vec3(0.235,0.227,0.365),vec3(0.282,0.275,0.471),vec3(0.110,0.106,0.200));\n  sdLine(dis_col,pos,vec2(-0.375449,-0.627070),vec2(-0.439486,-0.529481),vec3(0.282,0.275,0.471),vec3(0.110,0.106,0.200),vec3(0.361,0.314,0.592),vec3(0.110,0.102,0.133));\n  sdLine(dis_col,pos,vec2(-0.332113,-0.645086),vec2(-0.375323,-0.626910),vec3(0.361,0.314,0.592),vec3(0.131,0.122,0.145));\n  sdLine(dis_col,pos,vec2(-0.265559,-0.648265),vec2(-0.332002,-0.645122),vec3(0.361,0.314,0.592),vec3(0.165,0.153,0.165));\n  sdLine(dis_col,pos,vec2( 0.205231,-0.817938),vec2( 0.109033,-0.765411),vec3(0.429,0.459,0.576),vec3(0.820,0.737,0.624));\n  sdLine(dis_col,pos,vec2( 0.293818,-0.895384),vec2( 0.205808,-0.818524),vec3(0.447,0.478,0.592),vec3(0.820,0.737,0.624),vec3(0.529,0.557,0.659),vec3(0.820,0.737,0.624));\n  sdLine(dis_col,pos,vec2( 0.354093,-0.996256),vec2( 0.293952,-0.895611),vec3(0.529,0.557,0.659),vec3(0.820,0.737,0.624),vec3(0.612,0.635,0.722),vec3(0.820,0.737,0.624));\n  sdLine(dis_col,pos,vec2( 0.367427,-1.054936),vec2( 0.353965,-0.995872),vec3(0.612,0.635,0.722),vec3(0.820,0.737,0.624),vec3(0.725,0.690,0.663),vec3(0.816,0.737,0.624));\n  sdLine(dis_col,pos,vec2(-0.954948,-0.473706),vec2(-0.984357,-0.410454),vec3(0.161,0.147,0.363),vec3(0.398,0.363,0.714));\n  sdLine(dis_col,pos,vec2(-0.903811,-0.638807),vec2(-0.954931,-0.473614),vec3(0.153,0.141,0.349),vec3(0.404,0.369,0.718),vec3(0.067,0.063,0.188),vec3(0.420,0.392,0.722));\n  sdLine(dis_col,pos,vec2(-0.875055,-0.699107),vec2(-0.903928,-0.638463),vec3(0.073,0.069,0.202),vec3(0.408,0.380,0.702));\n  sdLine(dis_col,pos,vec2(-0.629447,-0.956558),vec2(-0.687403,-0.870736),vec3(0.029,0.029,0.135),vec3(0.120,0.114,0.286));\n  sdLine(dis_col,pos,vec2(-0.605535,-1.023209),vec2(-0.629620,-0.956694),vec3(0.029,0.029,0.125),vec3(0.096,0.096,0.247));\n  sdLine(dis_col,pos,vec2(-0.265320,-0.663013),vec2(-0.242156,-0.691406),vec3(0.216,0.129,0.125),vec3(0.361,0.310,0.592),vec3(0.325,0.267,0.251),vec3(0.361,0.310,0.592));\n  sdLine(dis_col,pos,vec2(-0.265459,-0.648465),vec2(-0.265186,-0.663040),vec3(0.355,0.298,0.288),vec3(0.355,0.306,0.580));\n  sdLine(dis_col,pos,vec2(-0.630864,-0.893412),vec2(-0.687487,-0.870996),vec3(0.125,0.112,0.275),vec3(0.259,0.253,0.482));\n  sdLine(dis_col,pos,vec2(-0.586520,-0.885655),vec2(-0.630843,-0.893310),vec3(0.108,0.092,0.233),vec3(0.208,0.206,0.418));\n  sdLine(dis_col,pos,vec2(-0.487897,-0.819075),vec2(-0.586679,-0.885778),vec3(0.104,0.088,0.218),vec3(0.176,0.176,0.375));\n  sdLine(dis_col,pos,vec2(-0.300556,-0.770950),vec2(-0.487735,-0.819175),vec3(0.098,0.082,0.188),vec3(0.188,0.182,0.373));\n  sdLine(dis_col,pos,vec2(-0.274553,-0.751048),vec2(-0.300678,-0.771091),vec3(0.094,0.078,0.163),vec3(0.202,0.188,0.363));\n  sdLine(dis_col,pos,vec2(-0.242248,-0.691634),vec2(-0.274548,-0.751130),vec3(0.090,0.075,0.147),vec3(0.216,0.196,0.359));\n  sdLine(dis_col,pos,vec2(-0.800847,-0.800581),vec2(-0.875072,-0.699008),vec3(0.069,0.057,0.225),vec3(0.351,0.331,0.616));\n  sdLine(dis_col,pos,vec2(-0.687515,-0.871181),vec2(-0.800804,-0.800859),vec3(0.055,0.049,0.192),vec3(0.331,0.316,0.584));\n  sdLine(dis_col,pos,vec2(-0.727078, 0.837400),vec2(-0.792967, 0.812525),vec3(0.851,0.773,0.682),vec3(0.453,0.390,0.737));\n  sdLine(dis_col,pos,vec2(-0.657094, 0.890944),vec2(-0.727080, 0.837365),vec3(0.859,0.780,0.682),vec3(0.475,0.412,0.759));\n  sdLine(dis_col,pos,vec2(-0.603768, 0.961718),vec2(-0.657083, 0.890933),vec3(0.857,0.780,0.682),vec3(0.508,0.445,0.794));\n  sdLine(dis_col,pos,vec2(-0.589831, 0.999997),vec2(-0.603747, 0.961733),vec3(0.857,0.780,0.682),vec3(0.527,0.467,0.816));\n  sdLine(dis_col,pos,vec2(-0.902586, 0.451620),vec2(-0.836020, 0.550739),vec3(0.569,0.553,0.867),vec3(0.618,0.624,0.949));\n  sdLine(dis_col,pos,vec2(-0.958157, 0.411244),vec2(-0.902331, 0.451519),vec3(0.506,0.494,0.859),vec3(0.637,0.647,0.957));\n  sdLine(dis_col,pos,vec2(-0.988291, 0.406328),vec2(-0.958317, 0.411469),vec3(0.465,0.453,0.851),vec3(0.649,0.663,0.961));\n  sdLine(dis_col,pos,vec2(-0.790561, 0.737649),vec2(-0.792976, 0.808576),vec3(0.722,0.694,0.898),vec3(0.859,0.788,0.661));\n  sdLine(dis_col,pos,vec2(-0.835941, 0.550741),vec2(-0.790568, 0.737610),vec3(0.708,0.680,0.892),vec3(0.849,0.778,0.680));\n  sdLine(dis_col,pos,vec2( 0.124987,-0.012010),vec2( 0.128540,-0.077336),vec3(0.153,0.094,0.125),vec3(0.980,0.929,0.725),vec3(0.082,0.039,0.075),vec3(0.773,0.251,0.153));\n\n  return dis_col;\n}\n\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n// --------------------------------------\n\nvec2 randomInCircle( void )\n{\n    float an = 6.283185*float(rand())/32767.0;\n    return vec2(cos(an),sin(an));\n}\n\n// WoS\nvec3 march( in vec2 p )\n{\n    vec4 h = vec4(0.0);\n\tfor( int i=0; i<24; i++ )\n    {\n        h = map(p);\n        if( h.x<0.001 ) break;\n        p = p + h.x*randomInCircle();\n    }\n    return h.yzw;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init randoms\n    srand( ivec2(fragCoord), iFrame );\n    \n\t// coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n#if 1\n    // solve\n    vec3 col = march(p);\n#else\n    // display SDF (reset shader after enabling this)\n    vec4 dist_col = map(p);\n    vec3 col = dist_col.yzw*smoothstep(0.01,0.0,abs(dist_col.x));\n#endif\n    \n    // montecarlo\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 460, 460, 565]], "test": "untested"}
{"id": "WsXBzl", "name": "Montecarlo PDE (1)", "author": "iq", "description": "Playing with [url]http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]. See [url]https://www.shadertoy.com/view/WdXfzl[/url] for a more advanced example", "tags": ["2d", "montecarlo", "pde"], "likes": 68, "viewed": 8185, "published": 3, "date": "1588817386", "time_retrieved": "2024-07-30T21:08:27.814997", "image_code": "// Playing with Keenan Crane's latest paper in collab with\n// Rohan Sawhney: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]\n//\n// See https://www.shadertoy.com/view/WdXfzl for a more complex example\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = vec4(data.xyz/data.w, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Playing with Keenan Crane's latest paper in collab with\n// Rohan Sawhney\n//\n// http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]\n//\n\n// https://iquilezles.org/articles/distfunctions\nvec4 sdLine( in vec2 p, in vec2 a, in vec2 b, in vec3 ca, in vec3 cb )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    float s = step(0.0,pa.x*ba.y-pa.y*ba.x);\n    return vec4(d, mix(ca,cb,s)*smoothstep(-0.1,0.1,sin(50.0*h)) );\n}\n\n// sdf map\nvec4 map( in vec2 p )\n{\n    vec4 d  = sdLine(p, vec2(-1.0,0.4), vec2(1.1,-0.1), vec3(1.0,0.4,0.1),vec3(0.2,0.5,0.8) )-0.05;\n    vec4 d2 = sdLine(p, vec2(-0.3,0.8), vec2(0.2,-0.6), vec3(1.0,1.0,0.2), vec3(0.1,0.7,0.3) )-0.05;\n    if( d2.x<d.x ) d = d2;\n    \n    return d;\n}\n\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n// --------------------------------------\n\nvec2 randomInCircle( void )\n{\n    float an = 6.283185*float(rand())/32767.0;\n    return vec2(cos(an),sin(an));\n}\n    \n// WoS\nvec3 march( in vec2 p )\n{\n    vec4 h=vec4(0.0);\n\tfor( int i=0; i<32; i++ )\n    {\n        h = map(p);\n        if( h.x<0.001 ) break;\n        p = p + h.x*randomInCircle();\n    }\n    return h.yzw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init randoms\n    srand( ivec2(fragCoord), iFrame );\n\n    // solve\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = march(p);\n\n    // display map()\n    #if 0\n    vec4 dcol = map(p);\n    float f = 1.0-smoothstep(0.0,0.01,dcol.x);\n    col = mix(col,dcol.yzw,f);\n    col *= smoothstep(0.0,0.01,abs(dcol.x));\n    #endif\n\n    // montecarlo\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 295, 295, 400]], "test": "untested"}
{"id": "tdsfzf", "name": "Day 139 - DFT", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 5, "viewed": 391, "published": 3, "date": "1588801109", "time_retrieved": "2024-07-30T21:08:28.783408", "image_code": "// This is a DFT with some distortion and colouring\n\n#define tau 6.28\n\nfloat af(float i){return sin(i*(400.+sin(iTime)));}\n//float f(float i){return fract(i*(400.+sin(iTime)));}\nvec4 f(vec2 i){return texture(iChannel0,vec2(i));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float iters = 47.;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y*iters;\n    \n    vec3 col = vec3(0);\n    \n    vec2 p = vec2(0);\n    \n    for(float x = 0.; x < iters; x++){\n        for(float y = 0.; y < iters; y++){\n            float coord = tau*(uv.x*x+uv.y*y)/iters;\n            float fn = f(vec2(x,y)/iters).y;\n            p+=vec2(cos(coord),sin(coord+1.))*fn;\n        }\n    }\n    \n    \n    // coloring\n    col += 0.5+sin(vec3(4,1,1)+5.*length(p)/iters)+ length(p)/iters;\n    col *= length(p)/iters;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 89, 89, 122], [123, 178, 193, 193, 228], [231, 231, 288, 288, 845]], "test": "untested"}
{"id": "tdsBzf", "name": "Iridescent Waves", "author": "jarble", "description": "Based on [url=https://www.shadertoy.com/view/tdsBRf]this shader[/url]", "tags": ["fractal", "waves"], "likes": 3, "viewed": 439, "published": 3, "date": "1588798884", "time_retrieved": "2024-07-30T21:08:29.589253", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = (uv*50.0);\n    for(float i = 1.0; i <5.0; i++){\n        uv += col;\n        col = cos(uv.yx*(i+sin((uv.y-uv.x)/10.0+iTime)));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 388]], "test": "untested"}
{"id": "wdlBzf", "name": "Procedural water texture", "author": "jarble", "description": "A simple procedural texture, based on [url=https://www.shadertoy.com/view/tdsBRf]this shader[/url].\nThis one isn't very good: I was trying to do a tileable caustic like [url=https://www.shadertoy.com/view/MdlXz8]this one[/url].", "tags": ["procedural", "texture", "water"], "likes": 1, "viewed": 417, "published": 3, "date": "1588798148", "time_retrieved": "2024-07-30T21:08:30.510789", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = (uv*20.0);\n    for(float i = 1.0; i <4.0; i++){\n        uv += col;\n        col = cos(uv.yx*i+iTime);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 364]], "test": "untested"}
{"id": "tdsBRf", "name": "Fractal animation 3", "author": "jarble", "description": "This is another simple fractal animation, based on [url=https://www.shadertoy.com/view/wdffRf]this shader[/url].", "tags": ["fractal"], "likes": 1, "viewed": 352, "published": 3, "date": "1588795063", "time_retrieved": "2024-07-30T21:08:31.266768", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = (uv*10.0);\n    for(float i = 1.0; i <6.0; i++){\n        uv += col;\n        col = cos(uv.yx*i+iTime);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 364]], "test": "untested"}
{"id": "wslBRf", "name": "Flickering plaid", "author": "jarble", "description": "I modifed one of my fractals to make this \"plaid\" animation.", "tags": ["plaid"], "likes": 0, "viewed": 285, "published": 3, "date": "1588794958", "time_retrieved": "2024-07-30T21:08:32.015766", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = (uv.yx*10.0);\n    for(float i = 1.0; i <5.0; i++){\n        uv += col.yx;\n        col.xy = cos(uv.yx*i+iTime);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 373]], "test": "untested"}
{"id": "wslBzX", "name": "Melting Webcam 2", "author": "tomachi", "description": "Smoothly melting screen.", "tags": ["webcam"], "likes": 1, "viewed": 427, "published": 3, "date": "1588786042", "time_retrieved": "2024-07-30T21:08:32.795680", "image_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define melting(g) texture(iChannel1, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define brightness 1.0001\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \t\n    vec2 xy = fragCoord;\n    vec4 webcam = camchan(xy);\n    vec4 melt = melting(xy);\n    vec4 herbivore = tex(xy);\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    \n  // fragColor = herbivore + (webcam * vec4(r, g, b, 1.)) + vec4(r*brightness, g*brightness, b*brightness, 1.); //  * vec4(1.0);\n\tfragColor = melt + webcam + sin(tex(fragCoord).w * vec4(20.,19.9,19.0,19.0));\n\t//fragColor = melt - webcam + tex(fragCoord).w;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define brightness 3.99\n#define count 20\n#define radius 0.943\n#define emitSize 0.950\n#define force 0.99\n#define constraint 0.91\n#define effect 0.99\n#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n\n// v => coord x,y / s => dir\n\n// v => coord x,y / d => diam\n// https://github.com/aiekick/NoodlesPlate/blob/master/fluid.glsl\n//NoodlesPlate widgets\n//uniform(hidden) \tint\t\t\t(frame) \t\t\t\t\t\tuFrame;\n//uniform(hidden) \tfloat\t\t(deltatime) \t\t\t\t\tuDeltaTime;\n//uniform(hidden) \tsampler2D\t(buffer:0) \t\t\t\t\t\tbuffer;\n//uniform(hidden) \tsampler2D\t(buffer:1) \t\t\t\t\t\tbuffer1;\n//uniform(hidden) \tvec2\t\t(buffer:0) \t\t\t\t\t\tsize;\n//uniform(color) \tvec3\t\t(0:10:7.7,6.0,7.5) \t\t\t\tcolor;\n//uniform(physic) \tfloat\t\t(0.0:1.0:0.1) \t\t\t\t\tforce;\n//uniform(prism) \tfloat\t\t(0.00001:0.1:0.01) \t\t\t\tconstraint;\n//uniform(prism) \tfloat\t\t(-1.0:1.0:0.0) \t\t\t\t\teffect;\n//uniform(prism) \tfloat\t\t(0.99:1.0:1.0) \t\t\t\t\tviscosity;\n//uniform(emit) \tfloat\t\t(1.0:20.0:5.0) \t\t\t\t\temitSize;\n//uniform(emit) \tint\t\t\t(0:50:1) \t\t\t\t\t\tcount;\n//uniform(emit) \tfloat\t\t(0.0:0.5:0.3) \t\t\t\t\tradius;\n//uniform(emit) \tfloat\t\t(checkbox:true) \t\t\t\temit;\n//uniform(shape) \tint\t\t\t(combobox:circle,triangle,quad) shapeType;\n\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n    return tri;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // x,y => pos\n\t// z => pressure\n\t// w => ink\n    \n    vec2 xy = fragCoord.xy;\n\tvec4 webcam = camchan(xy);\n\n    vec2 s = iResolution.xy;\n\tvec2 g = fragCoord;\n\t\n\tvec4 a = tex(g+vec2(1,0));// + webcam.r;\n\tvec4 b = tex(g+vec2(0,1));// + webcam.g;\n\tvec4 c = tex(g+vec2(-1,0));// + webcam.b;\n\tvec4 d = tex(g+vec2(0,-1));// + (webcam.r * -0.0125);\n\tfloat lumens = (webcam.r + webcam.g + webcam.b)*0.333;\n\t//fragColor = tex(g-tex(g).xy); // last state\n    vec4 tomachi = vec4(1.0001,1.0002,1.0003,0.0);\n\tfragColor = tex(g-tex(g).xy)* tomachi; // last state\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n\n    if (lumens < 0.95) { \n       \n    } else {\n       \tgp = gp * vec2(0.9,0.9); // pressure gradient\n\n    }\n\n\t//fragColor.xyz = vec3(\n\t//\tfragColor.x + gp.x,\n\t//\tfragColor.y + gp.y,\n\t//\t0.25 * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y));\n    //float magic = 0.25 * (a.z-c.z) * webcam.r;\n    \n    \n        vec4 left = camchan(xy+vec2(1,0)) + tex(xy+vec2(1,0));\n\t\tvec4 right = camchan(xy+vec2(0,1)) + tex(xy+vec2(0,1));\n\t\tvec4 up = camchan(xy+vec2(-1,0)) + tex(xy+vec2(-1,0));\n\t\tvec4 down = camchan(xy+vec2(0,-1))+ tex(xy+vec2(1,0));\n      \tvec2 presh = vec2(left.z-right.z,up.z-down.z); // pressure gradient\n        float magic = 0.249;\n\n    if (presh.x + presh.y < 2.1) {\n        if (lumens > brightness ) {\n          emit(xy,presh * vec2(2.));\n   \t \t}\n       //magic = 0.251;\n    } else {\n       //magic = 0.2651 ;  \n       presh += vec2(-10.91, -10.951);   \n\n    }\n        float pressure = magic * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n\n    if (lumens > 2.2 || webcam.b > 0.5 || pressure < 0.5) {\n               //  emit(xy,presh * vec2(0.000000001));\n\n       \t//\temit(xy,vec2(1.+webcam.r*-0.5, 1. + (webcam.g*-0.5) + (webcam.b*-0.5)));\n        } else {\n         \tpressure *= 0.9;   \n        }\n    \n    \n  \t//emit(xy, 0.005);\n\n    if (d.b > 0.95 && a.r > 0.95)\n    {\n        \t\t\tvec2 p = vec2( webcam.r, webcam.g);\n        \t\t\tvec2 dir = vec2( webcam.g, webcam.b);\n        \t\t\temit(p, dir);\n               \t\t//emit(xy, float (iFrame) * 0.01);\n\n    } else {\n    }\n      \n  \n\n    \n\tfragColor.xyz = vec3(\n\t\tfragColor.x + gp.x,// + webcam.r,\n\t\tfragColor.y + gp.y,// + webcam.r,\n\t\tpressure);// + webcam.r;\n    \n\tif (iFrame < 1) fragColor = vec4(0);\n\tif (g.x < 1. || g.y < 1. || g.x > s.x - 1. || g.y > s.y - 1.) fragColor.xy *= 0.;\n\t\n   \tif (iFrame < 10)\n    {\n\t\tfor (int i=0;i<count;i++)\n\t\t{\n\t\t\tfloat a = 6.28318 * float(i)/float(count);\n\t\t\tvec2 dir = vec2(cos(a),sin(a));\n            s.x -= float( 1 / iFrame );\n\t\t\tvec2 p = s * 0.95 - dir * radius * min(s.x,s.y);\n           \n\t\t}\n\t}\n\n    \n\t// wall\n//\tvec2 p = g - s * 0.015;\n//\tvec2 dim = vec2(s.x * 0.0152);\n//\tif (shape(g-s*0.25*iTime, dim) < 0.1) \n//\t{\n//\t\tfragColor.w = fragColor.z / (shape(fragColor.xy, vec2(constraint)));\n//\t\tfragColor.xy *= effect * (shape(fragColor.xy, vec2(constraint)));\n\t//}\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define webcam(g) texture(iChannel2, (g)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord;\n    vec4 campix = webcam(xy);\n    vec4 particle = tex(xy);\n    // float r, g, b;\n   \tvec4 a = tex(xy+vec2(1,0)) * campix.r; // LEFT\n    vec4 b = tex(xy+vec2(0,1)) + campix.g; // RIGHT\n\tvec4 c = tex(xy+vec2(-1,0)) + campix.b;// UP\n\tvec4 d = tex(xy+vec2(0,-1)) + (campix.r * -0.0125);//DOWN\n    \n    fragColor = campix * vec4(a.r,a.r,a.r,a.r);\n \tfragColor = tex(fragCoord); // last state\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 254, 254, 687]], "test": "untested"}
{"id": "tdjSDy", "name": "Melting Webcam", "author": "tomachi", "description": "A simulation of what it is like on DMT.", "tags": ["life"], "likes": 2, "viewed": 565, "published": 3, "date": "1588783185", "time_retrieved": "2024-07-30T21:08:33.598534", "image_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define melting(g) texture(iChannel1, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define brightness 1.0001\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \t\n    vec2 xy = fragCoord;\n    vec4 webcam = camchan(xy);\n    vec4 melt = melting(xy);\n    vec4 herbivore = tex(xy);\n    float r, g, b, pressure;\n  \tfloat rh, gh, bh;\n    \n  // fragColor = herbivore + (webcam * vec4(r, g, b, 1.)) + vec4(r*brightness, g*brightness, b*brightness, 1.); //  * vec4(1.0);\n\tfragColor =  melt + webcam  + sin(tex(fragCoord).w * vec4(20.,19.9,19.0,19.0));// + (herbivore*0.1);\t//fragColor = melt + webcam + tex(fragCoord).w;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define count 20\n#define radius 0.943\n#define emitSize 0.950\n#define force 0.99\n#define constraint 0.91\n#define effect 0.99\n#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define camchan(g) texture(iChannel2, (g)/iResolution.xy)\n#define wallCircle(v,d) if (length(g-(v)) < (d)) fragColor.w = fragColor.z / (length(fragColor.xy)+0.0001), fragColor.xy *= 0.\n#define emit(v,s) if (length(g-(v)) < emitSize) fragColor.xy = fragColor.xy * (1.0 - force) + force * (s), fragColor.w = 1.0\n\n// v => coord x,y / s => dir\n\n// v => coord x,y / d => diam\n// https://github.com/aiekick/NoodlesPlate/blob/master/fluid.glsl\n//NoodlesPlate widgets\n//uniform(hidden) \tint\t\t\t(frame) \t\t\t\t\t\tuFrame;\n//uniform(hidden) \tfloat\t\t(deltatime) \t\t\t\t\tuDeltaTime;\n//uniform(hidden) \tsampler2D\t(buffer:0) \t\t\t\t\t\tbuffer;\n//uniform(hidden) \tsampler2D\t(buffer:1) \t\t\t\t\t\tbuffer1;\n//uniform(hidden) \tvec2\t\t(buffer:0) \t\t\t\t\t\tsize;\n//uniform(color) \tvec3\t\t(0:10:7.7,6.0,7.5) \t\t\t\tcolor;\n//uniform(physic) \tfloat\t\t(0.0:1.0:0.1) \t\t\t\t\tforce;\n//uniform(prism) \tfloat\t\t(0.00001:0.1:0.01) \t\t\t\tconstraint;\n//uniform(prism) \tfloat\t\t(-1.0:1.0:0.0) \t\t\t\t\teffect;\n//uniform(prism) \tfloat\t\t(0.99:1.0:1.0) \t\t\t\t\tviscosity;\n//uniform(emit) \tfloat\t\t(1.0:20.0:5.0) \t\t\t\t\temitSize;\n//uniform(emit) \tint\t\t\t(0:50:1) \t\t\t\t\t\tcount;\n//uniform(emit) \tfloat\t\t(0.0:0.5:0.3) \t\t\t\t\tradius;\n//uniform(emit) \tfloat\t\t(checkbox:true) \t\t\t\temit;\n//uniform(shape) \tint\t\t\t(combobox:circle,triangle,quad) shapeType;\n\nfloat shape(vec2 p, vec2 d)\n{\n\tfloat r = min(d.x, d.y);\n\tfloat tri = max(abs(p.x)-p.y,p.y) - r;\n    return tri;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // x,y => pos\n\t// z => pressure\n\t// w => ink\n    \n    vec2 xy = fragCoord.xy;\n\tvec4 webcam = camchan(xy);\n\n    vec2 s = iResolution.xy;\n\tvec2 g = fragCoord;\n\t\n\tvec4 a = tex(g+vec2(1,0)) + webcam.r;\n\tvec4 b = tex(g+vec2(0,1)) + webcam.g;\n\tvec4 c = tex(g+vec2(-1,0)) + webcam.b;\n\tvec4 d = tex(g+vec2(0,-1)) + (webcam.r);// * -0.0125);\n\tfloat lumens = webcam.r + webcam.g + webcam.b + webcam.a;\n\t//fragColor = tex(g-tex(g).xy); // last state\n    vec4 tomachi = vec4(1.0001,1.0002,1.0003,1.0);\n\tfragColor = tex(g-tex(g).xy)* tomachi; // last state\n\n\tvec2 gp = vec2(a.z-c.z,b.z-d.z); // pressure gradient\n    \n\t//fragColor.xyz = vec3(\n\t//\tfragColor.x + gp.x,\n\t//\tfragColor.y + gp.y,\n\t//\t0.25 * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y));\n    //float magic = 0.25 * (a.z-c.z) * webcam.r;\n    float magic = 0.251;// * webcam.b;\n    float pressure = magic * (a.z + b.z + c.z + d.z) - 0.05 * (c.x - a.x + d.y - b.y);\n    \n  \t//emit(xy, 0.005);\n\n    if (d.b > 0.95 && a.r > 0.95)\n    {\n        \t\t\tvec2 p = vec2( webcam.r, webcam.g);\n        \t\t\tvec2 dir = vec2( webcam.g, webcam.b);\n        \t\t\t// emit(p, dir);\n               \t\t//emit(xy, float (iFrame) * 0.01);\n\n    } else {\n    }\n        \n    if (webcam.r > 0.05 ) {\n               \t\temit(xy, 0.001);\n    }\n    \n\tfragColor.xyz = vec3(\n\t\tfragColor.x + gp.x,// + webcam.r,\n\t\tfragColor.y + gp.y,// + webcam.r,\n\t\tpressure);// + webcam.r;\n    \n\tif (iFrame < 1) fragColor = vec4(0);\n\tif (g.x < 1. || g.y < 1. || g.x > s.x - 1. || g.y > s.y - 1.) fragColor.xy *= 0.;\n\t\n   \tif (iFrame < 5) // initial seeding\n    {\n\t\tfor (int i=0;i<count;i++)\n\t\t{\n\t\t\tfloat a = 6.28318 * float(i)/float(count);\n\t\t\tvec2 dir = vec2(cos(a),sin(a));\n            s.x -= float( 1 / iFrame );\n\t\t\tvec2 p = s * 0.95 - dir * radius * min(s.x,s.y);\n            if (lumens < 0.95) { //emit(p, dir); \n            }\n\t\t}\n\t}\n\n    \n\t// wall\n\tvec2 p = g - s * 0.015;\n\tvec2 dim = vec2(s.x * 0.0152);\n\tif (shape(g-s*0.25*iTime, dim) < 0.1) \n\t{\n\t\tfragColor.w = fragColor.z / (shape(fragColor.xy, vec2(constraint)));\n\t\tfragColor.xy *= effect * (shape(fragColor.xy, vec2(constraint)));\n\t}\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define tex(g) texture(iChannel0, (g)/iResolution.xy)\n#define webcam(g) texture(iChannel2, (g)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord;\n    vec4 campix = webcam(xy);\n    vec4 particle = tex(xy);\n    // float r, g, b;\n   \tvec4 a = tex(xy+vec2(1,0)) * campix.r; // LEFT\n    vec4 b = tex(xy+vec2(0,1)) + campix.g; // RIGHT\n\tvec4 c = tex(xy+vec2(-1,0)) + campix.b;// UP\n\tvec4 d = tex(xy+vec2(0,-1)) + (campix.r );//* -0.00000125);//DOWN\n    \n    fragColor = campix * vec4(a.r,a.r,a.r,a.r);\n \tfragColor = tex(fragCoord); // last state\n \tfragColor = vec4(0.5); // last state\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 254, 254, 709]], "test": "untested"}
{"id": "tdXBRf", "name": "Super SPH ", "author": "michael0884", "description": "Finally implemented a proper SPH fluid\nif you have the plugin:\nuse acceleration 4x", "tags": ["fluid", "particles"], "likes": 82, "viewed": 2469, "published": 3, "date": "1588779349", "time_retrieved": "2024-07-30T21:08:34.713553", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    fragColor = texel(ch2, pi);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define dt 3.\n#define loop(i,x) for(int i = min(0, iFrame); i < x; i++)\n\n//rendering scale\n#define SC 1.\n\n#define smoothR 2.5\n#define density 0.036\n\n//sim stuff\nstruct obj\n{\n    int id; //ID\n    vec2 X; //position\n    vec2 V; //velocity\n    float Pressure; //pressure\n    float Rho; //neighbor density\n    float SScale; //smooth scale\n    float Div; //average distance to neighbors\n    vec4 Y; //additional data\n};\n    \nfloat Force(float d)\n{\n    return 0.2*exp(-0.05*d)-2.*exp(-0.5*d);\n}\n\n//40% of the buffer used for particles\n#define P 0.5\n#define SN ivec2(4, 2)\n\nivec2 N; //buffer size\nivec2 sN; //buffer single element size\nint TN; //buffer length\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sqr(float x)\n{\nreturn x*x + 1e-2;\n}\n\n//hash funcs\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}", "buffer_a_code": "//L1 particle buffer - simulation\n//L2 directional neighbor graph 4x - sort\n\nint ID;\nobj O; //this object\n\n//sort arrays\nvec4 lnk0, lnk1;\nvec4 d0, d1;\n\n//L3\nvec4 EA[SN.x]; //element array\n\nvoid insertion_sort(float t, int id);\nobj getObj(int id); vec4 saveObj(int i);\nbool iscoincidenceEA(int id);\nvoid sort0(int idtemp, int D); void sort1(int idtemp, int D);\n\nfloat SKernel(float d, float h)\n{\n    return exp(-(d/h));\n}\n\nfloat Kernel(float d, float h)\n{\n    return exp(-sqr(d/h))/(PI*sqr(h));\n}\n\nfloat KernelGrad(float d, float h)\n{\n    return 2.*d*Kernel(d,h)/sqr(h);\n}\n\nvec2 borderF(vec2 p)\n{\n    \n    float d = min(min(p.x,p.y),min(R.x-p.x,1e10));\n    return exp(-max(d,0.)*max(d,0.))*((d==p.x)?vec2(1,0):(\n    \t\t(d==p.y)?vec2(0,1):(\n            (d==R.x-p.x)?vec2(-1,0):vec2(0,-1))));\n}\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    //4 pix per layer, 3 layers\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    int S = 3; //log2(sN.x)\n    \n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    O = getObj(ID);\n    d0 = vec4(1e6); d1 = vec4(1e6);\n    lnk0 = vec4(-1); lnk1 = vec4(-1);\n    \n    switch(sid.z)\n    {\n    case 0: //particle\n        if(sid.z >= 3) discard;\n        float sk = 0.;\n        \n        //scale /=sk;\n        vec2 F =1e-3*vec2(0.,-1.);//-0.001*(O.X - R*0.5)/(pow(length(O.X - R*0.5),1.)+1.); \n        vec2 Fp = vec2(0);\n        float avgP = 0.;\n     \n         float scale = 0.21/density; //radius of smoothing\n        float Div = 0.;\n        float Rho = Kernel(0., scale);\n           vec2 avgV = vec2(O.V)*Rho;\n        vec3 avgCol = vec3(O.Y.xyz);\n        float Gsum = 1.;\n        float curscale = 1e10;\n        float avgSc = 0.;\n        \n        loop(j,4)\n        {\n            vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n            loop(i,4)\n            {\n                if(nb[i] < 0. || nb[i] > float(TN)) continue;\n                obj nbO = getObj(int(nb[i]));\n                \n               \n                float d = distance(O.X, nbO.X);\n                vec2 dv = (nbO.V - O.V); //delta velocity\n                vec2 dx = (nbO.X - O.X); //delta position \n                vec2 ndir = dx/(d+0.001); //neighbor direction\n                //SPH smoothing kernel\n                float K = Kernel(d, scale);\n                float dK = KernelGrad(d, scale);\n               \n                //Gkernel\n                float G = 1./(d*d+0.01);\n                float dotv = dot(ndir, dv); //divergence\n                vec2 pressure = -(nbO.Pressure/sqr(nbO.Rho) + \n                                    O.Pressure/sqr(O.Rho))*ndir*K;//pressure gradient\n                curscale = min(curscale, d);\n                Gsum += 1.;\n                Div += dotv*K; // local divergence\n                Rho += K;\n                avgCol += nbO.Y.xyz;\n                avgP += nbO.Pressure*K;\n                avgV += nbO.V*K;\n                vec2 viscosity = 1.4*(3. + 3.*length(dv))*ndir*dotv*K;\n                F += pressure + viscosity;\n                Fp -= ndir*SKernel(d,scale);\n            }\n        }\n        \n         //border conditions\n        vec2 bdf = borderF(O.X);\n        F += 0.5*bdf*abs(dot(bdf, O.V));\n       // Fp += 0.*bdf*dot(bdf, O.V);\n        \n        if(R.x - O.X.x < 2.) O.V.x = -abs(O.V.x);\n        if(O.X.x < 2.) O.V.x = abs(O.V.x);\n        //if(R.y - O.X.y < 2.) O.V.y = -abs(O.V.y);\n        if(O.X.y < 2.) O.V.y = abs(O.V.y);\n        \n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, O.X);\n            O.Y.xyz +=(0.5+0.5*sin(vec3(1,2,3)*iTime))/(0.2*d*d+2.);\n            F += 0.01*(iMouse.xy - iMouse.zw)/(0.2*d*d+2.);\n        }\n        \n        O.Rho = Rho;\n        O.Div = Div; //average distance\n        O.SScale = avgSc/Gsum; //average average distance\n        \n        float r = 7.;\n        float D = 1.;\n        float waterP = 0.035*density*(pow(abs(O.Rho/density), r) - D);\n        float gasP = 0.03*O.Rho;\n        O.Pressure = min(waterP,0.04);\n        if(iFrame > 20) O.Pressure += 0.*(avgP/O.Rho - O.Pressure);\n        \n        \n        O.V += F*dt;\n        O.V -= O.V*(0.5*tanh(8.*(length(O.V)-1.5))+0.5);\n        O.X += (O.V)*dt + 0.*Fp; //advect\n        \n        \n        \n        \n        \n        //color diffusion\n        \n        O.Y.xyz = 0.995*mix(avgCol/Gsum, O.Y.xyz,0.995)\n        + 0.01*(exp(-0.1*distance(O.X,R*0.3))*(0.5*sin(vec3(1,2,3)*iTime)+0.5)\n             + exp(-0.1*distance(O.X,R*0.7))*(0.5*sin(vec3(2,3,1)*iTime))+0.5);\n        \n        \n        \n        if(iFrame<10)\n        {\n            O.X = R*vec2(i2xy(ivec3(ID,0,0)))/vec2(N*sN);\n            O.X += 0.*sin(10.*O.X.x/R.x)*sin(10.*O.X.y/R.y);\n\t\t\tO.V = 0.*(hash22(3.14159*pos) - 0.5);\n            O.Y = texture(ch1,O.X/R);\n            O.Pressure = 0.;\n            O.Div = 0.;\n            O.Rho = 5.;\n            O.SScale = 1.;\n        }\n\n        Q = saveObj(sid.y);\n        return;\n        \n    case 1: //dir graph\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        \n        //random sorts\n        loop(i,8) sort0(int(float(TN)*hash13(vec3(iFrame, ID, i))), sid.y);\n        \n        loop(i,4)\n        {\n            sort0(int(nb0[i]), sid.y);  //sort this\n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = texel(ch0, i2xy(ivec3(nb0[i], (iFrame+ID)%4, 1)));\n            loop(j,2)\n            {\n                sort0(int(nb1[j]), sid.y);  \n            }\n        }\n        \n        \n        \n        Q = lnk0;\n        return;\n    }\n     \n}\n\nvec4 saveObj(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(O.X, O.V);\n    case 1:\n        return vec4(O.Pressure, O.Rho, O.SScale, O.Div);\n    case 2:\n        return O.Y;\n    case 3:\n        return vec4(0.);\n    }\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    \n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.Pressure = a.x;\n    o.Rho = a.y;\n    o.SScale = a.z;\n    o.Div = a.w;\n    \n    o.Y = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid insertion_sort(float t, int id)\n{\n\tif(d0.x > t)\n    {\n        d0 = vec4(t, d0.xyz);\n        lnk0 = vec4(id, lnk0.xyz);\n    }else if(d0.y > t && d0.x < t)\n    {\n        d0.yzw = vec3(t, d0.yz);\n        lnk0.yzw = vec3(id, lnk0.yz);\n    }else if(d0.z > t&& d0.y < t)\n    {\n        d0.zw = vec2(t, d0.z);\n        lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t && d0.z < t)\n    {\n        d0.w = t;\n        lnk0.w = float(id);\n    }\n}\n\nbool iscoincidence(int id)\n{\n    return (id < 0) || \n      \t\t(id == ID) ||\n           any(equal(lnk0,vec4(id)));\n}\n\nvoid sort0(int idtemp, int D) //sort closest objects in sN.x directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec2 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xy; \n   \n    vec2 dx = nbX - O.X;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n    \n    if(dir != D) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//voronoi particle tracking + graph augmented\n\nvec2 sc(vec2 p)\n{\n    return SC*(p - 0.5*R) + 0.5*R;\n}\n\nfloat d;\nint id;\nvec2 p;\n\nfloat particleDistance(int i)\n{\n    return distance(p, sc(texel(ch0, i2xy(ivec3(i, 0, 0))).xy));\n}\n\nvoid sort(int utemp)\n{\n    if(utemp < 0) return; \n   \tfloat dtemp = particleDistance(utemp);\n    if(dtemp < d) //sorting\n    {\n        d = dtemp;\n        id = utemp;\n    }\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    d = 1e10;\n    id = 1;\n    p = pos;\n    ivec2 pi = ivec2(floor(pos));\n    \n    sort(1+0*int(texel(ch1, pi).x));\n    \n   int ID = id;\n    loop(j,8)\n    {\n        \n        int nbid = int(texel(ch1, pi+cross_distribution(j)).x);\n        sort(nbid);\n    }\n    \n    loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,4)\n    \t{ \n            sort(int(nb[i]));  //sort this\n        }\n    }\n    \n    loop(i,5) //random sort\n    {\n        sort(int(float(TN)*hash13(vec3(iFrame, pi.x, pi.y*i))));\n    }\n    \n   \tQ = vec4(id, d, 0, 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec2 sc(vec2 p)\n{\n    return SC*(p - 0.5*R) + 0.5*R;\n}\n\n// iq's smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    \n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.Pressure = a.x;\n    o.Rho = a.y;\n    o.SScale = a.z;\n    o.Div = a.w;\n    \n    o.Y = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    int ID = int(texel(ch1, pi).x); \n    obj O = getObj(ID);\n    float d =distance(pos, sc(O.X));\n    float d1 = exp(-sqr(d/1.)) +  0.*exp(-0.1*d);\n    float d2 = 10.*O.Y.x;\n   \n    /*loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,4)\n    \t{\n            if(nb[i] < 0.) continue;\n            vec2 nbX = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xy; \n        \td1 += exp(-0.5*distance(pos, sc(nbX)));\n    \t}\n    }*/\n    d1*=1.;\n    // Output to screen\n \tvec3 pcol = texel(ch2, pi).xyz;\n    vec3 ncol = 0.*sin(vec3(1,2,3)*d2*0.3)*d1 + hsv2rgb(vec3(atan(O.V.x,O.V.y)/PI, 2.*length(O.V),20.*length(O.V)))*d1;\n    fragColor = vec4(mix(pcol,ncol,0.5),1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 185]], "test": "untested"}
{"id": "Wslfzf", "name": "polar Perlin noise", "author": "FabriceNeyret2", "description": "#define NOISE :  0: base Perlin  1: flamme 2: blobs\nUncomment line 40 for spirals\nNB: could use narrower rings (smooth(3)), but here it manage the donuts borders smoothing as well. ;-)", "tags": ["procedural", "noise", "perlin", "polar", "anisotropy", "short", "cyclical"], "likes": 9, "viewed": 608, "published": 3, "date": "1588779076", "time_retrieved": "2024-07-30T21:08:35.577243", "image_code": "#define NOISE 0     // 0: base Perlin  1: flamme 2: blobs\n\n#define hash(p) (2.*fract(sin(mod(.5+p,C)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)-1.)\n\n// --- cyclical base Perlin in [-1,1] \nfloat noise(vec2 U, vec2 C) {\n    vec2 I = floor(U),\n         F = fract(U), \n         S = F*F*(3. - 2.*F),\n#define H(x,y)  dot( hash(I+vec2(x,y)) , F-vec2(x,y) )   \n         V = mix(vec2(H(0,0),H(0,1)),vec2(H(1,0),H(1,1)),S.xx);\n    return mix(V.x,V.y,S.y);\n}\n\n// --- Perlin modulator \nfloat noiseT(vec2 U, vec2 C) {\n    return   NOISE == 0 ?       noise(U,C)             // bozo ( pass-through )\n           : NOISE == 1 ? 1./3. - abs(noise(U,C))      // flamme\n           :              abs(noise(U,C)) - 1./5.;     // blobs\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) /R.y,\n         P = vec2( 6.*atan(U.y,U.x)/6.283, length(U)); // polar coords\n    float l = P.y,\n          S = 1., s = 60.,                      // noise scaling, aspect ratio\n          v = 0.,w;\n#if 0                                           // --- tests    \n  //v = noise(10.*U,vec2(10));                  //  cartesian noise\n  //v = noise(10.*P,vec2(10));                  //  brute polar noise\n  //v = noise(10.*P*vec2(P.y,1),vec2(10));      // naive perimetric param 1\n  //v = noise(P*vec2(floor(10.*P.y),10),vec2(10));   // naive perimetric param 2\n#else                                           // --- the true thing\n    float T, t = 3.*iTime; // 20.*iMouse.y/R.y; // --- tune aspect \n    t = mod(floor(t),20.); t = min(t,20.-t);\n    S=5.,s=10.; T = exp2(.5*(t-5.)); S = ceil(S*sqrt(T)), s /= T;\n\n  //P *= mat2(cos(.5+vec4(0,11,33,0)));         // spiral\n  //float r = 5.;                               // to test one single ring\n    for (float r=5.; r<15.; r++) {              // --- combine rings with adapted scaling\n        w = smoothstep(3.,0.,abs(10.*l-r));     // smooth rings\n        if (w>0.)  //   ...  ring coords   ...   seed     ...    cycling ... ring mask\n            v += noiseT( P*S/6.*vec2(r,s) -r*vec2(117,119), vec2(r*S,1024) ) * w ;\n         // R =  sin(6.28*P*S/6.*vec2(r,s)) , v+= R.x*R.y * w; // test grid\n    }\n#endif \n    O = vec4(.5+.5*v); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wslfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 479, 509, 509, 720], [722, 722, 760, 760, 2193]], "test": "untested"}
{"id": "WdsfRf", "name": "mount mask", "author": "lomateron", "description": "mouse x controls fractal loop", "tags": ["fractal"], "likes": 9, "viewed": 496, "published": 3, "date": "1588770940", "time_retrieved": "2024-07-30T21:08:36.385083", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n         u = -u.yx;\n         u += vec2(1.,0.);\n    vec2 v = u;\n         u = u/dot(u,u);\n    \n    float t = iTime*.8;\n    if(iMouse.z > 0.) t = 10.*iMouse.x/iResolution.x;\n\n    float pi = 3.14159265359;\n    vec4 sum = vec4(0.);\n    for(float i = 0.; i < t; ++i)\n    {\n        u = cos(u.y-vec2(.0,.5*pi))*exp(u.x);\n        u+= v;\n        sum+= (.5+.5*cos(i*4.+vec4(0,1,2,0)))/length(u);\n    }\n    fragColor = sqrt(sum)*.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 542]], "test": "untested"}
{"id": "wsXfR2", "name": "Minimalist, Blackhole to present", "author": "Leria", "description": "A 3d black hole first try with rays\nMouse.X allows the user to ncrease or decrease the mass of the blackhole", "tags": ["noise", "blackhole", "hole", "dark"], "likes": 2, "viewed": 300, "published": 3, "date": "1588767448", "time_retrieved": "2024-07-30T21:08:37.304625", "image_code": "#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t22.\n#define RAY_TRACING \t\t0\n#define GRAV_CONST\t\t\t6.674\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n    mat4 projection;\n \tvec3 pos; //position\n    vec3 focal_point; //focal point = target point\n    float vfov; //vertical fov\n};\n\nstruct BlackHole\n{\n    vec3 pos; //position\n    vec3 disk_normal;\n    float mass; //blackhole mass\n    float attraction_radius; //attraction radius of the blackhole\n    float inner_radius; //inner radius\n    float accretion_disk_radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nBlackHole bh;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n//Transformations\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_black_hole(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tbh = BlackHole(pos, J, mass, radius, inner_rad, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\n//gravity stuff\nvoid space_time_bending(inout Ray r, inout vec3 p)\n{    \n\n    vec3 bh_vec = bh.pos - p;\n    float d = dot(bh_vec,bh_vec);\n    vec3 res = normalize(bh_vec) * (GRAV_CONST*bh.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + 0.05*res);\n}\n\nvoid init_black_hole(void)\n{\n \tset_black_hole(vec3(0., 0., -15.), iMouse.x/iResolution.y, RADIUS, 4., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target, float theta /*degree*/)\n{\n    cam = Camera(mat4(1), pos, target, theta);\n}\n\nvoid init_camera(void)\n{\n    init_black_hole();\n    set_camera(vec3(0., 0., 30.), bh.pos, 60.); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\nfloat sdf_plane(vec3 pXp0, vec4 n)\n{\n\treturn dot(pXp0,n.xyz) + n.w ;   \n}\n\nfloat sdf_box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\nfloat sdf_torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n                 \nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    vec3 opacity, transmission;\n    \n    opacity = vec3(0.); transmission = vec3(1.);\n    \n    vec3 p = ray_interpolation(r, k*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3)))));\n    vec3 tmp = p;\n    float s = 0.;\n    \n    for(s; s < 2000.; s++)\n    {               \n        vec2 nu = polar_coord(p-bh.pos);\n        \n        if((length(nu) - bh.inner_radius >= 0.) && (length(nu)-bh.accretion_disk_radius <= 0.) && (distance(p.y, bh.pos.y) < .2))\n        {\n            vec4 tex = texture(iChannel0, p/8.+0.05*iTime);\n            float coef = length(p-bh.pos);\n        \tc += 0.1*tex.rrr*vec3(0.6, 0.3, 0.2);\n        }\n        \n        if(length(p) > 46.)\n        {\n        \tvec3 a = abs(r.dir);\n            float M = max(a.x, max(a.y, a.z));\n            vec2 u = M==a.x ? r.dir.yz : M==a.y ? r.dir.xz : r.dir.xy ;\n            \n           \tc += min(0.7*texture(iChannel1, (u/1.)).rgb*vec3(0.1, 0.1, 0.2), 0.7*texture(iChannel1, (u/1.)).rgb);\n            break;\n        }\n        \n        p += r.dir*k;\n        space_time_bending(r, p); //comment this line to see what's behind\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n    #if RAY_TRACING\n    vec3 point;\n    \n    if(intersect_disk(Ray(cam.pos, vec3(uv, -1.)), vec3(0., 0., -15.), vec3(-.25, 1., 0.), RADIUS, point))\n    {\n        vec4 tex = texture(iChannel0, point/16.+0.1*iTime);\n        color = tex.rrr*vec3(0.9, 0.5, 0.4);\n    }\n    \n    #else\n    vec3 ray_dir = vec3(uv, -1.);\n    bh.pos = normalize(vec3(-10, 20., bh.pos.z));\n    //float degree = mix(0., 10., iMouse.y);\n    ray_march_scene(Ray((vec4(cam.pos, 1.)*rotation_matrix(I, (-iMouse.y/40.)*PI/180.)).xyz, normalize(ray_dir)), .05, color);\n    #endif\n    \n    fragColor = vec4(color, 1.);\n}\n\n\n////////////////////////////////", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[818, 865, 893, 893, 1063], [1065, 1087, 1133, 1133, 1756], [1777, 1777, 1818, 1818, 1854], [1856, 1856, 1997, 1997, 2060], [2062, 2062, 2105, 2105, 2145], [2147, 2163, 2215, 2215, 2418], [2420, 2420, 2448, 2448, 2532], [2534, 2534, 2598, 2598, 2647], [2649, 2649, 2673, 2673, 2747], [2749, 2749, 2796, 2796, 2848], [2850, 2850, 2933, 2933, 3072], [3074, 3074, 3110, 3110, 3147], [3149, 3149, 3182, 3182, 3273], [3275, 3275, 3328, 3328, 3685], [3687, 3687, 3722, 3722, 3787], [3789, 3789, 3815, 3815, 3963], [3982, 3982, 4034, 4034, 5120], [5122, 5122, 5179, 5179, 5884]], "test": "untested"}
{"id": "3slBRf", "name": "Sand Album", "author": "dr2", "description": "An assortment of sand sculptures (mouseable; mouse near top/bottom overrides autopaging)", "tags": ["symmetry", "sculpture", "building", "sandcastle"], "likes": 29, "viewed": 502, "published": 3, "date": "1588764567", "time_retrieved": "2024-07-30T21:08:38.295974", "image_code": "// \"Sand Album\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 IcoSym (vec3 p);\nvec3 DodSym (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDirEx, sunDir, qHit, pgSize;\nfloat tCur, msAz, msEl, dstFarEx, tpBook, phsTurn, idPage, dstFar, pileHt, grRad, pR, pA,\n   nStr, pgRnd, rc;\nint idObj;\nconst float pi = 3.14159, sqrt2 = 1.41421;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat PileDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 st;\n  float d, r, s, a;\n  q = p;\n  q.y -= pileHt;\n  s = q.y / pileHt;\n  a = (nStr == 1. || mod (nStr, 2.) == 0.) ? pA : mod (pA + 0.5 / nStr, 1.);\n  r = Fbm2 (vec2 (pgRnd + 64. * a, 1.5 * s));\n  if (nStr == 0.) r = mix (r, Fbm2 (vec2 (pgRnd + 64. * (a - 1.), 1.5 * s)), a);\n  r = 0.8 * r + 8. * (1. + 0.05 * (s - 1.5) * (s - 1.5));\n  d = SmoothMax (pR - r, q.y - pileHt - 0.01, 0.2);\n  if (nStr > 1.) q.xz = Rot2D (q.xz, 2. * pi * (floor (nStr * (pA - 0.5) + 0.5) / nStr));\n  else q.xz *= -1.;\n  st = q.xy - vec2 (-9., -0.05);\n  if (nStr > 0.) d = max (d, min (0.6 - abs (q.z), (st.y - st.x + 0.2 -\n     abs (mod (st.x + st.y, 0.4) - 0.2) / sqrt2)));\n  d = SmoothMin (d, q.y + pileHt, 0.3);\n  d = max (d, max (pR - grRad, - p.y));\n  DMIN (2);  \n  return 0.6 * dMin;\n}\n\nfloat CasBldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, a;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  qq = q;\n  q.xy -= vec2 (-5., 1.2);\n  d = PrRoundBoxDf (q, vec3 (0.15, 1.2 + rc, 5.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 1.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  d = max (d, - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.6, 0.)), vec2 (0.6, 0.4), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 5.;\n  q.y -= 0.2;\n  d = min (PrCylAnDf (q.xzy, 0.45, 0.05, 1.2 + 0.2), PrCylDf (q.xzy, 0.4, 1.2));\n  dMin = min (dMin, d);\n  q = qq;\n  q.xy -= vec2 (-2., 2.);\n  d = max (max (q.y - 1.8 - 0.3 * q.x, - q.x), - p.y);\n  dMin = min (dMin, d);\n  d = PrRoundBoxDf (q, vec3 (0.15, 2.2 + rc, 2.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 2.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 2.;\n  d = PrCylDf (q.xzy, 0.3, 2.3);\n  dMin = min (dMin, d);\n  nStr = 4.;\n  return dMin;\n}\n\nfloat SprBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, h;\n  q = p;\n  q.y -= 2.5;\n  d = max (PrRoundBox2Df (vec2 (pR - (4. - 0.35 * q.y),\n     mod (q.y + 1. + 2. * pA, 2.) - 1.), vec2 (0.4, 0.5), rc), abs (q.y + 0.5) - 3.);\n  d = min (d, PrCylDf (q.xzy, 4. - 0.2 * q.y, 2.5));\n  dMin = min (dMin, d);\n  h = 1.3;\n  q.y -= 2.5 + h;\n  d = PrCylDf (q.xzy, 0.5 * (1. + 0.2 * sin (2. * pi * (2. * q.y / h + pA))) * (1. - 0.95 * q.y / h), h);\n  dMin = min (dMin, d);\n  nStr = 0.;\n  return 0.9 * dMin;\n}\n\nfloat TwrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 3.5 - rc;\n  d = PrRoundBoxDf (q, vec3 (vec2 (1.3) * (1. - 0.05 * q.y), 3.5).xzy - rc, rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-4., -1.);\n  d = min (d, PrRoundCylDf (q.xzy, 0.8 * (1. - 0.05 * q.y), rc, 2.5));\n  q.x -= 1.7;\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y - 0.8 + 0.2 * q.x * q.x).xzy, vec3 (2., 0.4, 0.1), rc));\n  q.z = abs (q.z);\n  q -= vec3 (-2.5, -1., 1.1);\n  d = min (d, PrRoundCylDf (q.xzy, 0.7 * (1. - 0.05 * q.y), rc, 1.5));\n  dMin = min (dMin, d);\n  nStr = 4.;\n  return dMin;\n}\n\nfloat PyrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = max (max (abs (q.y) - 2., - q.x + q.y), min (0.4 - abs (abs (q.z) - 0.6), (q.y - q.x + 0.18 -\n     abs (mod (q.x + q.y - 0.02, 0.4) - 0.2) / sqrt2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.2;\n  d = PrCylAnDf (q.xzy, 0.5, 0.05, 0.2);\n  dMin = min (dMin, d);\n  nStr = 4.;\n  return dMin;\n}\n\nfloat TajBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (5.8, 0.1, 5.8) - rc, rc);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * (pA - 0.5) + 0.5) / 8.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = abs (q.y) - 2.;\n  q.y = mod (q.y + 0.4, 2.) - 1.;\n  q.z = abs (q.z) - 0.6;\n  d = max (d, max (- q.x, - max (PrCapsDf ((q - vec3 (0., -0.5, 0.)).xzy, 0.4, 1.), - q.y - 0.2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.z = abs (q.z);\n  q -= vec3 (-5., 3.1, 5.);\n  d = PrCylDf (q.xzy, 0.3 - 0.1 * q.y / 3., 3.);\n  dMin = min (dMin, d);\n  q.y -= 3.2;\n  d = PrSphDf (q, 0.3);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.6;\n  d = PrSphDf (q, 2.);\n  dMin = min (dMin, d);\n  nStr = 1.;\n  return dMin;\n}\n\nfloat PisBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, ht, dh, a, ai, nf, na;\n  nf = 8.;\n  na = 12.;\n  ht = 3.5;\n  q = p;\n  d = PrCylDf (q.xzy, 3., 0.05);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, pi / 4.);\n  q.y -= ht + 0.05;\n  q.xy = Rot2D (q.xy, 0.025 * pi);\n  a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n  d = PrCylDf (q.xzy, 1., ht);\n  dh = abs (q.y) - ht * (1. + 1. / (4. * nf));\n  q.y = mod (q.y + ht / nf, 2. * ht / nf) - ht / nf;\n  d = min (d, max (dh, PrRoundCylDf (q.xzy, 1.2, rc, ht / (4. * nf))));\n  ai = floor (na * (a - 0.5) + 0.5) / na;\n  q.xz = Rot2D (q.xz, 2. * pi * ai);\n  q.y = abs (q.y) - ht / nf;\n  d = max (d, - PrRoundBoxDf (vec3 (length (q.xz) - 1., q.y, 2. * pi * (abs (a - ai - 0.5) - 0.5 / na)),\n     vec3 (0.2, 0.55 * ht / nf, 0.12) - rc, rc));\n  q.x -= -1.05;\n  d = min (d, max (dh, PrCylDf (q.xzy, 0.08, ht / nf)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 0.4;\n  d = PrRoundBox2Df (vec2 (pR - 6.5, abs (q.y) - 0.4), vec2 (0.25, 0.01), rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (64. * (pA - 0.5) + 0.5) / 64.));\n  q.x = abs (q.x + 6.5) - 0.15;\n  d = min (d, PrCylDf (q.xzy, 0.08, 0.4));\n  dMin = min (dMin, d);\n  nStr = 3.;\n  return dMin;\n}\n\nfloat FrtBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, r;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (5. * (pA - 0.5) + 0.5) / 5.));\n  q.xy -= vec2 (-2., 1.4);\n  d = max (max (- q.x, abs (q.y) - 1.4), - PrRoundBoxDf (vec3 (q.x, abs (q.y) - 0.5,\n     mod (q.z + 0.5, 1.) - 0.5), vec3 (0.1, 0.2, 0.15), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x - 2., q.y - 1.4 - 0.3 * q.x), vec2 (2.2, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.xy -= vec2 (-3.5, -0.6);\n  d = max (max (abs (q.x) - 0.4, abs (q.y) - 0.8),\n     - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.2, 0.)), vec2 (0.4, 0.3), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x, q.y - 0.9 + 0.4 * abs (q.x)), vec2 (0.6, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.y -= 0.3;\n  q.z = abs (q.z) - 5.5 * tan (pi / 5.);\n  d = PrCylDf (q.xzy, 0.8, 1.1);\n  r = 0.2 * length (q.xz);\n  q.y -= 1.4 - r;\n  d = min (d, PrCylDf (q.xzy, 1.1, 0.3 - r));\n  dMin = min (dMin, d);\n  nStr = 5.;\n  return dMin;\n}\n\nfloat WvnBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, rs, s, h, f, yy;\n  h = 2.5;\n  rs = 0.15;\n  q = p;\n  q.y -= h + rs;\n  f = q.y / h - 1.;\n  yy = abs (q.y) - h;\n  d = max (pR - 2.3 - 0.7 * f * f, yy);\n  q.xz *= 1.4 + 0.4 * f;\n  q.xz = vec2 (20. * pA, length (q.xz) - 10. / pi);\n  d = min (d, length (vec2 (yy, q.z)) - 2. * rs);\n  s = 0.4 * rs * cos (2. * pi * q.x);\n  d = min (d, max (min (length (vec2 ((mod ((q.x + q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z + s)),\n     length (vec2 ((mod ((q.x - q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z - s))) - rs, yy));\n  dMin = min (dMin, d);\n  nStr = 3.;\n  return 0.5 * dMin;\n}\n\nfloat PstBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, s, ss;\n  s = 1.7;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    q.xz = Rot2D (q.xz, 0.25 * pi);\n    q.xz = abs (q.xz) - 0.75 * s;\n    ss = s * s;\n    q.xz = mix (q.xz, q.zx, step (q.x, q.z));\n    d = min (PrRoundBoxDf (q - vec3 (0., 0.6 * ss - rc, 0.), s * vec3 (0.3, 0.6 * s, 0.3) - rc, rc),\n       PrCylDf ((q - vec3 (0., 1.45 * ss - rc, 0.)).xzy, 0.12 * s, 0.25 * ss));\n    dMin = min (dMin, d);\n    s *= 0.85;\n  }\n  nStr = 4.;\n  return dMin;\n}\n\nfloat BrgBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 0.1 + 0.01 * sin (8. * pi * pR);\n  d = max (abs (abs (pR - 5.2) - 1.4) - 0.4, abs (q.y) - 0.1);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 1.5;\n  d = min (PrCylDf (q.xzy, 2.5, 1.5),\n     PrCylDf (vec3 (q.xz, q.y - (2.2 - 0.25 * pR + 0.1 * sin (32. * pi * pA))), 2.8, 0.07));\n  q.y -= 2.16;\n  d = min (d, PrCylDf (q.xzy, 0.5, 0.22));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (3. * (pA - 0.5) + 0.5) / 3.));\n  d = max (d, - PrRoundBoxDf (q - vec3 (-2.5, 0.8, 0.), vec3 (0.7, 0.8, 0.7), rc));\n  dMin = min (dMin, d);\n  q.x += 5.2;\n  q.y -= 0.5 - 0.2 * q.x * q.x;\n  d = PrBoxDf (q, vec3 (1.6, 0.1, 0.6));\n  q.z = abs (q.z);\n  q.yz -= vec2 (0.3, 0.5);\n  d = min (d, PrRoundBoxDf (q, vec3 (1.6, 0.3, 0.1) - rc, rc));\n  dMin = min (dMin, d);\n  nStr = 3.;\n  return dMin;\n}\n\nfloat PolBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, pRad, bRad, cRad;\n  pRad = 4.;\n  bRad = 0.4;\n  cRad = 0.25;\n  p.y -= 0.65 * pRad;\n  q = DodSym (p);\n  q.z += pRad;\n  d = PrSphDf (q, bRad);\n  q = IcoSym (p);\n  q.z += pRad;\n  d = min (d, PrSphDf (q, bRad));\n  q.yx = sin (mod (atan (q.x, q.y) + pi / 3., 2. * pi / 3.) + vec2 (0.5 * pi, 0.)) * length (q.xy);\n  q.z = dot (q.yz, sin (- pi / 10. + vec2 (0., 0.5 * pi)));\n  d = SmoothMin (SmoothMin (d, length (q.xz) - cRad, rc), PrSphDf (p, pRad - 0.1), rc);\n  dMin = min (dMin, d);\n  nStr = 5.;\n  return dMin;\n}\n\nfloat PanBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 1.8;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (4.9, 1.6, 2.9) - rc, rc);\n  q.y = abs (q.y) - 1.5;\n  d = min (d, PrRoundBoxDf (q, vec3 (5.4, 0.1, 3.4) - rc, rc));\n  q = p;\n  q.y -= -1.7;\n  d = min (d, PrRoundBoxDf (q, vec3 (6., 0.1, 4.) - rc, rc));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 2.2;\n  d = PrCylDf (q.xzy, 1.7, 0.75);\n  q.y -= 0.75;\n  d = min (d, max (max (PrSphDf (q, 2.), - q.y), 0.2 - pR));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = mod (q.xz + 0.5, 1.) - 0.5;\n  d = max (PrCylDf (q.xzy, 0.2, 1.5), max (abs (p.x) - 5.5, abs (p.z) - 3.5));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * (pA - 0.5) + 0.5) / 16.));\n  q.xy -= vec2 (-1.85, 2.2);\n  d = min (d, PrCylDf (q.xzy, 0.15, 0.75));\n  dMin = min (dMin, d);\n  nStr = 2.;\n  return dMin;\n}\n\nconst int nPage = 12;\n\n#define ISBOOK  1\n#define ID_PAGE 1\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  pR = length (p.xz);\n  pA = ((pR > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.) + 0.5;\n  nStr = 0.;\n  q = p;\n  q.y -= 2. * pileHt;\n  rc = 0.05;\n  if (idPage <= 4.) {\n    if (idPage == 1.)       dMin = CasBldgDf (q, dMin);\n    else if (idPage == 2.)  dMin = SprBldgDf (q, dMin);\n    else if (idPage == 3.)  dMin = TwrBldgDf (q, dMin);\n    else /*if (idPage == 4.)*/ dMin = PyrBldgDf (q, dMin);\n  } else if (idPage <= 8.) {\n    if (idPage == 5.)       dMin = TajBldgDf (q, dMin);\n    else if (idPage == 6.)  dMin = PisBldgDf (q, dMin);\n    else if (idPage == 7.)  dMin = FrtBldgDf (q, dMin);\n    else /*if (idPage == 8.)*/ dMin = WvnBldgDf (q, dMin);\n  } else /*if (idPage <= 12.)*/ {\n    if (idPage == 9.)       dMin = PstBldgDf (q, dMin);\n    else if (idPage == 10.) dMin = BrgBldgDf (q, dMin);\n    else if (idPage == 11.) dMin = PolBldgDf (q, dMin);\n    else /*if (idPage == 12.)*/ dMin = PanBldgDf (q, dMin);\n  }\n  idObj = 1;\n  dMin = PileDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += clamp (3. * h, 0.02, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  float f;\n  if (rd.y == 0.) rd.y = 0.0001;\n  f = Fbm2 (4. * rd.xz / rd.y);\n  return mix (mix (vec3 (0.2, 0.3, 0.7), vec3 (0.5, 0.5, 0.7), pow (1. - max (rd.y, 0.), 8.)),\n     vec3 (0.9), clamp (1.6 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 SandCol (vec3 ro, vec3 rd, vec3 vn, float sh)\n{\n  vec4 vn4;\n  vec3 col;\n  float f;\n  col = 0.8 * vec3 (1., 0.9, 0.7);\n  if (ro.y < 0.05) {\n    f = smoothstep (0.85, 0.9, vn.y);\n    vn4 = RippleNorm (ro.xz, vn, 8. * f * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n    vn = vn4.xyz;\n    col *= mix (1., 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w), f);\n  }\n  vn = VaryNf (16. * ro, vn, 1.);\n  col *= (0.8 + 0.2 * Fbm3 (32. * ro)) *\n     (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dstObj, sh, ao, f, fr, a, s, w;\n  int idObjT;\n  bool isSand;\n  isSand = false;\n  pgRnd = 17.11 * idPage;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObjT = idObj;\n    sh = ObjSShadow (ro, sunDir);\n    if (idObjT == 1) {\n      ao = ObjAO (ro, vn);\n      vn = VaryNf (32. * ro, vn, 0.5);\n      sh = min (sh, ao);\n      col = vec3 (1., 0.9, 0.7);\n      col *= 0.8 + 0.2 * Fbm3 (32. * ro);\n      col = (col * (ao * 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         0.05 * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n    } else if (idObjT == 2) {\n      isSand = true;\n    }\n  } else if (rd.y < 0.) {\n    f = 0.1 * tCur;\n    ro += (- ro.y / rd.y) * rd;\n    a = atan (ro.z, - ro.x) / (2. * pi) + 0.5;\n    fr = mix (Fbm1 (pgRnd + 32. * a), Fbm1 (pgRnd + 32. * (a - 1.)), a);\n    s = SmoothBump (0.25, 0.75, 0.25, mod (f + 0.4, 1.));\n    w = length (ro.xz) - (grRad + 0.2 + mix (16. * fr, 16. + 3. * fr, s));\n    if (w < 0.) {\n      vn = vec3 (0., 1., 0.);\n      sh = 1.;\n      isSand = true;\n    } else {\n      w = 0.02 * w + f;\n      col = mix (mix (vec3 (0.2, 0.3, 1.), vec3 (0.2, 0.3, 1.) + vec3 (0.6, 0.5, 0.),\n         Fbm2 (2048. * vec2 (w, fr)) * SmoothBump (0.4, 0.6, 0.01, mod (w, 1.))), vec3 (0.2, 0.3, 1.),\n         smoothstep (-0.1, 0., rd.y));\n    }\n  } else {\n    col = BgCol (rd);\n  }\n  if (isSand) col = SandCol (ro, rd, vn, sh);\n  return clamp (col, 0., 1.);\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az, zmFac;\n  az = 0.2 * pi;\n  el = -0.05 * pi;\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  grRad = 16.;\n  pileHt = 1.5;\n  ro = vuMat * vec3 (0., 3., -40.);\n  ro.y = max (ro.y, 0.2);\n  zmFac = 4.;\n  dstFar = 100.;\n  rd = vuMat * normalize (vec3 (fCoord, zmFac));\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fCol = pow (ShowScene (ro, rd), vec3 (0.8));\n}\n\n#if ISBOOK\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 4.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.z / nRing;\n  bc = q.z;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (3.2, 0.011, 1.8);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = vec3 (0.9, 0.9, 0.8) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz));\n      col4 = vec4 (c, 0.2);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n#if ISBOOK\n  tpBook = max (0.2 * tCur - 1., 0.);\n  tpBook *= 3.;  //\n  az = 0.;\n  el = -0.5 * pi;\n#else\n  idPage = float (ID_PAGE);\n#endif\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    if (abs (mPtr.y) > 0.42) {\n#if ISBOOK\n      tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n#else\n      idPage = clamp (floor ((1.05 * mPtr.x + 0.45) * float (nPage)), 0., float (nPage)) + 1.;\n#endif\n#if ISBOOK\n    } else if (abs (mPtr.x - 0.04) > 0.42) {\n      el += pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n#endif\n    } else if (abs (mPtr.x - 0.04) < 0.42 && abs (mPtr.y) < 0.42) {\n      msAz = pi * clamp (3. * (mPtr.x - 0.04), -1., 1.);\n      msEl = pi * mPtr.y;\n    }\n  }\n#if ISBOOK\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (3.2, 0., -20.);\n  zmFac = 9.5;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n  ro = vuMat * ro;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ExShowScene (ro, rd);\n#else\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec3 ComSym (vec3 p, vec2 cs1, vec2 cs2, float w)\n{\n  p.x = - abs (p.x);\n  for (int j = 0; j < 4; j ++) {\n    if (dot (p.yz, cs1) > 0.) p.zy = Rot2Cs (p.zy, cs2) * vec2 (1., -1.);\n    if (j < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.yx = sin (mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w + vec2 (0.5 * pi, 0.)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nvec3 IcoSym (vec3 p)\n{\n  vec2 cs1, cs2;\n  cs1 = cos (0.5 * acos (sqrt (5.) / 3.) + vec2 (0., 0.5 * pi));\n  cs2 = cos (acos (sqrt (5.) / 3.) + vec2 (0., 0.5 * pi));\n  p.yz = Rot2Cs (vec2 (p.y, abs (p.z)), cs1);\n  p = ComSym (p, cs1, cs2, 2. * pi / 3.);\n  return p;\n}\n\nvec3 DodSym (vec3 p)\n{\n  vec2 cs1, cs2;\n  cs1 = cos (0.5 * atan (2.) + vec2 (0., 0.5 * pi));\n  cs2 = cos (atan (2.) + vec2 (0., 0.5 * pi));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), vec2 (cs1.x, - cs1.y));\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  p = ComSym (p, cs1, cs2, 2. * pi / 5.);\n  return p;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slBRf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1273, 1273, 1308, 1308, 2093], [2095, 2095, 2133, 2133, 3104], [3106, 3106, 3144, 3144, 3605], [3607, 3607, 3645, 3645, 4233], [4235, 4235, 4273, 4273, 4700], [4702, 4702, 4740, 4740, 5514], [5516, 5516, 5554, 5554, 6696], [6698, 6698, 6736, 6736, 7648], [7650, 7650, 7688, 7688, 8264], [8266, 8266, 8304, 8304, 8814], [8816, 8816, 8854, 8854, 9664], [9666, 9666, 9704, 9704, 10234], [10236, 10236, 10274, 10274, 11063], [11125, 11125, 11147, 11147, 12161], [12163, 12163, 12196, 12196, 12380], [12382, 12382, 12403, 12403, 12660], [12662, 12662, 12699, 12699, 12952], [12954, 12954, 12986, 12986, 13188], [13190, 13190, 13215, 13215, 13594], [13596, 13596, 13640, 13640, 13834], [13836, 13836, 13858, 13858, 14099], [14101, 14101, 14153, 14153, 14625], [14627, 14627, 14662, 14662, 16161], [16163, 16163, 16209, 16209, 16713], [21371, 21371, 21403, 21403, 21503], [21505, 21505, 21551, 21551, 21598], [21600, 21600, 21647, 21647, 21694], [21696, 21696, 21729, 21729, 21756], [21758, 21758, 21800, 21800, 21851], [21853, 21853, 21906, 21906, 21967], [21969, 21969, 22026, 22026, 22190], [22192, 22192, 22235, 22235, 22299], [22301, 22301, 22347, 22347, 22404], [22406, 22406, 22457, 22457, 22777], [22779, 22779, 22801, 22801, 23044], [23046, 23046, 23068, 23068, 23340], [23342, 23342, 23378, 23378, 23584], [23586, 23586, 23616, 23616, 23729], [23731, 23731, 23762, 23762, 23826], [23828, 23828, 23873, 23873, 23976], [23978, 23978, 24023, 24023, 24061], [24063, 24063, 24120, 24120, 24203], [24237, 24237, 24261, 24261, 24314], [24316, 24316, 24340, 24340, 24452], [24454, 24454, 24478, 24478, 24597], [24599, 24599, 24624, 24624, 24770], [24772, 24772, 24797, 24797, 24983], [24985, 24985, 25010, 25010, 25235], [25237, 25237, 25259, 25259, 25413], [25415, 25415, 25436, 25436, 25591], [25593, 25593, 25614, 25614, 25769], [25771, 25771, 25800, 25800, 26012], [26014, 26014, 26053, 26053, 26238]], "test": "untested"}
{"id": "wsffRf", "name": "lattice R", "author": "haptix", "description": "lattice R", "tags": ["latticer"], "likes": 7, "viewed": 473, "published": 3, "date": "1588740300", "time_retrieved": "2024-07-30T21:08:39.199558", "image_code": "vec2 smoothU(vec2 a, vec2 b, float r)\n{\n\tvec2 u = max(vec2(r - a.x, r - b.x), vec2(0.));\n\treturn vec2(max(r, min (a.x, b.x)) - length(u), (a.y+b.y) / 2.);\n}\n\nvec3 rep(vec3 pos, float sp)\n{\n\treturn mod(pos, sp) - .5*sp;\n}\n\nvec2 cylX(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.yx - c.zx) - c.x;\n    return vec2(sdf, matId);\n}\n\nvec2 cylY(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.xz - c.xy) - c.z;\n    return vec2(sdf, matId);\n}\n\nvec2 cylZ(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.yz - c.yx) - c.y;\n    return vec2(sdf, matId);\n}\n\nmat2 rot(float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = iTime*.05 + 42.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        p.xy *= rot(.021*t);\n        \n        p = abs(p) + vec3(.02*cos(t*.21) + .31,\n                          .03*sin(t*.27) + 8.35,\n                          .04*sin(t*.37) + 120.37);\n        \n        p.yz *= rot(.013*t);\n    }\n    \n    return p;\n}\n\nvec2 crs(vec3 p, vec3 c, float matId)\n{\n    vec2 cylx = cylX(p, c, matId);\n    vec2 cyly = cylY(p, c, matId + 1.);\n    vec2 cylz = cylZ(p, c, matId + 2.);\n \n    float soft = .015;\n    vec2 sdf = smoothU(cylx, cyly, soft);\n    return smoothU(sdf, cylz, soft);\n}\n\nvec2 map(vec3 p)\n{   \n    p = 250. * sin(p/dot(p,p));\n    p = kif(p);\n    \n    float t = -iTime*.2 - 42.;\n    p = rep(p + t, 1.3);\n    \n    vec2 m = crs(p, vec3(.05), 1.);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 50.;\n\tvec2 h,t= vec2(.75);\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .01 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 ro = vec3(3.*sin(iTime*.25), -5.*cos(iTime*.25), 32.);\n    \n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos1 = ro;\n    vec3 lightPos2 = ro + 10.;\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos1 - hit);\n\n        vec2 eps = vec2(0., .05);\n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 45.);\n\n        vec3 col = vec3(0.);\n        col += .2 * diff;\n        col += vec3(1.) * spec;\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    {\n        vec3 wh = vec3(1.);\n        fragColor = vec4(.85); \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsffRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 156], [158, 158, 188, 188, 220], [222, 222, 262, 262, 333], [335, 335, 375, 375, 446], [448, 448, 488, 488, 559], [561, 561, 582, 582, 642], [644, 644, 662, 662, 991], [993, 993, 1032, 1032, 1253], [1255, 1255, 1273, 1273, 1442], [1444, 1444, 1471, 1471, 1697], [1699, 1699, 1756, 1756, 2973]], "test": "untested"}
{"id": "wdffRf", "name": "Fractal animation 2", "author": "jarble", "description": "Based on my previous [url=https://www.shadertoy.com/view/wdffzX]\"Fractal animation\"[/url] shader", "tags": ["fractal", "animation"], "likes": 1, "viewed": 293, "published": 3, "date": "1588738687", "time_retrieved": "2024-07-30T21:08:40.091174", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = cos(uv.yx*8.0);\n    for(float i = 1.0; i <6.0; i++){\n        uv += col.yx;\n        col.xy += cos(uv.xy*i+iTime);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdffRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 376]], "test": "untested"}
{"id": "wsXBRf", "name": "Simple DoF", "author": "42yeah", "description": "Learning dof from dissecting P_Malin's awesome Meta CRT code: https://frame.42yeah.casa/2020/05/02/dof.html", "tags": ["raymarching", "dof"], "likes": 18, "viewed": 761, "published": 3, "date": "1588732613", "time_retrieved": "2024-07-30T21:08:41.139372", "image_code": "#define PI 3.14159265\n\n// Random hash function\nvec2 rand2d(vec2 uv) {\n    return fract(sin(vec2(\n        dot(uv, vec2(215.1616, 82.1225)),\n        dot(uv, vec2(12.345, 856.125))\n    )) * 41234.45) * 2.0 - 1.0;\n}\n\n// Calculate CoC: https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch23.html\nfloat getCoC(float depth, float focalPlane) {\n    float focalLength = 0.1;\n    float aperture = min(1.0, focalPlane * focalPlane);\n    return abs(aperture * (focalLength * (focalPlane - depth)) /\n        (depth * (focalPlane - focalLength)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample original texture data at uv\n    vec4 texData = texture(iChannel0, uv);\n    \n    // Get its depth\n    float depth = texData.w;\n    \n    // Focal plane at 3.9 (the camera is looking at the center from ~4.0)\n    float focalPlane = 3.9;\n    \n    // Calculate CoC, see above\n    float coc = getCoC(depth, focalPlane);\n    \n    // Sample count\n    const int taps = 32;\n    \n    // Golden ratio: https://www.youtube.com/watch?v=sj8Sg8qnjOg\n    float golden = 3.141592 * (3.0 - sqrt(5.0));\n    \n    // Color & total weight\n    vec3 color = vec3(0.0);\n    float tot = 0.0;\n    \n    for (int i = 0; i < taps; i++) {\n        // Radius slowly increases as i increases, all the way up to coc\n        float radius = coc * sqrt(float(i) / float(taps));\n        \n        // Golden ratio sample offset\n        float theta = float(i) * golden;\n        vec2 tapUV = uv + sin(theta + vec2(0.0, PI / 2.0)) * radius;\n        \n        // Sample the bit over there\n        vec4 tapped = texture(iChannel0, tapUV);\n        float tappedDepth = tapped.w;\n\n        if (tappedDepth > 0.0) {\n            // Use CoC over there as weight\n            float tappedCoC = getCoC(tappedDepth, focalPlane);\n            float weight = max(0.001, tappedCoC);\n            \n            // Contribute to final color\n            color += tapped.rgb * weight;\n            // And final weight sum\n            tot += weight;\n        }\n    }\n    // And normalize the final color by final weight sum\n    color /= tot;\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// It's \"floor\" because floor is reserved keyword\nfloat sol(vec3 pos) {\n    return pos.y;\n}\n\n// Finite repetition: https://iquilezles.org/articles/distfunctions\nfloat cube(vec3 pos, vec3 off) {\n    vec3 c = vec3(3.0, 0.0, 3.0);\n    vec3 l = vec3(1.0);\n    pos = pos - c * clamp(floor(pos / c + 0.5), -l, l);\n    pos -= off;\n    vec3 d = abs(pos) - vec3(0.5);\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// Classic map from raymarching. I ripped it off from iq's fruxis: https://www.shadertoy.com/view/ldl3zl \nvec2 map(vec3 pos) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    // Ground\n    float dist = sol(pos);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    // Cubes\n    dist = cube(pos, vec3(0.0, 0.48, 0.0));\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    return vec2(closest, id);\n}\n\n// Raymarching\nvec2 trace(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 200; i++) {\n        vec2 info = map(ro + rd * depth);\n        if (abs(info.x) <= 0.001) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\n// Returns a grid like color\nvec3 getFloorColor(vec3 pos) {\n    pos *= 2.0;\n    vec3 baseColor = vec3(1.0, 1.0, 1.0);\n    vec3 f = mod(floor(pos), 2.0);\n    return baseColor * clamp(abs(f.x - f.z), 0.8, 1.0);\n}\n\n// Returns a slowly-turning-from-blue-to-white-as-ray-direction-increases color\nvec3 getSkyColor(vec3 rd) {\n    vec3 baseColor = vec3(0.69, 0.89, 0.99);\n    return mix(baseColor, vec3(1.0, 1.0, 1.0), clamp(rd.y * 4.6, 0.0, 1.0));\n}\n\n// General getColor function. You plug object id in, and get the respective object color\nvec3 getColor(float id, vec3 pos, vec3 rd) {\n    if (id < -0.5) { return getSkyColor(rd); } // sky\n    if (id < 1.0) { return getFloorColor(pos); } // ground\n    if (id < 2.0) { return vec3(1.0, 0.5, 0.0); }\n    return vec3(1.0, 0.0, 0.0); // red for undefined\n}\n\n// Estimate normal function\nvec3 getNormal(vec3 p) {\n    const float epsilon = 0.001;\n    float mapped = map(p).x;\n    return normalize(vec3(\n        mapped - map(vec3(p.x - epsilon, p.yz)).x,\n        mapped - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        mapped - map(vec3(p.x, p.y, p.z - epsilon)).x\n    ));\n}\n\n// Soft shadow calculation: https://iquilezles.org/articles/rmshadows\nfloat getShadowIntensity(vec3 ro, vec3 rd) {\n    float depth = 0.001;\n    float res = 1.0;\n    for (int i = 0; i < 25; i++) {\n        float dist = map(ro + rd * depth).x;\n        res = min(res, 20.0 * dist / depth);\n        if (res < 1e-6) { break; }\n        depth += clamp(dist, 0.001, 2.0);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Calculate ray direction\nvec3 getRd(vec3 ro, vec2 uv) {\n    vec3 center = vec3(0.0, 0.0, 0.0);\n\n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    \n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n    return rd;\n}\n\n// Get fragment color according to raymarched id, pos, etc.\nvec3 getFinalColor(float id, vec3 pos, vec3 n, vec3 rd, vec3 lightDir) {\n    float ambient = 1.0;\n    float diffuse = max(dot(n, lightDir), 0.0);\n    float dome = 0.2 + 0.8 * clamp(n.y, 0.0, 1.0);\n    float sol = 0.2 + 0.8 * clamp(-n.y, 0.0, 1.0);\n    float back = max(dot(n, vec3(-lightDir.x, 0.0, -lightDir.z)), 0.0);\n    float shadow = getShadowIntensity(pos + n * 1e-3, lightDir);\n\n    vec3 light = vec3(1.0);\n    if (id > 0.0) {\n        light = vec3(0.0);\n        light += ambient * vec3(0.2, 0.2, 0.2) * shadow;\n        light += diffuse * vec3(0.82, 0.80, 0.82) * shadow;\n        light += dome * vec3(0.26, 0.32, 0.334);\n        light += sol * vec3(0.3, 0.21, 0.23);\n        light += back * vec3(0.2, 0.21, 0.23);\n    }\n\n    vec3 objColor = getColor(id, pos, rd) * light;\n    return objColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    // Ray origin\n    vec3 ro = vec3(4.0 * sin(iTime * 1.0), 1.5, 4.0 * cos(iTime * 1.0));\n    \n    // Ray direction\n    vec3 rd = getRd(ro, uv);\n    \n    // Raymarch. info.x is depth, and info.y is object id\n    vec2 info = trace(ro, rd);\n    vec3 pos = ro + rd * info.x;\n    vec3 n = getNormal(pos);\n\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n\n    // Get final color & apply gamma correction\n    vec3 color = getFinalColor(info.y, pos, n, rd, lightDir);\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, info.x);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 47, 69, 69, 211], [213, 306, 351, 351, 550], [553, 553, 610, 660, 2224]], "test": "untested"}
{"id": "wdffzX", "name": "Fractal animation", "author": "jarble", "description": "This is a very simple fractal formula.", "tags": ["fractal"], "likes": 2, "viewed": 309, "published": 3, "date": "1588727607", "time_retrieved": "2024-07-30T21:08:42.197542", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = cos(uv.yx*(8.0));\n    for(float i = 1.0; i <5.0; i++){\n        uv /= col.yx;\n        col.xy = sin(uv.xy+iTime);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdffzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 375]], "test": "untested"}
{"id": "WsXBzS", "name": "Demoscene museum", "author": "friol", "description": "A strange museum with strange objects. Ticket is 50$.", "tags": ["metaballs", "refraction", "plasma", "demoscene"], "likes": 19, "viewed": 1070, "published": 3, "date": "1588718200", "time_retrieved": "2024-07-30T21:08:43.263692", "image_code": "\n//\n// friol 2o2o\n// Now that the demoscene is cultural heritage of humanity (at least in Finland)\n// I imagined how a demoscene museum would look like and what would would you find in there\n// sdf functions&ao by iq\n// plasma cube inspiration from patu https://www.shadertoy.com/view/4d3SRN\n// some materials taken from https://www.shadertoy.com/view/WslfD7\n// music by Salidad -> https://soundcloud.com/salidad\n//\n\nconst int iterationAmount=1024*3;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdAmigahSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdInvertedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return -length(max(q,0.0)) - min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTwistingBox( vec3 p, vec3 b, float r )\n{\n\tp=rotx(p,2.0*sin(iTime)*sin(.92*p.x+iTime/2.0));\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlasmaCube( vec3 p, vec3 b, vec3 shift )\n{\n  p=rotx(p,iTime);\n  p=roty(p,iTime);\n  p+=shift;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  p=roty(p,iTime+3.141592/2.0);\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n//#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\n#define FK(k) int(cos(k))*int(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat noise(vec2 p) \n{\n    vec2 id = floor(p);\n    vec2 crds = fract(p);\n    float h1 = hash(id.x,id.y);\n    float h2 = hash(id.x+1.,id.y);\n    float h3 = hash(id.x,id.y+1.);\n    float h4 = hash(id.x+1.,id.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nfloat triplanar(vec3 p, vec3 n) \n{\n    return mix(noise(p.xy), mix(noise(p.xz), noise(p.yz), n.x*n.x), 1.-n.z*n.z);\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//\n//\n//\n\nfloat mapBin(vec3 r)\n{\n    //r*=1.55;\n\tfloat mainCone=sdCappedCone(r-vec3(0.0,-0.4,0.0),.6,  0.5,0.7);\n    float innerCone=sdCappedCone(r-vec3(0.0,-0.25,0.0),.55,0.45,0.65);\n    float t=opSubtraction(innerCone,mainCone);\n    //float t=100.0;\n    \n    vec3 capsr=r;\n    \n    const float PI=3.141592;\n    const float TWOPI=PI*2.0;\n    for (float i=0.0;i<TWOPI;i+=PI/18.0)\n    {\n        vec3 realcapsr=roty(capsr,i);\n    \trealcapsr=rotz(realcapsr,-0.15);\n        float caps=sdVerticalCapsule(realcapsr-vec3(0.60,-0.63,0.0),0.9,0.06);\n        t=opSubtraction(caps,t);\n        //t=min(t,caps);\n    }\n\n    return t;\n}\n\nfloat mapDemosceneLogo(vec3 r)\n{\n    //r*=1.55;\n    float t=10000.0;\n    \n    r=rotx(r,0.25);\n    r=rotz(r,-0.5);\n    \n    float spessore=0.05;\n    \n    float horz1=sdBox(r-vec3(0.0,0.85,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz1);\n    float horz2=sdBox(r-vec3(0.0,0.6,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz2);\n    float horz3=sdBox(r-vec3(0.0,0.35,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz3);\n    \n    float vertleft=sdBox(r-vec3(-0.25,0.80,0.0),vec3(spessore,0.25,spessore));\n    t=min(t,vertleft);\n    float vertright=sdBox(r-vec3(0.25,0.80,0.0),vec3(spessore,0.25,spessore));\n    t=min(t,vertright);\n    float vertcenter=sdBox(r-vec3(0.0,0.25,0.0),vec3(spessore,0.3,spessore));\n    t=min(t,vertcenter);\n    \n    return t;\n}\n\n// returns: t, material, hit type (0.0 solid, 1.0 transparent)\n\nvec3 SDF(vec3 r)\n{\n    float amt=9.0; // bump amount on glass panels\n    float t=0.0;\n    float mat=0.0;\n    vec3 origR=r;\n\n    vec3 boxR=r-vec3(0.0,0.0,0.0);\n    t=sdInvertedBox(boxR,vec3(4.0,2.5,35.0));\n    \n    //float domainRep=3.7;\n    //vec3 c=vec3(domainRep);\n    //r = mod(r+0.5*c,c)-0.5*c;\n    \n    // little boxes+balls at the entrance\n    float pyrh=1.1;\n    float pyr1=sdBox(r-vec3(3.0,-2.5,-5.0),vec3(.55,0.25,0.55));\n    t=min(t,pyr1);\n    \n    float pyr2=sdBox(r-vec3(-3.0,-2.5,-5.0),vec3(.55,0.25,0.55));\n    t=min(t,pyr2);\n\n    float container1=sdRoundBox(r-vec3(3.0,-1.7,-5.0),vec3(.5,.5,.5),0.1);\n    float innerBox1=sdBox(r-vec3(3.0,-1.7,-5.0),vec3(.49));\n    container1=opSubtraction(innerBox1,container1);\n    t=min(t,container1);\n\n    float container2=sdRoundBox(r-vec3(-3.0,-1.7,-5.0),vec3(.5,.5,.5),0.1);\n    float innerBox2=sdBox(r-vec3(-3.0,-1.7,-5.0),vec3(.49));\n    container2=opSubtraction(innerBox2,container2);\n    t=min(t,container2);\n    \n    float amigaball1=sdAmigahSphere(r-vec3(3.0,-1.7+0.05*sin(iTime*2.0),-5.0),0.45);\n    t=min(t,amigaball1);\n\n    float amigaball2=sdAmigahSphere(r-vec3(-3.0,-1.7+0.05*sin(iTime*2.0),-5.0),0.45);\n    t=min(t,amigaball2);\n    \n    // metaballs\n    \n    float mbz=11.0;\n    float mbally=0.0;\n    if (iTime>32.0) mbally=(iTime-32.0)/2.5;\n    \n    float backS=sdSphere(r-vec3(1.7*sin(iTime),-.7*sin(iTime)+mbally,mbz),.76);\n    backS+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n\n    float backS2=sdSphere(r-vec3(-1.0*cos(iTime),-.1+mbally,mbz),.86);\n    backS2+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n\n    float backS3=sdSphere(r-vec3(-1.0*sin(iTime),-.7*cos(iTime)+mbally,mbz),.76);\n    backS3+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n    \n    float metaballs=opSmoothUnion(opSmoothUnion(backS,backS2,0.5),backS3,0.5);\n    t=min(t,metaballs);\n    \n    // twisting block\n    vec3 tbr=r;\n    float tblockpos=.5;\n\n    float spikeAmt=6.0;\n    float tblocky=0.0;\n    if (iTime>25.0) tblocky=1.5*sin((iTime-25.0)/2.3);\n    float tblock=sdTwistingBox(tbr-vec3(iTime/4.0,tblocky,2.0+tblockpos),vec3(17.0,.87,.87),0.1);\n    tblock+=(.12)*sin(r.x*spikeAmt)*(.52*sin(r.y*spikeAmt))*(.52*cos(r.z*spikeAmt));\n    t=min(t,tblock);\n\n    float trashbin=10000.0;\n    float merlogo=10000.0;\n    \n    if (iTime>24.0)\n    {        \n        // biiin\n        float binx=3.2;\n        float binz=14.5;\n        trashbin=mapBin(r-vec3(binx,-1.5,binz));\n        t=min(t,trashbin);\n        // random demoscene logo\n        merlogo=mapDemosceneLogo(r-vec3(binx-0.21,-1.7,binz-0.1));\n        t=min(t,merlogo);\n    }\n    \n    // cyboman's torus (not really)\n    vec3 rottor=r;\n    float cybotorus=sdTorus(rottor-vec3(0.0,-.5,21.0),vec2(1.5,.5));\n    cybotorus+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,cybotorus);\n    \n    // plasmacube from 2nd reality\n    float cubeZ=27.0;\n    float cubeBase=sdBox(r-vec3(0.0,-1.96,cubeZ),vec3(1.35,1.07,1.35));\n    t=min(t,cubeBase);\n    \n    vec3 rcubed=r;\n    float cubeSide=0.52;\n    \n    //float innerCube=sdBox(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),vec3(cubeSide-0.1,cubeSide-0.1,cubeSide-0.1));\n    \n    float sideProf=0.32;\n    float pcube0=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,cubeSide,sideProf),\n                              vec3(0.0,0.0,-cubeSide/2.5));\n    float pcube1=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,cubeSide,sideProf),\n                              vec3(0.0,0.0,cubeSide/2.5));\n    float pcube2=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,sideProf,cubeSide),\n                              vec3(0.0,cubeSide/2.5,0.0));\n    float pcube3=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,sideProf,cubeSide),\n                              vec3(0.0,-cubeSide/2.5,0.0));\n    float pcube4=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(sideProf,cubeSide,cubeSide),\n                              vec3(-cubeSide/2.5,0.0,0.0));\n    float pcube5=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(sideProf,cubeSide,cubeSide),\n                              vec3(cubeSide/2.5,0.0,0.0));\n    t=min(t,pcube0);\n    t=min(t,pcube1);\n    t=min(t,pcube2);\n    t=min(t,pcube3);\n    t=min(t,pcube4);\n    t=min(t,pcube5);\n\n    float container3=sdRoundBox(r-vec3(0.0,-0.1,cubeZ),vec3(1.25,1.25,1.25),0.1);\n    float innerBox3=sdBox(r-vec3(0.0,-0.1,cubeZ),vec3(1.15,1.15,1.15));\n    container3=opSubtraction(innerBox3,container3);\n    t=min(t,container3);\n    //float container3=1000.0;\n    \n    //\n    // glass panels\n    //\n\n    float boxxpos=3.0;\n    float glass0z=0.0;\n    if (iTime>11.0) boxxpos+=iTime-11.0;\n    float rbox=sdRoundBox(r-vec3(boxxpos,-0.1,glass0z),vec3(3.0,4.6,0.1),0.1);\n    rbox+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox);\n\n    float rbox2=sdRoundBox(r-vec3(-boxxpos,-0.1,glass0z),vec3(3.0,4.6,0.1),0.1);\n    rbox2+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox2);\n\n    float boxxpos2=3.0;\n    float glass1z=8.0;\n    if (iTime>26.5) boxxpos2+=iTime-26.5;\n    float rbox3=sdRoundBox(r-vec3(boxxpos2,-0.1,glass1z),vec3(3.0,4.6,0.1),0.1);\n    rbox3+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox3);\n\n    float rbox4=sdRoundBox(r-vec3(-boxxpos2,-0.1,glass1z),vec3(3.0,4.6,0.1),0.1);\n    rbox4+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox4);\n\n    float boxxpos3=3.0;\n    float glass2z=16.0;\n    if (iTime>36.0) boxxpos3+=iTime-36.0;\n    float rbox5=sdRoundBox(r-vec3(boxxpos3,-0.1,glass2z),vec3(3.0,4.6,0.1),0.1);\n    rbox5+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox5);\n\n    float rbox6=sdRoundBox(r-vec3(-boxxpos3,-0.1,glass2z),vec3(3.0,4.6,0.1),0.1);\n    rbox6+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox6);\n\n    float boxxpos4=3.0;\n    float glass3z=25.0;\n    if (iTime>44.0) boxxpos4+=iTime-44.0;\n    float rbox7=sdRoundBox(r-vec3(boxxpos4,-0.1,glass3z),vec3(3.0,4.6,0.1),0.1);\n    rbox7+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox7);\n\n    float rbox8=sdRoundBox(r-vec3(-boxxpos4,-0.1,glass3z),vec3(3.0,4.6,0.1),0.1);\n    rbox8+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox8);\n    \n    // calc materials\n    \n    if (t==metaballs) return vec3(t,2.0,0.0);\n    if (t==tblock) return vec3(t,3.0,0.0);\n    if ((t==container1)||(t==container2)||(t==container3)) return vec3(t,7.0,1.0);\n    if ((t==rbox)||(t==rbox2)||(t==rbox3)||(t==rbox4)||(t==rbox5)||(t==rbox6)||(t==rbox7)||(t==rbox8)) return vec3(t,0.0,1.0);\n    if ((t==pyr1)||(t==pyr2)||(t==cubeBase)) return vec3(t,5.0,0.0);\n    if ((t==amigaball1)||(t==amigaball2)) return vec3(t,6.0,0.0);\n    if (t==cybotorus) return vec3(t,4.0,0.0);\n    if ((t==pcube0)||(t==pcube1)) return vec3(t,8.0,0.0);\n    if ((t==pcube2)||(t==pcube3)) return vec3(t,8.1,0.0);\n    if ((t==pcube4)||(t==pcube5)) return vec3(t,8.2,0.0);\n    if (t==trashbin) return vec3(t,9.0,0.0);\n    if (t==merlogo) return vec3(t,10.0,0.0);\n    \n    return vec3(t,1.0,0.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float h )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    pos.y+=h;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = SDF( aopos )[0];\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDF(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t=0.0;\n    float trasp=0.0;\n    bool refrakkted=false;\n    vec3 rd=rayDir;\n    for (int i=0;i<iterationAmount;i++)\n    {\n        vec3 res = SDF(rayOrigin + rd * t);\n        if (res[0] < (0.0001*t))\n        {\n            if (res[2]==0.0)\n            {\n            \treturn vec4(t,res[1],trasp,0.0);\n            }\n            else\n            {\n                if (!refrakkted)\n                {\n                    vec3 hitNorm=calcNormal(rayOrigin+rd*t);\n                    vec3 newdir;\n                    if (res[1]==7.0) newdir=rd; // don't refract the thecas\n                    else newdir=refract(rd,hitNorm,0.90);\n                    rd=newdir;\n                    trasp=t;\n                    refrakkted=true;\n                }\n            }\n        }\n\n        if (!refrakkted) t+=res[0];\n        else t += 0.02;\n    }\n    \n    return vec4(-1.0,-1.0,-1.0,-1.0);\n}\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    const float FOG_DENSITY = 0.06;\n    vec3 FOG_COLOR = fxcol.xyz;\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\nvec3 srgb(float r) {\n    return vec3(r*r);\n}\n\nvec4 cubePlasma (vec2 coord, vec3 p, int ptype) \n{\n    float \n        k = iTime * 3.0,\n        as = 4.78207464329,\n    \tfd = 12.18910931609,\n    \tas1 = 2.839499561581 / 24.0 + sin(k) * 0.02,\n    \tfd2 = 2.188989119604,\n    \tps = -5.624243766069,\n    \tps2 = 9.393007904291,\n    \tp1 = sin(k / ps) * 4.0,\n    \tp2 = sin(k / fd) * 3.0,\n    \tt3 = sin(k / fd2) + cos(as1),\n        t4 = sin(k / ps);    \n    \n    float coordDivider=32.0;\n    coord.x = floor(coord.x * coordDivider) / coordDivider;\n    coord.y = floor(coord.y * coordDivider) / coordDivider;\n    \n    float x = sin(p1 + coord.x) * sin(p2 + coord.y) + sin(t3 + coord.x) * sin(t4 + coord.y) * -p.x;\n    \n    float r,g,b;\n    \n    if (ptype==0)\n    {\n        r = (0.01 );\n        g = (0.12 + sin(x / as1)) / 2.0; \n        b = (0.97 + sin(x / as1 )) + sin(coord.y / as1) / 4.0;\n    }\n    else if (ptype==1)\n    {\n        r = (0.81 + sin(x / as1)) / 2.0;\n        g = (0.51 + sin(x / as1)) / 2.0; \n        b = (0.37 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n    \t//r=pow(r,2.9);\n        r+=0.5;\n        g+=0.5;\n    \tg=pow(g,2.0);\n    \tb=pow(b,2.0);\n    }\n    else if (ptype==2)\n    {\n        r = (0.31 + sin(x / as1)) / 2.0;\n        g = (0.97 + sin(x / as1)) / 2.0; \n        b = (0.17 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n    \tr=pow(r,2.9);\n    \tg=pow(g,2.0);\n    \t//b=pow(b,2.0);\n    }\n\n    r=clamp(r,0.0,1.0);\n    g=clamp(g,0.0,1.0);\n    b=clamp(b,0.0,1.0);\n    vec4 color = vec4(vec3(r,g,b), 1.0);\n    return color;\n}\n\nvec4 boxmap( in vec3 p, in float k, int ptype ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = cubePlasma(p.yz, p,ptype);\n\tvec4 y = cubePlasma(p.zx, p,ptype);\n\tvec4 z = cubePlasma(p.xy, p,ptype);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(1.33,1.0,-1.0));\n\n    vec4 rayHit = castRay(rayOrigin, rayDir);\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    vec3 N=calcNormal(pHit);\n    float dotprod=abs(dot(N,L));\n\n    if (mat==1.0)\n    {\n        float occlHeight=1.6;\n        if (pHit.z<0.0) occlHeight=0.52; // amigahballs\n        if ((pHit.z>13.5)&&(pHit.z<15.0)) occlHeight=0.5; // bin\n        if (pHit.z>16.0) occlHeight=0.2; // cybomantorus\n        float occ = calcAO( pHit, vec3(0.0,1.0,0.0),occlHeight );\n\n        vec2 a=vec2(1.0);\n        if ((N.z>0.01)||(N.z<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.y, 1.)));\n        }\n        else if ((N.x>0.01)||(N.x<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.y, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n        }\n        else if ((N.y>0.01)||(N.y<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n        }\n        \n        float cenDist=distance(vec3(pHit.x,pHit.y,mod(pHit.z,6.0)),vec3(0.0,0.0,3.0));\n\n        if (pHit.z<0.0)\n        {\n            //if (iTime>4.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n            //else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n            col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n        }\n        else if ((pHit.z>=0.0)&&(pHit.z<8.0))\n        {\n            if (iTime>5.80) col = vec3(.7-a.x,.8-a.y,0.9-a.x);\n            else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else if ((pHit.z>=8.0)&&(pHit.z<16.0))\n        {\n            if (iTime>6.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n            else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else if ((pHit.z>=16.0)&&(pHit.z<25.0))\n        {\n        \tcol = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else\n        {\n            if (iTime>8.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n        \telse col =vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n\n        col+=vec3(1.0)/cenDist*1.25;\n        if (N.y>0.01) col=mix(col,vec3(occ),0.06);\n        //col=fog(col,distance(rayOrigin,pHit)/4.0,vec3(1.,1.,1.));\n    }\n    else if (mat==2.0) // metaballs\n    {\n        dotprod+=pow(dotprod,16.0);\n        col=vec3(.85,.5,.7)*dotprod;\n\n        vec3 oldcolor = col + (col * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        col = floor(oldcolor);    \n    }\n    else if (mat==3.0) // twisting block\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.,.05,.1), srgb(0.4,.3,1.), diff1) + pow(diff1, spexex)*1.5;\n        vec3 col2 = mix(srgb(0.1,.0,0.3), srgb(1.,.2,0.5), diff2) + pow(diff2, spexex)*1.5;\n        vec3 col3 = mix(srgb(0.33), srgb(0.2,0.9,1.), diff3) + pow(diff3, spexex)*2.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));  \n        \n        if (iTime<5.80) col*=vec3(0.25);\n    }\n    else if (mat==4.0) // rolling torus\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.2,.05,.1), srgb(0.24,.3,1.), diff1) + pow(diff1, spexex)*2.5;\n        vec3 col2 = mix(srgb(0.41,.0,0.3), srgb(0.5,.2,0.5), diff2) + pow(diff2, spexex)*2.5;\n        vec3 col3 = mix(srgb(0.33), srgb(0.02,0.3,1.), diff3) + pow(diff3, spexex)*3.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));        \n    }\n    else if (mat==5.0) // ball's base\n    {\n        float occ = calcAO( pHit, vec3(0.0,1.0,0.0),0.3);\n        col=vec3(.05,.05,.05)*dotprod;\n\t\tif (N.y>0.01) col=mix(col,vec3(occ),0.06);\n    }\n    else if (mat==6.0) // amigahballs\n    {\n    \tvec3 amigaLight=normalize(vec3(1.03,1.0,-1.0));;\n        if (pHit.x>0.0) amigaLight=normalize(vec3(-1.03,1.0,-1.0));;\n        \n        vec3 N2=roty(N,iTime);\n        vec2 matuv = vec2( atan(N2.x,N2.z), acos(N2.y ) );\n        vec2 qp = floor(matuv*2.51);\n        float intensity=mod(qp.x+qp.y,2.0);\n        if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n        else col=vec3(1.0);\n        float NoL = max(dot(N, amigaLight), 0.1);\n        col*=NoL;\n        col+=pow(NoL,32.0);\n\n        vec3 oldcolor = col + (col * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        col = floor(oldcolor);    \n    }\n    else if ((mat==8.0)||(mat==8.1)||(mat==8.2)) // plasmacube\n    {\n        // 2nd reality cube faces are \n        // red-yellow-black\n        // blue-white-black\n        // green-brown-black\n        \n        float cubeZ=28.0;\n        if (mat==8.0) col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,0).xyz;\n        else if (mat==8.1) col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,1).xyz;\n        else col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,2).xyz;\n        \n        //col=vec3(1.0,0.0,0.0);\n        col*=dotprod;\n    }\n    else if (mat==9.0) // trashbin\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.05,.05,.05), srgb(0.3,.3,.3), diff1) + pow(diff1, spexex)*1.5;\n        vec3 col2 = mix(srgb(0.1,.1,0.1), srgb(.2,.2,0.2), diff2) + pow(diff2, spexex)*1.5;\n        vec3 col3 = mix(srgb(0.43,0.43,0.43), srgb(0.82,0.82,0.82), diff3) + pow(diff3, spexex)*2.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));\n        col*=0.8;\n    }\n    else if (mat==10.0) // random demoscene logo\n    {\n        col=vec3(1.0,85.0/255.0,0.0)*dotprod;\n        col*=0.8;\n    }\n    else\n    {\n        col=vec3(0.0,1.0,0.0);\n    }\n    \n    if (rayHit[2]!=0.0)\n    {\n        vec3 tN=calcNormal(rayOrigin+rayDir*rayHit[2]);\n        float dotprod=max(dot(tN,L),0.0);\n        dotprod+=pow(dotprod,2.0);\n        col=mix(col,vec3(0.8,0.8,0.8)*dotprod,0.15);\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n    \n    //float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n\n    // opening fade in\n    if (iTime<10.4)\n    {\n        camPos=vec3(0.0,-1.8,-11.0+(iTime/11.0));\n        camTarget=vec3(0.0,0.0,-4.0+(iTime/11.0));\n    }\n    // panning right-left\n    else if ((iTime>=10.4)&&(iTime<20.0))\n    {\n        camPos=vec3(10.4-iTime/1.5,-1.6,-8.0);\n        camTarget=vec3(10.4-iTime/1.5,-1.6,-7.0);\n    }\n    // walkthrough\n    else if ((iTime>=20.0)&&(iTime<49.0))\n    {    \n        camPos=vec3(0.0,-0.1,-26.0+iTime);\n        camTarget=vec3(0.0,0.0,0.0+iTime);\n    }\n    else\n    {\n        camPos=vec3(0.0,-0.1,(-18.0+42.0)-(abs(.7*sin(iTime-49.0))));\n        camTarget=vec3(0.0,0.0,-18.0+42.0+2.0);\n    }\n    \n    //camPos=vec3(sin(iTime)*0.2,0.6,7.5);\n    //camTarget=vec3(0.0,0.0,9.0);\n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4(render(camPos, rayDir,uv,fragCoord).xyz,1.0);\n    \n    // fadein\n    if (iTime<2.001)\n    {\n        finalCol=vec4(mix(finalCol.xyz,vec3(0.0),(2.0-iTime)/2.0),1.0);\n    }\n    \n    // fadeout\n    if (iTime>55.0)\n    {\n        finalCol=vec4(mix(vec3(0.0),finalCol.xyz,clamp((59.0-iTime)/4.0,0.0,1.0)),1.0);\n    }\n\n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22476, "src": "https://soundcloud.com/salidad/salidad-white-day", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 496, 496, 518], [520, 520, 552, 552, 663], [665, 665, 696, 696, 807], [809, 809, 840, 840, 951], [953, 953, 1005, 1005, 1104], [1106, 1106, 1139, 1139, 1167], [1169, 1169, 1208, 1208, 1236], [1238, 1238, 1283, 1283, 1374], [1376, 1376, 1409, 1409, 1440], [1442, 1442, 1473, 1473, 1560], [1562, 1562, 1601, 1601, 1689], [1691, 1691, 1739, 1739, 1884], [1886, 1886, 1936, 1936, 2073], [2075, 2075, 2108, 2108, 2205], [2297, 2297, 2327, 2327, 2406], [2408, 2408, 2430, 2430, 2682], [2684, 2684, 2718, 2718, 2801], [2803, 2803, 2825, 2825, 2844], [2845, 2845, 2904, 2904, 3217], [3219, 3219, 3272, 3272, 3331], [3343, 3343, 3365, 3380, 3954], [3956, 3956, 3988, 4003, 4716], [4782, 4782, 4800, 4800, 11981], [11983, 11983, 12034, 12034, 12362], [12364, 12364, 12391, 12391, 12628], [12630, 12630, 12673, 12673, 13555], [13557, 13557, 13599, 13599, 13778], [13780, 13780, 13818, 13818, 13850], [13851, 13851, 13871, 13871, 13895], [13897, 13897, 13947, 13947, 15381], [15383, 15383, 15432, 15432, 15641], [15643, 15643, 15710, 15710, 22657], [22659, 22659, 22719, 22719, 23045], [23047, 23047, 23093, 23093, 23219], [23221, 23221, 23251, 23251, 23323], [23325, 23325, 23382, 23382, 24672]], "test": "untested"}
{"id": "WdXBzf", "name": "Rigid (ish) structure", "author": "Plento", "description": "Ok its not a real rigid body it actually acts more like IK bones. Try dragging the points around. Its easier to manipulate by turning on \"smallmode\" in common tab. Also try turning gravity off. (Reset to get a totally new structure!)", "tags": ["2d", "mouse", "particle"], "likes": 8, "viewed": 448, "published": 3, "date": "1588710961", "time_retrieved": "2024-07-30T21:08:44.127383", "image_code": "// Reset shader to get a new structure every time\nvec2 R;\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n\n    vec3 col = vec3(0);\n    vec4 bA = getA(u);\n    \n    for(int i = 0; i < nVerts; i++){\n        col.g += ss(vr, vr-2., length(u.xy - getA(ivec2(i, 0)).xy));\n        col.b += step(0.1,float(i))*ss(3., 1., line(u, getA(ivec2(i, 0)).xy, \n                                                    getA(ivec2(i-1, 0)).xy));\n    }\n    \n    col.rgb += 1.-step(FLOOR, u.y);\n    \n    f = vec4(col, 1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 R;\nbool th=false;\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    int id = int(u.x);\n    \n    if(id <= nVerts){\n    \tvec4 bA = getA(ivec2(id, 0));\n    \tvec4 bC = getC(ivec2(id, 0));\n        \n        vec4 s0 = getA(ivec2(id+1, 0)), s1 = getA(ivec2(id-1, 0));\n        vec2 dir = vec2(0), dir2 = vec2(0);\n        float dif = 0., dif2 = 0.;\n        \n        // difference between cuurent distance and initial distance is how far to move\n        if(id == 0){\n            dif = length(bA.xy-s0.xy) - bC.y;\n            dir = normalize(bA.xy-s0.xy);\n        }\n        else if(id == nVerts-1){\n            dif = length(bA.xy-s1.xy) - bC.x;\n            dir = normalize(bA.xy-s1.xy);\n        }\n        else{\n            dif = length(bA.xy-s0.xy) - bC.y;\n            dir = normalize(bA.xy-s0.xy);\n            dif2 = length(bA.xy-s1.xy) - bC.x;\n            dir2 = normalize(bA.xy-s1.xy);\n        }\n        \n        bA.zw -= (dif*dir.xy)*dt;\n        bA.zw -= (dif2*dir2.xy)*dt;\n        \n        if(bA.y-vr <= FLOOR){\n            bA.z = 0.;\n            th=true;\n        }\n        \n        bA.w -= g*dt;\n        \n        bA.y += bA.w*dt;\n        bA.x += bA.z*dt;\n        \n        bA.z -= bA.z*0.1;\n        bA.w -= bA.w*0.01;\n        \n       if(th) bA.y += abs(bA.y-vr - FLOOR);\n       \n        \n       if(iMouse.z > 0. && length(bA.xy - iMouse.xy) <= vr){\n        \tbA.xy = iMouse.xy;\n            bA.zw = vec2(0);\n    \t}\n        \n   \t\tif(iFrame == 0){\n            #ifdef smallmode\n            bA.xy = hash22(u + iDate.w)*R.xy * 0.5 + R.xy*0.25;\n            #else\n        \tbA.xy = hash22(u + iDate.w)*R.xy;\n            #endif\n            bA.zw = vec2(0.);\n   \t\t}\n        \n    \tf = bA;\n    }\n    else return;\n        \n    \n   \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n\n#define getA(id) texelFetch(iChannel0, ivec2(id), 0)\n#define getC(id) texelFetch(iChannel2, ivec2(id), 0)\n\n#define FLOOR iResolution.y / 32.\n\n// vertice screen radius\n#define vr 20.\n\n// lets you drag the joints around easier\n//#define smallmode\n\n// number of verts to connect to\nconst int nVerts = 28;\n\n// gravity stuff\nfloat g = 2.; \nfloat dt = 0.15;\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n", "buffer_c_code": "// Inital lengths to connected verts\nvoid mainImage( out vec4 f, in vec2 u ){\n    int id = int(u.x);\n    \n \tif(id <= nVerts){\n        vec4 bC = getC(ivec2(id, 0));\n        float d0 = bC.x, d1 = bC.y;\n        \n    \tif(iFrame == 0){\n            if(id == 0){\n                d0 = 0.;\n                d1 = length(getA(ivec2(id, 0)).xy - getA(ivec2(id+1, 0)).xy);\n            }\n            else if(id == nVerts){\n                d0 = length(getA(ivec2(id, 0)).xy - getA(ivec2(id-1, 0)).xy);\n                d1 = 0.;\n            }\n            else{\n                d0 = length(getA(ivec2(id, 0)).xy - getA(ivec2(id-1, 0)).xy);\n                d1 = length(getA(ivec2(id, 0)).xy - getA(ivec2(id+1, 0)).xy);\n            }\n    \t}\n        \n        f = vec4(d0, d1, 0., 0.);\n    }\n    else return;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 105, 105, 224], [226, 226, 266, 266, 688]], "test": "untested"}
{"id": "WdXfRX", "name": "rare bull", "author": "lomateron", "description": "bull face doesn't show in ANGLE, so change it to openGL in chrome://flags/\n\ntrying every equation combination possible to get fractals\nbut only posting the rare ones", "tags": ["fractal"], "likes": 3, "viewed": 331, "published": 3, "date": "1588691421", "time_retrieved": "2024-07-30T21:08:45.001047", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n         u = -u.yx - vec2(1.,.0);\n    vec2 v = u;\n         u = u/dot(u,u);\n    \n    float e = -2.;\n    float pi = 3.14159265359;\n\n    for(float i = 0.; i < 7.; ++i)\n    {\n        u = cos(u.y-vec2(.0,.5*pi))*exp(u.x);\n        u = cos(atan(u.y,u.x)*e-vec2(0.,pi*.5))*pow(length(u),e);\n        u+= v;\n    }\n    fragColor = exp(dot(u,u)*-vec4(.03,.04,.05,.05));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 475]], "test": "untested"}
{"id": "3dXfRX", "name": "2D FBM example", "author": "Nrx", "description": "Basic 2D FBM example in reply to [url=https://www.facebook.com/groups/IndieGameDevs/permalink/10156876829611573/]this Facebook post[/url].\nUse the mouse to zoom & pan.", "tags": ["fbm"], "likes": 3, "viewed": 455, "published": 3, "date": "1588690590", "time_retrieved": "2024-07-30T21:08:45.764007", "image_code": "// This is a very basic 2D FBM example in reply to this Facebook post:\n// https://www.facebook.com/groups/IndieGameDevs/permalink/10156876829611573/\n// Comment out line 26 to get a triangular look.\n\n#define SPEED\t\t0.2\n#define SCALE\t\t3.0\n#define WIDTH\t\t0.005\n#define DX\t\t\t0.001\n#define STAR_SIZE\t0.005\n\n// PRNG (1D)\nfloat rand (in float seed) {\n\treturn fract (sin (seed * 12.9898) * 137.5453);\n}\n\n// PRNG (2D)\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// Noise\nfloat noise (in float p) {\n\tfloat f = fract (p);\n//\tf = f * f * (3.0 - 2.0 * f); // Comment this to get a triangular look.\n\tp = floor (p);\n\treturn mix (rand (p), rand (p + 1.0), f);\n}\n\n// FBM\nfloat fbm (in float p) {\n\tp *= SCALE;\n\treturn (noise (p) + noise (p * 2.0) / 2.0 + noise (p * 4.0) / 4.0) / (1.0 + 1.0 / 2.0 + 1.0 / 4.0);\n}\n\n// Main\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Define the local coordinates\n\tvec2 uv = fragCoord / iResolution.y;\n\tuv.x -= iMouse.x / iResolution.y;\n\tuv *= 1.0 + iMouse.y / iResolution.y;\n\tuv.x += iTime * SPEED;\n\n\t// Call the FBM function to define the profile of the mountain\n\tfloat y = fbm (uv.x);\n\n\t// Compute the distance of the fragment to the mountain, to draw a nice line\n#ifdef DX\n\tfloat dy = (fbm (uv.x + DX) - fbm (uv.x - DX)) / (2.0 * DX);\n#else\n\tfloat dy = dFdx (y) / dFdx (uv.x);\n#endif\n\tfloat dist = abs (uv.y - y) / sqrt (1.0 + dy * dy);\n\tfloat mountain = smoothstep (WIDTH * 1.1, WIDTH, dist);\n\n\t// Add some (blocky) stars above the mountain\n\tfloat star = step (0.995, rand (floor (uv / STAR_SIZE)));\n\tstar *= step (y, uv.y) * step (WIDTH, dist);\n\n\t// Final color\n\tfragColor = vec4 (mountain + star, star, star, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 315, 343, 343, 394], [396, 409, 436, 436, 586], [588, 597, 623, 623, 780], [782, 789, 813, 813, 929], [931, 939, 995, 1028, 1788]], "test": "untested"}
{"id": "tdsfz2", "name": "rare flower", "author": "lomateron", "description": "a rare fractal\nclick to explore it", "tags": ["breathe"], "likes": 12, "viewed": 512, "published": 3, "date": "1588685895", "time_retrieved": "2024-07-30T21:08:46.514999", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n    float p = 1.+sin(iTime)*.05;\n    u *= p;\n    vec2 v = u;\n    vec2 m = vec2(.25,.6);  if(iMouse.z>0.)m=iMouse.xy/iResolution.xy;\n    float e = 16.*m.x-8.;\n    for(float i = 0.; i < 8.*m.y; ++i)\n    {\n        u = sin(atan(u.y,u.x)*e+vec2(0.,pi*.5))*pow(length(u),e*.6);\n        u+= v/p;\n    }\n    fragColor = vec4(exp(dot(u,u)*-.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 483]], "test": "untested"}
{"id": "wssBz2", "name": "Practica 2Arnau Aguilar i Marc S", "author": "arnauaguilaremanuel", "description": "practica shaders Arnau Aguilar i Marc Solis", "tags": ["enti"], "likes": 1, "viewed": 223, "published": 3, "date": "1588685324", "time_retrieved": "2024-07-30T21:08:47.616055", "image_code": "#ifndef CFG_NO_POSTPROD\n\nconst float kToneMapA =.15;\nconst float kToneMapB =.50;\nconst float kToneMapC =.10;\nconst float kToneMapD =.20;\nconst float kToneMapE =.02;\nconst float kToneMapF =.30;\nconst float kToneMapW =2.0;\n\n//  Operador de Tonemapping \"Filmic\".\n//\tEntradas:\tx - Color en el espacio RGB HDR.\n//\tSalida:\t\tColor resultante en el espacio RGB LDR.\nvec4 tonemap(vec4 x)\n{\n   return ( (x * (kToneMapA * x + kToneMapC * kToneMapB) + kToneMapD * kToneMapE)  /\n            (x * (kToneMapA * x + kToneMapB            ) + kToneMapD * kToneMapF)) -\n            kToneMapE / kToneMapF;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv  = fragCoord.xy / iResolution.xy;\n    vec2 qv  = uv * 2. - 1.;\n    vec4 col = texture(iChannel0, uv);\n\tcol = tonemap(col) / tonemap(kToneMapW + .05 * textureLod(iChannel0, vec2(.5), 9.)); // Tonemapping.\n    col = col* (1./ pow(1. + pow(sqrt(dot(qv, qv)) * .3, 3.), 150.)); // Vignetting.\n    col = pow(col, vec4(1./2.2)); // Corrección Gamma.    \n\n    fragColor = col;\n}\n#else\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n#endif//CFG_NO_POSTPROD", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//==============================================================================\n//\tFUNCIONES DE DISTANCIA\n//==============================================================================\n\n//\tPrimitivas de ejemplo.\n//\tOtras primitivas disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://www.pouet.net/topic.php?which=7931&page=1\nfloat sdPlaneY(vec3 p) { return p.y; }\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdBox   (vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//\tOperadores de ejemplo.\n//\tOtros operadores disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://mercury.sexy/hg_sdf/\nfloat opUnion       (float d1, float d2) { return min( d1, d2); }\nfloat opIntersection(float d1, float d2) { return max( d1, d2); }\nfloat opSubstraction(float d1, float d2) { return max(-d1, d2); }\nvec3  opRepetition  (vec3 pos, vec3 frq) { return mod(pos, frq) - 0.5 * frq; } \n\n//  Smooth minimum (polynomial smin())\n//  Ver https://iquilezles.org/articles/smin para más información.\nfloat opBlend(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n//==============================================================================\n//\tESCENA\n//==============================================================================\n\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2 mapScene(vec3 pos)\n{\n    float t = iTime * 2.;\n    vec2  a = vec2(kFarPlaneDist, 0), b = a;\n    \n    // Creamos una caja para contener la escena.\n    b = vec2(opSubstraction(sdBox(pos, vec3(10)), sdBox(pos, vec3(100))), 0); MIN(a, b);\n    \n\t// Calculamos la distancia a 3 esferas unidas entre ellas de forma suave, una centrada y dos orbitando alrededor.\n\tfloat p0= opBlend(sdSphere(pos, 1.), sdSphere(pos + 2. * vec3(sin(t*.11), cos(t*.24), cos(t*.33)), 1.), 0.5);\n    p0 = opBlend(p0, sdSphere(pos + 1.5 * vec3(cos(t*.21), cos(t*.23), sin(t*.45)), 1.), 0.5);\n\n    // Restamos a dichas esferas un dominio de repetición de cubos en XY e YZ.\n    float p1= sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(5, 5, .015));\n    p1 = opUnion(p1, sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(.015, 5, 5)));\n\tb  = vec2(opIntersection(p0, p1), 1); MIN(a, b);\n    \n\treturn a;\n}\n\n//==============================================================================\n//\tTRAZADO DE RAYOS\n//==============================================================================\n\n//\tcastRay() traza un rayo con origen en \"ro\" en dirección \"rd\" desde el plano cercano kNearPlaneDist \n//  hasta encontrar una superficie contra la que chocar o hasta superar la distancia del plano lejano kFarPlaneDist.\n//\tEl rayo se mueve en pasos discretos hasta un máximo de kMaxSteps (lo que sirve para determinar la precisión).\n//\tEl rayo se desplaza a lo largo de un dominio de distancia: dada una posición en mundo (la del rayo), preguntamos\n//\ta la función mapScene(), que representa la escena, cuál es la distancia al objeto más cercano. Avanzamos entonces\n//\ten la dirección del rayo dicha distancia, y volvemos a preguntar hasta que se dé alguna de las condiciones\n//\tanteriormente indicadas.\n//\tEntradas:\tro - Origen del rayo.\n//\t\t\t\trd - Dirección del rayo.\n//\tSalida:\t\tvec4(totalDistance, lastStepDistance, materialID, steps). \n#ifndef CFG_USING_ENHANCED_RAYMARCHING\nvec4 castRay(vec3 ro, vec3 rd)\n{\n    float  t   = kNearPlaneDist;\n    vec2   res = vec2(kFarPlaneDist, 0);\n    int    i   = 0;\n    for (; i < kMaxSteps; ++i)\n    {\n\t    res    = mapScene(ro + rd * t);\n        if ((res.x < kEpsilon) || (t > kFarPlaneDist))\n            break;\n        t += res.x;\n    }\n    return vec4(t, res.xy, i);\n}\n#else// CFG_USING_ENHANCED_RAYMARCHING\nvec2  gTexelSize  ; // Pixel size   (screen domain).\nfloat gTexelRadius; // Pixel radius (screen domain).\n\nvec4 castRay(vec3 ro, vec3 rd)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n    \n    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;\n    vec2  res = vec2(kFarPlaneDist, 0);\n\tint   i   = kMaxSteps;\n    for (; (i >= 0) && (t < kFarPlaneDist); --i)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {//\tError detectado, deja de aplicar la optimización \"over-relaxation raymarching\".\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {// Actualiza el error.\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break; // Aplica \"screen-space aware intersection point selection\".\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, kMaxSteps - i);\n}\n#endif//CFG_USING_ENHANCED_RAYMARCHING\n\n//==============================================================================\n//\tUTILIDADES\n//==============================================================================\n\n//\tCalcula el sombreado para la superficie. Para ello, traza un rayo desde la superficie hasta la luz, y determina\n//\tsi es posible llegar hasta la luz sin encontrar otra superficie antes. Si es posible llegar hasta la luz, el\n//\tpunto estará iluminado. En caso contrario, el punto estará sombreado.\n//\tAdemás, para cada paso del rayo computa la distancia mínima al objeto más cercano y utiliza ese valor para calcular\n//\tla penumbra.\n//\tMás información sobre el algoritmo en https://iquilezles.org/articles/rmshadows\n//\tEntradas:\tro   - Posición en mundo de la superficie.\n//\t\t\t\trd   - Dirección desde \"ro\" hasta la luz para la cual queremos calcular el sombreado.\n//\t\t\t\ttmin - Distancia desde \"ro\" hasta el inicio del rayo (evita arterfactos por precisión de flotante).\n//\t\t\t\ttmax - Distancia entre \"ro\" y la luz (permite descartar cuando llegamos a la luz).\n//\t\t\t\tk    - Factor de penumbra (cuanto más mayor, la sombra es más dura).\n//\tSalida: \tFactor de sombreado (0 para sombreado, 1 para iluminado, valores intermedios representan penumbra).\n#ifndef\tCFG_NO_SHADOWS\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float ph  = 1e20;\n    for( float t = tmin; t < tmax;)\n    {\n        float h = mapScene(ro + rd*t).x;\n        if( h < 0.001)\n            return 0.;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h - y*y);\n        res = min(res, k*d / max(0.0,t - y));\n        ph  = h;\n        t  += h;\n    }\n    return res;\n}\n#else\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) { return 1.0; }\n#endif//CFG_NO_SHADOWS\n\n//\tCalcula la oclusión ambiental de la superficie. Para ello, muestrea a distintas distancias desde la posición en \n//\tmundo para la superficie, y calcula la oclusión ambiental aplicando un filtro de paso bajo: los valores de\n//  distancia obtenidos más cercanos a la superficie tienen más peso, y a medida que nos alejamos tienen menos.\n//\tEl proceso que se sigue es el siguiente:\n//\t\t- Para cada iteración, calcula una posición en mundo alejada de la superficie 1/N del total de muestras.\n//\t\t- Calcula la distancia desde esa posición a la superficie más cercana.\n//\t\t- Cuanto más cercana sea esa distancia a la distancia original entre la superficie de entrada y la calculada\n//\t\t  en la iteración actual, menos oclusión hay.\n//\tEntradas:\tpos\t- Posición en mundo para la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\tSalida:\t\tFactor de oclusión (0 para totalmente ocluido, 1 para totalmente visible).\n#ifndef CFG_NO_AO\nfloat computeAO(vec3 pos, vec3 nor)\n{\n\tfloat  occ = 0.0;\n    float  sca = 1.0;\n    for( int i = 0; i < 5; ++i)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3  aopos = nor * hr + pos;\n        float dd = mapScene(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);    \n}\n#else\nfloat computeAO(vec3 pos, vec3 nor) { return 1.0; }\n#endif//CFG_NO_AO\n\n//  Calcula la normal de la superficie en \"pos\" mediante derivación del gradiente de la función de distancia.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\tSalida:\t\tVector normal de la superficie.\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(kEpsilon, 0, 0);\n\treturn normalize(vec3(mapScene(pos + epsilon.xyy).x - mapScene(pos - epsilon.xyy).x, mapScene(pos + epsilon.yxy).x - mapScene(pos - epsilon.yxy).x, \n        mapScene(pos + epsilon.yyx).x - mapScene(pos - epsilon.yyx).x));\n}\n\n//\tcomputeCameraMatrix() calcula la matriz de cámara.\n//\tEntradas:\tro - Posición de la cámara (eye).\n//\t\t\t\tta - Posición en mundo a la que mira la cámara (lookAt).\n//\t\t\t\tcr - Rotación del vector front, de 0 a 2*π radianes.\n//\tSalida:\t\tMatriz de cámara.\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n\n\n\n\n//==============================================================================\n//\tENTRYPOINT\n//==============================================================================\n\n//  Función principal.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Coordenadas UV en el rango [0,1].\n\tvec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // Coordenadas UV en el rango [0,1] con Aspect Ratio aplicado.\n    \n    vec3 pos, nor, col; // Posición, normal, color.\n    vec4 res; // Resultados del trazado de rayos.\n\n\t// Configura la cámara.\n    vec3 ro = vec3(sin(iTime * .35) * (4. + sin(iTime)), 1, cos(iTime * .35) * (3. + cos(iTime)));\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    \n    // Traza el rayo y calcula la posición en mundo de la superficie impactada.\n    res = castRay(ro, rd);\n    pos = ro + rd * res.x;    \n    \n#\tifdef   CFG_USING_DISCONTINUITY_REDUCTION\n  \t// Aplica la optimización \"discontinuity reduction\" para mejorar la adaptación del espacio esférico al de pantalla.\n    float coneSize  = tan(kPi / 6.) / (iResolution.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {\n        pos    -= rd *    (error - mapScene(pos).x);\n        error   = coneSize * length(ro  - pos);\n    }\n#\tendif//\tCFG_USING_DISCONTINUITY_REDUCTION\n\n    // Calcula la normal.\n    nor = computeNormal(pos);\n    \n#   ifdef   CFG_SHOW_WORLDPOS\n    col = pos;\n#   endif// CFG_SHOW_WORLDPOS\n\n#   ifdef   CFG_SHOW_NORMALS\n    col = nor;\n#   endif// CFG_SHOW_NORMALS\n\n#   ifdef   CFG_SHOW_STEPS\n    col = mix(vec3(0, 1, 0), vec3(1, 0, 0), res.w / float(kMaxSteps));\n#   endif// CFG_SHOW_STEPS\n\n#   ifdef   CFG_SHOW_DISTANCE\n    col = vec3(res.x / (kFarPlaneDist - kNearPlaneDist));\n#   endif// CFG_SHOW_DISTANCE\n    \n    \n    float a = (kFarPlaneDist + kNearPlaneDist) / (kFarPlaneDist - kNearPlaneDist);\n \tfloat b = 2.0 * kFarPlaneDist * kNearPlaneDist / (kFarPlaneDist - kNearPlaneDist);\n \tfloat depth = a + b /-length(ro - pos);\n\n\n    vec3 viewSpaceNormal = inverse(ca) * nor;\n    vec2 np = viewSpaceNormal.xy* 0.5 + 0.5;\n    \n    vec3 reconstructedVSN = vec3(np.xy * 2. - 1., 0.);\n\treconstructedVSN.z =-sqrt(1. - dot(reconstructedVSN.xy, reconstructedVSN.xy));\n\n    vec3 reconstructedWSN = ca * reconstructedVSN;\n\n    \n    fragColor = vec4(np,depth,int(res.z));\n    //fragColor = vec4(reconstructedWSN, 1.0); \n    //fragColor = vec4(viewSpaceNormal, 1.0);\n    //agColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "//==============================================================================\n//\tFUNCIONES DE DISTANCIA\n//==============================================================================\n\n//\tPrimitivas de ejemplo.\n//\tOtras primitivas disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://www.pouet.net/topic.php?which=7931&page=1\nfloat sdPlaneY(vec3 p) { return p.y; }\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdBox   (vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//\tOperadores de ejemplo.\n//\tOtros operadores disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://mercury.sexy/hg_sdf/\nfloat opUnion       (float d1, float d2) { return min( d1, d2); }\nfloat opIntersection(float d1, float d2) { return max( d1, d2); }\nfloat opSubstraction(float d1, float d2) { return max(-d1, d2); }\nvec3  opRepetition  (vec3 pos, vec3 frq) { return mod(pos, frq) - 0.5 * frq; } \n\n//  Smooth minimum (polynomial smin())\n//  Ver https://iquilezles.org/articles/smin para más información.\nfloat opBlend(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n//==============================================================================\n//\tESCENA\n//==============================================================================\n\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2 mapScene(vec3 pos)\n{\n    float t = iTime * 2.;\n    vec2  a = vec2(kFarPlaneDist, 0), b = a;\n    \n    // Creamos una caja para contener la escena.\n    b = vec2(opSubstraction(sdBox(pos, vec3(10)), sdBox(pos, vec3(100))), 0); MIN(a, b);\n    \n\t// Calculamos la distancia a 3 esferas unidas entre ellas de forma suave, una centrada y dos orbitando alrededor.\n\tfloat p0= opBlend(sdSphere(pos, 1.), sdSphere(pos + 2. * vec3(sin(t*.11), cos(t*.24), cos(t*.33)), 1.), 0.5);\n    p0 = opBlend(p0, sdSphere(pos + 1.5 * vec3(cos(t*.21), cos(t*.23), sin(t*.45)), 1.), 0.5);\n\n    // Restamos a dichas esferas un dominio de repetición de cubos en XY e YZ.\n    float p1= sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(5, 5, .015));\n    p1 = opUnion(p1, sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(.015, 5, 5)));\n\tb  = vec2(opIntersection(p0, p1), 1); MIN(a, b);\n    \n\treturn a;\n}\n\n//==============================================================================\n//\tTRAZADO DE RAYOS\n//==============================================================================\n\n//\tcastRay() traza un rayo con origen en \"ro\" en dirección \"rd\" desde el plano cercano kNearPlaneDist \n//  hasta encontrar una superficie contra la que chocar o hasta superar la distancia del plano lejano kFarPlaneDist.\n//\tEl rayo se mueve en pasos discretos hasta un máximo de kMaxSteps (lo que sirve para determinar la precisión).\n//\tEl rayo se desplaza a lo largo de un dominio de distancia: dada una posición en mundo (la del rayo), preguntamos\n//\ta la función mapScene(), que representa la escena, cuál es la distancia al objeto más cercano. Avanzamos entonces\n//\ten la dirección del rayo dicha distancia, y volvemos a preguntar hasta que se dé alguna de las condiciones\n//\tanteriormente indicadas.\n//\tEntradas:\tro - Origen del rayo.\n//\t\t\t\trd - Dirección del rayo.\n//\tSalida:\t\tvec4(totalDistance, lastStepDistance, materialID, steps). \n#ifndef CFG_USING_ENHANCED_RAYMARCHING\nvec4 castRay(vec3 ro, vec3 rd)\n{\n    float  t   = kNearPlaneDist;\n    vec2   res = vec2(kFarPlaneDist, 0);\n    int    i   = 0;\n    for (; i < kMaxSteps; ++i)\n    {\n\t    res    = mapScene(ro + rd * t);\n        if ((res.x < kEpsilon) || (t > kFarPlaneDist))\n            break;\n        t += res.x;\n    }\n    return vec4(t, res.xy, i);\n}\n#else// CFG_USING_ENHANCED_RAYMARCHING\nvec2  gTexelSize  ; // Pixel size   (screen domain).\nfloat gTexelRadius; // Pixel radius (screen domain).\n\nvec4 castRay(vec3 ro, vec3 rd)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n    \n    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;\n    vec2  res = vec2(kFarPlaneDist, 0);\n\tint   i   = kMaxSteps;\n    for (; (i >= 0) && (t < kFarPlaneDist); --i)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {//\tError detectado, deja de aplicar la optimización \"over-relaxation raymarching\".\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {// Actualiza el error.\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break; // Aplica \"screen-space aware intersection point selection\".\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, kMaxSteps - i);\n}\n#endif//CFG_USING_ENHANCED_RAYMARCHING\n\n//==============================================================================\n//\tUTILIDADES\n//==============================================================================\n\n//\tCalcula el sombreado para la superficie. Para ello, traza un rayo desde la superficie hasta la luz, y determina\n//\tsi es posible llegar hasta la luz sin encontrar otra superficie antes. Si es posible llegar hasta la luz, el\n//\tpunto estará iluminado. En caso contrario, el punto estará sombreado.\n//\tAdemás, para cada paso del rayo computa la distancia mínima al objeto más cercano y utiliza ese valor para calcular\n//\tla penumbra.\n//\tMás información sobre el algoritmo en https://iquilezles.org/articles/rmshadows\n//\tEntradas:\tro   - Posición en mundo de la superficie.\n//\t\t\t\trd   - Dirección desde \"ro\" hasta la luz para la cual queremos calcular el sombreado.\n//\t\t\t\ttmin - Distancia desde \"ro\" hasta el inicio del rayo (evita arterfactos por precisión de flotante).\n//\t\t\t\ttmax - Distancia entre \"ro\" y la luz (permite descartar cuando llegamos a la luz).\n//\t\t\t\tk    - Factor de penumbra (cuanto más mayor, la sombra es más dura).\n//\tSalida: \tFactor de sombreado (0 para sombreado, 1 para iluminado, valores intermedios representan penumbra).\n#ifndef\tCFG_NO_SHADOWS\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float ph  = 1e20;\n    for( float t = tmin; t < tmax;)\n    {\n        float h = mapScene(ro + rd*t).x;\n        if( h < 0.001)\n            return 0.;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h - y*y);\n        res = min(res, k*d / max(0.0,t - y));\n        ph  = h;\n        t  += h;\n    }\n    return res;\n}\n#else\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) { return 1.0; }\n#endif//CFG_NO_SHADOWS\n\n//\tCalcula la oclusión ambiental de la superficie. Para ello, muestrea a distintas distancias desde la posición en \n//\tmundo para la superficie, y calcula la oclusión ambiental aplicando un filtro de paso bajo: los valores de\n//  distancia obtenidos más cercanos a la superficie tienen más peso, y a medida que nos alejamos tienen menos.\n//\tEl proceso que se sigue es el siguiente:\n//\t\t- Para cada iteración, calcula una posición en mundo alejada de la superficie 1/N del total de muestras.\n//\t\t- Calcula la distancia desde esa posición a la superficie más cercana.\n//\t\t- Cuanto más cercana sea esa distancia a la distancia original entre la superficie de entrada y la calculada\n//\t\t  en la iteración actual, menos oclusión hay.\n//\tEntradas:\tpos\t- Posición en mundo para la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\tSalida:\t\tFactor de oclusión (0 para totalmente ocluido, 1 para totalmente visible).\n#ifndef CFG_NO_AO\nfloat computeAO(vec3 pos, vec3 nor)\n{\n\tfloat  occ = 0.0;\n    float  sca = 1.0;\n    for( int i = 0; i < 5; ++i)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3  aopos = nor * hr + pos;\n        float dd = mapScene(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);    \n}\n#else\nfloat computeAO(vec3 pos, vec3 nor) { return 1.0; }\n#endif//CFG_NO_AO\n\n//  Calcula la normal de la superficie en \"pos\" mediante derivación del gradiente de la función de distancia.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\tSalida:\t\tVector normal de la superficie.\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(kEpsilon, 0, 0);\n\treturn normalize(vec3(mapScene(pos + epsilon.xyy).x - mapScene(pos - epsilon.xyy).x, mapScene(pos + epsilon.yxy).x - mapScene(pos - epsilon.yxy).x, \n        mapScene(pos + epsilon.yyx).x - mapScene(pos - epsilon.yyx).x));\n}\n\n//\tcomputeCameraMatrix() calcula la matriz de cámara.\n//\tEntradas:\tro - Posición de la cámara (eye).\n//\t\t\t\tta - Posición en mundo a la que mira la cámara (lookAt).\n//\t\t\t\tcr - Rotación del vector front, de 0 a 2*π radianes.\n//\tSalida:\t\tMatriz de cámara.\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n//\tMateriales, luces y colores.\nvec3[] gMaterials  = vec3[](vec3(1, 0, 0), vec3( 1, 1,.9));\nvec3[] gLightPos   = vec3[](vec3(4, 4, 4), vec3(-4, 4,-4));\nvec3[] gLightCol   = vec3[](vec3(1,.9,.5), vec3(.5,.9, 1));\nvec3   gAmbientCol = vec3(.1,.2,.3);\n\n\n\n//==============================================================================\n//\tENTRYPOINT\n//==============================================================================\n\n//  Función principal.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Coordenadas UV en el rango [0,1].\n\tvec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // Coordenadas UV en el rango [0,1] con Aspect Ratio aplicado.\n    \n    vec3 pos, nor; // Posición, normal, color.\n    vec4 res; // Resultados del trazado de rayos.\n\n\t// Configura la cámara.\n    vec3 ro = vec3(sin(iTime * .35) * (4. + sin(iTime)), 1, cos(iTime * .35) * (3. + cos(iTime)));\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    \n    // Traza el rayo y calcula la posición en mundo de la superficie impactada.\n    res = castRay(ro, rd);\n    pos = ro + rd * res.x;    \n    \n#\tifdef   CFG_USING_DISCONTINUITY_REDUCTION\n  \t// Aplica la optimización \"discontinuity reduction\" para mejorar la adaptación del espacio esférico al de pantalla.\n    float coneSize  = tan(kPi / 6.) / (iResolution.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {\n        pos    -= rd *    (error - mapScene(pos).x);\n        error   = coneSize * length(ro  - pos);\n    }\n#\tendif//\tCFG_USING_DISCONTINUITY_REDUCTION\n\n    // Calcula la normal.\n    nor = computeNormal(pos);\n    \n    // Para cada luz, computa la el sombreado.\n    float shadow = 0.;\n    for (int i = 0; i < gLightPos.length(); ++i)\n    {\n\t\tshadow += computeSoftShadow(pos, normalize(gLightPos[i] - pos), .025, length(gLightPos[i] - pos), 25.);\n    }\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    float AO = computeAO(pos, nor);\n    \n#   ifdef   CFG_SHOW_WORLDPOS\n    col = pos;\n#   endif// CFG_SHOW_WORLDPOS\n\n#   ifdef   CFG_SHOW_NORMALS\n    col = nor;\n#   endif// CFG_SHOW_NORMALS\n\n#   ifdef   CFG_SHOW_STEPS\n    col = mix(vec3(0, 1, 0), vec3(1, 0, 0), res.w / float(kMaxSteps));\n#   endif// CFG_SHOW_STEPS\n\n#   ifdef   CFG_SHOW_DISTANCE\n    col = vec3(res.x / (kFarPlaneDist - kNearPlaneDist));\n#   endif// CFG_SHOW_DISTANCE\n    \n    fragColor = vec4(shadow, AO,0.,0.);\n}", "buffer_b_inputs": [], "common_code": "//==============================================================================\n//\tCONFIGURACIÓN\n//==============================================================================\n\n//\tCFG_USING_ENHANCED_RAYMARCHING utiliza una versión mejorada del algoritmo de trazado de rayos, que implementa\n//\tlas optimizaciones \"over-relaxation raymarching\" y \"screen-space aware intersection point selection\" descritas en\n//\tel paper \"Enhanced Sphere Tracing\" de Benjamin Kelinert et al. (http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf).\n\t#define CFG_USING_ENHANCED_RAYMARCHING\n\n//  CFG_USING_DISCONTINUITY_REDUCTION corrige el patrón esférico derivado de la discontinuidad entre el espacio de\n//\tpantalla (proyección 2D) y el espacio de mundo (posición del rayo y distancia a la superficie). Dicha discontinuidad\n//  aparece debido a la proyección del espacio esférico (que tiene profundidad) en el espacio de pantalla.\n//\tEl algoritmo está descrito en el mismo paper \"Enhanced Sphere Tracing\" indicado anteriormente.\n  \t#define CFG_USING_DISCONTINUITY_REDUCTION\n\n//#define CFG_SHOW_WORLDPOS\t// Descomentar para mostrar posiciones en mundo.\n//#define CFG_SHOW_NORMALS\t// Descomentar para mostrar normales.\n//#define CFG_SHOW_STEPS\t// Descomentar para mostrar pasos del Raymarcher.\n//#define CFG_SHOW_DISTANCE\t// Descomentar para mostrar distancias.\n//#define CFG_NO_SHADOWS    // Descomentar para desactivar las sombras.\n//#define CFG_NO_AO         // Descomentar para desactivar la oclusión ambiental.\n//#define CFG_NO_POSTPROD\t// Descomentar para desactivar los FX de post-producción.\n\nconst float kNearPlaneDist =   0.1;\t// Distancia al plano cercano.\nconst float kFarPlaneDist  =  50.0;\t// Distancia al plano lejano.\nconst float kEpsilon       = 0.001;\t// Valor de epsilon para comparaciones de distancia.\nconst float kPi\t\t\t   = 3.14159265359;\nconst int   kMaxSteps      =    64;\t// Número máximo de pasos del trazado de rayos.\nconst int   kMaxLightSteps =    16; // Número máximo de pasos del trazado de rayos de iluminación. ", "buffer_c_code": "//#ifndef CFG_NO_POSTPROD\n//\tFXAA (autor: Mudlord).\n\nvec3[] gMaterials  = vec3[](vec3(1, 0, 0), vec3( 1, 1,.9)); \nvec3[] gLightPos   = vec3[](vec3(4, 4, 4), vec3(-4, 4,-4));\nvec3[] gLightCol   = vec3[](vec3(1,.9,.5), vec3(.5,.9, 1));\nvec3   gAmbientCol = vec3(.1,.2,.3);\n\nvec3 computeShading(vec3 pos, vec3 nor, vec3 viewVector, int matID, int lightID)\n{\n\tvec3  col = vec3(0), halfVec  = normalize(-viewVector + normalize(gLightPos[lightID] - pos));\n\tcol = col + gLightCol[lightID] * gMaterials[matID] * clamp(dot(nor, normalize(gLightPos[lightID] - pos)), 0., 1.); // Cálculo de difusa.\n\tcol = col + gLightCol[lightID] * pow(clamp(dot(nor, halfVec), 0., 1.), 5.); // Cálculo de especular.\n\treturn \tcol;\n}\n\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    //agColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    vec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // Coordenadas UV en el rango [0,1] con Aspect Ratio aplicado.\n    vec2  pp        = 1.0 / iResolution.xy;\n    vec4  data     = texture(iChannel0, vec2(fragCoord.xy * pp));\n    \n    vec4  extraData     = texture(iChannel1, vec2(fragCoord.xy * pp));\n    \n    vec4  color     = vec4(gMaterials[int(data.a)],1);\n    float  depth     = data.b;\n    \n    vec3 ro = vec3(sin(iTime * .35) * (4. + sin(iTime)), 1, cos(iTime * .35) * (3. + cos(iTime)));\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    \n    \n    float a = (kFarPlaneDist + kNearPlaneDist) / (kFarPlaneDist - kNearPlaneDist);\n \tfloat b = 2.0 * kFarPlaneDist * kNearPlaneDist / (kFarPlaneDist - kNearPlaneDist);   \n    vec3 surfaceWorldPos = ro + rd *(b / (a - depth));\n    \n    vec2 np = data.xy;\n    \n    vec3 reconstructedVSN = vec3(np.xy * 2. - 1., 0.);\n\treconstructedVSN.z =-sqrt(1. - dot(reconstructedVSN.xy, reconstructedVSN.xy));\n\n    vec3 reconstructedWSN = ca * reconstructedVSN;\n    //color = vec4(reconstructedWSN,0);\n    \n    vec3 finalColor;\n     // Para cada luz, computa la iluminación y el sombreado.\n    for (int i = 0; i < gLightPos.length(); ++i)\n    {\n\t\tfinalColor+= computeShading(surfaceWorldPos, reconstructedWSN, rd, int(data.a), i) * clamp(extraData.x,0.,1.);// * computeSoftShadow(pos, normalize(gLightPos[i] - pos), .025, length(gLightPos[i] - pos), 25.);\n    }\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    finalColor = finalColor + gAmbientCol * gMaterials[int(data.a)] * mix(extraData.y, 1., dot(finalColor, W));\n    \n    \n#   ifdef   CFG_SHOW_WORLDPOS\n    finalColor = surfaceWorldPos;\n#   endif// CFG_SHOW_WORLDPOS\n\n#   ifdef   CFG_SHOW_NORMALS\n    finalColor = reconstructedWSN;\n#   endif// CFG_SHOW_NORMALS\n\n#   ifdef   CFG_SHOW_DISTANCE\n    finalColor = vec3(depth);\n#   endif// CFG_SHOW_DISTANCE\n    \n    \n\tfragColor = vec4(finalColor,1);\n    \n    \n\n}\n\n//#else\n//void mainImage(out vec4 fragColor, vec2 fragCoord)\n//{\n//    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n//}\n//#endif//CFG_NO_POSTPROD", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#ifndef CFG_NO_POSTPROD\n//\tFXAA (autor: Mudlord).\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2  p         = fragCoord.xy/iResolution.xy;\n    vec2  pp        = 1.0 / iResolution.xy;\n    vec4  color     = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3  luma      = vec3(0.299, 0.587, 0.114);\n    float lumaNW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.,-1.)) * pp).xyz, luma);\n    float lumaNE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1.,-1.)) * pp).xyz, luma);\n    float lumaSW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1., 1.)) * pp).xyz, luma);\n    float lumaSE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1., 1.)) * pp).xyz, luma);\n    float lumaM     = dot(color.xyz, luma);\n    float lumaMin   = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax   = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2  dir       = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * (1.0/8.0)), (1.0/128.0));\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0), max(vec2(-8.0, -8.0), dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1. / 3. -.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2. / 3. -.5)).xyz\n    );\n    vec3 rgbB = rgbA * 0.5 + 0.25 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir *-.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * .5).xyz\n    );\n\n    float lumaB = dot(rgbB, luma);\n    fragColor = vec4((lumaB < lumaMin) || (lumaB > lumaMax) ? rgbA : rgbB, color.w);\n}\n#else\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n#endif//CFG_NO_POSTPROD", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wdlBR2", "name": "Raytracing a Cone", "author": "mla", "description": "Ray-surface intersection for a cone or other quadric requires solving a quadratic equation and numeric errors can occur. One type, noticeable here at the cone apex, is fixable by moving the ray origin closer to the surface.", "tags": ["raytracing", "quadric", "cone", "quadratic", "hyperboloid"], "likes": 6, "viewed": 466, "published": 3, "date": "1588674498", "time_retrieved": "2024-07-30T21:08:48.448828", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Ray tracing a cone, showing effect of rounding errors on quadratic solution.\n// See https://www.shadertoy.com/view/WdXfR2 for similar problems with sphere.\n//\n// Errors are particularly pronounced at cone apex, even at smaller distances,\n// can be significantly reduced by moving the projection point closer to the\n// surface (compare LHS of image with RHS, zoom in with 'z').\n//\n// Despite shader name, it also does hyperboloids and spheres (illustrating\n// another, possibly GPU dependent, source of numeric error).\n//\n// Matthew Arcus, mla, 2020.\n//\n// <mouse>: rotate cone\n// b: background\n// c: clip cone\n// h: hyperboloid\n// q: quality\n// x: sphere\n// z: extra zoom in\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nint quality = 0;\n\n// NB: This solves Ax^2 + 2Bx + C = 0 (with factor of 2 on B)\nbool quadratic(float A, float B, float C, out vec2 t) {\n  // Sometimes should also check for A = 0 or C = 0\n  float D = B*B-A*C;\n  if (D < 0.0) return false;\n  float x,y;\n  if (true) {\n    // The wrong way, but doesn't seem to cause problems\n    // with this shader.\n    x = (-B-sqrt(D))/A;\n    y = (-B+sqrt(D))/A;\n  } else {\n    // The right way\n    x = B <= 0.0 ? -B-sqrt(D) : -B+sqrt(D);\n    y = C/x;\n    x /= A;\n  }\n  // Return solutions in order\n  t = x < y ? vec2(x,y) : vec2(y,x);\n  return true;\n}\n\nbool dohyperboloid = false;\nbool doclip = true;\nbool dosphere = true;\n\nint checkcone(vec3 p) {\n  float height = dohyperboloid ? 2.0 : 1.0;//exp(iTime);\n  if (doclip && abs(p.y) > height) return 0;\n  float N = 16.0;\n  float i = floor(N*(atan(p.z,p.x))/PI);\n  float j = floor(N*p.y/height);\n  return int(mod(i+j,2.0));\n}\n\nint intersectcone(vec3 p, vec3 r, out vec3 n) {\n  float k = 0.0;\n  if (quality == 1) {\n    // Move projection point to be orthogonal to cone apex.\n    k = -dot(p,r); p += k*r;\n  }\n  // Quadric equation is: (p*X).p = 0\n  // So solve: ((p+tr)*X).(p+tr) = 0\n  vec3 X = dosphere ? vec3(1) : vec3(1,-1,1);\n  // Since r is normalized, can take a shortcut for a sphere.\n  float A = dosphere ? 1.0 : dot(r*X,r);\n  float B = dot(p*X,r);\n  float C = dot(p*X,p);\n  if (dosphere) C -= 1.0;\n  else if (dohyperboloid) C += sin(0.2*iTime);// Hyperboloid\n  vec2 t;\n  if (!quadratic(A,B,C,t)) return 0;\n  int type;\n  vec3 q;\n#if 0\n  // Do people prefer assignments in conditionals,\n  if (!(t.x+k >= 0.0 && (type = checkcone(q = p+t.x*r)) != 0) &&\n      !(t.y+k >= 0.0 && (type = checkcone(q = p+t.y*r)) != 0)) {\n    return 0;\n  }\n#elif 0\n  // or using a one-iteration loop and break/return?\n  for(;;) {\n    if (t.x+k >= 0.0) {\n      q = p+t.x*r;\n      type = checkcone(q);\n      if (type != 0) break;\n    }\n    if (t.y+k >= 0.0) {\n      q = p+t.y*r;\n      type = checkcone(q);\n      if (type != 0) break;\n    }\n    return 0;\n#else\n  // Or just this?\n  type = 0;\n  if (t.x+k >= 0.0) {\n     q = p+t.x*r;\n     type = checkcone(q);\n  }\n  if (type == 0 && t.y+k >= 0.0) {\n     q = p+t.y*r;\n     type = checkcone(q);\n  }\n  if (type == 0) return 0;\n#endif\n  \n  n = normalize(q*X);\n  if (dot(n,r) > 0.0) n = -n;\n  return type;\n}\n\nint intersectscene(vec3 p, vec3 r, out vec3 n) {\n  return intersectcone(p,r,n);\n}\n\nvec3 getcolor(vec3 p) {\n  return abs(p);\n}\n\nvec3 raycolor(vec3 p, vec3 r, vec3 light) {\n  vec3 n;\n  int type = intersectscene(p,r,n);\n  if (type == 0) {\n    return vec3(0);\n  } else {\n    float ambient = 0.3;\n    float diffuse = 0.3;\n    vec3 basecolor = getcolor(n);\n    if (type == 2) basecolor *= 0.8;\n    vec3 color = basecolor*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r)),5.0);\n    //vec3 speccol = vec3(1);\n    vec3 speccol = basecolor;\n    color += 0.5*specular*speccol;\n    return color;\n  }\n}\n\nvec2 rotate(vec2 p, float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (true) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n    p.xy = rotate(p.xy,iTime * 0.125);\n  }\n  return p;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_H = 72;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dohyperboloid = key(CHAR_H);\n  dosphere = key(CHAR_X);\n  doclip = !key(CHAR_C);\n  vec3 light = vec3(0.5,1.0,-1.0);\n  light = transform(light);\n  light = normalize(light);\n  float camera = 1.0;\n  float t = iTime;\n  t = mod(t,20.0);\n  camera *= exp(t);\n  vec3 p = vec3(0,0,-camera);\n  p = transform(p);\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      if (key(CHAR_Z)) uv *= 0.1; \n      vec3 r = vec3(uv,camera);\n      r = normalize(r);\n      r = transform(r);\n      if (uv.y < 0.0) r = normalize(r); // Normalize after transform\n      if (uv.x < 0.0 || key(CHAR_Q)) quality = 1;\n      vec3 c = raycolor(p,r,light);\n      if (c == vec3(0) && key(CHAR_B)) c = pow(texture(iChannel0,uv).xyz,vec3(2.2));\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[894, 956, 1011, 1063, 1460], [1533, 1533, 1556, 1556, 1780]], "test": "untested"}
{"id": "tslfRj", "name": "Diving Gold", "author": "butadiene", "description": "practice", "tags": ["rauymarching"], "likes": 4, "viewed": 355, "published": 3, "date": "1588659193", "time_retrieved": "2024-07-30T21:08:49.397292", "image_code": "mat2 rot (float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat cube(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nvec2 pmod(vec2 p,float n){\n  float np = 3.141592*2./n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r  =mod(r,np)-0.5*np;\n  return length(p)*vec2(cos(r),sin(r));\n}\n\nfloat dist2(vec3 p){\n    float k = 0.5;\n    p.y += 0.1*sin(p.z*5.+iTime);\n    p.xy *= rot(p.z*0.1);\n    p.z += -iTime;\n    \n    \n    p = mod(p,k)-0.5*k;\n    float d;\n    vec2 c = vec2(max(0.,length(p.xy)-0.0),max(abs(p.z)-0.04,0.));\n    d = length(c);\n\treturn d;\n}\n\nfloat dist(vec3 p){\n    p.z += iTime;\n    for(int i = 0;i<6;i++){\n    float si = step(mod(iTime,6.),float(i));\n    p.xy = mix(p.xy,p.xy*rot(0.3+step(0.6,fract(iTime))),si);\n    p.yz = mix(p.yz,p.yz*rot(0.2+step(0.3,fract(iTime))),si);\n    p = abs(p)-0.2;\n  }\n\n  p.xy = pmod(p.xy,6.);\n  \n  p.x -= 0.6;\n  float k = 0.8;\n  p = mod(p,k)-0.5*k;\n \n  float s = 0.2-0.03;\n  float d2 = cube(p,vec3(10.,0.05,0.05));\n  float d3 = cube(p,vec3(0.05,0.05,10.));\n  float d4 = cube(p,vec3(0.05,10.,0.05));\n  return min(cube(p,vec3(0.2,0.2,s)),min(min(d2,d3),d4));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  float s = 0.1;\n  vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.y,r.x);\n  p *= rot(iTime);\n  float radius = 0.1;\n  float rkt = iTime*0.2;\n  vec3 ro = vec3(cos(rkt)*radius,0.,sin(rkt)*radius);\n  vec3 ta = vec3(0.,0.,0.);\n  vec3 cdir = normalize(ta-ro);\n  vec3 side = cross(cdir,vec3(0.,1.,0.));\n  vec3 up = cross(side,cdir);\n  float fov = 0.4;\n  vec3 rd = normalize(p.x*side+p.y*up+cdir*fov);\n  float d,t=0.5;\n  float ac = 0.;\n  float ac2 = 0.;\n  for(int i = 0;i<76;i++){\n    d = dist(ro+rd*t);\n    float d2 = dist2(ro+rd*t);\n    ac += exp(abs(d)*-.2)*step(d,d2);\n    ac2 += 0.03/abs(d2)*step(d2,d);\n      d = min(d,d2);\n      if(d<0.001) break;\n    t+=d;\n  }\n  vec3 col = vec3(0.);;\n   col +=0.05*ac*vec3(1.0,0.5,0.1);\n      col +=.1*ac2*vec3(1.,1.,1.);\n  float near = 0.;\n  float far = 7.;\n  vec3 fcol = vec3(0.3,0.3,0.3);\n  col = mix(fcol,col,clamp((far-t)/(far-near),0.0,1.0));\n  float suv = 0.96;\n  uv = (uv-0.5)*suv+0.5;\n  vec2 sd = vec2(0.002,0.);\n \n  col = clamp(col,0.,1.);\n \n \n    col *= 1.5;\n    fragColor=vec4(col,1);\n  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 66], [68, 68, 94, 94, 191], [193, 193, 219, 219, 347], [349, 349, 369, 369, 613], [615, 615, 634, 634, 1164], [1167, 1167, 1223, 1223, 2303]], "test": "untested"}
{"id": "tsXBz2", "name": "Metronome", "author": "blepfo", "description": "tick", "tags": ["fractal", "kifs"], "likes": 4, "viewed": 280, "published": 3, "date": "1588653507", "time_retrieved": "2024-07-30T21:08:50.372684", "image_code": "// Toggle to view different elements of the scene\n// 1 - Menger Kifs\n// 2 - Sierpinski Kifs\n// 3 - Combined Menger+Sierpinski Kifs\n// 4 - Tiled\n#define VIEW_LAYER 3\n\n\n#define PI (3.141)\n#define MAX_ITERATIONS (16)\n#define ITERATIONS 10\n\n\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\n\nfloat circSdf(vec2 uv, float r) {\n    return length(uv) - r;\n}\n\n\nvec2 fold(vec2 uv, float theta) {\n    vec2 normal = vec2(cos(-theta), sin(-theta));\n    float d = dot(uv, normal);\n    return uv - (2. * min(0., d) * normal);\n}\n\n\nvec2 sierpinskiKifs(vec2 uv, int N) {\n    uv -= vec2(-0.5, 0.);\n    for(int i = 0; i < 12; i++) {\n        if (i >= N) { break; }\n        uv *= 2.;\n        uv.x -= 1.5;\n        \n        float animationSpeed = 0.5;\n        //float iTime = 4.072;\n        // Oscillate between (PI / 6) and (PI / 2)\n        float animatedAngle = ((cos(iTime*animationSpeed) + 1.) / 2.) * ((PI / 2.) - (PI / 6.)) + (PI / 6.);\n        uv = fold(uv, animatedAngle);\n    \tuv = fold(uv, -PI/6.);\n    }\n    return uv;\n}\n\n\nvec2 mengerKifs(vec2 uv, int N) {\n    for(int i = 0; i < 12; i++) {\n        if (i >= N) { break; }\n        uv *= 3.;  \n        uv.x = abs(uv.x);\n        uv.y = abs(uv.y);\n        uv = fold(uv, 0.33 * PI);\n        uv.x -= 1.*sqrt(2.);\n        uv = fold(uv, 0.33 * PI);\n        uv.x -= 1.*sqrt(2.);\n    }\n    return uv;\n}\n\n\n// Menger Kifs\nfloat viewLayerMenger(vec2 uv) {\n    //return vec3(1.);\n    uv *= 2.;\n    vec2 mengerUv = mengerKifs(uv, ITERATIONS);\n    float cSdf = circSdf(mengerUv, 1.);\n    float pixelSize = (2. * pow(3., float(ITERATIONS))) / iResolution.x;\n    float c = smoothstep(2.*pixelSize, 0., cSdf);\n    return c;\n}\n\n\n// Sierpinski Kifs\nfloat viewLayerSierpinski(vec2 uv) {\n    uv.x += 0.2;\n    uv *= rotate2d(PI / 6.);\n    vec2 sierpinskiUv = sierpinskiKifs(uv, ITERATIONS+2);\n    float cSdf = circSdf(sierpinskiUv, 1.);\n    float pixelSize = (2. * pow(3., float(ITERATIONS))) / iResolution.x;\n    float c = smoothstep(2.*pixelSize, 0., cSdf);\n    return c;\n}\n\n// Menger+Sierpinski\nfloat viewLayerMerge(vec2 uv) {\n    uv.x += 0.2;\n    uv *= rotate2d(PI / 6.);\n    vec2 hybridUv = sierpinskiKifs(uv, ITERATIONS);\n    hybridUv = mengerKifs(hybridUv, ITERATIONS);\n    float cSdf = circSdf(hybridUv, 1.);\n    float pixelSize = (1. * (pow(3., float(ITERATIONS)) * pow(2., float(ITERATIONS)))) / iResolution.x;\n    float c = smoothstep(2.*pixelSize, 0., cSdf);\n    return c;\n}\n\n\n// Tiled Menger + Sierpinski\nfloat viewLayerTiling(vec2 uv) {\n    float globalScale = 2.000;\n    uv *= globalScale;\n    uv *= rotate2d(PI / 2.);\n    vec2 tileIdx = floor(uv);\n    float flipSign = (2.*mod(floor(tileIdx.y), 2.)) - 1.;\n    uv = fract(uv);\n    uv.y *= flipSign ;\n    uv += vec2(-0.7, -0.5 * flipSign);\n    uv.y += -0.04;\n    uv *= -rotate2d(PI / 6.);\n    vec2 hybridUv = sierpinskiKifs(uv, ITERATIONS);\n    hybridUv = mengerKifs(hybridUv, ITERATIONS);\n    float cSdf = circSdf(hybridUv, 1.);\n    float pixelSize = (2. * globalScale * pow(3., float(ITERATIONS+1))) / iResolution.x;\n    float c = smoothstep(2.*pixelSize, 0., cSdf);\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1.5;\n    \n    float globalScale = 1.;\n    uv *= globalScale;\n    \n    float c = 0.;\n    if (VIEW_LAYER == 1) {\n        c = viewLayerMenger(uv);\n    } else if (VIEW_LAYER == 2) {\n        c = viewLayerSierpinski(uv);\n    } else if (VIEW_LAYER == 3) {\n        c = viewLayerMerge(uv);\n    } else if (VIEW_LAYER == 4) {\n        c = viewLayerTiling(uv);\n    } else {\n        c = 0.;\n    }\n    \n    vec3 color = vec3(0.165,0.123,0.130);\n    color = mix(color, vec3(0.750,0.909,0.975), c);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 266, 266, 350], [353, 353, 386, 386, 415], [418, 418, 451, 451, 578], [581, 581, 618, 618, 1073], [1076, 1076, 1109, 1109, 1395], [1398, 1413, 1445, 1468, 1709], [1712, 1731, 1767, 1767, 2054], [2056, 2077, 2108, 2108, 2465], [2468, 2497, 2529, 2529, 3127], [3130, 3130, 3187, 3187, 3814]], "test": "untested"}
{"id": "WsXcWn", "name": "Non-Euclidean world", "author": "tmst", "description": "- The layout comes from tracing a polyhedron's geodesics; pillars are at its vertices\n- Tall pillars: pos curvature (270° around); arch pillars: neg curvature (450° around)\n- The \"laser\" and camera path follow one closed geodesic\n- Inputs: Mouse, S, D, F", "tags": ["portal", "laser", "ssao", "curvature", "noneuclidean", "geodesic"], "likes": 112, "viewed": 2045, "published": 3, "date": "1588652330", "time_retrieved": "2024-07-30T21:08:51.711106", "image_code": "#define DEPTH(texCoord) textureLod(iChannel0, texCoord, 0.0).a\n\nvoid outlineCheck(in vec2 uv, in float weight, in float aBase, inout float n) {\n    n += weight * (1.0 - isInInterval(aBase-0.004, aBase+0.004, DEPTH(uv)));\n}\n\nfloat outline(in vec2 uv, in float aBase) {\n    vec2 uvPixel = 1.0/iResolution.xy;\n    float n = 0.0;\n\n    outlineCheck(uv + vec2( 1.0, 0.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2( 0.0, 1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2( 0.0,-1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2(-1.0, 0.0)*uvPixel, 0.125, aBase, n);\n\n    outlineCheck(uv + vec2( 1.0, 1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2( 1.0,-1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2(-1.0, 1.0)*uvPixel, 0.125, aBase, n);\n    outlineCheck(uv + vec2(-1.0,-1.0)*uvPixel, 0.125, aBase, n);\n\n    return n;\n}\n\nvec2 ssao(vec2 fragCoord) {\n    vec2 texCoord = fragCoord / iResolution.xy;\n    vec2 texColorSize = iResolution.xy;\n\n    float d = DEPTH(texCoord);\n    float scaleBase = 0.25/d;\n\n    vec2 offset[16];\n    float rand = hash12(fragCoord);\n    vec2 invRes = 1.0 / iResolution.xy;\n    \n    mat2 m = mat2(INV_SQRT2, INV_SQRT2, -INV_SQRT2, INV_SQRT2);\n\n    float dSample = 2.0*scaleBase;\n    float ra = rand*PI_OVER_2;\n    vec2 r = vec2(cos(ra), sin(ra));\n    offset[ 0] = dSample*vec2( r.x, r.y)*invRes;\n    offset[ 1] = dSample*vec2(-r.y, r.x)*invRes;\n    offset[ 2] = dSample*vec2(-r.x,-r.y)*invRes;\n    offset[ 3] = dSample*vec2( r.y,-r.x)*invRes;\n\n    dSample = 4.0*scaleBase;\n    r = m*r;\n    offset[ 4] = dSample*vec2( r.x, r.y)*invRes;\n    offset[ 5] = dSample*vec2(-r.y, r.x)*invRes;\n    offset[ 6] = dSample*vec2(-r.x,-r.y)*invRes;\n    offset[ 7] = dSample*vec2( r.y,-r.x)*invRes;\n\n    dSample = 6.0*scaleBase;\n    r = m*r;\n    offset[ 8] = dSample*vec2( r.x, r.y)*invRes;\n    offset[ 9] = dSample*vec2(-r.y, r.x)*invRes;\n    offset[10] = dSample*vec2(-r.x,-r.y)*invRes;\n    offset[11] = dSample*vec2( r.y,-r.x)*invRes;\n\n    dSample = 8.0*scaleBase;\n    r = m*r;\n    offset[12] = dSample*vec2( r.x, r.y)*invRes;\n    offset[13] = dSample*vec2(-r.y, r.x)*invRes;\n    offset[14] = dSample*vec2(-r.x,-r.y)*invRes;\n    offset[15] = dSample*vec2( r.y,-r.x)*invRes;\n\n    float deeperCount = 0.0;\n    float nearerCount = 0.0;\n    for(int i=0; i<16; ++i){\n        vec2 texSamplePos = texCoord + offset[i];\n        float dsamp = DEPTH(texSamplePos);\n\n        deeperCount += step(d, dsamp);\n        nearerCount += step(dsamp, d);\n    }\n\n    float shadowIntensity = clamp(1.0 - deeperCount/8.0, 0.0, 1.0);\n    float highlightIntensity = clamp(1.0 - nearerCount/8.0, 0.0, 1.0);\n\n    return vec2(shadowIntensity, highlightIntensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 dataBase = textureLod(iChannel0, uv, 0.0);\n    vec3 rgb = unpackColor(dataBase.st);\n    float glow = dataBase.b;\n    float depth = dataBase.a;\n    \n    vec2 datassao = ssao(fragCoord);\n    float outlineAmount = outline(uv, depth);\n    \n    vec4 overlay = vec4(0.0);\n    overlay = blendOnto((0.15*datassao.t)*vec4(vec3(1.0), 1.0), overlay);\n    overlay = blendOnto((0.75*datassao.s)*vec4(vec3(0.0), 1.0), overlay);\n    overlay = blendOnto((0.4*outlineAmount) * vec4(vec3(0.0), 1.0), overlay);\n    overlay *= 1.0 - glow;\n\n    bool showOverlay = texelFetch(iChannel1, ivec2(KEY_S,0), 0).x > 0.5;\n    if (showOverlay) {\n        rgb = vec3(0.4);\n    }\n    vec3 finalRGB = blendOnto(overlay, rgb).rgb;\n\n    float dCorner = length(uv - vec2(0.5)) * SQRT2;\n    float vignetteFactor = 1.0 - mix(0.0, 0.4, smoothstep(0.3, 0.9, dCorner));\n    fragColor = vec4(vignetteFactor*finalRGB, 1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ======================\n// Lighting, colors, sky\n// ======================\n\n#define PILLAR_COLOR vec3(0.5, 0.1, 0.0)\n#define TERRAIN_COLOR vec3(1.0, 0.5, 0.2)\n#define LIGHT_COLOR vec3(1.0, 0.7, 0.5)\n#define GLOW_COLOR vec3(0.2, 0.5, 1.0)\n\n// cf. iq https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(TWOPI*(c*t+d));\n}\nvec3 colormapPhi(float t) {\n    return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n}\n\nvec3 colormapTerrainGrass(float h) {\n    return mix(vec3(0.3, 0.2, 0.1), vec3(0.3, 0.6, 0.2), h);\n}\n\nvec3 colormapTerrainStone(float h) {\n    return mix(vec3(0.4), vec3(0.7,0.6,0.5), h);\n}\n\nvec4 glowPremulFromDsq(float dsq) {\n    float glow = 1.0 / (1.0 + 500.0*dsq);\n    vec3 glowColor = mix( GLOW_COLOR, vec3(1.0), smoothstep(0.0, 1.0, glow) );\n    return glow*vec4(glowColor, 1.0);\n}\n\nvec4 skyboxLocal(vec2 phiTheta) {\n    vec2 phiThetaT = vec2(phiTheta.s + 0.05*iTime, phiTheta.t);\n    float a = textureLod(iChannel0, phiThetaT*vec2(1.0,3.0), 0.0).r;\n    a = 0.75*a*a;\n    return a*vec4(vec3(1.0), 1.0);\n}\n\nvec3 skyboxGlobal(vec3 nvDir) {\n    float t = abs(nvDir.y);\n    return colormapPhi(t*(1.0-0.5*t));\n}\n\n#define MAT_SKY 0\n#define MAT_PILLAR 1\n#define MAT_TERRAIN 2\n#define MAT_WATER 3\n\nvoid computeLighting(\n    in int matId,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 litColor\n) {\n    float ambientCoefficient = 0.0;\n    float diffuseCoefficient = 0.0;\n    float specularCoefficient = 0.0;\n    float specularExponent = 1.0;\n    switch(matId) {\n        case MAT_PILLAR: {\n            ambientCoefficient = 0.0;\n            diffuseCoefficient = 0.9;\n            specularCoefficient = 0.9;\n            specularExponent = 20.0;\n            break;\n        }\n        case MAT_TERRAIN: {\n            ambientCoefficient = 0.0;\n            diffuseCoefficient = 0.9;\n            specularCoefficient = 0.15;\n            specularExponent = 10.0;\n            break;\n        }\n        case MAT_WATER: {\n            ambientCoefficient = 0.3;\n            diffuseCoefficient = 0.5;\n            specularCoefficient = 0.6;\n            specularExponent = 50.0;\n            break;\n        }\n    }\n\n    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));\n    valDiffuse *= diffuseCoefficient;\n\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    litColor = clamp((ambientCoefficient+valDiffuse)*texColor*lightColor + valSpecular*lightColor, 0.0, 1.0);\n}\n\n// ======================\n// Geometry and textures\n// ======================\n\n#define EPS 1e-4\n#define T_MAX 25.0\n\n#define SDF_STEPS 50\n#define SDF_EPS 5e-3\n#define SDF_N_EPS 0.015\n\n#define TERRAIN_POM_DEPTH 0.15\n#define TERRAIN_POM_STEPS 16\n#define TERRAIN_N_EPS 0.01\n\n// NOTE: Changing these 3 will break the \"laser\" path\n#define HALF_WIDTH 0.5\n#define HALF_INNER_DIAM 1.0\n#define HALF_OUTER_DIAM 2.4\n\n#define HALF_DEPTH 1.0\n#define PILLAR_RADIUS 0.05\n#define ARCH_B_VERT_OFFSET (0.25*HALF_DEPTH)\n#define LASER_Y (-HALF_DEPTH + 1.5*ARCH_B_VERT_OFFSET)\n\n#define ID_NOTHING 0\n#define ID_PORTAL_LOOP 1\n#define ID_PORTAL_SIDE 2\n#define ID_PORTAL_INNER 3\n#define ID_PORTAL_OUTER 4\n#define ID_PILLAR 5\n#define ID_PLANAR 6\n\n// Helper for hitting multiple materials\nvoid updateHit(inout float tMin, inout int idMin, in float t, in int id) {\n    if (t < tMin) {\n        tMin = t;\n        idMin = id;\n    }\n}\n\n// ----------------------------\n// Miscellaneous useful macros\n// ----------------------------\n\n#define _SDF_NORMAL(sdfFn, p) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0) ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0) ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0) ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0) ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS) ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS) )  \\\n    ))\n\n#define _SDF_HIT(sdfFn, p, pDist, shadowAmount) \\\n\tfloat tPillar = 0.0; \\\n    float didHitPillar = 0.0; \\\n    vec3 pSdf = p; \\\n    for (int i=0; i<SDF_STEPS; i++) { \\\n        float d = sdfFn(pSdf); \\\n        float curShadowAmount = clamp(1.0 - abs(d)/( 0.015 + 0.04*(pDist+tPillar) ), 0.0, 1.0); \\\n        shadowAmount = max(shadowAmount, curShadowAmount); \\\n        if (abs(d) < SDF_EPS || tPillar > t) { \\\n            didHitPillar = 1.0; \\\n            break; \\\n        } \\\n        tPillar += d; \\\n        pSdf += d * nv; \\\n    } \\\n    if (didHitPillar > 0.5) { \\\n        updateHit(t, id, tPillar, ID_PILLAR); \\\n    }\n\n#define _DSQ_POINT_FACE(iFace, p) \\\n\t(iFace == 0 ? dsq0Point(p) : \\\n     iFace == 1 ? dsq1Point(p) : \\\n     iFace == 2 ? dsq2Point(p) : \\\n                  dsq3Point(p) )\n\n#define _DSQ_NORMAL(iFace, p) \\\n\t(iFace == 0 ? _SDF_NORMAL(dsq0Point, p) : \\\n     iFace == 1 ? _SDF_NORMAL(dsq1Point, p) : \\\n     iFace == 2 ? _SDF_NORMAL(dsq2Point, p) : \\\n                  _SDF_NORMAL(dsq3Point, p) )\n\n#define _UV_FACE(iFace, p) \\\n\t(iFace == 0 ? uvFace0(p) : \\\n     iFace == 1 ? uvFace1(p) : \\\n     iFace == 2 ? uvFace2(p) : \\\n                  uvFace3(p) )\n\n#define _DPHI_FACE(iFace, p) \\\n\t(iFace == 0 ? vec2(1.0, 0.0) : \\\n     iFace == 1 ? ( abs(p.x) > abs(p.z) ? vec2(-sign(p.x), 0.0) : vec2(0.0, -sign(p.z)) ) : \\\n     iFace == 2 ? vec2(1.0, 0.0) : \\\n                  ( abs(p.x) > abs(p.z) ? vec2( sign(p.x), 0.0) : vec2(0.0,  sign(p.z)) ) )\n\n// --------------------------------\n// Repeated geometry and bump maps\n// --------------------------------\n\nfloat floorH(int face, vec2 xz) {\n    switch(face) {\n        case 1:\n        case 3: {\n            // Terrain\n            return textureLod(iChannel0, xz*0.15, 0.0).g;\n        }\n        case 0:\n        case 2: {\n            // Water: Ensure match over \"loop portals\"\n            float loopdist = face == 0 ? (4.0*HALF_OUTER_DIAM) : (8.0*HALF_INNER_DIAM);\n            vec2 xzSlow = (xz + vec2(0.0, iTime*0.66)) / loopdist;\n            vec2 xzFast = (xz + vec2(0.0, iTime*1.00)) / loopdist + vec2(0.4, 0.0);\n\n            float hFast = textureLod(iChannel0, xzFast, 0.0).g;\n            float h = textureLod(iChannel0, xzSlow + 0.05*vec2(0.0, hFast), 0.0).g;\n\n            float ts = smoothstep(0.0, 0.8, abs(xz.x)/HALF_WIDTH);\n            return mix(h, hFast, mix(0.5, 0.2, ts));\n        }\n    }\n    return 1.0;\n}\n\n// Coords: y is up, z is depth; arch opening ranges x = [0,halfLen] -> [center,pillar]\nfloat sdPillar(float height, float halfLen, float zCenter, vec3 p) {\n    float baseHeight = PILLAR_RADIUS*0.8;\n    float baseRadius = PILLAR_RADIUS*1.25;\n\n    float dBase = sdBox(\n        vec3(halfLen, -HALF_DEPTH+baseHeight*0.5 - 10.0, zCenter),\n        vec3(baseRadius, baseHeight*0.5 + 10.0, baseRadius),\n        p\n    );\n    float dTop = sdBox(\n        vec3(halfLen, -HALF_DEPTH+height-baseHeight*0.5, zCenter),\n        vec3(baseRadius, baseHeight*0.5, baseRadius),\n        p\n    );\n    float dCol = distance( p.xz, vec2(halfLen, zCenter) ) - PILLAR_RADIUS;\n    return min(dCol, min(dBase, dTop));\n}\n\nfloat sdArchA(float halfLen, float zCenter, vec3 p) {\n    float baseHeight = PILLAR_RADIUS*0.0;\n    float baseRadius = PILLAR_RADIUS*0.8;\n\n    float pillarBaseY = baseHeight;\n    float dVert = sdPillar(2.0*HALF_DEPTH-pillarBaseY, halfLen, zCenter, vec3(p.x, p.y-pillarBaseY, p.z));\n\n    float dArchBase = sdBox(\n        vec3(0.0, -HALF_DEPTH+baseHeight*0.5 - 10.0, zCenter),\n        vec3(halfLen, baseHeight*0.5 + 10.0, baseRadius),\n        p\n    );\n\n    return min(dVert, dArchBase);\n}\n\nfloat sdArchB(float halfLen, float zCenter, vec3 p) {\n    float topHeight = PILLAR_RADIUS*0.8;\n    float baseHeight = ARCH_B_VERT_OFFSET;\n\n    float baseRadius = PILLAR_RADIUS*0.8;\n    float topRadius = PILLAR_RADIUS*4.25;\n\n    float archHeight = HALF_INNER_DIAM;\n    float archCenterY = HALF_DEPTH - 0.5*archHeight;\n\n    // ----------------\n    float pillarBaseY = baseHeight;\n    float dVert = sdPillar(2.0*HALF_DEPTH-archHeight-pillarBaseY, halfLen, zCenter, vec3(p.x, p.y-pillarBaseY, p.z));\n\n    float dArchBase = sdBox(\n        vec3(0.0, -HALF_DEPTH+baseHeight*0.5 - 10.0, zCenter),\n        vec3(halfLen+baseRadius, baseHeight*0.5 + 10.0, baseRadius),\n        p\n    );\n    float dArchTop = sdBox(\n        vec3(0.0, HALF_DEPTH-topHeight*0.5, zCenter),\n        vec3(halfLen+topRadius, topHeight*0.5, topRadius),\n        p\n    );\n\n    float dSoFar = min(dVert, min(dArchBase,dArchTop));\n    // ----------------\n\n    // ----------------\n    float dArchBody = sdBox(\n        vec3(0.0, archCenterY, zCenter),\n        vec3(halfLen+PILLAR_RADIUS, archHeight*0.5, PILLAR_RADIUS),\n        p\n    );\n    float rArchSubY = archHeight - topHeight*2.0;\n    float rArchSubX = halfLen - PILLAR_RADIUS;\n    float dArchSub = distance(\n        vec2(0.0, archCenterY - archHeight*0.5),\n        vec2(p.x*(rArchSubY/rArchSubX), p.y)\n    ) - rArchSubY;\n\n    float dDecor = sdSubtract(dArchSub, dArchBody);\n    // ----------------\n\n\n    return min(dSoFar, dDecor);\n}\n\n// ---------------------\n// Face 0: \"Outer ring\"\n// ---------------------\n\n// Geodesic pieces\n#define G12_P vec3(-0.5, LASER_Y,  1.5)\n#define G12_V vec3( INV_SQRT2, 0.0, -INV_SQRT2)\n#define G08_P vec3(-0.5, LASER_Y,  9.1)\n#define G08_V vec3( INV_SQRT2, 0.0, -INV_SQRT2)\n#define G06_P vec3( 0.5, LASER_Y, 11.1)\n#define G06_V vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n#define G02_P vec3( 0.5, LASER_Y, 18.7)\n#define G02_V vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n\nfloat dsq0Point(vec3 p) {\n    float dsq12 = dsqPointLine(p, G12_P, G12_V);\n    float dsq08 = dsqPointLine(p, G08_P, G08_V);\n    float dsq06 = dsqPointLine(p, G06_P, G06_V);\n    float dsq02 = dsqPointLine(p, G02_P, G02_V);\n    return min(min(dsq12, dsq08), min(dsq02, dsq06));\n}\n\nfloat dsq0Segment(vec3 p, vec3 q) {\n    float dsq12 = dsqSegmentLine(p, q, G12_P, G12_V);\n    float dsq08 = dsqSegmentLine(p, q, G08_P, G08_V);\n    float dsq06 = dsqSegmentLine(p, q, G06_P, G06_V);\n    float dsq02 = dsqSegmentLine(p, q, G02_P, G02_V);\n    return min(min(dsq12, dsq08), min(dsq02, dsq06));\n}\n\n// SDF for face\nfloat sdFace0(vec3 p) {\n    float fiz = mod(p.z, 2.0*HALF_OUTER_DIAM);\n    vec3 pArch = vec3( abs(fiz-HALF_OUTER_DIAM), p.y, abs(p.x) );\n    float dArch = sdArchA(HALF_OUTER_DIAM, HALF_WIDTH, pArch);\n\n    return dArch;\n}\n\n// Values that continue seamlessly across the geometry\nvec2 uvFace0(vec3 p) {\n    float tWidth = unmix(-HALF_WIDTH, HALF_WIDTH, p.x);\n    float phi = tWidth/4.0;\n\n    vec2 usq = paramUnitSquare(p.z / (2.0*HALF_OUTER_DIAM));\n    float theta = 0.5+0.5*atan(usq.y, usq.x)/PI;\n\n    return vec2(phi, theta);\n}\n\nvoid traverseFace0(\n    in bool navOnly,\n    inout vec3 p, inout vec3 nv, inout float tRemaining,\n    inout vec4 color, inout float glowDsq, inout float shadowAmount,\n    out bool finished, out int matHit, out vec3 nvHit, out int nextFace\n) {\n    int id = ID_NOTHING;\n    float t = tRemaining;\n\n    float tPortalS = hitIntervalFromInside(-HALF_WIDTH, HALF_WIDTH, p.x, nv.x);\n    updateHit(t, id, tPortalS, ID_PORTAL_SIDE);\n\n    float tPortalL = hitIntervalFromInside(0.0, 8.0*HALF_OUTER_DIAM, p.z, nv.z);\n    updateHit(t, id, tPortalL, ID_PORTAL_LOOP);\n\n    if (!navOnly) {\n        float tPlanar = hitIntervalFromInside(-HALF_DEPTH - TERRAIN_POM_DEPTH, HALF_DEPTH, p.y, nv.y);\n        updateHit(t, id, tPlanar, ID_PLANAR);\n\n        _SDF_HIT(sdFace0, p, T_MAX-tRemaining, shadowAmount)\n    }\n\n    vec3 pNext = p + t*nv;\n    glowDsq = min(glowDsq, dsq0Segment(p, pNext));\n    p = pNext;\n    tRemaining -= t;\n\n    finished = true;\n    nextFace = 0;\n\n    // Floor or ceiling hit\n    if (id == ID_PLANAR) {\n        if (p.y > 0.0) {\n\n            tRemaining = 0.0;\n            vec2 phiTheta = uvFace0(p);\n            color = blendOnto(color, skyboxLocal(phiTheta));\n            matHit = MAT_SKY;\n\n        } else {\n\n\t\t\tnvHit = vec3(0.0, 1.0, 0.0);\n            color = blendOnto(color, PILLAR_COLOR);\n            matHit = MAT_PILLAR;\n\n        }\n    }\n\n    // SDF geometry was hit\n    else if (id == ID_PILLAR) {\n\n        nvHit = _SDF_NORMAL(sdFace0, p);\n        color = blendOnto(color, PILLAR_COLOR);\n        matHit = MAT_PILLAR;\n\n    }\n\n    // Loop portal was hit: Determine transform\n    else if (id == ID_PORTAL_LOOP) {\n\t\tfinished = false;\n        nextFace = 0;\n\n        if (p.z-EPS < 0.0) {\n            p.z += 8.0*HALF_OUTER_DIAM;\n        } else if (p.z+EPS > 8.0*HALF_OUTER_DIAM) {\n            p.z -= 8.0*HALF_OUTER_DIAM;\n        }\n    }\n\n    // Side portal was hit: Determine transform\n    else if (id == ID_PORTAL_SIDE) {\n        finished = false;\n\n        float fi = floor(p.z / (2.0*HALF_OUTER_DIAM));\n        float fiz = mod(p.z, 2.0*HALF_OUTER_DIAM);\n\n        if (p.x-EPS < -HALF_WIDTH) {\n            nextFace = 3;\n\n            if (fi < 1.0) {\n                p.xz = vec2(HALF_OUTER_DIAM, -HALF_OUTER_DIAM + fiz);\n            } else if (fi < 2.0) {\n                p.xz = vec2(HALF_OUTER_DIAM - fiz, HALF_OUTER_DIAM);\n                nv.xz = vec2(-nv.z, nv.x);\n            } else if (fi < 3.0) {\n                p.xz = vec2(-HALF_OUTER_DIAM, HALF_OUTER_DIAM - fiz);\n                nv.xz = -nv.xz;\n            } else {\n                p.xz = vec2(-HALF_OUTER_DIAM + fiz, -HALF_OUTER_DIAM);\n                nv.xz = vec2(nv.z, -nv.x);\n            }\n        } else if (p.x+EPS > HALF_WIDTH) {\n            nextFace = 1;\n\n            if (fi < 1.0) {\n                p.xz = vec2(HALF_OUTER_DIAM, HALF_OUTER_DIAM - fiz);\n                nv.xz = -nv.xz;\n            } else if (fi < 2.0) {\n                p.xz = vec2(HALF_OUTER_DIAM - fiz, -HALF_OUTER_DIAM);\n                nv.xz = vec2(-nv.z, nv.x);\n            } else if (fi < 3.0) {\n                p.xz = vec2(-HALF_OUTER_DIAM, -HALF_OUTER_DIAM + fiz);\n            } else {\n                p.xz = vec2(-HALF_OUTER_DIAM + fiz, HALF_OUTER_DIAM);\n                nv.xz = vec2(nv.z, -nv.x);\n            }\n        }\n    }\n}\n\n// ---------------------\n// Face 2: \"Inner ring\"\n// ---------------------\n\n// Geodesic pieces\n#define G10_P vec3(-0.5, LASER_Y, 2.5)\n#define G10_V vec3( INV_SQRT2, 0.0, -INV_SQRT2)\n#define G04_P vec3( 0.5, LASER_Y, 6.5)\n#define G04_V vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n\nfloat dsq2Point(vec3 p) {\n    float dsq10 = dsqPointLine(p, G10_P, G10_V);\n    float dsq04 = dsqPointLine(p, G04_P, G04_V);\n    return min(dsq10, dsq04);\n}\n\nfloat dsq2Segment(vec3 p, vec3 q) {\n    float dsq10 = dsqSegmentLine(p, q, G10_P, G10_V);\n    float dsq04 = dsqSegmentLine(p, q, G04_P, G04_V);\n    return min(dsq10, dsq04);\n}\n\n// SDF for face\nfloat sdFace2(vec3 p) {\n    float fiz = mod(p.z, 2.0*HALF_INNER_DIAM);\n    vec3 pArch = vec3( abs(fiz-HALF_INNER_DIAM), p.y, abs(p.x) );\n    float dArch = sdArchB(HALF_INNER_DIAM, HALF_WIDTH, pArch);\n\n    return dArch;\n}\n\n// Values that continue seamlessly across the geometry\nvec2 uvFace2(vec3 p) {\n    float tWidth = unmix(-HALF_WIDTH, HALF_WIDTH, p.x);\n    float phi = 0.5 + tWidth/4.0;\n\n    vec2 usq = paramUnitSquare(p.z / (2.0*HALF_INNER_DIAM));\n    float theta = 0.5+0.5*atan(usq.y, usq.x)/PI;\n\n    return vec2(phi, theta);\n}\n\nvoid traverseFace2(\n    in bool navOnly,\n    inout vec3 p, inout vec3 nv, inout float tRemaining,\n    inout vec4 color, inout float glowDsq, inout float shadowAmount,\n    out bool finished, out int matHit, out vec3 nvHit, out int nextFace\n) {\n    int id = ID_NOTHING;\n    float t = tRemaining;\n\n    float tPortalS = hitIntervalFromInside(-HALF_WIDTH, HALF_WIDTH, p.x, nv.x);\n    updateHit(t, id, tPortalS, ID_PORTAL_SIDE);\n\n    float tPortalL = hitIntervalFromInside(0.0, 8.0*HALF_INNER_DIAM, p.z, nv.z);\n    updateHit(t, id, tPortalL, ID_PORTAL_LOOP);\n\n    if (!navOnly) {\n        float tPlanar = hitIntervalFromInside(-HALF_DEPTH+ARCH_B_VERT_OFFSET - TERRAIN_POM_DEPTH, HALF_DEPTH, p.y, nv.y);\n        updateHit(t, id, tPlanar, ID_PLANAR);\n\n        _SDF_HIT(sdFace2, p, T_MAX-tRemaining, shadowAmount)\n    }\n\n    vec3 pNext = p + t*nv;\n    glowDsq = min(glowDsq, dsq2Segment(p, pNext));\n    p = pNext;\n    tRemaining -= t;\n\n    finished = true;\n    nextFace = 2;\n\n    // Floor or ceiling hit\n    if (id == ID_PLANAR) {\n        if (p.y > 0.0) {\n\n            tRemaining = 0.0;\n            vec2 phiTheta = uvFace2(p);\n            color = blendOnto(color, skyboxLocal(phiTheta));\n            matHit = MAT_SKY;\n\n        } else {\n\n            nvHit = vec3(0.0, 1.0, 0.0);\n            color = blendOnto(color, PILLAR_COLOR);\n            matHit = MAT_PILLAR;\n\n        }\n    }\n\n    // SDF geometry was hit\n    else if (id == ID_PILLAR) {\n\n        nvHit = _SDF_NORMAL(sdFace2, p);\n        color = blendOnto(color, PILLAR_COLOR);\n        matHit = MAT_PILLAR;\n\n    }\n\n    // Loop portal was hit: Determine transform\n    else if (id == ID_PORTAL_LOOP) {\n\t\tfinished = false;\n        nextFace = 2;\n\n        if (p.z-EPS < 0.0) {\n            p.z += 8.0*HALF_INNER_DIAM;\n        } else if (p.z+EPS > 8.0*HALF_INNER_DIAM) {\n            p.z -= 8.0*HALF_INNER_DIAM;\n        }\n    }\n\n    // Side portal was hit: Determine transform\n    else if (id == ID_PORTAL_SIDE) {\n        finished = false;\n\n        float fi = floor(p.z / (2.0*HALF_INNER_DIAM));\n        float fiz = mod(p.z, 2.0*HALF_INNER_DIAM);\n\n        if (p.x-EPS < -HALF_WIDTH) {\n            nextFace = 1;\n\n            if (fi < 1.0) {\n                p.xz = vec2(HALF_INNER_DIAM, HALF_INNER_DIAM - fiz);\n                nv.xz = -nv.xz;\n            } else if (fi < 2.0) {\n                p.xz = vec2(HALF_INNER_DIAM - fiz, -HALF_INNER_DIAM);\n                nv.xz = vec2(-nv.z, nv.x);\n            } else if (fi < 3.0) {\n                p.xz = vec2(-HALF_INNER_DIAM, -HALF_INNER_DIAM + fiz);\n            } else {\n                p.xz = vec2(-HALF_INNER_DIAM + fiz, HALF_INNER_DIAM);\n                nv.xz = vec2(nv.z, -nv.x);\n            }\n        } else if (p.x+EPS > HALF_WIDTH) {\n            nextFace = 3;\n\n            if (fi < 1.0) {\n                p.xz = vec2(HALF_INNER_DIAM, -HALF_INNER_DIAM + fiz);\n            } else if (fi < 2.0) {\n                p.xz = vec2(HALF_INNER_DIAM - fiz, HALF_INNER_DIAM);\n                nv.xz = vec2(-nv.z, nv.x);\n            } else if (fi < 3.0) {\n                p.xz = vec2(-HALF_INNER_DIAM, HALF_INNER_DIAM - fiz);\n                nv.xz = -nv.xz;\n            } else {\n                p.xz = vec2(-HALF_INNER_DIAM + fiz, -HALF_INNER_DIAM);\n                nv.xz = vec2(nv.z, -nv.x);\n            }\n        }\n    }\n}\n\n// ---------------------\n// Face 1: \"Top square\"\n// ---------------------\n\n// Geodesic pieces\n#define G01_P vec3(2.4, LASER_Y, 1.9)\n#define G01_V vec3(-INV_SQRT2, 0.0, INV_SQRT2)\n#define G05_P (vec3(-1.0, LASER_Y,  0.5) + vec3(0.25, 0.0, 0.25))\n#define G05_V vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n#define G09_P (vec3( 0.5, LASER_Y, -1.0) + vec3(0.25, 0.0, 0.25))\n#define G09_VR vec3(-INV_SQRT2, 0.0, -INV_SQRT2)\n\nfloat dsq1Point(vec3 p) {\n    float dsq01 = dsqPointLine(p, G01_P, G01_V);\n    float dsq05  = dsqPointRay(p, G05_P, G05_V);\n    float dsq09r = dsqPointRay(p, G09_P, G09_VR);\n    return min(dsq01, min(dsq05, dsq09r));\n}\n\nfloat dsq1Segment(vec3 p, vec3 q) {\n    float dsq01 = dsqSegmentLine(p, q, G01_P, G01_V);\n    float dsq05  = dsqSegmentRay(p, q, G05_P, G05_V);\n    float dsq09r = dsqSegmentRay(p, q, G09_P, G09_VR);\n    return min(dsq01, min(dsq05, dsq09r));\n}\n\n// SDF for face\nfloat sdFace1(vec3 p) {\n    vec3 pArch = vec3( min(abs(p.x),abs(p.z)), p.y, max(abs(p.x),abs(p.z)) );\n    float dO = sdArchA(HALF_OUTER_DIAM, HALF_OUTER_DIAM, pArch);\n    float dI = sdArchB(HALF_INNER_DIAM, HALF_INNER_DIAM, pArch);\n\n    return min(dI, dO);\n}\n\n// Values that continue seamlessly across the geometry\nvec2 uvFace1(vec3 p) {\n    float tWidth = unmix(HALF_OUTER_DIAM, HALF_INNER_DIAM, max(abs(p.x),abs(p.z)));\n    float phi = 0.25 + tWidth/4.0;\n\n    float theta = 0.5+0.5*atan(-p.z, p.x)/PI;\n\n    return vec2(phi, theta);\n}\n\nvoid traverseFace1(\n    in bool navOnly,\n    inout vec3 p, inout vec3 nv, inout float tRemaining,\n    inout vec4 color, inout float glowDsq, inout float shadowAmount,\n    out bool finished, out int matHit, out vec3 nvHit, out int nextFace\n) {\n    int id = ID_NOTHING;\n    float t = tRemaining;\n\n    float tPortalO = hitBox2FromInside(\n        -vec2(HALF_OUTER_DIAM), vec2(HALF_OUTER_DIAM),\n        p.xz, nv.xz\n    );\n    updateHit(t, id, tPortalO, ID_PORTAL_OUTER);\n\n    float tPortalI;\n    float didHitPortalI;\n    hitBox2FromOutside(\n        -vec2(HALF_INNER_DIAM), vec2(HALF_INNER_DIAM),\n        p.xz, nv.xz, tPortalI, didHitPortalI\n    );\n    if (didHitPortalI > 0.5) {\n        updateHit(t, id, tPortalI, ID_PORTAL_INNER);\n    }\n\n    if (!navOnly) {\n        float tPlanar = hitIntervalFromInside(-HALF_DEPTH - TERRAIN_POM_DEPTH, HALF_DEPTH, p.y, nv.y);\n        updateHit(t, id, tPlanar, ID_PLANAR);\n\n        _SDF_HIT(sdFace1, p, T_MAX-tRemaining, shadowAmount)\n    }\n\n    vec3 pNext = p + t*nv;\n    glowDsq = min(glowDsq, dsq1Segment(p, pNext));\n    p = pNext;\n    tRemaining -= t;\n\n    finished = true;\n    nextFace = 1;\n\n    // Floor or ceiling hit\n    if (id == ID_PLANAR) {\n        if (p.y > 0.0) {\n\n            tRemaining = 0.0;\n            vec2 phiTheta = uvFace1(p);\n            color = blendOnto(color, skyboxLocal(phiTheta));\n            matHit = MAT_SKY;\n\n        } else {\n\n            nvHit = vec3(0.0, 1.0, 0.0);\n            color = blendOnto(color, PILLAR_COLOR);\n            matHit = MAT_PILLAR;\n\n        }\n    }\n\n    // SDF geometry was hit\n    else if (id == ID_PILLAR) {\n\n        nvHit = _SDF_NORMAL(sdFace1, p);\n        color = blendOnto(color, PILLAR_COLOR);\n        matHit = MAT_PILLAR;\n\n    }\n\n    // Inner portal was hit: Determine transform\n    else if (id == ID_PORTAL_INNER) {\n        finished = false;\n        nextFace = 2;\n\n        if (p.x+EPS > HALF_INNER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH,                        HALF_INNER_DIAM - p.z);\n            nv.xz = -nv.xz;\n        } else if (p.x-EPS < -HALF_INNER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH, 4.0*HALF_INNER_DIAM + (HALF_INNER_DIAM + p.z));\n        } else if (p.z-EPS < -HALF_INNER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH, 2.0*HALF_INNER_DIAM + (HALF_INNER_DIAM - p.x));\n            nv.xz = vec2(nv.z, -nv.x);\n        } else {\n            p.xz = vec2(-HALF_WIDTH, 6.0*HALF_INNER_DIAM + (HALF_INNER_DIAM + p.x));\n            nv.xz = vec2(-nv.z, nv.x);\n        }\n    }\n\n    // Outer portal was hit: Determine transform\n    else if (id == ID_PORTAL_OUTER) {\n        finished = false;\n        nextFace = 0;\n\n        if (p.x+EPS > HALF_OUTER_DIAM) {\n            p.xz = vec2(HALF_WIDTH,                        HALF_OUTER_DIAM - p.z);\n            nv.xz = -nv.xz;\n        } else if (p.x-EPS < -HALF_OUTER_DIAM) {\n            p.xz = vec2(HALF_WIDTH, 4.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM + p.z));\n        } else if (p.z-EPS < -HALF_OUTER_DIAM) {\n            p.xz = vec2(HALF_WIDTH, 2.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM - p.x));\n            nv.xz = vec2(nv.z, -nv.x);\n        } else {\n            p.xz = vec2(HALF_WIDTH, 6.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM + p.x));\n            nv.xz = vec2(-nv.z, nv.x);\n        }\n    }\n}\n\n// ------------------------\n// Face 3: \"Bottom square\"\n// ------------------------\n\n// Geodesic pieces\n#define G07_P vec3(-2.4, LASER_Y, 1.9)\n#define G07_V vec3(INV_SQRT2, 0.0, INV_SQRT2)\n#define G11_P (vec3( 1.0, LASER_Y,  0.5) + vec3(-0.25, 0.0, 0.25))\n#define G11_V vec3(INV_SQRT2, 0.0, -INV_SQRT2)\n#define G03_P (vec3(-0.5, LASER_Y, -1.0) + vec3(-0.25, 0.0, 0.25))\n#define G03_VR vec3(INV_SQRT2, 0.0, -INV_SQRT2)\n\nfloat dsq3Point(vec3 p) {\n    float dsq07 = dsqPointLine(p, G07_P, G07_V);\n    float dsq11  = dsqPointRay(p, G11_P, G11_V);\n    float dsq03r = dsqPointRay(p, G03_P, G03_VR);\n    return min(dsq07, min(dsq11, dsq03r));\n}\n\nfloat dsq3Segment(vec3 p, vec3 q) {\n    float dsq07 = dsqSegmentLine(p, q, G07_P, G07_V);\n    float dsq11  = dsqSegmentRay(p, q, G11_P, G11_V);\n    float dsq03r = dsqSegmentRay(p, q, G03_P, G03_VR);\n    return min(dsq07, min(dsq11, dsq03r));\n}\n\n// SDF for face\nfloat sdFace3(vec3 p) {\n    vec3 pArch = vec3( min(abs(p.x),abs(p.z)), p.y, max(abs(p.x),abs(p.z)) );\n    float dO = sdArchA(HALF_OUTER_DIAM, HALF_OUTER_DIAM, pArch);\n    float dI = sdArchB(HALF_INNER_DIAM, HALF_INNER_DIAM, pArch);\n\n    return min(dI, dO);\n}\n\n// Values that continue seamlessly across the geometry\nvec2 uvFace3(vec3 p) {\n    float tWidth = unmix(HALF_INNER_DIAM, HALF_OUTER_DIAM, max(abs(p.x),abs(p.z)));\n    float phi = 0.75 + tWidth/4.0;\n\n    float theta = 0.5+0.5*atan(p.z, p.x)/PI;\n\n    return vec2(phi, theta);\n}\n\nvoid traverseFace3(\n    in bool navOnly,\n    inout vec3 p, inout vec3 nv, inout float tRemaining,\n    inout vec4 color, inout float glowDsq, inout float shadowAmount,\n    out bool finished, out int matHit, out vec3 nvHit, out int nextFace\n) {\n    int id = ID_NOTHING;\n    float t = tRemaining;\n\n    float tPortalO = hitBox2FromInside(\n        -vec2(HALF_OUTER_DIAM), vec2(HALF_OUTER_DIAM),\n        p.xz, nv.xz\n    );\n    updateHit(t, id, tPortalO, ID_PORTAL_OUTER);\n\n    float tPortalI;\n    float didHitPortalI;\n    hitBox2FromOutside(\n        -vec2(HALF_INNER_DIAM), vec2(HALF_INNER_DIAM),\n        p.xz, nv.xz, tPortalI, didHitPortalI\n    );\n    if (didHitPortalI > 0.5) {\n        updateHit(t, id, tPortalI, ID_PORTAL_INNER);\n    }\n\n    if (!navOnly) {\n        float tPlanar = hitIntervalFromInside(-HALF_DEPTH - TERRAIN_POM_DEPTH, HALF_DEPTH, p.y, nv.y);\n        updateHit(t, id, tPlanar, ID_PLANAR);\n\n        _SDF_HIT(sdFace3, p, T_MAX-tRemaining, shadowAmount)\n    }\n\n    vec3 pNext = p + t*nv;\n    glowDsq = min(glowDsq, dsq3Segment(p, pNext));\n    p = pNext;\n    tRemaining -= t;\n\n    finished = true;\n    nextFace = 3;\n\n    // Floor or ceiling hit\n    if (id == ID_PLANAR) {\n        if (p.y > 0.0) {\n\n           \ttRemaining = 0.0;\n            vec2 phiTheta = uvFace3(p);\n            color = blendOnto(color, skyboxLocal(phiTheta));\n            matHit = MAT_SKY;\n\n        } else {\n\n            nvHit = vec3(0.0, 1.0, 0.0);\n            color = blendOnto(color, PILLAR_COLOR);\n            matHit = MAT_PILLAR;\n\n        }\n    }\n\n    // SDF geometry was hit\n    else if (id == ID_PILLAR) {\n\n        nvHit = _SDF_NORMAL(sdFace3, p);\n        color = blendOnto(color, PILLAR_COLOR);\n        matHit = MAT_PILLAR;\n\n    }\n\n    // Inner portal was hit: Determine transform\n    else if (id == ID_PORTAL_INNER) {\n        finished = false;\n        nextFace = 2;\n\n        if (p.x+EPS > HALF_INNER_DIAM) {\n            p.xz = vec2(HALF_WIDTH,                        HALF_INNER_DIAM + p.z);\n        } else if (p.x-EPS < -HALF_INNER_DIAM) {\n            p.xz = vec2(HALF_WIDTH, 4.0*HALF_INNER_DIAM + (HALF_INNER_DIAM - p.z));\n            nv.xz = -nv.xz;\n        } else if (p.z-EPS < -HALF_INNER_DIAM) {\n            p.xz = vec2(HALF_WIDTH, 6.0*HALF_INNER_DIAM + (HALF_INNER_DIAM + p.x));\n            nv.xz = vec2(-nv.z, nv.x);\n        } else {\n            p.xz = vec2(HALF_WIDTH, 2.0*HALF_INNER_DIAM + (HALF_INNER_DIAM - p.x));\n            nv.xz = vec2(nv.z, -nv.x);\n        }\n    }\n\n    // Outer portal was hit: Determine transform\n    else if (id == ID_PORTAL_OUTER) {\n        finished = false;\n        nextFace = 0;\n\n        if (p.x+EPS > HALF_OUTER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH,                        HALF_OUTER_DIAM + p.z);\n        } else if (p.x-EPS < -HALF_OUTER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH, 4.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM - p.z));\n            nv.xz = -nv.xz;\n        } else if (p.z-EPS < -HALF_OUTER_DIAM) {\n            p.xz = vec2(-HALF_WIDTH, 6.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM + p.x));\n            nv.xz = vec2(-nv.z, nv.x);\n        } else {\n            p.xz = vec2(-HALF_WIDTH, 2.0*HALF_OUTER_DIAM + (HALF_OUTER_DIAM - p.x));\n            nv.xz = vec2(nv.z, -nv.x);\n        }\n    }\n}\n\n// =============\n// Render scene\n// =============\n\n#define FIXED_UP vec3(0.0, 1.0, 0.0)\n#define TAN_HALF_FOVY 0.7002075382097097\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, FIXED_UP));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid castRay(\n    inout vec3 pRay, inout vec3 nvRay, inout int rayFace,\n    out vec4 cFinal, out float glowDsq, out float shadowAmount,\n    out float dHit, out int matHit, out vec3 nvHit\n) {\n    float tRemaining = T_MAX;\n    cFinal = vec4(0.0);\n    glowDsq = 1e5;\n    shadowAmount = 0.0;\n\n    for (int i=0; i<100; i++) {\n        bool finished;\n\n        if (rayFace == 0) {\n            traverseFace0(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);\n        } else if (rayFace == 1) {\n            traverseFace1(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);\n        } else if (rayFace == 2) {\n            traverseFace2(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);\n        } else {\n            traverseFace3(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);\n        }\n\n        if (finished) {\n            break;\n        }\n    }\n\n    dHit = T_MAX - tRemaining;\n}\n\nvoid navigate(\n    inout vec3 sphPos, inout int sphFace, inout vec3 nvSphDir,\n    in float dist\n) {\n    float tRemaining = dist;\n    vec3 pCur = sphPos;\n    vec3 nvCur = nvSphDir;\n    int face = sphFace;\n\n    for (int i=0; i<100; i++) {\n        vec4 c;\n        float ga;\n        float sa;\n        bool finished;\n        int matHit;\n        vec3 nvHit;\n\n        if (face == 0) {\n            traverseFace0(true, pCur, nvCur, tRemaining, c, ga, sa, finished, matHit, nvHit, face);\n        } else if (face == 1) {\n            traverseFace1(true, pCur, nvCur, tRemaining, c, ga, sa, finished, matHit, nvHit, face);\n        } else if (face == 2) {\n            traverseFace2(true, pCur, nvCur, tRemaining, c, ga, sa, finished, matHit, nvHit, face);\n        } else if (face == 3) {\n            traverseFace3(true, pCur, nvCur, tRemaining, c, ga, sa, finished, matHit, nvHit, face);\n        }\n\n        if (finished) {\n            break;\n        }\n    }\n\n    sphPos = pCur;\n    nvSphDir = nvCur;\n    sphFace = face;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool isMousePressed = clamp(iMouse.z, 0.0, 1.0) > 0.0;\n    bool hideGlow  = texelFetch(iChannel1, ivec2(KEY_D,0), 0).x > 0.5;\n    bool hideLight = texelFetch(iChannel1, ivec2(KEY_F,0), 0).x > 0.5;\n\n    float LOOPS = 3.0;\n    float geodesicLength = sqrt(2.0)*12.6;\n    float tLoop = isMousePressed ? (iMouse.x / iResolution.x) : mod(0.02*iTime, 1.0);\n\n    // Establish current position\n\t// -----------------------------------------\n    // NOTE: Changing the initial point will break the \"laser\" path\n    vec3 sphPos = vec3(0.5);\n    int sphFace = 0;\n    vec3 nvSphDir = normalize(vec3(1.0, 0.0, -1.0));\n\n    navigate(sphPos, sphFace, nvSphDir, tLoop*LOOPS*geodesicLength);\n    sphPos = vec3(sphPos.x, mix(0.2, 0.55, 0.5+0.5*sin(tLoop*TWOPI)), sphPos.z);\n\n    // Camera settings\n    // -----------------------------------------\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 angRtUp = vec2(-0.35 - 0.1*PI*sin(tLoop*TWOPI), PI*sin(tLoop*TWOPI));\n\n    vec3 nvCamRt = normalize(cross(nvSphDir, FIXED_UP));\n    mat3 rotRt = glRotate(nvCamRt, angRtUp.s);\n    mat3 rotUp = glRotate(vec3(0.0, 1.0, 0.0), angRtUp.t);\n    vec3 nvCamFw = rotUp*(rotRt*nvSphDir);\n\n    mat4 clipToWorld = getClipToWorld(iResolution.x/iResolution.y, nvCamFw);\n    vec4 vWorld = clipToWorld * vec4(uv*2.0 - 1.0, 1.0, 1.0);\n    vec3 nvCamDir = normalize(vWorld.xyz / vWorld.w);\n\n    // Initial geometry hit\n    // -----------------------------------------\n    vec4 cFinal;\n    float glowDsq;\n    float shadowAmount;\n    float dHit;\n    int matHit;\n    vec3 nvHit;\n    castRay(\n        sphPos, nvCamDir, sphFace,\n        cFinal, glowDsq, shadowAmount, dHit, matHit, nvHit\n    );\n\n    float fogAmount = clamp( dHit/T_MAX, 0.0, 1.0 );\n    if (hideGlow) {\n        glowDsq = 1e5;\n    }\n    vec4 glowPremul = glowPremulFromDsq(glowDsq);\n\n    // Terrain/water POM adjustment\n    // -----------------------------------------\n    float pomTop = -HALF_DEPTH;\n    if (sphFace == 2) {\n        pomTop = -HALF_DEPTH+ARCH_B_VERT_OFFSET;\n\t}\n\n    if (sphPos.y < pomTop) {\n        // Back up to surface\n        float dSurf = (pomTop - sphPos.y)/nvCamDir.y;\n        vec3 sphPosSurf = sphPos + dSurf*nvCamDir;\n        float dHitSurf = dHit + dSurf;\n\n        // Down to floor/subsurface\n        float dMax = -(TERRAIN_POM_DEPTH-EPS) / nvCamDir.y;\n        vec3 sphPosBase = sphPosSurf + dMax*nvCamDir;\n        float dHitBase = dHitSurf + dMax;\n\n        // POM loop\n        int i = 0;\n        float it = 0.0;\n        float iMidstep = 0.0;\n        float yOffsetPrev = 0.0;\n        for (; i<TERRAIN_POM_STEPS; i++) {\n            it = float(i)/float(TERRAIN_POM_STEPS);\n\n            vec3 sphPosStep = mix(sphPosSurf, sphPosBase, it);\n            float texY = mix(sphPosBase.y, sphPosSurf.y, floorH(sphFace, sphPosStep.xz));\n\n            float yOffset = sphPosStep.y - texY;\n            if (yOffset < 0.0) {\n\t\t\t\tfloat iMidstep = mix(float(i)-1.0, float(i), unmix(yOffsetPrev, yOffset, 0.0));\n\t\t\t\tit = iMidstep / float(TERRAIN_POM_STEPS);\n             \tbreak;\n            }\n            yOffsetPrev = yOffset;\n        }\n\n        float dHitStep = mix(dHitSurf, dHitBase, it);\n        if (dHitStep < dHit) {\n            sphPos = mix(sphPosSurf, sphPosBase, it);\n            dHit = mix(dHitSurf, dHitBase, it);\n\n            float hSA = floorH(sphFace, sphPos.xz + vec2(-TERRAIN_N_EPS, 0.0));\n            float hSB = floorH(sphFace, sphPos.xz + vec2( TERRAIN_N_EPS, 0.0));\n            float hTA = floorH(sphFace, sphPos.xz + vec2(0.0, -TERRAIN_N_EPS));\n            float hTB = floorH(sphFace, sphPos.xz + vec2(0.0,  TERRAIN_N_EPS));\n            vec2 gradh = vec2(hSB-hSA, hTB-hTA)*(TERRAIN_POM_DEPTH/(2.0*TERRAIN_N_EPS));\n            nvHit = normalize(vec3(-gradh.x, 1.0, -gradh.y));\n\n            if (sphFace == 0 || sphFace == 2) {\n                vec3 waterColor;\n                if (sphFace == 0) {\n                \twaterColor = mix(1.0, 0.5, it)*0.7*vec3(0.3, 0.7, 1.0);\n                } else {\n                    waterColor = mix(1.0, 0.5, it)*1.0*vec3(1.0, 0.9, 0.8);\n                }\n\n                cFinal = blendOnto(vec4(waterColor, 1.0), cFinal);\n                matHit = MAT_WATER;\n\n            } else {\n\n                vec3 terrainColor;\n                if (sphFace == 1) {\n                    terrainColor = colormapTerrainStone(1.0-it);\n                } else {\n                    terrainColor = colormapTerrainGrass(1.0-it);\n                }\n\n                cFinal = vec4(terrainColor, 1.0);\n                matHit = MAT_TERRAIN;\n\n            }\n\n        }\n    }\n\n    // Lighting and shadows\n    // -----------------------------------------\n    if (matHit != MAT_SKY) {\n        vec3 ambientColor = 0.15*cFinal.rgb;\n        \n        // Light in the direction of +phi, with shadows\n        // -----------------------------------------\n        float lSA = _UV_FACE(sphFace, sphPos + vec3(-0.05, 0.0, 0.0)).s;\n        float lSB = _UV_FACE(sphFace, sphPos + vec3( 0.05, 0.0, 0.0)).s;\n        float lTA = _UV_FACE(sphFace, sphPos + vec3(0.0, 0.0, -0.05)).s;\n        float lTB = _UV_FACE(sphFace, sphPos + vec3(0.0, 0.0,  0.05)).s;\n\n        vec2 gradlLight = normalize(vec2(lSB-lSA, lTB-lTA));\n        vec3 nvFragToLight = normalize(vec3( gradlLight.x, 0.8, gradlLight.y ));\n\n        // - grad phi has discontinuity; using smoothed version fixes hard edge for light,\n        //   but causes shadow glitch (a little shadow \"peeks through\" the smoothed part over\n        //   the discontinuity) so we use the exact non-smoothed version for shadow direction\n        // - also add a little EPS to avoid a div by zero in some intersections\n        vec2 gradlShadow = _DPHI_FACE(sphFace, sphPos) + vec2(0.0001, 0.001);\n        vec3 nvFragToLightShadow = normalize(vec3( gradlShadow.x, 0.8, gradlShadow.y ));\n        \n        vec3 nvCamDir2 = nvFragToLightShadow;\n        vec3 sphPos2 = sphPos + (5.0*SDF_EPS)*nvHit;\n\n        int sphFace2 = sphFace;\n        vec4 cFinal2;\n        float glowDsq2;\n        float shadowAmount2;\n        float dHit2;\n        int matHit2;\n        vec3 nvHit2;\n\n        castRay(\n            sphPos2, nvCamDir2, sphFace2,\n            cFinal2, glowDsq2, shadowAmount2, dHit2, matHit2, nvHit2\n        );\n\n        float hardShadowAmount = 1.0 - step(T_MAX, dHit2);\n        float totalShadow = max(shadowAmount2, hardShadowAmount);\n        \n        vec3 litColor;\n        computeLighting(\n            matHit,\n            1.25*(1.0-totalShadow)*LIGHT_COLOR, cFinal.rgb,\n            nvHit, nvFragToLight, -nvCamDir,\n            litColor\n        );\n        if (hideLight) {\n            litColor = vec3(0.0);\n        }\n        \n        // Light from the \"laser\"\n        // -----------------------------------------\n        float dsqLaser = _DSQ_POINT_FACE(sphFace, sphPos);\n        float dsqInt = 1.0 / (1.0 + 1.5*dsqLaser);\n        \n        // this is discontinuous along lines equidistant to multiple parts of the\n        // geodesic, causing hard edges in the light--not too noticeable, won't fix\n        vec3 dsqNormal = _DSQ_NORMAL(sphFace, sphPos);\n\n        vec3 litColor2;\n        computeLighting(\n            matHit,\n            1.25*dsqInt*mix(GLOW_COLOR, vec3(1.0), 0.25), cFinal.rgb,\n            nvHit, -dsqNormal, -nvCamDir,\n            litColor2\n        );\n        if (hideGlow) {\n            litColor2 = vec3(0.0);\n        }\n\n        // Final blending, with fog adjustment\n        // -----------------------------------------\n        cFinal = vec4(ambientColor + litColor + litColor2, 1.0);\n        cFinal = blendOnto(glowPremul, cFinal);\n    \tcFinal *= (1.0 - fogAmount);\n\n    } else {\n        // Since we don't get the distance to the laser, it's not possible to \n        // \"fog\" it accurately--so we just fake it when it's against the sky.\n        // (when it's against non-sky, we borrow the depth of the thing behind it)\n        cFinal = blendOnto(glowPremul*0.4, cFinal);\n    }\n\n    cFinal = blendOnto(cFinal, skyboxGlobal(nvCamDir));\n\n    fragColor = vec4(packColor(fragCoord, clamp(cFinal.rgb, 0.0, 1.0)), glowPremul.a, dHit/T_MAX);\n}\n", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ==========================\n// Generic Helpers/Constants\n// ==========================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define PI_OVER_2 1.570796326794896\n#define PI_OVER_4 0.7853981633974483\n\n#define SQRT2 1.414213562373095\n#define INV_SQRT2 0.7071067811865476\n\n// Keyboard input description: https://www.shadertoy.com/view/lsXGzf\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n\n//---------------\n// Miscellaneous\n//---------------\n\n//cf. Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\n// 1 if x \\in (a,b], else 0\nfloat isInInterval(float a, float b, float x) {\n    return step(a, x) * (1.0 - step(b, x));\n}\n\n// Parameterization of unit square with t \\in [0,4]\nvec2 paramUnitSquare(float t) {\n    float tmod4 = mod(t, 4.0);\n    return vec2(\n        clamp(2.0*abs(tmod4-2.5)-2.0, -1.0, 1.0),\n        clamp(2.0-2.0*abs(tmod4-1.5), -1.0, 1.0)\n    );\n}\n\n// Rodrigues' formula: v -> (v.n)n + (v-(v.n)n)c - (vxn)s\nmat3 oProd(vec3 n) {\n    float xy = n.x*n.y, xz = n.x*n.z, yz = n.y*n.z;\n    return mat3(n.x*n.x,xy,xz,  xy,n.y*n.y,yz,  xz,yz,n.z*n.z);\n}\nmat3 glRotate(vec3 axis, float angle) {\n    float c = cos(angle), s = sin(angle);\n    vec3 n = normalize(axis);\n    return (\n        (1.-c)*oProd(n) +\n        mat3(c,s*n.z,-s*n.y,  -s*n.z,c,s*n.x,  s*n.y,-s*n.x,c)\n    );\n}\n\n//----------------------------------------\n// Color blending for premultiplied alpha\n//----------------------------------------\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\n//--------------------------------------------------------------\n// Conversions vec3 rgb888 <-> vec2 rgb565 to free up a channel\n//--------------------------------------------------------------\n\n#define DITHER\n\n//24-bit color in [0,1]^3 to 16-bit color in [0,1]^2\nvec2 packColor(vec2 fragCoord, vec3 c24){\n  //get 5r6g5b values\n  float r = (c24.r == 1.0) ? 31.0 : floor(c24.r*32.0);\n  float g = (c24.g == 1.0) ? 63.0 : floor(c24.g*64.0);\n  float b = (c24.b == 1.0) ? 31.0 : floor(c24.b*32.0);\n\n  #ifdef DITHER\n      float tr = fract(c24.r*32.0);\n      float tg = fract(c24.g*64.0);\n      float tb = fract(c24.b*32.0);\n\n      float tarr[16];\n      tarr[ 0] =  1.0; tarr[ 1] =  9.0; tarr[ 2] =  3.0; tarr[ 3] = 11.0;\n      tarr[ 4] = 13.0; tarr[ 5] =  5.0; tarr[ 6] = 15.0; tarr[ 7] =  7.0;\n      tarr[ 8] =  4.0; tarr[ 9] = 12.0; tarr[10] =  2.0; tarr[11] = 10.0;\n      tarr[12] = 16.0; tarr[13] =  8.0; tarr[14] = 14.0; tarr[15] =  6.0;\n\n      int tci = int(mod(fragCoord.x, 4.0));\n      int tcj = int(mod(fragCoord.y, 4.0));\n\n      float thresh = 1.0;\n      for(int i=0; i<4; i++){\n      for(int j=0; j<4; j++){\n        if((i == tci) && (j == tcj)){ thresh = tarr[i*4+j]/17.0; }\n      }}\n\n      if(tr > thresh){ r = min(r+1.0, 31.0); }\n      if(tg > thresh){ g = min(g+1.0, 63.0); }\n      if(tb > thresh){ b = min(b+1.0, 31.0); }\n  #endif\n\n  //encode 5r6g5b -> [gggrrrrr][gggbbbbb]\n  float gmin = mod(g,8.0);\n  float gmax = floor(g/8.0);\n\n  float x = (r + 32.0*gmin)/255.0;\n  float y = (b + 32.0*gmax)/255.0;\n\n  return vec2(x,y);\n}\n\n//16-bit color in [0,1]^2 to 24-bit color in [0,1]^3\nvec3 unpackColor(vec2 c16){\n  //[gggrrrrr][gggbbbbb] -> 5r6g5b\n\n  float rpack = floor(255.0*c16.x);\n  float bpack = floor(255.0*c16.y);\n\n  float gmin = floor(rpack/32.0);\n  float gmax = floor(bpack/32.0);\n  float g = (gmin + 8.0*gmax)/63.0;\n\n  float r = mod(rpack,32.0)/31.0;\n  float b = mod(bpack,32.0)/31.0;\n\n  return vec3(r,g,b);\n}\n\n//---------------------------\n// Signed distance functions\n//---------------------------\n\nfloat sdSubtract(float d1, float d2) {\n    return max(-d1,d2);\n}\n\nfloat sdBox(vec3 boxCenter, vec3 boxRadii, vec3 p) {\n    vec3 q = boxRadii - abs(p - boxCenter);\n    return length(min(q, 0.0)) - max( min(min(q.x, q.y), q.z), 0.0 );\n}\n\n//------------------------------------------\n// Exact hits along a ray (1d and 2d boxes)\n//------------------------------------------\n\n// Find t>0 so x+t*dx is on boundary of xMin-xMax, assuming x in interval\nfloat hitIntervalFromInside(\n    float xMin, float xMax,\n    float x, float dx\n) {\n    float tMin = (xMin - x) / dx;\n    float tMax = (xMax - x) / dx;\n    return max(tMin, tMax);\n}\n\n// Find t>0 so p+t*v is on boundary of boxMin-boxMax, assuming x in box\nfloat hitBox2FromInside(\n    in vec2 boxMin, in vec2 boxMax,\n    in vec2 p, in vec2 v\n) {\n    return min(\n        hitIntervalFromInside(boxMin.x, boxMax.x, p.x, v.x),\n        hitIntervalFromInside(boxMin.y, boxMax.y, p.y, v.y)\n    );\n}\n\n// Find t>0 so p+t*v is on boundary of boxMin-boxMax, assuming x outside box\n// (Hitting from outside means there may be no such t, then didHit -> 0.0)\nvoid hitBox2FromOutside(\n    in vec2 boxMin, in vec2 boxMax,\n    in vec2 p, in vec2 v,\n    out float t, out float didHit\n) {\n    vec2 tb0 = (boxMin - p) / v;\n    vec2 tb1 = (boxMax - p) / v;\n    vec2 tmin = min(tb0, tb1);\n    vec2 tmax = max(tb0, tb1);\n\n    vec2 tRange = vec2(\n        max(tmin.x, tmin.y),\n        min(tmax.x, tmax.y)\n    );\n\n    didHit = step(tRange.s, tRange.t) * step(0.0, tRange.s);\n    t = tRange.s;\n}\n\n//-----------------------------------------------------\n// Exact squared distances (point, segment, ray, line)\n//-----------------------------------------------------\n\n// Returns t that minimizes distance(p, a + t*nv)\nfloat minPointLine(vec3 a, vec3 nv, vec3 p) {\n    return dot(p - a, nv);\n}\n\n// Returns (s,t) that minimizes distance(a + t*nv, b + t*nw)\nvec2 minLineLine(vec3 a, vec3 nv, vec3 b, vec3 nw) {\n    vec3 d = a - b;\n    float vw = dot(nv, nw);\n    float dv = dot(d, nv);\n    float dw = dot(d, nw);\n    return vec2(dv - dw*vw, -dw + dv*vw) / (vw*vw - 1.0);\n}\n\nfloat dsq(vec3 p, vec3 q) {\n    vec3 d = p - q;\n    return dot(d, d);\n}\n\nfloat dsqPointLine(vec3 a, vec3 p, vec3 nv) {\n    float tMinA = minPointLine(p, nv, a);\n    return dsq( a, p + tMinA*nv );\n}\n\nfloat dsqPointRay(vec3 a, vec3 p, vec3 nv) {\n\tfloat tMinA = max(0.0, minPointLine(p, nv, a));\n    return dsq( a, p + tMinA*nv );\n}\n\nfloat dsqSegmentLine(vec3 a, vec3 b, vec3 p, vec3 nv) {\n    float tMinA = minPointLine(p, nv, a);\n    float tMinB = minPointLine(p, nv, b);\n    float dsqMin = min(\n        dsq( a, p + tMinA*nv ),\n        dsq( b, p + tMinB*nv )\n    );\n\n    float lenSeg = length(a - b);\n    vec3 nvSeg = (a - b) / lenSeg;\n\n    vec2 minInterior = minLineLine(b, nvSeg, p, nv);\n    if (minInterior.s > 0.0 && minInterior.s < lenSeg) {\n        vec3 cpSeg = b + minInterior.s*nvSeg;\n        vec3 cpLine = p + minInterior.t*nv;\n        dsqMin = min( dsqMin, dsq(cpSeg, cpLine) );\n    }\n\n    return dsqMin;\n}\n\nfloat dsqSegmentRay(vec3 a, vec3 b, vec3 p, vec3 nv) {\n    float tMinA = max(0.0, minPointLine(p, nv, a));\n    float tMinB = max(0.0, minPointLine(p, nv, b));\n    float dsqMin = min(\n        dsq( a, p + tMinA*nv ),\n        dsq( b, p + tMinB*nv )\n    );\n\n    float lenSeg = length(a - b);\n    vec3 nvSeg = (a - b) / lenSeg;\n\n    float sMinP = clamp(minPointLine(b, nvSeg, p), 0.0, lenSeg);\n    dsqMin = min( dsqMin, dsq(p, b + sMinP*nvSeg) );\n\n    vec2 minInterior = minLineLine(b, nvSeg, p, nv);\n    if (minInterior.s > 0.0 && minInterior.s < lenSeg && minInterior.t > 0.0) {\n        vec3 cpSeg = b + minInterior.s*nvSeg;\n        vec3 cpLine = p + minInterior.t*nv;\n        dsqMin = min( dsqMin, dsq(cpSeg, cpLine) );\n    }\n\n    return dsqMin;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 143, 143, 222], [224, 224, 267, 267, 864], [866, 866, 893, 893, 2690], [2692, 2692, 2749, 2749, 3681]], "test": "untested"}
{"id": "3slfz2", "name": "colzurs", "author": "gurudevbk", "description": "colorful (arc)tangents", "tags": ["colors"], "likes": 3, "viewed": 325, "published": 3, "date": "1588649433", "time_retrieved": "2024-07-30T21:08:52.580782", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // useful values\n    const float pi = 3.14159265;\n    const float i_max = pi;\n    const float d_i = i_max / 2.;\n    vec2 res = iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - 0.5*res)/res.y;\n    \n    // Time varying pixel color\n    vec3 col = .8 - 0.5*cos(iTime+uv.xyx+vec3(sin(iTime)/5.,.2*cos(iTime/4.),1));\n    uv = mat2(sin(iTime), cos(iTime), sin(iTime), -cos(iTime)) * uv;\n    \n\tcol.b /= atan(fragCoord.x, fragCoord.y+iTime);\n\tcol.r /= (1./col.b)*(pow(sin(iTime),3.)+pow(cos(iTime),2.))*atan(fragCoord.x, fragCoord.y-cos(iTime));\n\tcol.g /= atan(fragCoord.y, fragCoord.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 83, 755]], "test": "untested"}
{"id": "WslBz2", "name": "HDR Emissive Values Demo", "author": "hypernewbie", "description": "Test for various emissive values under convolution.", "tags": ["test"], "likes": 0, "viewed": 190, "published": 3, "date": "1588640360", "time_retrieved": "2024-07-30T21:08:53.431507", "image_code": "\nvec3 f( vec2 uv )\n{\n    vec2 space = uv;\n    space.y *= iResolution.y / iResolution.x;\n    \n    // Bottom bar - Correct HDR.\n    float d = length(space - vec2( 0.5, 0.2));\n    vec3 x1 = vec3( d > 0.025 ? 0 : 1 ) * pow( abs(1.0-d), 50.1f ) * vec3( 0.03, 0.06, 0.3 ) * 50.0 ;\n    \n    // Mid bar = Less correct HDR\n    float d2 = length(space - vec2( 0.5, 0.3));\n    vec3 x2 = vec3( d2 > 0.025 ? 0 : 1 ) * pow( abs(1.0-d2), 50.1f ) * vec3( 0.15, 0.7, 0.9 ) * 10.0 ;\n    \n    // Top bar = Bad HDR\n    float d3 = length(space - vec2( 0.5, 0.4));\n    vec3 x3 = vec3( d3 > 0.025 ? 0 : 1 ) * pow( abs(1.0-d3), 25.1f ) * vec3( 0.57, 1.0, 1.1 ) * 2.0 ;\n    \n    return x1 + x2 + x3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 c = vec3( 0.0 );\n    \n    float filterLength = (iMouse.x * 3.0) / iResolution.x;\n    for( float i = 0.0; i < 128.0; i+=1.0 )\n    {\n        float x = i - 64.0;\n        c += f( uv + vec2( x * (filterLength / iResolution.x), 0.0 ) );\n    }\n    c /= 128.0;\n    \n\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 676], [678, 678, 735, 785, 1182]], "test": "untested"}
{"id": "tdXfDM", "name": "Basic cubemap example", "author": "4rknova", "description": "A basic example of how to render to each face in the 'Cube A' pass", "tags": ["basic"], "likes": 3, "viewed": 660, "published": 3, "date": "1588632856", "time_retrieved": "2024-07-30T21:08:54.311155", "image_code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI\t(3.14159265359)\n#define PIH (1.57079632679)\n\nvec3 dir(vec2 p)\n{\n    vec2 s = (p/iResolution.xy*2.-1.) * vec2(PI,PIH); // Spherical coords\n    vec4 t = vec4(sin(s), cos(s));                    // Precalculated sin/cos values\n    return t.zyx * vec3(t.w, 1, t.w);                 // Conversion to direction\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = texture(iChannel0, dir(fragCoord));\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define FACE_X_POS (0)\n#define FACE_X_NEG (1)\n#define FACE_Y_POS (2)\n#define FACE_Y_NEG (3)\n#define FACE_Z_POS (4)\n#define FACE_Z_NEG (5)\n\nint dir2face(in vec3 dir)\n{\n    vec3 d = abs(dir);\n    if (d.z >= d.x && d.z >= d.y) return dir.z < 0.0 ? FACE_Z_NEG : FACE_Z_POS;\n    if (d.y >= d.x              ) return dir.y < 0.0 ? FACE_Y_NEG : FACE_Y_POS;\n    \t\t\t\t\t\t\t  return dir.x < 0.0 ? FACE_X_NEG : FACE_X_POS;  \n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    int idx = dir2face(rayDir);    \n    \n    vec3 col = vec3(0);\n    \n    switch (idx) {\n        case FACE_X_POS: col = vec3(1.0,0.0,0.0); break;\n        case FACE_X_NEG: col = vec3(0.5,0.0,0.0); break;\n        case FACE_Y_POS: col = vec3(0.0,1.0,0.0); break;\n        case FACE_Y_NEG: col = vec3(0.0,0.5,0.0); break;\n        case FACE_Z_POS: col = vec3(0.0,0.0,1.0); break;\n        case FACE_Z_NEG: col = vec3(0.0,0.0,0.5); break;\n    }\n    \n    fragColor = vec4(col, 1);\n}", "cube_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfDM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[177, 177, 195, 195, 438], [440, 440, 495, 495, 546]], "test": "untested"}
{"id": "WssfRj", "name": "hoveringsoul01", "author": "paulobarcelos", "description": "hoveringsoul01", "tags": ["hoveringsoul01"], "likes": 0, "viewed": 264, "published": 3, "date": "1588630516", "time_retrieved": "2024-07-30T21:08:55.218728", "image_code": "#define PI 3.14159265358979323846\nvec2 rotate2D(vec2 uv, float angle){\n    uv -= 0.5;\n    float s = sin(angle);\n    float c = cos(angle);\n    uv *=  mat2(c,-s,s ,c);\n    uv += 0.5;\n    return uv;\n}\n\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 gradient(float t) {\n\treturn vec4( cosPalette(t,\n    \tvec3(0.5, 0.2, 0.5),\n        vec3(0.2, 0.2, 0.2),\n        vec3(0.4, 0.2, 0.8),\n        vec3(0.0, 0.1, 0.0)\n    ), 1.0);\n}\n\nfloat rectangle(vec2 uv, vec2 size, float blur) {\n    uv = abs(uv);\n    vec2 halfSize = size * 0.5;\n    float halfBlur = blur * 0.5;\n    vec2 start = halfSize + halfBlur;\n    vec2 end = clamp(vec2(0.0), vec2(1.0), halfSize - halfBlur);\n    vec2 m = smoothstep(start, end, uv);\n    return m.x * m.y;\n}\n\nfloat leafShape(vec2 uv, float time) {\n    float height = 0.5;\n    float verticalChange = clamp(0.0, 1.0, ((uv.y + 0.5) - (1.0 - height)) / height);\n    uv.x += sin(time + verticalChange * 5.0) * verticalChange * 0.5;\n    uv.y += 0.1;\n    vec2 size = vec2(mix(0.1, 0.9, verticalChange), height);\n    float blur = mix(0.3, 1.1, verticalChange * verticalChange);\n    float r = rectangle(uv, size, blur);\n    return smoothstep(0.1, 0.15, smoothstep(0.1, 0.15, r));\n}\n\nfloat lines(vec2 suv, float time) {\n    float l;\n    vec2 uv;\n       \n    uv = suv;\n    uv *= 6.0;\n    uv.x += step(1., mod(uv.y, 2.0)) * 0.5;\n    uv = fract(uv) - 0.5;\n    uv.y += time * 1.0;  \n    uv.y = mod(uv.y, 2.0) - 0.5;\n    l += smoothstep(0.05, 0.08, rectangle(uv, vec2(0.001, 0.7), 0.2)) * 0.6;\n   \n    uv = suv;\n    uv *= 6.0;\n    uv.x += step(1., mod(uv.y + 1.0, 2.0)) * 0.5;\n    uv = fract(uv) - 0.5;\n    uv.y += time * 1.0;  \n    uv.y = mod(uv.y + 1.0 , 2.0) - 0.5;\n    l += smoothstep(0.05, 0.08, rectangle(uv, vec2(0.001, 0.7), 0.2)) * 0.6;\n    \n    return l;\n}\n\nvec4 soul(vec2 uv, float time) {\n    vec4 color = vec4(0);\n    \n    uv.y *= 0.7;\n    uv.y += 0.1;\n    \n    float t1 = time + 0.2;\n    float t2 = t1 + 0.2;\n    float t3 = t2 + 0.2;\n    \n    vec2 offset1 = vec2(sin(t1) * 0.1, cos(t1) * 0.05);\n    vec2 offset2 = vec2(sin(t2) * 0.2, cos(t2) * 0.075);\n    vec2 offset3 = vec2(sin(t3) * 0.3, cos(t3) * 0.1);\n    \n    float s1 = leafShape(uv + offset1, t1);\n    float s2 = leafShape(uv / vec2(0.8, 1.0) + offset2 , t2);\n    float s3 = leafShape(uv / vec2(0.5, 1.0) + offset3, t3);\n    \n    float ss1 = leafShape(uv + offset1 + vec2(0.005), t1);\n    float ss2 = leafShape(uv / vec2(0.8, 1.0) + offset2 + vec2(0.005), t2);\n    float ss3 = leafShape(uv / vec2(0.5, 1.0) + offset3 + vec2(0.005), t3);\n\n    vec4 shaddowColor = vec4(0, 0, 0, 1.0);\n    \n    color = mix(color, shaddowColor, ss1 * 0.5);\n    color = mix(color, gradient(t1 + uv.y), s1);\n    \n    color = mix(color, shaddowColor, ss2 * 0.5);\n    color = mix(color, gradient(t2 + uv.y), s2);\n    \n    color = mix(color, shaddowColor, ss3 * 0.5);\n    color = mix(color, gradient(t3 + uv.y), s3);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // speed\n    float time = iTime * 0.5;\n    \n    // normalize -0.5 <> 0.5\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    // shrink scene\n    uv *= 1.5;\n    \n    // rotate scene \n    float a = PI * 0.25;\n    float s = sin(a);\n    float c = cos(a);\n    uv *=  mat2(c,-s,s ,c);\n    \n    // uv.x += cos(time * (uv.y + 0.5) * .06) * .03;\n    \n    uv.x += cos(uv.y * 6.0 ) * .05;\n    \n    \n    // bg color\n    vec4 color = vec4(gradient(time * 0.5 + uv.y * 0.5)) * 0.5;\n    \n \n    // lines\n    color = mix(color, vec4(1), lines(uv, time));\n    \n    // soul\n    vec4 soul = soul(uv, time);\n    \n    // color = mix(color, vec4(0), soulShaddow.a * 0.5);\n    color = mix(color, soul, soul.a);\n    \n    // paint pixel\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 70, 70, 197], [199, 199, 259, 259, 302], [304, 304, 328, 328, 483], [485, 485, 534, 534, 785], [787, 787, 825, 825, 1250], [1252, 1252, 1287, 1287, 1829], [1831, 1831, 1863, 1863, 2950], [2952, 2952, 3009, 3022, 3770]], "test": "untested"}
{"id": "3ssfRj", "name": "the handshake", "author": "lomateron", "description": "trying every equation combination posible to get fractals\nbut posting only the rare ones", "tags": ["fractal", "zoom"], "likes": 7, "viewed": 348, "published": 3, "date": "1588621490", "time_retrieved": "2024-07-30T21:08:56.080424", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 4.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n\n    u /= pow(2.,iTime*.4);\n    u -= vec2(.00008303,.0);\n\n    vec2 v = u;\n    float e = 2.;\n\n    for(float i = 0.; i < 32.; ++i)\n    {\n        u = vec2(atan(u.y,u.x),log(length(u)));\n        u = sin(atan(u.x,u.y)*e+vec2(0.,pi*.5))*pow(length(u),e);\n        u-= v*v;\n    }\n    fragColor = vec4(exp(dot(u,u)*-.02));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 461]], "test": "untested"}
{"id": "tdXBz2", "name": "Camera noise", "author": "kaylent", "description": "camera noise visual effect", "tags": ["noise", "camera"], "likes": 6, "viewed": 477, "published": 3, "date": "1588609781", "time_retrieved": "2024-07-30T21:08:57.149565", "image_code": "// \"Camera noise\" by kaylent - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n//random alghoritm by Spatial https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl \n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)); }\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec2 fishEye(vec2 uv){\n    uv -= vec2(0.5,0.5);\n    uv = uv * 1.2 * (0.833 + 2.0f * uv.x*uv.x * uv.y*uv.y);\n    uv += vec2(0.5,0.5);\n    return uv;\n}\n\nvec2 squadShift(vec2 fragCoord){\n    vec2 shift;\n    shift.x = random(floor(fragCoord.x/60.0))*float(uint(fract(iTime/3.0)+0.10))/24.0;\n    shift.y = random(floor(fragCoord.y/60.0))*float(uint(fract(iTime/3.0)+0.10))/24.0;\n    shift.x += random(floor(fragCoord.x/60.0))*float(uint(fract(iTime/11.0)+0.10))/48.0;\n    shift.y += random(floor(fragCoord.y/60.0))*float(uint(fract(iTime/11.0)+0.10))/48.0;\n    return shift;\n}\n\nvec2 scanShift(vec2 fragCoord){\n    vec2 shift;\n    shift.y = exp(-pow(iResolution.y-fragCoord.y-fract(iTime*2000./8000.)*8000.,2.0)/1.);\n    shift.y += exp(-pow(iResolution.y-20.-fragCoord.y-fract(iTime*2000./8000.)*8000.,2.0)/1.);\n    shift.y += exp(-pow(iResolution.y-fragCoord.y-fract(iTime*2000./3000.)*12000.,2.0)/1.);\n    shift.y += exp(-pow(iResolution.y-fragCoord.y-fract(iTime*2000./2400.)*23400.,2.0)/1.);\n    shift.x = 0.;\n    return shift;\n}\n\n\nvec3 tonalCompression(vec3 color, float exposure ){\n    return vec3(1.0) - exp(-color * exposure);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 texColor;\n\n    uv += squadShift(fragCoord);\n    uv += scanShift(fragCoord);\n    uv = fishEye(uv);    \n\t//remove the second part for more purity\n    float noise = (sin(uv.y*350.0f+iTime*14.f)+1.35)*min((random(uv+iTime*2.f)*10.),1.0);\n    noise = min(noise, 1.0);\n    \n\ttexColor = texture(iChannel0,uv).xyz*noise;\n\ttexColor = tonalCompression(texColor, 3.0f);\n    \n    fragColor = vec4(texColor,1.0f);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBz2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[232, 303, 324, 324, 455], [458, 458, 480, 480, 513], [515, 515, 547, 547, 967], [969, 969, 994, 994, 1045], [1046, 1046, 1071, 1071, 1122], [1124, 1124, 1146, 1146, 1273], [1275, 1275, 1307, 1307, 1695], [1697, 1697, 1728, 1728, 2151], [2154, 2154, 2205, 2205, 2258], [2261, 2261, 2318, 2318, 2777]], "test": "untested"}
{"id": "wsffR2", "name": "Blur with bias", "author": "gmakoveckij", "description": "blur", "tags": ["blur"], "likes": 1, "viewed": 277, "published": 3, "date": "1588609761", "time_retrieved": "2024-07-30T21:08:58.003787", "image_code": "void mainImage( out vec4 col, in vec2 coord )\n{\n    // BLUR\n    vec4 t_c = texture(iChannel0, coord/iResolution.xy) / 2.;\n    vec4 t_tr = texture(iChannel0, (coord + vec2(cos(iTime) * 10.))/iResolution.xy) / 4.;\n    vec4 t_dl = texture(iChannel0, (coord - vec2(sin(iTime) * 10.))/iResolution.xy) / 4.;\n    \n    col = t_c + t_tr + t_dl;\n    \n    // DEFAULT\n    //col = texture(iChannel0, coord/iResolution.xy);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsffR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 59, 411]], "test": "untested"}
{"id": "tsffR2", "name": "Outcome of Nothing", "author": "DerStefan", "description": "Click : new Start\nSpace: new Frame\n\nJust pause somewhere and step with SPACE", "tags": ["gameoflife", "cellularautomata", "mandala"], "likes": 3, "viewed": 500, "published": 3, "date": "1588609654", "time_retrieved": "2024-07-30T21:08:58.755777", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int SCALE = 3;\nconst int SIZE = 1024;\nconst int STOP=810;\n\n\nfloat isColor(vec4 c)\n{\n\t\t\n    if(c.r+c.g+c.b>=0.2){\n        return 1.0;\n    }\n        else {\n        return 0.0;\n    } \n    \n}\n\nvec4 doRule(float sum){\n\tvec4 c = vec4(0.,0.,0.,1.0);\n\tif(sum==1.0)c= vec4(1.0,0.6,0.1,0.0);\n\t//if(sum==4.0)c= vec4(0.6,0.5,0.2,0.0);\n\tif(sum==6.0)c= vec4(0.2,0.1,0.6,0.0);\n\tif(sum==8.0)c= vec4(0.4,0.5,0.2,0.0); \n\treturn c;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame<STOP && 1.0==mod(float(iFrame),float(2))){\n    fragCoord -= mod(fragCoord, float(SCALE));\n\tfloat midx = 0.5*iResolution.x-mod(0.5*iResolution.x,float(SCALE));\n    float midy = 0.5*iResolution.y-mod(0.5*iResolution.y,float(SCALE));\n    \n    if (iFrame == 1 || iMouse.z > .5)\n    {      \n        if(fragCoord.x!=midx || fragCoord.y!=midy ){\n \t\tfragColor = vec4(0);\n        } else {\n         fragColor = vec4(1);   \n        }\n    }\n    else\n    {\n        if(abs(fragCoord.x-midx)*2.0<float(SIZE*SCALE) && abs(fragCoord.y-midy)*2.0<float(SIZE*SCALE)){\n        vec2 o = float(SCALE) / iResolution.xy;\n        vec2 uv = (fragCoord / iResolution.xy) + (o * .5);\n        \n        float accum = 0.;\n        float self = 0.;\n        for (int i = -1; i <= 1; ++i)\n        {\n            for (int j = -1; j <= 1; ++j)\n            {\n\t\t\t\tfloat s = isColor(texture(iChannel0, uv + o * vec2(i, j)));\n                if (i == 0 && j == 0)\n                    self = s;\n                else\n                    accum += s;\n            }\n        }\n      \n        fragColor = vec4(doRule(accum));\n        } else {\n         fragColor= vec4(0.0,0.0,0.0,0.0);   \n        }\n    }\n    } else {\n        fragColor = texture(iChannel0,(fragCoord / iResolution.xy));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsffR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 131]], "test": "untested"}
{"id": "wdfBzj", "name": "MS-06 ZAKU", "author": "yasuo", "description": "reference images: [url]https://www.google.com/search?q=zaku+head&tbm=isch[/url]", "tags": ["reproduction", "zaku"], "likes": 7, "viewed": 353, "published": 3, "date": "1588598365", "time_retrieved": "2024-07-30T21:08:59.606502", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 80.\n#define SURF_DIST .002\n#define EDGE_WIDTH 0.015\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat edge;\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 emitColor(vec3 p, vec3 emitPos, vec3 emitColor, float radius, float softness, float brightness) {\n    float c = smoothstep(-softness,softness,-(length(p-emitPos)-radius));\n    emitColor = (emitColor*c)*brightness;\n    return emitColor;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n// ventilator pipe based on the sdLink distance function\n// Notice that the following function is not reusable code.\nfloat sdVentilator( vec3 p, float le, float r1, float r2 )\n{\n    p.x*=0.9;\n    vec3 prevP = p;\n    vec3 q = vec3( p.x, p.y, max(abs(p.z)-le,0.0) );\n    vec2 p2 = vec2(length(q.xz)-r1,q.y);\n\n    float d = length(p2) - r2;\n\tfloat d2 = length(p2) - (r2*0.8);\n    \n    float space = 0.05;\n    p.z = mod(p.z,0.38)-0.19;\n    float b = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n\tfloat b2 = sdBox(p,vec3(1.5,0.3,0.9));\n    b = max(b2,b);\n    \n    p*= matRotateY(radians(52.0));\n    float b3 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b3);\n\n    p*= matRotateY(radians(70.0));\n\tfloat b4 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b4);\n    \n    p*= matRotateY(radians(-52.0));\n    float b5 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b5);\n\n    p*= matRotateY(radians(-70.0));\n\tfloat b6 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b6);\n    \n    \n    vec3 p3 = p-vec3(0.0,0.02,1.15);\n    p3*= matRotateZ(radians(90.0));\n    float d3 = sdCappedCylinder(p3,0.2,0.33);\n    \n    return min(min(d2,d3),max(-b,d))*0.6;\n}\n\nfloat headBack(vec3 p) {\n    float size = 1.5;\n    float thickness = 0.35;\n    vec4 a1 = vec4(0.0,size,1.6,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size,0.0,0.85); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.15); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.15); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat sdHead(vec3 p) {\n    vec3 prevP = p;\n    p.x*=1.15;\n    float d =  length(p)-1.0;\n    d = max(-(p.y+0.3),d);\n    float d2 = sdBox(p-vec3(0.0,0.3,1.0),vec3(1.5,0.2,0.5));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p*=matRotateX(radians(-110.0));\n    p.y-=1.25;\n    p.z+=1.35;\n    float sc = mix(0.7,3.0,smoothstep(-1.0,1.0,p.y));\n    vec3 p2 = p-vec3(0.0,-0.25,1.2);\n    p2.x*=sc;\n    \n    d2 = sdBox(p2,vec3(0.6,0.46,.15));\n    d = smin(d,d2,0.3);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.85;\n    d2 = sdBox(p-vec3(0.0,0.34,0.15),vec3(0.15,0.15,0.15));\n    d = max(-d2,d);\n    p = prevP;\n    p*=matRotateX(radians(-18.0));\n    d2 = sdBox(p-vec3(0.0,0.1,1.5),vec3(0.2,0.1,0.1));\n    d = max(-d2,d);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    p.x-=0.15;\n    \n    d2 = headBack(p-vec3(0.0,-0.04,-1.08));\n    d = smin(d,d2,0.1);\n    \n    return d*0.6;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = 0.0;\n    \n    p*=matRotateX(radians(-10.0));\n    float v = sdVentilator(p-vec3(0.0,1.2+y,-0.2),0.3,0.9,0.15);\n    p = prevP;\n\tfloat h = sdHead(p-vec3(0.0,1.1+y,0.0));\n    \n    float d = min(v,h);\n    vec4 res = vec4(vec3(0.4,0.5,0.4),d);\n        \n    vec3 eyeEmitPos = vec3(sin(iTime*2.0)*0.2,1.43+y,0.56);\n    vec3 eyePos = p-eyeEmitPos;\n    eyePos *= matRotateX(radians(90.0));\n    vec3 ecol = emitColor(p,eyeEmitPos, vec3(1.0,0.5,0.8),0.0001,0.9,3.0);\n    d = sdCappedCylinder(eyePos,0.15,0.02);\n    vec4 eye = vec4(vec3(0.7,0.0,0.0)+ecol,d);\n    \n    vec4 model = combine(res,eye);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float lastDistEval = 1e10; \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n\t\tif (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n\t\t}\n        if (dist < lastDistEval) lastDistEval = dist;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 zionLogo(vec2 p, vec3 col, vec3 bcol) {\n    vec2 prevP = p;\n    p.y*=0.95;\n    float d = length(p)-0.2;\n    p.x*=1.2;\n    float d2 = length(p)-0.18;\n    d = max(-d2,d);\n    \n    p.x = abs(p.x);\n    p.x -= 0.15;\n    d2 = sdTriangle(p, vec2(0.22,0.05), vec2(0.03,-0.02), vec2(0.0,-0.155));\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,0.35), vec2(0.03,-0.2), vec2(0.0,0.0), vec2(0.0,-0.3));\n    d = min(d,d2);\n    p = prevP;\n    \n    d2 = sdBox(p-vec2(0.0,-0.15),vec2(0.012,0.25));\n    d = min(d,d2);\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,-0.35), vec2(0.05,0.00), vec2(0.00,-0.03), vec2(0.0,-0.14));\n    d = min(d,d2);\n    p = prevP;\n    \n\tp.x = abs(p.x);\n    p.x -= 0.01;\n    d2 = sdTriangle(p-vec2(0.0,-0.1), vec2(0.1,0.05), vec2(0.0,0.0), vec2(0.0,-0.05));\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,-0.27), vec2(0.45,0.2), vec2(0.0,0.0), vec2(0.15,-0.03));\n    d = min(d,d2);\n    p = prevP;\n    \n\tp.x = abs(p.x);\n    p.x -= 0.01;\n    d2 = sdTriangle(p-vec2(0.0,0.02), vec2(0.3,0.2), vec2(0.0,0.0), vec2(0.0,-0.06));\n    d = min(d,d2);\n    p = prevP;\n    \n    col = mix(col,bcol,S(d,-0.002));\n    return col;\n}\n\nvec3 serialNumber(vec2 p, vec3 col, vec3 bcol) {\n    vec2 prevP = p;\n    \n    //　０\n    vec2 p0 = p-vec2(-0.1,0.0);\n    float d = sdBox(p0,vec2(0.1,0.15));\n    float d2 = sdBox(p0,vec2(0.05,0.1));\n    d = max(-d2,d);\n    d2 = sdBox(p0,vec2(0.01,0.2));\n    d = max(-d2,d);\n    \n    // 6\n    vec2 p1 = p-vec2(0.1,0.0);\n    d2 = sdBox(p1-vec2(-0.05,0.0),vec2(0.025,0.15));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(0.025,-0.06),vec2(0.075,0.09));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(0.015,-0.06),vec2(0.04,0.04));\n    d = max(-d2,d);\n    d2 = sdBox(p1-vec2(0.035,0.125),vec2(0.065,0.025));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(-0.02,0.0),vec2(0.01,0.2));\n    d = max(-d2,d);\n    \n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nvec3 animationLine(vec2 p, vec3 col, float dir) {\n    p.x+=iTime*0.1*dir;\n    p.x = mod(p.x,0.02)-0.01;\n    p*=Rot(radians(45.0*dir));\n    float d = sdBox(p,vec2(0.001,0.05));\n\tcol = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3.5, -1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-45.0));\n    ro.xz *= Rot(radians((sin(t*0.2)*80.0)+180.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1.1,0), 1.);\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.rgb;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col =.84*max(mix(vec3(1.1)+(.1-length(uv.xy)/3.),vec3(1),.1),0.);\n        \n        uv*=2.0;\n        col = zionLogo(uv-vec2(1.05,0.5),col,vec3(0.7,0.1,0.1));\n        uv = prevUV;\n        uv*=1.5;\n        col = serialNumber(uv-vec2(-0.9,-0.45),col,vec3(0.95));\n    }\n    \n    col = mix(col,vec3(0.1,0.1,0.1),edge);\n    \n    // overlay contents\n    uv = prevUV;\n    col = animationLine(uv-vec2(0.0,-0.49),col,1.0);\n    col = animationLine(uv-vec2(0.0,0.49),col,-1.0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[659, 659, 700, 700, 791], [793, 793, 829, 829, 871], [873, 873, 902, 902, 986], [988, 988, 1040, 1040, 1147], [1149, 1149, 1251, 1251, 1391], [1393, 1444, 1511, 1511, 2076], [2078, 2129, 2166, 2166, 2246], [2249, 2366, 2426, 2426, 3440], [3442, 3442, 3466, 3466, 4179], [4181, 4181, 4203, 4203, 5048], [5050, 5050, 5072, 5072, 5742], [5744, 5744, 5777, 5777, 6273], [6275, 6275, 6299, 6299, 6500], [6502, 6502, 6536, 6536, 6850], [6852, 6852, 6875, 6875, 7231], [7233, 7233, 7275, 7275, 7470], [7472, 7472, 7516, 7516, 8698], [8700, 8700, 8748, 8748, 9442], [9444, 9444, 9493, 9493, 9673], [9675, 9675, 9732, 9732, 10925]], "test": "untested"}
{"id": "tsfBRj", "name": "fractals ordered construction", "author": "lomateron", "description": "like https://www.shadertoy.com/view/tt3GW2\nbut instead of wraping the image of a cat\nwrap the image of a point of light\nit applies that space wrap multiple times\nbut in order through time\nmouse Y controls how open the hand fan is", "tags": ["mandelbrot"], "likes": 5, "viewed": 392, "published": 3, "date": "1588591625", "time_retrieved": "2024-07-30T21:09:00.517068", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 1.2*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 8.*iMouse.xy/iResolution.xy;\n    float pi = 3.14159265359;\n\n    vec2 v = u;\n    float t = iTime;\n    float r = 2.;\n    if(iMouse.z>0.) t = m.x;\n    if(iMouse.z>0.) r = m.y*4.-16.;\n\n    for(float i = 0.; i < t; ++i)\n    {\n        float s = clamp(t-i,0.,1.);\n        float e = min(s,.5)*r+1.;\n        u = cos(atan(u.y,u.x)*e-vec2(0.,pi*.5))*pow(length(u),e);\n        u+= v*max(s-.5,.0)*2.;\n    }\n    fragColor = vec4(.05/length(u));\n    //fragColor = vec4(exp(dot(u,u)*-1.));\n    //fragColor = texture( iChannel0, vec2(.125,1.)*.1*u+.4 );\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 668]], "test": "untested"}
{"id": "Wsffz2", "name": "Weird Machine on Projector", "author": "blackle", "description": "fake projector look", "tags": ["projector", "machine"], "likes": 16, "viewed": 524, "published": 3, "date": "1588590636", "time_retrieved": "2024-07-30T21:09:01.492460", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x=FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat noise(vec2 uv) {\n    vec2 crds = smoothstep(vec2(0.),vec2(1.),fract(uv));\n    uv = floor(uv);\n    float h1 = hash(uv.x,uv.y);\n    float h2 = hash(uv.x+1.,uv.y);\n    float h3 = hash(uv.x,uv.y+1.);\n    float h4 = hash(uv.x+1.,uv.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nvec2 map(vec2 uv) {\n    return (uv+vec2(0.7,0.4))*vec2(1.,iResolution.x/iResolution.y)*0.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float rot = cos(sin(cos(iTime*0.01)*8.)*8.)*0.5;\n    uv *= mat2(cos(0.01*rot),sin(0.01*rot),-sin(0.01*rot),cos(0.01*rot));\n    \n    float ntime = floor(iTime*25.)/25.;\n    float trackingy = hash(ntime,ntime);\n    float trackingx = hash(trackingy,ntime);\n    float trackinglight = hash(trackingx,ntime)*0.05+1.;\n    uv.y += trackingy/iResolution.y*0.4;\n    uv.x += trackingx/iResolution.y*0.1;\n    \n    vec4 color = vec4(0);\n    for (int i = -2; i < 3; i++) {\n    \tfor (int j = -2; j < 3; j++) {\n            vec2 off = vec2(i,j)/iResolution.y/4.*2.2;\n            float dispersion = hash(hash(hash(uv.x,uv.y),iTime),hash(float(i),float(j)))*0.02+1.;\n            float red = texture(iChannel0,map(uv*dispersion*1.03+off)).x;\n            float green = texture(iChannel0,map(uv*dispersion*1.01+off)).y;\n            float blue = texture(iChannel0,map(uv*dispersion*1.0+off)).z;\n    \t\tcolor += pow(vec4(red, green, blue, 1.),vec4(2.));\n        }\n    }\n\t\n    vec3 satstr = vec3(0.1);\n    mat3 desaturate = mat3(1.-satstr.x*2.)+mat3(satstr,satstr,satstr);\n    \n    float bounds = smoothstep(0.02,-0.02,max(abs(uv.x)-0.7,abs(uv.y)-0.4)) * smoothstep(2.,0.,length(uv));\n    float filmgrain = (noise((uv+mod(floor(ntime*60.),100.))*iResolution.y/1.5)*0.5+0.5)*0.05;\n    float shotnoise = abs(hash(hash(uv.x,uv.y),ntime))*0.05;\n    fragColor.xyz = smoothstep(-0.4,2.,desaturate*bounds*sqrt(color.xyz/color.w))*trackinglight;\n    fragColor.xyz += pow(1./(1.+length(uv*vec2(2,1)-vec2(1.,.7))),3.)*0.25*(sign(trackingy+0.99)*0.5+0.5);\n    fragColor.xyz += pow(1./(1.+length(uv*vec2(2,1)-vec2(-1.,.7))),3.)*0.5;\n    fragColor.xyz += filmgrain*mix(0.3,1.2,bounds) + shotnoise*mix(1.5,0.5,bounds) + smoothstep(0.06,-0.06,max(abs(uv.x)-0.7,abs(uv.y)-0.4))*0.02;\n    fragColor.xyz *= smoothstep(2.,0.2,length(uv));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//set FOCALBLUR to 1 and SAMPS to 3 for a prettier shader, but beware, it's slow!\n#define FOCALBLUR 0\n#define SAMPS 1\n\nfloat ntime;\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(vec3(0),q)) + min(0., max(q.x,max(q.y,q.z)));\n}\n\nfloat fancyrings(vec3 p) {\n    p=abs(p);\n    p.xy = vec2(max(p.x,p.y),min(p.y,p.x));\n    float ring = length(vec2(super(p.xy)-1.8,p.z))-0.2;\n    float metaring = super(vec2(length(p.xz-vec2(1.8,0.))-0.5, p.y-(0.5+0.25*cos(ntime*8.))))-0.2;\n    return min(ring,metaring);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    float b = box(erot(p,vec3(0,0,1),p.z*0.5+ntime),vec3(0.25,0.25,4))-0.5;\n    float scale = 0.65;\n    p.z = (asin(sin(p.z*scale*3.14)*0.99)/3.14)/scale;\n    float ring1 = fancyrings(p+vec3(0,0,.75));\n    float ring2 = fancyrings(erot(p,vec3(0,0,1),radians(45.))-vec3(0,0,0.75));\n    return min(min(ring1,ring2),b);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat noise(vec2 p) {\n    vec2 id = floor(p);\n    vec2 crds = fract(p);\n    float h1 = hash(id.x,id.y);\n    float h2 = hash(id.x+1.,id.y);\n    float h3 = hash(id.x,id.y+1.);\n    float h4 = hash(id.x+1.,id.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nfloat triplanar(vec3 p, vec3 n) {\n    return mix(noise(p.xy), mix(noise(p.xz), noise(p.yz), n.x*n.x), 1.-n.z*n.z);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\nvec3 srgb(float r) {\n    return vec3(r*r);\n}\n\nfloat speed(float x) {\n    return pow(sin(fract(x)*3.14/2.),200.)+floor(x)+x*2.;\n}\n\nvec3 pixel(vec2 uv) {\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-6,0,0);\n    \n    float h1 = hash(hash(uv.x,uv.y),ntime*8.);\n    float h2 = hash(h1,ntime);\n    float h3 = hash(h2,ntime);\n    vec3 blur = normalize(tan(vec3(h1,h2,h3)))*float(FOCALBLUR);\n    cam+=blur*0.025;\n    init-=blur*0.1;\n    \n    float ramptime = speed(ntime*0.25);\n    float yrot = 0.2;\n    float zrot = ramptime;\n    init.x += sin(ramptime*0.5);\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    init.z += cos(ramptime);\n    \n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float marble = smoothstep(-0.5,0.4,triplanar(p*4., n));\n    float tex = max(triplanar(p*80., n),0.)*marble;\n    float spexex = mix(8., 6., tex);\n    float ao = smoothstep(-1.,1.,scene(p+r*0.3)/0.3/dot(r,n))*0.5+0.5;\n    float diff1 = ao*pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n    float diff2 = ao*pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n    float diff3 = ao*pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n    vec3 col1 = mix(srgb(0.,.05,.1), srgb(0.4,.3,1.), diff1) + pow(diff1, spexex)*1.5;\n    vec3 col2 = mix(srgb(0.1,.0,0.5), srgb(1.,.2,0.5), diff2) + pow(diff2, spexex)*1.5;\n    vec3 col3 = mix(srgb(0.1), srgb(0.9,0.9,1.), diff3) + pow(diff3, spexex)*1.5;\n    vec3 col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));\n    return hit ? col : mix(srgb(0.25), srgb(0.1), length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    ntime = floor(iTime*25.)/25.;\n\n    vec4 col;\n    for (int i = 0; i<SAMPS;i++) {\n        for (int j = 0; j<SAMPS;j++) {\n            vec2 off= vec2(i,j)/iResolution.y/float(SAMPS);\n            col += vec4(pixel(uv+off), 1);\n        }\n    }\n    fragColor.xyz = col.xyz/col.w;\n    fragColor.xyz = sqrt(fragColor.xyz) + hash(hash(uv.x,uv.y),ntime)*0.02;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsffz2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[249, 249, 279, 279, 356], [358, 358, 380, 380, 659], [661, 661, 680, 680, 754], [756, 756, 813, 813, 2673]], "test": "untested"}
{"id": "3dXfR2", "name": "Memetic Kill Agent (Click2View)", "author": "blackle", "description": "this is my design for a \"memetic kill agent\", a fictional concept, popularized by the SCP foundation. because it's a little flashy and might be bad for photosensitive people, I've hidden it behind the mouse click.", "tags": ["scp", "cognitohazard", "memetic"], "likes": 8, "viewed": 514, "published": 3, "date": "1588588750", "time_retrieved": "2024-07-30T21:09:02.300300", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x=FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\n\nvec2 map(vec2 uv) {\n    return (uv*iResolution.y+0.5*iResolution.xy)/iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec4 color = vec4(0);\n    for (int i = -2; i < 3; i++) {\n    \tfor (int j = -2; j < 3; j++) {\n            vec2 off = vec2(i,j)/iResolution.y/4.*1.5;\n            float dispersion = hash(hash(hash(uv.x,uv.y),iTime),hash(float(i),float(j)))*0.02+1.;\n            float red = texture(iChannel0,map(uv*dispersion*1.03+off)).x;\n            float green = texture(iChannel0,map(uv*dispersion*1.01+off)).y;\n            float blue = texture(iChannel0,map(uv*dispersion*1.0+off)).z;\n    \t\tcolor += pow(vec4(red, green, blue, 1.),vec4(2.));\n        }\n    }\n\n    fragColor.xyz = sqrt(color.xyz/color.w)*0.9+abs(hash(hash(uv.x,uv.y),iTime))*0.1;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x=FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat speed(float x) {\n    return pow(sin(fract(x)*3.14/2.),100.)+floor(x)+x*2.;\n}\n\nfloat noise(vec2 uv) {\n    vec2 crds = smoothstep(vec2(0.),vec2(1.),fract(uv));\n    uv = floor(uv);\n    float h1 = hash(uv.x,uv.y);\n    float h2 = hash(uv.x+1.,uv.y);\n    float h3 = hash(uv.x,uv.y+1.);\n    float h4 = hash(uv.x+1.,uv.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nfloat wild(vec2 uv, float time) {\n    float t = speed(speed(speed(time)*0.4)*0.3);\n    float color = 0.;\n    for (int i = 0; i < 50; i++) {\n        float h1 = hash(float(i), float(i));\n        float h2 = hash(h1, float(i));\n        float h3 = hash(h2, float(i));\n        float h4 = hash(h3, float(i));\n        color += cos(80.*dot(uv, vec2(h1,h2))+t*h4+h3*100.);\n    }\n    int idx = int(floor(t));\n        float h1 = hash(float(idx), float(idx));\n        float h2 = hash(h1, float(idx));\n    vec2 uv2 = uv+floor(time*10.)/10.*vec2(h1,h2);\n    float m1 = noise(uv2*20.+float(idx)*20.)*0.5+0.5;\n    m1 = smoothstep(0.3,0.6, m1);\n    return color*m1*1.5+time*40.;\n}\n\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat cognitohazard(vec2 uv) {\n    float rnd = sin(noise(uv+iTime*8.+5.)*0.1)*0.5+0.5;\n    float t = floor(iTime*10.)/40. + fract(iTime*10.)/40.*rnd;\n    float m1 = noise(uv*10.+floor(iTime)*20.)*0.5+0.5;\n    m1 = smoothstep(0.5,.9, m1);\n    float color = mix(wild(uv,t), wild(uv*0.5+100.,t), m1);\n    float bx = max(abs(uv.x),abs(uv.y));\n    if (bx>0.3 || bx<0.1) {\n        color = 0.;\n    }\n    color = sin(color)*80. < 0. ? 1. : 0.;\n    if (iMouse.z < 0. || iMouse.x == 0.) {\n        color = 0.;\n    }\n    uv = abs(uv);\n    uv = vec2(max(uv.x,uv.y), min(uv.x,uv.y));\n    float ld = linedist(uv, vec2(0), vec2(0.01));\n    if (ld < 0.002) {\n        color = 1.;\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    fragColor.xyz = vec3(cognitohazard(uv));\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfR2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[249, 249, 279, 279, 356], [359, 359, 378, 378, 445], [447, 447, 504, 504, 1205]], "test": "untested"}
{"id": "wslfRB", "name": "Radial Optical Illusion", "author": "kstyler", "description": "If you stare at the image for long enough the next time you look at a wall, it (the wall) will appear to move.", "tags": ["illusion"], "likes": 4, "viewed": 397, "published": 3, "date": "1588551901", "time_retrieved": "2024-07-30T21:09:03.117116", "image_code": "\nmat2 rotate(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 uv = (fragCoord.xy -0.5* iResolution.xy)/iResolution.x;\n    vec2 p = uv;\n    //rotate ring\n    p*=rotate(iTime/1.);\n    \n    //create ring\n    float ang = 6.283185/90.0;\n    float sector = round(atan(p.x,p.y)/ang);\n    float an = sector*ang;\n    vec2 q = p;\n    q = rotate(an)*q;\n    \n    //duplicate ring radialy \n    float c = 0.006;\n    q.y-=iTime/10.;\n    q.y = mod(q.y+0.5*c,c)-0.5*c;\n   \n    //make circles\n    vec3 r = vec3(length(q));\n    vec3 color = smoothstep(0.0019,0.002,r);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 71], [73, 73, 127, 127, 660]], "test": "untested"}
{"id": "wdsfRS", "name": "circlegrid02", "author": "paulobarcelos", "description": "circlegrid02", "tags": ["circlegrid02"], "likes": 3, "viewed": 302, "published": 3, "date": "1588542048", "time_retrieved": "2024-07-30T21:09:03.973825", "image_code": "// inspired by https://www.youtube.com/watch?v=cQXAbndD5CQ\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv - center and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    // uv - rotate 45 deg\n\tfloat a = 0.7853982; // 45 in radians\n    float sa = sin(a);\n    float ca = cos(a);\n    uv *= mat2(ca, -sa, sa, ca);\n    \n    float time = iTime * 2.0;\n    vec3 col = vec3(0);\n    \n    float divisions = 11.0;\n    vec2 gv = fract(uv * divisions) - 0.5;\n    vec2 id = floor(uv * divisions);\n    gv.x *= mod(id.x, 2.0) == 0.0 ? 1.0 : -1.0;\n    gv.y *= mod(id.y, 2.0) == 0.0 ? 1.0 : -1.0;\n    \n    float d = length(gv + vec2(sin(time) * 2.0, cos(time) * 2.0) * 0.25);\n    float radius = 0.5 * (0.1 + sin(time * 0.25 + length(uv) * 3.12) * 0.5 + 0.5);\n    float circle = smoothstep(radius + 0.01, radius - 0.02, d);\n    \n   \n    col = mix(vec3(0.125, 0.874, 0.733), vec3(0.874, 0.125, 0.266), circle);\n    \n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 157, 991]], "test": "untested"}
{"id": "tdlBRS", "name": "circlegrid01", "author": "paulobarcelos", "description": "circlegrid01", "tags": ["circlegrid01"], "likes": 2, "viewed": 309, "published": 3, "date": "1588541560", "time_retrieved": "2024-07-30T21:09:04.879404", "image_code": "// inspired by https://www.youtube.com/watch?v=cQXAbndD5CQ\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv - center and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    // uv - rotate 45 deg\n\tfloat a = 0.7853982; // 45 in radians\n    float sa = sin(a);\n    float ca = cos(a);\n    uv *= mat2(ca, -sa, sa, ca);\n    \n    float time = iTime * 2.0;\n    vec3 col = vec3(0);\n    \n    float divisions = 11.0;\n    vec2 gv = fract(uv * divisions) - 0.5;\n    vec2 id = floor(uv * divisions);\n    gv.x *= mod(id.x, 2.0) == 0.0 ? 1.0 : -1.0;\n    gv.y *= mod(id.y, 2.0) == 0.0 ? 1.0 : -1.0;\n    \n    float d = length(gv + vec2(sin(time) * 2.0, cos(time) * 2.0) * 0.25);\n    float radius = 0.5 * (0.1 + sin(time * 0.25 + length(uv) * 3.12) * 0.5 + 0.5);\n    float circle = smoothstep(radius + 0.02, radius - 0.02, d);\n    \n    \n    col.rg = gv;\n    \n    col += d;\n    col = pow(col, vec3(4.0));\n   \n    col = max(col, vec3(circle));\n    \n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 157, 1020]], "test": "untested"}
{"id": "WdlfzB", "name": "radiance03", "author": "paulobarcelos", "description": "radiance03", "tags": ["radiance03"], "likes": 0, "viewed": 281, "published": 3, "date": "1588537831", "time_retrieved": "2024-07-30T21:09:05.716167", "image_code": "\nfloat noise(vec2 p) {\n    float a = sin(p.x * 1234.456) * cos(p.y * 5678.1234) * 999.0;\n    float b = cos(p.x * 2355.234) * sin(p.y * 3534.3465) * 456.0;\n    return fract(a + b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float scale = 0.5;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float time = mod(iTime, 6.35);\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 center = vec2(0);\n    vec2 follow = mix(center, vec2(mouse.x, 0.0), clamp(iMouse.w, 0., 1.));\n    \n    uv *= scale;\n    follow *= scale;\n    vec3 col = vec3(0);\n\n    float points = mix(noise(uv), noise(uv + iTime * 0.000001), 0.01);\n    float focus = clamp(length(uv.xx - follow + vec2(sin(time), cos(time)) * 0.01), 0.0, 1.0);\n    float waves = pow((1.0 - focus) * sin(pow(focus, 0.5) * 200.0 - time) * 0.5 + 0.5, 1.5);\n    float mask = smoothstep(0.0, 0.0001, smoothstep(0.2, 0.0, pow(focus + waves * 0.05, 0.8) * points + focus * 0.15));\n\n    col = mix(vec3(0.2, 0.0, 0.1), vec3(0.9, 0.9, 0.8), mask);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 181], [182, 182, 239, 239, 1076]], "test": "untested"}
{"id": "3ssBRS", "name": "radiance01", "author": "paulobarcelos", "description": "radiance01", "tags": ["radiance01"], "likes": 0, "viewed": 286, "published": 3, "date": "1588517663", "time_retrieved": "2024-07-30T21:09:06.513036", "image_code": "float noise(vec2 p) {\n    float a = sin(p.x * 1234.456) * cos(p.y * 5678.1234) * 999.0;\n    float b = cos(p.x * 2355.234) * sin(p.y * 3534.3465) * 456.0;\n    return fract(a + b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float scale = 0.5;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float time = mod(iTime, 6.35);\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 center = vec2(0);\n    vec2 follow = mix(center, mouse, clamp(iMouse.w, 0., 1.));\n    \n    uv *= scale;\n    follow *= scale;\n    vec3 col = vec3(0);\n\n    float points = mix(noise(uv), noise(uv + time * 0.000001), 0.01);\n    float focus = clamp(length(uv - follow + vec2(sin(time), cos(time)) * 0.01), 0.0, 1.0);\n    float waves = pow((1.0 - focus) * sin(pow(focus, 0.5) * 200.0 - iTime) * 0.5 + 0.5, 1.5);\n    float mask = smoothstep(0.0, 0.0001, smoothstep(0.2, 0.0, pow(focus + waves * 0.05, 0.8) * points + focus * 0.15));\n\n    col = mix(vec3(0.2, 0.0, 0.1), vec3(0.9, 0.9, 0.8), mask);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 180], [181, 181, 238, 238, 1059]], "test": "untested"}
{"id": "wdfBzB", "name": "Isolating Androids", "author": "dr2", "description": "Gotta stay safe", "tags": ["torus", "robot", "moebius"], "likes": 7, "viewed": 361, "published": 3, "date": "1588509080", "time_retrieved": "2024-07-30T21:09:07.441554", "image_code": "// \"Isolating Androids\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir;\nfloat tCur, dstFar, tRadB, tRadS;\nint idObj;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat RobDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float szFac, rAngH, rAngA, d, s;\n  s = sin (pi * tCur);\n  rAngH = -0.7 * s;\n  rAngA = 1.1 * s;\n  szFac = 0.15;\n  dMin /= szFac;\n  p /= szFac;\n  p.y -= 0.25;\n  q = p; \n  q.y -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.y - 0.2);\n  q = p; \n  q.y -= 1.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.9, 0.28, 0.75));\n  q = p;  \n  q.x = abs (q.x); \n  q.xy -= vec2 (1.05, 2.);\n  q.yz = Rot2D (q.yz, rAngA * sign (p.x));\n  q.y -= -0.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;\n  q.xz = Rot2D (q.xz, rAngH);\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.3, 3.1);\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  q.y -= 0.25;\n  d = min (d, PrRoundCylDf (q.xzy, 0.06, 0.04, 0.3));\n  q = p;\n  q.xy -= vec2 (0.4, 0.3);\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  q = p;\n  q.x = - q.x;  \n  q.xy -= vec2 (0.4, 0.3);\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  DMIN (2);\n  q = p;\n  q.xz = Rot2D (q.xz, rAngH);\n  q.x = abs (q.x); \n  q -= vec3 (0.4, 2.7, 0.7);  \n  d = PrSphDf (q, 0.15);\n  DMIN (3);\n  return szFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b;\n  float dMin, d, a, t, ns;\n  dMin = dstFar;\n  p.yz = Rot2D (p.yz, 0.1 * pi);\n  q = p;\n  ns = 16.;\n  t = 0.05 * tCur;\n  d = length (vec2 (Rot2D (vec2 (length (q.xz) - tRadB, q.y),\n     0.5 * atan (q.z, q.x)))) - tRadS;\n  q.xz = Rot2D (q.xz, t);\n  a = 2. * pi * (floor (ns * atan (q.z, - q.x) / (2. * pi)) + 0.5) / ns;\n  q.xz = Rot2D (q.xz, a);\n  q.x += tRadB;\n  q.xy = Rot2D (q.xy, 0.5 * (a + t));\n  b = vec2 (0.95 * tRadS, 0.65 * pi * tRadB / ns);\n  d = max (d, - max (PrBox2Df (vec2 (abs (q.x) - tRadS, q.z), b),\n     PrBox2Df (vec2 (abs (q.y) - tRadS, q.z), b)));\n  DMIN (1);\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (4. * atan (q.y, - q.x) / (2. * pi)) / 4.)) -\n     vec2 (-0.35, 0.06);\n  q.xz = vec2 (q.z, - q.x);\n  dMin = RobDf (q, dMin);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  p.yz = Rot2D (p.yz, 0.1 * pi);\n  return PrTorusDf (p.xzy, tRadS - 0.02, tRadB);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ErCol (vec3 rd)\n{\n  vec3 erDir, col, vn;\n  float erRad, bs, ts;\n  erDir = normalize (vec3 (0.02, -0.04, 1.));\n  erRad = 0.04;\n  col = vec3 (0.);\n  bs = dot (rd, erDir);\n  ts = bs * bs - 1. + erRad * erRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - erDir) / erRad);\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (1., 1., 0.95),\n         smoothstep (0.2, 0.8, Fbm2 (6. * vn.xy + 7.1))) * (0.5 + 0.5 * max (- dot (vn, rd), 0.)) *\n         (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n    }\n  }\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  col = ErCol (rd);\n  if (length (col) < 0.03) col += StarPat (rd, 16.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, colR, vn, roo;\n  float dstObj, dstObjT;\n  tRadB = 3.;\n  tRadS = 0.8;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.5, 0.5, 0.55, 0.2);\n    else if (idObj == 2) col4 = vec4 (0., 1., 1., 0.2);\n    else if (idObj == 3) col4 = vec4 (1., 0., 0., 0.2);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = BgCol (rd);\n  }\n  ro = roo;\n  dstObjT = TrObjRay (ro, rd);\n  if (dstObjT < min (dstObj, dstFar)) {\n    ro += dstObjT * rd;\n    vn = TrObjNf (ro);\n    col = mix (0.1 + 1.5 * BgCol (reflect (rd, vn)), col, 0.1 +\n       0.9 * smoothstep (0.1, 0.7, - dot (rd, vn)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.07 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 6.;\n  dstFar = 50.;\n  ltDir = normalize (vec3 (1., 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBzB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[624, 624, 658, 658, 1692], [1694, 1694, 1716, 1716, 2501], [2503, 2503, 2536, 2536, 2719], [2721, 2721, 2742, 2742, 2997], [2999, 2999, 3023, 3023, 3107], [3109, 3109, 3144, 3144, 3330], [3332, 3332, 3355, 3355, 3612], [3614, 3614, 3636, 3636, 4171], [4173, 4173, 4208, 4208, 4661], [4663, 4663, 4685, 4685, 4786], [4788, 4788, 4823, 4823, 5690], [5692, 5692, 5748, 5748, 6726], [6728, 6728, 6761, 6761, 6788], [6790, 6790, 6823, 6823, 6912], [6914, 6914, 6971, 6971, 7135], [7137, 7137, 7183, 7183, 7240], [7242, 7242, 7264, 7264, 7302], [7304, 7304, 7340, 7340, 7546], [7548, 7548, 7578, 7578, 7691], [7725, 7725, 7749, 7749, 7861], [7863, 7863, 7888, 7888, 8074], [8076, 8076, 8097, 8097, 8252]], "test": "untested"}
{"id": "tsXBzB", "name": "Carre de Sierpinzki", "author": "Windless", "description": "Simplest self-contained fractal I could think of.", "tags": ["fractal"], "likes": 1, "viewed": 318, "published": 3, "date": "1588507384", "time_retrieved": "2024-07-30T21:09:08.285298", "image_code": "vec4 carre(vec2 from, vec2 to, vec2 pos) {\n    \n    while(true) {\n    \n        int colone = int((pos.x - from.x) / (to.x - from.x) * 3.);\n        int ligne  = int((pos.y - from.y) / (to.y - from.y) * 3.);\n\n        if( (colone == 1) && (ligne == 1) ) return vec4(0.,0.,33.,1.);\n\n        if(distance(from, to) < 0.11 + (cos(iTime) * 0.1) ) {\n            return vec4(0.33,0.33, 1.00, 1.);\n        }\n\n\t\tvec2 newFrom = vec2(\n            from.x + (to.x - from.x) / 3. * float(colone) \n            , from.y + (to.y - from.y) / 3. * float(ligne)\n        );\n        vec2 newTo = vec2(\n            from.x + (to.x - from.x) / 3. * float(colone + 1) \n            , from.y + (to.y - from.y) / 3. * float(ligne + 1)\n        );\n        \n        from = newFrom;\n        to = newTo;\n        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = carre(vec2(0., 0.), vec2(1.,1.), uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 782], [784, 784, 841, 841, 937]], "test": "untested"}
{"id": "tsXBzS", "name": "fractal pyramid", "author": "bradjamesgrant", "description": "Creating multiple shapes with one SDF evaluation by repeatedly rotating and folding space", "tags": ["fractalcineshader"], "likes": 647, "viewed": 322972, "published": 3, "date": "1588478931", "time_retrieved": "2024-07-30T21:09:09.081170", "image_code": "vec3 palette(float d){\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<8; ++i){\n        float t = iTime*0.2;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*1.89);\n        p.xz = abs(p.xz);\n        p.xz-=.5;\n\t}\n\treturn dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.5;\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n        \tbreak;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 73], [75, 75, 103, 103, 175], [177, 177, 195, 195, 396], [398, 398, 425, 425, 803], [804, 804, 861, 861, 1256]], "test": "untested"}
{"id": "tsXBRS", "name": "Graph Network**", "author": "wyatt", "description": "Some research Michael and I are working on, mixing fluid math and particle math.", "tags": ["graph"], "likes": 42, "viewed": 1316, "published": 3, "date": "1588468656", "time_retrieved": "2024-07-30T21:09:09.849116", "image_code": "// Fork of \"Graph Network*\" by wyatt. https://shadertoy.com/view/wdjcDR\n// 2020-05-02 23:47:39\n\n// Fork of \"Graph Network\" by wyatt. https://shadertoy.com/view/tssyDS\n// 2020-04-09 20:04:37\nvec4 color (vec2 U, vec2 r) {\n\t vec4 c = C(U+r),\n         a = A(unpack(c.z)), aa = A(unpack(c.w)),\n        d = D(unpack(c.z)),dd = D(unpack(c.z));\n    \n    float o = length(aa.xy-a.xy),\n          q = length(U-a.xy),\n          w = sg(U,a.xy,aa.xy),\n          v = pie(U,a.xy,aa.xy);\n    return max(1.+0.5*(sign(unpack(c.z).x-0.5*R.x))*\n               sin(mix(d.z,dd.z,.5)+vec4(3,2,1,4)),0.5)*\n        (exp(-w)*exp(-.1*o)*.5+0.3*exp(-.2*q));\n\n}\nMain {Q = vec4(0);\n    for (int x = -1; x<=1; x++)\n        for (int y = -1; y<=1; y++) {\n        \tQ += color(U,vec2(x,y))/3./(1.+length(vec2(x,y)));\n        }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define O 4.\n#define shape(U) (round((U)/O)*O+0.5-1e-8)\n#define N 12\n#define Z vec2(u)\n#define ro(a) mat2(cos(a),sin(-a),sin(a),cos(a))\n\n#define unpack(i) vec2(mod(i,R.x),i/R.x)\n#define pack(U) (floor((U).x)+floor((U).y)*R.x)\nfloat angle (vec2 a, vec2 b) {\n\treturn atan(a.x*b.y-a.y*b.x,dot(a.xy,b.xy));\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\nfloat ssg (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-3||length(a)<1.||length(b)<1.) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return (l+1.)*(1.+length(a-b));\n}\nvec2 pie2 (vec2 p, vec2 a, vec2 b) {\n\tif (length(a-b)<1e-3||length(a)<1.||length(b)<1.) return vec2(1e5);\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return vec2(l,length(p-a)); // pojection\n} \nfloat pie (vec2 p, vec2 a, vec2 b) {\n\t if (length(a-b)<1e-3||length(a)<1.||length(b)<1.) return 1e9;\n    vec2 m = 0.5*(a+b); // midpoint\n    return abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} ", "buffer_a_code": "Main {\n    vec2 u = shape(U);\n    if (u.x+O>=R.x||u.y+O>=R.y||u.x<O||u.y<O) {Q = vec4(-1e3,-1e3,0,0);return;}\n    Q = A(u);\n    vec4 qd = D(u);\n    vec2 f = vec2(0);\n    float n = 0.;\n    for (int x=-1;x<=1; x++) {\n        for (int y=-1;y<=1; y++) {\n            vec4 b = B(u+vec2(x,y));\n            vec4\n                a = A(b.xy),\n                d = D(b.xy);\n            vec2 r = (a.xy-Q.xy);\n            float l = length(a.xy-Q.xy);\n            if (l >1e-5&&a.x>3.) {\n                f -= r*(d.z-qd.z)/l/l/l;\n                float m = sign(U.x-0.5*R.x)*sign(b.x-0.5*R.x);\n                f += .5*r*m/l/l/l;\n                f -= 2.*r/l/l/l/l;\n                n++;\n            }\n            a = A(b.zw);\n            d = D(b.zw);\n            r = (a.xy-Q.xy);\n            l = length(a.xy-Q.xy);\n            if (l >1e-5&&a.x>3.) {\n                f -= r*(d.z-qd.z)/l/l/l;\n                float m = sign(U.x-0.5*R.x)*sign(b.x-0.5*R.x);\n                f += .5*r*m/l/l/l;\n                f -= 2.*r/l/l/l/l;\n                n++;\n            }\n        }\n\t}\n    f /= n;\n    Q.w -= 0./R.y;\n    Q.zw += f;\n    Q.xy += f+Q.zw*sqrt(1./(1.+dot(Q.zw,Q.zw)));\n    \n    if (length(Q.zw)>1.)Q.zw=1.*normalize(Q.zw);\n    vec2 mouse = vec2(.3,.5)*R;\n    if (iMouse.z>0.) mouse = iMouse.xy;\n    Q.zw += vec2(.02,0)*smoothstep(20.,18.,length(mouse-Q.xy));\n    if (Q.x<5.) {Q.x=5.;Q.z = +.5*abs(Q.z);}\n    if (R.x-Q.x<5.) {Q.x=R.x-5.;Q.z =-.5*abs(Q.z);}\n    if (Q.y<5.) {Q.y=5.;Q.w = +.5*abs(Q.w);}\n    if (R.y-Q.y<5.) {Q.y=R.y-5.;Q.w =-.5*abs(Q.w);}\n    if (iFrame < 20) {\n    \tQ = vec4(u+0.5*O,0,0);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define g .25\nvoid X (inout vec4 Q, inout vec2 r, vec4 a, vec2 U, vec2 u, vec4 n) {\n\tfloat l = pie(a.xy+g*(U-u),a.xy,A(n.xy).xy),\n          ll = pie(a.xy+g*(U-u),a.xy,A(n.zw).xy);\n    if (l<r.x){\n        r = vec2(l,r.x);\n        Q=vec4(n.xy,Q.xy);\n    } else if (l<r.y) {\n    \tr.y = l;\n        Q.zw = n.xy;\n    }\n    if (ll<r.x){\n    \tr = vec2(ll,r.x);\n        Q=vec4(n.zw,Q.xy);\n    } else if (ll<r.y) {\n    \tr.y = ll;\n        Q.zw = n.zw;\n    }\n}\nMain {\n    vec2 u = shape(U);\n    vec4 a = A(u);\n\tQ = B(U);\n    vec2 r = vec2(pie(a.xy+g*(U-u),a.xy,A(Q.xy).xy)\n                 ,pie(a.xy+g*(U-u),a.xy,A(Q.zw).xy));\n    \n    for (int x = -2; x <= 2; x++) {\n        for (int y = -2; y <= 2; y++) {\n        \t vec4 c = C(a.xy+vec2(x,y));\n    \t\tX(Q,r,a,U,u,vec4(unpack(c.z),unpack(c.w)));\n    \t\tX(Q,r,a,U,u,B(U+vec2(x,y)));\n        }\n    }\n    vec4 c = C(a.xy);\n    X(Q,r,a,U,u,vec4(unpack(c.z),unpack(c.w)));\n    X(Q,r,a,U,u,vec4(unpack(c.x),unpack(c.y)));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void X (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = ssg(U,A(unpack(n.z)).xy,A(unpack(n.w)).xy),\n          ll = ssg(U,A(unpack(Q.z)).xy,A(unpack(Q.w)).xy);\n\tif (l<ll) Q.zw = n.zw;\n    l = ssg(U,A(unpack(Q.z)).xy,A(unpack(n.z)).xy);\n    if (l<ll) Q.w = n.z;\n    l = ssg(U,A(unpack(Q.x)).xy,A(unpack(n.y)).xy);\n    if (l<ll) Q.y = n.y;\n}\nvoid Y (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = ssg(U,A(unpack(n.x)).xy,A(unpack(n.y)).xy),\n          ll = ssg(U,A(unpack(Q.x)).xy,A(unpack(Q.y)).xy);\n\tif (l<ll) Q.xy = n.xy;\n    l = ssg(U,A(unpack(Q.x)).xy,A(unpack(n.x)).xy);\n}\nMain {\n\tQ = C(U).xyxy;\n    vec2 u = shape(U);\n    if (iFrame%N==0) {\n        Q.xy = vec2(pack(u),pack(B(A(u).xy+u-U).xy));\n    \t\n    }\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tY(Q,U,C(U+vec2(0,k)));\n    \tY(Q,U,C(U+vec2(k,0)));\n    \tY(Q,U,C(U-vec2(0,k)));\n    \tY(Q,U,C(U-vec2(k,0)));\n    }\n\n\tX(Q,U,C(U+vec2(0,1)));\n    X(Q,U,C(U+vec2(1,0)));\n    X(Q,U,C(U-vec2(0,1)));\n    X(Q,U,C(U-vec2(1,0)));\n    \n\tX(Q,U,C(U+vec2(0,2)));\n    X(Q,U,C(U+vec2(2,0)));\n    X(Q,U,C(U-vec2(0,2)));\n    X(Q,U,C(U-vec2(2,0)));\n    \n    \n    \n    X(Q,U,C(U));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    vec2 u = shape(U);\n    if (u.x+O>=R.x||u.y+O>=R.y||u.x<O||u.y<O) discard;\n    Q = D(u);\n    vec4 qa = A(u);\n    vec2 f = vec2(0);\n    float n = 0.;\n    for (int x=-1;x<=1; x++) {\n        for (int y=-1;y<=1; y++) {\n            vec4 b = B(u+vec2(x,y)),\n                a = A(b.xy),\n                d = D(b.xy);\n            vec2 r = a.xy-qa.xy;\n            float l = length(r);\n            if (l > 0.&&a.x>3.){\n                f.x -= dot(r,a.zw-qa.zw)/l;\n                //f.y -= dot(r.yx*vec2(-1,1),a.zw-qa.zw)/l/l;\n                f.x += 2.*(d.z-Q.z)/l ;\n                //f.y += (d.w-Q.w)/l;\n                n++;\n            }\n            a = A(b.zw);\n            d = D(b.zw);\n            r = a.xy-qa.xy; \n            l = length(r);\n            if (l > 1e-3&&a.x>3.) {\n                f.x -= dot(r,a.zw-qa.zw)/l;\n                //f.y -= dot(r.yx*vec2(-1,1),a.zw-qa.zw)/l/l;\n                f.x += 2.*(d.z-Q.z)/l;\n                //f.y += (d.w-Q.w)/l;\n                n++;\n            }\n        }\n\t}\n    f /= n;\n    Q.zw += f;\n    if (iFrame < 20) {\n    \tQ = vec4(0);\n    }\n    \n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 190, 219, 219, 631]], "test": "untested"}
{"id": "3sXBRB", "name": "Galaxy vortex", "author": "michael0884", "description": "yes\nif you have the plugin:\nalt+down to restart in fullscreen\nuse acceleration 4x", "tags": ["fluid", "particles"], "likes": 16, "viewed": 649, "published": 3, "date": "1588453635", "time_retrieved": "2024-07-30T21:09:10.616066", "image_code": "obj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    o.Y = texel(ch0, i2xy(ivec3(id, 1, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    int ID = int(texel(ch1, pi).x); \n    obj O = getObj(ID);\n    float d1 = exp(-0.15*distance(pos, O.X));\n    float d2 = 1.*O.Y.x;\n   \n    loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 2)));\n        loop(i,4)\n    \t{\n            if(nb[i] < 0.) continue;\n            vec2 nbX = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xy; \n        \td1 += exp(-0.15*distance(pos, nbX));\n    \t}\n    }\n    d1*=0.07;\n    // Output to screen\n    fragColor = vec4(sin(vec3(1,2,3)*d2*0.3)*d1 + d1,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define dt 2.\n#define loop(i,x) for(int i = min(0, iFrame); i < x; i++)\n\n\n//sim stuff\nstruct obj\n{\n    int id; //ID\n    vec2 X; //position\n    vec2 V; //velocity\n    vec4 Y; //inner params \n};\n    \nfloat Force(float d)\n{\n    return -4.*exp(-0.6*d);\n}\n\n//40% of the buffer used for particles\n#define P 0.8\n#define SN ivec2(8, 3)\n\nivec2 N; //buffer size\nivec2 sN; //buffer single element size\nint TN; //buffer length\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\n//hash funcs\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}", "buffer_a_code": "//L1 particle buffer - simulation\n//L2 directional graph - sort\n//L3 neighbor graph - sort\n\nint ID;\nobj O; //this object\n\n//sort arrays\nvec4 lnk0, lnk1;\nvec4 d0, d1;\n\n//L3\nvec4 EA[SN.x]; //element array\n\nvoid insertion_sort(float t, int id);\nobj getObj(int id); vec4 saveObj(int i);\nbool iscoincidenceEA(int id);\nvoid sort0(int idtemp, int D); void sort1(int idtemp, int D);\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    //4 pix per layer, 3 layers\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    int S = 3; //log2(sN.x)\n    \n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    O = getObj(ID);\n    d0 = vec4(1e6); d1 = vec4(1e6);\n    lnk0 = vec4(-1); lnk1 = vec4(-1);\n    \n    switch(sid.z)\n    {\n    case 0: //particle\n        if(sid.z >= 2) discard;\n        \n       \t//load all neighbors\n        loop(i,4)\n        {\n            EA[i] = texel(ch0, i2xy(ivec3(ID, i, 2))); \n        }\n        \n        vec2 F = -0.0005*(O.X - R*0.5)/(pow(length(O.X - R*0.5),1.)+1.); \n        vec2 Fp = vec2(0);\n        float DIV = 0.;\n        vec2 avgP = vec2(0.,0.);\n        \n        vec2 Lnb = texel(ch0, i2xy(ivec3(EA[3].w, 0, 0))).xy;\n        float scale = 0.25*distance(O.X, Lnb);  \n        \n        loop(j,4)\n        {\n            vec4 nb = EA[j];\n            loop(i,4)\n            {\n                int pid = int(nb[i]);\n                if(pid < 0 || pid >= TN || pid == ID) continue; \n                obj nbO = getObj(pid);\n                \n                float d = distance(O.X, nbO.X);\n                vec2 dv = (nbO.V - O.V);\n                float sk = exp(-d/scale)/scale;\n                float divD = 1./(length((nbO.X - O.X))+1.);\n                float dotv = divD*dot(O.X - nbO.X, dv); //divergence correction\n                \n                vec2 antidivergence = 0.3*dv*abs(dotv)*sk;\n                vec2 pressure = 0.01*sk*divD*(nbO.X - O.X)*(nbO.Y.x - O.Y.x);\n                Fp += (nbO.X - O.X)*Force(d)*divD;\n                DIV += dotv*sk;\n                avgP += vec2(nbO.Y.x, 1)*sk;\n                F += pressure + antidivergence + 0.0005*(nbO.X - O.X)*divD/(0.1*d*d+1.);\n            }\n        }\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, O.X);\n            F += 0.004*normalize(iMouse.xy - O.X)/(sqrt(d)+2.);\n        }\n        \n        O.Y.x += (DIV + 0.6*(avgP.x/avgP.y - O.Y.x) - O.Y.x*0.01)*dt;\n        O.V += (F)*dt;\n        O.X += (O.V+0.1*Fp)*dt;\n\n        \n        /*//border conditions\n        if(R.x - O.X.x < 2.) {O.V.x = -abs(O.V.x); O.X.x = mix(O.X.x,R.x - 2.,0.5);}\n        if(O.X.x < 2.)  {O.V.x = abs(O.V.x); O.X.x = mix(O.X.x,2.,0.5);}\n        if(R.y - O.X.y < 2.)  O.V.y = -abs(O.V.y);\n        if(O.X.y < 2.)  {O.V.y = abs(O.V.y); O.X.y = mix(O.X.y, 2.,0.5);}*/\n        \n        if(iFrame<10)\n        {\n            O.X = R*vec2(i2xy(ivec3(ID,0,0)))/vec2(N*sN);\n\t\t\tO.V = 0.2*(hash22(3.14159*pos) - 0.5) + 0.2*vec2(O.X.y-R.x*0.5, R.y*0.5-O.X.x)/R;\n            O.Y = vec4(0);\n        }\n\n        Q = saveObj(sid.y);\n        return;\n        \n    case 1: //dir graph\n        if(sid.y >= 4) discard;\n        \n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        loop(i,4)\n        {\n            sort0(int(nb0[i]), sid.y);  //sort this\n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = texel(ch0, i2xy(ivec3(nb0[i], (iFrame+ID)%4, 1)));\n            loop(j,2)\n            {\n                sort0(int(nb1[j]), sid.y);  \n            }\n        }\n        \n        //random sorts\n        loop(i,4) sort0(int(float(TN)*hash13(vec3(iFrame, ID, i))), sid.y);\n        \n        Q = lnk0;\n        return;\n        \n    case 2: // neighbor graph\n        \n        //basic XOR sort\n        int ste = iFrame % S;\n        int id0 = sid.y;\n        int id1 = id0^((1<<(ste+1))-1); //pair id, by flipping first n bits, n - is the step\n        if(id1 >= sN.x) discard;\n\t    //sort this block\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, id0, 2)));\n        vec4 nb1 = texel(ch0, i2xy(ivec3(ID, id1, 2)));\n        loop(i,4)\n        {\n            sort1(int(nb[i]), sid.y);  \n            sort1(int(nb1[i]), sid.y);  \n        }\n\n        if(id1 == sN.x-1 || id0 == sN.x-1) //if last pair\n        {\n            //load entire array\n            loop(i,sN.x)\n            {\n                EA[i] = texel(ch0, i2xy(ivec3(ID, i, 2))); \n            }\n            \n            //do random sorts\n            loop(j,4)\n            {\n            \tvec4 nb1 = texel(ch0, i2xy(ivec3(ID, j, 1)));\n                loop(i,2)\n                {\n                   //check coincidence with entire array\n                   if(iscoincidenceEA(int(nb1[i+iFrame%2]))) continue;\n                   sort1(int(nb1[i+iFrame%2]), sid.y);  \n                }\n            }\n            \n            loop(i,4) \n            {\n                int nbid = int(float(TN)*hash13(vec3(iFrame, ID, i))); \n                if(iscoincidenceEA(nbid)) continue;\n                sort1(nbid, sid.y);\n            }\n        }\n        \n        //store sorted\n        Q = (id0>id1) ? lnk1 : lnk0;\n        return;\n    }\n     \n}\n\nvec4 saveObj(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(O.X, O.V);\n    case 1:\n        return O.Y;\n    case 2:\n        return vec4(0.);\n    case 3:\n        return vec4(0.);\n    }\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    o.Y = texel(ch0, i2xy(ivec3(id, 1, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid insertion_sort(float t, int id)\n{\n    if(d0.x > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0 = vec4(t, d0.xyz);\n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0 = vec4(id, lnk0.xyz);\n    } else if(d0.y > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.yzw = vec3(t, d0.yz); \n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0.yzw = vec3(id, lnk0.yz);\n    } else if(d0.z > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.zw = vec2(t, d0.z); \n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.w = t; \n        lnk1 = vec4(lnk0.w,lnk1.xyz); lnk0.w = float(id); \n    }else if(d1.x > t)\n    {\n        d1 = vec4(t, d1.xyz);\n        lnk1 = vec4(id, lnk1.xyz);\n    }else if(d1.y > t)\n    {\n        d1.yzw = vec3(t, d1.yz);\n        lnk1.yzw = vec3(id, lnk1.yz);\n    }else if(d1.z > t)\n    {\n        d1.zw = vec2(t, d1.z);\n        lnk1.zw = vec2(id, lnk1.z);\n    }else if(d1.w > t)\n    {\n        d1.w = t;\n        lnk1.w = float(id);\n    }\n}\n\nbool iscoincidence(int id)\n{\n    return (id < 0) || \n           any(equal(lnk0,vec4(id))) || \n           any(equal(lnk1,vec4(id)));\n}\n\nbool iscoincidenceEA(int id)\n{\n    bool f = id < 0;\n    for(int i = 0; i < SN.x; i++)\n    {\n        f = f || any(equal(EA[i],vec4(id))); \n    }\n    return f;\n}\n\n\nvoid sort0(int idtemp, int D) //sort closest objects in sN.x directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec2 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xy; \n   \n    vec2 dx = nbX - O.X;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n    \n    if(dir != D) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}\n\nvoid sort1(int idtemp, int D) //sort closest objects \n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec2 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xy; \n   \n    vec2 dx = nbX - O.X;\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//voronoi particle tracking + graph augmented\n\nfloat d;\nint id;\nvec2 p;\n\nfloat particleDistance(int i)\n{\n    return distance(p, texel(ch0, i2xy(ivec3(i, 0, 0))).xy);\n}\n\nvoid sort(int utemp)\n{\n    if(utemp < 0) return; \n   \tfloat dtemp = particleDistance(utemp);\n    if(dtemp < d) //sorting\n    {\n        d = dtemp;\n        id = utemp;\n    }\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    d = 1e10;\n    id = 1;\n    p = pos;\n    ivec2 pi = ivec2(floor(pos));\n    \n    sort(1+0*int(texel(ch1, pi).x));\n    \n    int ID = id;\n    loop(j,4)\n    {\n        int nbid = int(texel(ch1, pi+cross_distribution(j)).x);\n        sort(nbid);\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        sort(int(nb[0]));  //sort this\n    }\n    \n    loop(i,8) //random sort\n    {\n        sort(int(float(TN)*hash13(vec3(iFrame, pi.x, pi.y*i))));\n    }\n    \n   \tQ = vec4(id, d, 0, 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 194]], "test": "untested"}
{"id": "wdlfDH", "name": "DigEggs  (173 chars)", "author": "Smake", "description": "The simplest 3d game.\nUse mouse to avoid collisions.\nit's just a demo )\n", "tags": ["3d", "raymarching", "game", "smallest", "fly", "shiortest"], "likes": 4, "viewed": 461, "published": 3, "date": "1588445159", "time_retrieved": "2024-07-30T21:09:11.498706", "image_code": "void mainImage( out vec4 O, vec2 U )  {                         \n//    vec4  c = vec4(U/7e2, 1,0), r; \n          vec4 r;\n          r +=.01*iMouse + cos(iTime);  \n          O=r;  \n    for  (r.z = iTime; O.a++ < 1e2; )             \n//          r += c*(length(fract(r.xyz)-.5)-.2); \n\n  r += vec4(U/7e2, 1,0)*(length(fract(r.xyz)-.5)-.2); \n          O = fract(r*9.) - .1*(r.z - iTime);\n}", "image_inputs": [{"id": 22419, "src": "https://soundcloud.com/mrswilfongsmusicclass/the-ride-of-the-valkyries-by", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 102, 383]], "test": "untested"}
{"id": "WsffRS", "name": "Artifact at Sea", "author": "samlo", "description": "Wrote this piece on and off over the past two weeks to get back into raymarching :) Water inspired by the sum of sines method in Very fast procedural ocean by afl_ex. It has some continuity bugs, but I'm quite pleased with the result 🌊\n", "tags": ["raymarch", "sdf", "water", "ocean", "glow", "night"], "likes": 103, "viewed": 2428, "published": 3, "date": "1588441792", "time_retrieved": "2024-07-30T21:09:12.296573", "image_code": "#define time iTime\n\nconst float CAM_FAR = 20.0;\nconst vec3 BACKGROUND = vec3(0.1, 0.1, 0.13);\nconst int WATER_MARCH_ITERATIONS = 12;\nconst int WATER_NORMAL_ITERATIONS = 39;\nconst float PI = 3.14159265359;\n\nconst int NUM_PARTICLES = 20;\nvec4 ppos[NUM_PARTICLES];\n\n// calculated per fragment\nvec3 artifactOffset;\nmat3 artifactRotation;\nvec3 artifactAxis;\nfloat flicker;\nvec3 camFwd;\nvec3 camUp;\n\nfloat rand(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\nmat4 viewMatrix (vec3 dir, vec3 up) { \n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4( s,   0.0),\n        vec4( u,   0.0),\n        vec4(-f,   0.0),\n        vec4( 0.0, 0.0, 0.0, 1)\n    );\n}\nmat3 rotationAlign(vec3 d, vec3 z) {\n    vec3  v = cross(z, d);\n    float c = dot(z, d);\n    float k = 1.0/(1.0+c);\n    return mat3(v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\nvec3 calcRay(vec2 uv, float fov, float aspect) {\n    uv = uv * 2.0 - 1.0;\n    float d = 1.0 / tan(radians(fov) * 0.5);\n    return normalize(vec3(aspect * uv.x, uv.y, d));\n}\nvec2 getWave(vec2 position, vec2 dir, float speed, float frequency, float timeshift) {\n    float x = dot(dir, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dist = wave * cos(x);\n    return vec2(wave, -dist);\n}\nfloat heightmap(vec2 worldPos, int iterations) {\n    const float scale = 0.13;\n    vec2 p = worldPos * scale;\n    vec2 p2 = (artifactOffset.xz - vec2(0.0, 1.0)) * scale;\n    float d = clamp(length(p2 - p) / 0.8, 0.0, 1.0);\n    d = (1.0 - smoothstep(0.0, 1.0, d)) * 0.8;\n    float angle     = 0.0;\n    float freq      = 5.0;\n    float speed     = 2.0;\n    float weight    = 1.9;\n    float wave      = 0.0;\n    float waveScale = 0.0;\n    vec2 dir;\n    vec2 res;\n    for (int i = 0; i < iterations; i++) {\n        dir = vec2(cos(angle), sin(angle));\n        res = getWave(p, dir, speed, freq, time);\n        p += dir * res.y * weight * 0.05;\n        wave += res.x * weight - d;\n        angle += 12.0;\n        waveScale += weight;\n        weight = mix(weight, 0.0, 0.2);\n        freq *= 1.18;\n        speed *= 1.06;\n    }\n    return wave / waveScale;\n}\nvec3 waterNormal(vec2 p, float eps) {\n    vec2 h = vec2(eps, 0.0);\n    #define i WATER_NORMAL_ITERATIONS\n    return normalize(vec3(heightmap(p - h.xy, i) - heightmap(p + h.xy, i),\n                          2.0 * eps,\n                          heightmap(p - h.yx, i) - heightmap(p + h.yx, i)));\n}\nfloat octahedron(vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nvoid artifact(vec3 p, inout float curDist, inout vec3 glowColor, inout int id) {\n    p -= artifactOffset;\n    p = artifactRotation * p;\n    float dist = octahedron(p, 1.2);\n    const float glowDist = 4.8;\n    if (dist < glowDist) {\n        float d = dist + rand(dist) * 1.7;\n        glowColor += vec3(0.75, 0.55, 0.45) * clamp(1.0 - pow((d / glowDist), 5.0), 0.0, 1.0) * 0.035 * flicker; // glow\n    }\n    if (dist < curDist) {\n        curDist = dist;\n        id = 1;\n    }\n}\nvoid particles(vec3 p, inout float curDist, inout vec3 glowColor, inout int id) {\n    float t;\n    float angle;\n    float radius;\n    float dist = CAM_FAR;\n    const float glowDist = 0.2;\n    for (int i = 0; i < NUM_PARTICLES; i++) {\n        dist = length(p - ppos[i].xyz) - 0.005;\n        if (dist < glowDist && false) {\n            float d = dist + rand(dist) * 0.5;\n            glowColor += clamp(1.0 - d / glowDist, 0.0, 1.0) * 0.005;\n        }\n        if (dist < curDist) {\n            curDist = dist;\n            id = 2;\n        }\n    }\n}\nfloat objects(vec3 p, inout vec3 glowColor, inout int objId) {\n    float dist = CAM_FAR;\n    artifact(p, dist, glowColor, objId);\n    particles(p, dist, glowColor, objId);\n    return dist;\n}\nfloat artifactDist(vec3 p) {\n    p -= artifactOffset;\n    p = artifactRotation * p;\n    return octahedron(p, 1.2);\n}\nfloat objectsDist(vec3 p) {\n    return artifactDist(p);\n}\nvec3 objectsNormal(vec3 p, float eps) {\n    vec2 h = vec2(eps, 0);\n    #define f artifactDist\n    return normalize(vec3(f(p + h.xyy) - f(p - h.xyy),\n                          f(p + h.yxy) - f(p - h.yxy),\n                          f(p + h.yyx) - f(p - h.yyx)));\n}\nvec3 objectsColor(int id, vec3 normal, vec3 ray) {\n    if (id == 1) { // artifact\n        float l = dot(normal, normalize(vec3(0.0, 1.0, 0.5)));\n        float hl = mix(0.8, 1.5, l * 0.5 + 0.5);\n        return vec3(0.85, 0.65, 0.55) * hl * flicker;\n    }\n    if (id == 2) {\n        return vec3(0.85, 0.65, 0.55) * 1.5;\n    }\n    return vec3(1.0, 1.0, 0.0); // shouldn't happen\n}\nvoid marchObjects(vec3 eye, vec3 ray, float wDepth, inout vec4 color) {\n    float dist = 0.0;\n    int id;\n    vec3 rayPos = eye + ray * dist;\n    vec3 c;\n    float depth = CAM_FAR;\n    vec3 glowColor = vec3(0.0);\n    for (int i = 0; i < 100; i++) {\n        dist = objects(rayPos, color.rgb, id);\n        depth = distance(rayPos, eye);\n        if (depth > wDepth) {\n            break;\n        }\n        if (dist < 0.01) {\n            vec3 normal = objectsNormal(rayPos, 0.01);\n            color = vec4(objectsColor(id, normal, ray), depth);\n            return;\n        }\n        rayPos += ray * dist;\n    }\n}\nvec3 waterColor(vec3 ray, vec3 normal, vec3 p) {\n    vec3 color = vec3(0.0);\n    float fogDist = length(p - vec3(0.0, 0.0, -6.));\n    float dist = 0.0;\n    int objId = 0;\n    vec3 refl = reflect(ray, normal);\n    vec3 rayPos = p + refl * dist;\n    vec3 dir = normalize(artifactOffset - p);\n    if (length(p.xz - artifactOffset.xz) < 8.5 && dot(refl, dir) > -0.25) { // hacky but this way we aren't reflecting on every single fragment\n        for (int i = 0; i < 40; i++) {\n            dist = objects(rayPos, color, objId);\n            if (dist < 0.01) {\n                vec3 objNormal = objectsNormal(rayPos, 0.001);\n                color = objectsColor(objId, objNormal, rayPos);\n                break;\n            }\n            rayPos += refl * dist;    \n        }\n    }\n    float fresnel = (0.04 + 0.9 * (pow(1.0 - max(0.0, dot(-normal, ray)), 7.0)));\n    vec3 lightOffset = artifactOffset - p;\n    float d = length(lightOffset);\n    const float r = 14.0;\n    float atten = clamp(1.0 - (d*d) / (r*r), 0.0, 1.0);\n    atten *= atten;\n    vec3 point = vec3(0.75, 0.55, 0.45) * atten * (1.0 + fresnel) * 0.07;\n    vec3 ambient = vec3(dot(normal, normalize(vec3(0.0, 1.0, 0.5)))) * max(fresnel, 0.06) * vec3(0.1, 0.5, 1.0) * 0.85;\n    float fog = smoothstep(25.0, 6.0, fogDist) / (fogDist * 0.1);\n   \n    return color + (point + ambient) * fog;\n}\nvoid marchWater(vec3 eye, vec3 ray, inout vec4 color) {\n    const vec3 planeNorm = vec3(0.0, 1.0, 0.0);\n    const float depth = 3.0;\n    float ceilDist = intersectPlane(eye, ray, vec3(0.0, 0.0, 0.0), planeNorm);\n    vec3 normal = vec3(0.0);\n    if (dot(planeNorm, ray) > -0.05) {\n        normal = vec3(0.0);\n        color = vec4(vec3(0.0), CAM_FAR);\n        return;\n    }\n    float height = 0.0;\n    vec3 rayPos = eye + ray * ceilDist;\n    for (int i = 0; i < 80; i++) {\n        height = heightmap(rayPos.xz, WATER_MARCH_ITERATIONS) * depth - depth;\n        if (rayPos.y - height < 0.1) {\n            color.w = distance(rayPos, eye);\n            vec3 normPos = (eye + ray * color.w);\n            normal = waterNormal(normPos.xz, 0.005);\n            color.rgb = waterColor(ray, normal, normPos);\n            return;\n        }\n        rayPos += ray * (rayPos.y - height);\n    }\n}\nvec3 march(vec2 uv, vec3 camPos) {\n    mat4 vm = viewMatrix(camFwd, camUp);\n    vec3 ray = (vm * vec4(calcRay(uv, 80.0, iResolution.x / iResolution.y), 1.0)).xyz;\n    vec4 color = vec4(BACKGROUND, CAM_FAR);\n    vec3 waterColor;\n    marchWater(camPos, ray, color);\n    marchObjects(camPos, ray, color.w, color);\n    return color.rgb;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // simulate  particles\n    float pR;\n    float pA;\n    float gen;\n    float t;\n    float loop;\n    float height;\n    vec4 p;\n    const float emitR = 1.7;\n    for (int i = 0; i < NUM_PARTICLES; i++) {\n        t = time * 0.035 + float(i) * 0.07;\n        gen = floor(t);\n        loop = fract(t);\n        pR = rand(gen + float(i)) * emitR;\n        pA = rand(float(i)) * PI * 2.0;\n        p.xz = vec2(cos(pA), sin(pA)) * pR + vec2(0.0, -5.2);\n        height = mix(3.0, 2.3, (abs(pR) / emitR));\n        p.y = mix(-3.5, height, sqrt(loop));\n        //p.w = cos(loop * PI * 2.0) * min(1.0, 1.0 - (loop / 0.9)); // not currently used :(\n        ppos[i] = p;\n    }\n    \n    // artifact animation\n    t = time;\n    float s = sin(t);\n    float c = cos(t);\n    artifactRotation = mat3x3(c,0,s,\n                              0,1,0,\n                             -s,0,c);\n    artifactRotation *= rotationAlign(vec3(0.0, 1.0, 0.0), vec3(sin(t) * 0.2, 1.0, cos(t) * 0.2 + 0.3));\n    artifactOffset = vec3(sin(time) * 0.4, cos(time * 0.5) * 0.3 - 1.7, -6.);\n    flicker = mix(1.0, 1.1, sin(time * 2.0) * 0.5 + 0.5) + noise(time * 4.0) * -0.1 + 0.05;\n\n    // camera animation\n    camFwd = vec3(0.0, 0.7 + noise(time * 0.8 + 4.0) * 0.08 - 0.04, 1.0);\n    camUp = vec3(noise(time * 1.2) * 0.02 - 0.01, 1.0, 0.0);\n\n    // scene\n    vec3 color = march(uv, vec3(0.0, 1.9, 1.0));\n\n    // vignette\n    color -= (length(uv - 0.5) - 0.3) * 0.05;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsffRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 394, 415, 415, 459], [460, 460, 481, 481, 511], [512, 512, 534, 534, 666], [667, 667, 704, 704, 931], [932, 932, 968, 968, 1268], [1269, 1269, 1345, 1345, 1438], [1439, 1439, 1487, 1487, 1611], [1612, 1612, 1698, 1698, 1864], [1865, 1865, 1913, 1913, 2713], [2714, 2714, 2751, 2751, 3009], [3010, 3010, 3045, 3045, 3098], [3099, 3099, 3179, 3179, 3574], [3575, 3575, 3656, 3656, 4119], [4120, 4120, 4182, 4182, 4310], [4311, 4311, 4339, 4339, 4427], [4428, 4428, 4455, 4455, 4485], [4486, 4486, 4525, 4525, 4748], [4749, 4749, 4799, 4799, 5126], [5127, 5127, 5198, 5198, 5734], [5735, 5735, 5783, 5783, 7079], [7080, 7080, 7135, 7135, 7957], [7958, 7958, 7992, 7992, 8292], [8293, 8293, 8348, 8348, 9852]], "test": "untested"}
{"id": "wssfD7", "name": "Brightness illusion test", "author": "Zavie", "description": "Testing the effect of two patterns on perceived brightness.", "tags": ["opticalillusion", "glow", "brightness"], "likes": 4, "viewed": 504, "published": 3, "date": "1588434009", "time_retrieved": "2024-07-30T21:09:13.283933", "image_code": "/*\n\nA simple yet powerful brightness illusion.\nThe shader toggles two patterns to see how they contribute\nto the illusion.\n\n--\nZavie\n\n*/\n\nvec3 brightnessIllusion(vec2 uv,\n                        vec2 aspect_ratio,\n                        bool enable_glow,\n                        bool enable_texture,\n                        bool enable_stripes)\n{\n    float radius = 0.1;\n    float num_stripes = 72.;\n\n    vec2 p = (uv - 0.5) * aspect_ratio;\n    float d = length(p);\n    float isCircle = smoothstep(radius + 0.002, radius, d);\n\n    vec3 background = vec3(0.);\n    vec3 circle = vec3(1.);\n    float contrast = 1.;\n\n    vec3 color = background;\n    if (enable_texture)\n    {\n        color = texture(iChannel0, uv).rgb;\n        contrast = pow(1. + radius -d, 8.);\n    }\n    if (enable_stripes)\n    {\n    \tfloat angle = atan(p.y, p.x);\n    \tfloat isStripe = smoothstep(0.4, 0.6, abs(fract(angle * num_stripes * 0.5 / acos(-1.)) * 2. - 1.));\n        vec3 stripes = vec3(mix(0., 1., isStripe));\n        color = mix(color, stripes, contrast);\n    }\n    if (enable_glow)\n    {\n\t    vec3 glow = mix(vec3(1.), vec3(1., 1., 0.2), pow(1. + radius -d, 10.));\n    \tcolor = mix(color, glow, 1.-glow.b);\n    }\n    color = mix(color, circle, isCircle);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect_ratio = vec2(1, iResolution.y / iResolution.x);\n\n\tfloat t1 = abs(fract(iTime / 10.) * 2. - 1.);\n    bool enable_texture = t1 < 0.5;\n\n    bool enable_glow = uv.x > 0.5;\n    bool enable_stripes = uv.y > 0.5;\n    vec3 color = brightnessIllusion(fract(uv*2.),\n                                    aspect_ratio,\n                                    enable_glow,\n                                    enable_texture,\n                                    enable_stripes);\n\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 347, 347, 1255], [1257, 1257, 1314, 1314, 1885]], "test": "untested"}
{"id": "tslBD7", "name": "Graph Drawing", "author": "mla", "description": "Playing with enslow's [url]https://www.shadertoy.com/view/wdlfW4[/url]\n\nDivide points into quadrants and only check lines between points in opposing quadrants. There is a subtle (fixable) bug, to do with the way lines are drawn.", "tags": ["graph", "drawing"], "likes": 17, "viewed": 652, "published": 3, "date": "1588430512", "time_retrieved": "2024-07-30T21:09:14.174552", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Graph Drawing, Matthew Arcus, mla, 2020\n//\n// Playing with enslow's https://www.shadertoy.com/view/wdlfW4\n//\n// Divide points into quadrants and only check lines between points in opposing\n// quadrants. There is a subtle (fixable) bug, to do with the way lines are\n// drawn - sometimes a line is drawn twice due to overlap between quadrants. \n// Also generate points in bufferA to save a bit of work (and storage on the GPU).\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Store index set as packed integers\n#if 1\nint quad0[N/4], quad1[N/4], quad2[N/4], quad3[N/4];\n#define setq(q,i,x) (q[i>>2] |= (x<<(8*(i&3))), i++)\n#define getq(q,i) ((q[i>>2] >> (8*(i&3)))&255)\n#else\nint quad0[N], quad1[N], quad2[N], quad3[N];\n#define setq(q,i,x) (q[i++] = x)\n#define getq(q,i) (q[i])\n#endif\nint iquad0 = 0, iquad1 = 0, iquad2 = 0, iquad3 = 0;\n\nvec2 getpoint(int i, float t) {\n  //return mkpoint(i,t); // Generate points on the fly\n  return texelFetch(iChannel0,ivec2(i,0),0).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  uv *= 1.333;\n  vec3 col = vec3(1,1,0.5)*(0.7+0.3*texture(iChannel1,uv).y);    \n  float t = 0.25*iTime;\n    \n  for (int i = 0; i < N; i++) {\n    float eps = 0.01; // Need some overlap here\n    vec2 p = getpoint(i,t);\n    // Add point to appropriate quadrant list\n    // NB: it could end up in all of them\n    if (p.x <= uv.x+eps && p.y <= uv.y+eps) setq(quad0,iquad0,i);\n    if (p.x <= uv.x+eps && p.y > uv.y-eps) setq(quad1,iquad1,i);\n    if (p.x > uv.x-eps && p.y > uv.y-eps) setq(quad2,iquad2,i);\n    if (p.x > uv.x-eps && p.y <= uv.y+eps) setq(quad3,iquad3,i);\n  }\n  // Two loops, checking lines between points in opposite quadrants\n  float lwidth = max(0.01,fwidth(uv.x));\n  for (int i = 0; i < iquad0; i++) {\n    int i0 = getq(quad0,i);\n    vec2 p = getpoint(i0,t);\n    for (int j = 0; j < iquad2; j++) {\n      int j0 = getq(quad2,j);\n      vec2 q = getpoint(j0,t);\n      float t = 1.0-smoothstep(0.0,lwidth,segment(uv,p,q));\n      t *= 0.75*texture(iChannel1,uv).x;\n      col *= 1.0-t;\n    }\n  }\n  for (int i = 0; i < iquad1; i++) {\n    int i0 = getq(quad1,i);\n    vec2 p = getpoint(i0,t);\n    for (int j = 0; j < iquad3; j++) {\n      int j0 = getq(quad3,j);\n      vec2 q = getpoint(j0,t);\n      float t = 1.0-smoothstep(0.0,lwidth,segment(uv,p,q));\n      t *= 0.75*texture(iChannel1,uv).x;\n      col *= 1.0-t;\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    float t = 1.0-smoothstep(0.02,0.03,distance(getpoint(i,t),uv));\n    t *= 2.0*texture(iChannel1,uv).x;\n    col = mix(vec3(1,0,0),col,1.0-t);\n  }\n  // Output to screen\n  fragColor = vec4(pow(col,vec3(0.4545)),1.0);\n}\n", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = 0.25*iTime;\n    int i = int(fragCoord.x), j = int(fragCoord.y);\n    if (j == 0 && i < N) {\n        fragColor = vec4(mkpoint(int(fragCoord.x),t),0,0);\n    }\n}", "buffer_a_inputs": [], "common_code": "#define N 32\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(int x) {\n  return float(ihash(uint(x)))/pow(2.0,32.0);\n}\n\nfloat hash2(int x) {\n  return hash(x^0x12345678);\n}\n\nvec2 mkpoint(int i, float t) {\n  return vec2(cos(t+float(i*23)),sin(t+float(i*31)))+vec2(hash(i),hash2(i))-0.5;\n}\n\n//Segment function credit: https://www.shadertoy.com/view/MlcGDB\n//User: gPlatl\n\nfloat segment(vec2 P, vec2 A, vec2 B) {\n  vec2 g = B - A;\n  vec2 h = P - A;\n  float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n  return d;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[962, 962, 993, 1048, 1098], [1100, 1100, 1157, 1205, 2843]], "test": "untested"}
{"id": "3ssfDM", "name": "Anti Menger Sphere Sponge II", "author": "ManuManu", "description": "For some reasons, I played with parameters from this old shader of mine (  here https://www.shadertoy.com/view/MtBGWK ).\n\nAnd find the results satisfying:)", "tags": ["raymarching", "menger", "sponge"], "likes": 4, "viewed": 382, "published": 3, "date": "1588429645", "time_retrieved": "2024-07-30T21:09:15.135981", "image_code": "\n//---------------------------------------------------------\n//\n// source header from IQ, for sure...\n//\n//\n// Modified by ManuManu to create the Monge effect\n//\n//\n\n// Shader:   RayMarchingPrimitivesV2.glsl\n// original: https://www.shadertoy.com/view/Xds3zN   colored\n//           http://glslsandbox.com/e#20839          gray scaled\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// A list of usefull distance function to simple primitives (animated), and an example \n// on how to / do some interesting boolean operations, repetition and displacement.\n// More info here: https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------\n\n\n//---------------------------------------------------------\n\n#define ANIMATE true\n#define ROTATE true\n#define flag true\n\nfloat aTime = 0.0;\nfloat sinTime = 0.0;\n//---------------------------------------------------------\n//  primitives\n//---------------------------------------------------------\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\n\n//----------------------------------------------------------------------\n// distance operations\n//----------------------------------------------------------------------\n\n\n// Union: d1 +d2\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n//----------------------------------------------------------------------\n// animated fractal Anti sphere sponge\nfloat AntiSphereSponge(vec3 w)\n{\n  const int ITER = 10;\n  float sphereHoles = 8.0 + 5.*sin(0.42*aTime);\n  float sphereScale = 1.5 + 0.9*sin(0.39*aTime);\n  float scale =1.6;\n  //float scale =1.5;\n  float k = scale*.5;\n  float d = 10000.0;\n  float r, d1;\n  //float sph=length(w * vec3(0.8, 0.8, 0.5)) - 0.6 ;\n  float sph=length(w * vec3(0.8, 0.5, 0.5)) - 0.6;\n  \n  if ( sph < .1)\n  for (int i = 0; i < ITER; i++) \n  {\n    vec3 zz = mod(w * k, sphereHoles) - vec3(0.5 * sphereHoles);\n    r = length(zz);\n    d1 = -(sphereScale - r) / k;\n    k *= scale;\n    d = min(d, d1);\n  }\n\telse d = 0.;\n  d = max(d,sph);\n  return d;\n}\n//----------------------------------------------------------------------\nvec2 map( in vec3 pos )\n{\n  vec3 r1, r2;\n  vec2 res = vec2( sdPlane( pos), 1.0 );\n  float color = 46.9 + 40.0 * cos(0.2 * iTime);\n  res = opU(res,vec2(AntiSphereSponge(pos - vec3(0.0, 0.7, 0.0)), color));\n  return res;\n}\n//----------------------------------------------------------------------\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 1.0;\n  float tmax = 20.0;\n\n  float precis = 0.002;\n  float t = tmin;\n  float m = -1.0;\n  for ( int i=0; i<100; i++ )\n  {\n    vec2 res = map( ro+rd*t );\n    if ( res.x<precis || t>tmax ) break;\n    t += res.x;\n    m = res.y;\n  }\n\n  if ( t>tmax ) m=-1.0;\n  return vec2( t, m );\n}\n\n//----------------------------------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for ( int i=0; i<14; i++ )\n  {\n    float h = map( ro + rd*t ).x;\n    res = min( res, 8.0*h/t );\n    t += clamp( h, 0.02, 0.10 );\n    if ( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n//----------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3( 0.001, 0.0, 0.0 );\n  vec3 nor = vec3(\n  map(pos+eps.xyy).x - map(pos-eps.xyy).x, \n  map(pos+eps.yxy).x - map(pos-eps.yxy).x, \n  map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\n\n//----------------------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n//---------------------------------------------------------\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  aTime = ANIMATE ? iTime : 0.0;\n  sinTime = sin(aTime);\n  vec3 col = vec3(0.8, 0.9, 1.0);\n  vec2 res = castRay(ro, rd);\n  float t = res.x;\n  float m = res.y;\n  if ( m > -0.5 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    // material        \n    col = 0.45 + 0.3*sin( vec3(0.05, 0.08, 0.10)*(m-1.0) );\n\n    if ( m<1.5 )\n    {\n      float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n      col = 0.4 + 0.1*f*vec3(1.0);\n    }\n\n    // lighting        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y, 0.0, 1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor, rd), 0.0, 1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0);\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 brdf = vec3(0.0);\n    brdf += 1.20*dif*vec3(1.00, 0.90, 0.60);\n    brdf += 1.20*spe*vec3(1.00, 0.90, 0.60)*dif;\n    brdf += 0.30*amb*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.40*dom*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.30*bac*vec3(0.25, 0.25, 0.25)*occ;\n    brdf += 0.40*fre*vec3(1.00, 1.00, 1.00)*occ;\n    brdf += 0.02;\n    col = col*brdf;\n    col = mix( col, vec3(0.8, 0.9, 1.0), 1.0-exp( -0.005*t*t ) );\n  }\n  return vec3( clamp(col, 0.0, 1.0) ); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0*(fragCoord.xy / iResolution.xy) - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n\n  // camera  \n  float angle = ROTATE ? 0.02*iTime : 0.0;\n  float rx = 0.5 + 3.0*cos(angle + 6.0*iMouse.x);\n  float rz = 0.5 + 3.0*sin(angle + 6.0*iMouse.x);\n  vec3 ro = vec3( rx, 1.0 + 1.0*iMouse.y, rz );\n  vec3 ta = vec3( 0.0, 0.5, 0.0 );\n\n  // camera tx\n  vec3 cw = normalize( ta-ro );\n  vec3 cp = vec3( 0.0, 1.0, 0.0 );\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 3.0*cw );\n\n  // pixel color\n  vec3 col = render( ro, rd );\n  col = pow( col, vec3(0.4545) );\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfDM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[918, 1053, 1078, 1078, 1094], [1268, 1285, 1315, 1315, 1351], [1353, 1465, 1497, 1497, 2084], [2085, 2158, 2183, 2183, 2378], [2379, 2452, 2492, 2492, 2785], [2787, 2860, 2934, 2934, 3177], [3179, 3252, 3284, 3284, 3501], [3503, 3576, 3618, 3618, 3887], [3888, 3948, 3987, 3987, 5540], [5543, 5543, 5600, 5600, 6265]], "test": "untested"}
{"id": "WsffW7", "name": "sensual seduction —sat.sketch #9", "author": "szczm_", "description": "When I was a teenager, I saw Snoop Dogg's \"Sensual Seduction\" video on TV and my life hasn't been the same ever since.\n\nI didn't implement the full track, since I couldn't link the original track anyway, and it just doesn't feel the same :'(", "tags": ["2d", "chroma", "wave", "video", "80s", "zoom", "effect", "background", "sprite", "key", "damme", "jean", "claude", "vapor", "van", "multibuffer"], "likes": 20, "viewed": 818, "published": 3, "date": "1588425851", "time_retrieved": "2024-07-30T21:09:16.154259", "image_code": "/**************************************************************************************************\n\n sensual seduction — saturday sketch #9\n  — Matthias Scherba (@szczm_)\n\n\n When I was a teenager, I saw Snoop Dogg's \"Sensual Seduction\" video on TV and my life hasn't been\n the same ever since. I decided to recreate the basic effect visible in some of the scenes.\n\n The effect is implemented using \"sprite\" IDs and an anti-interpolation trick, and is very simple.\n Full explanation in the \"Buffer B\" tab.\n\n I didn't implement the full track, since I couldn't link the original track anyway, and it just\n doesn't feel the same :'(\n\n\n\n Switch to the Britney video at your own risk.\n\n https://twitter.com/szczm_\n\n**************************************************************************************************/\n\n// https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float sample_offset = 0.006;\n\n#define VIDEO_BUFFER (iChannel0)\n#define BACKGROUND_BUFFER (iChannel1)\n#define POI_BUFFER (iChannel2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n       \n    vec4 bg = texture(BACKGROUND_BUFFER, uv);\n    vec4 damn = texture(VIDEO_BUFFER, uv);\n    \n    float bg_time = bg.b / 10.0;\n    \n    float id = round(bg.g);\n\tfloat diff = 0.0;\n        \n    for (float i = 0.0; i < 1.0; i += 1.0 / 16.0)\n    {\n        float angle = i * TAU;\n\t\tvec2 dir = vec2(cos(angle), sin(angle));\n\n        diff += step(0.1, distance(id, texture(BACKGROUND_BUFFER, uv + dir * sample_offset).g));\n    }\n    \n    diff /= 16.0;\n    \n    float bg_border = smoothstep(1.0, 0.0, distance(diff, 0.5) * 2.0);\n    \n    bg_border = clamp(bg_border, 0.0, 1.0);    \n    \n    vec3 bg_color = hsv2rgb(vec3(bg_time, 1.0, 1.0));\n    \n    vec3 bg_final = mix(bg_color, vec3(0.0), bg_border);\n    \n    vec3 col = mix(bg_final, damn.rgb, damn.a);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\nBUFFER A: Jean Chroma Van Damme\n\n\nThis one just chroma keys the protagonist.\n\n*/\n\n#define THAT_DAMME_BUFFER (iChannel0)\n#define THIS_BUFFER (iChannel2)\n\n\nconst vec3 chroma_key = vec3(14, 162, 37) / 256.0;\n\nconst float chroma_low = 0.05;\nconst float chroma_high = 0.3;\n\nconst float chroma_cutoff_start = 0.5;\nconst float chroma_cutoff_end = 1.2;\n\n\n// bad chroma because I'm staying true to the original\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(THAT_DAMME_BUFFER, uv);\n    \n    float chroma = distance(col.rgb, chroma_key);\n    chroma = (chroma - chroma_low) / (chroma_high - chroma_low);\n    \n\tcol.a = smoothstep(chroma_cutoff_start, chroma_cutoff_end, chroma);\n\n    fragColor = col;\n}\n\n#undef THAT_DAMME_BUFFER", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n\nBUFFER B: background effect\n\n\nIn the original inspiration - the \"Sensual Seduction\" music video - contours keep shape and scale\nuniformly.\n\nI can't do ordinary \"sprites\", like the original most likely did.\n\nI started with a naïve outline approach, which, of course, didn't work well at all.\nThen I switched to a more radical idea:\n\nI took contours of our protagonist, and on the edges I calculated the alpha gradient, and then\nI propagated those gradients, like waves. Not only it took me too much time and fixing, it was\nalso incorrect (waves could cancel out one another), and it also was numerically unstable most\nof the time.\n\nI also tried radial dilation, but again, incorrect, contours started to bloat.\n\nAnd THEN - I had a moment of eureka. I already scale the UVs. Isn't that zooming? Zooming sprites?\nAnd that's the final approach that you see.\n\nI scale the UVs based on the \"center of mass\" calculated in Buffer C (the \"POI buffer\").\n\nAs often is the case, the simplest approach is the best approach.\n\n\n\nNow comes the problem of storing the data. Since it's not sprite based, the \"instance\" data is\nheld in the texture itself. I keep the time data for each \"sprite\", and an ID for differentiating\nbetween frames. (I've tried different approaches, but this one yielded best results, especially\nwhen filtering comes into play.)\n\nThis means that any discrete data is subject to interpolation. What can I do about this?\n\nMost obvious solution: nearest neighbour filtering. That disorts the image heavily, which is not\ndesired.\n\nThen I thought: how can I find out that data was distorted by interpolation? Error detection!\n\nI mark frame with an integer ID, and if it's no longer an integer, this gives me some information.\nIf the adjacent sprites have successive IDs, I can easily reconstruct the interpolated data.\nAs I only need to find out if we're on the edge of two sprites, I can assign only 0 and 1\nalternatively.\n\nThis comes with a downside - frame no 3 can overlap frame no 1, and we no longer get an outline.\n\nI switched to just successive IDs, which works very well for generating outlines between distant\nsprites.\n\nThis of course comes with yet another downside: no longer does the fractional part of the integer\npart allow us to correctly reconstruct the frame ID, if distant frames overlap. This shows in the\nfinal image as multiple/layered outlines.\n\nI considered switching back to ping-ponged IDs, which would lower the amount of layered outlines,\nbut it would again hide some of them. I decided to stay with the current, if slightly incorrect,\nresult.\n\n\nThe best and more obvious solution would probably be a highpass filter, or some reconstruction\nfilter, but I decided to stay with the current solution only because I find it very simple and\ninteresting.\n\n\n*/\n\n#define CHROMA_BUFFER (iChannel0)\n#define THIS_BUFFER (iChannel1)\n#define POI_BUFFER (iChannel2)\n\nconst int frame_gate = 12;\nconst float step_back_to_reality = 0.5;\nconst float zoom_per_frame = 1.02;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 center = texelFetch(POI_BUFFER, ivec2(0, 0), 0).rg;\n    \n    uv -= center;\n    uv /= zoom_per_frame;\n    uv += center;\n    \n    vec4 col;\n    \n    vec4 samp = texture(THIS_BUFFER, uv);\n    \n    float id = fract(samp.g);\n    \n    // check how far up or down we should move the interpolated ID\n    float deviation = step(0.5, id) - id;\n    \n    samp.g += deviation * step_back_to_reality;\n    // oh, there goes gravity. thanks a lot, Marshall\n\n    // we could also correct time, but the error is covered by the outline anyway\n    samp.b += iTimeDelta;\n    \n    col = vec4(samp.rgb, 1.0);\n    \n    \n    // put a new Van Damme in the background\n    if (iFrame % frame_gate == 0)\n    {\n        vec4 samp = texture(CHROMA_BUFFER, uv);\n        float id = float(iFrame / frame_gate);\n        \n\t    col = mix(col, vec4(0.0, id, 0.0, 1.0), step(0.5, samp.a));\n    }\n    \n    fragColor = col;\n}\n\n#undef CHROMA_BUFFER\n#undef THIS_BUFFER\n#undef POI_BUFFER", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// death to pi\n#define TAU 6.28318530718", "buffer_c_code": "/*\n\nBUFFER C: find center of mass\n\n\nSamples the chroma keyed buffer at equal offsets, checking if Van Damme is Van There,\nand then stores the data in the Van Bottom Left Pixelle. Weighted average.\n\n*/\n\n#define CHROMA_BUFFER (iChannel0)\n#define THIS_BUFFER (iChannel1)\n\nconst vec2 data_location = vec2(0.5, 0.5);\nconst float sample_step = 1.0 / 20.0;\nconst float offcenter_multiplier = 3.0;\n\nconst float half_pixel = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Are we in the data pixel?\n    if (distance(fragCoord, data_location) <= half_pixel)\n    {\n        vec2 sum = vec2(0.0);\n        float weights = 0.0;\n        \n        for (float x = sample_step / 2.0; x < 1.0; x += sample_step)\n        {\n            for (float y = sample_step / 2.0; y < 1.0; y += sample_step)\n            {\n                float alpha = texture(CHROMA_BUFFER, vec2(x, y)).a;\n                \n                sum += vec2(x, y) * alpha;\n                weights += alpha;\n            }\n        }\n        \n        if (weights > 1.0)\n        \tsum /= weights;\n        \n        // The FUTURISTIC off-center movement effect\n        sum -= 0.5;\n        sum *= offcenter_multiplier;\n        sum += 0.5;\n        \n        \n        // Mix a bit with the previous result for a smoother look\n        vec2 prev = texelFetch(THIS_BUFFER, ivec2(0, 0), 0).rg;\n        \n        sum = mix(prev, sum, step(1.0, weights) * 0.5);\n        \n    \tfragColor = vec4(sum, 0.0, 1.0);\n    }\n}\n\n#undef CHROMA_BUFFER", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsffW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[816, 871, 893, 893, 1062], [1203, 1203, 1260, 1260, 2090]], "test": "untested"}
{"id": "tslBW7", "name": "Fortress Harkonnen", "author": "mrange", "description": "License CC0: Fortress Harkonnen\nInspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n", "tags": ["2d", "fractal"], "likes": 37, "viewed": 1116, "published": 3, "date": "1588421175", "time_retrieved": "2024-07-30T21:09:17.019944", "image_code": "// License CC0: Fortress Harkonnen\n// Inspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\n// SABS from ollj\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define PI      3.141592654\n#define TAU     (2.0*3.141592654)\n#define TIME    iTime\n#define PERIOD  55.0\n#define PERIODS 5.0\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat plane(vec2 p, vec2 n, float m) {\n  return dot(p, n) + m;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat holey(float d, float k) {\n  return abs(d) - k;\n}\n\nfloat tanh2(float x) {\n  // Hack around precision problem\n  if (abs(x) > 50.0) {\n    return sign(x);\n  } else {\n    return tanh(x);\n  }\n}\n\nfloat nfield(vec2 p, vec2 c) {\n  vec2 u = p;\n\n  float a = 0.0;\n  float s = 1.0;\n\n  \n  for (int i = 0; i < 25; ++i) {\n    float m = dot(u,u);\n    u = SABS(u, 0.0125)/m + c;\n    u *= pow(s, 0.65);\n    a += pow(s, 1.0)*m;\n    s *= 0.75;\n  }\n  \n  return -tanh2(0.125*a);\n}\n\nvec3 normal(vec2 p, vec2 c) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(2.0/iResolution.y, 0);\n  \n  vec3 n;\n  n.x = nfield(p + e.xy, c) - nfield(p - e.xy, c);\n  n.y = 2.0*e.x;\n  n.z = nfield(p + e.yx, c) - nfield(p - e.yx, c);\n  \n  return normalize(n);\n}\n\nvec3 field(vec2 p, vec2 c) {\n  vec2 u = p;\n\n  float a = 0.0;\n  float s = 1.0;\n\n  vec2 tc = vec2(0.5, 0.3);\n  rot(tc, TAU*TIME/PERIOD);\n  vec2 tpn = normalize(vec2(1.0));\n  float tpm = 0.0 + 1.4*tanh(length(p));\n  \n  float tcd = 1E10;\n  float tcp = 1E10;\n  \n  for (int i = 0; i < 18; ++i) {\n    float m = dot(u,u);\n    u = SABS(u, 0.0125)/m + c;\n    tcd = min(tcd, holey(circle(u-tc, 0.05), -0.1));\n    tcp = min(tcp, holey(plane(u, tpn, tpm), -0.1));\n    u *= pow(s, 0.5);\n    a += pow(s, 1.0)*m;\n    s *= 0.75;\n  }\n  \n  return vec3(tanh(0.125*a), tanh(tcd), tanh(tcp));\n\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n    \n  float currentPeriod = mod(floor(TIME/PERIOD), PERIODS);\n  float timeInPeriod = mod(TIME, PERIOD);\n  \n  p *= 0.25 + (0.005*timeInPeriod) + pow(1.35, currentPeriod);\n  vec2 c = vec2(-0.5, -0.35);\n   \n  vec3 gp = vec3(p.x, 1.0*tanh(1.0 - (length(p))), p.y);\n  vec3 lp1 = vec3(-1.0, 1.5, 1.0);\n  vec3 ld1 = normalize(lp1 - gp);\n  vec3 lp2 = vec3(1.0, 1.5, 1.0);\n  vec3 ld2 = normalize(lp2 - gp);\n  vec3 f = field(p, c);\n\n  vec3 n = normal(p, c);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n  \n  const vec3 dcol1 = vec3(0.3, 0.5, 0.7).xyz;\n  const vec3 dcol2 = 0.5*vec3(0.7, 0.5, 0.3).xyz;\n  const vec3 scol1 = 0.5*vec3(1.0);\n  const vec3 scol2 = 0.5*0.5*vec3(1.0);\n  \n  col += diff1*dcol1;\n  col += diff2*dcol2;\n  col += scol1*pow(diff1, 10.0);\n  col += scol2*pow(diff2, 3.0);\n  col -= vec3(tanh(f.y-0.1));\n  col += 0.5*(diff1+diff2)*(1.25*pow(vec3(f.z), 5.0*vec3(1.0, 4.0, 5.0)));\n \n  col = postProcess(col, q);\n \n  const float fade = 2.0;\n  float fadeIn  = smoothstep(0.0, fade, timeInPeriod);\n  float fadeOut = 1.0-smoothstep(PERIOD - fade, PERIOD, timeInPeriod);\n  col *= fadeIn*fadeOut;\n \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 22430, "src": "https://soundcloud.com/gmm/ugress-win-without-triumph", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslBW7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[392, 392, 425, 425, 510], [512, 512, 550, 550, 576], [578, 578, 609, 609, 635], [637, 637, 668, 668, 691], [693, 693, 715, 750, 830], [832, 832, 862, 862, 1100], [1102, 1102, 1131, 1131, 1350], [1352, 1352, 1380, 1380, 1925], [1927, 1927, 1963, 1963, 2211], [2213, 2213, 2268, 2268, 3559]], "test": "untested"}
{"id": "3djyDD", "name": "flower_glow", "author": "elle", "description": "strange flower", "tags": ["flower"], "likes": 3, "viewed": 390, "published": 3, "date": "1588410433", "time_retrieved": "2024-07-30T21:09:17.772931", "image_code": "vec3 rotate(vec3 p, float angleX, float angleY)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\treturn (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n}\n\nfloat flower(vec3 p)\n{\n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n\treturn (1.44 * x2 + y2 + z2 +\n            1.0 / sqrt(abs(cos((5.0 + cos(0.5 * iTime)) * atan(p.z / p.y)))) +\n    \t\t1.0 / (y2 + z2) + 3.0 / (x2 + y2 + z2) - 7.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n   vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n   vec2 uv =  8.0 * aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    \n   vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy - 0.5);   \n   float d = flower(rotate(vec3(uv.x, uv.y, 2.2), mouse.x+0.5, mouse.y-1.1));\n    \n   vec3 color = vec3(0.5 + 0.5 * cos(0.5 * iTime + 2.0),\n                     0.5 + 0.5 * sin(0.5 * iTime + 4.0),\n                     0.5 + 0.5 * cos(0.5 * iTime + 0.0));\n  \n   fragColor = vec4(color * vec3(d/6.0), 1.0);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 296], [298, 298, 320, 320, 563], [565, 565, 620, 620, 1137]], "test": "untested"}
{"id": "WdsfD7", "name": "Watercolour Sketches", "author": "samhattangady", "description": "Tried to make a watercolour painting. Quite happy with how it turned out.\nThoughts and criticism appreciated.", "tags": ["watercolour", "handdraw"], "likes": 10, "viewed": 723, "published": 3, "date": "1588397199", "time_retrieved": "2024-07-30T21:09:18.672525", "image_code": "/*\n * 02 May 2020\n * I liked yesterday's sketch a lot. Wanted to make it a little less thick.\n * Fiddled with the values till I had a nice thin line that looked nice.\n * Wanted to go with a quick and dirty watercolour style sketch. Really happy\n * with the result.\n * The biggest problem I'm facing is the uniformity of the noise. Specifically\n * while filling in the colours (painting). So if I draw\n * multiple shapes that occupy the same space, their behaviour is identical which\n * doesn't look so great. So I need to figure out what infrastructure is required\n * so that the scale of noise is dependent on the size of the area being filled,\n * as well as use a different noise pattern for every individual shape (or something\n * along those lines) like passing a \"seed\" that is shared for the single fill.\n */\nfloat PI = 3.14159;\n\nvec3 paper_colour = vec3(0.9, 0.9, 0.85);\nvec3 pencil_colour = vec3(0.3, 0.3, 0.40);\n\nfloat line_thickness = 0.0;\nfloat line_variation = 5.2508;\nfloat line_smoothness = 1.5;\nfloat fill_noise = 35.04;\n\nfloat rand(vec2 c) {\n    //return pow((sin(iTime/1.0)),2.0)*0.1 + 0.9*fract(sin(dot(c.xy ,vec2(15.868,781.233))) * 4378.5453);\n\n\treturn fract(sin(dot(c.xy ,vec2(15.868,781.233))) * 4378.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n    p += vec2(iTime*14.50, 0.0);\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 30.3;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat pNoise2(vec2 p, int res){\n    p += vec2(iTime*12.0, iTime*52.0);\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 3.3;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat get_noise(vec2 p) {\n    float noise = pNoise(p, 3);\n    noise *= 2.0;\n    // noise -= 0.5;\n    return noise;\n}\nfloat get_noise2(vec2 p) {\n    float noise = pNoise2(p, 3);\n    noise *= 2.0;\n    // noise -= 0.5;\n    return noise;\n}\n\nfloat triangle_sign (vec2 p1, vec2 p2, vec2 p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool point_in_triangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3) {\n    float d1, d2, d3;\n    bool has_neg, has_pos;\n    d1 = triangle_sign(pt, v1, v2);\n    d2 = triangle_sign(pt, v2, v3);\n    d3 = triangle_sign(pt, v3, v1);\n    has_neg = (d1 < 0.0) || (d2 < 0.0) || (d3 < 0.0);\n    has_pos = (d1 > 0.0) || (d2 > 0.0) || (d3 > 0.0);\n    return !(has_neg && has_pos);\n}\n\nfloat rectangle(vec2 samplePosition, vec2 halfSize){\n    vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);\n    return outsideDistance + insideDistance;\n}\n\nfloat distance_to_line(vec2 p, vec2 p1, vec2 p2) {\n    float d;\n    float l_sq = pow(distance(p1, p2), 2.0);\n    if (l_sq == 0.0)\n        d = distance(p, p1);\n    else {\n        float t = max(0.0, min(1.0, dot(p - p1, p2 - p1) / l_sq));\n        vec2 projection = p1 + t * (p2 - p1);  // Projection falls on the segment\n        d = distance(p, projection);\n    }\n    return d;\n}\n\nfloat triangle (vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    float d, d2, d3;\n    d = distance_to_line(p, p1, p2);\n    d = min(d, distance_to_line(p, p2, p3));\n    d = min(d, distance_to_line(p, p3, p1));\n    if (point_in_triangle(p, p1, p2, p3))\n        return -d;\n    return d;\n}\n\nvec3 draw_line(vec2 p, vec2 p1, vec2 p2, vec3 current_colour) {\n    // return current_colour;\n    p += sin(iTime/1.2)*4.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    p1 += 5.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    p2 -= 5.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    float d = distance_to_line(p, p1, p2);\n    float noise;\n    // TODO (01 May 2020 sam): Figure out how to to better line check\n    if (p1.y<p.y) noise = get_noise(p.yx);\n    else noise = get_noise(p);\n    d += noise*line_variation;\n    float pencil = smoothstep(line_thickness, line_thickness+line_smoothness, d);\n    return mix(pencil_colour, current_colour, pencil);\n}\n\nvec3 fill_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour, vec3 fill_colour) {\n    vec3 colour = current_colour;\n    vec2 p2 = vec2(p1.x, p3.y);\n    vec2 p4 = vec2(p3.x, p1.y);\n    vec2 box_center = (p1 + p3)/2.0;\n    float bd = rectangle(p-box_center, (p3-p1)/2.0);\n    float noise = get_noise2(p);\n    noise *= fill_noise;\n    if (bd+noise<0.0)\n        colour = fill_colour;\n    return colour;\n}\n\nvec3 draw_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour, bool fill_paper) {\n    vec3 colour = current_colour;\n    vec2 p2 = vec2(p1.x, p3.y);\n    vec2 p4 = vec2(p3.x, p1.y);\n    vec2 box_center = (p1 + p3)/2.0;\n    float bd = rectangle(p-box_center, (p3-p1)/2.0);\n    float noise = get_noise(p);\n    noise *= 5.0;\n    if (bd-noise<0.0 && fill_paper)\n        colour = paper_colour;\n    colour = draw_line(p, p1, p2, colour);\n    colour = draw_line(p, p2, p3, colour);\n    colour = draw_line(p, p3, p4, colour);\n    colour = draw_line(p, p4, p1, colour);\n    return colour;\n}\n\nvec3 fill_triangle(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec3 current_colour, vec3 fill_colour) {\n    vec3 colour = current_colour;\n    float d = triangle(p, p1, p2, p3);\n    float noise = get_noise2(p);\n    noise *= fill_noise;\n    if (d+noise<0.0)\n        colour = fill_colour;\n    return colour;\n}\n\nvec3 draw_pillar(vec2 pos, vec2 p1, vec2 p3, vec3 current) {\n    float WIDTH = iResolution.x;\n\tfloat HEIGHT = iResolution.y;\n    vec3 building_colour = paper_colour*0.95;\n    vec3 shadow_colour = building_colour*0.9;\n    vec3 sky_colour = vec3(0.83, 0.83, 0.85);\n    vec3 ground_colour = vec3(0.8, 0.8, 0.65);\n    \n    vec3 colour = current;\n    colour = draw_box(pos, p1, p3, colour, true);\n    colour = fill_box(pos, p1, p3, colour, building_colour);\n    colour = fill_box(pos, vec2(p1.x+WIDTH*0.015, p1.y), p3, colour, shadow_colour);\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 colour;\n    float WIDTH = iResolution.x;\n\tfloat HEIGHT = iResolution.y;\n    vec3 building_colour = paper_colour*0.95;\n    vec3 shadow_colour = building_colour*0.9;\n    vec3 sky_colour = vec3(0.83, 0.83, 0.85);\n    vec3 ground_colour = vec3(0.8, 0.8, 0.65);\n\n    vec2 pos = fragCoord;\n    vec2 uv = pos/iResolution.xy;\n    colour = paper_colour;\n    // background\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.99), colour, sky_colour*0.93);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.75), colour, sky_colour*0.96);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.5), colour, sky_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.01), vec2(WIDTH*0.99, HEIGHT*0.31), colour, ground_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.3),  vec2(WIDTH*0.95, HEIGHT*0.1), colour, ground_colour*0.9);\n    float fade = rectangle(pos-vec2(WIDTH*0.5,HEIGHT*0.5), vec2(WIDTH*0.05, 0.0001));\n    fade += get_noise2(pos.yx) * 500.0;\n    fade = smoothstep(WIDTH*0.25, WIDTH*0.452, fade);\n    colour = mix(colour, paper_colour, fade);\n    // horizon\n    colour = draw_line(pos, vec2(-50000.0, iResolution.y/3.0), vec2(iResolution.x*5000.0, iResolution.y/3.0), colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.18, HEIGHT*0.66), vec2(WIDTH*0.5, HEIGHT*0.82), vec2(WIDTH*0.82, HEIGHT*0.66), colour, paper_colour);\n    // pillars\n    colour = draw_pillar(pos, vec2(WIDTH*0.22, HEIGHT*0.405), vec2(WIDTH*0.26, HEIGHT*0.585), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.30, HEIGHT*0.405), vec2(WIDTH*0.34, HEIGHT*0.588), colour);\n    //colour = draw_pillar(pos, vec2(WIDTH*0.22, HEIGHT*0.41), vec2(WIDTH*0.26, HEIGHT*0.59), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.37, HEIGHT*0.407), vec2(WIDTH*0.41, HEIGHT*0.586), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.44, HEIGHT*0.404), vec2(WIDTH*0.48, HEIGHT*0.583), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.51, HEIGHT*0.406), vec2(WIDTH*0.55, HEIGHT*0.588), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.59, HEIGHT*0.404), vec2(WIDTH*0.63, HEIGHT*0.589), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.66, HEIGHT*0.408), vec2(WIDTH*0.70, HEIGHT*0.586), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.74, HEIGHT*0.409), vec2(WIDTH*0.78, HEIGHT*0.583), colour);\n    // base\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.4), colour, true);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.4), colour, building_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.36), colour, shadow_colour);\n    colour = draw_box(pos, vec2(WIDTH*0.24, HEIGHT*0.32), vec2(WIDTH*0.76, HEIGHT*0.38), colour, false);\n    // roof\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.66), colour, true);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.66), colour, building_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.26, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.64), colour, shadow_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), vec2(WIDTH*0.8, HEIGHT*0.68), colour, building_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.6, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), vec2(WIDTH*0.8, HEIGHT*0.68), colour, shadow_colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.8, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.8, HEIGHT*0.68), colour);\n    fragColor = vec4(colour, 1.0);\n    float c = get_noise(pos.yx);\n    // fragColor = vec4(vec3(c), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1037, 1037, 1057, 1163, 1231], [1233, 1233, 1266, 1266, 1638], [1640, 1640, 1670, 1670, 1994], [1996, 1996, 2027, 2027, 2356], [2358, 2358, 2383, 2383, 2474], [2475, 2475, 2501, 2501, 2593], [2595, 2595, 2644, 2644, 2720], [2722, 2722, 2783, 2783, 3084], [3086, 3086, 3138, 3138, 3427], [3429, 3429, 3479, 3479, 3806], [3808, 3808, 3860, 3860, 4085], [4087, 4087, 4150, 4180, 4730], [4732, 4732, 4812, 4812, 5131], [5133, 5133, 5212, 5212, 5710], [5712, 5712, 5806, 5806, 6009], [6011, 6011, 6071, 6071, 6569], [6571, 6571, 6628, 6628, 10514]], "test": "untested"}
{"id": "WslfD7", "name": "Weird Machine That Does Nothing", "author": "blackle", "description": "made in like an hour a half on discord live with some friends. it has some texture swimming problems but I didn't want to deal with it >.<", "tags": ["sdf", "machine", "relfection"], "likes": 19, "viewed": 576, "published": 3, "date": "1588395626", "time_retrieved": "2024-07-30T21:09:19.464408", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//set FOCALBLUR to 1 and SAMPS to 3 for a prettier shader, but beware, it's slow!\n#define FOCALBLUR 0\n#define SAMPS 1\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(vec3(0),q)) + min(0., max(q.x,max(q.y,q.z)));\n}\n\nfloat fancyrings(vec3 p) {\n    p=abs(p);\n    p.xy = vec2(max(p.x,p.y),min(p.y,p.x));\n    float ring = length(vec2(super(p.xy)-1.8,p.z))-0.2;\n    float metaring = super(vec2(length(p.xz-vec2(1.8,0.))-0.5, p.y-(0.5+0.25*cos(iTime*8.))))-0.2;\n    return min(ring,metaring);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    float b = box(erot(p,vec3(0,0,1),p.z*0.5+iTime),vec3(0.25,0.25,4))-0.5;\n    float scale = 0.65;\n    p.z = (asin(sin(p.z*scale*3.14)*0.99)/3.14)/scale;\n    float ring1 = fancyrings(p+vec3(0,0,.75));\n    float ring2 = fancyrings(erot(p,vec3(0,0,1),radians(45.))-vec3(0,0,0.75));\n    return min(min(ring1,ring2),b);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat noise(vec2 p) {\n    vec2 id = floor(p);\n    vec2 crds = fract(p);\n    float h1 = hash(id.x,id.y);\n    float h2 = hash(id.x+1.,id.y);\n    float h3 = hash(id.x,id.y+1.);\n    float h4 = hash(id.x+1.,id.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nfloat triplanar(vec3 p, vec3 n) {\n    return mix(noise(p.xy), mix(noise(p.xz), noise(p.yz), n.x*n.x), 1.-n.z*n.z);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\nvec3 srgb(float r) {\n    return vec3(r*r);\n}\n\nfloat speed(float x) {\n    return pow(sin(fract(x)*3.14/2.),200.)+floor(x)+x*2.;\n}\n\nvec3 pixel(vec2 uv) {\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-6,0,0);\n    \n    float h1 = hash(hash(uv.x,uv.y),iTime*8.);\n    float h2 = hash(h1,iTime);\n    float h3 = hash(h2,iTime);\n    vec3 blur = normalize(tan(vec3(h1,h2,h3)))*float(FOCALBLUR);\n    cam+=blur*0.025;\n    init-=blur*0.1;\n    \n    float ramptime = speed(iTime*0.25);\n    float yrot = 0.2;\n    float zrot = ramptime;\n    init.x += sin(ramptime*0.5);\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    init.z += cos(ramptime);\n    \n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init) > 10.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float marble = smoothstep(-0.5,0.4,triplanar(p*4., n));\n    float tex = max(triplanar(p*80., n),0.)*marble;\n    float spexex = mix(8., 6., tex);\n    float ao = smoothstep(-1.,1.,scene(p+r*0.3)/0.3/dot(r,n))*0.5+0.5;\n    float diff1 = ao*pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n    float diff2 = ao*pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n    float diff3 = ao*pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n    vec3 col1 = mix(srgb(0.,.05,.1), srgb(0.4,.3,1.), diff1) + pow(diff1, spexex)*1.5;\n    vec3 col2 = mix(srgb(0.1,.0,0.5), srgb(1.,.2,0.5), diff2) + pow(diff2, spexex)*1.5;\n    vec3 col3 = mix(srgb(0.1), srgb(0.9,0.9,1.), diff3) + pow(diff3, spexex)*1.5;\n    vec3 col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));\n    return hit ? col : mix(srgb(0.25), srgb(0.1), length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col;\n    for (int i = 0; i<SAMPS;i++) {\n        for (int j = 0; j<SAMPS;j++) {\n            vec2 off= vec2(i,j)/iResolution.y/float(SAMPS);\n            col += vec4(pixel(uv+off), 1);\n        }\n    }\n    fragColor.xyz = col.xyz/col.w;\n    fragColor.xyz = sqrt(fragColor.xyz) + hash(hash(uv.x,uv.y),iTime)*0.02;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslfD7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[313, 313, 334, 334, 366], [367, 367, 388, 388, 420], [422, 422, 449, 449, 541], [543, 543, 569, 569, 815], [817, 817, 855, 855, 919], [921, 921, 942, 942, 1261], [1318, 1318, 1348, 1348, 1427], [1429, 1429, 1450, 1450, 1702], [1704, 1704, 1737, 1737, 1820], [1822, 1822, 1841, 1841, 1958], [1960, 1960, 1998, 1998, 2030], [2031, 2031, 2051, 2051, 2075], [2077, 2077, 2099, 2099, 2159], [2161, 2161, 2182, 2182, 3901], [3903, 3903, 3960, 3960, 4341]], "test": "untested"}
{"id": "3dsBD7", "name": "My First Working Shader", "author": "Zi7ar21", "description": "THANK YOU SO MUCH https://www.shadertoy.com/user/loicvdb FOR TEACHING ME", "tags": ["firstshader"], "likes": 5, "viewed": 331, "published": 3, "date": "1588388605", "time_retrieved": "2024-07-30T21:09:20.331091", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))+(texture(iChannel0, uv).rgb);\n\n    // Output to screen\n    fragColor = vec4(col,0.5);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 325]], "test": "untested"}
{"id": "3slfWM", "name": "New Chess Set", "author": "eiffie", "description": "Sadly it did not improve my playing. ", "tags": ["chess"], "likes": 20, "viewed": 709, "published": 3, "date": "1588368654", "time_retrieved": "2024-07-30T21:09:21.420179", "image_code": "//New Chess Set - by eiffie (sadly the new board didn't improve my playing)\n// Global Illumination and the very beginnings of a chess engine in a single frag\n// running nicely on a $150 2in1. This was just a speed test before trying to\n// port a CPU based 4 or 5 turn minmax to glsl.\nvoid mainImage(out vec4 O, in vec2 U){\n  if(U.x<9. && U.y<8.)O=vec4(0.);//hide 'logic'\n  else O=texture(iChannel0,U/iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//adjust ENDFRAME, if it runs too fast make it higher\n#define ENDFRAME 54.\n#define rez iResolution\n#define TAU 6.283\n#define PAWN 1.0\n#define ROOK 5.0\n#define KNIGHT 4.0\n#define BISHOP 3.0\n#define QUEEN 9.0\n#define KING 100.0\n#define ILLEGAL -1000.0\n#define half 0.5\n#define wid 8.0\n#define zero 0.0\n#define one 1.0\n#define two 2.0\n#define get(v) texture(iChannel0,(vec2(floor((v).x),floor((v).y))+vec2(half))/iResolution.xy)\n#define same(x,y) all(equal(floor(x),floor(y)))\n#define fsame(x,y) (floor(x)==floor(y))\n#define isZero(x) (abs(x)<half)\n#define STATEVEC (rez.xy-vec2(one))\n#define SCOREFRAME ENDFRAME-3.\n#define BESTFRAME ENDFRAME-2.\n#define ssgn(x) ((x)-.1>0.?1.:(x)+.1<0.?-1.:0.)\n\n//random seed and generator\nvec2 randv2;\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 4375.5453),\n  fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 2342.631));\n}\nfloat legal(float t, float p, vec2 p1, vec2 p2){//this only handles computer moves! \n  if(p2.x<zero||p2.x>=wid||p2.y<zero||p2.y>wid)return ILLEGAL;//off board\n  if(same(p1,p2))return ILLEGAL;\n  float cap=get(p2).x;\n  if(cap!=zero){//not empty \n    if(sign(cap)==p)return ILLEGAL;//landed on own piece  \n  }\n  cap=abs(cap);\n  if(t==PAWN){//pawn needs special checks\n    vec2 a=abs(p2-p1);\n    if((fsame(a.x,one) && cap==zero) || (isZero(a.x) && cap!=zero))return ILLEGAL;//only captures diag\n    //if(a.y==2)if(!(p1.y==d.y || p1.y==7+d.y))return -1;//can only jump 2 at start\n  }//no long jumping pawn or castling king so we can bail here\n  if(t==KNIGHT || t==PAWN ||t==KING)return cap;//can not be blocked so the move is good\n  vec2 d=vec2(ssgn(p2.x-p1.x),ssgn(p2.y-p1.y)),w=p1+d;\n  for(int i=0;i<8;i++){\n  \tif(same(w,p2))break;\n    if(get(w).x!=zero)return ILLEGAL;//blocked\n    w+=d;\n  }\n  return cap;//other pieces are good, no checks for castling or en passant\n}\n//CHEBYSHEV rotations for KING and KNIGHT moves\n#define cPi (two*two)\nfloat cCos(float a){return clamp(abs(mod(a,two*cPi)-cPi)-cPi/two,-one,one);}\nfloat cSin(float a){return cCos(a-cPi/two);}\nvec2 rookMove(float j, vec2 p){return j<wid?vec2(j-p.x,zero):vec2(zero,j-wid-p.y);}\nvec2 bishopMove(float j, vec2 p){return j<wid?vec2(j-p.x):vec2(j-wid-p.x,p.x-j+wid);}\n//this would only be used on the last leaf, otherwise score all moves (not best)\nvoid scoreMoves(inout vec4 b, vec2 p1, float p, float lvl){//b.x=piece,b.y=score,b.zw=p2, p1=square, p=player (-1,1)\n  if(lvl==1.){b.y=ILLEGAL;b.z=b.w=zero;}//no move\n  else if(b.y==ILLEGAL)return;//first move couldn't be competed\n  if(!fsame(sign(b.x),p) || b.x==zero)return;//empty or wrong player's piece\n  vec2 fp1=floor(p1);\n  float t=abs(b.x), bw=ILLEGAL,w,qw;//type of piece,best score (weight)\n  for(float m=0.;m<16.;m+=1.){\n    if((t==PAWN && m>two) || ((t==KING || t==KNIGHT) && m>=wid))break;//fewer moves\n    vec2 d=vec2(zero);w=ILLEGAL;//delta of move, default is illegal\n    if(t==PAWN){d.y=-p;if(m==one)d.x=-one;else if(m==two)d.x=one;} \n    else if(t==ROOK || t==QUEEN)d=rookMove(m,fp1);//queen (also bishopMoves below) \n    else if(t==BISHOP)d=bishopMove(m,fp1);\n    else if(t==KNIGHT){\n      float a=m*cPi/4.+cPi/8.;d=vec2(cCos(a)*2.,cSin(a)*2.);\n    }else if(t==KING){\n      float a=m*cPi/4.;d=vec2(cCos(a),cSin(a)); \n    }\n    w=legal(t,p,p1,p1+d);//get score weight/illegal move\n    if(t==QUEEN){//check bishopMoves for queen\n      vec2 d2=bishopMove(m,fp1);qw=legal(t,p,p1,p1+d);\n      if(qw>w){w=qw;d=d2;}//swap rook type movefor bishop type\n    }\n    if(w>bw){bw=w;if(lvl==1.){b.z=p1.x+d.x;b.w=p1.y+d.y;}}\n  }\n  b.y=(lvl==1.?bw:b.y-=bw);\n}\nvec4 setup1(vec2 p){//find starting positions\n  vec4 v=vec4(zero,zero,zero,one);\n  vec2 ap=floor(abs(p-vec2(4.)));\n  p=floor(p);\n  if(ap.y==3.){\n    if(ap.x==3.)v.x=ROOK;\n    else if(ap.x==two)v.x=KNIGHT;\n    else if(ap.x==one)v.x=BISHOP;\n    else if(p.x<4.)v.x=QUEEN;\n    else v.x=KING;\n  }else if(ap.y==two)v.x=PAWN;\n  if(v.x>0.)v.x*=sign(p.y-4.);\n  return v;\n}\nvec4 findBestInBoard(vec2 U,vec2 dir){//2 directional search x then y\n  vec4 b=vec4(zero);vec2 dd;float best=ILLEGAL;\n  if(dir.x>zero)dd=vec2(half,U.y);else dd=vec2(U.x,half);\n  for(int i=0;i<8;i++){\n    vec4 v=get(dd);\n    if(v.y+sin(float(i)+iDate.w)>best){\n      best=v.y;\n      if(dir.x>zero)b=vec4(v.x,v.y,dd.x,dd.y);\n      else b=v;\n    }\n    dd+=dir;\n  }\n  return b;\n}\nvoid doMove(inout vec4 O, vec2 U){\n  vec4 m=get(vec2(wid,zero));//p1 in zw\n  vec4 m2=get(vec2(m.z,m.w));//p2 in zw\n  if(same(U,vec2(m.z,m.w)))O=vec4(zero);//remove from p1\n  else if(same(U,vec2(m2.z,m2.w))){\n    O=get(vec2(m.z,m.w));//replace at p2\n  }\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec4 st=vec4(zero);\n  randv2=fract(cos(vec2(iTime)+vec2(dot(U.xy,vec2(113.0,107.0)),dot(U.yx,vec2(43.1,13.7))))*4231.8413);\n  O=get(U);//texture(iChannel0,U/rez.xy);\n  if(same(U,STATEVEC)){//state vector rez.x,??,frame,player\n    if(!fsame(O.x,rez.x))O=vec4(rez.x,zero,zero,one);\n    else if(O.z<ENDFRAME)O.z+=one;\n    else{O.y+=one;O.z=one;O.w=-O.w;if(O.y>30.)O=vec4(rez.x,zero,zero,one);}\n    return;//done with state\n  }else st=get(STATEVEC);\n  float frame=floor(st.z+0.1),player=st.w;\n  if(U.y<wid){//very dumb chess game\n    if(U.x>wid+one)return;//not needed\n    //vec2 mu=mod(U,vec2(wid));\n    if(frame==0. && U.x<wid)O=setup1(U);//setup/reset\n    else if(frame==SCOREFRAME && U.x<wid){scoreMoves(O,U,player,1.);scoreMoves(O,U,-player,2.);}\n    else if((frame>=BESTFRAME && frame<ENDFRAME) && fsame(U.x,wid)){\n      vec2 v=vec2(1.,0.);O=findBestInBoard(U,(frame==BESTFRAME?v:vec2(v.y,v.x)));\n    }else if(frame==ENDFRAME && U.x<wid)doMove(O,U);\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//the instruments need an update!\n#define bps 7.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= 4.0; \n  else if(n<4.0)n= 5.0; \n  else if(n<5.0)n= 4.0; \n  else if(n<6.0)n= 3.0; \n  else if(n<7.0)n= 2.0; \n  else n=1.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n)); \n} \nvec2 mainSound( in int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(0.5,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr sitar=instr(100.0,0.25,4.0,0.0,0.2525,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.75,1.0,0.0125); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(10.0,0.2,1.5,0.0,0.25,0.005); \n instr bass=instr(20.0,0.2,1.5,0.0,0.2525,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,sitar)*n0.y*0.25;\n   if(mod(i,3.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y*0.3;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i; \n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+51.0,time,t1,pluckbass)*n1.y;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       \n       a+=I(n2.x+44.0,time,t2,bass)*n2.y*4.0; \n       a+=I(n2.x+24.0,time+0.008*sin(t2*15.0),t2,bassdrum)*n2.y*4.0; \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/24.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 284, 322, 322, 418]], "test": "untested"}
{"id": "3dlfWH", "name": "Gentle Rings", "author": "darknoon", "description": "Just a simple relaxing sine combination", "tags": ["rings"], "likes": 13, "viewed": 1044, "published": 3, "date": "1588367654", "time_retrieved": "2024-07-30T21:09:22.309801", "image_code": "#define PI 3.141596\n\n\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.33, 0.67);\n\n// iq color mapper\nvec3 colorMap(float t) {\n\treturn (a + b * cos(2. * PI * (c * t + d)));\n}\n\nvoid mainImage(out vec4 o, in vec2 i)\n{\n    vec2 uv = i / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    \n    float ring = 1.5 + 0.8 * sin(PI * 0.25 * iTime);\n    \n    float kr = 0.5 - 0.5 * cos(7. * PI * r); \n    vec3 kq = 0.5 - 0.5 * sin(ring*vec3(30., 29.3, 28.6) * r - 6.0 * iTime + PI * vec3(-0.05, 0.5, 1.0));\n    vec3 c = kr * (0.1 + kq * (1. - 0.5* colorMap(a / PI))) * (0.5 + 0.5 * sin(11.*a + 22.5*r));\n\n    // Output to screen\n    o.rgb = mix(vec3(0.0, 0.0, 0.2), c, 0.85);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 165, 189, 189, 237], [239, 239, 278, 278, 819]], "test": "untested"}
{"id": "tdsfD8", "name": "Pink beamkiller!", "author": "friol", "description": "Watch your head.", "tags": ["raymarching", "demoscene", "volumetric", "lights"], "likes": 15, "viewed": 662, "published": 3, "date": "1588366564", "time_retrieved": "2024-07-30T21:09:23.134595", "image_code": "\n//\n// friol 2o2o\n// sdf functions by iq\n// music by Twisterium\n// 02.05.2020: slightly enlarged beamrays\n//\n\nconst int iterationAmount=512;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdInvertedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return -length(max(q,0.0)) - min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\n//\n//\n//\n\nvec2 SDF(vec3 r)\n{\n    float mat=0.0;\n    vec3 origR=r;\n    float rotTime=iTime/1.0;\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    float cylRad=0.15+0.1*fft;\n    \n    r=rotz(r,rotTime);\n    r=roty(r,-rotTime);\n    float t = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    r=rotx(r,3.141592/2.0);\n    float t2 = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    r=rotz(r,3.141592/2.0);\n    float t3 = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    \n    t=min(min(t,t2),t3);\n    \n    return vec2(t,1.0);\n}\n\nvec2 SDFsolid(vec3 r)\n{\n    vec3 origR=r;\n    float t=1000.0;\n    float rotTime=iTime/1.0;\n\n    r=rotz(r,rotTime);\n    r=roty(r,-rotTime);\n\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    //float rbox = sdRoundBox(r,vec3(.5,.5,.5),.1);\n    float rbox = sdSphere(r,.69+fft*0.33);\n    float amt=10.0;\n    //rbox+=0.2*(0.5+abs(sin(iTime)))*cos(r.x*amt)*sin(r.y*amt)*cos(r.z*amt);\n    rbox+=(.10+0.05*fft)*cos(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=rbox;\n    \n    float cyllen=.55;\n    float cylrad=.19;\n    float tcyl0=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl0);\n    r=rotx(r,3.141592/2.0);\n    float tcyl1=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl1);\n    r=rotz(r,3.141592/2.0);\n    float tcyl2=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl2);\n    \n    /*\n    origR+=vec3(0.0,0.0,iTime);\n    int numq=5;\n    for (int i=0;i<numq;i++)\n    {\n        float c=.9;\n        vec3 q = vec3(origR.x,origR.y,mod(origR.z+0.5*c,c)-0.5*c);\n        vec3 rotatedr=rotz(q,(float(i)*3.141592*2.0)/float(numq));\n    \t//float abox=sdRoundBox(rotatedr-vec3(0.0,-2.3,4.0),vec3(1.82,.01,3.5),.1);\n        float box=sdSphere(rotatedr-vec3(0.0,-1.0,0.0),.2);\n        //float box=sdPlane(rotatedr-vec3(0.0,-1.0,0.0),vec4(0.0,1.0,0.0,1.0));\n        t=min(t,box);\n    }\n\t*/\n    \n    float ibox=sdInvertedBox(origR,vec3(5.5));\n    t=min(t,ibox);\n\n    if ((t==tcyl0)||(t==tcyl1)||(t==tcyl2)) return vec2(t,3.0);\n    if (t==rbox) return vec2(t,2.0);\n    return vec2(t,4.0);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFsolid(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float mintlc=100000.0;\n    float lightAccum=0.0;\n    float fogAccum=0.0;\n    \n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    \n    // light cone\n    float tlc = 0.0;\n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * tlc);\n        if (res[0]<0.0)\n        {\n            float fact=distance(vec3(0.),rayOrigin + rayDir * tlc);\n            float k=(abs(noise((rayOrigin+rayDir*tlc))));\n            //k*=0.02;\n            k*=0.08*fft;\n            //float cnst=0.08;\n            lightAccum+=mix(k,0.08,0.4)/fact;\n            //lightAccum+=k/fact;\n            if (tlc<mintlc) mintlc=tlc;\n        }\n        tlc += 0.0155;\n    }\n    \n    //lightAccum/=2.0;\n    //lightAccum=clamp(lightAccum,0.0,1.0);\n    \n    // solid shapes\n    float t=0.0;\n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDFsolid(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n    \t\tif (lightAccum>0.0)\n            {\n                vec3 vecLight=rayOrigin+rayDir*mintlc;\n                vec3 vecSolid=rayOrigin+rayDir*t;\n                \n                if (distance(rayOrigin,vecSolid)<=distance(rayOrigin,vecLight))\n                {\n                    return vec4(t,res[1],0.0,fogAccum);\n                }\n                else\n                {\n                    return vec4(t,res[1],lightAccum,fogAccum);\n                }\n            }\n            else\n            {\n                return vec4(t,res[1],0.0,fogAccum);\n            }\n        }\n\n        float n=abs(noise((rayOrigin+rayDir*tlc)));\n        //n=cos(n)*n*sin(n);\n        fogAccum+=n*0.04;\n        t += res[0];\n    }\n    \n\tif (lightAccum>0.0) return vec4(0.0,1.0,clamp(0.0,1.0,lightAccum),fogAccum);\n     \n    return vec4(-1.0,-1.0,-1.0,-1.0);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(0.0,0.0,-1.0));\n\n    vec4 rayHit = castRay(rayOrigin, rayDir);\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n\n    if (mat==1.0)\n    {\n        col=vec3(1.0,1.0,1.0)*rayHit[2];\n    }\n    else if (((mat==2.0)||(mat==3.0))||(mat==4.0))\n    {\n        vec3 N=calcNormal(rayOrigin + rayDir * rayHit[0]);\n        if (mat==2.0) \n        {\n    \t\tfloat rotTime=iTime/4.0;\n            vec3 N2=N;\n            N2=rotz(N2,rotTime);\n            N2=roty(N2,-rotTime);\n            vec2 matuv = vec2( atan(N2.x,N2.z), acos(N2.y ) );\n\t\t\tfloat intensity=max((dot(N2,L)),0.0);\n            intensity+= pow(intensity, 2.0);            \n            //col=texture(iChannel0,matuv).rrr;\n            //col=mix(col,vec3(intensity),0.9);\n            //col=vec3(intensity*0.817,intensity*0.32,intensity*0.5);\n            vec3 colstart=vec3(0.03,0.045,0.18);\n            vec3 colenddd=vec3(0.817,0.32,0.5);\n            col=mix(colstart,colenddd,intensity/2.0);\n        }\n        else if (mat==3.0) \n        {\n        \tfloat NoL=max(dot(N, L),0.0);\n            col=vec3(1.,1.,1.)*NoL;\n        }\n        else if (mat==4.0) \n        {\n            //vec3 ll=vec3(1.0,0.0,0.0);\n        \t//float NoL=max(dot(N, ll),0.0);\n            //float intens=0.1;\n            //col=vec3(intens)*NoL;\n            //col+=vec3(0.1,0.1,0.4);\n            //col/=pHit.z/3.2;\n        \tvec2 a=vec2(1.0);\n            if ((N.z>0.01)||(N.z<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.y, 1.)));\n            }\n            else if ((N.x>0.01)||(N.x<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.y, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n            }\n            else if ((N.y>0.01)||(N.y<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n            }\n            col = vec3(.6-a.x,.7-a.y,0.8-a.x);\n            //col*=NoL;\n        }\n        \n        // add fog\n        col+=vec3(rayHit[3]);\n        \n        // add lightrays\n        col+=vec3(rayHit[2]);\n        \n        // add beat\n        if (iTime>15.0) col+=pow(fft,16.0);\n    }\n    else\n    {\n        col=vec3(0.0,0.0,0.0);\n    }\n\n    //col=fog(col,, vec3 fxcol)\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime;\n    float rotTime=iTime*1.5;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n    \n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    float radius=2.0+2.0*abs(sin(iTime));\n    //camPos = vec3(radius*sin(myTime),0.0,-radius*cos(myTime));\n    //camTarget = vec3(0.0,cos(myTime)*2.0,0.0);\n    camPos=vec3(radius*sin(rotTime),2.0*sin(rotTime),-radius*cos(rotTime));\n    camTarget=vec3(0.0,0.0,0.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz,1.0);\n\tfinalCol+=0.09;    \n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n", "image_inputs": [{"id": 22384, "src": "https://soundcloud.com/twisterium/trance-2-free-instrumental-background-music-creative-commons", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 186, 186, 208], [210, 210, 242, 242, 353], [355, 355, 386, 386, 497], [499, 499, 530, 530, 641], [643, 643, 695, 695, 794], [796, 796, 829, 829, 857], [859, 859, 904, 904, 995], [997, 997, 1030, 1030, 1061], [1063, 1063, 1094, 1094, 1181], [1183, 1183, 1247, 1247, 1364], [1366, 1366, 1418, 1418, 1525], [1527, 1527, 1563, 1563, 1597], [1599, 1599, 1638, 1638, 1726], [1728, 1748, 1768, 1768, 1863], [1865, 1888, 1914, 1914, 2388], [2401, 2401, 2419, 2419, 2892], [2894, 2894, 2917, 2917, 4379], [4381, 4381, 4408, 4408, 4650], [4652, 4652, 4695, 4695, 6477], [6479, 6479, 6530, 6530, 9117], [9119, 9119, 9179, 9179, 9505], [9507, 9507, 9553, 9553, 9679], [9681, 9681, 9711, 9711, 9783], [9785, 9785, 9842, 9842, 10483]], "test": "untested"}
{"id": "tsffDM", "name": "Hypercentric Optics", "author": "blackle", "description": "experimenting with hypercentric optics as described by the applied science video here: https://www.youtube.com/watch?v=iJ4yL6kaV1A\n\nuse the mouse to rotate", "tags": ["hypercentric", "pericentric", "appliedscience", "domino", "dominos"], "likes": 9, "viewed": 466, "published": 3, "date": "1588354880", "time_retrieved": "2024-07-30T21:09:24.060120", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(vec3(0), q)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nint mat;\nfloat domino(vec3 p, mat3 topholes, mat3 bottomholes) {\n    float body = box(p, vec3(0.0,0.4,0.9))-0.2;\n    float holes = linedist(p, vec3(.2,0.45,0), vec3(0.2,-0.45,0))-0.04; //divider\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec2 holepos = vec2(float(i-1), float(j-1))*0.3;\n            if (topholes[i][j] == 1.) {\n                holes = min(holes, length(p-vec3(.2,holepos+vec2(0.,0.55)))-0.08);\n            }\n            if (bottomholes[i][j] == 1.) {\n                holes = min(holes, length(p-vec3(.2,holepos+vec2(0.,-0.55)))-0.08);\n            }\n        }\n    }\n    mat = -body < holes ? 1 : 0;\n    return -smin(-body, holes, 0.05);\n}\n\nfloat scene(vec3 p) {\n    float table = box(p-vec3(0,0,-1.2), vec3(3,3,0.05))-0.05;\n    float d1 = domino(erot(p-vec3(-1,0,0),vec3(0,0,1),-0.05), mat3(0,0,1,0,1,0,1,0,0), mat3(1,0,1,0,1,0,1,0,1));\n    int d1mat = mat;\n    float d2 = domino(erot(p-vec3(1,0,0),vec3(0,0,1),0.1), mat3(1,0,1,0,0,0,1,0,1), mat3(0,0,0,0,1,0,0,0,0));\n    int d2mat = mat;\n    float dominos = min(d1,d2);\n    mat = d1 < d2 ? d1mat : d2mat;\n    mat = dominos < table ? mat : 2;\n    return min(dominos,table);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])) );\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nvec3 srgb(float k) {\n    return vec3(k*k);\n}\n\nvec3 trilinear_texture(vec3 p, vec3 n) {\n    return mix(mix(texture(iChannel0,p.xz), texture(iChannel0,p.yz), n.x*n.x), texture(iChannel0,p.xy), n.z*n.z).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    //when centricity is negative, instead of camera rays diverging from the\n    //image plane, they instead converge. you can image this as the image plane\n    //being a refractive object that causes the camera rays to switch directions\n    float centricity = cos(iTime)*0.5;\n    vec3 cam = normalize(vec3(1,uv*centricity));\n    vec3 init = vec3(-5,uv*(4.-centricity*2.));\n\n   \tfloat yrot = 0.1;\n    float zrot = 3.14;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 500 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p, init) > 100.) break;\n    }\n    int locmat = mat;\n\tvec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float ao = smoothstep(-1.,1.,scene(p+n*0.1)/.1);\n    float specao = smoothstep(0.,1.,scene(p+r*0.3)/.3);\n    float diff = ao*length(sin(n*2.5)*0.5+0.5)/sqrt(3.);\n    float spec = length(sin(r*2.5)*0.5+0.5)/sqrt(3.);\n    float diffbright = locmat == 0 ? 0.05 : 1.;\n    float specbright = locmat == 2 ? 0.1 : 1.5;\n  \n    p += trilinear_texture(p*0.5,n)*0.1;\n    vec3 tex = trilinear_texture(p,n)*0.25 + trilinear_texture(p*0.5,n)*0.5 + trilinear_texture(p*0.2,n);\n    vec3 diffcol = locmat == 2 ? (tex.x*0.5+0.1)*srgb(0.9, 0.85, 0.8) : srgb(0.95);\n    specbright += tex.x*tex.x*0.2;\n    vec3 col = mix(diffcol*0.1, diffcol, diff)*diffbright + pow(spec, 10.)*specbright*specao;\n    fragColor.xyz = hit ? col : vec3(pow(length(sin(cam*2.5)*0.5+0.5)/sqrt(3.), 10.)+0.01);\n    fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsffDM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 215, 215, 247], [249, 249, 276, 276, 371], [373, 373, 413, 413, 505], [507, 507, 545, 545, 609], [611, 611, 650, 650, 721], [732, 732, 787, 787, 1417], [1419, 1419, 1440, 1440, 1904], [1906, 1906, 1925, 1925, 2042], [2044, 2044, 2082, 2082, 2114], [2116, 2116, 2136, 2136, 2160], [2162, 2162, 2202, 2202, 2322], [2324, 2324, 2381, 2381, 4285]], "test": "untested"}
{"id": "3dfBD7", "name": "Combination Grid", "author": "mla", "description": "To complete the major trinity of combinatorial generation: combinations themselves. Unranking uses the \"Combinatorial Number System\", algorithm from Knuth.\n\n'x' multiplies index by int(iTime), so gives a permutation for times coprime to 2,3,7 and 11.", "tags": ["grid", "combinations"], "likes": 7, "viewed": 397, "published": 3, "date": "1588330608", "time_retrieved": "2024-07-30T21:09:24.856990", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Combinations Grid\n// Matthew Arcus, mla, 2020\n// Show the 792 ways of selecting 5 objects from 12.\n////////////////////////////////////////////////////////////////////////////////\n\nbool alert = false;\nconst int CHAR_X = 88;\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\n// Return true if the kth item is selected in the Nth\n// combination of T items. Algorithm from Knuth, TAOCP,\n// 7.2.1.3, Ex. 17.\nbool unrankcombination(int T, int N, int k) {\n  int t = T, x = 0, x1 = 1, c = t-1;\n  while (x1 <= N) {\n    x = x1; c++; x1 = (c+1)*x1/(c+1-t);\n  }\n  while (c > k) {\n    N = N-x;\n    if (t == 2) return N == k;\n    x = x*t/c; t--; c--;\n    while(x > N) {\n      x = x*(c-t)/c; c--;\n    }\n  }\n  return c == k;\n}\n\nvec3 combinations(vec2 fragCoord) {\n  // 12 choose 5 = 792 = 2*2*2*3*3*11\n  ivec2 pdim = ivec2(iResolution.xy);\n  ivec2 pcoord = ivec2(fragCoord);\n  pcoord.y = pdim.y-1-pcoord.y;\n  vec3 col = vec3(0.2);\n  // Should have W1 choose N = W*H*H1\n  int W = 11, W1 = 12;\n  int H = 9, H1 = 8;\n  int M = 1, N = 5;\n  ivec2 bdim = ivec2(W*(W1+M)+M, H*(H1+M)+M);\n  ivec2 bcoord = pcoord*bdim/pdim;\n  int nwidth = bdim.x; //14*5+15;\n  int nheight = bdim.y; //14*5+15;\n  int i = bcoord.x, j = bcoord.y;\n  int i1 = (i+W1)%(W1+M); // Index within a horizontal block\n  int j1 = (j+H1)%(H1+M);   // Index within a vertical block\n  if (i1 < W1 && j1 < H1) {\n    int index = (i-M)/(W1+M)*(H*H1)+(j-M)/(H1+M)*H1+j1;\n    if (key(CHAR_X)) index = (index*int(iTime))%(W*H*H1);\n    bool p = unrankcombination(N,index,W1-i1-1);\n    if (p) col = vec3(0.8);\n    else col = vec3(0.5);\n  }\n  ivec2 boffset = (bcoord*pdim+bdim-1)/bdim; // Index of 1st pixel in block\n  if (bcoord.x > 0 && j1 < H1 && pcoord.x == boffset.x) col = vec3(0);\n  if (bcoord.y > 0 && i1 < W1 && pcoord.y == boffset.y) col = vec3(0);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = vec4(combinations(fragCoord),1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 328, 328, 388], [390, 520, 565, 565, 827], [829, 829, 864, 902, 1922], [1924, 1924, 1976, 1976, 2025]], "test": "untested"}
{"id": "WdfBD7", "name": "Pencil Sketches", "author": "samhattangady", "description": "Trying to replicate a hand-drawn aesthetic.", "tags": ["handdrawn"], "likes": 10, "viewed": 969, "published": 3, "date": "1588330496", "time_retrieved": "2024-07-30T21:09:25.687769", "image_code": "\n/*\n * 01 May 2020\n * Wanted to try to see if I could replicate some kind of hand drawn aesthetic\n * It looks alright. Definitely doesn't look hand drawn though. Maybe need to\n * make the lines not straight. But it's alright\n */\n\nfloat PI = 3.14159;\n\nvec3 paper_colour = vec3(0.9, 0.9, 0.85);\nvec3 pencil_colour = vec3(0.3, 0.3, 0.40);\nfloat line_thickness = 1.7;\nfloat line_variation = 3.0508;\nfloat line_smoothness = 0.5;\n\nfloat rand(vec2 c) {\n\treturn fract(sin(dot(c.xy ,vec2(12.868,781.233))) * 4378.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 30.3;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat get_noise(vec2 p) {\n    float noise = pNoise(p, 3);\n    noise *= 2.0;\n    // noise -= 0.5;\n    return noise;\n}\n\nfloat rectangle(vec2 samplePosition, vec2 halfSize){\n    vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);\n    return outsideDistance + insideDistance;\n}\n\nvec3 draw_line(vec2 p, vec2 p1, vec2 p2, vec3 current_colour) {\n    float d;\n    float l_sq = pow(distance(p1, p2), 2.0);\n    if (l_sq == 0.0)\n        d = distance(p, p1);\n    else {\n        float t = max(0.0, min(1.0, dot(p - p1, p2 - p1) / l_sq));\n        vec2 projection = p1 + t * (p2 - p1);  // Projection falls on the segment\n        d = distance(p, projection);\n    }\n    float noise;\n    // TODO (01 May 2020 sam): Figure out how to to better line check\n    if (p1.y<p.y) noise = get_noise(p.yx);\n    else noise = get_noise(p);\n    d += noise*line_variation;\n    float pencil = smoothstep(line_thickness, line_thickness+line_smoothness, d);\n    return mix(pencil_colour, current_colour, pencil);\n}\n\nvec3 draw_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour) {\n    vec3 colour = current_colour;\n    vec2 p2 = vec2(p1.x, p3.y);\n    vec2 p4 = vec2(p3.x, p1.y);\n    vec2 box_center = (p1 + p3)/2.0;\n    float bd = rectangle(p-box_center, (p3-p1)/2.0);\n    float noise = get_noise(p);\n    noise *= 5.0;\n    if (bd-noise<0.0)\n        colour = paper_colour;\n    colour = draw_line(p, p1, p2, colour);\n    colour = draw_line(p, p2, p3, colour);\n    colour = draw_line(p, p3, p4, colour);\n    colour = draw_line(p, p4, p1, colour);\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 colour;\n    float WIDTH = iResolution.x;\n\tfloat HEIGHT = iResolution.y;\n\n    vec2 pos = fragCoord;\n    vec2 uv = pos/iResolution.xy;\n    pos.x += (tan(iTime)/100.0)*iResolution.x*20.0;\n    colour = paper_colour;\n    // horizon\n    colour = draw_line(pos, vec2(-50000.0, iResolution.y/3.0), vec2(iResolution.x*5000.0, iResolution.y/3.0), colour);\n    // pillars\n    colour = draw_box(pos, vec2(WIDTH*0.22, HEIGHT*0.41), vec2(WIDTH*0.26, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.30, HEIGHT*0.41), vec2(WIDTH*0.34, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.37, HEIGHT*0.41), vec2(WIDTH*0.41, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.44, HEIGHT*0.41), vec2(WIDTH*0.48, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.51, HEIGHT*0.41), vec2(WIDTH*0.55, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.59, HEIGHT*0.41), vec2(WIDTH*0.63, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.66, HEIGHT*0.41), vec2(WIDTH*0.70, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.74, HEIGHT*0.41), vec2(WIDTH*0.78, HEIGHT*0.59), colour);\n    // base\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.4), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.24, HEIGHT*0.32), vec2(WIDTH*0.76, HEIGHT*0.38), colour);\n    // roof\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.66), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.8, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.8, HEIGHT*0.68), colour);\n    fragColor = vec4(colour, 1.0);\n    float c = get_noise(pos.yx);\n    // fragColor = vec4(vec3(c), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 425, 445, 445, 512], [514, 514, 547, 547, 919], [921, 921, 951, 951, 1242], [1244, 1244, 1269, 1269, 1360], [1362, 1362, 1414, 1414, 1703], [1705, 1705, 1768, 1768, 2410], [2412, 2412, 2474, 2474, 2958], [2960, 2960, 3017, 3017, 4880]], "test": "untested"}
{"id": "WsXBD7", "name": "Shader10_Dela Vega", "author": "zerotojiro", "description": "Sniper scope view with mouse controls\n", "tags": ["midterms"], "likes": 1, "viewed": 312, "published": 3, "date": "1588330186", "time_retrieved": "2024-07-30T21:09:26.497603", "image_code": "float circle(vec2 uv, float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n\n\tvec2 mouse = vec2(iMouse)/vec2(iResolution.xy);\n    vec2 mousePos = vec2(mouse.x * ratio, mouse.y);\n    \n    vec2 floorPos = vec2(.5 * ratio, .1);\n    vec2 bod1Pos = vec2(.25 * ratio, .5);\n    vec2 bod2Pos = vec2(.5 * ratio, .5);\n    vec2 bod3Pos = vec2(.75 * ratio, .5);\n    \n    vec2 h1Pos = vec2(.25 * ratio, .68);\n    vec2 h2Pos = vec2(.5 * ratio, .68);\n    vec2 h3Pos = vec2(.75 * ratio, .68);\n    \n    vec2 bar1Pos = vec2(.25 * ratio, .3);\n    vec2 bar2Pos = vec2(.5 * ratio, .3);\n    vec2 bar3Pos = vec2(.75 * ratio, .3);\n    \n    vec2 base1Pos = vec2(.25 * ratio, .2);\n    vec2 base2Pos = vec2(.5 * ratio, .2);\n    vec2 base3Pos = vec2(.75 * ratio, .2);\n    \n    vec2 s1Pos = vec2(.23 * ratio, .65);\n    vec2 s2Pos = vec2(.5 * ratio, .72);\n    vec2 s3Pos = vec2(.73 * ratio, .55);\n    \n    float scope = circle(uv, .3, .1, mousePos);\n    float yline = rect(uv, mousePos, vec2(.005, .6));\n    float xline = rect(uv, mousePos, vec2(.6, .005));\n    \n    float floor = rect(uv, floorPos, vec2(2., .2));\n    \n    float bod1 = rect (uv, bod1Pos, vec2(.2, .25));\n    float bod2 = rect (uv, bod2Pos, vec2(.2, .25));\n    float bod3 = rect (uv, bod3Pos, vec2(.2, .25));\n    \n    float h1 = circle(uv, .08, .0, h1Pos);\n    float h2 = circle(uv, .08, .0, h2Pos);\n    float h3 = circle(uv, .08, .0, h3Pos);\n    \n    float bar1 = rect(uv, bar1Pos, vec2(.05, .3));\n    float bar2 = rect(uv, bar2Pos, vec2(.05, .3));\n    float bar3 = rect(uv, bar3Pos, vec2(.05, .3));\n    \n    float base1 = rect(uv, base1Pos, vec2(.15, .05));\n    float base2 = rect(uv, base2Pos, vec2(.15, .05));\n    float base3 = rect(uv, base3Pos, vec2(.15, .05));\n    \n    float s1 = circle(uv, .01, .0, s1Pos);\n    float s2 = circle(uv, .01, .0, s2Pos);\n    float s3 = circle(uv, .01, .0, s3Pos);\n    \n    vec3 col = vec3(.2470, .3098, .2431);\n    col = mix(col, vec3(.2294, .1156, .0568), floor);\n    col = mix(col, vec3(.4294, .3156, .2568), bar1);\n    col = mix(col, vec3(.4294, .3156, .2568), bar2);\n    col = mix(col, vec3(.4294, .3156, .2568), bar3);\n    col = mix(col, vec3(.4294, .3156, .2568), base1);\n    col = mix(col, vec3(.4294, .3156, .2568), base2);\n    col = mix(col, vec3(.4294, .3156, .2568), base3);\n    col = mix(vec3(.3882, .3647, .3529), col, h1);\n    col = mix(col, vec3(.3882, .3647, .3529), bod1);\n    col = mix(vec3(.3882, .3647, .3529), col, h2);\n    col = mix(col, vec3(.3882, .3647, .3529), bod2);\n    col = mix(vec3(.3882, .3647, .3529), col, h3);\n    col = mix(col, vec3(.3882, .3647, .3529), bod3);\n    col = mix(vec3(0.), col, s1);\n    col = mix(vec3(0.), col, s2);\n    col = mix(vec3(0.), col, s3);\n    \n    col = mix(col, vec3(0.), yline);\n    col = mix(col, vec3(0.), xline);\n    col = mix(col, vec3(0.), scope);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 180], [182, 182, 225, 225, 384], [386, 386, 443, 443, 3323]], "test": "untested"}
{"id": "3dfBW7", "name": "Shader9_Dela Vega", "author": "zerotojiro", "description": "Turning windmills on a sunny day", "tags": ["midtems"], "likes": 2, "viewed": 299, "published": 3, "date": "1588323980", "time_retrieved": "2024-07-30T21:09:27.329379", "image_code": "float circle(vec2 uv, float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p,a,b);\n    float m = 0.9*smoothstep(.01,.001, d/30.);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 pos1 = vec2(.7 * ratio, .7);\n    vec2 pos2 = vec2(.4 * ratio, .7);\n    vec2 pos3 = vec2(.2 * ratio, .7);\n    \n    vec2 b1Pos = vec2(.7 *ratio, .4);\n    vec2 b2Pos = vec2(.4 *ratio, .4);\n    vec2 b3Pos = vec2(.2 *ratio, .4);\n    \n    vec2 sunPos = vec2(.1, 3.4);\n    \n    float dist = distance(pos1, uv) * 2.0;\n    float dist2 = distance(pos2, uv) * 2.0;\n    float dist3 = distance(pos3, uv) * 2.0;\n    \n    vec2 uv1 = uv;\n    uv1 -= pos1;\n    \n    vec2 uv2 = uv;\n    uv2 -= pos2;\n    \n    vec2 uv3 = uv;\n    uv3 -= pos3;\n    \n    float angle = atan(uv1.y, uv1.x) + iTime;\n    float angle2 = atan(uv2.y, uv2.x) + iTime;\n    float angle3 = atan(uv3.y, uv3.x) + iTime;\n\n    float radius = sin((angle+iTime*3.)*3.);\n    radius *= .6;\n    \n    float radius2 = sin((angle2+iTime*3.)*3.);\n    radius2 *= .45;\n    \n    float radius3 = sin((angle3+iTime*3.)*3.);\n    radius3 *= .3;\n    \n    float value = 1.-smoothstep(radius, radius +.0, dist);\n    float value2 = 1.-smoothstep(radius2, radius2 +.0, dist2);\n    float value3 = 1.-smoothstep(radius3, radius3 +.0, dist3);\n    \n    float cap1 = circle(uv, .04, 0., pos1);\n    float cap2 = circle(uv, .03, 0., pos2);\n    float cap3 = circle(uv, .02, 0., pos3);\n    \n    float back1 = circle(uv, .07, 0., pos1);\n    float back2 = circle(uv, .05, 0., pos2);\n    float back3 = circle(uv, .03, 0., pos3);\n    \n    float bar1 = rect(uv, b1Pos, vec2(.08, .6));\n    float bar2 = rect(uv, b2Pos, vec2(.06, .6));\n    float bar3 = rect(uv, b3Pos, vec2(.04, .6));\n    \n    float m = line(uv,vec2(-.1, .2), vec2(2., -.15));\n    \n    float sun = circle(uv, .5, 3., sunPos);\n    \n    vec3 color = vec3(.7294, .8980, .9686);\n    color = mix(vec3(1., 1., 0.), color, sun);\n    \n    color = mix(color, vec3(.9), bar1);\n    color = mix(vec3(.9), color, back1);\n    color = mix(color, vec3(.7), value);\n    color = mix(vec3(.9), color, cap1);\n    \n    color = mix(color, vec3(.9), bar2);\n    color = mix(vec3(.9), color, back2);\n    color = mix(color, vec3(.7), value2);\n    color = mix(vec3(.9), color, cap2);\n    \n    color = mix(color, vec3(.9), bar3);\n    color = mix(vec3(.9), color, back3);\n    color = mix(color, vec3(.7), value3);\n    color = mix(vec3(.9), color, cap3);\n  \n    color = mix(color, vec3(0., 1., 0.), m);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 180], [182, 182, 225, 225, 384], [386, 386, 425, 425, 543], [545, 545, 580, 580, 676], [678, 678, 735, 785, 3214]], "test": "untested"}
{"id": "tlGXzK", "name": "Shader3_DelaVega", "author": "zerotojiro", "description": "simple radar", "tags": ["midterms"], "likes": 1, "viewed": 324, "published": 3, "date": "1588323861", "time_retrieved": "2024-07-30T21:09:28.251913", "image_code": "float circle(vec2 uv,float radius, vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = step(radius,d);\n    \n    return value; \n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y, uv.y) - step(pos.y + size.y,uv.y);\n}\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p,a,b);\n    float m = .9*smoothstep(.01, .001, d);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\t \n    float ratio = iResolution.x / iResolution.y;\n    \n    //circle position\n    vec2 circlePos = vec2(.5,.5);\n    //rectangular position\n    vec2 rectPos = vec2(.5*ratio,.5);\n    \n    circlePos.x *= ratio;\n    uv.x *= ratio;\n    \n    //circles\n    float value = circle(uv,.49,circlePos);\n    value -= circle(uv, .5,circlePos);\n    \n    float value2 = circle(uv,.34,circlePos);\n    value2 -= circle(uv,.35,circlePos);\n    \n    float value3 = circle(uv,.19,circlePos);\n    value3 -= circle(uv,.20,circlePos);\n\n    float value4 = circle(uv, .015,circlePos);\n    value4 -= circle(uv,.02,circlePos);\n    \n    float value5 = circle(uv, .64,circlePos);\n    value5 -= circle(uv,.65,circlePos);\n    \n    //pings\n    vec2 ping1 = vec2((sin(iTime*.5)*.3 + .5)*ratio, (sin(iTime*.9)*.2+.3)*ratio);\n    vec2 ping2 = vec2((sin(iTime*.3)*.2 + .4)*ratio, (sin(iTime*.5)*.2+.3)*ratio);\n    \n    float dist = distance(uv, ping1);\n    float dist2 = distance(uv, ping2);\n    \n    float t = cos(iTime*2.5)*.1 - .3;\n    float t2 = sin(iTime*2.5)*.1 - .3;\n    \n    vec3 pingOne = vec3(1.-fract(smoothstep(0.2 + t, .25 + t, dist)));\n    vec3 pingTwo = vec3(1.-fract(smoothstep(0.2 + t2, .25 + t2, dist2)));\n    \n    //lines\n    float l = line(uv, vec2(.5*ratio, 0.), vec2(.5*ratio, 1.));\n    l += line(uv, vec2(.14*ratio, .5), vec2(.86*ratio, .5));\n    \n    //rotating bar\n    uv-=rectPos;\n    uv*= rotate2d((iTime)*2.);\n    uv+=rectPos;\n    vec3 rectangle = vec3(rect(uv,rectPos,vec2(.007,.65)));\n    \n    vec3 col = mix(vec3(0.,0.,0.), vec3(0.,1.,0.),value);\n    col = mix(col, vec3(.0, 1. ,.0), l);\n    \n    col += mix(vec3(1.,0.,0.), vec3(0., 0., 0.), pingOne);\n    col += mix(vec3(0.,0.,1.), vec3(0., 0., 0.), pingTwo);\n    \n    col += mix(vec3(0.,0.,0.), vec3(0.,0.8,0.),value2);\n    col += mix(vec3(0.,0.,0.), vec3(0.,0.6,0.),value3);\n    col += mix(vec3(0.,0.,0.), vec3(0.,1.,0.),value4);\n    col += mix(vec3(0.,0.,0.), vec3(0.,1.,0.),value5);\n    \n    col += mix(vec3(0,0,0),vec3(0,0.8,0), rectangle);\n   \n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 144], [146, 146, 174, 174, 241], [243, 243, 286, 286, 431], [433, 433, 472, 472, 590], [592, 592, 627, 627, 719], [721, 721, 778, 778, 2845]], "test": "untested"}
{"id": "3tVSD3", "name": "Shader6_Dela Vega", "author": "zerotojiro", "description": "Solar simulation system with twinkling stars", "tags": ["midterms"], "likes": 1, "viewed": 330, "published": 3, "date": "1588323618", "time_retrieved": "2024-07-30T21:09:29.026841", "image_code": "float circle(vec2 uv, float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    \n    uv.x *= ratio;\n    \n    vec2 center = vec2(.5*ratio, .5);\n    vec2 mercPos = vec2(.5*ratio, .65);\n    vec2 venPos = vec2(.5*ratio, .75);\n    vec2 eartPos = vec2(.5*ratio, .88);\n    vec2 moonPos = vec2(.5*ratio, .95);\n    vec2 marsPos = vec2(.5*ratio, 1.1);\n    vec2 starPos1 = vec2(.35*ratio,.65);\n    vec2 starPos2 = vec2(.15*ratio,.45);\n    vec2 starPos3 = vec2(.5*ratio,.2);\n    vec2 starPos4 = vec2(.7*ratio,.8);\n    vec2 starPos5 = vec2(.9*ratio,.3);\n    \n    vec2 uv1 = uv;\n    vec2 uv2 = uv;\n    vec2 uv3 = uv;\n    vec2 uv5 = uv;\n    \n    float sun = circle(uv, .08, .04, center);\n    float star = circle(uv,.0015*(sin(iTime*5.)+0.5),0.005, starPos1);\n    float star2 = circle(uv,.0015*(sin(iTime*7.)+0.5),0.005, starPos2);\n    float star3 = circle(uv,.0015*(sin(iTime*6.)+0.5),0.005, starPos3);\n    float star4 = circle(uv,.0015*(sin(iTime*8.)+0.5),0.005, starPos4);\n    float star5 = circle(uv,.0015*(sin(iTime*9.)+0.5),0.005, starPos5);\n    \n    uv1 -= center;\n    uv1 *= rotate2d((iTime)*2.);\n    uv1 += center;\n    \n    uv2 -= center;\n    uv2 *= rotate2d((iTime)*1.5);\n    uv2 += center;\n    \n    uv3 -= center;\n    uv3 *= rotate2d((iTime)*1.);\n    uv3 += center;\n    \n    vec2 uv4 = uv3;\n    \n    uv5 -= center;\n    uv5 *= rotate2d((iTime)*1.2);\n    uv5 += center;\n    \n    uv4 -= eartPos;\n    uv4 *= rotate2d((iTime)*3.);\n    uv4 += eartPos;\n\n    \n    float merc = circle(uv1, .008, .01, mercPos);\n    float ven = circle(uv2, .015, .01, venPos);\n    float earth = circle(uv3, .03, .01, eartPos);\n    float moon = circle(uv4, .001, .01, moonPos);\n    float mars = circle(uv5, .035, .01, marsPos);\n    \n    vec3 col = mix(vec3(1., 1., 0.), vec3(0.), sun);\n    col += mix(vec3(1.,1.,1.),vec3(0,0,0),star);\n    col += mix(vec3(1.,1.,1.),vec3(0,0,0),star2);\n    col += mix(vec3(1.,1.,1.),vec3(0,0,0),star3);\n    col += mix(vec3(1.,1.,1.),vec3(0,0,0),star4);\n    col += mix(vec3(1.,1.,1.),vec3(0,0,0),star5);\n    col = mix(vec3(.949, .7176, .5529), col, merc);\n    col = mix(vec3(.949, .5529, .6235), col, ven);\n    col = mix(vec3(0., .0, 1.), col, earth);\n    col = mix(vec3(.9), col, moon);\n    col = mix(vec3(1., 0., 0.), col, mars);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 180], [182, 182, 210, 210, 277], [279, 279, 336, 386, 2683]], "test": "untested"}
{"id": "3lKSD3", "name": "Shader5_Dela Vega", "author": "zerotojiro", "description": "Clock", "tags": ["midterms"], "likes": 0, "viewed": 311, "published": 3, "date": "1588323614", "time_retrieved": "2024-07-30T21:09:29.937406", "image_code": "float circle(vec2 uv,float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p,a,b);\n    float m = .9*smoothstep(.01, .00001, d);\n    \n    return m;\n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y,uv.y) - step(pos.y + size.y,uv.y);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 center = vec2(.5*ratio, .5);\n    \n    float border = circle(uv,.45, 0., center);\n    border -= circle(uv, .5, 0., center);\n    \n    float blank = circle(uv,.38, 0., center);\n    blank -= circle(uv, .45, 0., center);\n    \n    float middle = circle(uv,.02, 0., center);\n    \n    vec2 uvMin = uv;\n    vec2 uvHour = uv;\n    \n    uvMin -= center;\n    uvMin *= rotate2d((iTime)*1.2);\n    uvMin += center;\n    \n    uvHour -= center;\n    uvHour *= rotate2d((iTime)*.1);\n    uvHour += center;\n    \n    float minHand = rect(uvMin, center,vec2(.02,.4));\n    float hourHand = rect(uvHour, center,vec2(.02,.25));\n    \n    //lines\n    float l = line(uv, vec2(.5*ratio, 0.), vec2(.5*ratio, 1.));\n    l += line(uv, vec2(0.*ratio, .5), vec2(1.*ratio, .5));\n    l += line(uv, vec2(.35*ratio, 0.), vec2(.65*ratio, 1.));\n    l += line(uv, vec2(.05*ratio, 0.), vec2(.95*ratio, 1.));\n    l += line(uv, vec2(.05*ratio, 1.), vec2(.95*ratio, 0.));\n    l += line(uv, vec2(.35*ratio, 1.), vec2(.65*ratio, 0.));\n    \n    vec3 col = mix(vec3(1.), vec3(0.), l);\n    col = mix(vec3(1.), col, blank);\n    col = mix(col, vec3(0.), minHand);\n    col = mix(col, vec3(0.), hourHand);\n    col = mix(vec3(0.), col, middle);\n    col = mix(col, vec3(0.), border);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 179], [181, 181, 220, 220, 338], [340, 340, 375, 375, 469], [471, 471, 514, 514, 658], [660, 660, 688, 688, 755], [757, 757, 814, 864, 2263]], "test": "untested"}
{"id": "3lyXWV", "name": "Shader4_DelaVega", "author": "zerotojiro", "description": "Waterwheel in the night", "tags": ["midterms"], "likes": 1, "viewed": 299, "published": 3, "date": "1588323611", "time_retrieved": "2024-07-30T21:09:30.751230", "image_code": "vec3 waves(vec2 uv, vec3 color)\n{\n    // To create the waves\n\tfloat wave_width;\n\tuv  = -.2 + 5.0 * uv;\n\tuv.y += 0.0;\n\tfor(float i = .0; i < 15.; i++) {\n\t\t\n\t\tuv.y += (.07 * sin(uv.x + i/2.0 + iTime ));\n\t\twave_width = abs(1. / (150.0 * uv.y));\n\t\tcolor += vec3(wave_width * 1.9, wave_width, wave_width * 1.5);\n\t}\n    \n    return color;\n}\n\nfloat circle(vec2 uv,float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    uv.x *= ratio;\n    \n    vec2 moonPos = vec2(.2*ratio, .7);\n    vec2 landPos = vec2(.5*ratio, .1);\n    vec2 wheelPos = vec2(.7*ratio, .35);\n    vec2 supportPos = vec2(.7*ratio, .25);\n        \n    float moon = circle(uv, .15, .05, moonPos);\n   \tfloat land = rect(uv, landPos, vec2(2., .1));\n    float support = rect(uv, supportPos, vec2(.1, .3));\n    \n    vec3 water = waves(uv, vec3(-.05));\n    \n    //wheel\n    uv-=wheelPos;\n    uv*= rotate2d((iTime)*2.);\n    uv+=wheelPos;\n    \n    float wheel = circle(uv,.3, 0., wheelPos);\n    wheel -= circle(uv, .35, 0., wheelPos);\n    \n    //woodenbars\n    float bar1 = rect(uv, wheelPos, vec2(.05, .8));\n    float bar2 = rect(uv, wheelPos, vec2(.8, .05));\n    float bolt = rect(uv, wheelPos, vec2(.05, .05));\n    \n\tvec3 col = mix(vec3(.0627, .0823, .2), vec3(.4), support);\n    col = mix(col, vec3(.4196, .1903, 0.), land);\n    col = mix(col, vec3(.2784, .1882, .1176), wheel);\n    col = mix(col, vec3(.2784, .1882, .1176), bar1);\n    col = mix(col, vec3(.2784, .1882, .1176), bar2);\n    col = mix(col, vec3(.1), bolt);\n    col = mix(col, vec3(0., 0., 1.), water);\n    col = mix(vec3(.9764, 1., .7607), col, moon);\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 60, 334], [336, 336, 395, 395, 515], [517, 517, 560, 560, 719], [721, 721, 749, 749, 816], [818, 818, 875, 875, 2159]], "test": "untested"}
{"id": "wlKXzd", "name": "Shader2_DelaVega", "author": "zerotojiro", "description": "Waving swedish flag", "tags": ["midterms"], "likes": 1, "viewed": 291, "published": 3, "date": "1588323531", "time_retrieved": "2024-07-30T21:09:31.546105", "image_code": "float rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nvec2 hash( vec2 p ) {                       \n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p,a,b);\n    float m = 0.9*smoothstep(.02,.01, d);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n    uv.x *= ratio;\n    \n    uv.y+=noise((uv*.5) + iTime)*.1;\n    uv.x+=noise((uv*.3) + iTime)*.3;\n    \n    vec2 basePos = vec2(.5*ratio, .5);\n    vec2 rect1Pos = vec2(.38*ratio, .5);\n    vec2 rect2Pos = vec2(.5*ratio, .5);\n    \n    vec3 base = vec3(rect(uv, basePos, vec2(1.4, .8)));\n    vec3 rect1 = vec3(rect(uv, rect1Pos, vec2(.15, .8)));\n    vec3 rect2 = vec3(rect(uv, rect2Pos, vec2(1.4, .15 )));\n    float m = line(uv,vec2(-.1,-.1),vec2(.25,.15));\n    m += line(uv,vec2(-.1,1.1),vec2(.25,.85));\n\n    vec3 col = vec3(.0941, .1725, .3215);\n    col = mix(col, vec3(1.0), m);\n    col = mix(col, vec3(0., .2941, .5294), base);\n    col = mix(col, vec3(1.0, 0.8196, 0.), rect1);\n    col = mix(col, vec3(1.0, 0.8196, 0.), rect2);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 202], [204, 204, 225, 225, 385], [387, 387, 413, 413, 784], [787, 787, 826, 826, 944], [946, 946, 981, 981, 1072], [1074, 1074, 1131, 1181, 2066]], "test": "untested"}
{"id": "tlGXzV", "name": "Shader1_Dela Vega", "author": "zerotojiro", "description": "rotating Lightsaber", "tags": ["midterms"], "likes": 4, "viewed": 355, "published": 3, "date": "1588323518", "time_retrieved": "2024-07-30T21:09:32.393839", "image_code": "mat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nfloat rect (vec2 uv, vec2 pos, float blurVal, vec2 size)\n{\n\tfloat value = smoothstep(pos.x - size.x/2., (pos.x - size.x/2.) + blurVal, uv.x) \n        \t\t- smoothstep(pos.x + size.x/2., (pos.x + size.x/2.) + blurVal,uv.x);\n    \n    return value *= smoothstep(pos.y, pos.y + blurVal, uv.y) \n        \t\t  - smoothstep(pos.y + size.y, (pos.y+size.y) + blurVal, uv.y);\n}\n\nfloat circle(vec2 uv,float radius, vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = step(radius,d);\n    \n    return value; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    \n   \tvec2 bladePos = vec2(.495*ratio,.48);\n    vec2 handlePos = vec2(.499*ratio,.34);\n    vec2 shinePos = vec2(.494*ratio,.48);\n    vec2 circlePos = vec2(.499*ratio,.44);\n    vec2 hiltPos = vec2(.5*ratio,.48);\n    vec2 bottomPos = vec2(.5*ratio,.34);\n    \n    uv.x *= ratio;\n    \n    uv-=bladePos;\n    uv*= rotate2d(sin(iTime)*5.);\n    uv+=bladePos;\n    \n    vec3 blade = vec3(rect(uv, bladePos, 0.02, vec2(.029, 0.7)));\n    vec3 handle = vec3(rect(uv, handlePos, 0.0, vec2(.029, 0.15)));\n    vec3 shine = vec3(rect(uv, shinePos, 0.02, vec2(.01, 0.7)));\n    float button = circle(uv, 0.01, circlePos);\n    vec3 hilt = vec3(rect(uv, hiltPos, 0.0, vec2(.05, .015)));\n    vec3 bottom = vec3(rect(uv, bottomPos, 0.0, vec2(.05, .015)));\n    \n    vec3 col = mix(vec3(.0), vec3(0., 0., 1.), blade);\n    col = mix(col, vec3(1., 1., 1.), shine);\n    col += mix(col, vec3(.3), handle);\n    col += mix(col, vec3(.0), button);\n    col = mix(col, vec3(.2), hilt);\n    col = mix(col, vec3(.2), bottom);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 95], [97, 97, 155, 155, 460], [462, 462, 508, 508, 606], [608, 608, 665, 715, 1854]], "test": "untested"}
{"id": "WssBW4", "name": "Shader7_Dela Vega", "author": "zerotojiro", "description": "Electric fan", "tags": ["midterms"], "likes": 2, "viewed": 287, "published": 3, "date": "1588323182", "time_retrieved": "2024-07-30T21:09:33.145828", "image_code": "float circle(vec2 uv,float radius, float blur,  vec2 pos)\n{\n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2(.5 * ratio, .7);\n    vec2 barPos = vec2(.5 * ratio, .3);\n    vec2 b1Pos = vec2(.5 * ratio, .15);\n    vec2 b2Pos = vec2(.5 * ratio, .21);\n    vec2 b3Pos = vec2(.5 * ratio, .27);\n\n    float dist = distance(shapePos, uv) * 2.0;\n    \n    vec2 uv1 = uv;\n    uv1 -= shapePos;\n    \n    float angle = atan(uv1.y, uv1.x) + iTime;\n    \n    float ring = circle(uv,.33, 0., shapePos);\n    ring -= circle(uv, .35, 0., shapePos);\n    \n    float back = circle(uv, .1, 0., shapePos);\n    float plug = circle(uv, .05, 0., shapePos);\n    float bar = rect(uv, barPos, vec2(.13, .7));\n    float b1 = rect(uv, b1Pos, vec2(.04, .04));\n    float b2 = rect(uv, b2Pos, vec2(.04, .04));\n    float b3 = rect(uv, b3Pos, vec2(.04, .04));\n\n    float radius = sin((angle + iTime * 12.)*3.);\n    radius *= .6;\n    \n    float value = 1.-smoothstep(radius, radius +.1, dist);\n    \n    vec3 color = mix(vec3(.1), vec3(1.), back);\n    color = mix(color, vec3(.1), bar);\n    color = mix(color, vec3(1.), b1);\n    color = mix(color, vec3(1.), b2);\n    color = mix(color, vec3(1.), b3);\n    color = mix(color, vec3(.2), value);\n    color = mix( vec3(.1), color, plug);\n    color = mix(color, vec3(.2), ring);\n    \n    // Output to screen\n    fragColor = vec4(color*2.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 173], [175, 175, 218, 218, 377], [379, 379, 436, 486, 1857]], "test": "untested"}
{"id": "3sXBW7", "name": "Shader8_Dela Vega", "author": "zerotojiro", "description": "Propeller Airplane", "tags": ["midterms"], "likes": 1, "viewed": 289, "published": 3, "date": "1588323174", "time_retrieved": "2024-07-30T21:09:33.964639", "image_code": "float circle(vec2 uv, float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2(.5 * ratio, .5);\n    vec2 wingPos = vec2(.5 * ratio, .4);\n\tvec2 windowPos = vec2(.5 * ratio, .6);\n    vec2 finPos = vec2(.5 * ratio, .7 );\n    \n    float dist = distance(shapePos, uv) * 2.0;\n    \n    vec2 uv1 = uv;\n    uv1 -= shapePos;\n    \n    float angle = atan(uv1.y, uv1.x) + iTime;\n    \n    float back = circle(uv, .23, 0., shapePos);\n    float cap  = circle(uv, .06, 0., shapePos);\n    float window = circle(uv, .18, 0., windowPos);\n    \n    float wings = rect(uv, wingPos, vec2(1.3, .15));\n    float fin = rect(uv, finPos, vec2(.07, .3));\n\n    float radius = sin((angle+iTime*10.)*4.);\n\n    radius *= .6;\n    \n    float value = 1.-smoothstep(radius, radius +.1, dist);\n    \n    vec3 color;\n    color = mix(vec3(.5058, .7686, .9411), vec3(.5215, .0705, .0705),fin);\n    color = mix(vec3(.6509, .9686, .9686), color,  window);\n    color = mix(vec3(.5215, .0705, .0705), color, back);\n    color = mix(color, vec3(.5215, .0705, .0705), wings);\n    color = mix(color, vec3(.2), value);\n    color = mix(vec3(.9), color, cap);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 180], [182, 182, 225, 225, 384], [386, 386, 443, 493, 1718]], "test": "untested"}
