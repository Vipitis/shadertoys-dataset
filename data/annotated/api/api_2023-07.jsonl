{"id": "cllcDM", "name": "N-dimensional Pulsar", "author": "Ares_ekb", "description": "Some cosmic smoke", "tags": ["smoke"], "likes": 0, "viewed": 168, "published": 3, "date": "1690824803", "time_retrieved": "2024-07-30T17:41:30.974281", "image_code": "#define PI 3.14159265359\n#define RANDOM_DETAILS 20.0\n#define SMOKE_WAVES 8\n#define SMOKE_RADIUS 1.0\n#define SMOKE_EDGE_BRIGHTNESS 0.0\n#define SMOKE_CENTER_BRIGHTNESS 0.0\n#define SMOKE_PULSATION 1.2\n#define SMOKE_STABILITY 10.0\n\nfloat random(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat blured_random(vec2 uv, float scale) {\n    vec2 uv2 = fract(uv * scale);\n    float d1 = random(floor(uv * scale));\n    float d2 = random(floor(uv * scale + vec2(1.0, 0.0)));\n    float d3 = random(floor(uv * scale + vec2(0.0, 1.0)));\n    float d4 = random(floor(uv * scale + vec2(1.0, 1.0)));\n    d1 = mix(d1, d3, uv2.y);\n    d2 = mix(d2, d4, uv2.y);\n    return mix(d1, d2, uv2.x);\n}\n\nfloat layered_random(vec2 uv, float scale) {\n    float d = blured_random(uv, scale);\n    d += blured_random(uv, scale * 2.0) * 0.5;\n    d += blured_random(uv, scale * 4.0) * 0.25;\n    d += blured_random(uv, scale * 8.0) * 0.125;\n    d += blured_random(uv, scale * 16.0) * 0.0625;\n    return d / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\n    // Random circle in the center\n    float d = layered_random(uv, RANDOM_DETAILS)\n            * smoothstep(0.0, 0.3, +0.4 - length(uv));\n\n    for (int i = 0; i < SMOKE_WAVES; i++) {\n        // Add smoke wave\n        float time = iTime + SMOKE_PULSATION * 2.0 * PI * float(i) / float(SMOKE_WAVES);\n        float scale = RANDOM_DETAILS - abs(sin(time / 2.0)) * SMOKE_STABILITY;\n        float d2 = layered_random(uv, scale)\n                 * smoothstep(SMOKE_RADIUS, SMOKE_EDGE_BRIGHTNESS, length(uv))\n                 * smoothstep(-SMOKE_CENTER_BRIGHTNESS, SMOKE_RADIUS, length(uv))\n                 * sin(time);\n        d += smoothstep(0.0, 0.5, d2);\n        // Add rays\n        d *= abs(sin(iTime / 3.0 + 1.5 * uv.x / uv.y))\n           * abs(sin(iTime / 5.0 + 0.5 * uv.y / uv.x));\n    }\n\n    fragColor = vec4(d, d, d, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 251, 251, 324], [326, 326, 369, 369, 713], [715, 715, 759, 759, 1016], [1018, 1018, 1073, 1073, 1972]], "test": "untested"}
{"id": "mlfcW7", "name": "animation n2", "author": "jorge2017a2", "description": "animation n2", "tags": ["2d", "bezier", "animation", "draw"], "likes": 19, "viewed": 207, "published": 3, "date": "1690816333", "time_retrieved": "2024-07-30T17:41:32.004527", "image_code": "///---jorge2017a2\n//31-jul-2023-\n//animation n2\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(7.0*antialiasing(1.0),b,d)\n#define PI 3.141516\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n\nvec3 lineah(vec2 p, float posy, vec3 colOut)\n{\nfloat s1;\ns1=p.x+0.001;\nfloat d1=abs(p.y-posy);\nvec3 col= DrawFigBorde(vec3(0.0,1.0,0.0), colOut, d1);\nreturn col;\n}\n\nvec3 lineav(vec2 p, float posx, vec3 colOut)\n{\nfloat s1;\ns1=p.y+0.001;\nfloat d1=abs(p.x-posx);\nvec3 col= DrawFigBorde(vec3(0.0), colOut, d1);\nreturn col;\n}\n\n\nfloat N21(vec2 p)\n{ return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);}\n\n\n\nvec3 OrejaBz(vec2 p, vec3 col)\n{\nvec2 pc1p1=vec2(9.430,2.810);\nvec2 pc1p2=vec2(9.480,3.110);\nvec2 pc1p3=vec2(9.600,2.920);    \n\nvec2 pc2p1=vec2(9.820,2.820);\nvec2 pc2p2=vec2(9.870,3.000);\nvec2 pc2p3=vec2(9.990,2.910);\n\nfloat b1= sdBezier(p, pc1p1,pc1p2,pc1p3);\nfloat b2= sdBezier(p, pc2p1,pc2p2,pc2p3);\n\ncol= DrawFigBorde(vec3(0.0),col,b1);\ncol= DrawFigBorde(vec3(0.0),col,b2);\n\nreturn col;\n}\n\n\nvec3 cerBz(vec2 p, vec3 col)\n{\nvec2 pc3p1=vec2(9.440,2.450);\nvec2 pc3p2=vec2(9.490,2.550);\nvec2 pc3p3=vec2(9.650,2.450);\n\nvec2 pc4p1=vec2(9.920,2.470);\nvec2 pc4p2=vec2(9.940,2.550);\nvec2 pc4p3=vec2(10.000,2.590);\n\nvec2 pc5p1=vec2(9.760,2.180);\nvec2 pc5p2=vec2(9.890,2.240);\nvec2 pc5p3=vec2(10.110,2.270);\n\nvec2 pc6p1=vec2(9.410,1.660);\nvec2 pc6p2=vec2(9.600,1.900);\nvec2 pc6p3=vec2(9.460,2.060);\n\nvec2 pc7p1=vec2(10.090,1.770);\nvec2 pc7p2=vec2(9.670,1.930);\nvec2 pc7p3=vec2(9.440,1.730);\n\nfloat d3= sdBezier(p,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(p,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(p,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(p,pc6p1,pc6p2,pc6p3);\nfloat d7= sdBezier(p,pc7p1,pc7p2,pc7p3);\n\ncol= DrawFigBorde(vec3(0.0),col,d3);\ncol= DrawFigBorde(vec3(0.0),col,d4);\ncol= DrawFigBorde(vec3(0.0),col,d5);\ncol= DrawFigBorde(vec3(0.0),col,d6);\ncol= DrawFigBorde(vec3(0.0),col,d7);\nreturn col;\n}\n\n\nvec3 patasCer00(vec2 p, vec3 col)\n{\nvec2 pc8p1=vec2(8.980,1.450);\nvec2 pc8p2=vec2(8.970,1.250);\nvec2 pc8p3=vec2(9.010,1.110);\n\nvec2 pc9p1=vec2(8.190,1.530);\nvec2 pc9p2=vec2(8.190,1.440);\nvec2 pc9p3=vec2(8.160,1.410);\n\nvec2 pc10p1=vec2(7.950,1.620);\nvec2 pc10p2=vec2(7.770,1.410);\nvec2 pc10p3=vec2(7.790,1.250);\n\nvec2 pc11p1=vec2(9.250,1.550);\nvec2 pc11p2=vec2(9.310,1.420);\nvec2 pc11p3=vec2(9.280,1.320);\n\n\nfloat d8= sdBezier(p,pc8p1,pc8p2,pc8p3);\nfloat d9= sdBezier(p,pc9p1,pc9p2,pc9p3);\nfloat d10=sdBezier(p,pc10p1,pc10p2,pc10p3);\nfloat d11=sdBezier(p,pc11p1,pc11p2,pc11p3);\n\ncol= DrawFigBorde(vec3(0.0),col,d8);\ncol= DrawFigBorde(vec3(0.0),col,d9);\ncol= DrawFigBorde(vec3(0.0),col,d10);\ncol= DrawFigBorde(vec3(0.0),col,d11);\n\n\nreturn col;\n}\n\nvec3 cerdito(vec2 p, vec3 col)\n{\nvec2 p1=vec2(8.53,2.21);\nvec2 med1=vec2(0.95,0.75);\nfloat d1=sdEllipse(p-p1,med1);\n\n\nvec2 p2=vec2(8.53,2.18);\nvec2 med2=vec2(1,0.75);\n\nfloat ang = 5.0 * PI / 180.0;\n\nvec2 pr = Rotate(p-p2, med2, ang);\nfloat d2  = sdEllipse(pr, med2);\n\nfloat dfin=min(d1,d2);\n\n\nvec2 p3=vec2(9.55,2.22);\nvec2 med3=vec2(0.55,0.59);\nfloat d3=sdEllipse(p-p3,med3);\n\nvec2 p4=vec2(9.83,2.24);\nvec2 med4=vec2(0.3,0.54);\nfloat d4=sdEllipse(p-p4,med4);\nd3=min(d3,d4);\n\nvec2 p5=vec2(9.68,2.21);\nvec2 med5=vec2(0.45,0.59);\nfloat d5=sdEllipse(p-p5,med5);\nd3=min(d3,d5);\n\nvec2 p6=vec2(10.2,2.01);\nvec2 med6=vec2(0.26,0.25);\nfloat d6=sdEllipse(p-p6,med6);\n\nvec2 p7=vec2(9.97,2.32);\nvec2 med7=vec2(0.06,0.08);\nfloat d7=sdEllipse(p-p7,med7);\n\n\nvec2 p8=vec2(9.63,2.23);\nvec2 med8=vec2(0.06,0.08);\nfloat d8=sdEllipse(p-p8,med8);\n\nvec2 p9=vec2(10.08,1.99);\nvec2 med9=vec2(0.02,0.07);\n//rotar\nang = 10.0 * PI / 180.;\npr = Rotate(p-p9, med9, ang);\nfloat d9  = sdEllipse(pr, med9);\n\nvec2 p10=vec2(10.34,2.03);\nvec2 med10=vec2(0.02,0.07);\nfloat d10=sdEllipse(p-p10,med10);\n ang = -10.0 * PI / 180.0;\n pr = Rotate(p-p10, med10, ang);\nd10  = sdEllipse(pr, med10);\n\n\nvec2 p11=vec2(9.64,2.06);\nvec2 med11=vec2(0.02,0.07);\nang = 10. * PI / 180.0;\nvec2 med=vec2(0.02, 0.07);\npr = Rotate(p-p11, med11, ang);\nfloat d11  = sdEllipse(pr, med);\n\n\n//pies\nvec2 p12=vec2(9.06,1);\nvec2 med12=vec2(0.22,0.07);\nfloat d12=sdEllipse(p-p12,med12);\n\n\nvec2 p13=vec2(9.39,1.23);\nvec2 med13=vec2(0.25,0.07);\nfloat d13=sdEllipse(p-p13,med13);\n\n\nvec2 p14=vec2(8.14,1.33);\nvec2 med14=vec2(0.25,0.07);\nfloat d14=sdEllipse(p-p14,med14);\n\nvec2 p15=vec2(7.75,1.14);\nvec2 med15=vec2(0.25,0.07);\nfloat d15=sdEllipse(p-p15,med15);\n\n    col= DrawFigBorde(vec3(1.0), col, dfin);\n    col= DrawFigBorde(vec3(1.0), col, d3);\n    col= DrawFigBorde(vec3(1.0), col, d6);\n    col= DrawFigBorde(vec3(0.0), col, d7);\n    col= DrawFigBorde(vec3(0.0), col, d8);\n    col= DrawFigBorde(vec3(0.0), col, d9);\n    col= DrawFigBorde(vec3(0.0), col, d10);\n    col= DrawFigBorde(vec3(0.0), col, d11);\n    col= DrawFigBorde(vec3(1.0), col, d12);\n    col= DrawFigBorde(vec3(1.0), col, d13);\n    col= DrawFigBorde(vec3(1.0), col, d14);\n    col= DrawFigBorde(vec3(1.0), col, d15);\n    col= OrejaBz(p,col);\n    col=cerBz(p,col);\n    col=patasCer00(p,col);\n    return col;\n}\n\n\nvec3 vallasInc(vec2 p, vec3 col)\n{\nvec2 pos=vec2(3.03,2.89);\nvec2 med=vec2(0.12,0.855);\nfloat d7= sdBox(p-pos, med );\n\nfloat ang = -45.0 * PI / 180.0;\nvec2 pr =Rotate(p- pos, med/2.0, ang);\n\nd7 = sdBox(pr, med);\n\n//poste centro\n pos=vec2(3.82,1.62);\n med=vec2(0.25,0.925);\nfloat d1= sdBox(p-pos, med );\n//elipse centro\nvec2 p2=vec2(3.8,2.61);\nvec2 med2=vec2(0.27,0.11);\nfloat d2=sdEllipse(p-p2,med2);\n\nd7=differenceSDF(d7,d1);\nd7=differenceSDF(d7,d2);\n\n pos=vec2(3.06,1.74);\n med=vec2(0.12,0.855);\nfloat d8= sdBox(p-pos, med );\nang = -45.0 * PI / 180.0;\npr = Rotate(p- pos, med/ 2.0, ang);\nd8 = sdBox(pr, med);\n\nd8=differenceSDF(d8,d1);\n\n//poste 1\n pos=vec2(5.9,-0.17);\n med=vec2(0.345,1.03);\nfloat d5= sdBox(p-pos, med );\n//elipse poste 1\nvec2 p6=vec2(5.86,0.95);\nvec2 med6=vec2(0.44,0.11);\nfloat d6=sdEllipse(p-p6,med6);\n\npos=vec2(4.39,1.37);\nmed=vec2(0.12,1.18);\nfloat d9= sdBox(p-pos, med );\nang = -45.0 * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\n\nd9 = sdBox(pr, med);\nd9=differenceSDF(d9,d5);\nd9=differenceSDF(d9,d6);\n\npos=vec2(4.4,0.19);\nmed=vec2(0.12,1.18);\nfloat d10= sdBox(p-pos, med );\nang = -45.0 * PI / 180.0;\npr = Rotate(p-pos, med/ 2.0, ang);\n\nd10 = sdBox(pr, med);\nd10=differenceSDF(d10,d5);\ncol = DrawFigBorde(vec3(0.75),col,d7);\ncol = DrawFigBorde(vec3(0.75),col,d8);\ncol = DrawFigBorde(vec3(0.67),col,d9);\ncol = DrawFigBorde(vec3(0.67), col, d10);\n    return col;\n}\n\nvec3 vallas(vec2 p, vec3 col)\n{    \nvec2 pos=vec2(3.82,1.62);\nvec2 med=vec2(0.25,0.925);\nfloat d1= sdBox(p-pos, med );\n\n\nvec2 p2=vec2(3.8,2.61);\nvec2 med2=vec2(0.27,0.11);\nfloat d2=sdEllipse(p-p2,med2);\n\nvec2 p3=vec2(2.63,3.99);\nvec2 med3=vec2(0.27,0.11);\nfloat d3=sdEllipse(p-p3,med3);\n\npos=vec2(2.70,2.86);\nmed=vec2(0.25,1.03);\nfloat d4= sdBox(p-pos, med );\n\n\npos=vec2(5.9,-0.17);\nmed=vec2(0.345,1.03);\nfloat d5= sdBox(p-pos, med );\n\nvec2 p6=vec2(5.86,0.95);\nvec2 med6=vec2(0.44,0.11);\nfloat d6=sdEllipse(p-p6,med6);\n\ncol= DrawFigBorde(vec3(0.70),col,d1);\ncol= DrawFigBorde(vec3(0.45),col,d2);\ncol= DrawFigBorde(vec3(0.45),col,d3);\ncol= DrawFigBorde(vec3(0.75),col,d4);\ncol= DrawFigBorde(vec3(0.75),col,d5);\ncol= DrawFigBorde(vec3(0.45),col,d6);\nreturn col;\n}\n\nvec3 cerBz02(vec2 p, vec3 col)\n{\nvec2 pc1p1=vec2(8.240,2.220);\nvec2 pc1p2=vec2(8.490,2.040);\nvec2 pc1p3=vec2(8.620,2.150);\n\nvec2 pc2p1=vec2(8.340,3.070);\nvec2 pc2p2=vec2(8.640,3.050);\nvec2 pc2p3=vec2(8.650,2.830);\n\nvec2 pc3p1=vec2(10.000,2.940);\nvec2 pc3p2=vec2(9.960,3.130);\nvec2 pc3p3=vec2(10.150,3.220);\n\nvec2 pc4p1=vec2(10.290,2.980);\nvec2 pc4p2=vec2(10.300,3.150);\nvec2 pc4p3=vec2(10.520,3.210);\n\nvec2 pc5p1=vec2(10.130,2.540);\nvec2 pc5p2=vec2(10.040,2.810);\nvec2 pc5p3=vec2(10.260,2.690);\n\nvec2 pc6p1=vec2(10.510,2.680);\nvec2 pc6p2=vec2(10.460,2.830);\nvec2 pc6p3=vec2(10.550,2.840);\n\nvec2 pc7p1=vec2(10.320,2.240);\nvec2 pc7p2=vec2(10.510,2.400);\nvec2 pc7p3=vec2(10.650,2.380);\n\nvec2 pc8p1=vec2(10.370,1.930);\nvec2 pc8p2=vec2(10.610,1.800);\nvec2 pc8p3=vec2(10.800,1.940);\n\nvec2 pc9p1=vec2(10.290,1.740);\nvec2 pc9p2=vec2(10.360,1.620);\nvec2 pc9p3=vec2(10.260,1.450);\n\nvec2 pc10p1=vec2(9.820,1.310);\nvec2 pc10p2=vec2(9.980,1.510);\nvec2 pc10p3=vec2(9.840,1.640);\nfloat d1= sdBezier(p,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(p,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(p,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(p,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(p,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(p,pc6p1,pc6p2,pc6p3);\nfloat d7= sdBezier(p,pc7p1,pc7p2,pc7p3);\nfloat d8= sdBezier(p,pc8p1,pc8p2,pc8p3);\nfloat d9= sdBezier(p,pc9p1,pc9p2,pc9p3);\nfloat d10= sdBezier(p,pc10p1,pc10p2,pc10p3);\ncol=DrawFigBorde(vec3(0.0),col,d1);\ncol=DrawFigBorde(vec3(0.0),col,d2);\ncol=DrawFigBorde(vec3(0.0),col,d3);\ncol=DrawFigBorde(vec3(0.0),col,d4);\ncol=DrawFigBorde(vec3(0.0),col,d5);\ncol=DrawFigBorde(vec3(0.0),col,d6);\ncol=DrawFigBorde(vec3(0.0),col,d7);\ncol=DrawFigBorde(vec3(0.0),col,d8);\ncol=DrawFigBorde(vec3(0.0),col,d9);\ncol=DrawFigBorde(vec3(0.0),col,d10);\n    return col;\n}\n\n\nvec3 cerdito02(vec2 p, vec3 col)\n{\nfloat ang;\nvec2 pr;\n\nvec2 pos=vec2(9.38,2.35);\nvec2 med=vec2(0.85,0.75);\nfloat d1=sdEllipse(p-pos,med);\n\n pos=vec2(9.54,2.32);\n med=vec2(0.85,0.75);\nfloat d2=sdEllipse(p-pos,med);\nd2=min(d1,d2);\ncol = DrawFigBorde(vec3(1.0), col, d2);\n\n\n pos=vec2(10.2,2.34);\n med=vec2(0.55,0.64);\nfloat d3=sdEllipse(p-pos,med);\n\n//cabeza\npos=vec2(10.6,2.1);\nmed=vec2(0.35,0.25);\nfloat d4=sdEllipse(p-pos,med);\nd4=min(d4,d3);\ncol = DrawFigBorde(vec3(1.0), col, d4);\n\n\n//nariz\npos=vec2(10.85,2.19);\nmed=vec2(0.23,0.24);\nfloat d5=sdEllipse(p-pos,med);\ncol = DrawFigBorde(vec3(1.0), col, d5);\n\n//ojo\npos=vec2(10.29,2.42);\nmed=vec2(0.06,0.08);\nfloat d6=sdEllipse(p-pos,med);\ncol = DrawFigBorde(vec3(0.0), col, d6);\n\n//ojo\npos=vec2(10.6,2.52);\nmed=vec2(0.06,0.08);\nfloat d7=sdEllipse(p-pos,med);\ncol = DrawFigBorde(vec3(0.0), col, d7);\n\npos=vec2(9.81,1.318);\nmed=vec2(0.25,0.08);\nang = -30.0 * PI/180.0;\npr = Rotate(p-pos, med, ang);\nfloat d9  = sdEllipse(pr, med);\ncol = DrawFigBorde(vec3(1.0), col, d9);\n\n\npos=vec2(10.38,1.649);\nmed=vec2(0.28,0.08);\n ang = -30.0 * PI / 180.0;\n pr = Rotate(p-pos, med, ang);\nfloat d10  = sdEllipse(pr, med);\ncol = DrawFigBorde(vec3(1.0), col, d10);\n\n\n//pie atras\npos=vec2(7.94,2.21);\nmed=vec2(0.28,0.08);\n ang = -30.0 * PI / 180.0;\n pr = Rotate(p-pos, med, ang);\nfloat d11  = sdEllipse(pr, med);\ncol = DrawFigBorde(vec3(1.0), col, d11);\n\n//pie atras 2\npos=vec2(8.52,2.03);\nmed=vec2(0.28,0.08);\n ang = -30. * PI / 180.;\n pr = Rotate(p-pos, med, ang);\nfloat d12  = sdEllipse(pr, med);\nd12=differenceSDF(d12,d1);\ncol = DrawFigBorde(vec3(1.0), col, d12);\n\ncol= cerBz02(p,col);\n\nreturn col;\n}\n\n\nvec3 escena(vec2 p, vec3 col,vec2 p2)\n{  \n    \n   float d1=abs(p.x-4.0+p.y);\nfloat d2=abs(p.x-12.0+p.y);\n col= DrawFigBorde(vec3(0.0), col, d1);\n col= DrawFigBorde(vec3(0.0), col, d2);\n\n\n   float tt=fract(iTime*1.0);\n   if(tt<0.5)\n       col=cerdito(p,col);\n   else\n       col=cerdito02(p,col);\n       \n   col= vallas(p,col);\n   col= vallasInc(p,col);\n   \n\n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 uv2=uv*5.0;\n    uv-=vec2(-1.5,-0.5);\n    uv*=4.0;\n    \n    vec3 col=vec3(0.5);\n    col=escena(uv,col,uv2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n\n\n//Quadratic Bezier - exact   (https://www.shadertoy.com/view/MlKcDD)\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 279, 279, 306], [307, 307, 350, 350, 377], [378, 378, 426, 426, 454], [457, 473, 521, 521, 599], [601, 601, 636, 636, 659], [661, 661, 698, 698, 770], [772, 772, 824, 824, 931], [935, 935, 971, 971, 1016], [1022, 1022, 1084, 1084, 1210], [1211, 1211, 1292, 1292, 1420], [1422, 1422, 1486, 1486, 1557], [1561, 1561, 1607, 1607, 1724], [1726, 1726, 1772, 1772, 1881], [1884, 1884, 1903, 1903, 1957], [1961, 1961, 1993, 1993, 2353], [2356, 2356, 2386, 2386, 3249], [3252, 3252, 3287, 3287, 3995], [3997, 3997, 4029, 4029, 6302], [6305, 6305, 6339, 6339, 7694], [7696, 7696, 7727, 7727, 8457], [8459, 8459, 8491, 8491, 10216], [10219, 10219, 10253, 10253, 11854], [11857, 11857, 11896, 11896, 12231], [12234, 12234, 12291, 12291, 12542]], "test": "untested"}
{"id": "mtXyWM", "name": "Tripy Circle (I think)", "author": "lolaitu", "description": "A modification of the program in the tutorial \"An introduction to Shader Art Coding\" from kishimisu\nhttps://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["test"], "likes": 1, "viewed": 195, "published": 3, "date": "1690812078", "time_retrieved": "2024-07-30T17:41:32.824335", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.500, -0.500, 0.300);\n    vec3 b = vec3(0.600, 0.500, 0.600);\n    vec3 c = vec3(1.600, 1.000, 1.150);\n    vec3 d = vec3(0.000, 0, 0.587);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat pi = 3.141592653589;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 FinalColor = vec3(0.0);\n    float music = texture(iChannel0, vec2(1.0, 0.0)).x;\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        \n        uv = fract(uv * ( ((sin(iTime * .6) + 1.0)* 0.25 + 0.5) + (iMouse.x / iResolution.x)* 0.5)) - 0.5;\n\n\n        float d = length(uv) + music * 0.2;\n\n        vec3 col = palette(length(uv0) + iTime * .6 + music * 0.5);\n\n        d = sin(d * 12.0 + iTime) / 20.;\n        d = abs(d);\n\n        d = 0.02 / d;\n\n        FinalColor = d * col;\n    }\n\n    fragColor = vec4(FinalColor, 1.0);\n}", "image_inputs": [{"id": 34159, "src": "https://soundcloud.com/mutomborecords/illuzion-greenhouse?in=sc-playlists/sets/lo-fi-chill-beats&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 230], [259, 259, 316, 316, 930]], "test": "untested"}
{"id": "ctfcD7", "name": "colorful thing", "author": "beans_please", "description": "random shader (i was bored)", "tags": ["colors", "color", "idk", "nice"], "likes": 2, "viewed": 134, "published": 3, "date": "1690805466", "time_retrieved": "2024-07-30T17:41:33.686031", "image_code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    float t = 0.9 * floor(iTime * 30.0) / 30.0;\n    vec2 c = floor(frag_coord / 2.0) * 2.0 + 0.5;\n    \n    // Initialize PRNG\n    prng_init(vec3(c / iResolution.y, t));\n    \n    // UV\n    vec2 uv = screen_to_uv(c);\n    \n    // Render\n    uv += vec2(0.5, 0.0);\n    float r = length(uv) + random() * 0.05;\n    float a = (0.55 * get_angle(uv) / TAU) + t * 0.1 + random() * 0.01;\n    vec3 col = rgb_sweep(a);\n    col = mix(col, col * dot(col, vec3(0.5, 0.3, 0.2)) * 1.1, 0.25);\n    col = mix(col, vec3(1.02), pow(map_range_clamp(r, 2.5, 0.0, 0.0, 1.0), 6.0));\n    float ring = 0.6 + cos(t * TAU * 0.5) * 0.04 + cos(t * TAU * 0.3) * 0.02 + cos(t * TAU * 1.5) * 0.005;\n    float ring_width = 0.04 + cos(t * TAU * 0.4) * 0.015;\n    if (r > ring && r < (ring + ring_width))\n    {\n        float fac = 1.0 - 2.0 * abs((get_angle(uv) / TAU) - 0.5);\n        fac *= fac;\n        col = pow(col, vec3(map_range(fac, 0.0, 1.0, 1.0, 2.5)));\n        col *= map_range(fac, 0.0, 1.0, 1.0, 1.2);\n    }\n    col = pow(col, vec3(map_range_clamp(r, 0.5, 5.0, 0.9, 5.0)));\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 1\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\nfloat get_angle(vec2 v)\n{\n    v /= length(v);\n    return atan(-v.y, -v.x) + PI;\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), smoothstep(0.0, 60.0, hue));\n    col = mix(col, vec3(0, 1, 0), smoothstep(60.0, 120.0, hue));\n    col = mix(col, vec3(0, 1, 1), smoothstep(120.0, 180.0, hue));\n    col = mix(col, vec3(0, 0, 1), smoothstep(180.0, 240.0, hue));\n    col = mix(col, vec3(1, 0, 1), smoothstep(240.0, 300.0, hue));\n    col = mix(col, vec3(1, 0, 0), smoothstep(300.0, 360.0, hue));\n    \n    return col;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 250, 250, 331], [333, 333, 364, 381, 421], [423, 423, 478, 478, 1608]], "test": "untested"}
{"id": "DlXyD7", "name": "codercor-trial", "author": "codercor", "description": "My trials", "tags": ["shader"], "likes": 3, "viewed": 128, "published": 3, "date": "1690801927", "time_retrieved": "2024-07-30T17:41:34.511823", "image_code": "vec3 palette(float t){\n  vec3 a = vec3(0.5,0.5,0.5);\n  vec3 b = vec3(0.5,0.5,0.5);\n   vec3 c = vec3(1.0,1.0,1.0);\n   vec3 d = vec3(0.263,0.416,0.558);\n   return a+b*cos(6.28318*(c*t+d));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    vec2 uv0=uv;\n    //uv=uv-0.5;\n    //uv= uv*500000.0;\n    //uv=fract(uv);\n           uv=fract(uv*3.0)-0.5;\n    float d = length(uv);\n       vec3 col = palette(length(uv0)+iTime);\n\n    d=sin(d*8.+iTime)/8.0;\n    \n    d=abs(d);\n //  d =smoothstep(0.0,0.1,d);\n    d=0.05/d;\n \n       col*=d; \n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 188], [194, 194, 251, 251, 626]], "test": "untested"}
{"id": "clfcWM", "name": "Random bubbles", "author": "klemek", "description": "small bubbles generated from randomness", "tags": ["bubbles"], "likes": 7, "viewed": 289, "published": 3, "date": "1690793330", "time_retrieved": "2024-07-30T17:41:35.262816", "image_code": "#define PI 3.1415927\n#define E.001\n\nfloat estep(float threshold,float x,float e){\n    return smoothstep(threshold+e,threshold-e,x);\n}\n\nfloat rand(float seed){\n    float v=pow(abs(seed),6./7.);\n    v*=sin(v)+1.;\n    return fract(v);\n}\n\nvec3 col(float x){\n    return vec3(\n        .5*(sin(x*2.*PI)+1.),\n        .5*(sin(x*2.*PI+2.*PI/3.)+1.),\n        .5*(sin(x*2.*PI-2.*PI/3.)+1.)\n    );\n}\n\nfloat saw(float x){\n    return abs(mod(x+1.,2.)-1.);\n}\n\nfloat circle(vec2 uv,vec2 center,float size){\n    uv-=center;\n    return estep(size,length(uv),E);\n}\n\nvec3 cell(float size0, float color0, vec2 uv, float id, float t)\n{\n    float speed = .1 + rand(id + 4192.) * 3.;\n    vec3 color = col(color0 + (rand(id + 5849.) - .5) * .1);\n    float size = size0 * .1 + rand(id + 9582.) * size0 * .2;\n    float px = size + saw(rand(id + 8457.) + speed * t) * (size0 - size * 2.);\n    float py = size + saw(rand(id + 4628.) + speed * t)* (size0 - size * 2.);\n    float thick = .65 + .2 * rand(id + 8371.);\n\n    return color * (rand(id + 9471.) + .2) * vec3(circle(uv, vec2(px, py), size) - circle(uv, vec2(px, py), size * thick) * .75);\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-.5);\n    uv.x*=iResolution.x/iResolution.y;\n    \n    uv += iTime * .1 + 1.;\n    \n    float size = .01;\n    \n    vec3 c = vec3(0);\n    \n    for(int i = 0; i < 7; i++) {\n        c = c * .75 + cell(size, iTime * .1, mod(uv, size), ceil(1728. + uv.x/size) * 7234. + ceil(9374. + uv.y/size) * 2348., iTime);\n    \n        size *= 1.5;\n    }\n    \n    fragColor=vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 81, 81, 133], [135, 135, 158, 158, 233], [235, 235, 253, 253, 386], [388, 388, 407, 407, 442], [444, 444, 489, 489, 544], [546, 546, 612, 612, 1117], [1121, 1121, 1175, 1175, 1584]], "test": "untested"}
{"id": "DtlcW4", "name": "skybox template", "author": "01000001", "description": "A template with which to develop skyboxes. z up.", "tags": ["utility", "skybox", "tool"], "likes": 2, "viewed": 226, "published": 3, "date": "1690749845", "time_retrieved": "2024-07-30T17:41:36.013807", "image_code": "const float pi = 3.14159;\n\nvec3 skybox(vec3 v)\n{\n    float a = 20.;\n    return pow(vec3(sin(v.x*a), sin(v.y*a), sin(v.z*a))*sin(v.x*a)*sin(v.y*a)*sin(v.z*a), vec3(2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mv = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float z = mv.y*pi*0.5;\n    vec3 camDir = normalize(vec3(sin(mv.x)*cos(z), cos(mv.x)*cos(z), sin(z)));\n    vec3 r = normalize(cross(camDir, vec3(0, 0, 1)));\n    vec3 u = normalize(cross(r, camDir));\n    vec3 v = normalize(camDir + r * uv.x + u * uv.y);\n    vec3 col = skybox(v);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 48, 48, 169], [171, 171, 228, 228, 687]], "test": "untested"}
{"id": "DlfcWN", "name": "Cloth Fractal", "author": "Sleng", "description": "playing with simple fractals", "tags": ["raymarch", "mandelbulb"], "likes": 1, "viewed": 177, "published": 3, "date": "1690733211", "time_retrieved": "2024-07-30T17:41:36.783749", "image_code": "float mandelbulbDist(vec3 pos);\nfloat rayMarch(vec3 ro, vec3 rd);\nvec3 getNormal(vec3 p);\nfloat lightIntensity(vec3 p, vec3 lightDir);\nmat3 rotationMatrix(vec3 axis, float angle);\n\nfloat mandelbulbDist(vec3 pos) {\n    // Rotate the fractal over time\n    float angle = iTime/10.;\n    mat3 rot = rotationMatrix(vec3(0.0, 1.0, 0.0), angle);\n    pos = rot * pos;\n    \n     // Scale the fractal to make it appear larger\n    float scaleFactor = 0.85;  // Adjust this value to control the zoom level\n    pos *= scaleFactor;\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    const int iterations = 5;\n    const float bailout = 2.0;\n    const float power = 3.0;\n    for (int i = 0; i < iterations; i++) {\n        r = length(z);\n        if (r > bailout) return r;\n\n        float theta = acos(z.z/r);\n        float phi = atan(z.y, z.x);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n        float zr = pow(r, power);\n        theta *= power;\n        phi *= power;\n\n        z = zr * vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n        z += pos;\n    }\n    return 0.5 * log(r) * r/dr;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float totalDist = 0.0;\n    for(int i = 0; i < 128; i++) {\n        vec3 p = ro + rd * totalDist;\n        float d = mandelbulbDist(p);\n        totalDist += d;\n        if(d < 0.001) {\n            return totalDist;\n        }\n        if(totalDist > 4.0) break;\n    }\n    return totalDist;\n}\n\nvec3 getNormal(vec3 p) {\n    const vec2 eps = vec2(0.001, 0.0);\n    vec3 n;\n    n.x = mandelbulbDist(p + eps.xyy) - mandelbulbDist(p - eps.xyy);\n    n.y = mandelbulbDist(p + eps.yxy) - mandelbulbDist(p - eps.yxy);\n    n.z = mandelbulbDist(p + eps.yyx) - mandelbulbDist(p - eps.yyx);\n    return normalize(n);\n}\n\nfloat lightIntensity(vec3 p, vec3 lightDir) {\n    vec3 normal = getNormal(p);\n    return max(0.1, dot(normal, lightDir));\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,   oc * axis.y * axis.y + c,         oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,   oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 color = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, -2.5);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    // Rotate the fractal over time\n    float angle = iTime;\n    mat3 rot = rotationMatrix(vec3(0.0, 1.0, 0.0), angle);\n    target = rot * target;\n\n    vec3 forward = normalize(target - ro);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), forward);\n    vec3 up = cross(forward, right);\n    vec3 c = ro + forward * 2.0;\n    vec3 i = c + right * uv.x;\n    vec3 j = c + up * uv.y;\n    vec3 p = i + j;\n    vec3 rayDir = normalize(p - ro);\n\n    float dist = rayMarch(ro, rayDir);\n    if(dist < 4.0) {\n        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8)); // Direction of the light\n        float diff = lightIntensity(ro + rayDir * dist, lightDir);\n        color = vec3(1.0, 0.0, 0.0) * diff;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 213, 249, 1111], [1113, 1113, 1147, 1147, 1437], [1439, 1439, 1463, 1463, 1748], [1750, 1750, 1795, 1795, 1873], [1875, 1875, 1920, 1920, 2390], [2392, 2392, 2449, 2449, 3382]], "test": "untested"}
{"id": "DtXyW4", "name": "AquaColors V3", "author": "ersh", "description": "Aqua Colors. Make it full screen and wait. Click to reset.", "tags": ["fractal", "generative"], "likes": 8, "viewed": 228, "published": 3, "date": "1690725662", "time_retrieved": "2024-07-30T17:41:37.582613", "image_code": "// (C) Yury Ershov 2023\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// (C) Yury Ershov 2023\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z > 0.) { RETV(vec4(0.)) }\n\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iRes_i = ivec2(iResolution.xy);\n    ivec2 iRes_i_1 = iRes_i - ivec2(1, 1);\n\n#if SCROLL_DIR == 1\n    fragColor =\n        fragCoord_i.y < iRes_i_1.y ?\n        T(ivec2(fragCoord_i.x, fragCoord_i.y+1)) :\n        vec4(TL(ivec2(fragCoord_i.x, 0)), 1.);\n#elif SCROLL_DIR == 2\n    fragColor =\n        fragCoord_i.y > 0 ?\n        T(ivec2(fragCoord_i.x, fragCoord_i.y-1)) :\n        vec4(TL(ivec2(fragCoord_i.x, 0)), 1.);\n#endif\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// (C) Yury Ershov 2023\n\nfloat hash12(vec2 position, float s)  // s=50.\n{\n    vec2 p = (position + mod(iTime + float(iFrame)/37.9, 200.) * 1500. + s);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat cc(in vec2 fragCoord, float c, float s) {\n    return fract(c + (hash12(fragCoord, s)-0.5)*CSPEED);\n}\n\nvec4 mcolr(in vec2 fragCoord, vec4 c, float d) {\n    return vec4(cc(fragCoord, c.r, 67.), cc(fragCoord, c.g, 42.), cc(fragCoord, c.b, 92.), c.a + d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 2 || iMouse.z > 0.) { RETV(\n#if INITSTYLE == 0\n        vec4(0.)\n#elif INITSTYLE == 1\n        vec4(hash12(fragCoord, 10.), hash12(fragCoord, 20.), hash12(fragCoord, 30.), 1.)\n#elif INITSTYLE == 2\n        vec4(\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x + 0.5, 0., 1.)) - 1., 2.))/2.,\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x, 0., 1.)) - 1., 2.))/2.,\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x - 0.5, 0., 1.)) - 1., 2.))/2.,\n            1.)\n#endif\n    ) }\n\n    if (fragCoord.y > 1.) {\n        RETV(vec4(1., 0., 0., 1.));\n        return;\n    }\n\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iRes_i = ivec2(iResolution.xy);\n    ivec2 iRes_i_1 = iRes_i - ivec2(1, 1);\n\n    if (hash12(fragCoord, 50.) > SPEED) { RET }\n\n    vec4 pt = T(ivec2(fragCoord_i.x, 0));\n    int sgn = hash12(fragCoord, 55.) > 0.5 ? 1 : -1;\n    float d = 1.;\n    vec4 pt1 = T(ivec2(fragCoord_i.x + sgn, 0));\n    if (pt1.a > pt.a) { pt = pt1; d = SIDE_WEIGHT; }\n    vec4 pt2 = T(ivec2(fragCoord_i.x - sgn, 0));\n    if (pt2.a > pt.a) { pt = pt2; d = SIDE_WEIGHT; }\n\n    fragColor = mcolr(fragCoord, pt, d);\n}\n", "buffer_b_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// (C) Yury Ershov 2023\n\nfloat hash12(vec2 position, float s)  // s=50.\n{\n    vec2 p = (position + mod(iTime + float(iFrame)/37.9, 200.) * 1500. + s + 15.);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat cc(in vec2 fragCoord, float c, float s) {\n    return fract(c + (hash12(fragCoord, s)-0.5)*CSPEED);\n}\n\nvec4 mcolr(in vec2 fragCoord, vec4 c, float d) {\n    return vec4(cc(fragCoord, c.r, 72.), cc(fragCoord, c.g, 62.), cc(fragCoord, c.b, 52.), c.a + d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 2 || iMouse.z > 0.) { RETV(\n#if INITSTYLE == 0\n        vec4(0.)\n#elif INITSTYLE == 1\n        vec4(hash12(fragCoord, 10.), hash12(fragCoord, 20.), hash12(fragCoord, 30.), 1.)\n#elif INITSTYLE == 2\n        vec4(\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x + 0.5, 0., 1.)) - 1., 2.))/2.,\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x, 0., 1.)) - 1., 2.))/2.,\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x - 0.5, 0., 1.)) - 1., 2.))/2.,\n            1.)\n#endif\n    ) }\n\n    if (fragCoord.y > 1.) {\n        RETV(vec4(1., 0., 0., 1.));\n        return;\n    }\n\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iRes_i = ivec2(iResolution.xy);\n    ivec2 iRes_i_1 = iRes_i - ivec2(1, 1);\n\n    if (hash12(fragCoord, 50.) > SPEED) { RET }\n\n    vec4 pt = T(ivec2(fragCoord_i.x, 0));\n    int sgn = hash12(fragCoord, 55.) > 0.5 ? 1 : -1;\n    float d = 1.;\n    vec4 pt1 = T(ivec2(fragCoord_i.x + sgn, 0));\n    if (pt1.a > pt.a) { pt = pt1; d = SIDE_WEIGHT; }\n    vec4 pt2 = T(ivec2(fragCoord_i.x - sgn, 0));\n    if (pt2.a > pt.a) { pt = pt2; d = SIDE_WEIGHT; }\n\n    fragColor = mcolr(fragCoord, pt, d);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SCROLL_DIR      2   // 1=UP  2=DOWN\n\n#define SPEED         0.5   // speed of horizontal change. 0.5 max\n#define CSPEED       0.01   // speed of color change\n\n#define SIDE_WEIGHT   0.8   // 1 or 0.5\n\n#define INITSTYLE       2   // 0=black  1=rnd  2=rainbow\n\n\n\n\n\n\n\n#define T(X)     texelFetch(iChannel0, X, 0)\n#define TL(X)    ((saw(texelFetch(iChannel1, X, 0).rgb)+saw(texelFetch(iChannel2, X, 0).rgb)+saw(texelFetch(iChannel3, X, 0).rgb))/3.)\n#define DD(X)    ((X).rgb != vec3(0., 0., 0.))\n#define D(X)     DD(T(X))\n#define RET      fragColor = texelFetch(iChannel0, fragCoord_i, 0); return;\n#define RETV(X)  fragColor = X; return;\n\n\n\nfloat saw(float x) { return 1.-abs(fract(x)-0.5)*2.; }\nvec3 saw(vec3 x) { return vec3(saw(x.r), saw(x.g), saw(x.b)); }\nvec4 saw(vec4 x) { return vec4(saw(x.r), saw(x.g), saw(x.b), x.a); }\n\n", "buffer_d_code": "// (C) Yury Ershov 2023\n\nfloat hash12(vec2 position, float s)  // s=50.\n{\n    vec2 p = (position + mod(iTime + float(iFrame)/37.9, 200.) * 1500. + s + 27.);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat cc(in vec2 fragCoord, float c, float s) {\n    return fract(c + (hash12(fragCoord, s)-0.5)*CSPEED);\n}\n\nvec4 mcolr(in vec2 fragCoord, vec4 c, float d) {\n    return vec4(cc(fragCoord, c.r, 63.), cc(fragCoord, c.g, 72.), cc(fragCoord, c.b, 67.), c.a + d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 2 || iMouse.z > 0.) { RETV(\n#if INITSTYLE == 0\n        vec4(0.)\n#elif INITSTYLE == 1\n        vec4(hash12(fragCoord, 10.), hash12(fragCoord, 20.), hash12(fragCoord, 30.), 1.)\n#elif INITSTYLE == 2\n        vec4(\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x + 0.5, 0., 1.)) - 1., 2.))/2.,\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x, 0., 1.)) - 1., 2.))/2.,\n            (1. - pow(saw(clamp(fragCoord.x/iResolution.x - 0.5, 0., 1.)) - 1., 2.))/2.,\n            1.)\n#endif\n    ) }\n\n    if (fragCoord.y > 1.) {\n        RETV(vec4(1., 0., 0., 1.));\n        return;\n    }\n\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iRes_i = ivec2(iResolution.xy);\n    ivec2 iRes_i_1 = iRes_i - ivec2(1, 1);\n\n    if (hash12(fragCoord, 50.) > SPEED) { RET }\n\n    vec4 pt = T(ivec2(fragCoord_i.x, 0));\n    int sgn = hash12(fragCoord, 55.) > 0.5 ? 1 : -1;\n    float d = 1.;\n    vec4 pt1 = T(ivec2(fragCoord_i.x + sgn, 0));\n    if (pt1.a > pt.a) { pt = pt1; d = SIDE_WEIGHT; }\n    vec4 pt2 = T(ivec2(fragCoord_i.x - sgn, 0));\n    if (pt2.a > pt.a) { pt = pt2; d = SIDE_WEIGHT; }\n\n    fragColor = mcolr(fragCoord, pt, d);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 82, 144]], "test": "untested"}
{"id": "ctfcW4", "name": "Spring Waves (desmos)", "author": "SnoopethDuckDuck", "description": "A bit messy and unoptimised, inspired by the references at the top of this page:\nhttps://www.febucci.com/2018/08/easing-functions/", "tags": ["bounce", "function", "periodic", "spring", "easing", "cc0", "elastic", "desmos"], "likes": 13, "viewed": 201, "published": 3, "date": "1690725134", "time_retrieved": "2024-07-30T17:41:38.343578", "image_code": "// License: CC0\n\n#define pi 3.14159\n#define ss(a) smoothstep(-1./R.y, 1./R.y, .02 - length(u - a))\n\n// Spring easing function:\n// https://www.desmos.com/calculator/vluz5j0svo\n\n// Wobble both ways (green) \n// https://www.desmos.com/calculator/9atfimg1ox\n#define f(a,b,x) sign(cos(x)) \\\n              * (1. - exp(-(a) * abs(cos(x))) * cos((b) * abs(cos(x))))\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    x = mod(x, 2.);\n    float f1 = 1. - exp(-a1 * x) * cos(b1 * x); \n    float f2 = exp(-a2 * (x-1.)) * cos(b2 * (x-1.));\n    f2 = mix(1., f2, step(1., x));\n    return 1. - 2. * f1 * f2;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    // Multiply by square wave to flip-flop sign of wave\n    float s = sign(mod(x, 4.) - 2.); \n    \n    // Make x periodic\n    x = mod(x, 2.);\n    \n    // Clamp x so mix(f,g,v) is a quarter superellipse for 1 < x < 2\n    float v = min(1., x);\n    \n    // Spring equation\n    float f = 1. - exp(-a * x) * cos(b * x);\n    \n    // Half superellipse equation (n = 2. is circle)\n    float g = pow(1. - pow(1.-x, n), 1./n); \n    // g = sqrt(1. - (1.-x) * (1.-x));\n    \n    // Mix spring into circle, then mix with an equation which\n    // is vertical at 0 so that the start/end gradients \n    // match at x = 0, 2, 4 etc.\n    // (sloppy and expensive)\n    float l = mix(mix(f, g, v), \n                  1. - exp(-7. * sqrt(x)), \n                  1. - pow(v, .1)); \n    \n    return l * s;    \n}\n      \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float t = iTime;\n    \n    vec2 R = iResolution.xy,\n         u = (I-.5*R)/R.y,\n         p = vec2(.5 * f(5., 10., pi/2. * (t + 1.)), .1),\n         q = vec2(.5 * g(12., 20., 6., 16., .5 * t), 0),\n         r = vec2(.5 * h(8., 22., 4., t), -.1);\n         \n    O = vec4(ss(q), ss(p), ss(r), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfcW4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[358, 438, 496, 496, 685], [687, 889, 934, 991, 1723], [1731, 1731, 1772, 1772, 2067]], "test": "untested"}
{"id": "dlsyD8", "name": "Weaving carpet", "author": "Ares_ekb", "description": "A carpet made of stripes", "tags": ["random"], "likes": 2, "viewed": 157, "published": 3, "date": "1690711490", "time_retrieved": "2024-07-30T17:41:39.100554", "image_code": "float random(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.x;\n    float c = random(floor(uv * abs(sin(iTime / 2.0 - uv.x * uv.y)) * 50.0));\n    fragColor = vec4(c, c, c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 96], [98, 98, 153, 153, 338]], "test": "untested"}
{"id": "cllcWH", "name": "sand ooga", "author": "lomateron", "description": ".", "tags": ["fractal", "booga"], "likes": 15, "viewed": 265, "published": 3, "date": "1690685546", "time_retrieved": "2024-07-30T17:41:39.851546", "image_code": "float fbm(vec2 u,float t)\n{\n    float l = length(u)-t*.15;\n    l = sin(l)+sin(l*2.3)+sin(l*3.1);\n    float a = 1.-l*.6;\n    mat2 m = mat2(.8,.6, -.6,.8)*2.;\n    u*=.007;\n    a += .50*texture(iChannel0,u).x; u *= m;\n    a += .25*texture(iChannel0,u).x; u *= m;\n    a += .12*texture(iChannel0,u).x; u *= m;\n    a += .06*texture(iChannel0,u).x; u *= m;\n    a += .03*texture(iChannel0,u).x;\n    return a;\n}\nfloat tal(vec2 u,vec2 n)\n{\n    float s = 1.;\n    for(float i=0.; i<8.; ++i)\n    {\n        u = abs(u);\n        float l = 1.5/dot(u,u);\n        s*=l;\n        u*=l;\n        u+=n;\n    }\n    return -abs(u.y)/s;\n}\nfloat tal2(vec2 u,vec2 n,out vec4 o)\n{\n    vec2 m = vec2(6);\n    float s = 1.;\n    for(float i=0.; i<8.; ++i)\n    {\n        u = abs(u);\n        float l = 1.5/dot(u,u);\n        s*=l;\n        u*=l;\n        u+=n;\n        o+=(cos(i*m.x+l+vec4(2,1,3,4)*m.y))*(.1-abs(u.y)/s);\n    }o=o*.5+1.;\n    return -abs(u.y)/s;\n}\nvec4 my(vec2 u, vec2 pp)\n{\n    vec2 v = u*10.;\n    float t = pp.y;\n    float a = fbm(v-vec2(2,88)*.0001,t)-fbm(v,t);\n    vec4 b = a*7.+vec4(.77,.74,.67,0);\n    vec2 n = cos(-t*.1+vec2(.0,.5)*3.145)*.02;\n    n -= vec2(2.41,.09);\n    v = vec2(abs(u.x)+.2,u.y);\n    vec4 c = vec4(0);\n    float s = tal2(v,n,c);\n    c*=(tal(v-vec2(2,88)*.00005,n)-s)*22.+.7;\n    c*=s*3.+1.1;\n    s = s*4.+.5-a*8.;\n    b = mix(b,c,clamp(s+.5,0.,1.));\n    b = mix(b,c,clamp(s*6.,0.,1.));\n    return b;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 1.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 1.*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    fragColor = my(u, vec2(iTime*4.));\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 402], [403, 403, 429, 429, 610], [611, 611, 649, 649, 923], [924, 924, 950, 950, 1404], [1405, 1405, 1462, 1462, 1623]], "test": "untested"}
{"id": "DtlyWH", "name": "MANDELBROT FRACTAL SHADER", "author": "jackjackdev", "description": "Credits to CoderSpaceChannel on YT, tutorial: https://www.youtube.com/shorts/h5PuIm6fRr8\n", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 166, "published": 3, "date": "1690683919", "time_retrieved": "2024-07-30T17:41:40.611514", "image_code": "// MANDELBROT FRACTAL SHADER\n// Credits to CoderSpaceChannel on YT, tutorial: https://www.youtube.com/shorts/h5PuIm6fRr8\nfloat MAX_ITER = 1055.0;\nfloat mandelbrot(vec2 uv) {\n    vec2 c = 4.0 * uv - vec2(0.7, 0.0);\n    c = c / pow(iTime, 4.0) - vec2(0.65, 0.45);\n    vec2 z = vec2(0.0);\n    float iter = 0.0;\n    for(float i = 0.0; i < MAX_ITER; i += 1.0) {\n        z = vec2(\n            z.x * z.x - z.y * z.y,\n            2.0 * z.x * z.y) + c;\n        if(dot(z, z) > 4.0) return iter / MAX_ITER;\n        iter += 1.0;\n    }\n    return 0.0;\n}\n\nvec3 hash13(float m) {\n    float x = fract(sin(m) * 0.246);\n    float y = fract(sin(m + x) * 0.486);\n    float z = fract(sin(x + y) * 100.352 * cos(iTime)*.05+.5);\n    return vec3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    float m = mandelbrot(uv);\n    col += hash13(m);\n    //col += m;\n    \n    //col = pow(col, vec3(0.45));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 173, 173, 540], [542, 542, 564, 564, 733], [735, 735, 792, 792, 1034]], "test": "untested"}
{"id": "ctsyW8", "name": "GrayFractals", "author": "jackjackdev", "description": "Credits to Radian628 on Youtube, tutorial here: https://www.youtube.com/watch?v=8bbTkNZYdQ8", "tags": ["fractal"], "likes": 2, "viewed": 192, "published": 3, "date": "1690673211", "time_retrieved": "2024-07-30T17:41:41.366496", "image_code": "// GrayFractals\n// Credits to Radian628 on Youtube, tutorial here: https://www.youtube.com/watch?v=8bbTkNZYdQ8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = cos(iTime) * 0.22;\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    for (float i = 0.0; i < 50.0; i += 1.0) {\n        uv = abs(uv);\n        uv -= 0.5;\n        uv *= 1.15;\n        uv *= mat2(\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n        );\n    }\n    fragColor = vec4(vec3(length(uv)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 111, 168, 168, 522]], "test": "untested"}
{"id": "dtXcW8", "name": "Hello world shader", "author": "tanczmy", "description": "First shader", "tags": ["gradient"], "likes": 1, "viewed": 239, "published": 3, "date": "1690667852", "time_retrieved": "2024-07-30T17:41:42.116490", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.668, 0.608, 0.768);\n    vec3 b = vec3(1.048, 0.548, 0.362);\n    vec3 c = vec3(0.778, 1.338, 1.388);\n    vec3 d = vec3(1.617, 1.528, 3.007);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 rotateUV(vec2 uv, vec2 pivot, float rotation) {\n    float cosa = cos(rotation);\n    float sina = sin(rotation);\n    uv -= pivot;\n    return vec2(\n        cosa * uv.x - sina * uv.y,\n        cosa * uv.y + sina * uv.x \n    ) + pivot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    \n    // Translate (0, 0) to center\n    vec2 uv = ((fragCoord * 2.0) - res) / res.y;\n    uv = rotateUV(uv, vec2(0.0), iTime * .1);\n\n\n    vec2 uv0 = uv * sin(iTime / 5.);\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * 1.6) - 0.5;\n\n        float dist = length(uv) * exp(-length(uv0));\n\n        // Color palette\n        vec3 color = palette(length(uv0) + i * 0.4 - iTime * .2);\n\n        dist = sin(dist * 8. + iTime * .3) / 8.;\n        dist = abs(dist);\n\n        dist = 0.01 / dist;\n\n        finalColor += color * dist / 1.8;\n    }\n    \n    finalColor.r = pow(finalColor.r, 1.2);\n    finalColor.g = pow(finalColor.g, 1.6);\n    finalColor.b = pow(finalColor.b, 1.6);\n\n    float clmp = 0.05;\n\n    finalColor = clamp(finalColor, 0., 1.0 - clmp) + clmp;\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 62, 62, 266], [268, 268, 320, 320, 505], [507, 507, 564, 564, 1454]], "test": "untested"}
{"id": "mlscWr", "name": "Blinn-Phong Shading", "author": "beans_please", "description": "Sphere", "tags": ["3d", "raytracing", "phong", "lighting", "sphere", "shading", "blinn"], "likes": 5, "viewed": 316, "published": 3, "date": "1690662251", "time_retrieved": "2024-07-30T17:41:43.045008", "image_code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Camera params\n    const vec3 cam_pos = vec3(0.0, -1.6, 0.5);\n    const float cam_fov = 90.0;\n    \n    // Camera details\n    float cam_zoom = 90.0 / cam_fov;\n    vec3 cam_forward = normalize(-cam_pos);\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    vec3 cam_up = cross(cam_right, cam_forward);\n    \n    // Setup ray\n    ray_info r;\n    r.orig = cam_pos;\n    r.dir = normalize(cam_forward + cam_right * (uv.x / cam_zoom) + cam_up * (uv.y / cam_zoom));\n    \n    // Cast ray\n    ray_sphere(0.8, r);\n    if (r.hit)\n    {\n        // Material params\n        const vec3 mat_diffuse = vec3(1.0, 0.5, 0.0);\n        const float mat_specular = 0.1;\n        const float mat_specular_pow = 300.0;\n        \n        // Point light params\n        const vec3 light_col = vec3(10.5);\n        const vec3 light_pos = vec3(1.0, -1.8, 3.0);\n        \n        // Light details\n        float light_dist = distance(r.pos, light_pos);\n        vec3 light_dir = (light_pos - r.pos) / light_dist;\n        \n        // Lambertian diffuse\n        vec3 diffuse =\n            mat_diffuse * light_col\n            * max(0.0, dot(r.normal, light_dir))\n            / (light_dist * light_dist);\n        \n        // Blinn specular\n        vec3 hv = normalize(light_dir - r.dir);\n        vec3 spec =\n            mat_specular * light_col\n            * pow(max(0.0, dot(hv, r.normal)), mat_specular_pow);\n        \n        // Ambient\n        vec3 ambient = 0.05 * mat_diffuse + 0.02 * vec3(0.04, 0.3, 0.7);\n        \n        // Shade\n        vec3 col = diffuse + spec + ambient;\n        \n        return col;\n    }\n    else\n    {\n        // Background color\n        vec3 col = vec3(0.04, 0.3, 0.7);\n        col *= map_range_clamp(uv.y, -0.5, 0.7, 1.1, 0.8);\n        col *= map_range(smoothstep(2.0, 0.7, length(uv)), 0.0, 1.0, 0.9, 1.0);\n        col *= 1.1;\n        col = pow(col, vec3(map_range(smoothstep(2.0, 0.7, length(uv)), 0.0, 1.0, 1.1, 1.0)));\n        return col;\n    }\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Render with jitter sampling\n    const int num_samples = 24;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        vec2 offs = vec2(random(), random()) - 0.5;\n        col += render(frag_coord + offs);\n    }\n    col /= float(num_samples);\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 1\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 0\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\nstruct ray_info\n{\n    vec3 orig;\n    vec3 dir;\n    bool hit;\n    vec3 pos;\n    vec3 normal;\n};\n\nvoid ray_sphere(float radius, inout ray_info r)\n{\n    // Quadratic equation\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(r.orig, r.dir);\n    float c = dot(r.orig, r.orig) - radius*radius;\n    float discriminant = (b * b) - (4.0 * a * c);\n    \n    if (discriminant < 0.0)\n    {\n        // No hits\n        r.hit = false;\n        return;\n    }\n    \n    float sqrt_d = sqrt(discriminant);\n    float t1 = (-b - sqrt_d) / (2.0 * a);\n    float t2 = (-b + sqrt_d) / (2.0 * a);\n    \n    if (t1 < 0.0 && t2 < 0.0)\n    {\n        // Fully behind the origin\n        r.hit = false;\n        return;\n    }\n    \n    if (t1 < 0.0)\n    {\n        // Partially behind the origin\n        r.hit = true;\n        r.pos = r.orig + (t2 * r.dir);\n    }\n    else\n    {\n        // Fully in front\n        r.hit = true;\n        r.pos = r.orig + (t1 * r.dir);\n    }\n    \n    // Normal\n    r.normal = r.pos / radius;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlscWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 250, 250, 331], [333, 333, 364, 381, 421], [423, 423, 453, 463, 2472], [2474, 2474, 2529, 2552, 2968]], "test": "untested"}
{"id": "dtXcDn", "name": "SomeRandomShader", "author": "Lop807667", "description": "SomeRandomShader", "tags": ["idk"], "likes": 1, "viewed": 117, "published": 3, "date": "1690653616", "time_retrieved": "2024-07-30T17:41:43.811957", "image_code": "float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdRoundedX( in vec2 p, in float w, in float r, in float offset )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*(44.1*sin(iTime*0.15+offset)+2.7)*0.1) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float size = 0.13;\n    vec2 uv = size*vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y)-size*0.5;\n    vec2 uv0 = uv*0.11;\n    float sizefract= 3341.141;\n    uv = fract(((uv*30.1)))*sizefract-sizefract*0.5;\n    float dis =11.0*sin(iTime*0.015+length(uv0));\n    float ChangeFactor = length(uv0)*0.25*((sin(iTime*0.5+length(uv0))+2.3));\n    float ChangeFactor2 = length(uv0)*0.45*((cos(iTime*0.05+length(uv0))+4.3));\n\tfloat d = sdRoundedX( uv, dis*0.1, 3.1,4.0 );\n    float dc1 = sdRoundedX(uv*ChangeFactor*0.4, 33.100*abs((dis+1.3)*sin(0.1*iTime+3.14159265359/3.0*1.0*ChangeFactor)), -1.0,d*ChangeFactor2);\n    float dc2 = sdRoundedX(uv*ChangeFactor*0.075, 330.100*abs((dis+2.3)*sin(0.1*iTime+3.14159265359/3.0*2.0*ChangeFactor)),sin(0.1+length(uv0))*d+10.0,2.0*ChangeFactor2+length(uv0));\n    float dc3 = sdRoundedX(uv*ChangeFactor*0.095,22.100*abs((dis-3.3)*sin(0.1*iTime+3.14159265359/3.0*3.0*ChangeFactor)),cos(0.1+length(uv0))*d+1.0,3.0*ChangeFactor2+length(uv0));\n    vec3 col;\n    for( float t = 0.0; t < 5.1; t += 1.09 )\n\t{\n        dc1 = atan(dc1*0.05);\n        dc2 = sin(dc2*0.5);\n        dc3 = atan(dc3*0.05);\n        d = sin(d*0.018+length(uv0*pow(t,1.1)));\n        d = 0.001/d;\n        d = d*10.2;\n        col += vec3(3.110*abs(cos(iTime*0.3))+1.5) - \n        abs(d)*vec3(0.7,105.0,1.7)- \n        smoothstep(-0.5,0.5,(dc1)*vec3(1.13,1.33,1.05)*length(1.0/uv0))- \n        smoothstep(-0.5,0.5,(dc2)*vec3(1.13,-1.03,-0.33)*length(1.0/uv0))- \n        smoothstep(-0.5,0.5,(dc3)*vec3(-1.13,0.73,-1.05)*length(1.0/uv0));\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(0.18/col,1.0) ;\n   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXcDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 63], [64, 64, 136, 136, 233], [235, 235, 292, 342, 1961]], "test": "untested"}
{"id": "clXyW8", "name": "Box - occlusion clipping optimiz", "author": "clem494949", "description": "Analytic box occlusion with clipping optimized using less acos / conditions. It's based on the cube's perimeter instead of the individual faces' perimeter.\nFork of : https://www.shadertoy.com/view/4djXDy", "tags": ["3d", "occlusion", "analytic"], "likes": 0, "viewed": 67, "published": 3, "date": "1690646857", "time_retrieved": "2024-07-30T17:41:44.568934", "image_code": "// Forked from https://www.shadertoy.com/view/4sSXDV\n\n// MIT License\n\n// Analytic box occlusion with clipping optimized using less acos / conditions. \n// It's based on the cube's perimeter instead of the individual faces' perimeter.\n\n//=====================================================\n\nfloat sacos( float x ) { return acos( min(max(x,-1.0),1.0) ); }\n\nvec3 clip( in vec3 a, in vec3 b, in vec4 p )\n{\n    return a - (b-a)*(p.w + dot(p.xyz,a))/dot(p.xyz,(b-a));\n    //return ( a*dot(p.xyz,b) - b*dot(p.xyz,a)  - (b-a)*p.w ) / dot(p.xyz,(b-a));\n}\n\nfloat fedgeOcclusion(in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1)\n{\n    vec3 nv0 = normalize(v0 - pos);\n    vec3 nv1 = normalize(v1 - pos);\n    return dot(nor, normalize(cross(nv0,nv1))) * sacos(dot(nv0,nv1)) / 6.283185;\n}\n\nfloat edgeOcclusion(in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, inout vec3 c0, inout vec3 c1, in vec4 plane)\n{\n    float s0 = dot(vec4(v0,1.0), plane);\n    float s1 = dot(vec4(v1,1.0), plane);\n    float sn = sign(s0) + sign(s1);\n\n    vec3 c = clip( v0, v1, plane );\n    \n    float occ = 0.0;\n    // All vertices above horizon\n    if(sn>1.0) \n    {\n        occ += fedgeOcclusion(pos, nor, v0, v1);\n    }\n    // 1 vertex above horizon\n    else if(sn>-1.0) \n    {\n        vec3 pa, pb;\n        if(s0 > 0.0 )        { pa = v0; pb = c;  }\n        else/*if( s1>0.0 )*/ { pa = c;  pb = v1; }\n        occ += fedgeOcclusion(pos, nor, pa, pb);\n        \n        // Save the intersection\n        if(dot(c0, c0) != 0.0) { c1 = c; } \n        else { c0 = c; }\n    }\n    // zero (no) vertices above horizon\n    return occ;\n}\n\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    vec4 w = vec4( n, -dot(n,p) ); // clipping plane\n    \n    // Orient the hexagon based on p\n    vec3 sp = sign(p);\n    vec3 f = rad * sp;\n    \n    // Make sure the hexagon is always convex\n    vec3 s = sign(rad - abs(p));\n    \n    // 6 verts\n    vec3 v0 = vec3( 1.0, 1.0, min(s.x,s.y))*f;\n    vec3 v1 = vec3( 1.0, s.x, s.x)*f;\n    vec3 v2 = vec3( 1.0, min(s.x,s.z), 1.0)*f;\n    vec3 v3 = vec3( s.z, s.z, 1.0)*f;\n    vec3 v4 = vec3( min(s.y,s.z), 1.0, 1.0)*f;\n    vec3 v5 = vec3( s.y, 1.0, s.y)*f;\n    \n    // Points of intersection with the plane\n    vec3 c0 = vec3(0.0);\n    vec3 c1 = vec3(0.0);\n    \n    // 6 edges\n    float occ = edgeOcclusion(p, n, v0, v1, c0, c1, w);\n    occ += edgeOcclusion(p, n, v1, v2, c0, c1, w);\n    occ += edgeOcclusion(p, n, v2, v3, c0, c1, w);\n    occ += edgeOcclusion(p, n, v3, v4, c0, c1, w);\n    occ += edgeOcclusion(p, n, v4, v5, c0, c1, w);\n    occ += edgeOcclusion(p, n, v5, v0, c0, c1, w);\n    occ *= sp.x * sp.y * sp.z;\n    // 1 edge for intersection with plane\n    occ += abs(fedgeOcclusion(p, n, c0, c1));\n    return max(0.0, occ);\n}\n\n//-----------------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n//-----------------------------------------------------------------------------------------\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // box animation\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,0.9,0.5)), 0.5*iTime );\n\tmat4 tra = translate( 0.0, 0.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\tvec3 box = vec3(0.2,0.7,2.0) ;\n\n    vec4 rrr = textureLod( iChannel0, (fragCoord.xy)/iChannelResolution[0].xy, 0.0  ).xzyw;\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = 0.0;\n        \n        if( p.x > s )\n        {\n            occ = boxOcclusion( pos, nor, txx, txi, box );\n        }\n        else\n        {\n   \t\t    vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\t    vec3  rv  = normalize( cross( ru, nor ) );\n\n            occ = 0.0;\n            for( int i=0; i<256; i++ )\n            {\n                vec2  aa = hash2( rrr.x + float(i)*203.1 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  dir = vec3( rx*ru + ry*rv + rz*nor );\n                vec4 res = boxIntersect( pos, dir, txx, txi, box );\n                occ += step(0.0,res.x);\n            }\n            occ /= 256.0;\n        }\n\n        col = vec3(1.2);\n        col *= 1.0 - occ;\n    }\n\n    vec4 res = boxIntersect( ro, rd, txx, txi, box );\n    float t2 = res.x;\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.yzw;\n\t\tcol = vec3(1.4);//vec3(1.0,0.85,0.6);\n        col *= 0.6 + 0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXyW8.jpg", "access": "api", "license": "mit", "functions": [[291, 291, 315, 315, 354], [356, 356, 402, 402, 546], [548, 548, 620, 620, 775], [777, 777, 893, 893, 1590], [1592, 1592, 1680, 1680, 2828], [2923, 2971, 3056, 3093, 3611], [3613, 3613, 3660, 3660, 4064], [4066, 4066, 4111, 4111, 4227], [4230, 4230, 4253, 4253, 4323], [4418, 4418, 4458, 4458, 4491], [4493, 4493, 4550, 4550, 6596]], "test": "untested"}
{"id": "clXcW8", "name": "Shivershade slime", "author": "xenn", "description": "This is just a variation on Florian Berger's (flockaroo's) single pass CFD method, with (possibly) some optimizations and time- and resolution-dependent stability fixes, a randomized simplex gradient seed for initial color, and mouse interaction.", "tags": ["fluid", "flow", "dynamics", "pass", "cfd", "single"], "likes": 13, "viewed": 355, "published": 3, "date": "1690643011", "time_retrieved": "2024-07-30T17:41:45.624112", "image_code": "\n\n// Based on \"spilled\" by florian berger (flockaroo) https://www.shadertoy.com/view/MsGSRd\n// Click and drag to inject color\n// Press I to pick a different start seed\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Based on \"spilled\" by florian berger (flockaroo) https://www.shadertoy.com/view/MsGSRd\n// Click and drag to inject color\n// Press I to pick a different start seed\n\n// RotNum has to be an odd integer\n#define RotNum 9\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel1\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float third = 1.0 / 3.0;\nconst float sixth = 1.0 / 6.0;\nconst float rotFloat = float(RotNum);\nconst float iRotFloat = 1.0 / rotFloat;\nconst float imf = 1.0 / float(0xFFFFFFFFU);\nconst float ang = 2.0 * 3.1415926535 / float(RotNum);\nmat2 m2 = mat2( cos(ang), sin(ang),\n              -sin(ang), cos(ang));\n\nvec4 permute(vec4 x) {\n    vec4 xm = mod(x, 289.0);\n    return mod(((xm * 34.0) + 10.0) * xm, 289.0);\n}\n\n// Stefan Gustavson's and Ian McEwan's implementation of simplex noise (patent is now expired)\n// https://github.com/stegu/psrdnoise\nvec3 psrdnoise(vec3 x) {\n    vec3 uvw = x + dot(x, vec3(third));\n    vec3 i0 = floor(uvw);\n    vec3 f0 = fract(uvw);\n    vec3 g_ = step(f0.xyx, f0.yzz);\n    vec3 l_ = 1.0 - g_;\n    vec3 g = vec3(l_.z, g_.xy);\n    vec3 l = vec3(l_.xy, g_.z);\n    vec3 o1 = min(g, l);\n    vec3 o2 = max(g, l);\n    vec3 i1 = i0 + o1;\n    vec3 i2 = i0 + o2;\n    vec3 i3 = i0 + 1.0;\n    vec3 v0 = i0 - dot(i0, vec3(sixth));\n    vec3 v1 = i1 - dot(i1, vec3(sixth));\n    vec3 v2 = i2 - dot(i2, vec3(sixth));\n    vec3 v3 = i3 - dot(i3, vec3(sixth));\n    vec3 x0 = x - v0;\n    vec3 x1 = x - v1;\n    vec3 x2 = x - v2;\n    vec3 x3 = x - v3;\n    vec4 hash = permute(permute(permute(\n                  vec4(i0.z, i1.z, i2.z, i3.z))\n                + vec4(i0.y, i1.y, i2.y, i3.y))\n                + vec4(i0.x, i1.x, i2.x, i3.x));\n    vec4 theta = hash * 3.883222077;\n    vec4 sz = hash * -0.006920415 + 0.996539792;\n    vec4 psi = hash * 0.108705628;\n    vec4 Ct = cos(theta);\n    vec4 St = sin(theta);\n    vec4 sz_prime = sqrt(1.0 - sz * sz);\n    vec4 gx = Ct * sz_prime;\n    vec4 gy = St * sz_prime;\n    vec3 g0 = vec3(gx.x, gy.x, sz.x);\n    vec3 g1 = vec3(gx.y, gy.y, sz.y);\n    vec3 g2 = vec3(gx.z, gy.z, sz.z);\n    vec3 g3 = vec3(gx.w, gy.w, sz.w);\n    vec4 w = 0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3));\n    w = max(w, 0.0);\n    vec4 w2 = w * w;\n    vec4 w3 = w2 * w;\n    vec4 gdotx = vec4(dot(g0, x0), dot(g1, x1), dot(g2, x2), dot(g3, x3));\n    vec4 dw = -6.0 * w2 * gdotx;\n    vec3 dn0 = w3.x * g0 + dw.x * x0;\n    vec3 dn1 = w3.y * g1 + dw.y * x1;\n    vec3 dn2 = w3.z * g2 + dw.z * x2;\n    vec3 dn3 = w3.w * g3 + dw.w * x3;\n    return 39.5 * (dn0 + dn1 + dn2 + dn3);\n}\n\n// Chris Wellons' and TheIronBorn's best 32-bit two-round integer hash\n// https://github.com/skeeto/hash-prospector\n// flockaroo used 2D noise, but it was only sampled along one dimension\n// and only used one output value, so I replaced it with 1D noise\nfloat hash32(int x) {\n    // since the frame number is an int seed, convert to uint for bitwise ops\n    uint p = uint(x);\n    p ^= p >> 16;\n    p *= 0x21F0AAADU;\n    p ^= p >> 15;\n    p *= 0xD35A2D97U;\n    p ^= p >> 15;\n    // normalize float and shift range to -0.5, 0.5 to cover whole period with ang\n    return float(p) * imf - 0.5;\n}\n\nfloat circleSDF(vec2 p, vec2 c, float r) {\n    return length(p + c) - r;\n}\n\n// basically tried to eliminate as many dot products and divisions as possible\nfloat getRot(vec2 invRes, vec2 pos, vec2 b, float idb) {\n    vec2 p = b;\n    float rot = 0.0;\n    for(int i = 0; i < RotNum; i++) {\n        rot += dot(texture(iChannel0, fract((pos + p) * invRes)).xy - 0.5,\n                   vec2(p.y, -p.x));\n        p = m2 * p;\n    }\n    return rot * iRotFloat * idb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // use screen resolution in all calculations\n    // since buffer and image resolution are the same\n    \n    // eliminate division where possible\n    vec2 invRes = 1.0 / iResolution.xy;\n    \n    // proportionally squared and zero-centered uvs\n    // to keep simplex seed color grid coords from stretching\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) * invRes.y;\n    float rnd = hash32(iFrame);\n    \n    // do ang * rnd once instead of twice\n    float angrnd = ang * rnd;\n    vec2 b = vec2(cos(angrnd), sin(angrnd));\n    \n    // calculate dot product and its inverse only once\n    float db = dot(b, b);\n    float idb = 1.0 / db;\n    vec2 v = vec2(0.0);\n    \n    // abort loop later for bigger vortices (for long-term stability)\n    // this makes it less dependent on certain resolutions for stability\n    float bbMax = iResolution.y;\n    bbMax *= bbMax;\n    \n    // reduced the number of rounds the velocity is summed over\n    for(int l = 0; l < 9; l++) {\n        if(db > bbMax) break;\n        vec2 p = b;\n        for(int i = 0; i < RotNum; i++) {\n            v += p.yx * getRot(invRes, fragCoord.xy + p, b, idb);\n            p = m2 * p;\n        }\n        b *= 2.0;\n        // do multiplications for dot product optimizations\n        db *= 4.0;\n        idb *= 0.25;\n    }\n    \n    fragColor=texture(iChannel0,fract((fragCoord.xy + v * vec2(-1, 1) * 2.0) / Res.xy));\n\n    vec2 scr = fragCoord.xy * invRes - 0.75;\n    // added an extra blue color \"fountain\"\n    // since velocity is driven by red and green channels, blue is initially stationary (like black)\n    // but starts moving when red and green accumulate in the blue pixels\n    // slowed down color accumulation a bit to accomodate for an extra channel being used\n //   fragColor.xyz += (0.009 * vec3(scr.xy, -0.5 * (scr.x + scr.y)) / (dot(scr, scr) * 10.0 + 0.3));\n    \n    if(iFrame < 1 || KEY_I > 0.5) {\n        float srv = iDate.x + iDate.y + iDate.z + iDate.w; \n        vec3 n = psrdnoise(vec3(uv * 4.0, srv));\n        n = normalize(n) * 0.5 + 0.5;\n        fragColor = vec4(n, 1.0);\n    }\n    \n    if(iMouse.z > 0.0) {\n        float t = iTime;\n        vec2 ppos = -(iMouse.xy - 0.5 * iResolution.xy) * invRes.y;\n        vec3 pcol = 0.5 * (sin(vec3(t, t + 2.1, t + 4.2)) + 1.0);\n        float dist = circleSDF(uv, ppos, 0.1);\n        if(dist < 0.0) fragColor = vec4(pcol, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "#define HEIGHT 20.0*(5.*(sin(iTime/4.333)))\n#define BRIGHTNESS .95\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n\n    vec3 normal = bump2Normal(uv, iChannel0, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3((sin(iTime/8.)), -abs(sin(iTime/7.)), (sin(iTime/6.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 01.99) {\n        fragColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        fragColor*=texture(iChannel1, uv);\n                fragColor = clamp(fragColor, 0., 1.);\n\n    } else {\n        fragColor = vec4(normalRGB, 1.0);\n    }  \n    \n//    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n//    \tfragColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n//    }\n\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n\n\n// Fork of \" expansive reaction-diffusion\" by Flexi. https://shadertoy.com/view/4dcGW2\n// 2022-07-28 10:46:34\n\n// and\n\n// Brush toy by Leon Denise 2022-05-17\n\n// I wanted to play further with shading and lighting from 2D heightmap.\n// I started by generating a heightmap from noise, then shape and curves.\n// Once the curve was drawing nice brush strokes, I wanted to add motion.\n// Also wanted to add droplets of paints falling, but that will be\n// for another sketch.\n\n// This is the color pass\n// Click on left edge to see layers\n\n// The painting pass (Buffer A) is using FBM noise to simulate brush strokes\n// The curve was generated with a discrete Fourier Transform,\n// from https://www.shadertoy.com/view/3ljXWK\n\n// Frame buffer sampling get offset from brush motion,\n// and the mouse also interact with the buffer.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(.0);\n    \n    // coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 dither = texture(iChannel1, fragCoord.xy / 124.).rgb;\n    \n    // value from noise buffer A\n    vec3 noise = texture(iChannel0, uv).rgb;\n    float gray = noise.x;\n    \n    // gradient normal from gray value\n    vec3 unit = vec3(3./iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray));\n    \n    \n    // specular light\n    vec3 dir = normalize(vec3(0,1,2.));\n    float specular = pow(dot(normal, dir)*.5+.5,10.);\n    color += vec3(.5)*specular;\n    \n    // rainbow palette\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*(2.5+(2.45*sin(iTime/3.)+1.))+gray*5.+uv.x*5.);\n    dir = normalize(vec3(uv-.5, 0.));\n    color += tint*pow(dot(normal, -dir)*.5+.5, 0.5);\n    \n    // background blend\n    vec3 background = vec3(.0)*smoothstep(1.5,0.,length(uv-.5));\n    color = mix(background, clamp(color, 0., 1.), smoothstep(.2,.5,noise.x));\n    \n    // display layers when clic\n    if (iMouse.z > 0.5 && iMouse.x/iResolution.x < .1)\n    {\n        if (uv.x < .33) color = vec3(gray);\n        else if (uv.x < .66) color = normal*.5+.5;\n        else color = vec3(.2+specular)*gray;\n    }\n\n    fragColor = vec4(color, 1);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n// Fork of \"Loverlamp DUB TEK\" by xenn. https://shadertoy.com/view/Nt33Wf\n// 2021-11-13 13:32:45\n\n// Fork of \"Loverlamp Minus 2\" by xenn. https://shadertoy.com/view/Nl33WX\n// 2021-11-13 13:08:30\n\n// Fork of \"Loverlamp Minus\" by xenn. https://shadertoy.com/view/Nlt3Dj\n// 2021-11-13 09:45:13\n\n// Fork of \"Loverlamp\" by xenn. https://shadertoy.com/view/7tdGWS\n// 2021-11-12 18:46:48\n\n//Chromamargins 0.tic aberration, film grain and tone mapping\n//#define Margins 0.\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .015;\n      vec3 color = vec3(texture(iChannel0, uv - 0.250 * d).r,\n                      texture(iChannel0, uv - .0 * d).g,\n                      texture(iChannel0, uv + 0.250 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.250  * d).r,\n                      texture(iChannel1, uv - .0 * d).g,\n                      texture(iChannel1, uv - 0.250 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv -0.250  * d).r,\n                      texture(iChannel2, uv - .0 * d).g,\n                      texture(iChannel2, uv - 0.250  * d).b);\n                      \n                       vec3 col3 = vec3(texture(iChannel3, uv - 0.250 * d).r,\n                      texture(iChannel3, uv - 0.0 * d).g,\n                      texture(iChannel3, uv - 0.250 * d).b);\n                      \n                      \n                      color = min(col2,color);\n                      col = min(col,col3);\n                //     col = mix(col,color,col2);\n                 //    color = mix(col,color,col2)*(color+color);\n                 col3 *= max (color, col3)-(col2*col3);\n                      \n        vec3 blend = (min(col3,col2)*col);               \n      col = ((max(color,col),col3)*(col3));\n      color = (mix(color,col,col2)*(col2));\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm((blend+(mix(color,blend,col)))*noise), 1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 226, 226, 306]], "test": "untested"}
{"id": "DlscDn", "name": "Axis Fusion", "author": "Tobinyan", "description": "modify axis", "tags": ["axis"], "likes": 4, "viewed": 153, "published": 3, "date": "1690607233", "time_retrieved": "2024-07-30T17:41:46.372113", "image_code": "void  mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y; //x座標の倍率をyに合わせる\n    \n    vec2 uv = st*2.-vec2(iResolution.x/iResolution.y,1.); //原点を中央に\n    vec2 wx = vec2(pow(length(uv), 2.))*10.; //中央からの距離の二乗\n    \n    vec2 warp_uv =  mix(uv,uv*0.,length(wx)*tan(iTime)*.01)*10.; //wxでmix\n\tfloat color2 = step(fract((warp_uv.x)),0.1)+step(fract((warp_uv.y)),0.1); //格子に\n    \n    float r = 1.;\n    float g = color2+.3;\n    float b = .5;\n    \n    \n\n    fragColor = vec4(r,g,b,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlscDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 618]], "test": "untested"}
{"id": "mtXcWr", "name": "MyFirstGLSLTutorial", "author": "DavidSi", "description": "This is the result of my first GLSL tutorial for shader toy.", "tags": ["tutorial", "youtube", "kishimisu"], "likes": 1, "viewed": 198, "published": 3, "date": "1690587090", "time_retrieved": "2024-07-30T17:41:47.292651", "image_code": "vec3 palette( in float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.2, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.3, 0.4, 0.5);\n    \n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n    \n        uv = fract(uv * 1.5) - 0.5;\n\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8.0 + iTime)/8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXcWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 217], [220, 220, 277, 277, 762]], "test": "untested"}
{"id": "7ltBzj", "name": "2D Cubic Bézier patch", "author": "Reynolds", "description": "Nicely behaved (injective) 2D Bézier patches have the property that every point is within its boundary curves.", "tags": ["bezier", "inverse", "subdivision", "patch"], "likes": 9, "viewed": 340, "published": 3, "date": "1690583393", "time_retrieved": "2024-07-30T17:41:48.234134", "image_code": "#define ZERO min(0,iFrame)\n#define maxIterations 10\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n//From Trisomie21\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\nint cubic_bezier_int_test(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n    \n    int n_ints=0;\n        \n    if(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    else{\n    \n        if(abs(cu) < .00001){\n            n_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n        }\n        else{\n            n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n        }\n\n        for(int i=ZERO;i<n_roots;i++){\n            if(roots[i] >= 0.0 && roots[i] <= 1.){\n                float x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n                x_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n                x_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n                x_pos = x_pos * roots[i] + p0.x;\n\n                if(x_pos > uv.x){\n                    n_ints++;\n                }\n            }\n        }\n    }\n\n\treturn n_ints;\n}\n\nvec2 bez(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(\n            mix(mix(A, B, t), mix(B, C, t), t),\n            mix(mix(B, C, t), mix(C, D, t), t), t);\n}\n\nvec2 thirdCp(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(mix(A, B, t), mix(B, C, t), t);\n}\n\nvec2 fifthCp(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(mix(B, C, t), mix(C, D, t), t);\n}\n\nvec2 evalPatch(vec2 uv, vec2 b00, vec2 b10, vec2 b20, vec2 b30, vec2 b01, vec2 b11, vec2 b21, vec2 b31, vec2 b02, vec2 b12, vec2 b22, vec2 b32, vec2 b03, vec2 b13, vec2 b23, vec2 b33) {\n    vec2 bu0 = bez(b00, b10, b20, b30, uv.x);\n    vec2 bu1 = bez(b01, b11, b21, b31, uv.x);\n    vec2 bu2 = bez(b02, b12, b22, b32, uv.x);\n    vec2 bu3 = bez(b03, b13, b23, b33, uv.x);\n\n    return bez(bu0, bu1, bu2, bu3, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y*2.0 - vec2(1.3, 0.5);\n    \n    //perturb base control points randomly\n    vec2 B00 = vec2(0.0, 0.0) +0.05*vec2(cos(iTime/2.6), sin(iTime/0.5));\n    vec2 B10 = vec2(1.0/3.0, 0.0) + 0.1*vec2(cos(iTime/2.6), 2.0*sin(iTime/0.5));\n    vec2 B20 = vec2(2.0/3.0, 0.0) - 0.1*vec2(cos(iTime/0.7), 2.0*sin(iTime));\n    vec2 B30 = vec2(1.0, 0.0) + +0.05*vec2(cos(iTime/0.5), sin(iTime/2.6));\n   \n    vec2 B01 = vec2(0.0, 1.0/3.0) + 0.1*vec2(cos(iTime/2.5), sin(iTime));\n    vec2 B11 = vec2(1.0/3.0, 1.0/3.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B21 = vec2(2.0/3.0, 1.0/3.0) + 0.1*vec2(cos(iTime/1.3), sin(iTime/0.7));\n    vec2 B31 = vec2(1.0, 1.0/3.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    \n    vec2 B02 = vec2(0.0, 2.0/3.0) - 0.1*vec2(cos(iTime/0.7), 2.0*sin(iTime));\n    vec2 B12 = vec2(1.0/3.0, 2.0/3.0) + 0.1*vec2(cos(iTime/0.3), sin(iTime/1.1));\n    vec2 B22 = vec2(2.0/3.0, 2.0/3.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B32 = vec2(1.0, 2.0/3.0) - 0.1*vec2(cos(iTime/0.7), 2.0*sin(iTime));\n    \n    vec2 B03 = vec2(0.0, 1.0) + 0.05*vec2(cos(iTime/2.6), sin(iTime/0.5));\n    vec2 B13 = vec2(1.0/3.0, 1.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B23 = vec2(2.0/3.0, 1.0) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B33 = vec2(1.0, 1.0) + 0.05*vec2(cos(iTime/2.6), sin(iTime/0.5));\n  \n    vec2 b00 = B00;\n    vec2 b10 = B10;\n    vec2 b20 = B20;\n    vec2 b30 = B30;\n   \n    vec2 b01 = B01;\n    vec2 b11 = B11;\n    vec2 b21 = B21;\n    vec2 b31 = B31;\n    \n    vec2 b02 = B02;\n    vec2 b12 = B12;\n    vec2 b22 = B22;\n    vec2 b32 = B32;\n    \n    vec2 b03 = B03;\n    vec2 b13 = B13;\n    vec2 b23 = B23;\n    vec2 b33 = B33;\n    \n    //switch for colour interpolation to texture mode\n    int mode = 0;\n    float changeTime = 2.*float(maxIterations);\n    if(mod(iTime, changeTime) > changeTime * 0.50)\n        mode = 1;\n\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 t = vec2(0.5);\n    float d;\n    //new control point positions\n    vec2 b00_n, b10_n, b20_n, b30_n, b01_n, b11_n, b21_n, b31_n, b02_n, b12_n, b22_n, b32_n, b03_n, b13_n, b23_n, b33_n;\n    \n    float f = 0.5;\n    \n    vec2 miu = vec2(0.0);\n    vec2 mau = vec2(1.0);\n\n    int s0 = cubic_bezier_int_test(b00, b10, b20, b30, uv);\n    s0 += cubic_bezier_int_test(b30, b31, b32, b33, uv);\n    s0 += cubic_bezier_int_test(b33, b23, b13, b03, uv);\n    s0 += cubic_bezier_int_test(b03, b02, b01, b00, uv);\n\n    int iterations = maxIterations;\n    iterations = max(1, int(iTime) % maxIterations);\n\n    if(s0 % 2 == 1) { //first test whether uv is bound by 4 main boundary curves\n        col = vec3(1.0);\n        for(int i = 0; i < iterations; ++i) {\n            f = f * 0.5;\n\n            vec2 bu0 = bez(b00, b10, b20, b30, 0.5);\n            vec2 bu1 = bez(b01, b11, b21, b31, 0.5);\n            vec2 bu2 = bez(b02, b12, b22, b32, 0.5);\n            vec2 bu3 = bez(b03, b13, b23, b33, 0.5);\n\n            vec2 bv0 = bez(b00, b01, b02, b03, 0.5);\n            vec2 bv1 = bez(b10, b11, b12, b13, 0.5);\n            vec2 bv2 = bez(b20, b21, b22, b23, 0.5);\n            vec2 bv3 = bez(b30, b31, b32, b33, 0.5);\n\n            vec2 C = bez(bu0, bu1, bu2, bu3, 0.5);\n\n            col = vec3(1.0);\n\n            //lo\n            vec2 b10_lo = 0.5*(b00 + b10);\n            vec2 b20_lo = thirdCp(b00, b10, b20, b30, 0.5);\n\n            vec2 b01_lo = 0.5*(b00 + b01);\n            vec2 b02_lo = thirdCp(b00, b01, b02, b03, 0.5);\n\n            vec2 b31_lo = 0.5*(bu0 + bu1);\n            vec2 b32_lo = thirdCp(bu0, bu1, bu2, bu3, 0.5);\n\n            vec2 b13_lo = 0.5*(bv0 + bv1);\n            vec2 b23_lo = thirdCp(bv0, bv1, bv2, bv3, 0.5);\n\n            //lb\n            vec2 b01_lb = fifthCp(b00, b01, b02, b03, 0.5);\n            vec2 b02_lb = 0.5 * (b02 + b03);\n\n            vec2 b13_lb = 0.5 * (b03 + b13);\n            vec2 b23_lb = thirdCp(b03, b13, b23, b33, 0.5);\n\n            vec2 b31_lb = fifthCp(bu0, bu1, bu2, bu3, 0.5);\n            vec2 b32_lb = 0.5 * (bu3 + bu2);\n\n            //rb\n            vec2 b13_rb = fifthCp(b03, b13, b23, b33, 0.5);\n            vec2 b23_rb = 0.5*(b23 + b33);\n\n            vec2 b31_rb = fifthCp(b30, b31, b32, b33, 0.5);\n            vec2 b32_rb = 0.5*(b32 + b33);\n\n            vec2 b10_rb = fifthCp(bv0, bv1, bv2, bv3, 0.5);\n            vec2 b20_rb = 0.5*(bv2 + bv3);\n\n            //ro\n            vec2 b10_ro = fifthCp(b00, b10, b20, b30, 0.5);\n            vec2 b20_ro = 0.5*(b20 + b30);\n\n            vec2 b31_ro = 0.5*(b30 + b31);\n            vec2 b32_ro = thirdCp(b30, b31, b32, b33, 0.5);\n\n            //we know it is on the patch check three quadrants to find out in which one we are\n            int s_lo = cubic_bezier_int_test(b00, b10_lo, b20_lo, bu0, uv);\n            s_lo += cubic_bezier_int_test(bu0, b31_lo, b32_lo, C, uv);\n            s_lo += cubic_bezier_int_test(C, b23_lo, b13_lo, bv0, uv);\n            s_lo += cubic_bezier_int_test(bv0, b02_lo, b01_lo, b00, uv);\n\n            int s_lb = cubic_bezier_int_test(bv0, b13_lo, b23_lo, C, uv);\n            s_lb += cubic_bezier_int_test(C, b31_lb, b32_lb, bu3, uv);\n            s_lb += cubic_bezier_int_test(bu3, b23_lb, b13_lb, b03, uv);\n            s_lb += cubic_bezier_int_test(b03, b02_lb, b01_lb, bv0, uv);\n\n            int s_rb = cubic_bezier_int_test(C, b10_rb, b20_rb, bv3, uv);\n            s_rb += cubic_bezier_int_test(bv3, b31_rb, b32_rb, b33, uv);\n            s_rb += cubic_bezier_int_test(b33, b23_rb, b13_rb, bu3, uv);\n            s_rb += cubic_bezier_int_test(bu3, b32_lb, b31_lb, C, uv);\n\n            vec2 small_c = 0.25*(b11 + b21 + b22 + b12);\n\n            if(s_lo % 2 == 1) {\n                //left bottom\n                col = vec3(1.0, 0.0, 0.0);\n                miu = miu;\n                mau = mau - f;\n                \n                t = vec2(t.x - f, t.y - f);\n\n                vec2 lo = 0.25*(b00 + b10 + b01 + b11);\n                vec2 ro = 0.25*(b10 + b20 + b21 + b11);\n                vec2 lb = 0.25*(b01 + b11 + b12 + b02);\n                \n                //compute control points of quadrant\n                b00_n = b00;\n                b10_n = b10_lo;\n                b20_n = b20_lo;\n                b30_n = bu0;\n\n                b01_n = b01_lo;\n                b11_n = lo;\n                b21_n = 0.5 * (lo + ro); \n                b31_n = b31_lo;\n\n                b02_n = b02_lo;\n                b12_n = 0.5 * (lo + lb);\n                b22_n = 0.25 * (lo + ro + lb + small_c);\n                b32_n = b32_lo;\n\n                b03_n = bv0;\n                b13_n = b13_lo;\n                b23_n = b23_lo;\n                b33_n = C;\n            }\n            else if(s_lb % 2 == 1) {\n                //right bottom\n                col = vec3(0.0, 0.0, 1.0);\n                miu = vec2(miu.x - f, miu.y);\n                mau = vec2(mau.x, mau.y - f);\n\n                t = vec2(t.x - f, t.y + f);\n\n                vec2 lo = 0.25*(b01 + b11 + b12 + b02);\n                vec2 lb = 0.25*(b02 + b12 + b13 + b03);\n                vec2 rb = 0.25*(b12 + b22 + b23 + b13);\n\n                //compute control points of quadrant\n                b00_n = bv0;\n                b10_n = b13_lo;\n                b20_n = b23_lo;\n                b30_n = C;\n\n                b01_n = b01_lb;\n                b11_n = 0.5*(lb + lo);\n                b21_n = 0.25*(lo + lb + rb + small_c); \n                b31_n = b31_lb;\n\n                b02_n = b02_lb;\n                b12_n = lb;\n                b22_n = 0.5*(lb + rb);\n                b32_n = b32_lb;\n\n                b03_n = b03;\n                b13_n = b13_lb;\n                b23_n = b23_lb;\n                b33_n = bu3;\n            }\n            else if(s_rb % 2 == 1) {\n                //right top\n                col = vec3(1.0, 0.0, 1.0);\n                miu = vec2(miu.x + f, miu.y + f);\n                mau = vec2(mau.x, mau.y);\n\n                t = vec2(t.x + f, t.y + f);\n\n                vec2 lb = 0.25*(b12 + b22 + b23 + b13);\n                vec2 ro = 0.25*(b21 + b31 + b32 + b22);\n                vec2 rb = 0.25*(b22 + b32 + b33 + b23);\n\n                //compute control points of quadrant\n                b00_n = C;\n                b10_n = b10_rb;\n                b20_n = b20_rb;\n                b30_n = bv3;\n\n                b01_n = b31_lb;\n                b11_n = 0.25*(lb + ro + rb + small_c);\n                b21_n = 0.5 * (rb + ro); \n                b31_n = b31_rb;\n\n                b02_n = b32_lb;\n                b12_n = 0.5*(rb + lb);\n                b22_n = rb;\n                b32_n = b32_rb;\n\n                b03_n = bu3;\n                b13_n = b13_rb;\n                b23_n = b23_rb;\n                b33_n = b33;\n            }\n            else {\n                //left top\n                col = vec3(0.0, 1.0, 0.0);\n                miu = vec2(miu.x, miu.y + f);\n                mau = vec2(mau.x - f, mau.y);\n\n                t = vec2(t.x + f, t.y - f);\n\n                vec2 lo = 0.25*(b10 + b20 + b21 + b11);\n                vec2 ro = 0.25*(b20 + b30 + b31 + b21);\n                vec2 rb = 0.25*(b21 + b31 + b32 + b22);\n\n                //compute control points of quadrant\n                b00_n = bu0;\n                b10_n = b10_ro;\n                b20_n = b20_ro;\n                b30_n = b30;\n\n                b01_n = b31_lo;\n                b11_n = 0.5*(lo + ro);\n                b21_n = ro; \n                b31_n = b31_ro;\n\n                b02_n = b32_lo;\n                b12_n = 0.25*(lo + ro + rb + small_c);\n                b22_n = 0.5*(ro + rb);\n                b32_n = b32_ro;\n\n                b03_n = C;\n                b13_n = b10_rb;\n                b23_n = b20_rb;\n                b33_n = bv3;\n            }\n\n            \n            b00 = b00_n;\n            b10 = b10_n;\n            b20 = b20_n;\n            b30 = b30_n;\n\n            b01 = b01_n;\n            b11 = b11_n;\n            b21 = b21_n;\n            b31 = b31_n;\n\n            b02 = b02_n;\n            b12 = b12_n;\n            b22 = b22_n;\n            b32 = b32_n;\n\n            b03 = b03_n;\n            b13 = b13_n;\n            b23 = b23_n;\n            b33 = b33_n;\n        }\n    }\n       \n    //compute parametric corners of subpatch\n    vec2 h = vec2(f * 0.5);\n    vec2 miuv = t - h;\n    vec2 mauv = t + h;\n    //do something with it to approximate interpolation? \n    //inverse bilinear does not work because there will still be discontinuties \n    \n    \n    vec3 c1 = vec3(1.0, 0.0, 0.0);\n    vec3 c2 = vec3(0.0, 1.0, 0.0);\n    vec3 c3 = vec3(0.0, 0.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 0.0);\n    \n    //interpolate colour\n    vec3 cd = mix(mix(c1, c2, t.x), \n                   mix(c3, c4, t.x), t.y); \n\n    //comment this to show quadrant debug colours\n    col = cd;\n                   \n    //show control points\n    if(length(uv - B00) < 0.01) col = vec3(0.0);\n    if(length(uv - B10) < 0.01) col = vec3(0.0);\n    if(length(uv - B20) < 0.01) col = vec3(0.0);\n    if(length(uv - B30) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - B01) < 0.01) col = vec3(0.0);\n    if(length(uv - B11) < 0.01) col = vec3(0.0);\n    if(length(uv - B21) < 0.01) col = vec3(0.0);\n    if(length(uv - B31) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - B02) < 0.01) col = vec3(0.0);\n    if(length(uv - B12) < 0.01) col = vec3(0.0);\n    if(length(uv - B22) < 0.01) col = vec3(0.0);\n    if(length(uv - B32) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - B03) < 0.01) col = vec3(0.0);\n    if(length(uv - B13) < 0.01) col = vec3(0.0);\n    if(length(uv - B23) < 0.01) col = vec3(0.0);\n    if(length(uv - B33) < 0.01) col = vec3(0.0);\n    \n    if(mode == 1)\n        col = textureLod(iChannel0, t, 0.).xyz  ;  \n         \n        \n    fragColor = vec4(col, 1.0);\n    //uncomment to show parametrisation\n    //fragColor = vec4(vec3(t, 0.0), 1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltBzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 138, 181, 181, 1196], [1198, 1216, 1265, 1300, 1480], [1482, 1500, 1571, 1571, 2625], [2627, 2627, 2678, 2678, 2796], [2798, 2798, 2853, 2853, 2902], [2904, 2904, 2959, 2959, 3008], [3010, 3010, 3195, 3195, 3424], [3426, 3426, 3483, 3533, 15229]], "test": "untested"}
{"id": "DlXcDr", "name": "Processing Data (CineShader ed.)", "author": "StefanPijnacker", "description": "CineShader version of the Processing Data shader I made some time ago. \nhttps://cineshader.com/view/DlXcDr", "tags": ["2d", "monochrome", "cineshader"], "likes": 14, "viewed": 1329, "published": 3, "date": "1690575854", "time_retrieved": "2024-07-30T17:41:49.065910", "image_code": "float N21(vec2 uv) { return fract(sin(uv.x * 21.281 + uv.y * 93.182) * 5821.92); }\n\nfloat line(vec2 uv) { return smoothstep(0.0, 0.05, uv.x) - smoothstep(0.0, 0.95, uv.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    \n    vec2 offset = abs(uv.yx) / vec2(30., 5.2);\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    \n    vec2 scale = vec2(128, 90);\n    \n    vec2 lUV = fract(uv * scale);\n    vec2 gID = floor(uv * scale);\n\n    float rowNoise = N21(vec2(0.0, gID.y));\n    float dir = ((rowNoise * 2.0) - 1.0) + 0.2;\n    gID.x += floor(iTime * dir * 30.);\n    \n    float cellNoise = N21(gID);\n    float drawBlock = float(cellNoise > 0.38);\n    int even = int(gID.y) % 2;\n\n    vec3 col = vec3(line(lUV)) * drawBlock * float(even);\n    col *= fract(sin(gID.y)) + 0.24;\n    col *= vec3(0.224,0.996,0.557);\n    \n    fragColor = vec4(vec3(col), col.g * 0.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 82], [84, 84, 105, 105, 173], [175, 175, 232, 232, 941]], "test": "untested"}
{"id": "ctXyDr", "name": "Curve Visualization Blend Modes", "author": "Chrisy", "description": "Credit to IQ for anti aliased Curve plot , hsv ( edited)\nCredit Branchless Blend Modes https://www.shadertoy.com/view/Md3GzX", "tags": ["curvelines2dplotblendmodesphotoshopchris"], "likes": 3, "viewed": 171, "published": 3, "date": "1690573724", "time_retrieved": "2024-07-30T17:41:49.894694", "image_code": "#define ctiles  4.0 \n#define cgrid 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float dx = 1.0/iResolution.y;\n\n     col = vec3(0.0);\n\n    \n    vec2 tileduv = mod(uv*ctiles,vec2(1.0));\n    int idxy = int(uv.y*ctiles)*int(ctiles);\n    int idxx = int(uv.x*ctiles);\n    int idx = idxx+idxy;\n    \n    vec3 ix = vec3(tileduv.x);vec3 iy = vec3(tileduv.y-.2)*1.25;\n    col = vec3( 0.2 + 0.02*mod(floor(ix*cgrid)+floor(iy*cgrid),2.0) );\n    if(tileduv.y<0.2){\n        col = plotA(ix,iTime,idx);\n    }else{\n    \n        vec3 y = plotA( ix,iTime,idx);\n        vec3 dy = plotA(ix-dx,iTime,idx) - y;\n        vec3 di = iy-y;\n        col = mix( col, vec3(1), smoothstep(1., 0., abs(di)/fwidth(di) ) );\n    }\n    //col.x = float(idx==0?1:0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\n#define DEG2RAD 0.03926990816987241548078304229099\n\n\n\nvec3 multiply(in vec3 src, in vec3 dst)\n{\n\treturn src * dst;\n}\n\nvec3 screen(in vec3 src, in vec3 dst)\n{\n    return src + dst - src * dst;\n}\n\nvec3 exclusion(in vec3 src, in vec3 dst)\n{\n    return dst + src - (2.0*dst*src);;\n}\n\nvec3 overlay(in vec3 src, in vec3 dst)\n{\n    return mix(2.0 * src * dst, 1.0 - 2.0 * (1.0 - src) * (1.0-dst), step(0.5, dst));\n}\n\nvec3 hardlight(in vec3 src, in vec3 dst)\n{\n    return mix(2.0 * src * dst,  1.0 - 2.0 * (1.0 - src) * (1.0-dst), step(0.5, src));\n}\n\nvec3 softlight(in vec3 src, in vec3 dst)\n{\n    return mix(dst - (1.0 - 2.0 * src) * dst * (1.0 - dst), \n               mix(dst + ( 2.0 * src - 1.0 ) * (sqrt(dst) - dst),\n                   dst + (2.0 * src - 1.0) * dst * ((16.0 * dst - 12.0) * dst + 3.0),\n                   step(0.5, src) * (1.0 - step(0.25, dst))),\n               step(0.5, src));\n}\n\nvec3 colorDodge(in vec3 src, in vec3 dst)\n{\n    return step(0.0, dst) * mix(min(vec3(1.0), dst/ (1.0 - src)), vec3(1.0), step(1.0, src)); \n}\n\nvec3 colorBurn(in vec3 src, in vec3 dst)\n{\n    return mix(step(0.0, src) * (1.0 - min(vec3(1.0), (1.0 - dst) / src)),\n        vec3(1.0), step(1.0, dst));\n}\n\nvec3 linearDodge(in vec3 src, in vec3 dst)\n{\n    return clamp(src.xyz + dst.xyz, 0.0, 1.0);\n}\n\nvec3 linearBurn(in vec3 src, in vec3 dst)\n{\n    return clamp(src.xyz + dst.xyz - 1.0, 0.0, 1.0);\n}\n\nvec3 vividLight(in vec3 src, in vec3 dst)\n{\n    return mix(max(vec3(0.0), 1.0 - min(vec3(1.0), (1.0 - dst) / (2.0 * src))),\n               min(vec3(1.0), dst / (2.0 * (1.0 - src))),\n               step(0.5, src));\n}\n\nvec3 linearLight(in vec3 src, in vec3 dst)\n{\n    return clamp(2.0 * src + dst - 1.0, 0.0, 1.0);;\n}\n\nvec3 pinLight(in vec3 src, in vec3 dst)\n{\n    return mix(mix(2.0 * src, dst, step(0.5 * dst, src)),\n        max(vec3(0.0), 2.0 * src - 1.0), \n        step(dst, (2.0 * src - 1.0))\n    );\n}\n\nvec3 hardMix(in vec3 src, in vec3 dst)\n{\n    return step(1.0, src + dst);\n}\n\nvec3 subtract(in vec3 src, in vec3 dst)\n{\n    return dst - src;\n}\n\nvec3 divide(in vec3 src, in vec3 dst)\n{\n    return dst / src;\n}\n\nvec3 addition(vec3 src, vec3 dst)\n{\n    return src + dst;\n}\n\nvec3 difference(in vec3 src, in vec3 dst )\n{\n    return abs(dst - src);   \n}\n\nvec3 darken(in vec3 src, in vec3 dst)\n{\n    return min(src, dst);\n}\n\nvec3 lighten(in vec3 src, in vec3 dst)\n{\n    return max(src, dst);\n}\n\nvec3 invert(in vec3 src, in vec3 dst)\n{\n    return 1.0 - dst;\n}\n\nvec3 invertRGB(in vec3 src, in vec3 dst)\n{\n    return src * (1.0 - dst);\n}\n\nvec3 source(in vec3 src, in vec3 dst)\n{\n\treturn src;\n}\n\nvec3 dest(in vec3 src, in vec3 dst)\n{\n\treturn dst;\n}\n\n// Branchless RGB2HSL implementation from : https://www.shadertoy.com/view/MsKGRW\nvec3 rgb2hsl( in vec3 c )\n{\n    const float epsilon = 0.00000001;\n    float cmin = min( c.r, min( c.g, c.b ) );\n    float cmax = max( c.r, max( c.g, c.b ) );\n\tfloat cd   = cmax - cmin;\n    vec3 hsl = vec3(0.0);\n    hsl.z = (cmax + cmin) / 2.0;\n    hsl.y = mix(cd / (cmax + cmin + epsilon), cd / (epsilon + 2.0 - (cmax + cmin)), step(0.5, hsl.z));\n\n    vec3 a = vec3(1.0 - step(epsilon, abs(cmax - c)));\n    a = mix(vec3(a.x, 0.0, a.z), a, step(0.5, 2.0 - a.x - a.y));\n    a = mix(vec3(a.x, a.y, 0.0), a, step(0.5, 2.0 - a.x - a.z));\n    a = mix(vec3(a.x, a.y, 0.0), a, step(0.5, 2.0 - a.y - a.z));\n    \n    hsl.x = dot( vec3(0.0, 2.0, 4.0) + ((c.gbr - c.brg) / (epsilon + cd)), a );\n    hsl.x = (hsl.x + (1.0 - step(0.0, hsl.x) ) * 6.0 ) / 6.0;\n    return hsl;\n}\n\n// HSL2RGB thanks to IQ : https://www.shadertoy.com/view/lsS3Wc\nvec3 hsl2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hue(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(srcHSL.r, dstHSL.gb));\n}\n\nvec3 saturation(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(dstHSL.r, srcHSL.g, dstHSL.b));\n}\n\nvec3 color(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(srcHSL.rg, dstHSL.b));\n}\n\nvec3 luminosity(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(dstHSL.rg, srcHSL.b));\n}\nvec3 blend(in vec3 src, in vec3 dst, in int mode)\n{\n    //if (mode == )  return source(src, dst);\n    //if (mode == )  return dest(src, dst);\n    if (mode == 0)  return screen(src, dst);\n    if (mode == 1)  return multiply(src, dst);\n    if (mode == 2)  return overlay(src, dst);\n    if (mode == 3)  return hardlight(src, dst);\n    if (mode == 4)  return softlight(src, dst);\n    if (mode == 5)  return colorDodge(src, dst);\n    if (mode == 6)  return colorBurn(src, dst);\n    if (mode == 7)  return linearDodge(src, dst);\n    if (mode == 8)  return linearBurn(src, dst);\n    if (mode == 9)  return vividLight(src, dst);\n    if (mode == 10) return linearLight(src, dst);\n    if (mode == 11) return pinLight(src, dst);\n    if (mode == 12) return hardMix(src, dst);\n    if (mode == 13) return subtract(src, dst);\n    if (mode == 14) return divide(src, dst);\n    if (mode == 15) return addition(src, dst);\n    if (mode == 16) return difference(src, dst);\n    if (mode == 17) return darken(src, dst);\n    if (mode == 18) return lighten(src, dst);\n    if (mode == 19) return invert(src, dst);\n    if (mode == 20) return invertRGB(src, dst);\n    if (mode == 21) return hue(src, dst);\n    if (mode == 22) return saturation(src, dst);\n    if (mode == 23) return color(src, dst);\n    if (mode == 24) return luminosity(src, dst);\n    if (mode == 25) return exclusion(src, dst);\n    return vec3(0.0,0.0,0.0);\n}\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    //c*= vec3(0.01666666666,0.01,0.01); // mapping to photoshop\n    c*= vec3(6.0,1.0,1.0); // mapping to 0..1\n    vec3 rgb = clamp( abs(mod(c.x+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    c*= vec3(0.01666666666,0.01,0.01); // mapping to photoshop\n    //c*= vec3(6.0,1.0,1.0); // mapping to 0..1\n    vec3 rgb = clamp( abs(mod(c.x+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvec3 p22( vec3 c )\n{\n    return pow(c,vec3(2.2));\n}\nvec3 p045( vec3 c )\n{\n    return pow(c,vec3(0.454545));\n}\nvec3 plotA ( vec3 c,float time,int idx)\n{\n\nfloat t = 0.5 + 0.5*cos(time*0.075); \n\n//c = p22(c);\n//c*=hsv2rgb(vec3(0.,1.,1.0));\n//c = p045(c);\n//c=1.0-hsv2rgb(vec3(180.,0.5,1.0));\nc= blend(c,hsv2rgb(vec3(180.,0.0,0.75)),idx);\n\nreturn c;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 97, 147, 984]], "test": "untested"}
{"id": "dlsyR7", "name": "a bird [317 chars]", "author": "iY0Yi", "description": "it's a bird. they was rebranded with boxes instead of circles.", "tags": ["x", "bird", "golf", "alive"], "likes": 22, "viewed": 502, "published": 3, "date": "1690549121", "time_retrieved": "2024-07-30T17:41:50.756390", "image_code": "// @Xor 317 chars\nvoid mainImage( out vec4 O, vec2 C)\n{\n    float T=smoothstep(1.,5.,mod(iTime,6.)),V;\n    vec2 U=fract(C/iResolution.x+vec2(T,.225-T))-.5,\n    F=vec2(U.y*.8,0),\n    P=abs(U+F);\n    V=max(P.x-.04,P.y-.2);\n    P=abs(U*mat2(cos(vec4(0,11,33,0)+sign(U.y)*sin(T*94.25)))-F);\n    O=vec4(min(min( max(-V, max(P.x,P.y-.2)), abs(V) ), length(U+vec2(.13,-.16))))*5e2-5.;\n}\n\n/* original 338 chars\nvoid mainImage( out vec4 O, vec2 C ){\n    float T=smoothstep(1.,5.,mod(iTime,6.)),V;\n    vec2 U=fract(C.xy/iResolution.x-vec2(-T,T-.225))-.5,\n    F=vec2(U.y*.8,0),\n    P=abs(U+F)-vec2(.04,.2);\n    V=max(P.x,P.y);\n    P=abs(U*mat2(cos(vec4(0,11,33,0)+sign(U.y)*sin(T*94.25)))-F)-vec2(0,.2);\n    O=vec4(\n        step(.01, min(min( max(-V, max(P.x,P.y)), abs(V) ), length(U-vec2(-.13,.16))))\n    );\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 55, 55, 379]], "test": "untested"}
{"id": "DllyR7", "name": "Test2-MrFuzz32", "author": "MrFuzz32", "description": "test2", "tags": ["test"], "likes": 0, "viewed": 154, "published": 3, "date": "1690535359", "time_retrieved": "2024-07-30T17:41:51.868418", "image_code": "vec3 palette(float t){\n    vec3 a = vec3(0.968, 1.118, 1.278);\n    vec3 b = vec3(0.268, 0.318, 0.448);\n    vec3 c = vec3(-0.342, -0.162, 0.158);\n    vec3 d = vec3(-0.582, -0.452, -0.452);\n\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Conform pixel coordinates to -1 to 1, and adjust for aspect ratio\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 finalColour = vec3(0.0);\n\n    vec3 col = palette((abs(uv.y)-0.5)*(sin(iTime/4.0)*4.0));\n    col *= 0.03/(abs(sin(uv.x*(sin(iTime/8.0)-0.0)*13.0)-uv.y*3.0));\n\n    finalColour += col;\n    // Output to screen\n    fragColor = vec4(finalColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 229], [232, 232, 289, 361, 683]], "test": "untested"}
{"id": "DlsczM", "name": "VoronoiseWithIntHash", "author": "programmerwho", "description": "VoronoiseWithIntHash", "tags": ["2d"], "likes": 0, "viewed": 145, "published": 3, "date": "1690534401", "time_retrieved": "2024-07-30T17:41:52.855777", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float  GridMaxRandom = 0.9;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 XY = fragCoord/iResolution.xy;\n    XY=XY*20.;\n\n\n    vec2 GridPos = floor(XY);\n    vec2 GridOffset = fract(XY);\n    vec2 tempResult = vec2(0.0,0.0);\n    for(int i = -1;i <= 1; i ++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            vec2 currGridPos = GridPos + vec2(i, j);\n            \n            uvec2 p = uvec2(currGridPos);\n            uint n = p.x + 1920U*p.y;\n            \n            n = (n << 13U) ^ n;\n            n = n * (n * n * 15731U + 789221U) + 1376312589U;\n            uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n            vec3 hashPos = vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n    \n            vec3 hashPointInfo = hashPos*vec3(GridMaxRandom,GridMaxRandom,1.0);\n            vec2 currPointLocation = hashPointInfo.xy + vec2(i, j);\n            float distanceRatio = pow(clamp(1.4-dot((GridOffset - currPointLocation),(GridOffset - currPointLocation)), 0.0, 1.4),64.0);\n            tempResult += vec2(hashPointInfo.z*distanceRatio,distanceRatio);\n        }\n    }\n\n    // Time varying pixel color\n    vec3 col = vec3(tempResult.x/tempResult.y,tempResult.x/tempResult.y,tempResult.x/tempResult.y);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1316]], "test": "untested"}
{"id": "DllczM", "name": "Test-MrFuzz32", "author": "MrFuzz32", "description": "It's a test", "tags": ["test"], "likes": 1, "viewed": 158, "published": 3, "date": "1690533359", "time_retrieved": "2024-07-30T17:41:53.626715", "image_code": "vec3 palette(float t){\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Conform pixel coordinates to -1 to 1, and adjust for aspect ratio\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColour = vec3(0.0);\n\n    for(float i = 0.0; i < 4.0; i++){\n        uv = fract(uv*1.2) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime/6.);\n\n\n        d = sin(d*30.0 + iTime/3.0)/8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d,1.3);\n\n        finalColour += col*d;\n    }\n    // Output to screen\n    fragColor = vec4(finalColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 206], [209, 209, 266, 338, 838]], "test": "untested"}
{"id": "dtXcz7", "name": "Zellij pattern 16 (music)", "author": "jarble", "description": "A zellij tile pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "zellige"], "likes": 6, "viewed": 208, "published": 3, "date": "1690523019", "time_retrieved": "2024-07-30T17:41:54.537281", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a+fract(a*2.+.5)/2.)\n        //fract(a+fract(a*2.+.5)/2.)\n        //fract(a-fract(a*4.)/2.)\n        //min(abs(fract(a)-.5),abs(fract(a*2.)-.5))\n        //fract(a-.5+mod(floor(a.x*2.),2.)/2.)\n        //abs(fract(a)-fract(-a/2.)/2.)\n        //abs(fract(a)-abs(.5-fract(a)))\n    ;\n}\n\nvec2 triangle_wave1(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //-vec2(1.,0.5)\n        //vec2(1.-sign(a.x)/2.,0.5+sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    return\n        triangle_wave1(a)\n        //triangle_wave1(a-triangle_wave1(a+.5)/1.5)\n        //triangle_wave1(a+.5*floor(a.x))\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1/2.0;\n    //if(iMouse.z>.5)\n    //uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 5; k++){\n        //if(uv.x<uv.y && k%5 == 0) {uv = -uv;}\n\n    \n        //uv.x += float(int(uv.x*2.)<<2)/8.;\n        //k += int(uv.y>uv.x);\n\n        //if(uv.y>0.) uv.x += .5;\n        //else uv.y += .5;\n        \n        uv =\n            abs(.5+uv+t2)/1.5\n            //abs(.5*sign(t2.x-t2.y)+uv+t2)/1.5\n            //(uv+t2)/1.5\n            //abs(.5+uv*mod(floor(-uv.x*4.),2.)+t2)/1.5\n        ;\n        //uv += sign(uv-uv.yx)/2.+.5;\n        if(uv.y>uv.x)\n            uv = uv.yx\n            //uv.x += .5\n            //uv.y -= .5\n        ;\n        //else k += 1;\n\n        t2 =\n            triangle_wave(uv+.5)\n            //-triangle_wave(uv-.5*sign(uv.x-.5)-sign(t2.x-.5))\n            //-triangle_wave(uv-.5)*sign(.5-uv.x)\n        ;\n        //if(t2.y>t2.x) t2 = t2.yx;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2+triangle_wave(uv.yx-floor(.5+t2.y+t2.x))\n        ;\n        \n        //uv += (uv-ceil(uv));\n        //if(t2.y<uv.x)\n        //if(uv.x<uv.y) uv.x /= 1.5;\n        //if(t2.y>t2.x) t2 -= .5;\n\n        {t2 =\n            -t2.yx\n            //t2.yx*(1.+mod(floor(uv.y),2.)/2.)\n        ;\n        uv=-uv.yx;}\n\n        \n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n            //abs(vec3(col.zx,max(uv.y-uv.x,-col.y)))\n        ;\n        //if(uv.x<uv.y && k%2 == 0) {uv = -uv;break;}\n\n        //if(uv.x>uv.y) col=col.yzx;\n        //uv /= 1.+mod(uv.y,2.);\n        //if(uv.x>t2.x-.25) uv.x /= 1.5;\n    }\n    fragColor = vec4(col*4.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod(float a, float b){\n    //a += floor(a/b)/8.;\n    a /= (1. + floor(mod(a*8.,2.)))/4.;\n    return\n        mod((floor(a)+mod(floor(a*2.),b))/2.,b)\n        //floor(mod((floor(a)/4.+mod(floor(a*2.)/4.,b))/2.,b))\n        //mod((floor(a)+mod(floor(a/2.),b*2.))/2.,b)\n        //mod(mod(floor(a+4.),floor(a/16.+4.)),b)\n    ;\n}\n\nvec2 song(float t){\n  float tempo = 2.;\n  t /= tempo;\n  float s1 =\n      8.\n  ;\n  float p1 = 1. + floor(mod((1.+t/4.)/2.,2.));\n  t *= p1/2.;\n  \n  float a=\n      8.*pow(fract(-t*p1),2.),\n      //pow((1.-log(fract(t*p1)*2.)),2.),\n  nb = t*tempo*pow(2.,(2.+fmod(t*2.,s1)+1. + fmod(floor(t/s1),2.))*2./5.+6.5);\n  return\n      vec2(a,nb)\n  ;\n}\n\nvec2 mainSound(int samp, float t){\n  vec2 s =\n      song(t)\n   ;\n  \n  float a=\n      s.x\n  ,\n  nb =\n      s.y;\n  return\n      (abs(.5-abs(vec2(fract(nb/2.),fract(nb)))))*a\n      \n      //(abs(a/8.-abs(.5-vec2(fract((a/8.+nb)*.998/2.),fract(a/8.+nb)))*a))\n      \n      //abs(a/16.-(abs(.5-abs(vec2(fract(nb/2.),fract(nb)))))*a)\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXcz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 321], [323, 323, 351, 351, 536], [538, 538, 565, 565, 705], [707, 707, 764, 764, 2643]], "test": "untested"}
{"id": "dlfyR7", "name": "BLEND 2", "author": "tianluo970922", "description": "BLEND 2", "tags": ["blend2"], "likes": 0, "viewed": 107, "published": 3, "date": "1690517282", "time_retrieved": "2024-07-30T17:41:55.380028", "image_code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //cubicPulse动态混合过程\n    //earthmap\n    float divisionLine1 = 1.3/19.0 + 0.02;\n    //digital hardware\n    float divisionLine2 = 3.5/19.0;\n    //machine social network\n    float divisionLine3 = 6.6/19.0;\n    //FE\n    float divisionLine4 = 10.0/19.0;\n    //operation center\n    float divisionLine5 = 13.0/19.0 - 0.01;\n    //logo\n    float divisionLine6 = 16.0/19.0;\n    \n    float divisonTime;\n    float divisionLine;\n    int count; \n    \n    count = 1;\n    \n    //from earthmap to digital hardware\n    if(count == 1){\n    divisionLine = divisionLine1 + (divisionLine2 - divisionLine1) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from digital hardware to machine social network\n    if(count == 2){\n    divisionLine = divisionLine2 + (divisionLine3 - divisionLine2) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from machine social network to FE\n    if(count == 3){\n    divisionLine = divisionLine3 + (divisionLine4 - divisionLine3) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from FE to operation center\n    if(count == 4){\n    divisionLine = divisionLine4 + (divisionLine5 - divisionLine4) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from operation center to logo\n    if(count == 5){\n    divisionLine = divisionLine5 + (divisionLine6 - divisionLine5) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    float d = cubicPulse(divisionLine,0.21,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //加上标识曲线\n    //maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    //深色色板\n    float PI = 3.1415926;\n    float time = iTime * 0.015; \n    float scale = 0.5;\n    \n    vec4 vcolor0 = vec4(0.180,0.427,1.000,1.0);\n    vec4 vcolor1 = vec4(0.259,0.459,1.000,1.0);\n    vec4 vcolor2 = vec4(0.561,0.678,1.000,1.0);\n    vec4 vcolor3 = vec4(1.000,0.573,0.341,1.0);\n    vec4 vcolor4 = vec4(1.000,0.749,0.502,1.0);\n    \n    float step0 = 0.2 * scale;\n    float step1 = 0.45 * scale;\n    float step2 = 0.65 * scale;\n    float step3 = 0.8  * scale;\n    \n    float offset = uv.x-0.35-time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor; \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    darkColor = correct(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    //darkColor = correct(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor3, dist2);\n    //darkColor = correct(vcolor2, vcolor3, dist2);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    darkColor = mix(vcolor3, vcolor4, dist02);\n    darkColor = correct(vcolor3, vcolor4, dist02);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    darkColor = mix(vcolor4, vcolor0, dist3);\n    //darkColor = correct(vcolor4, vcolor0, dist3);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //浅色色板\n    float qscale = 0.25;\n    float qtime = iTime* 0.015;\n    \n    float qstep0 = 0.15 * qscale;\n    float qstep1 = 0.35 * qscale;\n    float qstep2 = 0.45 * qscale;\n    float qstep3 = 0.65 * qscale;\n    \n    vec4 qcolor0 = vec4(0.502,0.651,1.000,1.0);\n    float brightness = 0.15;\n\tfloat contrast = 1.0;\n    float saturation = 1.0;\n    qcolor0 = saturationMatrix(saturation) * qcolor0; \n    brightnessAdjust(qcolor0, brightness); \n    contrastAdjust(qcolor0, contrast); \n    \n    vec4 qcolor1 = vec4(0.502,0.651,1.000,1.0);\n    float brightness1 = 0.15;\n\tfloat contrast1 = 1.0;\n    float saturation1 = 1.0;\n    qcolor1 = saturationMatrix(saturation1) * qcolor1; \n    brightnessAdjust(qcolor1, brightness1); \n    contrastAdjust(qcolor1, contrast1); \n    \n    vec4 qcolor2 = vec4(0.600,0.702,1.000,1.0);\n    float brightness2 = 0.15;\n\tfloat contrast2 = 1.0;\n    float saturation2 = 1.0;\n    qcolor2 = saturationMatrix(saturation2) * qcolor2; \n    brightnessAdjust(qcolor2, brightness2); \n    contrastAdjust(qcolor2, contrast2); \n    \n    vec4 qcolor3 = vec4(0.600,0.702,1.000,1.0);\n    float brightness3 = 0.15;\n\tfloat contrast3 = 1.0;\n    float saturation3 = 1.;\n    qcolor3 = saturationMatrix(saturation3) * qcolor3; \n    brightnessAdjust(qcolor3, brightness3); \n    contrastAdjust(qcolor3, contrast3); \n    \n    vec4 qcolor4 = vec4(1.000,1.000,1.000,1.0);\n    float brightness4 = 0.15;\n\tfloat contrast4 = 1.0;\n    float saturation4 = 1.;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4); \n    \n    float qoffset = uv.x-qtime;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    lightColor = vec4(dist0);\n    lightColor = mix(qcolor0, qcolor1, dist0);\n    lightColor = correct(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    //lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    lightColor = correct(qcolor1, qcolor2, dist1);\n    }\n    \n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    //lightColor = vec4(dist2);\n    lightColor = mix(qcolor2, qcolor3, dist2);\n    lightColor = correct(qcolor2, qcolor3, dist2);\n    }\n    \n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    //lightColor = vec4(dist02);\n    lightColor = mix(qcolor3, qcolor4, dist02);\n    lightColor = correct(qcolor3, qcolor4, dist02);\n    }\n    \n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    lightColor = vec4(dist3);\n    lightColor = mix(qcolor4, qcolor0, dist3);\n    lightColor = correct(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    \n    //start to move\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //adding mask\n    float endMask = smoothstep(0.6,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    //night激活状态\n    vec4 nightColor1 = vec4(0.000,0.067,0.259,1.0);\n    vec4 nightColor0 = vec4(0.000,0.165,0.620,1.0);\n    vec4 nightColor = mix(nightColor0, nightColor1, pow(uv.x,1.));\n    nightColor = sqrt(nightColor);\n    \n    //iStart是一个从零逐步增加的时间，点击之后时间从零开始累加\n    float iStart = 5.0;\n    \n    //night to awake\n\tfragColor = mix(nightColor, fragColor, smoothstep(0.0,1.0,iStart*0.2));\n    \n    //Debug\n    //fragColor = vec4(maskColor,1.0);\n    //fragColor = vec4(lightColor);\n    //fragColor = vec4(darkColor);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n    if (uv.y<-0.1&&uv.y > -1.2){\n    fragColor = vec4(darkColor);\n    }\n    if (uv.y<-1.3&&uv.y > -2.4){\n    fragColor = vec4(lightColor);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 92, 92, 189], [191, 191, 237, 237, 331], [333, 333, 364, 364, 455], [457, 457, 500, 500, 943], [945, 945, 999, 999, 1021], [1023, 1023, 1075, 1075, 1142], [1144, 1144, 1168, 1168, 1198], [1200, 1200, 1223, 1223, 1546], [1548, 1636, 1739, 1739, 4277], [4279, 4279, 4336, 4373, 11925]], "test": "untested"}
{"id": "dtfyR7", "name": "BLEND 5", "author": "tianluo970922", "description": "BLEND 5", "tags": ["blend5"], "likes": 0, "viewed": 99, "published": 3, "date": "1690517182", "time_retrieved": "2024-07-30T17:41:56.393318", "image_code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    float divisionLine;\n    divisionLine = fract(iTime * 0.02);\n    float d = cubicPulse(divisionLine,0.16,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //混合遮罩\n    //maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    //深色色板 分成三段\n    float PI = 3.1415926;\n    float time = iTime * 0.; \n    float scale = 1.;\n    \n    vec4 vcolor0 = vec4(0.000,0.298,1.000,1.0);\n    vec4 vcolor1 = vec4(0.322,0.502,1.000,1.0);\n    vec4 vcolor2 = vec4(0.000,0.192,0.722,1.0);\n    \n    float step0 = 0.2 * scale;\n    float step1 = 0.4 * scale;\n    float step2 = 0.6 * scale;\n\n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor;\n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor0,dist2);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //darkColorMask\n    float darkMaskd = cubicPulse(divisionLine,0.24,uv.x);\n    vec3 darkMaskColor = vec3(darkMaskd);\n    float darkMaskpct = plot(uv,darkMaskd);\n    \n    vec3 darkColorMask = darkMaskColor+darkMaskpct*vec3(0.0,1.0,0.0);\n    darkColor = mix(darkColor,vec4(0.361,0.639,1.000,1.),darkColorMask.r);\n    \n    \n    //浅色色板\n    float qscale = 0.25;\n    float qtime = iTime * 0.;\n    \n    float qstep0 = 0.05 * qscale;\n    float qstep1 = 0.25 * qscale;\n    float qstep2 = 0.45 * qscale;\n    float qstep3 = 0.75 * qscale;\n    \n    vec4 qcolor0 = vec4(0.722,0.804,1.000,1.0);\n    vec4 qcolor1 = vec4(0.722,0.804,1.000,1.0);\n    vec4 qcolor2 = vec4(1.000,0.616,0.522,1.0);\n    vec4 qcolor3 = vec4(1.000,0.933,0.702,1.0);\n    vec4 qcolor4 = vec4(1.000,1.000,1.000,1.0);\n    \n    float brightness4 = 0.15;\n\tfloat contrast4 = 1.0;\n    float saturation4 = 1.;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4); \n    \n    float qoffset = uv.x- 0.15;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    //lightColor = vec4(dist0);\n    //lightColor = mix(qcolor0, qcolor1, dist0);\n    lightColor = correct(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    //lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    lightColor = correct(qcolor1, qcolor2, dist1);\n    }\n    \n    //蓝到橙色\n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    //lightColor = mix(qcolor2, qcolor3, dist2);\n    lightColor = correct(qcolor2, qcolor3, dist2);\n    }\n    \n    //橙色到黄色\n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    //lightColor = vec4(dist02);\n    //lightColor = mix(qcolor3, qcolor4, dist02);\n    lightColor = correct(qcolor3, qcolor4, dist02);\n    }\n    \n    //黄色到白色\n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    //lightColor = vec4(dist3);\n    //lightColor = mix(qcolor4, qcolor0, dist3);\n    lightColor = correct(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    //lightColor = vec4(1.0);\n    \n    //通过混合遮罩进行混合\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //ending mask mask\n    float endMask = smoothstep(0.62,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    //fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 92, 92, 189], [191, 191, 237, 237, 331], [333, 333, 364, 364, 455], [457, 457, 500, 500, 943], [945, 945, 999, 999, 1021], [1023, 1023, 1075, 1075, 1142], [1144, 1144, 1168, 1168, 1198], [1200, 1200, 1223, 1223, 1546], [1548, 1636, 1739, 1739, 4277], [4279, 4279, 4336, 4374, 8783]], "test": "untested"}
{"id": "mtXyR7", "name": "BLEND 4", "author": "tianluo970922", "description": "BLEND 4", "tags": ["blend4"], "likes": 0, "viewed": 90, "published": 3, "date": "1690516561", "time_retrieved": "2024-07-30T17:41:57.679878", "image_code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //cubicPulse动态混合过程\n    //earthmap\n    float divisionLine1 = 1.3/19.0 + 0.02;\n    //digital hardware\n    float divisionLine2 = 3.5/19.0;\n    //machine social network\n    float divisionLine3 = 6.6/19.0;\n    //FE\n    float divisionLine4 = 10.0/19.0;\n    //operation center\n    float divisionLine5 = 13.0/19.0 - 0.01;\n    //logo\n    float divisionLine6 = 16.0/19.0;\n    \n    float divisonTime;\n    float divisionLine;\n    int count; \n    \n    count = 1;\n    \n    //from earthmap to digital hardware\n    if(count == 1){\n    divisionLine = divisionLine1 + (divisionLine2 - divisionLine1) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from digital hardware to machine social network\n    if(count == 2){\n    divisionLine = divisionLine2 + (divisionLine3 - divisionLine2) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from machine social network to FE\n    if(count == 3){\n    divisionLine = divisionLine3 + (divisionLine4 - divisionLine3) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from FE to operation center\n    if(count == 4){\n    divisionLine = divisionLine4 + (divisionLine5 - divisionLine4) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from operation center to logo\n    if(count == 5){\n    divisionLine = divisionLine5 + (divisionLine6 - divisionLine5) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //不靠按钮让division line动起来\n    divisionLine = fract(iTime * 0.1);\n    float d = cubicPulse(divisionLine,0.21,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //加上标识曲线\n    //maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    //深色色板\n    float PI = 3.1415926;\n    float time = iTime * 0.015; \n    float scale = 0.5;\n    \n    vec4 vcolor0 = vec4(0.078,0.357,1.000,1.0);\n    vec4 vcolor1 = vec4(0.102,0.369,1.000,1.0);\n    vec4 vcolor2 = vec4(0.561,0.678,1.000,1.0);\n    vec4 vcolor3 = vec4(1.000,0.616,0.522,1.0);\n    vec4 vcolor4 = vec4(1.000,0.906,0.702,1.0);\n    \n    float step0 = 0.2 * scale;\n    float step1 = 0.50 * scale;\n    float step2 = 0.65 * scale;\n    float step3 = 0.8  * scale;\n    \n    float offset = uv.x-0.35-time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor; \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    darkColor = correct(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    //darkColor = correct(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor3, dist2);\n    //darkColor = correct(vcolor2, vcolor3, dist2);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    darkColor = mix(vcolor3, vcolor4, dist02);\n    darkColor = correct(vcolor3, vcolor4, dist02);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    darkColor = mix(vcolor4, vcolor0, dist3);\n    //darkColor = correct(vcolor4, vcolor0, dist3);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //浅色色板\n    float qscale = 0.25;\n    float qtime = iTime* 0.015;\n    \n    float qstep0 = 0.15 * qscale;\n    float qstep1 = 0.35 * qscale;\n    float qstep2 = 0.45 * qscale;\n    float qstep3 = 0.65 * qscale;\n    \n    vec4 qcolor0 = vec4(0.502,0.651,1.000,1.0);\n    float brightness = 0.15;\n\tfloat contrast = 1.0;\n    float saturation = 1.0;\n    qcolor0 = saturationMatrix(saturation) * qcolor0; \n    brightnessAdjust(qcolor0, brightness); \n    contrastAdjust(qcolor0, contrast); \n    \n    vec4 qcolor1 = vec4(0.502,0.651,1.000,1.0);\n    float brightness1 = 0.15;\n\tfloat contrast1 = 1.0;\n    float saturation1 = 1.0;\n    qcolor1 = saturationMatrix(saturation1) * qcolor1; \n    brightnessAdjust(qcolor1, brightness1); \n    contrastAdjust(qcolor1, contrast1); \n    \n    vec4 qcolor2 = vec4(0.600,0.702,1.000,1.0);\n    float brightness2 = 0.15;\n\tfloat contrast2 = 1.0;\n    float saturation2 = 1.0;\n    qcolor2 = saturationMatrix(saturation2) * qcolor2; \n    brightnessAdjust(qcolor2, brightness2); \n    contrastAdjust(qcolor2, contrast2); \n    \n    vec4 qcolor3 = vec4(0.600,0.702,1.000,1.0);\n    float brightness3 = 0.15;\n\tfloat contrast3 = 1.0;\n    float saturation3 = 1.;\n    qcolor3 = saturationMatrix(saturation3) * qcolor3; \n    brightnessAdjust(qcolor3, brightness3); \n    contrastAdjust(qcolor3, contrast3); \n    \n    vec4 qcolor4 = vec4(0.878,0.918,1.000,1.0);\n    float brightness4 = 0.15;\n\tfloat contrast4 = 1.0;\n    float saturation4 = 1.;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4); \n    \n    float qoffset = uv.x-qtime;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    lightColor = vec4(dist0);\n    lightColor = mix(qcolor0, qcolor1, dist0);\n    lightColor = correct(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    //lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    lightColor = correct(qcolor1, qcolor2, dist1);\n    }\n    \n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    //lightColor = vec4(dist2);\n    lightColor = mix(qcolor2, qcolor3, dist2);\n    lightColor = correct(qcolor2, qcolor3, dist2);\n    }\n    \n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    //lightColor = vec4(dist02);\n    lightColor = mix(qcolor3, qcolor4, dist02);\n    lightColor = correct(qcolor3, qcolor4, dist02);\n    }\n    \n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    lightColor = vec4(dist3);\n    lightColor = mix(qcolor4, qcolor0, dist3);\n    lightColor = correct(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    \n    //start to move\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //adding mask\n    float endMask = smoothstep(0.6,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    //night激活状态\n    vec4 nightColor1 = vec4(0.000,0.067,0.259,1.0);\n    vec4 nightColor0 = vec4(0.000,0.165,0.620,1.0);\n    vec4 nightColor = mix(nightColor0, nightColor1, pow(uv.x,1.));\n    nightColor = sqrt(nightColor);\n    \n    //iStart是一个从零逐步增加的时间，点击之后时间从零开始累加\n    float iStart = 5.0;\n    \n    //night to awake\n\tfragColor = mix(nightColor, fragColor, smoothstep(0.0,1.0,iStart*0.2));\n    \n    //Debug\n    //fragColor = vec4(maskColor,1.0);\n    //fragColor = vec4(lightColor);\n    //fragColor = vec4(darkColor);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n    if (uv.y<-0.1&&uv.y > -1.2){\n    fragColor = vec4(darkColor);\n    }\n    if (uv.y<-1.3&&uv.y > -2.4){\n    fragColor = vec4(lightColor);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 92, 92, 189], [191, 191, 237, 237, 331], [333, 333, 364, 364, 455], [457, 457, 500, 500, 943], [945, 945, 999, 999, 1021], [1023, 1023, 1075, 1075, 1142], [1144, 1144, 1168, 1168, 1198], [1200, 1200, 1223, 1223, 1546], [1548, 1636, 1739, 1739, 4277], [4279, 4279, 4336, 4373, 12008]], "test": "untested"}
{"id": "dtXyR7", "name": "crop contorno img", "author": "nictemeral", "description": "crop img", "tags": ["crop"], "likes": 0, "viewed": 122, "published": 3, "date": "1690516508", "time_retrieved": "2024-07-30T17:41:58.530605", "image_code": "uniform sampler2D iChannel;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st =  fragCoord/iResolution.xy;\n    vec2 uv=st;\n    vec4 color = vec4(0.0);\n\n    // Fix the proportions by finding the aspect ratio\n    float aspect = iChannelResolution[0].x/iChannelResolution[0].y;\n    st.y *= aspect;  // and then applying to it\nst*=1.248;\nst+=vec2(-0.100,-0.20);//+sin(uv.y*250.+iTime)*0.025;\n    float crop=step(st.y,1.)*step(0.,st.y)*step(st.x,1.)*step(0.,st.x);\n   // crop*=sin(uv.y*250.+iTime)+cos(uv.x*50.+iTime);\n    color = texture(iChannel,st)*crop;\n\t//color=vec4(crop);\n    // Output to screen\n    fragColor = color;\n} ", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 137, 694]], "test": "untested"}
{"id": "mtsyRN", "name": "Fire 3d", "author": "ersh", "description": "Molten metal (Fire 3d)", "tags": ["procedural", "3d", "fractal", "cloud", "fire", "generated"], "likes": 18, "viewed": 285, "published": 3, "date": "1690504128", "time_retrieved": "2024-07-30T17:41:59.546887", "image_code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n// This is a fork of two other shaders: https://www.shadertoy.com/view/7sjyRD and https://www.shadertoy.com/view/mlXyR4\n\n// At lease some of these must be 1:\n#define PLOT_AVG       0\n#define PLOT_MAX       1\n\n#define START_DIST   2.5\n#define FOV          5.\n\nvec3 col(float x) {\n  return vec3(\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x-2./3., 0., 1./3.)\n   ) * 3.;\n}\n\nvec3 col2(float x) {\n  return vec3(\n      clamp(x, 0., 1.)\n   );\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if (sdBox(I - BUTTON_ORIGIN, BUTTON_SZ) <= 0.) {\n        O = vec4(0,0,1. - step(0.5, iMouse.z)*step(0., -sdButton)*0.5,1);\n        vec2 inner_sz = BUTTON_SZ - 2.;\n        float sdf = min(sdEquilateralTriangle(-(I - BUTTON_ORIGIN - vec2(3,0)).yx/inner_sz.y)*inner_sz.y,\n                        sdBox(I - BUTTON_ORIGIN + vec2(inner_sz.y,0), vec2(2,inner_sz.y)));\n        O.rgb = mix(O.rgb, vec3(1,1,1), smoothstep(1., -1., sdf));\n        return;\n    }\n\n    O = vec4(0,0,0,1);\n    mat2 rot_yz, rot_xy;            // rotations\n    if (iMouse.x < 0.5 || sdButton <= 0.) {\n      // https://graphtoy.com/?f1(x,t)=(floor(x/5)+smoothstep(0,1,fract(x/5)*10))*0.5&v1=true&f2(x,t)=&v2=false&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,7.451055876709886\n      rot_xy = rot(-iTime/2.);\n      //rot_xy = rot(float(-iFrame)/70.);\n      rot_yz = rot(1.2);\n    } else {\n      vec2 M = (iMouse.xy / R2.xy * vec2(1., -0.7) + vec2(0.5, 0.1)) * 2. * PI;\n      rot_yz = rot(-M.y);\n      rot_xy = rot(-M.x);\n    }\n    vec3 p = vec3(0,0,START_DIST);                                       // current ray pos\n    p.yz *= rot_yz;  p.xy *= rot_xy;\n\n    vec3 D = normalize(vec3(I+I, -FOV*R2.y) - vec3(R2.xy, 0.));    // ray direction\n    D.yz *= rot_yz;  D.xy *= rot_xy;\n\n    vec3 R3 = Res2to3(R2.xy);\n    float scale2 = R3.x;\n    float c = 0.;\n    float n_c = 0.;\n    float cmax = 0.;\n    float st = 0.5/R3.z;\n    int n_steps = int(3./st);\n    vec3 st1 = st * D;\n    int n;\n    float axis = 99.;\n    for (p += D*(START_DIST - 1.5), n = 0; n < n_steps; n++, p += st1) {\n        vec3 coord = (p + 0.5) * scale2;\n        if (coord.x >= 0. && coord.y >= 0. && coord.z >= 0. &&\n            coord.x < R3.x && coord.y < R3.y && coord.z < R3.z) {\n#if PLOT_AVG\n            c += T(coord).x;\n            n_c++;\n#endif\n#if PLOT_MAX\n            cmax = max(cmax, T(coord).x);\n#endif\n#define SDF_AXIS(XX)   distance(coord.XX + coord.XX, R3.XX)\n            axis = min(\n                    min(axis, SDF_AXIS(xy)),\n                    min(SDF_AXIS(yz), SDF_AXIS(xz)));\n#define SDF_EDGE(XX)   distance(mod(coord.XX+coord.XX + R3.XX, R3.XX+R3.XX), R3.XX)\n            axis = min(\n                    min(axis, SDF_EDGE(xy)),\n                    min(SDF_EDGE(yz), SDF_EDGE(zx)));\n        }\n    }\n\n#if PLOT_AVG\n\tif (n_c > 0.) {\n        c = log(max(1., c*c*10000.)/n_c)/15.;\n        //c += c*2.2/n_c;\n        //c = pow(c*20., 0.5)*1.5/n_c;\n    }\n#endif\n    //O.rgb = col(c + cmax);\n    O.rgb = col(cmax) + col2(c)/2.;\n    if (iMouse.z > 0.5) O.rgb = mix(O.rgb, vec3(1), smoothstep(1., 0., axis)/2.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        1     // Cause the fire to flare up\n#define SPEED           1.\n//https://graphtoy.com/?f1(x,t)=4&v1=false&f2(x,t)=pow(1-x,f1())&v2=true&f3(x,t)=pow(1-x,1/f1())&v3=true&f4(x,t)=1-pow(x,f1())&v4=true&f5(x,t)=1-pow(x,1/f1())&v5=true&f6(x,t)=&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n#define RAND            (hash13(uv3, iTime/10000.)-0.5)/100.\n//#define RAND            (hash13(uv3, iTime/10000.)-0.4-uv3.z*0.5)/100.\n\n#if FLARE_UP\n#define COORD (1.-uv3.z)*SPEED\n//#define COORD (1.-pow(distance(vec3(0.5,0.5,0),uv3), 4.)/1.)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I3, I2, R3 = Res2to3(R2.xy), R2.xy);\n    vec3 uv3 = I3 / R3;\n    if (OUT_OF_BOUND) { O=vec4(0.); return; }\n\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        INIT\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n\n    if (hash13(uv3, iTime) > 0.05*COORD) {\n        O = pt0; // texture(iChannel0,uv);\n        return;\n    }\n\n    vec3 d = I3;\n    float v = pt0.y;\n    float vv; vec3 dd;\n#define TEST(DX, DY, DZ) \\\n    dd = I3 + vec3(DX, DY, DZ); \\\n    vv = T(dd).y; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( 0., 0.,-1.);\n    TEST( 0., 0., 1.);\n    TEST(-1., 0., 0.);\n    TEST( 1., 0., 0.);\n    TEST( 0.,-1., 0.);\n    TEST( 0., 1., 0.);\n\n    TEST(-1., 1., 0.);\n    TEST( 1.,-1., 0.);\n    TEST(-1.,-1., 0.);\n    TEST( 1., 1., 0.);\n    TEST( 1., 0.,-1.);\n    TEST(-1., 0., 1.);\n    TEST(-1., 0.,-1.);\n    TEST( 1., 0., 1.);\n    TEST( 0.,-1.,-1.);\n    TEST( 0., 1., 1.);\n    TEST( 0., 1.,-1.);\n    TEST( 0.,-1., 1.);\n\n    TEST(-1.,-1.,-1.);\n    TEST( 1., 1., 1.);\n    TEST( 1., 1.,-1.);\n    TEST(-1.,-1., 1.);\n    TEST(-1., 1.,-1.);\n    TEST( 1.,-1., 1.);\n    TEST( 1.,-1.,-1.);\n    TEST(-1., 1., 1.);\n\n    float c = clamp(T(d).x + RAND, 0., 1.);\n    O = vec4(c, v+0.0001, 0., 0.);\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RANGE          5.\n#define BOUNDS         1   // 1 = cube  2 = cylinder  3 = sphere\n\nconst vec2 BUTTON_SZ = vec2(25, 12);\nconst vec2 BUTTON_ORIGIN = BUTTON_SZ + 1.;\n\n#define R2       iResolution\n#define T(P)     texelFetch(iChannel0, ivec2(I3to2(P, R3, R2.xy)), 0)\n#define PI       3.14159265359\n\n#define INIT1 \\\n    float d = clamp(distance(uv3, vec3(0.5))*2., 0., 1.); \\\n    O = vec4(pow(1. - d, 4.), 1. - pow(d, 10.), 0., 0.); \\\n//EOM\n#define INIT2 \\\n    float d = clamp(distance(uv3, vec3(0.5, 0.5, 0.))*2., 0., 1.); \\\n    O = vec4(pow(1. - d, 4.), 1. - pow(d, 10.), 0., 0.); \\\n//EOM\n\n#define INIT INIT2\n\n#if BOUNDS == 1\n#define OUT_OF_BOUND       any(lessThan(I3, vec3(1.0))) || any(greaterThan(I3, R3-vec3(2.0)))\n#elif BOUNDS == 2\n#define OUT_OF_BOUND       distance(uv3.xy, vec2(0.5)) >= (0.5-1./R3.x)\n#elif BOUNDS == 3\n#define OUT_OF_BOUND       distance(uv3, vec3(0.5)) >= (0.5-1./R3.x)\n#endif\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position, float iTime)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 position, float iTime)\n{\n    vec3 p3 = vec3(position) + iTime * 500. + 50.0;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 Res2to3(in vec2 R2) {\n    return vec3(floor(pow(R2.x*R2.y, 1./3.)));  // 1200 / 80 = 13\n}\n\nvec2 I3to2(in vec3 I3, in vec3 R3, in vec2 R2) {\n    I3 = floor(clamp(I3, vec3(0), R3-1.));\n    float offset = I3.x + I3.y*R3.x + I3.z*R3.x*R3.y;\n    vec2 I2;\n    I2.x = mod(offset, R2.x);\n    I2.y = floor(offset/R2.x);\n    return I2;\n}\n\nvoid I2to3(out vec3 I3, in vec2 I, in vec3 R3, in vec2 R2) {\n    I = floor(I);\n    //I -= 0.5;\n    float offset = I.x + I.y*R2.x;\n    I3.x = mod(offset, R3.x);\n    I3.y = mod(floor(offset/R3.x), R3.y);\n    I3.z = min(floor(offset/R3.x/R3.y), R3.z-1.);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEquilateralTriangle( in vec2 p ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c,-s,s,c); }\n\n", "buffer_b_code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           1.\n//https://graphtoy.com/?f1(x,t)=4&v1=false&f2(x,t)=pow(1-x,f1())&v2=true&f3(x,t)=pow(1-x,1/f1())&v3=true&f4(x,t)=1-pow(x,f1())&v4=true&f5(x,t)=1-pow(x,1/f1())&v5=true&f6(x,t)=&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n//#define RAND            (hash13(uv3, iTime/10010.)-0.5)/100.\n//#define RAND            (hash13(uv3, iTime/10010.)-0.3-distance(vec3(0.5,0.5,0),uv3)*1.2)/100.\n#define RAND            (hash13(uv3, iTime/10010.)-0.5+pow(1.-distance(vec3(0.5,0.5,0),uv3), 10.)/1.)/100.\n\n#if FLARE_UP\n#define COORD (1.-uv3.z)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I3, I2, R3 = Res2to3(R2.xy), R2.xy);\n    vec3 uv3 = I3 / R3;\n    if (OUT_OF_BOUND) { O=vec4(0.); return; }\n\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        INIT\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n\n    if (hash13(uv3, iTime*1.15) > 0.05*COORD) {\n        O = pt0; // texture(iChannel0,uv);\n        return;\n    }\n\n    vec3 d = I3;\n    float v = pt0.y;\n    float vv; vec3 dd;\n#define TEST(DX, DY, DZ) \\\n    dd = I3 + vec3(DX, DY, DZ); \\\n    vv = T(dd).y; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( 0., 0.,-1.);\n    TEST( 0., 0., 1.);\n    TEST(-1., 0., 0.);\n    TEST( 1., 0., 0.);\n    TEST( 0.,-1., 0.);\n    TEST( 0., 1., 0.);\n\n    TEST(-1., 1., 0.);\n    TEST( 1.,-1., 0.);\n    TEST(-1.,-1., 0.);\n    TEST( 1., 1., 0.);\n    TEST( 1., 0.,-1.);\n    TEST(-1., 0., 1.);\n    TEST(-1., 0.,-1.);\n    TEST( 1., 0., 1.);\n    TEST( 0.,-1.,-1.);\n    TEST( 0., 1., 1.);\n    TEST( 0., 1.,-1.);\n    TEST( 0.,-1., 1.);\n\n    TEST(-1.,-1.,-1.);\n    TEST( 1., 1., 1.);\n    TEST( 1., 1.,-1.);\n    TEST(-1.,-1., 1.);\n    TEST(-1., 1.,-1.);\n    TEST( 1.,-1., 1.);\n    TEST( 1.,-1.,-1.);\n    TEST(-1., 1., 1.);\n\n    float c = clamp(T(d).x + RAND, 0., 1.);\n    O = vec4(c, v+0.0001, 0., 0.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           1.\n//https://graphtoy.com/?f1(x,t)=4&v1=false&f2(x,t)=pow(1-x,f1())&v2=true&f3(x,t)=pow(1-x,1/f1())&v3=true&f4(x,t)=1-pow(x,f1())&v4=true&f5(x,t)=1-pow(x,1/f1())&v5=true&f6(x,t)=&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n//#define RAND            (hash13(uv3, iTime/10020.)-0.5)/100.\n//#define RAND            (hash13(uv3, iTime/10020.)-0.2-distance(vec3(0.5,0.5,0),uv3)*1.5)/100.\n#define RAND            (hash13(uv3, iTime/10020.)-0.5+pow(1.-distance(vec3(0.5,0.5,0),uv3), 10.)/2.)/100.\n\n#if FLARE_UP\n#define COORD (1.-uv3.z)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I3, I2, R3 = Res2to3(R2.xy), R2.xy);\n    vec3 uv3 = I3 / R3;\n    if (OUT_OF_BOUND) { O=vec4(0.); return; }\n\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        INIT\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n\n    if (hash13(uv3, iTime*1.25) > 0.05*COORD) {\n        O = pt0; // texture(iChannel0,uv);\n        return;\n    }\n\n    vec3 d = I3;\n    float v = pt0.y;\n    float vv; vec3 dd;\n#define TEST(DX, DY, DZ) \\\n    dd = I3 + vec3(DX, DY, DZ); \\\n    vv = T(dd).y; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( 0., 0.,-1.);\n    TEST( 0., 0., 1.);\n    TEST(-1., 0., 0.);\n    TEST( 1., 0., 0.);\n    TEST( 0.,-1., 0.);\n    TEST( 0., 1., 0.);\n\n    TEST(-1., 1., 0.);\n    TEST( 1.,-1., 0.);\n    TEST(-1.,-1., 0.);\n    TEST( 1., 1., 0.);\n    TEST( 1., 0.,-1.);\n    TEST(-1., 0., 1.);\n    TEST(-1., 0.,-1.);\n    TEST( 1., 0., 1.);\n    TEST( 0.,-1.,-1.);\n    TEST( 0., 1., 1.);\n    TEST( 0., 1.,-1.);\n    TEST( 0.,-1., 1.);\n\n    TEST(-1.,-1.,-1.);\n    TEST( 1., 1., 1.);\n    TEST( 1., 1.,-1.);\n    TEST(-1.,-1., 1.);\n    TEST(-1., 1.,-1.);\n    TEST( 1.,-1., 1.);\n    TEST( 1.,-1.,-1.);\n    TEST(-1., 1., 1.);\n\n    float c = clamp(T(d).x + RAND, 0., 1.);\n    O = vec4(c, v+0.0001, 0., 0.);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           1.\n//https://graphtoy.com/?f1(x,t)=4&v1=false&f2(x,t)=pow(1-x,f1())&v2=true&f3(x,t)=pow(1-x,1/f1())&v3=true&f4(x,t)=1-pow(x,f1())&v4=true&f5(x,t)=1-pow(x,1/f1())&v5=true&f6(x,t)=&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n//#define RAND            (hash13(uv3, iTime/10030.)-0.5)/100.\n#define RAND            (hash13(uv3, iTime/10030.)-0.4-uv3.z*1.0)/30.\n\n#if FLARE_UP\n#define COORD (1.-uv3.z)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I3, I2, R3 = Res2to3(R2.xy), R2.xy);\n    vec3 uv3 = I3 / R3;\n    if (OUT_OF_BOUND) { O=vec4(0.); return; }\n\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        INIT\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n\n    if (hash13(uv3, iTime*1.35) > 0.05*COORD) {\n        O = pt0; // texture(iChannel0,uv);\n        return;\n    }\n\n    vec3 d = I3;\n    float v = pt0.y;\n    float vv; vec3 dd;\n#define TEST(DX, DY, DZ) \\\n    dd = I3 + vec3(DX, DY, DZ); \\\n    vv = T(dd).y; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( 0., 0.,-1.);\n    TEST( 0., 0., 1.);\n    TEST(-1., 0., 0.);\n    TEST( 1., 0., 0.);\n    TEST( 0.,-1., 0.);\n    TEST( 0., 1., 0.);\n\n    TEST(-1., 1., 0.);\n    TEST( 1.,-1., 0.);\n    TEST(-1.,-1., 0.);\n    TEST( 1., 1., 0.);\n    TEST( 1., 0.,-1.);\n    TEST(-1., 0., 1.);\n    TEST(-1., 0.,-1.);\n    TEST( 1., 0., 1.);\n    TEST( 0.,-1.,-1.);\n    TEST( 0., 1., 1.);\n    TEST( 0., 1.,-1.);\n    TEST( 0.,-1., 1.);\n\n    TEST(-1.,-1.,-1.);\n    TEST( 1., 1., 1.);\n    TEST( 1., 1.,-1.);\n    TEST(-1.,-1., 1.);\n    TEST(-1., 1.,-1.);\n    TEST( 1.,-1., 1.);\n    TEST( 1.,-1.,-1.);\n    TEST(-1., 1., 1.);\n\n    float c = clamp(T(d).x + RAND, 0., 1.);\n    O = vec4(c, v+0.0001, 0., 0.);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 321, 321, 441], [443, 443, 463, 463, 509], [511, 511, 550, 550, 3220]], "test": "untested"}
{"id": "ctfyR7", "name": "black hole⠀", "author": "01000001", "description": "A black hole! Varies ssaa samples to maintain decent FPS. Idea by beans_please. Tested from 4K to mobile\n\n[url=dd2yDz]flim[/url] by beans_please\n\nHonestly this is a very gimmicky shader. Was a good learning experience.", "tags": ["raymarching", "blackhole", "physics", "gravity", "singularity"], "likes": 6, "viewed": 230, "published": 3, "date": "1690502079", "time_retrieved": "2024-07-30T17:42:00.575138", "image_code": "#define IS_NOT_MOBILE\n\nconst float maxDist = pow(7.,2.);\nconst float horizon = 1.;\nconst float disk = 3.;\nconst float diskT = 0.05;\nvec3 col = vec3(0);\nfloat stepSize;\nconst int maxSteps = 512;\nconst float orbit = 2.2;\nconst float gap = .4;\nconst float spin = .05;\nconst float warp = 0.;\nconst float focalLength = 1.2;\n\nint ssaa = 1;\n\nmat2x2 rotMat(float t)\n{\n    return mat2x2(\n        cos(t), sin(t),\n        -sin(t), cos(t)\n    );\n}\n\nfloat rand(float t)\n{\n    return fract(sin(t*234.89));\n}\n\nvec3 bhuv(vec3 p)\n{\n    vec3 buv = 1.-vec3(length(p.xy) - disk + gap * 2.5)/disk;\n    buv.y = ((atan(p.y/p.x)+0.5*pi)/pi + (p.x > 0.?1.:0.))*.5;\n    buv.z = p.z/diskT;\n    if (buv.x > 1.) buv.x = 0.0;\n    return clamp(buv, 0., 1.);\n}\n\nvec3 diskCol(vec3 p)\n{\n    vec3 buv = bhuv(p);\n    buv.y += iTime*spin;\n\n    float x = pow(buv.x, 2.);\n    float s = 0.5;\n    vec3 o = texture(iChannel2, vec3(buv.x *= 3., 0.5+s*sin(buv.y*pi*2.), 0.5+s*cos(buv.y*pi*2.))).xxx * vec3(1, .5, 0.2);\n    s *= 0.5;\n    o += texture(iChannel2, vec3(buv.x*=.5, 0.5+s*sin(buv.y*pi*2.), 0.5+s*cos(buv.y*pi*2.))).xxx * vec3(0, 0.1, 1);\n    s *= 0.5;\n    o += texture(iChannel2, vec3(buv.x*=.5, 0.5+s*sin(buv.y*pi*2.), 0.5+s*cos(buv.y*pi*2.))).xxx * vec3(0.6, 1, 0.4);\n    return o * x;\n}\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 ps(uvec3 x){\n    return hash(x).xy * 2. - 1.;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\n    vec2 r = iResolution.xy;\n    int i = 0;\n    vec2 muv = iMouse.z > 0.?(2.*iMouse.xy - r.xy)/r.xy:vec2(iTime, sin(iTime*.3)*.5);\n\n    \n    \n    // Performance adjusting ssaa //\n    \n    ssaa = iFrame < 20?2:\n        4*int(max(iFrameRate*.1,min(iFrameRate*.4, ceil(pow(1.1, iFrameRate - 50.)*3.))));\n\n    ///////////////////////////////\n    \n    \n        \n        \n    for (int m = 0; m < ssaa; m++){\n\n        vec2 offset = ps(uvec3(iFrame + m, int(U.y) - m, int(U.x)+m))*2.;\n        // SSAA\n        float c = 1./(sqrt(length(offset))+0.3);\n        //Varied contribution of ssaa sample based on distance from centre\n        vec2 uv = (2.*U - r.xy\n            +offset\n        )/r.y;\n\n        /*\n        vec3 dirV = normalize(vec3(uv.x, 1.0, uv.y)) * mat3x3(\n            cos(iTime), -sin(iTime), 0,\n            sin(iTime), cos(iTime), 0,\n            0, 0, 1\n        );/*/\n\n\n        vec3 camDir = normalize(vec3(sin(muv.xx + vec2(0,11)), -muv.y*0.5));\n        vec3 r = cross(camDir, vec3(0, 0, 1));\n        vec3 u = cross(r, camDir);\n        vec3 dirV = normalize(camDir * focalLength + r * uv.x + u * uv.y);\n        //*/\n\n        vec3 camPos = vec3(sin(-muv.xx - vec2(0,11)) * disk * orbit, muv.y*orbit*1.2);\n\n        float g = 0.;\n        vec3 p = camPos;\n\n        for (i = 0; i<maxSteps; i++)\n        {\n            stepSize = min(pow(length(p)/8., 0.5), abs(p.z)+diskT*rand(p.x + p.y * pi + p.z / pi));\n            p += stepSize * dirV;\n\n            if (abs(p.z) < diskT)\n            {\n                col += diskCol(p)*0.5*c;\n            }\n\n            g = (stepSize / pow(length(p), 3.));\n            dirV = normalize(dirV - p * horizon*g);\n\n            p.xy *= rotMat(g*warp);\n            // rotating black hole, simulate dragging of space\n            // by rotating space by the strength of gravity\n\n            if (length(p) < horizon || dot(p,p) > maxDist){\n                break;\n            }\n        }\n\n        if (i == maxSteps || dot(p,p) > maxDist){ \n            col += c\n                //The skybox\n                * pow(clamp(texture(iChannel1, fract(dirV.yz)).xxx,0.,1.), vec3(8));\n        }\n\n    }\n    \n    col /= float(ssaa);\n    #ifdef IS_NOT_MOBILE\n        col = flim(col, 0.0);\n    #endif\n    \n    /*\n    O = vec4(float(i) / float(maxSteps));//col.xyzz);\n    /*/\n    O = vec4(col.xyzz);//*/\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float pi = 3.14159;\n#define flim(x, y) flim_transform(iChannel0, x, y)\n\n\n\n\n\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float pe = 4.3; const vec3 fpff = vec3(1); const float fpffs = 0.;\nconst float egr = 1.05; const float egg = 1.12; const float egb = 1.045;\nconst float grr = .5; const float ggr = 2.; const float gbr = .1;\nconst float grm = 1.; const float ggm = 1.; const float gbm = 1.; const float flsi = -10.;\nconst float flsa = 22.; const float fsx = .44; const float fsy = .28;\nconst float fssx = .591; const float fssy = .779; const float fe = 6.;\nconst float fd = 5.; const vec3 pb = vec3(1); const float pfe = 6.;\nconst float pfd = 27.5; const float bp = -1.; const vec3 pff = vec3(1);\nconst float pffs = 0.; const float ms = 1.02;\nfloat wrap(float i, float s, float e){return s + mod(i - s, e - s);}\nfloat lerp(float a, float b, float t){return a + t * (b - a);}\nvec3 lerp(vec3 a, vec3 b, float t){return a + t * (b - a);}\nfloat mrc(float i, float is, float ie, float os, float oe){\n    float t = clamp((i - is) / (ie - is), 0., 1.);\n    float v = os + t * (oe - os);\n    return v; }\nvec3 rth(vec3 rgb){\n    float ca, ci, h, s, v, cd;\n    vec3 c;\n    ca = max(rgb[0], max(rgb[1], rgb[2]));\n    ci = min(rgb[0], min(rgb[1], rgb[2]));\n    cd = ca - ci;\n    v = ca;\n    if (ca != 0.) s = cd / ca;\n    else s = 0.0; h = 0.0;\n    if (s == 0.) h = 0.0; \n    else{\n        c = (vec3(ca) - rgb.xyz) / cd;\n\n        if (rgb.x == ca) h = c[2] - c[1];\n        else if (rgb.y == ca) h = 2.+ c[0] - c[2];\n        else h = 4.+ c[1] - c[0];\n        h /= 6.0;\n        if (h < 0.) h += 1.0; }\n    return vec3(h, s, v); }\nvec3 htr(vec3 hsv){\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n    if (s == 0.) rgb = vec3(v, v, v);\n    else {\n        if (h == 1.) h = 0.0;\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.- s);\n        q = v * (1.- (s * f));\n        t = v * (1.- (s * (1.- f)));\n        if (i == 0.) rgb = vec3(v, t, p);\n        else if (i == 1.) rgb = vec3(q, v, p);\n        else if (i == 2.) rgb = vec3(p, v, t);\n        else if (i == 3.) rgb = vec3(p, q, v);\n        else if (i == 4.) rgb = vec3(t, p, v);\n        else rgb = vec3(v, p, q); }\n    return rgb; }\nvec3 bhs(vec3 col, float hue, float sat, float value){\n    vec3 hsv = rth(col);\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n    return htr(hsv); }\nfloat rgb_avg(vec3 i){\n    return (i.x + i.y + i.z) / 3.0; }\nfloat rgb_sum(vec3 i){\n    return i.x + i.y + i.z; }\nfloat rgb_max(vec3 i){\n    return max(max(i.x, i.y), i.z); }\nfloat rgb_min(vec3 i){\n    return min(min(i.x, i.y), i.z); }\nvec3 uo(vec3 i, float bp, float wp){\n    float mono = rgb_avg(i);\n    float mono2 = mrc(mono, bp / 1000., 1.- (wp / 1000.), 0., 1.);\n    return i * (mono2 / mono); }\n// https://www.desmos.com/calculator/khkztixyeu\nfloat ss(float i, float tx, float ty, float sx, float sy){\n    i = clamp(i, 0., 1.);\n    tx = clamp(tx, 0., 1.);\n    ty = clamp(ty, 0., 1.);\n    sx = clamp(sx, 0., 1.);\n    sy = clamp(sy, 0., 1.);\n    float slope = (sy - ty) / (sx - tx);\n    if (i < tx){\n        float toe_pow = slope * tx / ty;\n        return ty * pow(i / tx, toe_pow); }\n    if (i < sx){\n        float intercept = ty - (slope * tx);\n        return slope * i + intercept; }\n    float shoulder_pow = -slope / (((sx - 1.) / pow(1.- sx, 2.)) * (1.- sy));\n    return (1.- pow(1.- (i - sx) / (1.- sx), shoulder_pow)) * (1.- sy) + sy; }\nfloat dmf(float mono, float max_density){\n    float offset = pow(2., flsi);\n    float fac = mrc(log2(mono + offset), flsi, flsa, 0., 1.);\n    fac = ss(fac, fsx, fsy, fssx, fssy);\n    fac *= max_density;\n    fac = pow(2., -fac);\n    return clamp(fac, 0., 1.); }\nvec3 cl(vec3 i, vec3 sensitivity_tone, vec3 dye_tone, float max_density){\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n    float mono = dot(i, sensitivity_tone_norm);\n    float mixFac = dmf(mono, max_density);\n    return lerp(dye_tone_norm, vec3(1.), mixFac); }\nvec3 rgbd(vec3 i, float e, float max_density){\n    i *= pow(2., e);\n    vec3 result = cl(i, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n    result *= cl(i, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n    result *= cl(i, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n    return result; }\nvec3 emr(float ph, float s, float r, float m){\n    vec3 result = htr(vec3(wrap(ph + (r / 360.), 0., 1.), 1./ s, 1.));\n    result /= rgb_sum(result);\n    result *= m;\n    return result; }\nmat3 gem(float rs,float gs,float bs,float rr,float gr, float br, float rm, float gm, float bm){\n    mat3 m;\n    m[0] = emr(0., rs, rr, rm);\n    m[1] = emr(1./ 3., gs, gr, gm);\n    m[2] = emr(2./ 3., bs, br, bm);\n    return m; }\nvec3 nap(vec3 i, vec3 bex){\n    i = rgbd(i, fe, fd);\n    i *= bex;\n    i = rgbd(i, pfe, pfd);\n    return i; }\nbool flm(sampler2D mc, out mat3 em, out mat3 emi){\n    const float valid_w = 2.0;\n    vec4 row;\n    row = texelFetch(mc, ivec2(0, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(1, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(2, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[2] = row.xyz;\n    row = texelFetch(mc, ivec2(3, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(4, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(5, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[2] = row.xyz;\n    return true; }\nvec3 flim_transform(sampler2D mc, vec3 i, float e){\n    i = max(i, 0.);\n    i *= pow(2., pe + e);\n    i = min(i, 5000.);\n    mat3 em, emi;\n    if (!flm(mc, em, emi)){ return vec3(1, 0, 1); }\n    vec3 bex = pb * em;\n    const float big = 10000000.0;\n    vec3 white_cap = nap(vec3(big, big, big), bex);\n    i = lerp(i, i * fpff, fpffs);\n    i *= em;\n    i = nap(i, bex);\n    i *= emi;\n    i = max(i, 0.);\n    i /= white_cap;\n    if (bp == -1.){\n        vec3 black_cap = nap(vec3(0.), bex);\n        black_cap /= white_cap;\n        i = uo(i, rgb_avg(black_cap) * 1000., 0.);\n    }else{ i = uo(i, bp, 0.); }\n    i = lerp(i, i * pff, pffs);\n    i = clamp(i, 0., 1.);\n    float mono = rgb_avg(i);\n    float mixFac = (mono < 0.5) ? mrc(mono, 0.05, 0.5, 0., 1.) : mrc(mono, 0.5, 0.95, 1., 0.);\n    i = lerp(i, bhs(i, 0.5, ms, 1.), mixFac);\n    i = clamp(i, 0., 1.);\n    i = pow(i, vec3(1./ 2.2));\n    return i; }\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n", "buffer_a_code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 O, in vec2 U){\n    const float w = 2.0;\n    if (ivec2(U).x > 5 || ivec2(U).y > 0)\n        return;\n    vec4 p = texelFetch(iChannel0, ivec2(U), 0);\n    O = p;\n    bool n = (p.w != w) || (iTime == 0.0) || (iFrame < 1);\n    if (!n)\n        return;\n    mat3 e = gem(egr,egg,egb,grr,ggr,gbr,grm,ggm,gbm);\n    mat3 ei = inverse(e);\n    if (ivec2(U) == ivec2(0, 0)) {\n        O = vec4(e[0], w);\n    } if (ivec2(U) == ivec2(1, 0)) {\n        O = vec4(e[1], w);\n    } if (ivec2(U) == ivec2(2, 0)) {\n        O = vec4(e[2], w);\n    }\n    if (ivec2(U) == ivec2(3, 0)) {\n        O = vec4(ei[0], w);\n    } if (ivec2(U) == ivec2(4, 0)) {\n        O = vec4(ei[1], w);\n    } if (ivec2(U) == ivec2(5, 0)) {\n        O = vec4(ei[2], w);\n    }}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 359, 359, 435], [437, 437, 458, 458, 493], [495, 495, 514, 514, 728], [730, 730, 752, 752, 1256], [1286, 1286, 1308, 1308, 1441], [1442, 1493, 1510, 1510, 1545], [1548, 1548, 1589, 1589, 3905]], "test": "untested"}
{"id": "ddBBWw", "name": "Audio Analyser", "author": "QuantumSuper", "description": "Analyses music by historic sound spectrum to estimate BPM, offset & beat count. Hope this is useful for designs where you need information on track structure.\n\n - Use with music in iChannel0 of Buffer A -", "tags": ["spectrum", "music", "audio", "bpm", "buffer"], "likes": 6, "viewed": 257, "published": 3, "date": "1690486977", "time_retrieved": "2024-07-30T17:42:01.606380", "image_code": "// Audio Analyser 0.5.230727 by QuantumSuper\n// analyse audio spectrum to estimate bpm, offset & beat count\n// looks at spectrum history, assumes static resolution & frame rate\n// Buffer A: spectrum history\n// Buffer B: filter beats\n// Buffer C: analyse (filtered) spectrum\n// Image: design mockup to visualize results (& highlight use for designs to build upon & debugging/refining)\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\n#define showBuffer true\n\n\nfloat aaStep( float fun){return smoothstep( fwidth(fun), .0, fun);} //simple antialiasing\nfloat sdCircle( vec2 p, float r){return length(p)-r;}\nfloat sdBox( vec2 p, vec2 b){vec2 d = abs(p) - b; return length(max(d,.0)) + min(max(d.x,d.y),.0);} //source: https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( vec2 p, vec2 a, vec2 b){vec2 pa = p - a, ba = b - a; float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.); return length(pa - ba*h);} //source: https://iquilezles.org/articles/distfunctions2d/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // TOOLS\n    \n    // Read compression values from Buffer A\n    vec4 fft, ffts;\n    for (int n=0;n<4;n++) \n        fft[n] = getDat( iChannel0, vec2( 0, n)).a,\n        ffts[n] = getDat( iChannel0, vec2( 0, n+4)).a;\n      \n    // Read analysis results from Buffer C\n    float count         = getDat( iChannel2, vec2(0,0)).a; //beat count (0..15)\n    float bpm           = getDat( iChannel2, vec2(0,1)).a; //bmp estimate (>90..180)\n    float frameRate     = getDat( iChannel2, vec2(0,2)).a; //frame rate average\n    float isPause       = getDat( iChannel2, vec2(0,3)).a; //is bass less high than average\n    float timeFirstBeat = getDat( iChannel2, vec2(0,4)).a; //time difference to beat drop (16 beat range)\n    float isBeat        = getDat( iChannel2, vec2(0,5)).a; //is bass high\n    float isFlank       = getDat( iChannel2, vec2(0,6)).a; //is bass just getting high\n                  \n\n    // DESIGN\n    \n    // Draw status display\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n    vec3 col = vec3(0);\n    \n    vec4 tmp = vec4(.46,.26,.34,.22); //top windows\n    col += (uv.y > tmp.y)?\n        aaStep( sdBox( uv-vec2(-1,1)*tmp.xy, tmp.zw)) * getDat( iChannel1, ((uv-vec2(-1,1)*tmp.xy)/tmp.zw+vec2(1))/2.*iResolution.xy).r : //filter\n        aaStep( sdBox( uv-vec2(-1,1)*tmp.xy, tmp.zw)) * getDat( iChannel0, ((uv-vec2(-1,1)*tmp.xy)/tmp.zw+vec2(1))/2.*iResolution.xy * vec2(1,8./512.)).r; //bass\n    col += aaStep( sdBox( uv-tmp.xy, tmp.zw)) * getDat( iChannel2, ((uv-tmp.xy)/tmp.zw+vec2(1))/2.*iResolution.xy).r / max(.001,getDat( iChannel2, vec2(0,(180./bpm-1.)*iResolution.y)).r); //bpm certainties\n    col += aaStep( sdBox( uv-tmp.xy, tmp.zw)) * aaStep( abs(uv.y - tmp.y + (3.-360./bpm)*tmp.w) - .001); //bpm line\n    \n    tmp = vec4(.0,.13,.8,.08); //long mid  window\n    col += aaStep( sdBox( uv+tmp.xy, tmp.zw)) * (getDat( iChannel0, ((uv+tmp.xy)/tmp.zw+vec2(1))/2.*iResolution.xy * vec2(1,4./512.)).bbb - .95)/.05 ; //pause   \n    \n    tmp = vec4(0,.26,.025,.1); //middle top dots\n    col += aaStep( sdCircle( uv-tmp.xy-tmp.xw, tmp.z)) * (isBeat*.95+.05) + clamp(.01/max(.001,sdCircle( uv-tmp.xy-tmp.xw, tmp.z)),.0,1.) * isFlank;\n    col += aaStep( sdCircle( uv-tmp.xy+tmp.xw, tmp.z)) * (float(isPause > .13)*.95+.05);\n    \n    for (float n=0.; n<4.; n++) //large dots bottom\n        col += aaStep( sdCircle( uv+vec2(.6-n*.4,.35), .08)) * float(abs(n-mod(count,4.)+.5)<.5); //count from 1 to 4\n       \n    for (float n=0.; n<16.; n++) //small dots bottom\n        col += aaStep( sdCircle( uv+vec2(.75-n*.1,.48), .01)) * float(abs(n-count+.5)<.5); //count from 1 to 16\n    \n    tmp = vec4(.9,-.5,.5,.003); //side bars\n    col += aaStep( sdSegment( vec2(abs(uv.x),uv.y), tmp.xy, tmp.xz) - tmp.w*4.) * aaStep(fract((uv.y-tmp.y)/abs(-tmp.y+tmp.z)*4.) - .03); //side scales\n    col += aaStep( sdSegment( uv, tmp.xy, tmp.xy + vec2( 0, abs(tmp.z-tmp.y) * frameRate/120.)) - tmp.w); //framerate percentage of 120fps\n    col += aaStep( sdSegment( vec2(-uv.x,uv.y), tmp.xy, tmp.xy + vec2( 0, abs(tmp.z-tmp.y) * pow(1.-isPause,10.))) - tmp.w); //isPause, inverted log\n\n    if (showBuffer){\n        tmp.x = mod((iTime-timeFirstBeat)/(60./bpm*2.),32.);\n             if (tmp.x< 8.) ;\n        else if (tmp.x<10.) col = getDat( iChannel0, fragCoord).ggg; //waveform\n        else if (tmp.x<12.) col = getDat( iChannel0, fragCoord).rrr; //audio spectrum\n        else if (tmp.x<14.) col = (uv.y<0.)? getDat( iChannel0, fragCoord*vec2(1,8./512.)).rrr : getDat( iChannel1, fragCoord).rrr; //filter beats\n        else if (tmp.x<16.) col = getDat( iChannel2, fragCoord).rrr / max(.001,getDat( iChannel2, vec2(0,(180./bpm-1.)*iResolution.y)).r); //bpm certainties\n        else if (tmp.x<17.) col = getDat( iChannel2, fragCoord).ggg / min(iResolution.x, iResolution.y); //maximum search\n        else if (tmp.x<18.) col = getDat( iChannel0, fragCoord).bbb; //average amplitude maximum\n        else if (tmp.x<19.) col = (getDat( iChannel0, fragCoord*vec2(1,8./512.)).b-.95)/.05 * vec3(.9); //filter average amplitude maximum\n        else if (tmp.x<20.) col = getDat( iChannel0, fragCoord/vec2(1,iResolution.y/8.)).aaa; //compression amplitudes over time \n        else if (tmp.x<22.) col = vec3(step(.0,(fragCoord.y/iResolution.y-.9))) + .7*dot( step(.0,fft-abs(floor(fragCoord.x/iResolution.x*4.-vec4(0,1,2,3)))-fragCoord.y/iResolution.y/.9),vec4(1)) + .3*dot( step(.0,ffts-abs(floor(fragCoord.x/iResolution.x*4.-vec4(0,1,2,3)))-fragCoord.y/iResolution.y/.9),vec4(1)); //compression amplitudes\n    }\n    \n    col += .1 * (1.-length(col)); //background\n    col -= length(uv) * .03; //vignette\n    fragColor = vec4( col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// COMMON (0.0) of Audio Analyser by QuantumSuper\n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define getDat( buf, addr) texelFetch( buf, ivec2(addr), 0)\n#define getDatN( buf, addr) getDat( buf, addr).r / getDat( buf, addr).b", "buffer_a_code": "// BUFFER A (1.0) of Audio Analyser by QuantumSuper\n// audio spectrum by brightness of frequency by y-axis at time by x-axis (0 now; >0 historic)\n// .r: amplitude \n// .g: waveform\n// .b: average amplitude\n// .a: ( fft, ffts, timestamp, 0..0) variables\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\n#define TRACKDURATIONINFRAMES 3600.\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ [WIP]\n}\n\nfloat estMax(float p){ //estimate changing maximum over time of sound texel by weighted amplitude tracking\n    float curVal = clamp( getDat( iChannel0, vec2(p/iResolution.y*512.,0)).x, .0, 1.); //current amplitude\n    float maxVal = clamp( getDat( iChannel1, vec2(0,p)).z, .0, 1.); //latest max amp\n    \n    if (curVal >= maxVal) maxVal = 0.; //check for new max    \n    \n    if (maxVal != 0.) //avoid uninitialized state & deprecated maxVal\n        curVal *=    1./TRACKDURATIONINFRAMES,\n        maxVal *= 1.-1./TRACKDURATIONINFRAMES;\n  \n    return maxVal+curVal; //returns value between 0 and 1\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    compressFft(); //initializes fft, ffts\n    fragColor = (fragCoord.x<1.)? vec4( \n        getDat( iChannel0, vec2( fragCoord.y/iResolution.y*512., 0)).x, //.r amplitudes\n        getDat( iChannel0, vec2( fragCoord.y/iResolution.y*512., 1)).x, //.g waveform (does not work in VirtualDJ)\n        estMax( fragCoord.y), //.b average amplitude\n        (fragCoord.y<4.)? fft[int(fragCoord.y)] : //.a compression part 1\n        (fragCoord.y<8.)? ffts[int(fragCoord.y)-4] : //.a compression part 2\n        (fragCoord.y<9.)? iTime : //.a timestamp\n        0.) //.a empty\n        : getDat( iChannel1, fragCoord-vec2(1,0)); //history   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34123, "src": "https://soundcloud.com/semangat/tina-tischler-aka-semangat-10-years-anniversary-set", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// BUFFER B (0.1) of Audio Analyser by QuantumSuper\n// filter of audio spectrum\n// .r: beats (1D)\n// .g: 0\n// .b: 0\n// .a: 0\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    if (fragCoord.x < 1.) { //new data\n    \n        vec3 pos = 5. * vec3(0,1,2); //defines spread over frames (max beat width)      \n\n        vec3 amp = vec3(\n            (getDatN( iChannel0, vec2(pos.x,1)) + getDatN( iChannel0, vec2(pos.x,2))), //average-normalized amplitudes of 86-258Hz\n            (getDatN( iChannel0, vec2(pos.y,1)) + getDatN( iChannel0, vec2(pos.y,2))),\n            (getDatN( iChannel0, vec2(pos.z,1)) + getDatN( iChannel0, vec2(pos.z,2)))\n            ) * .5; //normalize\n            \n        fragColor = vec4(0);\n        if (amp.y>.92 && amp.x<amp.y && amp.z<amp.y) //super simple max rise detection\n            fragColor.r = 1.;  //beat\n            \n    } else\n        fragColor = getDat( iChannel1, fragCoord-vec2(1,0)); //history \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// BUFFER C (0.9) of Audio Analyser by QuantumSuper\n// analyse filtered beats\n// .r: bpm estimation, brightness corresponds to certainty, linear 90-180bpm\n// .g: buffer to find maximum\n// .b: -\n// .a: variables ( count (0..15), bmp estimate (>90..180), frame rate estimate, isPause (fract), timeFirstBeat, beat (bool), flank (bool), 0..0)\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\nfloat isFlank( float shift){ //simple comparison of bool-like data\n    return (getDat( iChannel1, vec2( mod(shift,iResolution.x), 0)).r > getDat( iChannel1, vec2( mod(shift+1.,iResolution.x), 0)).r)? 1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n         \n    // Set space for search algorithm\n    float isVert = float(iResolution.x < iResolution.y); //vertical screen orientation, bool-like\n    vec2 orient = vec2( 1.-isVert, isVert); //(1,0) horizontal/square; (0,1) vertical\n    vec2 myResolution = bool(isVert)?\n        iResolution.yx : iResolution.xy;\n    vec2 myFragCoord = bool(isVert)?\n        fragCoord.yx : fragCoord.xy; \n    \n    \n    // Estimate average frame rate\n    float estFrameRate = (iFrame < int(iResolution.x))? //buffer not yet fully filled \n        (iFrame < 1)? //initialization\n            30. : //guess frame rate\n            float(iFrame) / (iTime - getDat( iChannel0, vec2( iFrame, 8)).a) : //estimate average frame rate with less accuracy\n        iResolution.x / (iTime - getDat( iChannel0, vec2( iResolution.x-1., 8)).a); //estimate average frame rate\n    \n    \n    // Estimate BPM certainties (comb-like sum)\n    float beat = getDat( iChannel1, vec2(0)).r; //beat ongoing, bool-like\n    float flank = isFlank(0.); //rising flank of beat, bool-like\n    float amp = 0.;\n    \n    if (bool(flank)) //recalculate bpm probability if there is a new beat\n    \n        if (fragCoord.x < 1.){\n        \n            float minStep = estFrameRate / 3.; //assume max 180 bpm (3bps)\n            float stepSize = minStep * (1.+myFragCoord.y/myResolution.y); //assume min >90bpm (>1.5bps)\n            \n            for ( float n=0.; n++ < myResolution.x/stepSize; ) //go through beat history at bpm-rate steps\n                amp += isFlank( n*stepSize); //add found beat flanks\n            amp /= myResolution.x/stepSize; //normalize          \n            \n            float prevAmp = getDat( iChannel2, myFragCoord*orient.yx).r;\n            amp = (amp + prevAmp*359.) / 360.; //weight, assume stable bpm over about 2 minutes at 180bpm (or 4 min at 90bpm)\n            \n        } else \n            amp = getDat( iChannel2, myFragCoord-orient).r; //history     \n    else \n        amp = getDat( iChannel2, fragCoord).r; //copy old data (no new info) \n        \n    fragColor.r = amp;\n\n    \n    // Find BPM estimate (search algorithm)\n    vec2 compPos = (myFragCoord.x < 1.)? //is first line\n        myFragCoord.y + orient.yx : //first neighbour\n        vec2(\n            getDat( iChannel2, myFragCoord - orient).g,\n            getDat( iChannel2, myFragCoord - orient + mod( myFragCoord.x + myFragCoord.y + 1., myResolution.y) * orient.yx ).g ); //next new neighbour\n    \n    amp = (getDat( iChannel2, compPos.x*orient.yx).r < getDat( iChannel2, compPos.y*orient.yx).r)? //compare current compPos-bpm-certainties\n        compPos.y : compPos.x ; //keep only position of higher certainty\n    fragColor.g = amp;  \n    \n    float bpm = (iFrame<1)?\n        127. : //guess\n        180. / (1. + getDat( iChannel2, ceil(iResolution.y*.5)*orient).g / iResolution.y); //most certain beat-rate, range from >90 to 180 bpm\n \n    \n    // Find Beat-offset (watchdog)\n    float isPause = 1. - clamp( getDat( iChannel0, vec2(0,1)).b + getDat( iChannel0, vec2(0,2)).b, .0, 2.)/2.; //inverse average max, bool-like intent but fract usage\n    \n    float timeFirstBeat = (iFrame < 1)? 0. : //initialization\n        (isPause<.05 && getDat( iChannel2, vec2(5,3)).a > .13)? //there was a pause but is no more\n            mod( iTime, 60./bpm*16.) : //new first beat\n            getDat( iChannel2, vec2(0,4)).a; //old first beat\n    \n    float count = mod( (mod( iTime, 60./bpm*16.)-timeFirstBeat) / 60.*bpm, 16.); //count to 16 at bpm from first beat\n    \n\n    // Save variables \n    if (fragCoord.x<1.)\n             if (fragCoord.y<1.) amp = count; //beat count (0..15)\n        else if (fragCoord.y<2.) amp = bpm; //bmp estimate (>90..180)\n        else if (fragCoord.y<3.) amp = estFrameRate; //frame rate average\n        else if (fragCoord.y<4.) amp = isPause; //is average max-bass low\n        else if (fragCoord.y<5.) amp = timeFirstBeat; //time difference to sudden bass increase\n        else if (fragCoord.y<6.) amp = beat; //is bass high\n        else if (fragCoord.y<7.) amp = flank; //is bass beginning\n        else amp = 0.; //empty\n    else amp = getDat( iChannel2, fragCoord-vec2(1,0)).a; //history\n        \n    fragColor.a = amp;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[463, 463, 488, 488, 530], [531, 553, 586, 586, 606], [607, 607, 636, 636, 706], [707, 766, 807, 807, 911]], "test": "untested"}
{"id": "ctsyzN", "name": "Outline and Pixelify", "author": "daiksoul", "description": "Draws outline and Pixelify image", "tags": ["pixel"], "likes": 1, "viewed": 359, "published": 3, "date": "1690471434", "time_retrieved": "2024-07-30T17:42:02.424194", "image_code": "// pixel scale\n#define SCALEFAC 1.\n// color unification\n#define COLFAC 1.\n// outline threshold\n#define THRESHLD 0.05\n// line thickness\n#define STEPS 3\n// line color\n#define LINECOL vec4(0.2,0.2,0.2,1.)\n\nvec4 colorAt(vec2 uv){\n    vec4 t = texture(iChannel0,uv);\n    float r = floor( t.r * 255. / COLFAC ) * COLFAC / 255.;\n    float g = floor( t.g * 255. / COLFAC ) * COLFAC / 255.;\n    float b = floor( t.b * 255. / COLFAC ) * COLFAC / 255.;\n    return vec4(r*1.,g*1.,b,t.a);\n}\n\nvec4 colorAtO(vec2 uv){\n    return texture(iChannel0,uv);\n}\n\nvec2 deScale(vec2 uv, float factor){\n    float u = floor( uv.x / factor) * factor;\n    float v = floor( uv.y / factor) * factor;\n    return vec2(u,v);\n}\n\nfloat colorDe(vec4 col1, vec4 col2){\n    vec4 t = col1 - col2;\n    return (abs(t.r) + abs(t.g) + abs(t.b))/3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uvO = fragCoord/iResolution.xy;\n    if(uvO.x < 0. ){\n        fragColor = colorAtO(uvO);\n        return;\n    }\n    \n    vec2 uvi = deScale(fragCoord,SCALEFAC);\n    //vec2 uvi = fragCoord;\n    \n    if(uvO.x < 0.){\n        uvi = fragCoord;\n    }\n    \n    vec2 uv = uvi/iResolution.xy;\n    \n    float t1 = 0.;\n    for(int i = 1; i<=STEPS; i++){\n        vec2 uuv = uvi - vec2(0.,float(i));\n        vec2 duv = uvi + vec2(0.,float(i));\n        t1 = t1 + colorDe(colorAt(uuv/iResolution.xy),colorAt(duv/iResolution.xy));\n    }\n    t1 = t1/float(STEPS);\n    \n    float t2 = 0.;\n    for(int i = 1; i<=STEPS; i++){\n        vec2 luv = uvi - vec2(float(i),0.);\n        vec2 ruv = uvi + vec2(float(i),0.);\n        t2 = t2 + colorDe(colorAt(luv/iResolution.xy),colorAt(ruv/iResolution.xy));\n    }\n    t2 = t2/float(STEPS);\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    if(t1>=THRESHLD|| t2>=THRESHLD){\n        fragColor = LINECOL;\n    }\n    else{\n        fragColor = colorAt(uv);\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 225, 225, 477], [479, 479, 502, 502, 538], [540, 540, 576, 576, 692], [694, 694, 730, 730, 806], [808, 808, 865, 958, 2020]], "test": "untested"}
{"id": "ctlyzN", "name": "Travelling to Neon-Giza", "author": "mrange", "description": "CC0: Travelling to Giza\nSome artifacts left and the normals goes bad after\nawhile (which is the reason for the 60 sec reset)\nBut I will be travelling for a few days and thought I like to publish this before I go.\n\nMusic: RMC Nighthawk by", "tags": ["raymarch"], "likes": 60, "viewed": 1947, "published": 3, "date": "1690471249", "time_retrieved": "2024-07-30T17:42:05.657549", "image_code": "// CC0: Travelling to Neon-Giza\n//  Some artifacts left and the normals goes bad after\n//  awhile (which is the reason for the 60 sec reset)\n//  But I will be travelling for a few days and thought I like to publish this before I go.\n\n// Music: RMC Nighthawk by amazing Skaven: https://soundcloud.com/skaven252/rmc-nighthawk\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec3 col = texture(iChannel0, q).xyz;\n  col = aces_approx(col);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define REFLECT\n#define WARP_WORLD\n#define SKYBOX1\n\n//#define BACKSTEP\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define MAX_RAY_LENGTH_HI   48.0\n#define TOLERANCE_HI        0.0001\n#define MAX_RAY_MARCHES_HI  70\n#define NORM_OFF            0.001\n#define ROT(a)              mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define SCA(a)              vec2(sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#if defined(WARP_WORLD)\n#define PATHA (0.33*vec2(0.1147, 0.2093))\n#define PATHB (0.33*vec2(13.0, 3.0))\nvec3 path(float z) {\n  return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dpath(float z) {\n  return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddpath(float z) {\n  return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n#endif\n\nfloat beat() {\n float beat = 0.0;\n  beat = texture(iChannel0, vec2(0.75, 0.25)).x;\n  beat -= 0.25;\n  beat *= beat;\n  beat *= beat;\n  beat *= 100.0;\n  beat = clamp(beat, 0.0, 1.0);\n  return beat;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d/\nfloat flatTorus(vec3 p, vec2 dim) {\n  float d = length(p.xy)-dim.x;\n  d = abs(d) - dim.y;\n  vec2 w = vec2(d, abs(p.z) - dim.y);\n  return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat cappedTorus(vec3 p, vec2 sc, vec2 t) {\n  float ra = t.x;\n  float rb = t.y;\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat arc(vec2 p, vec2 sc, float ra, float rb) {\n  // sc is the sin/cos of the arc's aperture\n  p.x = abs(p.x);\n  return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                abs(length(p)-ra)) - rb;\n}\n\n#if defined(SKYBOX0)\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 glowCol0   = HSV2RGB(vec3(hoff+0.4, 0.85, 0.00125));\nconst vec3 glowCol1   = HSV2RGB(vec3(hoff+0.55, 0.85, 0.05));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.45, 0.5, 0.25));\nconst vec3 sunDir     = normalize(vec3(0., 0.5, 7.0));\n\nconst vec3 sunCol     = sunCol1;\n\nvec3 render0(vec3 ro, vec3 rd, vec3 nrd, float beat) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir, rd), 0.0);\n  float sf = 1.0001-sd;\n\n\n  col += clamp(vec3(1.0/abs(rd.y))*glowCol0, 0.0, 1.0);\n  col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += 2.0*sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), -6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n#elif defined(SKYBOX1)\n#define ROTY(a)               \\\n  mat3(                       \\\n    +cos(a) , 0.0 , +sin(a) \\\n  , 0.0     , 1.0 , 0.0     \\\n  , -sin(a) , 0.0 , +cos(a) \\\n  )\n\n#define ROTZ(a)               \\\n  mat3(                       \\\n    +cos(a) , +sin(a) , 0.0   \\\n  , -sin(a) , +cos(a) , 0.0   \\\n  , 0.0     , 0.0     , 1.0   \\\n  )\n\n#define ROTX(a)               \\\n  mat3(                       \\\n    1.0 , 0.0     , 0.0       \\\n  , 0.0 , +cos(a) , +sin(a)   \\\n  , 0.0 , -sin(a) , +cos(a)   \\\n  )\n\nconst mat3 roty       = ROTY(radians(10.0));\nconst vec3 sunDir     = normalize(vec3(0.0, -0.01, 1.0))*roty;\nconst vec3 lightPos   = vec3(0.0, -60.0, -200.0)*roty;\nconst float hoff      = 0.725;\nconst vec3 sunColor   = HSV2RGB(vec3(hoff+0.0, 0.9, 0.0005));\nconst vec3 topColor   = HSV2RGB(vec3(hoff+0.0, 0.9, 0.0001));\nconst vec3 glowColor0 = HSV2RGB(vec3(hoff+0.0, 0.9, 0.0001));\nconst vec3 glowColor2 = HSV2RGB(vec3(hoff+0.3, 0.95, 0.001));\nconst vec3 diffColor  = HSV2RGB(vec3(hoff+0.0, 0.9, .25));\n\nconst vec3 glowCol1   = HSV2RGB(vec3(hoff+0.2, 0.85, 0.0125));\nconst vec3 diffCol    = diffColor;\nconst vec3 sunCol     = sunColor;\n\nvec2 planeCoord(vec3 p, vec3 c, vec3 up, vec4 dim) {\n  vec3 d = p - c;\n  vec3 xx = (cross(up,dim.xyz));\n  vec3 yy = (cross(xx,dim.xyz));\n  return vec2(dot(d,xx), dot(d,yy));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triIso(vec2 p, vec2 q) {\n  p.x = abs(p.x);\n  vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n  float s = -sign( q.y );\n  vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                vec2( dot(b,b), s*(p.y-q.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal)  {\n  vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n  vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n  vec3 k = abs(m)*boxSize;\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n  float tN = max( max( t1.x, t1.y ), t1.z );\n  float tF = min( min( t2.x, t2.y ), t2.z );\n  if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n  outNormal = (tN>0.0) ? step(vec3(tN),t1)  : // ro ouside the box\n                         step(t2,vec3(tF))  ;  // ro inside the box\n  outNormal *= -sign(rd);\n  return vec2( tN, tF );\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  col += sunColor/(1.0+0.00001 - dot(sunDir, rd));\n  float hd = max(abs(rd.y+0.15), 0.00066);\n  col += 100.0*glowColor0/sqrt(hd);\n  col += glowColor2/(hd);\n  return col;\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 glow(vec3 ro, vec3 rd, float beat) {\n  vec3 bn;\n  vec3 bro = ro;\n  bro.y += -1000.0+70.0;\n  vec2 bi = rayBox(bro, rd, vec3(90.0, 1000.0, 90.0), bn);\n  float lightDist = distance(lightPos, ro);\n  vec3 lightDir   = normalize(lightPos-ro);\n  float g3        = 1.0+0.00001 - dot(lightDir, rd);\n  vec3 col = vec3(0.0);\n  col += 8.0*glowColor0/(g3);\n  vec3 rrd = rd*transpose(roty)*ROTX(0.027);\n  if (bi != vec2(-1.0)) {\n    float bdi = tanh_approx(0.00125*(bi.y-bi.x));\n    col += 1000.0*glowColor0*(bdi/max(rrd.y, 0.005));\n  }\n  \n  float sx = abs(rrd.x);\n  rrd.y += mix(0.00, 0.0125, beat)*(texture(iChannel0, vec2(0.5*sx, 0.75)).x-0.5);\n  col += 20.0*glowColor0/(abs(mix(mix(20.0, 0.25, beat)*rrd.y*rrd.y, abs(rrd.y), tanh_approx(4.0*sx)))+mix(2.0, 0.5, beat)*sx*sx*sx+0.0001);\n\n  col *= mix(1.0, 4.0, beat);\n  return col;\n}\n\nvec3 side(vec3 col, vec3 ro, vec3 rd, vec3 nrd, float t, float nt, vec4 dim, vec3 c) {\n  vec3 n = dim.xyz;\n\n  vec3 p = ro + rd*t;\n  vec3 np = ro + nrd*t;\n\n  vec3 r = reflect(rd, n);\n  vec3 ldiff = p - lightPos;\n  vec3 ld = normalize(ldiff);\n  vec3 rcol0 = sky(p, r);\n  float dcol = max(dot(ld, n), 0.0);\n  dcol *= dcol;\n  float aa = distance(p, np);\n  vec2 pp = planeCoord(p, c, vec3(0.0, 1.0, 0.0), dim);\n  vec2 p0 = pp;\n  vec2 p1 = pp;\n  const vec2 tri =vec2(485, sqrt(3.0)*356.0);\n  float d0 = triIso(p0, tri);\n  float d1 = triIso(p1, 0.11*tri);\n  float d = d0;\n  vec3 bcol = col;\n  float hf = smoothstep(-600.0, -400.0, p.y);\n  vec3 pcol = 3.0*diffColor*dcol;  \n  pcol += rcol0;\n  pcol = mix(clamp(col, 0.0, 0.1), pcol, hf); \n  col = mix(col, pcol, smoothstep(aa, 0.0, d));\n  col += topColor/max(0.00005*(d1-1.), 0.000025)*hf;\n  return col;\n}\n\nvec3 pyramid(vec3 col, vec3 ro, vec3 rd, vec3 nrd) {\n  const mat3 rotx = ROTX(radians(-51.8));\n  const mat3 rr0  = rotx;\n  const mat3 rr1  = rr0*ROTY(PI/2.0);\n\n  const vec3 n0   = normalize(vec3(.0, 0.0, 1.0))*rr0;\n  const vec3 c0   = vec3(0.0);\n  const vec4 dim0 = vec4(n0, -dot(c0, n0));\n\n  const vec3 n1   = normalize(vec3(.0, 0.0, 1.0))*rr1;\n  const vec3 c1   = vec3(0.0);\n  const vec4 dim1 = vec4(n1, -dot(c1, n1));\n\n  float t0  = rayPlane(ro, rd , dim0);\n  float nt0 = rayPlane(ro, nrd, dim0);\n  float t1  = rayPlane(ro, rd , dim1);\n  float nt1 = rayPlane(ro, nrd, dim1);\n  if (t1 > 0.0 && nt1 > 0.0) {\n    col = side(col, ro, rd, nrd, t1, nt1, dim1, c1);\n  }\n  if (t0 > 0.0 && nt0 > 0.0) {\n    col = side(col, ro, rd, nrd, t0, nt0, dim0, c0);\n  }\n\n\n  return col;\n}\n\nvec3 render0(vec3 ro, vec3 rd, vec3 nrd, float beat) {\n  const vec3 ro_ = vec3(0.0, 0.0, -2700.0)*roty;\n  const mat3 rrd = ROTX(-0.2)*ROTY(0.); \n  rd *= rrd;\n  ro = ro_;\n  const float rdd = 3.0;\n  const float mm = 4.0;\n\n  vec3 glowCol = glow(ro, rd, beat);\n  \n  vec3 col = sky(ro, rd); \n  col = pyramid(col, ro, rd, nrd);\n  col += glowCol;  \n  col = clamp(col, 0.0, 10.0);\n  return col;\n}\n\n#endif\n\n\nfloat g_gd;\n\nvoid warpWorld(inout vec3 p){\n#if defined(WARP_WORLD)\n  vec3 warp = path(p.z);\n  vec3 dwarp = normalize(dpath(p.z));\n  p.xy -= warp.xy;\n  p -= dwarp*dot(vec3(p.xy, 0), dwarp)*0.5*vec3(1,1,-1);\n#endif\n}\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 dfArcs(vec3 p) {\n  vec3 p1 = p;\n  float n1 = mod1(p1.z, 4.0);\n  float h1 = hash(n1);\n  float sh1 = -1.0+2.0*h1;\n  vec3 p2 = p1;\n  const mat2 rot = ROT(-PI*0.25);\n  p1.xy *= ROT(0.25*TIME*sh1);\n  p1.xy = abs(p1.xy);\n  p1.xy *= rot;\n  float d1 = cappedTorus(p1, SCA(PI*0.125*0.5), 3.0*vec2(1.0, 0.075)); \n  float d2 = flatTorus(p2, 3.0*vec2(1.0, 0.03));\n  d2 = max(d2, -d1);\n  return vec2(d1, d2);\n}\n\nfloat df(vec3 p, float t) {\n  warpWorld(p);\n  \n  vec3 p0 = p;\n  p0.y -= 3.0;\n  p0.y = -p0.y;\n  vec3 p1 = p;\n  mod1(p1.z, 4.0); \n  p1 = p1.xzy;\n  float d0 = arc(p0.xy, SCA(PI/6.0), 6.0, 0.8);\n  vec2 dd1 = dfArcs(p);\n  float d = d0;\n  d = pmax(d, -(dd1.y-0.25), 0.125);\n  d = min(d, dd1.x);\n  d = min(d, dd1.y);\n  float gd = dd1.x;\n  t = max(t-MAX_RAY_LENGTH_HI*0.5, 0.0);\n  g_gd = min(g_gd, gd+t*t*1E-4);\n  \n  return d;\n\n}\n\nfloat df(vec3 p) {\n  return df(p, 0.0);\n}\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarchHi(vec3 ro, vec3 rd, float initt, out int iter) {\n  float t = initt;\n  const float tol = TOLERANCE_HI;\n#if defined(BACKSTEP)\n  vec2 dti = vec2(1e10,0.0);\n#endif  \n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES_HI; ++i) {\n    float d = df(ro + rd*t, t);\n#if defined(BACKSTEP)\n    if (d<dti.x) { dti=vec2(d,t); }\n#endif  \n    if (d < TOLERANCE_HI || t > MAX_RAY_LENGTH_HI) {\n      break;\n    }\n    t += d;\n  }\n  \n#if defined(BACKSTEP)\n  if(i==MAX_RAY_MARCHES_HI) { t=dti.y; };\n#endif\n  iter = i;\n  \n  return t;\n}\n\n\nvec3 render1(vec3 ro, vec3 rd, vec3 nrd, vec2 sp) {\n  float beat = beat();\n  g_gd = 1E3;\n  int iter;\n  float t = rayMarchHi(ro, rd, 0.0, iter);\n  float gd = g_gd;\n  vec3 ggcol = (glowCol1)/(max(gd, 0.00125));\n  vec3 skyCol = render0(ro, rd, nrd, beat);\n  vec3 col = skyCol;\n\n  float tt = t/MAX_RAY_LENGTH_HI;\n  tt -= 0.33;\n  tt = clamp(tt, 0.0, 1.0);\n  float sfo = 1.0-exp(-9.0*tt*tt);\n\n  if (t < MAX_RAY_LENGTH_HI) {\n    vec3 p = ro+rd*t;\n    vec3 n = normal(p);\n    vec3 r = reflect(rd, n);\n    vec3 nr = reflect(nrd, n);\n    float fre0 = 1.0+dot(rd, n);\n    float fre = fre0;\n    fre *= fre;\n    float dif = dot(sunDir, n); \n  \n    float ao = 1.0-float(iter)/float(MAX_RAY_MARCHES_HI);\n    float fo = mix(0.2, 0.5, ao);\n\n    vec3 wp = p;\n    warpWorld(wp);\n    vec2 dd = dfArcs(wp);\n\n    vec3 rcol = vec3(0.0);\n    float hit = min(dd.x, dd.y);\n#if defined(REFLECT)\n    if (hit > .05) {\n      g_gd = 1E3;\n      int riter;\n      float rt = rayMarchHi(p, r, 0.5,riter);\n      float rgd = g_gd;\n      vec3 rggcol = (glowCol1)/(max(rgd, 0.00125));\n      rcol = clamp(rggcol, 0.0, 40.0);\n      rcol *= smoothstep(0.66, 0.1, tt);\n      if (rt < MAX_RAY_LENGTH_HI) {\n        rcol += diffCol*0.2;\n      } else {\n        rcol += 0.5*render0(p, r, nr, beat);\n      }\n    } else {\n    }\n    rcol += 4.0*(diffCol+0.5)*glowCol1/max(dd.x*dd.x, 0.01);\n#else\n    rcol += 0.5*render0(p, r, nr);\n    rcol += 4.0*(diffCol+0.5)*glowCol1/max(dd.x*dd.x, 0.01);\n#endif\n    col = vec3(0.0);\n    col += sunCol*dif*dif*diffCol*fo;\n    col += rcol*fre;\n  }\n\n  col = clamp(col, 0.0, 4.0);  \n  col = mix(col, skyCol, sfo);\n\n  col += clamp(ggcol, 0.0, 4.0);\n\n#if defined(SKYBOX1)\n  vec3 rrd = rd*transpose(roty)*ROTX(0.027);\n  float flash = dot(rrd, normalize(vec3(0.0, -0.2, -1.0)))+1.0005;\n  col += (0.01*vec3(0.5, 0.25, 1.0))*smoothstep(0.5, 1.0, beat)/flash;\n#endif\n\nreturn col;\n}\n\n\nvec3 effect(vec2 p, vec2 pp) {\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  float tm  = mod(TIME, 60.)-30.0;\n  float z = 5.0*tm;\n#if defined(WARP_WORLD)\n  \n  vec3 ro = path(z);\n  vec3 ww = normalize(dpath(z));\n  vec3 dd = ddpath(z);\n#else\n  vec3 ro = vec3(0.0, 0.0, z);\n  vec3 ww = normalize(vec3(0.0, 0.0, +1.0));\n  vec3 dd = vec3(0.0);\n#endif\n  vec3 uu = normalize(cross(up+dd, ww));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec2 np = p + 4.0/RESOLUTION.y;\n  vec3 rd   = normalize(-p.x*uu + p.y*vv + fov*ww);\n  vec3 nrd  = normalize(-np.x*uu + np.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd, nrd, p);\n  col -= 0.05*length(pp);\n\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = clamp(col, 0.0, 4.0); \n  col *= smoothstep(30.0, 28.0, abs(tm));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 34118, "src": "https://soundcloud.com/skaven252/rmc-nighthawk", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\nconst mat2 brot = 1.05*ROT(2.399);\n// License: Unknown, author: Dave Hoskins, found: Forgot where\nvec3 dblur(vec2 q,float rad) {\n  vec3 acc=vec3(0);\n  const float m = 0.0025;\n  vec2 pixel=vec2(m*RESOLUTION.y/RESOLUTION.x,m);\n  vec2 angle=vec2(0,rad);\n  rad=1.;\n  const int iter = 20;\n  for (int j=0; j<iter; ++j) {  \n    rad += 1./rad;\n    angle*=brot;\n    vec3 col=texture(iChannel1,q+pixel*(rad-1.)*angle).xyz;\n    acc+=clamp(col, 0.0, 1.0);\n  }\n  return acc*(1.0/float(iter));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0+2.0*q;\n  vec2 p2 = (1.0-0.025)*p;\n  vec2 q2 = 0.5+0.5*p2;\n\n  vec3 bcol = dblur(q2, 1.);\n  vec3 col = texture(iChannel0, q).xyz;\n  const vec3 mul = vec3(0.5*vec3(3.0, 1.0, 2.0))/3.0;\n  col += bcol*mul;\n  fragColor = vec4(col, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[384, 491, 517, 517, 701], [704, 704, 759, 759, 912]], "test": "untested"}
{"id": "Dllyz4", "name": "Loading colored optimised", "author": "Arkitu", "description": "[some description]", "tags": ["loading", "neon"], "likes": 2, "viewed": 215, "published": 3, "date": "1690463779", "time_retrieved": "2024-07-30T17:42:06.541186", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\n//const float CIRCLE_COUNT = 10.;\nconst float GLOBAL_RADIUS = .4;\n\n/*\n\nfragColor : output (r, g, b, a)\nfragCoor : position du pixel (x, y)\niTime : timestamp actuel en secondes\niResolution : résolution de l'écran\n\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.388, 0.478, 0.500);\n    vec3 b = vec3(-0.122, -0.164, 0.355);\n    vec3 c = vec3(0.340, 0.340, 0.340);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float step = iDate[3]/2.;\n    float CIRCLE_COUNT = (sin(step))*150.;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 baseColor = palette(iTime);\n\n    vec3 color = vec3(.0);\n\n    float unitAngle = (2.*PI)/CIRCLE_COUNT;\n    float stepSin = sin(step);\n    for (float i = 0.; i < abs(CIRCLE_COUNT); i++) {\n        if (i == 0.) {\n            continue;\n        }\n        float angle = (unitAngle + 1.01) * i;\n        float angleSin = sin(angle);\n        float angleCos = cos(angle);\n        vec2 center = vec2(\n            (\n                angleSin * stepSin\n                 + \n                angleCos * (1.-stepSin)\n            ),\n            (\n                angleSin * (1.-stepSin)\n                 + \n                angleCos * stepSin\n            )\n        )*GLOBAL_RADIUS;\n        float a = (sin(50./(length(uv-center) - ((sin(iDate[3]+(1.*i)))/10.)))/2.)/CIRCLE_COUNT;\n        float b = (sin(.01/(length(uv-center) - ((sin(iDate[3]+(1.*i)))/10.)))/2.);\n\n        color += palette(i/CIRCLE_COUNT)*a*b*500.;\n    }\n\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dllyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 316, 341, 341, 547], [549, 549, 606, 606, 1742]], "test": "untested"}
{"id": "DlsyR4", "name": "Loading with background colored", "author": "Arkitu", "description": "[some description]", "tags": ["loading", "neon"], "likes": 2, "viewed": 174, "published": 3, "date": "1690461765", "time_retrieved": "2024-07-30T17:42:07.294173", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\n//const float CIRCLE_COUNT = 10.;\nconst float GLOBAL_RADIUS = .5;\n\n/*\n\nfragColor : output (r, g, b, a)\nfragCoor : position du pixel (x, y)\niTime : timestamp actuel en secondes\niResolution : résolution de l'écran\n\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.388, 0.478, 0.500);\n    vec3 b = vec3(-0.122, -0.164, 0.355);\n    vec3 c = vec3(0.340, 0.340, 0.340);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float CIRCLE_COUNT = (sin(iDate[3]/2.))*150.;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 baseColor = palette(iTime);\n\n    vec3 color = vec3(.0);\n\n    float unitAngle = (2.*PI)/CIRCLE_COUNT;\n    for (float i = 0.; i < abs(CIRCLE_COUNT); i++) {\n        if (i == 0.) {\n            continue;\n        }\n        float angle = (1.01)*i + unitAngle * i;\n        vec2 center = vec2(\n            (\n                sin(angle)*sin(iDate[3]/2.)\n                 + \n                cos(angle)*(1.-sin(iDate[3]/2.))\n            ),\n            (\n                sin(angle)*(1.-sin(iDate[3]/2.))\n                 + \n                cos(angle)*(sin(iDate[3]/2.))\n            )\n        )*GLOBAL_RADIUS;\n        float a = (sin(50./(length(uv-center) - ((sin(iDate[3]+(1.*i)))/10.)))/2.)/CIRCLE_COUNT;\n\n        color += palette(i/CIRCLE_COUNT)*a;\n    }\n    \n    for (float i = 0.; i < abs(CIRCLE_COUNT); i++) {\n        if (i == 0.) {\n            continue;\n        }\n        float angle = (1.01)*i + unitAngle * i;\n        vec2 center = vec2(\n            (\n                sin(angle)*sin(iDate[3]/2.)\n                 + \n                cos(angle)*(1.-sin(iDate[3]/2.))\n            ),\n            (\n                sin(angle)*(1.-sin(iDate[3]/2.))\n                 + \n                cos(angle)*(sin(iDate[3]/2.))\n            )\n        )*GLOBAL_RADIUS;\n        float a = (sin(.01/(length(uv-center) - ((sin(iDate[3]+(1.*i)))/10.)))/2.);\n\n        color += palette(i/100.)*a;\n    }\n\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 316, 341, 341, 547], [549, 549, 606, 606, 2189]], "test": "untested"}
{"id": "dtXcRN", "name": "Thursday tiling experiment", "author": "mrange", "description": "CC0: Repeated tiling experiment\nSaw some twitter art. Tried it and failed to replicate it.\nStill turned out quite nice to my eyes at least.\n", "tags": ["2d"], "likes": 31, "viewed": 365, "published": 3, "date": "1690454328", "time_retrieved": "2024-07-30T17:42:08.154871", "image_code": "// CC0: Thursday tiling experiment\n//  Saw some twitter art. Tried it and failed to replicate it.\n//  Still turned out quite nice to my eyes at least.\n\n// Define for a more \"boxy\" variant\n// #define VARIANT\n\n// Define for a parallax effect suggested by Dave Hoskins in the comments\n//#define DH_VARIANT\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\nfloat height(vec2 p) {\n  vec2 n = mod(floor(p), 2.0);\n  p = fract(p);\n  p = mix(p, 1.0-p, n);\n  vec4 tcol = texture(iChannel0, p);\n  float h = 1.25*(sqrt(abs(tcol.x))); \n  return h;\n}\n\nfloat circle(vec2 p, float r) {\n#if defined(VARIANT)\n  p *= p;\n  return pow(dot(p, p), 0.25) - r;\n#else\n  return length(p) - r;\n#endif\n}\n\nfloat cell0(vec2 p) {\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d);\n  return d;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec3 layer(vec3 col, vec3 bcol, vec2 p, vec2 o, float z, float co, float aa) {\n  p /= z;\n#if defined(VARIANT)\n  p += 0.5;\n#endif\n  vec2 np = round(p);\n  vec2 cp = p - np;\n  vec2 rcp = vec2(cp.y, -cp.x);\n  vec2 hp = np*z*(0.25*0.25);\n  hp += o;\n  float h = height(hp);\n  float h0 = hash(np);\n  if (h0 > 0.5) {\n    cp = rcp;\n  }\n  float fo = dot(cp, cp);\n  float d = cell0(cp)-0.01;\n  d *= z;\n  if (h > co) {  \n    col = mix(col, bcol-0.5*fo, smoothstep(aa, -aa, d));\n  }\n  \n  return col;\n}\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  const float maxco = 1.0;\n  const float minco = 0.0;\n  const float maxi  = 9.0;\n  const float amp   = 8.0;\n  const mat2 rot    = ROT(0.2); \n  vec2 op = p;\n  vec2 o = amp*cos(vec2(1.0, 0.5)*TAU*(TIME+20.0)/(amp*30.0));\n  p += o;\n  p *= rot;\n  for (float i = 0.0; i <= maxi; ++i) {\n#if defined(DH_VARIANT)    \n    p+= i*.002*iTime;\n#endif    \n    vec3 bcol = 0.5*(1.0+cos(vec3(0.0, 1.0, 2.0)+0.5*i-0.5*TIME+length(p)));\n    float z = pow(0.5, i)*4.0;\n    float co = mix(minco, maxco, i/(maxi));\n\n    col = layer(col, bcol, p, vec2(0.0), z, co, aa);\n  }\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = max(col, 0.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[424, 424, 446, 446, 607], [609, 609, 640, 640, 745], [747, 747, 768, 768, 896], [898, 958, 979, 979, 1049], [1051, 1051, 1129, 1129, 1539], [1599, 1599, 1629, 1629, 2337], [2339, 2339, 2396, 2396, 2570]], "test": "untested"}
{"id": "mlXyR4", "name": "Fire3", "author": "ersh", "description": "New Fire. give it 10 seconds to evolve.", "tags": ["procedural", "2d", "fractal", "cloud", "fire", "generated"], "likes": 10, "viewed": 229, "published": 3, "date": "1690443779", "time_retrieved": "2024-07-30T17:42:09.139240", "image_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define OUTPUT_AVG     1    // Average 4 buffers or use only one\n#define SMOOTH         1    // Smooth output: 0=no; 1=slightly; 2=more\n#define PALETTE        0    // 0=fire, 1=blue, 2=green\n\nvec3 col(float x) {\n  return vec3(\n#if PALETTE == 0\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x-2./3., 0., 1./3.)\n#elif PALETTE == 1\n      clamp(x-2./3., 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x, 0., 1./3.)\n#elif PALETTE == 2\n      clamp(x-2./3., 0., 1./3.),\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.)\n#endif\n   ) * 3.;\n}\n\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2. + V( 0.0,  0.0)*8. + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 20.; \\\n//EOM\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y) + \\\n//          V(-s.x,  0.0) + V( 0.0,  0.0)*2.) / 5.; \\\n// EOM\n//#define AVG \\\n//  return (V(0.0, -s.y) + V(-s.x, 0.0) + V(s.x, 0.0) + V(0.0, s.y))/4.; \\\n// EOM\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n//EOM\n//#define AVG \\\n//  float avg = \\\n//         (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n//  float pt = V(0.0, 0.0); \\\n//  float diff = distance(avg, pt); \\\n//  return mix(pt, avg, smoothstep(0.0, 1.0, diff*1.5)); \\\n// EOM\n\n#define min4(a1,a2,a3,a4)               min(min(a1,a2),min(a3,a4))\n#define min8(a1,a2,a3,a4,b1,b2,b3,b4)   min(min4(a1,a2,a3,a4),min4(b1,b2,b3,b4))\n#define max4(a1,a2,a3,a4)               max(max(a1,a2),max(a3,a4))\n#define max8(a1,a2,a3,a4,b1,b2,b3,b4)   max(max4(a1,a2,a3,a4),max4(b1,b2,b3,b4))\n#define AVG \\\n  float mn = min8( \\\n          V(-s.x, -s.y),  V( 0.0, -s.y),     V( s.x, -s.y), \\\n          V(-s.x,  0.0),                     V( s.x,  0.0), \\\n          V(-s.x,  s.y),  V( 0.0,  s.y),     V( s.x,  s.y)); \\\n  float mx = max8( \\\n          V(-s.x, -s.y),  V( 0.0, -s.y),     V( s.x, -s.y), \\\n          V(-s.x,  0.0),                     V( s.x,  0.0), \\\n          V(-s.x,  s.y),  V( 0.0,  s.y),     V( s.x,  s.y)); \\\n  float avg = \\\n         (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n  float pt = V(0.0, 0.0); \\\n  float minmaxdiff = clamp(distance(mn,mx), 0.01, 0.67); \\\n  float diff = distance(avg, pt); \\\n  return mix(pt, avg, smoothstep(0.0, 1.0, diff / minmaxdiff)); \\\n// EOM\n\n#define V(X,Y)   texture(iChannel0, c + vec2(X, Y)).r\nfloat avg0(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   texture(iChannel1, c + vec2(X, Y)).r\nfloat avg1(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   texture(iChannel2, c + vec2(X, Y)).r\nfloat avg2(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   texture(iChannel3, c + vec2(X, Y)).r\nfloat avg3(in vec2 c, in vec2 s) { AVG }\n#undef V\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.a = 1.0;\n\n#if OUTPUT_AVG\n#if SMOOTH\n    vec2 s = vec2(1., 1.) / iResolution.xy;\n\tfragColor.rgb = col(\n            (avg0(uv, s) +\n             avg1(uv, s) +\n             avg2(uv, s) +\n             avg3(uv, s)) / 4.\n        );\n#else\n\tfragColor.rgb = col(\n            (texture(iChannel0,uv).r +\n            texture(iChannel1,uv).r +\n            texture(iChannel2,uv).r +\n            texture(iChannel3,uv).r) / 4.\n        );\n#endif\n\n#else\n\n#if SMOOTH\n\tfragColor.rgb = col(avg0(uv, vec2(1., 1.) / iResolution.xy));\n#else\n\tfragColor.rgb = col(texture(iChannel0,uv).r);\n#endif\n\n#endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        1     // Cause the fire to flare up\n#define SPEED           1.\n#define RAND            (hash12(uv)-0.5)/100.\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n        fragColor = vec4(vec3(pow(1.-uv.y, 4.)), 1.-pow(uv.y, 10.));\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    float c = clamp(texture(iChannel0, d).r + RAND, 0., 1.);\n    fragColor = vec4(c,0,0,v+0.0001);\n}\n\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           2.\n#define RAND            (hash12(uv)-0.4-uv.y*0.5)/100.\n//#define RAND            (hash12(uv)-0.4-distance(vec2(0.5, 0.), uv)*0.5)/100.\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 60.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n        fragColor = vec4(vec3(pow(1.-uv.y, 4.)), 1.-pow(uv.y, 10.));\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    float c = clamp(texture(iChannel0, d).r + RAND, 0., 1.);\n    fragColor = vec4(c,0,0,v+0.0001);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           2.\n#define RAND            (hash12(uv)-0.5)/100.\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 70.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n        fragColor = vec4(vec3(pow(1.-uv.y, 4.)), 1.-pow(uv.y, 10.));\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    float c = clamp(texture(iChannel0, d).r + RAND, 0., 1.);\n    fragColor = vec4(c,0,0,v+0.0001);\n}\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// (C) Copyright 2021 by Yury Ershov\n\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           2.\n#define RAND            (hash12(uv)-0.5)/100.\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 80.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n        fragColor = vec4(vec3(pow(1.-uv.y, 4.)), 1.-pow(uv.y, 10.));\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = uv + vec2(DX, DY); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    float c = clamp(texture(iChannel0, d).r + RAND, 0., 1.);\n    fragColor = vec4(c,0,0,v+0.0001);\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3220, 3220, 3277, 3277, 3913]], "test": "untested"}
{"id": "dllyzH", "name": "Colorful rnd firewrks(五彩缤纷的圆形烟花)", "author": "timmaffett", "description": "bubble fireworks ", "tags": ["bubble"], "likes": 2, "viewed": 170, "published": 3, "date": "1690436103", "time_retrieved": "2024-07-30T17:42:09.933117", "image_code": "// Fork of \"圆形烟花\" by houkinglong. https://shadertoy.com/view/dlsyRr\n// 2023-07-27 05:32:56\n\n#define HARDNESS 60.0\n#define AMOUNT 90\n#define MAX_DISTANCE 20.0\n#define SPEED 0.15\n\n#define PI  3.14159265359\n#define TAU 6.28318530717\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float res = exp2(-k * a) + exp2(-k * b);\n    return -log2(res) / k;\n}\n\nfloat sdCircle(vec2 uv, vec2 pos, float radius) {\n    return length(uv - pos) - radius;\n}\n\nfloat sdLine(vec2 uv, vec2 start, vec2 end) {\n    return 0.0;\n}\n\nfloat randomSingle(vec2 p) {\n    p = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec4 randomPoint(vec2 p) {\n    float x = randomSingle(p);\n    float y = randomSingle(vec2(x, p.x));\n    return vec4(x, y, randomSingle(vec2(y, x)), randomSingle(vec2(x, y)));\n}\n\nfloat Star(vec2 uv, float dist, vec2 id) {\n    vec4 rand = randomPoint(id);\n\n    float progress = fract(iTime * SPEED + rand.z);\n\n    vec2 dir = 2.0 * (normalize(rand.xy) - 0.5);\n\n    rand.w = clamp((rand.w - 0.5) * 999.0, -1.0, 1.0);\n    dir *= rand.w;\n\n    return smin(dist, sdCircle(uv, dir * progress * MAX_DISTANCE, 0.001) / (progress + 0.7), 200.0);\n}\n\nfloat Graph(vec2 uv, float r) {\n    float dist = sdCircle(uv, vec2(0.0, 0.0), r);\n\n    dist = Star(uv, dist, vec2(1.0, 1.0));\n\n    for (int s = 1; s < AMOUNT; ++s)\n        dist = Star(uv, dist, vec2(-1.0, s));\n\n    dist *= HARDNESS;\n\n    dist = max(dist, 0.0);\n    dist = 1.0 / (dist + 0.001);\n    dist *= clamp(0.8, 0.98, length(uv));\n\n    return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n\n    float angle = iTime * 0.4;\n\n    // compute angle for pixel and to hsv color\n    vec2 center = iResolution.xy /2.0;\n    vec2 toRing = normalize(fragCoord.xy - center);\n    float ringValue = atan(toRing.x, -toRing.y);\n    ringValue /= PI;\n    ringValue = 1. - ringValue;\n    float ringAngle = ringValue / 2.0; // scale to hsv func\n    vec3 hsv = hsb2rgb(vec3(ringAngle+angle, 0.85, 0.96));\n    \n    // 一个像素的大小\n    float scale = 1.0 / iResolution.y;\n\n    // 外圆半径\n    float outerRadius = 0.99;\n    // 内圆半径\n    float innerRadius = 0.3;\n\n    // 色值声明\n    vec3 col = vec3(0);\n    //vec3 colR = vec3(1.0, 0.0, 0.0);\n    //vec3 colG = vec3(0.0, 0.3, 0.0);\n    vec3 colB = vec3(0.2);//vec3(0.01, 0.13, 0.32);// hsv*0.1;//rotate outer ring color\n\n    float dis = length(uv);\n\n    // 圆底\n    float bg = smoothstep(scale, -scale, sdCircle(uv, vec2(0.0, 0.0), outerRadius));\n    col = mix( vec3(0.0), colB, bg);\n\n    // 渐变环\n    float ring = smoothstep(outerRadius - 0.2, outerRadius, dis);\n    col *= ring;\n\n    if (dis > outerRadius) {\n        fragColor = vec4(hsv,1.) * 0.1;//vec4(0.0);\n        return;\n    }\n\n\n\n#define COLORCENTER\n#ifdef COLORCENTER\n     if (dis < innerRadius/2.9) {\n         fragColor = vec4(hsb2rgb(vec3(ringAngle+angle, 0.85, 0.96)),1.0);//vec4(0.0, 0.1, 0.2, 1.);\n         return;\n     }\n#endif\n\n    // 增加旋转\n    float sinA = sin(angle);\n    float cosA = cos(angle);\n    mat2 rot = mat2(cosA, -sinA, sinA, cosA);\n    uv *= rot;\n\n    uv *= 3.0;\n\n    float m = Graph(uv, innerRadius);\n\n    vec3 tint = hsb2rgb(vec3(ringAngle+angle, 0.85, 0.96));//hsv;//vec3(0.0, 0.0, 1.0);\n\n    col += m * mix(tint, tint*0.8/*vec3(1.0, 1.0, 1.0)*/, m);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 265, 265, 500], [503, 543, 582, 582, 656], [658, 658, 707, 707, 747], [749, 749, 794, 794, 812], [814, 814, 842, 842, 942], [944, 944, 970, 970, 1120], [1122, 1122, 1164, 1164, 1479], [1481, 1481, 1512, 1512, 1836], [1838, 1838, 1893, 1893, 3698]], "test": "untested"}
{"id": "clscz8", "name": "rb-first", "author": "rachelboursia", "description": "This is my first shader!", "tags": ["test", "first"], "likes": 1, "viewed": 170, "published": 3, "date": "1690404950", "time_retrieved": "2024-07-30T17:42:11.129917", "image_code": "vec3 palette( float t ){\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos( 6.28318*(c*t*d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n    \n        uv = fract(uv * 2.0) - 0.5;\n    \n        float d = length(uv) * exp(-length(uv0));\n    \n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n        \n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n    \n        d = pow(0.01 / d, 2.0);\n    \n        finalColor += col * d;\n    \n    }\n    \n\n    fragColor = vec4(finalColor, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clscz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 214], [216, 216, 272, 272, 790]], "test": "untested"}
{"id": "Dtsyz8", "name": "Blended sprite particle storm", "author": "animtor120", "description": "Sprite particles blended together and then offset with some motion", "tags": ["sprite", "blend", "variance", "lagrangian", "smartblend"], "likes": 2, "viewed": 179, "published": 3, "date": "1690402260", "time_retrieved": "2024-07-30T17:42:12.140216", "image_code": "// Texture sampling function with scaling and intensity adjustment\n#define INTENSITY  1.\n#define COUNT 100.\n#define SampleTexture(U) texture(iChannel0, 2.0 * U) * INTENSITY\n\n// Texture for the mean color (you can use different textures or predefined colors)\n#define MeanTexture texture(iChannel0, 2.0 * U, 1.0) * INTENSITY\n\n// #iChannel0 \"file://angelTrumpetOne1.png\"\n// Variant texture sampling options:\n// #define MeanTexture vec4(65, 54, 46, 1) / 255.0      // Mean for Britney video\n// #define SampleTexture(U) vec4(0.5 + 0.5 * sin(120.0 * U.x))   // Gabor noise. mean = 0.5\n// #define SampleTexture(U) SmoothBlobKernel(U)         // Simple blob. mean = 0.5\n// #define MeanTexture 0.5\n\n// Background image texture (change the URL to use a different image)\n\n\n// Smooth kernel for blending particles\n#define SmoothBlobKernel(U) smoothstep(0.2, 0.0, length(U))\n\n// Function to generate a random value based on the input seed\n#define Random(seed) fract(1e4 * sin(seed + vec2(0, 73.17)))\n\nvoid mainImage(out vec4 fragColor, in vec2 U)\n{\n    // Initialize output color\n    fragColor -= fragColor;\n\n    // Get the resolution of the image\n    vec2 resolution = iResolution.xy;\n\n    // Calculate the aspect ratio\n    vec2 aspectRatio = resolution / resolution.y;\n\n    // Check if the current fragment is close to the center\n\n    // Normalize the coordinates\n    vec2 uv = U / resolution.y;\n\n    // Variables to hold the sum and sum of squares\n    float sum = 0.0;\n    float sumSquared = 0.0;\n\n    for (float i = 0.0; i < COUNT; i++)\n    {\n        // Get a random value based on the iteration index\n        vec2 randomOffset = Random(i);\n\n        // Calculate the sprite position\n        float xOff = Random(i).x;\n        vec2 spritePosition = uv * xOff - randomOffset * aspectRatio + 0.1 * cos(i + iTime + vec2(0, 1.6)); \n        spritePosition.x += xOff*.5;\n        float yOff = sin(iTime+i);\n        yOff = max(0., yOff);\n        spritePosition.y += yOff;\n        \n\n        // Calculate the kernel value\n        float kernelValue = SmoothBlobKernel(spritePosition);\n\n        // Update the sum and sum of squares\n        sum += kernelValue;\n        sumSquared += kernelValue * kernelValue;\n\n        // Accumulate the color from the texture\n        fragColor += kernelValue * SampleTexture(spritePosition);\n    }\n\n    // // Normalization\n    // if (uv.x < aspectRatio.x / 2.0)\n    // {\n    //     // Linear blend\n    //     fragColor /= sum;\n    // }\n    // else\n    // {\n        // Variance preserving blend\n        vec4 meanColor = MeanTexture;\n        fragColor = meanColor + (fragColor - sum * meanColor) / sqrt(sumSquared);\n    // }\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtsyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[988, 988, 1035, 1066, 2634]], "test": "untested"}
{"id": "ctsyz8", "name": "Loading black and white neon", "author": "Arkitu", "description": "edit : upgraded to use iDate[3] instead of iTime so that it is in sync even if it runs on different devices at the same time", "tags": ["loading", "neon"], "likes": 2, "viewed": 149, "published": 3, "date": "1690399465", "time_retrieved": "2024-07-30T17:42:12.959027", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\n//const float CIRCLE_COUNT = 10.;\nconst float GLOBAL_RADIUS = .5;\n\n/*\n\nfragColor : output (r, g, b, a)\nfragCoor : position du pixel (x, y)\niTime : timestamp actuel en secondes\niResolution : résolution de l'écran\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float CIRCLE_COUNT = (sin(iDate[3]/2.))*150.;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 baseColor = vec3(1.);\n\n    vec3 color = vec3(.0);\n\n    float unitAngle = (2.*PI)/CIRCLE_COUNT;\n    for (float i = 0.; i < abs(CIRCLE_COUNT); i++) {\n        if (i == 0.) {\n            continue;\n        }\n        float angle = (1.01)*i + unitAngle * i;\n        vec2 center = vec2(cos(angle), sin(angle))*GLOBAL_RADIUS;\n        float a = (sin(.001/(length(uv-center) - ((sin(iDate[3]+(1.*i)))/10.)))/2.);\n        color += baseColor*a;\n    }\n    \n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 329, 329, 985]], "test": "untested"}
{"id": "DtlcR8", "name": "Neon loading", "author": "Arkitu", "description": "it's my first shader", "tags": ["loading", "neon"], "likes": 1, "viewed": 168, "published": 3, "date": "1690397200", "time_retrieved": "2024-07-30T17:42:13.866601", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\n//const float CIRCLE_COUNT = 10.;\nconst float GLOBAL_RADIUS = .5;\n\n/*\n\nfragColor : output (r, g, b, a)\nfragCoor : position du pixel (x, y)\niTime : timestamp actuel en secondes\niResolution : résolution de l'écran\n\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.388, 0.478, 0.500);\n    vec3 b = vec3(-0.122, -0.164, 0.355);\n    vec3 c = vec3(0.340, 0.340, 0.340);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float CIRCLE_COUNT = (sin(iTime))*100.;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 baseColor = palette(iTime);\n\n    vec3 color = vec3(.0);\n\n    float unitAngle = (2.*PI)/CIRCLE_COUNT;\n    for (float i = 0.; i < abs(CIRCLE_COUNT); i++) {\n        float angle;\n        if (CIRCLE_COUNT > 0.) {\n            angle = unitAngle * i;\n        } else {\n            angle = unitAngle * i;\n        }\n        vec2 center = vec2(cos(angle), sin(angle))*GLOBAL_RADIUS;\n        float a = sin(.01/(length(uv-center) - ((sin(iTime+(1.*i)))/10.)))/2.;\n        color += baseColor*a;\n    }\n    \n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 316, 341, 341, 547], [549, 549, 606, 606, 1304]], "test": "untested"}
{"id": "dlXyzH", "name": "eindacor_hex_template", "author": "Eindacor_DS", "description": "it's a better hex grid, you dolt!", "tags": ["hexagons"], "likes": 2, "viewed": 98, "published": 3, "date": "1690392353", "time_retrieved": "2024-07-30T17:42:14.709347", "image_code": "#define TWOPI 6.28318530718f\n#define AA 0.001f\n#define SIXTY_DEGREES 1.0471975512f\n\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nvec2 rotateAroundAxis(vec2 point, vec2 axis, float angle) \n{\n    point -= axis;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.y * cos(angle) + point.x * sin(angle);\n    return vec2(x, y) + axis;\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nstruct AspectRatioData {\n    mat2x2 scaleMatrix;\n    mat2x2 inverseScaleMatrix;\n    float aspectRatio;\n};\n\nAspectRatioData getAspectRatioData(vec2 uvSize) {\n    float aspectRatio = uvSize.x / uvSize.y;\n    AspectRatioData aspectRatioData;\n    aspectRatioData.aspectRatio = aspectRatio;\n    aspectRatioData.scaleMatrix = mat2x2(\n        aspectRatio, 0.f,\n        0.f, 1.f\n    );\n    \n    aspectRatioData.inverseScaleMatrix = mat2x2(\n        1.f / aspectRatio, 0.f,\n        0.f, 1.f\n    );\n\n    return aspectRatioData;\n}\n\nvec3 getLocalHexCenter(vec2 uv, float hexRadius) {\n    float shortRadius = hexRadius * sin(SIXTY_DEGREES);\n    vec2 hexCenter = vec2(uv.x - mod(uv.x, 2. * shortRadius) + shortRadius,\n                            uv.y - mod(uv.y, 3. * hexRadius) + 1.5 * hexRadius);\n         \n    return vec3(hexCenter.x, hexCenter.y, distance(hexCenter, uv));\n}\n\nvec2 getHexCenter(vec2 uv, float hexRadius)\n{\n    float shortRadius = hexRadius * sin(SIXTY_DEGREES);\n    vec3 hexCenter1 = getLocalHexCenter(uv, hexRadius);\n         \n    vec2 altOffset = vec2(shortRadius, 1.5 * hexRadius);\n                            \n    vec3 hexCenter2 = getLocalHexCenter(uv + altOffset, hexRadius);\n                            \n    if (hexCenter1.z < hexCenter2.z) {\n        return hexCenter1.xy;\n    } else {\n        return hexCenter2.xy - altOffset;\n    }\n}\n\nstruct HexData {\n    // value (0 -> 1) representing the uv's value in radial space, origin is (1, 0)\n    float radialVal; \n    \n    // value (0 -> 1) representing approximity to center compared to hex radius\n    float distFromCenter;  \n    \n    // center vertex of the hexagon\n    vec2 center;           \n    \n    // locations of each vertex of the hex\n    vec2[6] vertices;  \n    \n    // locations of hex midpoints\n    vec2[6] midpoints; \n    \n    // value (0 -> 1) representing approximity to center compared to hexagon's edge\n    float edgeCoefficient;  \n    \n    // value (0 -> 1) representinglinear interpolation of radians between local triangle vertices\n    float radialLerp;      \n};\n\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec2[6] getHexMidpoints(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = hexCenter + vec2(hexRadius * sin(SIXTY_DEGREES), 0.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = rotateAroundAxis(firstVertex, hexCenter, rotationIncrement * float(i));\n    }\n    \n    return hexVertices;\n}\n\nvec2[6] getHexVertices(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = rotateAroundAxis(hexCenter + vec2(hexRadius, 0.), hexCenter, TWOPI / 12.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = rotateAroundAxis(firstVertex, hexCenter, rotationIncrement * float(i));\n    }\n    \n    return hexVertices;\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nfloat getRadialVal(vec2 hexCenter, vec2 p) {\n    float offsetAngle = getOffsetAngle(hexCenter, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nHexData getHexData(\n    vec2 uv, \n    float hexRadius) \n{\n    float aspectHexRadius = hexRadius;\n    vec2 hexCenter = getHexCenter(uv, hexRadius);\n    \n    HexData hexData;\n    hexData.radialVal = getRadialVal(hexCenter, uv);\n    hexData.center = hexCenter;\n    hexData.distFromCenter = distance(uv, hexCenter) / hexRadius;\n    hexData.vertices = getHexVertices(hexCenter, hexRadius);\n    hexData.midpoints = getHexMidpoints(hexCenter, hexRadius);\n    hexData.radialLerp = mod(hexData.radialVal, 1./6.) / (1./6.);\n     \n    return hexData;\n}\n\nfloat getLineValFromVertices(vec2 uv, vec2[6] vertices, float lineThickness) {\n    float lineVal = 0.;\n    for (int i=0; i<6; i++) {\n        vec2 first = vertices[i];\n\n        vec2 second;\n        if (i == 0) {\n            second = vertices[5];\n        } else {\n            second = vertices[i-1];\n        }\n        lineVal = max(lineVal, lineSegmentSmoothStep(first, second, uv, lineThickness, AA, true));\n    }\n    \n    return lineVal;\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat getPointVal(vec2 uv, vec2 point, float radius, float antialias) {\n    float dist = distance(uv, point);\n    return smoothstep(radius + antialias, radius - antialias, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    AspectRatioData aspectRatioData = getAspectRatioData(iResolution.xy);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * aspectRatioData.scaleMatrix;\n\n    float hexRadius = .2;\n    vec2 hexCenter = getHexCenter(uv, hexRadius);\n    \n    HexData hexData = getHexData(uv, hexRadius);\n    \n    float vertexVal = 0.;\n    for (int i=0; i<6; i++) {\n        vertexVal = max(vertexVal, getPointVal(uv, hexData.vertices[i], hexRadius * .1, AA));\n    }\n    \n    float midpointVal = 0.;\n    for (int i=0; i<6; i++) {\n        midpointVal = max(midpointVal, getPointVal(uv, hexData.midpoints[i], hexRadius * .1, AA));\n    }\n    \n    float centerVal = getPointVal(uv, hexData.center, hexRadius * .1, AA);\n    \n    float values[6];\n    values[0] = vertexVal;\n    values[1] = midpointVal;\n    values[2] = hexData.radialLerp;\n    values[3] = hexData.distFromCenter;\n    values[4] = hexData.radialVal;\n    values[5] = centerVal;\n    \n    float cycleTime = 12.;\n    float localTime = mod(iTime, cycleTime) / cycleTime;\n    \n    int currentIndex = int(localTime / (1./6.));\n    \n    \n    fragColor = vec4(values[currentIndex]);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 104, 104, 203], [205, 205, 285, 285, 374], [376, 376, 436, 436, 605], [607, 607, 720, 720, 1354], [1463, 1463, 1512, 1512, 1874], [1876, 1876, 1926, 1926, 2219], [2221, 2221, 2266, 2266, 2703], [3399, 3399, 3444, 3444, 3548], [4336, 4336, 4383, 4383, 4647], [4649, 4649, 4693, 4693, 4852], [4854, 4854, 4911, 4911, 5395], [5838, 5838, 5944, 5944, 6348], [6350, 6350, 6421, 6421, 6530], [6532, 6532, 6589, 6589, 7706]], "test": "untested"}
{"id": "dlfyRH", "name": "Hue Slider Test", "author": "timmaffett", "description": "Random test turned into Hue Slider", "tags": ["2d"], "likes": 4, "viewed": 220, "published": 3, "date": "1690386061", "time_retrieved": "2024-07-30T17:42:15.594979", "image_code": "// Fork of \"Spherical Slider Test\" by Karp. https://shadertoy.com/view/msSfDd\n// 2023-07-26 15:40:19\n\n///UV\nvec2 CenterUV(vec2 fragCoord)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy);\n\tuv = 2.0 * uv.xy / iResolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV manipulation\n    vec2 uv = AspectRatioUV(fragCoord.xy);\n    \n    vec2 center = iResolution.xy /2.0;\n \n    vec2 toRing = normalize(fragCoord.xy - center);\n    float ringValue = atan(toRing.x, -toRing.y);\n    ringValue /= PI;\n    ringValue = 1. - ringValue;\n    float ringAngle = ringValue / 2.0; // scale to hsv func\n    \n    \n    vec2 mousePos = iMouse.xy;\n    vec2 toHandle = normalize(mousePos - center);\n    \n    float value = atan(toHandle.x, -toHandle.y);\n    value /= PI;\n    value = 1. - value;\n    \n    //value = atan(normalize(mousePos - center));\n    float AA = 0.05;\n    //Visu\n    vec3 pix = vec3(uv,0);\n    pix = vec3(1.0);\n\n    float angle = iTime * 90.0;\n    angle = value * PI;\n    float angle2 = value / 2.0; // scale to hsv func\n    \n    //BackGround\n    float circleMask = Disk(uv,vec2(0.), 0.85, AA);\n    pix = mix(hsb2rgb(vec3(ringAngle, 0.83, 0.93)), pix, circleMask);\n    \n    //Handle\n    \n    vec2 pos = vec2(sin(angle),cos(angle)) * 0.75;\n    float BgMask = Disk(uv,pos, 0.45, AA);\n    pix = mix(hsb2rgb(vec3(ringAngle, 0.65, 0.96)), pix, BgMask);  // slider outer ring around dot\n    BgMask = Disk(uv,pos, 0.25, AA);\n    pix = mix(hsb2rgb(vec3(ringAngle,  0.83, 0.93)), pix, BgMask); // slider inner ring around dot\n\n    \n    pos = vec2(sin(angle),cos(angle)) * 0.75;\n    circleMask = Disk(uv,pos, 0.09, AA);\n    pix = mix(vec3(1.0), pix, circleMask);\n    circleMask = Disk(uv,pos, 0.07, AA);\n    pix = mix(hsb2rgb(vec3(angle2, 0.9, 0.92)), pix, circleMask); // inner pie\n    \n    \n    circleMask = Disk(uv,vec2(0.), 0.65, AA);\n    pix = mix(hsb2rgb(vec3(angle2, 0.62, 0.93)), pix, circleMask); //innerpie light\n    \n    //Pie\n    vec2 rotUv = RotateUV(uv, -angle/2.);\n    float pieMask = Pie(rotUv, vec2(0), angle/2., 0.65, AA);\n    pix = mix(hsb2rgb(vec3(angle2, 0.25, 0.92)), pix, pieMask);  \n    \n     \n    for(int i = 0; i < 24; i++)\n    {\n        float val = TAU/24.; \n        pos = vec2(sin(val * float(i)),cos(val * float(i))) * 0.5;\n        \n        circleMask = Disk(uv, pos, 0.02, AA);\n        pix = mix(hsb2rgb(vec3(ringAngle, 0.44, 0.83)),pix, circleMask);\n    } \n    \n    //BackGround\n    circleMask = Disk(uv,vec2(0.), 0.85, AA);\n    pix = mix(vec3(1.), pix, (1.-circleMask));\n    \n\tfragColor = vec4(pix, 1.0);\n}", "image_inputs": [], "common_code": "#define PI  3.14159265359\n#define TAU 6.28318530717\n\nconst ivec2 txClicTime = ivec2(1, 1);\n\n//HELPER\nfloat Clamp01(float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n//2DShape\nfloat Disk(vec2 uv, vec2 center, float radius, float blur) \n{\n    float sdfCircle = length(uv-center)-radius;\n\treturn Clamp01(sdfCircle * (10.0/blur));\n}\nfloat Pie(vec2 uv, vec2 center, float angle,float radius, float blur) \n{\n \n    vec2 pos = uv-center;\n    float sdfPie = sdPie( pos, vec2(sin(angle),cos(angle)), radius);\n\treturn Clamp01(sdfPie * (10.0/blur));\n}\n\n\n\n///COLOR\nvec3 HSVcolor(vec3 c)\n{\n    vec4 K = vec4(1.0, 12.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//UV\nvec2 RotateUV(vec2 uv, float angle)\n{\t\n    return uv * mat2( cos(angle), sin(angle),\n                     -sin(angle), cos(angle));\n}", "buffer_a_code": "vec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = \n    ( re.x==fragCoord.x && re.y==fragCoord.y ) \n    ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float state = loadValue(txClicTime).x;\n\n    fragColor = vec4(0.0);\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    \n    if (iMouse.z > 0.0) \n    {\n        state = iTime;\n    }\n            \n    storeValue( txClicTime, vec4(state,0.,0.,0.), fragColor, ifragCoord);\n\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 108, 139, 166, 369], [370, 370, 406, 406, 647], [650, 650, 677, 677, 912], [916, 916, 973, 996, 3238]], "test": "untested"}
{"id": "Dlfyz8", "name": "Triangle Neon", "author": "User228", "description": "Trying new stuffs ! 2nd day of forking !\n", "tags": ["neon"], "likes": 19, "viewed": 506, "published": 3, "date": "1690380002", "time_retrieved": "2024-07-30T17:42:16.353950", "image_code": "// CC0: For the neon style enjoyers\n//  Or is it synthwave style? Don't know!\n//  Anyone been tinkering with this for awhile and now want to get on with other stuff\n//  Hopefully someone enjoys it.\n\n//#define THAT_CRT_FEELING\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(vec3 c) {\n  const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nconst vec3 sunDir2      = normalize(vec3(0., 0.82, 1.0));\nconst vec3 sunDir       = normalize(vec3(0.0, 0.05, 1.0));\nconst vec3 sunCol       = HSV2RGB(vec3(0.0, 0.86, 0.0005));\nconst float mountainPos = -70.0;\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n\n//Tiles modifier\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat equilateralTriangle(vec2 p) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length(pa - ba*h);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\n\n\n\n\n\n\n\nvec3 sphereEffect(vec2 p) {\n  vec3 col ;\n  return col;\n}\nvec3 outerSkyRender(vec3 ro, vec3 rd) {\n  vec3 center = ro+vec3(-100.0, 40.0, 100.0);\n  vec4 sdim = vec4(center, 50);\n  const vec3 pn = normalize(vec3(0., 1.0, -0.8));\n  vec4 pdim = vec4(pn, -dot(pn, center)); \n  float ri = rayPlane(ro, rd, pdim);\n\n  vec3 col = vec3(0.0);\n  \n  col += sunCol/pow((1.001-((dot(sunDir, rd)))), 2.0);\n\n\n  vec3 gcol = vec3(0.0);\n\n  vec3 rp = ro + rd*ri;\n  float rl = length(rp-center);\n  float rb = 3.55*sdim.w;\n  float re = 2.45*sdim.w;\n  float rw = 0.1*sdim.w;\n  vec3 rcol = hsv2rgb(vec3(clamp((0.005*(rl+32.0)), 0.6, 0.8), 0.9, 1.0));\n  gcol = rcol*0.025;\n\n  col += gcol/max(abs(rd.y), 0.0033);\n\nreturn col;\n}\n\nvec3 triRender(vec3 col, vec3 ro, vec3 rd, inout float maxt) {\n  const vec3 tpn = normalize(vec3(0.0, 0.0, 1.0));\n  const vec4 tpdim = vec4(tpn, -2.0);\n  float tpd = rayPlane(ro, rd, tpdim);\n\n  if (tpd < 0.0 || tpd > maxt) {\n    return col;\n  }\n\n  vec3 pp = ro+rd*tpd;\n  vec2 p = pp.xy;\n  p.y = -p.y;\n\n  p *= 0.5;\n\n  const float off = 0.58;\n  vec2 op = p; \n  p.y += off;\n  const vec2 n = SCA(-PI/3.0);\n  vec2 gp = p;\n  float hoff = 0.15*dot(n, p);\n  vec3 gcol = hsv2rgb(vec3(clamp(0.7+hoff, 0.6, 0.8), 0.90, 0.02));\n  vec2 pt = p;\n  pt.y = -pt.y;\n  const float zt = 1.0;\n  float dt = equilateralTriangle(pt/zt)*zt;\n  if (dt < 0.0) {\n   col = sphereEffect(p);\n  }\n  col += (gcol/max(abs(dt), 0.001))*smoothstep(0.25, 0.0, dt);\n\n  return col;  \n}\n\n///////////////////////////MOUNTAIN\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\n\nfloat vnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    \n  vec2 u = f*f*(3.0-2.0*f);\n\n  float a = hash(i + vec2(0.0,0.0));\n  float b = hash(i + vec2(1.0,0.0));\n  float c = hash(i + vec2(0.0,1.0));\n  float d = hash(i + vec2(1.0,1.0));\n  \n  float m0 = mix(a, b, u.x);\n  float m1 = mix(c, d, u.x);\n  float m2 = mix(m0, m1, u.y);\n  \n  return m2;\n}\nfloat hiheight(vec2 p) {\n  p *= 0.25;\n  //heightFactor\n  float hf = 3.0* smoothstep(getWeight(20.0)*7.0, getWeight(1.0)*0.0, abs(p.x));\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  return hf*sum;\n  }\n\n\n\nfloat loheight(vec2 p) {\n  p *= 0.25;\n    //heightFactor\n  float hf = 4.0*smoothstep(7.0, 0.5, abs(p.x))+.5;\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    sum += a*vnoise(p)*0.7;\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;}\n\n//mountain modifier\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\nvec3 mountainRender(vec3 col, vec3 ro, vec3 rd, bool flip, inout float maxt) {\n  const vec3 tpn = normalize(vec3(0.0, 0.0, 1.0));\n  const vec4 tpdim = vec4(tpn, mountainPos);\n  float tpd = rayPlane(ro, rd, tpdim);\n\n  if (tpd < 0.0 || tpd > maxt) {\n    return col;\n  }\n\n  vec3 pp = ro+rd*tpd;\n  vec2 p = pp.xy;\n  const float cw = 1.0-0.25;\n  float hz = 0.0*TIME+1.0;\n  float lo = loheight(vec2(p.x, hz));\n  vec2 cp = p;\n  float cn = mod1(cp.x, cw);\n\n\n  const float reps = 1.0;\n\n  float d = 1E3;\n\n  for (float i = -reps; i <= reps; ++i) {\n    float x0 = (cn -0.5 + (i))*cw;\n    float x1 = (cn -0.5 + (i + 1.0))*cw;\n  \n    float y0 = hiheight(vec2(x0, hz));\n    float y1 = hiheight(vec2(x1, hz));\n    \n    float dd = segment(cp, vec2(-cw*0.5 + cw * float(i), y0), vec2(cw*0.5 + cw * float(i), y1));\n    \n    d = min(d, dd);\n  }\n\n  vec3 rcol = hsv2rgb(vec3(clamp(0.7+(0.5*(rd.x)), 0.6, 0.8), 0.95, 0.125));\n\n  float sd = 1.0001-((dot(sunDir, rd)));\n\n  vec3 mcol = col;\n  float aa = fwidth(p.y);\n  if ((dFdy(d) < 0.0) == !flip) {\n    mcol *= mix(0.0, 1.0, smoothstep(aa, -aa, d-aa));\n    mcol += HSV2RGB(vec3(0.55, 0.85, 0.8))*smoothstep(0.0, 5.0, lo-p.y);\n    col = mcol;\n    maxt = tpd;\n  }\n  col += 3.*rcol/(abs(d)+0.005+800.*sd*sd*sd*sd);\n  col += HSV2RGB(vec3(0.55, 0.96, 0.075))/(abs(p.y)+0.05);\n\n  return col;  \n}\n////////////////////////////   GROUND\nvec3 groundRender(vec3 col, vec3 ro, vec3 rd, inout float maxt) {\n  const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));\n  const vec4 gpdim = vec4(gpn, 0.0);\n  float gpd = rayPlane(ro, rd, gpdim);\n\n  if (gpd < 0.0) {\n    return col;\n  }\n  \n  maxt = gpd;\n  \n  vec3 gp     = ro + rd*gpd;\n  float gpfre = 1.0 + dot(rd, gpn);\n  gpfre *= gpfre;\n  gpfre *= gpfre;\n  gpfre *= gpfre;\n  \n  vec3 grr = reflect(rd, gpn);\n  \n  vec2 ggp    = gp.xz;\n  ggp.y += TIME;\n  float dfy   = dFdy(ggp.y);\n  float gcf = sin(ggp.x)*sin(ggp.y);\n  vec2 ggn    = mod2(ggp, vec2(1.0));\n  float ggd   = min(abs(ggp.x), abs(ggp.y));\n\n  vec3 gcol = hsv2rgb(vec3(0.7+0.1*gcf, 0.90, 0.02));\n  \n  float rmaxt = 1E6;\n  vec3 rcol = outerSkyRender(gp, grr);\n  rcol = mountainRender(rcol, gp, grr, true, rmaxt);\n  rcol = triRender(rcol, gp, grr, rmaxt);\n\n  col = gcol/max(ggd, 0.0+0.25*dfy)*exp(-0.25*gpd);\n  rcol += HSV2RGB(vec3(0.65, 0.85, 1.0))*gpfre;\n  rcol = 4.0*tanh(rcol*0.25);\n  col += rcol*gpfre;\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  float maxt = 1E6;  \n\n  vec3 col = outerSkyRender(ro, rd);\n  col = groundRender(col, ro, rd, maxt);\n  col = mountainRender(col, ro, rd, false, maxt);\n  col = triRender(col, ro, rd, maxt);\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const float fov = tan(TAU/6.0);\n  const vec3 ro = 1.0*vec3(0.0, 1.0, -4.);\n  const vec3 la = vec3(0.0, 1.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = render(ro, rd);\n#if defined(THAT_CRT_FEELING)  \n  col *= smoothstep(1.5, 0.5, length(pp));\n  col *= 1.25*mix(vec3(0.5), vec3(1.0),smoothstep(-0.9, 0.9, sin(0.25*TAU*p.y/aa+TAU*vec3(0.0, 1., 2.0)/3.0)));\n#endif  \n  col -= 0.05*vec3(.00, 1.0, 2.0).zyx;\n  col = aces_approx(col); \n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlfyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 627, 649, 649, 795], [1089, 1180, 1202, 1202, 1527], [1740, 1826, 1863, 1863, 1970], [1972, 2072, 2091, 2091, 2178], [2180, 2287, 2313, 2313, 2497], [2500, 2517, 2553, 2553, 2647], [2649, 2761, 2803, 2803, 2850], [2853, 2971, 3006, 3006, 3205], [3208, 3326, 3365, 3365, 3476], [3478, 3538, 3559, 3559, 3629], [3722, 3722, 3749, 3749, 3778], [3779, 3779, 3818, 3818, 4420], [4422, 4422, 4484, 4484, 5166], [5205, 5205, 5236, 5236, 5295], [5296, 5296, 5322, 5322, 5420], [5423, 5423, 5445, 5445, 5779], [5780, 5780, 5804, 5804, 6115], [6119, 6119, 6143, 6143, 6431], [6433, 6453, 6492, 6492, 6617], [6618, 6618, 6696, 6696, 7933], [7934, 7972, 8037, 8037, 8951], [8953, 8953, 8984, 8984, 9190], [9192, 9192, 9222, 9222, 9883], [9885, 9885, 9942, 9942, 10116]], "test": "untested"}
{"id": "DtfczH", "name": "zombie apocalypse vibes", "author": "raianmr", "description": "might become a dying light mod idk", "tags": ["filter", "red", "webcam", "gore"], "likes": 1, "viewed": 377, "published": 3, "date": "1690379874", "time_retrieved": "2024-07-30T17:42:17.260526", "image_code": "// tweak\nconst float brightness = 0.05, contrast = 1.05,\n            tMin       = 0.00, tRange   = 0.50;\nconst vec3  inWeights  = vec3(1.00, 0.00, 0.00),\n            outWeights = vec3(1.10, 0.50, 0.50);\nconst bool  useWebcam  = true;\n\n// best left unchanged\nconst vec3 lumWeights = vec3(0.2126, 0.7152, 0.0722); // https://en.wikipedia.org/wiki/Relative_luminance\n\nfloat sigmoid(float feed) {\n    return 1.0 / (1.0 + exp(-1.0 * feed));\n}\n\nvec3 grayscale(vec3 feed, float brightness, float contrast) {\n    float lum = dot(feed, lumWeights);\n    float bnw = (lum - 0.5 + brightness) * contrast + 0.5; // TODO replace with something less crude\n    \n    return vec3(bnw);\n}\n\nvec3 effect(vec3 feed) {\n    vec3  bnw      = grayscale(feed, brightness, contrast);\n    float likeness = dot(feed - bnw, inWeights);\n    float strength = smoothstep(tMin, tMin + tRange, likeness);\n    vec3  mixed    = mix(bnw, feed * outWeights, strength);\n    \n    return mixed;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 og = useWebcam \n                ? texture(iChannel0, uv) \n                : texture(iChannel1, uv);\n    \n    vec2 mi = iMouse.xy / iResolution.xy;\n    vec3 result = uv.x > mi.x \n                    ? effect(og.rgb) \n                    : og.rgb;         \n    \n\tfragColor = vec4(result, 0.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 392, 392, 437], [439, 439, 500, 500, 669], [671, 671, 695, 695, 953], [955, 955, 1010, 1010, 1355]], "test": "untested"}
{"id": "clfyR8", "name": "Snoopy's Heaven", "author": "dr2", "description": "What else could Snoopy wish for?", "tags": ["dog", "flight", "peanuts", "biplane"], "likes": 13, "viewed": 240, "published": 3, "date": "1690369185", "time_retrieved": "2024-07-30T17:42:18.268830", "image_code": "// \"Snoopy's Heaven\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (With bits from \"Doggy Dreaming\", \"Snoopy and the Red Baron 2\", \"Yellow Moth\")\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 AxToRMat (vec3 vz, vec3 vy);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_SEG   12\n#define N_FLYER 2\n\nstruct Path {\n  vec3 cpt[N_SEG], cPtOrg, cUpCirc, cDnCirc, oDir, oNorm;\n  float tLen[N_SEG], rLoop, sHzRamp, rCirc, pathDir, vfLoop, ptFac;\n};\nPath P;\n\nmat3 flyerMat[N_FLYER];\nvec3 flyerPos[N_FLYER], qHit, sunDir, qEye;\nvec2 csHeadAz, csHeadEl, csEar, szKen;\nfloat dstFar, flyVel, tCur, flSzFac, snpSzFac;\nint nFrame, idObj, idObjGrp;\nbool isSh;\nconst int idBod = 1, idHead = 2, idEar = 3, idArm = 4, idLegd = 5, idTaild = 6, idNos = 7,\n   idJaw = 8, idEye = 9, idCap = 10, idNeck = 11, idScarf = 12, idSeat = 13, idCush = 14,\n   idKenWl = 15, idKenRf = 16, idKenFl = 17,\n   idFus = 21, idPipe = 22, idWngM = 23, idStrut = 24, idWngT = 25, idTail = 26, idLeg = 27,\n   idWhl = 28, idNose = 29, idGun = 30, idPlt = 31;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHt (vec2 p)\n{\n  vec2 q, t, v;\n  float wAmp, h;\n  wAmp = 3.;\n  h = 0.00013 * dot (p, p);\n  q = 0.05 * p;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t = abs (sin (q + 2. * Noisefv2 (q) - 1.));\n    v = 1. - (1. - t) * (t + sqrt (1. - t * t));\n    h += wAmp * dot (v, v);\n    q *= 3. * mat2 (0.8, -0.6, 0.6, 0.8);\n    wAmp *= 0.25;\n  }\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.25, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  vec3 v;\n  vec2 e;\n  e = vec2 (max (0.01, 1e-5 * d * d), 0.);\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    v[j] = GrndHt (p.xz + ((j == 0) ? e.xx : (j == 1) ? e.xy : e.yx));\n  }\n  return normalize (vec3 (v.x - v.yz, e.x)).xzy;\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 ws;\n  float d, wr, h, qy;\n  int ig;\n  dMin /= flSzFac;\n  p /= flSzFac;\n  if (! isSh) d = PrRoundBoxDf (p, vec3 (1.2, 0.5, 1.1), 0.02);\n  if (isSh || d < dMin) {\n    ig = idObjGrp / 256;\n    q = p;\n    wr = -0.2 + q.z;\n    d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n       0.11 * (1. - 0.6 * wr * wr), 1.), 0.05);\n    d = max (d, - PrRoundBoxDf (q - vec3 (0., 0.16, 0.), vec3 (0.04, 0.03, 0.07), 0.04));\n    DMINQ (idObjGrp + idFus);\n    q = p;\n    q.yz -= vec2 (0.17, 0.5);\n    d = PrCylDf (q, 0.015, 0.15);\n    DMINQ (idObjGrp + idGun);\n    q = p;\n    q.y -= 0.17;\n    d = PrSphDf (q, 0.04);\n    DMINQ (idObjGrp + idPlt);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.1, 0.03, 0.8);\n    d = PrCapsDf (q, 0.02, 0.15);\n    DMINQ (idObjGrp + idPipe);\n    q = p;\n    q.yz -= vec2 (0.03, 1.1);\n    d = PrConeDf (q, vec3 (0.8, 0.6, 0.06));\n    DMINQ (idObjGrp + idNose);\n    q = p;\n    q.yz -= vec2 (((ig == 1) ? 0.12 : 0.09), 0.4);\n    qy = q.y;\n    if (ig == 1) q.y += 0.12;\n    h = (ig == 1) ? 0.24 : 0.42;\n    q.y = mod (q.y, h) - 0.5 * h;\n    d = min (1.2 - abs (q.x), abs (PrBox2Df (vec2 (abs (q.x) - 1., q.z + 0.2), vec2 (0.25, 0.05))));\n    wr = 0.47;\n    h = (q.z - 0.1) / wr;\n    d = max (SmoothMax (PrCaps2Df (vec2 (q.y, q.z + 0.25), 0.03 * (wr - h * h), wr), - d, 0.01),\n       - q.z - 0.22);\n    d = max (d, abs (qy) - 0.26);\n    q.y = qy;\n    DMINQ (idObjGrp + idWngM);\n    q = p;\n    q.yz -= vec2 (((ig == 1) ? 0.12 : 0.09), 0.42);\n    q.xz = abs (q.xz) - vec2 (0.5, 0.1);\n    d = PrCylDf (q.xzy, 0.01, ((ig == 1) ? 0.24 : 0.21));\n    DMINQ (idObjGrp + idStrut);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.1, ((ig == 1) ? 0.24 : 0.15), 0.42);\n    d = PrCylDf (q.xzy, 0.01, ((ig == 1) ? 0.12 : 0.15));\n    DMINQ (idObjGrp + idStrut);\n    q = p;\n    q.z -= -0.9;\n    wr = 0.33;\n    h = (q.z - 0.05) / wr;\n    q.x = abs (q.x);\n    d = min (0.42 - q.x, abs (q.z + 0.06));\n    d = max (SmoothMax (PrCaps2Df (vec2 (q.y, q.z + 0.18), 0.03 * (wr - h * h), wr), - d, 0.01),\n       - q.z - 0.14);\n    d = max (d, 0.02 - 1.5 * q.x - q.z);\n    DMINQ (idObjGrp + idWngT);\n    q = p;\n    wr = 0.28;\n    q.yz -= vec2 (-0.1, -0.98);\n    h = (q.z - 0.1) / wr;\n    d = min (0.24 - abs (q.y - 0.3), abs (PrBox2Df (vec2 (q.y - 0.35, q.z + 0.02), vec2 (0.16, 0.04))));\n    d = SmoothMax (PrCaps2Df (vec2 (q.x, dot (q.zy, sin (0.1 * pi + vec2 (0.5 * pi, 0.)))),\n       0.03 * (wr - h * h), wr), - d, 0.01);\n    d = max (d, - q.z - 0.04);\n    DMINQ (idObjGrp + idTail);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.135, -0.24, 0.7);\n    q.xy = Rot2D (q.xy, -0.55);\n    q.yz = Rot2D (q.yz, 0.15);\n    d = PrCylDf (q.xzy, 0.012, 0.12);\n    DMINQ (idObjGrp + idLeg);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.22, -0.34, 0.715);\n    d = PrCylDf (q.yzx, 0.01, 0.035);\n    DMINQ (idObjGrp + idLeg);\n    q.x -= 0.01;\n    d = PrCylDf (q.yzx, 0.1, 0.015);\n    DMINQ (idObjGrp + idWhl);\n  } else dMin = min (dMin, d);\n  return flSzFac * dMin;\n}\n\nfloat FObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    idObjGrp = (k + 1) * 256;\n    dMin = FlyerDf (flyerMat[k] * (p - flyerPos[k]), dMin);\n  }\n  return 0.8 * dMin;\n}\n\nfloat FObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = FObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 FObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  isSh = true;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = FObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  isSh = false;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / flSzFac;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    idObjGrp = (k + 1) * 256;\n    q = flyerMat[k] * (p - flyerPos[k]) / flSzFac - vec3 (0., 0.02, 1.07);\n    d = PrCylDf (q, 0.3, 0.007);\n    DMINQ (0);\n  }\n  return flSzFac * dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qr, ePos;\n  float dMin, d, db;\n  dMin = dstFar / snpSzFac;\n  p.y -= 11.;\n  p /= snpSzFac;\n  ePos = vec3 (0.25, 0.85, 0.3);\n  q = p;\n  q.xz = Rot2Cs (q.xz, csHeadAz);\n  q.yz = Rot2Cs (q.yz, csHeadEl);\n  qr = q;\n  q.y -= 0.7;\n  d = PrSphDf (q, 0.5);\n  d = max (d, - PrSphDf (vec3 (abs (q.x), q.y + 0.7, q.z) - ePos, 0.18));\n  q.yz = Rot2D (q.yz, -0.11 * pi);\n  q.z -= 0.6;\n  d = max (SmoothMin (d, PrSphDf (q, 0.35), 0.3), 0.06 - length (vec2 (q.y + 0.05,\n     max (0.1 - q.z, 0.))));\n  DMINQ (idHead);\n  q.y -= -0.05;\n  d = PrCylDf (q.xzy, 0.32, 0.05);\n  DMINQ (idJaw);\n  q.yz -= vec2 (0.22, 0.27);\n  d = PrSphDf (q, 0.1);\n  DMINQ (idNos);\n  q = qr;\n  q.y -= 0.7;\n  d = max (PrSphDf (q, 0.55), min (length (q.yz - vec2 (0.45, -0.25)) - 0.35,\n     min (q.z + 0.25, 0.4 - q.y)));\n  DMINQ (idCap);\n  q = qr;\n  q.x = abs (q.x);\n  qEye = q - ePos;\n  d = PrSphDf (qEye, 0.17);\n  DMINQ (idEye);\n  q = qr;\n  q.x = abs (q.x);\n  q -= vec3 (0.48, 0.7, -0.05);\n  d = PrCapsDf (q, 0.06, 0.12);\n  q.x -= 0.04;\n  q.xy = Rot2Cs (q.xy, csEar);\n  d = SmoothMin (d, SmoothMax (max (PrCaps2Df (q.zy, 0.15, 0.5), q.y),\n     abs (q.x) - 0.02, 0.03), 0.03);\n  DMINQ (idEar);\n  q = p;\n  q.yz -= vec2 (0.15, -0.1);\n  d = max (length (q.xz) - 0.15, abs (q.y) - 0.2);\n  DMINQ (idNeck);\n  q = p;\n  q.xy -= vec2 (0.1, 0.07) * CosSin (2. * pi * (q.z + tCur)) * smoothstep (0.3, 0.6, - q.z);\n  q.x = abs (q.x);\n  q -= vec3 (0.14, 0.15, -1.3);\n  d = 0.5 * PrBoxDf (q, vec3 (0.01, 0.04, 1.2));\n  DMINQ (idScarf);\n  q = p;\n  q.yz -= vec2 (-0.35, -0.05);\n  q.x *= 0.85;\n  d = PrSphDf (q, 0.45);\n  q.y -= -0.6;\n  d = SmoothMin (d, PrSphDf (q, 0.55), 0.3);\n  DMINQ (idBod);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, -0.3, 0.05);\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.yz = Rot2D (q.yz, -0.1 * pi);\n  d = PrSphDf (q, 0.11);\n  q.z -= 0.3;\n  d = SmoothMin (d, PrCapsDf (q, 0.1, 0.3), 0.05);\n  DMINQ (idArm);\n  q.yz -= vec2 (0.06, 0.34);\n  d = SmoothMax (PrCaps2Df (q.xy, 0.1, 0.05), abs (q.z) - 0.04, 0.04);\n  q.x = abs (q.x);\n  q.xy = Rot2D (q.xy - vec2 (0.05, 0.13), 0.1 * pi);\n  q.x = abs (q.x) - 0.025;\n  d = SmoothMin (d, PrSphDf (q, 0.04), 0.01);\n  DMINQ (idArm);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.4, -1.35, 0.2);\n  d = PrCapsDf (q, 0.13, 0.45);\n  DMINQ (idLegd);\n  q.yz -= vec2 (0.06, 0.52);\n  d = SmoothMax (PrCaps2Df (q.xy, 0.1, 0.06), abs (q.z) - 0.04, 0.04);\n  q.x = abs (q.x);\n  q.xy = Rot2D (q.xy - vec2 (0.05, 0.13), 0.1 * pi);\n  q.x = abs (q.x) - 0.025;\n  d = SmoothMin (d, PrSphDf (q, 0.04), 0.01);\n  DMINQ (idLegd);\n  q = p;\n  q.yz -= vec2 (-1.3, -0.6);\n  d = PrCapsDf (q, 0.07, 0.3);\n  DMINQ (idTaild);\n  q = p;\n  q.yz -= vec2 (-1.55, 0.1);\n  d = PrRoundBoxDf (q, vec3 (0.6, 0.08, 0.7), 0.02);\n  DMINQ (idSeat);\n  q = p;\n  db = dot (vec2 (abs (q.x), q.y), vec2 (1.) / sqrt(2.)) + 1.1;\n  q.yz -= vec2 (-5.4, 0.5);\n  d = max (abs (PrBox2Df (q.xz, szKen)) - 0.07,\n     max (min (- PrCaps2Df (vec2 (q.x, q.y - 0.6), 0.65, 0.75), - q.z),\n     max (db, abs (q.y - 2.1) - 2.)));\n  DMINQ (idKenWl);\n  d = max (abs (db) - 0.06, Maxv2 (abs (q.xz) - szKen - 0.3));\n  DMINQ (idKenRf);\n  d = PrBoxDf (q, vec3 (szKen + 0.3, 0.1).xzy);\n  DMINQ (idKenFl);\n  q.xz -= 0.4 * szKen;\n  d = PrRoundBoxDf (q, vec3 (0.6 * szKen, 0.1).xzy, 0.05);\n  DMINQ (idCush);\n  return snpSzFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  isSh = true;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  isSh = false;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat Insig (vec2 p, int ig)\n{\n  float s;\n  if (ig == 2) s = (1. - SmoothBump (0.08, 0.12, 0.005, length (p))) *\n     (1. - SmoothBump (-0.01, 0.03, 0.005, length (p)));\n  else s = 1. - SmoothBump (0.03, 0.06, 0.005, length (abs (p) - 0.07));\n  return s;\n}\n\nvec4 FlyerCol (int ig, int id, vec3 vn)\n{\n  vec4 col4;\n  vec2 w;\n  float s;\n  col4 = (ig == 2) ? vec4 (1., 1., 0.1, 0.2) : vec4 (1., 0.1, 0.1, 0.2);\n  if (id == idFus) {\n    if (qHit.z > 1.01) {\n      col4 = vec4 (0.9, 0.9, 0.9, 0.3);\n      if (length (abs (qHit.xy + vec2 (0., 0.05)) * vec2 (0.6, 1.)) < 0.03) col4.rgb *= 1. -\n         0.7 * SmoothBump (0.2, 0.8, 0.05, mod (64. * ((ig == 1) ? qHit.y : qHit.x), 1.));\n    }\n    w = abs (qHit.xz) - vec2 (0.09, 0.12);\n    if (abs (qHit.y - 0.1) < 0.04 && Maxv2 (w) < 0.) col4.rgb = vec3 (0.2, 0.15, 0.05);\n    col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (1.5 * qHit.yz + vec2 (0., 0.4), ig));\n  } else if (id == idWngM) {\n    col4.rgb = mix (col4.rgb, 1. - col4.rgb, step (0., qHit.z - 0.14 - 0.07 *\n       abs (sin ((8./1.2) * pi * qHit.x))));\n    s = 1.2 / 8.;\n    s = mod (qHit.x + 0.5 * s, s) - 0.5 * s;\n    col4.rgb *= 1. + 0.1 * SmoothBump (-0.01, 0.01, 0.002, s);\n    if (abs (qHit.y) > 0.1 && qHit.y * vn.y > 0.) {\n      col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (vec2 (abs (qHit.x) - 0.9, qHit.z), ig));\n    }\n  } else if (id == idWngT) {\n    col4.rgb = mix (col4.rgb, 1. - col4.rgb, step (0., qHit.z - 0.11 - 0.03 *\n       abs (sin (17. * pi * qHit.x))));\n    s = 1. / 17.;\n    s = mod (qHit.x + 0.5 * s, s) - 0.5 * s;\n    col4.rgb *= 1. + 0.1 * SmoothBump (-0.005, 0.005, 0.001, s);\n  } else if (id == idTail) {\n    col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (2.5 * qHit.yz + vec2 (-0.9, -0.25), ig));\n  } else if (id == idNose) {\n    col4 = (qHit.z > -0.04) ? mix (col4, vec4 (1., 1., 1., 0.5), 0.5) : vec4 (0.1);\n  } else if (id == idPipe) {\n    col4 = vec4 (0.8, 0.8, 0.85, 0.3) * (0.5 + 0.5 * SmoothBump (0.1, 0.9, 0.05,\n       mod (16. * qHit.z, 1.)));\n  } else if (id == idStrut || id == idLeg) {\n    col4.rgb = 0.6 * col4.rgb + vec3 (0.4);\n  } else if (id == idGun) {\n    col4.rgb = vec3 (0.6, 0.6, 0.7);\n  } else if (id == idPlt) {\n    col4 = vec4 (0.4, 0.2, 0.1, 0.);\n    if (qHit.z > 0.02 && qHit.y < 0.03) col4.rgb = (ig == 2) ? vec3 (0.9) : vec3 (0.6, 0.4, 0.4);\n    if (qHit.z > 0. && length (vec2 (abs (qHit.x) - 0.011, qHit.y - 0.015)) < 0.01)\n       col4 = vec4 (0., 0.2, 0., 0.2);\n    if (qHit.z > 0. && ig == 2 && length (qHit.xy - vec2 (0., -0.02)) < 0.012)\n       col4.rgb = vec3 (0.1);\n  } else if (id == idWhl) {\n    if (length (qHit.yz) > 0.07) col4 = vec4 (0.05);\n  }\n  return col4;\n}\n\nvec4 SnpCol (out vec2 vf)\n{\n  vec4 col4, cb4;\n  vec2 u;\n  cb4 = vec4 (0.9, 0.9, 0.92, 0.05);\n  if (idObj <= idJaw) {\n    col4 = cb4;\n    if (idObj == idBod) {\n      if (qHit.z < 0.) col4 *= 0.5 + 0.5 * smoothstep (0., 0.02,\n         PrCaps2Df (vec2 (qHit.x, qHit.y - 0.4), 0.03, 0.5));\n    } else if (idObj == idHead) {\n      col4 = (length (qEye) < 0.21) ? vec4 (0.8, 0.6, 0.2, 0.2) :\n         cb4 * (0.5 + 0.5 * step (0.03, length (qHit.yz - vec2 (0.2, 0.05))));\n    } else if (idObj == idEar) {\n      col4 *= 0.93 + 0.07 * sin (32. * pi * qHit.z);\n    } else if (idObj == idTaild) {\n      col4 *= 0.3 + 0.7 * step (-0.17, qHit.z);\n    } else if (idObj == idNos) {\n      col4 = vec4 (0.7, 0.5, 0.5, 0.);\n    } else if (idObj == idJaw) {\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2) * (0.4 + 0.6 * min (step (0.2,\n         fract (32. * (atan (qHit.z, qHit.x) / (2. * pi) + 0.5))),\n         step (0.005, abs (qHit.y))));\n    }\n  } else if (idObj <= idCush) {\n    if (idObj == idEye) {\n      col4 = vec4 (0., 0., 0.6, -1.);\n    } else if (idObj == idCap) {\n      col4 = vec4 (0.5, 0.2, 0., 0.) * (0.93 + 0.07 * sin (32. * pi * qHit.x));\n      vf = vec2 (8., 0.2);\n    } else if (idObj == idNeck || idObj == idScarf) {\n      col4 = mix (mix (vec4 (0., 1., 1., 0.2), vec4 (1., 0.3, 0.3, 0.2),\n         step (0.015, abs (qHit.y))), cb4, step (0.042, abs (qHit.y)));\n    } else if (idObj == idSeat) {\n      col4 = vec4 (0.6, 0.5, 0.1, 0.);\n    } else if (idObj == idCush) {\n      col4 = vec4 (0.7, 0.4, 0.4, 0.);\n    }\n  } else {\n    col4 = vec4 (0.8, 0.6, 0.1, 0.);\n    if (idObj == idKenWl) {\n      col4 *= (0.5 + 0.5 * step (0., PrBox2Df (qHit.xz, szKen))) *\n         (0.8 + 0.2 * smoothstep (0.08, 0.1, abs (fract (4. * qHit.y + 0.5) - 0.5)));\n      if (abs (qHit.z) > szKen.y) {\n        u = vec2 (qHit.x * sign (qHit.z - szKen.y), qHit.y - 2.75);\n        if (min (max (min (max (abs (PrCaps2Df ((u - vec2 (-0.1, 0.2)).yx, 0.2, 0.2)),\n           - PrBox2Df (u + vec2 (0.3, 0.), vec2 (0.3, 0.2))),\n           max (abs (PrCaps2Df ((u + vec2 (-0.1, 0.2)).yx, 0.2, 0.2)),\n           - PrBox2Df (u - vec2 (0.3, 0.), vec2 (0.3, 0.2)))), abs (u.x) - 0.3),\n           abs (length (u.xy) - 0.65) + 0.03) < 0.06) col4 = vec4 (0.2, 1., 1., 0.2);\n      }\n    } else if (idObj == idKenRf) {\n      col4 *= 0.8 + 0.2 * smoothstep (0.04, 0.05, abs (fract (2. * qHit.z + 0.5) - 0.5));\n      vf = vec2 (16., 0.2);\n    } else if (idObj == idKenFl) {\n      col4 *= 0.7;\n      vf = vec2 (4., 0.5);\n    }\n  }\n  return col4;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.3, 0.4, 0.8), vec3 (0.4, 0.4, 0.55), 1. - max (rd.y, 0.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = 0.7 * (0.8 + 0.5 * ff) * (vec3 (1.) - vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    fd = smoothstep (0.01, 0.1, rd.y);\n    skCol = mix (vec3 (0.8, 0.8, 0.75), vec3 (0.3, 0.4, 0.7), 0.3 + 0.7 * fd) +\n       step (0.1, sd) * vec3 (1., 1., 0.9) * min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * fd);\n  } else {\n    col = SkyBg (rd);\n  }\n  return 0.9 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, rog;\n  vec2 vf;\n  float dstGrnd, dstObj, dstFObj, sh, nDotL;\n  int ig, id;\n  csEar = CosSin (-0.4 * pi * (1. + sin (0.5 * pi * tCur)));\n  szKen = vec2 (1.6, 2.2);\n  roo = ro;\n  isSh = false;\n  dstGrnd = GrndRay (ro, rd);\n  rog = ro + dstGrnd * rd;\n  if (length (rog.xz) > dstFar - 10.) dstGrnd = dstFar;\n  dstFObj = FObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (min (dstObj, dstFObj), dstGrnd) < dstFar) {\n    if (min (dstObj, dstFObj) < dstGrnd) {\n      if (dstFObj < dstObj) {\n        dstObj = dstFObj;\n        ro += dstObj * rd;\n        vn = FObjNf (ro);\n        ig = idObj / 256;\n        id = idObj - 256 * ig;\n        col4 = FlyerCol (ig, id, flyerMat[ig] * vn);\n      } else {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = SnpCol (vf);\n      }\n    } else {\n      dstObj = dstGrnd;\n      if (dstObj < dstFar) {\n        ro = rog;\n        vf = vec2 (2., 4.);\n        vn = GrndNf (ro, dstObj);\n        col4 = mix (vec4 (0.2, 0.3, 0.1, 0.05), vec4 (0., 0.4, 0., 0.), 0.3 * Noisefv2 (ro.xz));\n      }\n    }\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      if (idObj >= idBod && idObj <= idTaild) nDotL *= sqrt (nDotL);\n      else if (idObj >= idFus && idObj <= idGun) nDotL *= nDotL;\n      if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      sh = min (FObjSShadow (ro + 0.01 * vn, sunDir), ObjSShadow (ro + 0.01 * vn, sunDir));\n      col = col4.rgb * (0.2 + 0.2 * max (dot (vn, sunDir * vec3 (-1, 1., -1.)), 0.) +\n         0.8 * sh * nDotL) + col4.a * step (0.95, sh) * pow (max (dot (sunDir,\n         reflect (rd, vn)), 0.), 32.);\n      col = mix (col, SkyBg (rd), 1. - exp2 (min (0., 4. - 7. * dstObj / dstFar)));\n    } else {\n      col = col4.rgb * (0.5 + 0.5 * max (- dot (rd, vn), 0.));\n    }\n  } else col = SkyCol (ro, rd);\n  if (TrObjRay (roo, rd) < min (dstObj, dstFar)) col = mix (col, mix (vec3 (1.), vec3 (0.8),\n     step (0.02, abs (length (qHit.xy) - 0.26))), 0.2);\n  return clamp (col, 0., 1.);\n}\n\nvoid PathSetup ()\n{\n  float hTop, sHzStr, sDnRamp, sUpRamp, pScl;\n  pScl = 0.7;\n  P.ptFac = 20. * pScl;\n  P.cPtOrg = vec3 (2. * P.pathDir, 0., -3.) * pScl;\n  hTop = 1.5 * pScl;\n  P.rLoop = 2.2 * pScl;\n  P.sHzRamp = 1. * pScl;\n  P.rCirc = 2. * pScl;\n  sDnRamp = 1.5 * pScl;\n  sUpRamp = 1.3 * sDnRamp;\n  sHzStr = sDnRamp - sUpRamp + 3. * P.sHzRamp;\n  P.vfLoop = 0.3 * pScl;\n  P.cDnCirc = P.cPtOrg + vec3 (- P.rCirc * P.pathDir, 0., -2. * P.sHzRamp);\n  P.cUpCirc = P.cPtOrg + vec3 (- P.rCirc * P.pathDir, 2. * hTop, 2. * sDnRamp + 6. * P.sHzRamp);\n  P.cpt[0] = P.cDnCirc;\n  P.cpt[0].xz += vec2 (- P.rCirc * P.pathDir, sHzStr);\n  P.cpt[1] = P.cpt[0];\n  P.cpt[1].z += sHzStr;\n  P.cpt[3] = P.cUpCirc;\n  P.cpt[3].x -= P.rCirc * P.pathDir;\n  P.cpt[4] = P.cUpCirc;\n  P.cpt[4].x += P.rCirc * P.pathDir;\n  P.cpt[2] = P.cpt[3];\n  P.cpt[2].z -= 2. * P.sHzRamp;\n  P.cpt[5] = P.cpt[4];\n  P.cpt[5].z -= 2. * P.sHzRamp;\n  P.cpt[7] = P.cPtOrg;\n  P.cpt[8] = P.cPtOrg;\n  P.cpt[6] = P.cpt[7];\n  P.cpt[6].z += 4. * P.sHzRamp;\n  P.cpt[9] = P.cDnCirc;\n  P.cpt[9].x += P.rCirc * P.pathDir;\n  P.cpt[10] = P.cDnCirc;\n  P.cpt[10].x -= P.rCirc * P.pathDir;\n  P.cpt[11] = P.cpt[0];\n  P.tLen[0] = 0.;\n  for (int k = 1; k < N_SEG; k ++) P.tLen[k] = length (P.cpt[k] - P.cpt[k - 1]);\n  P.tLen[4] = pi * P.rCirc;\n  P.tLen[8] = 2. * pi * P.rLoop * (1. + P.vfLoop);\n  P.tLen[10] = pi * P.rCirc;\n  for (int k = 1; k < N_SEG; k ++) P.tLen[k] += P.tLen[k - 1];\n}\n\nvec3 TrkPos (float t)\n{\n  vec3 r;\n  vec2 cs;\n  t *= 0.5 / (2. * pi);\n  t = fract (t);\n  cs = CosSin (2. * pi * t);\n  r.xz = vec2 (1., cs.y);\n  r.xz = 30. * cs.x * r.xz / dot (r.xz, r.xz);\n  r.y = 14. + 4. * sin (2. * pi * t);\n  r.z += 12.;\n  return r;\n}\n\nvoid FlyerPM1 (float t, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, acc, va, flVd, fpF, fpB;\n  vec2 cs;\n  float oRl, dt;\n  dt = 0.1;\n  flPos = TrkPos (t);\n  fpF = TrkPos (t + dt);\n  fpB = TrkPos (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  va = cross (acc, vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = 0.02 * length (va) * sign (va.y);\n  oRl = smoothstep (0.1, 0.2, abs (oRl)) * oRl;\n  cs = CosSin (oRl);\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid FlyerPM2 (float t, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 p, p1, p2, u;\n  vec2 cs;\n  float w, ft, ftt, s, h, oRl;\n  int ik;\n  h = 2. * sin (0.43 * pi * t) + sin (0.79 * pi * t);\n  oRl = 0.01 * pi * h;\n  t = mod (t, P.tLen[N_SEG - 1]);\n  for (int k = 1; k < N_SEG; k ++) {\n    if (t < P.tLen[k]) {\n      t -= P.tLen[k - 1];\n      p1 = P.cpt[k - 1];\n      p2 = P.cpt[k];\n      w = P.tLen[k] - P.tLen[k - 1];\n      ik = k;\n      break;\n    }\n  }\n  P.oNorm = vec3 (0., 1., 0.);\n  ftt = t / w;\n  ft = ftt;\n  if (ik == 4 || ik == 10) oRl += -0.15 * pi * SmoothBump (0.05, 0.95, 0.05, ft);\n  if (ik == 4) oRl += 2. * pi * smoothstep (0.4, 0.6, ft);\n  if (ik == 2 || ik == 6) {\n    P.oDir = p2 - p1;\n    p.xz = p1.xz + P.oDir.xz * ft * vec2 (P.pathDir, 1.);\n    p.y = p1.y + P.oDir.y * smoothstep (0., 1., ft);\n    P.oDir.y *= 6. * ft * (1. - ft);\n    P.oDir = normalize (P.oDir);\n  } else if (ik == 4) {\n    ft *= pi;\n    p = P.cUpCirc;\n    u = vec3 (- cos (ft) * P.pathDir, 0., sin (ft));\n    p.xz += P.rCirc * u.xz;\n    P.oDir = cross (P.oNorm, u);\n    P.oDir.xz *= P.pathDir;\n  } else if (ik == 8) {\n    ft = (ft < 0.5) ? ft * (1. + P.vfLoop * (1. - 2. * ft)) :\n       ft * (1. + 2. * P.vfLoop * (ft - 1.5)) + P.vfLoop;\n    p = 0.5 * (P.cpt[7] + P.cpt[8]);\n    ft *= 2. * pi;\n    u = vec3 (0., cos (ft), sin (ft));\n    p.yz += P.rLoop * (vec2 (1., 0.) - u.yz);\n    P.oNorm = u;\n    P.oDir = normalize (vec3 (0., 2. * pi * P.rLoop * vec2 (sin (ft), - cos (ft))));\n  } else if (ik == 10) {\n    ft *= pi;\n    p = P.cDnCirc;\n    u = vec3 (cos (ft) * P.pathDir, 0., - sin (ft));\n    p.xz += P.rCirc * u.xz;\n    P.oDir = cross (P.oNorm, u);\n    P.oDir.xz *= P.pathDir;\n  } else {\n    P.oDir = p2 - p1;\n    p = p1 + P.oDir * ft;\n    P.oDir = normalize (P.oDir);\n  }\n  p *= P.ptFac;\n  p.yz += vec2 (15. + 0.1 * h, 80.);\n  flPos = p;\n  if (vu > 0.) {\n    P.oDir *= -1.;\n    oRl *= -1.;\n  }\n  cs = CosSin (oRl * P.pathDir);\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) * AxToRMat (P.oDir, P.oNorm);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec2 e;\n  e = vec2 (1., 0.);\n  if (sd.z > 0.) col = 0.05 * pow (abs (sd.z), 8.) *\n     (2. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n      e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n      e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\n#define N_WIN  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, zmFac, asp, sr, azH, elH;\n  int vuId, regId;\n  bool sWin;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 66.;\n  asp = canvas.x / canvas.y;\n  sWin = true;\n  if (sWin) {\n    mSize = (1./6.) * vec2 (asp, 1.);\n    mMid[0] = (1. - mSize.y) * vec2 (- asp, -1.);\n    for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    if (sWin) {\n      for (int k = 0; k < N_WIN; k ++) {\n        msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n        if (Maxv2 (abs (msw)) < mSize.y) {\n          regId = k + 1;\n          msw /= 2. * mSize.y;\n          break;\n        }\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = k + 1;\n        break;\n      }\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 0.2 * 2. * pi * msw.x;\n    el += 0.2 * 0.5 * pi * msw.y;\n  }\n  flSzFac = 1.5;\n  snpSzFac = 0.3;\n  P.pathDir = 1.;\n  PathSetup ();\n  if (length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.01,\n     fract (tCur / 80.))) vuId = 1 - vuId;\n  flyVel = (vuId == 0) ? 0.5 : 0.5;\n  if (vuId == 0) {\n    for (int k = 0; k < N_FLYER; k ++)\n       FlyerPM1 (tCur * flyVel + ((k == 0) ? 0. : 1.), 0., flyerPos[k], flyerMat[k]);\n  } else {\n    for (int k = 0; k < N_FLYER; k ++)\n       FlyerPM2 ((tCur + ((k == 0) ? 0. : 2.)) * flyVel, 0., flyerPos[k], flyerMat[k]);\n  }\n  ro = vec3 (0., 11., 0.);\n  vd = normalize (0.5 * (flyerPos[0] + flyerPos[1]) - ro);\n  azH = atan (vd.z, - vd.x) - 0.5 * pi;\n  elH = asin (vd.y);\n  vuMat = StdVuMat (el + elH, az + azH);\n  csHeadAz = CosSin (clamp (azH, -0.3 * pi, 0.3 * pi));\n  csHeadEl = CosSin (clamp (elH, -0.1 * pi, 0.2 * pi));\n  ro.xz -= vec2 (1., 5.);\n  ro = vuMat * ro;\n  zmFac = 4.;\n  sunDir = normalize (vec3 (0.5, 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.02 * tCur);\n  dstFar = 400.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col += GlareCol (rd, sunDir * vuMat, uv);\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (vec3 (p.xy, sign (p.z) * (max (0., abs (p.z) - h)))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (vec2 (p.x, sign (p.y) * (max (0., abs (p.y) - h)))) - r;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y), vec3 (vx.z, vy.z, vz.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfyR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1894, 1894, 1917, 1917, 2250], [2252, 2252, 2286, 2286, 2806], [2808, 2808, 2839, 2839, 3068], [3070, 3070, 3106, 3106, 6078], [6080, 6080, 6103, 6103, 6297], [6299, 6299, 6333, 6333, 6517], [6519, 6519, 6541, 6541, 6797], [6799, 6799, 6837, 6837, 7112], [7114, 7114, 7138, 7138, 7422], [7424, 7424, 7459, 7459, 7643], [7645, 7645, 7667, 7667, 10934], [10936, 10936, 10969, 10969, 11152], [11154, 11154, 11175, 11175, 11430], [11432, 11432, 11469, 11469, 11743], [11745, 11745, 11775, 11775, 12001], [12003, 12003, 12044, 12044, 14384], [14386, 14386, 14413, 14413, 16882], [16884, 16884, 16906, 16906, 16989], [16991, 16991, 17023, 17023, 17793], [17795, 17795, 17830, 17830, 19834], [19836, 19836, 19855, 19855, 21259], [21261, 21261, 21284, 21284, 21514], [21516, 21516, 21583, 21583, 22120], [22122, 22122, 22189, 22189, 24142], [24144, 24144, 24187, 24187, 24621], [24641, 24641, 24697, 24697, 27762], [27764, 27764, 27796, 27796, 27896], [27898, 27898, 27931, 27931, 28020], [28022, 28022, 28068, 28068, 28115], [28117, 28117, 28150, 28150, 28177], [28179, 28179, 28221, 28221, 28272], [28274, 28274, 28317, 28317, 28394], [28396, 28396, 28440, 28440, 28516], [28518, 28518, 28551, 28551, 28624], [28626, 28626, 28648, 28648, 28675], [28677, 28677, 28699, 28699, 28726], [28728, 28728, 28773, 28773, 28865], [28867, 28867, 28912, 28912, 28950], [28952, 28952, 29009, 29009, 29092], [29094, 29094, 29124, 29124, 29237], [29239, 29239, 29270, 29270, 29334], [29336, 29336, 29370, 29370, 29532], [29534, 29534, 29570, 29570, 29776], [29810, 29810, 29834, 29834, 29946], [29948, 29948, 29972, 29972, 30115], [30117, 30117, 30142, 30142, 30326], [30328, 30328, 30349, 30349, 30504], [30506, 30506, 30535, 30535, 30747], [30749, 30749, 30788, 30788, 31040]], "test": "untested"}
{"id": "dtsyzr", "name": "Radial Sweep", "author": "mortadelo15g", "description": "Simple radial sweep", "tags": ["radial", "angle", "wipe", "sweep"], "likes": 0, "viewed": 148, "published": 3, "date": "1690363956", "time_retrieved": "2024-07-30T17:42:19.180393", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float colorAlpha;\n    float tipThreshold = (1.0 - sin(iTime)) * PI;\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float angle = atan(uv.y, uv.x);\n    \n    if (angle < 0.0) angle += 2.0 * PI;\n    \n    float startAngle = 0.0;\n    \n    startAngle += tipThreshold;\n    \n    if (angle >= startAngle) {\n        colorAlpha = 0.0;\n    } else {\n        colorAlpha = 1.0;\n    }\n\n    fragColor = vec4(vec3(colorAlpha),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 526]], "test": "untested"}
{"id": "ctlyRn", "name": "Tutorial Shader (jchacko)", "author": "jchacko", "description": "From kishimisu tutorial with changes. Just wanted to try out the tutorial and see what changes I could do to it with what he suggested. \n\nIf he reads this. THANK YOU for the tutorial!", "tags": ["tutorial"], "likes": 4, "viewed": 188, "published": 3, "date": "1690333259", "time_retrieved": "2024-07-30T17:42:20.024137", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.238, 0.210, 0.078);\n    vec3 b = vec3(0.798, 0.368, 0.958);\n    vec3 c = vec3(0.036, 0.256, 0.256);\n    vec3 d = vec3(1.917, 1.337, 2.667);\n    \n    return a + b*cos( 6.28318*(c*t*d) );\n} \n//used http://dev.thi.ng/gradients/ to pick palette\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n} \n//https://iquilezles.org/articles/distfunctions2d/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    \n    for (float i = 0.0; i < 3.0; i++){\n        uv = fract (uv * 1.4) - .5;\n\n        float d = sdOctogon( uv, 0.35 );\n\n        vec3 col = palette(length(uv0) + i*.8+ iTime*.8);\n\n        d = sin(d * 9. + iTime)/9.;\n        d = abs(d);\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n}\n    \n    \n    fragColor = vec4(finalColor, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 233], [288, 288, 330, 330, 614], [668, 668, 725, 725, 1208]], "test": "untested"}
{"id": "mtfcRn", "name": "edificio 2d", "author": "jorge2017a2", "description": "edificio 2d", "tags": ["edificio2d"], "likes": 19, "viewed": 193, "published": 3, "date": "1690320346", "time_retrieved": "2024-07-30T17:42:20.903785", "image_code": "// jorge2017a2=Jorge.F.P.\n// 25-jul-2023\n///edificio 2d\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(1.0),b,d)\n#define PI 3.141516\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n\nvec3 vI00(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.45);\nvec2 pos=vec2(4.17,5.15);\nvec2 med=vec2(1.2,0.2);\n\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p- pos, med/ 2.0, ang);\nfloat d1 = sdBox(pr, med);\ncol=DrawFigBorde(colc, col, d1);\nreturn col;\n}\n\nvec3 vI01(vec2 p, vec3 col)\n{\nvec2 pos=vec2(4.17,1);\nvec2 med=vec2(1.2,0.2);\nfloat ang =-8.0 * PI / 180.0;\nvec2 pr = Rotate(p- pos, med/ 2.0, ang);\nfloat d2 = sdBox(pr, med);\ncol = DrawFigBorde(vec3(0.45), col, d2);\nreturn col;\n\n}\n\n\nvec3 vI02(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.65);\nvec2 pos=vec2(5.08,3.23);\nvec2 med=vec2(0.15,1.75);\nfloat d5= sdBox(p-pos, med );\n    col=DrawFigBorde(colc, col, d5);\n    return col;\n}\n\n\nvec3 vI03(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.,0.,0.09);\nvec2 pos=vec2(4.01,3.1);\nvec2 med=vec2(1,1.95);\nfloat d7= sdBox(p-pos, med );\ncol=DrawFigBorde(colc, col, d7);\nreturn col;\n}\n\n\nvec3 vI04(vec2 p, vec3 col)\n{\nvec2 pos=vec2(4.13,1.29);\nvec2 med=vec2(1.125,0.1);\nfloat d9= sdBox(p-pos, med );\nfloat ang = -7.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med/2.0, ang);\nd9 = sdBox(pr, med);\ncol = DrawFigBorde(vec3(0.8), col, d9);\nreturn col;\n}\n\n\nvec3 vD01(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.22,0.33,0.45);\nvec2 pos=vec2(8.89,1.64);\nvec2 med=vec2(0.95,0.175);\nfloat d3= sdBox(p-pos, med );\nfloat ang = -10.0 * PI / 180.0;\nvec2 pr = Rotate(p- pos, med/2.0, ang);\nd3 = sdBox(pr, med);\ncol = DrawFigBorde(colc, col, d3);\n    return col;\n}\n\nvec3 vD02(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.22,0.33,0.45);\nvec2 pos=vec2(8.78,5.06);\nvec2 med=vec2(0.85,0.175);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p- pos, med/2.0, ang);\nfloat d4 = sdBox(pr, med);\ncol = DrawFigBorde(colc, col, d4);\n    return col;\n}\n\nvec3 vD03(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.47,0.6,0.72);\nvec2 pos=vec2(9.49,3.41);\nvec2 med=vec2(0.125,1.5);\nfloat d6= sdBox(p-pos, med );\n    col=DrawFigBorde(colc, col, d6);    \n    return col;\n}\n\nvec3 vD04(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.0,0.1,0.7);\ncolc=vec3(0.,0.,0.1);\nvec2 pos=vec2(8.8,3.36);\nvec2 med=vec2(0.825,1.6);\nfloat d8= sdBox(p-pos, med );\ncol=DrawFigBorde(colc, col, d8);\n\n\n pos=vec2(8.76,1.85);\n med=vec2(0.825,0.075);\nfloat d10= sdBox(p-pos, med );\nfloat ang = -8.0 * PI / 180.0;\nvec2 pr = Rotate(p- pos, med/2.0, ang);\nd10 = sdBox(pr, med);\ncol = DrawFigBorde(vec3(0.8), col, d10);\n    return col;\n}\n\n\nvec3 vD05(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.22,0.33,0.45);\nvec2 pos=vec2(9.2,3.32);\nvec2 med=vec2(0.4, 0.11);\nfloat d1= sdBox(p-pos, med );\ncol=DrawFigBorde(colc, col, d1);\nreturn col; \n}\n\nvec3 ventanaIzq(vec2 p, vec3 col)\n{\n    col=vI03(p, col);\n    col=vI00(p, col);\n    col=vI01(p, col);\n    col=vI02(p, col);\n    col=vI04(p, col);\n    return col;\n}\n\nvec3 ventanaDer(vec2 p, vec3 col)\n{\n    col=vD04(p, col);\n    col=vD01(p, col);\n    col=vD02(p, col);\n    col=vD03(p, col);\n    col=vD05(p, col);\n    return col;\n}\n\n\nvec3 E00A(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.24,3.39);\nvec2 med=vec2(0.075,3.6);\nfloat d11= sdBox(p-pos, med );\ncolOut=DrawFigBorde(colIn, colOut, d11);\n    return colOut;\n}\n\nvec3 E00B(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(7.47,3.36);\nvec2 med=vec2(0.075,3.6);\nfloat d12= sdBox(p-pos, med );\ncolOut=DrawFigBorde(colIn, colOut, d12);\n    return colOut;\n}\n\nvec3 E01(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.9,3.09);\nvec2 med=vec2(0.6,0.075);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d13 = sdBox(pr, med);\ncolOut=DrawFigBorde(colIn, colOut, d13);\n    return colOut;\n}\n\n\nvec3 E02(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.89,3.81);\nvec2 med=vec2(0.6,0.075);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d14 = sdBox(pr, med);\ncolOut=DrawFigBorde(colIn, colOut, d14);\n    return colOut;\n}\n\n\nvec3 E03(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.91,4.56);\nvec2 med=vec2(0.6,0.075);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d15 = sdBox(pr, med);\ncolOut=DrawFigBorde(colIn, colOut, d15);\n    return colOut;\n}\n\nvec3 E04(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.86,5.28);\nvec2 med=vec2(0.6,0.075);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d16 = sdBox(pr, med);\ncolOut=DrawFigBorde(colIn,colOut,d16);\n    return colOut;\n}\n\nvec3 E05(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.88,5.92);\nvec2 med=vec2(0.6,0.075);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d17 = sdBox(pr, med);\ncolOut=DrawFigBorde(colIn,colOut,d17);\n    return colOut;\n}\n\nvec3 E06(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.89,2.35);\nvec2 med=vec2(0.6,0.075);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d18 = sdBox(pr, med);\ncolOut=DrawFigBorde(colIn,colOut,d18);\n    return colOut;\n}\n\nvec3 E07(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.89,1.49);\nvec2 med=vec2(0.6,0.075);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d19 = sdBox(pr, med);\n\n\ncolOut=DrawFigBorde(colIn,colOut,d19);\n    return colOut;\n}\n\nvec3 E08(vec2 p, vec3 colOut, vec3 colIn)\n{\nvec2 pos=vec2(6.89,0.66);\nvec2 med=vec2(0.6,0.075);\nfloat ang = -5.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d19 = sdBox(pr, med);\ncolOut=DrawFigBorde(colIn,colOut,d19);\n    return colOut;\n}\n\nvec3 Escalera(vec2 p, vec3 col)\n{\n    vec2 pp=p;\n    col=E01(pp,col,vec3(0.65));\n    col=E02(pp,col,vec3(0.65));\n    col=E03(pp,col,vec3(0.65));\n    col=E04(pp,col,vec3(0.65));\n    col=E05(pp,col,vec3(0.65));\n    col=E06(pp,col,vec3(0.65));\n    col=E07(pp,col,vec3(0.65));\n    col=E08(pp,col,vec3(0.65));\n    col=E00A(p,col,vec3(0.5));\n    col=E00B(p,col,vec3(0.5));\n    \nreturn col;\n}\n\nvec3 EscaleraB(vec2 p, vec3 col)\n{\n    vec2 pp=p;\n    col=E01(pp,col,vec3(0.0));\n    col=E02(pp,col,vec3(0.0));\n    col=E03(pp,col,vec3(0.0));\n    col=E04(pp,col,vec3(0.0));\n    col=E05(pp,col,vec3(0.0));\n    col=E06(pp,col,vec3(0.0));\n    col=E07(pp,col,vec3(0.0));\n    col=E08(pp,col,vec3(0.0));\n    col=E00A(p,col,vec3(0.0));\n    col=E00B(p,col,vec3(0.0));\n    \nreturn col;\n}\n\n\nvec3 lineah(vec2 p, float posy, vec3 colOut)\n{\nfloat d1=abs(p.y-posy);\nvec3 col= DrawFigBorde(vec3(0.0,1.0,0.0), colOut, d1);\nreturn col;\n}\n\nvec3 lineav(vec2 p, float posx, vec3 colOut)\n{\nfloat d1=abs(p.x-posx)-0.01;\nvec3 col= DrawFigBorde(vec3(0.0), colOut, d1);\nreturn col;\n}\n\n\nvec3 dibujarfx(vec2 p, vec3 col)\n{    float d1=0.1*sin(p.y*5.0)+p.x-0.07;\n    float d2=(-p.x-11.0);\n    d1=intersectSDF(d1,d2);\n    col= DrawFigBorde(vec3(0.4),col, d1 );\n    return col;\n}\n\nvec3 Edificio(vec2 p, vec3 col)\n{   col= dibujarfx(p-vec2(10.5,0.0),col);\n    col=ventanaIzq(p,col);\n    col=ventanaDer(p,col);\n    col=EscaleraB(p-vec2(-0.35,0.155),col);\n    col=Escalera(p,col);\n    col=lineav(p,2.0, col);\n    col=lineav(p,10.5, col);   \nreturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(-1.2,-0.5);\n    uv*=5.0;\n    uv.y+=iTime;\n    vec3 col=vec3(0.5,0.02,0.2);\n    uv.y=mod(uv.y,5.4);\n    col=Edificio(uv,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 287, 287, 314], [315, 315, 358, 358, 385], [386, 386, 434, 434, 462], [465, 481, 529, 529, 607], [609, 609, 644, 644, 667], [669, 669, 706, 706, 778], [780, 780, 832, 832, 939], [943, 943, 979, 979, 1024], [1030, 1030, 1092, 1092, 1218], [1219, 1219, 1300, 1300, 1428], [1430, 1430, 1494, 1494, 1565], [1569, 1569, 1598, 1598, 1817], [1819, 1819, 1848, 1848, 2049], [2052, 2052, 2081, 2081, 2240], [2243, 2243, 2272, 2272, 2425], [2428, 2428, 2457, 2457, 2684], [2687, 2687, 2716, 2716, 2977], [2979, 2979, 3008, 3008, 3244], [3246, 3246, 3275, 3275, 3447], [3449, 3449, 3478, 3478, 3874], [3877, 3877, 3906, 3906, 4067], [4069, 4069, 4104, 4104, 4232], [4234, 4234, 4269, 4269, 4397], [4400, 4400, 4444, 4444, 4589], [4591, 4591, 4635, 4635, 4780], [4782, 4782, 4825, 4825, 5032], [5035, 5035, 5078, 5078, 5286], [5289, 5289, 5332, 5332, 5540], [5542, 5542, 5585, 5585, 5791], [5793, 5793, 5836, 5836, 6042], [6044, 6044, 6087, 6087, 6293], [6295, 6295, 6338, 6338, 6546], [6548, 6548, 6591, 6591, 6797], [6799, 6799, 6832, 6832, 7184], [7186, 7186, 7220, 7220, 7564], [7567, 7567, 7613, 7613, 7706], [7708, 7708, 7754, 7754, 7844], [7847, 7847, 7881, 7881, 8035], [8037, 8037, 8070, 8070, 8307], [8310, 8310, 8367, 8367, 8640]], "test": "untested"}
{"id": "DtXyzr", "name": "death of a logo", "author": "flockaroo", "description": "and for the fun of it - here's another one ...because the bird deserves some attention - shortly after its death ;-)", "tags": ["logo", "x", "twitter"], "likes": 34, "viewed": 406, "published": 3, "date": "1690315465", "time_retrieved": "2024-07-30T17:42:21.796399", "image_code": "// created by florian berger (flockaroo) - 2033\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// death of a logo\n\nfloat linstep(float a, float b, float x) { return clamp((x-a)/(b-a),0.,1.); }\nfloat smin(float a, float b, float k) { return mix(a,b,linstep(-2.*k,2.*k,a-b))-k*linstep(-2.*k,0.,-abs(a+b)); }\nfloat smax(float a, float b, float r) { return -smin(-a,-b,r); }\n\nfloat X11=0.;\n\nfloat distX2(vec2 p)\n{\n    float W=.8;\n    float H=1.;\n    float w1=.15;\n    float w2=.04;\n    float w3=.03;\n    float sr=.007;\n    float dX11=.015;\n    \n    float d=10000.;\n    \n    float d1,d2,dh,dThick;\n    dh=abs(p.y)-H*.5;\n    \n    vec2 Xn;\n    \n    Xn=normalize(vec2(H+.05-X11*.03,W+X11*.03));\n    float d10=dot(p,Xn);\n    d1=abs(d10)-w1*.5;\n    d1=smax(d1,dh,sr);\n    \n    Xn=normalize(vec2(-(H-.05+X11*.03),W-X11*.03));\n    float d20=dot(p,Xn);\n    d2=abs(d20+X11*(w2+dX11)*.5*sign(d10))-w2*.5;\n    d2=smax(d2,dh,sr);\n    \n    d=smin(d1,d2,sr);\n    d=smax(d,-d1-w3-X11*w1,sr);\n    d=smax(d,-abs(d20)+(dX11*(-1.5+2.*X11)),sr);\n    return d;\n}\n\nfloat D=.15;\nfloat distX(vec3 p)\n{\n    float sr=.007;\n    float d=distX2(p.xy);\n    float dThick=abs(p.z)-D*.5;\n    d=smax(d,dThick,sr);\n    return d;\n}\n\nfloat distTw2(vec2 p) {\n    float d1,d2,d=1000.;\n    d1=length(p)-1.;\n    d=min(d,d1);\n    d1=length(p-vec2(-.5,-.04))-.8;\n    d=max(d,-d1);\n    d=max(d,p.y);\n    d1=length(p-vec2(.647,.06))-.36;\n    d=min(d,d1);\n\n    float dw=1000.;\n    d1=length(p-vec2(.01,-.31))-.38;\n    d2=length(p-vec2(-.28,-.08))-.366;\n    d1=max(d1,-d2);\n    dw=min(dw,d1);\n    \n    d1=length(p-vec2(-.11,-.08))-.367;\n    d2=length(p-vec2(-.3,.235))-.366;\n    d1=max(d1,-d2);\n    dw=min(dw,d1);\n\n    d1=length(p-vec2(-.105,.17))-.367;\n    d2=length(p-vec2(.365,.955))-1.;\n    dw=min(dw,d1);\n    dw=min(dw,length(p-vec2(.3,0))-.3);\n    dw=max(dw,-d2);\n    \n    float ds=1000.;\n    d1=length(p-vec2(.66,.6))-.53;\n    d2=length(p-vec2(.73,1.07))-.8;\n    d1=max(d1,-d2);\n    d1=max(d1,-(p.x-.85));\n    ds=min(ds,d1);\n    d1=length(p-vec2(.5,.7))-.82;\n    d2=length(p-vec2(.9,1.))-.81;\n    d1=max(d1,-d2);\n    d1=max(d1,-(p.x-.85));\n    ds=min(ds,d1);\n    \n    d=min(d,dw);\n    d=min(d,ds);\n\n    return d;\n}\n\nfloat distTwX(vec3 p)\n{\n    p.xy+=vec2(.3,-.3);\n    float d=distTw2(p.xy);\n    d=smax(d,abs(p.z)-.15,.02);\n    if(iTime>2.0) d=smax(d,-distX2((p.xy-vec2(.63,.17))*7.)/7.,.007);\n    if(iTime>2.6) d=smax(d,-distX2((p.xy-vec2(.80,.17))*7.)/7.,.007);\n    float dz=length((p.xy-vec2(1.02,.2))*vec2(1.8,.65)*.8)-.1;\n    dz=smax(dz,dot(p.xy-vec2(1.02,.2),vec2(-.2,.9)),.017);\n    dz=smax(dz,-(abs(dot(p.xy-vec2(1.02,.2),vec2(1,0)))+.005-(p.y-.2)*.1),.02);\n    float dpy=(p.y/.2-1.);\n    dz=smax(dz,abs(p.z+D-.01-dpy*.15-.15*dpy*dpy)-.02,.01);\n    if(iTime>3.2) d=min(d,dz);\n    return d;\n}\n\nfloat distFloor(vec3 p)\n{\n    return p.z+.5;\n}\n\nfloat dist(vec3 p)\n{\n    float d=10000.;\n    d=min(d,distTwX(p.xzy/.7)*.7);\n    d=min(d,distFloor(p));\n    return d;\n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps*.5,0); \n    return vec3(dist(p+d.xyy)-dist(p-d.xyy),dist(p+d.yxy)-dist(p-d.yxy),dist(p+d.yyx)-dist(p-d.yyx))/eps; \n}\n\nfloat DOF_Apert=.0;\nfloat DOF_FocalD=5.3;\n\n#define PIH 1.57079632679\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\n#define RandTex iChannel1\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-iResolution.xy*.5)/iResolution.x*2.;\n    dir=normalize(vec3(0,0,-4.)+vec3(sc,0));\n    pos=vec3(0,0,5.5);\n    pos+=sin(iTime*100.*vec3(1,1.3,.7))*.1*step(2.0,iTime)*exp(-(iTime-2.0)/.07);\n    pos+=sin(iTime*100.*vec3(1.3,.7,1))*.1*step(2.6,iTime)*exp(-(iTime-2.6)/.07);\n    pos+=sin(iTime*100.*vec3(.7,1,1.3))*.1*step(3.2,iTime)*exp(-(iTime-3.2)/.07);\n    pos+=vec3(cos(iTime*2.*vec2(.7,1))*.01,0);\n    pos+=vec3(cos(iTime*3.*vec2(1,.7))*.005,0);\n    vec4 r=(texelFetch(RandTex,(ivec2(fc)+iFrame*ivec2(13,61))%256,0)-.5);\n    pos.xy+=r.xy*DOF_Apert;\n    dir.xy-=r.xy*DOF_Apert/DOF_FocalD;\n    float ph = iMouse.x/iResolution.x*10.+.45+cos(iTime*1.)*.05;\n    float th = iMouse.y/iResolution.y*10.+1.25;\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n}\n\n#define PIH 1.57079632679\n\nvoid march(inout vec3 p, vec3 dir)\n{\n    for(int i=0;i<80;i++) {float d=dist(p); p+=dir*d; if(d<.001) break; }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n\n    march(pos,dir);\n    vec3 n=normalize(getGrad(pos,.001));\n    float ao=1.; float sc=.01; for(int i=0;i<16;i++) { ao*=.88+.12*clamp(dist(pos+n*sc)/sc,0.,1.);  sc*=1.5; if(sc>1.) break; }\n    vec3 R=reflect(dir,n);\n    float fres=1.-abs(dot(dir,n));\n    fres*=fres*fres*fres;\n    fres=fres*.8+.2;\n    \n    float isFloor=0.; if (dist(pos)==distFloor(pos)) isFloor=1.;    \n    \n    fragColor.xyz=vec3(1);\n    fragColor.xyz=n*.1+.9;\n    fragColor.xyz*=mix(vec3(.2,.7,1),vec3(1),isFloor);\n    fragColor.xyz=mix(fragColor.xyz,texture(iChannel0,R).xyz,fres);\n    fragColor.xyz*=ao;\n    fragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXyzr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[156, 156, 198, 198, 233], [234, 234, 273, 273, 346], [347, 347, 386, 386, 411], [428, 428, 450, 450, 1077], [1092, 1092, 1113, 1113, 1231], [1233, 1233, 1256, 1256, 2210], [2212, 2212, 2235, 2235, 2794], [2796, 2796, 2821, 2821, 2842], [2844, 2844, 2864, 2864, 2962], [2964, 2964, 2998, 2998, 3136], [3302, 3302, 3358, 3358, 4189], [4218, 4218, 4254, 4254, 4330], [4332, 4332, 4389, 4389, 5041]], "test": "untested"}
{"id": "ctfyzr", "name": "human shader", "author": "texl", "description": "Computer version of https://humanshader.com/", "tags": ["humanshader"], "likes": 1, "viewed": 288, "published": 3, "date": "1690314126", "time_retrieved": "2024-07-30T17:42:22.931364", "image_code": "int roundn(int v, int n)\n{\n    return int(round(float(v) / pow(10.0f, float(n))));\n}\n\nvec3 human_shader(const ivec2 coord)\n{\n    int x = coord.x;\n    int y = coord.y;\n\n    // A\n    int u = x - 36;\n    int v = 18 - y;\n    int h = u * u + v * v;\n    \n    int c_r = 0;\n    int c_b = 0;\n    \n    if (h < 200)\n    {\n        // B - sphere\n        c_r = 420;\n        c_b = 520;\n        int t = 5000 + 8 * h;\n        int p = roundn(t * u, 2);\n        int q = roundn(t * v, 2);\n        int s = 2 * q;\n        int w = roundn(1000 + p - s, 2) + 8;\n\n        if (w > 0)\n        {\n            c_r = c_r + w * w;\n        }\n        \n        int o = s + 2200;\n        c_r = roundn(c_r * o, 4);\n        c_b = roundn(c_b * o, 4);\n        \n        if (p > -q)\n        {\n            w = roundn(p + q, 1);\n            c_r = c_r + w;\n            c_b = c_b + w;\n        }\n    }\n    else if (v < 0)\n    {\n        // C - ground\n        c_r = 150 + 2 * v;\n        c_b = 50;\n        int p = h + 8 * v * v;\n        int c = 240 * (-v) - p;\n\n        if (c > 1200)\n        {\n            int o = roundn(6 * c, 1);\n            o = c * (1500 - o);\n            o = roundn(o, 2) - 8360;\n            c_r = roundn(c_r * o, 3);\n            c_b = roundn(c_b * o, 3);\n        }\n\n        int r = c + u * v;\n        int d = 3200 - h - 2 * r;\n\n        if (d > 0)\n        {\n            c_r = c_r + d;\n        }\n    }\n    else\n    {\n        // D - sky\n        int c = x + 4 * y;\n        c_r = 132 + c;\n        c_b = 192 + c;\n    }\n    \n    if (c_r > 255)\n    {\n        c_r = 255;\n    }\n    \n    if (c_b > 255)\n    {\n        c_b = 255;\n    }\n    \n    int c_g = roundn(7 * c_r + 3 * c_b, 1);\n\n    return vec3(c_r, c_g, c_b) / 255.0f;\n}\n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 gridSize = vec2(71, 40);\n    const vec2 highlightCoord = vec2(49, 20);\n\n    // normalize\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // flip y\n    uv.y = 1.0 - uv.y;\n\n    // correct aspect\n    vec2 ratio = vec2(iResolution) / gridSize;\n    vec2 aspectCorrection = ratio / min(ratio.x, ratio.y);\n    uv *= aspectCorrection;\n    \n    vec2 coord = floor(uv * gridSize);\n    vec3 humanShaderCol = human_shader(ivec2(coord));\n    \n    vec2 grid = 3.0f * (1.0f - 2.0f * abs(fract(uv * vec2(gridSize)) - 0.5f));\n    vec3 gridCol = vec3(min(grid.x, grid.y));\n        \n    float highlight = max(1.0f - length(highlightCoord - coord), 0.0f);\n    float pulse = max(sin(iTime * 4.0f), 0.0f);\n    vec3 highlightCol = vec3(highlight) * pulse;\n\n    vec3 col = highlightCol + min(gridCol, humanShaderCol);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 84], [86, 86, 124, 124, 1686], [1688, 1688, 1713, 1713, 1748], [1750, 1750, 1807, 1807, 2678]], "test": "untested"}
{"id": "DlXyzr", "name": "Just a simple gradient", "author": "mrange", "description": "CC0: Just a simple gradient\nCreated while listening to a twitch stream\n", "tags": ["2d"], "likes": 11, "viewed": 329, "published": 3, "date": "1690314121", "time_retrieved": "2024-07-30T17:42:23.910745", "image_code": "// CC0: Just a simple gradient\n//  Created while listening to a twitch stream\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 4.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  const mat2 rot = ROT(1.0*PI/4.0);\n  p*=rot;\n\n  vec3 col0 = (1.0+cos(vec3(0.0, 1.0, 2.0)+1.0*(p.y*p.y*p.x-p.x)-0.25*TIME))*0.5;\n  vec3 col1 = sqrt(0.5)*col0*col0;\n\n  float n = mod1(p.y, 1.0/128.0);\n  float t = smoothstep(0.0, -aa, p.y);\n  if (mod(n, 2.0) == 0.0) {\n    t = 1.0-t;\n  }\n  vec3 col  = mix(col0, col1, t);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 343, 382, 382, 507], [509, 509, 565, 565, 1063]], "test": "untested"}
{"id": "ds2BWt", "name": "Neon Sliders", "author": "StefanPijnacker", "description": "My second attempt on a shader. Applied some of the techniques that I learned from kishimisu's awesome shader tutorial together with some tricks I already knew.", "tags": ["2d", "neon"], "likes": 4, "viewed": 176, "published": 3, "date": "1690309369", "time_retrieved": "2024-07-30T17:42:24.705620", "image_code": "vec2 Rotate(vec2 uv, float angle)\n{\n    float rad = angle * (3.141594 / 180.0);\n    mat2 rot = mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n    \n    return uv * rot;\n}\n\nvec3 palletes(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a + b * cos(6.28316 * (c * t + d));\n}\n\nfloat angles[4] = float[4](50., 120., 240., 0.);\nfloat zooms[4] = float[4](0.85f, 1.2f, 0.6, 1.0f);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 palls[4];\n    \n    palls[0] = palletes(uv.x * uv.y + iTime * 0.2, vec3(0.424,0.784,0.855), \n    vec3(0.098,0.416,0.525), vec3(1.0, 1.0, 1.0),vec3(0.173,0.745,0.886));\n    palls[1] = palletes(uv.x * uv.y + iTime * 0.7, vec3(0.938, 0.328, 0.718),\n    vec3(0.659, 0.483, 0.328), vec3(0.388, 0.388, 0.296), vec3(2.538, 2.478, 0.168));\n    palls[2] = palls[0];\n    palls[3] = palls[1];\n\n    float time = iTime * 0.5;\n    int i = int(time) % 4;\n    int i2 = (i + 1) % 4;\n    \n    float t = smoothstep(0.0, 0.3, fract(time));\n    float offset = mix(angles[i], angles[i2], t);\n    float zoomM = mix(zooms[i], zooms[i2], t);\n    uv *= zoomM;\n\n    uv = Rotate(uv, iTime * 5. + offset);\n    vec3 tex = vec3(texture(iChannel0, uv).rgb);\n    \n    vec3 pal = mix(palls[i], palls[(i + 1) % 4], t);\n\n    vec3 color = tex.r * pal; // symbol\n    color += tex.g * abs(uv.x) * vec3(0.110,0.110,0.110); // borders\n    color += tex.b * pal * 2.; // moving borders\n\n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define gridScale 4.0\n#define pi 3.14159265359\n\nfloat N21(vec2 uv)\n{\n    return fract(sin(uv.x * 18.289 + uv.y * 112.282) * 5102.32);\n}\n\nfloat sphereSDF(vec2 uv)\n{\n    return length(uv) - 0.5;\n}\n\nfloat boxSDF(vec2 uv, vec2 b) // Thank you Inigo Quilez \n{\n    vec2 d = abs(uv)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 gID = floor(uv * gridScale);\n\n    float speed = 0.9;\n    float t = iTime * speed;\n    int row = int(floor(t)) % int(gridScale);\n    float pos = (cos(t * pi) + 1.0) * 0.5;\n    \n    float r = N21(vec2(floor(t), 0.0));\n    float dir = step(0.5, r);\n    float isMoving = 0.0;\n\n    if(dir == 1.0)\n    {\n        if(int(gID.y) == row)\n        {\n            uv.x += pos;\n            isMoving = 1.0;\n        }\n    }\n    else\n    {\n        if(int(gID.x) == row)\n        {\n            uv.y += pos;\n            isMoving = 1.0;\n        }\n    }\n    \n    vec2 lUV = fract(uv * gridScale) * 2.0 - 1.0;\n    float dist = abs(sphereSDF(lUV));\n    dist = smoothstep(0.0, 0.325, dist);\n    dist = 0.13 / dist;\n    \n    float distBox = boxSDF(lUV, vec2(0.8));\n    distBox = step(0.125, distBox);\n    float glow = isMoving * distBox * ((cos(t * pi * 2.0 - pi) + 1.0) * 0.5);\n\n    fragColor = vec4(vec3(dist, distBox, glow) ,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2BWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 169], [171, 171, 227, 227, 276], [379, 379, 436, 436, 1489]], "test": "untested"}
{"id": "ctXcRn", "name": "Vertical Perlin Patterns", "author": "misol101", "description": "Lost track of where the pnoise function came from unfortunately.", "tags": ["perlin", "pattern"], "likes": 2, "viewed": 174, "published": 3, "date": "1690302170", "time_retrieved": "2024-07-30T17:42:25.722900", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 143758.5453);\n}\n\nfloat hermite(float t)\n{\n  return t * t * (3.0 - 2.0 * t);\n}\n\nfloat noise(vec2 co, float frequency)\n{\n  vec2 v = vec2(co.x * frequency, co.y * frequency);\n\n  float ix1 = floor(v.x);\n  float iy1 = floor(v.y);\n  float ix2 = floor(v.x + 1.0);\n  float iy2 = floor(v.y + 1.0);\n\n  float fx = hermite(fract(v.x));\n  float fy = hermite(fract(v.y));\n\n  float fade1 = mix(rand(vec2(ix1, iy1)), rand(vec2(ix2, iy1)), fx);\n  float fade2 = mix(rand(vec2(ix1, iy2)), rand(vec2(ix2, iy2)), fx);\n\n  return mix(fade1, fade2, fy);\n}\n\nfloat pnoise(vec2 co, float freq, int steps, float persistence)\n{\n  float value = 0.0;\n  float ampl = 1.0;\n  float sum = 0.0;\n  for(int i=0 ; i<steps ; i++)\n  {\n    sum += ampl;\n    value += noise(co, freq) * ampl;\n    freq *= 2.0;\n    ampl *= persistence;\n  }\n  return value / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 v2 = vec2(25.*(sin(iTime/4.)*1.23-cos((uv.y*1.0+sin(iTime/5.))*9.)/3.)/56.,\n                   uv.y*0.7+sin(-iTime/2.17)*0.12*(cos(uv.x*55.)*2.+5.)/5.);\n\n    float c = abs(pnoise(v2, 0.6, 6, 13.8)-0.5)*2.5;\n\n    vec3 color=vec3(c,c,c/1.2);\n\n    color += (-0.3 + 0.5*cos(iTime/2.5+uv.xyx+vec3(0,2,4))) / 10.;\n\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 93], [95, 95, 119, 119, 155], [157, 157, 196, 196, 609], [611, 611, 676, 676, 895], [897, 897, 954, 954, 1350]], "test": "untested"}
{"id": "ms2BWd", "name": "Automata X2 Showcase 3x2", "author": "misol101", "description": "Fullcreen recommended.\n\nCONTROLS: 7-9=speed, m=see automata, a=antialiasing, space=regenerate\n\nZOOM: Mouse x zooms, arrow keys to pan.", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 9, "viewed": 271, "published": 3, "date": "1690298627", "time_retrieved": "2024-07-30T17:42:26.850884", "image_code": "\n// Keys: 7-9=speed, m=see automata, a=antialiasing, space=regenerate.  Mouse x zooms, arrow keys to pan.\n\n// Recommend 'm' key to see the rather crazy underlying automata.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int mono = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    int aa = 1-int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    vec2 ppos = texelFetch(iChannel1, ivec2(10,0), 0 ).xy;   \n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul) + ppos;\n\n    vec4 val = vec4(0.);\n    int am=0, ap=aa, j=0;\n    for (int j = -am; j <= ap; j++)\n        for (int i = -am; i <= ap; i++)\n            val += texelFetch( iChannel0, ivec2(int(fragCoord.x)+i,int(fragCoord.y)+j), 0 );\n    float n=float((am+ap+1));\n    if (am+ap > 0) val /= n*n-2.;\n    \n    if (aa == 0) val/=0.6;\n    \n    if (mono == 0) {\n        fragColor = val;\n    } else {\n        float v=(1./liveval)*val.w;\n        fragColor = vec4( v*0.9, v*0.95, v, 1.0 );\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int rows = 2;\n    \n    float xsq = 3., ysq = float(rows);\n    float wsq = iResolution.x / xsq;\n    float hsq = iResolution.y / ysq;\n    float thick = 2.;\n\n    int cix = (int(fragCoord.x / wsq) + int(fragCoord.y / hsq)*int(xsq) + int(ix*10.)) % 9;\n    setRules(cix, vec3(0.));\n\n    float dt=density; if (density2 >= 0.) density=density2;;\n    float i, bsh=1.;\n    for (i=0.; i<=xsq; i++) {\n        if (fragCoord.x > wsq*i-thick && fragCoord.x < wsq*i+thick ) {\n            fragColor = vec4(bsh,bsh,bsh,randpix(fragCoord));\n            return;\n        }\n    }\n    for (i=0.; i<=ysq; i++) {\n        if (fragCoord.y > hsq*i-thick && fragCoord.y < hsq*i+thick ) {\n            fragColor = vec4(bsh,bsh,bsh,randpix(fragCoord));\n            return;\n        }\n    }\n    density=dt;\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_Z) || readKey(KEY_X) || int(xres) != int(iResolution.x) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, randpix(fragCoord));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, randpix(fragCoord));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 4 || nh==5 || nh == 6) {\n        // .XXX. 4\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // .XXX.\n        k =   cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1))\n            + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1));\n        // XXXXX 6\n        // X...X\n        // X.*.X\n        // X...X\n        // XXXXX\n        if (nh > 4) k += cell(px+ivec2(2, 2)) + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, 2)) + cell(px+ivec2(2, -2));\n        // XXXXX 5\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        if (nh < 6)\n            k += cell(px+ivec2(0,-1))\n            + cell(px+ivec2(-1, 0)) + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(0, 1))  + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1));\n    } else if (nh == 7) {\n        // XX.XX\n        // X...X\n        // ..*..\n        // X...X\n        // XX.XX\n        k =   cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2))\n            + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 1)) + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, -1));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate;\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x += cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y += cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z += cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\t\n\n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x -= cstep*rm;\n                curr.y -= cstep*gm;\n                curr.z -= cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x -= cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n    }\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAST_PATT = 0.001;\nconst float cstep=1./256.;\n\nfloat density=50., density2=0.;\nfloat liveval = 2.0;\nint newmethod = 0;\nfloat decimate = 0.;\nfloat rp,gp,bp, rm,gm,bm, stayval;\nint colch, staypatt;\nint ra,ga,ba;\nbool clampstay;\nint setmethod;\nint stayset, bornset;\nint nh;\nint wrap;\n\nvoid setRules(int index, vec3 col) {\n    int v1, v2;\n    decimate = 1.;liveval=2.;\n\n    rp=4.,gp=3.,bp=10., rm=2.,gm=2.,bm=8., ra=7,ga=7,ba=7,staypatt=1,stayval=1.,colch=0, clampstay=false, setmethod=0; nh=10, wrap=0, density2=1.;;\n\n    // evil alien\n    if (index == 0) {nh=7, v1 = 31, v2=220; density=50.; setmethod=2; liveval=5.; decimate=0.; colch=2, staypatt=6; rp=5.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; } \n\n    // rounded blue lines\n    if (index == 1) {nh=10, v1 = 64863, v2=4094; density=85.; setmethod=0; liveval=5.; decimate=0.; colch=2, staypatt=0; rp=0.;gp=4.;bp=4.; rm=5.,gm=5.,bm=5.; ra=1,ga=2,ba=2; } \n\n    // scribble and noise\n    if (index == 2) {nh=10, v1 = 64863, v2=4078; density=98.; setmethod=4; liveval=5.; decimate=0.; colch=2, staypatt=6; rp=5.;gp=2.;bp=2.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; } \n\n    // small worms\n    if (index == 3) {nh=10, v1 = 64860, v2=4094; density=10.; setmethod=0; liveval=2.; decimate=0.; colch=2, staypatt=6; rp=9.; gp=4.; bp=4.; rm=16.,gm=18.,bm=18.; ra=6,ga=7,ba=6; wrap=0; } \n\n    // red and green\n    if (index == 4) {nh=10, v1 = 64863, v2=4082; density=30.; setmethod=4; liveval=5.; decimate=0.; colch=2, staypatt=0; rp=10.;gp=4.;bp=4.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; } \n\n    // alien scribble\n    if (index == 5) {nh=10; v1 = 4094, v2=3966; density=90., setmethod=2; liveval=5., decimate=0., colch=2, staypatt=0, rp=10., gp=4., bp=4., rm=16., gm=16.,bm=18.,  ra=6,ga=7,ba=6; }\n\n    rp=rp+col.x; gp=gp+col.y; bp=bp+col.z;\n    stayset = v1; bornset = v2;\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_A     = 65;\nconst int KEY_M     = 77;\nconst int KEY_W     = 87;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\nconst int KEY_C     = 67;\nconst int KEY_V     = 86;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) {\n        fragColor = vec4(0.,0.,0.,1.0);\n        return;\n    }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_Z)||readKey(KEY_X)||readKey(KEY_C)||readKey(KEY_V) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_RIGHT) || readKey(KEY_DOWN)) {\n                    kx+=0.1;\n                    if (kx > LAST_PATT*0.1+0.05) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=LAST_PATT*0.1+0.05;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_A, 1., 2.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        vec2 ppos = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xy;\n        float mmul = iMouse.x / iResolution.x;\n        vec2 mid = iResolution.xy / 2.;\n\n        float psp=8.;\n        if( readKey(KEY_LEFT)) ppos.x -= psp;\n        if( readKey(KEY_RIGHT)) ppos.x += psp;\n        if( readKey(KEY_UP)) ppos.y += psp;\n        if( readKey(KEY_DOWN)) ppos.y -= psp;\n        ppos.x = clamp(ppos.x, -mid.x*mmul, mid.x*mmul);\n        ppos.y = clamp(ppos.y, -mid.y*mmul, mid.y*mmul);\n\n        fragColor = vec4(ppos,0.,1.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2BWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 231, 231, 1104]], "test": "untested"}
{"id": "ddjBDd", "name": "raymarched-water", "author": "LydianLights", "description": "More like wibbly rubber than water, lol. Just wanted to test some stuff out and try out raymarching again. I think this will serve as a base sketch for me to improve as I learn better techniques.", "tags": ["raymarching", "water"], "likes": 1, "viewed": 231, "published": 3, "date": "1690297198", "time_retrieved": "2024-07-30T17:42:27.662713", "image_code": "const float MAX_STEPS = 80.0;\nconst float MIN_DIST = 0.01;\n\nconst float AMPLITUDE = 0.13;\nconst float OCTAVES = 5.0;\nconst float LACUNARITY = 1.8;\nconst float GAIN = 0.5;\n\nstruct RayResult {\n    vec3 ray;\n    float d;\n    float steps;\n    bool hit;\n    vec3 p;\n    vec3 color;\n};\n\nfloat fbm(in vec2 q) {\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    for (float i = 0.0; i < OCTAVES; i++) {\n        float n = 0.7 * cos(0.5 * q.x + 0.5 * q.y + 0.5 * iTime) +\n                  0.7 * cos(0.5 * q.x - 0.5 * q.y + 0.5 * iTime) +\n                  0.7 * cos(q.x + 3.0 * iTime) +\n                  1.0 * cos(q.y + 5.0 * iTime);\n        n += sign(n) * pow(0.9 * n, 1.1);\n        value += amplitude * n;\n        q *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    float base = 0.2 * cos(0.05 * q.y + iTime);\n    base += sign(base) * pow(0.9 * base, 1.1);\n    return value + base;\n}\n\n\nfloat scene(in vec3 p) {\n    float y = p.y + fbm(p.xz);\n    float d = y;\n \treturn d;\n}\n\nvec3 sceneNormals(in vec3 p) {\n    const float h = 0.005;\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy * scene(p + k.xyy * h) +\n                     k.yyx * scene(p + k.yyx * h) +\n                     k.yxy * scene(p + k.yxy * h) +\n                     k.xxx * scene(p + k.xxx * h));\n}\n\nvoid shade(inout RayResult r) {\n    const vec3 SKY_COLOR = vec3(0.3, 0.65, 0.8);\n    const vec3 SUN = normalize(vec3(0.0, 9.0, 1.0));\n    const vec3 FAKE_SUN = normalize(vec3(0.0, 2.0, 1.0));\n    const float FOG_DIST = 70.0;\n    const vec3 WATER_COLOR = vec3(0.08, 0.3, 0.7);\n    \n    vec3 sky = SKY_COLOR + pow(dot(r.ray, FAKE_SUN), 5.0);\n    if (!r.hit) {\n        r.color = sky;\n        return;\n    }\n    \n    vec3 normal = sceneNormals(r.p);\n    float diffuse = max(dot(SUN, normal), 0.0);\n    float specular = pow(max(dot(SUN, normal), 0.0), 99.0);\n    \n    vec3 color = diffuse * WATER_COLOR + specular * vec3(1.0);\n    \n    float fog = min(r.d / FOG_DIST, 1.0);\n    color = mix(color, sky, fog);\n    \n    r.color = color;\n}\n\nRayResult march(in vec3 origin, in vec3 ray) {\n    RayResult r;\n    r.ray = ray;\n    r.d = 0.0;\n    for (r.steps = 0.0; r.steps < MAX_STEPS; r.steps++) {\n     \tr.p = origin + ray * r.d;\n        float sd = scene(r.p);\n        if (sd < MIN_DIST) {\n            r.hit = true;\n            break;\n        }\n        r.d += sd;\n    }\n    shade(r);\n    return r;\n}\n\nvec3 gamma(in vec3 color) {\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 4.0, -1.0);\n\n    RayResult r = march(origin, ray);\n\n    vec3 color = r.color;\n    color = gamma(color);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 303, 303, 888], [891, 891, 915, 915, 977], [979, 979, 1009, 1009, 1282], [1284, 1284, 1315, 1315, 2013], [2015, 2015, 2061, 2061, 2370], [2372, 2372, 2399, 2399, 2451], [2453, 2453, 2508, 2508, 2780]], "test": "untested"}
{"id": "cdScWD", "name": "Bloody Constant Collision", "author": "misol101", "description": "Variation on constant collision with 3 layers, 45 degree square rotation, and a deadly palette :D\n\nFullscreen recommended. SPACE to toggle between rotated or not.", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 6, "viewed": 224, "published": 3, "date": "1690294424", "time_retrieved": "2024-07-30T17:42:28.654063", "image_code": "// SPACE to toggle between rotated or not\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 val = 1.-texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    float r = 1.-val.x*1.0;\n    float g = val.y*0.95;\n    float b = val.z*1.0;\n    fragColor = vec4( r*r*r*5.3,g*g*g*1.75, b*b*1.75, 1.0 );\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(0.+uv.xyx+vec3(0,2,4));    \n    fragColor=(fragColor+vec4(col,1.0)*0.3)/2.1;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "bool ReadKey( int key )\n{\n\tbool toggle = true;\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nvec2 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).xw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n\n    int k;\n    if (!ReadKey(Key_R)) {\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else {\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n                + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n                + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    int e = cell(px);\n    vec2 cvv=cellval(px);\n    int ev = int(cvv.x*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = ev - 1;\n        if (stayrules[k]==1) f = k;\n    }\n    else {\n        f = bornrules[k]==1? k : 0;\n    }\n\n    float ff = float(f)/10.;\n\n    if( iFrame==0 ||iResolution.x != cvv.y) ff = clamp(step(liveval, hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1))), 0., liveval);\n\n    float maxregen = 2. + iResolution.x/800.;  \n    for (float i=0.; i<maxregen; i++) {\n        int sz = int(1. + hash1(iTime + i) * 1.5);\n        if (abs(int(hash1(iTime+i)*iResolution.x) - int(fragCoord.x)) < sz && abs(int(hash1(iTime + i + 0.287)*iResolution.y) - int(fragCoord.y)) < sz)\n            ff = -1.;\n    }\n\n\tfragColor = vec4( ff, 0.0, 0.0, iResolution.x);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "bool ReadKey( int key )\n{\n\tbool toggle = true;\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nvec2 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).xw;\n}\n\nconst float hashp = 1.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n\n    int k;\n    if (!ReadKey(Key_R)) {\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else {\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n                + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n                + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    int e = cell(px);\n    vec2 cvv=cellval(px);\n    int ev = int(cvv.x*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = ev - 1;\n        if (stayrules[k]==1) f = k;\n    }\n    else {\n        f = bornrules[k]==1? k : 0;\n    }\n\n    float ff = float(f)/10.;\n\n    if( iFrame==0 || iResolution.x != cvv.y) ff = clamp(step(liveval, hash1(hashp+fragCoord.x*13.0+hash1(fragCoord.y*71.1))), 0., liveval);\n\n    float maxregen = 2. + iResolution.x/800.;  \n    for (float i=0.; i<maxregen; i++) {\n        int sz = int(1. + hash1(iTime + i) * 1.5);\n        if (abs(int(hash1(hashp+iTime+i)*iResolution.x) - int(fragCoord.x)) < sz && abs(int(hash1(hashp + iTime + i + 0.287)*iResolution.y) - int(fragCoord.y)) < sz)\n            ff = -1.;\n    }\n\n\tfragColor = vec4( ff, 0.0, 0.0, iResolution.x);\n}\n\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "bool ReadKey( int key )\n{\n\tbool toggle = true;\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nvec2 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).xw;\n}\n\nconst float hashp = 2.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n\n    int k;\n    if (!ReadKey(Key_R)) {\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else {\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n                + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n                + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    int e = cell(px);\n    vec2 cvv=cellval(px);\n    int ev = int(cvv.x*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = ev - 1;\n        if (stayrules[k]==1) f = k;\n    }\n    else {\n        f = bornrules[k]==1? k : 0;\n    }\n\n    float ff = float(f)/10.;\n\n    if( iFrame==0 || iResolution.x != cvv.y) ff = clamp(step(liveval, hash1(hashp+fragCoord.x*13.0+hash1(fragCoord.y*71.1))), 0., liveval);\n\n    float maxregen = 2. + iResolution.x/800.;  \n    for (float i=0.; i<maxregen; i++) {\n        int sz = int(1. + hash1(iTime + i) * 1.5);\n        if (abs(int(hash1(hashp+iTime+i)*iResolution.x) - int(fragCoord.x)) < sz && abs(int(hash1(hashp+iTime + i + 0.287)*iResolution.y) - int(fragCoord.y)) < sz)\n            ff = -1.;\n    }\n\n\tfragColor = vec4( ff, 0.0, 0.0, iResolution.x);\n}\n\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 val = 1.-texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx;\n    vec3 val2 = 1.-texelFetch( iChannel1, ivec2(fragCoord), 0 ).xxx;\n    vec3 val3 = 1.-texelFetch( iChannel2, ivec2(fragCoord), 0 ).xxx;\n    float r = val.x*0.3+val3.x*0.4+ val2.x*0.35;\n    float g = val2.x*0.2+val.x*0.4+val3.x*0.35;\n    float b = val3.x*0.4+val.x*0.7+val2.x*0.5;\n    fragColor = vec4( r*r*1.3,g*g*1.3, b*b*1.3, 1.0 );\n    \n    vec2 screenCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    vec3 valb2 = texture(iChannel3, (fragCoord - screenCenter) * 0.993 / iResolution.xy + 0.5).xxx;\n\n    fragColor = vec4( (fragColor.xyz*0.5+valb2*0.9)/1.4, 1.0 );\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// value for key to reset with\nconst int Key_R = 32;\n\n// imploding rectangles\nconst int stayrules[9] = int[9](0,0,1,1,0,0,0,0,1);\nconst int bornrules[9] = int[9](0,0,1,0,0,0,1,1,0);\nconst float liveval = 0.01;\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdScWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 100, 100, 461]], "test": "untested"}
{"id": "msjfDt", "name": "Moving White Point", "author": "beans_please", "description": "Random experiment\n\n- Drag to move the white point", "tags": ["2d", "triangle", "colors", "barycentric", "colorspace"], "likes": 6, "viewed": 267, "published": 3, "date": "1690292056", "time_retrieved": "2024-07-30T17:42:29.532714", "image_code": "vec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvec3 render(vec2 coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(coord);\n    \n    // Primaries and white point\n    vec2 r = vec2(0.7, -0.5);\n    vec2 g = vec2(0.0, 0.5);\n    vec2 b = vec2(-0.7, -0.5);\n    vec2 w = vec2(0.0, -0.16667);\n    \n    // Animate the white point\n    float t = TAU * iTime * 0.5;\n    w += vec2(cos(t), sin(t)) * cos(0.2 * t) * 0.2;\n    \n    // Drag the white point\n    if (iMouse.z > 0.5)\n    {\n        w = screen_to_uv(iMouse.xy);\n    }\n    \n    // Stuff\n    vec3 col = vec3(0.0);\n    bool outside;\n    vec3 bary;\n    \n    // Check if UV is inside\n    bary = cart2barycentric(uv, r, g, b, false, outside);\n    if (!outside)\n    {\n        // Check if white point is inside\n        bary = cart2barycentric(w, r, g, b, false, outside);\n        if (outside)\n        {\n            col = vec3(1.0, 0.05, 0.03);\n        }\n        else\n        {\n            // Get interpolated color\n            bary = cart2barycentric(uv, r, w, b, false, outside);\n            if (!outside)\n            {\n                col = bary.x * vec3(1, 0, 0)\n                    + bary.y * vec3(1.0 / 3.0)\n                    + bary.z * vec3(0, 0, 1);\n            }\n            bary = cart2barycentric(uv, g, w, r, false, outside);\n            if (!outside)\n            {\n                col = bary.x * vec3(0, 1, 0)\n                    + bary.y * vec3(1.0 / 3.0)\n                    + bary.z * vec3(1, 0, 0);\n            }\n            bary = cart2barycentric(uv, b, w, g, false, outside);\n            if (!outside)\n            {\n                col = bary.x * vec3(0, 0, 1)\n                    + bary.y * vec3(1.0 / 3.0)\n                    + bary.z * vec3(0, 1, 0);\n            }\n            col = max(col, 0.0);\n            float mono = max(max(col.r, col.g), col.b);\n            if (mono > 0.0) col /= mono;\n        }\n    }\n    \n    // Draw dots on the points\n    if (inside_circle(uv, r, 0.03)) col = vec3(0.5);\n    if (inside_circle(uv, g, 0.03)) col = vec3(0.5);\n    if (inside_circle(uv, b, 0.03)) col = vec3(0.5);\n    if (inside_circle(uv, w, 0.01)) col = vec3(0.5);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Jitter sampling\n    const int jitter_samples = 32;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < jitter_samples; i++)\n    {\n        col += render(frag_coord + vec2(random(), random()) - 0.5);\n    }\n    col /= float(jitter_samples);\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n\n// Basically |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 barycentric2cart(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\n// https://www.desmos.com/calculator/8g8xjejuox\nvec3 cart2barycentric(vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    return b;\n}\n\nvec3 cart2barycentric(vec2 p, vec2 v0, vec2 v1, vec2 v2, bool clamped, out bool outside)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    outside = min(min(b.x, b.y), b.z) < -0.001;\n    if (clamped)\n    {\n        b = max(b, 0.0);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nbool inside_circle(vec2 p, vec2 center, float radius)\n{\n    return distance(p, center) < radius;\n}\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 112], [114, 114, 145, 162, 202], [204, 204, 229, 239, 2293], [2295, 2295, 2350, 2373, 2760]], "test": "untested"}
{"id": "Dd2fDd", "name": "Tidal screensaver", "author": "ChibiDenDen", "description": "Playing around with noise to create random shapes", "tags": ["noise", "waves"], "likes": 3, "viewed": 165, "published": 3, "date": "1690286110", "time_retrieved": "2024-07-30T17:42:30.558969", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += vec2(noise(uv + vec2(0.2, 0.4)* iTime), noise(uv.yx + vec2(0.7, 0.1)* iTime))*2.2f;\n    if (fract(uv.x) > 0.2) {\n\n        // Time varying pixel color\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    } else {\n    \n        // Time varying pixel color\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.yyx+vec3(1,2,3));\n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2fDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 144], [146, 233, 259, 259, 776], [778, 778, 835, 885, 1395]], "test": "untested"}
{"id": "msSfDd", "name": "Spherical Slider Test", "author": "Karp", "description": "Random test", "tags": ["2d"], "likes": 2, "viewed": 99, "published": 3, "date": "1690271281", "time_retrieved": "2024-07-30T17:42:31.308964", "image_code": "///UV\nvec2 CenterUV(vec2 fragCoord)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy);\n\tuv = 2.0 * uv.xy / iResolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV manipulation\n    vec2 uv = AspectRatioUV(fragCoord.xy);\n    \n    vec2 center = iResolution.xy /2.0;\n    vec2 mousePos = iMouse.xy;\n    vec2 toHandle = normalize(mousePos - center);\n    \n    float value = atan(toHandle.x, -toHandle.y);\n    value /= PI;\n    value = 1. - value;\n    \n    //value = atan(normalize(mousePos - center));\n    float AA = 0.05;\n    //Visu\n    vec3 pix = vec3(uv,0);\n    pix = vec3(1.0);\n\n    float angle = iTime * 90.0;\n    angle = value * PI;\n    \n    //BackGround\n    float circleMask = Disk(uv,vec2(0.), 0.85, AA);\n    pix = mix(vec3(0.85, 0.83, 0.93), pix, circleMask);\n    \n    //Handle\n    \n    vec2 pos = vec2(sin(angle),cos(angle)) * 0.75;\n    float BgMask = Disk(uv,pos, 0.45, AA);\n    pix = mix(vec3(0.48, 0.65, 0.96), pix, BgMask);\n    BgMask = Disk(uv,pos, 0.25, AA);\n    pix = mix(vec3(0.38, 0.4, 0.97), pix, BgMask);\n\n    \n    pos = vec2(sin(angle),cos(angle)) * 0.75;\n    circleMask = Disk(uv,pos, 0.09, AA);\n    pix = mix(vec3(1.0), pix, circleMask);\n    circleMask = Disk(uv,pos, 0.07, AA);\n    pix = mix(vec3(0.45, 0.25, 0.92), pix, circleMask);\n    \n    \n    circleMask = Disk(uv,vec2(0.), 0.65, AA);\n    pix = mix(vec3(0.7, 0.62, 0.93), pix, circleMask);\n    \n    //Pie\n    vec2 rotUv = RotateUV(uv, -angle/2.);\n    float pieMask = Pie(rotUv, vec2(0), angle/2., 0.65, AA);\n    pix = mix(vec3(0.45, 0.25, 0.92), pix, pieMask);  \n    \n     \n    for(int i = 0; i < 24; i++)\n    {\n        float val = TAU/24.; \n        pos = vec2(sin(val * float(i)),cos(val * float(i))) * 0.5;\n        \n        circleMask = Disk(uv, pos, 0.02, AA);\n        pix = mix(vec3(0.56, 0.44, 0.83),pix, circleMask);\n    } \n    \n    //BackGround\n    circleMask = Disk(uv,vec2(0.), 0.85, AA);\n    pix = mix(vec3(1.), pix, (1.-circleMask));\n    \n\tfragColor = vec4(pix, 1.0);\n}", "image_inputs": [], "common_code": "#define PI  3.14159265359\n#define TAU 6.28318530717\n\n//HELPER\nfloat Clamp01(float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n//2DShape\nfloat Disk(vec2 uv, vec2 center, float radius, float blur) \n{\n    float sdfCircle = length(uv-center)-radius;\n\treturn Clamp01(sdfCircle * (10.0/blur));\n}\nfloat Pie(vec2 uv, vec2 center, float angle,float radius, float blur) \n{\n \n    vec2 pos = uv-center;\n    float sdfPie = sdPie( pos, vec2(sin(angle),cos(angle)), radius);\n\treturn Clamp01(sdfPie * (10.0/blur));\n}\n\n///COLOR\nvec3 HSVcolor(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//UV\nvec2 RotateUV(vec2 uv, float angle)\n{\t\n    return uv * mat2( cos(angle), sin(angle),\n                     -sin(angle), cos(angle));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 6, 37, 64, 267], [268, 268, 304, 304, 545], [547, 547, 604, 627, 2404]], "test": "untested"}
{"id": "dd2fWV", "name": "SDF Writer", "author": "fenix", "description": "Computing a 2D signed distance field per-pixel. Higher paint calls work well for faster update. Interactive-only: use mouse to draw a shape, then wait for SDF to be computed.\n\n* mouse to draw *\n* space to reset *", "tags": ["2d", "mouse", "interactive", "sdf", "multipass"], "likes": 22, "viewed": 367, "published": 3, "date": "1690266892", "time_retrieved": "2024-07-30T17:42:32.069930", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Computing a 2D signed distance field per-pixel. Distance is stored in x. In yz is\n//  stored the coordinates of the \"root\": the drawn-on pixel closest to us. Each\n//  iteration, we search near the root for a better root. Raising the paint calls \n//  allows for faster update.\n//\n//  I guess this SDF would be usable for ray marching, if there is a use for 2D ray\n//  marching. But it seems like this approach would extend to 3D reasonably easily.\n//  The resolution would not need to be very high for it to work, and we could use\n//  texture hardware for interpolation.\n//\n//  I used a compact style because it seemed clear enough this way, but I didn't\n//  really try very hard to reduce characters. But if someone wants to golf this\n//  I will happily post your efforts.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n    \n    O = mix( vec4(1), vec4(.9,.6,.3,0) // iq's standard SDF distance visualization\n\t                     * (1. - exp(-6.*abs(O.x * .002)))\n\t                     * (.8 + .2*cos(O.x * .3)), smoothstep(0., 3.,O.x) );\n                         \n    vec2 c = (vec2(sin(iTime * .3), cos(iTime)) * .45 + .5) * iResolution.xy;\n    O = mix(O, vec4(1, 1, 0, 1), smoothstep(3., 0., abs(distance(c, u) - T(c).x)));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void n(vec2 u, inout vec4 O)\n{\n    vec4 v = T(u), a; // get neighbor value\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y)\n    {\n        a = T(v.yz + vec2(x, y)); // search near neighbor's root\n        a.x += distance(u, v.yz + vec2(x, y)); // new prospective distance\n        O = (a.x <= O.x) ? vec4(a.x, v.yz, 0) : O; // when we find a shorter path, update our distance and root\n    }\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution, m = iMouse.xyz, e = vec3(1, 0, distance(m.xy, u));\n    \n    if (max(u.x, u.y) < 1.)\n        O.x = R.x * R.y; // resolution stored in lower left corner, unreachable by sim\n    else if (iFrame == 0 || // bootstrap\n        T(vec2(0)).x != R.x * R.y || // detect resolution changes\n        texelFetch(iChannel3,ivec2(32,0),0).x > 0. || // support keyboard \"space\" reset\n        u.x < 1. || u.x == R.x - .5 || // detect edges\n        u.y < 1. || u.y == R.y - .5)\n        \n        O = vec4(1e6); // clear edges and screen\n    else\n    {\n        // support drawing with mouse\n        O = m.z > 0. && e.z < R.y * .005 ? vec4(max(0., e.z - R.y * .005), u, 0) : T(u);\n\n        // search neighbors for new shorter path\n        n(u + e.xy, O);\n        n(u - e.xy, O);\n        n(u + e.yx, O);\n        n(u - e.yx, O);\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2fWV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1078, 1078, 1116, 1116, 1539]], "test": "untested"}
{"id": "csBfWd", "name": "𝕏 - X11 fade", "author": "flockaroo", "description": "as i'm a liunx (and X11) native, i had to...", "tags": ["x11", "xorg", "twitterx"], "likes": 16, "viewed": 282, "published": 3, "date": "1690237238", "time_retrieved": "2024-07-30T17:42:33.067264", "image_code": "// created by florian berger (flockaroo) - 2033\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// X - X11 - new twitter logo\n\n#define X11 clamp(-cos(iTime*.3)+.5,0.,1.)\n\nfloat linstep(float a, float b, float x) { return clamp((x-a)/(b-a),0.,1.); }\nfloat smin(float a, float b, float k) { return mix(a,b,linstep(-2.*k,2.*k,a-b))-k*linstep(-2.*k,0.,-abs(a+b)); }\nfloat smax(float a, float b, float k) { return -smin(-a,-b,k); }\n\nfloat distX(vec3 p)\n{\n    float W=.8;\n    float D=.15;\n    float H=1.;\n    float w1=.15;\n    float w2=.04;\n    float w3=.03;\n    float sr=.007;\n    float dX11=.015;\n    \n    float d=10000.;\n    \n    float d1,d2,dh,dThick;\n    dh=abs(p.y)-H*.5;\n    dThick=abs(p.z)-D*.5;\n    \n    vec3 Xn;\n    \n    Xn=normalize(vec3(H+.05-X11*.03,W+X11*.03,0));\n    float d10=dot(p,Xn);\n    d1=abs(d10)-w1*.5;\n    d1=smax(d1,dh,sr);\n    \n    Xn=normalize(vec3(-(H-.05+X11*.03),W-X11*.03,0));\n    float d20=dot(p,Xn);\n    d2=abs(d20+X11*(w2+dX11)*.5*sign(d10))-w2*.5;\n    d2=smax(d2,dh,sr);\n    \n    d=smin(d1,d2,sr);\n    d=smax(d,-d1-w3-X11*w1,sr);\n    d=smax(d,dThick,sr);\n    d=smax(d,-abs(d20)+(dX11*(-1.5+2.*X11)),sr);\n    return d;\n}\n\n\nfloat dist(vec3 pos)\n{\n    return min(distX(pos.xzy*vec3(1,1,1)*.75)/.75,pos.z+.7);\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, vec3 dir)\n{\n    float eps=0.001;\n    for(int cnt=0;cnt<100;cnt++)\n    {\n        float d = dist(pos);\n        pos+=d*dir;\n        if(d<eps) { break; }\n    }\n    vec3 n = getGrad(pos,.001);\n    return vec4(n,0.); // .w=1 => background\n}\n\nmat3 rotX(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(1,0,0, 0,c,s, 0,-s,c);\n}\n\nmat3 rotZ(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(c,s,0, -s,c,0, 0,0,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    vec3 pos = vec3(0,-3.5,0);\n    // pixel view direction\n    vec3 dir = normalize(2.*normalize(-pos)+vec3(sc.x,0,sc.y*iResolution.y/iResolution.x));\n    // rotate view around x,z\n    float phi = iMouse.x/iResolution.x*7.;\n    float th  = iMouse.y/iResolution.y*7.;\n    if (iMouse.x==0.) { phi=sin(iTime*.5)*.5; th=.3*sin(iTime*.3)-.15; }\n    mat3 rx = rotX(th);\n    mat3 rz = rotZ(phi);\n    pos = rz*(rx*pos);\n    dir = rz*(rx*dir);\n    \n    // march it...\n   \tvec4 n=march(pos,dir);\n    float bg=n.w;\n        \n    // calc some ambient occlusion\n    float ao=1.;\n    #if 0\n    // calc simple ao by stepping along radius\n    ao*=dist(pos*1.02)/.02;\n    ao*=dist(pos*1.05)/.05;\n    ao*=dist(pos*1.1)/.1;\n    #else\n    // calc ao by stepping along normal\n    ao*=dist(pos+n.xyz*.02)/.02;\n    ao*=dist(pos+n.xyz*.05)/.05;\n    ao*=dist(pos+n.xyz*.10)/.10;\n    #endif\n    // adjust contrast of ao\n    ao=pow(ao,.4);\n    \n    // reflection dir\n    vec3 R = pos-2.0*dot(pos,n.xyz)*n.xyz;\n    R = -((R*rz)*rx).yzx;\n    \n    vec3 c = vec3(1);\n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c += n.xyz*.1+.1;\n\n    //  reflection of cubemap\n    c *= texture(iChannel1,R).xyz*1.5+.4;\n    \n    // add some depth darkening\n\tc*=clamp(-dot(dir,pos)*.7+.7, .2, 1.);\n    \n    // apply ambient occlusion\n    c*=ao;\n    \n    // apply background\n    if(bg>=.5) c=vec3(.5,.6,.75)-.17;\n    \n    // vignetting\n    float vign = (1.1-.3*length(sc.xy));\n    \n\tfragColor = vec4(c*vign,1);\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBfWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[211, 211, 253, 253, 288], [289, 289, 328, 328, 401], [402, 402, 441, 441, 466], [468, 468, 489, 489, 1188], [1191, 1191, 1213, 1213, 1276], [1278, 1278, 1313, 1313, 1493], [1495, 1510, 1548, 1548, 1771], [1773, 1773, 1795, 1795, 1870], [1872, 1872, 1894, 1894, 1969], [1971, 1971, 2028, 2054, 3693]], "test": "untested"}
{"id": "mdjfD3", "name": "Automata Lab X2 (more scribble)", "author": "misol101", "description": "CONTROLS:  down/up=next/prev CA, 1-5=start method, 7-9=speed, m=see automata, v=antialiasing, space=regenerate, h=text\n\nZOOM: Mouse x zooms, w/a/s/d to pan.", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 5, "viewed": 258, "published": 3, "date": "1690230066", "time_retrieved": "2024-07-30T17:42:34.165327", "image_code": "\n// Down/up arrows to switch between CA's. \n\n// Other keys: 1-5=start method, 7-9=speed, m=see automata, v=antialiasing, space=regenerate.  Mouse x zooms, w/a/s/d to pan.\n\n// Recommend 'm' key to see the rather crazy underlying automata\n\nfloat text(vec2 uv, float ix)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(ix*10.,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv); \n\n    text_pos(iResolution.x/2. - (13./2.)*CHAR_SPACING.x, iResolution.y - STRHEIGHT(1.0)*2.);\n    col += _p() + _r() + _e() + _s() + _s() + _spc() + _d() + _o() + _w() + _n() + _lsl() + _u() + _p();\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int mono = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    int aa = 1-int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    vec2 ppos = texelFetch(iChannel1, ivec2(10,0), 0 ).xy;\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, ix);    \n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul) + ppos;\n\n    vec4 val = vec4(0.);\n    int am=0, ap=aa, j=0;\n    for (int j = -am; j <= ap; j++)\n        for (int i = -am; i <= ap; i++)\n            val += texelFetch( iChannel0, ivec2(int(fragCoord.x)+i,int(fragCoord.y)+j), 0 );\n    float n=float((am+ap+1));\n    if (am+ap > 0) val /= n*n-2.;\n    \n    if (aa == 0) val/=0.6;\n    \n    if (mono == 0) {\n        fragColor = val;\n    } else {\n        float v=(1./liveval)*val.w;\n        fragColor = vec4( v*0.9, v*0.95, v, 1.0 );\n    }\n\n    fragColor += text_pixel;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nfloat restart(vec2 fragCoord, int method, bool preserve) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=60., h=50.;\n    float xrad=569.,yrad=453.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return randpix(fragCoord);\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return randpix(fragCoord);\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return randpix(fragCoord);\n    }\n    if (method == 3) {\n        if (length(vec2((fragCoord.x-mid.x)*0.793,(fragCoord.y-mid.y)*1.0))< radius)\n            return randpix(fragCoord);\n    }\n    if (method == 4) {\n        float xmul=1.;\n        if (fragCoord.x > mid.x - radius*xmul && fragCoord.x < mid.x + radius*xmul+1. && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius +1.)\n            return randpix(fragCoord);\n    }\n    return preserve? -1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int rows = 2+ int(texelFetch(iChannel2, ivec2(4,0), 0 ).x);\n    \n    float xsq = 3., ysq = float(rows);\n    float wsq = iResolution.x / xsq;\n    float hsq = iResolution.y / ysq;\n    float thick = 3.;\n\n    int index=int(ix*10.);\n    setRules(index, vec3(0.));\n    if(index==0 && iResolution.y < 600.) radius=80.;\n\n    if (wrap == 0 && (fragCoord.y < 1. || fragCoord.x < 1. || fragCoord.x >= iResolution.x-1. || fragCoord.y >= iResolution.y-1. ) ) {\n        density=0.;  if (density2>=0.) density=density2;\n        fragColor = vec4( 0.0, 0.0, 0.0, 0.);\n        return;\n    }\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_DOWN) || readKey(KEY_UP) || int(xres) != int(iResolution.x) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, setmethod, false));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, method, false));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 4 || nh==5 || nh == 6) {\n        // .XXX. 4\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // .XXX.\n        k =   cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1))\n            + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1));\n        // XXXXX 6\n        // X...X\n        // X.*.X\n        // X...X\n        // XXXXX\n        if (nh > 4) k += cell(px+ivec2(2, 2)) + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, 2)) + cell(px+ivec2(2, -2));\n        // XXXXX 5\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        if (nh < 6)\n            k += cell(px+ivec2(0,-1))\n            + cell(px+ivec2(-1, 0)) + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(0, 1))  + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1));\n    } else if (nh == 7) {\n        // XX.XX\n        // X...X\n        // ..*..\n        // X...X\n        // XX.XX\n        k =   cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2))\n            + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 1)) + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, -1));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate;\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x += cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y += cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z += cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\t\n\n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x -= cstep*rm;\n                curr.y -= cstep*gm;\n                curr.z -= cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x -= cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n    }\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAST_PATT = 8.001;\nconst float cstep=1./256.;\n\nfloat density=50., density2=-1.;\nfloat liveval = 2.0;\nint newmethod = 0;\nfloat decimate = 0.;\nfloat rp,gp,bp, rm,gm,bm, stayval;\nint colch, staypatt;\nint ra,ga,ba;\nbool clampstay;\nint setmethod;\nint stayset, bornset;\nint nh;\nint wrap;\nfloat radius;\n\nvoid setRules(int index, vec3 col) {\n    int v1, v2;\n    decimate = 1.;liveval=2.;\n\n    rp=4.,gp=3.,bp=10., rm=2.,gm=2.,bm=8., ra=7,ga=7,ba=7,staypatt=1,stayval=1.,colch=0, clampstay=false, setmethod=0; nh=10, wrap=0, density2=-1.; radius=25.;\n\n    // blue scribble\n    if (index == 0) {nh=10, v1 = 64863, v2=21948; density=91.; setmethod=1; liveval=5.; decimate=0.; colch=2, staypatt=0; rp=0.;gp=8.;bp=9.; rm=2.,gm=2.,bm=2.; ra=1,ga=2,ba=2; radius=200.;wrap=0; } \n\n    // evil but brighter\n    if (index == 1) {nh=7, v1 = 31, v2=220; density=50.; setmethod=4; liveval=5.; decimate=0.; colch=2, staypatt=6; rp=9.; gp=4.; bp=4.; rm=16.,gm=18.,bm=18.; ra=6,ga=7,ba=6; radius=140.; wrap=0; } \n\n    // rounded blue lines\n    if (index == 2) {nh=10, v1 = 64863, v2=4094; density=80.; setmethod=0; liveval=5.; decimate=0.; colch=2, staypatt=0; rp=0.;gp=4.;bp=4.; rm=5.,gm=5.,bm=5.; ra=1,ga=2,ba=2; radius=110.; } \n\n    // scribble and noise\n    if (index == 3) {nh=10, v1 = 64863, v2=4078; density=98.; setmethod=4; liveval=5.; decimate=0.; colch=2, staypatt=6; rp=5.;gp=2.;bp=2.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; radius=25.; } \n\n    // small worms\n    if (index == 4) {nh=10, v1 = 64860, v2=4094; density=10.; setmethod=0; liveval=2.; decimate=0.; colch=2, staypatt=6; rp=9.; gp=4.; bp=4.; rm=16.,gm=18.,bm=18.; ra=6,ga=7,ba=6; radius=180.; wrap=0; } \n\n    // red and green\n    if (index == 5) {nh=10, v1 = 64863, v2=4082; density=30.; setmethod=4; liveval=5.; decimate=0.; colch=2, staypatt=0; rp=10.;gp=4.;bp=4.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; density2=10.; } \n\n    // alien scribble\n    if (index == 6) {nh=10; v1 = 4094, v2=3966; density=90., setmethod=2; liveval=5., decimate=0., colch=2, staypatt=0, rp=10., gp=4., bp=4., rm=16., gm=16.,bm=18.,  ra=6,ga=7,ba=6; density2=-1.;radius=2.; }\n\n    // evil alien\n    if (index == 7) {nh=7, v1 = 31, v2=220; density=50.; setmethod=2; liveval=5.; decimate=0.; colch=2, staypatt=6; rp=5.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; radius=110.; } \n\n    // evil alien full\n    if (index == 8) {nh=7, v1 = 31, v2=220; density=40.; setmethod=0; liveval=5.; decimate=0.; colch=2, staypatt=6; rp=5.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; radius=110.; } \n\n    rp=rp+col.x; gp=gp+col.y; bp=bp+col.z;\n    stayset = v1; bornset = v2;\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_H     = 72;\nconst int KEY_M     = 77;\nconst int KEY_S     = 83;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) {\n        fragColor = vec4(0.,0.,0.,1.0);\n        return;\n    }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_RIGHT) || readKey(KEY_DOWN)) {\n                    kx+=0.1;\n                    if (kx > LAST_PATT*0.1+0.05) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=LAST_PATT*0.1+0.05;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_H, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 2.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        vec2 ppos = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xy;\n        float mmul = iMouse.x / iResolution.x;\n        vec2 mid = iResolution.xy / 2.;\n\n        float psp=8.;\n        if( readKey(KEY_D)) ppos.x += psp;\n        if( readKey(KEY_A)) ppos.x -= psp;\n        if( readKey(KEY_S)) ppos.y -= psp;\n        if( readKey(KEY_W)) ppos.y += psp;\n        ppos.x = clamp(ppos.x, -mid.x*mmul, mid.x*mmul);\n        ppos.y = clamp(ppos.y, -mid.y*mmul, mid.y*mmul);\n\n        fragColor = vec4(ppos,0.,1.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 269, 269, 665], [667, 667, 724, 724, 1819]], "test": "untested"}
{"id": "ds2BD3", "name": "UnchainedEnergy", "author": "NoxWings", "description": "The colors and the lighting are specifically done to camera.\nIt started nice and organized and then I went onto a rabbit hole of hacks to make it look as I wanted to so don't take any of this as a reference.\nxD", "tags": ["unchainedenergy", "euskalencounter"], "likes": 27, "viewed": 381, "published": 3, "date": "1690229669", "time_retrieved": "2024-07-30T17:42:35.384070", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color0 = texture(iChannel0, uv);\n    vec4 color1 = texture(iChannel1, uv);\n    \n    fragColor = ACESFilm(color0 + color1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#ifndef __COMMON_BASIC_GLSL__\n#define __COMMON_BASIC_GLSL__\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,iTime))\n\nconst float PI = 3.14159;\nconst float HALF_PI = PI * 0.5;\nconst float TAU = PI * 2.0;\nconst float DEG2RAD = TAU/360.0;\n\nfloat invLerp(float a, float b, float x) {\n    x = clamp(x, a, b);\n    return (x - a) / (b - a);\n}\n\nmat3 lookAtMatrix(in vec3 lookAtDirection) {\n\tvec3 ww = normalize(lookAtDirection);\n    vec3 uu = cross(ww, vec3(0.0, 1.0, 0.0));\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, -ww);\n}\n\nstruct Camera {\n    vec3 position;\n\tvec3 direction;\n};\n\nCamera createOrbitCamera(vec2 uv, vec2 mouse, vec2 resolution, float fov, vec3 target, float height, float distanceToTarget, float iTime)\n{\n    vec2 r = mouse / resolution * vec2(3.0 * PI, 0.5 * PI);\n    float halfFov = fov * 0.5;\n    float zoom = cos(halfFov) / sin(halfFov);\n\n    vec3 position = target + vec3(sin(r.x), 0.0, cos(r.x)) * distanceToTarget + vec3(0, height, 0);\n    vec3 direction = normalize(vec3(uv, -zoom));\n    direction = lookAtMatrix(target - position) * direction;\n\n    return Camera(position, direction);\n}\n\nmat2 rot2d(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 100000.5453);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n#endif // __COMMON_BASIC_GLSL__\n#ifndef __COMMON_COLORS_GLSL__\n#define __COMMON_COLORS_GLSL__\n\nvec4 linearTosRGB(vec4 linearRGB)\n{\n    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = linearRGB * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec4 sRGBToLinear(vec4 sRGB)\n{\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec4 ACESFilm(vec4 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec4(0), vec4(1));\n}\n\n#endif // __COMMON_COLORS_GLSL__\n#ifndef __COMMON_DIST_FUNCTIONS_GLSL__\n#define __COMMON_DIST_FUNCTIONS_GLSL__\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPrism(vec3 p, float tall, vec2 topSize, vec2 botSize) {\n    vec3 top = vec3(topSize.x, tall, topSize.y);\n    vec3 bot = vec3(botSize.x, tall, botSize.y);\n\n    float q = (p.y+tall)*.5/tall;\n    vec3 shape = mix(bot, top, q);\n\n    return sdBox(p, shape);\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 ) {\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n#endif // __COMMON_DIST_FUNCTIONS_GLSL__\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\nstruct Hit {\n    int id;\n    float dist; // means distance from ray to hit (<= surfHit usually)\n};\n\nstruct TraceResult {\n    Hit hit;\n    float dist; // means distance from ro to closest point to hit\n    vec3 ro;\n    vec3 rd;\n};\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k) {\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\nHit hmin(Hit a, Hit b) { if (a.dist < b.dist) return a; return b; }\nHit hmax(Hit a, Hit b) { if (a.dist < b.dist) return b; return a; }\nHit hsmin(in Hit a, in Hit b, in float k) {\n    Hit h = hmin(a, b);\n    h.dist = smin(a.dist, b.dist, k);\n    return h;\n}\nHit hsmax(in Hit a, in Hit b, in float k) {\n    Hit h = hmax(a, b);\n    h.dist = smin(a.dist, b.dist, k);\n    return h;\n}\nHit hnegate(Hit a) { return Hit(a.id, -a.dist); }\nHit opUnion(Hit a, Hit b) { return hmin(a, b); }\nHit opSubtraction(Hit a, Hit b) { return hmax(hnegate(a), b); }\nHit opIntersection(Hit a, Hit b) { return hmax(a, b); }\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\n\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emissive;\n    float ao;\n};\n\nstruct Surface {\n    int materialId;\n    float dist;\n    vec3 position;\n    vec3 normal;\n    float ao;\n    vec3 view;\n};\n\n// -----------------------------------------------------------------------------\n// PBR Implementation\n// - Lambert or Burley diffuse\n// - Schlick Fresnel\n// - GGX NDF\n// - Smith-GGX height-correlated visibility function\n\n// Sources\n//\n// https://learnopengl.com/PBR/Lighting\n// https://google.github.io/filament/Filament.html\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation\n\nvec3 F_Schlick_full(float HoV, vec3 f0, vec3 f90) {\n    return f0 + (f90 - f0) * pow(1.0 - HoV, 5.0);\n}\n\nvec3 F_Schlick(float HoV, vec3 f0) {\n    return F_Schlick_full(HoV, f0, vec3(1.0));\n}\n\nfloat Diff_Lambert() {\n    return 1.0 / PI;\n}\n\nvec3 Diff_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    vec3 lightScatter = F_Schlick_full(NoL, vec3(1.0), vec3(f90));\n    vec3 viewScatter = F_Schlick_full(NoV, vec3(1.0), vec3(f90));\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat D_GGX(float NoH, float a) {\n    float a2 = a * a;\n    float f = (NoH * a2 - NoH) * NoH + 1.0;\n    return a2 / (PI * f * f);\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float a) {\n    float a2 = a * a;\n    float NoV2 = NoV*NoV;\n    float NoL2 = NoL*NoL;\n    float GGL = NoL * sqrt(NoV2 * (1.0 - a2) + a2);\n    float GGV = NoV * sqrt(NoL2 * (1.0 - a2) + a2);\n\treturn 0.5 / (GGL + GGV);\n}\n\nfloat GGX_Smith_Approx_Visibility(float NoV, float NoL, float a) {\n    return 1.0 / (2.0 * mix(2.0*NoL*NoV, NoL+NoV, a));\n}\n\n\nvec3 BRDF(DirectionalLight l, Surface surf, Material mat, float shadow) {\n    vec3 V = -surf.view;\n    vec3 N = surf.normal;\n    vec3 L = l.direction;\n    vec3 H = normalize(V + L);\n\n    float NoV = max(dot(N, V), 0.0);\n    float NoL = max(dot(N, L), 0.0);\n    float NoH = max(dot(N, H), 0.0);\n    float HoV = max(dot(H, V), 0.0);\n\n    vec3  albedo     = mat.albedo;\n    float roughness  = mat.roughness;\n    float a          = roughness * roughness;\n    float metallic   = mat.metallic;\n    float dielectric = 1.0 - metallic;\n\n    // Constants\n    vec3 dielectricSpecular = vec3(0.04);\n    vec3 black = vec3(0);\n\n    // Frenel term\n    vec3 F0 = mix(dielectricSpecular, albedo, metallic);\n    vec3 F  = F_Schlick(HoV, F0);\n\n    // Normal distribution\n    float D = D_GGX(NoH, a);\n\n    // Visibility term\n    //     should be equivalent to G / (4.0 * NoL * NoV)\n    //     but it doesn't look the same as https://www.shadertoy.com/view/tdKXR3\n    float Vis = V_SmithGGXCorrelated(NoV, NoL, a);\n\n    // Specular BRDF Cook Torrance\n    vec3 specular = F * (Vis * D);\n\n    // Lambert Diffuse\n    //     Should we scale by (1.0 - F) ?? gltf and learnopengl have it but filament doesn't\n    //     Also what about lambert 1/PI ?? https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    //     PI might not be used in IBL only?\n    vec3 kD = vec3(1.0) - F;\n    vec3 c = mix(albedo * (1.0-dielectricSpecular), black, metallic);\n    vec3 diffuse = kD * (c / PI);\n    // vec3 diffuse = (1.0 - F) * diffuseColor * Diff_Burley(NoV, NoL, NoH, a);\n\n    // Final Color\n    vec3 emissive = mat.emissive;\n    vec3 directLight = l.color * NoL * (diffuse + specular);\n\n    //return vec3(Vis)*NoL;\n    return emissive + directLight * shadow;\n}\n", "buffer_a_code": "\n// ***********************************************************************\n// *************************** SCENE *************************************\n// ***********************************************************************\n\n\nfloat straigthChain(vec3 p, float l) {\n    const float le = 0.15, r1 = 0.2, r2 = 0.07;\n    vec3 a = p;\n    vec3 b = p;\n\n    if (p.y > -.5 && p.y < l) {\n        a.y = fract(a.y)-0.5;\n        b.y = fract(b.y+.5)-0.5;\n    }\n\n    return min(\n        sdLink(a.xyz, le, r1, r2),\n        sdLink(b.zyx, le, r1, r2)\n    );\n}\n\nfloat circularChain(vec3 p, float radius, float repetitions) {\\\n    const float le = 0.15, r1 = 0.2, r2 = 0.065;\n    float arc = 360.0 / repetitions * DEG2RAD;\n\n    vec3 q = p;\n    pModPolar(q.xz, repetitions);\n    q -= vec3(radius, 0, 0);\n    q.yz = rot2d(90.0 * DEG2RAD) * q.yz;\n\n    float link1 = sdLink(q, le, r1, r2);\n\n    vec3 q2 = p;\n    q2.xz = rot2d(arc * 0.5) * q2.xz;\n    pModPolar(q2.xz, repetitions);\n    q2 -= vec3(radius, 0, 0);\n    // alternate link rotation\n    q2.xz = rot2d(90.0 * DEG2RAD) * q2.xz;\n    q2.xy = rot2d(90.0 * DEG2RAD) * q2.xy;\n    float link2 = sdLink(q2, le, r1, r2);\n\n    return min(link1, link2);\n}\n\nvoid r2d(inout vec2 axis, float angle) {\n    axis = rot2d(angle) * axis;\n}\n\nHit map(vec3 p) {\n    //Hit floorPlane = Hit(0, sdPlane(p, -20.5));\n    Hit ball = Hit(1, sdSphere(p - vec3(0,1.0,0), 0.75));\n\n    float linkRadius = 2.0;\n    float linkRepetitions = 12.0;\n    float selfRotationSpeed = 1.5;\n\n    vec3 q = p;\n    q -= vec3(0, 1, 0);\n\n    vec3 q1 = q;\n    r2d(q1.yz, iTime + 1.*TAU/3.);\n    r2d(q1.xz, iTime * selfRotationSpeed * 2.0);\n    Hit chainLink = Hit(2, circularChain(q1, linkRadius, 12.0));\n\n    vec3 q2 = q;\n    r2d(q2.xy, iTime + 2.*TAU/3.);\n    r2d(q2.xz, iTime * selfRotationSpeed * 1.5);\n    chainLink = hmin(chainLink, Hit(2, circularChain(q2, linkRadius * 1.4, 16.0)));\n\n    vec3 q3 = q;\n    r2d(q3.yz, iTime + TAU);\n    r2d(q3.xz, iTime * selfRotationSpeed * 1.0);\n    chainLink = hmin(chainLink, Hit(2, circularChain(q3, linkRadius * 1.7, 21.0)));\n\n    //Hit result = hmin(floorPlane, chainLink);\n    Hit result = chainLink;\n    result = hmin(result, ball);\n    return result;\n}\n\n// ***********************************************************************\n// *************************** END SCENE *********************************\n// ***********************************************************************\n\nvec3 mapNormal(vec3 p, float surfHit) {\n    vec2 e = vec2(surfHit, 0);\n    float d = map(p).dist;\n\n    return normalize(vec3(\n        d - map(p - e.xyy).dist,\n        d - map(p - e.yxy).dist,\n        d - map(p - e.yyx).dist\n    ));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// Fast raymarching\nTraceResult trace(vec3 ro, vec3 rd, float surfHit, float maxDistance, int maxSteps) {\n    float d = 0.0;\n    for (int i = 0; i < maxSteps && d <= maxDistance; i++) {\n        vec3 p = ro + rd * d;\n        Hit h = map(p);\n        if (h.dist <= surfHit)\n            return TraceResult(h, d, ro, rd);\n        d += h.dist;\n    }\n    return TraceResult(Hit(-1, maxDistance), d, ro, rd);\n}\n\n// Raymarching\n// Regular sphere tracing but returning the closest hit\nTraceResult traceClosest(vec3 ro, vec3 rd, float surfHit, float maxDistance, int maxSteps) {\n    float d = 0.0;\n    Hit closest = Hit(-1, maxDistance);\n    for (int i=0; i < maxSteps && d <= maxDistance; i++){\n        vec3 p = ro + rd * d;\n        Hit h = map(p);\n        if (h.dist < closest.dist)\n            closest = h;\n        if (h.dist <= surfHit)\n            return TraceResult(h, d, ro, rd);\n        d += h.dist;\n    }\n    return TraceResult(closest, d, ro, rd);\n}\n\n// Traces soft shadows\nfloat traceShadow(vec3 ro, vec3 rd, float hardness, float surfHit, float farPlane, int maxSteps) {\n    float d = surfHit;\n    float k = hardness;\n    float res = 1.0;\n\n    for (int i=0; i < maxSteps && d <= farPlane; i++) {\n        vec3 p = ro + rd * d;\n        float stepDistance = map(p).dist;\n        if (stepDistance < surfHit) return 0.0;\n        res = min(res, k * stepDistance / d);\n        d += stepDistance;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\n\nSurface getSurf(TraceResult tr) {\n    vec3 position = tr.ro + tr.rd * tr.dist;\n    vec3 normal = mapNormal(position, 0.01);\n    vec3 view = tr.rd;\n    float ao = calcAO(position, normal);\n\n    return Surface(\n        tr.hit.id,  // material id\n        tr.dist,    // distance\n        position,\n        normal,\n        ao,\n        view\n    );\n}\n\nMaterial matFromSurface(Surface s) {\n    Material m;\n    m.albedo    = vec3(0.0);\n    m.metallic  = 0.0;\n    m.roughness = 1.0;\n    m.emissive  = vec3(0.0);\n    m.ao = s.ao;\n\n    if (s.materialId == 0) { // Floor\n        m.albedo    = vec3(0.2, 0.2, 0.2);\n        m.roughness = 0.0;\n    } else if (s.materialId == 1) { // Ball\n        m.albedo = vec3(0.2);\n        m.roughness = 0.6;\n        m.emissive = vec3(15000,15000,20000);\n    } else if (s.materialId == 2) { // Chains\n        m.albedo = vec3(.05);\n        m.roughness = 0.2;\n        m.metallic = 1.0;\n        // m.emissive = vec3(0);\n    } else { // Error\n        m.emissive = vec3(1, 0, 1);\n    }\n\n    return m;\n}\n\nstruct RenderInfo {\n    vec3 color;\n    float dist;\n};\n\n\nvec3 fakeReflectionIBL(Surface s, Material m) {\n    vec3 reflection = reflect(s.view, s.normal);\n\n    vec3 roughRef = sRGBToLinear(texture(iChannel0, reflection)).rgb;\n    vec3 glossyRef = sRGBToLinear(texture(iChannel1, reflection)).rgb;\n    \n    float a = m.roughness * m.roughness;\n    vec3 ref = mix(glossyRef, roughRef, a);\n    \n    return mix(vec3(0), ref, m.metallic);\n}\n\nRenderInfo render(Camera cam) {\n    DirectionalLight sun = DirectionalLight(\n        normalize(vec3(1,1,1)),\n        vec3(10, 10, 10)\n    );\n    vec3 ambientLight = vec3(1);\n\n    int primarySteps = 256;\n    float farPlane = 20.0;\n    float surfHit = 0.01;\n\n    TraceResult traceRes = trace(cam.position, cam.direction, surfHit, farPlane, primarySteps);\n    Surface surface = getSurf(traceRes);\n        \n    if (surface.materialId == -1) {\n        return RenderInfo(\n            texture(iChannel0, surface.view).rgb,\n            farPlane\n        );\n    }\n    \n    Material material = matFromSurface(surface);\n\n    vec3 shadowOrigin = surface.position + surface.normal * surfHit * 2.0;\n    int shadowSteps = 32;\n    float shadow = traceShadow(shadowOrigin, sun.direction, 28.0, surfHit, farPlane, shadowSteps);\n\n    vec3 brdfColor = max(vec3(0.0), BRDF(sun, surface, material, shadow));\n    vec3 ambientColor = ambientLight * material.albedo;\n\n    vec3 finalColor = brdfColor + ambientColor * surface.ao + fakeReflectionIBL(surface, material);\n\n    return RenderInfo(\n        finalColor,\n        traceRes.dist\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 fakeScreen = uv * 2.0 - 1.0;\n    fakeScreen.x *= iResolution.x / iResolution.y;\n\n    Camera cam = createOrbitCamera(\n        fakeScreen,\n        iMouse.xy + iTime * 100.0,\n        iResolution.xy,\n        60.0 * DEG2RAD,\n        vec3(0,1.0,0),  // target,\n        2.0,            // height,\n        7.0,            // distanceToTarget,\n        iTime\n    );\n\n    RenderInfo renderOut = render(cam);\n    fragColor = vec4(renderOut.color, renderOut.dist);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fake volumetrics\n\nconst float INTENSITY = 1.0;\nconst float RANDOMIZE = 1.0;\n\nvec4 sampleTex(vec2 uv) {\n    vec4 color = texture(iChannel0, uv);\n    float maxAllowed = 20000.0;\n    if (length(color.rgb) < maxAllowed) {\n        color = vec4(0.0);\n    } else {\n        color = pow(color, vec4(1.0));\n        color *= INTENSITY / maxAllowed;\n    }\n    return color;\n}\n\nvec3 shaft(vec2 uv, int steps) {\n    vec2 centerPos = vec2(0.5, 0.5);\n    uv -= centerPos;\n    float invSamples = 1.0 / float(steps);\n    \n    vec3 result = vec3(0.0);\n    float scale = 0.0;\n    \n    for( int i = 1; i < steps; i++ ) {\n        scale = (float(i) + rand(uv) * RANDOMIZE)*invSamples;\n        result += sampleTex(uv * scale + centerPos).rgb;\n    }\n    \n    return result * invSamples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = shaft(uv, 32);\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2BD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 236]], "test": "untested"}
{"id": "ms2BD3", "name": "newton flower 4", "author": "shadertoyjiang", "description": "中心的花", "tags": ["fractal", "flower", "center", "newton"], "likes": 4, "viewed": 70, "published": 3, "date": "1690228778", "time_retrieved": "2024-07-30T17:42:36.203878", "image_code": "// 一\n\n\n\nvoid mainImage( out vec4 O, vec2 u )\n\n{\n\n\tvec2 g,q,R=iResolution.xy,\n\tv=24.*(u+u-R)/R.y,h;//=v;\n\n\t\n\n\tfloat a,r,s,i;  //,p=5., l=1.;\n\n\n\n\tfor(;i++<10.   ;)\n\n\t\ta=atan(v.y, v.x)+.618,\n\n\t\tr=length(v)*.7,      //(p-1.5   )/p,\n\t\t\n        s=.2/r/r/r/r,     //s=l/(p*pow(r, p-l)),\t\t\n\n\t\tg=q,q=v, \n\n\t\tv=vec2(r*cos(a)-s*cos(-4.*a),   // -4.=1.-p\n\n\t\t       r*sin(a)-s*sin(-4.*a))\n               \n       /*可注销 // */  ,  i<3.       ? h = v : h \n           ;\n\n    g = abs(q - g);\n\n\th = abs(v - h);\n\n\ts =g.x * g.y;\n\n\tO = vec4( 1.7 * log(1. + s) - .8\n\n\t\t,     .25 * log(1. + h.x * h.y) - .4 \n\n\t\t,     .3  * log(1. + s * s) - .1\n\n\t\t, 1.);\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2BD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 49, 49, 640]], "test": "untested"}
{"id": "cs2fDc", "name": "vibez", "author": "crow_fff", "description": "playing with Perlin noise", "tags": ["noise", "color"], "likes": 1, "viewed": 138, "published": 3, "date": "1690219093", "time_retrieved": "2024-07-30T17:42:37.071557", "image_code": "// Pi divided by two (pi/2)\nconst float M_PI_2 = 1.57079632679489661923132169163975144;\n\n// For multiple octaves\n#define NOISE fbm\n#define NUM_NOISE_OCTAVES 5\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n    float theta = atan(st.x, st.y)/M_PI_2 +.5; float phi = log(length(st)) * .8;\n    float r = noise(vec2(iTime + 0.001 * st.x, iTime + 6.4 * st.y)), \n    g = noise(vec2(iTime + 0.3 * st.x, iTime + 114. * st.y)),\n    b = noise(vec2(iTime + 102. * st.x, iTime + 3.3 * st.y));\n\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2fDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 234, 255, 255, 322], [323, 323, 343, 343, 448], [450, 450, 472, 472, 604], [607, 607, 628, 628, 1262], [1265, 1265, 1286, 1286, 2047], [2049, 2049, 2106, 2156, 2511]], "test": "untested"}
{"id": "mdjBWK", "name": "Triangle Barycentric Coordinates", "author": "beans_please", "description": "This started as a 4 AM question: \"How do vertex attributes get interpolated in a fragment shader?\"\nThe Wikipedia page for Barycentric Coordinates was too complicated for me, so hopefully this is easier to und.\nhttps://www.desmos.com/calculator/8g8xjejuox\n", "tags": ["2d", "triangle", "barycentric", "linear", "matrix", "interpolation", "vectors", "matrices"], "likes": 2, "viewed": 215, "published": 3, "date": "1690217266", "time_retrieved": "2024-07-30T17:42:37.932256", "image_code": "vec3 view_transform(vec3 col)\n{\n\t// OETF\n    return pow(col, vec3(1. / 2.2));\n}\n\nvoid get_vertices(out vec2 v0, out vec2 v1, out vec2 v2)\n{\n    v0 = vec2(random() - .5, random() - .5);\n    v1 = vec2(random() - .5, random() - .5);\n    v2 = vec2(random() - .5, random() - .5);\n    \n    v0 = mix(v0, 1.3 * vec2(0., .4), .6);\n    v1 = mix(v1, 1.3 * vec2(-.5, -.3), .6);\n    v2 = mix(v2, 1.3 * vec2(.5, -.3), .6);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // time\n    const float speed = 1.7;\n    float ti = floor(iTime * speed);\n    float tfrac = fract(iTime * speed);\n    \n    // UV\n    vec2 uv = screen_to_uv_fit(frag_coord, iResolution.xy);\n    \n    // triangle vertices\n    vec2 v0, v1, v2,\n        v0a, v0b,\n        v1a, v1b,\n        v2a, v2b;\n    {\n        prng_init(vec3(float(int(ti)), 1, 2));\n        get_vertices(v0a, v1a, v2a);\n        \n        prng_init(vec3(float(int(ti) + 1), 1, 2));\n        get_vertices(v0b, v1b, v2b);\n        \n        float t = smoothstep(.1, .9, tfrac);\n        v0 = mix(v0a, v0b, t);\n        v1 = mix(v1a, v1b, t);\n        v2 = mix(v2a, v2b, t);\n    }\n    \n    // get barycentric coords\n    bool outside;\n    vec3 col = cartesian_to_barycentric(uv, v0, v1, v2, true, outside);\n    \n    // darken the outer areas\n    if (outside)\n    {\n        col *= cos(TAU * speed * .1 * iTime) * .45 + .55;\n    }\n    \n    // output\n    col = view_transform(col);\n    frag_col = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "/*_________________ math utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T inp, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nfloat min_component(vec2 inp)\n{\n    return min(inp.x, inp.y);\n}\n\nfloat min_component(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nfloat min_component(vec4 inp)\n{\n    return min(min(min(inp.x, inp.y), inp.z), inp.w);\n}\n\nfloat max_component(vec2 inp)\n{\n    return max(inp.x, inp.y);\n}\n\nfloat max_component(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat max_component(vec4 inp)\n{\n    return max(max(max(inp.x, inp.y), inp.z), inp.w);\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n\n\n/*_______ pseudo-random number generator ______*/\n// source: https://www.shadertoy.com/view/WdSSRt\n\n/* usage example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // use the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 2654435771u, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// generate two normally distributed random numbers using the\n// Box-Muller transform\n// source: https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 40, 79], [81, 81, 139, 139, 410], [412, 412, 467, 479, 1433]], "test": "untested"}
{"id": "cs2BD3", "name": "PerfTest Uni, Bi, TriPlanar", "author": "gehtsiegarnixan", "description": "Simple performance Test for Tri-, Bi-, and Uni-planar mapping to see who is fastest. This repeats the function n times with different values to tank your fps, so you can see which is fastest.", "tags": ["test", "triplanar", "dither", "cubemap", "performance", "performance", "interpolation", "biplanar", "uniplanar"], "likes": 4, "viewed": 317, "published": 3, "date": "1690215330", "time_retrieved": "2024-07-30T17:42:38.992421", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis performance test aims to compare planar mapping implementations. \n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n*/\n\n// Number of repeats of the test, 1500 should be enough for RTX3080\n#define REPEAT 1\n\n// switch between the test cases\n// 0 = uniplanarIf using dithered deriviative Mips ~ 82 fps\n// 1 = uniplanarIf using deriviative Mips ~ 78 fps\n// 2 = uniplanarIf (use linear texture) ~ 132 fps\n// 3 = uniplanarLerp (use linear texture) ~ 105 fps\n// 4 = Biplanar  ~ 19 fps\n// 5 = Triplanar ~ 63 fps\n// 6 = Triplanar with Branching ~ 83 fps\n// 7 = Triplanar with Less Branching ~ 80 fps\n// 8 = Triplanar with Nested Branching ~ 78 fps\n// 9 = Triplanar with Nested Branching Broken mips ~ 110 fps\n#define TEST 6\n\n// shows the blend area\n//#define SHOWBLEND\n#define LINETHICKNESS 0.05\n\n// 1 for no contrast, higher values for more contrast\n#define CONTRAST 16.0 \n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIfDitheredMips( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast) {    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx( position );\n    vec3 duvwdy = dFdy( position );\n    \n    // uvs for derivatives Mips\n    vec2 duvdx; \n    vec2 duvdy; \n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n        duvdx = duvwdx.yz; // how is this thing allowed?\n        duvdy = duvwdy.yz;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n        duvdx = duvwdx.zx;\n        duvdy = duvwdy.zx;\t\n    } else {\n        uv = uvZ;\n        duvdx = duvwdx.xy;\n        duvdy = duvwdy.xy;\n    }\n    \n    // texture sample\n    vec4 col = textureGrad( sam, uv, duvdx, duvdy);\n    \n    #ifdef SHOWBLEND\n    float lineThickness = 0.05; // must be smaller than 0.1\n    vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIfMips( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast) {    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n    } else {\n        uv = uvZ;\n    }\n    \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx( position );\n    vec3 duvwdy = dFdy( position );\n    \n    // uvs for derivatives Mips\n    vec2 duvdx; \n    vec2 duvdy; \n    if (alpha.x>alpha.y && alpha.x>alpha.z) {\n        duvdx = duvwdx.yz;\n        duvdy = duvwdy.yz;\n    } else if (alpha.y>alpha.z) {\n        duvdx = duvwdx.zx;\n        duvdy = duvwdy.zx;\t\n    } else {\n        duvdx = duvwdx.xy;\n        duvdy = duvwdy.xy;\n    }  \n    \n    // texture sample\n    vec4 col = textureGrad( sam, uv, duvdx, duvdy);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarIf( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast) {    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n       \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    // Apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = alpha.y + xDitherPart;\n\n    // \"interpolate\" the UVs\n    vec2 uv;\n    if (xDitherPart >= 0.0 && yDitherPart >= 0.0) {\n        uv = uvX;\n    } else if (yDitherPart >= 0.0) {\n        uv = uvY;\n    } else {\n        uv = uvZ;\n    }\n    \n    vec4 col = texture( sam, uv);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// one texture sample, uses dithering to make the edges smoother\nvec4 uniplanarLerp( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast) {\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // static dither\n    float dither = InterleavedGradientNoise(fragCoord);\n    \n    //apply float dither to three values of Alpha\n    float xDitherPart = alpha.x - dither;\n    float yDitherPart = step(0., alpha.y + xDitherPart);\n    float xDither = step(0., xDitherPart);\n    vec3 ditherAlpha = vec3(xDither, yDitherPart - xDither, 1.0 - yDitherPart);\n    \n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n    \n    // interpolate (since we use bitmasks it is allowed for UVs)\n    vec2 uv = uvX * ditherAlpha.x + uvY * ditherAlpha.y + uvZ * ditherAlpha.z;\n    \n    vec4 col = texture( sam, uv);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(alpha - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// IQ's Biplanar mapping implementation (https://www.shadertoy.com/view/ws3Bzf)\n// The MIT License\n// Copyright © 2020 Inigo Quilez\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, in float k ) {\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // contrast\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n    // transition control\n    m = pow( m, vec2(k/8.0) );\n    m = m / (m.x + m.y);\n    \n    // interpolate\n\tvec4 col = x*m.x + y*m.y;\n    \n    #ifdef SHOWBLEND\n    vec2 mask = step(abs(m - 0.1), vec2(LINETHICKNESS));\n    return vec4(max(mask, col.xy), col.zw);\n    #else\n    return col;\n    #endif\n}\n\n// IQ's Triplanar mapping implementation (https://www.shadertoy.com/view/MtsGWH)\n// The MIT License\n// Copyright © 2015 Inigo Quilez\nvec4 triplanar( in sampler2D s, in vec3 p, in vec3 n, in float k ) {\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and contrast\n    vec3 m = pow( abs(n), vec3(k) );\n    m = m / (m.x + m.y + m.z);\n    \n    // interpolate\n    vec4 col = (x*m.x + y*m.y + z*m.z);\n    \n    #ifdef SHOWBLEND\n    vec3 mask = step(abs(m - 0.1), vec3(LINETHICKNESS));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// Triplanar with branching, using 3,2,1 samples where possible. \n#define JUST_ABOVE_ZERO (1.0 / float(0xffffU))\n#define JUST_BELOW_ONE (1.0 - JUST_ABOVE_ZERO)\nvec4 branchingTriplanar( in sampler2D sam, in vec3 position, in vec3 normal, in float contrast ){\n    // Alpha Mask for blending\n    vec3 weights = abs(normal); \n    \n    // Normalize alpha to sum=1\n    weights = weights / (weights.x + weights.y + weights.z);\n    \n    // Apply contrast \n    weights = straightContrast(weights, contrast); // increase contrast    \n\n    // Coordinate projections\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n        \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx(position);\n    vec3 duvwdy = dFdy(position);\n    \n    // Partial Derivative Projection\n    vec2 duvdxX = duvwdx.yz; \n    vec2 duvdyX = duvwdy.yz;\n    vec2 duvdxY = duvwdx.zx; \n    vec2 duvdyY = duvwdy.zx;\n    vec2 duvdxZ = duvwdx.xy; \n    vec2 duvdyZ = duvwdy.xy;\n    \n    vec4 color;\n    if (weights.x > JUST_BELOW_ONE) {\n        // Sample X Side\n        color = textureGrad(sam, uvX, duvdxX, duvdyX);\n        \n    } else if (weights.y > JUST_BELOW_ONE) {\n        // Sample Y Side\n        color = textureGrad(sam, uvY, duvdxY, duvdyY);\n    \n    } else if (weights.z > JUST_BELOW_ONE) {\n        // Sample Z Side\n        color = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n    } else if (weights.x < JUST_ABOVE_ZERO) {\n        // Samples YZ Side \n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n        // Color interpolation\n        color = colorY * weights.y + \n                colorZ * weights.z;\n    \n    } else if (weights.y < JUST_ABOVE_ZERO) {\n        // Samples XZ Side\n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n        // Color interpolation\n        color = colorX * weights.x +\n                colorZ * weights.z;\n    \n    } else if (weights.z < JUST_ABOVE_ZERO) {\n        // Samples XY Side\n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n\n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y;\n        \n    } else {\n       // Samples all 3 \n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n\n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y + \n                colorZ * weights.z;\n    }\n        \n    #ifdef SHOWBLEND\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        return vec4(max(mask, color.xyz), color.w);\n    #else\n        return color;\n    #endif\n}\n\n// Triplanar with branching where a samples is 100% and 3 samples otherwise\n#define JUST_ABOVE_ZERO (1.0 / float(0xffffU))\n#define JUST_BELOW_ONE (1.0 - JUST_ABOVE_ZERO)\nvec4 lessBanchingTriplanar( in sampler2D sam, in vec3 position, in vec3 normal, in float contrast ){\n    // Alpha Mask for blending\n    vec3 weights = abs(normal); \n    \n    // Normalize alpha to sum=1\n    weights = weights / (weights.x + weights.y + weights.z);\n    \n    // Apply contrast \n    weights = straightContrast(weights, contrast); // increase contrast    \n\n    // Coordinate projections\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n    \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx(position);\n    vec3 duvwdy = dFdy(position);\n    \n    // Partial Derivative Projection\n    vec2 duvdxX = duvwdx.yz; \n    vec2 duvdyX = duvwdy.yz;\n    vec2 duvdxY = duvwdx.zx; \n    vec2 duvdyY = duvwdy.zx;\n    vec2 duvdxZ = duvwdx.xy; \n    vec2 duvdyZ = duvwdy.xy;\n    \n    vec4 color;\n    if (weights.x > JUST_BELOW_ONE) {\n        // Sample X Side\n        color = textureGrad(sam, uvX, duvdxX, duvdyX);\n        \n    } else if (weights.y > JUST_BELOW_ONE) {\n        // Sample Y Side\n        color = textureGrad(sam, uvY, duvdxY, duvdyY);\n    \n    } else if (weights.z > JUST_BELOW_ONE) {\n        // Sample Z Side\n        color = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n    } else {\n        // Samples all 3 \n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n\n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y + \n                colorZ * weights.z;\n    }\n        \n    #ifdef SHOWBLEND\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        return vec4(max(mask, color.xyz), color.w);\n    #else\n        return color;\n    #endif\n}\n\n// Triplanar with nested branching, using texture grad to fix edges\nvec4 NestedBranchingTriplanar( in sampler2D sam, in vec3 position, in vec3 normal, in float contrast ){\n    // Alpha Mask for blending\n    vec3 weights = abs(normal); \n    \n    // Normalize alpha to sum=1\n    weights = weights / (weights.x + weights.y + weights.z);\n    \n    // Apply contrast \n    weights = straightContrast(weights, contrast); // increase contrast    \n    \n    // Coordinate projections\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n    \n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx(position);\n    vec3 duvwdy = dFdy(position);\n    \n    // Partial Derivative Projection\n    vec2 duvdxX = duvwdx.yz; \n    vec2 duvdyX = duvwdy.yz;\n    vec2 duvdxY = duvwdx.zx; \n    vec2 duvdyY = duvwdy.zx;\n    vec2 duvdxZ = duvwdx.xy; \n    vec2 duvdyZ = duvwdy.xy;\n    \n    // Precalculate boolean statments for branchnig\n    bool sampleX = weights.x > JUST_BELOW_ONE;\n    bool sampleY = weights.y > JUST_BELOW_ONE;\n    bool sampleZ = weights.z > JUST_BELOW_ONE;\n    bool sampleYZ = weights.x < JUST_ABOVE_ZERO;\n    bool sampleXZ = weights.y < JUST_ABOVE_ZERO;\n    bool sampleXY = weights.z < JUST_ABOVE_ZERO;\n    \n    vec4 color;\n    if (sampleX || sampleY || sampleZ) {\n        // In case just one is visible\n        // Find roughly the largest UVs\n        vec2 uvSingle;\n        vec2 ddxSingle;\n        vec2 ddySingle;\n        if (sampleX) {\n            // X Side\n            uvSingle = uvX;\n            ddxSingle = duvdxX;\n            ddySingle = duvdyX;\n\n        } else if (sampleY) {\n            // Y Side\n            uvSingle = uvY;\n            ddxSingle = duvdxY;\n            ddySingle = duvdyY;\n\n        } else {\n            // Z Side\n            uvSingle = uvZ;\n            ddxSingle = duvdxZ;\n            ddySingle = duvdyZ;\n        }\n    \n        // sample Single\n        color = textureGrad(sam, uvSingle, ddxSingle, ddySingle);\n        \n    } else if (sampleYZ || sampleXZ || sampleXY) {\n        // In Case two values are Blending         \n        vec2 uvDoubleA;\n        vec2 uvDoubleB;\n        vec2 ddxDoubleA;\n        vec2 ddyDoubleA;\n        vec2 ddxDoubleB;\n        vec2 ddyDoubleB;\n        vec2 weightsDouble;\n        if (sampleYZ) {\n            // YZ Side\n            uvDoubleA = uvY;\n            ddxDoubleA = duvdxY;\n            ddyDoubleA = duvdyY;\n            \n            uvDoubleB = uvZ; \n            ddxDoubleB = duvdxZ;\n            ddyDoubleB = duvdyZ;\n\n            weightsDouble = vec2(weights.y, weights.z);\n\n        } else if (sampleXZ) {\n            // XZ Side\n            uvDoubleA = uvX;\n            ddxDoubleA = duvdxX;\n            ddyDoubleA = duvdyX;\n            \n            uvDoubleB = uvZ;\n            ddxDoubleB = duvdxZ;\n            ddyDoubleB = duvdyZ;\n\n            weightsDouble = vec2(weights.x, weights.z);\n\n        } else {\n            //  XY Side\n            uvDoubleA = uvX;\n            ddxDoubleA = duvdxX;\n            ddyDoubleA = duvdyX;\n            \n            uvDoubleB = uvY;   \n            ddxDoubleB = duvdxY;\n            ddyDoubleB = duvdyY;\n            \n            weightsDouble = vec2(weights.x, weights.y);\n        }\n        \n        // Samples 2 Sides\n        vec4 colorX = textureGrad(sam, uvDoubleA, ddxDoubleA, ddyDoubleA);\n        vec4 colorY = textureGrad(sam, uvDoubleB, ddxDoubleB, ddyDoubleB);\n        \n        // Color interpolation\n        color = colorX * weightsDouble.x + \n                colorY * weightsDouble.y;\n                \n    } else {\n        // Samples all 3 \n        vec4 colorX = textureGrad(sam, uvX, duvdxX, duvdyX);\n        vec4 colorY = textureGrad(sam, uvY, duvdxY, duvdyY);\n        vec4 colorZ = textureGrad(sam, uvZ, duvdxZ, duvdyZ);\n        \n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y + \n                colorZ * weights.z;\n    } \n                                    \n    #ifdef SHOWBLEND\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        return vec4(max(mask, color.xyz), color.w);\n    #else\n        return color;\n    #endif\n}\n\n// Triplanar with nested branching each should hide the Mip edges ... but branching creates new edges?\nvec4 FixNestedBranchingTriplanar( in sampler2D sam, in vec3 position, in vec3 normal, in float contrast ){\n    // Alpha Mask for blending\n    vec3 weightsO = abs(normal); \n    \n    // Normalize alpha to sum=1\n    weightsO = weightsO / (weightsO.x + weightsO.y + weightsO.z);\n    \n    // Apply contrast \n    vec3 weights = straightContrast(weightsO, contrast); // increase contrast    \n\n    // Coordinate projections\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n        \n    vec4 color;    \n    if (any(greaterThan(weights, vec3(JUST_BELOW_ONE)))) {\n        // In case just one is visible\n        // Find roughly the largest UVs\n        vec2 uvSingle;\n        if (weights.x > 0.5) {\n            // X Side\n            uvSingle = uvX;\n\n        } else if (weights.y > 0.5) {\n            // Y Side\n            uvSingle = uvY;\n\n        } else {\n            // Z Side\n            uvSingle = uvZ;\n        }\n    \n        // sample Single\n        color = texture(sam, uvSingle);\n        \n    } else if (any(greaterThan(vec3(JUST_ABOVE_ZERO), weights))) {\n        // In Case two values are Blending         \n        vec2 uvDoubleA;\n        vec2 uvDoubleB;\n        vec2 weightsDouble;\n        if (weightsO.x < weightsO.y && weightsO.x < weightsO.z) {\n            // YZ Side\n            uvDoubleA = uvY;\n            uvDoubleB = uvZ;   \n\n            weightsDouble = vec2(weights.y, weights.z);\n\n        } else if (weightsO.y < weightsO.z) {\n            // XZ Side\n            uvDoubleA = uvX;\n            uvDoubleB = uvZ; \n\n            weightsDouble = vec2(weights.x, weights.z);\n\n        } else {\n            //  XY Side\n            uvDoubleA = uvX;\n            uvDoubleB = uvY;   \n\n            weightsDouble = vec2(weights.x, weights.y);\n        }\n        \n        // Samples 2 Sides\n        vec4 colorX = texture(sam, uvDoubleA);\n        vec4 colorY = texture(sam, uvDoubleB);\n        \n        // Color interpolation\n        color = colorX * weightsDouble.x + \n                colorY * weightsDouble.y;\n                \n    } else {\n        // Samples all 3 \n        vec4 colorX = texture(sam, uvX);\n        vec4 colorY = texture(sam, uvY);\n        vec4 colorZ = texture(sam, uvZ);\n        \n        // Color interpolation\n        color = colorX * weights.x + \n                colorY * weights.y + \n                colorZ * weights.z;\n    } \n                                    \n    #ifdef SHOWBLEND\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        return vec4(max(mask, color.xyz), color.w);\n    #else\n        return color;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 dir = sphereNormals(uv);\n\n    // if you get around 144 fps use a higher repeat value\n    vec4 test;\n    for(int i=0; i<REPEAT; i++) {\n        float mut = (float(i)/float(REPEAT)); // permutation each iteration\n            \n        // use which ever you wish to test\n        #if TEST == 0\n            test += uniplanarIfDitheredMips(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 1\n            test += uniplanarIfMips(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 2\n            test += uniplanarIf(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 3\n            test += uniplanarLerp(iChannel0, dir + mut, dir - mut, fragCoord + mut, CONTRAST);\n        #elif TEST == 4\n            test += biplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #elif TEST == 5\n            test += triplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #elif TEST == 6\n            test += branchingTriplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #elif TEST == 7\n            test += lessBanchingTriplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #elif TEST == 8\n            test += NestedBranchingTriplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #else\n            test += FixNestedBranchingTriplanar(iChannel0, dir + mut, dir - mut, CONTRAST);\n        #endif\n    }\n    \n    #if REPEAT > 1\n        // Ensure test vector stays in visible range\n        test = fract(test);\n    #endif\n\n    // Output to screen\n    fragColor = test;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926536\n\n// sphere normals form morgan3d https://www.shadertoy.com/view/4dsGD2\nvec3 sphereNormals(vec2 uv) \n{\n    float theta = (1.0 - uv.y) * PI;\n\tfloat phi   = uv.x * PI * 2.0;\n    \n    float sinTheta = sin(theta);    \n    \n    // Equation from http://graphicscodex.com  [sphry]\n\tvec3 dir = vec3(sinTheta * sin(phi),\n                    cos(theta), \n                    sinTheta * cos(phi));\n    return dir;\n}\n\n// \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n// https://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// Straight Contrast to 3 Barycentric Weights, oh the pain\n// See: https://www.desmos.com/calculator/n23ntt1nys\nvec3 straightContrast(vec3 weights, float contrast) {\n    // Offset of weights to move towards the center\n    // InverseStraightContrast(0)*(1/3)\n    float offset = (contrast-1.) / (6. * contrast);\n\n    // Merge the offset with the diagonal offsets\n    float offsetA = min(offset, min(weights.y, weights.z) * 0.5);\n    float offsetB = min(offset, min(weights.x, weights.z) * 0.5);\n\n    // Apply the contrast to the merged weights\n    float contrastA = straightContrast(weights.x + offsetA, contrast);\n    float contrastB = straightContrast(weights.y + offsetB, contrast);\n    // No proper calculation needed as sum(weights)=1\n    float contrastC = 1. - contrastA - contrastB; \n        \n    // merge into vector\n    return vec3(contrastA, contrastB, contrastC);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2BD3.jpg", "access": "api", "license": "mit", "functions": [[2360, 2425, 2531, 2531, 3884], [3886, 3951, 4049, 4049, 5417], [5419, 5484, 5578, 5578, 6439], [6441, 6506, 6602, 6602, 7536], [7538, 7671, 7737, 7781, 9217], [9219, 9353, 9421, 9442, 9855], [10017, 10017, 10114, 10145, 12761], [12933, 12933, 13033, 13064, 14739], [14741, 14809, 14912, 14943, 18891], [18893, 18996, 19102, 19133, 21586]], "test": "untested"}
{"id": "ddSfDc", "name": "little animation", "author": "jorge2017a2", "description": "little animation", "tags": ["2d", "bezier", "animation"], "likes": 15, "viewed": 171, "published": 3, "date": "1690208884", "time_retrieved": "2024-07-30T17:42:39.758373", "image_code": "//por jorge flores,p.\n//24-jul-2023\n//little animation\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(1.0),b,d)\n#define PI 3.141516\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nvec3  brazo00_izq(vec2 p ,vec3 col  )\n{\nvec2 pos, med;\nvec2 pr;\nfloat d1, d2,d3,d4,d5;\nfloat dfin, ang;\nvec3 colc;\n \npos=vec2(6.65,1.74);\nmed=vec2(0.15,0.2);\nd1=sdBox(p-pos,med); \n\npos =vec2(6.76,2.21);\nmed =vec2(0.17,0.4);\nang=10.0 * PI / 180.0 ;\npr=Rotate(p - pos ,med,ang);\nd3=sdEllipse(pr,med);\n dfin=unionSDF(d1,d3);\n\n\npos=vec2(6.69,2.05);\nmed=vec2(0.17,0.32);\n \nang=10.0 * PI / 180.0 ;\nmed=vec2(0.17,0.32);\npr=Rotate(p -pos ,med,ang);\nd5=sdEllipse(pr,med);\n \n dfin=unionSDF(dfin,d5);\n col=DrawFigBorde(vec3(1.0 ),col,dfin);\n col=DrawFigBorde(colc,col,abs(dfin)- 0.01);\n return col;\n} \n \nvec3  brazo00_der(vec2 p ,vec3 col)\n{ \n vec2 pos, med;\n float d2,dfin;\n vec3 colc;\n \n pos=vec2(7.83,1.76);\n med=vec2(0.15,0.2);\n d2=sdBox(p - pos,med);\nfloat d6;\npos=vec2(7.81,2.19) ;\nmed=vec2(0.15,0.32) ;\nd6=sdEllipse(p - pos ,med);\n\ndfin=unionSDF(d2,d6 );\n float d7 ;\n    pos=vec2(7.85,2.01);\n    med=vec2(0.15,0.32);\n\n    d7=sdEllipse(p - pos ,med);\n    dfin=unionSDF(dfin,d7);\n \n col=DrawFigBorde(vec3(1.0 ),col,dfin );\n col=DrawFigBorde(colc,col,abs(dfin)- 0.01);\n \n return col;\n} \n \nvec3  Comida00(vec2 p,vec3 col)\n{ \n vec2 pos, med;\n float d1,d2, dfin;\n vec3 colc;\n pos=vec2(7.19,2.46);\n med=vec2(0.5,0.4);\n \n \n    d1=sdEllipse (p - pos,med);\n    // --------- ;\n    pos =vec2(7.19,2.24);\n    med =vec2(0.525,0.2);\n \n d2=sdBox (p-pos,med);\n dfin=unionSDF(d1 ,d2);\n col=DrawFigBorde(vec3(1.0 ),col,dfin);\n col=DrawFigBorde(colc,col,abs(dfin)- 0.01);\n return col;\n} \n \nvec3  cabeza00(vec2 p ,vec3 col)\n{\n vec2 pos, med;\n float d1, d2,d3,d4,d5,d6;\n float r4,r5;\n vec2 p4, p5;\n vec3 colc;\n\n// cabeza ;\npos=vec2(6.74,3.12);\nmed=vec2(0.8,1.05);\nd1=sdEllipse(p - pos,med);\ncol=DrawFigBorde(vec3(1.0),col,d1) ;\n\n// ojo izq ;\npos=vec2(6.8,3.04);\nmed=vec2(0.07,0.14);\nfloat ang ;\nvec2 pr;\nang=10.0 * PI / 180.0 ;\nmed=vec2(0.07,0.14);\npr=Rotate (p- pos,med,ang);\nd2=sdEllipse(pr,med );\ncol=DrawFigBorde (colc,col,abs(d2)-0.01) ;\n\n// ojo derecho ;\npos=vec2(7.26,3.04);\nmed=vec2(0.07,0.13);\nang=10.0 * PI / 180.0;\nmed=vec2(0.07,0.13);\npr=Rotate(p- pos ,med,ang);\nd3=sdEllipse(pr,med);\ncol=DrawFigBorde(colc,col, abs(d3)-0.01);\n\n // -----------Boca ;\npos=vec2(6.9,2.61);\nmed=vec2(0.35,0.05);\nd4=sdBox(p- pos,med);\ncol=DrawFigBorde(colc,col,d4);\n \nreturn col ;\n}\n\n\nvec3 cuerpo(vec2 p, vec3 col)\n{\n//cuerpo\nvec2 pos=vec2(7.05,1.76);\nvec2 med=vec2(1.25,0.64);\nfloat d5=sdEllipse(p-pos,med);\ncol=DrawFigBorde(vec3(0.8 ),col,d5);\nreturn col;\n}\n \nvec3  Cejas(vec2 p,vec3 col)\n{\nvec2 pc1p1, pc1p2,pc1p3;\nvec2 pc2p1, pc2p2,pc2p3;\nvec2 pc3p1,pc3p2,pc3p3;\nvec2 pc4p1,pc4p2,pc4p3;\nvec2 pc5p1,pc5p2,pc5p3;\n \nfloat d1,d2,d3,d4,d5;\nvec3 colc;\n \npc1p1=vec2(6.24,3.49);\npc1p2=vec2(6.37,3.65);\npc1p3=vec2(6.52,3.57);\n\npc2p1=vec2(6.78,3.5);\npc2p2=vec2(6.89,3.64);\npc2p3=vec2(7.0,3.53);\nd1=sdBezier(p,pc1p1,pc1p2,pc1p3);\nd2=sdBezier(p,pc2p1,pc2p2,pc2p3);\ncol=DrawFigBorde(colc,col,d1 ); //ceja izq\ncol=DrawFigBorde(colc,col,d2);//ceja der\nreturn col ;\n}\n\n\n\nvec3  Boca01(vec2 p,vec3 col)\n{\nvec2 pc1p1, pc1p2,pc1p3;\nvec2 pc2p1, pc2p2,pc2p3;\nvec2 pc3p1,pc3p2,pc3p3;\nvec2 pc4p1,pc4p2,pc4p3;\nvec2 pc5p1,pc5p2,pc5p3;\n \nfloat d1,d2,d3,d4,d5;\nvec3 colc;\n \n \npc3p1=vec2(6.58, 2.78); \npc3p2=vec2(6.6, 2.65);\npc3p3=vec2(6.54, 2.56);\n \npc4p1=vec2(6.73, 2.79);\npc4p2=vec2(6.71, 2.66);\npc4p3=vec2(6.8, 2.52 );\n\npc5p1=vec2(6.56,2.66 );\npc5p2=vec2(6.64,2.73 );\npc5p3=vec2(6.72,2.67 );\n \nd3=sdBezier(p,pc3p1,pc3p2,pc3p3);\nd4=sdBezier(p,pc4p1,pc4p2,pc4p3);\nd5=sdBezier(p,pc5p1,pc5p2,pc5p3);\ncol=DrawFigBorde(colc,col,d3);//cachete 1\ncol=DrawFigBorde(colc,col,d4); //cachete 2\ncol=DrawFigBorde(colc,col,d5); //boca\nreturn col ;\n}\n\nvec3  cabeza01 (vec2 p ,vec3 col )\n{\nvec2 pos,med;\nfloat d1, d2, d3;\nvec3 colc=vec3(0.0);\n // cabeza ;\npos=vec2(6.4 ,3.18);\nmed=vec2(0.85,0.95);\nd1=sdEllipse (p-pos, med);\n \n//ojo izq\npos=vec2(6.44,3.23);\nmed=vec2(0.05,0.13);\nd2=sdEllipse (p- pos, med);\n\n// ojo der ;\npos=vec2(6.93,3.28);\nmed=vec2(0.05,0.12);\nd3=sdEllipse(p-pos,med);\n \n col=DrawFigBorde(vec3(1.0) ,col,d1);\n col=DrawFigBorde(colc ,col,abs(d2)- 0.01);\n col=DrawFigBorde(colc ,col,abs(d3)- 0.01);\n \nreturn col;\n}\n\n\nvec3 brazosyComida(vec2 uv, vec3 col )\n{\n col = brazo00_der( uv , col ) ;\n col = Comida00( uv, col ) ;\n col = brazo00_izq( uv , col ) ;\n return col;\n}\n\n\nvec3 cabeza03(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.0);\nvec2 p1=vec2(6.34,3.28);\nvec2 med1=vec2(0.8,1.0);\nfloat d1=sdEllipse(p-p1,med1);\n\n\nvec2 p2=vec2(6.41,3.28);\nvec2 med2=vec2(0.06,0.13);\nfloat d2=sdEllipse(p-p2,med2);\n\n\nvec2 p3=vec2(6.88,3.31);\nvec2 med3=vec2(0.05,0.13);\nfloat d3=sdEllipse(p-p3,med3);\n\ncol=DrawFigBorde(vec3(1.0),col,d1);\ncol=DrawFigBorde(colc ,col,abs(d2)- 0.01);\ncol=DrawFigBorde(colc ,col,abs(d3)- 0.01);\n    return col;\n}\n\n\nvec3 cejasYBoca03(vec2 p,vec3 col)\n{\nvec2 pc1p1=vec2(6.240,3.520);\nvec2 pc1p2=vec2(6.310,3.680);\nvec2 pc1p3=vec2(6.450,3.590);\n\nvec2 pc2p1=vec2(6.760,3.530);\nvec2 pc2p2=vec2(6.820,3.670);\nvec2 pc2p3=vec2(6.980,3.550);\n\nvec2 pc3p1=vec2(6.400,2.960);\nvec2 pc3p2=vec2(6.380,2.790);\nvec2 pc3p3=vec2(6.270,2.730);\n\nvec2 pc4p1=vec2(6.760,2.900);\nvec2 pc4p2=vec2(6.700,2.840);\nvec2 pc4p3=vec2(6.780,2.760);\n\nvec2 pc5p1=vec2(6.410,2.870);\nvec2 pc5p2=vec2(6.560,2.910);\nvec2 pc5p3=vec2(6.740,2.850);\n\n\nfloat d1=sdBezier(p,pc1p1,pc1p2,pc1p3);\nfloat d2=sdBezier(p,pc2p1,pc2p2,pc2p3);\nfloat d3=sdBezier(p,pc3p1,pc3p2,pc3p3);\nfloat d4=sdBezier(p,pc4p1,pc4p2,pc4p3);\nfloat d5=sdBezier(p,pc5p1,pc5p2,pc5p3);\n\ncol=DrawFigBorde(vec3(0.0),col,d1);\ncol=DrawFigBorde(vec3(0.0),col,d2);\ncol=DrawFigBorde(vec3(0.0),col,d3);\ncol=DrawFigBorde(vec3(0.0),col,d4);\ncol=DrawFigBorde(vec3(0.0),col,d5);\nreturn col;\n\n}\n\nvec3 cabeza04(vec2 p, vec3 col)\n{\n//CABEZA\n    vec2 pos=vec2(6.33,3.27);\n    vec2 med=vec2(0.8,1.0);\n    float d1=sdEllipse(p-pos,med);\n    col=DrawFigBorde(vec3(1.0),col,d1);\n    \nvec2 p2=vec2(6.41,3.28);\nvec2 med2=vec2(0.06,0.13);\nfloat d2=sdEllipse(p-p2,med2);\n    col=DrawFigBorde(vec3(1.0),col,abs(d2)-0.01);\n\nvec2 p3=vec2(6.88,3.31);\nvec2 med3=vec2(0.05,0.13);\nfloat d3=sdEllipse(p-p3,med3);\n    col=DrawFigBorde(vec3(1.0),col,abs(d3)-0.01);    \n    return col;\n}\n\nvec3 Boca04(vec2 p, vec3 col)\n{\nvec2 pc3p1=vec2(6.270,2.970);\nvec2 pc3p2=vec2(6.680,2.800);\nvec2 pc3p3=vec2(7.030,3.000);\n\nvec2 pc4p1=vec2(6.430,2.890);\nvec2 pc4p2=vec2(6.660,2.820);\nvec2 pc4p3=vec2(6.910,2.910);\n\nfloat d3=sdBezier(p,pc3p1,pc3p2,pc3p3);\nfloat d4=sdBezier(p,pc4p1,pc4p2,pc4p3);\n\ncol=DrawFigBorde(vec3(0.0),col,d3);\ncol=DrawFigBorde(vec3(0.0),col,d4);\n     return col;\n}\n\nvec3 cejasy04(vec2 p, vec3 col)\n{\nvec2 pc1p1=vec2(6.220,3.530);\nvec2 pc1p2=vec2(6.280,3.720);\nvec2 pc1p3=vec2(6.450,3.600);\n\nvec2 pc2p1=vec2(6.760,3.560);\nvec2 pc2p2=vec2(6.820,3.700);\nvec2 pc2p3=vec2(6.970,3.580);\n\nfloat d1=sdBezier(p,pc1p1,pc1p2,pc1p3);\nfloat d2=sdBezier(p,pc2p1,pc2p2,pc2p3);\n\ncol=DrawFigBorde(vec3(0.0),col,d1);\ncol=DrawFigBorde(vec3(0.0),col,d2);\n     return col;\n}\n\n\n\nvec3 boca05(vec2 p, vec3 col)\n{\nvec2 pos=vec2(6.70,2.72);\nvec2 med=vec2(0.30,0.2);\nfloat d1= sdBox(p-pos, med );\nfloat ang = 9.0 * PI / 180.0;\nvec2 pr = Rotate(p- pos, med/2.0, ang);\nd1 = sdBox(pr, med);\ncol = DrawFigBorde(vec3(0.0), col, d1);\nreturn col;\n}\n\nvec3 rostro(vec2 uv, vec3 col )\n{ \n float fx=fract(iTime*0.2);\n \n if(fx<0.2)\n {\n  col=cuerpo(uv ,col); //bien\n  col = cabeza00(uv,col);\n  col=Cejas(uv-vec2(0.35,-0.1) , col ) ;\n  col=brazosyComida( uv,col);\n    \n }\n else if(fx<0.4)\n  { \n   col=cuerpo(uv ,col) ;\n     col = cabeza01(uv,col); \n     col=Cejas( uv, col) ;\n     col=Boca01( uv, col) ;\n     col=brazosyComida( uv-vec2(0.0,-0.25),col); \n  }\n  else if(fx<0.6)\n  {\n      col=cuerpo(uv ,col); //bien\n      col= cabeza03(uv,col);\n      col=brazosyComida( uv,col);\n      col=cejasYBoca03( uv,col);\n  }\n else if(fx<0.8)\n {\n  col=cuerpo(uv ,col); \n   col=cabeza04(uv,col);\n   col=Boca04(uv,col);\n   col=cejasy04(uv,col);\n   col=brazosyComida( uv,col);\n }\n else \n {\n   col=cuerpo(uv ,col); \n   col=cabeza04(uv,col);\n   col=cejasy04(uv,col);\n   col=boca05(uv,col);\n   col=brazosyComida( uv,col);\n }\n \n return col;\n}\n\nfloat N21(vec2 p)\n{ return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(-3.25,-1.25);\n    uv*=2.0;\n    vec3 col=vec3(0.99,0.81,0.74);\n    col=mix(col, vec3(0.0), N21(uv*0.05));\n    col= rostro(uv,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//iQ\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\n//Quadratic Bezier - exact   (https://www.shadertoy.com/view/MlKcDD)\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 286, 286, 313], [314, 314, 357, 357, 384], [385, 385, 433, 433, 461], [463, 463, 498, 498, 521], [523, 523, 560, 560, 632], [634, 650, 698, 698, 776], [778, 778, 840, 840, 966], [967, 967, 1048, 1048, 1176], [1178, 1178, 1242, 1242, 1313], [1316, 1316, 1355, 1355, 1905], [1909, 1909, 1946, 1946, 2394], [2398, 2398, 2431, 2431, 2778], [2782, 2782, 2816, 2816, 3562], [3565, 3565, 3596, 3605, 3739], [3742, 3742, 3772, 3772, 4235], [4239, 4239, 4270, 4270, 4892], [4894, 4894, 4930, 4930, 5372], [5375, 5375, 5415, 5415, 5525], [5528, 5528, 5561, 5561, 5974], [5977, 5977, 6013, 6013, 6865], [6867, 6867, 6900, 6909, 7336], [7338, 7338, 7369, 7369, 7723], [7725, 7725, 7758, 7758, 8112], [8116, 8116, 8147, 8147, 8373], [8375, 8375, 8408, 8408, 9241], [9243, 9243, 9262, 9262, 9316], [9318, 9318, 9375, 9375, 9648]], "test": "untested"}
{"id": "cdBfD3", "name": "Uniplanar (Dithered)", "author": "gehtsiegarnixan", "description": "Simpler verions of Triplanar mapping using only a single texture lookup, that dithering to hid it's hard edges. ", "tags": ["3d", "triplanar", "sphere", "dither", "mapping", "boxmap", "uniplanar"], "likes": 6, "viewed": 636, "published": 3, "date": "1690199821", "time_retrieved": "2024-07-30T17:42:40.628048", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* This is using dither to make a triplanar mapping variant with one \ntexture sample. So it would be Uniplanar mapping then. \n\nThere is a little bit of flickering in the resulting image, I would \nrecomend using TAA to blend it with past frames which makes this \neffect basically visually the same as the triplanar mapping. \n\nTo see how Dither \"Interpolation\" works see this demo:\nhttps://www.shadertoy.com/view/dsjBzh\n\nSee here for a performance test between Uni, Bi, TriPlanar\nhttps://www.shadertoy.com/view/cs2BD3\n*/\n\n// number of previous frames looked at for AA effect also hides dithering\n#define AA 1\n\n// Enable debug grid where the two mappings blend with each other\n//#define SHOWBLEND\n\n//1 no contrast, higher values increase contrast\n#define Contrast 16.\n\n// valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nfloat ScreenSpaceDither12(vec2 vScreenPos, float time)\n{\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + time); \n    return fract( vDither / 103.0);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\nvec4 uniplanar( sampler2D sam, vec3 normal, vec3 position, vec2 fragCoord, float contrast, int tOffset) {\n    vec2 uvX = position.yz;\n    vec2 uvY = position.zx;\n    vec2 uvZ = position.xy;\n\n    vec3 alpha = abs(normal); // Alpha Mask for blending\n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // sample dither\n    float dither = ScreenSpaceDither12(fragCoord, iTime-float(tOffset));\n    \n    // smooth contrast creates artifacts in the dither. Clamp on the dither removes it\n    dither = clamp(dither, 0.01, 0.99);\n\n    // Mip caculation as the automatic ones don't work\n    vec3 duvwdx = dFdx(position);\n    vec3 duvwdy = dFdy(position);\n    \n    // uvs for derivatives Mips\n    vec2 duvdx; \n    vec2 duvdy;\n\n    // \"interpolate\" the UVs using dither\n    vec2 uv;\n    if (alpha.x > dither) {\n        uv = uvX;\n        duvdx = duvwdx.yz; // how is this thing allowed?\n        duvdy = duvwdy.yz;\n    } else if (1.-alpha.z > dither) {\n        uv = uvY;\n        duvdx = duvwdx.zx;\n        duvdy = duvwdy.zx;\t\n    } else {\n        uv = uvZ;\n        duvdx = duvwdx.xy;\n        duvdy = duvwdy.xy;\n    } \n    \n    // texture sample\n    vec4 col = textureGrad( sam, uv, duvdx, duvdy);\n    \n    #ifdef SHOWBLEND\n    float lineThickness = 0.05; // must be smaller than 0.1\n    vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n    return vec4(max(mask, col.xyz), col.w);\n    #else\n    return col;\n    #endif\n}\n\n// _______________Ray Marching section (copied from iq)________________\n// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 p )\n{\n\tfloat d = length(p-vec3(0.0,1.0,0.0))-1.0;\n    d = smin( d, p.y, 1.0 );\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        int tOffset = m+n;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        int tOffset = 0;\n#endif\n        \n        // camera movement\t        \n        vec3 ro; // camera pos\n        float dist = 2.5;\n        // If the mouse was not clicked, animate;\n        if (iMouse.x > 0.0) {\n            // Scale mouse coords to 0-1 range of screen\n            vec2 mouse = iMouse.xy / iResolution.xy;\n            \n            float dist = 2.0 + mouse.y * 4.0;\n            float angle = mouse.x * 6.283 * 1.25;\n            \n             // Calculate direction clockwise\n            vec2 direction = vec2(sin(angle), cos(angle));\n            ro = vec3(sin(angle)* dist, 2.0, cos(angle)* dist) ;\n        \n        } else {        \n            // Animated \n            float an = 0.2*iTime;\n            ro = vec3( 2.5*sin(an), 2.0, 2.5*cos(an) );\n        }\n        \n        \n        vec3 ta = vec3( 0.0, 1.0, 0.0 ); // camera target\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        float tmax = dist+8.0;\n        float t = dist-2.;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            float h = map(pos);\n            if( h<0.001 ) break;\n            t += h;\n            if( t>tmax ) break;\n        }\n        \n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + rd*t;\n            vec3 nor = calcNormal( pos, 0.001 );\n            float occ = clamp(0.4 + 0.6*nor.y, 0.0, 1.0);\n            col = uniplanar(iChannel0, nor, 0.5*pos, fragCoord, Contrast, tOffset).xyz;\n            col = col*col;\n            col *= occ;\n            col *= 2.0;\n            col *= 1.0-smoothstep(1.0,6.0,length(pos.xz));\n        }\n        // to gamma space\n        col = sqrt( col );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBfD3.jpg", "access": "api", "license": "mit", "functions": [[1846, 2031, 2087, 2087, 2196], [2198, 2341, 2390, 2428, 2584], [2586, 2586, 2691, 2691, 4027], [5180, 5180, 5221, 5221, 5310], [5312, 5312, 5336, 5336, 5425], [5427, 5473, 5519, 5519, 5716]], "test": "untested"}
{"id": "msBBRw", "name": "Flowmap Dither", "author": "gehtsiegarnixan", "description": "Experimental flowmpa using dither to interpolate UVs and skip a texturelookup. ", "tags": ["cheap", "dither", "flow", "interpolation", "flowmap"], "likes": 4, "viewed": 264, "published": 3, "date": "1690199817", "time_retrieved": "2024-07-30T17:42:41.433893", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nExperimental Flowmap using dithering to make a bitmap out of the alpha and interpolate \nthe UVs instead of the textures. This allows us to skip a texture lookup and is a lot \nfaster than the normal 3 texture flowmap.\n\nThis works also for tiling texture breakup, and Directional Flow to save multiple texture \nsamples. For static textures this should be basically unnoticable. \n\nOther dither functions will work too, but keep in mind the dither has the be cheaper \nthan a texture lookup or it defeats the purpuse of the opimization.\n\nModeren screens have an absurd resolution and often use TAA or other temporal effects\nto effectively hide the dithering. If used in volumetric effects the ray marching \nblends the and use a dither in worldspace the results making this method especally \nuseful there. (I tested it in volumetric clouds, using world space dither creates \nnoisy clouds, the hash dither worked the best. Using screens space dither made the \nclouds stylied, which slooks cool but not for my current project)\n*/\n\n// valve edition (slightly modified to be useful as binary dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nfloat ScreenSpaceDither(vec2 vScreenPos)\n{\n\t// Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iTime); \n    return fract( vDither / 71.0) - 0.5;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{    \n    float cenderDistance = length(point); // distance to center    \n    // simple inverted x^2 https://www.desmos.com/calculator/ibidozowyh\n    float donut =  1.0-pow(2.0*(cenderDistance-offset)/spread, 2.0);     \n    donut = clamp(donut, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(-point.y, point.x)); // flow vectors\n    flow *= donut;  // masked by donut\n    //flow = (flow+1.0)/2.0; // generates a flowmap texture\n    //flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// dithered temporal Flowmaps \nvec3 ditherFlowmaps(vec2 uv, vec2 flowUV, vec2 ditherUV, float time, float strength) {\n    // sample flow texture or function\n    vec2 flow = donutFlow(flowUV, 0.7, 0.5);\n    flow *= strength;\n    \n    // time caculatation, one is offset by half\n    float time1 = fract(time);\n    float time2 = fract(time - .5);\n\n    // generate dither pattern\n    float dither = ScreenSpaceDither(ditherUV);\n    \n    // normal alpha flipping between 0-1 using timer 1\n    float alpha = abs((0.5-time1)*2.);\n    \n    // flip  between time 1 and two using the alpha and dither, if is slightly faster than step mix\n    float mixTime = (alpha + dither >= 0.5) ? time2 : time1;\n    \n    // calculate UV values using our dither time offset\n    vec2 mixUV = uv - (mixTime * flow);\n    \n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );\n    \n    // texture sample\n    vec3 tex = textureGrad(iChannel0, mixUV, duvdx, duvdy).xyz;\n    return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime* 0.1; // flow speed multiplier\n    float strength = 0.3; // flow distrotion strength\n    float scale = 1.0;  // scale of the \"wave\" texture\n    \n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords\n    \n    vec3 flow = ditherFlowmaps(uv*scale, uv, fragCoord, time, strength);\n    \n    fragColor = vec4(flow,1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBBRw.jpg", "access": "api", "license": "mit", "functions": [[2106, 2298, 2340, 2430, 2545], [2547, 2618, 2674, 2674, 3201], [3203, 3234, 3320, 3359, 4219], [4221, 4221, 4277, 4277, 4652]], "test": "untested"}
{"id": "mdBfRd", "name": "Texture Tiling Hider Dithered ", "author": "gehtsiegarnixan", "description": "Simpler variant of Directional Flow use to hide the repeating Tiling by rotating cells in random directions that uses only 1 texture sample, a cheap dither, and 1 cheap hash. ", "tags": ["hexagon", "barycentric", "flow", "pattern", "hex", "directional", "dodecahedron", "vectorfield", "stochastic", "direction", "rohmbic", "rhom"], "likes": 4, "viewed": 229, "published": 3, "date": "1690199806", "time_retrieved": "2024-07-30T17:42:42.475109", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a simple variant of the Square Directional Flow. This one simply doesn't move.\nIt is a great way to create a non repeating tiling. It uses dithering to interpolate\nUVs and is there able to only use 1 texture lookup.  \nThis uses 1 cheap hash call, 1 cheap dither, and 1 texture lookup.\n\nDirectional Flow animates and rotates a texture in multiple directions with \na flowmap. This means that water wave textures can flow in multiple directions \nat the same time, while the waves point in the right direction. This is not \npossible with trational flow animation, which either has only one wind \ndirection or stretches the texture with temporal blending. The Directional Flow\ndoes this by blending in the spatial dimension. \n\nThe earliest iteration of directional flow I could find is from 2010:\nhttps://www.rug.nl/society-business/centre-for-information-technology/research/hpcv/publications/watershader/\nBut CatlikeCoding's version is much better explained, so I recommend reading \nit as a guide:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n*/\n\n//#define RepeatTiling\n//#define ShowGrid\n//#define AnimatedDither\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n\treturn vec2(q) * SMALLESTFLOAT;\n}\n\n// \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n// https://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n// valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nfloat ScreenSpaceDither12(vec2 vScreenPos)\n{\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iTime); \n    return fract( vDither / 103.0);\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal \n{\n    vec2 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec2 id;         // ID values\n    float edgeDist;  // Edge distance from the cell's center to its boundaries\n};\n\n// Square tiling function\ntilingVal squareTile(vec2 uv) {\n    vec2 grid = fract(uv) - 0.5;   // the cell coordinates in the grid\n\n    vec2 distanceFromCenter = abs(grid);\n    float edgeDist = (0.5 - max(distanceFromCenter.x, distanceFromCenter.y)) * 2.0;\n\n    vec2 id = uv - grid;  // ID values for the cell\n\n    return tilingVal(grid, id, edgeDist);  // make tilingVal struct\n}\n\n// Rhombus tiling function\ntilingVal rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;    \n    vec2 grid = dot(a,a) < dot(b,b) ? a : b; //UV centered in cell\n    \n    vec2 ma = abs(a);\n    vec2 mb = abs(b);\n    float eDist = (max(ma.x+ma.y,mb.x+mb.y)-0.5)*2.; //Edge Distance\n    \n    // adding tiny offset to prevent floating point errors\n    vec2 id = uv - grid  + 0.0000001; //ID values\n    return tilingVal(grid, id, eDist);  // make tilingVal struct\n}\n\n// rotates and animates texture in flowmap direction \nvec3 directionalTex (vec2 uv, vec2 flowMap, vec2 duvdx, vec2 duvdy) {\n    vec2 direction = normalize(flowMap); // normalize for rotation\n    uv = mat2x2(direction.y, direction.x, -direction.x, direction.y)*uv; // rotate UVs\n    \n    uv += flowMap; // offset\n    \n    // scale UVs so the entire texture is visible in a tile\n    // the proper range is ~1-3 and artists don't read, so this is hard set to\n    uv *= 2.0; \n    \n    return textureGrad(iChannel0, uv, duvdx, duvdy).xyz; // sample texture\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// 3 Grids blending between each other with each tile having a unique rotation and offset\nvec3 squareDirectionalNoiseDither(vec2 uv, float gridRes, float contrast, vec2 fragCoord) {\n    #ifdef RepeatTiling    \n        uv = fract(uv); // repeating UVs is sometimes useful\n        // needs to be a hole number or tiling won't be seamless\n        gridRes = floor(gridRes);\n    #endif    \n    \n    uv *= gridRes; // scalue UVs to gridres\n    \n    tilingVal A = squareTile(uv); // grid A\n    tilingVal B = squareTile(uv + vec2(0.5)); // grid B offset to corner of grid A\n    tilingVal C = rhomTile(uv); // grid C\n    \n    //All edgeDist added = 1 -> so we can skip the more expensive C calculation\n    vec3 alpha = vec3(A.edgeDist, B.edgeDist, 1.-(A.edgeDist + B.edgeDist)); \n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    #ifdef AnimatedDither\n        // smooth contrast creates artifacts in the dither. Clamp on the dither removes it\n        float dither = clamp(ScreenSpaceDither12(fragCoord), 0.01, 0.99);\n    #else\n        // static dither\n        float dither = InterleavedGradientNoise(fragCoord);\n    #endif\n    \n    // add prime number to avoid 0 which hash doesn't like\n    A.id = A.id + 181.;    \n    #ifdef RepeatTiling\n        // mod for repeating at UV=1\n        B.id = mod(B.id, gridRes) + 691.;\n        // also multiply by 2 as hash rounds UVs, adding ti\n        C.id = mod(C.id, gridRes)*2. + 353.);\n    #else\n        B.id = B.id + 691.;\n        C.id = C.id * 2. + 353.;\n    #endif\n\n    // \"interpolate\" the UVs using dither\n    float sumXY = alpha.x + alpha.y;\n    vec2 ditherId;\n    vec2 ditherGrid;\n    if (alpha.x > dither) {\n        ditherId = A.id;\n        ditherGrid = A.grid;\n    } else if (1.-alpha.z > dither) {\n        ditherId = B.id;\n        ditherGrid = B.grid;\n    } else {\n        ditherId = C.id;\n        ditherGrid = C.grid;\n    }\n        \n    // Sample Noise using dithered ID\n    vec2 noise = hash22(ditherId)*2.-1.;\n    \n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );\n    \n    // rotate and offset then sample texture using dithered UVs. \n    // !!! Auto Mips must be disabled, but computed values still work\n    vec3 col = directionalTex(ditherGrid, noise, duvdx, duvdy);\n    \n    #ifdef ShowGrid\n        float lineThickness = 0.05; // must be smaller than 0.1\n        vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n        return max(mask, col);\n    #else\n        return col;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // rectangular UVs\n    vec2 uv = fragCoord/iResolution.y;    \n    // uv *= 2.; // to better see repeating tilings\n    \n    float gridRes = 2.;\n    float contrast = 4.; //1 no contrast, higher values increase contrast\n\n    vec3 col = squareDirectionalNoiseDither(uv, gridRes, contrast, fragCoord);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdBfRd.jpg", "access": "api", "license": "mit", "functions": [[2495, 2495, 2516, 2516, 2617], [2619, 2771, 2814, 2814, 2943], [2945, 3130, 3174, 3174, 3284], [3565, 3591, 3622, 3622, 3943], [3945, 3972, 4001, 4001, 4453], [4455, 4509, 4578, 4578, 5008], [5010, 5153, 5202, 5240, 5396], [7932, 7932, 7989, 8012, 8324]], "test": "untested"}
{"id": "dsjBzh", "name": "Dither UV Interpolation", "author": "gehtsiegarnixan", "description": "This is a novel (I think) method to improve performance by using dither to generate a bitmask and interpolate UVs instead of using UVs on textures and interpolating the textures colors.", "tags": ["noise", "fast", "dither", "performance", "interpolation"], "likes": 1, "viewed": 203, "published": 3, "date": "1690199435", "time_retrieved": "2024-07-30T17:42:43.396645", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a novel technique (I think)* that makes it possible to interpolate UVs.\n\nMany shaders require blending between two or more UV mappings. However, directly \ninterpolating UVs creates noise, so the common approach is to read a texture \nper UV and then interpolate the resulting colors. This can be computationally \nexpensive because texture reads are among the most expensive operations in a \nshader.\n\nTo address this, you can only use one UV at a time and use a bit-mask to switch \nbetween them. Normally, this would create a hard edge between the two UVs. However, \nyou can employ dithering to break up the bit-mask, resulting in an appearance \nthat closely resembles true interpolation. This technique only requires a single \ntexture lookup, which significantly improves performance.\n\nThere are a few limitations to consider. \n- Automatic mipmaps will not work with this approach because the dithered region \n  becomes noise. However, you can use your own computed mipmaps. \n- The speed of the dithering algorithm must be faster than the texture lookups \n  you are trying to save; otherwise, this technique becomes pointless. I recommend \n  conducting a performance test to compare different dithering methods against \n  texture lookups (you can find an example here: \n  https://www.shadertoy.com/view/mdjcDK). \n- This method works best with textures that have low variation, testing is \n  adviced. \n- And lastly as with all screenspace methods higher resolutions improve the \n  smoothness. To me at 4k it becomes hard to tell which is the dithered one, \n  but my fading eyesight might also help. \n\nThis shader shows the simplest version, two sets of UVs get mixed, one is at a\n45 degree angle. However this technique is applicable to any problem involving \nmultiple texture lookups, whether it's linear, barycentric \n(3 values https://www.shadertoy.com/view/DdlBWf), bilinear, GausSSian Blurs, or \nany other interpolation method.\n\n*it is not novel Far Cry 5 did it first\nhttps://www.gdcvault.com/play/1025480/Terrain-Rendering-in-Far-Cry\n*/\n\n// to switch between textures for this demo, normally you would use a normal texturelookup\nvec3 textureSwitcher(int index, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    vec4 color;    \n    // automatic mips don't work and create noise, so use linear instead\n    if (index == 0) {\n        color = textureGrad(iChannel0, uv, duvdx, duvdy);\n    } else if (index == 1) {\n        color = textureGrad(iChannel1, uv, duvdx, duvdy);\n    } else if (index == 2) {\n        color = textureGrad(iChannel2, uv, duvdx, duvdy);\n    } else {\n        color = textureGrad(iChannel3, uv, duvdx, duvdy);\n    }\n    return color.xyz;\n}\n\n// creates Noise, don't do this\nvec3 UVLerp(vec2 uvA, vec2 uvB, float alpha, int texIndex) {\n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uvA );\n    vec2 duvdy = dFdy( uvA );\n\n    vec2 uvLerp = mix(uvA, uvB, alpha);\n    return textureSwitcher(texIndex, uvLerp, duvdx, duvdy);\n}\n\n// hard Edge from switching directly between on or the other\nvec3 BitLerp(vec2 uvA, vec2 uvB, float alpha, int texIndex) {\n    // you could also use if it hardly matters to performance see:\n    // (https://www.shadertoy.com/view/clsGDr)\n    float bitmask = step(0.5, alpha);\n    vec2 uvLerp = mix(uvA, uvB, bitmask);\n     \n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uvA );\n    vec2 duvdy = dFdy( uvA );\n     \n    return textureSwitcher(texIndex, uvLerp, duvdx, duvdy);\n}\n\n// normal beautiful interpolation but with 2 texture lookups\nvec3 TwoTextureLerp(vec2 uvA, vec2 uvB, float alpha, int texIndex) {\n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uvA );\n    vec2 duvdy = dFdy( uvA );\n\n     vec3 texA = textureSwitcher(texIndex, uvA, duvdx, duvdy);\n     vec3 texB = textureSwitcher(texIndex, uvB, duvdx, duvdy);\n     return mix(texA, texB, alpha);\n}\n\n// looks terrible in 2D, but Hashes look best in volumetric\nvec3 hash12CLerp(vec2 uvA, vec2 uvB, float alpha, vec2 fragCoord, int texIndex) {\n     float dither = hash12C(fragCoord);\n     float bitmask = step(1.0, alpha + dither);\n     vec2 uvLerp = mix(uvA, uvB, bitmask);\n     \n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uvA );\n    vec2 duvdy = dFdy( uvA );\n     \n     return textureSwitcher(texIndex, uvLerp, duvdx, duvdy);\n}\n\n// COD Dither produces pretty nice static results\nvec3 InterleavedGradientLerp(vec2 uvA, vec2 uvB, float alpha, vec2 fragCoord, int texIndex) {\n    float dither = InterleavedGradientNoise(fragCoord);\n    float bitmask = step(1.0, alpha + dither);\n    vec2 uvLerp = mix(uvA, uvB, bitmask);\n     \n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uvA );\n    vec2 duvdy = dFdy( uvA );\n     \n    return textureSwitcher(texIndex, uvLerp, duvdx, duvdy);\n}\n\n// Valve Dither very nice animated\nvec3 ScreenSpaceDither12Lerp(vec2 uvA, vec2 uvB, float alpha, vec2 fragCoord, int texIndex) {\n    float dither = ScreenSpaceDither12(fragCoord, iTime);\n    float bitmask = step(1.0, alpha + dither);\n    vec2 uvLerp = mix(uvA, uvB, bitmask);\n     \n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uvA );\n    vec2 duvdy = dFdy( uvA );\n     \n    return textureSwitcher(texIndex, uvLerp, duvdx, duvdy);\n}\n\n// Valve Dither animated blended with past samples\nvec3 MotionBlurSSD12Lerp(vec2 uvA, vec2 uvB, float alpha, vec2 fragCoord, int texIndex) {\n    // This function emulates the look of Temporal Anti-Aliasing (TAA) or motion blur,\n    // which helps to hide the noise pattern. It's not technically TAA or motion blur,\n    // but it can produce a similar visual effect.\n    int numSamples = 8; // like TAA usually\n    vec3 result = vec3(0.);\n    for(int i = 0; i < numSamples; i++) {\n        float dither = ScreenSpaceDither12(fragCoord, iTime - float(i));\n        float bitmask = step(1.0, alpha + dither);\n        vec2 uvLerp = mix(uvA, uvB, bitmask);\n        \n        // Mip calculation as the automatic ones don't work\n        vec2 duvdx = dFdx( uvA );\n        vec2 duvdy = dFdy( uvA );\n        \n        result += textureSwitcher(texIndex, uvLerp, duvdx, duvdy);\n    }    \n    return result / float(numSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    // square UVs\n    vec2 uvA = fragCoord/iResolution.y;\n    // add some movement\n    float movePeriod = 15.; // in seconds for a full cycle\n    uvA += alternatingPattern(iTime, movePeriod) * vec2(0.05, 0.1);\n    \n    // rotate UVs to have two sets of UVs\n    vec2 direction = normalize(vec2(1., -1.));\n    vec2 uvB = mat2x2(direction.y, direction.x, -direction.x, direction.y)*uvA; \n\n    // normalized UV, Alpha.y for spliting up and Alpha.x the interpolation\n    vec2 Alpha = fragCoord / iResolution.xy;\n    // slightly increase contrast of alpha.x\n    Alpha.x = clamp(Alpha.x * 1.5 - 0.25, 0., 1.);\n    \n    // setup breakup of screen\n    float ComparisonCount = 6.; // increase to 6 to see some terrible demos\n    float y = floor(Alpha.y*(ComparisonCount));\n    \n    // switch textures around to see method on different textures\n    float switchPerid = (movePeriod * 4.0); // in seconds\n    int texIndex = int(4.0 * fract(iTime / switchPerid)); //0-4 values\n    \n    // add the texture blending methods\n    if (y == 6.) {\n        // lerping UVs is just broken, disabled by default\n        fragColor.xyz = UVLerp(uvA, uvB, Alpha.x, texIndex); \n    } else if (y == 5.) {\n        // simple bitmask switch\n        fragColor.xyz = BitLerp(uvA, uvB, Alpha.x, texIndex); \n    } else if (y == 4.) {\n        // default 2 texture lookup lerp\n        fragColor.xyz = TwoTextureLerp(uvA, uvB, Alpha.x, texIndex); \n    } else if (y == 3.) {\n        // hash Dither, ugly in 2d, but best in volumetrics\n        fragColor.xyz = hash12CLerp(uvA, uvB, Alpha.x, fragCoord, texIndex); \n    } else if (y == 2.) {\n        // COD Dither (static)\n        fragColor.xyz = InterleavedGradientLerp(uvA, uvB, Alpha.x, fragCoord, texIndex); \n    } else if (y == 1.) {\n        // Valve Dither (animated)\n        fragColor.xyz = ScreenSpaceDither12Lerp(uvA, uvB, Alpha.x, fragCoord, texIndex); \n    } else if (y == 0.) {\n        // Valve Dither (animated) with psuedo motion blur\n        fragColor.xyz = MotionBlurSSD12Lerp(uvA, uvB, Alpha.x, fragCoord, texIndex); \n    }\n\n    // black bars\n    float BorderThickness = 0.04;\n    float ZigzagPattern = abs(fract(Alpha.y*(ComparisonCount))-0.5);\n    fragColor *= vec4(step(ZigzagPattern, 0.5-BorderThickness*0.5)); \n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_____________________________Generic Functions________________________________\n\n// makes a flope stair used for iTime (https://www.desmos.com/calculator/8vh6zysjxv)\nfloat alternatingPattern(float x, float period) {\n    float flipFlop = mod(x, period * 0.5) * mod(floor((2.0 * x) / period), 2.0);\n    float staircase = 0.5 * period * floor(x / period);\n    return flipFlop + staircase;\n}\n\n// Created by David Hoskins. May 2018\n// https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash12C(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n// returns [-intensity;intensity[, magnitude of 2x intensity\n// \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n// https://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST\nfloat InterleavedGradientNoise( vec2 uv ) {\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n// valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nfloat ScreenSpaceDither12(vec2 vScreenPos, float time) {\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + time); \n    return fract( vDither / 103.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjBzh.jpg", "access": "api", "license": "mit", "functions": [[3134, 3225, 3291, 3291, 3739], [3741, 3773, 3833, 3888, 4051], [4053, 4114, 4175, 4289, 4558], [4560, 4621, 4689, 4744, 4969], [4971, 5031, 5112, 5112, 5433], [5435, 5485, 5578, 5578, 5912], [5914, 5949, 6042, 6042, 6378], [6380, 6431, 6520, 6745, 7293], [7295, 7295, 7352, 7373, 9595]], "test": "untested"}
{"id": "cdBBWc", "name": "rgb switch", "author": "Antosser", "description": "rgb", "tags": ["rgb"], "likes": 1, "viewed": 129, "published": 3, "date": "1690195924", "time_retrieved": "2024-07-30T17:42:48.927857", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int color = iFrame % 3;\n    \n    if (color == 0) fragColor = vec4(1, 0, 0, 0);\n    if (color == 1) fragColor = vec4(0, 1, 0, 0);\n    if (color == 2) fragColor = vec4(0, 0, 1, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 242]], "test": "untested"}
{"id": "DdBBW3", "name": "FBM Particle Image Transition", "author": "alphardex", "description": "A particle image transition effect using FBM.", "tags": ["fbm", "transition"], "likes": 1, "viewed": 230, "published": 3, "date": "1690190128", "time_retrieved": "2024-07-30T17:42:50.410891", "image_code": "const float PI=3.14159265359;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x){\n    return mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159-.85373472095314*r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C=vec2(1./6.,1./3.);\n    const vec4 D=vec4(0.,.5,1.,2.);\n    \n    // First corner\n    vec3 i=floor(v+dot(v,C.yyy));\n    vec3 x0=v-i+dot(i,C.xxx);\n    \n    // Other corners\n    vec3 g=step(x0.yzx,x0.xyz);\n    vec3 l=1.-g;\n    vec3 i1=min(g.xyz,l.zxy);\n    vec3 i2=max(g.xyz,l.zxy);\n    \n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1=x0-i1+C.xxx;\n    vec3 x2=x0-i2+C.yyy;// 2.0*C.x = 1/3 = C.y\n    vec3 x3=x0-D.yyy;// -1.0+3.0*C.x = -0.5 = -D.y\n    \n    // Permutations\n    i=mod289(i);\n    vec4 p=permute(permute(permute(\n                i.z+vec4(0.,i1.z,i2.z,1.))\n                +i.y+vec4(0.,i1.y,i2.y,1.))\n                +i.x+vec4(0.,i1.x,i2.x,1.));\n                \n                // Gradients: 7x7 points over a square, mapped onto an octahedron.\n                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n                float n_=.142857142857;// 1.0/7.0\n                vec3 ns=n_*D.wyz-D.xzx;\n                \n                vec4 j=p-49.*floor(p*ns.z*ns.z);//  mod(p,7*7)\n                \n                vec4 x_=floor(j*ns.z);\n                vec4 y_=floor(j-7.*x_);// mod(j,N)\n                \n                vec4 x=x_*ns.x+ns.yyyy;\n                vec4 y=y_*ns.x+ns.yyyy;\n                vec4 h=1.-abs(x)-abs(y);\n                \n                vec4 b0=vec4(x.xy,y.xy);\n                vec4 b1=vec4(x.zw,y.zw);\n                \n                //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n                //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n                vec4 s0=floor(b0)*2.+1.;\n                vec4 s1=floor(b1)*2.+1.;\n                vec4 sh=-step(h,vec4(0.));\n                \n                vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n                vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n                \n                vec3 p0=vec3(a0.xy,h.x);\n                vec3 p1=vec3(a0.zw,h.y);\n                vec3 p2=vec3(a1.xy,h.z);\n                vec3 p3=vec3(a1.zw,h.w);\n                \n                //Normalise gradients\n                vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n                p0*=norm.x;\n                p1*=norm.y;\n                p2*=norm.z;\n                p3*=norm.w;\n                \n                // Mix final noise value\n                vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n                m=m*m;\n                return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),\n                dot(p2,x2),dot(p3,x3)));\n            }\n            \n            float fbm(vec3 p,float progress){\n                float value=0.;\n                float amplitude=1.;\n                float frequency=1.;\n                float lacunarity=2.;\n                float persistance=.5;\n                // float scale=1.;\n                // float scale=600.;\n                float scale=mix(0.,600.,progress);\n                int octaves=10;\n                \n                for(int i=0;i<octaves;i++){\n                    float noiseVal=snoise(p*frequency*scale);\n                    \n                    value+=amplitude*noiseVal;\n                    frequency*=lacunarity;\n                    amplitude*=persistance;\n                }\n                \n                return value;\n            }\n            \n            vec4 getFromColor(vec2 uv){\n                return texture(iChannel0,uv);\n            }\n            \n            float remap(float a,float b,float c,float d,float t)\n            {\n                return clamp((t-a)/(b-a),0.,1.)*(d-c)+c;\n            }\n            \n            vec4 transition(vec2 uv){\n                // float progress=iMouse.x/iResolution.x;\n                float progress=abs(sin(iTime*.5));\n                \n                float ratio=iResolution.x/iResolution.y;\n                \n                vec2 p=uv;\n                p-=.5;\n                p.x*=ratio;\n                float noise=fbm(vec3(p,0.),progress);\n                noise=remap(-1.,1.,0.,1.,noise);\n                float pr=smoothstep(progress-.01,progress,noise);\n                pr*=step(.1,1.-progress);\n                \n                return mix(\n                    getFromColor(uv),\n                    vec4(0.),\n                    pr\n                );\n            }\n            \n            void mainImage(out vec4 fragColor,in vec2 fragCoord){\n                vec2 uv=fragCoord/iResolution.xy;\n                \n                vec4 col=transition(uv);\n                \n                fragColor=col;\n            }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 423, 443, 443, 483], [485, 485, 505, 505, 545], [547, 547, 568, 568, 605], [607, 607, 635, 635, 684], [686, 686, 708, 708, 3300], [3326, 3326, 3359, 3359, 4050], [4076, 4076, 4103, 4103, 4163], [4189, 4189, 4255, 4255, 4326], [4352, 4352, 4377, 4435, 5035], [5061, 5061, 5114, 5114, 5284]], "test": "untested"}
{"id": "ms2fDV", "name": "REALISTIC SUB-PIXEL OLD CRT :::.", "author": "ENDESGA", "description": "CHECK COMMON FOR CONTROLS\n\norder of filters:\n\nBuffer A:\n- chromatic aberration\n- RGB grain\n- vignette\n- rounded corners\n\nBuffer B:\n- 7x4 pixelation\n- hex offset\n- 7x4 sub-pixel RGB mask\n\nImage:\n- bloom\n- barrel-distortion", "tags": ["crt", "aberration", "old", "vignette", "grain"], "likes": 29, "viewed": 1455, "published": 3, "date": "1690188725", "time_retrieved": "2024-07-30T17:42:51.529900", "image_code": "// CC0 :::.\n// Credit (@ENDESGA) and\n// link to this Shadertoy appreciated\n\n// CHECK COMMON FOR CONTROLS\n\nvoid mainImage( out vec4 C, in vec2 F )\n{\n    vec2 uv = (( F.xy / iResolution.xy ) * 2.) - 1.;\n    float r = length( uv );\n    uv /= ( 2. * distortion_amount * r * r );\n    uv = ( ( uv * ( 1. - sqrt( 1. - 4. * distortion_amount * r * r ) ) ) + 1. ) / 2.;\n    float v = min( min( uv.x, 1. - uv.x ), min( uv.y, 1. - uv.y ) ),\n        AA = 0.5 * length( vec2( dFdx( v ), dFdy( v ) ) );\n    vec4 t = mix( vec4( 0. ), texture( iChannel0, uv ), smoothstep( -AA, AA, v ) );\n    // bloom\n    float weight[ 7 ] = float[]( 0.25, 0.5, 1.0, 2.0, 1.0, 0.5, 0.25 );\n    C = vec4(0.);\n    for( int x = -3; x <= 3; ++x )\n        for( int y = -3; y <= 3; ++y )\n            C += weight[ x + 3 ] *\n                weight[ y + 3 ] *\n                texture( iChannel0, uv + vec2( x, y ) * (1.0 / iResolution.xy) );\n    C = mix(texture( iChannel0, uv ), C / 7., bloom_amount * mask_amount)\n        // barrel-distortion mask\n        * smoothstep( -AA, AA, v );\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float hash( vec3 p )\n{\n\tp = fract( p * 0.1031 );\n\tp += dot( p, p.yzx + 19.19 );\n\treturn fract( ( p.x + p.y ) * p.z );\n}\n\nfloat noise( vec3 x )\n{\n\tvec3 p = floor( x ), f = fract( x ), m = f * f * ( 3.0 - 2.0 * f );\n\tvec3 i = p + vec3( 1.0, 0.0, 0.0 );\n\tvec4 hash = vec4( hash( p ), hash( i ), hash( p + vec3( 0.0, 1.0, 0.0 ) ), hash( i + vec3( 0.0, 1.0, 0.0 ) ) );\n\treturn mix( mix( hash.x, hash.y, m.x ), mix( hash.z, hash.w, m.x ), m.y );\n}\n\nfloat grain( vec3 x )\n{\n\treturn 0.5 + ( 4.0 * noise( x ) - noise( x + 1. ) + noise( x - 1. ) ) / 4.0;\n}\n\nvoid mainImage( out vec4 C, in vec2 F )\n{\n\tvec2 uv = F / iResolution.xy,\n        aber_dis = ( uv - vec2( 0.5 ) ) * aberration_amount * length( uv - 0.5 ) * .5;\n\tvec3 aber = vec3(\n            texture( iChannel0, uv ).r,\n            texture( iChannel0, uv - aber_dis ).g,\n            texture( iChannel0, uv - 2.0 * aber_dis ).b\n        );\n\tfloat frame = floor( float( iFrame ) );\n\tvec3 rgb_grain = vec3(\n            grain( vec3( F, frame ) ),\n            grain( vec3( F, frame + 9.0 ) ),\n            grain( vec3( F, frame - 9.0 ) )\n        );\n    float radius = rounded_amount * ((iResolution.x + iResolution.y)*.5) * .5;\n\t//\n    C = vec4(vec3(\n        // aberration + RGB grain\n        mix( aber, mix( aber * rgb_grain, aber + ( rgb_grain - 1.0 ), 0.5 ), noise_amount )\n        // vignette\n        * mix( 1.0, 1.0 - clamp( smoothstep( 0.25, 1.0, length( (uv - vec2( 0.5 )) * vec2( 1.0, iResolution.y / iResolution.x * 2.0 ) ) ), 0.0, 1.0 ), vignette_amount )\n        )\n        // rounded corners\n        * step(length(max(abs(F - iResolution.xy / 2.)-(iResolution.xy / 2.)+radius,0.0))-radius, 0.)\n        ,1.);\n}\n", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define X vec3( 0.0 )\n#define R vec3( 1.0, 0.0, 0.0 )\n#define G vec3( 0.0, 1.0, 0.0 )\n#define B vec3( 0.0, 0.0, 1.0 )\n#define M vec3[ 28 ]( X, X, X, X, X, X, X, X, R, R, G, G, B, B, X, R, R, G, G, B, B, X, R, R, G, G, B, B )\n\nvoid mainImage( out vec4 C, in vec2 F )\n{\n    vec2 uv = floor((F / iResolution.xy) * (iResolution.xy / vec2(7., 4.)));\n    float hex_offset = mod(uv.x, 2.0) * 2.;\n    uv.y += floor(mod(F.y, 4.) / 2.) * hex_offset * .5;\n\n    // 7x4 pixelation\n    C = vec4(0.0);\n    for(float y = 0.0; y < 4.; y++) {\n        for(float x = 0.0; x < 7.; x++) {\n            C += texture(iChannel0, ((uv * vec2(7., 4.)) + vec2(x, y)) / iResolution.xy);\n        }\n    }\n    C = mix(texture(iChannel0,F / iResolution.xy), C/28.,pixelate_amount);\n    \n    C.rgb *= mix(vec3(1.),\n        // 7x4 sub-pixel RGB mask\n        M[int(int(mod(F.y + hex_offset, 4.0)) * 7 + int(mod(F.x, 7.0)))],\n        mask_amount);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define aberration_amount 0.07\n#define noise_amount 0.7\n#define vignette_amount 0.7\n#define rounded_amount 0.07\n\n#define pixelate_amount .7\n#define mask_amount .7\n\n#define bloom_amount .7\n#define distortion_amount 0.07", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2fDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ms2BWV", "name": "FBM Paper Texture", "author": "alphardex", "description": "Using FBM to simulate paper texture.", "tags": ["fbm", "texture"], "likes": 6, "viewed": 238, "published": 3, "date": "1690183693", "time_retrieved": "2024-07-30T17:42:52.552167", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x){\n    return mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159-.85373472095314*r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C=vec2(1./6.,1./3.);\n    const vec4 D=vec4(0.,.5,1.,2.);\n    \n    // First corner\n    vec3 i=floor(v+dot(v,C.yyy));\n    vec3 x0=v-i+dot(i,C.xxx);\n    \n    // Other corners\n    vec3 g=step(x0.yzx,x0.xyz);\n    vec3 l=1.-g;\n    vec3 i1=min(g.xyz,l.zxy);\n    vec3 i2=max(g.xyz,l.zxy);\n    \n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1=x0-i1+C.xxx;\n    vec3 x2=x0-i2+C.yyy;// 2.0*C.x = 1/3 = C.y\n    vec3 x3=x0-D.yyy;// -1.0+3.0*C.x = -0.5 = -D.y\n    \n    // Permutations\n    i=mod289(i);\n    vec4 p=permute(permute(permute(\n                i.z+vec4(0.,i1.z,i2.z,1.))\n                +i.y+vec4(0.,i1.y,i2.y,1.))\n                +i.x+vec4(0.,i1.x,i2.x,1.));\n                \n                // Gradients: 7x7 points over a square, mapped onto an octahedron.\n                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n                float n_=.142857142857;// 1.0/7.0\n                vec3 ns=n_*D.wyz-D.xzx;\n                \n                vec4 j=p-49.*floor(p*ns.z*ns.z);//  mod(p,7*7)\n                \n                vec4 x_=floor(j*ns.z);\n                vec4 y_=floor(j-7.*x_);// mod(j,N)\n                \n                vec4 x=x_*ns.x+ns.yyyy;\n                vec4 y=y_*ns.x+ns.yyyy;\n                vec4 h=1.-abs(x)-abs(y);\n                \n                vec4 b0=vec4(x.xy,y.xy);\n                vec4 b1=vec4(x.zw,y.zw);\n                \n                //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n                //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n                vec4 s0=floor(b0)*2.+1.;\n                vec4 s1=floor(b1)*2.+1.;\n                vec4 sh=-step(h,vec4(0.));\n                \n                vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n                vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n                \n                vec3 p0=vec3(a0.xy,h.x);\n                vec3 p1=vec3(a0.zw,h.y);\n                vec3 p2=vec3(a1.xy,h.z);\n                vec3 p3=vec3(a1.zw,h.w);\n                \n                //Normalise gradients\n                vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n                p0*=norm.x;\n                p1*=norm.y;\n                p2*=norm.z;\n                p3*=norm.w;\n                \n                // Mix final noise value\n                vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n                m=m*m;\n                return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),\n                dot(p2,x2),dot(p3,x3)));\n            }\n            \n            float fbm(vec3 p){\n                float value=0.;\n                float amplitude=1.;\n                // float frequency=1.;\n                float frequency=.025;\n                float lacunarity=2.;\n                float persistance=.5;\n                // float scale=1.;\n                float scale=.5;\n                int octaves=8;\n                \n                for(int i=0;i<octaves;i++){\n                    float noiseVal=snoise(p*frequency*scale);\n                    \n                    value+=amplitude*noiseVal;\n                    frequency*=lacunarity;\n                    amplitude*=persistance;\n                }\n                \n                return value;\n            }\n            \n            // inspired from: https://www.shadertoy.com/view/fsjyR3\n            float paperNoise(vec2 uv){\n                float n1=fbm(vec3(uv.xy+vec2(1.,0.),0.));\n                float n2=fbm(vec3(uv.xy-vec2(1.,0.),0.));\n                float n=n1-n2;\n                return n;\n            }\n            \n            void mainImage(out vec4 fragColor,in vec2 fragCoord){\n                vec2 uv=fragCoord/iResolution.xy;\n                vec3 col=vec3(.8);\n                float noise=paperNoise(uv*iResolution.xy)*.3;\n                col+=noise;\n                fragColor=vec4(col,1.);\n            }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2BWV.jpg", "access": "api", "license": "mit", "functions": [[392, 392, 412, 412, 452], [454, 454, 474, 474, 514], [516, 516, 537, 537, 574], [576, 576, 604, 604, 653], [655, 655, 677, 677, 3269], [3295, 3295, 3313, 3313, 3988], [4014, 4082, 4108, 4108, 4295], [4321, 4321, 4374, 4374, 4603]], "test": "untested"}
{"id": "msSBDV", "name": "hex_morph", "author": "Eindacor_DS", "description": "it's a pattern you dolt!", "tags": ["shader"], "likes": 1, "viewed": 114, "published": 3, "date": "1690154307", "time_retrieved": "2024-07-30T17:42:53.571441", "image_code": "\n\n#define TWOPI 6.28318530718f\n#define AA 0.001f\n#define SIXTY_DEGREES 1.0471975512f\n\n#define u_TimeScaleModifier 0.1f\n#define u_HexRadius .15f\n\nstruct HexData {\n    // value (0 -> 1) representing the uv's value in radial space, origin is (1, 0)\n    float radialVal; \n    \n    // value (0 -> 1) representing approximity to center compared to hex radius\n    float distFromHexCenter;  \n    \n    // center vertex of the hexagon\n    vec2 hexCenter;           \n    \n    // locations of each vertex of the hex\n    vec2[6] hexVertices;      \n    \n    // value (0 -> 1) representing approximity to center compared to hexagon's edge\n    float edgeCoefficient;  \n    \n    // value (0 -> 1) representinglinear interpolation of radians between local triangle vertices\n    float radialLerp;         \n    \n    // value (0 -> 1) representing the sumtotal of each hex vertex's distance to the uv compared\n    //       to the maximum sumtotal distance possible\n    float sumDistCoefficient; \n};\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nvec2 rotateAroundAxis(vec2 point, vec2 axis, float angle) \n{\n    point -= axis;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.y * cos(angle) + point.x * sin(angle);\n    return vec2(x, y) + axis;\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nstruct AspectRatioData {\n    mat2x2 scaleMatrix;\n    mat2x2 inverseScaleMatrix;\n    float aspectRatio;\n};\n\nAspectRatioData getAspectRatioData(vec2 uvSize) {\n    float aspectRatio = uvSize.x / uvSize.y;\n    AspectRatioData aspectRatioData;\n    aspectRatioData.aspectRatio = aspectRatio;\n    aspectRatioData.scaleMatrix = mat2x2(\n        aspectRatio, 0.f,\n        0.f, 1.f\n    );\n    \n    aspectRatioData.inverseScaleMatrix = mat2x2(\n        1.f / aspectRatio, 0.f,\n        0.f, 1.f\n    );\n\n    return aspectRatioData;\n}\n\nbool isHexCenter(vec2 pos, float hexXIncrement, float hexYIncrement) {\n    float columnIndex = round(pos.x / hexXIncrement);\n    float rowIndex = round(pos.y / hexYIncrement);\n    return int(round(mod(abs(columnIndex), 2.f))) == int(round(mod(abs(rowIndex), 2.f)));\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvec3 vec2Tovec3(vec2 vec) {\n    return vec3(vec.x, vec.y, 0.f);\n}\n\nvec2 getHexCenter(vec2 aspectUV, \n                    vec2 leftBottom, \n                    vec2 leftTop, \n                    vec2 rightBottom, \n                    vec2 rightTop,\n                    float aspectHexGridXIncrement, \n                    float hexGridYIncrement,\n                    float aspectHexRadius) {\n    vec2 hexCenter = vec2(-1.f, -1.f); \n\n    if (isHexCenter(leftBottom, aspectHexGridXIncrement, hexGridYIncrement)) {\n        vec2 hexDiagRight = leftBottom + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = leftTop + vec2(aspectHexRadius / 2.f, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagLeft - hexDiagRight));\n        vec2 sharedToRightTopVector = normalize(vec2(rightTop - hexDiagRight));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagRight));\n\n        vec3 crossRightTop = cross(vec2Tovec3(sharedEdgeVector), \n                                    vec2Tovec3(sharedToRightTopVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = (crossRightTop.z == crossUV.z) || \n            (crossRightTop.z < 0.f && crossUV.z < 0.f) || \n            (crossRightTop.z > 0.f && crossUV.z > 0.f) ? rightTop : leftBottom;\n    } else {\n        vec2 hexDiagRight = leftTop + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = rightBottom - vec2(aspectHexRadius, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagRight - hexDiagLeft));\n        vec2 sharedToRightBottomVector = normalize(vec2(rightBottom - hexDiagLeft));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagLeft));\n\n        vec3 crossRightBottom = cross(vec2Tovec3(sharedEdgeVector), \n                                        vec2Tovec3(sharedToRightBottomVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = crossRightBottom.z == crossUV.z || \n            (crossRightBottom.z < 0.f && crossUV.z < 0.f) || \n            (crossRightBottom.z > 0.f && crossUV.z > 0.f) ? rightBottom : leftTop;\n    }\n\n    return hexCenter;\n}\n\nvec2[6] getHexVertices(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = vec2(hexRadius, 0.) * createRotationMatrix(rotationIncrement * 2.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = firstVertex * createRotationMatrix(rotationIncrement * float(i)) + hexCenter;\n    }\n    \n    return hexVertices;\n}\n\nfloat getEdgeCoefficient(vec2 uv, vec2 hexCenter, float hexRadius, float radialVal) {\n    vec2 adjustedUv = uv - hexCenter;\n    float adjustmentRotation = mod(radialVal, TWOPI / 6.);\n    mat2x2 adjsutmentRotationMatrix = createRotationMatrix(adjustmentRotation);\n    adjustedUv = adjustedUv * adjsutmentRotationMatrix;\n    \n    float radialLerp = mod(radialVal, 1./6.) / (1./6.);\n    radialLerp = .5 - (radialLerp > .5 ? 1. - radialLerp : radialLerp);\n    float operativeAngle = radialLerp * TWOPI / 6.;\n    \n    float tangentDistance = cos(TWOPI / 12.) * hexRadius;\n    \n    float maxToEdge = tangentDistance / cos(operativeAngle);\n    return distance(uv, hexCenter) / maxToEdge;\n}\n\nfloat getRadialVal(vec2 hexCenter, vec2 p) {\n    float offsetAngle = getOffsetAngle(hexCenter, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nHexData getHexData(\n    vec2 uv, \n    float hexRadius, \n    float hexGridXIncrement,\n    float hexGridYIncrement) \n{\n    float aspectHexGridXIncrement = hexGridXIncrement;\n\n    float leftEdge = floor(uv.x / aspectHexGridXIncrement) * aspectHexGridXIncrement;\n    float rightEdge = leftEdge + aspectHexGridXIncrement;\n    float bottomEdge = floor(uv.y / hexGridYIncrement) * hexGridYIncrement;\n    float topEdge = bottomEdge + hexGridYIncrement;\n\n    \n    vec2 leftBottom = vec2(leftEdge, bottomEdge);\n    vec2 leftTop = vec2(leftEdge, topEdge);\n    vec2 rightTop = vec2(rightEdge, topEdge);\n    vec2 rightBottom = vec2(rightEdge, bottomEdge);\n\n    float aspectHexRadius = hexRadius;\n    vec2 hexCenter = getHexCenter(uv,\n                            leftBottom, \n                            leftTop, \n                            rightBottom, \n                            rightTop, \n                            aspectHexGridXIncrement, \n                            hexGridYIncrement,\n                            aspectHexRadius);\n    \n    float distMin = 6. * u_HexRadius;\n    float distMax = 4. * u_HexRadius + 4. * cos(SIXTY_DEGREES / 2.) * u_HexRadius;\n    \n    HexData hexData;\n    hexData.radialVal = getRadialVal(hexCenter, uv);\n    hexData.hexCenter = hexCenter;\n    hexData.distFromHexCenter = distance(uv, hexCenter) / hexRadius;\n    hexData.hexVertices = getHexVertices(hexCenter, hexRadius);\n    hexData.edgeCoefficient = getEdgeCoefficient(uv, hexCenter, hexRadius, hexData.radialVal);\n    hexData.radialLerp = mod(hexData.radialVal, 1./6.) / (1./6.);\n     \n    float distTotal = 0.;\n    for (int i=0; i<6; ++i) {\n        distTotal += distance(uv, hexData.hexVertices[i]);\n    }\n    hexData.sumDistCoefficient = (distTotal - distMin) / (distMax - distMin);\n    \n    return hexData;\n}\n\nfloat getVal(HexData hexData, vec2 uv, float timeOffset) {\n    vec2 hexCenter = hexData.hexCenter;\n    float pointRadius = u_HexRadius * .1;\n    \n    float timeVal = (sin((iTime * .5) + timeOffset * TWOPI) + 1.) / 2.;\n    float timeIncrement = 8.;\n    //timeVal = getHoldTransitionValue(0., 1., timeIncrement / 4., timeIncrement / 4., iTime * .25 + (timeIncrement * timeOffset));\n    \n    vec2 farRightPoint = hexData.hexCenter + vec2(u_HexRadius, 0.);\n    float shortSide = cos(TWOPI/12.) * u_HexRadius;\n    vec2 secondPoint = rotateAroundAxis(hexData.hexCenter + vec2(shortSide, 0.), hexData.hexCenter, TWOPI / 12.);\n    vec2 thirdPoint = rotateAroundAxis(hexData.hexCenter + vec2(shortSide, 0.), hexData.hexCenter, TWOPI / -12.);\n    vec2 fourthPoint = farRightPoint - vec2(2. * (farRightPoint.x - secondPoint.x), 0.);\n    vec2 fifthPoint = rotateAroundAxis(fourthPoint, hexData.hexCenter, TWOPI / -6.);\n    vec2 sixthPoint = rotateAroundAxis(farRightPoint, hexData.hexCenter, TWOPI / -6.);\n \n    //float val = circleSmoothStepFill(secondPoint, pointRadius, uv, AA);\n    float val = max(0., circleSmoothStepFill(thirdPoint, pointRadius, uv, AA));\n    val = max(val, circleSmoothStepFill(fourthPoint, pointRadius, uv, AA));\n    val = max(val, circleSmoothStepFill(farRightPoint, pointRadius, uv, AA));\n    val = max(val, circleSmoothStepFill(fifthPoint, pointRadius, uv, AA));\n    val = max(val, circleSmoothStepFill(sixthPoint, pointRadius, uv, AA));\n    val = 0.;\n    \n    vec2 connectionPoint = mix(fourthPoint, farRightPoint, timeVal);\n    vec2 connectionPoint2 = mix(fifthPoint, sixthPoint, timeVal);\n    \n    float lineThickness = pointRadius * .4;\n    val = max(val, lineSegmentSmoothStep(thirdPoint, connectionPoint, uv, lineThickness, AA, true));\n    val = max(val, lineSegmentSmoothStep(thirdPoint, connectionPoint2, uv, lineThickness, AA, true));\n    return val;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    AspectRatioData aspectRatioData = getAspectRatioData(iResolution.xy);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * aspectRatioData.scaleMatrix;\n    \n    uv += vec2(iTime * .05, sin(iTime * .05));\n\n    float hexGridXIncrement = 1.5f * u_HexRadius;\n    float hexGridYIncrement = u_HexRadius * sin(SIXTY_DEGREES);\n    \n    HexData hexData = getHexData(\n        uv, \n        u_HexRadius, \n        hexGridXIncrement,\n        hexGridYIncrement);\n        \n    for (int i=0; i<6; i++) {\n        vec2 hexVertex = hexData.hexVertices[i];\n    }\n   \n    \n    int offset = int(hexData.radialVal * 6.);\n    vec2 originalUV = uv;\n    uv = rotateAroundAxis(uv, hexData.hexCenter, (float(offset) * TWOPI / 6.));\n    \n    float timeOffset = hexData.radialVal;\n    \n    float val = getVal(hexData, uv, timeOffset);\n    float val2 = getVal(hexData, uv, timeOffset * -1.);\n    float val3 = getVal(hexData, uv, 0.);\n    float val4 = getVal(hexData, uv, hexData.radialLerp);\n    \n    vec4 color1 = vec4(vec3(0., 0., mix(.5, 1., val4)), 1.0);\n    \n    float colorMix = getHoldTransitionValue(0., 1., 10., 2., iTime);\n    vec4 color2 = vec4(vec3(val * .8, val2 * .8, .5), 1.0);\n    vec4 color3 = vec4(vec3(0., val2 * .8, .5), 1.0);\n    vec4 color4 = vec4(vec3(val * .8, 0., .5), 1.0);\n    \n    vec4 oscillateColor = mix(color3, color4, colorMix);\n    vec4 oscCombined = mix(color2, oscillateColor, getHoldTransitionValue(0., 1., 5., 1., iTime));\n\n    fragColor = mix(color1, color2, vec4(getHoldTransitionValue(0., 1., 10., 2., iTime)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[979, 979, 1059, 1059, 1148], [1150, 1196, 1216, 1216, 1315], [1317, 1317, 1377, 1377, 1546], [1548, 1548, 1661, 1661, 2295], [2404, 2404, 2453, 2453, 2815], [2817, 2817, 2887, 2887, 3084], [3086, 3086, 3133, 3133, 3397], [3399, 3399, 3444, 3444, 3548], [3550, 3550, 3656, 3656, 4060], [4062, 4062, 4089, 4089, 4127], [4129, 4129, 4451, 4451, 6289], [6693, 6693, 6778, 6778, 7375], [7377, 7377, 7421, 7421, 7580], [7582, 7582, 7698, 7698, 9375], [9377, 9377, 9435, 9435, 11254]], "test": "untested"}
{"id": "ddSBDV", "name": "Automata Lab X (alien scribble)", "author": "misol101", "description": "\"Fullscreen\" version of the showcase shader.\n\nCONTROLS:  down/up=next/prev CA, 1-5=start method, 7-9=speed, m=see automata, v=antialiasing, space=regenerate, h=text\n\nZOOM: Mouse x zooms, w/a/s/d to pan.", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 8, "viewed": 237, "published": 3, "date": "1690154045", "time_retrieved": "2024-07-30T17:42:54.863985", "image_code": "float text(vec2 uv, float ix)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(ix*10.,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv); \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int mono = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    int aa = 1-int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    vec2 ppos = texelFetch(iChannel1, ivec2(10,0), 0 ).xy;\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, ix);    \n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul) + ppos;\n\n    vec4 val = vec4(0.);\n    int am=0, ap=aa, j=0;\n    for (int j = -am; j <= ap; j++)\n        for (int i = -am; i <= ap; i++)\n            val += texelFetch( iChannel0, ivec2(int(fragCoord.x)+i,int(fragCoord.y)+j), 0 );\n    float n=float((am+ap+1));\n    if (am+ap > 0) val /= n*n-2.;\n    \n    if (aa == 0) val/=0.6;\n    \n    if (mono == 0) {\n        fragColor = val;\n    } else {\n        float v=(1./liveval)*val.w;\n        fragColor = vec4( v*0.9, v*0.95, v, 1.0 );\n    }\n\n    fragColor += text_pixel;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nfloat restart(vec2 fragCoord, int method, bool preserve) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=60., h=50.;\n    float xrad=569.,yrad=453.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return randpix(fragCoord);\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return randpix(fragCoord);\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return randpix(fragCoord);\n    }\n    if (method == 3) {\n        if (length(vec2((fragCoord.x-mid.x)*0.793,(fragCoord.y-mid.y)*1.0))< radius)\n            return randpix(fragCoord);\n    }\n    if (method == 4) {\n        float xmul=1.;\n        if (fragCoord.x > mid.x - radius*xmul && fragCoord.x < mid.x + radius*xmul+1. && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius +1.)\n            return randpix(fragCoord);\n    }\n    return preserve? -1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int rows = 2+ int(texelFetch(iChannel2, ivec2(4,0), 0 ).x);\n    \n    float xsq = 3., ysq = float(rows);\n    float wsq = iResolution.x / xsq;\n    float hsq = iResolution.y / ysq;\n    float thick = 3.;\n\n    setRules(int(ix*10.), vec3(0.));\n\n    if (wrap == 0 && (fragCoord.y < 1. || fragCoord.x < 1. || fragCoord.x >= iResolution.x-1. || fragCoord.y >= iResolution.y-1. ) ) {\n        density=0.;  if (density2>=0.) density=density2;\n        fragColor = vec4( 0.0, 0.0, 0.0, 0.);\n        return;\n    }\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_DOWN) || readKey(KEY_UP) || int(xres) != int(iResolution.x) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, setmethod, false));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, method, false));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 4 || nh==5 || nh == 6) {\n        // .XXX. 4\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // .XXX.\n        k =   cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1))\n            + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1));\n        // XXXXX 6\n        // X...X\n        // X.*.X\n        // X...X\n        // XXXXX\n        if (nh > 4) k += cell(px+ivec2(2, 2)) + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, 2)) + cell(px+ivec2(2, -2));\n        // XXXXX 5\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        if (nh < 6)\n            k += cell(px+ivec2(0,-1))\n            + cell(px+ivec2(-1, 0)) + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(0, 1))  + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate;\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x += cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y += cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z += cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\t\n\n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x -= cstep*rm;\n                curr.y -= cstep*gm;\n                curr.z -= cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x -= cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n    }\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAST_PATT = 8.;\nconst float cstep=1./256.;\n\nfloat density=50., density2=-1.;\nfloat liveval = 2.0;\nint newmethod = 0;\nfloat decimate = 0.;\nfloat rp,gp,bp, rm,gm,bm, stayval;\nint colch, staypatt;\nint ra,ga,ba;\nbool clampstay;\nint setmethod;\nint stayset, bornset;\nint nh;\nint wrap;\nfloat radius;\n\nvoid setRules(int index, vec3 col) {\n    int v1, v2;\n    decimate = 1.;liveval=2.;\n\n    rp=4.,gp=3.,bp=10., rm=2.,gm=2.,bm=8., ra=7,ga=7,ba=7,staypatt=1,stayval=1.,colch=0, clampstay=false, setmethod=0; nh=10, wrap=0, density2=-1.; radius=25.;\n\n    // alien scribble\n    if (index == 0) {nh=10; v1 = 4094, v2=3966; density=90., setmethod=2; liveval=5., decimate=0., colch=2, staypatt=0, rp=10., gp=4., bp=4., rm=16., gm=16.,bm=18.,  ra=6,ga=7,ba=6; density2=-1.;radius=2.; }\n\n    // sponge\n    if (index == 1) {nh=5; v1 = 1175456, v2=1910512; setmethod=4, density=70., liveval=6., decimate=1., colch=1, staypatt=0, rp=0.24, gp=0.36, bp=0.15, rm=26., gm=41.,bm=81.,  ra=1,ga=2,ba=4; density2=10.; }\n\n    // baby explosions\n    if (index == 2) {nh=5; v1 = 1175524, v2=1910512; density=20., liveval=6., decimate=1., colch=1, staypatt=0, rp=3., gp=1.5, bp=1.5, rm=6., gm=8.,bm=13.,  ra=1,ga=2,ba=4; }\n\n    // pump\n    if (index == 3) {nh=5; v1 = 1175552, v2=1910552; density=100., liveval=7., decimate=1., colch=3, staypatt=0, rp=11.5, gp=6.5, bp=6.5, rm=6., gm=7.5,bm=13.,  ra=1,ga=3,ba=7;wrap=1; }\n\n    // straight lines\n    if (index == 4) {nh=6; v1 = 50182, v2=16516; density=20., wrap=1, liveval=6., decimate=0., colch=1, staypatt=5, rp=4., gp=4., bp=8., rm=6., gm=16.,bm=18.,  ra=6,ga=7,ba=6; }\n\n    // small worms\n    if (index == 5) {nh=10, v1 = 64860, v2=4094; density=80.; liveval=2.; decimate=0.; colch=2, staypatt=6; rp=9.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; density2=10.; } \n\n    // generative\n    if (index == 6) {nh=0; v1 = 23, v2=86; density=101., setmethod=3; liveval=5., wrap=1; decimate=0., colch=2, staypatt=0, rp=10.*1.3, gp=7.*1.3, bp=20.*1.3, rm=2., gm=2.,bm=2.,  ra=1,ga=2,ba=4; radius=97.; }\n\n    // straight lines II\n    if (index == 7) {nh=-1, v1 = 24, v2=150; density=101.; setmethod=3; wrap=1; liveval=3.; decimate=1.; staypatt=6; rp=5.; rm=8.5,gm=8.5,bm=6.; ra=1,ga=2,ba=4; radius=208.; } \n\n    // square critters\n    if (index == 8) {nh=4, v1 = 1175537, v2=1910520; density=70.; liveval=6.; decimate=1.; colch=1, staypatt=1, rp=10., gp=2.5, bp=1., rm=39., gm=39.,bm=39.,  ra=1,ga=2,ba=4; density2=10.; } \n\n\n    rp=rp+col.x; gp=gp+col.y; bp=bp+col.z;\n    stayset = v1; bornset = v2;\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_H     = 72;\nconst int KEY_M     = 77;\nconst int KEY_S     = 83;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) {\n        fragColor = vec4(0.,0.,0.,1.0);\n        return;\n    }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_RIGHT) || readKey(KEY_DOWN)) {\n                    kx+=0.1;\n                    if (kx > LAST_PATT*0.1+0.05) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=LAST_PATT*0.1+0.05;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_H, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 2.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        vec2 ppos = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xy;\n        float mmul = iMouse.x / iResolution.x;\n        vec2 mid = iResolution.xy / 2.;\n\n        float psp=8.;\n        if( readKey(KEY_D)) ppos.x += psp;\n        if( readKey(KEY_A)) ppos.x -= psp;\n        if( readKey(KEY_S)) ppos.y -= psp;\n        if( readKey(KEY_W)) ppos.y += psp;\n        ppos.x = clamp(ppos.x, -mid.x*mmul, mid.x*mmul);\n        ppos.y = clamp(ppos.y, -mid.y*mmul, mid.y*mmul);\n\n        fragColor = vec4(ppos,0.,1.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 232], [234, 234, 291, 291, 1386]], "test": "untested"}
{"id": "dsBBRm", "name": "XXsFirstShader", "author": "xangadix", "description": "its my first notepad like shader", "tags": ["test"], "likes": 6, "viewed": 150, "published": 3, "date": "1690149533", "time_retrieved": "2024-07-30T17:42:55.768567", "image_code": "float createSun( vec2 uv, vec3 col ) {\n    float d = length( vec2(uv.x-0.8, uv.y-0.6) )*.08;\n    \n    //d = sin(d*8. + iTime)/8.;\n    //d = abs(d);\n    d = pow(0.01 / d, 1.2);\n    \n    return d;\n}\n\nvec3 createLandscape3( vec2 uv, vec3 col )\n{\n    vec3 d = vec3(0.);\n    float wave = ( sin( uv.x + sin( iTime * 0.3  ) * 9. ) * 0.2 ) -0.8;\n    if ( uv.y < wave ) d = vec3(1.);\n    return d;\n}\n\nvec3 createLandscape2( vec2 uv, vec3 col )\n{\n    vec3 d = vec3(0.);\n    float wave = ( sin( uv.x + sin( iTime * 0.3  ) * 6. ) * 0.1 ) -0.3;\n    if ( uv.y < wave ) d = vec3(1.);\n    return d;\n}\n\nvec3 createLandscape_base( vec2 uv, vec3 col )\n{\n    vec3 d = vec3(0.);\n    if ( \n        //uv.x > ((sin(2.)*.05)+0.5)\n        uv.y < ( sin( (uv.x + sin( iTime * 0.3 )) * 2. ) * 0.1 )\n    ) {\n        d = vec3(1.);\n    }\n    \n    //d = ((cos(col*2.)*.05)+0.5);\n    \n    // there is this sin\n    // check if this y is higher or lower then the sign\n    \n    return d;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n\n    // Time varying pixel color\n    vec3 col = ( 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)) ) * 0.3;\n\n    col += createLandscape_base( uv, col ) * 0.2;\n    col += createLandscape2( uv, col ) * 0.2;\n    col += createLandscape3( uv, col ) * 0.2;\n    col += createSun( uv, col );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 196], [198, 198, 242, 242, 390], [392, 392, 436, 436, 584], [586, 586, 634, 634, 952], [957, 957, 1014, 1106, 1524]], "test": "untested"}
{"id": "msSBWV", "name": "Sun, Moon and Sea", "author": "almorgan", "description": "Collection of simple 2d effects. Day-night cycle above a sea on an alien planet.", "tags": ["sun", "repetition", "moon"], "likes": 1, "viewed": 133, "published": 3, "date": "1690141302", "time_retrieved": "2024-07-30T17:42:56.771884", "image_code": "#define PI 3.141592\n\nconst vec3 a = vec3(0.500,  0.400, 0.500);\nconst vec3 b = vec3(3.000,  0.100, 3.000);\nconst vec3 c = vec3(0.500,  1.000, 0.500);\nconst vec3 d = vec3(0.000, -0.500, 0.500);\n\nvec3 palette( float t ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 rotate(vec2 uv, float th)\n{\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nfloat sdfCircle(vec2 uv, float r, vec2 offset)\n{\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n\n    return length(vec2(x, y)) - r;\n}\n\nfloat sdfSun(vec2 uv, vec2 center)\n{\n    float sun = sdfCircle(uv, 0.1, center);\n    return smoothstep(-.01, .01, sun);\n}\n\nfloat sdfMoon(vec2 uv, vec2 center)\n{\n    float d1 = sdfCircle(uv, 0.1, center);\n    float d2 = sdfCircle(\n        uv, 0.09,\n        center + rotate(vec2(0.04, 0.00), atan(center.y/center.x))\n        );\n\n    float res; // result\n    res = max(d1, -d2); // subtraction - subtract d1 from d2\n\n    res = smoothstep(-0.01, 0.01, res); // Same as res > 0. ? 1. : 0.;\n\n    return res;\n}\n\nvec3 getSunglow(vec2 uv, vec2 center)\n{\n    vec3 gradientStartColor = vec3(1., 0., 1.);\n    vec3 gradientEndColor = vec3(0., .7, .7);\n    return mix(\n        gradientStartColor,\n        gradientEndColor,\n        1.2*distance(uv, center));\n}\n\nvec3 getMoonglow(vec2 uv, vec2 center)\n{\n    vec3 gradientStartColor = vec3(.0, .0, .8);\n    vec3 gradientEndColor = vec3(0., .7, .7);\n    return mix(\n        gradientStartColor,\n        gradientEndColor,\n        1.2*distance(uv, center));\n}\n\nfloat sdfSea(vec2 uv)\n{\n    float noise = 0.005*sin(uv.x+.2*iTime)+0.0075*sin(uv.x+0.3*iTime)\n                    + 0.0015*cos(uv.x+.25*iTime)+0.00125*sin(uv.x+0.15*iTime);\n    return smoothstep(-0.01, 0.01, uv.y + .25 + noise);\n}\n\nvec3 drawScene(vec2 uv)\n{\n    float t = .2*iTime-.5;\n    vec2 offsetSun = vec2(-0.5*cos(PI*t), -0.5+0.5*sin(PI*t));\n    vec2 offsetMoon = vec2(-0.5*cos(PI*t+PI), -0.5+0.5*sin(PI*t+PI));\n\n    // gradient background of Sun and Moon\n    vec3 col = getSunglow(uv, offsetSun);\n    // dot operation cuts daynight cycle in half (night<0.0, day>0.0)\n    col = mix(\n        col,\n        getMoonglow(uv, offsetMoon),\n        smoothstep(-1., 1., dot(uv+vec2(0.0, .75), -offsetSun+offsetMoon))\n        );\n\n    // sun\n    float sun = sdfSun(uv, offsetSun);\n    vec3 colorSun = vec3(1.0, 0.2, 0.1);\n    col = mix(colorSun, col, sun);\n\n    // moon\n    float moon = sdfMoon(uv, offsetMoon);\n    vec3 colorMoon = vec3(0.0); // change color\n    col = mix(colorMoon, col, moon);\n\n    float ground = sdfSea(uv);\n    float paletteT = .5 + .2*sin(PI*t+PI);\n\n    \n    col = mix(palette(paletteT), col, ground);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n    \n    \n    vec3 col = drawScene(uv);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 219, 219, 262], [264, 264, 296, 296, 357], [359, 359, 407, 407, 507], [509, 509, 545, 545, 630], [632, 632, 669, 669, 1012], [1014, 1014, 1053, 1053, 1254], [1256, 1256, 1296, 1296, 1497], [1499, 1499, 1522, 1522, 1729], [1731, 1731, 1756, 1756, 2641], [2643, 2643, 2700, 2700, 2940]], "test": "untested"}
{"id": "dsjBDy", "name": "2D Fourier Transform", "author": "beans_please", "description": "(Not so fast) 2D Fourier Transform implemented in glsl\n\n- Enable fft_preview_input in the Common tab to see the input shapes.\n\n- You can also change the FFT resolution in the Common tab.", "tags": ["2d", "fft", "experiment"], "likes": 2, "viewed": 380, "published": 3, "date": "1690140863", "time_retrieved": "2024-07-30T17:42:58.137234", "image_code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: Buffer A\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.5));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Render\n    vec3 col = vec3(0.0);\n    if (max(abs(uv.x), abs(uv.y)) < 1.0)\n    {\n        col = texture(iChannel0, vec2(uv * 0.5 + 0.5) * vec2(fft_res) / iResolution.xy).rgb;\n        \n        vec3 tint = rgb_sweep(iTime * 0.14) + 0.03;\n        tint /= dot(tint, vec3(0.3, 0.59, 0.12));\n        col *= tint;\n    }\n    else\n    {\n        col = vec3(0);\n        //col = vec3(0.005, 0.01, 0.02);\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\nconst ivec2 fft_res = ivec2(185);\nconst bool fft_preview_input = bool(0);\nconst float fft_mul = 50.0 / float(fft_res.x * fft_res.y);\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 0\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 1\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// Just linear mapping\nfloat not_so_smoothstep(float e0, float e1, float x)\n{\n    return clamp((x - e0) / (e1 - e0), 0.0, 1.0);\n}\n\n// 1D slit function\nfloat slit(float x, float center, float half_width, float fade_width)\n{\n    return not_so_smoothstep(-half_width - fade_width, -half_width, x - center)\n        * not_so_smoothstep(half_width + fade_width, half_width, x - center);\n}\n\n// Regular polygon\n// Source: https://www.shadertoy.com/view/tdsXz8\nfloat sd_npoly(float n, float radius, float rotation, vec2 p)\n{\n    n *= .5;\n    float o = PI_OVER_2 / n;\n    float a = atan(p.y / p.x);\n    if(p.x < 0.)\n        a += PI;\n    float s = round((a + rotation) / PI * n) / n * PI - rotation;\n    float d = round((a + o + rotation) / PI * n) / n * PI - o - rotation;\n    vec2 c = vec2(cos(d), sin(d)) * radius;\n    vec2 f = vec2(cos(s), sin(s));\n    float b = length(p - c);\n    float l = dot(p, f);\n    l -= cos(o) * radius;\n    float m = b;\n    if(abs(dot(vec2(p.x, -p.y), f.yx)) <= sin(o) * radius)\n        m = l;\n    return m;\n}\n", "buffer_a_code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: FFT is performed in this buffer.\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nfloat shape0_radius;\nfloat shape1_slit1_half_width;\nfloat shape1_slit2_center;\nfloat shape1_slit2_fade;\nfloat shape1_cutout_radius;\n\nfloat fft_input(vec2 uv)\n{\n    int shape = int(floor(0.34 * iTime)) % 3;\n    if (shape == 0)\n    {\n        // Circle\n        return not_so_smoothstep(shape0_radius, shape0_radius - 0.02, distance(uv, vec2(0.5, 0.5)));\n    }\n    else if (shape == 1)\n    {\n        // Double slit\n        float v = slit(uv.x, 0.44, shape1_slit1_half_width, 0.004);\n        v += slit(uv.x, shape1_slit2_center, 0.02, shape1_slit2_fade);\n        v *= slit(uv.y, 0.5, 0.25, 0.004);\n        float d = distance(uv, vec2(0.5, 0.5));\n        v *= not_so_smoothstep(shape1_cutout_radius, shape1_cutout_radius - 0.01, d);\n        v *= not_so_smoothstep(0.3, 0.01, d) * 0.5 + 0.5;\n        return v;\n    }\n    else if (shape == 2)\n    {\n        // Pentagon\n        return not_so_smoothstep(0.01, 0.0, sd_npoly(5.0, 0.15, iTime * 0.25, uv - 0.5));\n    }\n    return 0.0;\n}\n\n// How much of this frequency is present in fft_input?\nvec2 freq_amount(ivec2 freq)\n{\n    const vec2 uv00 = 0.5 / vec2(fft_res);\n    const vec2 uv_step = 1.0 / vec2(fft_res);\n    vec2 f2 = vec2(freq) * TAU;\n    vec2 v = vec2(0.0);\n    float a = 0.0;\n    for (float y = uv00.y; y < 1.0; y += uv_step.y)\n    {\n        for (float x = uv00.x; x < 1.0; x += uv_step.x)\n        {\n            a = dot(vec2(x, y), f2);\n            v += fft_input(vec2(x, y)) * vec2(cos(a), sin(a));\n        }\n    }\n    return v * fft_mul;\n}\n\n// Simpler but less optimized version of freq_amount()\nvec2 freq_amount_unoptimized_but_simpler(ivec2 freq)\n{\n    // Complex coefficient or something\n    float vcos = 0.0;\n    float vsin = 0.0;\n    \n    // Basically a huge dot product (input . some_wavy_pattern_based_on_freq)\n    // (we treat those \"images\" as very long 1D vectors)\n    for (int y = 0; y < fft_res.y; y++)\n    {\n        for (int x = 0; x < fft_res.x; x++)\n        {\n            vec2 uv = (vec2(float(x), float(y)) + 0.5) / vec2(fft_res);\n            \n            vcos += fft_input(uv) * cos(dot(uv, vec2(freq)) * TAU);\n            vsin += fft_input(uv) * sin(dot(uv, vec2(freq)) * TAU);\n        }\n    }\n    \n    return vec2(vcos, vsin) * fft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < fft_res.x || int(floor(iResolution.y)) < fft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    vec2 uv = (vec2(icoord) + 0.5) / vec2(fft_res);\n    \n    // If outside the region of interest\n    if (icoord.x >= fft_res.x || icoord.y >= fft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Init variables for fft_input\n    float t = TAU * iTime;\n    shape0_radius = 0.16 + 0.07 * cos(t * 0.2);\n    shape1_slit1_half_width = 0.02 + 0.007 * cos(t * 0.2286);\n    shape1_slit2_center = 0.56 + 0.01 * cos(t * 0.4);\n    shape1_slit2_fade = 0.005 + 0.004 * cos(t * 0.3772);\n    shape1_cutout_radius = 0.254 + 0.02 * cos(t * 0.1689);\n    \n    float v = 0.0;\n    if (fft_preview_input)\n    {\n        // Preview FFT input\n        v = fft_input(uv);\n    }\n    else\n    {\n        // What 2D frequency to check\n        ivec2 freq = icoord - (fft_res / 2);\n        \n        // How much of the frequency is present\n        v = length(freq_amount(freq));\n    }\n    \n    // Output\n    frag_col = vec4(v, v, v, 1.0);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 254, 254, 335], [337, 337, 368, 385, 425], [427, 427, 482, 492, 1023]], "test": "untested"}
{"id": "mdSBWV", "name": "Scalar Field Mushroom", "author": "almorgan", "description": "Simple animation utilizing knowledge from scalar field physics. The result is quite pretty, I think :)", "tags": ["colors", "repetition", "scalarfield"], "likes": 5, "viewed": 192, "published": 3, "date": "1690139921", "time_retrieved": "2024-07-30T17:42:59.084701", "image_code": "#define PI 3.141592\n#define EPSILON .004\n\nstruct Source\n{\n    float c; // charge\n    vec2 r;  // position\n};\n\nSource sources[4] = Source[4](\n    Source(1.0, vec2(0.0, -0.1)),\n    Source(-1.0, vec2(0.0, 0.1)),\n    Source(-1.0, vec2(-0.1, 0.0)),\n    Source(-1.0, vec2(0.1, 0.0))\n    );\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(1.0, 1.0, 1.0);\nconst vec3 d = vec3(0.263,0.416,0.557);\n\nvec3 palette( float t ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 rotate(vec2 uv, float th)\n{\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n    \n    vec3 col = vec3(0.0);\n    float force_const = 0.01;\n    float force = 0.0;\n    float t = 0.2*iTime;\n\n    for (int i = 0; i < sources.length(); i++)\n    {\n        sources[i].r = rotate(sources[i].r, 2.0*PI*sin(t));\n\n        vec2 r   = sources[i].r - uv;\n        force += sin(t)*sources[i].c*force_const / (dot(r, r) + EPSILON);\n    }\n\n    col = palette(force);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 434, 459, 459, 502], [504, 504, 536, 536, 597], [599, 599, 656, 656, 1225]], "test": "untested"}
{"id": "ddBBDK", "name": "Avoiding overestimation ", "author": "mrange", "description": "CC0: Avoiding overestimation \nInspired by: https://www.shadertoy.com/view/WtXcWB\n\nWatched blackie's youtube on the estimating the distance field of grid\nwhere each object in the cell is differently sized which typically leads\nto artifacts\n\n", "tags": ["2d"], "likes": 13, "viewed": 330, "published": 3, "date": "1690137271", "time_retrieved": "2024-07-30T17:42:59.845666", "image_code": "// CC0: Avoiding overestimation \n// Inspired by: https://www.shadertoy.com/view/WtXcWB\n\n// Watched blackie's youtube on the estimating the distance field of grid\n// where each object in the cell is differently sized which typically leads\n// to artifacts (or fine tuning of the step size).\n\n// I thought I try adapt the approach to also utilize the ray direction as\n// I figured that it's only in the ray direction we have to make sure not\n// to over estimate\n\n// Like blackie I try to compute the nearest neighbour but with the twist \n// to only consider cells in the ray direction.\n\n// In addition, it turned out that I needed to also consider the cells that \n// touch the corner to not overestimate when I get in the corner near the edges\n\n// My hope is that this also eliminates artifacts as well as being cheap enough\n// to be useful\n\n// I thought it was rather interesting to do so sharing in case some find \n// something useful in the idea.\n\n#define TIME_MULT   0.0\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat pie( in vec2 p, in vec2 c, in float r ) {\n  p.x = abs(p.x);\n  float l = length(p) - r;\n  float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n  return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b ) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nconst float z = 0.2;\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  co += 123.4;\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 g_thing_edge    = vec2(0.0);\nvec2 g_thing_ird    = vec2(0.0);\nvec3 g_thing_step   = vec3(0.0);\nmat2 g_thing_rot    = mat2(1.0);\nvec2 g_ro     = vec2(0.0);\nvec2 g_la     = vec2(0.0);\nmat2 g_pie_rot= mat2(1.0);\n\nfloat dobj(vec2 p, float h) {\n  float w = 0.45*mix(0.1, 1.0, h);\n  //return box(p, vec2(w-0.1))-0.1;\n  return length(p)-w;\n}\n\nfloat drep(vec2 p) {\n  p -= 0.5;\n\n  // Compute the the object in the current cell\n  vec2 c0   = round(p);\n  float h0  = hash(c0);\n  vec2 p0   = p-c0;\n\n  // Let's figure out the which adjacent cell that is the nearest with respect to the ray direction\n  vec2 t1   = (g_thing_edge-p0)*g_thing_ird;\n  vec2 c1   = c0 + (t1.x < t1.y ? g_thing_step.xz : g_thing_step.zy); \n  float h1  = hash(c1);\n  vec2 p1   = p-c1;\n\n  // Also consider the diagonal cell for those cases when we step past the adjacent cell\n  vec2 c2 = c0 + g_thing_step.xy;\n  float h2  = hash(c2);\n  vec2 p2   = p-c2;\n\n  float d0 = dobj(p0, h0);\n  float d1 = dobj(p1, h1);\n  float d2 = dobj(p2, h2);\n  \n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nfloat dthing(vec2 p) {\n  p *= g_thing_rot;\n  float d0 = drep(p/z)*z;\n  float d1 = box(p, vec2(4.0*z));\n  float d = d0;\n  d = max(d, d1);\n  return d;\n}\n\nvec4 df(vec2 p) {\n  const vec2 cone = SCA(PI/4.0);\n  float d0 = dthing(p);\n  float r1 = dthing(g_ro);\n  float d1 = pie(g_pie_rot*(p-g_ro), cone, r1);\n  float d2 = length(p-g_la)-0.1;\n  d2 = abs(d2) - 0.005;\n  float d3 = segment(p, g_ro, g_la)-0.005;\n  vec4 d = vec4(d0, d1, d2, d3);\n  return d;\n}\n\nvec3 effect(vec2 p) {\n  float aa      = 4.0/RESOLUTION.y;\n  float tm      = TIME_MULT*TIME;\n  mat2 rot      = ROT(sin(tm)+tm);\n\n  vec2 rd       = (normalize(g_la-g_ro));\n\n  g_pie_rot     = ROT(PI/2.0)*transpose(mat2(rd.x, rd.y, -rd.y, rd.x));\n  rd *= rot;\n  vec2 srd      = sign(rd);\n\n  g_thing_rot   = rot;\n  g_thing_edge  = srd*vec2(0.5);\n  g_thing_step  = vec3(srd, 0.0)*vec3(1.0, 1.0, 0.0);\n  g_thing_ird   = 1.0/rd;\n\n  vec4 d = df(p);\n  vec3 col = vec3(0.0);\n  const vec3 bcol = vec3(1.0, 0.125, 0.25); \n  vec3 gcol = mix(sqrt(bcol), sqrt(bcol).yzx, 0.5*(sign(-d.x)+1.0));\n  col += gcol*mix(0.125, 1.0, smoothstep(-0.5, 0.5, sin(TAU*d.x/(3.0*aa))))*mix(0.125, 1.0, exp(-20.0*abs(d.x)));\n  col = mix(col, bcol.xxx, smoothstep(0.0, -aa, abs(d.x)-aa));\n  col = mix(col, bcol.yzx, smoothstep(0.0, -aa, d.w));\n  col = mix(col, bcol.zxy, smoothstep(0.0, -aa, d.z));\n  col = mix(col, bcol.xzy, smoothstep(0.0, -aa, d.y));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  float r = RESOLUTION.x/RESOLUTION.y; \n  p.x *= r;\n  g_ro = (-1.0+2.0*iMouse.xy/RESOLUTION.xy)*vec2(r, 1.0);\n  vec3 col = effect(p);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1192, 1310, 1337, 1337, 1413], [1415, 1533, 1580, 1580, 1740], [1742, 1860, 1900, 1900, 2013], [2036, 2096, 2117, 2117, 2202], [2419, 2419, 2448, 2448, 2543], [2545, 2545, 2565, 2565, 3274], [3276, 3276, 3298, 3298, 3426], [3428, 3428, 3445, 3445, 3724], [3726, 3726, 3747, 3747, 4680], [4682, 4682, 4737, 4737, 4964]], "test": "untested"}
{"id": "cdSfDV", "name": "infinite widget", "author": "yasuo", "description": "infinite widget", "tags": ["graphicdesign", "cineshader"], "likes": 24, "viewed": 1553, "published": 3, "date": "1690129968", "time_retrieved": "2024-07-30T17:43:00.963676", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.9;\n    p.y-=size*3.2;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.06;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segDot(vec2 p){\n    vec2 prevP = p;\n    p*=SkewX(-0.4);\n    float size = 0.03;\n    p.y = abs(p.y)-0.07;\n    float d = B(p,vec2(size));\n    return d;\n}\n\nfloat checkChar(int targetChar, int char){\n    return 1.-abs(sign(float(targetChar) - float(char)));\n}\n\nfloat drawFont(vec2 p, int char){\n    p*=SkewX(-0.4);\n    float d = seg0(p)*checkChar(seg_0,char);\n    d += seg1(p)*checkChar(seg_1,char);\n    d += seg2(p)*checkChar(seg_2,char);\n    d += seg3(p)*checkChar(seg_3,char);\n    d += seg4(p)*checkChar(seg_4,char);\n    d += seg5(p)*checkChar(seg_5,char);\n    d += seg6(p)*checkChar(seg_6,char);\n    d += seg7(p)*checkChar(seg_7,char);\n    d += seg8(p)*checkChar(seg_8,char);\n    d += seg9(p)*checkChar(seg_9,char);\n    \n    return d;\n}\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// principal value of logarithm of z\n// https://gist.github.com/ikr7/d31b0ead87c73e6378e6911e85661b93\nvec2 clog (vec2 z) {\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\n// The following code will return the Droste Zoom UV.\n// by roywig https://www.shadertoy.com/view/Ml33R7\nvec2 drosteUV(vec2 p){\n    float speed = 0.25;\n    float animate = mod(iTime*speed,2.07);\n    float rate = sin(iTime*0.5);\n    //p = clog(p)*mat2(1,.11,rate*0.5,1);\n    p = clog(p);\n    p = exp(p.x-animate) * vec2( cos(p.y), sin(p.y));\n    vec2 c = abs(p);\n    vec2 duv = .5+p*exp2(ceil(-log2(max(c.y,c.x))-2.));\n    return duv;\n}\n\n// circle animation\nfloat widgetItem0(vec2 p, float rval){\n    vec2 prevP = p;\n    \n    float d = abs(length(p)-0.12)-0.005;\n    p*=Rot(radians(iTime*60.*rval));\n    d = max((abs(p.y)-0.05),d);\n    float d2 = abs(length(p)-0.12)-0.03;\n    d2 = max(-(abs(p.y)-0.05),d2);\n    d = min(d,abs(d2)-0.005);\n    \n    d2 = abs(length(p)-0.03)-0.005;\n    d = min(d,d2);\n    \n    p.y = abs(p.y)-0.135;\n    d2 = Tri(p,vec3(0.03));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(sin(iTime*0.5)*-100.));\n    p.y = abs(p.y)-0.175;\n    p.y*=-1.;\n    d2 = abs(Tri(p,vec3(0.04)))-0.005;\n    d = min(d,d2);    \n    \n    return d;\n}\n\n// clock animation\nfloat widgetItem1(vec2 p){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(iTime*30.));\n    p = DF(p,8.);\n    p-=0.25;\n    p*=Rot(radians(45.));\n    float d = B(p,vec2(0.005,0.03)); \n    \n    p = prevP;\n    \n    p*=Rot(radians(iTime*30.));\n    p = DF(p,4.);\n    p-=0.27;\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.005,0.05));     \n    \n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p*=Rot(radians(sin(iTime)*180.));\n    p.y = abs(p.y);\n    p.y-=0.28;\n    p.y*=0.07;\n    d2 = Tri(p,vec2(0.05));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = length(p)-0.03;\n    d = min(d,d2);\n    \n    return d;\n}\n\n// digit number animation\nfloat widgetItem2(vec2 p){\n    vec2 prevP = p;\n    p*=1.05;\n    float d = drawFont(p-vec2(-0.35,0.0),int(mod(iTime,9.)));\n    float d2 = drawFont(p-vec2(-0.15,0.0),int(mod(iTime*2.,9.)));\n    d = min(d,d2);\n    d2 = drawFont(p-vec2(0.15,0.0),int(mod(iTime*15.,9.)));\n    d = min(d,d2);\n    d2 = drawFont(p-vec2(0.35,0.0),int(mod(iTime*30.,9.)));\n    d = min(d,d2);\n    d2 = segDot(p);\n    d = min(d,d2);\n    return abs(d)-0.002;\n}\n\n// slider animation\nfloat widgetItem3(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.42,0.002));\n    p.x += sin(iTime)*0.35;\n    d = max(-(length(p)-0.02),d);\n    p = prevP;\n    p.x = abs(p.x)-0.42;\n    float d2 = B(p,vec2(0.002,0.03));\n    d = min(d,d2);\n    p = prevP;\n    p.x += sin(iTime)*0.35;\n    d2 = abs(length(p)-0.02)-0.002;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x-=iTime*0.1;\n    p.x = mod(p.x,0.06)-0.03;\n    d2 = length(p)-0.008;\n    p = prevP;\n    d2 = max((abs(p.x)-0.4),d2);\n    p.x += sin(iTime)*0.35;\n    d2 = max(-(length(p)-0.02),d2);\n    d = min(d,d2);\n    \n    \n    p = prevP;\n    p*=15.;\n    p.x+=iTime*1.5;\n    d2 = sin(p.y*0.6)*0.23+cos(p.x*1.5)*0.2;\n    d2 = abs(d2)-0.005;\n    p = prevP;\n    d2 = max(abs(p.x)-0.4,d2);\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat widgetItem4(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.42,0.002));\n    p.x = abs(p.x)-0.42;\n    float d2 = B(p,vec2(0.002,0.05));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x-=iTime*0.1;\n    p.x = mod(p.x,0.06)-0.03;\n    d2 = B(p,vec2(0.002,0.025));\n    p = prevP;\n    d2 = max((abs(p.x)-0.4),d2);\n    d = min(d,d2);\n    \n    p.x -= sin(iTime*1.1)*-0.35;\n    p.y = abs(p.y)-0.05;\n    p.y*=-1.;\n    d2 = abs(Tri(p,vec2(0.03)))-0.002;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat widgetItem5(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.002,0.42));\n    p.y -= sin(iTime)*0.33;\n    p*=Rot(radians(45.));\n    d = max(-B(p,vec2(0.03)),d);\n    p = prevP;\n    p.y = abs(p.y)-0.42;\n    float d2 = B(p,vec2(0.03,0.002));\n    d = min(d,d2);\n    p = prevP;\n    p.y -= sin(iTime)*0.33;\n    p*=Rot(radians(45.));\n    d2 = abs(B(p,vec2(0.03)))-0.002;\n    d = min(d,d2);\n    return d;\n}\n\nfloat widgetItem6(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.002,0.42));\n    p.y = abs(p.y)-0.42;\n    float d2 = B(p,vec2(0.05,0.002));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=iTime*0.1;\n    p.y = mod(p.y,0.06)-0.03;\n    d2 = B(p,vec2(0.025,0.002));\n    p = prevP;\n    d2 = max((abs(p.y)-0.4),d2);\n    d = min(d,d2);\n    \n    p.y -= sin(iTime*1.1)*-0.35;\n    p.x = abs(p.x)-0.05;\n    p*=Rot(radians(-90.));\n    d2 = abs(Tri(p,vec2(0.03)))-0.002;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat pattern1(vec2 p){\n    float d = abs(B(p-vec2(0.002),vec2(0.5)))-0.004;\n    \n    float d2 = widgetItem1(p);\n    d = min(d,d2);\n    return d;\n}\n\nfloat pattern2(vec2 p){\n    float d = abs(B(p-vec2(0.002,0.002+0.25),vec2(0.5,0.25)))-0.004;\n    float d2 = abs(B(p-vec2(0.002,0.002-0.25),vec2(0.5,0.25)))-0.004;\n    d = min(d,d2);\n        \n    d2 = widgetItem3(p-vec2(0,0.25));\n    d = min(d,d2);\n    d2 = widgetItem4(p-vec2(0,-0.25));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat pattern3(vec2 p){\n    float d = abs(B(p-vec2(0.002+0.25,0.002),vec2(0.25,0.5)))-0.004;\n    float d2 = abs(B(p-vec2(0.002-0.25,0.002),vec2(0.25,0.5)))-0.004;\n    \n    d = min(d,d2);\n    \n    d2 = length(p-vec2(0.25,0.0))-0.2;\n    d2 = widgetItem5(p-vec2(0.25,0.0));\n    d = min(d,d2);\n    d2 = length(p-vec2(-0.25,0.0))-0.2;\n    d2 = widgetItem6(p-vec2(-0.25,0.0));\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat pattern4(vec2 p, float rval){\n    vec2 prevP = p;\n    float d = abs(B(p-vec2(0.002+0.25,0.002+0.25),vec2(0.25)))-0.004;\n    float d2 = abs(B(p-vec2(0.002-0.25,0.002+0.25),vec2(0.25)))-0.004;\n    d = min(d,d2);\n    d2 = abs(B(p-vec2(0.002,0.002-0.25),vec2(0.5,0.25)))-0.004;\n    d = min(d,d2);\n    \n    p.x = abs(p.x);\n    p.x-=0.25;\n    p*= vec2(sign(prevP.x),1);\n    d2 = widgetItem0(p-vec2(0.0,0.25),-rval);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = widgetItem2(p-vec2(0.0,-0.25));\n    d = min(d,d2);  \n    \n    return min(d,d2);\n}\n\nfloat pattern5(vec2 p, float rval){\n    vec2 prevP = p;\n    float d = abs(B(p-vec2(0.002+0.25,0.002-0.25),vec2(0.25)))-0.004;\n    float d2 = abs(B(p-vec2(0.002-0.25,0.002-0.25),vec2(0.25)))-0.004;\n    d = min(d,d2);\n    d2 = abs(B(p-vec2(0.002,0.002+0.25),vec2(0.5,0.25)))-0.004;\n    d = min(d,d2);\n    \n    p.x = abs(p.x);\n    p.x-=0.25;\n    p*= vec2(sign(prevP.x),1);\n    d2 = widgetItem0(p-vec2(0.0,-0.25),-rval);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = widgetItem2(p-vec2(0.0,0.25));\n    d = min(d,d2);  \n    \n    return min(d,d2);\n}\n\nvec3 draw(vec2 p, vec3 col, float size){\n    vec2 prevP = p;\n    \n    p*=size;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    float n = random(id);\n    \n    if(n<0.2){\n        float d = pattern1(gr);\n        col = mix(col, vec3(1.), S(d,0.0));\n    } else if(n>=0.2 && n<0.35){\n        float d = pattern2(gr);\n        col = mix(col, vec3(1.), S(d,0.0));\n    } else if(n>=0.35 && n<0.5){\n        float d = pattern3(gr);\n        col = mix(col, vec3(1.), S(d,0.0));\n    } else if(n>=0.5 && n<0.75){\n        float d = pattern4(gr,n);\n        col = mix(col, vec3(1.), S(d,0.0));\n    } else {\n        float d = pattern5(gr,n);\n        col = mix(col, vec3(1.), S(d,0.0));\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    \n    p = drosteUV(p);\n    //p.y-=iTime*0.1;\n    vec3 col = vec3(0.);\n    col =draw(p,col,4.);\n    p = prevP;\n    col*=B(p,vec2(0.1));\n \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[646, 646, 668, 668, 993], [995, 995, 1014, 1014, 1164], [1166, 1166, 1185, 1185, 1496], [1498, 1498, 1517, 1517, 1805], [1807, 1807, 1826, 1826, 2121], [2123, 2123, 2142, 2142, 2430], [2432, 2432, 2451, 2451, 2739], [2741, 2741, 2760, 2760, 3030], [3032, 3032, 3051, 3051, 3234], [3237, 3237, 3256, 3256, 3442], [3444, 3444, 3463, 3463, 3733], [3735, 3735, 3756, 3756, 3891], [3893, 3893, 3935, 3935, 3995], [3997, 3997, 4030, 4030, 4476], [4478, 4478, 4501, 4501, 4574], [4576, 4678, 4698, 4698, 4746], [4748, 4853, 4875, 4875, 5183], [5185, 5205, 5243, 5243, 5808], [5810, 5829, 5855, 5855, 6433], [6435, 6461, 6487, 6487, 6891], [6893, 6913, 6939, 6939, 7723], [7725, 7725, 7751, 7751, 8216], [8218, 8218, 8244, 8244, 8626], [8628, 8628, 8654, 8654, 9132], [9134, 9134, 9157, 9157, 9281], [9283, 9283, 9306, 9306, 9609], [9611, 9611, 9634, 9634, 10025], [10027, 10027, 10062, 10062, 10572], [10574, 10574, 10609, 10609, 11119], [11121, 11121, 11161, 11161, 11822], [11824, 11824, 11881, 11881, 12139]], "test": "untested"}
{"id": "cdSBWV", "name": "Floating Ghost 2", "author": "bronson113", "description": "floating ghost, now transparent!", "tags": ["raymarching", "ghost", "phantommode"], "likes": 2, "viewed": 284, "published": 3, "date": "1690127167", "time_retrieved": "2024-07-30T17:43:01.721650", "image_code": "#define C(x) clamp(x, 0.0, 1.0)\n\n// To control the scean with a mouse, change the 0 to 1\n#define MOUSE 1\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \nvec2 opUnion(vec2 a, vec2 b){\n    return (a.x<b.x)?a:b;\n}\n// SDF of line segment -> capsul\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Droplet -> line segment, but one side with r = 0 and anthoer side with r = r\nfloat sdDroplet( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r*h;\n}\n\n// Mouth shape\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w )\n{\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}\n\nvec2 DistGhost(vec3 location, float time){\n    float k = .01; //roundness\n    vec2 res;\n    \n    // body\n    float radial_change = cos(atan(location.x/location.z)*20.+time*10.+cos(location.y*3.+1.7)*10.);\n    float to_ground = exp(-(location.y+0.5)*10.);\n    float r = (0.48)+.02*(radial_change)*C(to_ground)+0.05*to_ground;\n    float dBody = sdCapsule(location, vec3(0., .5, 0.), vec3(0., -.5, 0.), r);\n\n    // eye hole\n    float dEyeH1 = sdCapsule(location, vec3(0.45, .45, 0.2), vec3(0.45, 0.2, 0.2), 0.05);\n    float dEyeH2 = sdCapsule(location, vec3(0.45, .45, -0.2), vec3(0.45, 0.2, -0.2), 0.05);\n    dBody = max(dBody, -dEyeH1);\n    dBody = max(dBody, -dEyeH2);\n    \n    //mouth hole\n    float dMouthHole = sdVesicaSegment(location, vec3(0.47, -.13, 0.13), vec3(0.47, -.13, -0.13), 0.02);\n    dBody = opSmoothSubtraction(dBody, dMouthHole, k);\n    \n    // float\n    float dFloat = location.y + 0.45 + 0.01*sin(radial_change);\n    dBody = max(dBody, -dFloat);\n    res = vec2(dBody, 1.0);\n    \n    \n    // eye\n    float dEye1 = sdCapsule(location, vec3(0.41, .45, 0.19), vec3(0.41, 0.19, 0.19), 0.04);\n    float dEye2 = sdCapsule(location, vec3(0.41, .45, -0.19), vec3(0.41, 0.19, -0.19), 0.04);\n    float dEye = min(dEye1, dEye2);\n    res = opUnion(res, vec2(dEye, 2.0));\n    \n    // mouth\n    float dMouthL = sdVesicaSegment(location, vec3(0.42, -.13, -0.15), vec3(0.44, -.13, 0.05), 0.05);\n    //float dMouthR = sdVesicaSegment(location, vec3(0.44, -.13, -0.03), vec3(0.42, -.13, 0.15), 0.05);\n    res = opUnion(res, vec2(dMouthL, 3.0));\n    //res = opUnion(res, vec2(dMouthR, 3.0));\n    \n    // water droplet\n    float dDrop = sdDroplet(location, vec3(0.45, -.115, -0.1), vec3(0.465, -.2, -0.1), 0.02);\n    res = opUnion(res, vec2(dDrop, 4.0));\n    \n    \n    \n    return res;\n}\n\nvec2 hash( in vec2 x )   // this hash is not production ready, please\n{                        // replace this by something better\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat valueNoise (in vec2 p) {\n    vec2 st = p + vec2(iTime*2., 0.);\n    st *= 0.2;\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    vec2 a = hash(i);\n    vec2 b = hash(i + vec2(1.0, 0.0));\n    vec2 c = hash(i + vec2(0.0, 1.0));\n    vec2 d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // some curve\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    float va = dot( a, f - vec2(0.0,0.0) );\n    float vb = dot( b, f - vec2(1.0,0.0) );\n    float vc = dot( c, f - vec2(0.0,1.0) );\n    float vd = dot( d, f - vec2(1.0,1.0) );\n\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd);  // value\n\n}\n\nvec2 Dist(vec3 location, float time){    \n    float offset = pow(abs(sin(time*.6)), 2.)*3.-6.;\n    vec2 dGhost = DistGhost(location + vec3(0., offset, 0.)*.1, time);\n    \n    float dFloor = location.y + 0.2 + valueNoise(location.xz)*0.2*length(location.xz);\n    vec2 res = opUnion(dGhost, vec2(dFloor, 0.0));\n    \n    return res;\n}\n\n// get the gradiant of the distant -> normal vector of that \"surface\"\nvec3 Norm(vec3 location, float time){\n/* small step in all direction as our Normal\n    vec2 diff = vec2(0.0005, 0);\n    return normalize( vec3( Dist(location + diff.xyy, time) - Dist(location - diff.xyy, time), \n                            Dist(location + diff.yxy, time) - Dist(location - diff.yxy, time),\n                            Dist(location + diff.yyx, time) - Dist(location - diff.yyx, time)));\n*/\n// https://iquilezles.org/articles/normalsSDF/\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Dist(location+0.0005*e,time).x;\n    }\n    return normalize(n);    \n}\nfloat RayMarching(vec3 ro, vec3 rd, float time){\n    // distant traveled\n    float t = 0.; \n    float maxt = 20.;\n    // ray marching\n    for(float i=0.; i<75. && t < maxt; i+=1.){\n        // currect location\n        vec3 loc = ro + t*rd;\n        // distant to surface\n        float d = Dist(loc, time).x;\n        \n        // we hit a surface\n        if(d <= 0.0) break;\n        \n        // otherwise march forward, minimum march distance: 0.02\n        t += max(d, 0.0002);\n    }\n    // max distant: 20, return -1 if didn't hit\n    return t>maxt?-1.:t;\n}\n\nvec3 renderLoc(vec3 ro, vec3 rd, float t, float time){\n    vec3 col = vec3(0.);\n    // if we hit something with 20 unit\n    if(t > 0.){\n        // point we hit\n        vec3 loc = ro + rd*t;\n        // normal of that surface\n        vec3 nor = Norm(loc, time);\n        \n        vec2 res = Dist(loc, time);\n        // object color\n        col = vec3(0.0);\n        if(res.y < 0.5){\n            col = vec3(0.005, .005, 0.22) * (1.-valueNoise(loc.xz));\n        } else if (res.y < 1.5){\n            col = vec3(0.3);\n        } else if (res.y < 2.5){\n            col = vec3(0.01);\n        } else if (res.y < 3.5){\n            col = vec3(.247, .086, .049);\n        } else if (res.y < 4.5){\n            col = vec3(.124, .202, .235);\n        }\n        \n        vec3 lightin = vec3(0.);\n        // moon at 10. 10. -5.\n        vec3 moon_loc = vec3(10., 10., -5.);\n        vec3 moon_dir = normalize(moon_loc-loc);\n        float moon_diffuse = C(dot(moon_dir, nor));\n        \n        //shadow\n        float can_see_moon = step(RayMarching(loc+0.001*moon_dir, moon_dir, time), 0.);\n        \n        // sky\n        float sky_diffuse = C(dot(normalize(vec3(0., 1., 0.)), nor));\n        float sky_diffuse2 = C(dot(normalize(vec3(0., 1., 1.)), nor));\n        \n        // general bounced light\n        float bounced = C(dot(normalize(vec3(0., -1., 0.)), nor));\n        \n        \n        lightin += vec3(5., 5., 4.) * moon_diffuse * can_see_moon;\n        lightin += vec3(0.2, 0.1, .5) * sky_diffuse;\n        lightin += vec3(0.1, 0.15, .25) * sky_diffuse2;\n        lightin += vec3(0.6, 0.4, 0.2) * bounced;\n        col *= lightin;\n        col = mix( col, vec3(0.7,0.4,0.3), 1.0-exp( -0.0001*pow(t, 3.) ) );\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float time = iTime;\n\n\n   // camera\t\n\n#if MOUSE==1\n    float an = 10.57*iMouse.x/iResolution.x;\n    float bn = iMouse.y/iResolution.y*1.57;\n    vec3  ta = vec3( 0.0, 0.5, 0.0);                         // pointing at\n    float zoom = 1.5;\n    vec3  ro = ta + zoom*vec3( 1.3*cos(an), sin(bn)*2.-0.5, 1.3*sin(an) ); // camera location\n#else\n    float an = time*.392;\n    vec3  ta = vec3(0.0, 0.5, 0.0);                         // pointing at\n    float zoom = sin(time*.234)*0.5+2.;\n    vec3  ro = ta + zoom*vec3( 1.3*cos(an), sin(an*0.3)*0.4+0.2, 1.3*sin(an) ); // camera location\n#endif \n    // frame\n\tvec3 cw = normalize(ta-ro);    // vector pointing toward target\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) ); // vector pointing up\n\tvec3 cv =          ( cross(cu,cw) ); // vector pointing right\n\n    vec3 rd = normalize( p.x*cu + p.y*cv + 1.8*cw ); // actual ray direction from frame\n    \n    \n    // distant to surface\n    // sky\n    vec3 col = vec3(0.);\n    float phantom = 10.;\n    for(float i=0.; i<phantom; i+=1.){\n        float t = RayMarching(ro, rd, time);\n        if(t < 0.){\n            col += (vec3(0.1, 0.05, 0.03) - max(rd.y,0.0)*0.6) * (1. - i/phantom/2.);\n            break;\n        }\n        if(Dist(ro+rd*t, time).y < 0.5){\n            col += renderLoc(ro, rd, t, time)*(1. - i/phantom/2.);\n            break;\n        }\n        col += renderLoc(ro, rd, t, time)*(6./phantom/2.);\n        ro = ro+rd*(t+0.15);\n    }\n    \n    \n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 157, 209, 209, 308], [310, 310, 368, 368, 468], [470, 470, 529, 529, 628], [634, 634, 663, 663, 691], [692, 725, 777, 777, 898], [900, 980, 1032, 1032, 1155], [1157, 1172, 1242, 1242, 1551], [1553, 1553, 1595, 1595, 3339], [3341, 3341, 3412, 3471, 3609], [3611, 3698, 3728, 3728, 4357], [4359, 4359, 4396, 4396, 4690], [4692, 4762, 4799, 5215, 5443], [5444, 5444, 5492, 5516, 5998], [6000, 6000, 6054, 6054, 7707], [7709, 7709, 7766, 7766, 9388]], "test": "untested"}
{"id": "DsSBWy", "name": "Huge 3D Automata", "author": "misol101", "description": "Pixel packed states to reach max size pow(xres*yres*24,1/3), e.g 205^3 for a 800x450 buffer (!). Speed obviously suffers with larger size.\n\nCONTROLS: up/down=prev/next CA, b=box, 7-9=speed, c=color method, v=view, p=pause, space=regen, w/s=zoom,  t=text\n", "tags": ["3d", "interactive", "voxel", "automata"], "likes": 16, "viewed": 300, "published": 3, "date": "1690119133", "time_retrieved": "2024-07-30T17:43:02.887534", "image_code": "\n// Increase SIZE in Common if your GPU can handle it!\n\n// Press UP/DOWN for variants.\n\n// More keys: b=box, 7-9=speed, c=color, v=view, p=pause, space=regen, w/s=zoom\n\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nint bbox;\nbool inverted;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n /= CPP;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n\n    vec4 outv = texelFetch(iChannel0, p2, 0 );\n\n    int val = int(outv[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    \n    return float(val);\n}\n\nbool map(in vec3 p, out float v) \n{\n    p+=5.; // 0 == -5\n\n    if (bbox == 1) {\n        int NM=int(N)-1;\n        int x=int(p.x),y=int(p.y),z=int(p.z);\n        if ((x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n            v=-1.;\n            return true;\n        }\n    }\n\n    float cv = cellval(ivec3(p));\n\n    if(colmethod == 1) {\n        v=cv*0.12; // col by state value\n    } else\n        v=length(p-N/2.)*0.1+1.5; // col by distance\n\n    return !inverted ? cv > 1. : int(cv) == 1;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 32.; ++i) {\n        if (map(ep, v)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-3., xrot=-0.66;\n    if (view == 1) yp=0., xrot=0.0;\n    if (view == 2) yp=0., xrot=1.;\n\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, yp, -d+zmod);\n\n    float mxc, myc;\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.33))*1.17;\n        myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    colmethod = int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n    bbox = int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n    inverted = getInverted(int(index));\n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*1.37, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec3 color = vec3(0.03, 0.03, 0.03);\n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n \n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    \n    fragColor += text_pixel;    \n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Persistive Keyboard Input buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); return; }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=1.001;\n                    if (kx > LAST_PATT+0.5) kx=0.5;\n                } else {\n                    kx-=1.001;\n                    if (kx < 0.) kx=LAST_PATT+0.5;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = -1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 3.);\n        return;\n    }\n\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Automata buffer, pixel packed with 4 bits per state and max 8 digits per component for 6*4=24 cells per pixel \n\nint N;\n\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\nconst int KEY_D  = 68;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val == int(liveval) ? 1 : 0;\n}\n\nint cellwrap( in ivec3 p, int xp,int yp, int zp) {\n    int x=p.x+xp, y=p.y+yp, z=p.z+zp;\n    if (x==0) x=N-2;  if (x==N-1) x=1;\n    if (y==0) y=N-2;  if (y==N-1) y=1;\n    if (z==0) z=N-2;  if (z==N-1) z=1;\n    int n=x+y*N+z*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val == int(liveval) ? 1 : 0;\n}\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val;\n}\n\nvec4 cv4( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    return texelFetch(iChannel0, p2, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    pos1d *= CPP;\n    if (pos1d > N*N*N) { fragColor = vec4(0.); return; }\n    fragCoord.x = float(pos1d % int(iResolution.x));\n    fragCoord.y = float(pos1d / int(iResolution.x));\n\n    int index = int(texelFetch(iChannel1, ivec2(0,0), 0 ).x);\n    float xres = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    int speed = 1+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n\n    setRules(index);\n    if (readKey(KEY_D) && withermethod >= 0) { setRules(withermethod); } //wither\n\n    ivec4 fst=ivec4(0);\n\n    bool regen = iFrame < 1 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x);\n\n    speed += speedplus;\n    if (!regen && (iFrame % (speed+1) > 0 || pause == 1)) {\n        fragColor = cv4(ivec3(x,y,z),0,0,0);\n        return;\n    }\n\n    for (int i=0; i<CPP; i++) {\n        int fi=i/6;\n        int xi=x+i,yi=y,zi=z;\n        if (xi >= N) {xi-=N; yi++; if (yi >= N) {yi=0; zi++;}}\n        ivec3 pos3d=ivec3(xi,yi,zi);\n\n        int NM=N-1;\n        if (xi==0 || yi==0 || zi==0 || xi==NM || yi==NM || zi==NM) { \n            fst[fi] = fst[fi]<<4;\n            continue;\n        }\n\n        if (regen) {\n            pos3d-=N/2;\n\n            if (hash1(fragCoord.x*0.03*fragCoord.y*0.021+iTime*0.04) < density) {\n                if (clearmethod == 0) {\n                    if (length(vec3(pos3d))<radius) {\n                        fst[fi] = (fst[fi] << 4) | int(liveval);\n                        continue;\n                    }\n                } else if (clearmethod == 1) {\n                    int iradius=int(radius);\n                    if (abs(pos3d.x)<iradius && abs(pos3d.y)<iradius && abs(pos3d.z)<iradius) {\n                        fst[fi] = (fst[fi] << 4) | int(liveval);\n                        continue;\n                    }\n                } else {\n                    fst[fi] = (fst[fi] << 4) | int(liveval);\n                    continue;\n                }\n            }\n            fst[fi] = (fst[fi] << 4);\n            continue;\n        }\n\n        int st = cellval(pos3d,0,0,0);\n\n        int count = 0;\n        if (countmethod == 0) {\n            // Mooore\n            if (wrap == 1) {\n                for (int i=-1; i<=1; i++)\n                    for (int j=-1; j<=1; j++)\n                        for (int k=-1; k<=1; k++)\n                            if((i|j|k)!=0)\n                                count += cellwrap(pos3d,i,j,k);\n            } else {\n                for (int i=-1; i<=1; i++)\n                    for (int j=-1; j<=1; j++)\n                        for (int k=-1; k<=1; k++)\n                            if((i|j|k)!=0)\n                                count += cell(pos3d,i,j,k);\n            }\n        } else {\n            // Neumann \n            if (wrap == 1) {\n                count = cellwrap(pos3d,0,-1,0) + cellwrap(pos3d,0,1,0) + cellwrap(pos3d,-1,0,0) + cellwrap(pos3d,1,0,0) + cellwrap(pos3d,0,0,-1) + cellwrap(pos3d,0,0,1);\n            } else {\n                count = cell(pos3d,0,-1,0) + cell(pos3d,0,1,0) + cell(pos3d,-1,0,0) + cell(pos3d,1,0,0) + cell(pos3d,0,0,-1) + cell(pos3d,0,0,1);\n            }\n        }\n\n        if(st <= 1) {\n            if (((1<<count) & bornset) > 0)\n                st = int(liveval);\n        }\n        else {\n            if (((1<<count) & liveset) == 0)\n                st--;\n        }\n\n        fst[fi] = (fst[fi] << 4) | st;\n\n        fragCoord.x+=1.;\n        if(fragCoord.x >= iResolution.y) { fragCoord.y+=1.; fragCoord.x=0.; }\n    }\n\n    fragColor = vec4(fst);\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 125.\n\nconst int CPP = 24; // Cells Per Pixel (only 6,12,18,24 will work)\n\n#define HORIZON\n\nconst float LAST_PATT = 23.01;\n\nint liveset, bornset, clearmethod, countmethod, withermethod;\nfloat liveval;\nfloat radius;\nfloat density;\nint speedplus, wrap;\n\nvoid setRules(int index) {\n    int v1, v2;\n    countmethod=0, clearmethod=0, withermethod=-1;\n    speedplus=0, wrap=1;\n\n    if (index == 0) {  liveval=10.; v1=240, v2=448; radius=6.; density=0.4;  withermethod=8; }                          // pyroclastic\n    if (index == 1) {  countmethod=1; liveval=2.; v1=127, v2=10; clearmethod=1; radius=1.0; density=1.0; speedplus=4; wrap=0; } // crystal\n    if (index == 2) {  liveval=8.;  v1=5382088, v2=9701408; radius=8.0; density=0.5; speedplus=-1; wrap=0; }            // amoeba II\n    if (index == 3) {  liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.499; wrap=1; }                    // clouds\n    if (index == 4) {  liveval=2.;  v1=593808, v2=2195520; radius=35.0; density=0.3; wrap=0; }                          // slowburning star\n    if (index == 5) {  liveval=4.;  v1=134217600, v2=16; clearmethod=1; radius=12.0; density=0.5; wrap=1; }             // struct builder\n    if (index == 6) {  liveval=5.;  v1=371520, v2=63793088; clearmethod=1; radius=6.0; density=0.6; }                   // expanding shells\n    if (index == 7) {  liveval=2.;  v1=0, v2=2; clearmethod=1; radius=1.0; density=1.0; speedplus=20; wrap=0; }         // single point\n    if (index == 8) {  liveval=10.; v1=580, v2=848; radius=13.; density=0.1;  withermethod=0; }                         // builder\n    if (index == 9) {  liveval=5.;  v1=16, v2=16; clearmethod=1; radius=15.0; density=0.4; }                            // 445\n    if (index == 10) { countmethod=1; liveval=2.; v1=127, v2=10; clearmethod=1; radius=4.0; density=1.0; speedplus=4;wrap=0; } // crystal (same, radius change)\n    if (index == 11) { liveval=3.;  v1=448, v2=448; radius=24.0; density=0.4; wrap=0;}                                  // 678\n    if (index == 12) { liveval=10.; v1=5382088, v2=9701408; radius=10.0; density=0.5; speedplus=-1; wrap=0; }           // amoeba II slow\n    if (index == 13) { liveval=7.;  v1=148064, v2=53477506; radius=1.0; clearmethod=1; density=1.; speedplus=12; }      // build cube\n    if (index == 14) { liveval=8.;  v1=21635016, v2=1052704; clearmethod=2; density=0.5; wrap=0; }                      // wither\n    if (index == 15) { liveval=11.; v1=65646754, v2=1123384; radius=7.; density=0.5; wrap=0; }                          // constant explosions\n    if (index == 16) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.515; wrap=0; }                    // clouds II\n    if (index == 17) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.58; wrap=0; }                     // clouds III (funkycube)\n\n    if (index == 18) { liveval=4.;  v1=134217600, v2=16; clearmethod=1; radius=17.0; density=0.5; wrap=0; }             // inv. struct builder\n    if (index == 19) { liveval=8.;  v1=5382088, v2=9701408; radius=10.0; density=0.5; speedplus=-1; wrap=0; }           // inv. amoeba II\n    if (index == 20) { liveval=5.;  v1=16, v2=16; clearmethod=1; radius=20.0; density=0.4; }                            // inv. 445\n    if (index == 21) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.52; wrap=1; }                     // inv. clouds\n    if (index == 22) { liveval=5.;  v1=134217216, v2=45280; clearmethod=0; radius=10.; density=0.8; wrap=0; }           // inv. amoeba I\n    if (index == 23) { liveval=5.;  v1=38553186, v2=2506768; clearmethod=0; radius=14.; density=0.58; wrap=0; }         // inv. little puffs\n\n    if (index==1 || index==10 || index==13) withermethod=4;\n    if (index==2 || index==15) withermethod=14;\n\n    liveset = v1; bornset = v2;\n}\n\nbool getInverted(int index) {\n    return index >= 18;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_c_code": "// resolution change\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4(iResolution.x); }\n", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 339, 339, 584], [587, 642, 718, 718, 761], [763, 763, 792, 792, 1142], [1144, 1144, 1179, 1179, 1814], [1816, 1816, 1926, 1926, 2243], [2245, 2245, 2294, 2294, 2405], [2407, 2407, 2524, 2524, 3226], [3228, 3228, 3316, 3316, 3895], [3897, 3897, 3992, 3992, 4131], [4133, 4133, 4209, 4209, 5343], [5346, 5346, 5371, 5371, 5558], [5560, 5560, 5716, 5716, 6480], [6482, 6482, 6509, 6509, 6576], [6578, 6578, 6635, 6635, 8607]], "test": "untested"}
{"id": "ds2fDy", "name": "bluering", "author": "zhangzhihao", "description": "扩散的发光圆环", "tags": ["ring"], "likes": 4, "viewed": 173, "published": 3, "date": "1690116127", "time_retrieved": "2024-07-30T17:43:03.820040", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=fragCoord/iResolution.xy*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    float d=length(uv);\n    vec3 color=vec3(1.0,2.0,3.0);\n    d=sin(d*4.0-iTime)/4.;\n    d=abs(d);\n    d=0.005/d;\n    color*=d;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2fDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 303]], "test": "untested"}
{"id": "mdjfWG", "name": "assignment nnuuss", "author": "nus_Boby", "description": "...", "tags": ["planets"], "likes": 0, "viewed": 146, "published": 3, "date": "1690104632", "time_retrieved": "2024-07-30T17:43:04.942039", "image_code": "const float music_length=120.0;\nconst float blur_turn = 13.0;\nconst float fading_turn=14.0;\nconst float first_turn=16.0;\nconst float end_turn=20.0;\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Add the original image to the blurred image to get the final image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float t = mod(iTime, music_length);\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n    \n    //The range of this pix fit the OriginalImageTex's size,\n    //Use the texel coordinate of gl_fragcoord and texelFetch can imporve the accuracy\n    vec4 origin = texture(iChannel0,uv);\n    \n    //The size of the blurred threshold image is smaller,\n    //Use the texCoord and texture() to sample the corresponding value;\n    vec4 color = texture(iChannel1,uv);\n    \n     fragColor = origin + color;\n    if(t>blur_turn && t<fading_turn){    \n        fragColor =origin + color*100.0*((t-blur_turn)/(fading_turn-blur_turn)) ;\n    }\n    if(t>fading_turn && t<first_turn){    \n        fragColor = (origin + color*100.0)*(1.0-(t-fading_turn)/(fading_turn-blur_turn)) ;\n    }\n    if(t> first_turn && t<end_turn){    \n        fragColor = (origin + color)*((t-first_turn)/(end_turn-first_turn)) ;\n    }\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 8;\nconst int NUM_MATERIALS = 30;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 39;\n\nconst float music_length=120.0;\nconst int max_inflate=16;\nconst float delay=1.2;\nconst float first_turn= 16.5;\nconst float second_turn=91.0;\nconst float stop_point=10.0; \nconst float lowest = -5.0;\n\nconst float Rpow = 1.28;//radius parameter\nconst float tStep = 4.0;//period for spheres emergement && height\nconst float rs =  10.0;//radius divede speed\nconst float AS = 4.0;//speed for angles\nconst float tBegin = -80.0;//time for pyramid\nconst float IP = 6.0;//initialized posotion\nconst float ys = 8.0;//y speed divided\nconst float boost = 5.0;//time for boost\nconst float boostpara =12.0;//boost parameter\n// 生成0~1伪随机数\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453123);\n}\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\n\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nPlane_t Plane[NUM_PLANES];\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length);\n     // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    \n    // Material[1].k_d = vec3( 0.3, 0.2, 0.5 );\n    Material[1].k_d = vec3( 0.8, 0.6, 0.2 );\n    Material[1].k_a = 0.5 * Material[1].k_d;\n    Material[1].k_r = 3.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    \n    \n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    //粉球\n    Material[3].k_d = vec3( 0.8, 0.7, 0.6 );\n    Material[3].k_a = 0.5 * Material[1].k_d;\n    Material[3].k_r = 1.0 * Material[1].k_d;\n    Material[3].k_rg = 0.5 * Material[1].k_r;\n    Material[3].n = 64.0;\n    \n    //蓝球\n    Material[4].k_d = vec3( 0.2, 0.1, 1.0 );\n    Material[4].k_a = 0.5 * Material[1].k_d;\n    Material[4].k_r = 1.0 * Material[1].k_d;\n    Material[4].k_rg = 0.5 * Material[1].k_r;\n    Material[4].n = 64.0;\n    \n    //红金球\n    Material[5].k_d = vec3( 0.7, 0.4, 0.2 );\n    Material[5].k_a = 0.5 * Material[1].k_d;\n    Material[5].k_r = 1.0 * Material[1].k_d;\n    Material[5].k_rg = 0.5 * Material[1].k_r;\n    Material[5].n = 64.0;\n    \n    //绿色球\n    Material[6].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[6].k_a = 0.5 * Material[1].k_d;\n    Material[6].k_r = 1.0 * Material[1].k_d;\n    Material[6].k_rg = 0.5 * Material[1].k_r;\n    Material[6].n = 64.0;\n    \n    //绿色球(黄色，渲染后）\n    Material[7].k_d = vec3( 0.2, 0.8, 0.2 );\n    Material[7].k_a = 0.5 * Material[1].k_d;\n    Material[7].k_r = 3.0 * Material[1].k_d;\n    Material[7].k_rg = 0.5 * Material[1].k_r;\n    Material[7].n = 64.0;\n    \n\n    // mercury\n    Material[8].k_d = vec3( 0.8, 0.6, 0.2 );\n    Material[8].k_a = 0.5 * Material[1].k_d;\n    Material[8].k_r = 3.0 * Material[1].k_d;\n    Material[8].k_rg = 0.5 * Material[1].k_r;\n    Material[8].n = 64.0;\n    \n    //venus\n    Material[9].k_d = vec3( 0.7, 0.4, 0.2 );\n    Material[9].k_a = 0.5 * Material[5].k_d;\n    Material[9].k_r = 0.5 * Material[5].k_d;\n    Material[9].k_rg = 0.5 * Material[5].k_r;\n    Material[9].n = 64.0;\n  \n    //earth\n    Material[10].k_d = vec3( 0.5, 0.1, 1.0 );\n    Material[10].k_a = 0.5 * Material[4].k_d;\n    Material[10].k_r = 0.2 * Material[4].k_d;\n    Material[10].k_rg = 0.5 * Material[4].k_r;\n    Material[10].n = 64.0;\n    \n    //mars\n    Material[11].k_d = vec3( 0.8, 0.7, 0.6 );\n    Material[11].k_a = 0.5 * Material[3].k_d;\n    Material[11].k_r = 0.3 * Material[3].k_d;\n    Material[11].k_rg = 0.5 * Material[3].k_r;\n    Material[11].n = 64.0;\n    \n    // jupitor\n    Material[12].k_d = vec3(0.7, 0.4, 0.1);\n    Material[12].k_a =vec3(0.6, 0.4, 0.0);\n    Material[12].k_r = vec3(0.5, 0.5, 0.5 );\n    Material[12].k_rg = 1.0 * Material[2].k_r;\n    Material[12].n = 0.078125;\n    \n    // saturn\n    Material[13].k_d = vec3(1.0, 0.3, 0.1);\n    Material[13].k_a =0.5*Material[13].k_d;\n    Material[13].k_r = vec3(1.0, 0.4, 0.1 );\n    Material[13].k_rg = 0.3 * Material[2].k_r;\n    Material[13].n = 0.078125;\n    \n    //uranus\n    Material[14].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[14].k_a = 0.2 * Material[2].k_d;\n    Material[14].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[14].k_rg = 0.5 * Material[2].k_r;\n    Material[14].n = 128.0;\n    \n    // neptune\n    Material[15].k_d = vec3( 1.0, 0.0, 1.0 );\n    Material[15].k_a = 0.3 * Material[2].k_d;\n    Material[15].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[15].k_rg = 1.0 * Material[2].k_r;\n    Material[15].n = 0.07;\n    \n    // 镜面材质.\n    Material[16].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[16].k_a = 0.01 * Material[16].k_d;\n    Material[16].k_r = 2.0 * Material[16].k_d;\n    Material[16].k_rg = 1.0 * Material[16].k_r;\n    Material[16].n = 64.0;\n    \n    // 奇点球材质.\n    Material[17].k_d = vec3( 0.6, 0.6, 0.2 );\n    Material[17].k_a = 0.5 * Material[16].k_d;\n    Material[17].k_r = 20.0 * Material[16].k_d;\n    Material[17].k_rg = 5.0 * Material[16].k_r;\n    Material[17].n = 64.0;\n    \n    //First step\n    if(t<=first_turn){\n        // Light 0.\n    Light[0].position = vec3( 6.0, 4.0, -3.0 );\n    Light[0].I_a = vec3( 0.0, 0.0, 0.8 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n    // Light 1.\n    Light[1].position = vec3( -6.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.0, 0.0, 0.8);\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n        // 奇点\n        Sphere[0].center = vec3( 0.0,0.0, 0.0 );\n        Sphere[0].radius = max(0.1,(t+delay)/2.0*abs(sin(120.0 / 60.0 * PI * iTime)));\n        Sphere[0].materialID = 17;\n\n    \n    }\n        \n    if(t > first_turn && t<=second_turn){\n           \n        \n        \n        \n        \n        if( t <(first_turn +boost) ){\n            float BOOST = (-(t-first_turn)*(t-first_turn)+2.0*boost*(t-first_turn))/boostpara;//Symmetry axis to be 5 after first_turn && distance to be 25*5/parameter\n\n            \n            Sphere[0].center = vec3( 0.0,20.0-(t-tBegin)/ys, 0.0 );\n            Sphere[0].radius = 6.0;\n            Sphere[0].materialID = 1;\n\n            //mercary\n            Sphere[1].center = vec3( pow(Rpow,(t-tBegin-7.0*tStep)/rs) * cos(AS*(t-tBegin-7.0*tStep)) , IP-(t-tBegin-7.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-7.0*tStep)/rs) * sin(AS*(t-tBegin-7.0*tStep)) );\n            Sphere[1].center = Sphere[1].center + Sphere[0].center ;\n            Sphere[1].radius = 0.5;\n            Sphere[1].materialID = 9;\n\n            //venus\n            Sphere[2].center = vec3( pow(Rpow,(t-tBegin-6.0*tStep)/rs) * cos(AS*(t-tBegin-6.0*tStep)) , IP-(t-tBegin-6.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-6.0*tStep)/rs) * sin(AS*(t-tBegin-6.0*tStep)) );\n            Sphere[2].center = Sphere[2].center + Sphere[0].center ;\n            Sphere[2].radius = 0.7;\n            Sphere[2].materialID = 10;\n\n            //earth\n            Sphere[3].center = vec3( pow(Rpow,(t-tBegin-5.0*tStep)/rs) * cos(AS*(t-tBegin-5.0*tStep)) , IP-(t-tBegin-5.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-5.0*tStep)/rs) * sin(AS*(t-tBegin-5.0*tStep)) );\n            Sphere[3].center = Sphere[3].center + Sphere[0].center ;\n            Sphere[3].radius = 1.0;\n            Sphere[3].materialID = 11;\n\n            //mars\n            Sphere[4].center = vec3( pow(Rpow,(t-tBegin-4.0*tStep)/rs) * cos(AS*(t-tBegin-4.0*tStep)) , IP-(t-tBegin-4.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-4.0*tStep)/rs) * sin(AS*(t-tBegin-4.0*tStep)) );\n            Sphere[4].center = Sphere[4].center + Sphere[0].center ;\n            Sphere[4].radius = 0.7;\n            Sphere[4].materialID = 12;\n\n            //jupiter\n            Sphere[5].center = vec3( pow(Rpow,(t-tBegin-3.0*tStep)/rs) * cos(AS*(t-tBegin-3.0*tStep)) , IP-(t-tBegin-3.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-3.0*tStep)/rs) * sin(AS*(t-tBegin-3.0*tStep)) );\n            Sphere[5].center = Sphere[5].center + Sphere[0].center ;\n            Sphere[5].radius =2.0;\n            Sphere[5].materialID = 12;\n\n            //saturn\n            Sphere[6].center = vec3( pow(Rpow,(t-tBegin-2.0*tStep)/rs) * cos(AS*(t-tBegin-2.0*tStep)) , IP-(t-tBegin-2.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-2.0*tStep)/rs) * sin(AS*(t-tBegin-2.0*tStep)) );\n            Sphere[6].center = Sphere[6].center + Sphere[0].center ;\n            Sphere[6].radius = 1.7;\n            Sphere[6].materialID = 13;\n\n            //uranus\n\n            Sphere[7].center = vec3( pow(Rpow,(t-tBegin-1.0*tStep)/rs) * cos(AS*(t-tBegin-1.0*tStep)) , IP-(t-tBegin-1.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-1.0*tStep)/rs) * sin(AS*(t-tBegin-1.0*tStep)) );\n            Sphere[7].center = Sphere[7].center + Sphere[0].center ;\n            Sphere[7].radius = 1.3;\n            Sphere[7].materialID = 14;\n\n            //neptune\n\n            Sphere[8].center = vec3( pow(Rpow,(t-tBegin-0.0*tStep)/rs) * cos(AS*(t-tBegin-0.0*tStep)) , IP-(t-tBegin-0.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-0.0*tStep)/rs) * sin(AS*(t-tBegin-0.0*tStep)) );\n            Sphere[8].center = Sphere[8].center + Sphere[0].center ;\n            Sphere[8].radius =1.5;\n            Sphere[8].materialID = 15;\n\n            ////mercary\n            Sphere[11].center = vec3( pow(Rpow,(t-tBegin-8.0*tStep)/rs) * cos(AS*(t-tBegin-8.0*tStep)) , IP-(t-tBegin-8.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-8.0*tStep)/rs) * sin(AS*(t-tBegin-8.0*tStep)) );\n            Sphere[11].center = Sphere[11].center + Sphere[0].center ;\n            Sphere[11].radius = 0.5;\n            Sphere[11].materialID = 9;\n\n            //venus\n            Sphere[12].center = vec3( pow(Rpow,(t-tBegin-9.0*tStep)/rs) * cos(AS*(t-tBegin-9.0*tStep)) , IP-(t-tBegin-9.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-9.0*tStep)/rs) * sin(AS*(t-tBegin-9.0*tStep)) );\n            Sphere[12].center = Sphere[12].center + Sphere[0].center ;\n            Sphere[12].radius = 0.7;\n            Sphere[12].materialID = 10;\n\n            //earth\n            Sphere[13].center = vec3( pow(Rpow,(t-tBegin-10.0*tStep)/rs) * cos(AS*(t-tBegin-10.0*tStep)) , IP-(t-tBegin-10.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-10.0*tStep)/rs) * sin(AS*(t-tBegin-10.0*tStep)) );\n            Sphere[13].center = Sphere[13].center + Sphere[0].center ;\n            Sphere[13].radius = 1.0;\n            Sphere[13].materialID = 11;\n\n            //mars\n            Sphere[14].center = vec3( pow(Rpow,(t-tBegin-11.0*tStep)/rs) * cos(AS*(t-tBegin-11.0*tStep)) , IP-(t-tBegin-11.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-11.0*tStep)/rs) * sin(AS*(t-tBegin-11.0*tStep)) );\n            Sphere[14].center = Sphere[14].center + Sphere[0].center ;\n            Sphere[14].radius = 0.7;\n            Sphere[14].materialID = 12;\n\n            //jupiter\n            Sphere[15].center = vec3( pow(Rpow,(t-tBegin-12.0*tStep)/rs) * cos(AS*(t-tBegin-12.0*tStep)) , IP-(t-tBegin-12.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-12.0*tStep)/rs) * sin(AS*(t-tBegin-12.0*tStep)) );\n            Sphere[15].center = Sphere[15].center + Sphere[0].center ;\n            Sphere[15].radius =2.0;\n            Sphere[15].materialID = 12;\n\n            //saturn\n            Sphere[16].center = vec3( pow(Rpow,(t-tBegin-13.0*tStep)/rs) * cos(AS*(t-tBegin-13.0*tStep)) , IP-(t-tBegin-13.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-13.0*tStep)/rs) * sin(AS*(t-tBegin-13.0*tStep)) );\n            Sphere[16].center = Sphere[16].center + Sphere[0].center ;\n            Sphere[16].radius = 1.7;\n            Sphere[16].materialID = 13;\n\n        }\n        else{\n            //70s to\n            // sun\n            Sphere[0].center = vec3( 0.0,20.0-(t-tBegin)/ys, 0.0 );\n            Sphere[0].radius = 6.0;\n            Sphere[0].materialID = 1;\n\n            //mercary\n            Sphere[1].center = vec3( pow(Rpow,(t-tBegin-7.0*tStep)/rs) * cos(AS*(t-tBegin-7.0*tStep)) , IP-(t-tBegin-7.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-7.0*tStep)/rs) * sin(AS*(t-tBegin-7.0*tStep)) );\n            Sphere[1].center = Sphere[1].center + Sphere[0].center ;\n            Sphere[1].radius = 0.5;\n            Sphere[1].materialID = 9;\n\n            //venus\n            Sphere[2].center = vec3( pow(Rpow,(t-tBegin-6.0*tStep)/rs) * cos(AS*(t-tBegin-6.0*tStep)) , IP-(t-tBegin-6.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-6.0*tStep)/rs) * sin(AS*(t-tBegin-6.0*tStep)) );\n            Sphere[2].center = Sphere[2].center + Sphere[0].center ;\n            Sphere[2].radius = 0.7;\n            Sphere[2].materialID = 10;\n\n            //earth\n            Sphere[3].center = vec3( pow(Rpow,(t-tBegin-5.0*tStep)/rs) * cos(AS*(t-tBegin-5.0*tStep)) , IP-(t-tBegin-5.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-5.0*tStep)/rs) * sin(AS*(t-tBegin-5.0*tStep)) );\n            Sphere[3].center = Sphere[3].center + Sphere[0].center ;\n            Sphere[3].radius = 1.0;\n            Sphere[3].materialID = 11;\n\n            //mars\n            Sphere[4].center = vec3( pow(Rpow,(t-tBegin-4.0*tStep)/rs) * cos(AS*(t-tBegin-4.0*tStep)) , IP-(t-tBegin-4.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-4.0*tStep)/rs) * sin(AS*(t-tBegin-4.0*tStep)) );\n            Sphere[4].center = Sphere[4].center + Sphere[0].center ;\n            Sphere[4].radius = 0.7;\n            Sphere[4].materialID = 12;\n\n            //jupiter\n            Sphere[5].center = vec3( pow(Rpow,(t-tBegin-3.0*tStep)/rs) * cos(AS*(t-tBegin-3.0*tStep)) , IP-(t-tBegin-3.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-3.0*tStep)/rs) * sin(AS*(t-tBegin-3.0*tStep)) );\n            Sphere[5].center = Sphere[5].center + Sphere[0].center ;\n            Sphere[5].radius =2.0;\n            Sphere[5].materialID = 12;\n\n            //saturn\n            Sphere[6].center = vec3( pow(Rpow,(t-tBegin-2.0*tStep)/rs) * cos(AS*(t-tBegin-2.0*tStep)) , IP-(t-tBegin-2.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-2.0*tStep)/rs) * sin(AS*(t-tBegin-2.0*tStep)) );\n            Sphere[6].center = Sphere[6].center + Sphere[0].center ;\n            Sphere[6].radius = 1.7;\n            Sphere[6].materialID = 13;\n\n            //uranus\n\n            Sphere[7].center = vec3( pow(Rpow,(t-tBegin-1.0*tStep)/rs) * cos(AS*(t-tBegin-1.0*tStep)) , IP-(t-tBegin-1.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-1.0*tStep)/rs) * sin(AS*(t-tBegin-1.0*tStep)) );\n            Sphere[7].center = Sphere[7].center + Sphere[0].center ;\n            Sphere[7].radius = 1.3;\n            Sphere[7].materialID = 14;\n\n            //neptune\n\n            Sphere[8].center = vec3( pow(Rpow,(t-tBegin-0.0*tStep)/rs) * cos(AS*(t-tBegin-0.0*tStep)) , IP-(t-tBegin-0.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-0.0*tStep)/rs) * sin(AS*(t-tBegin-0.0*tStep)) );\n            Sphere[8].center = Sphere[8].center + Sphere[0].center ;\n            Sphere[8].radius =1.5;\n            Sphere[8].materialID = 15;\n\n            ////mercary\n            Sphere[11].center = vec3( pow(Rpow,(t-tBegin-8.0*tStep)/rs) * cos(AS*(t-tBegin-8.0*tStep)) , IP-(t-tBegin-8.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-8.0*tStep)/rs) * sin(AS*(t-tBegin-8.0*tStep)) );\n            Sphere[11].center = Sphere[11].center + Sphere[0].center ;\n            Sphere[11].radius = 0.5;\n            Sphere[11].materialID = 9;\n\n            //venus\n            Sphere[12].center = vec3( pow(Rpow,(t-tBegin-9.0*tStep)/rs) * cos(AS*(t-tBegin-9.0*tStep)) , IP-(t-tBegin-9.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-9.0*tStep)/rs) * sin(AS*(t-tBegin-9.0*tStep)) );\n            Sphere[12].center = Sphere[12].center + Sphere[0].center ;\n            Sphere[12].radius = 0.7;\n            Sphere[12].materialID = 10;\n\n            //earth\n            Sphere[13].center = vec3( pow(Rpow,(t-tBegin-10.0*tStep)/rs) * cos(AS*(t-tBegin-10.0*tStep)) , IP-(t-tBegin-10.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-10.0*tStep)/rs) * sin(AS*(t-tBegin-10.0*tStep)) );\n            Sphere[13].center = Sphere[13].center + Sphere[0].center ;\n            Sphere[13].radius = 1.0;\n            Sphere[13].materialID = 11;\n\n            //mars\n            Sphere[14].center = vec3( pow(Rpow,(t-tBegin-11.0*tStep)/rs) * cos(AS*(t-tBegin-11.0*tStep)) , IP-(t-tBegin-11.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-11.0*tStep)/rs) * sin(AS*(t-tBegin-11.0*tStep)) );\n            Sphere[14].center = Sphere[14].center + Sphere[0].center ;\n            Sphere[14].radius = 0.7;\n            Sphere[14].materialID = 12;\n\n            //jupiter\n            Sphere[15].center = vec3( pow(Rpow,(t-tBegin-12.0*tStep)/rs) * cos(AS*(t-tBegin-12.0*tStep)) , IP-(t-tBegin-12.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-12.0*tStep)/rs) * sin(AS*(t-tBegin-12.0*tStep)) );\n            Sphere[15].center = Sphere[15].center + Sphere[0].center ;\n            Sphere[15].radius =2.0;\n            Sphere[15].materialID = 12;\n\n            //saturn\n            Sphere[16].center = vec3( pow(Rpow,(t-tBegin-13.0*tStep)/rs) * cos(AS*(t-tBegin-13.0*tStep)) , IP-(t-tBegin-13.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-13.0*tStep)/rs) * sin(AS*(t-tBegin-13.0*tStep)) );\n            Sphere[16].center = Sphere[16].center + Sphere[0].center ;\n            Sphere[16].radius = 1.7;\n            Sphere[16].materialID = 13;\n            // Circling sphere.\n            //Sphere[1].center = vec3( 3.0+1.5 * cos(iTime), -0.3, 1.5 * sin(iTime) );\n            //Sphere[1].radius = 0.5;\n            //Sphere[1].materialID = 2;\n        }\n    }\n    \n    if(t > second_turn){\n           //移动距离/s\n        float v = min(5.0,0.5*(t-second_turn));\n        //底面镜面\n        Plane[0].A = 0.0;\n        Plane[0].B = 1.0;\n        Plane[0].C = 0.0;\n        Plane[0].D = 0.0;\n        Plane[0].materialID = 16;\n        // sun\n        Sphere[0].center = vec3( 0.0,lowest+v,0.0);\n        Sphere[0].radius = 6.0;\n        Sphere[0].materialID = 1;\n        //mercary\n        Sphere[1].center = vec3( 8.0*cos(iTime),lowest+v,8.0*sin(iTime));\n        Sphere[1].radius = 1.0;\n        Sphere[1].materialID = 9;\n\n        //enus\n        Sphere[2].center = vec3( 12.0*cos(2.0*iTime),lowest+v,12.0*sin(2.0*iTime));\n        Sphere[2].radius = 1.4;\n        Sphere[2].materialID = 10;\n\n        //earth\n        Sphere[3].center = vec3( 16.0*cos(1.5*iTime),lowest+v,16.0*sin(1.5*iTime));\n        Sphere[3].radius = 2.0;\n        Sphere[3].materialID = 11;\n\n        //mars\n        Sphere[4].center = vec3( 21.0*cos(1.2*iTime),lowest +v,21.0*sin(1.2*iTime));\n        Sphere[4].radius = 1.4;\n        Sphere[4].materialID = 12;\n\n        //jupiter\n        Sphere[5].center = vec3( 27.0*cos(0.8*iTime),lowest +v,27.0*sin(0.8*iTime));\n        Sphere[5].radius = 3.2;\n        Sphere[5].materialID = 12;\n\n        //turn\n        Sphere[6].center = vec3(35.0*cos(0.7*iTime),lowest +v,35.0*sin(0.7*iTime));\n        Sphere[6].radius = 3.0;\n        Sphere[6].materialID = 13;\n\n        //uranus\n        Sphere[7].center = vec3( 24.5*cos(0.5*iTime),lowest+v,24.5*sin(0.5*iTime));\n        Sphere[7].radius = 1.3;\n        Sphere[7].materialID = 14;\n\n        //neptune\n        Sphere[8].center = vec3(  28.0,lowest +v,0.0);\n        Sphere[8].radius =1.5;\n        Sphere[8].materialID = 15;\n        \n        //随机材料选择\n        bool equal = (mod((t-fract(t)),2.0)== 0.0);\n        if(equal){\n            int matrial1 = int(9.0 + mod(10.0 * random(iTime),4.0));\n            int matrial2 = int(9.0 + mod(10.0 * random(iTime+1.0),4.0));\n            int matrial3 = int(9.0 + mod(10.0 * random(iTime+2.0),4.0));\n            int matrial4 = int(9.0 + mod(10.0 * random(iTime+3.0),4.0));\n            int matrial5 = int(9.0 + mod(10.0 * random(iTime+4.0),4.0));\n            int matrial6 = int(9.0 + mod(10.0 * random(iTime+5.0),4.0));\n            int matrial7 = int(9.0 + mod(10.0 * random(iTime+6.0),4.0));\n            int matrial8 = int(9.0 + mod(10.0 * random(iTime+7.0),4.0));\n            int matrial9 = int(9.0 + mod(10.0 * random(iTime+8.0),4.0));\n\n            Sphere[0].materialID = matrial1;\n            Sphere[1].materialID = matrial2;\n            Sphere[2].materialID = matrial3;\n            Sphere[3].materialID = matrial4;\n            Sphere[4].materialID = matrial5;\n            Sphere[5].materialID = matrial6;\n            Sphere[6].materialID = matrial7;\n            Sphere[7].materialID = matrial8;\n            Sphere[8].materialID = matrial9;\n        }\n    }\n    \n    // Light 0.\n    Light[0].position = vec3( 6.0, 4.0, -3.0 );\n    Light[0].I_a = vec3( 0.0, 0.0, 0.8 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( 30, 0.0, 5.0 );\n    Light[1].I_a = vec3( 1.0, 1.0, 1.0 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n    // Light 2.\n    Light[2].position = vec3( 28,0.0, 3.0 );\n    Light[2].I_a = vec3( 1.0, 1.0, 1.0);\n    Light[2].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    //??\n    vec3 origin_dup=ray.o - sph.center;\n    float a = dot(ray.d,ray.d);\n    float b = dot(ray.d,origin_dup)*2.0;\n    float c = dot(origin_dup,origin_dup)- sph.radius*sph.radius;\n    float d= b*b-4.0*a*c;\n    float t0=(-b-sqrt(d))/(2.0*a);\n    float t1=(-b+sqrt(d))/(2.0*a);\n    if(d<0.0){\n        return false;\n    }\n    if(d==0.0)\n    {\n        if(t0<tmin||t0>tmax) return false;\n        else{\n            t = t0;\n            hitPos = ray.o + t0 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        } \n    }\n    if(d>0.0)\n    {\n        //??\n        if(t0>tmin&&t0<tmax)\n        {\n            t = t0;\n            hitPos = ray.o + t0 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        }\n        if(t1>tmin&&t1<tmax)\n        {\n            t = t1;\n            hitPos = ray.o + t1 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        }\n        return false;\n    }\n\n\n    return false;  // Replace this with your code.\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 origin_dup=ray.o - sph.center;\n    float a = dot(ray.d,ray.d);\n    float b = dot(ray.d,origin_dup)*2.0;\n    float c = dot(origin_dup,origin_dup)- sph.radius*sph.radius;\n    float d= b*b-4.0*a*c;\n    float t0=(-b-sqrt(d))/(2.0*a);\n    float t1=(-b+sqrt(d))/(2.0*a);\n    if(d<0.0){\n        return false;\n    }\n    if(d==0.0)\n    {\n        if(t0<tmin||t0>tmax) return false;\n        else{\n            return true;\n        } \n    }\n    if(d>0.0)\n    {\n        if(t0>tmin&&t0<tmax)\n        {\n            return true;\n        }\n        if(t1>tmin&&t1<tmax)\n        {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    vec3 cubemapReflectionColor = texture(iChannel0,ray.d).rgb;\n \n     for(int i=0; i<NUM_PLANES; i++){\n            temp_hasHit = IntersectPlane( Plane[i], ray, DEFAULT_TMIN, nearest_t,\n                             temp_t, temp_hitPos, temp_hitNormal );\n            if(temp_hasHit==true && nearest_t>temp_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                hasHitSomething = temp_hasHit;\n                nearest_hitMatID =  Plane[i].materialID;\n            }\n       }\n\n    for(int i=0; i<NUM_SPHERES; i++){\n        temp_hasHit = IntersectSphere( Sphere[i], ray, DEFAULT_TMIN, nearest_t,\n                         temp_t, temp_hitPos, temp_hitNormal );\n        if(temp_hasHit==true && nearest_t>temp_t){\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            hasHitSomething = temp_hasHit;\n            nearest_hitMatID =  Sphere[i].materialID;\n        }\n    }\n\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return cubemapReflectionColor;\n    \n    Ray_t reflect_ray;\n    reflect_ray.o = nearest_hitPos;\n    reflect_ray.d = normalize(reflect(ray.d,nearest_hitNormal));\n\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n\n\n    bool inShadow=false;\n    Ray_t Shadow_ray;\n    \n    for(int i =0 ; i<2; i++){\n        Shadow_ray.o = nearest_hitPos;\n        Shadow_ray.d = normalize(Light[i].position-nearest_hitPos);\n\n        for(int i=0; i<NUM_PLANES; i++){\n                    inShadow = IntersectPlane( Plane[i], Shadow_ray, DEFAULT_TMIN, nearest_t);\n                    if(inShadow) break;\n                }\n\n\n        if(!inShadow){\n            for(int i=0; i<NUM_SPHERES; i++){\n                inShadow = IntersectSphere( Sphere[i], Shadow_ray, DEFAULT_TMIN, nearest_t);\n                if(inShadow) break;\n            }\n        }\n\n\n        I_local += PhongLighting( Shadow_ray.d, nearest_hitNormal, -ray.d, inShadow,\n                    Material[nearest_hitMatID],Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    \n //   I_local = mix(cubemapReflectionColor, I_local, step(nearest_t - DEFAULT_TMAX, 0.));\n //   I_local=cubemapReflectionColor;\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length) ;\n    vec3 cam_pos;\n    vec3 cam_lookat;\n    vec3 cam_up_vec;\n    \n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n     //First step\n    if(t<=first_turn){\n        // Position the camera.\n        // Position the camera.\n        cam_pos = vec3(0.0, 0.0, max(12.0,(20.0-t)) );\n        cam_lookat = Sphere[0].center;\n        cam_up_vec = vec3(0.0, 1.0, 0.0 );\n    \n    }\n    \n    if(t > first_turn && t<=second_turn){\n        // Position the camera.\n        // Position the camera.\n        cam_pos = vec3(0.0, 20.0, 30.0 );\n        cam_lookat = Sphere[0].center;\n        cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    }\n    \n    if(t > second_turn){\n        float carema_up_speed = 0.6*(t-second_turn);\n        cam_pos = vec3( 5.0+min(15.0,(10.0+carema_up_speed)), min(20.0,(0.0+carema_up_speed)), 5.0+min(15.0,(0.0+carema_up_speed)));\n        cam_lookat = vec3(Sphere[0].center.x,Sphere[0].center.y,Sphere[0].center.z);\n        cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    }\n\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34042, "src": "https://soundcloud.com/xx-246642668/test", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "const float LuminanceThreshold= 0.6;\n\n/////////////////////////////////////////////////////////////////////////////\n// Approximates the brightness of a RGB value.\n/////////////////////////////////////////////////////////////////////////////\nfloat Luminance( vec3 color )\n{\n    const vec3 LuminanceWeights = vec3(0.2126, 0.7152, 0.0722);\n    return dot(LuminanceWeights, color);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Threshold the original image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  float brightness=Luminance(texture(iChannel0, uv.xy).rgb);\n\n  fragColor = (brightness > LuminanceThreshold)? texture(iChannel0, uv.xy):vec4(0.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const int blurFilterWidth = 51;\nconst int halfWidth = 25;\nfloat weights[blurFilterWidth];\n\n/////////////////////////////////////////////////////////////////////////////\n// 1D gaussian function.\n/////////////////////////////////////////////////////////////////////////////\nfloat gauss(float x, float sigma2)\n{\n    const float PI = 3.1415926535897932384626433832795;\n    float coeff = 1.0 / sqrt(2.0 * PI * sigma2);\n    float expon = -(x * x) / (2.0 * sigma2);\n    return (coeff * exp(expon));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Set up 1D texture map that contains the 1D blur filter.\n/////////////////////////////////////////////////////////////////////////////\nvoid SetUpBlurFilterTexture()\n{\n    float sigma = float(halfWidth) / 2.0;  // Filter spans over 4 sigma (standard deviation).\n    float sigma2 = sigma * sigma;\n\n    float sum = 0.0;\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        float offset=float(i) - float(halfWidth);\n        weights[i] = gauss(offset, sigma2);\n        sum += weights[i];\n    }\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        weights[i] = weights[i] / sum;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Apply horizontal blurring to the threshold image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     \n    //After getting the fragment coordinate of fragment,\n    //Use the middle value of the blurFilterTex on the beginning fragment;\n    ivec2 pix = ivec2(fragCoord.xy);\n    SetUpBlurFilterTexture();\n    \n    vec4 sum = texture(iChannel0, uv) * weights[halfWidth];\n\n    //Apply the 1D Gaussian \n    for( int i = 1; i < halfWidth+1; i++ ) {\n        ivec2 offsetCoord = ivec2(pix.x + i, pix.y);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth+i];\n        offsetCoord = ivec2(pix.x - i, pix.y);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth-i];\n    }\n\n    //fragColor =texelFetch(iChannel0, pix, 0);\n    //fragColor =texture(iChannel2, uv.xy);\n    fragColor = sum;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// Interstellar\n// Hazel Quantock\n// This code is licensed under the CC0 license http://creativecommons.org/publicdomain/zero/1.0/\n\nfloat max3(vec3 rd) {\n   return max(max(rd.x, rd.y), rd.z);\n}\n/*original  https://www.shadertoy.com/view/XlfGRj */\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.3\n\n#define zoom   2.300\n#define tile   0.250\n#define speed  0.010 \n\n#define brightness 0.0115\n#define darkmatter 0.500\n#define distfading 0.530\n#define saturation 0.750\n\nconst float tau = 6.28318530717958647692;\nconst float music_length=120.0;\nconst float first_turn=16.0;\nconst float second_turn=90.0;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn texture( iChannel0, (vec2(x)+0.5)/256.0, -100.0 );\n}\n\nvec4 Rand( in int x )\n{\n\tvec2 uv;\n\tuv.x = (float(x)+0.5)/256.0;\n\tuv.y = (floor(uv.x)+0.5)/256.0;\n\treturn texture( iChannel0, uv, -100.0 );\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length);\n    //t=t+first_turn;\n      //  t=t+second_turn;\n    \n    if(t<=first_turn){\n        vec3 ray;\n        ray.xy = 2.0*(fragCoord.xy-iResolution.xy*.5)/iResolution.x;\n        ray.z = 1.0;\n\n        float offset = t*.5;\t\n        float speed2 = (cos(offset)+1.0)*2.0;\n        float speed3 = speed2+.1;\n        offset += sin(offset)*.96;\n        offset *= 2.0;\n\n\n        vec3 col = vec3(0);\n\n        vec3 stp = ray/max(abs(ray.x),abs(ray.y));\n\n        vec3 pos = 2.0*stp+.5;\n        for ( int i=0; i < 20; i++ )\n        {\n            float z = Noise(ivec2(pos.xy)).x;\n            z = fract(z-offset);\n            float d = 50.0*z-pos.z;\n            float w = pow(max(0.0,1.0-8.0*length(fract(pos.xy)-.5)),2.0);\n            vec3 c = max(vec3(0),vec3(1.0-abs(d+speed2*.5)/speed3,1.0-abs(d)/speed3,1.0-abs(d-speed2*.5)/speed3));\n            col += 1.5*(1.0-z)*c*w;\n            pos += stp;\n        }\n\n        fragColor = vec4(ToGamma(col),1.0);\n    }\n    if(t>first_turn){\n        vec2 uv=fragCoord.xy/iResolution.xy-.5;\n        uv.y*=iResolution.y/iResolution.x;\n        vec3 dir=vec3(uv*zoom,1.);\n        float time=t*speed+.25;\n\n\n        float a1=.5+iMouse.x/iResolution.x*2.;\n        float a2=.8+iMouse.y/iResolution.y*2.;\n        mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n        mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n        dir.xz*=rot1;\n        dir.xy*=rot2;\n        vec3 from=vec3(1.,.5,0.5);\n        from+=vec3(time*0.,time,time*10.);\n        from.xz*=rot1;\n        from.xy*=rot2;\n\n\n        float s=0.1,fade=1.;\n        vec3 v=vec3(0.);\n        for (int r=0; r<volsteps; r++) {\n            vec3 p=sin(fract(from-s*dir)*1.10);\n            p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n            float pa,a=pa=0.;\n            for (int i=0; i<iterations; i++) { \n                p=abs(p)/dot(p,p*3.1)-formuparam; // the magic formula\n                a+=abs(length(p)+pa); // absolute sum of average change\n                pa=0.2*fract(abs(length(p/2.)));\n            }\n                float dm=max(0.,darkmatter-a*a*.001); //dark matter\n                a*=a*a; // add contrast\n                if (r>10) fade*=1.-dm; // dark matter, don't render near\n                v+=vec3(fract(smoothstep(dm,dm*.1,0.)));\n                v+=fade;\n                v+=vec3(s,1.*fract(s*s),s*s*s)*a*brightness*fade; // coloring based on distance\n                fade*=distfading; // distance fading\n                s+=stepsize;\n            }\n            v=mix(vec3(length(v)),v,saturation); //color adjust\n            fragColor = vec4(v*0.01,1.);\n    }\n\n}", "cube_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "const int blurFilterWidth = 51;\nconst int halfWidth = 25;\nfloat weights[blurFilterWidth];\n\n/////////////////////////////////////////////////////////////////////////////\n// 1D gaussian function.\n/////////////////////////////////////////////////////////////////////////////\nfloat gauss(float x, float sigma2)\n{\n    const float PI = 3.1415926535897932384626433832795;\n    float coeff = 1.0 / sqrt(2.0 * PI * sigma2);\n    float expon = -(x * x) / (2.0 * sigma2);\n    return (coeff * exp(expon));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Set up 1D texture map that contains the 1D blur filter.\n/////////////////////////////////////////////////////////////////////////////\nvoid SetUpBlurFilterTexture()\n{\n    float sigma = float(halfWidth) / 2.0;  // Filter spans over 4 sigma (standard deviation).\n    float sigma2 = sigma * sigma;\n\n    float sum = 0.0;\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        float offset=float(i) - float(halfWidth);\n        weights[i] = gauss(offset, sigma2);\n        sum += weights[i];\n    }\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        weights[i] = weights[i] / sum;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Apply horizontal blurring to the threshold image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     \n    //After getting the fragment coordinate of fragment,\n    //Use the middle value of the blurFilterTex on the beginning fragment;\n    ivec2 pix = ivec2(fragCoord.xy);\n    SetUpBlurFilterTexture();\n    \n    vec4 sum = texture(iChannel0, uv) * weights[halfWidth];\n\n    //Apply the 1D Gaussian \n    for( int i = 1; i < halfWidth+1; i++ ) {\n        ivec2 offsetCoord = ivec2(pix.x , pix.y+ i);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth+i];\n        offsetCoord = ivec2(pix.x , pix.y- i);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth-i];\n    }\n\n    //fragColor =texelFetch(iChannel0, pix, 0);\n    //fragColor =texture(iChannel2, uv.xy);\n    fragColor = sum;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 377, 434, 434, 1376]], "test": "untested"}
{"id": "dsjBWG", "name": "SWS3005_15", "author": "HU_YINGXUAN", "description": "nice", "tags": ["1"], "likes": 1, "viewed": 149, "published": 3, "date": "1690102161", "time_retrieved": "2024-07-30T17:43:06.411112", "image_code": "const float music_length=120.0;\nconst float blur_turn = 13.0;\nconst float fading_turn=14.0;\nconst float first_turn=16.0;\nconst float end_turn=20.0;\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Add the original image to the blurred image to get the final image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float t = mod(iTime, music_length);\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n    \n    //The range of this pix fit the OriginalImageTex's size,\n    //Use the texel coordinate of gl_fragcoord and texelFetch can imporve the accuracy\n    vec4 origin = texture(iChannel0,uv);\n    \n    //The size of the blurred threshold image is smaller,\n    //Use the texCoord and texture() to sample the corresponding value;\n    vec4 color = texture(iChannel1,uv);\n    \n     fragColor = origin + color;\n    if(t>blur_turn && t<fading_turn){    \n        fragColor =origin + color*100.0*((t-blur_turn)/(fading_turn-blur_turn)) ;\n    }\n    if(t>fading_turn && t<first_turn){    \n        fragColor = (origin + color*100.0)*(1.0-(t-fading_turn)/(fading_turn-blur_turn)) ;\n    }\n    if(t> first_turn && t<end_turn){    \n        fragColor = (origin + color)*((t-first_turn)/(end_turn-first_turn)) ;\n    }\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 8;\nconst int NUM_MATERIALS = 31;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 39;\n\nconst float music_length=120.0;\nconst int max_inflate=16;\nconst float delay=1.3;\nconst float first_turn=16.5;\nconst float second_turn=91.0;\nconst float stop_point=10.0; \nconst float lowest = -9.0;\nconst float highest = 50.0;\n\nconst float Rpow = 1.3;//radius parameter\nconst float tStep = 4.0;//period for spheres emergement && height\nconst float rs =  10.0;//radius divede speed\nconst float AS = 4.0;//speed for angles\nconst float tBegin = -80.0;//time for pyramid\nconst float IP = 6.0;//initialized posotion\nconst float ys = 8.0;//y speed divided\nconst float boost = 5.0;//time for boost\nconst float boostpara =12.0;//boost parameter\nconst float radius_con=1.0;\n\n\n\n// 生成0~1伪随机数\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453123);\n}\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\n\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nPlane_t Plane[NUM_PLANES];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length);\n   // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    \n    // Material[1].k_d = vec3( 0.3, 0.2, 0.5 );\n    Material[1].k_d = vec3( 0.8, 0.6, 0.2 );\n    Material[1].k_a = 0.5 * Material[1].k_d;\n    Material[1].k_r = 3.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    \n    \n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    //粉球\n    Material[3].k_d = vec3( 0.8, 0.7, 0.6 );\n    Material[3].k_a = 0.5 * Material[3].k_d;\n    Material[3].k_r = 1.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n    \n    //蓝球\n    Material[4].k_d = vec3( 0.2, 0.1, 1.0 );\n    Material[4].k_a = 0.5 * Material[4].k_d;\n    Material[4].k_r = 1.0 * Material[4].k_d;\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 64.0;\n    \n    //红金球\n    Material[5].k_d = vec3( 0.7, 0.4, 0.2 );\n    Material[5].k_a = 0.5 * Material[5].k_d;\n    Material[5].k_r = 2.0 * Material[5].k_d;\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 64.0;\n    \n    //绿色球\n    Material[6].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[6].k_a = 0.5 * Material[6].k_d;\n    Material[6].k_r = 1.0 * Material[6].k_d;\n    Material[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].n = 64.0;\n    \n    //绿色球(黄色，渲染后）\n    Material[7].k_d = vec3( 0.2, 0.8, 0.2 );\n    Material[7].k_a = 0.5 * Material[7].k_d;\n    Material[7].k_r = 3.0 * Material[7].k_d;\n    Material[7].k_rg = 0.5 * Material[7].k_r;\n    Material[7].n = 64.0;\n    \n\n    // mercury\n    Material[8].k_d = vec3( 0.8, 0.6, 0.2 );\n    Material[8].k_a = 0.5 * Material[8].k_d;\n    Material[8].k_r = 3.0 * Material[8].k_d;\n    Material[8].k_rg = 0.5 * Material[8].k_r;\n    Material[8].n = 64.0;\n    \n    //venus\n    Material[9].k_d = vec3( 0.3, 0.7, 0.8 );\n    Material[9].k_a = 0.5 * Material[9].k_d;\n    Material[9].k_r = 1.0 * Material[9].k_d;\n    Material[9].k_rg = 0.5 * Material[9].k_r;\n    Material[9].n = 64.0;\n  \n    //earth\n    Material[10].k_d = vec3( 0.5, 0.1, 1.0 );\n    Material[10].k_a = 0.5 * Material[10].k_d;\n    Material[10].k_r = 0.2 * Material[10].k_d;\n    Material[10].k_rg = 0.5 * Material[10].k_r;\n    Material[10].n = 64.0;\n    \n    //mars\n    Material[11].k_d = vec3( 0.8, 0.7, 0.2 );\n    Material[11].k_a = 0.5 * Material[11].k_d;\n    Material[11].k_r = 0.3 * Material[11].k_d;\n    Material[11].k_rg = 0.5 * Material[11].k_r;\n    Material[11].n = 64.0;\n    \n    // jupitor\n    Material[12].k_d = vec3(0.7, 0.4, 0.1);\n    //Material[12].k_a =vec3(0.6, 0.4, 0.0);\n    Material[12].k_a =0.5 * Material[12].k_d;\n    //Material[12].k_r = vec3(0.5, 0.5, 0.5 );\n    Material[12].k_r =0.3 * Material[12].k_d;\n    Material[12].k_rg = 1.0 * Material[12].k_r;\n    Material[12].n = 0.078125;\n    \n    // saturn\n    Material[13].k_d = vec3(1.0, 0.3, 0.1);\n    Material[13].k_a =0.5*Material[13].k_d;\n    Material[13].k_r = vec3(1.0, 0.4, 0.1 );\n    Material[13].k_rg = 0.3 * Material[13].k_r;\n    Material[13].n = 0.078125;\n    \n    //uranus\n    Material[14].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[14].k_a = 0.2 * Material[2].k_d;\n    Material[14].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[14].k_rg = 0.5 * Material[2].k_r;\n    Material[14].n = 128.0;\n    \n    // neptune(紫色）\n    Material[15].k_d = vec3( 0.6, 0.2, 0.7 );\n    Material[15].k_a = 0.3 * Material[15].k_d;\n    Material[15].k_r = 0.5 * Material[15].k_d;\n    Material[15].k_rg = 0.5 * Material[15].k_r;\n    Material[15].n = 0.07;\n    \n    // Silver material.\n    Material[16].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[16].k_a = 0.01 * Material[16].k_d;\n    Material[16].k_r = 2.0 * Material[16].k_d;\n    Material[16].k_rg = 1.0 * Material[16].k_r;\n    Material[16].n = 64.0;\n    \n    \n    // 奇点球材质.\n    Material[17].k_d = vec3( 0.6, 0.6, 0.2 );\n    Material[17].k_a = 0.5 * Material[16].k_d;\n    Material[17].k_r = 20.0 * Material[16].k_d;\n    Material[17].k_rg = 5.0 * Material[16].k_r;\n    Material[17].n = 64.0;\n    \n    //term2 专属\n    \n    // neptune(紫色）\n    Material[18].k_d = vec3( 0.6, 0.2, 0.7 );\n    Material[18].k_a = 0.3 * Material[18].k_d;\n    Material[18].k_r = 0.5 * Material[18].k_d;\n    Material[18].k_rg = 0.5 * Material[18].k_r;\n    Material[18].n = 64.0;\n    \n    //uranus(蓝色)\n    Material[19].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[19].k_a = 0.5 * Material[19].k_d;\n    Material[19].k_r = 0.5 * Material[19].k_d;\n    Material[19].k_rg = 0.5 * Material[19].k_r;\n    Material[19].n = 128.0;\n    \n    // saturn\n    Material[20].k_d = vec3(1.0, 0.3, 0.1);\n    Material[20].k_a = 0.5 * Material[19].k_d;\n    Material[20].k_r = 0.5 * Material[19].k_d;\n    Material[20].k_rg = 0.5 * Material[19].k_d;\n    Material[20].n = 64.0;\n    \n    //红金球\n    Material[21].k_d = vec3( 0.7, 0.4, 0.2 );\n    Material[21].k_a = 0.5 * Material[21].k_d;\n    Material[21].k_r = 0.5 * Material[21].k_d;\n    Material[21].k_rg = 0.5 * Material[21].k_r;\n    Material[21].n = 64.0;\n    \n    //粉球\n    Material[22].k_d = vec3( 0.8, 0.7, 0.6 );\n    Material[22].k_a = 0.5 * Material[22].k_d;\n    Material[22].k_r = 0.5 * Material[22].k_d;\n    Material[22].k_rg = 0.5 * Material[22].k_r;\n    Material[22].n = 64.0;\n    \n    //绿色球(黄色，渲染后）\n    Material[23].k_d = vec3( 0.2, 0.8, 0.2 );\n    Material[23].k_a = 0.5 * Material[23].k_d;\n    Material[23].k_r = 0.5 * Material[23].k_d;\n    Material[23].k_rg = 0.5 * Material[23].k_r;\n    Material[23].n = 64.0;\n    \n    // mercury\n    Material[24].k_d = vec3( 0.8, 0.6, 0.2 );\n    Material[24].k_a = 0.5 * Material[24].k_d;\n    Material[24].k_r = 0.5 * Material[24].k_d;\n    Material[24].k_rg = 0.5 * Material[24].k_r;\n    Material[24].n = 64.0;\n    \n    //venus\n    Material[25].k_d = vec3( 0.3, 0.7, 0.8 );\n    Material[25].k_a = 0.5 * Material[25].k_d;\n    Material[25].k_r = 0.5 * Material[25].k_d;\n    Material[25].k_rg = 0.5 * Material[25].k_r;\n    Material[25].n = 64.0;\n    \n    //earth\n    Material[26].k_d = vec3( 0.5, 0.1, 1.0 );\n    Material[26].k_a = 0.5 * Material[10].k_d;\n    Material[26].k_r = 0.5 * Material[10].k_d;\n    Material[26].k_rg = 0.5 * Material[10].k_r;\n    Material[26].n = 64.0;\n    \n    //x\n    Material[27].k_d = vec3( 0.7, 0.3, 0.5 );\n    Material[27].k_a = 0.5 * Material[27].k_d;\n    Material[27].k_r = 0.5 * Material[27].k_d;\n    Material[27].k_rg = 0.5 * Material[27].k_r;\n    Material[27].n = 64.0;\n    \n    //y\n    Material[28].k_d = vec3( 0.2, 0.6, 1.0 );\n    Material[28].k_a = 0.5 * Material[10].k_d;\n    Material[28].k_r = 0.5 * Material[10].k_d;\n    Material[28].k_rg = 0.5 * Material[10].k_r;\n    Material[28].n = 64.0;\n    \n    //z\n    Material[29].k_d = vec3( 0.7, 0.7, 0.5 );\n    Material[29].k_a = 0.5 * Material[29].k_d;\n    Material[29].k_r = 0.5 * Material[29].k_d;\n    Material[29].k_rg = 0.5 * Material[29].k_r;\n    Material[29].n = 64.0;\n    \n    //x\n    Material[30].k_d = vec3( 0.8, 0.1, 0.3 );\n    Material[30].k_a = 0.5 * Material[30].k_d;\n    Material[30].k_r = 0.5 * Material[30].k_d;\n    Material[30].k_rg = 0.5 * Material[30].k_r;\n    Material[30].n = 64.0;\n    \n    \n    \n    \n    \n    //First step\n    if(t<=first_turn){\n    // Light 0.\n    Light[0].position = vec3( 6.0, 4.0, -3.0 );\n    Light[0].I_a = vec3( 0.0, 0.0, 0.8 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n    // Light 1.\n    Light[1].position = vec3( -6.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.0, 0.0, 0.8);\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n    // 奇点\n    Sphere[0].center = vec3( 0.0,0.0, 0.0 );\n    Sphere[0].radius = max(0.1,(t+delay)/2.0*abs(sin(120.0 / 60.0 * PI * iTime)));\n    Sphere[0].materialID = 17;\n\n    \n    }\n        \n        if(t > first_turn && t<=second_turn){\n         // Light 2.\n          Light[2].position = vec3( 30.0, 0.0, 5.0 );\n        Light[2].I_a = vec3( 1.0, 1.0, 1.0 );\n        Light[2].I_source = vec3( 1.0, 1.0, 1.0 );\n\n        // Light 3.\n        Light[3].position = vec3( 28.0,0.0, 3.0 );\n        Light[3].I_a = vec3( 1.0, 1.0, 1.0);\n        Light[3].I_source = vec3( 1.0, 1.0, 1.0 );\n\n            //左上侧镜面\n //           Plane[1].A = 1.0;\n //           Plane[1].B = 1.0;\n //           Plane[1].C = 1.0;\n //           Plane[1].D = 42.0;\n //           Plane[1].materialID = 16;\n            //右上侧镜面\n //           Plane[2].A = -1.0;\n //           Plane[2].B = 1.0;\n //           Plane[2].C = 1.0;\n  //          Plane[2].D = 42.0;\n  //          Plane[2].materialID = 16;\n            //右下角镜面\n //           Plane[3].A = -1.0;\n  //          Plane[3].B = 1.0;\n    //        Plane[3].C = -1.0;\n     //       Plane[3].D = 42.0;\n       //     Plane[3].materialID = 16;\n            //左下角镜面\n         //   Plane[3].A = 1.0;\n           // Plane[3].B = 1.0;\n           // Plane[3].C = -1.0;\n           // Plane[3].D = 42.0;\n           // Plane[3].materialID = 16;\n        \n        \n        \n        float height= highest-(highest-lowest)*(t-first_turn)/(second_turn-first_turn);\n        if( t <(first_turn +boost) ){\n            float BOOST = (-(t-first_turn)*(t-first_turn)+2.0*boost*(t-first_turn))/boostpara;//Symmetry axis to be 5 after first_turn && distance to be 25*5/parameter\n            \n            \n            Sphere[0].center = vec3( 0.0,height, 0.0 );\n            Sphere[0].radius = 6.0;\n            Sphere[0].materialID = 1;\n\n            //mercary\n            Sphere[1].center = vec3( pow(Rpow,(t-tBegin-7.0*tStep)/rs) * cos(AS*(t-tBegin-7.0*tStep)) , IP-(t-tBegin-7.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-7.0*tStep)/rs) * sin(AS*(t-tBegin-7.0*tStep)) );\n            Sphere[1].center = Sphere[1].center + Sphere[0].center ;\n            Sphere[1].radius = 0.5+radius_con;\n            Sphere[1].materialID = 18;\n\n            //venus\n            Sphere[2].center = vec3( pow(Rpow,(t-tBegin-6.0*tStep)/rs) * cos(AS*(t-tBegin-6.0*tStep)) , IP-(t-tBegin-6.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-6.0*tStep)/rs) * sin(AS*(t-tBegin-6.0*tStep)) );\n            Sphere[2].center = Sphere[2].center + Sphere[0].center ;\n            Sphere[2].radius = 0.7+radius_con;\n            Sphere[2].materialID = 19;\n\n            //earth\n            Sphere[3].center = vec3( pow(Rpow,(t-tBegin-5.0*tStep)/rs) * cos(AS*(t-tBegin-5.0*tStep)) , IP-(t-tBegin-5.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-5.0*tStep)/rs) * sin(AS*(t-tBegin-5.0*tStep)) );\n            Sphere[3].center = Sphere[3].center + Sphere[0].center ;\n            Sphere[3].radius = 1.0+radius_con;\n            Sphere[3].materialID = 20;\n\n            //mars\n            Sphere[4].center = vec3( pow(Rpow,(t-tBegin-4.0*tStep)/rs) * cos(AS*(t-tBegin-4.0*tStep)) , IP-(t-tBegin-4.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-4.0*tStep)/rs) * sin(AS*(t-tBegin-4.0*tStep)) );\n            Sphere[4].center = Sphere[4].center + Sphere[0].center ;\n            Sphere[4].radius = 0.7+radius_con;\n            Sphere[4].materialID = 21;\n\n            //jupiter\n            Sphere[5].center = vec3( pow(Rpow,(t-tBegin-3.0*tStep)/rs) * cos(AS*(t-tBegin-3.0*tStep)) , IP-(t-tBegin-3.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-3.0*tStep)/rs) * sin(AS*(t-tBegin-3.0*tStep)) );\n            Sphere[5].center = Sphere[5].center + Sphere[0].center ;\n            Sphere[5].radius =2.0+radius_con;\n            Sphere[5].materialID = 22;\n\n            //saturn\n            Sphere[6].center = vec3( pow(Rpow,(t-tBegin-2.0*tStep)/rs) * cos(AS*(t-tBegin-2.0*tStep)) , IP-(t-tBegin-2.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-2.0*tStep)/rs) * sin(AS*(t-tBegin-2.0*tStep)) );\n            Sphere[6].center = Sphere[6].center + Sphere[0].center ;\n            Sphere[6].radius = 1.7+radius_con;\n            Sphere[6].materialID = 23;\n\n            //uranus\n\n            Sphere[7].center = vec3( pow(Rpow,(t-tBegin-1.0*tStep)/rs) * cos(AS*(t-tBegin-1.0*tStep)) , IP-(t-tBegin-1.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-1.0*tStep)/rs) * sin(AS*(t-tBegin-1.0*tStep)) );\n            Sphere[7].center = Sphere[7].center + Sphere[0].center ;\n            Sphere[7].radius = 1.3+radius_con;\n            Sphere[7].materialID = 24;\n\n            //neptune\n\n            Sphere[8].center = vec3( pow(Rpow,(t-tBegin-0.0*tStep)/rs) * cos(AS*(t-tBegin-0.0*tStep)) , IP-(t-tBegin-0.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-0.0*tStep)/rs) * sin(AS*(t-tBegin-0.0*tStep)) );\n            Sphere[8].center = Sphere[8].center + Sphere[0].center ;\n            Sphere[8].radius =1.5+radius_con;\n            Sphere[8].materialID = 25;\n\n            ////mercary\n            Sphere[11].center = vec3( pow(Rpow,(t-tBegin-8.0*tStep)/rs) * cos(AS*(t-tBegin-8.0*tStep)) , IP-(t-tBegin-8.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-8.0*tStep)/rs) * sin(AS*(t-tBegin-8.0*tStep)) );\n            Sphere[11].center = Sphere[11].center + Sphere[0].center ;\n            Sphere[11].radius = 0.5+radius_con;\n            Sphere[11].materialID = 26;\n\n            //venus\n            Sphere[12].center = vec3( pow(Rpow,(t-tBegin-9.0*tStep)/rs) * cos(AS*(t-tBegin-9.0*tStep)) , IP-(t-tBegin-9.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-9.0*tStep)/rs) * sin(AS*(t-tBegin-9.0*tStep)) );\n            Sphere[12].center = Sphere[12].center + Sphere[0].center ;\n            Sphere[12].radius = 0.7+radius_con;\n            Sphere[12].materialID = 27;\n\n            //earth\n            Sphere[13].center = vec3( pow(Rpow,(t-tBegin-10.0*tStep)/rs) * cos(AS*(t-tBegin-10.0*tStep)) , IP-(t-tBegin-10.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-10.0*tStep)/rs) * sin(AS*(t-tBegin-10.0*tStep)) );\n            Sphere[13].center = Sphere[13].center + Sphere[0].center ;\n            Sphere[13].radius = 1.0+radius_con;\n            Sphere[13].materialID = 28;\n\n            //mars\n            Sphere[14].center = vec3( pow(Rpow,(t-tBegin-11.0*tStep)/rs) * cos(AS*(t-tBegin-11.0*tStep)) , IP-(t-tBegin-11.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-11.0*tStep)/rs) * sin(AS*(t-tBegin-11.0*tStep)) );\n            Sphere[14].center = Sphere[14].center + Sphere[0].center ;\n            Sphere[14].radius = 0.7+radius_con;\n            Sphere[14].materialID = 29;\n\n            //jupiter\n            Sphere[15].center = vec3( pow(Rpow,(t-tBegin-12.0*tStep)/rs) * cos(AS*(t-tBegin-12.0*tStep)) , IP-(t-tBegin-12.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-12.0*tStep)/rs) * sin(AS*(t-tBegin-12.0*tStep)) );\n            Sphere[15].center = Sphere[15].center + Sphere[0].center ;\n            Sphere[15].radius =2.0+radius_con;\n            Sphere[15].materialID = 30;\n\n            //saturn\n            Sphere[16].center = vec3( pow(Rpow,(t-tBegin-13.0*tStep)/rs) * cos(AS*(t-tBegin-13.0*tStep)) ,IP-(t-tBegin-13.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-13.0*tStep)/rs) * sin(AS*(t-tBegin-13.0*tStep)) );\n            Sphere[16].center = Sphere[16].center + Sphere[0].center ;\n            Sphere[16].radius = 1.7;\n            Sphere[16].materialID = 25;\n\n        }\n        else{\n            //70s to\n            // sun\n            Sphere[0].center = vec3( 0.0,height, 0.0 );\n            Sphere[0].radius = 6.0;\n            Sphere[0].materialID = 1;\n\n            //mercary\n            Sphere[1].center = vec3( pow(Rpow,(t-tBegin-7.0*tStep)/rs) * cos(AS*(t-tBegin-7.0*tStep)) , IP-(t-tBegin-7.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-7.0*tStep)/rs) * sin(AS*(t-tBegin-7.0*tStep)) );\n            Sphere[1].center = Sphere[1].center + Sphere[0].center ;\n            Sphere[1].radius = 0.5+radius_con;\n            Sphere[1].materialID = 18;\n\n            //venus\n            Sphere[2].center = vec3( pow(Rpow,(t-tBegin-6.0*tStep)/rs) * cos(AS*(t-tBegin-6.0*tStep)) , IP-(t-tBegin-6.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-6.0*tStep)/rs) * sin(AS*(t-tBegin-6.0*tStep)) );\n            Sphere[2].center = Sphere[2].center + Sphere[0].center ;\n            Sphere[2].radius = 0.7+radius_con;\n            Sphere[2].materialID = 19;\n\n            //earth\n            Sphere[3].center = vec3( pow(Rpow,(t-tBegin-5.0*tStep)/rs) * cos(AS*(t-tBegin-5.0*tStep)) , IP-(t-tBegin-5.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-5.0*tStep)/rs) * sin(AS*(t-tBegin-5.0*tStep)) );\n            Sphere[3].center = Sphere[3].center + Sphere[0].center ;\n            Sphere[3].radius = 1.0+radius_con;\n            Sphere[3].materialID = 20;\n\n            //mars\n            Sphere[4].center = vec3( pow(Rpow,(t-tBegin-4.0*tStep)/rs) * cos(AS*(t-tBegin-4.0*tStep)) , IP-(t-tBegin-4.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-4.0*tStep)/rs) * sin(AS*(t-tBegin-4.0*tStep)) );\n            Sphere[4].center = Sphere[4].center + Sphere[0].center ;\n            Sphere[4].radius = 0.7+radius_con;\n            Sphere[4].materialID = 21;\n\n            //jupiter\n            Sphere[5].center = vec3( pow(Rpow,(t-tBegin-3.0*tStep)/rs) * cos(AS*(t-tBegin-3.0*tStep)) , IP-(t-tBegin-3.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-3.0*tStep)/rs) * sin(AS*(t-tBegin-3.0*tStep)) );\n            Sphere[5].center = Sphere[5].center + Sphere[0].center ;\n            Sphere[5].radius =2.0+radius_con;\n            Sphere[5].materialID = 22;\n\n            //saturn\n            Sphere[6].center = vec3( pow(Rpow,(t-tBegin-2.0*tStep)/rs) * cos(AS*(t-tBegin-2.0*tStep)) , IP-(t-tBegin-2.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-2.0*tStep)/rs) * sin(AS*(t-tBegin-2.0*tStep)) );\n            Sphere[6].center = Sphere[6].center + Sphere[0].center ;\n            Sphere[6].radius = 1.7+radius_con;\n            Sphere[6].materialID = 23;\n\n            //uranus\n\n            Sphere[7].center = vec3( pow(Rpow,(t-tBegin-1.0*tStep)/rs) * cos(AS*(t-tBegin-1.0*tStep)) , IP-(t-tBegin-1.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-1.0*tStep)/rs) * sin(AS*(t-tBegin-1.0*tStep)) );\n            Sphere[7].center = Sphere[7].center + Sphere[0].center ;\n            Sphere[7].radius = 1.3+radius_con;\n            Sphere[7].materialID = 24;\n\n            //neptune\n\n            Sphere[8].center = vec3( pow(Rpow,(t-tBegin-0.0*tStep)/rs) * cos(AS*(t-tBegin-0.0*tStep)) , IP-(t-tBegin-0.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-0.0*tStep)/rs) * sin(AS*(t-tBegin-0.0*tStep)) );\n            Sphere[8].center = Sphere[8].center + Sphere[0].center ;\n            Sphere[8].radius =1.5+radius_con;\n            Sphere[8].materialID = 25;\n\n            ////mercary\n            Sphere[11].center = vec3( pow(Rpow,(t-tBegin-8.0*tStep)/rs) * cos(AS*(t-tBegin-8.0*tStep)) , IP-(t-tBegin-8.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-8.0*tStep)/rs) * sin(AS*(t-tBegin-8.0*tStep)) );\n            Sphere[11].center = Sphere[11].center + Sphere[0].center ;\n            Sphere[11].radius = 0.5+radius_con;\n            Sphere[11].materialID = 26;\n\n            //venus\n            Sphere[12].center = vec3( pow(Rpow,(t-tBegin-9.0*tStep)/rs) * cos(AS*(t-tBegin-9.0*tStep)) ,IP-(t-tBegin-9.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-9.0*tStep)/rs) * sin(AS*(t-tBegin-9.0*tStep)) );\n            Sphere[12].center = Sphere[12].center + Sphere[0].center ;\n            Sphere[12].radius = 0.7+radius_con;\n            Sphere[12].materialID = 27;\n\n            //earth\n            Sphere[13].center = vec3( pow(Rpow,(t-tBegin-10.0*tStep)/rs) * cos(AS*(t-tBegin-10.0*tStep)) , IP-(t-tBegin-10.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-10.0*tStep)/rs) * sin(AS*(t-tBegin-10.0*tStep)) );\n            Sphere[13].center = Sphere[13].center + Sphere[0].center ;\n            Sphere[13].radius = 1.0+radius_con;\n            Sphere[13].materialID = 28;\n\n            //mars\n            Sphere[14].center = vec3( pow(Rpow,(t-tBegin-11.0*tStep)/rs) * cos(AS*(t-tBegin-11.0*tStep)) , IP-(t-tBegin-11.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-11.0*tStep)/rs) * sin(AS*(t-tBegin-11.0*tStep)) );\n            Sphere[14].center = Sphere[14].center + Sphere[0].center ;\n            Sphere[14].radius = 0.7+radius_con;\n            Sphere[14].materialID = 29;\n\n            //jupiter\n            Sphere[15].center = vec3( pow(Rpow,(t-tBegin-12.0*tStep)/rs) * cos(AS*(t-tBegin-12.0*tStep)) , IP-(t-tBegin-12.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-12.0*tStep)/rs) * sin(AS*(t-tBegin-12.0*tStep)) );\n            Sphere[15].center = Sphere[15].center + Sphere[0].center ;\n            Sphere[15].radius =2.0+radius_con;\n            Sphere[15].materialID = 30;\n\n            //saturn\n            Sphere[16].center = vec3( pow(Rpow,(t-tBegin-13.0*tStep)/rs) * cos(AS*(t-tBegin-13.0*tStep)) , IP-(t-tBegin-13.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-13.0*tStep)/rs) * sin(AS*(t-tBegin-13.0*tStep)) );\n            Sphere[16].center = Sphere[16].center + Sphere[0].center ;\n            Sphere[16].radius = 1.7+radius_con;\n            Sphere[16].materialID = 18;\n            // Circling sphere.\n            //Sphere[1].center = vec3( 3.0+1.5 * cos(iTime), -0.3, 1.5 * sin(iTime) );\n            //Sphere[1].radius = 0.5;\n            //Sphere[1].materialID = 2;\n        }\n    }\n        if(t > second_turn){\n   \n        // Light 2.\n        Light[2].position = vec3( 30.0, 0.0, 5.0 );\n        Light[2].I_a = vec3( 1.0, 1.0, 1.0 );\n        Light[2].I_source = vec3( 1.0, 1.0, 1.0 );\n\n        // Light 3.\n        Light[3].position = vec3( 28.0,0.0, 3.0 );\n        Light[3].I_a = vec3( 1.0, 1.0, 1.0);\n        Light[3].I_source = vec3( 1.0, 1.0, 1.0 );\n        \n        //移动距离/s\n        float height = min(10.0,(highest-lowest)*(t-second_turn)/(music_length-second_turn)+lowest);\n        //底面镜面\n        Plane[0].A = 0.0;\n        Plane[0].B = 1.0;\n        Plane[0].C = 0.0;\n        Plane[0].D = 0.0;\n        Plane[0].materialID = 16;\n        //左上侧镜面\n        Plane[1].A = 0.0;\n        Plane[1].B = 0.0;\n        Plane[1].C = 1.0;\n        Plane[1].D = -50.0;\n        Plane[1].materialID = 16;\n        //右上侧镜面\n//        Plane[2].A = -1.0;\n//        Plane[2].B = 1.0;\n//        Plane[2].C = 1.0;\n//        Plane[2].D = 42.0;\n//        Plane[2].materialID = 16;\n        //右下角镜面\n//        Plane[3].A = -1.0;\n //       Plane[3].B = 1.0;\n//        Plane[3].C = -1.0;\n //       Plane[3].D = 42.0;\n //       Plane[3].materialID = 16;\n        //左下角镜面\n //       Plane[3].A = 1.0;\n//        Plane[3].B = 1.0;\n//        Plane[3].C = -1.0;\n//        Plane[3].D = 42.0;\n//        Plane[3].materialID = 16;\n        // sun\n        Sphere[0].center = vec3( 0.0,height,0.0);\n        Sphere[0].radius = 6.0;\n        Sphere[0].materialID = 1;\n        //mercary\n        Sphere[1].center = vec3( 8.0*cos(iTime),height,8.0*sin(iTime));\n        Sphere[1].radius = 1.0;\n        Sphere[1].materialID = 9;\n\n        //enus\n        Sphere[2].center = vec3( 12.0*cos(2.0*iTime),height,12.0*sin(2.0*iTime));\n        Sphere[2].radius = 1.4;\n        Sphere[2].materialID = 10;\n\n        //earth\n        Sphere[3].center = vec3( 16.0*cos(1.5*iTime),height,16.0*sin(1.5*iTime));\n        Sphere[3].radius = 2.0;\n        Sphere[3].materialID = 11;\n\n        //mars\n        Sphere[4].center = vec3( 21.0*cos(1.2*iTime),height,21.0*sin(1.2*iTime));\n        Sphere[4].radius = 1.4;\n        Sphere[4].materialID = 12;\n\n        //jupiter\n        Sphere[5].center = vec3( 27.0*cos(0.8*iTime),height,27.0*sin(0.8*iTime));\n        Sphere[5].radius = 3.2;\n        Sphere[5].materialID = 13;\n\n        //\n        Sphere[6].center = vec3(35.0*cos(0.7*iTime),height,35.0*sin(0.7*iTime));\n        Sphere[6].radius = 3.0;\n        Sphere[6].materialID = 14;\n\n        //uranus\n //       Sphere[7].center = vec3( *cos(0.5*iTime),height,24.5*sin(0.5*iTime));\n //       Sphere[7].radius = 1.3;\n //       Sphere[7].materialID = 14;\n\n        //neptune\n //       Sphere[8].center = vec3(  28.0,height,0.0);\n //       Sphere[8].radius =1.5;\n //       Sphere[8].materialID = 15;\n        \n        //随机材料选择\n        bool equal = (mod((t-fract(t)),2.0)== 0.0);\n        if(equal){\n            int matrial1 = int(9.0 + mod(10.0 * random(iTime),4.0));\n            int matrial2 = int(9.0 + mod(10.0 * random(iTime+1.0),4.0));\n            int matrial3 = int(9.0 + mod(10.0 * random(iTime+2.0),4.0));\n            int matrial4 = int(9.0 + mod(10.0 * random(iTime+3.0),4.0));\n            int matrial5 = int(9.0 + mod(10.0 * random(iTime+4.0),4.0));\n            int matrial6 = int(9.0 + mod(10.0 * random(iTime+5.0),4.0));\n            int matrial7 = int(9.0 + mod(10.0 * random(iTime+6.0),4.0));\n            int matrial8 = int(9.0 + mod(10.0 * random(iTime+7.0),4.0));\n            int matrial9 = int(9.0 + mod(10.0 * random(iTime+8.0),4.0));\n\n            Sphere[0].materialID = matrial1;\n            Sphere[1].materialID = matrial2;\n            Sphere[2].materialID = matrial3;\n            Sphere[3].materialID = matrial4;\n            Sphere[4].materialID = matrial5;\n            Sphere[5].materialID = matrial6;\n            Sphere[6].materialID = matrial7;\n            Sphere[7].materialID = matrial8;\n            Sphere[8].materialID = matrial9;\n        }\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    //??\n    vec3 origin_dup=ray.o - sph.center;\n    float a = dot(ray.d,ray.d);\n    float b = dot(ray.d,origin_dup)*2.0;\n    float c = dot(origin_dup,origin_dup)- sph.radius*sph.radius;\n    float d= b*b-4.0*a*c;\n    float t0=(-b-sqrt(d))/(2.0*a);\n    float t1=(-b+sqrt(d))/(2.0*a);\n    if(d<0.0){\n        return false;\n    }\n    if(d==0.0)\n    {\n        if(t0<tmin||t0>tmax) return false;\n        else{\n            t = t0;\n            hitPos = ray.o + t0 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        } \n    }\n    if(d>0.0)\n    {\n        //??\n        if(t0>tmin&&t0<tmax)\n        {\n            t = t0;\n            hitPos = ray.o + t0 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        }\n        if(t1>tmin&&t1<tmax)\n        {\n            t = t1;\n            hitPos = ray.o + t1 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        }\n        return false;\n    }\n\n\n    return false;  // Replace this with your code.\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 origin_dup=ray.o - sph.center;\n    float a = dot(ray.d,ray.d);\n    float b = dot(ray.d,origin_dup)*2.0;\n    float c = dot(origin_dup,origin_dup)- sph.radius*sph.radius;\n    float d= b*b-4.0*a*c;\n    float t0=(-b-sqrt(d))/(2.0*a);\n    float t1=(-b+sqrt(d))/(2.0*a);\n    if(d<0.0){\n        return false;\n    }\n    if(d==0.0)\n    {\n        if(t0<tmin||t0>tmax) return false;\n        else{\n            return true;\n        } \n    }\n    if(d>0.0)\n    {\n        if(t0>tmin&&t0<tmax)\n        {\n            return true;\n        }\n        if(t1>tmin&&t1<tmax)\n        {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    vec3 cubemapReflectionColor = texture(iChannel0,ray.d).rgb;\n \n     for(int i=0; i<NUM_PLANES; i++){\n        temp_hasHit = IntersectPlane( Plane[i], ray, DEFAULT_TMIN, nearest_t,\n                         temp_t, temp_hitPos, temp_hitNormal );\n        if(temp_hasHit==true && nearest_t>temp_t){\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            hasHitSomething = temp_hasHit;\n            nearest_hitMatID =  Plane[i].materialID;\n        }\n   }\n\n\n    for(int i=0; i<NUM_SPHERES; i++){\n        temp_hasHit = IntersectSphere( Sphere[i], ray, DEFAULT_TMIN, nearest_t,\n                         temp_t, temp_hitPos, temp_hitNormal );\n        if(temp_hasHit==true && nearest_t>temp_t){\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            hasHitSomething = temp_hasHit;\n            nearest_hitMatID =  Sphere[i].materialID;\n        }\n    }\n\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return cubemapReflectionColor;\n    \n    Ray_t reflect_ray;\n    reflect_ray.o = nearest_hitPos;\n    reflect_ray.d = normalize(reflect(ray.d,nearest_hitNormal));\n\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n\n\n    bool inShadow=false;\n    Ray_t Shadow_ray;\n    \n    for(int i =0 ; i<NUM_LIGHTS; i++){\n        Shadow_ray.o = nearest_hitPos;\n        Shadow_ray.d = normalize(Light[i].position-nearest_hitPos);\n\n       \n       for(int i=0; i<NUM_PLANES; i++){\n            inShadow = IntersectPlane( Plane[i], Shadow_ray, DEFAULT_TMIN, nearest_t);\n            if(inShadow) break;\n        }\n\n        if(!inShadow){\n            for(int i=0; i<NUM_SPHERES; i++){\n                inShadow = IntersectSphere( Sphere[i], Shadow_ray, DEFAULT_TMIN, nearest_t);\n                if(inShadow) break;\n            }\n        }\n\n\n        I_local += PhongLighting( Shadow_ray.d, nearest_hitNormal, -ray.d, inShadow,\n                    Material[nearest_hitMatID],Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    \n //   I_local = mix(cubemapReflectionColor, I_local, step(nearest_t - DEFAULT_TMAX, 0.));\n //   I_local=cubemapReflectionColor;\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length);\n    vec3 cam_pos;\n    vec3 cam_lookat;\n    vec3 cam_up_vec;\n    \n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n     //First step\n    if(t<=first_turn){\n        // Position the camera.\n        // Position the camera.\n        cam_pos = vec3(0.0, 0.0, max(12.0,(20.0-t)) );\n        cam_lookat = Sphere[0].center;\n        cam_up_vec = vec3(0.0, 1.0, 0.0 );\n    \n    }\n    \n   if(t > first_turn && t<=second_turn){\n        // Position the camera.\n        // Position the camera.\n        cam_pos = vec3(50.0*cos(t*0.5), 0.1, 50.0*sin(t*0.5) );\n        cam_lookat = vec3(Sphere[0].center.x,Sphere[0].center.y-5.0,Sphere[0].center.z);\n        cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    }\n\n\n    \n      if(t > second_turn){\n       // cam_pos = vec3( 20.0*(t-second_turn)/(music_length-second_turn)*cos(t*0.8), 0.001+(t-second_turn)/(music_length-second_turn)*(highest-25.0-0.1),20.0*(t-second_turn)/(music_length-second_turn)*cos(t*0.8));\n       cam_pos = vec3( max(20.0,40.0*min(1.0,(t-second_turn)/(music_length-second_turn))*cos(t*0.8)), 0.001+(t-second_turn)/(music_length-second_turn)*(highest-25.0-0.1),max(20.0,40.0*min(1.0,(t-second_turn)/(music_length-second_turn))*sin(t*0.8)));\n       cam_lookat = vec3(Sphere[0].center.x,Sphere[0].center.y,Sphere[0].center.z);\n       cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    }\n\n\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34044, "src": "https://soundcloud.com/louis-liu-319983371/star-sky-orchestral-two-steps-from-hell128-audiotrimmercom-audiotrimmercom", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "const float LuminanceThreshold= 0.6;\n\n/////////////////////////////////////////////////////////////////////////////\n// Approximates the brightness of a RGB value.\n/////////////////////////////////////////////////////////////////////////////\nfloat Luminance( vec3 color )\n{\n    const vec3 LuminanceWeights = vec3(0.2126, 0.7152, 0.0722);\n    return dot(LuminanceWeights, color);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Threshold the original image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  float brightness=Luminance(texture(iChannel0, uv.xy).rgb);\n\n  fragColor = (brightness > LuminanceThreshold)? texture(iChannel0, uv.xy):vec4(0.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const int blurFilterWidth = 51;\nconst int halfWidth = 25;\nfloat weights[blurFilterWidth];\n\n/////////////////////////////////////////////////////////////////////////////\n// 1D gaussian function.\n/////////////////////////////////////////////////////////////////////////////\nfloat gauss(float x, float sigma2)\n{\n    const float PI = 3.1415926535897932384626433832795;\n    float coeff = 1.0 / sqrt(2.0 * PI * sigma2);\n    float expon = -(x * x) / (2.0 * sigma2);\n    return (coeff * exp(expon));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Set up 1D texture map that contains the 1D blur filter.\n/////////////////////////////////////////////////////////////////////////////\nvoid SetUpBlurFilterTexture()\n{\n    float sigma = float(halfWidth) / 2.0;  // Filter spans over 4 sigma (standard deviation).\n    float sigma2 = sigma * sigma;\n\n    float sum = 0.0;\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        float offset=float(i) - float(halfWidth);\n        weights[i] = gauss(offset, sigma2);\n        sum += weights[i];\n    }\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        weights[i] = weights[i] / sum;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Apply horizontal blurring to the threshold image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     \n    //After getting the fragment coordinate of fragment,\n    //Use the middle value of the blurFilterTex on the beginning fragment;\n    ivec2 pix = ivec2(fragCoord.xy);\n    SetUpBlurFilterTexture();\n    \n    vec4 sum = texture(iChannel0, uv) * weights[halfWidth];\n\n    //Apply the 1D Gaussian \n    for( int i = 1; i < halfWidth+1; i++ ) {\n        ivec2 offsetCoord = ivec2(pix.x + i, pix.y);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth+i];\n        offsetCoord = ivec2(pix.x - i, pix.y);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth-i];\n    }\n\n    //fragColor =texelFetch(iChannel0, pix, 0);\n    //fragColor =texture(iChannel2, uv.xy);\n    fragColor = sum;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "const int blurFilterWidth = 51;\nconst int halfWidth = 25;\nfloat weights[blurFilterWidth];\n\n/////////////////////////////////////////////////////////////////////////////\n// 1D gaussian function.\n/////////////////////////////////////////////////////////////////////////////\nfloat gauss(float x, float sigma2)\n{\n    const float PI = 3.1415926535897932384626433832795;\n    float coeff = 1.0 / sqrt(2.0 * PI * sigma2);\n    float expon = -(x * x) / (2.0 * sigma2);\n    return (coeff * exp(expon));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Set up 1D texture map that contains the 1D blur filter.\n/////////////////////////////////////////////////////////////////////////////\nvoid SetUpBlurFilterTexture()\n{\n    float sigma = float(halfWidth) / 2.0;  // Filter spans over 4 sigma (standard deviation).\n    float sigma2 = sigma * sigma;\n\n    float sum = 0.0;\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        float offset=float(i) - float(halfWidth);\n        weights[i] = gauss(offset, sigma2);\n        sum += weights[i];\n    }\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        weights[i] = weights[i] / sum;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Apply horizontal blurring to the threshold image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     \n    //After getting the fragment coordinate of fragment,\n    //Use the middle value of the blurFilterTex on the beginning fragment;\n    ivec2 pix = ivec2(fragCoord.xy);\n    SetUpBlurFilterTexture();\n    \n    vec4 sum = texture(iChannel0, uv) * weights[halfWidth];\n\n    //Apply the 1D Gaussian \n    for( int i = 1; i < halfWidth+1; i++ ) {\n        ivec2 offsetCoord = ivec2(pix.x , pix.y+ i);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth+i];\n        offsetCoord = ivec2(pix.x , pix.y- i);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth-i];\n    }\n\n    //fragColor =texelFetch(iChannel0, pix, 0);\n    //fragColor =texture(iChannel2, uv.xy);\n    fragColor = sum;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// Interstellar\n// Hazel Quantock\n// This code is licensed under the CC0 license http://creativecommons.org/publicdomain/zero/1.0/\n\nfloat max3(vec3 rd) {\n   return max(max(rd.x, rd.y), rd.z);\n}\n/*original  https://www.shadertoy.com/view/XlfGRj */\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.3\n\n#define zoom   2.300\n#define tile   0.250\n#define speed  0.010 \n\n#define brightness 0.0115\n#define darkmatter 0.500\n#define distfading 0.530\n#define saturation 0.750\n\nconst float tau = 6.28318530717958647692;\nconst float music_length=120.0;\nconst float first_turn=16.0;\nconst float second_turn=90.0;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn texture( iChannel0, (vec2(x)+0.5)/256.0, -100.0 );\n}\n\nvec4 Rand( in int x )\n{\n\tvec2 uv;\n\tuv.x = (float(x)+0.5)/256.0;\n\tuv.y = (floor(uv.x)+0.5)/256.0;\n\treturn texture( iChannel0, uv, -100.0 );\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length);\n    //t=t+first_turn;\n      //  t=t+second_turn;\n    \n    if(t<=first_turn){\n        vec3 ray;\n        ray.xy = 2.0*(fragCoord.xy-iResolution.xy*.5)/iResolution.x;\n        ray.z = 1.0;\n\n        float offset = t*.5;\t\n        float speed2 = (cos(offset)+1.0)*2.0;\n        float speed3 = speed2+.1;\n        offset += sin(offset)*.96;\n        offset *= 2.0;\n\n\n        vec3 col = vec3(0);\n\n        vec3 stp = ray/max(abs(ray.x),abs(ray.y));\n\n        vec3 pos = 2.0*stp+.5;\n        for ( int i=0; i < 20; i++ )\n        {\n            float z = Noise(ivec2(pos.xy)).x;\n            z = fract(z-offset);\n            float d = 50.0*z-pos.z;\n            float w = pow(max(0.0,1.0-8.0*length(fract(pos.xy)-.5)),2.0);\n            vec3 c = max(vec3(0),vec3(1.0-abs(d+speed2*.5)/speed3,1.0-abs(d)/speed3,1.0-abs(d-speed2*.5)/speed3));\n            col += 1.5*(1.0-z)*c*w;\n            pos += stp;\n        }\n\n        fragColor = vec4(ToGamma(col),1.0);\n    }\n    if(t>first_turn){\n        vec2 uv=fragCoord.xy/iResolution.xy-.5;\n        uv.y*=iResolution.y/iResolution.x;\n        vec3 dir=vec3(uv*zoom,1.);\n        float time=t*speed+.25;\n\n\n        float a1=.5+iMouse.x/iResolution.x*2.;\n        float a2=.8+iMouse.y/iResolution.y*2.;\n        mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n        mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n        dir.xz*=rot1;\n        dir.xy*=rot2;\n        vec3 from=vec3(1.,.5,0.5);\n        from+=vec3(time*0.,time,time*10.);\n        from.xz*=rot1;\n        from.xy*=rot2;\n\n\n        float s=0.1,fade=1.;\n        vec3 v=vec3(0.);\n        for (int r=0; r<volsteps; r++) {\n            vec3 p=sin(fract(from-s*dir)*1.10);\n            p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n            float pa,a=pa=0.;\n            for (int i=0; i<iterations; i++) { \n                p=abs(p)/dot(p,p*3.1)-formuparam; // the magic formula\n                a+=abs(length(p)+pa); // absolute sum of average change\n                pa=0.2*fract(abs(length(p/2.)));\n            }\n                float dm=max(0.,darkmatter-a*a*.001); //dark matter\n                a*=a*a; // add contrast\n                if (r>10) fade*=1.-dm; // dark matter, don't render near\n                v+=vec3(fract(smoothstep(dm,dm*.1,0.)));\n                v+=fade;\n                v+=vec3(s,1.*fract(s*s),s*s*s)*a*brightness*fade; // coloring based on distance\n                fade*=distfading; // distance fading\n                s+=stepsize;\n            }\n            v=mix(vec3(length(v)),v,saturation); //color adjust\n            fragColor = vec4(v*0.01,1.);\n    }\n\n}", "cube_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 377, 434, 434, 1376]], "test": "untested"}
{"id": "DdjBDy", "name": "Inversion Transformation", "author": "o0CHT0o", "description": "find this trying Inversion Transformation", "tags": ["2d", "math"], "likes": 2, "viewed": 144, "published": 3, "date": "1690093731", "time_retrieved": "2024-07-30T17:43:07.415426", "image_code": "vec2 InvTrans(vec2 pos){\n    //vec2 lt=vec2(iTime/length(pos),atan(pos.y, pos.x));\n    //return lt.x * vec2(sin(lt.y), cos(lt.y));\n    return pos/dot(pos,pos)*iTime; //thank Envy24 \n}\n/*\nfloat sep(float x){\n    return floor(mod(x, 2.))*2.-1.;\n}\n\nvec4 checkerboard(vec2 pos){\n    float l=sep(pos.x)*sep(pos.y);\n    return vec4(l,l,l,1);\n}\n*/\n// Reference https://www.shadertoy.com/view/lt2XWK\nvec4 checkerboard(vec2 pos){\n    float l=mod(floor(pos.x)+floor(pos.y),2.);\n    return vec4(l,l,l,1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    // Output to screen\n    fragColor = checkerboard(InvTrans(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 130, 183], [184, 392, 420, 420, 495], [498, 498, 554, 604, 754]], "test": "untested"}
{"id": "DdjfWy", "name": "SWS3005_05", "author": "afet", "description": "SWS3005_05", "tags": ["sws300505"], "likes": 3, "viewed": 200, "published": 3, "date": "1690091522", "time_retrieved": "2024-07-30T17:43:08.559368", "image_code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    vec4 originalColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 blurColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor = originalColor + blurColor;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\nconst float PI = 3.14159265358979323;\nconst float FOVY = 20.0 * PI / 180.0;\n\n// SDF parameters\nconst float MAX_DIST = 100.0;\nconst int MAX_MARCHING_STEPS = 100;\nconst float EPSILON = 0.001;\nconst float OFFSET_SURFACE = 10.0; // offset for shadow ray and secondary ray\n\n// shadow parameters \n// greater SHADOW_HARDNESS, harder shadow\nconst float SHADOW_HARDNESS = 128.0; \n\n// lava lamp parameters\n// number of lava blobs\nconst uint LAVA_COUNT = 12u;\n\n// normal bump parameters\n// clinderical texture projection is used for normal bump\nconst float THETA0 = -1.7;\nconst float THETA1 = 0.3;\nconst float DELTA_THETA = THETA1 - THETA0;\nconst float HEIGHT0 = 1.175;\nconst float HEIGHT1 = 1.475;\nconst float DELTA_HEIGHT = HEIGHT1 - HEIGHT0;\n\n// scene parameters\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 5;\nconst int NUM_ITERATIONS = 2;\nconst int NUM_DOTS = 90;\n\n// material id\nconst int LAVA_LAMP_BODY = 1;\nconst int LAVA_LAMP_GLASS = 2;\nconst int LAVA_LAMP_LAVA = 3;\nconst int FLOOR = 4;\nconst int BACKGROUND = 0;\n\n// random number generator\n// generate a random number in [0, 1]\nfloat random(uint seed) {\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    return float(seed) / 4294967295.0;\n}\n\n// data structures\n\nstruct Ray_t {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\nstruct Dot_t {\n    vec2 position; // position in screen space [-1, 1]\n    float radius;  // radius in screen space\n    vec3 color;    // color\n};\n\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nDot_t Dots[NUM_DOTS];\n\nvoid InitScene() {\n\n    float radius = 4.0;\n\n    // Light 0.\n    Light[0].position = vec3(cos(iTime) * radius, 10.0, sin(iTime) * radius);\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = vec3(0.4, 0.4, 0.4);\n\n    // Light 1.\n    Light[1].position = vec3(8.0, 8.0, 6.0);\n    Light[1].I_a = vec3(0.1, 0.1, 0.1);\n    Light[1].I_source = vec3(1.0, 1.0, 1.0);\n\n    // background material.\n    Material[0].k_d = vec3(1.0, 1.0, 1.0);\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.01 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Silver material.\n    Material[1].k_d = vec3(0.5, 0.5, 0.5);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Silver material.\n    Material[2].k_d = vec3(1.0, 1.0, 1.0);\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 2.0 * Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 64.0;\n\n     // Lava material.\n    Material[3].k_d = vec3(0.0, 1.0, 0.0);\n    Material[3].k_a = 0.9 * Material[3].k_d;\n    Material[3].k_r = vec3(0.0, 1.0, 0.0);\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n\n    // floor material.\n    Material[4].k_d = vec3(0.1, 0.1, 0.1);\n    Material[4].k_a = 0.1 * Material[4].k_d;\n    Material[4].k_r = vec3(1.0, 1.0, 1.0);\n    Material[4].k_rg = 0.9 * Material[4].k_r;\n    Material[4].n = 128.0;\n\n    // Dots\n    for (uint i = 0u; i < uint(NUM_DOTS); i++) {\n        float x = random(i) * 4.0 - 2.0 + 0.05 * sin(iTime + random(i) * 100.0) * sin(iTime + random(i) * 200.0);\n        float y = random(i * 2u) * 2.0 - 1.0 + 0.05 * sin(iTime + random(i) * 100.0) * cos(iTime + random(i) * 200.0);\n\n        Dots[i].position = vec2(x, y);\n        Dots[i].radius = random(i * 3u) * 0.06 + 0.03;\n\n        float r = random(i + 4u) * (0.4 - 0.2) + 0.2;\n        float g = random(i + 3u) * (0.8 - 0.4) + 0.4;\n        float b = random(i + 2u) * (1.0 - 0.6) + 0.6;\n        Dots[i].color = vec3(r, g, b);\n    }\n\n}\n\n//=================== Signed Distance Functions primitives ==================\n// reference: https://iquilezles.org/articles/distfunctions\n\n// signed distance functions operations\nfloat sdfUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdfIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\n// signed distance functions for primitives\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if (k < 0.0)\n        return length(q) - r1;\n    if (k > a * h)\n        return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a, b)) - r1;\n}\n//===========================================================================\n\n// signed distance function of lava lamp's glass\nfloat sdLavaLampGlass(vec3 p) {\n    // side \n    float d0 = sdRoundCone(p, 0.423, 0.15, 1.6);\n    float d1 = sdPlane(p, vec3(0.0, -1.0, 0.0), 1.2);\n    float d2 = sdPlane(p, vec3(0.0, 1.0, 0.0), -0.0);\n    float d3 = sdfIntersection(d0, -d1, 0.01);\n    return sdfIntersection(d3, -d2, 0.01);\n}\n\n// signed distance function of lava lamp's body\nfloat sdLavaLampBody(vec3 p) {\n    // body shape\n    float d0 = sdRoundCone(p, 0.423, 0.15, 1.6);\n\n    // top\n    float d1 = sdPlane(p, normalize(vec3(0.5, 1.0, 0.5)), -1.3);\n    float d2 = sdfIntersection(d0, d1, 0.02);\n    float d3 = sdPlane(p, vec3(0.0, -1.0, 0.0), 1.2);\n    float d4 = sdfIntersection(d2, d3, 0.01);\n\n    // bottom\n    float d5 = sdPlane(p, vec3(0.0, -1.0, 0.0), -0.3);\n    float d6 = sdfIntersection(d0, d5, 0.025);\n    float d7 = sdPlane(p, vec3(0.0, 1.0, 0.0), -0.0);\n    float d8 = sdfIntersection(d6, d7, 0.01);\n    float d9 = -sdSphere(p - vec3(0.0, 0.3, 0.0), 0.5);\n    float d10 = sdfIntersection(d8, d9, 0.01);\n\n    return min(d4, d10);\n}\n\n// signed distance function of lava lamp's with glass\nfloat sdLavaLamp(vec3 p) {\n    return min(sdLavaLampBody(p), sdLavaLampGlass(p));\n}\n\n// signed distance function of lava lamp's lava\nfloat sdLavaLampLava(vec3 p) {\n    float d = MAX_DIST;\n    for (uint i = 1u; i <= LAVA_COUNT; i++) {\n        vec3 offset = vec3(0.223 * random(uint(i)) * cos(float(i) / float(LAVA_COUNT) * 2.0 * PI + iTime * 0.5), 0.4 * sin(float(i) / float(LAVA_COUNT) * 2.0 * PI + iTime * 1.0) + 0.5, 0.223 * random(uint(i)) * sin(float(i) / float(LAVA_COUNT) * 2.0 * PI + iTime * 0.5));\n\n        float radius = 0.123 * random(uint(i)) / ((abs(offset.y) + 0.95) * (abs(offset.y) + 0.95));\n\n        d = sdfUnion(d, sdSphere(p - offset, radius), 0.2);\n    }\n    return d;\n}\n\n// signed distance function of background\n// the background is a round box\nfloat sdBackground(vec3 p) {\n    return sdRoundBox(p - vec3(-0.0, -0.5, -0.0), vec3(1.1, 0.01, 1.1), 0.08);\n}\n\n// signed distance function of the scene with glass\nfloat sceneSDF(vec3 p) {\n    float d0 = min(sdLavaLamp(p), sdLavaLampLava(p));\n    float d1 = min(d0, sdBackground(p));\n    return d1;\n}\n\n// signed distance function of the scene without glass\nfloat sceneSDFWithoutGlass(vec3 p) {\n    float d0 = min(sdLavaLampBody(p), sdLavaLampLava(p));\n    float d1 = min(d0, sdBackground(p));\n    return d1;\n}\n\n// get normal of the scene\nvec3 getNormal(in vec3 pos, in bool withoutGlass) {\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    if (withoutGlass)\n        return normalize(e.xyy * sceneSDFWithoutGlass(pos + e.xyy * ep) +\n            e.yyx * sceneSDFWithoutGlass(pos + e.yyx * ep) +\n            e.yxy * sceneSDFWithoutGlass(pos + e.yxy * ep) +\n            e.xxx * sceneSDFWithoutGlass(pos + e.xxx * ep));\n    else\n        return normalize(e.xyy * sceneSDF(pos + e.xyy * ep) +\n            e.yyx * sceneSDF(pos + e.yyx * ep) +\n            e.yxy * sceneSDF(pos + e.yxy * ep) +\n            e.xxx * sceneSDF(pos + e.xxx * ep));\n}\n\n// normal bump\nvec3 normalBump(vec3 n, vec3 p) {\n    // normal bump\n    if (p.y <= HEIGHT1 && p.y >= HEIGHT0) {\n        // surface's tangent space\n        vec3 T = normalize(cross(p, n));\n        vec3 B = normalize(cross(n, T));\n\n        // cylindrical texture coordinates\n        vec2 textureCord = normalize(p.xz);\n        float angle = -atan(textureCord.y, textureCord.x);\n\n        if (angle >= THETA0 && angle <= THETA1) {\n            vec2 uv = vec2((angle - THETA0) / DELTA_THETA, (p.y - HEIGHT0) / DELTA_HEIGHT);\n            vec3 tangentSpacePerturbation = texture(iChannel0, uv).xyz * 2.0 - 1.0;\n            n = normalize(vec3(tangentSpacePerturbation.x * T +\n                tangentSpacePerturbation.y * B +\n                tangentSpacePerturbation.z * n));\n\n        }\n    }\n    return n;\n}\n\n// get material index of hit point\nint getMaterialIndex(in vec3 pos, in bool withoutGlass) {\n    // hit lava lamp body\n    if (sdLavaLampBody(pos) < EPSILON) {\n        return LAVA_LAMP_BODY;\n    }\n    // hit lava lamp glass\n    else if (!withoutGlass && sdLavaLampGlass(pos) < EPSILON) {\n        return LAVA_LAMP_GLASS;\n    }\n    // hit lava lamp lava\n    else if (sdLavaLampLava(pos) < EPSILON) {\n        return LAVA_LAMP_LAVA;\n    }\n    // hit floor\n    else if (sdBackground(pos) < EPSILON) {\n        return FLOOR;\n    }\n    return BACKGROUND;\n}\n\n// soft shadow\n// reference: https://iquilezles.org/articles/rmshadows\nfloat softshadow(in Ray_t ray, in bool withoutGlass) {\n    float res = 1.0;\n    float t = EPSILON;\n    for (int i = 0; i < 256 && t < MAX_DIST; i++) {\n        float h = withoutGlass ? sceneSDFWithoutGlass(ray.o + ray.d * t) : sceneSDF(ray.o + ray.d * t);\n        if (h < EPSILON)\n            return 0.0;\n        res = min(res, SHADOW_HARDNESS * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// Phong lighting\nvec3 PhongLighting(\n    in vec3 L,\n    in vec3 N,\n    in vec3 V,\n    float shadow,\n    in Material_t mat,\n    in Light_t light\n) {\n    vec3 R = reflect(-L, N);\n    float N_dot_L = max(0.0, dot(N, L));\n    float R_dot_V = max(0.0, dot(R, V));\n    float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\n    return light.I_a * mat.k_a +\n        shadow * light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n}\n\n// find intersection between ray and scene\nbool Intersect(in Ray_t ray, in bool withoutGlass, out vec3 pos, out vec3 normal) {\n    float t = 0.0;\n    float d = 0.0;\n\n    // ray marching\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        pos = ray.o + t * ray.d;\n        d = withoutGlass ? sceneSDFWithoutGlass(pos) : sceneSDF(pos);\n        t += d;\n        if (d < EPSILON || t > MAX_DIST)\n            break;\n    }\n\n    // if we hit something\n    if (t >= 0.0 && d < EPSILON) {\n        pos = ray.o + t * ray.d;\n        normal = getNormal(pos, withoutGlass);\n        // normal bump\n        normal = normalBump(normal, pos);\n        return true;\n    }\n\n    return false;\n}\n\n// cast ray\nvec3 castRay(in Ray_t ray, in bool withoutGlass, in bool insideGlass, out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg, out bool hasHitGlass) {\n    hasHit = Intersect(ray, withoutGlass && insideGlass, hitPos, hitNormal);\n    if (!hasHit)\n        return vec3(texture(iChannel1, ray.d)); // environment map\n\n    // shading\n    vec3 color = vec3(0.0);\n    int materialIndex = getMaterialIndex(hitPos, withoutGlass && insideGlass);\n    hasHitGlass = (materialIndex == LAVA_LAMP_GLASS);\n    if (hasHitGlass) {\n        k_rg = Material[materialIndex].k_rg;\n        return color;\n    }\n\n    // for each light source, make a shadow ray.\n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        vec3 L = normalize(Light[i].position - hitPos);\n        vec3 V = -ray.d;\n        float shadow = softshadow(Ray_t(hitPos + hitNormal * OFFSET_SURFACE * EPSILON, L), withoutGlass);\n        // if the shadow ray hits something, then the point is in shadow.\n        color += PhongLighting(L, hitNormal, V, shadow, Material[materialIndex], Light[i]);\n    }\n\n    k_rg = Material[materialIndex].k_rg;\n    return color;\n}\n\n// background\nvec3 background(vec2 uv) {\n    for (int i = 0; i < NUM_DOTS; i++) {\n        vec2 dir = uv - Dots[i].position;\n        float distence_squr = dot(dir, dir);\n        float radius_squr = Dots[i].radius * Dots[i].radius;\n        if (distence_squr < radius_squr) {\n            return Dots[i].color;\n        }\n    }\n    return vec3(1.0, 0.6, 0.25);\n}\n\nfloat FresnelTerm(vec3 Normal, vec3 ViewDir, float Power) {\n    return 0.1 + 0.9 * pow((1.0 - clamp(dot(normalize(Normal), normalize(ViewDir)), 0.0, 1.0)), Power);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    // Position the camera.\n    float radius = 7.0 + sin(iTime);\n    float starting_angle = -35.0 / 180.0 * PI;\n    float ending_angle = 125.0 / 180.0 * PI;\n    float time = abs(sin(iTime)) * (ending_angle - starting_angle) + starting_angle;\n    vec3 cam_pos = vec3(cos(time) * radius, 4.5, sin(time) * radius);\n    vec3 cam_lookat = vec3(0.0, 0.6, 0.0);\n    vec3 cam_up_vec = vec3(0.05 * sin(iTime), 1.0, 0.05 * cos(iTime));\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n    vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n    vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize(pixel_pos.x * cam_x_axis + pixel_pos.y * cam_y_axis + pixel_pos_z * cam_z_axis);\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    vec3 color_without_glass = vec3(0.0);\n    vec3 color_with_glass = vec3(0.0);\n    vec3 compounded_k_rg = vec3(1.0);\n    Ray_t nextRay = pRay;\n    bool isGlass = false;\n    vec3 glassNormal;\n    bool insideGlass = false;\n\n    // ray tracing without glass\n    for (int level = 0; level <= NUM_ITERATIONS; level++) {\n        bool hasHit, hasHitGlass;\n        vec3 hitPos, hitNormal, k_rg;\n        vec3 I_local = castRay(nextRay, true, insideGlass, hasHit, hitPos, hitNormal, k_rg, hasHitGlass);\n\n        color_without_glass += compounded_k_rg * I_local;\n\n        // if miss hitting something on primary ray, then use background color\n        if (!hasHit) {\n            if (level == 0) {\n               // color_without_glass = background(pixel_pos);\n            }\n            break;\n        }\n\n        compounded_k_rg *= k_rg;\n\n        if (hasHitGlass) {\n            nextRay = Ray_t(hitPos - hitNormal * OFFSET_SURFACE * EPSILON, normalize(refract(nextRay.d, hitNormal, 1.1)));\n            insideGlass = !insideGlass;\n        } else {\n            nextRay = Ray_t(hitPos + hitNormal * OFFSET_SURFACE * EPSILON, normalize(reflect(nextRay.d, hitNormal)));\n        }\n    }\n\n    // ray tracing with glass\n    compounded_k_rg = vec3(1.0);\n    nextRay = pRay;\n    for (int level = 0; level <= NUM_ITERATIONS; level++) {\n        bool hasHit, hasHitGlass;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = castRay(nextRay, false, false, hasHit, hitPos, hitNormal, k_rg, hasHitGlass);\n\n        // if we hit the glass, then we need to calculate the fresnel term\n        // and mix the color with the color without glass\n        // this requires the hit point normal of the glass\n        if (level == 0 && hasHitGlass) {\n            isGlass = true;\n            glassNormal = hitNormal;\n        }\n\n        color_with_glass += compounded_k_rg * I_local;\n\n        // if miss hitting something on primary ray, then use background color\n        if (!hasHit) {\n            if (level == 0) {\n               // color_without_glass = background(pixel_pos);\n            }\n            break;\n        }\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t(hitPos + hitNormal * OFFSET_SURFACE * EPSILON, normalize(reflect(nextRay.d, hitNormal)));\n    }\n\n    // mix the color with glass and the color without glass\n    vec3 I_result;\n\n    if (isGlass) {\n        float fresnel = FresnelTerm(glassNormal, -pRay.d, 6.0);\n        I_result = fresnel * color_with_glass + (1.0 - fresnel) * color_without_glass;\n    } else {\n        I_result = color_without_glass;\n    }\n\n    fragColor = vec4(I_result, 1.0);\n}\n", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\n\nconst float LuminanceThreshold = 0.50;\n\nfloat Luminance(vec3 color) {\n    const vec3 LuminanceWeights = vec3(-0.2, 0.9, -0.2);\n    return dot(LuminanceWeights, color);\n}\n\nvec4 ThresholdImage(in vec2 fragCoord) {\n    // step 1: read from the original image texture\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // step 2: calculate the luminance of the color\n    float luminance = Luminance(color.rgb);\n    // step 3: threshold the luminance\n    if (luminance >= LuminanceThreshold) {\n        return color;\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ThresholdImage(fragCoord);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\nconst int blurFilterWidth = 51;\n\n// Gaussian blur filter\nconst float weight[blurFilterWidth] = float[blurFilterWidth](0.00450533, 0.00527016, 0.00612551, 0.00707425, 0.00811782, 0.0092559, 0.0104862, 0.0118043, 0.0132032, 0.0146738, 0.0162041, 0.0177798, 0.0193843, 0.0209987, 0.0226025, 0.0241736, 0.025689, 0.0271251, 0.0284589, 0.0296678, 0.0307307, 0.0316286, 0.0323451, 0.0328667, 0.0331838, 0.0332901, 0.0331838, 0.0328667, 0.0323451, 0.0316286, 0.0307307, 0.0296678, 0.0284589, 0.0271251, 0.025689, 0.0241736, 0.0226025, 0.0209987, 0.0193843, 0.0177798, 0.0162041, 0.0146738, 0.0132032, 0.0118043, 0.0104862, 0.0092559, 0.00811782, 0.00707425, 0.00612551, 0.00527016, 0.00450533);\n\nvec4 HorizBlurImage(in vec2 fragCoord) {\n    // step 1: map current fragment's coordinates to threshold image's texel coordinates\n    ivec2 pix = ivec2(fragCoord); // current fragment's coordinates\n    int halfWidth = blurFilterWidth / 2;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // step 2: compute convolution\n    for (int i = -halfWidth; i <= halfWidth; i++) {\n        ivec2 offsetPix = pix + ivec2(i, 0); // offset pixel's coordinates\n        color += texelFetch(iChannel0, offsetPix, 0)        // read from threshold image\n        * weight[i + halfWidth]; // read from blur filter\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = HorizBlurImage(fragCoord);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\n\nconst int blurFilterWidth = 51;\n\n// Gaussian blur filter\nconst float weight[blurFilterWidth] = float[blurFilterWidth](0.00450533, 0.00527016, 0.00612551, 0.00707425, 0.00811782, 0.0092559, 0.0104862, 0.0118043, 0.0132032, 0.0146738, 0.0162041, 0.0177798, 0.0193843, 0.0209987, 0.0226025, 0.0241736, 0.025689, 0.0271251, 0.0284589, 0.0296678, 0.0307307, 0.0316286, 0.0323451, 0.0328667, 0.0331838, 0.0332901, 0.0331838, 0.0328667, 0.0323451, 0.0316286, 0.0307307, 0.0296678, 0.0284589, 0.0271251, 0.025689, 0.0241736, 0.0226025, 0.0209987, 0.0193843, 0.0177798, 0.0162041, 0.0146738, 0.0132032, 0.0118043, 0.0104862, 0.0092559, 0.00811782, 0.00707425, 0.00612551, 0.00527016, 0.00450533);\n\nvec4 VertBlurImage(in vec2 fragCoord) {\n    // step 1: map current fragment's coordinates to threshold image's texel coordinates\n    ivec2 pix = ivec2(fragCoord); // current fragment's coordinates\n    int halfWidth = blurFilterWidth / 2;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // step 2: compute convolution\n    for (int i = -halfWidth; i <= halfWidth; i++) {\n        ivec2 offsetPix = pix + ivec2(0, i); // offset pixel's coordinates\n        color += texelFetch(iChannel0, offsetPix, 0)        // read from threshold image\n        * weight[i + halfWidth]; // read from blur filter\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = VertBlurImage(fragCoord);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1062, 1062, 1117, 1117, 1357]], "test": "untested"}
{"id": "cdjBDG", "name": "NUS Disco Room", "author": "snowcharm", "description": "2023 SWS3005 Group 06.\nThe romance of light, shadow, and gems in NUS.", "tags": ["raytracing", "sws3005"], "likes": 1, "viewed": 172, "published": 3, "date": "1690084188", "time_retrieved": "2024-07-30T17:43:09.855902", "image_code": "//============================================================================\n// GROUP NUMBER: 06\n//\n// STUDENT NAME: CAI YUQIN\n// NUS User ID.: t0930312\n//\n// STUDENT NAME: QIU YILUN\n// NUS User ID.: t0930195\n//\n// STUDENT NAME: YANG XUAN\n// NUS User ID.: t0929996\n//\n// COMMENTS TO GRADER:\n// Due to time constraints, the coding style of our program may not be optimal. \n// However, we have ensured the consistency of variable naming and added comments \n// where appropriate to maximize the readability of the code. \n// I believe our code is easy to understand.\n//\n//============================================================================\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\nconst float SIN_30 = 0.5;\nconst float COS_30 = 0.86602540378;\nconst float BLOCK_NUM = 4.0;\nconst float BLOCK_LENGTH = 0.45;\nconst vec3 BACKGROUND_COLOR = vec3(1.0, 1.0, 0.3);\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 23;\nconst int NUM_PLANES = 6;\nconst int NUM_CYLINDERS = 4;\nconst int NUM_SPHERES = 8;\nconst int NUM_TRIANGLES = 12;\nconst int NUM_BOXS = 9;\n\n// Time for the prelude\nconst float PRELUDE_TIME = 11.0;\n\nstruct Ray_t {\n    vec3 o; // Ray origin\n    vec3 d; // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center; // Sphere center\n    float radius; // Sphere radius\n    int materialID;\n};\n\nstruct Cylinder_t {\n    vec3 center; // Cylinder center\n    float radius; // Cylinder radius\n    float height; // Cylinder height\n    int materialID;\n};\n\nstruct Triangle_t {\n    vec3 v0, v1, v2; // Three triangle vertexes\n    int materialID;\n};\n\nstruct Box_t {\n    vec3 radius; // Box raidus\n    int materialID;\n    mat4 M; // transform matrix\n};\n\nstruct Light_t {\n    vec3 position; // Point light 3D position.\n    vec3 I_a; // For Ambient.\n    vec3 I_source; // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCylinder_t Cylinder[NUM_CYLINDERS];\nTriangle_t Diamond[NUM_TRIANGLES];\nBox_t Box[NUM_BOXS];\nBox_t Platform;\nSphere_t Ball;\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n// Generate transform matrix for the box\nmat4 GenerateTransformMatrix(vec3 tranlate, float theta) {\n    return mat4(vec4(cos(theta / 180.0 * PI), 0, sin(theta / 180.0 * PI), 0), vec4(0, 1, 0, 0), vec4(-sin(theta / 180.0 * PI), 0, cos(theta / 180.0 * PI), 0), vec4(0, 0, 0, 1)) * mat4(vec4(1, 0, 0, 0), vec4(0, 1, 0, 0), vec4(0, 0, 1, 0), vec4(tranlate, 1));\n}\n\n// Set the parameters of the material\nvoid setMaterial(in vec3 k_d, in vec3 k_a, in vec3 k_r, in vec3 k_rg, in float n, inout Material_t material_out) {\n    material_out.k_d = k_d;\n    material_out.k_a = k_a;\n    material_out.k_r = k_r;\n    material_out.k_rg = k_rg;\n    material_out.n = n;\n}\n\n// Set the parameters of the box\nvoid setBox(in vec3 radius, in int materialID, in mat4 matrix, inout Box_t box_out) {\n    box_out.radius = radius;\n    box_out.materialID = materialID;\n    box_out.M = matrix;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene() {\n    // Six planes form a closed space for the scene\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 3;\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 5.0;\n    Plane[1].materialID = 3;\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 5.0;\n    Plane[2].materialID = 4;\n    Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 1.0;\n    Plane[3].D = -5.0;\n    Plane[3].materialID = 5;\n    Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = -5.0;\n    Plane[4].materialID = 2;\n    Plane[5].A = 0.0;\n    Plane[5].B = 1.0;\n    Plane[5].C = 0.0;\n    Plane[5].D = -9.0;\n    Plane[5].materialID = 3;\n\n    // Set the paramters of 4 cylinders\n    Cylinder[0].center = vec3(4.0, -0.5, 4.0);\n    Cylinder[0].radius = 0.3;\n    Cylinder[0].height = 10.0;\n    Cylinder[0].materialID = 3;\n    Cylinder[1].center = vec3(-4.0, -0.5, 4.0);\n    Cylinder[1].radius = 0.3;\n    Cylinder[1].height = 10.0;\n    Cylinder[1].materialID = 3;\n    Cylinder[2].center = vec3(4.0, -0.5, -4.0);\n    Cylinder[2].radius = 0.3;\n    Cylinder[2].height = 10.0;\n    Cylinder[2].materialID = 3;\n    Cylinder[3].center = vec3(-4.0, -0.5, -4.0);\n    Cylinder[3].radius = 0.3;\n    Cylinder[3].height = 10.0;\n    Cylinder[3].materialID = 3;\n\n    // Set the paramters of the platform\n    mat4 tranform_matrix = GenerateTransformMatrix(vec3(0.0, 0.0, 0.0), 0.0);\n    Platform.radius = vec3(0.8, 0.8, 0.8);\n    Platform.materialID = 4;\n    Platform.M = tranform_matrix;\n\n    // Set the paramters of the central ball\n    Ball.center = vec3(0.0, 3.25 + abs(0.5 * sin(iTime)), 0.0);\n    Ball.radius = 0.4;\n    Ball.materialID = 1;\n\n    // Set the paramters of 9 boxes in the wall\n    //mid\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -2.5, 2.0), 90.0);\n    float height = texture(iChannel0, vec2(0.07, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 6, tranform_matrix, Box[0]);\n    //center\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -2.5, 0.0), 90.0);\n    height = (texture(iChannel0, vec2(0.01, 0.25)).x - 0.8) * 8.0;\n    setBox(vec3(0.5, 0.51, height), 7, tranform_matrix, Box[1]);\n    //mid\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -2.5, -2.0), 90.0);\n    height = texture(iChannel0, vec2(0.07, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 8, tranform_matrix, Box[2]);\n    //corner\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -4.5, 2.0), 90.0);\n    height = texture(iChannel0, vec2(0.30, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 9, tranform_matrix, Box[3]);\n    //mid\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -4.5, 0.0), 90.0);\n    height = texture(iChannel0, vec2(0.07, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 10, tranform_matrix, Box[4]);\n    //corner\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -4.5, -2.0), 90.0);\n    height = texture(iChannel0, vec2(0.30, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 11, tranform_matrix, Box[5]);\n    //corner\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -0.5, 2.0), 90.0);\n    height = texture(iChannel0, vec2(0.30, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 12, tranform_matrix, Box[6]);\n    //mid\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -0.5, 0.0), 90.0);\n    height = texture(iChannel0, vec2(0.07, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 13, tranform_matrix, Box[7]);\n    //coner\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -0.5, -2.0), 90.0);\n    height = texture(iChannel0, vec2(0.30, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 14, tranform_matrix, Box[8]);\n\n    // Set the paramters of the diamond\n    Diamond[0].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[0].v1 = vec3(0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[0].v2 = vec3(-0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[1].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[1].v1 = vec3(0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[1].v2 = vec3(0.6, 2.8, 0.0);\n    Diamond[2].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[2].v1 = vec3(-0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[2].v2 = vec3(-0.6, 2.8, 0.0);\n    Diamond[3].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[3].v1 = vec3(0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[3].v2 = vec3(-0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[4].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[4].v1 = vec3(0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[4].v2 = vec3(0.6, 2.8, 0.0);\n    Diamond[5].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[5].v1 = vec3(-0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[5].v2 = vec3(-0.6, 2.8, 0.0);\n    Diamond[6].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[6].v1 = vec3(0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[6].v2 = vec3(-0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[7].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[7].v1 = vec3(0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[7].v2 = vec3(0.6, 2.8, 0.0);\n    Diamond[8].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[8].v1 = vec3(-0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[8].v2 = vec3(-0.6, 2.8, 0.0);\n    Diamond[9].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[9].v1 = vec3(0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[9].v2 = vec3(-0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[10].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[10].v1 = vec3(0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[10].v2 = vec3(0.6, 2.8, 0.0);\n    Diamond[11].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[11].v1 = vec3(-0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[11].v2 = vec3(-0.6, 2.8, 0.0);\n    for(int i = 0; i < NUM_TRIANGLES; i++) {\n        Diamond[i].materialID = 1;\n    }\n\n    // Set the paramters of 8 spheres\n    Sphere[0].center = vec3(0.7 + abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), 0.0);\n    Sphere[1].center = vec3(-0.7 - abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), 0.0);\n    Sphere[2].center = vec3(0.0, 3.5 - 2.2 * abs(cos(iTime)), 0.7 + abs(cos(iTime)));\n    Sphere[3].center = vec3(0.0, 3.5 - 2.2 * abs(cos(iTime)), -0.7 - abs(cos(iTime)));\n    Sphere[4].center = vec3(0.7 + abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), 0.7 + abs(cos(iTime)));\n    Sphere[5].center = vec3(-0.7 - abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), 0.7 + abs(cos(iTime)));\n    Sphere[6].center = vec3(0.7 + abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), -0.7 - abs(cos(iTime)));\n    Sphere[7].center = vec3(-0.7 - abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), -0.7 - abs(cos(iTime)));\n    for(int i = 0; i < NUM_SPHERES; i++) {\n        Sphere[i].radius = 0.2;\n        Sphere[i].materialID = i + 15;\n    }\n\n    // Set the paramters of different materials (some are not used)\n    setMaterial(vec3(0.5), vec3(0.1), vec3(1.0), vec3(0.5), 64.0, Material[1]);\n    setMaterial(vec3(0.0, 0.2, 0.2), vec3(0.0, 0.08, 0.08), vec3(0.0, 0.6, 0.6), vec3(0.0, 0.12, 0.12), 64.0, Material[2]);\n    setMaterial(vec3(0.5), vec3(0.1), vec3(1.0), vec3(0.1), 64.0, Material[3]);\n    setMaterial(vec3(0.0, 0.0, 0.0), vec3(0.25164, 0.60648, 0.22648), vec3(0.90, 0.91, 0.99), vec3(0.3), 1.0, Material[4]);\n    setMaterial(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), 0.0, Material[5]);\n    setMaterial(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[6]);\n    setMaterial(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[7]);\n    setMaterial(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[8]);\n    setMaterial(vec3(1.0, 0.0, 1.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[9]);\n    setMaterial(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[10]);\n    setMaterial(vec3(0.2, 0.6, 0.8), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[11]);\n    setMaterial(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[12]);\n    setMaterial(vec3(0.8, 0.4, 0.5), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[13]);\n    setMaterial(vec3(0.3, 0.6, 0.2), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[14]);\n    setMaterial(vec3(1.5, 0.5, 0.5), vec3(0.3, 0.1, 0.1), vec3(3.0, 1.0, 1.0), vec3(1.5, 0.5, 0.5), 64.0, Material[15]);\n    setMaterial(vec3(0.614240, 0.041360, 0.041360), vec3(0.174500, 0.011750, 0.011750), vec3(0.727811, 0.626959, 0.626959), vec3(0.55, 0.55, 0.55), 128.0, Material[16]);\n    setMaterial(vec3(0.3712, 0.008640, 0.3712), vec3(0.053750, 0.001250, 0.053750), vec3(0.614240, 0.041360, 0.041360), vec3(0.55, 0.55, 0.55), 128.0, Material[17]);\n    setMaterial(vec3(0.45, 0.568627, 0.113725), vec3(0.329412, 0.223529, 0.027451), vec3(0.992157, 0.941176, 0.807843), vec3(0.4, 0.4, 0.4), 27.0, Material[18]);\n    setMaterial(vec3(0.8, 0.45, 0.1), vec3(0.24725, 0.1995, 0.0745), vec3(0.7, 0.4, 0.1), vec3(0.55, 0.55, 0.55), 51.2, Material[19]);\n    setMaterial(vec3(0.021500, 0.045500, 0.098000), vec3(0.002, 0.00425, 0.009), vec3(0.089, 0.183, 0.316), vec3(0.2, 0.2, 0.2), 256.0, Material[20]);\n    setMaterial(vec3(0.021500, 0.174500, 0.021500), vec3(0.002, 0.017, 0.002), vec3(0.075680, 0.614240, 0.075680), vec3(0.2, 0.2, 0.2), 256.0, Material[21]);\n    setMaterial(vec3(0.001440, 0.662400, 0.630240), vec3(0.00025, 0.114, 0.108), vec3(0.001440, 0.662400, 0.630240), vec3(0.55, 0.55, 0.55), 128.0, Material[22]);\n\n    // Light 0.\n    Light[0].position = vec3(0.0, 8.0, 0.0);\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = vec3(1.0, 1.0, 1.0);\n\n    // Light 1.\n    Light[1].position = vec3(-4.0, 8.0, 0.0);\n    Light[1].I_a = vec3(0.1, 0.1, 0.1);\n    Light[1].I_source = vec3(1.0, 1.0, 1.0);\n}\n\n//Signed Distance Function of segment shape\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\n//Signed Distance Function of horsehoe shape\nfloat sdHorseshoe(in vec2 p, in vec2 c, in float r, in vec2 w) {\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x) * p;\n    p = vec2((p.y > 0.0 || p.x > 0.0) ? p.x : l * sign(-c.x), (p.x > 0.0) ? p.y : l);\n    p = vec2(p.x, abs(p.y - r)) - w;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n//Signed Distance Function of Letter 'N'\nfloat N_sdf(in vec2 p) {\n    vec2 offset = vec2(-2.0, 0.0);\n    float d = udSegment(p - offset, vec2(-0.6, 1.0), vec2(-0.6, 3.0)) - 0.1;\n    float d1 = udSegment(p - offset, vec2(-0.6, 3.0), vec2(0.6, 1.0)) - 0.1;\n    float d2 = udSegment(p - offset, vec2(0.6, 1.0), vec2(0.6, 3.0)) - 0.1;\n    return min(d2, min(d, d1));\n}\n\n//Signed Distance Function of Letter 'U'\nfloat U_sdf(in vec2 p) {\n    float d = udSegment(p, vec2(-0.6, 1.6), vec2(-0.6, 3.0)) - 0.1;\n    float d1 = sdHorseshoe(p - vec2(0.0, 1.6), vec2(cos(1.6), sin(1.6)), 0.6, vec2(0.1, 0.1));\n    float d2 = udSegment(p, vec2(0.6, 1.6), vec2(0.6, 3.0)) - 0.1;\n    return min(d2, min(d, d1));\n}\n\n////Signed Distance Function of Letter 'S'\nfloat S_sdf(in vec2 p) {\n    vec2 offset = vec2(2.0, 0.0);\n    float d1 = udSegment(p - offset, vec2(-0.6, 1.0), vec2(0.2, 1.0)) - 0.1;\n    float d2 = udSegment(p - offset, vec2(-0.2, 3.0), vec2(0.6, 3.0)) - 0.1;\n    float d3 = udSegment(p - offset, vec2(-0.2, 2.0), vec2(0.2, 2.0)) - 0.1;\n    float d4 = sdHorseshoe(p.yx - offset.yx - vec2(2.5, -0.2), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1));\n    float d5 = sdHorseshoe(-p.yx + offset.yx - vec2(-1.5, -0.2), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1));\n    return min(d1, min(d2, min(d3, min(d4, d5))));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between NUS and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectNUS(in vec2 p) {\n    return N_sdf(p) < 0.0 || U_sdf(p) < 0.0 || S_sdf(p) < 0.0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(\n    in Plane_t pln,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(N);\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(\n    in Sphere_t sph,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    vec3 oc = ray.o - sph.center;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discr = b * b - c;\n    if(discr >= 0.0) {\n        float sqrtd = sqrt(discr);\n        t = -b - sqrtd;\n        hitPos = ray.o + t * ray.d;\n        vec3 normal = normalize(hitPos - sph.center);\n        hitNormal = normal;\n        return (t >= tmin && t <= tmax);\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 oc = ray.o - sph.center;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discr = b * b - c;\n    if(discr >= 0.0) {\n        float sqrtd = sqrt(discr);\n        float t = -b - sqrtd;\n        return (t >= tmin && t <= tmax);\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a cylinder and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectCylinder(in Cylinder_t cyl, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec2 rayOriInSphere = ray.o.xz - cyl.center.xz;\n    float a = dot(ray.d.xz, ray.d.xz);\n    float b = 2.0 * dot(ray.d.xz, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - cyl.radius * cyl.radius;\n    float d = b * b - 4.0 * a * c;\n    if(d < 0.0)\n        return false;\n    float t1 = (-1.0 * b + sqrt(d)) / (2.0 * a);\n    float t2 = (-1.0 * b - sqrt(d)) / (2.0 * a);\n    float finalT;\n    bool isSatisfy = false;\n    if(t1 >= tmin && t1 <= tmax) {\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2 >= tmin && t2 <= tmax) {\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false)\n        return false;\n    t = finalT;\n    hitPos = ray.o + finalT * ray.d;\n    hitNormal = hitPos - cyl.center;\n    if(hitNormal.y - cyl.center.y < 0.0 || hitNormal.y - cyl.center.y > cyl.height)\n        return false;\n    hitNormal.y = 0.0;\n    hitNormal = hitNormal / cyl.radius;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a cylinder and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectCylinder(in Cylinder_t cyl, in Ray_t ray, in float tmin, in float tmax) {\n    vec2 rayOriInSphere = ray.o.xy - cyl.center.xy;\n    float a = dot(ray.d.xy, ray.d.xy);\n    float b = 2.0 * dot(ray.d.xy, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - cyl.radius * cyl.radius;\n    float d = b * b - 4.0 * a * c;\n    if(d < 0.0)\n        return false;\n    float t1 = (-1.0 * b + sqrt(d)) / (2.0 * a);\n    float t2 = (-1.0 * b - sqrt(d)) / (2.0 * a);\n    float finalT;\n    bool isSatisfy = false;\n    if(t1 >= tmin && t1 <= tmax) {\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2 >= tmin && t2 <= tmax) {\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 sco = (box.M * vec4(ray.o, 1.0)).xyz;\n    vec3 scd = normalize((transpose(inverse(box.M)) * vec4(ray.d, 1.0)).xyz);\n    vec3 m = 1.0 / scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * box.radius;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.y, t1.z), t1.x);\n    float tF = min(min(t2.y, t2.z), t2.x);\n    if(tN > tF || tF < 0.0)\n        return false;\n    if(tN < tmin || tN > tmax)\n        return false;\n    t = tN;\n    hitPos = (inverse(box.M) * vec4((sco + t * scd), 1.0)).xyz;\n    hitNormal = (transpose(inverse(box.M)) * vec4((-sign(ray.d) * step(t1.zxy, t1.xyz) * step(t1.yzx, t1.xyz)), 1.0)).xyz;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 sco = (box.M * vec4(ray.o, 1.0)).xyz;\n    vec3 scd = normalize((transpose(inverse(box.M)) * vec4(ray.d, 1.0)).xyz);\n    vec3 m = 1.0 / scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * box.radius;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.y, t1.z), t1.x);\n    float tF = min(min(t2.y, t2.z), t2.x);\n    if(tN > tF || tF < 0.0)\n        return false;\n    if(tN < tmin || tN > tmax)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a triangle and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle(in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 e1 = tri.v1 - tri.v0;\n    vec3 e2 = tri.v2 - tri.v0;\n    vec3 s = ray.o - tri.v0;\n    vec3 s1 = cross(ray.d, e2);\n    vec3 s2 = cross(s, e1);\n    float s1e1 = dot(s1, e1);\n    float s2e2 = dot(s2, e2);\n    float s1s = dot(s1, s);\n    float s2d = dot(s2, ray.d);\n    float s1e1_inv = 1.0 / s1e1;\n    float t0 = s2e2 * s1e1_inv;\n    float t1 = s1s * s1e1_inv;\n    float t2 = s2d * s1e1_inv;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    if(t1 < 0.0 || t2 < 0.0 || t1 + t2 > 1.0)\n        return false;\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = -abs(normalize(cross(e1, e2)));\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a triangle and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle(in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 e1 = tri.v1 - tri.v0;\n    vec3 e2 = tri.v2 - tri.v0;\n    vec3 s = ray.o - tri.v0;\n    vec3 s1 = cross(ray.d, e2);\n    vec3 s2 = cross(s, e1);\n    float s1e1 = dot(s1, e1);\n    float s2e2 = dot(s2, e2);\n    float s1s = dot(s1, s);\n    float s2d = dot(s2, ray.d);\n    float s1e1_inv = 1.0 / s1e1;\n    float t0 = s2e2 * s1e1_inv;\n    float t1 = s1s * s1e1_inv;\n    float t2 = s2d * s1e1_inv;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    if(t1 < 0.0 || t2 < 0.0 || t1 + t2 > 1.0)\n        return false;\n    return true;\n}\n\n// Compute the color of decorated squares\nvec3 squaresColours(vec2 p) {\n    p += vec2(iTime * 0.2);\n    vec3 orange = vec3(1.0, 0.4, 0.1) * 2.0;\n    vec3 purple = vec3(1.0, 0.2, 0.5) * 0.8;\n    float l = pow(0.5 + 0.5 * cos(p.x * 7.0 + cos(p.y) * 8.0) * sin(p.y * 2.0), 4.0) * 2.0;\n    vec3 c = pow(l * (mix(orange, purple, 0.5 + 0.5 * cos(p.x * 40.0 + sin(p.y * 10.0) * 3.0)) +\n        mix(orange, purple, 0.5 + 0.5 * cos(p.x * 20.0 + sin(p.y * 3.0) * 3.0))), vec3(1.2)) * 0.7;\n    c += vec3(1.0, 0.8, 0.4) * pow(0.5 + 0.5 * cos(p.x * 20.0) * sin(p.y * 12.0), 20.0) * 2.0;\n    c += vec3(0.1, 0.5 + 0.5 * cos(p * 20.0)) * vec3(0.05, 0.1, 0.4).bgr * 0.7;\n    return c;\n}\n\n// Compute the color for a better visual effect\nvec3 calculateColor(vec2 p, float border) {\n    float sm = 0.02;\n    vec2 res = vec2(3.5);\n    vec2 ip = floor(p * res) / res;\n    vec2 fp = fract(p * res);\n    float m = 1.0 - max(smoothstep(border - sm, border, abs(fp.x - 0.5)), smoothstep(border - sm, border, abs(fp.y - 0.5)));\n    m += 1.0 - smoothstep(0.0, 0.56, distance(fp, vec2(0.5)));\n    return m * squaresColours(ip);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(\n    in vec3 L,\n    in vec3 N,\n    in vec3 V,\n    in bool inShadow,\n    in Material_t mat,\n    in Light_t light\n) {\n    if(inShadow) {\n        return light.I_a * mat.k_a;\n    } else {\n        vec3 R = reflect(-L, N);\n        float N_dot_L = max(0.0, dot(N, L));\n        float R_dot_V = max(0.0, dot(R, V));\n        float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n        return light.I_a * mat.k_a +\n            light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n// This method will also be based on the plane in which the ray hit,\n// So that the shader can present different visual effects in the different planes (walls)\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(\n    in vec3 L,\n    in vec3 N,\n    in vec3 V,\n    in bool inShadow,\n    in Light_t light,\n    vec3 nearest_hitPos,\n    int hitWhichPlane\n) {\n    Material_t mat = Material[1];\n    vec2 p;\n    if(hitWhichPlane == 0 || hitWhichPlane == 5)\n        p = nearest_hitPos.xz;\n    else if(hitWhichPlane == 1 || hitWhichPlane == 3)\n        p = nearest_hitPos.xy;\n    else if(hitWhichPlane == 2 || hitWhichPlane == 4)\n        p = nearest_hitPos.yz;\n    else if(hitWhichPlane < 0) {\n        p.y = nearest_hitPos.y;\n        p.x = length(nearest_hitPos.xz);\n    }\n    p = p / BLOCK_NUM;\n    mat.k_d = calculateColor(p, BLOCK_LENGTH);\n    mat.k_a = 0.4 * mat.k_d;\n    mat.k_r = 3.0 * mat.k_d;\n    if(inShadow) {\n        return light.I_a * mat.k_a;\n    } else {\n        vec3 R = reflect(-L, N);\n        float N_dot_L = max(0.0, dot(N, L));\n        float R_dot_V = max(0.0, dot(R, V));\n        float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n        return light.I_a * mat.k_a +\n            light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay(\n    in Ray_t ray,\n    out bool hasHit,\n    out vec3 hitPos,\n    out vec3 hitNormal,\n    out vec3 k_rg\n) {\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX; // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;            // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;         // Normal vector at the nearest hit point.\n    int nearest_hitMatID;           // MaterialID of the object at the nearest hit point.\n\n    // Temporary arguments\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n    int hitWhichPlane;\n    // Intersect with the plane\n    for(int i = 0; i < NUM_PLANES; i++) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;\n            hitWhichPlane = i;\n        }\n    }\n    // Intersect with the cylinder\n    for(int i = 0; i < NUM_CYLINDERS; i++) {\n        temp_hasHit = IntersectCylinder(Cylinder[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Cylinder[i].materialID;\n        }\n    }\n    if(iTime >= PRELUDE_TIME) { // A judgement of time for a better performance in the prelude\n        // Intersect with the sphere\n        for(int i = 0; i < NUM_SPHERES; i++) {\n            temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n            if(temp_hasHit && temp_t < nearest_t) {\n                hasHitSomething = true;\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n        //Intersect with the box\n        for(int i = 0; i < NUM_BOXS; i++) {\n            temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n            if(temp_hasHit && temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n                hasHitSomething = true;\n            }\n        }\n        // Intersect with the triangle\n        for(int i = 0; i < NUM_TRIANGLES; i++) {\n            temp_hasHit = IntersectTriangle(Diamond[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n            if(temp_hasHit && temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Diamond[i].materialID;\n                hasHitSomething = true;\n            }\n        }\n        // Intersect with the platform\n        temp_hasHit = IntersectBox(Platform, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Platform.materialID;\n            hasHitSomething = true;\n        }\n        // Intersect with the central ball\n        temp_hasHit = IntersectSphere(Ball, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Ball.materialID;\n            hasHitSomething = true;\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if(!hasHitSomething)\n        return BACKGROUND_COLOR;\n\n    /* Drawing NUS in the plane*/\n    vec2 p = nearest_hitPos.xy;\n    if(hitWhichPlane == 3) { // Judge an intersection in a special plane (for drawing)\n        if(iTime < 3.0) {\n            if((udSegment(p, vec2(3.5, 2.0), vec2(3.5, 2.0 + iTime * (2.0 / 3.0))) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(0.5, 4.0), vec2(0.5, 4.0 - iTime * (1.4 / 3.0))) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n\n        } else if(iTime < 6.0 && iTime >= 3.0) {\n            if((udSegment(p, vec2(3.5, 2.0), vec2(3.5, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(3.5, 4.0), vec2(3.5 - (iTime - 3.0) * (2.0 / 3.0), 6.0 - iTime * (2.0 / 3.0))) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(0.5, 4.0), vec2(0.5, 2.6)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p - vec2(-0.1, 2.5), vec2(cos(1.6 * (iTime - 3.0) / 3.0), sin(1.6 * (iTime - 3.0) / 3.0)), 0.6, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 6.0 && iTime < 10.0) {\n            if((udSegment(p, vec2(3.5, 2.0), vec2(3.5, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(3.5, 4.0), vec2(1.5, 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(1.5, 2.0), vec2(1.5, 2.0 + (iTime - 6.0) / 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(0.5, 4.0), vec2(0.5, 2.6)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p - vec2(-0.1, 2.5), vec2(cos(1.6), sin(1.6)), 0.6, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-0.7, 2.6), vec2(-0.7, 2.6 + (iTime - 6.0) * (1.4 / 4.0))) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 10.0 && iTime < PRELUDE_TIME) {\n            if((udSegment(p, vec2(3.5, 2.0), vec2(3.5, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(3.5, 4.0), vec2(1.5, 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(1.5, 2.0), vec2(1.5, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(0.5, 4.0), vec2(0.5, 2.6)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p - vec2(-0.1, 2.5), vec2(cos(1.6), sin(1.6)), 0.6, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-0.7, 2.6), vec2(-0.7, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else {\n            Material[5].k_d = Material[1].k_d;\n            Material[5].k_a = Material[1].k_a;\n            Material[5].k_r = Material[1].k_r;\n            Material[5].k_rg = Material[1].k_rg;\n            Material[5].n = Material[1].n;\n        }\n    }\n    if(hitWhichPlane == 3) {\n        if(iTime < 2.0) {\n            if((udSegment(p, vec2(-3.1 + iTime * (0.9 / 2.0), 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 2.0 && iTime < 4.0) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6 * (iTime - 2.0) / 2.0), sin(1.6) * (iTime - 2.0) / 2.0), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 4.0 && iTime < 6.0) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-2.2, 3.0), vec2(-2.2 - (iTime - 4.0) * (0.9 / 2.0), 3.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 6.0 && iTime < 8.0) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-2.1, 3.0), vec2(-3.1, 3.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p.yx - vec2(2.5, -3.1), vec2(cos(1.6 * (iTime - 6.0) / 2.0), sin(1.6) * (iTime - 6.0) / 2.0), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 8.0 && iTime < 10.0) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-2.2, 3.0), vec2(-3.1, 3.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p.yx - vec2(2.5, -3.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-3.1, 2.0), vec2(-3.1 + (iTime - 8.0) * (1.2 / 2.0), 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 10.0 && iTime < PRELUDE_TIME) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-2.2, 3.0), vec2(-3.1, 3.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p.yx - vec2(2.5, -3.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-3.1, 2.0), vec2(-3.1 + (10.0 - 8.0) * (1.2 / 2.0), 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else {\n            Material[5].k_d = Material[1].k_d;\n            Material[5].k_a = Material[1].k_a;\n            Material[5].k_r = Material[1].k_r;\n            Material[5].k_rg = Material[1].k_rg;\n            Material[5].n = Material[1].n;\n        }\n    }\n    if(hitWhichPlane == 4) {\n        if(IntersectNUS(nearest_hitPos.zy)) {\n            nearest_hitNormal = vec3(-1.0, 0.0, 0.0);\n            Material[2].k_d = vec3(0.9, 0.8, 0.0);\n            Material[2].k_a = 0.0 * Material[2].k_d;\n            Material[2].k_r = 0.0 * Material[2].k_d;\n            Material[2].k_rg = 0.0 * Material[2].k_r;\n            Material[2].n = 128.0;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n    vec3 I_local = vec3(0.0); // Result color will be accumulated here.\n    Ray_t shadowRay;\n    shadowRay.o = nearest_hitPos;\n    for(int i = 0; i < NUM_LIGHTS; i++) {\n        bool inShadow = false, tempInShadow;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        float LineSegmentMin = DEFAULT_TMIN;\n        float LineSegmentMax = length(Light[i].position - nearest_hitPos);\n        if(iTime >= PRELUDE_TIME) {\n            for(int j = 0; j < NUM_SPHERES; j++) {\n                if(inShadow)\n                    break;\n                tempInShadow = IntersectSphere(Sphere[j], shadowRay, LineSegmentMin, LineSegmentMax);\n                if(tempInShadow)\n                    inShadow = true;\n            }\n            for(int j = 0; j < NUM_BOXS; j++) {\n                if(inShadow)\n                    break;\n                tempInShadow = IntersectBox(Box[j], shadowRay, LineSegmentMin, LineSegmentMax);\n                if(tempInShadow)\n                    inShadow = true;\n            }\n            for(int j = 0; j < NUM_TRIANGLES; j++) {\n                if(inShadow)\n                    break;\n                tempInShadow = IntersectTriangle(Diamond[j], shadowRay, LineSegmentMin, LineSegmentMax);\n                if(tempInShadow)\n                    inShadow = true;\n            }\n            tempInShadow = IntersectBox(Platform, shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow)\n                inShadow = true;\n            tempInShadow = IntersectSphere(Ball, shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow)\n                inShadow = true;\n        }\n        for(int j = 0; j < NUM_PLANES; j++) {\n            if(inShadow)\n                break;\n            tempInShadow = IntersectPlane(Plane[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow)\n                inShadow = true;\n        }\n        for(int j = 0; j < NUM_CYLINDERS; j++) {\n            if(inShadow)\n                break;\n            tempInShadow = IntersectCylinder(Cylinder[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow)\n                inShadow = true;\n        }\n        vec3 L = normalize(Light[i].position - nearest_hitPos);\n        vec3 N = normalize(nearest_hitNormal);\n        vec3 V = normalize(-ray.d);\n        if(nearest_hitMatID == 3) {\n            I_local += PhongLighting(L, N, V, inShadow, Light[i], nearest_hitPos, hitWhichPlane);\n        } else {\n            I_local += PhongLighting(L, N, V, inShadow, Material[nearest_hitMatID], Light[i]);\n        }\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    return I_local;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera (animation)\n    vec3 cam_pos, cam_lookat, cam_up_vec;\n    if(iTime < PRELUDE_TIME) {\n        cam_pos = vec3(0, 3.1, -1.5);\n        cam_lookat = vec3(0.0, 3.1, 5.0);\n        cam_up_vec = vec3(0.0, 1.0, 0.0);\n    } else {\n        float time = iTime - PRELUDE_TIME;\n        if(mod((time / 20.0), 2.0) >= 1.0 && time > 20.0) {\n            cam_pos = vec3(3.5 * cos(time * 0.3), 5.0, 3.5 * sin(time * 0.3));\n            cam_lookat = vec3(0.0, 2.0 + cos(time), 0.0);\n            cam_up_vec = vec3(0.0, 1.0, 0.0);\n        } else {\n            cam_pos = vec3(0, 5.0, 0);\n            cam_lookat = vec3(5.0 * sin(time * 0.3), 2.0, 5.0 * cos(time * 0.3));\n            cam_up_vec = vec3(0.0, 1.0, 0.0);\n        }\n    }\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n    vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n    vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize(pixel_pos.x * cam_x_axis + pixel_pos.y * cam_y_axis + pixel_pos_z * cam_z_axis);\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    vec3 I_result = vec3(0.0);\n    vec3 compounded_k_rg = vec3(1.0);\n    Ray_t nextRay = pRay;\n    for(int level = 0; level <= NUM_ITERATIONS; level++) {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        vec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n        I_result += compounded_k_rg * I_local;\n        if(!hasHit)\n            break;\n        compounded_k_rg *= k_rg;\n        nextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n    }\n    fragColor = vec4(I_result, 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3939, 3980, 4038, 4038, 4298], [4300, 4338, 4452, 4452, 4592], [4594, 4627, 4712, 4712, 4804], [4806, 4988, 5006, 5058, 14742], [14744, 14788, 14838, 14838, 14972], [14974, 15019, 15083, 15083, 15350], [15352, 15393, 15417, 15417, 15716], [15718, 15759, 15783, 15783, 16047], [16049, 16092, 16116, 16116, 16658], [16660, 16988, 17018, 17018, 17083], [17085, 17581, 17742, 17742, 18028], [18030, 18362, 18443, 18443, 18654], [18656, 19174, 19337, 19337, 19750], [19752, 20085, 20168, 20168, 20469], [20471, 20991, 21128, 21128, 22067], [22069, 22404, 22491, 22491, 23171], [23173, 23688, 23815, 23815, 24471], [24473, 24803, 24880, 24880, 25337], [25339, 25859, 25996, 25996, 26627], [26629, 26964, 27051, 27051, 27589], [27591, 27633, 27662, 27662, 28260], [28262, 28310, 28353, 28353, 28691], [28693, 29047, 29181, 29181, 29569], [29571, 30085, 30244, 30244, 31168], [31170, 31959, 32078, 32169, 57898], [57900, 58261, 58316, 58316, 60277]], "test": "untested"}
{"id": "dsBfDG", "name": "Simple Fractal [162 Chars]", "author": "SnoopethDuckDuck", "description": "golfing welcome :)", "tags": ["fractal", "short", "tweet", "golf", "200chars"], "likes": 27, "viewed": 259, "published": 3, "date": "1690068190", "time_retrieved": "2024-07-30T17:43:10.844259", "image_code": "// -1 thanks to coyote\nvoid mainImage( out vec4 O, vec2 I )\n{\n    I = (I+I-(I = iResolution.xy))/I.y;\n    \n    for (O -= O; \n         O.a++ < 18.;\n         O += .5 / exp(60.\n         * dot(\n               I = abs(I *= 1.2*mat2(cos(.1*iTime + vec4(0,-11,11,0))))\n                 - .4,\n               I))\n         );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 61, 61, 317]], "test": "untested"}
{"id": "csBfWy", "name": "Floating Ghost", "author": "bronson113", "description": "floating ghost =D", "tags": ["raymarching", "ghost"], "likes": 3, "viewed": 128, "published": 3, "date": "1690059835", "time_retrieved": "2024-07-30T17:43:11.673043", "image_code": "#define C(x) clamp(x, 0.0, 1.0)\n\n// To control the scean with a mouse, change the 0 to 1\n#define MOUSE 0\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \nvec2 opUnion(vec2 a, vec2 b){\n    return (a.x<b.x)?a:b;\n}\n// SDF of line segment -> capsul\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Droplet -> line segment, but one side with r = 0 and anthoer side with r = r\nfloat sdDroplet( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r*h;\n}\n\n// Mouth shape\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w )\n{\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}\n\nvec2 DistGhost(vec3 location, float time){\n    float k = .01; //roundness\n    vec2 res;\n    \n    // body\n    float radial_change = cos(atan(location.x/location.z)*20.+time*10.+cos(location.y*3.+1.7)*10.);\n    float to_ground = exp(-(location.y+0.5)*10.);\n    float r = 0.48+.02*(radial_change)*C(to_ground)+0.05*to_ground;\n    float dBody = sdCapsule(location, vec3(0., .5, 0.), vec3(0., -.5, 0.), r);\n\n    // eye hole\n    float dEyeH1 = sdCapsule(location, vec3(0.45, .45, 0.2), vec3(0.45, 0.2, 0.2), 0.05);\n    float dEyeH2 = sdCapsule(location, vec3(0.45, .45, -0.2), vec3(0.45, 0.2, -0.2), 0.05);\n    dBody = max(dBody, -dEyeH1);\n    dBody = max(dBody, -dEyeH2);\n    \n    //mouth hole\n    float dMouth = sdCapsule(location, vec3(0.47, -.13, 0.13), vec3(0.47, -.13, -0.13), 0.02);\n    dBody = opSmoothSubtraction(dBody, dMouth, k);\n    \n    // float\n    float dFloat = location.y + 0.45 + 0.01*sin(radial_change);\n    dBody = max(dBody, -dFloat);\n    res = vec2(dBody, 1.0);\n    \n    \n    // eye\n    float dEye1 = sdCapsule(location, vec3(0.41, .45, 0.19), vec3(0.41, 0.19, 0.19), 0.04);\n    float dEye2 = sdCapsule(location, vec3(0.41, .45, -0.19), vec3(0.41, 0.19, -0.19), 0.04);\n    float dEye = min(dEye1, dEye2);\n    res = opUnion(res, vec2(dEye, 2.0));\n    \n    // mouth\n    float dMouth2 = sdVesicaSegment(location, vec3(0.43, -.13, -0.13), vec3(0.43, -.13, 0.13), 0.05);\n    res = opUnion(res, vec2(dMouth2, 3.0));\n    \n    // water droplet\n    float dDrop = sdDroplet(location, vec3(0.42, -.11, -0.1), vec3(0.465, -.18, -0.1), 0.02);\n    res = opUnion(res, vec2(dDrop, 4.0));\n    \n    \n    \n    return res;\n}\n\nvec2 Dist(vec3 location, float time){    \n    float offset = pow(abs(sin(time*.6)), 2.)*3.-5.;\n    vec2 dGhost = DistGhost(location + vec3(0., offset, 0.)*.1, time);\n    \n    float dFloor = location.y + 0.50;\n    vec2 res = opUnion(dGhost, vec2(dFloor, 0.0));\n    \n    return res;\n}\n\n// get the gradiant of the distant -> normal vector of that \"surface\"\nvec3 Norm(vec3 location, float time){\n/* small step in all direction as our Normal\n    vec2 diff = vec2(0.0005, 0);\n    return normalize( vec3( Dist(location + diff.xyy, time) - Dist(location - diff.xyy, time), \n                            Dist(location + diff.yxy, time) - Dist(location - diff.yxy, time),\n                            Dist(location + diff.yyx, time) - Dist(location - diff.yyx, time)));\n*/\n// https://iquilezles.org/articles/normalsSDF/\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Dist(location+0.0005*e,time).x;\n    }\n    return normalize(n);    \n}\nfloat RayMarching(vec3 ro, vec3 rd, float time){\n    // distant traveled\n    float t = 0.; \n    float maxt = 20.;\n    // ray marching\n    for(float i=0.; i<1000. && t < maxt; i+=1.){\n        // currect location\n        vec3 loc = ro + t*rd;\n        // distant to surface\n        float d = Dist(loc, time).x;\n        \n        // we hit a surface\n        if(d < 0.000001) break;\n        \n        // otherwise march forward\n        t += d;\n    }\n    // max distant: 20, return -1 if didn't hit\n    return t>maxt?-1.:t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float time = iTime;\n\n\n   // camera\t\n\n#if MOUSE==1\n    float an = 10.57*iMouse.x/iResolution.x;\n    float bn = iMouse.y/iResolution.y*1.57;\n    vec3  ta = vec3( 0.0, 0.5, 0.0);                         // pointing at\n    float zoom = 1.;\n    vec3  ro = ta + zoom*vec3( 1.3*cos(an), sin(bn)*2.-0.5, 1.3*sin(an) ); // camera location\n#else\n    float an = time*.392;\n    vec3  ta = vec3( 0.0, 0.5, 0.0);                         // pointing at\n    float zoom = sin(time*.234)*0.5+2.;\n    vec3  ro = ta + zoom*vec3( 1.3*cos(an), sin(an*0.3)*0.4, 1.3*sin(an) ); // camera location\n#endif \n    // frame\n\tvec3 cw = normalize(ta-ro);    // vector pointing toward target\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) ); // vector pointing up\n\tvec3 cv =          ( cross(cu,cw) ); // vector pointing right\n\n    vec3 rd = normalize( p.x*cu + p.y*cv + 1.8*cw ); // actual ray direction from frame\n    \n    \n    // distant to surface\n    float t = RayMarching(ro, rd, time);\n    \n    // sky\n    vec3 col = vec3(0.1, 0.05, 0.03) - max(rd.y,0.0)*0.6;\n    \n    // if we hit something with 20 unit\n    if(t > 0.){\n        // point we hit\n        vec3 loc = ro + rd*t;\n        // normal of that surface\n        vec3 nor = Norm(loc, time);\n        \n        vec2 res = Dist(loc, time);\n        // object color\n        col = vec3(0.0);\n        if(res.y < 0.5){\n            col = vec3(0.03, .12, 0.04);\n        } else if (res.y < 1.5){\n            col = vec3(0.3);\n        } else if (res.y < 2.5){\n            col = vec3(0.01);\n        } else if (res.y < 3.5){\n            col = vec3(.247, .086, .049);\n        } else if (res.y < 4.5){\n            col = vec3(.124, .202, .235);\n        }\n        \n        vec3 lightin = vec3(0.);\n        // moon at 10. 10. -5.\n        vec3 moon_loc = vec3(10., 10., -5.);\n        vec3 moon_dir = normalize(moon_loc-loc);\n        float moon_diffuse = C(dot(moon_dir, nor));\n        \n        //shadow\n        float can_see_moon = step(RayMarching(loc+0.001*moon_dir, moon_dir, time), 0.);\n        \n        // sky\n        float sky_diffuse = C(dot(normalize(vec3(0., 1., 0.)), nor));\n        float sky_diffuse2 = C(dot(normalize(vec3(0., 1., 1.)), nor));\n        \n        // general bounced light\n        float bounced = C(dot(normalize(vec3(0., -1., 0.)), nor));\n        \n        \n        lightin += vec3(5., 5., 4.) * moon_diffuse * can_see_moon;\n        lightin += vec3(0.2, 0.1, .5) * sky_diffuse;\n        lightin += vec3(0.1, 0.15, .25) * sky_diffuse2;\n        lightin += vec3(0.6, 0.4, 0.2) * bounced;\n        col *= lightin;\n        col = mix( col, vec3(0.7,0.4,0.3), 1.0-exp( -0.0001*pow(t, 3.) ) );\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 157, 209, 209, 308], [310, 310, 368, 368, 468], [470, 470, 529, 529, 628], [634, 634, 663, 663, 691], [692, 725, 777, 777, 898], [900, 980, 1032, 1032, 1155], [1157, 1172, 1242, 1242, 1551], [1553, 1553, 1595, 1595, 3173], [3175, 3175, 3212, 3212, 3457], [3459, 3529, 3566, 3982, 4210], [4211, 4211, 4259, 4283, 4728], [4730, 4730, 4787, 4787, 7591]], "test": "untested"}
{"id": "cdBfzV", "name": "Cellular Automata 3D", "author": "misol101", "description": "CONTROLS: down/up=next/prev CA, b=box, 7-9=speed, c=color method, v=view, p=pause, space=regen, w/s=zoom, d=shrink(if available), t=text\n\nSize currently limited by pow(xres*yres,1/3), so a 1920x1080 display can process max 127^3 cells.", "tags": ["3d", "interactive", "voxel", "automata"], "likes": 27, "viewed": 338, "published": 3, "date": "1690056117", "time_retrieved": "2024-07-30T17:43:12.620510", "image_code": "\n// Press UP/DOWN for variants.\n\n// More keys: b=box, 7-9=speed, c=color, v=view, p=pause, space=regen, w/s=zoom, d=shrink(only for some CA's)\n\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nbool inverted;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n    return texelFetch(iChannel0, p2, 0 );\n}\n\nbool map(in vec3 p, out float v) \n{\n    p+=5.;// 0 == -5\n\n    vec4 cv = cellval(ivec3(p));\n    if (cv.z > 0.) {\n        v=-1.;\n        return true;\n    }\n\n    if(colmethod == 1) {\n        v=cv.x*0.12; // col by state value\n    } else\n        v=length(p-N/2.)*0.1+1.5; // col by distance\n\n    return !inverted ? cv.x > 0. : int(cv.x) == 0;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 32.; ++i) {\n        if (map(ep, v)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-3., xrot=-0.66;\n    if (view == 1) yp=0., xrot=0.0;\n    if (view == 2) yp=0., xrot=1.;\n\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, yp, -d+zmod);\n\n    float mxc, myc;\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.33))*1.17;\n        myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y, 1./3.));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    colmethod = int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n    inverted = getInverted(int(index));\n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*1.37, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec3 color = vec3(0.03, 0.03, 0.03);\n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n \n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    \n    fragColor += text_pixel;    \n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); return; }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT) ) {\n                    kx+=1.001;\n                    if (kx > LAST_PATT+0.5) kx=0.5;\n                } else {\n                    kx-=1.001;\n                    if (kx < 0.) kx=LAST_PATT+0.5;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = -1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 3.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Automata buffer\n\nint N;\n\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\nconst int KEY_D  = 68;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    return texelFetch(iChannel0, p2, 0 ).x == liveval-1. ? 1 : 0;\n}\n\nint cellwrap( in ivec3 p, int xp,int yp, int zp) {\n    int x=p.x+xp, y=p.y+yp, z=p.z+zp;\n    if (x==0) x=N-2;  if (x==N-1) x=1;\n    if (y==0) y=N-2;  if (y==N-1) y=1;\n    if (z==0) z=N-2;  if (z==N-1) z=1;\n    int n=x+y*N+z*N*N;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    return texelFetch(iChannel0, p2, 0 ).x == liveval-1. ? 1 : 0;\n}\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    return int(texelFetch(iChannel0, p2, 0 ).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y, 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x); \n    if (pos1d > N*N*N) { fragColor = vec4(0.); return; }\n\n    int index = int(texelFetch(iChannel1, ivec2(0,0), 0 ).x);\n    float xres = texelFetch(iChannel0, ivec2(0,0), 0 ).w;\n    int speed = 1+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int bbox = int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n    ivec3 pos3d=ivec3(x,y,z);\n\n    float wv=0.;\n    if (fragCoord.x < 1. && fragCoord.y < 1.) {\n        wv=iResolution.x;\n    }\n\n    // bounding box\n    int NM=N-1;\n    if (x==0 || y==0 || z==0 || x==NM || y==NM || z==NM) { \n        fragColor = vec4(-1.,0.,0.,wv);\n        if (bbox == 1) {\n            if ((x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) )\n                fragColor = vec4(-1.,0.,1.0,wv);\n        }\n        return;\n    }\n\n    setRules(index);\n    if (readKey(KEY_D) && withermethod >= 0) { setRules(withermethod); } //wither\n\n    if (iFrame < 1 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)) {\n        pos3d-=N/2;\n\n        if (hash1(fragCoord.x*0.03*fragCoord.y*0.021+iTime*0.04) < density) {\n            if (clearmethod == 0) {\n                if (length(vec3(pos3d))<radius) {\n                    fragColor = vec4(liveval-1.,0.0,0.0,wv);\n                    return;\n                }\n            } else if (clearmethod == 1) {\n                int iradius=int(radius);\n                if (abs(pos3d.x)<iradius && abs(pos3d.y)<iradius && abs(pos3d.z)<iradius) {\n                    fragColor = vec4(liveval-1.,0.0,0.0,wv);\n                    return;\n                }\n            } else {\n                fragColor = vec4(liveval-1.,0.0,0.0,wv);\n                return;\n            }\n        }\n        fragColor = vec4(-1.,0.,0.,wv);\n        return;\n    }\n\n    int st = cellval(pos3d,0,0,0);\n    \n    speed += speedplus;\n    if (iFrame % (speed+1) > 0 || pause == 1) {\n        fragColor = vec4(float(st),0.0,0.0,wv);\n        return;\n    }\n\n    int count = 0;\n    if (countmethod == 0) {\n        // Mooore\n        if (wrap == 1) {\n            count = cellwrap(pos3d,-1,-1,-1) + cellwrap(pos3d,0,-1,-1) + cellwrap(pos3d,1,-1,-1) + cellwrap(pos3d,-1,0,-1) + cellwrap(pos3d,0,0,-1) + cellwrap(pos3d,1,0,-1) + cellwrap(pos3d,-1,1,-1) + cellwrap(pos3d,0,1,-1) + cellwrap(pos3d,1,1,-1) \n                  + cellwrap(pos3d,-1,-1,0) + cellwrap(pos3d,0,-1,0) + cellwrap(pos3d,1,-1,0) + cellwrap(pos3d,-1,0,0) + cellwrap(pos3d,1,0,0) + cellwrap(pos3d,-1,1,0) + cellwrap(pos3d,0,1,0) + cellwrap(pos3d,1,1,0)\n                  + cellwrap(pos3d,-1,-1,1) + cellwrap(pos3d,0,-1,1) + cellwrap(pos3d,1,-1,1) + cellwrap(pos3d,-1,0,1) + cellwrap(pos3d,0,0,1) + cellwrap(pos3d,1,0,1) + cellwrap(pos3d,-1,1,1) + cellwrap(pos3d,0,1,1) + cellwrap(pos3d,1,1,1);\n        } else {\n            count = cell(pos3d,-1,-1,-1) + cell(pos3d,0,-1,-1) + cell(pos3d,1,-1,-1) + cell(pos3d,-1,0,-1) + cell(pos3d,0,0,-1) + cell(pos3d,1,0,-1) + cell(pos3d,-1,1,-1) + cell(pos3d,0,1,-1) + cell(pos3d,1,1,-1) \n                  + cell(pos3d,-1,-1,0) + cell(pos3d,0,-1,0) + cell(pos3d,1,-1,0) + cell(pos3d,-1,0,0) + cell(pos3d,1,0,0) + cell(pos3d,-1,1,0) + cell(pos3d,0,1,0) + cell(pos3d,1,1,0)\n                  + cell(pos3d,-1,-1,1) + cell(pos3d,0,-1,1) + cell(pos3d,1,-1,1) + cell(pos3d,-1,0,1) + cell(pos3d,0,0,1) + cell(pos3d,1,0,1) + cell(pos3d,-1,1,1) + cell(pos3d,0,1,1) + cell(pos3d,1,1,1);\n        }\n    } else { \n        // Neumann\n        if (wrap == 1)\n            count = cellwrap(pos3d,0,-1,0) + cellwrap(pos3d,0,1,0) + cellwrap(pos3d,-1,0,0) + cellwrap(pos3d,1,0,0) + cellwrap(pos3d,0,0,-1) + cellwrap(pos3d,0,0,1);\n        else\n            count = cell(pos3d,0,-1,0) + cell(pos3d,0,1,0) + cell(pos3d,-1,0,0) + cell(pos3d,1,0,0) + cell(pos3d,0,0,-1) + cell(pos3d,0,0,1);\n    }\n\n    if(st <= 0) {\n        if (((1<<count) & bornset) > 0)\n            st = int(liveval)-1;\n    }\n    else {\n        if (((1<<count) & liveset) == 0)\n            st--;\n    }\n\n    fragColor = vec4(float(st),0.0,0.0,wv);\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 125.\n\n#define HORIZON\n\nconst float LAST_PATT = 23.01;\n\nint liveset, bornset, clearmethod, countmethod, withermethod;\nfloat liveval;\nfloat radius;\nfloat density;\nint speedplus, wrap;\n\nvoid setRules(int index) {\n    int v1, v2;\n    countmethod=0, clearmethod=0, withermethod=-1;\n    speedplus=0, wrap=1;\n\n    if (index == 0) {  liveval=10.; v1=240, v2=448; radius=6.; density=0.4; withermethod=8; }                           // pyroclastic\n    if (index == 1) {  countmethod=1; liveval=2.; v1=127, v2=10; clearmethod=1; radius=1.0; density=1.0; speedplus=4; } // crystal\n    if (index == 2) {  liveval=8.;  v1=5382088, v2=9701408; radius=8.0; density=0.5; speedplus=-1; wrap=0; }            // amoeba II\n    if (index == 3) {  liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.499; wrap=1; }                    // clouds\n    if (index == 4) {  liveval=2.;  v1=593808, v2=2195520; radius=35.0; density=0.3; wrap=0; }                          // slowburning star\n    if (index == 5) {  liveval=4.;  v1=134217600, v2=16; clearmethod=1; radius=12.0; density=0.5; wrap=1; }             // struct builder\n    if (index == 6) {  liveval=5.;  v1=371520, v2=63793088; clearmethod=1; radius=6.0; density=0.6; }                   // expanding shells\n    if (index == 7) {  liveval=2.;  v1=0, v2=2; clearmethod=1; radius=1.0; density=1.0; speedplus=20; wrap=0; }         // single point\n    if (index == 8) {  liveval=10.; v1=580, v2=848; radius=13.; density=0.1; withermethod=0;}                           // builder\n    if (index == 9) {  liveval=5.;  v1=16, v2=16; clearmethod=1; radius=15.0; density=0.4; }                            // 445\n    if (index == 10) { countmethod=1; liveval=2.; v1=127, v2=10; clearmethod=1; radius=4.0; density=1.0; speedplus=4; } // crystal (same, radius change)\n    if (index == 11) { liveval=3.;  v1=448, v2=448; radius=24.0; density=0.4; wrap=0;}                                  // 678\n    if (index == 12) { liveval=10.; v1=5382088, v2=9701408; radius=10.0; density=0.5; speedplus=-1; wrap=0; }           // amoeba II slow\n    if (index == 13) { liveval=7.;  v1=148064, v2=53477506; radius=1.0; clearmethod=1; density=1.; speedplus=12; }      // build cube\n    if (index == 14) { liveval=8.;  v1=21635016, v2=1052704; clearmethod=2; density=0.5; wrap=0; }                      // wither\n    if (index == 15) { liveval=11.; v1=65646754, v2=1123384; radius=7.; density=0.5; wrap=0; }                          // constant explosions\n    if (index == 16) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.503; wrap=0; }                    // clouds II\n    if (index == 17) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.52; wrap=0; }                     // clouds III (funkycube)\n\n    if (index == 18) { liveval=4.;  v1=134217600, v2=16; clearmethod=1; radius=11.0; density=0.5; wrap=1; }             // inv. struct builder\n    if (index == 19) { liveval=8.;  v1=5382088, v2=9701408; radius=8.0; density=0.5; speedplus=-1; wrap=0; }            // inv. amoeba II\n    if (index == 20) { liveval=5.;  v1=16, v2=16; clearmethod=1; radius=15.0; density=0.4; }                            // inv. 445\n    if (index == 21) { liveval=2.;  v1=134209536, v2=942080; clearmethod=2; density=0.504; wrap=1; }                    // inv. clouds\n    if (index == 22) { liveval=5.;  v1=134217216, v2=45280; clearmethod=0; radius=10.; density=0.8; wrap=0; }           // inv. amoeba I\n    if (index == 23) { liveval=5.;  v1=38553186, v2=2506768; clearmethod=0; radius=14.; density=0.58; wrap=0; }         // inv. little puffs\n\n    if (index==1 || index==10 || index==13) withermethod=4;\n    if (index==2 || index==15) withermethod=14;\n\n    liveset = v1; bornset = v2;\n}\n\nbool getInverted(int index) {\n    return index >= 18;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 304, 304, 549], [552, 607, 683, 683, 726], [728, 728, 756, 756, 935], [937, 937, 972, 972, 1277], [1279, 1279, 1389, 1389, 1706], [1708, 1708, 1757, 1757, 1868], [1870, 1870, 1987, 1987, 2689], [2691, 2691, 2779, 2779, 3358], [3360, 3360, 3455, 3455, 3594], [3596, 3596, 3672, 3672, 4806], [4809, 4809, 4834, 4834, 5021], [5023, 5023, 5179, 5179, 5943], [5945, 5945, 5972, 5972, 6039], [6041, 6041, 6098, 6098, 8002]], "test": "untested"}
{"id": "msjBzt", "name": "SWS3005_13", "author": "oasis_land", "description": "Welcome to visit our Rainbow Rhythm via Real-Time Ray Tracing on GPU！", "tags": ["realtimeraytracing"], "likes": 1, "viewed": 165, "published": 3, "date": "1690044966", "time_retrieved": "2024-07-30T17:43:15.621486", "image_code": "const float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.8, 0.8, 0.8 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 4;\nconst int NUM_MATERIALS = 10;\nconst int NUM_PLANES = 1;\nconst int NUM_ROWS = 5;\nconst int NUM_SPHERES = NUM_ROWS * NUM_ROWS;\n\nconst int n = 10;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n    float radian;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = clamp(abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return hsv.z * mix(vec3(1.0), rgb, hsv.y);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    for(int i = 0;i < NUM_ROWS;i++)\n    {\n        for(int j = 0;j < NUM_ROWS;j++)\n        {\n            Sphere[i * NUM_ROWS + j].radius = 0.5;\n            Sphere[i * NUM_ROWS + j].radian = float(i + j) * PI / 10.0;\n            Sphere[i * NUM_ROWS + j].center = vec3( -i * 2 + 4, abs(sin(2.0 * iTime + Sphere[i * NUM_ROWS + j].radian)) + Sphere[i * NUM_ROWS + j].radius, -j * 2 + 4);\n            Sphere[i * NUM_ROWS + j].materialID = i + 5 - j ;\n        }\n    }\n    \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    for(int i = 1; i < 10; i++)\n    {\n        float colorchange = float(i) / 5.0 + iTime / 2.0;\n        Material[i].k_d = hsv2rgb(vec3(mod(colorchange, 1.0), 1.0, 1.0));;\n        Material[i].k_a = 0.2 * Material[i].k_d;\n        Material[i].k_r = vec3( 0.5, 0.5, 0.5 ) + 0.5 * Material[i].k_d;\n        Material[i].k_rg = 0.5 * Material[i].k_r;\n        Material[i].n = 128.0;\n    }\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, 4.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 0.7, 0.3, 0.3 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 4.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 0.3, 0.7, 0.3 );\n\n    // Light 2.\n    Light[2].position = vec3( 4.0, 8.0, -4.0 );\n    Light[2].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[2].I_source = vec3( 0.2, 0.2, 0.9 );\n\n    // Light 3.\n    Light[3].position = vec3( -4.0, 8.0, -4.0 );\n    Light[3].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[3].I_source = vec3( 0.6, 0.6, 0.1 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n     \n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = N;\n    for(int j = 0; j < NUM_SPHERES; j++)\n    {\n        vec3 radius = hitPos - vec3(Sphere[j].center.x ,0.0 ,Sphere[j].center.z);\n        float r = length(radius)/5.0;\n        float time = fract((iTime * 2.0 + Sphere[j].radian) / PI) * PI / 2.0;\n        if(r < time && r > (time - PI/10.0))\n        {\n            hitNormal += sin((r - time) * 40.0) * normalize(radius) * (PI / 2.0 - time) / (PI / 2.0);\n        }\n    }\n    \n    hitNormal = normalize(hitNormal);\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    \n    float a = dot(ray.d,ray.d);\n    float b = 2.0 * dot(ray.d, ray.o - sph.center);\n    float c = dot(ray.o - sph.center,ray.o - sph.center) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    if(d < 0.0) return false;\n    float sqrtd = sqrt(d);\n    float t1 = (- b - sqrtd)/(2.0 * a);\n    float t2 = (- b + sqrtd)/(2.0 * a); \n\n    if (tmin <= t1 && t1 <= tmax) t = t1;\n    else if (tmin <= t2 && t2 <= tmax) t = t2;\n    else return false;\n\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(hitPos - sph.center);\n\n    return true;\n\n\n    //return false;  // Replace this with your code.\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    \n    float a = dot(ray.d,ray.d);\n    float b = 2.0 * dot(ray.d, ray.o - sph.center);\n    float c = dot(ray.o - sph.center,ray.o - sph.center) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    if(d < 0.0) return false;\n    float sqrtd = sqrt(d);\n    float t1 = (- b - sqrtd)/(2.0 * a);\n    float t2 = (- b + sqrtd)/(2.0 * a); \n\n    if (tmin <= t1 && t1 <= tmax) return true;\n    else if (tmin <= t2 && t2 <= tmax) return true;\n    else return false;\n\n    //return false;  // Replace this with your code.\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        if (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;\n            hasHitSomething = true;\n        }\n    }\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        if (IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal)) \n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[i].materialID;\n            hasHitSomething = true;\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        Ray_t lightray;\n        lightray.o = nearest_hitPos;\n        lightray.d = normalize(Light[i].position - nearest_hitPos);\n        bool inShadow = false;\n        for (int j = 0; j < NUM_PLANES; j++)\n        {\n            if (IntersectPlane(Plane[j], lightray, DEFAULT_TMIN, nearest_t))\n                inShadow = true;\n            \n        }\n        for (int j = 0; j < NUM_SPHERES; j++)\n        {\n            if (IntersectSphere(Sphere[j], lightray, DEFAULT_TMIN, nearest_t)) \n                inShadow = true;\n        }\n        I_local += PhongLighting(lightray.d, nearest_hitNormal, -ray.d, inShadow, Material[nearest_hitMatID], Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 2.0 * sin(iTime / 2.0) + 5.0, 7.0, 2.0 * cos(iTime / 2.0));\n    vec3 cam_lookat = vec3( 0.0, 0.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis));\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis * 1.0  +  pixel_pos.y * cam_y_axis * 1.0 +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2477, 2477, 2501, 2501, 2672], [2674, 2856, 2874, 2899, 4713], [4717, 5213, 5367, 5367, 6150], [6154, 6486, 6569, 6569, 6781], [6785, 7303, 7460, 7574, 8190], [8194, 8527, 8612, 8726, 9252], [9256, 9610, 9740, 9740, 10152], [10156, 10945, 11058, 11149, 14719], [14722, 15083, 15140, 15140, 16611]], "test": "untested"}
{"id": "DdBfzt", "name": "Cell-By-Cell Raymarching", "author": "Shane", "description": "Amalgamating cell-by-cell traversal and raymarching to render a subdivided rectangular grid.", "tags": ["raymarching", "grid", "rectangle", "prism", "city", "block", "traversal", "sparse"], "likes": 66, "viewed": 932, "published": 3, "date": "1690033839", "time_retrieved": "2024-07-30T17:43:16.885107", "image_code": "/*\n\n    Cell-By-Cell Raymarching\n    ------------------------\n\n\tAmalgamating cell-by-cell traversal and raymarching to render a \n    subdivided rectangular grid. There are a few examples involving \n    similar methods on Shadertoy, so this is not new. However, it's \n    a really useful method that isn't used very often, so I figured \n    I'd attempt to post a simple example in the hopes that those not \n    familiar with the process might benefit from it.\n    \n    If you've ever tried raymarching a repeat space grid containing \n    objects comparable to the size of the grid cell boundaries, you'll \n    notice a lot of artifacts. The two main solutions involve\n    raymarching the grid neighbors, which is usually expensive and\n    doesn't always work, or to perform a cell-by-cell traversal, which\n    is great, but you lose a lot of raymarching benefits, like simple\n    CSG, soft shadows, uncomplicated ambient occlusion formulas, etc.\n    \n    The solution is to combine the two aforementioned methods in a\n    surprisingly easy to implement fashion. In addition to raymarching \n    the grid as usual, you determine the distance from the ray \n    position to the cell boundary and use that to restrict the ray \n    from advancing too far. The entire process requires the addition\n    of just a few extra lines.\n    \n    I'm not sure who first demonstrated the technique on Shadertoy, \n    but Nimitz's \"Sparse grid marching\" is a really nice early example. \n    IQ's \"Cubescape\" shader was posted over ten years ago, and that \n    utilizes similar principles, but it involves advancing the ray \n    from cell to cell, then raymarching at each step. I'm not sure \n    which method is more efficient, but I'm employing a 2D version of \n    the former. The difference between this and a regular raymarched\n    grid example is a small amount of setup and extra lines in the \n    distace, trace and shadow functions.\n    \n    This particular method can be applied to all kinds of rectangular\n    grids, and with some adjustments, I'd imagine other grid types \n    would be possible. I have a simple 3D version that I'll post at\n    some stage, and I intend to attempt some others later.\t\n    \n    \n\n\tSimilar examples:\n    \n    // Really stylish.\n    Sparse grid marching - nimitz\n    https://www.shadertoy.com/view/XlfGDs\n    \n\t// A cell be cell traversal with raymarching inside each cell.\n    // Amazing to think that this is over ten years old.\n    Cubescape  - iq\n\thttps://www.shadertoy.com/view/Msl3Rr  \n    \n    // A really clever 3D subdivided example. Traversing a\n    // variable sized 3D box grid is on my list.\n    Box Singularity - Tater\n    https://www.shadertoy.com/view/7dVGDd\n\n*/\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Scene color - Bluish purlple: 0, Tequila sunrise: 1.\n#define COLOR 1\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.609, 57.583)), 6.2831853))*43758.5453); \n}\n\n\n\n// Cube face texturing -- Hacked together quickly, but it'll work.\nvec3 texCube(sampler2D iCh, in vec3 p, in vec3 n){\n\n    \n    // Use the normal to determine the face. Z facing normals \n    // imply the XY plane, etc.\n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n    \n    // Reusing \"p\" for the color read.\n    p = texture(iCh, p.xy).xyz;\n \n    // Rough conversion from sRGB to linear.\n    return p*p;\n\n}\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p/8.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); }\n\n\n\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n\n// Subdivided rectangle grid.\nvec4 getGrid(vec2 p, inout vec2 sc){\n    \n    // Block offsets.\n    vec2 ipOffs = vec2(0);\n    // Row or column offset. Values like \"1/3\" would offset more\n    // haphazardly, but I wanted to maintain a little symmetry.\n    const float offDst = .5; \n    if(mod(floor(p.y/sc.y), 2.)<.5){\n        p.x -= sc.x*offDst; // Row offset.\n        ipOffs.x += offDst;\n    }\n    //if(mod(floor(p.x/sc.x), 2.)<.5){\n        //p.y -= sc.y*offDst; // Column offset.\n        //ipOffs.y += offDst;\n    //}\n    \n    vec2 oP = p;\n    \n    // Block ID.\n    vec2 ip;\n    \n    //#define EQUAL_SIDES\n    \n    // Subdivide.\n    for(int i = 0; i<4; i++){\n        \n        // Current block ID.\n        ip = floor(p/sc) + .5;\n        float fi = float(i)*.0617; // Unique loop number.\n        #ifdef EQUAL_SIDES        \n        // Squares.\n        \n        // Random split.\n        if(hash21(ip + .253 + fi)<.333){\n           sc /= 2.;\n           p = oP;\n           ip = floor(p/sc) + .5; \n        }\n        \n        #else\n        \n        // Powers of two rectangles.\n        \n        // Random X-split.\n        if(hash21(ip + .253 + fi)<.333){//3 && sc.x>1./8.\n           sc.x /= 2.;\n           p.x = oP.x;\n           ip.x = floor(p.x/sc.x) + .5;\n        }\n        // Random Y-split.\n        if(hash21(ip + .453 + fi)<.333){ // && sc.y>1./8.\n           sc.y /= 2.;\n           p.y = oP.y;\n           ip.y = floor(p.y/sc.y) + .5;\n        }\n        \n        #endif\n         \n    }\n    \n    // Local coordinates and cell ID.\n    return vec4(p - ip*sc, (ip + ipOffs)*sc);\n\n}\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec2 gP;\n\n \n// An extruded subdivided rectangular block grid. Use the grid cell's \n// center pixel to obtain a height value (read in from a height map), \n// then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n \n    // Local coordinates.\n    vec2 p = q3.xy;\n\n\n    vec3 sc = vec3(1); // Scale.\n    // Local coordinates and cell ID.\n    vec4 p4 = getGrid(p, sc.xy); \n    p = p4.xy;\n    vec2 id = p4.zw;\n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - vec3(p, q3.z))/gRd;\n    //vec2 rC = (gDir.xy*sc.xy - p)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n\n    // The extruded block height. See the height map function, above.\n    float h = hm(id);\n    h = (h*.975 + .025)*2.5;\n\n\n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    sc.xy -= .05*(hash21(id)*.9 + .1);\n\n    // Lower box prism.\n    float d = sBoxS(vec3(p, q3.z + h/2.), vec3(sc.xy, h)/2., .0);\n\n    // Putting some random boxes on top.\n    if(min(sc.x, sc.y)>.125 && hash21(id + .03)<.5){ \n       float d2 = sBoxS(vec3(p, q3.z + (h*1.3)/2.), vec3(sc.xy - .16, h*1.3)/2., .0);\n       d = min(d, d2);\n    }\n\n    // Saving the box dimensions and local coordinates.\n    gSc = vec3(sc.xy, h);\n    gP = p;\n\n        \n   \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, 0);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash31(ro + rd)*.15\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd; \n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001*(1. + t*.05)|| t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more \n// symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                     map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d, gCD), .02, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(iTime/2., 0, -4); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.02, .18, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning.\n    vec3 lp = ro + vec3(2, 2, 0);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Rotation.\n\trd.xy *= rot2(-.25);    \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    // Scene object ID. Either the pylons or the floor.\n    float svObjID = objID;\n    \n    // Saving the bloxk scale and local 2D base coordinates.\n    vec3 svSc = gSc;\n    vec2 svP = gP;\n    \n\t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n          \n        // Obtaining the texel color. \n\t    vec3 objCol; \n        \n        float svObjEdge = 1.;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            /*\n            // Random coloring using IQ's short versatile palette formula.\n            float rnd = hash21(svGID.yz + .34);\n            vec3 tx = .5 + .48*cos(6.2831853*rnd/10. + vec3(0, 1, 2) + .8);\n            tx *= .5;\n            */\n       \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(iChannel1, svGID.yz);\n            // Grunge texturing.\n            vec3 tx2 = texCube(iChannel2, sp/4., sn);\n            // Combining.\n            objCol = tx.yzx*(tx2*2. + .2);\n            //objCol = tx.yzx*.65;//\n                      \n                \n            \n            // Last minute edge routine. I've returned the nearest rectangle ID\n            // and dimensions from the \"raycasting\" routine, and the rest \n            // figures itself out.\n            float ew = .0125*(1. + t*.1); // Edge width.\n            float h = svSc.z;\n            float rct = sBoxS(svP, svSc.xy/2., .0);\n            float top = max(abs(sp.z + h), abs(rct));\n            float side = abs(abs(svP.x) - svSc.x/2.);\n            side = max(side, abs(abs(svP.y) - svSc.y/2.));\n            float objEdge = min(top, side) - ew;\n            \n            // Same for the boxes on top.\n            if(min(svSc.x, svSc.y)>.125 && hash21(svGID.yz + .03)<.5){\n                rct = sBoxS(svP, (svSc.xy - .16)/2., .0);\n                top = max(abs(sp.z + h), abs(rct));\n                top = min(top, max(abs(sp.z + h*1.3), abs(rct)));\n                side = abs(abs(svP.x) - (svSc.x - .16)/2.);\n                side = max(side, abs(abs(svP.y) - (svSc.y - .16)/2.));\n                objEdge = min(objEdge, min(top, side) - ew);\n            }\n            \n            svObjEdge = objEdge;\n           \n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            vec3 tx = getTex(iChannel2, sp.xy);\n            objCol = vec3(.3, .15, 1)/8.*(tx*2. + 1.);\n            //objCol = vec3(0);\n        }\n      \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 2./(1. + lDist*.125);\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff = pow(diff, 2. + 16.*objCol.x*objCol.x)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.  \n        \n        /*\n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel3\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel3, rf.xzy*vec3(1, -1, -1)).xyz; rTx *= rTx;\n        objCol = objCol*.5 + objCol*speR*rTx*4.;\n        */\n        \n        float svEw = .0125*(1. + t*.1);\n        float sf = 4./iResolution.y;\n        objCol = mix(objCol, objCol*1.5, 1. - smoothstep(0.,sf, svObjEdge - svEw));\n        objCol = mix(objCol, objCol/4., 1. - smoothstep(0., sf, svObjEdge));\n        \n        \n        // Combining the above terms to procude the final color.\n        col = objCol*(diff*sh + vec3(.2, .4, 1) + vec3(1, .97, .92)*spec*freS*sh*8.);\n        \n        \n        // Shading.\n        col *= ao*atten;\n          \n\t\n\t}\n    \n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    col = mix(col, vec3(1, .5, 2), smoothstep(.25, .9, t/FAR));\n \n    #if COLOR == 1\n    // Some gradient coloring.\n    col = mix(col.zyx, col.zxy, uv.y + .5);\n    #endif\n    \n    // Greyscale.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n    \n \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2895, 2928, 2950, 2950, 3008], [3011, 3039, 3060, 3060, 3145], [3149, 3216, 3266, 3367, 3573], [3575, 3597, 3632, 4009, 4103], [4105, 4169, 4189, 4189, 4249], [4253, 4528, 4566, 4566, 4661], [4663, 4719, 4757, 4757, 4842], [4845, 4875, 4911, 4938, 6418], [6819, 6819, 6840, 6873, 8894], [8973, 8996, 9014, 9033, 9296], [9300, 9321, 9357, 9406, 10464], [10467, 10571, 10607, 10607, 10786], [10789, 10984, 11036, 11117, 12405], [12408, 12560, 12595, 12595, 12846], [12848, 12848, 12904, 12941, 19024]], "test": "untested"}
{"id": "ddjfR3", "name": "shader para mascara", "author": "nictemeral", "description": "shader para generar mascara en pantallas", "tags": ["utils"], "likes": 0, "viewed": 100, "published": 3, "date": "1690033169", "time_retrieved": "2024-07-30T17:43:17.822600", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool auto= true;\n    bool tri= false;\n    float div= 12.;\n    float indice;\n    //indice de 0 a 11\n    float vel = 0.5;\n        if(auto){\n    float t;\n    if(tri){\n    t= abs(mod(iTime * vel*0.5  +0.5,1.)-0.5)*2.;\n    }\n    else{\n    t = fract(iTime * vel);\n    }\n    indice = floor(mod(t*div,div));\n    }\n    else{indice=0.;}\n    float px = 1./iResolution.x;\n    float cantPx = px*(iResolution.x/div);\n    vec2 uv = fragCoord.xy/(iResolution.xy);\n    //vec2 iuv = floor(fragCoord.xy*div/(iResolution.xy))/div;\n\n    vec3 col = vec3(uv.x);\n    col= step(cantPx*(div-indice-1.),1.-col)*step(cantPx*indice,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dsBfRd", "name": "Order and freedom", "author": "SlInevitable2003", "description": "A learning project of ray-tracing.", "tags": ["3d"], "likes": 6, "viewed": 211, "published": 3, "date": "1690014086", "time_retrieved": "2024-07-30T17:43:18.855838", "image_code": "//============================================================================\n// PROJECT ID:SWS3005_07\n//\n// GROUP NUMBER:07\n//\n// STUDENT NAME:Xu Xinyao\n// NUS User ID.:t0930028\n//\n// STUDENT NAME:Xue jing\n// NUS User ID.:t0930095\n//\n// STUDENT NAME:Lu Biran\n// NUS User ID.:t0930098\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 14;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 43;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\nvec3 create_satellite(int center_id, float circle_radius, float speed, int type, bool inverse)\n{\n    vec3 center = Sphere[center_id].center;\n    vec3 ret;\n    float offset = inverse ? PI : 0.0;\n    switch (type) {\n    case 0:\n        ret = vec3(center.x + circle_radius * cos(iTime * speed + offset),\n                   center.y,\n                   center.z + circle_radius * sin(iTime * speed + offset));\n        break;\n    case 1:\n        ret = vec3(center.x + circle_radius * sin(iTime * speed + offset),\n                   center.y + circle_radius * cos(iTime * speed + offset),\n                   center.z);\n        break;\n    case 2:\n        ret = vec3(center.x,\n                   center.y + circle_radius * sin(iTime * speed + offset),\n                   center.z + circle_radius * cos(iTime * speed + offset));\n        break;\n    }\n    return ret;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 7.0;\n    Plane[1].materialID = 13;\n\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 2.5 * sin(0.8 * iTime) + sin(-1.2 * iTime) + sin(2.0 * iTime) + sin(-2.8 * iTime), 5.0, 2.5 * cos(-0.8 * iTime) + cos(1.2 * iTime) + cos(-2.0 * iTime) + cos(2.8 * iTime) );\n    Sphere[0].radius = 0.50;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = create_satellite(0, 2.0, 2.0, 0, false);\n    Sphere[1].radius = 0.30;\n    Sphere[1].materialID = 2;\n    \n    Sphere[2].center = create_satellite(0, 2.0, 2.0, 1, false);\n    Sphere[2].radius = 0.30;\n    Sphere[2].materialID = 3;\n    \n    Sphere[3].center = create_satellite(0, 2.0, 2.0, 2, false);\n    Sphere[3].radius = 0.30;\n    Sphere[3].materialID = 4;\n    \n    Sphere[4].center = create_satellite(1, 0.5, 3.0, 0, false);\n    Sphere[4].radius = 0.10;\n    Sphere[4].materialID = 5;\n    \n    Sphere[5].center = create_satellite(1, 0.5, 3.0, 1, false);\n    Sphere[5].radius = 0.10;\n    Sphere[5].materialID = 6;\n    \n    Sphere[6].center = create_satellite(1, 0.5, 3.0, 2, false);\n    Sphere[6].radius = 0.10;\n    Sphere[6].materialID = 7;\n    \n    Sphere[7].center = create_satellite(2, 0.5, 3.0, 0, false);\n    Sphere[7].radius = 0.10;\n    Sphere[7].materialID = 7;\n    \n    Sphere[8].center = create_satellite(2, 0.5, 3.0, 1, false);\n    Sphere[8].radius = 0.10;\n    Sphere[8].materialID = 8;\n    \n    Sphere[9].center = create_satellite(2, 0.5, 3.0, 2, false);\n    Sphere[9].radius = 0.10;\n    Sphere[9].materialID = 9;\n   \n    Sphere[10].center = create_satellite(3, 0.5, 3.0, 0, false);\n    Sphere[10].radius = 0.10;\n    Sphere[10].materialID = 10;\n    \n    Sphere[11].center = create_satellite(3, 0.5, 3.0, 1, false);\n    Sphere[11].radius = 0.10;\n    Sphere[11].materialID = 11;\n    \n    Sphere[12].center = create_satellite(3, 0.5, 3.0, 2, false);\n    Sphere[12].radius = 0.10;\n    Sphere[12].materialID = 12;\n    \n    // Circling sphere.\n    Sphere[13].center = create_satellite(0, 2.0, 2.0, 0, true);\n    Sphere[13].radius = 0.30;\n    Sphere[13].materialID = 2;\n    \n    Sphere[14].center = create_satellite(0, 2.0, 2.0, 1, true);\n    Sphere[14].radius = 0.30;\n    Sphere[14].materialID = 3;\n    \n    Sphere[15].center = create_satellite(0, 2.0, 2.0, 2, true);\n    Sphere[15].radius = 0.30;\n    Sphere[15].materialID = 4;\n    \n    Sphere[16].center = create_satellite(13, 0.5, 3.0, 0, true);\n    Sphere[16].radius = 0.10;\n    Sphere[16].materialID = 5;\n    \n    Sphere[17].center = create_satellite(13, 0.5, 3.0, 1, true);\n    Sphere[17].radius = 0.10;\n    Sphere[17].materialID = 6;\n    \n    Sphere[18].center = create_satellite(13, 0.5, 3.0, 2, true);\n    Sphere[18].radius = 0.10;\n    Sphere[18].materialID = 7;\n    \n    Sphere[19].center = create_satellite(14, 0.5, 3.0, 0, true);\n    Sphere[19].radius = 0.10;\n    Sphere[19].materialID = 7;\n    \n    Sphere[20].center = create_satellite(14, 0.5, 3.0, 1, true);\n    Sphere[20].radius = 0.10;\n    Sphere[20].materialID = 8;\n    \n    Sphere[21].center = create_satellite(14, 0.5, 3.0, 2, true);\n    Sphere[21].radius = 0.10;\n    Sphere[21].materialID = 9;\n    \n    Sphere[22].center = create_satellite(15, 0.5, 3.0, 0, true);\n    Sphere[22].radius = 0.10;\n    Sphere[22].materialID = 10;\n    \n    Sphere[23].center = create_satellite(15, 0.5, 3.0, 1, true);\n    Sphere[23].radius = 0.10;\n    Sphere[23].materialID = 11;\n    \n    Sphere[24].center = create_satellite(15, 0.5, 3.0, 2, true);\n    Sphere[24].radius = 0.10;\n    Sphere[24].materialID = 12;\n    \n    Sphere[25].center = create_satellite(1, 0.5, 3.0, 0, true);\n    Sphere[25].radius = 0.10;\n    Sphere[25].materialID = 5;\n    \n    Sphere[26].center = create_satellite(1, 0.5, 3.0, 1, true);\n    Sphere[26].radius = 0.10;\n    Sphere[26].materialID = 6;\n    \n    Sphere[27].center = create_satellite(1, 0.5, 3.0, 2, true);\n    Sphere[27].radius = 0.10;\n    Sphere[27].materialID = 7;\n    \n    Sphere[28].center = create_satellite(2, 0.5, 3.0, 0, true);\n    Sphere[28].radius = 0.10;\n    Sphere[28].materialID = 7;\n    \n    Sphere[29].center = create_satellite(2, 0.5, 3.0, 1, true);\n    Sphere[29].radius = 0.10;\n    Sphere[29].materialID = 8;\n    \n    Sphere[30].center = create_satellite(2, 0.5, 3.0, 2, true);\n    Sphere[30].radius = 0.10;\n    Sphere[30].materialID = 9;\n    \n    Sphere[31].center = create_satellite(3, 0.5, 3.0, 0, true);\n    Sphere[31].radius = 0.10;\n    Sphere[31].materialID = 10;\n    \n    Sphere[32].center = create_satellite(3, 0.5, 3.0, 1, true);\n    Sphere[32].radius = 0.10;\n    Sphere[32].materialID = 11;\n    \n    Sphere[33].center = create_satellite(3, 0.5, 3.0, 2, true);\n    Sphere[33].radius = 0.10;\n    Sphere[33].materialID = 12;\n    \n    Sphere[34].center = create_satellite(13, 0.5, 3.0, 0, false);\n    Sphere[34].radius = 0.10;\n    Sphere[34].materialID = 5;\n    \n    Sphere[35].center = create_satellite(13, 0.5, 3.0, 1, false);\n    Sphere[35].radius = 0.10;\n    Sphere[35].materialID = 6;\n    \n    Sphere[36].center = create_satellite(13, 0.5, 3.0, 2, false);\n    Sphere[36].radius = 0.10;\n    Sphere[36].materialID = 7;\n    \n    Sphere[37].center = create_satellite(14, 0.5, 3.0, 0, false);\n    Sphere[37].radius = 0.10;\n    Sphere[37].materialID = 7;\n    \n    Sphere[38].center = create_satellite(14, 0.5, 3.0, 1, false);\n    Sphere[38].radius = 0.10;\n    Sphere[38].materialID = 8;\n    \n    Sphere[39].center = create_satellite(14, 0.5, 3.0, 2, false);\n    Sphere[39].radius = 0.10;\n    Sphere[39].materialID = 9;\n    \n    Sphere[40].center = create_satellite(15, 0.5, 3.0, 0, false);\n    Sphere[40].radius = 0.10;\n    Sphere[40].materialID = 10;\n    \n    Sphere[41].center = create_satellite(15, 0.5, 3.0, 1, false);\n    Sphere[41].radius = 0.10;\n    Sphere[41].materialID = 11;\n    \n    Sphere[42].center = create_satellite(15, 0.5, 3.0, 2, false);\n    Sphere[42].radius = 0.10;\n    Sphere[42].materialID = 12;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 1.0 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.8, 0.0, 0.8 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    // Red plastic material.\n    Material[3].k_d = vec3( 0.8, 0.0, 0.0 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n    \n    // Blue plastic material.\n    Material[4].k_d = vec3( 0.0, 0.0, 0.8 );\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 128.0;\n    \n    // purple plastic material.\n    Material[5].k_d = vec3( 0.7, 0.1, 0.7 );\n    Material[5].k_a = 0.2 * Material[5].k_d;\n    Material[5].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 128.0;\n\n    // dream plastic material.\n    Material[6].k_d = vec3( 0.9, 0.5, 0.3 );\n    Material[6].k_a = 0.2 * Material[6].k_d;\n    Material[6].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].n = 128.0;\n    \n    // ? plastic material.\n    Material[7].k_d = vec3( 0.5, 0.8, 0.4 );\n    Material[7].k_a = 0.2 * Material[7].k_d;\n    Material[7].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[7].k_rg = 0.5 * Material[7].k_r;\n    Material[7].n = 128.0;\n    \n    // ? plastic material.\n    Material[8].k_d = vec3( 0.2, 0.3, 0.5 );\n    Material[8].k_a = 0.2 * Material[8].k_d;\n    Material[8].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[8].k_rg = 0.5 * Material[8].k_r;\n    Material[8].n = 128.0;\n    \n    // ? plastic material.\n    Material[9].k_d = vec3( 0.7, 0.1, 0.1 );\n    Material[9].k_a = 0.2 * Material[9].k_d;\n    Material[9].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[9].k_rg = 0.5 * Material[9].k_r;\n    Material[9].n = 128.0;\n    \n    // ? plastic material.\n    Material[10].k_d = vec3( 0.1, 0.3, 0.1 );\n    Material[10].k_a = 0.2 * Material[10].k_d;\n    Material[10].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[10].k_rg = 0.5 * Material[10].k_r;\n    Material[10].n = 128.0;\n    \n    // ? plastic material.\n    Material[11].k_d = vec3( 0.7, 0.1, 0.9 );\n    Material[11].k_a = 0.2 * Material[11].k_d;\n    Material[11].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[11].k_rg = 0.5 * Material[11].k_r;\n    Material[11].n = 128.0;\n    \n    // ? plastic material.\n    Material[12].k_d = vec3( 0.2, 0.3, 0.2 );\n    Material[12].k_a = 0.2 * Material[12].k_d;\n    Material[12].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[12].k_rg = 0.5 * Material[12].k_r;\n    Material[12].n = 128.0;\n    \n    // Silver material.\n    Material[13].k_d = vec3( 1.0, 0.5, 0.0 );\n    Material[13].k_a = 0.2 * Material[0].k_d;\n    Material[13].k_r = 2.0 * Material[0].k_d;\n    Material[13].k_rg = 0.5 * Material[0].k_r;\n    Material[13].n = 64.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0 * abs(sin(iTime)), -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0* abs(sin(iTime)), -3.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 oc = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0f * dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0f * a * c;\n\n    if (discriminant < 0.0f)\n        return false; // No intersection.\n\n    // Find the nearest positive root of the quadratic equation.\n    float sqrt_discriminant = sqrt(discriminant);\n    float t0 = (-b - sqrt_discriminant) / (2.0f * a);\n    float t1 = (-b + sqrt_discriminant) / (2.0f * a);\n\n    // Choose the smaller positive root as the hit point.\n    float nearest_t = min(t0, t1);\n    if (nearest_t < tmin || nearest_t > tmax)\n        return false; // The hit point is outside the acceptable range.\n\n    // We have a hit - output the results.\n    t = nearest_t;\n    hitPos = ray.o + nearest_t * ray.d;\n    hitNormal = normalize(hitPos - sph.center); // Normal points outward from the sphere center.\n    return true;\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 oc = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0f * dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0f * a * c;\n\n    if (discriminant < 0.0f)\n        return false; // No intersection.\n\n    // Find the nearest positive root of the quadratic equation.\n    float sqrt_discriminant = sqrt(discriminant);\n    float t0 = (-b - sqrt_discriminant) / (2.0f * a);\n    float t1 = (-b + sqrt_discriminant) / (2.0f * a);\n\n    // Choose the smaller positive root as the hit point.\n    float nearest_t = min(t0, t1);\n    if (nearest_t < tmin || nearest_t > tmax)\n        return false; // The hit point is outside the acceptable range.\n\n    // We have a hit.\n    return true;\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    \n    // Intersect with planes.\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        if (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            hasHitSomething = true;\n            if (nearest_t > temp_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }\n    }\n\n    // Intersect with spheres.\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        if (IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            hasHitSomething = true;\n            if (nearest_t > temp_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n\n    // Iterate over each light source to compute lighting.\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        vec3 L = normalize(Light[i].position - nearest_hitPos);\n        vec3 V = ray.o - nearest_hitPos;\n        bool inShadow = false;\n\n        // Check if the point is in shadow by casting a shadow ray to each light source.\n        for (int j = 0; j < NUM_PLANES; j++)\n        {\n            if (IntersectPlane(Plane[j], Ray_t(nearest_hitPos, L), DEFAULT_TMIN, length(V)))\n            {\n                inShadow = true;\n                break;\n            }\n        }\n\n        for (int j = 0; j < NUM_SPHERES; j++)\n        {\n            if (IntersectSphere(Sphere[j], Ray_t(nearest_hitPos, L), DEFAULT_TMIN, length(V)))\n            {\n                inShadow = true;\n                break;\n            }\n        }\n\n        // Compute the Phong lighting model and accumulate the result.\n        I_local += PhongLighting(L, nearest_hitNormal, -ray.d, inShadow, Material[nearest_hitMatID], Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0f * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 3.0f * sin(iTime / 3.0f + 5.0f * m.x), 6.0f, 1.0f * cos(iTime / 3.0f + 5.0f * m.x) + 5.0f );\n    vec3 cam_lookat = Sphere[0].center;\n    vec3 cam_up_vec = vec3( 0.0f, 1.0f, 0.0f );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis) );\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3200, 3200, 3296, 3296, 4058], [4060, 4242, 4260, 4285, 14064], [14068, 14564, 14718, 14718, 15048], [15052, 15384, 15467, 15467, 15679], [15683, 16201, 16358, 16472, 17405], [17409, 17742, 17827, 17941, 18697], [18701, 19055, 19185, 19185, 19597], [19601, 20390, 20503, 20594, 24676], [24680, 25041, 25098, 25098, 26633]], "test": "untested"}
{"id": "cdBczz", "name": "Zooming Rainbow Spiral", "author": "evpevdev", "description": "Makes a spiral by setting distance from centre equal to angle from centre.", "tags": ["spiral"], "likes": 2, "viewed": 143, "published": 3, "date": "1690006498", "time_retrieved": "2024-07-30T17:43:19.603838", "image_code": "#define PI 3.1415926\n\n\n// From https://www.shadertoy.com/view/XlfGDN\nvec3 hsv2rgb(vec3 c)\n{\n    //vec3 K = vec3(3,2,1)/3.;\n    //return c.z * mix(K.xxx, clamp(abs(fract(c.xxx + K)*6. - vec3(3.)) - K.xxx, 0., 1.), c.y);\n    // Which can be further optimized to:\n    // Thanks to las @ http://www.pouet.net/user.php?who=4548\n    return mix(vec3(1.),clamp((abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),c.y)*c.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    const float size = 0.2;\n    // Speed is currently not used.\n    //float speed = 0.02\n    const float minSpeed = 0.1;\n    const float maxSpeed = 0.2;\n    // This is the integral of speed with respect to time\n    // Integral of minSpeed + (maxSpeed-minSpeed) * (sin(iTime) + 1.0)/2.0\n    float distanceOffset = minSpeed*iTime + (maxSpeed-minSpeed) * (cos(iTime) + iTime)/2.0;\n    float len = length(uv);\n    float len2 = pow(len, 0.1);\n    float angle = mod(atan(uv.y, uv.x) / 1.0, PI) / PI;\n    // Map to 0 at right, 0.5 at top, 1 at left, 1.5 at bottom\n    angle = angle + -(sign(uv.y)-1.0)/2.0;\n    \n    const int spokes = 1;\n    // Number of spokes are changed by changing the range of angle from 0-2 to 0-#spokes.\n    float dFg = abs(mod(len2 + distanceOffset - angle*size*(float(spokes)/2.0), size));\n    float dBg = abs(mod(len2 - iTime*0.01 - angle*size*(float(spokes)/2.0), size));\n    \n    // Normalize so d is between 0 and 1.\n    dFg *= 1./size;\n    dBg *= 1./size;\n    // Make transition smooth so the mod does not make a harsh edge.\n    float dFgSmooth = abs(dFg - 0.5) * 2.;\n    float dBgSmooth = abs(dBg - 0.5) * 2.;\n    \n    // Used for transitioning between foreground and background rainbows smoothly\n    float transition = smoothstep(0.5, 0.9, dFgSmooth);\n    \n    const float fgInterlaceAmount = 20.0;\n    const float fgInterlaceOffset = 0.02;\n    const float bgInterlaceAmount = 150.0;\n    const float bgInterlaceOffset = 0.01;\n    // 0 in centre of screen and 1 on the left/right edges\n    float bgValue = pow(len/aspect, 0.8);\n    const float blackSize = 0.05;\n    float fgValue = (-pow(1e-3, len/aspect) + 1.0) * 1.2;\n    \n    // Glow effect done by making the value greater than 1 on the edges, and decreasing saturation at the edges\n    vec3 rainbowFg = hsv2rgb(vec3(angle-len2 + fgInterlaceOffset*floor(mod(dFg*fgInterlaceAmount, 2.)), (1.0-bgValue)*0.7, fgValue));\n    vec3 rainbowBg = hsv2rgb(vec3(dBgSmooth/10.+0.77 + bgInterlaceOffset*floor(mod(dBg*bgInterlaceAmount, 2.)), bgValue*0.8, bgValue*0.5));\n    vec3 col = mix(rainbowFg, rainbowBg, vec3(1.0-transition));\n    \n    const float posterisation = 16.0;\n    col = ceil(col * posterisation) / posterisation;\n    \n    //col = vec3(fgValue);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 69, 91, 322, 413]], "test": "untested"}
{"id": "Ddsyzj", "name": "Orbiting Circles Fractal", "author": "evpevdev", "description": "Each circle has 4 circles rotating it.", "tags": ["fractal", "circle"], "likes": 7, "viewed": 180, "published": 3, "date": "1690006476", "time_retrieved": "2024-07-30T17:43:20.365801", "image_code": "#define maxIterations 4\n\n#define PI 3.1415926\n\nfloat circle(float radius, vec2 position, vec2 uv){\n    \n    float thickness = pow(radius, 2.0) * 0.025;\n    //float val = 1.0 - smoothstep(thickness, thickness*2.0, abs(length(uv-position) - radius));\n    float val = 1.0 - smoothstep(thickness, thickness*2.0, abs(dot(uv-position, uv-position) - pow(radius, 2.)));\n    return val;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float speed = 0.2;\n    float val = 0.0;\n    float baseRadius = 0.5;\n\n    float speedMultiplier = 1.618;\n    float sizeMultiplier = 0.618;\n    for (int iteration = 0; iteration < maxIterations; iteration++){\n        float radius = baseRadius * pow(sizeMultiplier, float(iteration));\n        // Loop through all circles in this iteration\n        for (float c = 0.0; c < pow(4.0, float(iteration)); c++){ \n            vec2 position = vec2(0.0);\n            // Move the circle\n            for (float j=0.0; j < float(iteration); j++){\n                float n = mod(floor(c/pow(4.0, float(iteration)-j-1.0)), 4.0);\n                float angle = n*PI/2.0 + iTime*speed*pow(speedMultiplier, float(j));\n                position += baseRadius*pow(sizeMultiplier, j) * vec2(cos(angle), sin(angle));\n            }\n\n            val += circle(radius, position, uv);\n        }\n    }\n    val = 1.0 - val;\n\n    // Output to screen\n    fragColor = vec4(vec3(val), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddsyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 98, 98, 380], [383, 383, 440, 490, 1545]], "test": "untested"}
{"id": "cs2yzK", "name": "Game of Life thing", "author": "evpevdev", "description": "Press space to pause and c to clear the canvas. The background will turn purple when paused.\n\nAll parameters that you can change are in common.", "tags": ["cellularautomaton"], "likes": 1, "viewed": 121, "published": 3, "date": "1690006356", "time_retrieved": "2024-07-30T17:43:21.289332", "image_code": "\nfloat grid(float size, float width, vec2 uv){\n    return min(step(mod(uv.x, size), width) + step(mod(uv.y, size), width), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    float pixSize = 1.0 / iResolution.y;\n    float pixSizeScaled = pixSize / canvasScale;\n    \n    bool isPaused = texelFetch(iChannel1, ivec2(KEY_SPACE, 2), 0).x == 1.0;\n    \n    float gridVal = grid(pixSizeScaled, pixSize*2.0,  uv);\n    vec3 bgCol = isPaused ? bgColourPaused : vec3(0.0);\n    vec3 bg = bgCol + vec3(gridVal * 0.1);\n    \n    vec3 cellCol = texture(iChannel0, st * canvasScale).rgb; \n    vec3 col =  mix(bg, cellCol, cellCol.g);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float isCellAlive(vec2 st){\n    // Allows for cells to loop\n    st = mod(st, canvasScale);\n    return float(texture(iChannel0, st).g + texture(iChannel0, st).b + texture(iChannel0, st).r > 0.0);\n}\n\nint getNeighbours(vec2 st, vec2 pixSize){\n    // Get adjacent and diagonal neighbours\n    // Account for aspect ratio\n    pixSize.x /= iResolution.x/iResolution.y;\n    int neighbours = int(isCellAlive(vec2(st.x-pixSize.x, st.y-pixSize.y))\n                   + isCellAlive(vec2(st.x, st.y-pixSize.y))\n                   + isCellAlive(vec2(st.x+pixSize.x, st.y-pixSize.y))\n                   + isCellAlive(vec2(st.x+pixSize.x, st.y))\n                   + isCellAlive(vec2(st.x+pixSize.x, st.y+pixSize.y))\n                   + isCellAlive(vec2(st.x, st.y+pixSize.y))\n                   + isCellAlive(vec2(st.x-pixSize.x, st.y+pixSize.y))\n                   + isCellAlive(vec2(st.x-pixSize.x, st.y))\n                   );\n    \n    return neighbours;\n    \n}\n\n\nint getNeighbours(vec2 st, vec2 pixSize, int radius){\n    // Account for aspect ratio\n    pixSize.x /= iResolution.x/iResolution.y;\n    int neighbours = 0;\n    for (int x=-radius; x <= radius; x++){\n        for (int y=-radius; y <= radius; y++){\n            neighbours += int(isCellAlive(vec2(st.x + pixSize.x*float(x), st.y + pixSize.y*float(y))));\n        }\n    }\n    // Don't include yourself as a neighbour\n    neighbours -= int(isCellAlive(st));\n    return neighbours;\n}\n\n\nbool maze(vec2 st, vec2 pixSize){\n    int neighbours = getNeighbours(st, pixSize, 2);\n    return (bool(isCellAlive(st)) && (neighbours<13 && neighbours>0)) || (neighbours<5 && neighbours>0);\n}\n\nbool plant(vec2 st, vec2 pixSize){\n    int neighbours = getNeighbours(st, pixSize);\n    return (bool(isCellAlive(st)) && (neighbours>1)) || neighbours==3 ;\n}\n\nbool conway(vec2 st, vec2 pixSize){\n    // Alive cell will stay alive if it has 2 or 3 live neighbours.\n    // Dead cell will come to life if it has 3 neighbours.\n    // All other cells will be dead.\n    int neighbours = getNeighbours(st, pixSize);\n    return (bool(isCellAlive(st)) && (neighbours==2 || neighbours==3)) || neighbours==3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 pixSize = vec2(1.0) / iResolution.yy;\n    vec2 canvasResolution = iResolution.xy * canvasScale;\n    \n    vec2 m = iMouse.xy/iResolution.y * canvasScale;\n    m = m - mod(m, pixSize);\n    \n    bool isPaused = texelFetch(iChannel1, ivec2(KEY_SPACE, 2), 0).x == 1.0;\n    bool clearPressed = texelFetch(iChannel1, ivec2(KEY_C, 0), 0).x == 1.0;\n    bool shiftPressed = texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).x == 1.0;\n    bool ctrlPressed = texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x == 1.0;\n\n    \n    vec3 col = vec3(0.0); \n    // Only render inside of the canvas resolution\n    if (!(fragCoord.x > canvasResolution.x || fragCoord.y > canvasResolution.y) && !clearPressed){\n    \n        col.g = texture(iChannel0, st).g;\n\n        // is true if we are switching to next generation this frame\n        // If generationTime is below 0, it will run as fast as it can.\n        bool doNextGeneration = mod(iTime - iTimeDelta, generationTime) >= mod(iTime, generationTime)\n                                || generationTime < 0.0;\n        doNextGeneration = doNextGeneration && !isPaused;\n\n        if (doNextGeneration){\n            \n            bool isAlive = conway(st, pixSize);\n            col.g = float(isAlive);\n        }\n        \n        // Handle drawing\n        bool isMouseDown = iMouse.z > 0.0;\n        \n        // Will be -1 if erasing\n        float eraseMultiplier = (float(shiftPressed) - 0.5) * -2.0;\n        float drawAmount = step(length(m-uv+pixSize/2.0), brushSize*pixSize.y) * float(isMouseDown);\n        drawAmount *= eraseMultiplier;\n        col.g = col.g + drawAmount;\n        col = clamp(col , 0.0, 1.0);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define brushSize 2.0\n#define canvasScale 1.0\n// If this is below 0, the simulation will run as fast as it can\n#define generationTime -1.0\n\nconst int KEY_SPACE = 32;\nconst int KEY_C = 67;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL = 17;\n\n\n\n// Background colour cannot have any green because green is treated as a cell.\nconst vec3 bgColourPaused = vec3(0.1, 0.0, 0.1);", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2yzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 46, 46, 131], [133, 133, 190, 190, 799]], "test": "untested"}
{"id": "dsXyW4", "name": "Circles getting big and small", "author": "evpevdev", "description": "circles growing", "tags": ["circle"], "likes": 0, "viewed": 87, "published": 3, "date": "1690006342", "time_retrieved": "2024-07-30T17:43:22.042318", "image_code": "#define PI 3.14159268\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float angle = 1.;\n    float offset_magnitude = 0.6;\n    \n    float period = 8.0;\n    float radius = 0.1 + (0.4 * (sin(iTime*2.*PI / (period*2.5))+1.0)/2.);\n    float max_width = radius/2.;\n    float width = max_width * abs(sin(iTime*2.*PI / period));\n    float separation_min = (radius - max_width)*sqrt(2.);\n    float separation_max = (radius + max_width)*4.;\n    float separation = (sin(iTime*2.*PI / period)/2.+0.5)*(separation_max-separation_min) + separation_min;\n    //vec2 offset = vec2(cos(angle), sin(angle)) * offset_magnitude;\n    float d = length(vec2(mod(uv.x, separation)-separation/2., \n                          mod(uv.y, separation)-separation/2.));\n    d = abs(d - radius);\n    d = step(width, d);\n    \n    vec3 col = vec3(d, d, d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 130, 1043]], "test": "untested"}
{"id": "DdBBzd", "name": "Fork Outrun Sce Sandoriel 039", "author": "Sandoriel", "description": "A simple outrun-inspired scene with 3D terrain.", "tags": ["3d", "retro", "outrun", "vaporwave"], "likes": 5, "viewed": 188, "published": 3, "date": "1689998156", "time_retrieved": "2024-07-30T17:43:23.017710", "image_code": "// A loose adaptation of noobdawn's \"Vaporwave Outrun\"\n// https://www.shadertoy.com/view/sscSWn\n\nconst float warp = 0.0;\nconst float scan = 0.2;\nconst float aberration = 8.0;\n\nvec4 crt(in vec2 fragCoord, in vec3 color, in vec2 uv) {\n    \n    vec2 dc = abs(0.5 - uv);\n    dc *= dc;\n    \n    uv.x -= 0.5; \n    uv.x *= 1.0 + (dc.y * (0.3 * warp));\n    uv.x += 0.5;\n    \n    uv.y -= 0.5; \n    uv.y *= 1.0 + (dc.x * (0.4 * warp));\n    uv.y += 0.5;\n\n    if (uv.y > 1.0 || uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0) return vec4(0.0, 0.0, 0.0, 1.0);\n    else return vec4(mix(color, vec3(0.0), abs(sin(fragCoord.y) * 0.5 * scan)), 1.0);\n    \n}\n\n// https://www.shadertoy.com/view/4dXXDl\nvec4 chromoAberration(in vec2 uv) {\n\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    vec2 coords = (uv - 0.5) * 2.0;\n    float coordDot = dot(coords, coords);\n    \n    vec2 uvOffset = aberration * coordDot * coords;\n    vec2 uvR = uv - texel.xy * uvOffset;\n    vec2 uvB = uv + texel.xy * uvOffset;\n    \n    vec4 newColor = vec4(0.0, 0.0, 0.0, 1.0);\n    newColor.r = texture(iChannel0, uvR).r;\n    newColor.g = texture(iChannel0, uv).g;\n    newColor.b = texture(iChannel0, uvB).b;\n    return newColor;\n    \n}\nvec4 gradient(in vec2 uv,in vec4 image){\n\n    vec2 center = (uv - 0.5);\n    center = center * 2.0;\n    float d = length(center);\n    \n    \n    d = -d + 1.1;\n    image = image * d;\n    return image;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 image = chromoAberration(uv);\n    image = crt(fragCoord, image.rgb, uv);\n    image = gradient(uv, image);\n    \n    fragColor = image;\n    //fragColor = texture(iChannel0,uv);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float lerp(in float a, in float b, in float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec2 lerp(in vec2 a, in vec2 b, in float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec3 lerp(in vec3 a, in vec3 b, in float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec4 lerp(in vec4 a, in vec4 b, in float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nfloat scale(in float n, in float imin, in float imax, in float omin, in float omax) {\n    return (n - imin) * (omax - omin) / (imax - imin) + omin;\n}", "buffer_a_code": "#define PI 3.14159265358979\n#define ANIM_SPEED 0.5\n#define GRID 32.0\n#define RAY_STEP 0.005\n#define NEAR_PLANE 1.0\n#define FAR_PLANE 512.0 \n#define TERRAIN_HEIGHT 0.33\n\nstruct Raycast {\n    bool hit;\n    vec3 position;\n};\n\nvec3 background(in vec3 direction, in float mouse) {\n    return lerp(vec3(0.8, 0.45, 0.8), vec3(0.2, 0.1, 0.6), abs(direction.y)) * ((mouse + 0.5) * 0.75 + 0.25);\n}\n\nRaycast raycastTerrain(in vec3 origin, in vec3 direction) {\n    \n    // init raycast result\n    Raycast raycast = Raycast(\n        false,\n        vec3(0.0, 0.0, 0.0)\n    );\n    \n    // the height of the terrain at the previous ray step\n    float prevHeight = 0.0;\n    \n    // cast ray\n    for (float i = NEAR_PLANE; i <= FAR_PLANE; i++) {\n    \n         // get current position along ray\n        raycast.position = origin + direction * RAY_STEP * i;\n        \n        // sample terrain height from texture\n        float height = texture(iChannel0, raycast.position.xz / 16.0).x * TERRAIN_HEIGHT;\n        \n        // make valley along x axis flat\n        height *= clamp(pow(abs(raycast.position.x - origin.x) * 1.66, 1.5), 0.0, 1.0);\n        \n        // if ray is clipping terrain\n        if (raycast.position.y < height) {\n        \n            // move back along ray one step\n            vec3 prevPos = raycast.position - direction * RAY_STEP; \n            \n            // find y offset from the terrain of both points along ray\n            float prevOffset = prevPos.y - prevHeight;\n            float currOffset = height - raycast.position.y;\n            \n            // interpolate between offsets to find terrain surface intersection\n            float t = prevOffset / (prevOffset + currOffset);\n            raycast.position = prevPos + direction * RAY_STEP * t;\n            \n            // mark as hit\n            raycast.hit = true;\n            return raycast;\n            \n        }\n        \n        // cache current terrain height\n        prevHeight = height;\n        \n    }\n    \n    return raycast;\n    \n}\n\nvec3 terrainColor(in vec3 cameraPosition, in vec3 rayPosition, in vec3 backgroundColor, in float mouse) {\n    \n    // grid lines\n    float fx = abs(fract(rayPosition.x * GRID + 0.5) - 0.5);\n    float fz = abs(fract(rayPosition.z * GRID + 0.5) - 0.5);\n\n    // grid line color\n    vec3 gridLineColor = vec3(0.3, 0.2, 0.6);\n    // current background color\n    vec3 bg = pow(backgroundColor, vec3(3.0, 3.0, 2.0));\n    \n    // the distance along the current ray as a 0 -> 1 mask \n    float dist = length(rayPosition.xz - cameraPosition.xz) * 0.125;\n    dist = clamp(dist, 0.0, 1.0);\n    \n    // the current color\n    vec3 color = bg * dist + gridLineColor * (1.0 - dist);\n    \n    // basic post-processing\n    float sweepingLight = texture(iChannel0, rayPosition.xz / 64.0 + vec2(0.0, -iTime * 0.01)).x * 0.5 + 0.5;\n    float lineGlow = abs(rayPosition.z - cameraPosition.z) + 0.25;\n    color /= min(sweepingLight, lineGlow);\n    \n    // apply grid\n    dist = min(fx, fz);\n    \n    // reduce line spread\n    dist = smoothstep(dist, 0., 0.02);\n    \n    // apply grid mask to background\n    vec3 result = bg * dist;\n    \n    // add grid color with grid mask\n    result += color * (1.0 - dist);\n    \n    return result;\n}\n\nconst vec3 SUN_DIR = normalize(vec3(0.0, 0.1, 1.0));\nconst vec4 SUN_COLOR_TOP = vec4(1.0, 0.0, 0.5, 1.0);\nconst vec4 SUN_COLOR_BOTTOM = vec4(2.0, 2.0, 0.0, 1.0);\n\nvec4 sun(in vec3 direction, in float animSpeed, in float mouse) {\n\n    mouse = clamp(mouse, -0.5, 0.125);\n\n    vec3 sunDir = SUN_DIR;\n    sunDir.y += mouse - 0.1;\n    \n    float sunMask = pow(smoothstep(0.95, 0.9, dot(direction, sunDir)), 0.125);\n\n    // generate horizontal cuts\n    float cut = 3.0 * sin((direction.y + iTime * animSpeed * 0.125) * 75.0) * (1.0 - sunMask);\n    cut += clamp((direction.y - mouse + 0.1) * 14.0 + 1.5, -7.0, 7.0);\n        \n    cut = clamp(cut, 0.0, 1.0);\n\n    // interpolate between top and bottom colors and masking cut lines\n    float a = abs(direction.y) + mouse;\n    vec4 color = lerp(SUN_COLOR_TOP, SUN_COLOR_BOTTOM, a);\n    color.a = lerp(color.a * cut, 0.0, sunMask);\n    return color * (mouse + 1.0);\n    \n}\n\n// generates ray direction at clipspace coordinate with camera settings\nvec3 perspective(in vec2 clip, in vec3 target, in vec3 position, in float fov, in vec3 up) {\n    vec3 w = normalize(target - position);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u, w));\n    return vec3(normalize(clip.x * u + clip.y * v + fov * w));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 clip = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // mouse input is inverted to ensure that the sun is above the horizon on shader load\n    float mouse = clamp((1.0 - (iMouse.y / iResolution.y)) - 0.5, -0.5, 0.5);\n    float animSpeed = ANIM_SPEED * mouse;\n    \n    float deltaZ = iTime * ANIM_SPEED;\n    vec3 cameraPosition = vec3(0.0, 0.1, deltaZ - 1.0);\n    vec3 cameraTarget = vec3(0.0, 0.1, deltaZ);\n    \n    vec3 raydir = perspective(clip, cameraTarget, cameraPosition, 1.25, vec3(0.0, 1.0, 0.0));\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec3 background = background(raydir, mouse);\n    Raycast raycast = raycastTerrain(cameraPosition, raydir);\n    vec3 terrain = terrainColor(cameraPosition, raycast.position, background, mouse);\n    if (raycast.hit) color = vec4(terrain, 1.0);\n    else {\n        vec4 sun = sun(raydir, animSpeed, mouse);\n        color = vec4(background * (1.0 - sun.w) + sun.xyz * sun.w, 1.0);\n    }\n    \n    fragColor = color;\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 232, 232, 631], [633, 674, 709, 709, 1181], [1182, 1182, 1222, 1222, 1381], [1382, 1382, 1437, 1437, 1672]], "test": "untested"}
{"id": "DsSfzc", "name": "mc water", "author": "ArmandB", "description": "sydfgybf", "tags": ["procedural", "2d", "sdf"], "likes": 4, "viewed": 188, "published": 3, "date": "1689973180", "time_retrieved": "2024-07-30T17:43:23.853476", "image_code": "float smin( float a, float b){\n    a = pow(a, 8.0);\n    b = pow(b, 8.0);\n    return pow(a*b/(a+b), 0.125);\n}\n\nbool isWater(vec2 p){\n    return texelFetch(iChannel0,ivec2(mod(p,64.0)),0).r*texelFetch(iChannel0,ivec2(mod(p/2.0,64.0)),0).r < 0.5;\n}\n\nfloat wave(float x){\n    return 2.0*abs(fract(x/16.0) - 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord);\n    vec2 block = floor(uv/16.0);\n    \n    vec3 col = mix(vec3(0.7,1.0,0.6), vec3(0.1,0.7,0.5), (texelFetch(iChannel0,ivec2(mod(uv,16.0)),0).r + 0.5)*(texelFetch(iChannel0,ivec2(mod(uv/2.0,8.0)),0).r + 0.1));\n    \n    if (isWater(block)){\n        vec2 m = uv.xy/16.0 - block.xy;\n        vec2 p = 1.0 - m - 0.0625;\n        float d = !isWater(block + vec2(1,0)) ? p.x : 1.0;\n        d = smin(d, !isWater(block - vec2(1,0)) ? m.x : 1.0);\n        d = smin(d, !isWater(block + vec2(0,1)) ? p.y : 1.0);\n        d = smin(d, !isWater(block - vec2(0,1)) ? m.y : 1.0);\n        if (d >= 0.5){\n            d = smin(d, !isWater(block + vec2(1,1)) ? sqrt(p.x*p.x + p.y*p.y) : 1.0);\n            d = smin(d, !isWater(block + vec2(-1,1)) ? sqrt(m.x*m.x + p.y*p.y) : 1.0);\n            d = smin(d, !isWater(block + vec2(1,-1)) ? sqrt(p.x*p.x + m.y*m.y) : 1.0);\n            d = smin(d, !isWater(block + vec2(-1,-1)) ? sqrt(m.x*m.x + m.y*m.y) : 1.0);\n        }\n        \n        vec2 wavecoord = (uv + vec2(iTime + wave(iTime+uv.y),0))/vec2(2,1);\n        float shorewaveheight = float(max(wave(floor(d*16.0 + iTime*4.0)), wave(floor(d*16.0 - iTime*4.0))) == 1.0);\n        float oceanwaveheight = max(texelFetch(iChannel0,ivec2(mod(wavecoord,64.0)),0).r - 0.99,0.0)*100.0;\n        float k = d == 0.0 ? 1.0 : shorewaveheight*clamp(1.0 - d*4.0,0.0,1.0);\n        if (d == 1.0/16.0) k = max(k,max(texelFetch(iChannel0,ivec2(mod(uv/2.0,64.0)),0).r - 0.3,0.0));\n        vec3 basecol = mix(vec3(0.28,0.85,0.91),vec3(0.17,0.54,0.71),clamp(floor(d*d*8.0)/4.0,0.0,1.0));\n        col = mix(basecol,vec3(1),clamp(max(floor(k*4.0)/4.0, oceanwaveheight),0.0,1.0));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 108], [110, 110, 131, 131, 245], [247, 247, 267, 267, 310], [312, 312, 369, 369, 2068]], "test": "untested"}
{"id": "Dtf3Dl", "name": "Human Shader - Code", "author": "iq", "description": "The shader I used while designing the Human Shader experiment ([url]https://humanshader.com/[/url]).", "tags": ["3d", "human", "humanshader"], "likes": 72, "viewed": 2764, "published": 3, "date": "1689972196", "time_retrieved": "2024-07-30T17:43:24.806928", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The shader I used while designing the Human Shader experiment\n//\n// https://humanshader.com\n\nint shift( int x, int n )\n{\n    if( n==1 ) { return (x+5)/10; }\n    if( n==2 ) { return (x+50)/100; }\n    if( n==3 ) { return (x+500)/1000; }\n                 return (x+5000)/10000;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    int R, B;\n\n    //-------------------------    \n    // Section A (2 MUL, 3 ADD)\n    //-------------------------    \n    int u = x-36;\n    int v = 18-y;\n    int u2 = u*u;\n    int v2 = v*v;\n    int h = u2 + v2;\n    //-------------------------  \n    \n    if( h < 200 ) \n    {\n        //-------------------------------------\n        // Section B, Sphere (4/7 MUL, 5/9 ADD)\n        //-------------------------------------\n        R = 420;\n        B = 520;\n\n        int t = 5000 + h*8;\n        int p = shift(t*u,2);\n        int q = shift(t*v,2);\n        int s = 2*q;\n        \n        // bounce light\n        int w = 18 + shift(p - s,2);\n        if( w>0 ) R += w*w;\n        \n        // sky light / ambient occlusion\n        int o = s + 2200;\n        R = shift(R*o,4);\n        B = shift(B*o,4);\n\n        // sun/key light\n        if( p > -q )\n        {\n            int w = shift(p+q,1);\n            R += w;\n            B += w;\n        }\n        //-------------------------  \n\t}\n    else if( v<0 )\n    {\n        //-------------------------------------\n        // Section C, Ground (5/9 MUL, 6/9 ADD)\n        //-------------------------------------\n        R = 150 + 2*v;\n        B = 50;\n        \n        int p = h + 8*v2;\n        int c = 240*(-v) - p;\n\n        // sky light / ambient occlusion\n        if( c>1200 )\n        {\n            int o = shift(6*c,1);\n            o = shift(c*(1500-o),2) - 8360;\n            R = shift(R*o,3);\n            B = shift(B*o,3);\n        }\n\n        // sun/key light with soft shadow\n        int r = c + u*v;\n        int d = 3200 - h - 2*r;\n        if( d>0 ) R += d;\n        //-------------------------  \n    }\n    else\n    {\n        //------------------------------\n        // Section D, Sky (1 MUL, 2 ADD)\n        //------------------------------\n        int c = x + 4*y;\n        R = 132 + c;\n        B = 192 + c;\n        //-------------------------  \n    }\n    \n    //-------------------------\n    // Section E (3 MUL, 1 ADD)\n    //-------------------------\n    R = min(R,255);\n    B = min(B,255);\n    \n    int G = shift(R*7 + 3*B,1);\n    //-------------------------  \n\n    return vec3(R,G,B);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 resolution = vec2(71,40);\n\n    ivec2 ij = ivec2(floor(resolution*fragCoord/iResolution.xy));\n    \n    vec3 col = compute( ij.x, 39-ij.y );\n    \n    // draw grid lines\n    {\n    ivec2 ijp = ivec2(floor(resolution*(fragCoord-vec2(1,1))/iResolution.xy));\n    ivec2 ijn = ivec2(floor(resolution*(fragCoord+vec2(1,1))/iResolution.xy));\n    if( ijn.x!=ij.x || ijn.y!=ij.y || ijp.x!=ij.x || ijp.y!=ij.y) col*=0.75;\n    }\n    \n    fragColor = vec4( col/255.0, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtf3Dl.jpg", "access": "api", "license": "mit", "functions": [[1174, 1174, 1201, 1201, 1357], [1359, 1389, 1419, 1419, 3543], [3549, 3549, 3606, 3606, 4082]], "test": "untested"}
{"id": "cdjfRc", "name": "Deprecated,Bean's Default Shader", "author": "beans_please", "description": "- My starting point for a new shader.\n\n- Helper \"modules\" can be enabled/disabled separately in the Common tab.\n\n- Each tab starts with a description of itself to make it easier to store local backups.\n\n- Feel free to copy and reuse.  :)", "tags": ["default", "shader", "utils", "helpers"], "likes": 2, "viewed": 70, "published": 3, "date": "1689964097", "time_retrieved": "2024-07-30T17:43:25.807253", "image_code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Render\n    vec3 col = vec3(uv, 0.0) + 0.1 * random();\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 1\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 0\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n", "buffer_a_code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: None\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 250, 250, 331], [333, 333, 364, 381, 421], [423, 423, 478, 501, 761]], "test": "untested"}
{"id": "csjBzc", "name": "Ball With Humans", "author": "elenzil", "description": "Forked from Xor's https://shadertoy.com/view/ddjBRK", "tags": ["humans"], "likes": 6, "viewed": 189, "published": 3, "date": "1689962757", "time_retrieved": "2024-07-30T17:43:26.770676", "image_code": "// Fork of \"Ball [408 Chars]\" by Xor. https://shadertoy.com/view/ddjBRK\n// 2023-07-21 17:57:24\n\n// Hash without Sine by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13A(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Humanshader.com\n//-9 thanks to SnoopethDuckDuck\nvoid mainImage(out vec4 O, vec2 I)\n{\n    I = ceil(I/iResolution.y*40.)-vec2(37,23);\n    float v = I.y,\n    h = dot(I,I),\n    z;\n    O = vec4(240,0,300,0)+I.x-4.*I.y;\n    if (h<2e2)\n    {\n        O = vec4(420,0,520,0);\n        I *= 50.+.08*h;\n        z = (I.x-I.y*2.)/1e2+18.;\n        z>0.?O.r += z*z : z;\n        O = O*(I.y+11e2)/5e3 + max(I.x+I.y,0.)*.1;\n    }\n    else if (v<0.)\n    {\n        O.r = 150.+v+v;\n        O.b = 50.;\n        z = -240.*v - h-8.*v*v;\n        z>12e2? O *= z*(.015-6e-6*z)-8.36 : O;\n        O.r += max(32e2 - h - 2.*(z+I.x*v),0.);\n    }\n    \n    float hash;\n    \n    hash = hash13A(vec3(I, 0.0));\n    if (hash < 0.02) {\n        O.r = hash / 0.02 * 255.0;\n    }\n    if (hash > 0.98) {\n        O.r = 255.0;\n        O.b = (hash - 0.98) / 0.02 * 255.0;\n    }\n    \n    O = min(O/255., 1.);\n    \n    O.g = .7*O.r+.3*O.b;\n    hash = hash13A(vec3(I, 30.0));\n    if (hash < 0.02) {\n        O.g = hash / 0.02 * 2.0;\n    }\n    \n    hash = hash13A(vec3(I, 50.0));\n    if (hash > smoothstep(0.0, 0.2, pow(fract(floor(iTime * 8.0) / 8.0 / 10.0), 3.0))) {\n        O.rgb *= 0.0;\n    }\n\n    \n}\n\n//Original:\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1.-uv.y;\n    vec2 P = round(uv*vec2(71,40)-.5);\n    float x = P.x;\n    float y = P.y;\n    \n    float u = x-36.;\n    float v = 18.-y;\n    float h = u*u+v*v;\n    \n    float R,G,B;\n    if (h<200.)\n    {\n        R = 420.;\n        B = 520.;\n        float t = 5000.+8.*h;\n        float p = round(t*u/1e2);\n        float q = round(t*v/1e2);\n        float s = 2.*q;\n        float w = round((1000. + p - s)/1e2)+8.;\n        if (w>0.) R = R + w*w;\n        float o = s+2200.;\n        R = round(R*o/1e4);\n        B = round(B*o/1e4);\n        if (p>-q)\n        {\n            w = round((p+q)/1e1);\n            R += w;\n            B += w;\n        }\n    }\n    else if (v<0.)\n    {\n        R = 150.+2.*v;\n        B = 50.;\n        float p = h+8.*v*v;\n        float c = 240.*-v - p;\n        if (c>1200.)\n        {\n            float o = round(6.*c/1e1);\n            o = c*(1500.-o);\n            o = round(o/1e2)-8360.;\n            R = round(R*o/1e3);\n            B = round(B*o/1e3);\n        }\n        float r = c+u*v;\n        float d = 3200. - h - 2.*r;\n        if (d>0.) R += d;\n    }\n    else\n    {\n        float c = x+4.*y;\n        R = 132.+c;\n        B = 192.+c;\n    }\n    R = min(R, 255.);\n    B = min(B, 255.);\n    G = round((7.*R+3.*B)/1e1);\n    \n    fragColor = vec4(R,G,B,255)/255.;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 175, 199, 199, 305], [307, 357, 393, 393, 1459]], "test": "untested"}
{"id": "cdjBzc", "name": "motion blurred disk", "author": "TinyTexel", "description": "Analytical motion blur for a 2d disk.", "tags": ["2d", "blur", "motion", "disk"], "likes": 1, "viewed": 43, "published": 3, "date": "1689962360", "time_retrieved": "2024-07-30T17:43:27.668276", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\nfloat capsule_aa(vec2 tc, float r, float s, vec2 a, vec2 b)\n{\n    vec2 vec = b - a;\n    \n    tc -= a;\n    \n    float tt = dot(vec, vec);\n    \n    float rcptt = 1.0 / tt;\n    \n    vec2 p = vec * (tt == 0.0 ? 0.0 : clamp(dot(tc, vec * rcptt), 0.0, 1.0));\n    \n    float l = length(tc - p);\n    \n    float v = clamp((r - l) * s * 0.5, 0.0, 1.0);\n    \n    v = v*v*(3.0-2.0*v);\n    \n    return v;\n}\n\nfloat lineseg_mb(float x, float r, float t)\n{\n    float u = r + t * 0.5;\n    \n    return clamp(u - abs(-x - r + u), 0.0, min(2.0 * r, t)) * (1.0/t);\n}\n\nfloat disk_mb(vec2 tc, float r, float t)\n{\n    float r0 = sqrt(max(0.0, r*r - tc.y*tc.y));\n    \n    return lineseg_mb(tc.x, r0, t);\n}\n\n#if 1\nfloat disk_mb(vec2 tc, float r, vec2 a, vec2 b)\n{\n    float aa_mask = capsule_aa(tc, r, iResolution.y, a, b);\n\n    vec2 vec = b - a;\n    \n    tc -= a;\n    \n    float tt = dot(vec, vec);\n        \n    float rcptt = 1.0 / tt;\n    \n    vec2 dirX = vec * rcptt;\n    \n    vec2 dirY = vec2(-dirX.y, dirX.x);\n        \n    float x = dot(tc, dirX);\n    float y = dot(tc, dirY);\n    \n    float r0 = sqrt(max(0.0, r*r * rcptt - y*y));\n    \n    float u = r0 + 0.5;\n    \n    float v = clamp(u - abs(-x - r0 + u), 0.0, min(2.0 * r0, 1.0));\n\n    if(tt == 0.0) v = dot(tc, tc) < r*r ? 1.0 : 0.0;\n    \n    v *= aa_mask;\n    \n    return v;\n}\n#else\nfloat disk_mb(vec2 tc, float r, vec2 a, vec2 b)\n{\n    vec2 vec = b - a;\n    \n    tc -= a;\n    \n    float t = length(vec);\n    \n    if(t == 0.0) return dot(tc, tc) < r*r ? 1.0 : 0.0;\n    \n    vec2 dirX = vec * (1.0/t);\n    \n    vec2 dirY = vec2(-dirX.y, dirX.x);\n    \n    tc = vec2(dot(tc, dirX), dot(tc, dirY));\n    \n    return disk_mb(tc, r, t);\n}\n#endif\n\nfloat disk_mb_aa(vec2 tc, float r, float s, vec2 a, vec2 b)\n{\n    vec2 vec = b - a;\n    \n    tc -= a;\n    \n    float tt = dot(vec, vec);\n        \n    float rcptt = 1.0 / tt;\n    \n    vec2 dirX = vec * rcptt;\n    \n    vec2 dirY = vec2(-dirX.y, dirX.x);\n        \n    float x = dot(tc, dirX);\n    float y = dot(tc, dirY);\n    \n    float r0 = sqrt(max(0.0, r*r * rcptt - y*y));\n    \n    float u = r0 + 0.5;\n    \n    float v = clamp(u - abs(-x - r0 + u), 0.0, min(2.0 * r0, 1.0));\n\n    if(tt == 0.0) v = dot(tc, tc) < r*r ? 1.0 : 0.0;\n    \n    // aa\n    {\n        vec2 p = vec * (tt == 0.0 ? 0.0 : clamp(x, 0.0, 1.0));\n\n        float l = length(tc - p);\n\n        float m = clamp((r - l) * s * 0.5, 0.0, 1.0);\n\n        v *= m*m*(3.0-2.0*m);\n    }\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 tc = (uv0 - iResolution.xy*0.5) / iResolution.yy;\n    \n    vec3 col = vec3(0.0);\n    \n    float v = 0.0;\n    \n    float r = 0.25;\n    \n    float t = 0.5;\n    \n  #if 1\n     \n    v = disk_mb(tc, r, t);\n    v = disk_mb(tc, r, vec2(-0.0, -0.), vec2(0., 0.));\n    v = disk_mb_aa(tc, r, iResolution.y, vec2(-0.2, -0.), vec2(0.2, 0.));\n    \n    //v = capsule_aa(tc, r, iResolution.y, vec2(-0.1, -0.1), vec2(.1, 0.));\n    \n    \n  #else\n    // numerical reference\n    float count = 128.0;\n    \n    for(float i = 0.0; i <= count; ++i)\n    {\n        float xo = (i / count) * t;\n        float v0 = abs(tc.x - xo) < sqrt(max(0.0, r*r - tc.y*tc.y)) ? 1.0 : 0.0;\n        \n        v += v0;\n    }\n    \n    v /= count+1.0;\n  #endif\n    \n    col = vec3(v);\n    //col = vec3(v != 0.0 ? 1.0 : 0.0);\n    //col = vec3(v * 1024.0*1024.0);\n    \n    outCol = vec4(pow(col, vec3(1.0/2.2)), 0.0);\n    outCol = vec4(col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjBzc.jpg", "access": "api", "license": "cc0-1.0", "functions": [[71, 71, 132, 132, 464], [466, 466, 511, 511, 616], [618, 618, 660, 660, 751], [1745, 1745, 1806, 1806, 2506], [2509, 2509, 2557, 2557, 3466]], "test": "untested"}
{"id": "cs2fR3", "name": "Cool Rocks [609 Chars]", "author": "SnoopethDuckDuck", "description": "Golifng welcome, im sure loads of characters could be cut", "tags": ["texture", "map", "25d", "bump", "rocks", "golf"], "likes": 25, "viewed": 333, "published": 3, "date": "1689953230", "time_retrieved": "2024-07-30T17:43:28.445199", "image_code": "// -14 thanks to Fabrice! [610]\n#define X(u) texture(iChannel0, u+t).r//\n#define D(a) cos(a+vec2(0,11))//\n#define S smoothstep(0.,//\n#define K X(U\n\nvoid mainImage( out vec4 O, vec2 I )  {\n    vec2  R = iResolution.xy,\n          U = (I-.5*R)/R.y, \n          n,\n          e = vec2(.001, 0);\n    float t = .02 * iTime,\n          c,  s;         \n    \n    for (; c++ < 40.; s = K) ) \n        U += D(3. * U.x + 40. * t) * (1. - 1. / cosh(3. * s)) / 25e2\n           + D(1e5 * s) / cosh(7. * s) / 714.,\n        U *= .99;\n       \n    n = vec2( K + e), K + e.yx) );\n    n = (  K) + K - e) + K - e.yx) + n.x + n.y  ) / 5. - n;\n    c = exp(-1.2 * pow(.5 - .353 * (n.x + n.y) / length(n), .25)); \n    \n    O =  ( X(8. * n - t) + 70. * n.y ) \n        * vec4(.95 + .05 * c, .5 + .5 * c, c, 0);\n    c = K) - .28 - .1 * cos(U.x + 20. * t),\n    s = S.09,c);\n    \n    O *= (1.-s) * vec4(.3, .62, 1, 0) + s;    \n    O = pow(mix(.4+.6*exp(-6.*(.5+.5*cos(O+O+40.*(U.x+U.y)))), O, S.04,abs(c))),\n            vec4(.87));\n}\n\n\n/*\n// Original [624]\n#define X(u) texture(iChannel0, u+t).r\n#define D(a) vec2(cos(a),sin(a))\n\n#define S s = smoothstep(\n#define K X(U\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec2 R = iResolution.xy,\n         U = (I-.5*R)/R.y,\n         n,\n         e = vec2(.001, 0);\n\n    float t = .02 * iTime,\n          c,\n          s;         \n    \n    for (; c++ < 40.; s = K)) {\n        U += D(3. * U.x + 40. * t) * (1. - 1. / cosh(3. * s)) / 25e2\n           + D(1e5 * s) / cosh(7. * s) / 714.;\n        U *= .99;\n    }\n    \n    n = vec2(K + e), K + e.yx));\n    n = (K) + K - e) + K - e.yx) + n.x + n.y) / 5. - n;\n    \n    // was .5+.5*dot(normalize(n), D(5pi/4))\n    c = exp(-1.2 * pow(.5 - .353 * (n.x + n.y) / length(n), .25)); \n    \n    O = (X(8. * n - t) + 70. * n.y) \n      * vec4(.95 + .05 * c, .5 + .5 * c, c, 0);\n    \n    S c = .28 + .1 * cos(U.x + 20. * t),\n          .09 + c, \n          K));\n    \n    O *= (1.-s) * vec4(.3, .62, 1, 0) + s;\n    \n    S 0., .04, abs(K) - c));\n    \n    O = pow(mix(.4+.6*exp(-6.*(.5+.5*cos(2.*O+40.*(U.x+U.y)))), O, s),\n            vec4(.87));\n}\n//*/", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2fR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DsBfR3", "name": "waves camera version 2", "author": "tianluo970922", "description": "waves camera version 2", "tags": ["wavescameraversion2"], "likes": 0, "viewed": 125, "published": 3, "date": "1689923755", "time_retrieved": "2024-07-30T17:43:29.493396", "image_code": "\n// Redefine below to see the tiling...\n//#define SHOW_TILING\nconst vec2 target_resolution = vec2(940, 86);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n    \n\tfloat time = iTime * .2 + 23.0;\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5; \n    \n    vec2 uv0 = uv; \n    uv0.x *= 6.;\n    uv0.y *= 1.;\n    uv0.y += iTime * 0.1;\n    \n    vec2 p = mod(uv0*TAU, TAU) - 250.0;\n    \n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .009;\n    \n    //pattern control\n    float iTimeCtrl = iTime * 0.05;\n    iTimeCtrl = pow(iTimeCtrl, 1.1);\n    \n    float scale = 2.0; \n    float timetest = -sin((iTimeCtrl * 1.0/scale - 0.25) * 3.1415926 * 4.0/2.0) * 0.5 + 0.5;\n    float endPattern = mix(4.5, 2.7, uv.y + pow(1.0-uv.y, 5.0));\n    float pattern = mix(3.0, endPattern, timetest * 1.2);\n    \n    //通过算法测算出water的pattern，通过增大tiling的值可以增大pattern的密度\n\tfor (int n = 0; n < int(MAX_ITER); n++) \n\t{\n\t\tfloat t = time * (1.0 - (2.5/ float(n+1)));\n        float t1= time * .2;\n\t\ti = p + vec2(cos(t1 - i.x) + sin(t + i.y), sin(t - i.y) + cos(t1 + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+ t1)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(pattern);\n    \n    //1.12 可以调整白色的对比度，数值越高，对比度越高\n    //1. 1可以调整蓝色的深浅,数值越高，蓝色越浅，白色越多且会过曝\n\tc = 1.25 - pow(c, 1.5);\n    \n    float intensityblue = mix(13.0, 10.0, timetest);\n    vec3 blueChange = mix(vec3(0.000,0.545,0.780), vec3(0.000,0.349,0.502), timetest);\n    //7.5可以调整蓝色的深浅，数值越高，蓝色越深，但不会影响白色的细节\n\tvec3 colour = vec3(pow(abs(c), intensityblue));\n    colour = clamp(colour + blueChange, 0.0, 1.0);\n                                             \n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n    //WhiteEdge\n    float offset = uv.y + iTimeCtrl;\n    float y = mod(offset, scale);\n    \n    float d = smoothstep(0.1 * scale, 0.0  * scale, y) * 1.0;\n    float d1 = smoothstep(0.85  * scale, 1.0  * scale, y) * 1.0;\n    vec3 maskColor =  vec3(d) + vec3(d1);\n    \n    //maskColor *= pow(1.0 - uv.y, 2.0);   //test0 从0-1.0\n    //maskColor *= pow(1.0 - uv.y, 2.0)/2.0 + 0.5; //test1 从0.5-1.0\n    maskColor *= smoothstep(0.0, 1.0, pow(1.0 - uv.y, 1.0) + 0.15) * 0.8; //test2 从0.2-1.0\n    \n    float near = pow(uv.y, 3.5) * mix(0.75, 0.5, timetest);\n    vec3 frontEdge = vec3(near) * 1.;\n    \n    //结尾的mask\n    float mask = pow(uv.y, 1.0);\n    //0.492的值越小，黑色边缘越硬\n    mask = smoothstep(0.,0.672,uv.y);\n    \n    fragColor.rgb = colour;\n    //maskColor *= pow(mask1, 1.5); \n    fragColor.rgb = colour + maskColor + frontEdge ;\n    \n    //摄像机追踪\n    float cameraTrackingPosition; //摄像机追踪的变量\n    cameraTrackingPosition = 0.0; \n    float mask1 = cubicPulse(cameraTrackingPosition,0.2,uv.x);\n    mask1 += 0.05;\n    \n    fragColor.rgb = mix(vec3(0.000,0.208,0.341), fragColor.rgb,  mask1  );\n\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 201, 201, 295], [297, 297, 355, 355, 4059]], "test": "untested"}
{"id": "DsSBR3", "name": "waves camera version 1", "author": "tianluo970922", "description": "waves camera version 1", "tags": ["wavescameraversion1"], "likes": 0, "viewed": 101, "published": 3, "date": "1689921822", "time_retrieved": "2024-07-30T17:43:30.477765", "image_code": "\n// Redefine below to see the tiling...\n//#define SHOW_TILING\nconst vec2 target_resolution = vec2(940, 86);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .3 + 23.0;\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5; \n    \n    vec2 uv0 = uv; \n    uv0.x *= 5.5;\n    uv0.y *= 1.;\n    uv0.y += iTime * 0.1;\n    \n    vec2 p = mod(uv0*TAU, TAU) - 250.0;\n    \n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n    float c1 = 1.0;\n\tfloat inten = .009;\n    \n    //pattern control\n    float iTimeCtrl = iTime * 0.12 - 1.0;\n    //iTimeCtrl = 1.0;\n    float scale = 2.0; \n    float timetest = -sin((iTimeCtrl * 1.0/scale - 0.25) * 3.1415926 * 4.0/2.0) * 0.5 + 0.5;\n    float endPattern = mix(5.0, 3.5, uv.y + pow(1.0-uv.y, 5.0));\n    float pattern =  mix(3.0, endPattern, timetest * 1.2);\n    \n    //通过算法测算出water的pattern，通过增大tiling的值可以增大pattern的密度\n\tfor (int n = 0; n < int(MAX_ITER); n++) \n\t{\n\t\tfloat t = time * (1.0 - (2.5/ float(n+1)));\n        float t1= time * .2;\n\t\ti = p + vec2(cos(t1 - i.x) + sin(t + i.y), sin(t - i.y) + cos(t1 + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+ t1)/inten),p.y / (cos(i.y+t)/inten)));\n        c1 += 1.0/length(vec2(p.x / (sin(i.x+ t1)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(pattern);\n    c1 /= float(3);\n    \n    //1.12 可以调整白色的对比度，数值越高，对比度越高\n    //1. 1可以调整蓝色的深浅,数值越高，蓝色越浅，白色越多且会过曝\n\tc = 1.25 - pow(c, 1.1);\n    c1 = 1.25 - pow(c1, 1.1);\n    \n    float intensityblue = mix(13.0, 9.0, timetest);\n    vec3 blueChange = mix(vec3(0.000,0.212,0.302), vec3(0.000,0.349,0.502), timetest);\n    //7.5可以调整蓝色的深浅，数值越高，蓝色越深，但不会影响白色的细节\n\tvec3 colour = vec3(pow(abs(c), intensityblue));\n    colour = clamp(colour + blueChange, 0.0, 1.0);\n    \n    vec3 colour1 = vec3(pow(abs(c1), 9.0));\n    colour1 = clamp(colour1 + blueChange, 0.0, 1.0);\n    \n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n    //WhiteEdge\n    float offset = uv.y + iTimeCtrl;\n    float y = mod(offset, scale);\n    \n    float d = smoothstep(0.2 * scale, 0.0  * scale, y) * 1.0;\n    float d1 = smoothstep(0.9  * scale, 1.0  * scale, y) * 1.0;\n    vec3 maskColor =  vec3(d) + vec3(d1);\n    \n    //控制maskColor的透明度\n    //maskColor *= pow(1.0 - uv.y, 2.0);   //test0 从0-1.0\n    //maskColor *= pow(1.0 - uv.y, 2.0)/2.0 + 0.5; //test1 从0.5-1.0\n    maskColor *= smoothstep(0.0, 1.0, pow(1.0 - uv.y, 1.0) + 0.15) * 0.8; //test2 从0.2-1.0\n    \n    float near = pow(uv.y, 3.5) * mix(0.75, 0.5, timetest);\n    vec3 frontEdge = vec3(near);\n    \n    fragColor.rgb = colour;\n    fragColor.rgb = colour + maskColor + frontEdge ; \n    \n    //debug\n    //fragColor.rgb = colour1 + frontEdge;\n    float button;\n    //button = 1.0;\n    button = smoothstep(0.0, 1.0, iTime * 0.05);\n    \n    fragColor.rgb = mix(colour1 + pow(uv.y, 6.0), fragColor.rgb, button);\n    \n    //结尾的mask\n    float mask = pow(uv.y, 1.0);\n    //0.492的值越小，黑色边缘越硬\n    mask = smoothstep(0.0,0.472,uv.y);\n    \n    //fragColor *= (mask);\n    //fragColor = vec4(endColor, 1.0);\n    //fragColor = vec4(frontEdge + maskColor,1.0);\n    \n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 201, 201, 295], [297, 297, 355, 355, 4313]], "test": "untested"}
{"id": "csBBRV", "name": "many balls around me", "author": "iY0Yi", "description": "just to remind my old shader algorithm.\ni forgot it by my self!\nthis time, with a scalable grid size.", "tags": ["cineshader", "neighbors"], "likes": 23, "viewed": 1638, "published": 3, "date": "1689913233", "time_retrieved": "2024-07-30T17:43:31.260672", "image_code": "#define PI acos(-1.)\n#define TAU (PI*2.)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// \"hash11()\" - \"hash44()\"\n// by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nvec4 bUni(vec4 a, vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\n// from iq\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n#define MIN_DIST 0.001\n#define MAX_DIST 1500.0\n#define COL_AMB vec3(0.541,0.718,1.000)\n#define COL_L0 vec3(1.000,0.965,0.898)\n#define COL_FLR vec3(0.792,0.769,0.780)*(1./PI)\n#define COL_S1 vec3(0.537,0.561,0.580)*(1./PI)\n#define COL_S2 vec3(0.259,1.000,0.545)*(1./PI)\n#define COL_S3 vec3(0.224,0.596,0.996)*(1./PI)\n#define COL_S4 vec3(0.545,0.302,1.000)*(1./PI)\n\n// i forgot where i found these bx_cossin()...\n// maybe from eiffie's shader\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\nvec3 grd = vec3(0);\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, vec3(0));\n    \n    float sphereRad = .5*(cos(iTime*.25)+1.)+.2;\n    float gridSize = pow(sin(iTime)*5.+5.,1.5)*2.+sphereRad*1.5;\n\n    // grid\n    vec3 q = p;\n    q.xz = mod(q.xz, gridSize);\n    q.y-= sphereRad;\n    \n    vec2 iqq = floor(p.xz/gridSize);\n    \n    bool bw = sin(iTime*.5+PI*.25)>0.;\n    \n    // tap only 4 neighbors\n    // see the image posted as comment\n    for(int x=-1; x<=0; x++)\n    for(int z=-1; z<=0; z++){\n    \n        vec2 offset = vec2(x,z);\n        vec2 rnd = hash22(iqq-offset);\n\n        // neighbor cell position\n        vec3 qq = q;\n        qq.xz+=offset*gridSize; \n        \n        // animation\n        float v =  rnd.x * iTime*.5 * sign(rnd.y-rnd.x); \n        vec2 sq = bx_cossin(v)*(gridSize-sphereRad)*rnd.y;\n        qq.xz+= sq;\n        \n        // jumping. just for fun.\n        float j = abs(sin(rnd.x*3.+iTime*3.*4.))*rnd.x*5.;\n        qq.y-=j;\n        \n        // random color\n        vec2 iq = abs(iqq-offset);\n        iq = vec2(int(iq.x)%2, int(iq.y)%2);\n        float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .05 : .05;\n        vec3 m = (rnd.y<.5) ? (tile<.5)?COL_S1:COL_S2 : (tile<.5)?COL_S3:COL_S4;\n        \n        // me\n        if(length(vec3(p.x,j,p.z))<sphereRad+.01 )m=vec3(bw?.9:.005);\n        \n        res = bUni(vec4(length(qq)-sphereRad, m), res);\n        res = bUni(vec4(sdCapsule(qq, vec3(0), vec3(sq.x, -sphereRad-j, sq.y), .03), m), res);\n        res = bUni(vec4(length(q+vec3(offset.x*gridSize,sphereRad,offset.y*gridSize))-.15, m), res);\n    }\n    \n    // prevent overshooting\n    res.x = min(res.x, -sdBox(q.xz-vec2(gridSize)*.5, vec2(gridSize)*.75));\n    \n    // floor\n    vec2 iq = abs(floor(iqq));\n    iq = vec2(int(iq.x)%2, int(iq.y)%2);\n    float tile = max(smoothstep(gridSize*.995*.5, gridSize*1.0005*.5, abs(q.x-gridSize*.5)),smoothstep(gridSize*.995*.5, gridSize*1.0005*.5, abs(q.z-gridSize*.5)));\n    if(!bw)tile=1.-tile;\n    else tile=.025+.975*tile;\n    res = bUni(vec4(p.y, COL_FLR*tile),res);\n    \n\treturn res;\n}\n\nvec4 intersect(vec3 ro, vec3 rd){\n\tfloat d = 1.;\n\tvec3  m = vec3(0);\n    grd=rd;\n\tfor (int i = 0; i < 600; i++){\n\t\tvec4 res = sdScene(ro + d * rd);\n\t\tm = res.yzw;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p){\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 ldir){\n\tfloat mint=.001;\n\tfloat maxt=5.;\n\tfloat k = 40.;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfor( int i=0; i < 80; i++){\n\t\tfloat h = sdScene(o + ldir*t).x;\n\t\tres = min( res, k*h/t);\n\t\tt += h;\n\t\tif( res<0.01 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Multi Level AO\" by iY0Yi\n// https://www.shadertoy.com/view/fsBfDR\nfloat aoSeed = 0.;\nconst float MAX_SAMP = 4.;\nfloat ao(vec3 p, vec3 n, float sphereRadius) {\n    float ao = 0.;\n    for(float i = 0.; i <= MAX_SAMP; i++) {\n        vec2 rnd = hash21(i + 1. + aoSeed);\n\n        float scale = (i + 1.)/MAX_SAMP;\n        scale = mix(.0, 1., pow(scale, .5));\n\n        rnd.x = (rnd.x * 2. - 1.) * PI * .5;\n        rnd.y = (rnd.y * 2. - 1.) * PI;\n        vec3 rd = normalize(n + hash21(i + 2. + aoSeed).xyx);\n        rd.xy *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n        rd.xz *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n\n        rd *= sign(dot(rd, n));\n\n        float raylen = sphereRadius * scale;\n        vec3 rndp = p + normalize(n + rd) * raylen;\n        float res = sdScene(rndp).x;\n        ao += res;\n        aoSeed++;\n    }\n    return ao/float(MAX_SAMP);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 h  = normalize(-vd+ld);\n\treturn pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\n\nvec3 mmr=vec3(0);\n\nvec3 render(vec2 uv){\n\n    // camera\n    float cL = 20.;\n    const vec3 forcus = vec3(0,-.5,0);\n    const float fov = .75;\n\n    vec3 up = vec3(0,1,0);\n    vec3 ro = vec3(0,14.,0);\n    float t = iTime;\n    ro.xz = vec2(sin(t),cos(t))*cL;\n    if(iMouse.z>.5)\n        ro.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-ro);\n    vec3 target = ro-dir;\n    vec3 cw = normalize(target - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    vec3 rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    \n    // ray march\n\tvec4 res = intersect(ro, rd);\n    \n\tvec3 p = ro + res.x * rd;\n    vec3 m = res.yzw;\n    vec3 col = COL_AMB;\n\tif (res.x<MAX_DIST){\n        vec3 ldir = normalize(vec3(-0.0875, 0.7071, -0.3935));\n\t\tvec3 n = normal(p);\n\n\t\tfloat lamb1 = sat(dot(n, ldir))*(1./PI);\n\t\tfloat lamb2 = sat(dot(n, -ldir))*(1./PI);\n\n\t\tfloat sh = shadow(p+n*.01, ldir);\n        float rgh = (length(m)<.3) ? .9 : 1.*texture(iChannel0, p.xz*.02).g*.01;\n        float spec = normalizedBlinnPhong(1./rgh, n, rd, ldir);\n        float a = ao(p-n*.1, n, .25);\n        a += ao(p-n*.25, n, .5);\n        a /= 2.;\n        \n\t\tfloat dif = lamb1;\n        \n        float hl = dot(n, ldir)*.5+.5;\n        vec3 mr = mix(vec3(0), mix(sdScene(p+ldir*.5).yzw, sdScene(p+ldir*1.5).yzw, .5), a);mmr=mr;\n\t\tdif *= sh;\n\t\tcol = mix(vec3(0), COL_L0*9., dif);\n\t\t\n\t\tcol += mix(vec3(0), COL_AMB, a)*1.5;\n\t\tcol*= m;\n        col += mix(vec3(0), mr, a*hl)*(.2+.8-sh*hl*.8)*1.5;\n\n        float intensity = .1*texture(iChannel0, p.xz*.02).g;\n\t\tspec = spec*intensity;\n\t\tcol = mix(col, col+COL_L0, spec*sh);\n\t\tcol = mix(col, COL_AMB, sat(pow(distance(ro, p)/MAX_DIST*4., 3.)));\n\t}\n    return col;\n}\n\n// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\nvec3 Tonemap_ACES(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 col = render(uv);\n    col = Tonemap_ACES(col);\n    //col=mmr;\n    col = mix(col,smoothstep(.0,1.,col),.3);\n\tcol = pow(col, vec3(.45454));\n\tfragColor = vec4(col,1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 217, 239, 239, 312], [313, 313, 336, 336, 441], [442, 442, 464, 464, 602], [603, 603, 624, 624, 760], [761, 761, 783, 783, 914], [916, 916, 942, 942, 965], [967, 1028, 1079, 1079, 1200], [1202, 1202, 1238, 1238, 1318], [1683, 1760, 1780, 1780, 1828], [1829, 1829, 1853, 1853, 1883], [1904, 1904, 1925, 1925, 3978], [3980, 3980, 4013, 4013, 4265], [4267, 4267, 4287, 4413, 4611], [4613, 4613, 4645, 4645, 4884], [5002, 5002, 5048, 5048, 5778], [5780, 5894, 5964, 5964, 6101], [6122, 6122, 6143, 6158, 7937], [7939, 8019, 8051, 8051, 8237], [8239, 8239, 8293, 8293, 8594]], "test": "untested"}
{"id": "dsBfzK", "name": "Line Seg. - distance 2D (Random)", "author": "Cast_E", "description": "Distance to a line segment but randomized based on a texture\n(also changed the coloring to make it easier on the eyes)", "tags": ["2d", "distancefield", "sdf", "circle", "distance"], "likes": 3, "viewed": 275, "published": 3, "date": "1689880614", "time_retrieved": "2024-07-30T17:43:32.244042", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a line segment\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n//\n// sdSegment from:\n// https://www.youtube.com/watch?v=PMltMdi1Wzg\n\n\nfloat sdCircle(in vec2 p, in float r) {\n    return length(p)-r;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b, in float r) {\n    float h = min(1.,\n              max(0.,\n                  dot(p-a, b-a) /\n                  dot(b-a, b-a)));\n    return length(p-a-(b-a)*h)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float r = texture(iChannel0, p).r * 0.3 + 0.1;\n    \n\tfloat d = sdSegment(p, vec2(0, 0), m, r);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*min(0., d));\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBfzK.jpg", "access": "api", "license": "mit", "functions": [[1316, 1316, 1355, 1355, 1381], [1383, 1383, 1445, 1445, 1594], [1596, 1596, 1653, 1653, 2124]], "test": "untested"}
{"id": "msBBRK", "name": "Fork Disk - distance 2D (Random)", "author": "Cast_E", "description": "Distance to a disk but randomized based on a texture", "tags": ["2d", "distancefield", "sdf", "circle", "distance"], "likes": 2, "viewed": 203, "published": 3, "date": "1689878172", "time_retrieved": "2024-07-30T17:43:33.166575", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a disk\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdCircle( in vec2 p, in float r ) {\n    return length(p)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float r = texture(iChannel0, vec2(p.x, p.y)).r * (cos(iTime * 0.1) * 0.5 + 0.5) + 0.1;\n    \n\tfloat d = sdCircle(p,r);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)));\n\n    if(iMouse.z>0.001) {\n        d = sdCircle(m,r);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBBRK.jpg", "access": "api", "license": "mit", "functions": [[1239, 1239, 1280, 1280, 1306], [1308, 1308, 1365, 1365, 2102]], "test": "untested"}
{"id": "mdBBRK", "name": "No strings attached", "author": "nicone1", "description": "sine test", "tags": ["strings"], "likes": 3, "viewed": 204, "published": 3, "date": "1689877697", "time_retrieved": "2024-07-30T17:43:33.965440", "image_code": "#define LINEWIDTH 0.01\n#define WAVES 16.0\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 0.0);\n    vec3 d = vec3(0.50, 0.20, 0.25);\n\n    return a + b * cos(6.28318*(c * t +d ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    for (float i = 0.5; i < WAVES; ++i)\n    {\n        float r = i / iTime;\n        float y = (1.0 - r) * sin((5.0 * uv.x + r) + (2.0 * r)) + 0.5;\n\n        if(uv.y > y - LINEWIDTH && uv.y < y + LINEWIDTH)\n            col = palette(r) * uv.y;\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdBBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 66, 66, 253], [256, 256, 311, 311, 667]], "test": "untested"}
{"id": "dsSBRK", "name": "lightsdlkhsldjha", "author": "rosienewman", "description": "lights", "tags": ["lights"], "likes": 7, "viewed": 312, "published": 3, "date": "1689877501", "time_retrieved": "2024-07-30T17:43:34.944821", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Time in seconds\n    float time = iTime;\n    \n    // Number of lights\n    const int numLights = 20;\n    \n    // Frequency of the color cycle\n    const float cycleFrequency = 0.2;\n    \n    // Light positions and sizes\n    vec2 lightPositions[numLights];\n    float lightSizes[numLights];\n    \n    for (int i = 0; i < numLights; i++)\n    {\n        float angle = float(i) * 2.0 * 3.14159 / float(numLights);\n        float radius = 0.3 + 0.2 * sin(time + angle * 3.0);\n        \n        lightPositions[i] = vec2(0.5 + radius * cos(angle), 0.5 + radius * sin(angle));\n        lightSizes[i] = 1.15 + 10.1 * sin(time + angle * 2.0);\n    }\n    \n    // Calculate distance and intensity for each light\n    vec3 finalColor = vec3(0.0);\n    \n    for (int i = 0; i < numLights; i++)\n    {\n        float dist = distance(fragCoord, iResolution.xy * lightPositions[i]);\n        \n        // Calculate time-based color values for each light\n        float red = 0.5 + 0.5 * sin(2.0 * 3.14159 * (time * cycleFrequency + float(i) / float(numLights)));\n        float green = 0.5 + 0.5 * sin(2.0 * 3.14159 * (time * cycleFrequency + (2.0 / 3.0) + float(i) / float(numLights)));\n        float blue = 0.5 + 0.5 * sin(2.0 * 3.14159 * (time * cycleFrequency + (4.0 / 3.0) + float(i) / float(numLights)));\n        \n        // Calculate light intensity based on distance (inverse square law) and light size\n        float intensity = lightSizes[i] / (0.1 + 0.1 * dist * dist);\n        \n        // Combine the colors and intensities\n        finalColor += vec3(red * intensity, green * intensity, blue * intensity);\n    }\n    \n    // Output the final color\n    fragColor = vec4(finalColor, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 78, 1725]], "test": "untested"}
{"id": "cdSBRV", "name": "Ball shape Teel", "author": "cneck", "description": "Teel Ball", "tags": ["teelball"], "likes": 0, "viewed": 128, "published": 3, "date": "1689870499", "time_retrieved": "2024-07-30T17:43:38.851376", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n \t\t\n    float t =  -iTime * 3. + 5000. +  sin(iTime / 3.) * 5.;\n    \n    float dist = distance(uv, vec2(0., 0.)) * .3;\n    float maxDist = .5;\n    vec4 color;\n               \n    float expDist = dist * dist * dist;\n    float strength = (sin(expDist * 100.)+1.)/2.;\n    float height = (sin(t * strength)+1.)/2.;\n    float alpha = 1. - expDist / (maxDist * maxDist * maxDist) + (1. - height) * -0.014  ;\n    color = vec4(.9,.9,.9, 9.) * height - (1. - alpha) * 0.652;\n    color.a = alpha;\n    if(dist > maxDist) color = vec4(.1,.1,.1, 0.);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 709]], "test": "untested"}
{"id": "cdBfzK", "name": "Cloud tester", "author": "cneck", "description": "cloud test", "tags": ["cloudtest"], "likes": 0, "viewed": 132, "published": 3, "date": "1689869638", "time_retrieved": "2024-07-30T17:43:39.769920", "image_code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// Volumetric clouds. Not physically correct in any way - \n// it does the wrong extintion computations and also\n// works in sRGB instead of linear RGB color space. No\n// shadows are computed, no scattering is computed. It is\n// a volumetric raymarcher than samples an fBM and tweaks\n// the colors to make it look good.\n//\n// Lighting is done with only one extra sample per raymarch\n// step instead of using 3 to compute a density gradient,\n// by using this directional derivative technique:\n//\n// https://iquilezles.org/articles/derivative\n\n\n// 0: one 3d texture lookup\n// 1: two 2d texture lookups with hardware interpolation\n// 2: two 2d texture lookups with software interpolation\n#define NOISE_METHOD 1\n\n// 0: no LOD\n// 1: yes LOD\n#define USE_LOD 1\n\n// 0: sunset look\n// 1: bright look\n#define LOOK 1\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n#if NOISE_METHOD==0\n    x = p + f;\n    return textureLod(iChannel2,(x+0.5)/32.0,0.0).x*2.0-1.0;\n#endif\n#if NOISE_METHOD==1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n#if NOISE_METHOD==2\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n}\n\n#if LOOK==0\nfloat map( in vec3 p, int oct )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n    float g = 0.5+0.5*noise( q*0.3 );\n    \n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    #if USE_LOD==1\n    if( oct>=2 ) \n    #endif\n    f += 0.25000*noise( q ); q = q*2.23;\n    #if USE_LOD==1\n    if( oct>=3 )\n    #endif\n    f += 0.12500*noise( q ); q = q*2.41;\n    #if USE_LOD==1\n    if( oct>=4 )\n    #endif\n    f += 0.06250*noise( q ); q = q*2.62;\n    #if USE_LOD==1\n    if( oct>=5 )\n    #endif\n    f += 0.03125*noise( q ); \n    \n    f = mix( f*0.1-0.75, f, g*g ) + 0.1;\n    return 1.5*f - 0.5 - p.y;\n}\n\nconst int kDiv = 1; // make bigger for higher quality\nconst vec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n    // bounding planes\t\n    const float yb = -3.0;\n    const float yt =  0.6;\n    float tb = (yb-ro.y)/rd.y;\n    float tt = (yt-ro.y)/rd.t;\n\n    // find tigthest possible raymarching segment\n    float tmin, tmax;\n    if( ro.y>yt )\n    {\n        // above top plane\n        if( tt<0.0 ) return vec4(0.0); // early exit\n        tmin = tt;\n        tmax = tb;\n    }\n    else\n    {\n        // inside clouds slabs\n        tmin = 0.0;\n        tmax = 60.0;\n        if( tt>0.0 ) tmax = min( tmax, tt );\n        if( tb>0.0 ) tmax = min( tmax, tb );\n    }\n    \n    // dithered near distance\n    float t = tmin + 0.1*texelFetch( iChannel1, px&1023, 0 ).x;\n    \n    // raymarch loop\n\tvec4 sum = vec4(0.0);\n    for( int i=0; i<190*kDiv; i++ )\n    {\n       // step size\n       float dt = max(0.05,0.02*t/float(kDiv));\n\n       // lod\n       #if USE_LOD==0\n       const int oct = 5;\n       #else\n       int oct = 5 - int( log2(1.0+t*0.5) );\n       #endif\n       \n       // sample cloud\n       vec3 pos = ro + t*rd;\n       float den = map( pos,oct );\n       if( den>0.01 ) // if inside\n       {\n           // do lighting\n           float dif = clamp((den - map(pos+0.3*sundir,oct))/0.3, 0.0, 1.0 );\n           vec3  lin = vec3(0.65,0.65,0.75)*1.1 + 0.8*vec3(1.0,0.6,0.3)*dif;\n           vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n           col.xyz *= lin;\n           // fog\n           col.xyz = mix(col.xyz,bgcol, 1.0-exp2(-0.075*t));\n           // composite front to back\n           col.w    = min(col.w*8.0*dt,1.0);\n           col.rgb *= col.a;\n           sum += col*(1.0-sum.a);\n       }\n       // advance ray\n       t += dt;\n       // until far clip or full opacity\n       if( t>tmax || sum.a>0.99 ) break;\n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\n    // background sky\n    vec3 col = vec3(0.76,0.75,0.86);\n    col -= 0.6*vec3(0.90,0.75,0.95)*rd.y;\n\tcol += 0.2*vec3(1.00,0.60,0.10)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    // tonemap\n    col = smoothstep(0.15,1.1,col);\n \n    return vec4( col, 1.0 );\n}\n\n#else\n\n\nfloat map5( in vec3 p )\n{    \n    vec3 q = p - vec3(0.0,0.1,1.0)*iTime;    \n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;    \n    f += 0.25000*noise( q ); q = q*2.03;    \n    f += 0.12500*noise( q ); q = q*2.01;    \n    f += 0.06250*noise( q ); q = q*2.02;    \n    f += 0.03125*noise( q );    \n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map4( in vec3 p )\n{    \n    vec3 q = p - vec3(0.0,0.1,1.0)*iTime;    \n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;    \n    f += 0.25000*noise( q ); q = q*2.03;    \n    f += 0.12500*noise( q ); q = q*2.01;   \n    f += 0.06250*noise( q );    \n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n    vec3 q = p - vec3(0.0,0.1,1.0)*iTime;    \n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;    \n    f += 0.25000*noise( q ); q = q*2.03;    f += 0.12500*noise( q );    \n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{    \n    vec3 q = p - vec3(0.0,0.1,1.0)*iTime;    \n    float f;\n    f  = 0.50000*noise( q ); \n    q = q*2.02;    f += 0.25000*noise( q );;    \n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nconst vec3 sundir = vec3(-0.7071,0.0,-0.7071);\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3 pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a>0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); vec3  lin = vec3(1.0,0.6,0.3)*dif+vec3(0.91,0.98,1.05); vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den ); col.xyz *= lin; col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) ); col.w *= 0.4; col.rgb *= col.a; sum += col*(1.0-sum.a); } t += max(0.06,0.05*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{    \n    vec4 sum = vec4(0.0);    \n    float t = 0.05*texelFetch( iChannel1, px&255, 0 ).x;    \n    MARCH(40,map5);    \n    MARCH(40,map4);    \n    MARCH(30,map3);    \n    MARCH(30,map2);    \n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n    // background sky         \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );    \n    vec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;    \n    col += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );    \n    // clouds        \n    vec4 res = raymarch( ro, rd, col, px );    \n    col = col*(1.0-res.w) + res.xyz;        \n    // sun glare        \n    col += vec3(0.2,0.08,0.04)*pow( sun, 3.0 );    \n    return vec4( col, 1.0 );\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m =                iMouse.xy      /iResolution.xy;\n\n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.8*m.y, cos(3.0*m.x))) - vec3(0.0,0.1,0.0);\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.07*cos(0.25*iTime) );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBfzK.jpg", "access": "api", "license": "proprietary-license", "functions": [[1572, 1572, 1624, 1624, 1801], [1803, 1803, 1829, 1829, 2560], [8175, 8175, 8232, 8232, 8669]], "test": "untested"}
{"id": "cdSfzK", "name": "Teel test crazy", "author": "cneck", "description": "Trippy Test", "tags": ["trippy"], "likes": 1, "viewed": 96, "published": 3, "date": "1689868932", "time_retrieved": "2024-07-30T17:43:40.516923", "image_code": "#define ITERS 8\n#define SCALE 2.0\n#define SPEED 0.25;\n\nvec3 hsv(float h, float s, float v) {\n  return mix(vec3(1.), clamp((abs(fract(h + vec3(3., 2., 1.) / 3.) * 6. - 3.) - 1.), 0., 1.), s) * v;\n}\n\nfloat col(vec2 p, float t) {\n  float a = length(p) - p.x;\n  float b = max(abs(p.x - 1.0), abs(p.y - 1.0));\n  float c = max(p.x, p.y);\n  float d = b * a;\n  return t * 0.1 + mix(mix(a, b, sin(t * 2.31) * 0.5 + 0.5), mix(c, d, sin(t + 1.0) * 0.5 + 0.5), sin(t * 0.46) * 0.5 + 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aspect = iResolution.x / iResolution.y;\n  vec2 p = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy);\n  p.x *= aspect;\n  p += 1.0;\n  vec3 c = vec3(1);\n  float t = 5.0 + iTime * SPEED;\n  for (int j = 3; j < ITERS; j++) {\n    p = abs(p - 1.0);\n    float h = col(p, t);\n    c += hsv(sin(h * 8.0) + 0.9, 2.0, 0.30); // <-- change this line\n    p *= SCALE;\n  }\n  fragColor = vec4(c, 200.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 92, 92, 196], [198, 198, 226, 226, 478], [480, 480, 535, 535, 926]], "test": "untested"}
{"id": "cdjfzy", "name": "Water or no water?", "author": "misol101", "description": "Not sure I would jump in :)\n\nMouse x zooms", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 2, "viewed": 193, "published": 3, "date": "1689868329", "time_retrieved": "2024-07-30T17:43:41.648897", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int mono = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    int showtext = int(texelFetch(iChannel1, ivec2(4,0), 0 ).x);\n    int aa = 1-int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul);\n\n    vec4 val = vec4(0.);\n    int am=aa, ap=aa, j=0;\n    for (int j = -am; j <= ap; j++)\n        for (int i = -am; i <= ap; i++) {\n            vec4 v1= texelFetch( iChannel0, ivec2(int(fragCoord.x)+i,int(fragCoord.y)+j), 0 );\n            vec4 v2= vec4(0.03+0.1,0.29+0.1,0.35+0.1,1.0)- texelFetch( iChannel2, ivec2(int(fragCoord.x*0.25)+i,int(fragCoord.y*0.25)+j), 0 );\n            if (v1.x > 0.03+0.4  && v1.y > 0.29+0.4 && v1.z > 0.35+0.4)\n                val += v1; else val+= v2*0.1+v1*0.85;\n         }\n    float n=float((am+ap+1));\n    if (am+ap > 0) val /= n*n-3.5;\n    \n    if (aa == 0) val/=0.6;\n    \n    if (mono == 0) {\n        fragColor = val;\n    } else {\n        float v=(1./liveval)*val.w;\n        fragColor = vec4( v*0.9, v*0.95, v, 1.0 );\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nfloat restart(vec2 fragCoord, int method, bool preserve) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=452., rradius=25.;\n    if (iResolution.y < 1000.) radius=182.;\n    float xrad=569.,yrad=453.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;//randpix(fragCoord);\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 3) {\n//        if (length(fragCoord-mid)< radius)\n        if (length(vec2((fragCoord.x-mid.x)*0.793,(fragCoord.y-mid.y)*1.0))< radius) // ellipse\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 4) {\n        float xmul=1.; if (iResolution.y < 1000.) xmul=1.75;\n        if (fragCoord.x > mid.x - rradius*xmul && fragCoord.x < mid.x + rradius*xmul+1. && fragCoord.y > mid.y - rradius && fragCoord.y < mid.y + rradius +1.)\n            return liveval;//randpix(fragCoord);\n    }\n    return preserve? -1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = 2+int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int usecolor = 1-int(texelFetch(iChannel2, ivec2(6,0), 0 ).x);\n    int usewrap = 1-int(texelFetch(iChannel2, ivec2(7,0), 0 ).x);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(-3.5*sin((iTime-10.)*0.012), 3.5*sin(iTime*0.0105), 3.5*sin(iTime*0.02));\n    if (usecolor == 0) col = vec3(0.);\n    col = vec3(0.);\n\n    setRules(int(ix*10.), col);\n    uv+=0.05;\n    uv-=iTime*0.005;\n    float axx = sin((uv.x*5.+uv.y)-0.8)*cos(uv.y*2.+2.1)*12.5+12.5;\n    axx=clamp(axx, 2.0, 12.0);\n\n    float axx2 = sin((uv.x*8.+uv.y*1.4)-0.8)*cos(uv.y*2.+2.1+uv.y*2.)*12.5+abs((uv.x-0.5)*2.)+12.5;\n    axx2=clamp(axx2, 2.0, 12.0);\n    axx=min(axx,axx2);\n\n    rm/=axx;\n    gm/=axx;\n    bm/=axx;\n\n    wrap = usewrap;\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if (wrap == 0 && (fragCoord.y < 2. || fragCoord.x < 2.) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, 0.);\n        return;\n    }\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)  ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, setmethod, false));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, method, false));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 5) {\n        // XXXXX\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1))\n            + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else if (nh == 13) {\n        // XXXXX\n        // ....X\n        // XX*.X\n        // X...X\n        // XXXXX            \n        k =   \n            cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, 0)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n            \n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate; //clamp(ev-decimate, 0., 1000.);\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x -= cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y -= cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z -= cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\n            \n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x += cstep*rm;\n                curr.y += cstep*gm;\n                curr.z += cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x += cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n\n        curr.x = clamp(curr.x, 0.03, 4000.0);\n        curr.y = clamp(curr.y, 0.29, 4000.0);\n        curr.z = clamp(curr.z, 0.35, 4000.0);\n\n}\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAST_PATT = 0.;\nconst float cstep=1./256.;\n\nfloat density=50.;\nfloat liveval = 2.0;\nint newmethod = 0;\nfloat decimate = 0.;\nfloat rp,gp,bp, rm,gm,bm, stayval;\nint colch, staypatt;\nint ra,ga,ba;\nbool clampstay;\nint setmethod;\nint stayset, bornset;\nint nh;\nint wrap;\n\nvoid setRules(int index, vec3 col) {\n    int v1, v2;\n    decimate = 1.;liveval=2.;\n\n    rp=4.,gp=3.,bp=10., rm=2.,gm=2.,bm=8., ra=7,ga=7,ba=7,staypatt=1,stayval=1.,colch=0, clampstay=false, setmethod=0; nh=10, wrap=0;\n\n    index = 0;\n    if (index == 0) {wrap=1; nh=13; v1 = 64863, v2=21948; setmethod=0, density=14., liveval=4., decimate=1.0, colch=0, staypatt=0, rp=5.5, gp=4.8, bp=4.6, rm=45., gm=61.,bm=61.,  ra=7,ga=7,ba=7; }\n\n    rp=rp+col.x; gp=gp+col.y; bp=bp+col.z;\n    stayset = v1; bornset = v2;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_A     = 65;\nconst int KEY_C     = 67;\nconst int KEY_H     = 72;\nconst int KEY_M     = 77;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=0.1;\n                    if (kx > LAST_PATT*0.1+0.05) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=LAST_PATT*0.1+0.05;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_H, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_A, 1., 2.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_W, 1., 2.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(1.0+iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nfloat restart(vec2 fragCoord, int method, bool preserve) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=452., rradius=25.;\n    if (iResolution.y < 1000.) radius=182.;\n    float xrad=569.,yrad=453.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;//randpix(fragCoord);\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 3) {\n//        if (length(fragCoord-mid)< radius)\n        if (length(vec2((fragCoord.x-mid.x)*0.793,(fragCoord.y-mid.y)*1.0))< radius) // ellipse\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 4) {\n        float xmul=1.; if (iResolution.y < 1000.) xmul=1.75;\n        if (fragCoord.x > mid.x - rradius*xmul && fragCoord.x < mid.x + rradius*xmul+1. && fragCoord.y > mid.y - rradius && fragCoord.y < mid.y + rradius +1.)\n            return liveval;//randpix(fragCoord);\n    }\n    return preserve? -1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = 4+int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int usecolor = 1-int(texelFetch(iChannel2, ivec2(6,0), 0 ).x);\n    int usewrap = 1-int(texelFetch(iChannel2, ivec2(7,0), 0 ).x);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(-3.5*sin((iTime-10.)*0.012), 3.5*sin(iTime*0.0105), 3.5*sin(iTime*0.02));\n    if (usecolor == 0) col = vec3(0.);\n    col = vec3(0.);\n\n    setRules(int(ix*10.), col);\n    uv.x-=0.4;\n    float axx = sin((uv.x*5.+uv.y)-0.8)*cos(uv.y*2.+2.1)*12.5+12.5;\n    axx=clamp(axx, 1.0, 5.0);\n\n    rm/=axx;\n    gm/=axx;\n    bm/=axx;\n    bp*=0.15;\n    gp*=0.15;\n    rp*=0.15;\n\n    wrap = usewrap;\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if (wrap == 0 && (fragCoord.y < 2. || fragCoord.x < 2.) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, 0.);\n        return;\n    }\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)  ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, setmethod, false));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, method, false));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 5) {\n        // XXXXX\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1))\n            + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else if (nh == 13) {\n        // XXXXX\n        // ....X\n        // XX*.X\n        // X...X\n        // XXXXX            \n        k =   \n            cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, 0)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n            \n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate; //clamp(ev-decimate, 0., 1000.);\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x -= cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y -= cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z -= cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\n            \n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x += cstep*rm;\n                curr.y += cstep*gm;\n                curr.z += cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                    curr.z += cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x += cstep*rm;\n                    curr.y += cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x += cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n\n        curr.x = clamp(curr.x, 0.03, 4000.0);\n        curr.y = clamp(curr.y, 0.29, 4000.0);\n        curr.z = clamp(curr.z, 0.35, 4000.0);\n\n}\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1212]], "test": "untested"}
{"id": "cdBBzK", "name": "ovo ono", "author": "Andrija385", "description": "basic", "tags": ["basic"], "likes": 0, "viewed": 78, "published": 3, "date": "1689867967", "time_retrieved": "2024-07-30T17:43:42.416843", "image_code": "#define MAX_DIST 10000.\n#define MAX_STEPS 100\n#define SURF_DIST .1\nfloat smoothMax(float a,float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\nfloat smoothMin(float a,float b,float k)\n{\n    return -smoothMax(-a,-b,k);\n}\nfloat mixuj(float a,float b,float c)\n{\n    //return smoothMin(a,b,.1);\n    //return (a+b+c)/2.;\n    //return max(a,b);\n    //return smoothMin(smoothMin(a,b,.1),c,.1);\n    return min(min(a,b),c);\n}\nfloat GetDist(vec3 p)\n{\n    vec4 s1 = vec4(40.*sin(iTime),30.,0.,36.);\n    vec4 s2 = vec4(-40.*sin(iTime),30.,0.,36.);\n    \n    float sphereDist1 = length(p-s1.xyz)-s1.w;\n    float sphereDist2 = length(p-s2.xyz)-s2.w;\n    float planeDist = p.y;\n    float d = mixuj(sphereDist1,sphereDist2,planeDist);\n    return d;\n}\nfloat GetDist(vec3 p,vec4 s1)\n{\n    return length(p-s1.xyz)-s1.w;\n}\nfloat RayMarch(vec3 ro,vec3 rd)\n{\n    float dist=0.0;\n    for(int i=0;i<MAX_STEPS;++i)\n    {\n        vec3 p =ro+dist*rd;\n        float cur=GetDist(p);\n        dist=dist+cur;\n        if(dist>MAX_DIST||cur<SURF_DIST)break;\n    }\n    return dist;\n}\nvec3 GetNormal(vec3 p)\n{\n    vec2 e = vec2(.01,0.);\n    return normalize(vec3(GetDist(p+e.xyy),GetDist(p+e.yxy),GetDist(p+e.yyx))-vec3(GetDist(p-e.xyy),GetDist(p-e.yxy),GetDist(p-e.yyx)));\n}\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,500,500);\n    vec3 normal = GetNormal(p);\n    vec3 lightVec = normalize(lightPos-p);\n    float dist = RayMarch(p+20.*SURF_DIST*normal,lightVec);\n    if(dist<MAX_DIST)return 0.;\n    return clamp(dot(lightVec,normal),0.0,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 s1 = vec4(40.*sin(iTime),30.,0.,36.);\n    vec4 s2 = vec4(-40.*sin(iTime),30.,0.,36.);\n    //-1. to 1.\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0.,30.,70.);\n    vec3 rd=vec3(uv.xy,-1);\n    float dist=RayMarch(ro,rd);\n    vec3 p = ro+dist*rd;\n    vec3 col = vec3(0.0);\n    //col=GetNormal(ro+dist*rd);\n    //col=vec3(dist)/6.;\n    float dif = GetLight(ro+dist*rd);\n    col=vec3(.7,.0,.0);\n    if(dist>100.)col=vec3(135, 206, 235)/255.;\n    else\n    {\n        if(GetDist(p,s1)-RayMarch(p,rd)<0.1)col=vec3(0,1,0);\n        if(GetDist(p,s2)-RayMarch(p,rd)<0.1)col=vec3(0,0,1);\n        col *= dif;\n        col = pow(col, vec3(1.0/2.2));\n    }\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 110, 110, 149], [150, 150, 192, 192, 226], [227, 227, 265, 393, 423], [424, 424, 447, 447, 740], [741, 741, 772, 772, 808], [809, 809, 842, 842, 1054], [1055, 1055, 1079, 1079, 1245], [1246, 1246, 1270, 1270, 1524], [1525, 1525, 1582, 1582, 2293]], "test": "untested"}
{"id": "csSBzK", "name": "Teel Hero Test", "author": "cneck", "description": "Hero for Teel Website", "tags": ["illusion"], "likes": 1, "viewed": 98, "published": 3, "date": "1689867574", "time_retrieved": "2024-07-30T17:43:43.187782", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finCol = vec3(0.0);\n\n    for (float i = 0.0; i < 3.0; i++)\n    {\n        uv = fract(uv * 2.5) - 0.5;\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = 0.5 * cos(iTime * 0.5 + uv.xyx + vec3(0, 2, 4) + iTime * 0.5);\n        d = sin(d * 2.5 + iTime * 0.5) / 5.0;\n        d = pow(0.01 / d, 1.1);\n        finCol += col * d;\n    }\n\n    float d2 = length(uv0);\n    d2 = sin(d2 * 2.5 + iTime * 0.5) / 5.0;\n    d2 = abs(d2);\n    d2 = pow(0.1 / d2, 1.2);\n    vec3 finCol2 = finCol * d2;\n\n    // Set vectors to black with 10% opacity\n    fragColor.rgb = vec3(0.0);\n    fragColor.a = 0.1;\n\n    if (length(finCol2) > 0.1)\n    {\n        // Set the background to white with 100% opacity\n        fragColor.rgb = vec3(1.0);\n        fragColor.a = 0.1;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 910]], "test": "untested"}
{"id": "Dsjfzy", "name": "State Variables", "author": "fad", "description": "A convenient system for easily loading and storing state variables across frames/buffers without manually figuring out locations to load and store them in the buffers. More info in Common tab.", "tags": ["memory", "persistence", "variable", "persistent"], "likes": 7, "viewed": 206, "published": 3, "date": "1689854972", "time_retrieved": "2024-07-30T17:43:43.984651", "image_code": "// A convenient system for easily loading and storing state variables\n// across frames/buffers without manually figuring out locations to load\n// and store them in the buffers. More info in Common tab.\n// \n// In this example, a ball's position and velocity is tracked, with a\n// mouse click changing the velocity. Colour changes every bounce/click.\n\nuint PCGHash(uint seed) {\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nfloat rand(uint seed) {\n    return float(PCGHash(seed)) / float(0xffffffffu);\n}\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return distance(p, c) - r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Load the state variables\n    loadState();\n    \n    // Generate a random color based on how many times it's bounced\n    vec3 ballColor = vec3(\n        rand(numBounces * 3u + 0u),\n        rand(numBounces * 3u + 1u),\n        rand(numBounces * 3u + 2u)\n    );\n    \n    // Draw the ball\n    float d = sdCircle(fragCoord, position, radius);\n    fragColor.rgb = mix(ballColor, vec3(1.0), clamp(d + 0.5, 0.0, 1.0));\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Usage:\n// Add to the STATE #define below to declare a new state variable. State\n// variables are automatically loaded and stored across buffers/frames.\n// Simply call loadState() at the beginning of mainImage() to make the\n// state variables available for use as global variables, and call\n// storeState() at the end of mainImage() to save any modifications made\n// to the state variables*. Modifications to state variables must be\n// uniform across all shader invocations. loadState() loads state\n// variables from the texture set as iChannel0. storeState() stores\n// state variables in the alpha channel of the current buffer.\n//\n// *Modifications to state variables are not stored if they are done\n// inside of the Image buffer.\n//\n// All types are loaded and stored by casting from and to floats, so the\n// maximum safe integer is 2^24-1.\n\n#define STATE        \\\n    UINT(numBounces) \\\n    VEC2(position)   \\\n    VEC2(velocity)   \\\n    FLOAT(radius)    \\\n\n// Declare the global variables\n#define BOOL(name) bool name;\n#define BVEC2(name) bvec2 name;\n#define BVEC3(name) bvec3 name;\n#define BVEC4(name) bvec4 name;\n#define INT(name) int name;\n#define IVEC2(name) ivec2 name;\n#define IVEC3(name) ivec3 name;\n#define IVEC4(name) ivec4 name;\n#define UINT(name) uint name;\n#define UVEC2(name) uvec2 name;\n#define UVEC3(name) uvec3 name;\n#define UVEC4(name) uvec4 name;\n#define FLOAT(name) float name;\n#define VEC2(name) vec2 name;\n#define VEC3(name) vec3 name;\n#define VEC4(name) vec4 name;\nSTATE\n#undef BOOL\n#undef BVEC2\n#undef BVEC3\n#undef BVEC4\n#undef INT\n#undef IVEC2\n#undef IVEC3\n#undef IVEC4\n#undef UINT\n#undef UVEC2\n#undef UVEC3\n#undef UVEC4\n#undef FLOAT\n#undef VEC2\n#undef VEC3\n#undef VEC4\n\n#ifndef HW_PERFORMANCE\nuniform vec3 iResolution;\nuniform sampler2D iChannel0;\n#endif\n\n// Set the global variables to their appropriate values\nvoid loadState() {\n    int i = 0;\n    int w = textureSize(iChannel0, 0).x;\n    #define GET(i) texelFetch(iChannel0, ivec2(i % w, i / w), 0).a\n    #define BOOL(name) name = bool(GET(i)); i += 1;\n    #define BVEC2(name) BOOL(name.x) BOOL(name.y)\n    #define BVEC3(name) BVEC2(name.xy) BOOL(name.z)\n    #define BVEC4(name) BVEC3(name.xyz) BOOL(name.w)\n    #define INT(name) name = int(GET(i)); i += 1;\n    #define IVEC2(name) INT(name.x) INT(name.y)\n    #define IVEC3(name) IVEC2(name.xy) INT(name.z)\n    #define IVEC4(name) IVEC3(name.xyz) INT(name.w)\n    #define UINT(name) name = uint(GET(i)); i += 1;\n    #define UVEC2(name) UINT(name.x) UINT(name.y)\n    #define UVEC3(name) UVEC2(name.xy) UINT(name.z)\n    #define UVEC4(name) UVEC3(name.xyz) UINT(name.w)\n    #define FLOAT(name) name = GET(i); i += 1;\n    #define VEC2(name) FLOAT(name.x) FLOAT(name.y)\n    #define VEC3(name) VEC2(name.xy) FLOAT(name.z)\n    #define VEC4(name) VEC3(name.xyz) FLOAT(name.w)\n    STATE\n    #undef BOOL\n    #undef BVEC2\n    #undef BVEC3\n    #undef BVEC4\n    #undef INT\n    #undef IVEC2\n    #undef IVEC3\n    #undef IVEC4\n    #undef UINT\n    #undef UVEC2\n    #undef UVEC3\n    #undef UVEC4\n    #undef FLOAT\n    #undef VEC2\n    #undef VEC3\n    #undef VEC4\n    #undef GET\n}\n\n// Store the state variables in fragColor.a\nvoid storeState(inout vec4 fragColor, vec2 fragCoord) {\n    int i = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    int j = 0;\n    #define SET(j, v) if (i == j) fragColor.a = float(v)\n    #define BOOL(name) SET(j, name); j += 1;\n    #define BVEC2(name) BOOL(name.x) BOOL(name.y)\n    #define BVEC3(name) BVEC2(name.xy) BOOL(name.z)\n    #define BVEC4(name) BVEC3(name.xyz) BOOL(name.w)\n    #define INT(name) SET(j, name); j += 1;\n    #define IVEC2(name) INT(name.x) INT(name.y)\n    #define IVEC3(name) IVEC2(name.xy) INT(name.z)\n    #define IVEC4(name) IVEC3(name.xyz) INT(name.w)\n    #define UINT(name) SET(j, name); j += 1;\n    #define UVEC2(name) UINT(name.x) UINT(name.y)\n    #define UVEC3(name) UVEC2(name.xy) UINT(name.z)\n    #define UVEC4(name) UVEC3(name.xyz) UINT(name.w)\n    #define FLOAT(name) SET(j, name); j += 1;\n    #define VEC2(name) FLOAT(name.x) FLOAT(name.y)\n    #define VEC3(name) VEC2(name.xy) FLOAT(name.z)\n    #define VEC4(name) VEC3(name.xyz) FLOAT(name.w)\n    STATE\n    #undef BOOL\n    #undef BVEC2\n    #undef BVEC3\n    #undef BVEC4\n    #undef INT\n    #undef IVEC2\n    #undef IVEC3\n    #undef IVEC4\n    #undef UINT\n    #undef UVEC2\n    #undef UVEC3\n    #undef UVEC4\n    #undef FLOAT\n    #undef VEC2\n    #undef VEC3\n    #undef VEC4\n    #undef SET\n}", "buffer_a_code": "// This buffer simulates the ball\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Load state variables\n    loadState();\n    \n    // Initialize state variables on the first frame\n    if (iFrame == 0) {\n        numBounces = 0u;\n        position = 0.5 * iResolution.xy;\n        velocity = vec2(0.0);\n        radius = 0.1 * iResolution.y;\n    }\n    \n    // Change ball velocity if mouse was clicked\n    if (iMouse.w > 0.0) {\n        ++numBounces;\n        velocity = 4.0 * (iMouse.xy + 0.5 - position);\n    }\n    \n    // Apply gravity and update velocity and position\n    vec2 gravity = vec2(0.0, -4.0 * iResolution.y);\n    velocity += gravity * iTimeDelta;\n    position += velocity * iTimeDelta;\n    \n    // Collide ball with wall\n    vec2 clamped = clamp(\n        position,\n        vec2(radius),\n        iResolution.xy - radius\n    );\n    \n    if (position != clamped) {\n        ++numBounces;\n        velocity *= mix(\n            vec2(-0.9),\n            vec2(1.0),\n            equal(position, clamped)\n        );\n        position = clamped;\n    }\n    \n    // Store state variables\n    storeState(fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsjfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 350, 375, 375, 533], [535, 535, 558, 558, 614], [616, 616, 657, 657, 690], [692, 692, 744, 776, 1184]], "test": "untested"}
{"id": "cd2fzy", "name": "Mini Jumper Game", "author": "SnoopethDuckDuck", "description": "Inspired by kastorp's shader:\nhttps://www.shadertoy.com/view/csXfRX\n\nThe map uses simplex noise from iq, and the collision code is pretty bad\n\nInstructions:\nA+D to move left+right\nSpace to jump", "tags": ["2d", "game", "interactive", "pixel", "simplex", "pixelart", "ca"], "likes": 23, "viewed": 232, "published": 3, "date": "1689852991", "time_retrieved": "2024-07-30T17:43:44.816427", "image_code": "vec3 drawBg(vec2 V) {\n    V += iTime;\n    return mix(vec3(99, 155, 255),\n               vec3(91, 110, 225),\n               mod(floor(V.x/12.)+floor(V.y/12.), 2.)) / 255.;\n}\n\nvec3 showMap(vec2 V) {\n    float t = cell(ch0, V + vec2(0, 1)).r;\n    float b = cell(ch0, V - vec2(0, 1)).r;\n    float l = cell(ch0, V - vec2(1, 0)).r;\n    float r = cell(ch0, V + vec2(1, 0)).r;\n    float c = cell(ch0, V).r;\n    \n    float sum = t + b + l + r;\n    \n    if (c == 1.) {\n        if (t == 0.) {\n            if (l + r == 2.) return vec3(1);\n            else if (l + r == 1.) return vec3(.85);\n            else return vec3(.7);\n        }\n        return vec3(.5);\n    } \n    else if (sum > 0.) return .8 * drawBg(V);\n    else return drawBg(V);\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec2 U = (I-.5*R)/R.y;\n   \n    vec4 player   = cell(ch1, cPlayer);\n    vec4 follower = cell(ch1, cFollower);\n    vec4 space    = cell(ch1, cSpace);\n    \n    // Zoom\n    float zm = .06;\n    \n    // uv moves with player position so player is centered\n    vec2 V = vec2(zm * (I-.5*R) + player.xy - .5);\n    \n    // Player\n    float dPlay = max(abs(U.x), abs(U.y));\n    float sPlay = step(dPlay, .5/R.y/zm);\n    float sPlay2 = step(dPlay, 10.5/R.y/zm);\n        \n    // Follower\n    vec2 vf = V - follower.xy;\n    float dFol = max(abs(vf.x), abs(vf.y));\n    float sFol = step(dFol, .25);\n    \n    // Spacebar effect\n    float dSpace = length(V - player.xy + .5 + 4. * player.zw);\n    float rSpace = space.x / 12.;\n    float sSpace = step(abs(dSpace - 4. * rSpace * rSpace), .5 * rSpace);\n    \n    // Trail\n    float trail = cell(ch0, V).g;\n    vec3 trailCol = pal(.5 * trail + .4 + .25 * vec3(0,1,2)/3.);\n    vec3 playerCol = mix(vec3(1), vec3(1,0,0), exp(-2.*length(player.zw)));\n    \n    // Colors\n    vec3 col = showMap(V);\n    col = mix(col, vec3(1), .7 * trail);\n    col = mix(col, vec3(1), sSpace * rSpace);  \n    //col = mix(0.5*col, col, sPlay2); // Cute mode\n    col = mix(col, vec3(1.-exp(-8.*length(player.zw))), sPlay);\n    col = mix(col, vec3(1), sFol);\n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define R iResolution.xy\n\n#define pal(a) .5 + .5 * cos(2. * pi * (a))\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\n#define KEY_LEFT 65.\n#define KEY_RIGHT 68.\n#define KEY_UP 87.\n#define KEY_DOWN 83.\n#define KEY_SPACE 32.\n\n#define Dir(a) vec2(cos(a),sin(a))\n\n#define cell(ch, J) texelFetch(ch, ivec2(J), 0)\n#define key_val(key) texelFetch(ch2, ivec2(key, 0), 0).x\n//#define key_down(key) key_val(key) == 1.\n#define key_pressed(key) texelFetch(ch2, ivec2(key, 1), 0).x\n\n// Object cells\n#define cPlayer   vec2(.5)\n#define cFollower vec2(1.5, .5)\n#define cSpace    vec2(2.5, .5)\n\n\n// From iq: https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n", "buffer_a_code": "// this buffer stores map data\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    // Generate map on first frame\n    if (iFrame < 1) {\n        O = 0.*O;\n        O.r = step(noise(I/50.), .0);\n        O.r = max(0., O.r - step(noise(I/20.), -.25));\n        O.r = max(0., O.r - step(noise(I/10.), 0.));\n    }\n    else {   \n        // Draw trail around player\n        vec2 p = cell(ch1, cPlayer).xy;   \n        vec2 v = cell(ch1, cPlayer).zw;\n        \n        O = cell(ch0, I);\n        vec4 av = (cell(ch0, I + vec2(1,0)) +\n                   cell(ch0, I - vec2(1,0)) +\n                   cell(ch0, I + vec2(0,1)) +\n                   cell(ch0, I - vec2(0,1))) / 4.;\n        O.g = mix(O.g, av.g, .5);\n        O.g *= 0.97;\n        if (length(p - .5 - I) <= 1.5)\n            O.g += .6 * (1.-exp(-length(v)));     \n            \n        // Display 2x2 box containing player       \n        /*\n        p = floor(p);\n        if (p - vec2(.5,.5) == I || p - vec2(.5,-.5) == I\n         || p + vec2(.5,.5) == I || p + vec2(.5,-.5) == I)\n            O.g = 1.;\n        //*/                    \n    }   \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// this buffer stores object data\n// (player, follower, spacebar)\n\n#define is I == \n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    // Initialize values\n    if (iFrame < 1) {\n        if (is cPlayer || is cFollower)\n            O = vec4(.5 * R, 0, 0);\n        else if (is cSpace)\n            O = vec4(0);\n        return;\n    }\n    \n    // Previous values\n    O = cell(ch1, I);\n    \n    // Player (position, velocity)\n    if (is cPlayer) {\n        // Update velocity \n        O.z += .05 * (key_val(KEY_RIGHT) - key_val(KEY_LEFT));\n        O.w += key_pressed(KEY_SPACE) -.03;\n        O.zw *= vec2(.9, 1);\n                 \n        // Update position\n        O.xy += O.zw;\n         \n        vec2 f = floor(O.xy);\n        \n        // Player position is always within 2x2 block of cells\n        // v = (TL, TR, \n        //      BL, BR)\n        // 1 if cell.r == 1., 0 otherwise\n        vec4 v = vec4(cell(ch0, f + vec2(-.5,  .5)).r == 1.,\n                      cell(ch0, f + vec2( .5,  .5)).r == 1.,\n                      cell(ch0, f + vec2(-.5, -.5)).r == 1.,\n                      cell(ch0, f + vec2( .5, -.5)).r == 1.); \n                      \n        float sum = v.x + v.y + v.z + v.w;\n        \n        // Copy O to compare before and after collision resolution\n        vec4 C = O;       \n                       \n        // Stuck inside region, move up\n        if (v == vec4(1)) O.y++;  \n        \n        // Push away from walls\n        else if (sum >= 2.) {\n                 if (v.xy == vec2(1)) O.y = f.y;      // Top 2 cells\n            else if (v.zw == vec2(1)) O.y = f.y + 1.; // Bottom\n                 if (v.yw == vec2(1)) O.x = f.x;      // Right\n            else if (v.xz == vec2(1)) O.x = f.x + 1.; // Left\n        }\n        \n        // If resolved in x or y, set x or y velocity = 0  \n        O.zw *= vec2(C.x == O.x, C.y == O.y);\n    }\n    \n    // Follower (position, velocity)\n    else if (is cFollower) {\n        vec4 player = cell(ch1, vec2(.5));\n        O.xy = mix(O.xy, player.xy - .5 + 2. * Dir(pi/2.-cos(iTime*3.)), .1);\n        O.xy += O.zw;\n    }\n\n    // Spacebar (effect cooldown)\n    else if (is cSpace) {\n        O.x = max(0., O.x - 1.);\n        if (key_pressed(KEY_SPACE) == 1.)\n            O.x = 12.;\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2fzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 172], [174, 174, 196, 196, 729], [731, 731, 769, 769, 2059]], "test": "untested"}
{"id": "DsjBRy", "name": "misty drip I", "author": "FleshBoy666", "description": "sweet sweet water, the refreshing drip", "tags": ["water"], "likes": 0, "viewed": 105, "published": 3, "date": "1689851983", "time_retrieved": "2024-07-30T17:43:45.600331", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime * 0.1;\n    float speed = 5.0;\n    float waveHeight = 0.1;\n    float frequency = 3.0;\n\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y += sin(uv.x * frequency + time * speed) * waveHeight;\n\n    float noiseValue = (noise(uv * 8.0) + 1.0) * 0.5;\n\n    vec3 color = vec3(0.0, 0.2, 0.5) + vec3(noiseValue * 0.1, noiseValue * 0.2, noiseValue * 0.4);\n\n    float foam = pow(1.0 - abs(uv.y), 6.0);\n    color += vec3(1.0) * foam * 0.2;\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 156, 156, 499], [501, 501, 556, 556, 1068]], "test": "untested"}
{"id": "cd2fRG", "name": "JPEG Compression Depth of Field", "author": "NBickford", "description": "I saw https://youtu.be/CuNgLZiWkm8 and I liked the idea! But the implementation there mimics the visuals of JPEG instead of applying its subsampling + DCT. What if we emulated it more closely? + bonus FX!\nClick and drag to move camera. Scene by @blackle.", "tags": ["depthoffield", "pixelation", "jpg", "jpeg"], "likes": 26, "viewed": 1576, "published": 3, "date": "1689849430", "time_retrieved": "2024-07-30T17:43:46.704380", "image_code": "// Elements are columns\n// Modified matrix from the \"JPEG conversion\" section of\n// https://en.wikipedia.org/wiki/YCbCr\nmat3 ycbcr_to_rgb = mat3(vec3(1.), vec3(0., -.344136, 1.772), vec3(1.402, -.714136, 0.));\n// I'm not worrying about 128/255 vs. .5 here.\nvec3 ycbcr_offset_to_rgb = vec3(0., -.5, -.5);\n\nbool show_effect(int effect, vec2 uv){\n#if EFFECT == E_MULTI\n    return float(effect)/4. <= uv.x && uv.x <= float(effect+1)/4.;\n#else\n    return (effect == EFFECT);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 effect_col;\n    vec2 src_uv = fragCoord/iResolution.xy;\n    \nif(show_effect(E_PIXELATE, src_uv)){\n    // Read the depth from the original render\n    // We read from mip 3, without linear filtering,\n    // to try to get a constant value in each 8x8 block.\n    // Otherwise, our pixels have unusual shapes.\n    // uh, don't look at the top row of pixels too closely\n    // if your preview height is not divisible by 8\n    float depth = texelFetch(iChannel0, ivec2(fragCoord)/8, 3).a;\n    float cc = EFFECT_STRENGTH * 60.f * cc_from_depth(depth);\n    \n#if 1\n    // Optional: If cc is restricted to powers of integers,\n    // then we never run into the unusual shape issue!\n    // But then depths look kind of quantized.\n    if(cc > 0.){\n        cc = exp2(round(log2(cc)));\n    }\n#endif\n    \n    // Pixelate fragCoord\n    fragCoord = round(fragCoord/cc)*cc;\n    vec2 pixelated_uv = fragCoord/iResolution.xy;\n    \n    // Output to screen\n    effect_col = texture(iChannel0, pixelated_uv).rgb;\n    \n}else if(show_effect(E_JPEG, src_uv)){\n\n    // Split the image into 8x1 blocks. What's my x index inside the block?\n    int block_x = int(fragCoord.x) % 8;\n    // Go to the start of the row in this 8x8 block\n    ivec2 block_start = ivec2(fragCoord) - ivec2(block_x, 0);\n    // Fetch 8 pixels in this row\n    vec3 row[8];\n    for(int i = 0; i < 8; i++){\n        row[i] = texelFetch(iChannel1, block_start + ivec2(i, 0), 0).rgb;\n    }\n    // Invert the horizontal DCT. This is the same trick\n    // as in Buffer D!\n    vec3 dct_out = vec3(0.);\n    for(int i = 0; i < 8; i++){\n        dct_out += dct[8*i + block_x] * row[i];\n    }\n    \n    effect_col = ycbcr_to_rgb * (dct_out + ycbcr_offset_to_rgb);\n\n}else if(show_effect(E_CHROMATIC, src_uv)){\n\n    // Some sort of chromatic aberration\n    float depth = texelFetch(iChannel0, ivec2(fragCoord), 0).a;\n    float cc = EFFECT_STRENGTH * 200.f * cc_from_depth(depth);\n    vec2 rcp_res = 1. / iResolution.xy;\n    effect_col = vec3(0.);\n    vec3 total_weight = vec3(0.);\n    float d_dx = .25;\n    // If our step size is larger than a pixel, we sample\n    // higher resolutions:\n    float sampled_lod = log2(max(1., d_dx*cc));\n    for(float dx = -1.; dx <= 1.; dx += d_dx){\n        vec3 val = textureLod(iChannel0, (fragCoord + vec2(dx*cc, 0.))*rcp_res, sampled_lod).rgb;\n        // sRGB -> linear\n        val = pow(max(val, vec3(0.)), vec3(2.2f));\n        // r  g  b\n        // \\ /^\\ /\n        //  \\   \\\n        // / \\ / \\\n        //-1  0  1\n        vec3 weight = clamp(vec3(-dx, 1.-abs(dx), dx), vec3(0.), vec3(1.));\n        effect_col += val*weight;\n        total_weight += weight;\n    }\n    effect_col = effect_col / total_weight;\n    // linear -> sRGB\n    effect_col = pow(effect_col, vec3(1./2.2f));\n\n}else if(show_effect(E_FLOW, src_uv)){\n\n    // er, sample along a curve, I guess?\n    vec2 uv = src_uv;\n    float depth = texelFetch(iChannel0, ivec2(fragCoord), 0).a;\n    // Total length, roughly in pixels\n    float cc = EFFECT_STRENGTH * 250.f * cc_from_depth(depth);\n    int num_steps = clamp(int(ceil(cc/4.)), 1, 16);\n    float step_size = (cc/256.)/float(num_steps); // Now to UV\n    effect_col = vec3(0.);\n    for(int i = 0; i < num_steps; i++){\n        effect_col += textureLod(iChannel0, uv, 0.f).rgb;\n        uv += (textureLod(iChannel2, uv, 0.).rg - vec2(.5)) * step_size;\n    }\n    effect_col = effect_col / float(num_steps);\n\n}else if(show_effect(E_CHEAP_DOF, src_uv)){\n    \n    float depth = texelFetch(iChannel0, ivec2(fragCoord), 0).a;\n    float cc = EFFECT_STRENGTH * iResolution.x * .15f * cc_from_depth(depth);\n    float sample_lod = log2(max(1., cc)) - .7;\n    effect_col = vec3(0.);\n    for(int i = 0; i < 3; i++){\n        float t = float(i) * 6.28 / 3.;\n        vec2 dp = .5 * (cc/iResolution.x) * vec2(cos(t), sin(t));\n        vec3 val = textureLod(iChannel0, src_uv + dp, sample_lod).rgb;\n        effect_col += pow(val, vec3(2.2));\n    }\n    effect_col = pow(effect_col / 3., vec3(1./2.2));\n    \n}\n\n#ifdef VIEW_ERROR\n    effect_col = vec3(.5) + effect_col - texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n#endif\n\n#if EFFECT == E_MULTI\n    // Draw labels at the top for each column\n    int chars[] = int[](80, 105, 120, 101, 108, 97, 116, 101, 74, 80, 69, 71, 67, 104, 114, \n111, 109, 97, 116, 105, 99, 70, 108, 111, 119);\n    int string_starts[] = int[](0, 8, 12, 21, 25);\n    vec2 char_size_uv = 0.03 * vec2(.6, 1.) * vec2(1.,iResolution.x/iResolution.y);\n    float v_from_top = 1.-src_uv.y - .01;\n    if(v_from_top < char_size_uv.y && v_from_top > 0.) {\n        int str_idx = clamp(int(floor(src_uv.x * 4.)), 0, 3);\n        int str_len = string_starts[str_idx + 1] - string_starts[str_idx];\n        float str_left_u = (float(str_idx) + .5)/4. - float(str_len) * char_size_uv.x * .5;\n        float char_idx_f = (src_uv.x - str_left_u)/char_size_uv.x;\n        int char_idx_i = int(floor(char_idx_f));\n        if(0 <= char_idx_i && char_idx_i < str_len) {\n            vec2 uv_in_letter = vec2(char_idx_f - float(char_idx_i), v_from_top/char_size_uv.y);\n            // Scale letters horizontally so they're more closely spaced\n            uv_in_letter.x = (uv_in_letter.x - .5) / 2. + .5;\n            int char_code = chars[string_starts[str_idx] + char_idx_i];\n            vec2 letter_in_grid = vec2(float(char_code % 16), float(char_code / 16));\n            float letter_sdf = texture(iChannel3, (uv_in_letter + letter_in_grid)/16.).a;\n            // Ad-hoc antialiasing\n            float step_width = 30. / iResolution.x;\n            effect_col = mix(\n                effect_col,\n                vec3(smoothstep(.5+step_width, .5-step_width, letter_sdf)),\n                vec3(smoothstep(.55+step_width, .55-step_width, letter_sdf)));\n        }\n    }\n    // effect_col = texture(iChannel3, src_uv).rgb;\n#endif\n\n    fragColor = vec4(effect_col, 1.);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Whack-A-Mole Pistons by Blackle Mori (@blackle):\n// https://www.shadertoy.com/view/WtXcWB\n// Modified by @nbickford with modifications\n// (textured background, reflections, depth in alpha channel)\n// also released under CC0 1.0 Universal.\n//\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//uncomment for slow but pretty version\n//#define PRETTY\n#ifdef PRETTY\n#define AA_SAMPLES 8\n#define MOTION_BLUR\n#else\n#define AA_SAMPLES 1\n#endif\n\n//the following functions assume that p is inside the cube of radius 1 centered at the origin\n//closest vertex of the cube to p\nvec3 vertex(vec3 p) {\n    return step(0.,p)*2.-1.;\n}\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(sign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,sign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n//closest edge of the cube to p\nvec3 edge(vec3 p) {\n    vec3 mask = vec3(1)-abs(face(p));\n    vec3 v = vertex(p);\n    vec3 a = v*mask.zxy, b = v*mask.yzx;\n    return distance(p,a)<distance(p,b)?a:b;\n}\n\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat corner(vec2 p, float h) {\n    vec2 q = p - vec2(0,h);\n    return super(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\n//returns rhombic dodecahedron tessalation data for p\n//x: distance to circle of radius .6 in current cell\n//y: distance to circle of radius .6 in closest adjacent cell\n//zw: ID of cell\nvec4 grid(vec3 p) {\n    vec3 id = floor(p)+.5;\n    vec3 m = sign(mod(id,2.)-1.);\n    if (m.x*m.y*m.z<0.) id += face(p-id);\n    p -= id;\n    float d1 = length(p)-.6;\n    p -= edge(p);\n    float d2 = length(p)-.6;\n    return vec4(d1,d2,id);\n}\n\n#define FBI floatBitsToInt\nfloat hash(float a, float b) {\n    int x = FBI(cos(a))^FBI(a);\n    int y = FBI(cos(b))^FBI(b);\n    return float((x*x+y)*(y*y-x)+x)/2.14e9;\n}\n\n//springy impulse\nfloat spring(float x) {\n    return smoothstep(-.4,.4,x) + smoothstep(-.3,.3,x) - smoothstep(-.7,.7,x);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = max(vec3(0),k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//mtime set by \"pixel_color\" to influence the time used by the scene\nfloat mtime;\n//lots of globals set by \"scene\"\nvec2 gid;\nvec3 glocal;\nfloat gnd;\nfloat gt;\nfloat scene(vec3 p) {\n    //ds1 chooses z coordinate in 2d slicing of the rhombic dodecahedron tessalation\n    //by varying it over space, we get different sized circles\n    float ds1 = dot(cos(p.xy/5.), sin(p.xy/4.))*.06;\n    vec3 p3 = vec3(p.xy, ds1);\n    vec4 g = grid(p3);\n    gid = g.zw;\n \n    float s1 = hash(gid.x,gid.y);\n    float s2 = hash(s1,s1);\n    gt = sin(s1*100.+mtime*mix(1.,2.,s2*.5+.5))-.4;\n    float h = spring(gt)*2.-.5;\n\n    vec2 crd = vec2(g.x,p.z);\n    vec2 crd2 = vec2(g.y,p.z);\n    float maxheight = 1.7;\n\n    gnd = corner(crd*vec2(-1,1)+vec2(0.08,0.),0.)-.04; //ground holes\n\n    //transform things into local coordinates for piston\n    crd.y -= h;\n    glocal = p - vec3(gid,h);\n    glocal = erot(glocal,vec3(0,0,1),s1*100.+gt*2.);\n    float curr = corner(crd, 0.); //distance to current piston\n    \n    //little holes on side of piston\n    vec3 lp = glocal;\n    lp.z = asin(sin(lp.z*5.+.5))/5.;\n    curr = -smin(-curr, length(lp.yz)-0.05,.03);\n    \n    float adjacent = corner(crd2, maxheight); //distance to adjacent piston (assumes maximally extended)\n    return min(gnd,min(curr, adjacent)-.02);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 skylight(vec3 p) {\n    return texture(iChannel2, p).rgb;\n    //float d = dot(p,normalize(vec3(1)));\n    //return vec3(1)*d*.2+.2 + pow(max(0.,d),10.)*1.5;\n}\n\nfloat smpl(vec3 p, vec3 dir, float dist) {\n    return smoothstep(-dist,dist,scene(p+dir*dist));\n}\n\nvec4 pixel_color(vec2 uv, float time)\n{\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    mtime = time;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-7,0,0);\n    \n    float yrot = 0.7+sin(time*.3)*.2;\n    float zrot = time*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    \n    init.xy += time*vec2(.5,sqrt(2.));\n    init.z += 2.;\n    vec3 p =init;\n    bool hit = false;\n    float dist; int i;\n    float total_dist = 0.f;\n    for (i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n        total_dist += dist;\n        if(distance(p,init)>50.)break;\n    }\n    //save globals locally\n    bool g = gnd == dist;\n    vec2 id = gid;\n    float s1 = hash(gid.y,gid.x);\n    float s2 = hash(s1,gid.x);\n    vec3 local = g ? p : glocal+vec3(id,0);\n    \n    float fog = min(1.,smoothstep(5.,50.,distance(p,init))+smoothstep(100.,200.,float(i)));\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ao = smpl(p,n,.1);\n    \n    //brushed metal tops. not sure if this is the right way, but it works!\n    if (!g && n.z>.9) {\n        float ang = atan(p.x-id.x,p.y-id.y);\n        float ang2 = atan(local.x-id.x,local.y-id.y);\n        local = vec3(ang2/2.,length(p.xy-id)*40.,local.z+id.x*.9+id.y*.4);\n        n = normalize(vec3(cos(ang*2.),sin(ang*2.),1));\n    }\n    \n    //rough texture\n    float sharpness = texture(iChannel0,local/2.).x;\n    sharpness = sqrt(texture(iChannel0,local*vec3(1,4,.5)+sharpness*.1).x);\n    sharpness *= pow(texture(iChannel0,local/10.+sharpness*.1).x, 2.);\n    sharpness = sharpness*.5+.9;\n    \n    //fake reflection occlusion\n    float ro = sqrt(smpl(p,r,.9)*smpl(p,r,.5)*smpl(p,r,.2));\n    \n    float spec = length(sin(r*3.*sharpness)*.4+.6)/sqrt(3.) * smoothstep(-1.,-.0,p.z);\n    float fres = 1.-abs(dot(cam,n))*.5;\n    vec3 mcol = abs(erot(vec3(0.4,0.6,0.9), normalize(vec3(0,s2,2)), s1*.6));\n    if (g) mcol = vec3(0.1);\n    \n    // Not reflection, just sampling the normal :shrug:\n    vec3 lightDir = reflect(cam, n);\n    vec3 light = texture(iChannel3, lightDir.xzy).rgb;\n    vec3 col = (mcol*spec + pow(spec,10.*sharpness))*ro*ao*fres*1.5*light;\n    vec3 bgcol = skylight(cam.xzy);\n    vec3 fragColor = hit ? mix(col,bgcol,fog) : bgcol;\n    return vec4(fragColor, total_dist);\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nfloat bayer(ivec2 uv) {\n    return texelFetch(iChannel1, uv % 8, 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    float b = bayer(ivec2(fragCoord));\n    for (int i = 0; i < AA_SAMPLES+int(min(0,iFrame)); i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n#ifdef MOTION_BLUR\n\t\t//using yx's bayer motion blur idea https://www.shadertoy.com/view/wsfcWX\n        float blur = ((float(i)+b)/float(AA_SAMPLES)-.5) * iTimeDelta;\n#else\n        float blur = 0.;\n#endif\n        fragColor += pixel_color(uv2, iTime+blur);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/float(AA_SAMPLES));\n    \n    fragColor.xyz = smin(fragColor.xyz,vec3(1),0.1);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// \"Depth of Field, but instead of getting blurry it gets more JPEG\",\n// but simulating the YCoCg + Discrete Cosine Transform quantization\n// modules of JPEG directly instead of visually.\n// Plus depth-of-field as pixelation, chromatic aberration, and\n// paint splotches/flow effects inspired by Jam2go's video!\n//\n// Scene:\n// Whack-A-Mole Pistons by Blackle Mori (@blackle):\n// https://www.shadertoy.com/view/WtXcWB\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n// Modified by @nbickford with modifications\n// (textured background, reflections, depth in alpha channel)\n// also released under CC0 1.0 Universal.\n\n//------------------------------------------------------------------------\n// Options (you can change these)!\n\n#define E_PIXELATE 0\n#define E_JPEG 1\n#define E_CHROMATIC 2\n#define E_FLOW 3\n#define E_CHEAP_DOF 4\n#define E_MULTI -1\n\n// Set this to change the effect.\n#define EFFECT E_MULTI\n\n// Set this to a different value to modify the strength of all the effects.\n#define EFFECT_STRENGTH 1.9\n\n// Define this to view the compression error between\n// the uncompressed image and the output.\n// #define VIEW_ERROR\n//------------------------------------------------------------------------\n\n// Here's roughly how the JPEG compression code is structured!\n//\n// Buffer A is the RGB + depth of blackle's Whack-A-Mole Pistons scene.\n// I've modified it so the background and lighting uses an environment map,\n// so if you move the camera the background has some additional detail.\n//\n// Buffers B, C, D, and Image apply different stages in JPEG compression\n// and decompression. They each load 8 pixels and output 1 pixel.*\n// \n// * B transforms RGB to YCoCg, emulates downsampling the CoCg channels\n// by a factor of 2 on the x axis**, and performs the horizontal component\n// of the Discrete Cosine Transform.\n// * C emulates downsampling the CoCg channels by a factor of 2 on the y\n// axis** (because the DCT is linear, the order of the horizontal DCT and\n// vertical downsample doesn't matter), and applies the vertical component\n// of the DCT. Then it looks up the depth from Buffer A and quantizes the\n// DCT coefficients depending on how large that point's circle of confusion\n// would be if this was a real image.\n// (If this was a full JPEG implementation, there would be an entropy\n// coding stage here - but that should*** be a lossless stage, and so this\n// shader doesn't simulate it)\n// * D inverts the vertical component of the DCT.\n// * Image inverts the horizontal component of the DCT.\n\n// Footnotes:\n// * In an ideal world, we could combine them together with Buffer A into\n// one shader by using a compute shader with an 8x8 workgroup size and use\n// warp operations to perform the DCT matrix multiplies. Then we'd never\n// have to read and write intermediate results out to textures, and the\n// amount of duplicated work (e.g. buffer B transforms each pixel color\n// from RGB to YCoCg 8 times) would be significantly reduced.\n// The 4-pass approach here might not be faster than a single-pass approach\n// that loads 64 values and has each thread perform a full DCT and IDCT!\n// After all, 4 passes result in 32 total texture loads, vs. 64 texture\n// loads for a single pass. (Maybe the 4-pass approach uses fewer registers,\n// though.)\n//\n// ** We could do this more accurately by actually downsampling the Co\n// and Cg components of the image and performing the DCT on them\n// separately. That's kind of difficult, though (although I think it's\n// possible in 4 buffers), and the CoCg 4:2:0 chroma subsampling\n// isn't as visible as the overwhelming crunchiness of DCT quantization.\n//\n// *** okay so this isn't true if you have a JPEG encoder that performs\n// Rate-Distortion Optimization or, more generally, modifies the\n// compressed data in some way so that the entropy coding stage produces\n// a smaller result but I'm not going to worry about that here, sorry\n\n// The other effects all take place entirely within the Image shader.\n// They're not really trying to be anything specific. But they're fun!\n\n// Related work:\n// Ompuco has a JPEG emulation asset pack for Unity with more quality options:\n// https://ompuco.itch.io/jpgpu\n// My favorite article on the JPEG file format: https://parametric.press/issue-01/unraveling-the-jpeg/\n// Other JPEG simulators on Shadertoy:\n// https://www.shadertoy.com/view/XtffDj (by Ultraviolet)\n// https://www.shadertoy.com/view/llfyz4 (by rory618; uses a single-pass approach)\n// https://www.shadertoy.com/view/ldyBRc (by rkibria; a DCT-compressed image)\n// https://www.shadertoy.com/view/Dd3Xz4 (by jolle; a DCT-compressed heightmap)\n// https://www.shadertoy.com/view/msdSz7 (by jolle; Dd3Xz4 + Daala deblocking)\n// Hannah Rose's \"pro-aliasing\" concept, which takes geometric edges and\n// makes them more jagged: https://twitter.com/hannaesthetic/status/1349776649802424321\n\n// Compute circle of confusion radius; based on\n// https://en.wikipedia.org/wiki/Circle_of_confusion#Determining_a_circle_of_confusion_diameter_from_the_object_field\n// but replacing units and a division by 2 with ad-hoc figures.\n// Multiply this by something that looks good\nfloat cc_from_depth(float d){\n    const float focus_depth = 7.f;\n    const float f = .7f;\n    return abs(d-focus_depth) * f /(focus_depth * abs(d - f));\n}\n\n// Table for discrete cosine transform; generated in Mathematica using\n// 1/2. Table[If[u==0,1/Sqrt[2],1]Cos[(2x+1)u Pi/16],{u,0,7},{x,0,7}]//Flatten\n// Picture this as an 8x8 matrix A; A*v is the DCT of v.\n// This matrix has some neat properties!\n// Its transpose is its inverse: A * A^t = I\n// The vertical DCT is its transpose.\n// An 8x8 DCT is just the horizontal DCT (apply this to each row), followed\n// by the vertical DCT (apply this to each column).\nfloat dct[64] = float[64](\n0.353553,0.353553,0.353553,0.353553,0.353553,0.353553,0.353553,0.353553,\n0.490393,0.415735,0.277785,0.0975452,-0.0975452,-0.277785,-0.415735,-0.490393,\n0.46194,0.191342,-0.191342,-0.46194,-0.46194,-0.191342,0.191342,0.46194,\n0.415735,-0.0975452,-0.490393,-0.277785,0.277785,0.490393,0.0975452,-0.415735,\n0.353553,-0.353553,-0.353553,0.353553,0.353553,-0.353553,-0.353553,0.353553,\n0.277785,-0.490393,0.0975452,0.415735,-0.415735,-0.0975452,0.490393,-0.277785,\n0.191342,-0.46194,0.46194,-0.191342,-0.191342,0.46194,-0.46194,0.191342,\n0.0975452,-0.277785,0.415735,-0.490393,0.490393,-0.415735,0.277785,-0.0975452\n);", "buffer_b_code": "// RGB -> YPbPr + horizontal DCT\n\n// Elements are columns\n// Modified matrix from the \"JPEG conversion\" section of\n// https://en.wikipedia.org/wiki/YCbCr\nmat3 rgb_to_ycbcr = mat3(vec3(.299, -.168736, .5), vec3(.587, -.331264, -.418688), vec3(.114, .5, -.081312));\n// I'm not worrying about 128/255 vs. .5 here.\nvec3 rgb_to_ycbcr_offset = vec3(0., .5, .5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Split the image into 8x1 blocks. What's my x index inside the block?\n    int block_x = int(fragCoord.x) % 8;\n    // Go to the start of the row in this 8x8 block\n    ivec2 block_start = ivec2(fragCoord) - ivec2(block_x, 0);\n    // Fetch 8 pixels in this row\n    vec3 row[8];\n    for(int i = 0; i < 8; i++){\n          row[i] = texelFetch(iChannel0, block_start + ivec2(i, 0), 0).rgb;\n    }\n    // Transform each texel to YCbCr, and shift to SNORM.\n    for(int i = 0; i < 8; i++){\n        row[i] = rgb_to_ycbcr_offset + rgb_to_ycbcr * row[i];\n    }\n    // Kind of emulate the horizontal component of 4:2:0 compression\n    // by averaging out the Cb and Cr components of every 2 pixels.\n    // Ideally, we'd really do the image rescaling - since this\n    // is sort of like a 16-wide DCT - but this should be close enough.\n    // Also this is really hard to see on a 1080p screen! Shoutout to\n    // the Joint Photography Experts Group.\n    for(int i = 0; i < 4; i++){\n        row[2*i+0].gb = row[2*i+1].gb = mix(row[2*i+0].gb, row[2*i+1].gb, .5);\n    }\n    // Get this component of the horizontal DCT\n    vec3 dct_out = vec3(0.);\n    for(int i = 0; i < 8; i++){\n          dct_out += dct[8*block_x + i] * row[i];\n    }\n    fragColor = vec4(dct_out, 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Horizontal DCT -> Full DCT + quantization\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Split the image into 8x1 blocks. What's my x index inside the block?\n    int block_y = int(fragCoord.y) % 8;\n    // Go to the start of the row in this 8x8 block\n    ivec2 block_start = ivec2(fragCoord) - ivec2(0, block_y);\n    // Fetch 8 pixels in this column\n    vec3 col[8];\n    for(int i = 0; i < 8; i++){\n        col[i] = texelFetch(iChannel1, block_start + ivec2(0, i), 0).rgb;\n    }\n    // Kind of emulate the vertical part of 4:2:0 subsampling\n    // by averaging out the CoCg components of each 2 pixels.\n    for(int i = 0; i < 4; i++){\n        col[2*i+0].gb = col[2*i+1].gb = mix(col[2*i+0].gb, col[2*i+1].gb, .5);\n    }\n    // Get this component of the vertical DCT:\n    vec3 dct_out = vec3(0.);\n    for(int i = 0; i < 8; i++){\n        dct_out += dct[8*block_y + i] * col[i];\n    }\n    // dct_out now contains the DCT of the block at frequency (block_x, block_y)!\n    // Let's quantizue it. I don't feel like embedding the official JPEG tables,\n    // so I'm just going to make something up.\n    int block_x = int(fragCoord.x) % 8;\n    // We'll multiply block_x + block_y + 1 by some value f. Here are a few\n    // test values of f:\n    // 10 is noticeably crunchy; 40 is about 10% in from the left of\n    // https://en.wikipedia.org/wiki/File:Felis_silvestris_silvestris_small_gradual_decrease_of_quality.png;\n    // 100 is like Discord video on a slow connection;\n    // 200 makes everything pink, gray, and blue;\n    // 0 should be no quantization; since I want to avoid division by 0, I'll add 1.\n    float depth = texelFetch(iChannel0, ivec2(fragCoord) - ivec2(block_x, block_y), 0).a;\n    float f = EFFECT_STRENGTH * 450.*(exp2(2.*cc_from_depth(depth)) - 1.);\n    float quantization = f * float(block_x + block_y + 1) + 1.f;\n    // And then this is roughly how JPEG quantizes: we scale to full-range,\n    // apply the quantization, and then scale back to normalized values.\n    dct_out = round(128. * dct_out / quantization) * (quantization / 128.);\n    fragColor = vec4(dct_out, 1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Full DCT -> Horizontal DCT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Split the image into 8x1 blocks. What's my x index inside the block?\n    int block_y = int(fragCoord.y) % 8;\n    // Go to the start of the row in this 8x8 block\n    ivec2 block_start = ivec2(fragCoord) - ivec2(0, block_y);\n    // Fetch 8 pixels in this column\n    vec3 col[8];\n    for(int i = 0; i < 8; i++){\n        col[i] = texelFetch(iChannel0, block_start + ivec2(0, i), 0).rgb;\n    }\n    // Multiply by the inverse of the vertical DCT.\n    // That's the transpose! This is the same as\n    // Buffer C except we swap i and block_y.\n    vec3 dct_out = vec3(0.);\n    for(int i = 0; i < 8; i++){\n        dct_out += dct[8*i + block_y] * col[i];\n    }\n    fragColor = vec4(dct_out,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2fRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 343, 343, 478]], "test": "untested"}
{"id": "cdjBRy", "name": "Perlin Vibes", "author": "FleshBoy666", "description": "GPT CHAT - noise example\n", "tags": ["noise"], "likes": 0, "viewed": 114, "published": 3, "date": "1689847157", "time_retrieved": "2024-07-30T17:43:47.517206", "image_code": "// Shadertoy header\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\n\n\n\n// Hash function used in Perlin noise\nfloat hash(float x) {\n    return fract(sin(x) * 43758.5453);\n}\n\n// 1D Perlin noise\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n// 2D Perlin noise\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float a = hash(i.x + i.y * 57.0);\n    float b = hash(i.x + 1.0 + i.y * 57.0);\n    float c = hash(i.x + i.y * 57.0 + 1.0);\n    float d = hash(i.x + 1.0 + i.y * 57.0 + 1.0);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Scale the coordinates to the range [-1, 1]\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Get 2D Perlin noise value\n    float n = noise(uv * 10.0); // You can adjust the scale (10.0) to change the noise frequency\n\n    // Add sine wave distortion using the noise value as an offset\n    float distortionAmount = 0.1; // Adjust the distortion intensity here\n    float sineWaveOffset = sin(uv.x * 20.0 + n * 2.0 * 3.14159) * distortionAmount;\n    uv.y += sineWaveOffset;\n\n    // Remap noise to [0, 1] and output grayscale color based on the noise value\n    fragColor = vec4(vec3(0.5 * (n + 1.0)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 116, 137, 137, 178], [180, 199, 221, 221, 353], [355, 374, 395, 395, 736], [738, 738, 793, 843, 1428]], "test": "untested"}
{"id": "cd2BRG", "name": "Liquid Colors", "author": "Quentin765", "description": "Offset by color + Motion Blur + noise + contrast + saturation)", "tags": ["psychedelic", "webcam", "configurable"], "likes": 0, "viewed": 276, "published": 3, "date": "1689841506", "time_retrieved": "2024-07-30T17:43:48.275180", "image_code": "// Instructions & Code in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nINSTRUCTIONS:\n\niChannel0 is the image/video input - you can click it to change it.\nI strong recomend webcam, but you can also try out any of the textures or videos.\n\nThere are a number of settings - any float that is set to a single value\nThe range of acceptable values in the comment\nTo apply the configuratiuon just press the play arrow in the bottom left of the edit area\n\nYou can make the configurations change with time by using the varrible iTime\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 lastFrame = texture(iChannel2,uv);\n    \n    float rootThree = pow(3., 0.5);\n    \n    float offsetAmount = 0.15;//+sin(iTime*10.)*0.2;  // any number, 0 is no effect & negative is backwards\n    \n    //triangle math to convert rgb into xy directions\n    vec2 offset = vec2(\n        rootThree*float(lastFrame.x-lastFrame.z),\n        lastFrame.y*2.-lastFrame.x-lastFrame.z\n        ) / 6.;\n\n    vec2 newUv = uv + offsetAmount*offset;\n    \n    vec4 frameInputOffseted = texture(iChannel0, newUv);\n    vec4 lastFrameOffseted = texture(iChannel2, newUv);\n    float noiseInput = iTime+uv.x*3.1536+uv.y*129.735902957;\n    vec4 noise = texture(iChannel1,vec2(noiseInput,noiseInput*256.));\n    \n    float noiseContrast = 3.; //>=1\n    \n    noise = vec4(pow(noise.x,noiseContrast),pow(noise.y,noiseContrast),pow(noise.z,noiseContrast),0.);\n    \n    float saturateAmount = 0.04; //0<x<=0.5\n    float constrastAmount = 0.04; //0<x<=0.5\n    float primary = 2. + (1. + constrastAmount*2.)/saturateAmount;\n    float bias = constrastAmount/saturateAmount;\n    \n    vec4 lastFrameOffsetedConstrast = vec4(\n         lastFrameOffseted.x*primary - lastFrameOffseted.y - lastFrameOffseted.z - bias,\n        -lastFrameOffseted.x + lastFrameOffseted.y*primary - lastFrameOffseted.z - bias,\n        -lastFrameOffseted.x - lastFrameOffseted.y + lastFrameOffseted.z*primary - bias,\n        0.\n    )*saturateAmount;\n    \n    float motionBlurAmount = 0.85; //0<=x<=1\n    float noiseAmount = 0.05; //0<=x<=0.5\n    float addin = 0.0; // only cause my math vvv is not perfect\n    addin += 2.*noiseAmount*(.5-1./(1.+noiseContrast));\n    \n    // Output to screen\n    fragColor = frameInputOffseted*(1.-motionBlurAmount-noiseAmount) + lastFrameOffsetedConstrast*(motionBlurAmount-noiseAmount) + noise*noiseAmount*2. + addin;\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2BRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 93, 156]], "test": "untested"}
{"id": "DdSBRy", "name": "Sin Wave Background Pattern", "author": "alphardex", "description": "A simple pattern.", "tags": ["pattern"], "likes": 1, "viewed": 241, "published": 3, "date": "1689817478", "time_retrieved": "2024-07-30T17:43:49.055094", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    uv.y+=sin(uv.x*6.)*.4;\n    uv=fract(uv*16.);\n    vec3 col=vec3(.1608,.9765,.0196);\n    float lineWidth=.3;\n    float lineOpacity=.5;\n    vec3 lineColor=vec3(1.,1.,1.);\n    float d=min(uv.y,1.-uv.y);\n    vec3 stripe=mix(col,lineColor,smoothstep(0.,32./iResolution.y,d-lineWidth));\n    col+=stripe*lineOpacity;\n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 434]], "test": "untested"}
{"id": "csBfzG", "name": "Bouncing Smiley", "author": "alphardex", "description": "Bouncing smiley with random backgrounds.", "tags": ["raymarching"], "likes": 6, "viewed": 151, "published": 3, "date": "1689815338", "time_retrieved": "2024-07-30T17:43:49.806086", "image_code": "#define AASIZE 2.\n#define BGCOUNT 7\n\nconst float PI=3.14159265359;\n\n// utils\n// rotate\nmat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nfloat getTheta(vec2 st){\n    return atan(st.y,st.x);\n}\n\nfloat sdBox(in vec2 p,in vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nvec3 rgb2hsv(in vec3 c){\n    vec4 K=vec4(0.,-.33333333333333333333,.6666666666666666666,-1.);\n    \n    vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));\n    vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));\n    \n    float d=q.x-min(q.w,q.y);\n    float e=1.e-10;\n    return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsb){\n    vec3 rgb=clamp(abs(mod(hsb.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return hsb.z*mix(vec3(1.),rgb,hsb.y);\n}\n\nvec3 hueShift(in vec3 color,in float amount){\n    vec3 hsv=rgb2hsv(color);\n    hsv.r+=amount;\n    return hsv2rgb(hsv);\n}\n\nvec3 blendMultiply(vec3 base,vec3 blend){\n    return base*blend;\n}\n\nfloat blendScreen(float base,float blend){\n    return 1.-((1.-base)*(1.-blend));\n}\n\nvec3 blendScreen(vec3 base,vec3 blend){\n    return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nfloat circle(vec2 uv,vec2 p,float r,float blur)\n{\n    float d=length(uv-p);\n    float c=smoothstep(r,r-blur,d);\n    return c;\n}\n\nhighp float random(vec2 co)\n{\n    highp float a=12.9898;\n    highp float b=78.233;\n    highp float c=43758.5453;\n    highp float dt=dot(co.xy,vec2(a,b));\n    highp float sn=mod(dt,3.14);\n    return fract(sin(sn)*c);\n}\n\nfloat remap(float a,float b,float c,float d,float t)\n{\n    return clamp((t-a)/(b-a),0.,1.)*(d-c)+c;\n}\n\n// raymarching\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n\nfloat sdCappedTorus(vec3 p,vec2 sc,float ra,float rb)\n{\n    p.x=abs(p.x);\n    float k=(sc.y*p.x>sc.x*p.y)?dot(p.xy,sc):length(p.xy);\n    return sqrt(dot(p,p)+ra*ra-2.*ra*k)-rb;\n}\n\nvec2 opUnion(vec2 d1,vec2 d2)\n{\n    return(d1.x<d2.x)?d1:d2;\n}\n\nfloat opSmoothUnion(float d1,float d2,float k)\n{\n    float h=max(k-abs(d1-d2),0.);\n    return min(d1,d2)-h*h*.25/k;\n}\n\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1,float d2,float k)\n{\n    float h=max(k-abs(d1-d2),0.);\n    return max(d1,d2)+h*h*.25/k;\n}\n\nfloat opSubtraction(float d1,float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opSmoothSubtraction(float d1,float d2,float k)\n{\n    float h=max(k-abs(-d1-d2),0.);\n    return max(-d1,d2)+h*h*.25/k;\n}\n\nfloat diffuse(vec3 n,vec3 l){\n    float diff=clamp(dot(n,l),0.,1.);\n    return diff;\n}\n\nfloat specular(vec3 n,vec3 l,float shininess){\n    float spec=pow(clamp(dot(n,l),0.,1.),shininess);\n    return spec;\n}\n\nfloat fresnel(float bias,float scale,float power,vec3 I,vec3 N)\n{\n    return bias+scale*pow(1.+dot(I,N),power);\n}\n\nconst float gamma=2.2;\n\nfloat toGamma(float v){\n    return pow(v,1./gamma);\n}\n\nvec2 toGamma(vec2 v){\n    return pow(v,vec2(1./gamma));\n}\n\nvec3 toGamma(vec3 v){\n    return pow(v,vec3(1./gamma));\n}\n\nvec4 toGamma(vec4 v){\n    return vec4(toGamma(v.rgb),v.a);\n}\n\n// functions\nvec3 getGrad(vec2 uv){\n    vec3 col1=vec3(.969,.639,.482);\n    vec3 col2=vec3(1.,.871,.659);\n    vec3 col3=vec3(.816,.894,.690);\n    vec3 col4=vec3(.486,.773,.816);\n    vec3 col5=vec3(0.,.635,.882);\n    vec3 col6=vec3(0.,.522,.784);\n    vec3 c=col1;\n    float ratio=1./6.;\n    c=mix(c,col2,step(ratio*1.,uv.y));\n    c=mix(c,col3,step(ratio*2.,uv.y));\n    c=mix(c,col4,step(ratio*3.,uv.y));\n    c=mix(c,col5,step(ratio*4.,uv.y));\n    c=mix(c,col6,step(ratio*5.,uv.y));\n    return c;\n}\n\n// bgs\nvec4 bg1(vec2 uv){\n    uv-=.5;\n    uv=rotate(uv,-PI/4.);\n    uv+=.5;\n    uv=fract(uv*16.);\n    vec3 c=mix(vec3(1.),vec3(.941,.416,.055),1.-step(.5,uv.y));\n    return vec4(c,1.);\n}\n\nvec4 bg2(vec2 uv){\n    vec2 st=.5-uv;\n    \n    st=rotate(st,PI/2.);\n    \n    float a=getTheta(st);\n    \n    vec3 col=mix(vec3(.604,.804,.196),vec3(1.,.078,.576),(a+PI)/(PI*2.));\n    \n    return vec4(col,1.);\n}\n\nvec4 bg3(vec2 uv){\n    uv=fract(uv*5.);\n    \n    vec2 p1=uv;\n    p1-=.5;\n    p1=rotate(p1,PI/4.);\n    p1+=.5;\n    float d1=sdBox(p1,vec2(.5));\n    \n    vec2 p2=uv;\n    p2.y=1.-p2.y;\n    p2-=.5;\n    p2=rotate(p2,PI/4.);\n    p2+=.5;\n    float d2=sdBox(p2,vec2(.5));\n    \n    float d=opUnion(d1,d2);\n    \n    float mask=step(0.,d);\n    \n    vec3 col=vec3(1.)*mask;\n    \n    return vec4(col,1.);\n}\n\nvec4 bg4(vec2 uv){\n    vec2 st=.5-uv;\n    \n    st=rotate(st,PI/2.);\n    \n    float a=getTheta(st);\n    a=mod(a,PI/6.);\n    \n    vec3 col=mix(vec3(.604,.804,.196),vec3(1.,.078,.576),step(1./24.,(a)/(PI*2.)));\n    \n    return vec4(col,1.);\n}\n\nvec4 bg5(vec2 uv){\n    uv-=.5;\n    \n    float a=length(uv);\n    a=sin(a*200.);\n    \n    vec3 col=mix(vec3(.937,.965,.957),vec3(.945,.169,.937),a);\n    \n    return vec4(col,1.);\n}\n\nvec4 bg6(vec2 uv){\n    vec3 col1=vec3(.373,.867,.800);\n    vec3 col2=vec3(1.,0.,.302);\n    uv-=.5;\n    uv=rotate(uv,PI/4.);\n    uv+=.5;\n    vec3 col12=mix(col1,col2,uv.x);\n    vec3 col=hueShift(col12,fract(iTime*.1));\n    return vec4(col,1.);\n}\n\nvec4 bg7(vec2 uv){\n    vec2 p1=uv;\n    p1-=.5;\n    p1=rotate(p1,-PI/4.);\n    p1+=.5;\n    p1=fract(p1*4.);\n    vec3 col1=getGrad(p1);\n    \n    vec2 p2=uv;\n    p2-=.5;\n    p2=rotate(p2,PI/4.);\n    p2+=.5;\n    p2=fract(p2*4.);\n    vec3 col2=getGrad(p2);\n    \n    // vec3 c=col1;\n    // vec3 c=col2;\n    vec3 c=blendMultiply(col1,col2);\n    \n    return vec4(c,1.);\n}\n\n// main\nvec4 getBg(vec2 uv,int frame){\n    if(frame==0){\n        return bg1(uv);\n    }else if(frame==1){\n        return bg2(uv);\n    }else if(frame==2){\n        return bg3(uv);\n    }else if(frame==3){\n        return bg4(uv);\n    }else if(frame==4){\n        return bg5(uv);\n    }else if(frame==5){\n        return bg6(uv);\n    }else if(frame==6){\n        return bg7(uv);\n    }\n}\n\nvec4 getRandBg(vec2 uv){\n    // float ratio=iResolution.x/iResolution.y;\n    // uv.x*=ratio;\n    \n    int frame=int(iTime);\n    \n    int currentFrame=0;\n    currentFrame=frame%BGCOUNT;\n    vec4 randBg=getBg(uv,currentFrame);\n    return randBg;\n}\n\n// raymarching\nvec2 map(vec3 p){\n    vec2 d=vec2(1e10,0.);\n    \n    float bounce=abs(sin(iTime*PI));\n    float y=-bounce+.5;\n    p.y+=y;\n    \n    float scaleX=remap(0.,1.,1.25,1.,bounce);\n    p.x/=scaleX;\n    \n    float scaleY=remap(0.,1.,.75,1.,bounce);\n    p.y/=scaleY;\n    \n    vec3 p1=p;\n    \n    float d1=sdSphere(p1,.5)*scaleX*scaleY;\n    d=opUnion(d,vec2(d1,1.));\n    \n    vec3 p2=p;\n    p2+=vec3(.15,-.2,.34);\n    float d2=sdSphere(p2,.1);\n    d=opUnion(d,vec2(d2,2.));\n    \n    vec3 p3=p;\n    p3+=vec3(-.15,-.2,.34);\n    float d3=sdSphere(p3,.1);\n    d=opUnion(d,vec2(d3,2.));\n    \n    vec3 p4=p;\n    p4.y*=-1.;\n    p4+=vec3(0.,.15,.45);\n    float angle=PI/4.;\n    float d4=sdCappedTorus(p4,vec2(sin(angle),cos(angle)),.4,.025);\n    d=opUnion(d,vec2(d4,2.));\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 pos,float eps){\n    const vec3 v1=vec3(1.,-1.,-1.);\n    const vec3 v2=vec3(-1.,-1.,1.);\n    const vec3 v3=vec3(-1.,1.,-1.);\n    const vec3 v4=vec3(1.,1.,1.);\n    \n    return normalize(v1*map(pos+v1*eps).x+\n    v2*map(pos+v2*eps).x+\n    v3*map(pos+v3*eps).x+\n    v4*map(pos+v4*eps).x);\n}\n\nvec3 calcNormal(vec3 pos){\n    return calcNormal(pos,.002);\n}\n\nfloat softshadow(in vec3 ro,in vec3 rd,in float mint,in float tmax)\n{\n    float res=1.;\n    float t=mint;\n    for(int i=0;i<16;i++)\n    {\n        float h=map(ro+rd*t).x;\n        res=min(res,8.*h/t);\n        t+=clamp(h,.02,.10);\n        if(h<.001||t>tmax)break;\n    }\n    return clamp(res,0.,1.);\n}\n\nvec3 material(vec3 col,vec3 normal,float m){\n    col=vec3(1.);\n    \n    if(m==1.){\n        col=vec3(1.,.6824,0.);\n    }\n    \n    if(m==2.){\n        col=vec3(.1137,.0588,.0039);\n    }\n    \n    return col;\n}\n\nvec3 lighting(in vec3 col,in vec3 pos,in vec3 rd,in vec3 nor){\n    vec3 lin=vec3(0.);\n    \n    // reflection\n    vec3 ref=reflect(rd,nor);\n    \n    // ao\n    float occ=1.;\n    \n    // sun\n    {\n        // pos\n        vec3 lig=normalize(vec3(-.5,.4,-.6));\n        // dir\n        vec3 hal=normalize(lig-rd);\n        // diffuse\n        float dif=diffuse(nor,lig);\n        // softshadow\n        dif*=softshadow(pos,lig,.02,2.5);\n        // specular\n        float spe=specular(nor,hal,16.);\n        spe*=dif;\n        // fresnel\n        spe*=fresnel(.04,.96,5.,-lig,hal);\n        // apply\n        lin+=col*2.20*dif*vec3(1.30,1.,.70);\n        lin+=5.*spe;\n    }\n    // sky\n    {\n        // diffuse\n        float dif=sqrt(clamp(.5+.5*nor.y,0.,1.));\n        // ao\n        dif*=occ;\n        // specular\n        float spe=smoothstep(-.2,.2,ref.y);\n        spe*=dif;\n        // fresnel\n        spe*=fresnel(.04,.96,5.,rd,nor);\n        // softshadow\n        spe*=softshadow(pos,ref,.02,2.5);\n        // apply\n        lin+=col*.60*dif;\n        lin+=2.*spe;\n    }\n    // back\n    {\n        // diff\n        float dif=diffuse(nor,normalize(vec3(.5,0.,.6)))*clamp(1.-pos.y,0.,1.);\n        // ao\n        dif*=occ;\n        // apply\n        lin+=col*.55*dif;\n    }\n    // sss\n    {\n        // fresnel\n        float dif=fresnel(0.,1.,2.,rd,nor);\n        // ao\n        dif*=occ;\n        // apply\n        lin+=col*.25*dif;\n    }\n    \n    return lin;\n}\n\nvec2 raycast(vec3 ro,vec3 rd){\n    vec2 res=vec2(-1.,-1.);\n    \n    float depth=0.;\n    for(int i=0;i<128;i++){\n        vec3 p=ro+rd*depth;\n        \n        vec2 t=map(p);\n        float d=t.x;\n        float m=t.y;\n        \n        // hit\n        if(d<.0001){\n            res=vec2(depth,m);\n            break;\n        }\n        \n        depth+=d;\n    }\n    \n    return res;\n}\n\nvec3 render(vec3 ro,vec3 rd,vec2 uv){\n    vec3 col=vec3(0.);\n    \n    vec2 res=raycast(ro,rd);\n    float d=res.x;\n    float m=res.y;\n    \n    // skybox\n    // col=vec3(.4,.7,1.)-(rd.y*.7);\n    col=getRandBg(uv).xyz;\n    \n    if(m>-.5){\n        vec3 p=ro+d*rd;\n        \n        vec3 nor=calcNormal(p);\n        col=material(col,nor,m);\n        col=lighting(col,p,normalize(-ro),nor);\n        col=toGamma(col);\n    }\n    \n    return col;\n}\n\nvec3 getSceneColor(vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    // uv (0,1) -> (-1,1)\n    vec2 p=uv;\n    p=2.*p-1.;\n    p.x*=iResolution.x/iResolution.y;\n    \n    // camera\n    vec3 ca=vec3(0.,0.,-5.);\n    float z=4.;\n    vec3 rd=normalize(vec3(p,z));\n    \n    // raymarch\n    vec3 col=render(ca,rd,uv);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 tot=vec3(0.);\n    \n    float AA_size=AASIZE;\n    float count=0.;\n    for(float aaY=0.;aaY<AA_size;aaY++)\n    {\n        for(float aaX=0.;aaX<AA_size;aaX++)\n        {\n            tot+=getSceneColor(fragCoord+vec2(aaX,aaY)/AA_size);\n            count+=1.;\n        }\n    }\n    tot/=count;\n    \n    fragColor=vec4(tot,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 87, 116, 116, 221], [223, 223, 255, 255, 289], [291, 291, 315, 315, 345], [347, 347, 381, 381, 455], [457, 457, 491, 491, 516], [518, 518, 542, 542, 859], [861, 861, 887, 887, 1030], [1032, 1032, 1077, 1077, 1152], [1154, 1154, 1195, 1195, 1220], [1222, 1222, 1264, 1264, 1304], [1306, 1306, 1345, 1345, 1449], [1451, 1451, 1500, 1500, 1578], [1799, 1799, 1853, 1853, 1900], [1902, 1917, 1949, 1949, 1975], [1977, 1977, 2032, 2032, 2155], [2157, 2157, 2188, 2188, 2219], [2221, 2221, 2269, 2269, 2338], [2340, 2340, 2381, 2381, 2406], [2408, 2408, 2463, 2463, 2532], [2534, 2534, 2574, 2574, 2600], [2602, 2602, 2656, 2656, 2727], [2729, 2729, 2758, 2758, 2815], [2817, 2817, 2863, 2863, 2935], [2937, 2937, 3002, 3002, 3050], [3076, 3076, 3099, 3099, 3129], [3131, 3131, 3152, 3152, 3188], [3190, 3190, 3211, 3211, 3247], [3249, 3249, 3270, 3270, 3309], [3311, 3324, 3346, 3346, 3807], [3809, 3816, 3834, 3834, 3995], [3997, 3997, 4015, 4015, 4206], [4208, 4208, 4226, 4226, 4601], [4603, 4603, 4621, 4621, 4842], [4844, 4844, 4862, 4862, 5022], [5024, 5024, 5042, 5042, 5268], [5270, 5270, 5288, 5288, 5632], [5634, 5642, 5672, 5672, 6010], [6012, 6012, 6036, 6104, 6257], [6259, 6274, 6291, 6291, 7047], [7049, 7049, 7085, 7085, 7356], [7358, 7358, 7384, 7384, 7419], [7421, 7421, 7490, 7490, 7718], [7720, 7720, 7764, 7764, 7925], [7927, 7927, 7989, 7989, 9354], [9356, 9356, 9386, 9386, 9730], [9732, 9732, 9769, 9769, 10168], [10170, 10170, 10205, 10205, 10515], [10517, 10517, 10570, 10570, 10899]], "test": "untested"}
{"id": "ms2BWw", "name": "broken noise3", "author": "aliva", "description": "noise explorations", "tags": ["noise"], "likes": 1, "viewed": 108, "published": 3, "date": "1689787367", "time_retrieved": "2024-07-30T17:43:50.564060", "image_code": "vec3 vp = vec3(3.);\nvec3 vpdir = vec3(-3.);\n\n\nvec4 getc(float z) {\n    float dpc = max(min(z,1.),-1.)/2.+0.5;\n    //return vec4(dpc,1.-dpc,0.,1.);\n    return vec4(vec3(1.-dpc-.3),1.);\n}\n\nfloat getdz(vec2 inp) {\n    float x = inp.x;\n    float y = inp.y;\n    return -cos(y-x)-sin(x+y);\n}\n\nfloat getz(vec2 inp) {\n    float x = inp.x;\n    float y = inp.y;\n    return -sin(y-x)+cos(x+y);\n    //return -4.*sin(y*y-x)+cos(x+y);\n}\n\nfloat gettdz(float t, vec2 dir) {\n    return vpdir.z-getdz(dir.xy * t);\n}\n\nfloat gettz(float t, vec2 dir) {\n    return vpdir.z*t+vp.z-getz(dir.xy * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = 0.03* (fragCoord.xy - (iResolution.xy*.5));// - 0.5;\n    \n    float t = 0.;\n    float cz = vp.z;\n    //float roty = normalize(vpdir.z);\n    //vec2 origin = vp-vec3(0.,uv.x,uv.y);\n    \n    vpdir = vec3(0.)-vp-vec3(normalize(vpdir.xy)*uv.x,uv.y);\n    \n    vec2 dir = normalize(vpdir.xy + uv + iTime/100.);\n    \n    //calculate zero using newton's method\n    float pv = 0., cv = 0.;\n    //x_(n + 1) = x_n - (x_n cos(x_n))/(cos(x_n) - x_n sin(x_n))\n    for(int i = 0; i < 20; i++) {\n        pv = cv;\n        cv = cv - gettz(cv,dir)/gettdz(cv,dir);\n        //if((abs(pv-cv)>0.01) break;\n    }\n    \n    \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float z = getz(dir*pv);//.05*\n    fragColor = getc(0.5*z);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2BWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 66, 66, 185], [187, 187, 210, 210, 285], [287, 287, 309, 309, 422], [424, 424, 457, 457, 497], [499, 499, 531, 531, 577], [579, 579, 636, 636, 1363]], "test": "untested"}
{"id": "DdjBDm", "name": "nosisy", "author": "aliva", "description": "Experiment with Inigo quilez noise code.", "tags": ["noise"], "likes": 1, "viewed": 142, "published": 3, "date": "1689781716", "time_retrieved": "2024-07-30T17:43:51.337990", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n// Value Noise (http://en.wikipedia.org/wiki/Value_noise), not to be confused with Perlin's\n// Noise, is probably the simplest way to generate noise (a random smooth signal with \n// mostly all its energy in the low frequencies) suitable for procedural texturing/shading,\n// modeling and animation.\n//\n// It produces lowe quality noise than Gradient Noise (https://www.shadertoy.com/view/XdXGW8)\n// but it is slightly faster to compute. When used in a fractal construction, the blockyness\n// of Value Noise gets qcuikly hidden, making it a very popular alternative to Gradient Noise.\n//\n// The principle is to create a virtual grid/latice all over the plane, and assign one\n// random value to every vertex in the grid. When querying/requesting a noise value at\n// an arbitrary point in the plane, the grid cell in which the query is performed is\n// determined, the four vertices of the grid are determined and their random\n// value fetched and then bilinearly interpolated with a smooth interpolant.\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\n// 0: integer hash\n// 1: float hash (aliasing based) (don't do this unless you live in the year 2013)\n#define METHOD 0\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\n\n#if METHOD==0\nfloat hash( in ivec2 p )  // this hash is not production ready, please\n{                         // replace this by something better\n\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n#else\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n#endif\n\nfloat noise( in vec2 p )\n{\n    #if METHOD==0\n    ivec2 i = ivec2(floor( p ));\n    #else\n    vec2 i = floor( p );\n    #endif\n    vec2 f = fract( p );\n\t\n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    #else\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n    #endif    \n\n    #if METHOD==0\n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n    #else\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n    #endif\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.25;\n\t\n\tfloat f = 0.0;\n\n    // left: value noise\t\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 32.0*uv );\n\t}\n    // right: fbm - fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 8.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjBDm.jpg", "access": "api", "license": "mit", "functions": [[2942, 2942, 2968, 2968, 3718], [3772, 3772, 3829, 3829, 4414]], "test": "untested"}
{"id": "DsjfDw", "name": "SDF Basics 0: Start sphere", "author": "SaphireSoul", "description": "Simple sdf raymarching of a sphere/circle as starting point for further experiments", "tags": ["3d", "raymarching", "sdf", "signeddistancefield"], "likes": 1, "viewed": 154, "published": 3, "date": "1689780282", "time_retrieved": "2024-07-30T17:43:52.092972", "image_code": "// defines/constants\n#define SDF_DIST .01\n#define RAYMARCH_STEPS 50\n#define MAX_DIST 50.0\n\nstruct Ray {\n    vec3 dir;\n    vec3 origin;\n};\n\nfloat GetMinSceneDistanceFromPoint(vec3 point) {\n    //define sphere here for now vec4(position.xyz, radius)\n    vec4 sphere = vec4(0.0, 1.0, 6.0, 1.0);\n    \n    // get distance from point to sphere\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat calcShading(vec3 p) \n{\n    // light source\n    vec3 light_position = vec3(-5.0, 5.0, 2.0);\n    \n    // light direction\n    vec3 light_dir = normalize(light_position - p);\n    \n    // calculate hitpoint normal (gradient of sdf at p)\n    float dist = GetMinSceneDistanceFromPoint(p);\n    vec2 epsilon = vec2(0.01, 0);\n    vec3 normal = normalize(dist - vec3(GetMinSceneDistanceFromPoint(p - epsilon.xyy), \n                                        GetMinSceneDistanceFromPoint(p - epsilon.yxy), \n                                        GetMinSceneDistanceFromPoint(p - epsilon.yyx)));\n    \n    // calculate diffuse contribution\n    return clamp(dot(normal, light_dir), 0.0, 1.0);\n}\n\nfloat Raymarch(Ray r)\n{\n    float dist_0 = 0.0; //distance from origin\n    \n    // main raymarch loop\n    for(int i=0; i < RAYMARCH_STEPS; i++) {\n\n        // march ray from origin in direction\n        vec3 t = r.origin + r.dir * dist_0;\n        \n        // get distance\n        float d = GetMinSceneDistanceFromPoint(t);\n        \n        //advance/march along ray\n        dist_0 += d;\n        \n        //compute sdf\n        if(dist_0 > MAX_DIST || d < SDF_DIST) {\n            // found a hit\n            return dist_0;\n        }\n    } \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Create ray\n    Ray ray;\n    ray.dir = normalize(vec3(uv.x, uv.y, 1.0));\n    ray.origin = vec3(0.0, 1.0, 0.0);\n    \n    // raymarching\n    float m = Raymarch(ray);\n    \n    if(m < MAX_DIST) {\n        // sphere hit\n        vec3 col = vec3(0.8, 0.8, 0.8);\n        fragColor = vec4(col,1.0);\n    }\n    else\n    {\n        // background\n        vec3 col = vec3(uv.xy, 1.0);\n        fragColor = vec4(col,1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 187, 247, 389], [391, 391, 419, 439, 1074], [1076, 1076, 1099, 1099, 1612], [1614, 1614, 1671, 1819, 2302]], "test": "untested"}
{"id": "DsBfWm", "name": "Doggy Dreaming", "author": "dr2", "description": "Quasi-Snoopy in flight mode", "tags": ["peanuts", "snoopy", "beagle"], "likes": 18, "viewed": 198, "published": 3, "date": "1689759241", "time_retrieved": "2024-07-30T17:43:53.137180", "image_code": "// \"Doggy Dreaming\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1   // optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, sunDir, qEye;\nvec2 csHead, csEar, szKen;\nfloat dstFar, tCur;\nint nFrame, idObj;\nconst int idBod = 1, idHead = 2, idEar = 3, idArm = 4, idLeg = 5, idTail = 6, idNos = 7, idJaw = 8,\n   idEye = 9, idCap = 10, idNeck = 11, idScarf = 12, idSeat = 13, idCush = 14, idKenWl = 15,\n   idKenRf = 16, idKenFl = 17;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qr, ePos;\n  float dMin, d, db;\n  dMin = dstFar;\n  p.y -= 5.5;\n  p.xz *= -1.;\n  ePos = vec3 (0.25, 0.85, 0.3);\n  q = p;\n  q.xz = Rot2Cs (q.xz, csHead);\n  qr = q;\n  q.y -= 0.7;\n  d = PrSphDf (q, 0.5);\n  d = max (d, - PrSphDf (vec3 (abs (q.x), q.y + 0.7, q.z) - ePos, 0.18));\n  q.yz = Rot2D (q.yz, -0.11 * pi);\n  q.z -= 0.6;\n  d = max (SmoothMin (d, PrSphDf (q, 0.35), 0.3), 0.06 - length (vec2 (q.y + 0.05,\n     max (0.1 - q.z, 0.))));\n  DMINQ (idHead);\n  q.y -= -0.05;\n  d = PrCylDf (q.xzy, 0.32, 0.05);\n  DMINQ (idJaw);\n  q.yz -= vec2 (0.22, 0.27);\n  d = PrSphDf (q, 0.1);\n  DMINQ (idNos);\n  q = qr;\n  q.y -= 0.7;\n  d = max (PrSphDf (q, 0.55), min (length (q.yz - vec2 (0.45, -0.25)) - 0.35,\n     min (q.z + 0.25, 0.4 - q.y)));\n  DMINQ (idCap);\n  q = qr;\n  q.x = abs (q.x);\n  qEye = q - ePos;\n  d = PrSphDf (qEye, 0.17);\n  DMINQ (idEye);\n  q = qr;\n  q.x = abs (q.x);\n  q -= vec3 (0.48, 0.7, -0.05);\n  d = PrCapsDf (q, 0.06, 0.12);\n  q.x -= 0.04;\n  q.xy = Rot2Cs (q.xy, csEar);\n  d = SmoothMin (d, SmoothMax (max (PrCaps2Df (q.zy, 0.15, 0.5), q.y),\n     abs (q.x) - 0.02, 0.03), 0.03);\n  DMINQ (idEar);\n  q = p;\n  q.yz -= vec2 (0.15, -0.1);\n  d = max (length (q.xz) - 0.15, abs (q.y) - 0.2);\n  DMINQ (idNeck);\n  q = p;\n  q.xy -= vec2 (0.1, 0.07) * CosSin (2. * pi * (q.z + tCur)) * smoothstep (0.3, 0.6, - q.z);\n  q.x = abs (q.x);\n  q -= vec3 (0.14, 0.15, -1.3);\n  d = 0.5 * PrBoxDf (q, vec3 (0.01, 0.04, 1.2));\n  DMINQ (idScarf);\n  q = p;\n  q.yz -= vec2 (-0.35, -0.05);\n  q.x *= 0.85;\n  d = PrSphDf (q, 0.45);\n  q.y -= -0.6;\n  d = SmoothMin (d, PrSphDf (q, 0.55), 0.3);\n  DMINQ (idBod);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, -0.3, 0.05);\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.yz = Rot2D (q.yz, -0.1 * pi);\n  d = PrSphDf (q, 0.11);\n  q.z -= 0.3;\n  d = SmoothMin (d, PrCapsDf (q, 0.1, 0.3), 0.05);\n  DMINQ (idArm);\n  q.yz -= vec2 (0.06, 0.34);\n  d = SmoothMax (PrCaps2Df (q.xy, 0.1, 0.05), abs (q.z) - 0.04, 0.04);\n  q.x = abs (q.x);\n  q.xy = Rot2D (q.xy - vec2 (0.05, 0.13), 0.1 * pi);\n  q.x = abs (q.x) - 0.025;\n  d = SmoothMin (d, PrSphDf (q, 0.04), 0.01);\n  DMINQ (idArm);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.4, -1.35, 0.2);\n  d = PrCapsDf (q, 0.13, 0.45);\n  DMINQ (idLeg);\n  q.yz -= vec2 (0.06, 0.52);\n  d = SmoothMax (PrCaps2Df (q.xy, 0.1, 0.06), abs (q.z) - 0.04, 0.04);\n  q.x = abs (q.x);\n  q.xy = Rot2D (q.xy - vec2 (0.05, 0.13), 0.1 * pi);\n  q.x = abs (q.x) - 0.025;\n  d = SmoothMin (d, PrSphDf (q, 0.04), 0.01);\n  DMINQ (idLeg);\n  q = p;\n  q.yz -= vec2 (-1.3, -0.6);\n  d = PrCapsDf (q, 0.07, 0.3);\n  DMINQ (idTail);\n  q = p;\n  q.yz -= vec2 (-1.55, 0.1);\n  d = PrRoundBoxDf (q, vec3 (0.6, 0.08, 0.7), 0.02);\n  DMINQ (idSeat);\n  q = p;\n  db = dot (vec2 (abs (q.x), q.y), vec2 (1.) / sqrt(2.)) + 1.1;\n  q.yz -= vec2 (-5.4, 0.5);\n  d = max (abs (PrBox2Df (q.xz, szKen)) - 0.07,\n     max (min (- PrCaps2Df (vec2 (q.x, q.y - 0.6), 0.65, 0.75), q.z),\n     max (db, abs (q.y - 2.1) - 2.)));\n  DMINQ (idKenWl);\n  d = max (abs (db) - 0.06, Maxv2 (abs (q.xz) - szKen - 0.3));\n  DMINQ (idKenRf);\n  d = PrBoxDf (q, vec3 (szKen + 0.3, 0.1).xzy);\n  DMINQ (idKenFl);\n  q.xz -= -0.4 * szKen;\n  d = PrRoundBoxDf (q, vec3 (0.6 * szKen, 0.1).xzy, 0.05);\n  DMINQ (idCush);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  idObj = idObjT;\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (4. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, cb4;\n  vec3 col, vn;\n  vec2 u, vf;\n  float dstObj, sh, nDotL;\n  bool isLit;\n  csHead = CosSin (0.2 * pi * sin (0.3 * pi * tCur));\n  csEar = CosSin (-0.4 * pi * (1. + sin (0.5 * pi * tCur)));\n  szKen = vec2 (1.6, 2.2);\n  dstObj = ObjRay (ro, rd);\n  isLit = false;\n  vf = vec2 (0.);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    cb4 = vec4 (0.9, 0.9, 0.92, 0.05);\n    if (idObj <= idJaw) {\n      col4 = cb4;\n      if (idObj == idBod) {\n        if (qHit.z < 0.) col4 *= 0.5 + 0.5 * smoothstep (0., 0.02,\n           PrCaps2Df (vec2 (qHit.x, qHit.y - 0.4), 0.03, 0.5));\n      } else if (idObj == idHead) {\n        col4 = (length (qEye) < 0.21) ? vec4 (0.8, 0.6, 0.2, 0.2) :\n           cb4 * (0.5 + 0.5 * step (0.03, length (qHit.yz - vec2 (0.2, 0.05))));\n      } else if (idObj == idEar) {\n        col4 *= 0.93 + 0.07 * sin (32. * pi * qHit.z);\n      } else if (idObj == idTail) {\n        col4 *= 0.3 + 0.7 * step (-0.17, qHit.z);\n      } else if (idObj == idNos) {\n        col4 = vec4 (0.7, 0.5, 0.5, 0.);\n      } else if (idObj == idJaw) {\n        col4 = vec4 (0.9, 0.9, 0.8, 0.2) * (0.4 + 0.6 * min (step (0.2,\n           fract (32. * (atan (qHit.z, qHit.x) / (2. * pi) + 0.5))),\n           step (0.005, abs (qHit.y))));\n      }\n    } else if (idObj <= idCush){\n      if (idObj == idCap) {\n        col4 = vec4 (0.5, 0.2, 0., 0.) * (0.93 + 0.07 * sin (32. * pi * qHit.x));\n        vf = vec2 (8., 0.2);\n      } else if (idObj == idNeck || idObj == idScarf) {\n        col4 = mix (mix (vec4 (0., 1., 1., 0.2), vec4 (1., 0.3, 0.3, 0.2),\n           step (0.015, abs (qHit.y))), cb4, step (0.042, abs (qHit.y)));\n      } else if (idObj == idSeat) {\n        col4 = vec4 (0.6, 0.5, 0.1, 0.);\n      } else if (idObj == idCush) {\n        col4 = vec4 (0.7, 0.4, 0.4, 0.);\n      }\n    } else {\n      col4 = vec4 (0.8, 0.6, 0.1, 0.);\n      if (idObj == idKenWl) {\n        col4 *= (0.5 + 0.5 * step (0., PrBox2Df (qHit.xz, szKen))) *\n           (0.8 + 0.2 * smoothstep (0.08, 0.1, abs (fract (4. * qHit.y + 0.5) - 0.5)));\n        if (abs (qHit.z) > szKen.y) {\n          u = vec2 (qHit.x * sign (qHit.z - szKen.y), qHit.y - 2.75);\n          if (min (max (min (max (abs (PrCaps2Df ((u - vec2 (-0.1, 0.2)).yx, 0.2, 0.2)),\n             - PrBox2Df (u + vec2 (0.3, 0.), vec2 (0.3, 0.2))),\n             max (abs (PrCaps2Df ((u + vec2 (-0.1, 0.2)).yx, 0.2, 0.2)),\n             - PrBox2Df (u - vec2 (0.3, 0.), vec2 (0.3, 0.2)))), abs (u.x) - 0.3),\n             abs (length (u.xy) - 0.65) + 0.03) < 0.06) col4 = vec4 (0.2, 1., 1., 0.2);\n        }\n      } else if (idObj == idKenRf) {\n        col4 *= 0.8 + 0.2 * smoothstep (0.04, 0.05, abs (fract (2. * qHit.z + 0.5) - 0.5));\n        vf = vec2 (16., 0.2);\n      } else if (idObj == idKenFl) {\n        col4 *= 0.7;\n        vf = vec2 (4., 0.5);\n      }\n    }\n    if (idObj == idEye) {\n      rd = reflect (rd, vn);\n      col = mix (vec3 (0., 0.3, 0.3), ((rd.y > 0.) ? SkyCol (rd) : vec3 (0.1, 0.5, 0.1)), 0.7);\n    } else {\n      isLit = true;\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = vec4 (0.2, 0.5, 0.2, 0.) * (0.7 + 0.3 * Fbm2 (ro.xz));\n    vf = vec2 (1., 0.5);\n    isLit = true;\n  } else {\n    col = SkyCol (rd);\n  }\n  if (isLit) {\n    if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    nDotL = max (dot (vn, sunDir), 0.);\n    if (idObj >= idBod || idObj <= idTail) nDotL *= sqrt (nDotL);\n    sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.9 * pi * SmoothBump (0.25, 0.75, 0.22, fract (0.04 * tCur)) * sign (fract (0.02 * tCur) - 0.5);\n    el -= 0.05 * pi * cos (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 3., -25.);\n  ro.y = max (ro.y, 0.05);\n  zmFac = 5.;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    rd = vuMat * normalize (vec3 (uvv, zmFac));\n    col += (1. / naa) * ((length (uvv * vec2 (max (0.8, 1. / asp), 1.)) > 0.99) ? vec3 (0.82) :\n       ShowScene (ro, rd));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (vec3 (p.xy, sign (p.z) * (max (0., abs (p.z) - h)))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (vec2 (p.x, sign (p.y) * (max (0., abs (p.y) - h)))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBfWm.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[1270, 1270, 1292, 1292, 4495], [4497, 4497, 4530, 4530, 4777], [4779, 4779, 4800, 4800, 5055], [5057, 5057, 5094, 5094, 5387], [5389, 5389, 5412, 5412, 5575], [5577, 5577, 5612, 5612, 9328], [9330, 9330, 9386, 9386, 10724], [10726, 10726, 10758, 10758, 10858], [10860, 10860, 10906, 10906, 10953], [10955, 10955, 10988, 10988, 11077], [11079, 11079, 11112, 11112, 11139], [11141, 11141, 11183, 11183, 11234], [11236, 11236, 11279, 11279, 11356], [11358, 11358, 11402, 11402, 11478], [11480, 11480, 11502, 11502, 11529], [11531, 11531, 11553, 11553, 11580], [11582, 11582, 11627, 11627, 11719], [11721, 11721, 11766, 11766, 11804], [11806, 11806, 11863, 11863, 11946], [11948, 11948, 11984, 11984, 12190], [12192, 12192, 12222, 12222, 12335], [12337, 12337, 12368, 12368, 12432], [12466, 12466, 12490, 12490, 12602], [12604, 12604, 12629, 12629, 12813], [12815, 12815, 12836, 12836, 12991], [12993, 12993, 13022, 13022, 13234], [13236, 13236, 13275, 13275, 13527]], "test": "untested"}
{"id": "msjfDD", "name": "assign5_task2", "author": "Luna", "description": "Doraemon using ray tracing\nrolling balls\nPyramid", "tags": ["raytracing"], "likes": 0, "viewed": 116, "published": 3, "date": "1689752140", "time_retrieved": "2024-07-30T17:43:54.501532", "image_code": "//============================================================================\n// PROJECT ID: SWS3005_11\n//\n// GROUP NUMBER: 11\n//\n// STUDENT NAME: LI YAO\n// NUS User ID.: t0930394\n//\n// STUDENT NAME: WANG HONGBO\n// NUS User ID.: t0930184\n//\n// STUDENT NAME: YOU XINYI\n// NUS User ID.: t0930404\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/view/msjfDD\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n\n\n//============================================================================\n// Initialize the Doraemon \n//============================================================================\nvoid InitDoraemon() {\n    //  Head\n    if (iTime>=13.0){\n    Sphere[0].center = vec3( 0.0, 1.4, 0.0 );\n    Sphere[0].radius = 0.5;\n    Sphere[0].materialID = 3;\n    }\n\n    //  Body\n    if (iTime>=5.0){\n    Stick[0].vertexA = vec3( 0.0, 1.4, 0.0 );\n    Stick[0].vertexB = vec3( 0.0, 0.7, 0.0 );\n    Stick[0].radius = 0.35;\n    Stick[0].materialID = 3;\n    }\n\n    // arm\n    if (iTime>=8.0){\n    float hand=0.1;\n    vec3 x = vec3( -0.7, 0.7, 0.0 );\n    vec3 y = vec3( -0.4, 0.9, 0.0 );\n    float r = sqrt( (x.x-y.x)*(x.x-y.x) + (x.y-y.y)*(x.y-y.y) + (x.z-y.z)*(x.z-y.z));\n    float w = 60.0;\n    float temp = 6.283185 * iTime / 120.0 * w;\n    float t = 1.0 / 3.0 * sin(temp);\n    Sphere[1].center.x = y.x - r * cos(-t );\n    Sphere[1].center.y = y.y - r * sin(-t ); \n    Sphere[1].center.z = y.z;\n    Sphere[1].radius = hand+0.03;\n    Sphere[1].materialID = 4;\n    Stick[1].vertexA = Sphere[1].center;\n    Stick[1].vertexB = vec3( -0.4, 1.0, 0.0 );\n    Stick[1].radius = hand;\n    Stick[1].materialID = 3;\n\n    Sphere[2].center = vec3( 0.7, 0.7, 0.0 );\n    Sphere[2].radius = hand+0.03;\n    Sphere[2].materialID = 4;\n    Stick[2].vertexA = vec3( 0.4, 0.9, 0.0 );\n    Stick[2].vertexB = Sphere[2].center;\n    Stick[2].radius = hand;\n    Stick[2].materialID = 3;\n    }\n    // leg\n    if (iTime>=2.0)\n    {\n    float leg=0.15;\n    float dis=0.2;\n    Stick[3].vertexA = vec3( -0.2, dis+0.3, 0.0 );\n    Stick[3].vertexB = vec3( -0.2, dis+0.05, 0.0 );\n    Stick[3].radius = leg;\n    Stick[3].materialID = 3;\n    Stick[4].vertexA = vec3( -0.2, dis+0.05, 0.0 );\n    Stick[4].vertexB = vec3( -0.2, dis, 0.0 );\n    Stick[4].radius = leg;\n    Stick[4].materialID = 4;\n\n    Stick[5].vertexA = vec3( 0.2, dis+0.3, 0.0 );\n    Stick[5].vertexB = vec3( 0.2, dis+0.05, 0.0 );\n    Stick[5].radius = leg;\n    Stick[5].materialID = 3;\n    Stick[6].vertexA = vec3( 0.2, dis+0.05, 0.0 );\n    Stick[6].vertexB = vec3( 0.2, dis, 0.0 );\n    Stick[6].radius = leg;\n    Stick[6].materialID = 4;\n    }\n\n\n   // bell\n   if (iTime>=13.0){\n    Sphere[3].center = vec3( 0.0, 1.05, 0.40 );\n    Sphere[3].radius = 0.08;\n    Sphere[3].materialID = 9;\n   }\n\n    // tail\n    if (iTime>=13.0){\n    Sphere[4].center = vec3( 0.0, 0.8, -0.35 );\n    Sphere[4].radius = 0.08;\n    Sphere[4].materialID = 6;\n    }\n\n    // nose\n    if (iTime>=13.0){\n    Sphere[5].center = vec3( 0.0, 1.6, 0.5 );\n    Sphere[5].radius = 0.07;\n    Sphere[5].materialID = 6;\n    }\n\n    // eyes\n    if (iTime>=13.0){\n    Ellipsoid[0].center = vec3(-0.1,1.8,0.38);\n    Ellipsoid[0].rad.x = 0.08;\n    Ellipsoid[0].rad.y = 0.1;\n    Ellipsoid[0].rad.z = 0.01;\n    Ellipsoid[0].materialID=4;\n    Ellipsoid[1].center = vec3(0.1,1.8,0.38);\n    Ellipsoid[1].rad.x = 0.08;\n    Ellipsoid[1].rad.y = 0.1;\n    Ellipsoid[1].rad.z = 0.01;\n    Ellipsoid[1].materialID=4;\n\n    Ellipsoid[2].center = vec3(-0.1,1.8,0.39);\n    Ellipsoid[2].rad.x = Ellipsoid[0].rad.x*0.25;\n    Ellipsoid[2].rad.y =  Ellipsoid[0].rad.y *0.25;\n    Ellipsoid[2].rad.z = 0.01;\n    Ellipsoid[2].materialID=7;\n    Ellipsoid[3].center = vec3(0.1,1.8,0.39);\n    Ellipsoid[3].rad.x = Ellipsoid[0].rad.x*0.25;\n    Ellipsoid[3].rad.y =  Ellipsoid[0].rad.y *0.25;\n    Ellipsoid[3].rad.z = 0.01;\n    Ellipsoid[3].materialID=7;\n    }\n\n}\n\nvoid InitBambooCopter(vec3 center) {\n    float zoom = 2.5;\n    float sizeOfCircle = 0.1* zoom;\n    float xPos = center.x;\n    float yPos = center.y + sizeOfCircle;\n    float zPos = center.z;\n    for (int i = 0; i < NUM_ROLLING_BALLS; i++)\n    {\n        float angle = 2.0 * PI / float(NUM_ROLLING_BALLS);\n        RollingBalls1[i].center.x = xPos + sizeOfCircle * sin(float(i) * angle + iTime * 12.0);\n        RollingBalls1[i].center.y = yPos;\n        RollingBalls1[i].center.z = zPos + sizeOfCircle * cos(float(i) * angle + iTime * 12.0);\n        RollingBalls1[i].radius = 0.03 ;\n        RollingBalls1[i].materialID = 5;\n    }\n    Stick[13].vertexA = center + vec3(0.0, sizeOfCircle*0.9, 0.0);\n    Stick[13].vertexB = center;\n    Stick[13].radius = 0.03;\n    Stick[13].materialID = 5;\n\n}\nvoid initDoor()\n{\n    Box[0].size = vec3(.4,.8,.05);\n    Box[0].center = vec3(-2.0,0.9,2.0);\n    Box[0].materialID = 2;\n\n    Sphere[7].center =Box[0].center+vec3(-0.15,0.0,0.07);\n    Sphere[7].radius = 0.07;\n    Sphere[7].materialID = 0;\n\n}\n\nvoid initLight()\n{\n    // Lighting Coeffecient\n    float lightCoeff = 1.0 / 12.5;\n\n    // Light 1.\n    Light[0].position = vec3(2.0*cos(1.1*iTime)+0.5, 8.0, 2.0*sin(1.1*iTime)+2.0) * 1.2;\n    Light[0].I_a      = vec3(7.0, 1.0, 4.0) * lightCoeff;\n    Light[0].I_source = vec3(7.0, 1.0, 4.0) * lightCoeff;\n\n    // Light 2.\n    Light[1].position = vec3(2.0*cos(1.1*iTime+PI*0.667)+0.5, 8.0, 2.0*sin(1.1*iTime+PI*0.667)+2.0) * 1.2;\n    Light[1].I_a      = vec3(1.0, 4.0, 7.0) * lightCoeff;\n    Light[1].I_source = vec3(1.0, 4.0, 7.0) * lightCoeff;\n\n    // Light 3.\n    Light[2].position = vec3(2.0*cos(1.1*iTime+PI*1.333)+0.5, 8.0, 2.0*sin(1.1*iTime+PI*1.333)+2.0) * 1.2;\n    Light[2].I_a      = vec3(4.0, 7.0, 1.0) * lightCoeff;\n    Light[2].I_source = vec3(4.0, 7.0, 1.0) * lightCoeff;\n    \n\n    Light[3].position = vec3( 0.0, 4.0, 8.0 );\n    Light[3].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[3].I_source = vec3( 1.0, 1.0, 1.0 ) * 0.3;\n\n}\nfloat seed;\n\nvoid initBouncingBall()\n{\n    Sphere[6].center = vec3( 1.5 * cos(iTime), 0.5 + abs(cos(6.2831 * iTime)), 1.5 *sin(iTime) );\n    Sphere[6].radius = 0.5;\n    Sphere[6].materialID = 1;\n}\n\nvoid InitRollingPyrimid(){\n    // size\n    float size = 1.1;\n    float ballRad = 0.2;\n\n    // translate direction\n    vec3 transDirec = vec3(3.0, 1.5 * ballRad, -0.5);\n    int num_sph=8;\n    for (int i = num_sph; i < NUM_SPHERES; i++){\n        Sphere[i].radius = ballRad;\n        Sphere[i].materialID = 8;\n    }\n\n    Sphere[num_sph].center = size * vec3(0.0, sqrt(6.0), 0.0) + transDirec;\n    Sphere[num_sph+1].center = size * vec3(cos(iTime)         , 0.0, sin(iTime)         ) + transDirec;\n    Sphere[num_sph+2].center = size * vec3(cos(iTime+PI*0.667), 0.0, sin(iTime+PI*0.667)) + transDirec;\n    Sphere[num_sph+3].center = size * vec3(cos(iTime+PI*1.333), 0.0, sin(iTime+PI*1.333)) + transDirec;\n\n    Stick[7].vertexA = Sphere[num_sph].center; Stick[7].vertexB = Sphere[num_sph+1].center;\n    Stick[8].vertexA = Sphere[num_sph].center; Stick[8].vertexB = Sphere[num_sph+2].center;\n    Stick[9].vertexA = Sphere[num_sph].center; Stick[9].vertexB = Sphere[num_sph+3].center;\n    Stick[10].vertexA = Sphere[num_sph+1].center; Stick[10].vertexB = Sphere[num_sph+2].center;\n    Stick[11].vertexA = Sphere[num_sph+1].center; Stick[11].vertexB = Sphere[num_sph+3].center;\n    Stick[12].vertexA = Sphere[num_sph+2].center; Stick[12].vertexB = Sphere[num_sph+3].center;\n\n    Stick[7].radius = ballRad / 2.5; Stick[7].materialID = 3;\n    Stick[8].radius = ballRad / 2.5; Stick[8].materialID = 3;\n    Stick[9].radius = ballRad / 2.5; Stick[9].materialID = 3;\n    Stick[10].radius = ballRad / 2.5; Stick[10].materialID = 3;\n    Stick[11].radius = ballRad / 2.5; Stick[11].materialID = 3;\n    Stick[12].radius = ballRad / 2.5; Stick[12].materialID = 3;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n\n    Plane[2].A = 0.0;\n    Plane[2].B = 1.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 10.0;\n    Plane[2].materialID = 4;\n\n    Plane[3].A = 1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = -10.0;\n    Plane[3].materialID = 0;\n\n    Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 10.0;\n    Plane[4].materialID = 4;\n\n\n\n    InitDoraemon();\n    if (iTime>=23.0){\n    initDoor();\n    }\n    if (iTime>=18.0){\n    vec3 center = vec3(0.0, 2.0, 0.0);\n    InitBambooCopter(center);\n    }\n    if (iTime>=25.0){\n    // Initialize the rolling pyrimid\n    InitRollingPyrimid();\n    }\n    if (iTime>=27.0){\n    initBouncingBall();\n    }\n    \n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // center sphere material.\n    Material[1].k_d = vec3( 1.0, 1.0, 1.0 );\n    Material[1].k_a = 0.0 * Material[1].k_d;\n    Material[1].k_r = 0.8 * Material[1].k_d;\n    Material[1].k_rg = 1.2 * Material[1].k_r;\n    Material[1].n = 128.0;\n    Material[1].ior = 4.5;\n    Material[1].fuzz = -1.0;\n\n    // Pink material.\n    Material[2].k_d = vec3(232.0,107.0,163.0) / 255.0;;\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r =0.5* Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    //  Blue material\n    Material[3].k_d = vec3( 0.0, 0.62, 0.91 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 0.2*Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n\n    //  White material\n    Material[4].k_d = vec3( 200.0,200.0, 200.0) / 255.0;\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = vec3(0.0);;\n    Material[4].k_rg = vec3(0.0);\n    Material[4].n = 128.0;\n\n    //  Bamboo Copter Yellow material\n    Material[5].k_d = vec3(235.0, 188.0, 59.0) / 255.0;\n    //Material[5].k_d = vec3( 1.0, 0.84134, 0.0 );\n    Material[5].k_a = 0.2 * Material[5].k_d;\n    Material[5].k_r = 1.5 * Material[5].k_d;\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 128.0;\n\n    //  Red material\n    Material[6].k_d = vec3(0.9, 0.0314, 0.0667);\n    Material[6].k_a = 0.2 * Material[6].k_d;\n    Material[6].k_r = 1.0 * Material[6].k_d;\n    Material[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].n = 64.0;\n\n    //  Black material\n    Material[7].k_d = vec3( 0.0, 0.0, 0.0 );\n    Material[7].k_a = 0.2 * Material[7].k_d;\n    Material[7].k_r = 2.0 * Material[7].k_d;\n    Material[7].k_rg = 0.5 * Material[7].k_r;\n    Material[7].n = 64.0;\n\n    // Balls - Silver material.\n    Material[8].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[8].k_a = 0.2 * Material[8].k_d;\n    Material[8].k_r = 2.0 * Material[8].k_d;\n    Material[8].k_rg = 0.5 * Material[8].k_r;\n    Material[8].n = 64.0;\n\n    //  Bell Yellow material\n    Material[9].k_d = vec3(255.0, 228.0, 59.0) / 255.0;\n    //Material[5].k_d = vec3( 1.0, 0.84134, 0.0 );\n    Material[9].k_a = 0.2 * Material[9].k_d;\n    Material[9].k_r = 1.5 * Material[9].k_d;\n    Material[9].k_rg = 0.5 * Material[9].k_r;\n    Material[9].n = 128.0;\n\n\n    initLight();\n}\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay(in Ray_t ray, out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg,out float ior, out float fuzz)\n{\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;\n    vec3 nearest_hitPos;\n    vec3 nearest_hitNormal;\n    int nearest_hitMatID;\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    \n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    temp_hasHit=false;\n    \n    \n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n\n        if (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }\n    }\n\n    //head\n    if (IntersectSphere(Sphere[0], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n    {\n        temp_hasHit = true;\n        if (temp_t < nearest_t)\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            vec3 temp = temp_hitPos - Sphere[0].center;\n            float r = Sphere[0].radius * 0.8;\n            //is in face\n            if(temp.x * temp.x + (temp.y - (-Sphere[0].radius + r)) * (temp.y - (-Sphere[0].radius + r)) <= r*r && temp.z > 0.0){\n                //is in mouth\n                nearest_hitMatID = 4;//white\n                if(-r <= temp.y && temp.y <= 0.0)\n                    if(-0.75 * Sphere[0].radius <= temp.x && temp.x <=0.75 * Sphere[0].radius)\n                        if(temp.y >= 64.0 / 45.0 * (temp.x - 0.75 * Sphere[0].radius) * (temp.x + 0.75 * Sphere[0].radius))\n                            nearest_hitMatID = 6;//red\n                            \n            }\n            else\n                nearest_hitMatID = Sphere[0].materialID;//blue\n        }\n    }\n    //others\n    for (int i = 1; i < NUM_SPHERES; i++)\n    {\n        float temp_t;\n        if (IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n\n    //body\n    if (IntersectStick(Stick[0], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n    {\n        temp_hasHit = true;\n        if (temp_t < nearest_t)\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n\n            float r = 0.85 * Stick[0].radius;\n            vec3 temp = temp_hitPos - Stick[0].vertexB;\n            vec3 bottom = Stick[0].vertexA - Stick[0].vertexB;\n            float x = temp.x - 0.5 * bottom.x;\n            float y = temp.y - 0.2 * bottom.y;\n            //is in belly\n            if(x * x + y * y <= r * r && temp.z > 0.0){\n                float rr = 0.77 * r;\n                if(x * x + y * y <= rr * rr && temp.z > 0.0 && y <= 0.0){\n                    float rrr = 0.73 * r;\n                    if(x * x + y * y <= rrr * rrr && temp.z > 0.0 && y <= -0.04)\n                        nearest_hitMatID = 4;\n                    else\n                        nearest_hitMatID = 7;\n                }\n                    \n                    \n                else\n                nearest_hitMatID = 4;\n            }\n                \n            else\n            nearest_hitMatID = Stick[0].materialID;\n        }\n    }\n    //others\n    for (int i = 1; i < NUM_STICKS; i++)\n    {\n        float temp_t;\n        if (IntersectStick(Stick[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Stick[i].materialID;\n            }\n        }\n    }\n\n    for (int i = 0; i < NUM_Ellipsoids; i++)\n    {\n        float temp_t;\n        if (IntersectEllipsoid(Ellipsoid[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Ellipsoid[i].materialID;\n            }\n        }\n    }\n\n    for (int i = 0; i < NUM_ROLLING_BALLS; i++)\n    {\n        float temp_t;\n        if (IntersectSphere(RollingBalls1[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = RollingBalls1[i].materialID;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_ROLLING_BALLS; i++)\n    {\n        float temp_t;\n        if (IntersectSphere(RollingBalls2[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = RollingBalls2[i].materialID;\n            }\n        }\n    }\n\n        \n    for (int i = 0; i < NUM_BOXS; i++)\n    {\n\n        if (IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n            }\n        }\n    }\n    hasHitSomething=temp_hasHit;\n\n\n    hasHit = hasHitSomething;\n    if (!hasHitSomething)\n        return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3(0.0);\n    \n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    Ray_t shadowRay;\n    shadowRay.o = nearest_hitPos;\n\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        bool intersect = false;\n\n        // Check for shadow by casting a shadow ray to each light source.\n\n        for (int j = 0; j < NUM_PLANES; j++)\n        {\n            if (IntersectPlane(Plane[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n        for (int j = 0; j < NUM_SPHERES; j++)\n        {\n            if (IntersectSphere(Sphere[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n\n        for (int j = 0; j < NUM_STICKS; j++)\n        {\n            if (IntersectStick(Stick[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n\n\n        for (int j = 0; j < NUM_ROLLING_BALLS; j++)\n        {\n            if (IntersectSphere(RollingBalls1[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n        for (int j = 0; j < NUM_ROLLING_BALLS; j++)\n        {\n            if (IntersectSphere(RollingBalls2[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n\n        for (int j = 0; j < NUM_BOXS; j++)\n        {\n            if (IntersectBox(Box[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n        if (!intersect)\n        {\n            I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, intersect, Material[nearest_hitMatID], Light[i]);\n        }\n        \n    }\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    ior = Material[nearest_hitMatID].ior;\n    fuzz = Material[nearest_hitMatID].fuzz;\n\n    return I_local;\n}\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\n    // Position the camera.\n    vec2 mouse_pos = iMouse.xy /iResolution.xy;\n    vec3 cam_pos = 3.0 * normalize(vec3(sin(0.35 * iTime + 3.0*mouse_pos.x), 0.2 + 0.8 * mouse_pos.y, \n                   abs(cos(0.35 * iTime + 3.0*mouse_pos.x)))) + vec3(0.0,2.0,4.0);\n   // vec3 cam_pos = vec3( 0.0, 2.0, 3.0 );\n    vec3 cam_lookat = vec3( 0.0, 0.0, -1.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    vec3 er = normalize(vec3(pixel_pos,pixel_pos_z));\n    pRay.d = normalize(mat3(cam_x_axis,cam_y_axis,cam_z_axis)*er);\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay[TOTAL_RAY_NUM];\n    nextRay[0] = pRay;\n    nextRay[0].should_cast = true;\n    nextRay[0].weight = 1.0;\n    \n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        float ior,fuzz;\n        \n        vec3 I_local;\n        //Cast at least one ray\n        //Maybe we need to cast more ray\n        for(int i=0;i<TOTAL_RAY_NUM;++i)\n        {\n            if(!nextRay[i].should_cast)\n                break;\n            I_local += CastRay( nextRay[i], hasHit, hitPos, hitNormal, k_rg,ior,fuzz)*nextRay[i].weight;\n            nextRay[i].should_cast = false;\n        }\n        \n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n        \n        vec3 reflected = reflect(nextRay[0].d, hitNormal);\n        \n        if(ior<0.0){ \n            if(fuzz<0.0){\n                //For specular surface, we only cast one ray\n                nextRay[0] = Ray_t( hitPos, reflected,true,1.0);\n            }else{\n                //For glossy surface, we need to sample more ray\n                for(int i=0;i<GLOSSY_RAY_NUM;++i){\n                    nextRay[i] = Ray_t( hitPos, reflected+fuzz*random_in_unit_sphere(seed),true,GLOSSY_RAY_WEIGHT);\n                    //refresh seed\n                    seed = hash1(seed);\n                }\n            }\n        }\n        else{\n        //For trasparent surface,we trace one or two ray\n            vec3 dir = nextRay[0].d;\n            if(dot(-dir,hitNormal)>=0.0){\n                ior = 1.0/ior;\n            }else{\n                hitNormal = -hitNormal;\n            }\n            float cos_theta = min(dot(-dir, hitNormal), 1.0);\n            float sin2_theta = 1.0 - cos_theta*cos_theta;\n            bool total_internal_reflect = ior*ior*sin2_theta > 1.0;\n            if(total_internal_reflect){\n            //For total internal reflection, we only cast one ray\n               nextRay[0] = Ray_t( hitPos, reflected,true,1.0);\n            }\n            else{\n            //We cast one ray for reflection, one ray for refraction\n               float reflective = reflectance(cos_theta,ior);\n               nextRay[0] = Ray_t(hitPos,reflected,true,reflective);\n               nextRay[1] = Ray_t(hitPos,refract(-dir,hitNormal,ior),true,1.0-reflective);\n            }\n       }\n    }\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [{"id": 34026, "src": "https://soundcloud.com/shekhar-tyagi/doraemon-theme-song", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "//============================================================================\n// Constants.\n//============================================================================\n\n\nconst float PI = 3.1415926536;\n\nconst float TAU = 2.0*PI;\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\n\nfloat cuberoot( float x ) { return sign(x)*pow(abs(x),1.0/3.0); }\n\nvec3 random_in_unit_sphere(float seed) {\n    float u = hash1(seed);\n    float v = hash1(seed);\n    float theta = u*2.0*PI;\n    float phi = acos(2.0*v-1.0);\n    float r = cuberoot(hash1(seed));\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r*sinPhi*cosTheta;\n    float y = r*sinPhi*sinTheta;\n    float z = r*cosPhi;\n    return vec3(x,y,z);\n}\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 3;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 4;\nconst int NUM_MATERIALS = 11;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 20;\nconst int NUM_STICKS = 40;\nconst int NUM_Ellipsoids=10;\nconst int NUM_ROLLING_BALLS = 8;\nconst int NUM_BOXS = 2;\n// Constants for ray numbers\nconst int TOTAL_RAY_NUM = 10;\nconst int GLOSSY_RAY_NUM = 10;\nconst float GLOSSY_RAY_WEIGHT = 1.0/float(GLOSSY_RAY_NUM);\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n    bool should_cast;\n    float weight;\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Stick_t {\n    vec3 vertexA;\n    vec3 vertexB;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Ellipsoid_t {\n    vec3 center;\n    vec3 rad;       // radius of x,y,z axis\n    int materialID;\n};\n\nstruct Box_t{\n    vec3 center;\n    vec3 size;\n    int materialID;\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n    float ior;  // Index of Refraction\n    float fuzz; // fuzz parameter\n};\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nStick_t Stick[NUM_STICKS];\nEllipsoid_t Ellipsoid[NUM_Ellipsoids];\nSphere_t RollingBalls1[NUM_ROLLING_BALLS];\nSphere_t RollingBalls2[NUM_ROLLING_BALLS];\nBox_t Box[NUM_BOXS];\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V, V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n    float discriminate = DdotV * DdotV - a0;\n\n    if (DdotV <= 0.0) {\n\n        if (discriminate >= 0.0) {\n            t = -DdotV - sqrt(discriminate);\n            hitPos = ray.o + t * ray.d;\n            hitNormal = normalize(hitPos - sph.center);\n            return (t >= tmin && t<= tmax);\n        }\n    }\n    return false;\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 V = ray.o - sph.center;\n    float a = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n    float discriminate = DdotV * DdotV - a;\n    if (DdotV <= 0.0) {\n\n        if (discriminate >= 0.0) {\n            float t1 = -DdotV - sqrt(discriminate);\n            float t2 = -DdotV + sqrt(discriminate);\n            return ((t1 >= tmin && t1<= tmax) || (t2 >= tmin && t2 <= tmax));\n        }\n    }\n    return false;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\n\n// reference from https://www.shadertoy.com/view/Xt3SzX of capIntersect() and capNormal\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the normal vector at the specified position on the stick surface.\n/////////////////////////////////////////////////////////////////////////////\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectStick( in Stick_t stk, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    t = capIntersect( ray.o, ray.d, stk.vertexA, stk.vertexB, stk.radius );\n\n    if (t >= 0.0 && t <= tmax){\n        hitPos = ray.o + t * ray.d;\n        hitNormal = capNormal(hitPos, stk.vertexA, stk.vertexB, stk.radius);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectStick( in Stick_t stk, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t = capIntersect( ray.o, ray.d, stk.vertexA, stk.vertexB, stk.radius );\n    if (t >= 0.0 && t >= tmin && t <= tmax){\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n// reference from https://www.shadertoy.com/view/llsSzn of eliIntersect() and eliNormal\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between an ellipsoid and a ray.\n/////////////////////////////////////////////////////////////////////////////\nfloat eliIntersect( in vec3 ro, in vec3 rd,in Ellipsoid_t sph )\n{\n    vec3 oc = ro - sph.center;\n    \n    vec3 ocn = oc / sph.rad;\n    vec3 rdn = rd / sph.rad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.0);\n\tif( h<0.0 ) return -1.0;\n\treturn (-b - sqrt( h ))/a;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the normal vector at the specified position on the ellipsoid surface.\n/////////////////////////////////////////////////////////////////////////////\nvec3 eliNormal( in vec3 pos, in Ellipsoid_t sph )\n{\n    return normalize( (pos-sph.center)/sph.rad );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between an ellipsoid and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectEllipsoid( in Ellipsoid_t tr, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    t = eliIntersect( ray.o, ray.d, tr );\n\n    if (t >= 0.0 && t <= tmax){\n        hitPos = ray.o + t * ray.d;\n        hitNormal = eliNormal(hitPos, tr);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between an ellipsoid and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectEllipsoid( in Ellipsoid_t tr, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t = eliIntersect( ray.o, ray.d, tr );\n    if (t >= 0.0 && t >= tmin && t <= tmax){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance.\n    float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n    r0 = r0*r0;\n    float temp = 1.0-cosine;\n    float temp2 = temp*temp;\n    return r0 + (1.0-r0)*temp*temp2*temp2;\n}\n\nbool IntersectBox( in Box_t box, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    vec3 ro = ray.o;\n    ray.o -= box.center;\n    vec3 m = sign(ray.d)/max(abs(ray.d), 1e-8);\n    vec3 n =m*ray.o;\n    vec3 k = abs(m)*box.size;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if( tN>tF || tF<=0.0) return false;\n    \n    if(tN >= tmin && tF<=tmax){\n        t = tN;\n        hitPos = ro + t*ray.d;\n        hitNormal = -sign(ray.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return true;\n    }\n    if(tF >= tmin && tF <= tmax){\n        t = tF;\n        hitPos = ro + t*ray.d;\n        hitNormal = -sign(ray.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return true;\n    }\n    \n    return false;\n}\n\nbool IntersectBox( in Box_t box, in Ray_t ray, in float tmin, in float tmax )\n{\n    ray.o -= box.center;\n    vec3 m = sign(ray.d)/max(abs(ray.d), 1e-8);\n    vec3 n =m*ray.o;\n    vec3 k = abs(m)*box.size;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if( tN>tF || tF<=0.0) return false;\n    \n    return (tN >= tmin && tF<=tmax)||(tF >= tmin && tF <= tmax);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[646, 832, 853, 866, 4048], [4050, 4050, 4086, 4086, 4836], [4837, 4837, 4854, 4854, 5077], [5079, 5079, 5097, 5125, 6013], [6027, 6027, 6052, 6052, 6210], [6212, 6212, 6238, 6250, 7859], [7861, 8043, 8061, 8086, 11568], [11574, 11928, 12058, 12058, 12470], [12474, 13263, 13390, 13390, 23205], [23212, 23573, 23630, 23630, 27227]], "test": "untested"}
{"id": "mdSfWh", "name": "Branching Flow Slime Mold", "author": "fenix", "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n\nIn honor of Richard Courant, a pioneer of CFD. The wave speed is modulated by simplex noise.\n\n* mouse: emit wave\n* space: reset\n* shift: disable shadows\n* b: blur off", "tags": ["2d", "reflection", "wave", "simulation"], "likes": 26, "viewed": 360, "published": 3, "date": "1689746779", "time_retrieved": "2024-07-30T17:43:55.378188", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  The simulation is pretty much the same as its fork parent, where I'm sending waves\n//  through a field with varying wave speed (Courant number) by position. In the video,\n//  Mr. Berglund shows a simulation with a baroque thread-like structure. I wanted to see\n//  these, and I think I found them. The \"trick\" is to visualize the derivative of the\n//  wave. It's necessasry to blur that over time to hide the wave motion (press B to disable\n//  the blurring, to see why it's necessary).\n//\n//  The lighting is also substantially the same as its predecessor, with screen-space\n//  shadows really helping to highlight the tendrils. The \"slime mold\" in the name is because\n//  these tendrils remind me of the \"slime mold\" simulations I've tried before, like:\n//\n//      Slime Mold Terrain     https://shadertoy.com/view/Dd23z3\n//\n//  The idea of those is to have particles lay trails that the particles prefer to\n//  follow. There's probably some reason why this wave simulation produces similar\n//  results, but I'm not at all sure that happens mathematically.\n// ---------------------------------------------------------------------------------------\n\nfloat map(vec2 p)\n{\n    float d = texture(iChannel0, p / iResolution.xy).w;\n    return pow(d * 5e4, .3);\n}\n\nvec2 gradient(vec2 p)\n{\n    if (p.y == iResolution.y - .5) return vec2(0);\n    \n    vec2 delta = vec2(1, 0);\n    float xGrad = map(p + delta.xy) - map(p - delta.xy);\n    float yGrad = map(p + delta.yx) - map(p - delta.yx);\n\n    return vec2(xGrad, yGrad);\n}\n\nvec4 getColor(float d)\n{\n    vec4 c = sin(d * vec4(3, 4, 1, 0));\n    return c * c * c + vec4(.02,.02,.3,0);\n}\n\nfloat computeShadow(vec2 u, float pd)\n{\n    if (keyDown(KEY_SHIFT)) return 1.;\n    \n    vec2 del = vec2(-1, 1);\n    float sh = 1.;\n    for (float i = 0.; i < 12.; ++i)\n    {\n        u += del;\n        float nd = map(u);\n        sh *= smoothstep(nd  - float(i) * 2e-3, nd - float(i) * 1e-4, pd);\n    }\n    \n    return sh;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 g = -gradient(u);\n    \n    const vec3 ld = normalize(vec3(-1, 1, 1)); // light dir\n    const vec3 vd = vec3(0, 0, 1); // view dir\n    \n    vec4 v = texelFetch(iChannel0, ivec2(u), 0); // wave height;\n    float wh = map(u);\n    float sh = computeShadow(u, wh); // shadow\n    vec3 n = normalize(vec3(g, .1)); // normal\n    O = .3 + max(vec4(0.), vec4(dot(n, ld))) * (sh * .5 + .5); // diffuse\n\n    O *= getColor(wh); // colorize\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, true); // true for last parameter => update state, emit waves\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define U(u) texelFetch(prevBuffer, ivec2(u), 0) //\nconst float FOCUS_DIST = .45;\n\n// From iq's 3d simplex noise: https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c)\n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_B 66\n\nconst float BOUND_GAMMA = .01; // damping factor for boundary\n\nvec2 initWave(vec2 u, vec2 c, vec2 R)\n{\n    vec2 delta = u - c;\n    float d2 = dot(delta, delta);\n\n    float df = sqrt(d2);\n    return 5. * R.x * vec2(sin(df), cos(df)) / (1. + d2 * 1e6);\n}\n\nvoid updateBuffer(out vec4 O, vec2 u, vec2 R, int iFrame, vec4 iMouse, sampler2D prevBuffer, sampler2D iChannel3, bool bufferA)\n{\n    vec2 o = vec2(1, 0),\n         p = (u - .5 * R) / R.y;\n\n    vec4 state = texelFetch(prevBuffer, ivec2(0), 0);\n    \n    // handle persistent state\n    if (ivec2(u) == ivec2(0))\n    {\n        if (iFrame == 0 ||\n            state.w != R.x * R.y ||\n            keyClick(KEY_SPACE))\n        {\n            O = vec4(0);\n            O.w = R.x * R.y;\n            return;\n        }\n        \n        O = state;\n        \n        if (bufferA && ++O.z > 10.)\n            O.z = 0.;\n        \n        return;\n    }\n    \n    if (iFrame == 0 ||\n        state.w != R.x * R.y ||\n        keyClick(KEY_SPACE))\n    {\n        // init\n        O = vec4(0);\n        return;\n    }\n    else\n    {\n        float C = simplex3d_fractal(vec3(p * 10., float(iFrame) * .0005)); // Courant, modulated by scrolling 3D simplex noise\n        C = .5 * pow(C * .5 + .5, 4.);\n\n        O = U(u).xxyw; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n                \n        float md = abs(O.x - O.z); // derivative mag\n        float blur = keyDown(KEY_B) ? 1. : .001;\n        O.w = mix(O.w, md, blur); // apply blur\n        \n        if (int(u.y) < 5)\n            O.x = O.x - C * (O.x - U(u + o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing bottom boundary\n        else if (int(u.y) == int(R.y) - 1)\n            O.x = O.x - C * (O.x - U(u - o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing top boundary\n        else if (int(u.x) == 0)\n            O.x = O.x - C * (O - U(u + o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing left boundary\n        else if (int(u.x) == int(R.x) - 1)\n            O.x = O.x - C * (O - U(u - o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing right boundary\n        else\n            O.x = -O.z + 2.*O.x + C*(U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx) - 4. * O).x; // apply wave equation\n    }\n\n    if (bufferA)\n    {\n        vec2 h = vec2(.5);\n        \n        // add disturbance at the center\n        if (state.z < 1. || iFrame == 0)\n            O.xy += initWave(u, h * R.xy, R);\n\n        // add disturbance for mouse click\n        if (iMouse.z > 0. && (state.z < 1. || iMouse.w > 0.))\n            O.xy += initWave(u, iMouse.xy, R);\n    }\n    \n    O *= .9990;\n}\n\n", "buffer_b_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSfWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1467, 1467, 1486, 1486, 1573], [1575, 1575, 1598, 1598, 1831], [1833, 1833, 1857, 1857, 1942], [1944, 1944, 1983, 1983, 2265], [2267, 2267, 2305, 2305, 2743]], "test": "untested"}
{"id": "md2fWW", "name": "Flower of Life Trance - SDF", "author": "13rac1", "description": "A signed distance field of two repeating overlapping circle grids, often known as the Flower of Life, slowly spin and change. Major color changes begin about 10 seconds. Shouldn't noticeably loop.", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "floweroflife"], "likes": 8, "viewed": 344, "published": 3, "date": "1689742087", "time_retrieved": "2024-07-30T17:43:56.496199", "image_code": "/*\n * Flower of Life Trance\n *\n * A signed distance field of two repeating overlapping circle grids,\n * often known as the Flower of Life, slowly spin and change.\n *\n * Designed for and with ambient music:\n * Carbon Based Lifeforms - 6EQUJ5\n * https://www.youtube.com/watch?v=a6YU4O3zq_M\n */\n\n#define SPEED 2.0\n\n#define PI 3.1415926538\n\nfloat sdRing(in vec2 p, in float r1, in float r2) {\n  return abs(length(p) - r1) - r2;\n}\n\nfloat sdFlowerOfLife( in vec2 p, in float r1, in float r2) {\n    float d = sdRing(p,r1,r2);\n\n    d = min(d, sdRing(p+vec2(0.0,-r1),r1,r2));\n    d = min(d, sdRing(p+vec2(0.0,r1),r1,r2));\n\n    vec2 pos = vec2(r1 * cos(PI/6.0), r1 * sin(PI/6.0));\n    vec2 rpos = reflect(pos, vec2(0.0,1.0));\n\n    d = min(d, sdRing(p+pos,r1,r2));\n    d = min(d, sdRing(p-pos,r1,r2));\n    d = min(d, sdRing(p+rpos,r1,r2));\n    d = min(d, sdRing(p-rpos,r1,r2));\n\n    d = min(d, sdRing(p+vec2(r1*1.73,0.0),r1,r2));\n    d = min(d, sdRing(p+vec2(-r1*1.73,0.0),r1,r2));\n    \n    vec2 pos2 = vec2(r1*1.73 * cos(PI/3.0), r1*1.73 * sin(PI/3.0));\n    vec2 rpos2 = reflect(pos2, vec2(0.0,1.0));\n    \n    d = min(d, sdRing(p+pos2,r1,r2));\n    d = min(d, sdRing(p-pos2,r1,r2));\n    d = min(d, sdRing(p+rpos2,r1,r2));\n    d = min(d, sdRing(p-rpos2,r1,r2));\n\n    d = min(d, sdRing(p+vec2(r1*1.73,r1),r1,r2));\n    d = min(d, sdRing(p+vec2(r1*1.73,-r1),r1,r2));\n    d = min(d, sdRing(p+vec2(-r1*1.73,r1),r1,r2));\n    d = min(d, sdRing(p+vec2(-r1*1.73,-r1),r1,r2));\n    \n    return d;\n}\n\nfloat sdFlowerOfLifeRepeating(in vec2 p, in float r1, in float r2) {    \n    p += vec2(r1*0.865,r1);    \n    p = mod(p,vec2(2.0*r1*0.865,2.0*r1))-vec2(r1*0.865,r1);\n    return sdFlowerOfLife(p,r1,r2);\n}\n\n// src: https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(2.0*PI*(c*t+d) );\n}\n\nvec3 pEarth(in float t) {   \n    return palette(t,\n        vec3(0.5, 0.5, 0.5),\n        vec3(0.5, 0.5, 0.5),\n        vec3(1.0, 1.0, 0.5),\n        vec3(0.80, 0.90, 0.30)\n    );\n}\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\n// src: https://www.shadertoy.com/view/7tf3Ws\nfloat easeInOutCubic(float x) {\n    return x < .5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat triangleWave(float x) {\n  return abs(( mod(x, 2.0)) - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime*SPEED;\n    \n    // Find the diviser to handle vertical and horizontal screens.\n    float resolutionDiviser = min(iResolution.y,iResolution.x);\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/resolutionDiviser;\n\n    // Zooming\n    uv *= easeInOutCubic(1.0-abs(cos(time/25.0)))*1.5+1.0;\n    //uv *= 2.0;\n    // Spinning\n    uv = rotate(uv, easeInOutCubic(cos(time/29.0))/2.0);\n    // Repeating flowers\n    float d = sdFlowerOfLifeRepeating(uv, 0.5, 0.00005);\n    // Repeating more flowers\n    uv = rotate(uv, -easeInOutCubic(sin(time/37.0))/2.0);\n    d = min(d-0.005, sdFlowerOfLifeRepeating(uv, 0.3+0.4*easeInOutCubic(triangleWave(time/41.0)), 0.00005));\n    // Coloring\n    vec3 col = pEarth(cos(d*10.0-time/23.0));\n    // Moving\n\tcol *= 0.7 + 0.5*cos(300.0*d + time*4.0);\n    vec3 lineCol = pEarth(cos(d*30.0-time/18.0)) * vec3(1.2);\n\tcol = mix( col, lineCol, 1.0 - smoothstep(0.0, easeInOutCubic(triangleWave(time/8.0))/58.0+0.005, d));\n    \n    // Just black and white\n    //vec3 col = vec3(smoothstep(0.0, 0.01, d));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2fWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 337, 388, 388, 425], [427, 427, 487, 487, 1475], [1477, 1477, 1545, 1545, 1679], [1681, 1731, 1803, 1803, 1844], [1846, 1846, 1871, 1871, 2023], [2025, 2025, 2057, 2057, 2116], [2118, 2164, 2195, 2195, 2267], [2269, 2269, 2298, 2298, 2336], [2338, 2338, 2393, 2393, 3474]], "test": "untested"}
{"id": "cdSBD1", "name": "Rain Frog", "author": "tristanantonsen", "description": "Saw these hilarious little frogs and wanted to practice SDF modeling one. This shader is a combination of ray marching, SDF modeling, and a smattering of techniques (mostly from or inspired by iq). Tried to comment it well and stay organized!", "tags": ["raymarching", "cute", "cute", "sdf", "character", "animal", "creature", "frog"], "likes": 66, "viewed": 768, "published": 3, "date": "1689731545", "time_retrieved": "2024-07-30T17:43:57.640141", "image_code": "// Ray marching constants\n#define MAX_STEPS 300\n#define SURF_DIST 0.001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\n////////////////////////////////////////////////////////////////\n// Noise\n////////////////////////////////////////////////////////////////\n\n// Hash & voronoi from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\n// From or adapted from iq: https://iquilezles.org/articles/distfunctions/\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n// Also from or adapted from iq: https://iquilezles.org/articles/distfunctions/\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -(m.x+1.)*TAU + PI * 0.95);\n    return p;\n}\n\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 po) {\n\n    float f = 0.06; // ribbet frequency\n    vec3 p = orbitControls(vec3(po.x, po.y, po.z)); // track mouse\n    vec3 pSym = vec3(abs(p.x),p.y,p.z);\n    \n    vec2 res = vec2(1.0);\n    \n    // ribbet timing\n    float w = 1.5;\n    float rt = sin(w * iTime);\n    rt = max(rt, sin(w * iTime + PI/3.));\n    rt = rt * 0.5 + 1.;\n    \n    // Body\n    float body = sdEllipsoid(p, vec3(0.), vec3(0.7, 0.5, 0.7) * 1. + (0.025 * rt));\n    body = opSmoothUnion(body,sdEllipsoid(p, vec3(0.,-0.1,0.025), vec3(0.8, 0.5, 0.75)), 0.1);\n    \n    // Head\n    vec3 pr = rotX(p+vec3(0., -0.25, 0.4), -PI/3.);\n    float head = sdEllipsoid(pr, vec3(0.), vec3(0.38, 0.325, 0.4));\n    res.x = opSmoothUnion(body, head, 0.3);\n    res.x += 0.0 * sin(50.*head) * smoothstep(1.,0.,5.*head);\n\n    // eyelid\n    float lid = sdEllipsoid(pSym, vec3(0.24,0.444 + (0.01 * rt), -0.525), vec3(0.16, 0.14, 0.16));\n    res.x = opSmoothUnion(res.x, lid, 0.04);\n    \n    // eye\n    float eye = sdSphere(pSym, vec3(0.27,0.43 + (0.012 * rt),-0.58),0.115);\n    res.x -= 0.02 * sin(60.*eye) * smoothstep(1.,0.,20.*eye);\n    if (eye-0.005 < res.x) {res.y = 2.0;};\n    res.x = opSmoothUnion(res.x, eye, 0.006);\n\n    //nose\n    float nose = sdSphere(p, vec3(0.,0.45,-0.67),0.01);\n    res.x = opSmoothUnion(res.x, nose, 0.25);\n\n\n    // mouth/face\n    pr = rotX(p+vec3(0., -0.12, 0.655), -0.35);\n    float face = sdEllipsoid(pr, vec3(0.), vec3(0.27, 0.3, 0.1));\n    float faceBool = sdEllipsoid(pr+vec3(0.,0. + (0.032 * rt),0.02), vec3(0.), vec3(0.26, 0.4, 0.04));\n    res.x = opSmoothSubtraction(res.x, faceBool, 0.02);\n    res.x = opSmoothUnion(res.x, face, 0.01);\n\n    // Ribbet\n    float rb = sdSphere(p, vec3(0.,0.0,-0.6),0.16);\n    res.x = opSmoothUnion(res.x,rb,0.2 * rt);\n    \n    // Arms\n    vec3 elbow = vec3(0.62,-0.3,-0.4);\n    vec3 shoulder = vec3(0.5,-0.1,-0.4);\n    vec3 wrist = vec3(0.57,-0.45,-0.45);\n    float upperArm = sdCapsule(pSym, shoulder,elbow, 0.08);\n    res.x = opSmoothUnion(res.x, upperArm, 0.1);\n    res.x += 0.01 * sin(40.*upperArm) * smoothstep(1.,0.,5.*upperArm);\n    float foreArm = sdCapsule(pSym, elbow+vec3(0.,-0.05,0.), wrist, 0.08);\n    res.x = opSmoothUnion(res.x, foreArm, 0.05);\n\n    // Fingers\n    float f1 = sdCapsule(pSym, wrist-vec3(0.,0.03,0.03), wrist-vec3(0.15,0.02,0.005), 0.04);\n    float f2 = sdCapsule(pSym, wrist-vec3(0.,0.03,0.03), wrist-vec3(0.2,0.04,0.06), 0.04);\n    float f3 = sdCapsule(pSym, wrist-vec3(0.,0.03,0.03), wrist-vec3(0.15,0.05,0.12), 0.04);\n\n    res.x = opSmoothUnion(res.x, f1, 0.04);\n    res.x = opSmoothUnion(res.x, f2, 0.04);\n    res.x = opSmoothUnion(res.x, f3, 0.04);\n    \n    // Legs\n    vec3 knee = vec3(0.55,-0.45,0.425);\n    float upperLeg = sdCapsule(pSym, vec3(0.4,-0.2,.475),knee, 0.07);\n    res.x = opSmoothUnion(res.x, upperLeg, 0.1);\n    res.x += 0.01 * sin(40.*upperLeg) * smoothstep(1.,0.,5.*upperLeg);\n\n    // Butt\n    float c = sdSphere(pSym, vec3(0.15,-0.15,.65),0.115);\n    res.x = opSmoothUnion(res.x, c, 0.15);\n\n    // Toes\n    float t1 = sdCapsule(pSym, knee-vec3(0.,0.03,0.), knee-vec3(-0.18, 0.05,0.12), 0.04);\n    float t2 = sdCapsule(pSym, knee-vec3(0.,0.03,0.), knee-vec3(-0.13, 0.05,0.18), 0.04);\n    float t3 = sdCapsule(pSym, knee-vec3(0.,0.03,0.), knee-vec3(-0.06, 0.05,0.18), 0.04);\n    \n    res.x = opSmoothUnion(res.x, t1, 0.04);\n    res.x = opSmoothUnion(res.x, t2, 0.04);\n    res.x = opSmoothUnion(res.x, t3, 0.04);\n\n    // Ground\n    float gnd = sdRoundedCylinder(po+vec3(0.,0.78,0.) , 0.8, 0.1, 0.15);\n    if (gnd-0.005 < res.x) {res.y = 3.0;};\n    res.x = opUnion(res.x, gnd);    \n        \n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec2(d, mat);\n}\n\n// from iq: https://iquilezles.org/articles/rmshadows/\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // camera orientation from https://raytracing.github.io/books/RayTracingInOneWeekend.html\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(-0.4 + 0.01 * sin(0.5*iTime), -0.2, 2.);\n    vec3 ro = vec3(-0.4 + 0.1 * cos(0.5*iTime), 0.5, -5.);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec2 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    vec3 col = mix(vec3(0.8, 0.8, 0.55), vec3(0.45, 0.55, 0.35), smoothstep(0.0, 1.0, uv.y));\n    fragColor = vec4(col, 1.);\n\tfragColor += mix(vec4(0.1), vec4(0.0, 0.15, 0.0, 1.0), v); // vignette\n    fragColor *= mix(vec4(0.5,0.6,0.6,1.), vec4(1.), smoothstep(-1.,1.,uv.x)); // darken left\n    \n    float vb = voronoi( 2. * vec3(2.,1.,1.) * vec3(uv, 1.)).x;\n    fragColor.xyz *= mix(0.7,1.,smoothstep(0.,1.,vb));\n\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n\n        // Simple surface texture\n        if (d.y == 1.) N += voronoi( 50.*pr).x * 0.13;\n        \n        // Lighting (partial phong shading)\n        vec3 lightPos1 = vec3(1, 1,-1);\n        float light1 = dot(N, normalize(lightPos1))*.5+.5;\n        light1 *= 1.5;\n        vec3 L1 = vec3(1, 1,-1);\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 lightVal = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n        \n        // Specular highlights\n        vec3 R = reflect(L1, N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        vec3 color;\n\n        // Color assignment\n        // Color assignment method adapted from iq: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=8470s\n        // A breakdown in my other shader: https://www.shadertoy.com/view/cdlBDl\n        if (d.y == 1.) color = vec3(0.3, 0.5, 0.2) + specular * 0.0006; // body\n        if (d.y == 2.) color = vec3(0.05) + specular * 0.004; // eyes\n        if (d.y == 3.) color = vec3(0.15, 0.25, 0.1);\n        \n        // Skin colors\n        float c = 1. - voronoi( 10.*pr).x;\n        // blended based on distance from a point above the frog\n        float tFac = mix(0., 1., smoothstep(0.,1., length(p-vec3(0.,0.7,0.5))-0.5));\n        color = mix(color, vec3(0.16, 0.16, 0.1), c * (1.-tFac));\n        \n        // shadows\n        float res = softShadow(p+N*0.01, normalize(lightPos1-p), 0.01, 5., 2.);\n        \n        if (p.y <= -0.525) {\n            float res2 = softShadow(p+N*0.01, vec3(0.,1.,0.), 0.01, 5., 2.);\n            color *= 1.0 - mix(0.4,0.,smoothstep(0.,1., res2));;\n        }\n        \n        color *= 1.0 - mix(0.3,0.,smoothstep(0.,1., res));\n        \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.35 * res;\n        \n        \n        fragColor = vec4(lightVal*color, 1.0);\n    }\n   \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 355, 376, 376, 534], [535, 535, 562, 562, 1142], [1379, 1379, 1421, 1421, 1457], [1459, 1459, 1502, 1502, 1532], [1534, 1534, 1580, 1580, 1689], [1691, 1691, 1743, 1743, 1864], [1866, 1866, 1911, 1911, 2002], [2004, 2004, 2068, 2068, 2185], [2416, 2416, 2452, 2452, 2473], [2475, 2475, 2516, 2576, 2603], [2604, 2604, 2646, 2646, 2672], [2674, 2674, 2724, 2724, 2823], [2824, 2824, 2880, 2880, 2980], [2981, 2981, 3037, 3037, 3136], [3282, 3282, 3310, 3310, 3460], [3462, 3462, 3490, 3490, 3640], [3642, 3642, 3671, 3671, 3813], [3973, 3973, 3992, 3992, 7563], [7565, 7565, 7598, 7598, 7911], [7913, 7968, 8045, 8045, 8288], [8291, 8291, 8314, 8314, 8648], [8650, 8650, 8695, 8722, 9421], [9424, 9424, 9481, 9481, 12214]], "test": "untested"}
{"id": "cd2BDW", "name": "Test Arno", "author": "frosty_arno", "description": "test", "tags": ["test"], "likes": 3, "viewed": 192, "published": 3, "date": "1689728461", "time_retrieved": "2024-07-30T17:43:58.578631", "image_code": "float circle_distance(vec2 point, float radius){\n    return length(point) - radius;\n}\n\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ){\n\n    vec2 uv = (frag_coord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 final_color = vec3(0.0);\n    \n    vec2 fract_uv = uv * 2.;\n    \n    for (int i = 0; i < 11; i++){\n        fract_uv = fract(fract_uv);\n        fract_uv -= 0.5;\n\n        float circle = circle_distance(fract_uv, 0.5) * exp(-length(uv));\n        circle = sin(circle * 8. - iTime) / 8.;\n        circle = abs(circle);\n        circle = smoothstep(0., 0.05, circle);\n        circle = 0.01 / circle;\n        final_color += circle;\n    }\n    \n    frag_color = vec4(final_color, 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2BDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 85], [88, 88, 146, 146, 702]], "test": "untested"}
{"id": "msSBDD", "name": "implicit curves sketch", "author": "elenzil", "description": "just fooling around", "tags": ["implicit"], "likes": 19, "viewed": 314, "published": 3, "date": "1689719104", "time_retrieved": "2024-07-30T17:43:59.482215", "image_code": "\nfloat circle(in vec2 p) {\n    p *= 1.2;\n    // distance^2 is fine, doesn't need to be actual distance.\n    float left = dot(p, p);\n    float right = 1.0;\n    return right - left;\n}\n\nfloat sine(in vec2 p) {\n    p *= 5.0;\n    float left  = sin(p.x + iTime * 1.5);\n    float right = p.y;\n    return right - left;\n}\n\nfloat lemniscate(in vec2 p) {\n\n    float left = p.x * p.x + p.y * p.y;\n    left = left * left;\n    float right = p.x * p.x - p.y * p.y;\n    return right - left;\n}\n\nfloat folium(in vec2 p) {\n    p *= 4.0;\n    float left = p.x * p.x * p.x + p.y * p.y * p.y;\n    float right = 6.0 * p.x * p.y;\n    return right - left;\n}\n\nfloat witchOfAgnesi(in vec2 p) {\n    p *= 8.0;\n    float left = (p.x * p.x + 2.0) * p.y;\n    float right = 10.0;\n    return right - left;\n}\n\nfloat blah(in vec2 p) {\n    p *= 20.0;\n    float left = p.x * cos(p.y) + p.y * cos(p.x);\n    float right = 0.0;\n    return right - left;\n}\n\n\n// gPlatl\nfloat parabel(in vec2 p) \n{ return p.x*p.x-p.y-0.8; }\n\n\n// gPlatl\nfloat Heart(in vec2 p) \n{ float x = p.x;\n  float y = p.y;\n  float a = x*x+y*y-0.5;\n  return a*a*a-x*x*y*y*y;\n}\n\n// gPlatl\nfloat MickeyMouse(in vec2 p) \n{ float x = p.x;\n  float y = p.y;\n  float a = x*x+y*y-0.5;\n  return a*a*a-x*x*y*y*y+0.01;\n}\n\n\n// Envy24\nfloat devil_curve(in vec2 p)\n{\n    p *= 2.;\n    float x = p.x, y = p.y, t0 = (1.+sin(iTime))*0.5;\n    return y * y * (y * y - 1.0) - x * x * (x * x - 1.65 + t0);\n}\n\n// Envy24\nfloat some_random_func(in vec2 p)\n{\n    p *= 4.;\n    float x = p.x, y = p.y;\n    return (x*x - x*y*x) -(y*y - x*y*x)/(y*y + y*x*x) + sin(iTime)*1.0;\n}\n\n// Envy24\nfloat gamma_correction_heart(in vec2 p)\n{\n    p *= 2.;\n    float x = p.x, y = p.y;\n    //               gamma correction of x*x)\n    float term = y - pow(x * x, 1.0 / 2.2);\n    return x * x + term * term - 1.0;\n}\n\n// Envy24\nfloat unknown(in vec2 p) {\n       p = (p - vec2(0.59)) * 8.0;\n    float sx = sin(2.*p.x), sy = sin(p.y);    \n    return sx*sx*sx + 4.*sy*sy*sy - 3.*sx*sy;\n}\n\nconst int numCurves = 12;\nfloat curve(in vec2 p, int index) {\n    switch (index) {\n        case 0:\n            return circle(p);\n        case 1:\n            return lemniscate(p);\n        case 2:\n            return folium(p);\n        case 3:\n            return witchOfAgnesi(p);\n        case 4:\n            return sine(p);\n        case 5:\n            return blah(p);\n        case 6:\n            return parabel(p);\n        case 7:\n            return Heart(p);\n        case 8:\n            return gamma_correction_heart(p);\n        case 9:\n            return MickeyMouse(p);\n        case 10:\n            return devil_curve(p);\n        case 11:\n            return some_random_func(p);\n            \n        default:\n            return 0.0;\n    }\n}\n\nfloat curve(in vec2 p) {\n\n    float t = iTime * 0.2;\n\n    int i0 = int(floor(t)) % numCurves;\n    int i1 = (i0 + 1)      % numCurves;\n    \n    float c0 = curve(p, i0);    \n    float c1 = curve(p, i1);\n    \n    float c = mix(c1, c0, smoothstep(-0.4, 0.4, cos(fract(t) * 3.1415)));\n    \n    return c;\n}\n\n// thanks Envy24!\nfloat fwidth_L2(in float d) {\n    return length(vec2(dFdx(d), dFdy(d)));\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 xy = (XY - iResolution.xy / 2.0)/min(iResolution.x, iResolution.y) * 2.0;\n\n    float d;\n    \n    // grey background\n    float c = 0.5;\n    \n    // axes\n    ivec2 dxy = ivec2(XY) - ivec2(iResolution.xy / 2.0);\n    if (/*dxy.x * */ dxy.y == 0) {\n        c *= 1.0  + -0.8* smoothstep(0.5, 0.6, cos(length(xy * 100.0)));\n    }\n    \n    // shadow\n    d = curve(xy - 0.015 * vec2(1.0, -1.0));\n    c *= mix(1.0, 0.8, smoothstep(8.0, 0.0, abs(d) / fwidth_L2(d) - 4.0));\n    \n    // main curve\n    d = curve(xy - 0.00 * vec2(1.0, -1.0));\n    c = mix(c, 1.0, smoothstep(2.0, 0.0, abs(d) / fwidth_L2(d) - 1.0));\n            \n    RGBA.rgb = vec3(c);\n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 181], [183, 183, 206, 206, 312], [314, 314, 343, 343, 476], [478, 478, 503, 503, 631], [633, 633, 665, 665, 772], [774, 774, 797, 797, 912], [915, 925, 952, 952, 978], [981, 991, 1016, 1016, 1101], [1103, 1113, 1144, 1144, 1234], [1237, 1247, 1277, 1277, 1410], [1412, 1422, 1457, 1457, 1572], [1574, 1584, 1625, 1625, 1796], [1798, 1808, 1834, 1834, 1964], [1992, 1992, 2027, 2027, 2707], [2709, 2709, 2733, 2733, 3009], [3011, 3029, 3058, 3058, 3103], [3105, 3105, 3150, 3150, 3819]], "test": "untested"}
{"id": "ds2fD1", "name": "Automata X Showcase 3x2 (3x3)", "author": "misol101", "description": "Fullscreen recommended.\n\nCONTROLS:  Enter=switch to 3x3, 7-9=speed, m=see automata, a=antialiasing, space=regenerate\n\nZOOM: Mouse x zooms, arrow keys pan.", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 23, "viewed": 347, "published": 3, "date": "1689709916", "time_retrieved": "2024-07-30T17:44:00.555346", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int mono = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    int aa = 1-int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    vec2 ppos = texelFetch(iChannel1, ivec2(10,0), 0 ).xy;\n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul) + ppos;\n\n    vec4 val = vec4(0.);\n    int am=0, ap=aa, j=0;\n    for (int j = -am; j <= ap; j++)\n        for (int i = -am; i <= ap; i++)\n            val += texelFetch( iChannel0, ivec2(int(fragCoord.x)+i,int(fragCoord.y)+j), 0 );\n    float n=float((am+ap+1));\n    if (am+ap > 0) val /= n*n-2.;\n    \n    if (aa == 0) val/=0.6;\n    \n    if (mono == 0) {\n        fragColor = val;\n    } else {\n        float v=(1./liveval)*val.w;\n        fragColor = vec4( v*0.9, v*0.95, v, 1.0 );\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nfloat restart(vec2 fragCoord, int method, bool preserve) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=452., rradius=25.;\n    if (iResolution.y < 1000.) radius=182.;\n    float xrad=569.,yrad=453.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n    }\n    if (method == 3) {\n        if (length(vec2((fragCoord.x-mid.x)*0.793,(fragCoord.y-mid.y)*1.0))< radius)\n            return liveval;\n    }\n    if (method == 4) {\n        float xmul=1.; if (iResolution.y < 1000.) xmul=1.75;\n        if (fragCoord.x > mid.x - rradius*xmul && fragCoord.x < mid.x + rradius*xmul+1. && fragCoord.y > mid.y - rradius && fragCoord.y < mid.y + rradius +1.)\n            return liveval;\n    }\n    return preserve? -1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int rows = 2+ int(texelFetch(iChannel2, ivec2(4,0), 0 ).x);\n    \n    float xsq = 3., ysq = float(rows);\n    float wsq = iResolution.x / xsq;\n    float hsq = iResolution.y / ysq;\n    float thick = 3.;\n\n    int cix = (int(fragCoord.x / wsq) + int(fragCoord.y / hsq)*int(xsq) + int(ix*10.)) % 9;\n    setRules(cix, vec3(0.));\n    if (cix==3 && iResolution.y < 400.) { rp*=1.8; gp*=1.8; bp*=1.8; } \n\n    float dt=density; if (density2 >= 0.) density=density2; if (cix==0 && iResolution.y > 400.) density=0.;\n    float i, bsh=1.;\n    for (i=0.; i<=xsq; i++) {\n        if (fragCoord.x > wsq*i-thick && fragCoord.x < wsq*i+thick ) {\n            fragColor = vec4(bsh,bsh,bsh,randpix(fragCoord));\n            return;\n        }\n    }\n    for (i=0.; i<=ysq; i++) {\n        if (fragCoord.y > hsq*i-thick && fragCoord.y < hsq*i+thick ) {\n            fragColor = vec4(bsh,bsh,bsh,randpix(fragCoord));\n            return;\n        }\n    }\n    density=dt;\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_ENTER) || readKey(KEY_Z) || readKey(KEY_X) || int(xres) != int(iResolution.x) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, setmethod, false));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, method, false));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 4 || nh==5 || nh == 6) {\n        // .XXX. 4\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // .XXX.\n        k =   cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1))\n            + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1));\n        // XXXXX 6\n        // X...X\n        // X.*.X\n        // X...X\n        // XXXXX\n        if (nh > 4) k += cell(px+ivec2(2, 2)) + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, 2)) + cell(px+ivec2(2, -2));\n        // XXXXX 5\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        if (nh < 6)\n            k += cell(px+ivec2(0,-1))\n            + cell(px+ivec2(-1, 0)) + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(0, 1))  + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate;\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x += cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y += cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z += cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\t\n\n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x -= cstep*rm;\n                curr.y -= cstep*gm;\n                curr.z -= cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x -= cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n    }\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAST_PATT = 3.;\nconst float cstep=1./256.;\n\nfloat density=50., density2=-1.;\nfloat liveval = 2.0;\nint newmethod = 0;\nfloat decimate = 0.;\nfloat rp,gp,bp, rm,gm,bm, stayval;\nint colch, staypatt;\nint ra,ga,ba;\nbool clampstay;\nint setmethod;\nint stayset, bornset;\nint nh;\nint wrap;\n\nvoid setRules(int index, vec3 col) {\n    int v1, v2;\n    decimate = 1.;liveval=2.;\n\n    rp=4.,gp=3.,bp=10., rm=2.,gm=2.,bm=8., ra=7,ga=7,ba=7,staypatt=1,stayval=1.,colch=0, clampstay=false, setmethod=0; nh=10, wrap=0, density2=-1.;\n\n    // sponge\n    if (index == 0) {nh=5; v1 = 1175456, v2=1910512; density=11., liveval=6., decimate=1., colch=1, staypatt=0, rp=0.24, gp=0.36, bp=0.15, rm=26., gm=41.,bm=81.,  ra=1,ga=2,ba=4; density2=15.; }\n\n    // baby explosions\n    if (index == 1) {nh=5; v1 = 1175524, v2=1910512; density=20., liveval=6., decimate=1., colch=1, staypatt=0, rp=3., gp=1.5, bp=1.5, rm=6., gm=8.,bm=13.,  ra=1,ga=2,ba=4; }\n\n    // worms\n    if (index == 2) {nh=10; v1 = 4094, v2=3966; density=90., liveval=5., decimate=0., colch=2, staypatt=0, rp=10., gp=4., bp=4., rm=16., gm=16.,bm=18.,  ra=6,ga=7,ba=6; density2=6.;}\n\n    // generative\n    if (index == 3) {nh=0; v1 = 23, v2=86; density=6., liveval=5., decimate=0., colch=2, staypatt=0, rp=10.*1.3, gp=7.*1.3, bp=20.*1.3, rm=2., gm=2.,bm=2.,  ra=1,ga=2,ba=4; }\n\n    // pump\n    if (index == 4) {nh=5; v1 = 1175552, v2=1910552; density=100., liveval=7., decimate=1., colch=3, staypatt=0, rp=11.5, gp=6.5, bp=6.5, rm=6., gm=7.5,bm=13.,  ra=1,ga=3,ba=7; density2=10.; }\n\n    // straight lines\n    if (index == 5) {nh=6; v1 = 50182, v2=16516; density=20., liveval=6., decimate=0., colch=1, staypatt=5, rp=4., gp=4., bp=8., rm=6., gm=16.,bm=18.,  ra=6,ga=7,ba=6; }\n\n    // small worms\n    if (index == 6) {nh=10, v1 = 64860, v2=4094; density=80.; liveval=2.; decimate=0.; colch=2, staypatt=6; rp=9.; rm=16.,gm=16.,bm=18.; ra=6,ga=7,ba=6; density2=10.; } \n\n    // straight lines II\n    if (index == 7) {nh=-1, v1 = 200, v2=14; density=-1.3; liveval=3.; decimate=1.; staypatt=6; rp=5.; rm=8.5,gm=8.5,bm=6.; ra=1,ga=2,ba=4; density2=10.; } \n\n    // square critters\n    if (index == 8) {nh=4, v1 = 1175537, v2=1910520; density=70.; liveval=6.; decimate=1.;  colch=1, staypatt=1, rp=10., gp=2.5, bp=1., rm=39., gm=39.,bm=39.,  ra=1,ga=2,ba=4; density2=10.; } \n\n\n    rp=rp+col.x; gp=gp+col.y; bp=bp+col.z;\n    stayset = v1; bornset = v2;\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_ENTER = 13;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_A     = 65;\nconst int KEY_M     = 77;\nconst int KEY_W     = 87;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\nconst int KEY_C     = 67;\nconst int KEY_V     = 86;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) {\n        fragColor = vec4(0.,0.,0.,1.0);\n        return;\n    }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_Z)||readKey(KEY_X)||readKey(KEY_C)||readKey(KEY_V) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_X) || readKey(KEY_V)) {\n                    kx+=0.1;\n                    if (kx > LAST_PATT*0.1+0.05) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=LAST_PATT*0.1+0.05;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_ENTER, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_A, 1., 2.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        vec2 ppos = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xy;\n        float mmul = iMouse.x / iResolution.x;\n        vec2 mid = iResolution.xy / 2.;\n\n        float psp=8.;\n        if( readKey(KEY_RIGHT)) ppos.x += psp;\n        if( readKey(KEY_LEFT)) ppos.x -= psp;\n        if( readKey(KEY_DOWN)) ppos.y -= psp;\n        if( readKey(KEY_UP)) ppos.y += psp;\n        ppos.x = clamp(ppos.x, -mid.x*mmul, mid.x*mmul);\n        ppos.y = clamp(ppos.y, -mid.y*mmul, mid.y*mmul);\n\n        fragColor = vec4(ppos,0.,1.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2fD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 927]], "test": "untested"}
{"id": "cdBfDD", "name": "complex-noise-10", "author": "LydianLights", "description": "dont know why I didn't think of it before, but modulating the t component with noise instead of the uv component gives less directionally biased results", "tags": ["perlinnoise", "fractalbrownianmotion"], "likes": 8, "viewed": 231, "published": 3, "date": "1689701082", "time_retrieved": "2024-07-30T17:44:01.436989", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float SCALE = 3.0;\nconst float AMPLITUDE = 0.3;\nconst int OCTAVES = 4;\nconst float LACUNARITY = 1.2;\nconst float GAIN = 0.9;\n\nfloat fbm(in vec3 q) {\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        float n = cnoise(q);\n        value += amplitude * n;\n        q.xy *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 uv) {\n    float t = 10.0 * fbm(vec3(uv, 5.0 * fbm(vec3(uv, 0.5 * iTime))));\n    vec3 q = vec3(uv.xy, t);\n    return fbm(q);\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (gl_FragCoord.xy / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 p = SCALE * uv + OFFSET;\n    float n = getNoise(p);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "//  https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 436], [438, 438, 466, 466, 586], [588, 588, 615, 615, 667], [669, 669, 724, 724, 984]], "test": "untested"}
{"id": "DsSfDW", "name": "Reactive Colour Change tweaked", "author": "ferociousmullet", "description": "Played with the alpha, still no idea what I am doing... ", "tags": ["audio", "colour"], "likes": 1, "viewed": 199, "published": 3, "date": "1689695078", "time_retrieved": "2024-07-30T17:44:02.195959", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   float time = iTime;\n   // Set the red line color\n    vec4 lineColor = vec4(1, (iResolution.x * sin(time)), (iResolution.y * sin(-time)), 1);\n\n    // Define the thickness of the line\n    float lineWidth = 1.0;\n\n    // Define the trails fade factor\n    float trailsFade = 222.1;\n\n    // Calculate the position of the line based on time\n    \n    float lineX = 0.1 * iResolution.x + 0.1 * iResolution.x * sin(time);\n\n    // Read the previous frame color from the screen\n    vec4 previousColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Get audio data from iChannel0\n    vec2 audioData = texture(iChannel0, vec2(fragCoord.x / iResolution.x, 0.01)).rg;\n\n    // Calculate the height scale based on the audio data (map audioData.y to [0, 1])\n    float heightScale = audioData.y / 0.2 ;\n\n    // Modulate the line color by the audio data\n    lineColor *= vec4(audioData, 0.8, 0.994);\n\n    // Check if the current fragment is part of the line\n    if (abs(fragCoord.x - lineX) < lineWidth * 0.5)\n    {\n        // Adjust the line's height based on the audio data\n        float lineHeight = lineWidth - 0.1 - heightScale;\n        if (abs(fragCoord.y * iResolution.y / 0.1) < lineHeight)\n        {\n            // Draw the line with the modulated line color\n            fragColor = lineColor;\n            return;\n        }\n    }\n\n    // Apply trails effect to the background color\n    vec4 backgroundTrails = previousColor * trailsFade;\n\n    // Blend the line color with the background trails\n    fragColor = mix(backgroundTrails, lineColor, lineColor.a);\n}\n", "image_inputs": [{"id": 34005, "src": "https://soundcloud.com/ferociousmullet/smooth-machine", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1615]], "test": "untested"}
{"id": "DdBBDW", "name": "Fork Animated R ferociousm 111", "author": "ferociousmullet", "description": "First Experiments, GPT helped", "tags": ["audio"], "likes": 1, "viewed": 144, "published": 3, "date": "1689694306", "time_retrieved": "2024-07-30T17:44:03.079597", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set the red line color\n    vec4 lineColor = vec4(1.0, 0.2, 0.3, 1.0);\n\n    // Define the thickness of the line\n    float lineWidth = 1.0;\n\n    // Define the trails fade factor\n    float trailsFade = 0.1;\n\n    // Calculate the position of the line based on time\n    float time = iTime;\n    float lineX = 0.5 * iResolution.x + 0.5 * iResolution.x * sin(time);\n\n    // Read the previous frame color from the screen\n    vec4 previousColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Get audio data from iChannel0\n    vec2 audioData = texture(iChannel0, vec2(fragCoord.x / iResolution.x, 0.01)).rg;\n\n    // Modulate the line color by the audio data\n    lineColor *= vec4(audioData, 1.0, 1.0);\n\n    // Check if the current fragment is part of the line\n    if (abs(fragCoord.x - lineX) < lineWidth * 0.5)\n    {\n        // Draw the line with the modulated line color\n        fragColor = lineColor;\n    }\n    else\n    {\n        // Apply trails effect to the background color\n        vec4 backgroundTrails = previousColor * trailsFade;\n\n        // Blend the line color with the background trails\n        fragColor = mix(backgroundTrails, lineColor, lineColor.a);\n    }\n}\n", "image_inputs": [{"id": 34004, "src": "https://soundcloud.com/ferociousmullet/smooth-machine", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 85, 1237]], "test": "untested"}
{"id": "cdSBDW", "name": "Animated Red Reactive", "author": "ferociousmullet", "description": "First Experiments, GPT helped", "tags": ["audio"], "likes": 1, "viewed": 137, "published": 3, "date": "1689693745", "time_retrieved": "2024-07-30T17:44:04.264429", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set the red line color\n    vec4 lineColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n    // Define the thickness of the line\n    float lineWidth = 5.0;\n\n    // Define the trails fade factor\n    float trailsFade = 0.97;\n\n    // Calculate the position of the line based on time\n    float time = iTime;\n    float lineX = 0.5 * iResolution.x + 0.5 * iResolution.x * sin(time);\n\n    // Read the previous frame color from the screen\n    vec4 previousColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Get audio data from iChannel0\n    vec2 audioData = texture(iChannel0, vec2(fragCoord.y / iResolution.y, 2)).rg;\n\n    // Modulate the line color by the audio data\n    lineColor *= vec4((audioData), 0.4, 1.0);\n\n    // Check if the current fragment is part of the line\n    if (abs(fragCoord.x - lineX) < lineWidth * 0.5)\n    {\n        // Draw the line with the modulated line color\n        fragColor = lineColor;\n    }\n    else\n    {\n        // Apply trails effect to the background color\n        vec4 backgroundTrails = previousColor * trailsFade;\n\n        // Blend the line color with the background trails\n        fragColor = mix(backgroundTrails, lineColor, lineColor.a);\n    }\n}\n", "image_inputs": [{"id": 34004, "src": "https://soundcloud.com/ferociousmullet/smooth-machine", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 85, 1237]], "test": "untested"}
{"id": "DsSfWW", "name": "Red Line Reactive Audio", "author": "ferociousmullet", "description": "Not sure if this is actually reacting or not. Actually, I think it might be. ", "tags": ["audio"], "likes": 0, "viewed": 141, "published": 3, "date": "1689693074", "time_retrieved": "2024-07-30T17:44:05.425325", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set the background color to black\n    vec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    // Set the red line color\n    vec4 lineColor = vec4(1.0, 0.0, 0.0, 1.0);\n    \n    // Define the thickness of the line\n    float lineWidth = 5.0;\n    \n    // Calculate the position of the line based on time\n    float time = iTime;\n    float lineX = 0.5 * iResolution.x + 0.5 * iResolution.x * sin(time);\n    \n    // Get audio data from iChannel0\n    vec2 audioData = texture(iChannel0, fragCoord / iResolution.xy).rg;\n    \n    // Modulate the line color by the audio data\n    lineColor *= vec4(audioData, 1.0, 1.0);\n    \n    // Check if the current fragment is part of the line\n    if (abs(fragCoord.x - lineX) < lineWidth * 0.5)\n    {\n        fragColor = lineColor;\n    }\n    else\n    {\n        fragColor = backgroundColor;\n    }\n}\n", "image_inputs": [{"id": 34003, "src": "https://soundcloud.com/ferociousmullet/smooth-machine", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 96, 890]], "test": "untested"}
{"id": "dsjBD1", "name": "Sweeping Colour Change", "author": "ferociousmullet", "description": "GPT Helped. Morphs the colour", "tags": ["line", "color"], "likes": 1, "viewed": 89, "published": 3, "date": "1689691076", "time_retrieved": "2024-07-30T17:44:06.222194", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set the background color to black\n    vec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);\n     float time = iTime;\n    // Set the red line color\n    vec4 lineColor = vec4(1.0, sin(time), sin(time *= 1.3), sin(time *= 1.2));\n    \n    // Define the thickness of the line\n    float lineWidth = 5.0;\n    \n    // Calculate the position of the line based on time\n   \n    float lineX = 0.5 * iResolution.x + 0.5 * iResolution.x * sin(time);\n    \n    // Check if the current fragment is part of the line\n    if (abs(fragCoord.x - lineX) < lineWidth * 0.5)\n    {\n        fragColor = lineColor;\n    }\n    else\n    {\n        fragColor = backgroundColor;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 96, 710]], "test": "untested"}
{"id": "cd2BD1", "name": "complex-noise-9", "author": "LydianLights", "description": "it's melting", "tags": ["perlinnoise", "fractalbrownianmotion"], "likes": 13, "viewed": 290, "published": 3, "date": "1689675704", "time_retrieved": "2024-07-30T17:44:07.021058", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float SCALE = 4.0;\nconst float AMPLITUDE = 1.0;\nconst int OCTAVES = 4;\nconst float LACUNARITY = 1.6;\nconst float GAIN = 0.9;\n\nfloat fbm(in vec2 p) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    vec3 q = vec3(p.xy, t);\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        q.y += 0.2 * float(i) * iTime;\n        float n = cnoise(q);\n        n = abs(n);\n        n = pow(n, 3.0);\n        value += amplitude * n;\n        q.xy *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 uv) {\n    vec2 offset = normalize(uv) * fbm(uv);\n    return fbm(uv + offset);\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 p = SCALE * uv + OFFSET;\n    float n = getNoise(p);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "//  https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2BD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 575], [577, 577, 605, 605, 679], [681, 681, 708, 708, 760], [762, 762, 817, 817, 1038]], "test": "untested"}
{"id": "DdjfDh", "name": "J/M Set", "author": "Elyades", "description": "Quick draft of the sets. Trying to get more precision", "tags": ["mandelbrotset"], "likes": 1, "viewed": 204, "published": 3, "date": "1689675610", "time_retrieved": "2024-07-30T17:44:07.874776", "image_code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\nfloat PIONFOUR = 0.78539816339;\nfloat E = 2.71828182846;\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 times(vec2 a , vec2 b)\n{\n    return( vec2(a.x*b.x - a.y*b.y , a.x*b.y + a.y*b.x) );\n}\n\nvec2 itimes(vec2 uv)\n{\n    return( vec2(-uv.y,uv.x) );\n}\n\nfloat norm(vec2 uv)\n{\n    return( uv.x*uv.x + uv.y*uv.y );\n}\n\nvec2 oneover(vec2 uv)\n{\n    return( vec2(uv.x , -uv.y)/norm(uv) );\n}\n\nvec2 square(vec2 uv)\n{\n    return( vec2(uv.x*uv.x - uv.y*uv.y, 2.0*uv.x*uv.y) );\n}\n\nvec2 cube(vec2 uv)\n{\n    float x2 = uv.x*uv.x ; float y2 = uv.y*uv.y;\n    return( vec2(x2*uv.x - 3.0*uv.x*y2 , 3.0*x2*uv.y - y2*uv.y) );\n}\n\nvec2 quad(vec2 uv)\n{\n    float x2 = uv.x*uv.x ; float y2 = uv.y*uv.y; float xy = uv.x*uv.y;\n    return( vec2(x2*x2 - 6.0*x2*y2 + y2*y2 , 4.0*xy*(x2 - y2) ) );\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return ( vec2 (exp2d(itimes(uv)) + exp2d(itimes(-uv)))*0.5);\n}\n\nvec2 sin2d(vec2 uv)\n{\n    return ( vec2 (-itimes((exp2d(itimes(uv)) - exp2d(itimes(-uv)))*0.5)));\n}\n\nvec2 cosh2(vec2 uv)\n{\n    float expo = exp(uv.x); float co = cos(uv.y); float si = sin(uv.y);\n    return ( (expo*vec2(co,si) + exp(-uv.x)*vec2(co,-si))*0.5 );\n}\n\nvec2 sinh2(vec2 uv)\n{\n    float expo = exp(uv.x); float co = cos(uv.y); float si = sin(uv.y);\n    return ( (expo*vec2(co,si) - exp(-uv.x)*vec2(co,-si))*0.5 );\n}\n\nvec2 tanh2(vec2 uv)\n{\n    vec2 expo = exp2d(2.0*uv);\n    return( vec2(expo - 1.0)/(expo + 1.0) );\n}\n\nvec2 rotate(vec2 uv,float angle)\n{\n    float co = cos(angle);float si = sin(angle);\n    uv *= mat2(co,-si,si,co);\n    return(uv);\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 zpowlnz(vec2 uv)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    float LOG = log(modulus);\n    float value = 2.0*angle*LOG;\n    vec2 result = vec2(cos(value),sin(value))*exp(-angle*angle + LOG*LOG);\n    return(result);\n}\n\nvec2 conj(vec2 uv)\n{\n    return vec2(uv.x,-uv.y);\n}\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.5,0.2,0.25);\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette3( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.2,0.3,0.3);\n    vec3 b = vec3(0.0,0.3,0.2);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.25,0.5);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette4(float t) //blue purple :D\n{\n    vec3 a = vec3(0.6,0.4,0.9);\n    vec3 b = vec3(0.4,0.6,0.1);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.45,0.0,0.1);\n\n    vec3 finalColor = vec3( a + b*cos(TWOPI*(c*t + d)) );\n    return finalColor;\n}\n\nvec4 threeLayerColoring( float t ) {\n    float iterationAmount = t;\n\n    float scale = 0.5;\n    float periodFast = 10.0*scale;\n    float residueFast = mod(iterationAmount,periodFast);\n    float indexFast = float(residueFast)/float(periodFast);\n    vec3 colorFast = palette3(indexFast);\n\n    float periodMedium = 20.0*scale;\n    float residueMedium = mod(iterationAmount,periodMedium);\n    float indexMedium = float(residueMedium)/float(periodMedium);\n    vec3 colorMedium = palette3(indexMedium);\n\n    float periodSlow = 100.0*scale;\n    float residueSlow = mod(iterationAmount,periodSlow);\n    float indexSlow = float(residueSlow)/float(periodSlow);\n    vec3 colorSlow = palette3(indexSlow);\n    \n    float finalIndex = (indexFast + indexMedium + indexSlow)/3.;\n    vec3 finalColor = (colorSlow + colorMedium + colorFast)/3.;\n    \n    return(vec4(finalColor, finalIndex));\n}\n\nfloat logplus(float t)\n{\n    if (t < 1.0){return(0.0);}\n    else{return(log(t));}\n}\n\nvec2 iteration(vec2 uv, vec2 c)\n{\n    return (square(uv) +  c );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = 3.0*(iMouse.xy - iResolution.xy/2.0)/iResolution.xy;\n    //Scale\n    float scale = 4.0;\n    uv += -0.5;\n    uv *= scale;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    \n\n    //Choosing the Zoom\n    float zoomAmount = pow(10.0,-iTime/8.0);\n    //vec2 zoomPoint = vec2(-1.76,0.035);\n    vec2 zoomPoint = vec2(0,0);\n    vec2 mousePoint = (iMouse.xy - iResolution.xy/2.0)*8.0/ iResolution.xy;\n    \n\n    uv = uv*zoomAmount;\n    //uv = rotate(uv,mod(max(iTime-7.0,0.0)/40.0,1.0)*TWOPI); //comment this to stop the rotation\n    uv += zoomPoint;\n    \n    //uv += mousePoint*zoomAmount*max(iTime-4.0,0.0);\n    //uv += vec2(-0.61021,-0.0001);\n    //uv += zoomPoint*zoomAmount;\n    \n    //Change this line to go from Mandelbrot to Julia\n    float angle = TWOPI*iTime/6.0;\n    float r = clamp(0.2,1.0,1.0 + cos(TWOPI*iTime/17.0));\n    //vec2 c = r*exp2d(vec2(cos(angle),sin(angle)));\n    vec2 c = mousePoint;\n    \n    float tol = pow(10.0,-10.0);\n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    float iterationAmount;\n    int testAmount = 5000;\n    float bailout = pow(10.0,2.0);\n    \n    vec2 dummyuv = uv; vec2 dz = vec2(1.0,0.0);\n    int i;\n    \n    for (i = 0; i < testAmount; i++)\n    {\n        previousIteration = dummyuv;\n        dz = times(dz, 2.0*dummyuv) + vec2(1.0,0.0);\n        dummyuv = iteration(dummyuv,c);\n        \n        currentModulus = norm(dummyuv);\n        DistanceToPrevious = norm(dummyuv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > bailout)\n        {\n            break;\n        } \n    }\n    iterationAmount = float(i);\n\n    //Coloring the interior of the set\n\n    if (currentModulus < bailout)\n    {\n        \n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //Coloring the exterior of the set\n \n    else\n    {\n        int colorType = 3; // 0 = usual , 1 = log-potential, 2 = (log-potential) + normal map;\n        //3 = distance estimation + normal map + log-potential (mu)\n        \n        if (colorType == 0){\n            iterationAmount = 4.0*log(iterationAmount+1.0)+2.0;\n            float i = iterationAmount+1.0;\n            vec3 color1; float finalIndex; vec4 result = threeLayerColoring(iterationAmount);\n            color1 = result.rgb; finalIndex = result.t;\n            vec3 color2 = threeLayerColoring(log(i)).rgb;\n            vec3 finalColor = mix(color1,color2,finalIndex);\n            \n            fragColor = vec4(finalColor,1.0);\n        }\n        \n        if (colorType == 1){\n            float K = log(2.0);\n            float potential = logplus(norm(dummyuv))/2.0;\n            float nu = log(potential/log(bailout))/K;\n            iterationAmount = log(iterationAmount) + nu;\n            vec3 color1 = threeLayerColoring(iterationAmount).rgb;\n            vec3 color2 = threeLayerColoring(iterationAmount+1.0).rgb;\n            vec3 finalColor = mix(color1,color2,0.5+0.5*sin(iterationAmount));\n            if(nu > 1.0){finalColor = vec3(0.0);}\n\n            fragColor = vec4(finalColor,1.0);\n        }\n        \n        if (colorType == 2){\n            float height = 1.5; float lightAngle = PIONFOUR; \n            vec2 lightVector = vec2(cos(lightAngle),sin(lightAngle));\n            vec2 u = times(dummyuv,oneover(dz)); u = u/length(u);\n            float intensity = ( dot(u,lightVector) + height )/(1.0+height);\n            \n            float K = log(2.0);\n            float potential = log(norm(dummyuv))/2.0;\n            float nu = log(potential)/K;\n            iterationAmount += 1.0 - nu;\n            \n            iterationAmount = 7.0*log(iterationAmount + 1.0) + 1.0; \n            \n            vec4 result = threeLayerColoring(iterationAmount);\n            vec3 color1 = result.rgb; float finalIndex = result.t;\n            vec3 color2 = threeLayerColoring(iterationAmount+1.0).rgb;\n            vec3 finalColor = mix(color1,color2,finalIndex)*intensity;\n\n            fragColor = vec4(finalColor,1.0);\n        }\n        \n        if (colorType == 3){\n            float estimation = sqrt(currentModulus/norm(dz))*0.5*log(currentModulus);\n            estimation = pow(estimation,0.1);\n            //vec3 finalColor = vec3(estimation,estimation,estimation);\n            float lg2 = log(2.0);\n            float potential = log(log(currentModulus))/lg2 - 1.0;\n            //estimation += potential;\n            //finalColor = 0.6*finalColor + 0.4*threeLayerColoring(log(estimation)).rgb;\n            \n            \n            \n            float height = 1.3; float lightAngle = PIONFOUR; \n            vec2 lightVector = vec2(cos(lightAngle),sin(lightAngle));\n            vec2 u = times(dummyuv,oneover(dz)); u = u/length(u);\n            float intensity = ( dot(u,lightVector) + height )/(0.8+height);\n            \n            //vec3 finalColor = 0.5*texture(iChannel0, vec2(intensity,estimation)).rgb;\n            //finalColor += 0.5*texture(iChannel0, vec2(iterationAmount,estimation)).rgb;\n            vec3 finalColor = vec3( estimation );\n            \n            fragColor = vec4(finalColor*intensity,1.0);\n        }\n        \n    }\n\n    \n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 184, 216, 302], [304, 304, 333, 333, 394], [396, 396, 418, 418, 452], [454, 454, 475, 475, 514], [516, 516, 539, 539, 584], [586, 586, 608, 608, 668], [670, 670, 690, 690, 808], [810, 810, 830, 830, 970], [972, 972, 993, 993, 1045], [1047, 1047, 1068, 1068, 1121], [1123, 1123, 1144, 1144, 1211], [1213, 1213, 1234, 1234, 1312], [1314, 1314, 1335, 1335, 1474], [1476, 1476, 1497, 1497, 1636], [1638, 1638, 1659, 1659, 1737], [1739, 1739, 1773, 1773, 1870], [1872, 1872, 1902, 1902, 2055], [2057, 2057, 2080, 2080, 2308], [2310, 2310, 2330, 2330, 2361], [2363, 2363, 2389, 2411, 2597], [2599, 2599, 2625, 2647, 2833], [2835, 2835, 2861, 2883, 3070], [3072, 3072, 3113, 3113, 3326], [3328, 3328, 3364, 3364, 4203], [4205, 4205, 4229, 4229, 4288], [4290, 4290, 4323, 4323, 4356], [4359, 4359, 4416, 4466, 9623]], "test": "untested"}
{"id": "Ds2BW1", "name": "complex-noise-8", "author": "LydianLights", "description": "blobbos", "tags": ["perlinnoise", "fractalbrownianmotion"], "likes": 7, "viewed": 204, "published": 3, "date": "1689674273", "time_retrieved": "2024-07-30T17:44:08.877097", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float SCALE = 1.0;\nconst float AMPLITUDE = 1.5;\nconst int OCTAVES = 6;\nconst float LACUNARITY = 1.9;\nconst float GAIN = 1.2;\n\nfloat fbm(in vec2 p) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    vec3 q = vec3(p.xy, t);\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        float n = cnoise(q);\n        n = 0.005 / n;\n        value += amplitude * n;\n        q.xy *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 uv) {\n    return fbm(uv);\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 p = SCALE * uv + OFFSET;\n    float n = getNoise(p);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "//  https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2BW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 514], [516, 516, 544, 544, 566], [568, 568, 595, 595, 647], [649, 649, 704, 704, 925]], "test": "untested"}
{"id": "DdjBW1", "name": "complex-noise-7", "author": "LydianLights", "description": "vaguely sinister...", "tags": ["simplexnoise", "fractalbrownianmotion"], "likes": 5, "viewed": 156, "published": 3, "date": "1689672739", "time_retrieved": "2024-07-30T17:44:09.748766", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float SCALE = 0.7;\nconst float AMPLITUDE = 0.7;\nconst int OCTAVES = 8;\nconst float LACUNARITY = 2.0;\nconst float GAIN = 0.9;\n\nfloat fbm(in vec2 p) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    vec3 q = vec3(p.xy, t);\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        float n = snoise(q);\n        n = abs(n);\n        n = 1.0 - n;\n        n = pow(n, 10.0);\n        value += amplitude * n;\n        q.xy *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 uv) {\n    return fbm(uv + 0.03 * fbm(uv + 0.1));\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 p = SCALE * uv + OFFSET;\n    float n = getNoise(p);\n    n = pow(n, 2.0);\n    n = 0.01 / n;\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n   return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 558], [560, 560, 588, 588, 633], [635, 635, 662, 662, 714], [716, 716, 771, 771, 1031]], "test": "untested"}
{"id": "csjfDh", "name": "2D Occlusion Test", "author": "beans_please", "description": "Drag to move the middle circle", "tags": ["2d", "sdf", "shadows", "occlusion"], "likes": 4, "viewed": 167, "published": 3, "date": "1689671017", "time_retrieved": "2024-07-30T17:44:10.721166", "image_code": "vec2 screen_to_world(vec2 coord)\n{\n    vec2 v = (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    v *= 5.0;\n    return v;\n}\n\nfloat sd_scene(vec2 p)\n{\n    vec2 circ1_pos = vec2(0.0);\n    if (iMouse.z > 0.0)\n        circ1_pos = screen_to_world(iMouse.xy);\n    \n    vec2 circ2_pos = vec2(4.5 + sin(TAU * 0.6 * iTime) * 0.25, cos(TAU * 0.22 * iTime) * 2.0);\n    vec2 circ3_pos = vec2(-4.5 - cos(TAU * 0.6 * iTime) * 0.25, cos(TAU * 0.22 * iTime + PI) * 2.0);\n\n    float d = 10000000.0;\n    #if 1\n    d = min(d, distance(p, circ1_pos) - 1.0);\n    d = min(d, distance(p, circ2_pos) - 0.7);\n    d = min(d, distance(p, circ3_pos) - 0.7);\n    #else\n    d = min(d, distance_alt(p, circ1_pos) - 1.0);\n    d = min(d, distance_alt(p, circ2_pos) - 0.7);\n    d = min(d, distance_alt(p, circ3_pos) - 0.7);\n    #endif\n    return d;\n}\n\nbool march(vec2 ro, vec2 rd)\n{\n    // Constants\n    const int max_steps = 100;\n    const float max_dist = 100.0;\n    const float hit_thres = 0.005;\n    \n    // March\n    float sd = 1.0;\n    float traveled = 0.0;\n    for (int i = 0; i < max_steps; i++)\n    {\n        // Get SD\n        sd = sd_scene(ro);\n        \n        // Are we inside an object?\n        if (sd < 0.0)\n            break;\n        \n        // Move forward\n        ro += rd * sd;\n        traveled += sd;\n        \n        // Did we hit something?\n        if (sd < hit_thres)\n            break;\n        \n        // Did we go too far?\n        if (traveled > max_dist)\n            break;\n    }\n    \n    return (sd < hit_thres);\n}\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord )\n{\n    // Initialize PRNG\n    eprng_init(frag_coord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Calculate occlusion\n    const int num_angles = 100;\n    float v = 0.0;\n    for (int i = 0; i < num_angles; i++)\n    {\n        // Ray origin\n        vec2 ro = screen_to_world(frag_coord + vec2(random(), random()) - 0.5);\n    \n        // Ray direction\n        #if 1\n        float angle = TAU * random();\n        vec2 rd = vec2(cos(angle), sin(angle));\n        #else\n        float angle = random();\n        vec2 rd = vec2(cos_alt_use_t(angle), sin_alt_use_t(angle));\n        #endif\n        \n        // March\n        if (!march(ro, rd)) v += 1.0;\n    }\n    v /= float(num_angles);\n    \n    // Colorize\n    v = clamp(v * v * 1.15, 0.0, 1.0);\n    vec3 col = mix(vec3(0.7, 0.03, 0.02), vec3(1.0, 0.95, 0.75), v);\n    \n    // Output\n    col = pow(col, vec3(1.0 / 2.2));\n    frag_color = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "#define PI 3.1415926535897932384626433832795\n#define TAU 6.283185307179586476925286766559\n\n// Not faster than built-in functions\n// t = angle_in_radians / tau\nfloat cos_alt_use_t(float t)\n{\n    t = fract(t);\n    t -= .25 + floor(t + .25);\n    t *= 16. * (abs(t) - 0.5);\n    #if 1\n    t += .225 * t * (abs(t) - 1.);\n    #endif\n    return t;\n}\nfloat sin_alt_use_t(float t)\n{\n    return cos_alt_use_t(t - 0.25);\n}\n\n// Not faster than built-in functions,\n// I'm just experimenting\nfloat distance_alt(vec2 a, vec2 b)\n{\n    a -= b;\n    return intBitsToFloat(0x1fbb4000 + (floatBitsToInt(a.x*a.x+a.y*a.y) >> 1));  \n}\n\n\n\n// ***********************************************\n// PRNG\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 145], [147, 147, 171, 171, 838], [840, 840, 870, 887, 1530], [1532, 1532, 1591, 1614, 2492]], "test": "untested"}
{"id": "cd2fR1", "name": "Carbon Fiber Texture", "author": "piyushslayer", "description": "Just my attempt at replicating a carbon fiber-esque texture by analyzing real-life reference images. Use the mouse to move the \"light\". ", "tags": ["procedural", "2d", "noise", "math", "texture", "perlin", "pattern", "material"], "likes": 9, "viewed": 288, "published": 3, "date": "1689667569", "time_retrieved": "2024-07-30T17:44:11.486122", "image_code": "/**\n    A quasi-realistic looking carbon fiber texture pattern based on overlapping two different sets of uv maps\n    mixed using a zigzag checkered pattern. The checkered pattern is stored in x channel of the carbon fiber\n    map. The anisotropic brushed \"metal\" look is generated by stretching two sets of perlin fbm noise along the\n    x and y axis and then mixing them using the same zigzag checkered pattern. A second map is also generated\n    that stores the heightmap for each \"weave\" in the mesh. Finally everything is mixed together using these \n    two masks with 2 distinct colors to differentiate between the horizontal and vertical weaves. Some fake lighting\n    is also added to enhance the effect of the heightmap & the anisotropic brushes on each weave of the mesh. Try playing\n    around with different settings below to customize the look of the texture. \n*/\n\n#define Saturate(x) clamp(x, 0.0, 1.0)\n\n#define WEAVE_SCALE 50.0\n#define HORIZONTAL_WEAVE_COLOR vec3(0.165,0.165,0.165) // #2A2A2A\n#define VERTICAL_WEAVE_COLOR   vec3(0.329,0.329,0.329) // #545454\n\n#define ANISOTROPIC_MASK 1\n#define ANISOTROPIC_ANIMATION 1\n#define ANISOTROPIC_THRESHOLD 0.3\n#define ANISOTROPIC_ANIMATION_SPEED 0.02\n\n#define LIGHTING 1\n#define SPECULAR 1\n\n#define DIFFUSE_SCALE 2.0\n#define SPECULAR_SCALE 0.5\n\nfloat Hash12(vec2 p, float f)\n{\n    p = abs(mod(p, f)); // we want the same random points for each subsection\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1.0 / float(0xffffffffU));\n}\n\n// Noise function by morgan3d (modified)\nfloat PerlinNoise(vec2 x, float freq) \n{\n    x *= freq; // tile\n    \n    vec2 f = fract(x);\n    x = floor(x);\n\n\tfloat a = Hash12(x, freq);\n    float b = Hash12(x + vec2(1.0, 0.0), freq);\n    float c = Hash12(x + vec2(0.0, 1.0), freq);\n    float d = Hash12(x + vec2(1.0, 1.0), freq);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat PerlinFbm (vec2 uv, float freq, int octaves)\n{\n    float amp = .5;\n    float noise = 0.;\n    \n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * PerlinNoise(uv, freq);\n        amp *= .5;\n        freq *= 2.;\n    }\n    return noise;\n}\n\nvec2 GenerateCarbonFiberMap(in vec2 uv)\n{\n    vec2 gridUv = uv * WEAVE_SCALE * vec2(1.0, iResolution.y / iResolution.x); // Scale grid row size based on aspect ratio.\n    vec2 gridId = floor(gridUv);\n    float maskScaleInverse = 0.5;\n    vec2 maskOffset = (gridUv + gridId.yx) * maskScaleInverse;\n    \n    float patternMask = mod(floor(maskOffset.x), 2.0); // zigzag pattern\n    vec2 gradients = 1.0 - abs(fract(maskOffset) - 0.5); // horizontal and vertical gradient patterns\n    gradients -= 0.5;\n    gradients = Saturate(pow(gradients, vec2(0.25)));\n    float heightMap = mix(gradients.y, gradients.x, patternMask); // mix both gradients based on the zigzag pattern\n    \n#if ANISOTROPIC_MASK\n    float anisotropicBrush = mix(PerlinFbm(uv * vec2(50.0, 0.1) + vec2(0.0, uv.x * 8.0) \n#if ANISOTROPIC_ANIMATION\n                                           + iTime * ANISOTROPIC_ANIMATION_SPEED\n#endif\n                                           , 32.0, 8), // vertical anisotropic\n                                 PerlinFbm(uv * vec2(0.1, 50.0) + vec2(uv.y * 8.0, 0.0)\n#if ANISOTROPIC_ANIMATION\n                                           + iTime * ANISOTROPIC_ANIMATION_SPEED\n#endif\n                                           , 32.0, 8), // horizontal anisotropic\n                                 patternMask);\n    heightMap = mix(anisotropicBrush * ANISOTROPIC_THRESHOLD, heightMap, heightMap);\n#endif\n    return vec2(patternMask, heightMap);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 carbonFiber = GenerateCarbonFiberMap(uv);\n    vec3 outColor = vec3(1.0);\n    \n#if LIGHTING\n    vec3 normal = normalize(vec3(dFdx(carbonFiber.y) * 2.0, dFdy(carbonFiber.y) * 2.0, carbonFiber.y)); // I've literally pulled the multiply by 2 out of my ass because it looks good. \n    vec3 lightDirection = normalize(vec3(iMouse.y < 0.5 ? vec2(iResolution.xy * 0.5) : iMouse.xy, 500.0) - vec3(fragCoord, 0.0));\n    outColor = vec3(max(0.0, dot(normal, lightDirection))) * DIFFUSE_SCALE; // diffuse \"lighting\"\n#if SPECULAR\n    vec3 r = reflect(-lightDirection, normal);\n    outColor += pow(max(0.0, dot(normalize(vec3(vec2(0.5), 1000.0) - vec3(uv, 0.0)), r)), 8.0) * SPECULAR_SCALE; // specular \"lighting\" \n#endif\n#else\n    outColor *= 2.0;\n#endif\n\n    outColor *= carbonFiber.y * mix(VERTICAL_WEAVE_COLOR, HORIZONTAL_WEAVE_COLOR, carbonFiber.x);\n    fragColor = vec4(outColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2fR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1304, 1304, 1335, 1335, 1561], [1563, 1604, 1644, 1644, 2003], [2005, 2005, 2057, 2057, 2259], [3705, 3705, 3762, 3762, 4693]], "test": "untested"}
{"id": "Dd2BWh", "name": "RayMarching4489", "author": "shaderNoob4489", "description": "RayMarchingShader", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 69, "published": 3, "date": "1689665815", "time_retrieved": "2024-07-30T17:44:12.458521", "image_code": "#define MAX_STEPS 50\n#define MAX_DIST 50.\n#define MAX_SHADOW_DIST 30.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a; \n    vec3 ap = p - a; \n    float t = dot(ap, ab) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n\n    return length(c - p) - r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a; \n    vec3 ap = p - a; \n    float t = dot(ap, ab) / dot(ab, ab);\n    vec3 c = a + t * ab;\n\n    float x = length(p - c) - r;\n    float y = (abs(t - .5) - .5) * length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    return e + i;\n}\n\nfloat sdTours(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 size)\n{\n    vec3 d = abs(p) - size;\n    float e = length(max(d, 0.));\n    float i = min(max(max(d.x, d.y), d.z), 0.);\n    return e + i;\n}\n\nfloat GetDist(vec3 p)\n{\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    float planeDist = p.y;\n    float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), .2);\n    float td = sdTours(p - vec3(0, .5, 6), vec2(1.5, .3));\n    float bd = sdBox(p - vec3(-3, .75, 6), vec3(.75));\n    float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(2, .3, 5), .3);\n    float d = min(planeDist, cd);\n    d = min(td, d);\n    d = min(bd, d);\n    d = min(cyld, d);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO * rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dO < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    //vec3 normal = d - vec3\n    //(\n    //    GetDist(p - e.xyy),\n    //    GetDist(p - e.yxy),\n    //    GetDist(p - e.yyx)\n    //);\n    vec3 normal = vec3\n    (\n        GetDist(p + e.xyy),\n        GetDist(p + e.yxy),\n        GetDist(p + e.yyx)\n    );\n    return normalize(normal);\n}\n\nfloat shadow(vec3 p, vec3 lightDir, float ldis)\n{\n    float shadow = 1.0;\n    float t = 0.001;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float d = GetDist(p + t * lightDir);\n        t += d;\n        if (t > MAX_SHADOW_DIST) break;\n        if (d < SURF_DIST) return 0.;\n        shadow = min(2. * d / t, shadow);\n    }\n    return shadow;\n}\n\nfloat ao(vec3 p, vec3 n)\n{\n    float a = 0.;\n    float e = .1;\n    int ignored;\n    float weight = .5;\n    \n    for (int i = 1; i <= 5; i++)\n    {\n        float d = e * float(i);\n        a += weight * (1.0 - (d - GetDist(p + n * d)));\n        weight *= .5;\n    }\n    \n    return a;\n}\n\nvec3 GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0, 5, 0);\n    lightPos += vec3(5. * cos(iTime) * .5, 0, 5. * sin(iTime) * .5);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = GetNormal(p);\n    float dif = clamp(dot(lightDir, normal), 0., 1.);\n    float ldis = length(lightPos - p);\n    dif *= shadow(p + normal * SURF_DIST * 2., lightDir, ldis);\n    \n    vec3 ambient = ao(p, normal) * vec3(.2);\n    return vec3(dif) + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 2, 0); \n    vec3 rd = normalize(vec3(uv.x, uv.y - .2, 1));\n    \n    vec3 p = ro + rd * RayMarch(ro, rd);\n    col = GetLight(p);\n    //col = GetNormal(p);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2BWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 143, 143, 312], [314, 314, 365, 365, 653], [655, 655, 686, 686, 761], [763, 763, 795, 795, 925], [927, 927, 950, 950, 1428], [1430, 1430, 1464, 1464, 1684], [1686, 1686, 1710, 1710, 2049], [2051, 2051, 2100, 2100, 2399], [2401, 2401, 2427, 2427, 2684], [2686, 2686, 2709, 2709, 3131], [3133, 3133, 3190, 3190, 3519]], "test": "untested"}
{"id": "mdSfD1", "name": "Image Transition Perlin Noise", "author": "alphardex", "description": "Use mouse to drag the transition.", "tags": ["transition"], "likes": 8, "viewed": 329, "published": 3, "date": "1689663452", "time_retrieved": "2024-07-30T17:44:13.330190", "image_code": "//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159-.85373472095314*r;\n}\n\nvec3 fade(vec3 t){\n    return t*t*t*(t*(t*6.-15.)+10.);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0=floor(P);// Integer part for indexing\n    vec3 Pi1=Pi0+vec3(1.);// Integer part + 1\n    Pi0=mod289(Pi0);\n    Pi1=mod289(Pi1);\n    vec3 Pf0=fract(P);// Fractional part for interpolation\n    vec3 Pf1=Pf0-vec3(1.);// Fractional part - 1.0\n    vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);\n    vec4 iy=vec4(Pi0.yy,Pi1.yy);\n    vec4 iz0=Pi0.zzzz;\n    vec4 iz1=Pi1.zzzz;\n    \n    vec4 ixy=permute(permute(ix)+iy);\n    vec4 ixy0=permute(ixy+iz0);\n    vec4 ixy1=permute(ixy+iz1);\n    \n    vec4 gx0=ixy0*(1./7.);\n    vec4 gy0=fract(floor(gx0)*(1./7.))-.5;\n    gx0=fract(gx0);\n    vec4 gz0=vec4(.5)-abs(gx0)-abs(gy0);\n    vec4 sz0=step(gz0,vec4(0.));\n    gx0-=sz0*(step(0.,gx0)-.5);\n    gy0-=sz0*(step(0.,gy0)-.5);\n    \n    vec4 gx1=ixy1*(1./7.);\n    vec4 gy1=fract(floor(gx1)*(1./7.))-.5;\n    gx1=fract(gx1);\n    vec4 gz1=vec4(.5)-abs(gx1)-abs(gy1);\n    vec4 sz1=step(gz1,vec4(0.));\n    gx1-=sz1*(step(0.,gx1)-.5);\n    gy1-=sz1*(step(0.,gy1)-.5);\n    \n    vec3 g000=vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100=vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010=vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110=vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001=vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101=vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011=vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111=vec3(gx1.w,gy1.w,gz1.w);\n    \n    vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));\n    g000*=norm0.x;\n    g010*=norm0.y;\n    g100*=norm0.z;\n    g110*=norm0.w;\n    vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));\n    g001*=norm1.x;\n    g011*=norm1.y;\n    g101*=norm1.z;\n    g111*=norm1.w;\n    \n    float n000=dot(g000,Pf0);\n    float n100=dot(g100,vec3(Pf1.x,Pf0.yz));\n    float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));\n    float n110=dot(g110,vec3(Pf1.xy,Pf0.z));\n    float n001=dot(g001,vec3(Pf0.xy,Pf1.z));\n    float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));\n    float n011=dot(g011,vec3(Pf0.x,Pf1.yz));\n    float n111=dot(g111,Pf1);\n    \n    vec3 fade_xyz=fade(Pf0);\n    vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);\n    vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);\n    float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);\n    return 2.2*n_xyz;\n}\n\nvec4 getFromColor(vec2 uv){\n    return texture(iChannel0,uv);\n}\n\nvec4 getToColor(vec2 uv){\n    return texture(iChannel1,uv);\n}\n\nfloat sdCircle(vec2 p,float r)\n{\n    return length(p)-r;\n}\n\nvec4 transition(vec2 uv){\n    float progress=iMouse.x/iResolution.x;\n    float ratio=iResolution.x/iResolution.y;\n    \n    vec2 p=uv;\n    p-=.5;\n    p.x*=ratio;\n    \n    float noise=cnoise(vec3(p*10.,0.));\n    float pr=progress+noise*.1;\n    \n    float d=sdCircle(p,pr*sqrt(2.));\n    float c=smoothstep(-.1,-.05,d);\n    \n    return mix(getFromColor(uv),getToColor(uv),1.-c);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 col=transition(uv);\n    \n    fragColor=col;\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSfD1.jpg", "access": "api", "license": "mit", "functions": [[445, 445, 466, 466, 506], [508, 508, 529, 529, 569], [571, 571, 593, 593, 630], [632, 632, 660, 660, 709], [711, 711, 729, 729, 768], [770, 794, 816, 816, 3005], [3007, 3007, 3034, 3034, 3070], [3072, 3072, 3097, 3097, 3133], [3135, 3135, 3167, 3167, 3193], [3195, 3195, 3220, 3220, 3571], [3573, 3573, 3626, 3626, 3724]], "test": "untested"}
{"id": "mdSBW1", "name": "complex-noise-6", "author": "LydianLights", "description": "looks like water caustics", "tags": ["simplexnoise", "fractalbrownianmotion"], "likes": 12, "viewed": 366, "published": 3, "date": "1689649825", "time_retrieved": "2024-07-30T17:44:14.158975", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float SCALE = 1.6;\nconst float AMPLITUDE = 0.4;\nconst int OCTAVES = 4;\nconst float LACUNARITY = 2.4;\nconst float GAIN = 0.5;\n\nfloat fbm(in vec2 p) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    vec3 q = vec3(p.xy, t);\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        float n = snoise(q);\n        n = abs(n);\n        value += amplitude * n;\n        q.xy *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 p) {\n    return fbm(p);\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 p = SCALE * uv + OFFSET;\n    float n = getNoise(p);\n    n = 0.02 / n;\n    n = pow(n, 1.9);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n   return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 511], [513, 513, 540, 540, 561], [563, 563, 590, 590, 642], [645, 645, 700, 700, 960]], "test": "untested"}
{"id": "ddSBW1", "name": "complex-noise-5", "author": "LydianLights", "description": "spiky", "tags": ["simplexnoise", "fractalbrownianmotion"], "likes": 7, "viewed": 161, "published": 3, "date": "1689649634", "time_retrieved": "2024-07-30T17:44:14.977786", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float SCALE = 2.0;\nconst float AMPLITUDE = 0.6;\nconst int OCTAVES = 8;\nconst float LACUNARITY = 3.0;\nconst float GAIN = 0.3;\n\nfloat fbm(in vec2 p) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    vec3 q = vec3(p.xy, t);\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        float n = snoise(q);\n        n = abs(n);\n        n = 1.0 - n;\n        n = pow(n, 5.0);\n        value += amplitude * n;\n        q.xy *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 p) {\n    return fbm(p + fbm(p));\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 p = SCALE * uv + OFFSET;\n    float n = getNoise(p);\n    n = pow(n, 1.9);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n   return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 557], [559, 559, 586, 586, 616], [618, 618, 645, 645, 697], [699, 699, 754, 754, 996]], "test": "untested"}
{"id": "msBfDh", "name": "complex-noise-4", "author": "LydianLights", "description": "goopy", "tags": ["simplexnoise", "fractalbrownianmotion"], "likes": 5, "viewed": 141, "published": 3, "date": "1689649476", "time_retrieved": "2024-07-30T17:44:15.900318", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float FREQ = 2.0;\nconst float AMPLITUDE = 1.0;\nconst int OCTAVES = 4;\nconst float LACUNARITY = 2.0;\nconst float GAIN = 0.5;\n\nfloat fbm(in vec2 uv) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    float freq = FREQ;\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        vec2 p = freq * (uv + OFFSET);\n        vec3 q = vec3(p.xy, t);\n        float n = snoise(q);\n        value += amplitude * n;\n        freq *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return 0.5 * value + 0.5;\n}\n\nfloat getNoise(in vec2 uv) {\n    return fbm(uv + fbm(uv + fbm(uv)));\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float n = getNoise(uv);\n    n = pow(n, 2.5);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n   return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 193, 193, 569], [571, 571, 599, 599, 641], [643, 643, 670, 670, 722], [725, 725, 780, 780, 989]], "test": "untested"}
{"id": "ddBfDh", "name": "complex-noise-3", "author": "LydianLights", "description": "cloudy", "tags": ["simplexnoise", "fractalbrownianmotion"], "likes": 2, "viewed": 149, "published": 3, "date": "1689649464", "time_retrieved": "2024-07-30T17:44:16.871721", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float SCALE = 0.7;\nconst float AMPLITUDE = 0.3;\nconst int OCTAVES = 8;\nconst float LACUNARITY = 1.7;\nconst float GAIN = 0.9;\n\nfloat fbm(in vec2 p) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    vec3 q = vec3(p.xy, t);\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        float n = snoise(q);\n        n = abs(n);\n        value += amplitude * n;\n        q.xy *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 uv) {\n    return fbm(uv);\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 p = SCALE * uv + OFFSET;\n    float n = getNoise(p);\n    n = pow(n, 2.0);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n   return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 511], [513, 513, 541, 541, 563], [565, 565, 592, 592, 644], [646, 646, 701, 701, 943]], "test": "untested"}
{"id": "mdSfDh", "name": "complex-noise-2", "author": "LydianLights", "description": "tendrils of energy", "tags": ["simplexnoise", "fractalbrownianmotion"], "likes": 11, "viewed": 223, "published": 3, "date": "1689648392", "time_retrieved": "2024-07-30T17:44:17.776302", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float SCALE = 0.7;\nconst float AMPLITUDE = 0.5;\nconst int OCTAVES = 8;\nconst float LACUNARITY = 2.0;\nconst float GAIN = 0.8;\n\nfloat fbm(in vec2 p) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    vec3 q = vec3(p.xy, t);\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        float n = snoise(q);\n        n = abs(n);\n        n = 1.0 - n;\n        n = pow(n, 10.0);\n        value += amplitude * n;\n        q.xy *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 uv) {\n    return fbm(uv);\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 p = SCALE * uv + OFFSET;\n    float n = getNoise(p);\n    n = pow(n, 2.0);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n   return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 558], [560, 560, 588, 588, 610], [612, 612, 639, 639, 691], [693, 693, 748, 748, 990]], "test": "untested"}
{"id": "ddSfDh", "name": "complex-noise-1", "author": "LydianLights", "description": "it's full of stars...", "tags": ["simplexnoise", "fractalbrownianmotion"], "likes": 7, "viewed": 192, "published": 3, "date": "1689648188", "time_retrieved": "2024-07-30T17:44:18.671907", "image_code": "const vec2 OFFSET = vec2(69.0, 420.0);\nconst float FREQ = 0.7;\nconst float AMPLITUDE = 0.03;\nconst int OCTAVES = 8;\nconst float LACUNARITY = 2.5;\nconst float GAIN = 0.7;\n\nfloat fbm(in vec2 uv) {\n    float t = iTime / 2.0;\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    float freq = FREQ;\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        vec2 p = freq * (uv + OFFSET);\n        vec3 q = vec3(p.xy, t);\n        float n = snoise(q);\n        n = 1.0 - n;\n        n = pow(n, 6.0);\n        value += amplitude * n;\n        freq *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return value;\n}\n\nfloat getNoise(in vec2 uv) {\n    return fbm(uv);\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float n = getNoise(uv);\n    n = pow(n, 2.5);\n    vec3 color = vec3(n);\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n   return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 194, 194, 604], [606, 606, 634, 634, 656], [658, 658, 685, 685, 737], [739, 739, 794, 794, 1003]], "test": "untested"}
{"id": "csBBW1", "name": "polar doodle", "author": "elenzil", "description": "doodle", "tags": ["polar"], "likes": 12, "viewed": 158, "published": 3, "date": "1689630086", "time_retrieved": "2024-07-30T17:44:19.942511", "image_code": "const float pi   = 3.14159265359;\nconst float pipi = pi * 2.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy/2.0;\n\n\n    float angle = fract((atan(xy.y, xy.x) + pipi) / pipi);\n    float dist  = length(xy);\n    \n    float numLanes = 17.0;\n    \n    float lane = floor(angle * numLanes);\n    \n    float distCompressed = pow(dist, 0.2) * 520.0;\n\n    float c = sin(distCompressed * 0.1 - 8.0 * iTime * (0.7 + 0.3 * sin(iTime * 0.01 + 5.0 * lane / numLanes * pipi)));\n    c = smoothstep(-0.4, 0.4, c);\n    \n    float minContrast = 0.0;\n    float maxContrast = 0.6;\n    float d = dist/iResolution.x * 2.0;\n    \n    c *=       mix(minContrast, maxContrast, d);\n    c += 1.0 - mix(minContrast, maxContrast, d);   \n    \n    fragColor = vec4(c, c, c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 122, 122, 799]], "test": "untested"}
{"id": "dsSfzz", "name": "Pool water", "author": "Jan300100", "description": "underwater pool noise fbm caustics", "tags": ["noise", "fbm", "caustics", "underwater", "pool"], "likes": 9, "viewed": 511, "published": 3, "date": "1689593577", "time_retrieved": "2024-07-30T17:44:20.840110", "image_code": "vec3 hash( uvec3 x )\n{  \n    //https://www.shadertoy.com/view/4lXyWN\n    \n    //multiply large prime value first.\n    uint k = 1103515245U;\n    x*= k;\n    //mix x, y, z values.\n    //Without shift operator, x, y and z value become same value.\n    x = ((x>>2u)^(x.yzx>>1u)^x.zxy)*k;\n \n    return (vec3(x)*(1.0/float(0xffffffffU)));\n}\n\nvec3 noise(vec3 p)\n{\n    uvec3 fl = uvec3(floor(p));\n    vec3 fr = fract(p);\n    fr = smoothstep(0.0,1.0,fr);\n    vec3 tr = hash(fl + uvec3(0,0,0));\n    vec3 tl = hash(fl + uvec3(1,0,0));\n    vec3 br = hash(fl + uvec3(0,1,0));\n    vec3 bl = hash(fl + uvec3(1,1,0));\n    vec3 tr2 = hash(fl + uvec3(0,0,1));\n    vec3 tl2 = hash(fl + uvec3(1,0,1));\n    vec3 br2 = hash(fl + uvec3(0,1,1));\n    vec3 bl2 = hash(fl + uvec3(1,1,1));\n        \n    \n    vec3 res = mix(mix(mix(tr, tl, fr.x), mix(br, bl, fr.x), fr.y)\n            ,mix(mix(tr2,tl2,fr.x), mix(br2,bl2, fr.x), fr.y),fr.z);\n    \n    vec3 result = (1.0 + res)*0.5; //map to [0,1]\n\n    return res;\n}\n\n\nvec3 fbm_levels(vec3 p, int levels)\n{\n    vec3 r = vec3(0);\n    \n    float m = 1.0f;\n    for (int i = 0; i < levels; i++)\n    {\n       m *= 0.5f;\n       r += m * noise(p); \n       p *= 2.03;\n    }\n    return r;\n}\n\nvec3 fbm(vec3 p)\n{\n    return fbm_levels(p,4);\n}\n\n\nvec3 pattern(vec3 p)\n{\n    vec3 q = fbm(p);\n    vec3 r = fbm(p + 4.*q);\n    \n    vec3 result;\n    result.x = fbm(p + fbm(p + 2.*fbm(p + q))).x;\n    result.y = q.x;\n    result.z = r.x;\n    return result;\n}\n\nvec3 sampleFloor(vec2 coord)\n{    \n    coord = coord * 1.8f + 0.25;\n    float g1 = 0.10f;\n    float g2 = 0.025f;\n    bool b1 = ((1.0 - fract(coord.x - g1/2.0f)) < g1 || (1.0 - fract(coord.y - g1/2.0f) < g1));\n    bool b2 = ((1.0 - fract(coord.x - g2/2.0f)) < g2 || (1.0 - fract(coord.y - g2/2.0f) < g2));\n    \n    vec3 baseCol;\n    \n    vec3 nRes = noise(vec3(coord * 100.0f,1.0f));\n    if (!b1 && !b2)\n    {\n        vec3 fRes = fbm_levels(vec3(coord * 5.0f,1.0f),3);\n        baseCol = vec3(0.3 + fRes.r * 0.3f+ nRes.r * 0.2f);\n    }\n    else if (b1 && !b2)\n    {\n        baseCol = vec3(0.1 + 0.2 * nRes.y);\n    }\n    else\n    {\n        baseCol = vec3(0.7 + 0.2 * nRes.z);\n    }\n    \n    //\n    vec3 timed_p = vec3(coord * 0.3f,iTime*0.4f + fbm(vec3(coord + 5.0,10.0))); \n    vec3 fRes = fbm_levels(timed_p,2);\n    \n    float cPow = 50.0f;\n    vec3 cCol = vec3(1);\n    \n    vec3 caustics = vec3(0);\n    caustics += pow(clamp(1.0-abs((fRes.y - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n    caustics += pow(clamp(1.0-abs((fRes.x - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n    caustics += pow(clamp(1.0-abs((fRes.z - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n\n    return clamp(baseCol + caustics * 0.2f,0.0,1.0);\n}\n\nvec2 CalcUV(vec2 coord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = coord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float zoom = 5.0f;\n    uv *= zoom;\n    uv += vec2(50.0,25.0);\n    return uv;\n}\n\nfloat sampleWater(vec2 coord)\n{\n    vec2 uv = CalcUV(coord);\n\n    // Time varying pixel color\n    vec3 p = vec3(uv,iTime/3.0f + fbm(vec3(uv + 5.0,10.0)));\n    vec3 res = pattern(p);\n    vec3 color;\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((res.x*res.x)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                1.0-res.y);\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                1.0-res.z);\n\n    return (color.r + color.g + color.b)/3.0f;\n}\n\n// normals using dfdx dfdy, same for the entire quad\n#define CHEAP_NORMALS 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = CalcUV(fragCoord);\n    vec3 finalCol = sampleFloor(uv);\n#if 1\n    float greyscale = sampleWater(fragCoord);\n\n    // normal \n    float height = 0.05f * iResolution.x; // scales with resolution, because noise also scales with the resolution.\n#if CHEAP_NORMALS\n    float offset = 1.0f;\n    float greyscale_dx = dFdx(greyscale);\n    float greyscale_dy = dFdy(greyscale);\n#else\n    float offset = 0.1f;\n    float greyscale_dx = (sampleWater(fragCoord + vec2(offset,0)) - greyscale);\n    float greyscale_dy = (sampleWater(fragCoord + vec2(0,offset)) - greyscale);\n#endif\n    vec2 dxdy = vec2(greyscale_dx, greyscale_dy);\n    vec3 normal = normalize(vec3(dxdy,offset/height));\n    \n    // light\n    vec3 viewDir = vec3(0,0,-1);\n    vec3 lDir = normalize(vec3(-0.477,-0.477,-0.277));\n    \n    vec3 reflectDir = reflect(lDir, normal);\n    float spec = pow(max(dot(reflectDir,viewDir),0.0f),2.0f);\n        \n    // Output to screen\n    vec3 waterCol = vec3(145, 239, 255) / 255.0f;\n    \n    vec2 samplePos = uv + greyscale;\n    finalCol = sampleFloor(samplePos) * waterCol + spec * 0.5f;\n#endif\n    fragColor = vec4(finalCol,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 113, 332], [334, 334, 354, 354, 983], [986, 986, 1023, 1023, 1198], [1200, 1200, 1218, 1218, 1248], [1251, 1251, 1273, 1273, 1455], [1457, 1457, 1487, 1487, 2645], [2647, 2647, 2672, 2722, 2882], [2884, 2884, 2915, 2915, 3459], [3539, 3539, 3596, 3596, 4730]], "test": "untested"}
{"id": "DdjfRm", "name": "Ghost in the Circuit", "author": "misol101", "description": "Fullscreen is a *must*  (as lower resolutions tend to die out)\n\nKeys:  m=see automata, space=regenerate, mouse x zooms\n\nMouse x zooms", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 5, "viewed": 292, "published": 3, "date": "1689592910", "time_retrieved": "2024-07-30T17:44:21.736713", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1. - (iMouse.x / iResolution.x);\n    fragCoord = mid - (mid*mmul-fragCoord*mmul);\n\n    vec4 val = vec4(0.);\n    for (int j = 0; j <= 1; j++)\n        for (int i = 0; i <= 1; i++)\n            val += texelFetch( iChannel0, ivec2(int(fragCoord.x)+i,int(fragCoord.y)+j), 0 );\n    val /= 2.;\n        \n    if (!readKeyToggle(KEY_M)) {\n        fragColor = val;\n    } else {\n        float v=(1./liveval)*val.w;\n        fragColor = vec4( v*0.9, v*0.95, v, 1.0 );\n    }    \n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33995, "src": "https://soundcloud.com/velvetacidchrist/ghost-in-the-circuit", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Cellular automata buffer\n\nvec4 cellval(ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\nint cell(ivec2 p) { return (cellval(p).w == liveval ) ? 1 : 0; }\n\nfloat restart(vec2 fragCoord, float rradius) {\n    vec2 mid = iResolution.xy * 0.5; \n    float xmul=1.; if (iResolution.y < 1000.) xmul=1.75;\n    if (fragCoord.x > mid.x - rradius*xmul && fragCoord.x < mid.x + rradius*xmul+1. && fragCoord.y > mid.y - rradius && fragCoord.y < mid.y + rradius +1.)\n        return liveval;\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = vec3(-3.5*sin((iTime-10.)*0.012), 3.5*sin(iTime*0.0105), 3.5*sin(iTime*0.02));\n    setRules(col);\n    ivec2 px = ivec2(fragCoord);\n    vec4 curr = cellval(px);\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n\n    if( iFrame<2 || readKey(KEY_SPACE) || int(xres) != int(iResolution.x) || (iResolution.y < 800. && mod(iTime, 69.) < 0.2)   ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, 25.));\n        return;\n    }\n    int k = cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n          + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n          + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    \n    float ff = 0.;\n    if (curr.w > 0.5) {\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n    if (ff >= 1.0) {\n        int st = int(ff);\n        if ((st & ra) > 0) curr.x += cstep*rp;\n        if ((st & ga) > 0) curr.y += cstep*gp;\n        if ((st & ba) > 0) curr.z += cstep*bp;\n    } else {\n        curr.x -= cstep*rm; curr.y -= cstep*gm; curr.z -= cstep*bm;\n    }\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float cstep=1./256.;\n\nfloat liveval, rp,gp,bp, rm,gm,bm;\nint stayset, bornset, ra,ga,ba;\n\nvoid setRules(vec3 col) {\n    stayset = 23; bornset = 86;\n    liveval=5., rp=10., gp=7., bp=20., rm=2., gm=2.,bm=2.,  ra=1,ga=2,ba=4;\n    rp=rp+col.x; gp=gp+col.y; bp=bp+col.z;\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_M     = 77;\n#define readKey(key) (texelFetch( iChannel3, ivec2(key, 0), 0).x > .5)\n#define readKeyToggle(key) (texelFetch( iChannel3, ivec2(key, 2), 0).x > .5)\n", "buffer_b_code": "// Resolution\nvoid mainImage( out vec4 O, in vec2 U ) { O = vec4(iResolution.x); }", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 575]], "test": "untested"}
{"id": "ddffWj", "name": "DnB Phace & Current Value", "author": "z0rg", "description": "zef\n", "tags": ["metaballs", "music", "dnb", "currentvalue", "phace"], "likes": 5, "viewed": 237, "published": 3, "date": "1689591093", "time_retrieved": "2024-07-30T17:44:22.520617", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdr(vec2 uv)\n{\n    vec2 off = vec2((hash11(uv.y+iTime*0.01)-0.5)*.2, 0.);\n    if (iTime < 65.0)\n        off *= 0.;\n    off *= sat(sin(iTime*10.)*.5+.5)*(1.-sat(1.5*abs(uv.y-.5)))*.25;\n    vec3 col = vec3(0.);\n    col.x =texture(iChannel0, uv+off).x;\n    col.y =texture(iChannel0, uv+0.5*off).y;\n    col.z =texture(iChannel0, uv-off).z;\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = rdr(uv)*2.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.07\n#define GLOW_POW 1.7\n#define GLOW_OPACITY 60.\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 2.*(1.+5.*length(uv));\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\n// Thanks iq :)\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    vec3 rep = vec3(10.);\n    vec3 id = floor((p+rep*.5)/rep);\n    p = mod(p+rep*.5,rep)-rep*.5;\n    p.xy *= r2d(id.x);\n    p.yz *= r2d(id.z);\n    //p.x += 1.-pow(texture(iChannel3, vec2(0.,p.y*2.)).x,.5)*.9;\n\n    float shape = 10000.;\n    for (float i = 0.; i < 8.; ++i)\n    {\n        vec3 pos = p+vec3(sin(i+iTime*.7), sin(i*5.+iTime*.25), sin(.33*iTime+i*3.3));\n        float curshape = length(pos)-.5-1.5*texture(iChannel3, vec2(i*.1,0.)).x;\n        shape = smin(shape, curshape, .2);\n        //acc = _min(acc, vec2(length(pos)-1., 0.));\n    }\n            acc = _min(acc, vec2(shape, 0.));\n            \n    float cube = _cucube(p, vec3(2.), vec3(.02));\n    cube = max(cube, -(length(p)-3.1));\n    if (iTime > 65.)\n        acc = _min(acc, vec2(cube, 1.));\n    \n    p += sin(p+iTime);\n    p.xy *= r2d(iTime);\n    float laser = length(p.xz)-.05;\n    laser = max(laser, sin(p.y*1.-sign(p.y)*20.*iTime));\n    if (iTime > 65.)\n        acc = _min(acc, vec2(laser, 1.));\n    \n    float laser2 = length(p.xy)-.02;\n    laser2 = max(laser2, sin(p.z*1.-sign(p.z)*10.*iTime)+.5);\n    if ((iTime > 35. && iTime < 60.) || iTime > 65.)\n        acc = _min(acc, vec2(laser2, 2.));\n    \n    float laser3 = length(p.yz)-.02;\n    laser3 = max(laser3, sin(p.x*2.-sign(p.x)*10.*iTime)+.5);\n\n    acc = _min(acc, vec2(laser3, 3.));\n    \n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 30.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.5;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 p, vec3 n, vec3 rd, vec3 res)\n{\n    vec3 col = vec3(0.1);\n    if (res.z == 1.)\n        col = vec3(0.247,0.675,0.788)*1.;\n    if (res.z == 2.)\n        col = vec3(1.000,0.039,0.329)*1.;\n    if (res.z == 3.)\n        col = vec3(0.922,0.502,0.020)*1.;\n    vec3 refl = normalize(reflect(rd, n));\n    col += texture(iChannel2, refl*vec3(1.,-1.,1.)).xyz*.2;\n    return col;\n}\n\nvec3 rdr(vec2 uv, vec2 ouv)\n{\n    float t = iTime*.17;\n    float d = 5.;\n    float tanim = iTime*.5;\n    float off = mix((hash11(floor(tanim))-0.5)*3., \n    (hash11(floor(tanim+1.))-0.5)*3., \n    sat(pow(fract(tanim), 15.)));\n    \n        float tanim2 = iTime*mix(2.5, 0., float(iTime < 12.));\n    float off2 = mix((hash11(floor(tanim2)))*3., \n    (hash11(floor(tanim2+1.)))*3., \n    sat(pow(fract(tanim2), 15.)));\n    d*= off2;\n    uv *= r2d(.5*sin(iTime*.3)-off);\n    vec3 ro = vec3(sin(t)*d,1.,cos(t)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 col = pow(texture(iChannel2, rd*vec3(1.,-1.,1.)).xyz, vec3(.35))*.15;\n    col = (1.-sat(pow(abs(uv.y), .1)))*\n    vec3(texture(iChannel3, vec2(abs(uv.x),0.)).x, 0.5,0.2).zxy;\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        float pix = .1;\n        col = n*.5+.5;//floor((n*.5+.5)/pix+texture(iChannel2, ouv*40.).x*2.)*pix;\n        col = getMat(p, n, rd, res);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 ouv = (fragCoord)/iResolution.xy;\n  \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    vec2 off = .2*(vec2(rand(), rand())-.5)*\n    pow(texture(iChannel3, vec2(0.5,0.)).x,8.);\n    vec3 col = rdr(uv+off+vec2(.2,0.)*0., ouv);\n    col = sat(col);\n    \n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .5);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33977, "src": "https://soundcloud.com/phace/phace-current-value-wild-thing?si=73eab0dab442401395e6e742289fb33f&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        \n        f = (f -.5)*2.;\n        float of = 1.-abs(f);\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        col += of*texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n\n        f = (f -.5)*2.;\n                float of = 1.-abs(f);\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        col += of*texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    fragColor = vec4(rgb,1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddffWj.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 416, 416, 756], [758, 758, 815, 815, 915]], "test": "untested"}
{"id": "csBBWz", "name": "HexTile4489", "author": "shaderNoob4489", "description": "gerenate hex tile", "tags": ["2d", "hextile"], "likes": 1, "viewed": 79, "published": 3, "date": "1689581092", "time_retrieved": "2024-07-30T17:44:23.807177", "image_code": "float HexDist(vec2 p)\n{\n    p = abs(p);\n    float c = dot(p, normalize(vec2(1, 1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv)\n{\n    vec2 r = vec2(1., 1.73);\n    vec2 h = .5 * r;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n    vec2 gv = dot(a, a) < dot(b, b) ? a : b; \n    vec2 id = uv - gv;\n    \n    return vec4(gv, id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    uv *= 5.;\n    \n    col.rg = HexCoords(uv).xy;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 124], [126, 126, 151, 151, 364], [366, 366, 423, 423, 627]], "test": "untested"}
{"id": "cdBfWR", "name": "iscg-2023-sunskyxh", "author": "SunskyXH", "description": "example", "tags": ["example"], "likes": 0, "viewed": 136, "published": 3, "date": "1689578816", "time_retrieved": "2024-07-30T17:44:24.702783", "image_code": "// 単純なレイトレーシングの雛形\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(0.0, 0.0, -3.0); }\nvec3 CameraTo() { return vec3(0.0, 0.0, 1.0); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(\n    vec3 from, vec3 to, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w, out vec3 e\n)\n{\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\nvec3 convertToCameraCoordinateSystem(\n    vec2 pixelCoordinate\n)\n{\n\n\tfloat time = 32.0 + iTime*1.5;\n    vec3 offset = vec3(2.0 * cos(0.1 * time), 0, 2.0 * sin(0.1 * time));\n    \n    float filmWidth = FilmWidth();\n    float filmHeight = FilmHeight();\n    float filmDistance = FilmDistance();\n    vec3 cameraFrom = CameraFrom();\n    vec3 cameraTo = CameraTo() + offset;\n    vec3 cameraUp = CameraUp();\n\n    vec3 u, v, w, e;\n    createOrthoNormalBasis(cameraFrom, cameraTo, cameraUp, u, v, w, e);\n\n    vec3 filmPlaneCenter = cameraFrom - w * filmDistance;\n    vec3 filmPlaneRight = u * filmWidth * (pixelCoordinate.x - iResolution.x / 2.0) / iResolution.x;\n    vec3 filmPlaneUp = v * filmHeight * (pixelCoordinate.y - iResolution.y / 2.0) / iResolution.y;\n\n    return normalize(filmPlaneCenter + filmPlaneRight + filmPlaneUp - e);\n}\n\nRay generateCameraRay(\n    vec2 pixelCoordinate\n)\n{\n    vec3 dir = convertToCameraCoordinateSystem(pixelCoordinate);\n    vec3 org = CameraFrom();\n    return Ray(org, dir);\n}\n\nbool intersectToSphere(\n    vec3 center, float radius, Ray ray,\n    out Hit hit\n)\n{\n    vec3 oc = ray.org - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(oc, ray.dir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return false;\n    }\n    float t = (-b - sqrt(discriminant)) / (2.0 * a);\n    if (t < 0.0) {\n        t = (-b + sqrt(discriminant)) / (2.0 * a);\n        if (t < 0.0) {\n            return false;\n        }\n    }\n    hit.distanceToHitpoint = t;\n    hit.normal = normalize(ray.org + t * ray.dir - center);\n    return true;\n}\n\nbool intersectToPlane(vec3 center, vec2 size, Ray ray, out Hit hit) {\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n    vec3 p = center - ray.org;\n    float t = dot(p, normal) / dot(ray.dir, normal);\n    if (t < 0.0) {\n        return false;\n    }\n    vec3 hitpoint = ray.org + t * ray.dir;\n    vec2 halfSize = size * 0.5;\n    if (abs(hitpoint.x - center.x) > halfSize.x || abs(hitpoint.y - center.y) > halfSize.y) {\n        return false;\n    }\n    hit.distanceToHitpoint = t;\n    hit.normal = normal;\n    return true;\n}\n\n\nbool intersect(Ray ray, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n\n    vec3 plane_center = vec3(0.5, 0.0, 0.0);\n    vec2 plane_size = vec2(0.5, 1.0);\n    \n    vec3 sphere_center = vec3(-0.5, 0.0, 0.0);\n    float radius = 0.5;\n    \n    if(intersectToPlane(plane_center, plane_size, ray, hit)) return true;\n    if(intersectToSphere(sphere_center, radius, ray, hit)) return true;\n    return false;\n}\n\nvec3 shade(Ray ray, Hit hit)\n{\n    return hit.normal * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n    float time = 32.0 + iTime*1.5;\n     \n    Hit hit;\n    if (intersect(ray, hit)) {\n        fragColor = vec4(shade(ray, hit), 0.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 187, 206, 206, 238], [239, 239, 259, 259, 292], [293, 293, 315, 315, 329], [331, 331, 350, 350, 381], [382, 382, 399, 399, 429], [430, 430, 447, 447, 477], [479, 479, 499, 499, 514], [516, 565, 681, 681, 781], [783, 783, 849, 849, 1612], [1614, 1614, 1665, 1665, 1787], [1789, 1789, 1872, 1872, 2427], [2429, 2429, 2498, 2498, 2941], [2944, 2944, 2982, 2982, 3356], [3358, 3358, 3388, 3388, 3425], [3427, 3427, 3484, 3484, 3713]], "test": "untested"}
{"id": "ms2fRm", "name": "Ever rising/lowering tone", "author": "ersh", "description": "To the infinity...\n\nThis shader demonstrated the generation of infinitely rising and/or lowering tone.\nFeel free to play with parameters in the \"Common\" tab.", "tags": ["sound"], "likes": 2, "viewed": 238, "published": 3, "date": "1689576087", "time_retrieved": "2024-07-30T17:44:25.642271", "image_code": "//////////////////////////////////////////////////\n// Go and play with parameters in the COMMON tab.\n//////////////////////////////////////////////////\n\n#define TONEWIDTH (1./400.)\n\nvec3 hsv2rgb(vec3 c) {\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The main purpose of this thing is to always keep time\n    // within a sensible range for sin()\n    float time = timesawtooth(iTime, TIMEPERIOD, TIMETRANS);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col, 1.0);\n    if (fragCoord.x > 5. && fragCoord.y > 5. && fragCoord.x < iResolution.x-5. && fragCoord.y < iResolution.y-5.) {\n        fragColor.rgb *= envMid(uv.x, uv.y);\n    }\n\n    float t = mod(time, RANGE);                        // time = [0 .. RANGE]\n    float tf = t / RANGE;                              // time = [0 .. 1]\n    float tfe = (exp2(tf) - 1.) / (exp2(RANGE) - 1.);  // exp time = [0..1]\n    float tfe1 = tfe + 1.;                             // exp time = [1..2]\n\n    fragColor.rgb *= smoothstep(0.3, 0., 0.5-abs(fract(uv.x - tf)-0.5));\n\n    if (abs(octf(PEAKOCTAVE) - uv.y) <= 1./iResolution.y || abs(octf(PEAKOCTAVE) - uv.x) <= 1./iResolution.x) fragColor += vec4(0.3);\n\n    for (float i = floor(OCTAVEMIN); i < ceil(OCTAVEMAX); i++) {\n        if (abs(octf(i) - uv.x) <= 1./iResolution.x) fragColor.g += 0.4;\n    }\n    for (float i = floor(OCTAVEMIN); i < ceil(OCTAVEMAX); i+=STEP) {\n        vec2 d = vec2(abs(octf(tf+i) - uv.x), envMid(uv.x, octf(PEAKOCTAVE)));\n        if (uv.y <= d.y) fragColor.rg += vec2(d.y*0.4  *  smoothstep(3./iResolution.x, 0., d.x - TONEWIDTH));\n    }\n\n    //if (abs(octf(tf) - uv.x) <= 1./iResolution.x) fragColor.rgb += vec3(0.4);\n}\n", "image_inputs": [], "common_code": "// Speed, octaves per sec\n#define SPD           0.06\n\n// Peak volume at this octave (-3 ... 5)\n#define PEAKOCTAVE    0.8\n\n// Number of tones per octave (1 .. 10)\n#define TONES_PER_OCTAVE  1.\n\n// Dynamic range, dB\n#define DYNRANGE_DB   40.\n\n// Ramp-up / ramp down oscillation period, seconds\n#define TIMEPERIOD    150.\n\n// Transition time between up/down / startup time, seconds\n#define TIMETRANS     1.5\n\n// Min hearable frequency, HZ - should be slightly above the hearable\n#define FREQMIN       50.\n\n// Max hearable frequency, HZ - should be slightly below the hearable\n#define FREQMAX       12000.\n\n// Rumbling effect by modulation with this freq, HZ (can comment out)\n#define MODULATE_BY   65.\n\n// Tone goes first up, then down  (comment out for down-up)\n#define UPDOWN\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloat note2freq(float note) { return 440. * exp2((-10.)/12.) * exp2(note/12.); }\nfloat octave2freq(float note) { return 440. * exp2((-10.)/12.) * exp2(note); }\n#define OCTAVEMIN   log2(FREQMIN / 440. / exp2((-10.)/12.))\n#define OCTAVEMAX   log2(FREQMAX / 440. / exp2((-10.)/12.))\n//float sinhz(float x) { return sin(6.28318530718 * x); }                         // sin\nfloat sinhz(float x) { return abs(fract(x-0.25)-0.5)*4.-1.; }                   // triangle\n//float sinhz(float x) { return fract(x)*2.-1.; }                                 // saw\n//float sinhz(float x) { return sign(fract(x)-0.5); }                             // square\n//float sinhz(float x) { return smoothstep(-1.,1.,sin(x*6.28318530718))*2.-1.; }  // smoothsquare 1\n//float sinhz(float x) { return smoothstep(0.+0.15,0.5-0.15,abs(fract(x)-0.5))*2.-1.; }  // smoothsquare 2\n\n// Sine for modulation\nfloat sinhz_mod(float x) { return sin(6.28318530718 * x); }\n\n// Envelope:\n//   https://graphtoy.com/?f1(x,t)=sin(3.14159265359%20*%20x)&v1=true&f2(x,t)=smoothstep(0,1,x)&v2=true&f3(x,t)=sin(3.14159265359%20*%20smoothstep(0,1,x))&v3=true&f4(x,t)=smoothstep(0,1,smoothstep(0,1,x))&v4=true&f5(x,t)=sin(3.14159265359%20*%20smoothstep(0,1,smoothstep(0,1,x)))&v5=true&f6(x,t)=pow(sin(3.14159265359%20*%20x),%204)&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n// * https://graphtoy.com/?f1(x,t)=sin(3.14159265359*x)&v1=true&f2(x,t)=&v2=false&f3(x,t)=&v3=false&f4(x,t)=4*(x-x*x)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=2&coords=0.5,0.5,0.6666666666666666\n//float envelope(float x) { return sin(3.14159265359 * x); }\n//float envelope(float x) { return sin(3.14159265359 * smoothstep(0., 1., x)); }\n//float envelope(float x) { return sin(3.14159265359 * x); }\n//float envelope(float x) { return pow(4. * (x - x*x), 0.7); }\nfloat _envelope(float x) { return 4. * (x - x*x); }\nfloat envelope(float x) { return 1. - pow(1. - _envelope(x), 1.5); }\n\n// Skew:\n//   https://graphtoy.com/?f1(x,t)=sin(3.14159265359%20*%20x)&v1=true&f2(x,t)=pow(x,%202)&v2=false&f3(x,t)=pow(x,%200.4)&v3=true&f4(x,t)=sin(3.14159265359%20*%20pow(x,%202))&v4=false&f5(x,t)=sin(3.14159265359%20*%20pow(x,%200.4))&v5=true&f6(x,t)=sin(3.14159265359%20*%20(1-pow(1-x,%200.4)))&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n//   https://graphtoy.com/?f1(x,t)=sin(3.14159265359*x)&v1=true&f2(x,t)=4*(x-x*x)&v2=true&f3(x,t)=pow(x,0.4)&v3=true&f4(x,t)=f2(pow(x,2))&v4=false&f5(x,t)=f2(pow(x,0.4))&v5=true&f6(x,t)=f2(1-pow(1-x,0.4))&v6=true&grid=2&coords=0.5,0.5,0.6666666666666666\n//   https://graphtoy.com/?f1(x,t)=pow(pow(x*2-1,2)-1,2)&v1=true&f2(x,t)=pow(x,1/0.4)&v2=false&f3(x,t)=pow(pow(pow(x,1/0.4)*2-1,2)-1,2)&v3=true&f4(x,t)=pow(pow((1-pow(1-x,1/0.4))*2-1,2)-1,2)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0.5,0.5,0.6666666666666666\n// * https://graphtoy.com/?f1(x,t)=4*(x-x*x)&v1=true&f2(x,t)=pow(x,0.5)&v2=false&f3(x,t)=pow(1-x,0.5)&v3=false&f4(x,t)=&v4=false&f5(x,t)=f1(f2(x))&v5=true&f6(x,t)=f1(f3(x))&v6=true&grid=2&coords=0.5,0.5,0.6666666666666666\nfloat _skewf(float x, float n) { return pow(clamp(x, 0., 1.), n); }\nfloat _skew1(float x, float mid) { return _skewf(x, log(0.5)/log(mid)); }\nfloat skew(float x, float mid) { return mid <= 0.5 ? _skew1(x, mid) : _skew1(1. - x, 1. - mid); }\n//float skew(float x, float mid) { return _skew1(x, 0.5-abs(fract(mid)-0.5)); }\n\nfloat envMid(float x, float mid) { return envelope(skew(x, mid)); }\n\nfloat db2amp(float x) { return pow(10., (x-1.)*DYNRANGE_DB/20.); }\n\nfloat octf(float n) { return clamp((n - OCTAVEMIN)/(OCTAVEMAX - OCTAVEMIN), 0., 1.); }\n\n// Skew:\n//   https://graphtoy.com/?f1(x,t)=pow(x,%200.25)&v1=true&f2(x,t)=0.5&v2=true&f3(x,t)=log(0.5)/log(x)&v3=true&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=2&coords=0.5,0.5,0.6666666666666666\n\n// https://www.shadertoy.com/view/tlcfRn\nfloat sabs(float x, float k) { return sqrt(x * x + k * k); }\n// Better smooth abs functions with smooth 1st derivative and converging to linear: https://graphtoy.com/?f1(x,t)=mix(x,3,clamp(-x+3,0,3)/3/2)&v1=false&f2(x,t)=f1(abs(x))&v2=true&f3(x,t)=sqrt(x*x%20+%203*3)&v3=true&f4(x,t)=log(exp(x)+exp(3))%20+%20log(exp(-x)+exp(3))%20-%203&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=2.2601521561494273,5.57995368872829,23.26586969184914\n//float ssabs(float x, float k) { return mix(x, k, clamp(-x + k, 0. , k)/k/2.); }\n//float ssabs(float x, float k) { return x >= k? x : -sqrt(k*k/(0.7071067812*0.7071067812)-x*x)+k*2.; }\n//float ssabs(float x, float k) { return log(exp(x)+exp(k))+log(exp(-x)+exp(k))-k; }\nfloat ssabs(float x, float k) { return x > k*10. ? x : log(exp(x)+exp(k))+log(exp(-x)+exp(k))-k; }\n\nfloat sawtooth(float x, float len) { return abs(mod(x, len*2.) - len); }\n//float ssawtooth(float x, float len) { return sinhz(x/len)/2. + 0.5; }\nfloat ssawtooth(float x, float len, float trans) {\n    // https://graphtoy.com/?f1(x,t)=sqrt(x%20*%20x%20+%20.1%20*%20.1)&v1=true&f2(x,t)=mod(x,%2010)-5&v2=false&f3(x,t)=f1(f2(x))&v3=false&f4(x,t)=5-f3(x+5)&v4=false&f5(x,t)=0.5%20-%20cos(x*6.28318530718/10)/2&v5=false&f6(x,t)=mix(f4(x),%20f3(x),%20f5(x))&v6=true&grid=1&coords=1.5548003398470707,2.9056924384027223,9.91735537190086\n    float len2 = len/2.;\n    x += len2;\n    float ssaw_bot = sabs(mod(x, len) - len2, trans);\n    float ssaw_top = len2 - sabs(mod(x + len2, len) - len2, trans);\n    float mixk = 0.5 - cos(x*6.28318530718/len)/2.;\n    return mix(ssaw_top, ssaw_bot, mixk);\n}\n\nfloat timesawtooth(float x, float len, float trans) {\n    // https://graphtoy.com/?f1(x,t)=sqrt(x*x+.3*.3)&v1=false&f2(x,t)=exp(1/(5-x)/5)+4&v2=false&f3(x,t)=clamp(mod(x,5)-(5-0.3),%200,%201)&v3=false&f4(x,t)=&v4=false&f5(x,t)=mix(f1(x),%20f2(x),%20f3(x))&v5=false&f6(x,t)=f5(abs(mod(x+5,10)-5))&v6=true&grid=1&coords=2.314344811316915,2.631207494963487,14.446274591184533\n    float len2 = len/2.;\n#ifndef UPDOWN\n    x += len2;\n#endif\n    x = abs(mod(x + len2, len) - len2);\n    float smoothlow = ssabs(x, trans); // sabs(x, trans);\n    float xtrans = x - len2 + trans;\n    if (xtrans <= 0.) return smoothlow;\n    float mixk = clamp(xtrans, 0., trans) / trans;\n    // https://graphtoy.com/?f1(x,t)=tan(tan(x/3%20*%20atan(atan(100./3))))*3%20+%205%20-%203&v1=true&f2(x,t)=f1(3)&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=-1.1158959084603164,1.2951708211315938,8.154545393121996\n    float peak = tan(tan(xtrans/trans * atan(atan(10.))))*trans + len2 - trans;\n    return mix(smoothlow, peak, mixk);\n}\n\n#define RANGE   (1./SPD)\n#define STEP    (1./TONES_PER_OCTAVE)\n", "sound_code": "vec2 mainSound( int samp, float time )\n{\n    time = timesawtooth(time, TIMEPERIOD, TIMETRANS);\n\n    float t = mod(time, RANGE);                        // time = [0 .. RANGE]\n    float tf = t / RANGE;                              // time = [0 .. 1]\n    // https://graphtoy.com/?f1(x,t)=&v1=false&f2(x,t)=exp(x*log(2))&v2=true&f3(x,t)=pow(2,%20x*log(2))&v3=true&f4(x,t)=(exp(x*log(2))-1)%20/%203&v4=true&f5(x,t)=((exp(x*log(2))-1)%20/%203)%20+%201&v5=true&f6(x,t)=&v6=false&grid=1&coords=0.7276582190451031,1.6451697223764041,3.8041556081466807\n    float tfe = (exp2(tf) - 1.) / (exp2(RANGE) - 1.);  // exp time = [0..1]\n    float tfe1 = tfe + 1.;                             // exp time = [1..2]\n\n    float v = 0.;\n\n    float iter = floor(time / RANGE);\n    for (float i = floor(OCTAVEMIN); i < ceil(OCTAVEMAX); i+=STEP) {\n        float f = octave2freq(tf+i);\n        if (f < FREQMIN || f > FREQMAX) continue;\n        v += sinhz(f*(t + i*RANGE)) * db2amp(envMid(octf(tf+i), octf(PEAKOCTAVE)));\n    }\n\n#ifdef MODULATE_BY\n    v *= abs(sinhz_mod(MODULATE_BY / 2. * time));\n#endif\n\n    return vec2(v/(OCTAVEMAX - OCTAVEMIN)*STEP);\n}\n\n", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2fRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 204, 204, 407], [409, 409, 466, 568, 1930]], "test": "untested"}
{"id": "DsBfzm", "name": "Starfield (again)", "author": "cedricl", "description": "this is a test", "tags": ["stars"], "likes": 24, "viewed": 737, "published": 3, "date": "1689548070", "time_retrieved": "2024-07-30T17:44:26.412212", "image_code": "float rand2(vec2 co) { return fract(sin(dot(co, vec2(12.9898, 70.233))) * 43758.5453); }\nvec2 Rot(vec2 p, float th) { return vec2(p.x*cos(th)-p.y*sin(th), p.x*sin(th)+p.y*cos(th)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; \n    vec3 r = normalize(vec3(Rot(uv - vec2(.5, .5 + .35*sin(.157 * iTime)), .4 * sin(.3 * iTime)), 1.));\n    fragColor = vec4(0,0,0,1);\n    \n    for(float a = 0.015; a < .3; a += .012)\n    {\n        float k = -a / r.y;\n        vec2 m = (k * r.xz * vec2(10., 20.3 * a)) - vec2(23. * rand2(vec2(a)) , sign(r.y) * .15 * iTime);\n        vec3 col2 = vec3(rand2(floor(m * 60.)) < .97);       \n        float p = smoothstep(.8, .9, (1. - 2. * length(fract(m * 60.) - vec2(.5))));\n        col2 = p * smoothstep(.5, .3, col2) / pow(abs(k), .9);\n        float p2 = 1. - 2. * length(fract(m * 3.) - vec2(.5));\n        col2 += pow(p2, 2.) * vec3(.3,0,.3) * rand2(floor(m * 3.));        \n        fragColor.xyz = max(fragColor.xyz, pow(abs(r.y), .4) * col2 / (20. * a + 1.));\n    }\n    \n    fragColor.xyz += 1.3 * (1. - 1.4 * abs(r.x)) * (pow(1. - abs(r.y), 2.) * vec3(.0, .2, .8) + pow(1. - abs(r.y), 40.4) * vec3(.1, .7, .95));\n    fragColor.xyz += .9 * pow(1. - 2. * length(r.xy), 6.);\n}", "image_inputs": [], "sound_code": "float wf(float t, float ramp, float pulse) { return 2. * ((smoothstep(0., ramp, fract(t)) - smoothstep(ramp + pulse, 1., fract(t))) - .5); }\nfloat PSin(float t) { return .5 + .5 * sin(t); }\nfloat S(float time) { return wf(55. * time, .3 * PSin(.3*time) + .02, .5) \n                            + wf(55.3 * time, .15 * PSin(.3*time) + .02, .5) \n                            + wf(55. * (4./3.) * time, .15 * PSin(.3*time) + .05, .5); }\n\nvec2 mainSound( int samp, float time )\n{\n    return .05*vec2( S(time) + .5*S(time-.7), S(time + .3) + .5*S(time - .4));\n}\n\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 88], [89, 89, 117, 117, 182], [184, 184, 241, 241, 1257]], "test": "untested"}
{"id": "ddSfzw", "name": "SynthEyes Lens Distortion", "author": "KartaVR", "description": "License: Apache 2.0\n\nBased Upon:\n- aleklesovoi CRT TV Shader Shadertoy Example (https://www.shadertoy.com/view/DldXWS)\n- SynthEyes Lens Distortion (http://www.ssontech.com/content/lensalg.htm)", "tags": ["distortion", "lens"], "likes": 2, "viewed": 242, "published": 3, "date": "1689540114", "time_retrieved": "2024-07-30T17:44:27.181156", "image_code": "// SynthEyes Lens Distortion\n\n// Open-Source License:\n// Apache 2.0\n\n// Fragment Shader Based Upon:\n// aleklesovoi's \"CRT TV Shader\" Shadertoy Example (https://www.shadertoy.com/view/DldXWS)\n\n// SynthEyes Lens Distortion:\n// http://www.ssontech.com/content/lensalg.htm\n\nvec2 SynthEyesDistortion(in vec2 uv, float aspect)\n{\n    // Distortion\n    float kCoeff = 0.1;\n    float kCube = 0.8;\n\n    // SynthEyes uses UV coordinates with a [-1:1] range\n    uv = (uv * 2.0) - 1.0;\n\n    // Compute the distortion\n    float r2 = (aspect * aspect) * (uv.x * uv.x) + (uv.y * uv.y);\n    float f = 1.0 + r2 * (kCoeff * kCube * sqrt(r2));\n\n    uv.x *= f;\n    uv.y *= f;\n\n    // Transform the UV coordinates back to a [0:1] range\n    uv = (uv * 0.5) + 0.5;\n\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Use a \"Screen Space\" UV Coordinate [0;1] range\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    // Apply the lens distortion\n    uv = SynthEyesDistortion(uv, aspect);\n    vec3 result = texture(iChannel0, uv).rgb;\n\n    // Return the final output\n    fragColor = vec4(result, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSfzw.jpg", "access": "api", "license": "free-unknown", "functions": [[270, 270, 322, 340, 758], [760, 760, 815, 869, 1159]], "test": "untested"}
{"id": "cdBfzw", "name": "Mergesort", "author": "fad", "description": "Stable mergesort where each merge is done in a single pass for a total of log(n) passes. Each pixel does O(log(n)) work each pass so O(n*log(n)^2) total time complexity. Sorts 1080p in ceil(log(1920*1080))=21 frames.", "tags": ["sort", "merge", "parallel", "stable"], "likes": 7, "viewed": 344, "published": 3, "date": "1689535338", "time_retrieved": "2024-07-30T17:44:28.017919", "image_code": "void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "bool lessThan_(vec4 a, vec4 b) {\n    // Comparison function for sorting\n    return length(a.rgb) < length(b.rgb);\n}\n\nvec4 get(int i) {\n    int w = textureSize(iChannel0, 0).x;\n    return texelFetch(iChannel0, ivec2(i % w, i / w), 0);\n}\n\nbool lessThan_(vec4 a, int i, vec4 b, int j) {\n    // Comparison function that uses pixel index for stable sort\n    return lessThan_(a, b) ? true : lessThan_(b, a) ? false : i < j;\n}\n\nvec4 kth(int arr1, int m, int arr2, int n, int k) {\n    // Returns the kth element (zero-indexed) from the result of merging\n    // sorted arrays arr1 and arr2 with lengths m and n respectively in\n    // O(log(k)) time.\n    \n    // Taken with modification from\n    // https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/\n\n    // we do a little recursive tomfoolery\n    #define RECURSE(a, b, c, d, e) {             \\\n        int A = a, B = b, C = c, D = d, E = e;   \\\n        arr1 = A, m = B, arr2 = C, n = D, k = E; \\\n        continue;                                \\\n    }\n    \n    ++k; // original algorithm had k one-indexed\n    \n    while (true) {\n        if (k > m + n || k < 1) {\n            return vec4(0.0, 1.0, 0.0, 1.0);\n        }\n\n        if (m > n) {\n            RECURSE(arr2, n, arr1, m, k);\n        }\n\n        if (m == 0) {\n            return get(arr2 + k - 1);\n        }\n\n        if (k == 1) {\n            vec4 a = get(arr1);\n            vec4 b = get(arr2);\n            return lessThan_(a, arr1, b, arr2) ? a : b;\n        }\n\n        int i = min(m, k / 2);\n        int j = min(n, k / 2);\n        int ai = arr1 + i - 1;\n        int bi = arr2 + j - 1;\n\n        if (lessThan_(get(ai), ai, get(bi), bi)) {\n            RECURSE(arr1 + i, m - i, arr2, n, k - i);\n        }\n        \n        RECURSE(arr1, m, arr2 + j, n - j, k - j);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    ivec2 r = ivec2(iResolution);\n    ivec2 p = ivec2(fragCoord);\n    \n    if (iFrame == 0) {\n        // Initialize data to sort on first frame\n        fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n        return;\n    }\n    \n    int N = r.x * r.y;\n    int t = int(ceil(log2(float(N)))); // number of passes\n    int i = p.x + r.x * p.y;\n    \n    if (iFrame > t) {\n        // Sorting finished\n        fragColor = get(i);\n        return;\n    }\n    \n    int arr1 = i >> iFrame << iFrame;\n    int m = min(arr1 + (1 << iFrame - 1), N) - arr1;\n    int arr2 = arr1 + m;\n    int n = min(arr2 + m, N) - arr2;\n    int k = i - arr1;\n    fragColor = kth(arr1, m, arr2, n, k);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 114]], "test": "untested"}
{"id": "DsBfRm", "name": "Wave Refraction", "author": "fenix", "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n\nSimulating refraction with the wave equation, demonstrating total internal reflection and fresnel equations.\n\n* mouse: emit wave\n* space: reset", "tags": ["2d", "reflection", "wave", "simulation"], "likes": 11, "viewed": 219, "published": 3, "date": "1689534720", "time_retrieved": "2024-07-30T17:44:28.786863", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  Another wave equation shader! Here are some of my other ones if you like this one:\n//\n//      Wave Equation           https://shadertoy.com/view/csXfRS\n//      Parabolic Reflectors    https://shadertoy.com/view/DdffzB\n//      Courant Noise           https://shadertoy.com/view/cslBWX\n//\n//  This shader shows a wavefront refracting when hitting a medium boundary. The bottom\n//  half has a slower speed of light/sound than the upper half. So the bottom might be\n//  water or glass while the top is air. You can see in the waves evidence of total\n//  internal refraction and the fresnel equations.\n//\n//  Here again the incomplete absorbtion of the boundary bedevils me. Definitely\n//  interested in any ideas how to improve that.\n// ---------------------------------------------------------------------------------------\n\nvec4 getColorFromHeight(float d)\n{\n    vec4 c = sin(d * 6e2 * vec4(9, 2, 5, 0));\n    return pow(abs(c), vec4(3));\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float wh = texelFetch(iChannel0, ivec2(u), 0).x; // wave height\n\n    O = getColorFromHeight(wh); // colorize\n    \n    O += abs(u.y / iResolution.y - .5) < .01 ? vec4(.2) : vec4(0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, true); // true for last parameter => update state, emit waves\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define U(u) texelFetch(prevBuffer, ivec2(u), 0) //\nconst float FOCUS_DIST = .45;\n\n#define keyClick(ascii)   ( texelFetch(keyBuffer,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n\nconst float BOUND_GAMMA = .1; // damping factor for boundary\n\nvec2 initWave(vec2 u, vec2 c, vec2 R)\n{\n    vec2 delta = u - c;\n    float d2 = dot(delta, delta);\n\n    float df = sqrt(d2);\n    return 3. * R.x * vec2(sin(df), cos(df)) / (1. + d2 * 1e6);\n}\n\nvoid updateBuffer(out vec4 O, vec2 u, vec2 R, int iFrame, vec4 iMouse, sampler2D prevBuffer, sampler2D keyBuffer, bool bufferA)\n{\n    vec2 o = vec2(1, 0),\n         p = (u - .5 * R) / R.y;\n\n    vec4 state = texelFetch(prevBuffer, ivec2(0), 0);\n    \n    // handle persistent state\n    if (ivec2(u) == ivec2(0))\n    {\n        if (iFrame == 0 ||\n            state.w != R.x * R.y ||\n            keyClick(KEY_SPACE))\n        {\n            O = vec4(0);\n            O.w = R.x * R.y;\n            return;\n        }\n        \n        O = state;\n        \n        if (bufferA && ++O.z > 25.)\n            O.z = 0.;\n        \n        return;\n    }\n    \n    if (iFrame == 0 ||\n        state.w != R.x * R.y ||\n        keyClick(KEY_SPACE))\n    {\n        // init\n        O = vec4(0);\n        return;\n    }\n    else\n    {\n        float C = p.y > 0. ? .5 : .2; // lower wave speed in lower half\n\n        O = U(u).xxyy; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n\n        if (int(u.y) < 5)\n            O.x = O.x - C * (O.x - U(u + o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing bottom boundary\n        else if (int(u.y) == int(R.y) - 1)\n            O.x = O.x - C * (O.x - U(u - o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing top boundary\n        else if (int(u.x) == 0)\n            O.x = O.x - C * (O - U(u + o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing left boundary\n        else if (int(u.x) == int(R.x) - 1)\n            O.x = O.x - C * (O - U(u - o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing right boundary\n        else\n            O.x = -O.z + 2.*O.x + C*(U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx) - 4. * O).x; // apply wave equation\n    }\n\n    if (bufferA)\n    {\n        vec2 h = vec2(.5, .4);\n        \n        // add disturbance at the center\n        if (state.z < 1. || iFrame == 0)\n            O.xy += initWave(u, h * R.xy, R);\n\n        // add disturbance for mouse click\n        if (iMouse.z > 0. && (state.z < 1. || iMouse.w > 0.))\n            O.xy += initWave(u, iMouse.xy, R);\n    }\n    \n    O *= .9995;\n}\n\n", "buffer_b_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBfRm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1138, 1138, 1172, 1172, 1253], [1255, 1255, 1293, 1293, 1480]], "test": "untested"}
{"id": "dd2BR1", "name": "Fork: It is alive...with music!", "author": "QuantumSuper", "description": "Added some auto-VJ capabilities to the organic beauty of coleda\n\n- Use with music in iChannel0 of Buffer A - ", "tags": ["procedural", "raymarching", "noise", "music", "organic"], "likes": 23, "viewed": 645, "published": 3, "date": "1689532268", "time_retrieved": "2024-07-30T17:44:29.884927", "image_code": "// Fork (0.2.230716) of \"It is alive...\"\n// Original by coledea at https://www.shadertoy.com/view/ctcGR8\n// mainly added auto-vj capabilities\n// \n// - use with music in iChannel0 of Buffer A -\n\n#define PI 3.14159265359\n#define aTime 2.133333*iTime\n\nconst int MAX_MARCHING_STEPS = 80;\nconst float MARCHING_EPSILON = 0.0001;\nconst float DERIVATIVE_EPSILON = 0.001;\n\n// LIGHTING\nconst vec3 ALBEDO_INNER = vec3(3.0, 0.02, 0.03);\nconst vec3 ALBEDO_OUTER = vec3(0.3, 0.0, 0.0);\nconst vec3 ALBEDO_CREASES = vec3(0.0, 0.0, 0.01);\n\n// SCENE\nconst vec3 SPHERE_CENTER = vec3(0.0);\nconst float SPHERE_RADIUS = .4;\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\n//======================================\n// HELPER FUNCTIONS\n//======================================\n\nvoid compressFft(){ //here just reads compressed amplitudes from buffer\n    for (int n=0;n<4;n++)\n        fft[n] = texelFetch( iChannel0, ivec2(n,0), 0 ).a,\n        ffts[n] = texelFetch( iChannel0, ivec2(n+4,0), 0 ).a;\n}\n\nvec2 spherical_mapping(vec2 normal)\n{\n    //return normal / 2.0 + 0.5;  // simpler approximation, leads to distortions at the poles\n    return vec2(asin(normal.x), asin(normal.y)) / PI + 0.5;\n}\n\n// From: https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), \n              dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\n\n// From: https://github.com/MaxBittker/glsl-voronoi-noise\nvec3 voronoi3d(const in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3(b) - f + hash(p + b);\n        float d = dot(r, r);\n\n        float cond = max(sign(res.x - d), 0.0);\n        float nCond = 1.0 - cond;\n\n        float cond2 = nCond * max(sign(res.y - d), 0.0);\n        float nCond2 = 1.0 - cond2;\n\n        id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n        res = vec2(d, res.x) * cond + res * nCond;\n\n        res.y = cond2 * d + nCond2 * res.y;\n      }\n    }\n  }\n\n  return vec3(sqrt(res), abs(id));\n}\n\n\n//======================================\n// SCENE DEFINITION\n//======================================\n\nfloat organic_displacement(vec2 normal)\n{   \n    vec2 uv = spherical_mapping(normal);\n    return texture(iChannel0, uv).x;\n}\n\nfloat distToSphere(vec3 center, float radius, vec3 queryPoint)\n{\n    return length(center - queryPoint) - radius;\n}\n\n// returns distance to scene and displacement value from texture\nvec2 distToScene(vec3 queryPoint)\n{\n    float displacement = organic_displacement(normalize(queryPoint - SPHERE_CENTER).xy);\n    float dist = length(SPHERE_CENTER - queryPoint) - (SPHERE_RADIUS + displacement);     // big sphere\n    \n    float sinTime = sin(iTime + fft.x*PI) * 0.2;\n    float cosTime = cos(aTime/4. + fft.y*PI) * 0.2;\n    dist = smin(dist, distToSphere(vec3(sinTime * sinTime, cosTime, sinTime), 0.5*pow(fft.x,9.), queryPoint), 0.4+ffts.x*.3); // first small sphere\n    dist = smin(dist, distToSphere(vec3(sinTime, sinTime * cosTime, cosTime), 0.3*fft.y, queryPoint), 0.3+.3*ffts.y); // second small sphere\n    dist = smin(dist, distToSphere(vec3(cosTime * cosTime, sinTime, sinTime * cosTime), 0.2*fft.z, queryPoint), 0.2+.2*ffts.z); // third small sphere\n    return vec2(dist, displacement);\n}\n\n//======================================\n// GENERAL LIGHTING\n//======================================\nvec3 normal(vec3 p)\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * distToScene(p + k.xyy * DERIVATIVE_EPSILON).x + \n                      k.yyx * distToScene(p + k.yyx * DERIVATIVE_EPSILON).x + \n                      k.yxy * distToScene(p + k.yxy * DERIVATIVE_EPSILON).x + \n                      k.xxx * distToScene(p + k.xxx * DERIVATIVE_EPSILON).x);\n}\n\n\n//======================================\n// PBR from  https://learnopengl.com/PBR/Lighting\n//======================================\n\n// Fresnel-Schlick approximation\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}  \n\n// normal distribution (for depicting roughness)\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\n// self-occlusion\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 lightPBR(vec3 point, vec3 lightPositions[2], vec3 lightColors[2], vec3 eye, float material)\n{\n   // doesn't work for some reason\n   /* vec2 materialDerivatives = vec2(dFdx(material), dFdy(material));\n    float materialChange = 10000.0 * (materialDerivatives.x + materialDerivatives.y);\n    vec3 albedo = vec3(materialChange);*/\n\n    vec3 albedo = mix(ALBEDO_OUTER, ALBEDO_INNER, smoothstep(0.05, 0.08, material));\n    //albedo = mix(ALBEDO_CREASES, albedo, step(0.01, material));\n\n    //float metallic = 0.1 * smoothstep(0.05, 0.08, material);\n    float metallic = .0;\n    float roughness = 0.1 + 0.4 * (1.0 - smoothstep(0.07, 0.08, material)); //0.5;\n    float ao = smoothstep(0.05, 0.09, material);\n\n    vec3 N = normal(point); \n    N = normalize(N);\n    vec3 V = normalize(eye - point);\n\n    vec3 F0 = vec3(0.04); // approximate base reflectivity for dielectrics\n    F0 = mix(F0, albedo, metallic);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    \n    for(int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - point);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - point);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;        \n        \n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metallic;\t  // metallic surfaces do not have diffuse reflection (refraction)\n        \n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n        vec3 specular     = numerator / denominator;  \n            \n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n    }   \n  \n    // add ambient term\n    vec3 ambient = vec3(0.03) * albedo * ao;\n    vec3 color = ambient + Lo;\n\t\n    // HDR tone mapping and gamma correction\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));  \n   \n    return color;\n}\n\n//======================================\n// RAYMARCHING\n//======================================\n\nvec3 getRayDirection(vec3 eye, vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n    vec3 ww = normalize(vec3(0.0) - eye);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    return normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    compressFft(); //initializes fft, ffts\n    \n    vec3 eye = vec3(sin(iTime * 0.05 + pow(sin(aTime/16.),9.)*PI) * 0.5 + 0.1, 0.0, 1.8);\n    vec3 ray = getRayDirection(eye, fragCoord);\n    \n    vec3 lightPos[2] = vec3[2](vec3(2.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0));\n    vec3 lightColors[2] = vec3[2](vec3(1.0), vec3(1.0));\n    \n    vec3 p = eye;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        \n        vec2 queryResult = distToScene(p);\n        float dist = queryResult.x;\n        float displacement = queryResult.y;\n        \n        if(dist < MARCHING_EPSILON){\n            fragColor = vec4(lightPBR(p, lightPos, lightColors, eye, displacement), 1.0);\n            return;\n        }\n        \n        p += ray * dist;\n    }\n    \n    // background\n    vec2 uv = fragCoord/iResolution.xy;\n    float organic = texture(iChannel0, uv).x;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = sin(iTime * 0.25) + uv * 6.0;\n    vec3 voronoi = voronoi3d(vec3(-6.0, uv))*.1*(1.+5.*fft.w);\n    float final = pow(voronoi.r * 3.0, organic * 10.0 * (1.+2.*fft.y));\n    uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y)*1.2;\n    final *= length(uv)*length(uv); //vignette\n    fragColor = vec4(final * .5 * ffts.w, 0., 0.015, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// BUFFER A (0.1) of Fork of \"It is alive...\"\n// Original by coledea at https://www.shadertoy.com/view/ctcGR8\n// mainly added auto-vj capabilities\n// \n// - use with music in iChannel0 of Buffer A -\n\n\n// I adapted the procedural texture from https://twigl.app/?ol=true&ss=-NNIajM4aEzy75lqtAUd\n\n#define DETAIL 20.0\n#define BASE_COLOR vec4(4, 2, 1, 0)\n#define ANIMATION_SPEED 2.0\n#define BRIGHTNESS 0.2\n#define STRUCTURE_SMOOTHNESS 1.2   // how washed out the result looks regarding structure\n#define SATURATION 0.2      // how crisp the result looks regarding colors/thickness of black lines\n\n#define aTime 2.133333*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    compressFft(); //initializes fft, ffts\n    \n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; // center (0,0) and handle aspect ratio\n    float dist_squared = dot(p,p);\n    float S = 9.0;\n    mat2 m = rotate2D(5.0);\n    \n    float a;\n    vec2 n,q;\n    \n    for(float j = 0.0; j++ < DETAIL;){\n      p *= m;\n      n *= m;\n      q = p * S + iTime *fft.x*0.01 * .15 * ANIMATION_SPEED + 1.8*sin((aTime/2. + fft.z*1.) * ANIMATION_SPEED - dist_squared * 6.0) * 0.8 + j + n;\n      a += dot(cos(q) / S, vec2(SATURATION));\n      n -= sin(q);\n      S *= STRUCTURE_SMOOTHNESS;\n    }\n    \n    float result = 0.2 * ((a + BRIGHTNESS) + a + a); \n    fragColor = vec4(result);\n    \n    if (fragCoord.y<1.)\n        if (fragCoord.x<8.)\n            fragColor.a = (fragCoord.x<4.)? fft[int(fragCoord.x)] : ffts[int(fragCoord.x)]; //save compressed amplitudes\n}", "buffer_a_inputs": [{"id": 33981, "src": "https://soundcloud.com/spor/strange-heart", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2BR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[757, 757, 776, 828, 977], [979, 979, 1016, 1110, 1172], [1174, 1221, 1262, 1262, 1346], [1349, 1349, 1368, 1368, 1549], [2472, 2472, 2513, 2513, 2596], [2598, 2598, 2662, 2662, 2713], [2715, 2780, 2815, 2815, 3592], [3594, 3696, 3717, 3717, 4065], [4201, 4234, 4280, 4280, 4354], [4358, 4407, 4463, 4463, 4730], [4732, 4750, 4806, 4806, 4961], [4963, 4963, 5025, 5025, 5243], [5245, 5245, 5343, 5577, 7599], [7699, 7699, 7747, 7747, 8001], [8004, 8004, 8061, 8061, 9314]], "test": "untested"}
{"id": "cslBWX", "name": "Courant Noise", "author": "fenix", "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n\nIn honor of Richard Courant, a pioneer of CFD. The wave speed is modulated by simplex noise.\n\n* mouse: emit wave\n* space: reset\n* shift: disable shadows", "tags": ["2d", "reflection", "wave", "simulation"], "likes": 23, "viewed": 329, "published": 3, "date": "1689525990", "time_retrieved": "2024-07-30T17:44:31.029866", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  One of the interesting things I learned from Mr. Berglund's video is that you can\n//  get some interesting effects with the wave equation by allowing the speed of wave\n//  propagation to vary spatially. My result looks very different from his, but I think\n//  it looks pretty interesting anyway.\n//\n//  I also learned that the constant that determine's the wave speed is called the\n//  Courant number:\n//\n//      https://www.idealsimulations.com/resources/courant-number-cfd/\n//\n//  I also learned that Richard Courant publushed a very early paper on computational\n//  fluid dynamics in 1928, \"Über die partiellen Differenzengleichungen der mathematischen\n//  Physik\", along with some other guys named Friederich, and Lewy (CFL), so I'm naming\n//  this shader in his honor. Hopefully the name doesn't get confused for a type of\n//  noise, because I'm just using 3D simplex noise from iq:\n//\n//      https://www.shadertoy.com/view/XsX3zB\n//\n//  Click and drag the mouse to emit more waves! Space to reset.\n//\n//  The simualtion itself is substantially the same as my previous shader this is\n//  branched from. The absorbing walls are still the same, but their deficiencies\n//  are not as obvious with all the motion. Mainly I just modulated the Courant\n//  number and then added some lighting and color. Lighting-wise, the only really\n//  interesting thing is the depth-based shadows (disable with shift).\n//  \n//  There are a couple of alternate color schemes available: change COLOR_SCHEME\n//  below. I can't decide...which one is best?\n//\n// ---------------------------------------------------------------------------------------\n\n#define COLOR_SCHEME 0 // choose 0, 1, or 2\n\nvec2 gradient(vec2 fragCoord)\n{\n    if (fragCoord.y == iResolution.y - .5) return vec2(0);\n    \n    vec2 delta = vec2(1, 0);\n    float xGrad = texture(iChannel0, (fragCoord + delta.xy) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.xy) / iResolution.xy).a;\n        \n    float yGrad = texture(iChannel0, (fragCoord + delta.yx) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.yx) / iResolution.xy).a;\n\n    return vec2(xGrad, yGrad);\n}\n\nvec4 getColorFromHeight(float d)\n{\n#if COLOR_SCHEME == 0\n    vec4 c = sin(d * 800. * vec4(9, 2, 5, 0));\n    return c * .7 + vec4(.02,.02,.3,0);\n#elif COLOR_SCHEME == 1\n    int i = int(pow(abs(d), .49) * 80.);\n    if (i <= 0) return vec4(.02,.02,.3,0);\n    switch(i)\n    {\n        case 1: return vec4(1.0, 0.0, 0.0, 2.0);\n        case 2: return vec4(1.0, 0.5, 0.0, 3.0);\n        case 3: return vec4(1.0, 1.0, 0.0, 4.0);\n        case 4: return vec4(0.0, 1.0, 0.0, 5.0);\n        case 5: return vec4(0.0, 0.0, 1.0, 6.0);\n        case 6: return vec4(0.25, 0.0, 0.5, 7.0);\n        default: case 7: return vec4(0.5, 0.0, 0.7, 8.0);\n    }    \n#else\n    vec4 c = pow(abs(d), .5) * vec4(1, .4, .2, 0) * 70. + .2;\n    return c;\n#endif\n}\n\nfloat computeShadow(vec2 u, float pd)\n{\n    if (keyDown(KEY_SHIFT)) return 1.;\n    \n    vec2 del = vec2(-1, 1);\n    float sh = 1.;\n    for (float i = 0.; i < 20.; ++i)\n    {\n        u += del;\n        float nd = texelFetch(iChannel0, ivec2(u), 0).x;\n        sh *= smoothstep(nd + float(i) * 5e-7, nd + float(i) * 1e-6, pd);\n    }\n    \n    return sh;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 g = -gradient(u);\n    \n    const vec3 ld = normalize(vec3(-1, 1, 1)); // light dir\n    const vec3 vd = vec3(0, 0, 1); // view dir\n    \n    float wh = texelFetch(iChannel0, ivec2(u), 0).x; // wave height\n    float sh = computeShadow(u, wh); // shadow\n    vec3 n = normalize(vec3(g, .0001)); // normal\n    O = vec4(dot(n, ld)) * (sh * .5 + .5); // diffuse\n\n    O *= getColorFromHeight(wh); // colorize\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, true); // true for last parameter => update state, emit waves\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define U(u) texelFetch(prevBuffer, ivec2(u), 0) //\nconst float FOCUS_DIST = .45;\n\n// From iq's 3d simplex noise: https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c)\n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n#define keyClick(ascii)   ( texelFetch(keyBuffer,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n\nconst float BOUND_GAMMA = .01; // damping factor for boundary\n\nvec2 initWave(vec2 u, vec2 c, vec2 R)\n{\n    vec2 delta = u - c;\n    float d2 = dot(delta, delta);\n\n    float df = sqrt(d2);\n    return 3. * R.x * vec2(sin(df), cos(df)) / (1. + d2 * 1e6);\n}\n\nvoid updateBuffer(out vec4 O, vec2 u, vec2 R, int iFrame, vec4 iMouse, sampler2D prevBuffer, sampler2D keyBuffer, bool bufferA)\n{\n    vec2 o = vec2(1, 0),\n         p = (u - .5 * R) / R.y;\n\n    vec4 state = texelFetch(prevBuffer, ivec2(0), 0);\n    \n    // handle persistent state\n    if (ivec2(u) == ivec2(0))\n    {\n        if (iFrame == 0 ||\n            state.w != R.x * R.y ||\n            keyClick(KEY_SPACE))\n        {\n            O = vec4(0);\n            O.w = R.x * R.y;\n            return;\n        }\n        \n        O = state;\n        \n        if (bufferA && ++O.z > 10.)\n            O.z = 0.;\n        \n        return;\n    }\n    \n    if (iFrame == 0 ||\n        state.w != R.x * R.y ||\n        keyClick(KEY_SPACE))\n    {\n        // init\n        O = vec4(0);\n        return;\n    }\n    else\n    {\n        float C = simplex3d_fractal(vec3(p * 10., float(iFrame) * .01)); // Courant\n        C = .5 * pow(C * .5 + .5, 4.);\n\n        O = U(u).xxyy; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n\n        if (int(u.y) < 5)\n            O.x = O.x - C * (O.x - U(u + o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing bottom boundary\n        else if (int(u.y) == int(R.y) - 1)\n            O.x = O.x - C * (O.x - U(u - o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing top boundary\n        else if (int(u.x) == 0)\n            O.x = O.x - C * (O - U(u + o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing left boundary\n        else if (int(u.x) == int(R.x) - 1)\n            O.x = O.x - C * (O - U(u - o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing right boundary\n        else\n            O.x = -O.z + 2.*O.x + C*(U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx) - 4. * O).x; // apply wave equation\n    }\n\n    if (bufferA)\n    {\n        vec2 h = vec2(.5);\n        \n        // add disturbance at the center\n        if (state.z < 1. || iFrame == 0)\n            O.xy += initWave(u, h * R.xy, R);\n\n        // add disturbance for mouse click\n        if (iMouse.z > 0. && (state.z < 1. || iMouse.w > 0.))\n            O.xy += initWave(u, iMouse.xy, R);\n    }\n    \n    O *= .9995;\n}\n\n", "buffer_b_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslBWX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1995, 1995, 2026, 2026, 2470], [2472, 2472, 2506, 2506, 3197], [3199, 3199, 3238, 3238, 3549], [3551, 3551, 3589, 3589, 4000]], "test": "untested"}
{"id": "dsjBzD", "name": "Weird Splats [257 Chars]", "author": "SnoopethDuckDuck", "description": "Golfing always welcome!", "tags": ["tweet", "onetweet", "golf", "wavelets", "300chars"], "likes": 21, "viewed": 210, "published": 3, "date": "1689518447", "time_retrieved": "2024-07-30T17:44:31.803797", "image_code": "void mainImage( out vec4 O, vec2 I )\n{  \n    I = 4. * I / iResolution.y + 1e2 + .4 * iTime;   \n    mat2 M = -mat2(.766,.643, -.643,.766); // rot(a = 21*pi/27)\n    O -= O;\n    for (int i; i++ < 27;) {   \n        I *= M;\n        //pow(fract(I.y), 2.); is good too\n        O.x += pow(4. * fract(I.y) * (1. - fract(I.y)), 40.);\n        O.y += cos(2. * O.x);\n        O.yz *= M;\n        O.z += cos(O.y);\n        O.zw *= M;\n        O.w += cos(O.z);\n    }\n    O = tanh(.5 * O.yyyy);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 480]], "test": "untested"}
{"id": "Ds2fRD", "name": "Halftone effect", "author": "SoldatovAndrey", "description": "This shader simulates printing CMYK dots on white paper. This can be useful for generating dynamic newspaper/magazine effect on arbitrary texture.", "tags": ["postprocessing", "halftone", "cmyk", "analog", "print"], "likes": 4, "viewed": 231, "published": 3, "date": "1689504887", "time_retrieved": "2024-07-30T17:44:32.686437", "image_code": "// Convert rgb color to cmyk\nvec4 cmyk(vec3 c) {\n    float k = 1.0 - max(c.r, max(c.g, c.b));\n    return vec4(\n        (1.0 - c.r - k) / (1.0 - k),\n        (1.0 - c.g - k) / (1.0 - k),\n        (1.0 - c.b - k) / (1.0 - k),\n        k\n    );\n}\n\n// Grid pattern rotated by 'a' radians with the density 'dens'\nvec2 grid(vec2 uv, float a, float dens) {\n    vec2 aspect = iResolution.xy / iResolution.y;\n    return vec2(\n        mod(((uv.x * aspect.x) * cos(a) - uv.y * sin(a)) * dens, 1.0), \n        mod(((uv.x * aspect.x) * sin(a) + uv.y * cos(a)) * dens, 1.0)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    //Color of the image, converted to cmyk\n    vec4 cmyk = cmyk(col);\n    \n    //Density of the dots\n    float dens = 100.0;\n    \n    //Rotation angles for different ink colors\n    //http://the-print-guide.blogspot.com/2009/05/halftone-screen-angles.html\n    float ca = 0.261;\n    float ma = 1.309;\n    float ya = 0.0;\n    float ka = 0.785;\n    \n    vec2 cgrid = grid(uv, ca, dens);\n    \n    float cb = cmyk.x * 0.8 / length(cgrid - vec2(0.5));\n    cb = pow(cb, 5.0);\n    cb = max(min(cb, 1.0), 0.0);\n    vec3 cv = vec3(cb, 0.0, 0.0);\n    \n    vec2 mgrid = grid(uv, ma, dens);\n    \n    float mb = cmyk.y * 0.9 / length(mgrid - vec2(0.5));\n    mb = pow(mb, 5.0);\n    mb = max(min(mb, 1.0), 0.0);\n    vec3 mv = vec3(0.0, mb, 0.0);\n    \n    vec2 ygrid = grid(uv, ya, dens);\n    \n    float yb = cmyk.z * 0.8 / length(ygrid - vec2(0.5));\n    yb = pow(yb, 5.0);\n    yb = max(min(yb, 1.0), 0.0);\n    vec3 yv = vec3(0.0, 0.0, yb);\n    \n    vec2 kgrid = grid(uv, ka, dens);\n    \n    float kb = cmyk.w * 0.6 / length(kgrid - vec2(0.5));\n    kb = pow(kb, 5.0);\n    kb = max(min(kb, 1.0), 0.0);\n    vec3 kv = vec3(kb);\n\n    // Output to screen\n    fragColor = vec4(vec3(1.0) - cv - mv - yv - kv,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2fRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 48, 48, 240], [242, 305, 346, 346, 564], [566, 566, 623, 673, 1954]], "test": "untested"}
{"id": "ddXBRS", "name": "GGX Ray tracer using Structs", "author": "SpinningCube", "description": "Implementation of the GGX specular BRDF in a ray tracer. I decided to use structs to keep the code organized.", "tags": ["3d", "raytracing", "pbr", "ggx"], "likes": 4, "viewed": 246, "published": 3, "date": "1689461165", "time_retrieved": "2024-07-30T17:44:33.593013", "image_code": "const float pi = 3.1415926536;\nconst float maxDist = 1000.0;\nconst float epsilon = 0.001;\n\nstruct Material {\n    vec3 color;\n    bool lit;\n    float roughness;\n};\n\n\n/* List of materials */\n\nMaterial sky = Material(2.5 * vec3(0.1, 0.5, 1.0), false, 0.0);\nMaterial mat0 = Material(vec3(0.3), true, 0.3);\nMaterial matRed = Material(vec3(0.6, 0.05, 0.02), true, 0.1);\n\nstruct SurfacePoint {\n    vec3 pos;\n    vec3 normal;\n    vec3 incidentRayDir;\n    Material material;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Intersection {\n    float depth;\n    vec3 normal;\n    Material material;\n};\n\nSurfacePoint getSurfacePoint(Ray ray, Intersection hit) {\n    SurfacePoint surface = SurfacePoint(ray.origin + ray.dir * hit.depth, hit.normal, ray.dir, hit.material);\n    \n    // mat0 Checkerboard texture\n    if (surface.material == mat0) {\n       surface.material.color = mix(surface.material.color, vec3(0.05), floor(mod(surface.pos.x + floor(mod(surface.pos.z, 2.0)), 2.0)));\n    }\n    return surface;\n}\n\n/**\n * Returns the closer of two intersections\n */\nIntersection nearest(Intersection current, Intersection new) {\n    if (new.depth < current.depth && new.depth > 0.0) {\n        return new;\n    }\n    return current;\n}\n\n\n/* Intersection Functions */\n\nIntersection sphere(Ray ray, vec3 pos, float radius, Material material) {\n    vec3 offset = pos - ray.origin;\n    float dot1 = dot(offset, ray.dir);\n    if (dot1 < 0.0) {\n        return Intersection(-1.0, vec3(0), material);\n    }\n    float v = radius * radius - (dot(offset, offset) - dot1 * dot1);\n    if (v > 0.0) {\n        float near = sqrt(v);\n        float depth = dot1 - near;\n        vec3 normal = (ray.dir * depth - offset) / radius;\n        return Intersection(depth, normal, material);\n    }\n    return Intersection(-1.0, vec3(0), material);\n}\n\nIntersection plane(Ray ray, vec3 normal, float dist, Material material) {\n    return Intersection(-(dot(ray.origin, normal) + dist)/dot(ray.dir, normal), normal, material);\n}\n\n/*\n * Ray intersection with the scene\n */\nIntersection raycast(Ray ray, float maxDist) {\n    Intersection hit = Intersection(maxDist, vec3(0), sky);\n    hit = nearest(hit, sphere(ray, vec3(0, 1, 5), 1.0, matRed));\n    hit = nearest(hit, plane(ray, vec3(0, 1, 0), 0., mat0));\n    return hit;\n}\n\n/*\n * Schlick's Approximation\n */\nfloat fresnel(float n1, float n2, vec3 normal, vec3 incident) {\n    float r0 = (n1 - n2)/(n1 + n2);\n    r0 *= r0;\n    float a = (1.0 - dot(normal, incident));\n    float b = a * a;\n    b *= b;\n    return r0 + (1.0 - r0) * (a * b);\n}\n\n/* \n * The GGX normal distribution function. This is\n * the D term of the GGX BRDF.\n */\nfloat ggxD(float alpha, float NdotH) {\n    float a2 = alpha * alpha;\n    float k = NdotH * NdotH * (a2 - 1.0) + 1.0;\n    return a2/(pi * k * k);\n}\n\n/*\n * The Smith shadowing/masking function for GGX.\n * This is G1, and is part of the G term of the GGX BRDF.\n */\nfloat ggxG1(float alpha, float VdotN) {\n    float a2 = alpha * alpha;\n    return 2.0 * VdotN/(VdotN + sqrt(a2 + VdotN * VdotN * (1.0 - a2)));\n}\n\n// Bi-directional Reflectance Distribution Function\nvec3 brdf(SurfacePoint surface, vec3 light, float NdotL) {\n    \n    // The microsurface normal, calculated as halfway between the light and incident directions.\n    vec3 halfway = normalize(light - surface.incidentRayDir);\n    \n    float NdotH = dot(halfway, surface.normal);\n    float alpha = surface.material.roughness * surface.material.roughness;\n    \n    // The D and G terms of the BRDF\n    float D = ggxD(alpha, NdotH);\n    float G = ggxG1(alpha, dot(-surface.incidentRayDir, surface.normal)) * ggxG1(alpha, dot(light, surface.normal));\n    \n    // GGX specular BRDF (without fresnel)\n    float specular = (G * D)/(4.0 * abs(dot(surface.normal, -surface.incidentRayDir)) * abs(NdotL));\n    \n    // Final output - mix between refraction and specular with fresnel\n    return mix(surface.material.color / pi, vec3(specular), fresnel(1.0, 1.5, halfway, -surface.incidentRayDir));\n}\n\nvec3 directionalLight(SurfacePoint surface, vec3 light, vec3 intensity, float dist) {\n    light = normalize(light);\n    float NdotL = dot(surface.normal, light);\n    return float(raycast(Ray(surface.pos + epsilon * surface.normal, light), dist).depth >= dist) * intensity * brdf(surface, light, NdotL) * max(0.0, NdotL);\n}\n\nvec3 directionalLight(SurfacePoint surface, vec3 light, vec3 intensity) {\n    return directionalLight(surface, light, intensity, maxDist);\n}\n\nvec3 pointLight(SurfacePoint surface, vec3 lightPos, vec3 intensity) {\n    vec3 light = lightPos - surface.pos;\n    float dist = length(light);\n    return directionalLight(surface, light, intensity/(dist * dist), dist);\n}\n\nvec3 lighting(SurfacePoint surface) {\n\n    Material mat = surface.material;\n    \n    vec3 col = mat.color;\n    if (mat.lit) {\n        col = directionalLight(surface, vec3(sin(iTime - 4.0), 1, cos(iTime - 4.0)), 30.0 * vec3(1));\n        col += mat.color * sky.color; // Ambient lighting, which is probably a little less accurate\n    }\n    \n    if (mat == sky) {\n        col.b += 10.0 * surface.incidentRayDir.y;\n        col.g -= 1.5 * surface.incidentRayDir.y;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 camPos = vec3(0, 1.0, 0);\n    \n    Ray ray = Ray(camPos, normalize(vec3(uv, 1.0)));\n    Intersection hit = raycast(ray, 10000.0);\n    \n    SurfacePoint surface = getSurfacePoint(ray, hit);\n    \n    float exposure = 1.0;\n    col = exposure * lighting(surface);\n    \n    // Lazy Tonemapping\n    col = vec3(atan(col.r), atan(col.g), atan(col.b))/(0.5 * pi);\n    \n    // Gamma Correction\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = hit.normal;\n    //col = vec3(uv, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[601, 601, 658, 658, 1008], [1010, 1061, 1123, 1123, 1227], [1260, 1260, 1333, 1333, 1814], [1816, 1816, 1889, 1889, 1990], [1992, 2034, 2080, 2080, 2284], [2286, 2320, 2383, 2383, 2551], [2553, 2641, 2679, 2679, 2787], [2789, 2903, 2942, 2942, 3046], [3048, 3100, 3158, 3260, 3984], [3986, 3986, 4071, 4071, 4308], [4310, 4310, 4383, 4383, 4450], [4452, 4452, 4522, 4522, 4673], [4675, 4675, 4712, 4712, 5158], [5160, 5160, 5217, 5267, 5967]], "test": "untested"}
{"id": "DsSfzh", "name": "Polar SDF Repetition (Bound)", "author": "tristanantonsen", "description": "Documenting polar repetition/arrays for SDFs (bound, not exact). Adapted from iq's \"Spherical Gears\" video. I tried to comment pretty heavily (this is mainly to help myself remember)", "tags": ["sdf", "repetition", "array", "polar"], "likes": 6, "viewed": 160, "published": 3, "date": "1689446478", "time_retrieved": "2024-07-30T17:44:34.354976", "image_code": "#define PI 3.141592653592\n\nfloat Circle(vec2 p, vec2 c, float r) {\n    return length(p-c) - r;\n}\n\nvec2 polarArray(vec2 p, float n, vec2 c, float a ) {\n    // p: the point to transform\n    // c: the center of the array\n    // a: the offset angle\n    \n    p = mat2(cos(a), -sin(a), sin(a), cos(a)) * p; //rotate in XY plane\n    \n    // Array parameters\n    float theta = 2. * PI / n;                    \n    float segment = round(atan(p.y,p.x) / theta); \n    float alpha = segment * theta;                \n    \n    vec2 q = p;\n    \n    q.xy = mat2(cos(alpha), -sin(alpha), sin(alpha), cos(alpha)) * q.xy; //rotate in XY plane\n    \n    return q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution .xy)/iResolution.y;\n    \n        \n    // Colors\n    vec3 col1 = vec3(244, 162, 97) / 255.; // yellow\n    vec3 col2 = vec3(231, 111, 81) / 255.; // orange\n    vec3 col3 = vec3(38, 70, 83) / 255.;   // blue\n    vec3 col4 = vec3(233, 196, 106) / 255.;   // green\n    \n    \n    vec2 p = uv; // the \"local\" coordinate point\n    \n    // Rotating the whole array\n    float a = 0.1*iTime;\n    p = mat2(cos(a), -sin(a), sin(a), cos(a)) * p; //rotate in XY plane\n    \n    \n    // Array parameters\n    float N = round(12. + 6.*sin(2.*iTime));      // Number of instances\n    float theta = 2. * PI / N;                    // angle between instances\n    float segment = round(atan(p.y,p.x) / theta); // the instance/segment number\n    float alpha = segment * theta;                // rotation angle\n    \n    \n    // Rotating each point back to position 0\n    vec2 q = p;\n    \n    // ==================================================\n    // 2D Rotation of point (x,y) by angle a in XY plane:\n    // | cos(a) -sin(a) || x |\n    // | sin(a)  cos(a) || y |\n    // ==================================================\n    \n    q.xy = mat2(cos(alpha), -sin(alpha), sin(alpha), cos(alpha)) * q.xy; //rotate in XY plane\n    \n    // Radius of polar array\n    float r = 0.35 + 0.1*sin(iTime);\n    \n    // distance/map function. This is the circle that will be arrayed\n    float d = Circle(q, vec2(r,0.), 0.05);\n\n    // Visualization\n    vec3 col = col1;\n    float c = abs(Circle(p, vec2(0.), r)) * mod(segment,2.); // segment colors\n    col = mix(col2, col, smoothstep(0.,1.,250.*c));          // array path\n    \n    // Axes\n    col = mix(vec3(1.), col, smoothstep(0.,1.,500.*abs(uv.x)));\n    col = mix(vec3(1.), col, smoothstep(0.,1.,500.*abs(uv.y)));\n    \n    // Array instances\n    col = mix(col3,col, smoothstep(0.,1.,200.*d));\n\n    \n    // Higlighting the starting instance\n    float f = Circle(p, vec2(r,0.), 0.05);\n    \n    col = mix(vec3(1.),col, smoothstep(0.,1.,400.*abs(f)));\n    \n       \n    // Version that packs it into a function\n    vec2 q2 = polarArray(uv, 8., vec2(0.), 0.);\n    float d2 = Circle(q2, vec2(0.15,0.), 0.025);\n    \n    col = mix(col4,col, smoothstep(0.,1.,200.*d2));\n    \n    fragColor = vec4(col,1.0);\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 66, 66, 96], [98, 98, 150, 244, 644], [646, 646, 703, 753, 3019]], "test": "untested"}
{"id": "dd2Bzh", "name": "S_1", "author": "abhiramTS", "description": "S1", "tags": ["pattern"], "likes": 1, "viewed": 145, "published": 3, "date": "1689445516", "time_retrieved": "2024-07-30T17:44:35.227642", "image_code": "\nvec3 palette(float t)\n{\n\tvec3 a = vec3(0.450, 0.450, 0.35);\n\tvec3 b = vec3(0.4, 0.5, 0.3);\n\tvec3 c = vec3(2., 3.0, 4.0);\n\tvec3 d = vec3(0.6, 0.5, 0.3);\n\n\treturn a + b * cos(6.28318 * (c * t + d));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 xy = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\tfloat t = iTime;\n\tconst float PI = 3.14159265358979323846264338327950288;\n\tfloat d0 = length(xy);\n\n\tvec3 fColor = vec3(0, 0, 0);\n\n\tfor (float i = 0.0; i < 3.0; i++)\n\t{\n\n\t\txy = fract(xy * (1. + (sin(.5 * PI * mod(t,11.) * d0)))) - 0.5;\n\n\t\tfloat d = length(xy);\n\n\t\tfloat p = sin(1. * PI * d + 0.75 * mod(t,17.));\n\t\tp = abs(p);\n\t\tfloat q = 2. * PI * p;\n\n\t\tfloat r = 1. - abs(sin(q) - p) / 2.;\n\t\tfloat g = 1. - abs(cos(q) - p) / 2.;\n\t\tfloat b = (pow(r, 2.) + pow(g, 2.));\n\n\t\tb = pow(0.1 / b, 0.5);\n\n\t\tvec3 col = palette(d0 * t * 0.01 * b);\n\n\t\tcol *= b;\n\n\t\tfColor += col;\n\t}\n\n\tfragColor = vec4(fColor-0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2Bzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 199], [200, 200, 255, 255, 928]], "test": "untested"}
{"id": "Dd2BR1", "name": "The control room", "author": "GetItemFromBlock", "description": "A mix of multiple shaders assembled in one big mess\nUse mouse to rotate the crewmate, and press space to change the crt effect\nSee Image tab for credits\n", "tags": ["3d", "screen", "crt", "postprocess", "room", "amongus", "sus", "amogus", "sussy"], "likes": 5, "viewed": 155, "published": 3, "date": "1689432931", "time_retrieved": "2024-07-30T17:44:36.409483", "image_code": "// Original shader (Image tab): \"Fnaf 3D shader\" by noClueBruh. https://shadertoy.com/view/DdsBzl\n\n// CRT shader (Buffer A): \"FixingPixelArt\" by TimothyLottes. https://www.shadertoy.com/view/XsjSzR\n\n// The rotating crewmate: \"3D low poly rotating Amogus\" by GetItemFromBlock. https://www.shadertoy.com/view/dsVXRm\n\nfloat str = 1.;\nfloat ok = 1.5;\n\nvec2 warp(vec2 inp)\n{\n    inp.y -= (inp.y - .5)* str * pow(abs(inp.x - .5), ok);\n    return inp;\n}\n\nvec4 col(vec2 inp)\n{\n    inp = fract(inp*5.);\n\n    if (inp.x < 0. || inp.x > 1. || inp.y < 0. || inp.y > 1.)\n    {\n        return vec4(0,0,0,1);\n    }\n    return texture(iChannel0, inp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = warp(fragCoord/iResolution.xy);\n    fragColor = col(uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TRIANGLE_COUNT 228\n\nstruct Triangle\n{\n    int a;\n    int na;\n    int b;\n    int nb;\n    int c;\n    int nc;\n    int col;\n};\n\nconst Triangle triangles[TRIANGLE_COUNT] = Triangle[TRIANGLE_COUNT](\n    Triangle(0, 1, 2, 3, 4, 5, 6),\n    Triangle(7, 8, 0, 1, 9, 10, 6),\n    Triangle(2, 3, 11, 12, 13, 14, 6),\n    Triangle(15, 16, 17, 18, 19, 20, 6),\n    Triangle(0, 1, 21, 22, 17, 18, 6),\n    Triangle(23, 24, 25, 26, 27, 28, 6),\n    Triangle(29, 30, 25, 26, 23, 24, 6),\n    Triangle(0, 1, 4, 5, 21, 22, 6),\n    Triangle(29, 30, 31, 32, 33, 34, 6),\n    Triangle(31, 32, 23, 24, 35, 36, 6),\n    Triangle(35, 36, 23, 24, 27, 28, 6),\n    Triangle(19, 20, 17, 18, 37, 38, 6),\n    Triangle(4, 5, 13, 14, 39, 40, 6),\n    Triangle(41, 42, 43, 44, 45, 46, 6),\n    Triangle(4, 5, 33, 34, 45, 46, 6),\n    Triangle(47, 48, 15, 16, 49, 50, 6),\n    Triangle(11, 12, 51, 52, 53, 54, 6),\n    Triangle(47, 48, 9, 10, 15, 16, 6),\n    Triangle(55, 56, 7, 8, 9, 10, 6),\n    Triangle(57, 58, 55, 56, 47, 48, 6),\n    Triangle(59, 60, 53, 54, 51, 52, 6),\n    Triangle(61, 62, 51, 52, 55, 56, 6),\n    Triangle(37, 38, 47, 48, 49, 50, 6),\n    Triangle(63, 64, 57, 58, 37, 38, 6),\n    Triangle(35, 36, 65, 66, 67, 68, 6),\n    Triangle(17, 18, 43, 44, 69, 70, 6),\n    Triangle(11, 12, 53, 54, 59, 60, 6),\n    Triangle(7, 8, 55, 56, 51, 52, 6),\n    Triangle(59, 60, 61, 62, 71, 72, 6),\n    Triangle(71, 72, 61, 62, 25, 26, 6),\n    Triangle(57, 58, 61, 62, 55, 56, 6),\n    Triangle(9, 10, 0, 1, 15, 16, 6),\n    Triangle(35, 36, 27, 28, 65, 66, 6),\n    Triangle(65, 66, 27, 28, 69, 70, 6),\n    Triangle(2, 3, 7, 8, 11, 12, 6),\n    Triangle(2, 3, 0, 1, 7, 8, 6),\n    Triangle(15, 16, 0, 1, 17, 18, 6),\n    Triangle(27, 28, 25, 26, 61, 62, 6),\n    Triangle(27, 28, 61, 62, 63, 64, 6),\n    Triangle(63, 64, 61, 62, 57, 58, 6),\n    Triangle(29, 30, 71, 72, 25, 26, 6),\n    Triangle(21, 22, 4, 5, 45, 46, 6),\n    Triangle(33, 34, 39, 40, 71, 72, 6),\n    Triangle(73, 74, 35, 36, 67, 68, 6),\n    Triangle(67, 68, 65, 66, 41, 42, 6),\n    Triangle(39, 40, 13, 14, 71, 72, 6),\n    Triangle(33, 34, 31, 32, 73, 74, 6),\n    Triangle(43, 44, 21, 22, 45, 46, 6),\n    Triangle(31, 32, 29, 30, 23, 24, 6),\n    Triangle(27, 28, 63, 64, 69, 70, 6),\n    Triangle(63, 64, 37, 38, 69, 70, 6),\n    Triangle(43, 44, 17, 18, 21, 22, 6),\n    Triangle(45, 46, 33, 34, 73, 74, 6),\n    Triangle(4, 5, 2, 3, 13, 14, 6),\n    Triangle(45, 46, 73, 74, 67, 68, 6),\n    Triangle(67, 68, 41, 42, 45, 46, 6),\n    Triangle(4, 5, 39, 40, 33, 34, 6),\n    Triangle(49, 50, 15, 16, 19, 20, 6),\n    Triangle(11, 12, 7, 8, 51, 52, 6),\n    Triangle(13, 14, 11, 12, 59, 60, 6),\n    Triangle(47, 48, 55, 56, 9, 10, 6),\n    Triangle(61, 62, 59, 60, 51, 52, 6),\n    Triangle(37, 38, 57, 58, 47, 48, 6),\n    Triangle(33, 34, 71, 72, 29, 30, 6),\n    Triangle(41, 42, 65, 66, 69, 70, 6),\n    Triangle(73, 74, 31, 32, 35, 36, 6),\n    Triangle(41, 42, 69, 70, 43, 44, 6),\n    Triangle(71, 72, 13, 14, 59, 60, 6),\n    Triangle(37, 38, 17, 18, 69, 70, 6),\n    Triangle(49, 50, 19, 20, 37, 38, 6),\n    Triangle(75, 76, 77, 78, 79, 80, 6),\n    Triangle(81, 82, 79, 80, 83, 84, 6),\n    Triangle(85, 86, 79, 80, 81, 82, 6),\n    Triangle(77, 78, 87, 88, 89, 90, 6),\n    Triangle(79, 80, 89, 90, 83, 84, 6),\n    Triangle(91, 92, 93, 94, 95, 96, 6),\n    Triangle(91, 92, 95, 96, 97, 98, 6),\n    Triangle(99, 100, 97, 98, 87, 88, 6),\n    Triangle(101, 102, 103, 104, 105, 106, 6),\n    Triangle(103, 104, 107, 108, 109, 110, 6),\n    Triangle(111, 112, 113, 114, 93, 94, 6),\n    Triangle(115, 116, 117, 118, 81, 82, 6),\n    Triangle(119, 120, 121, 122, 123, 124, 6),\n    Triangle(125, 126, 127, 128, 121, 122, 6),\n    Triangle(127, 128, 129, 130, 123, 124, 6),\n    Triangle(125, 126, 131, 132, 127, 128, 6),\n    Triangle(127, 128, 131, 132, 133, 134, 6),\n    Triangle(127, 128, 133, 134, 129, 130, 6),\n    Triangle(135, 136, 137, 138, 103, 104, 6),\n    Triangle(137, 138, 107, 108, 103, 104, 6),\n    Triangle(137, 138, 85, 86, 117, 118, 6),\n    Triangle(99, 100, 75, 76, 139, 140, 6),\n    Triangle(131, 132, 141, 142, 133, 134, 6),\n    Triangle(133, 134, 143, 144, 129, 130, 6),\n    Triangle(145, 146, 129, 130, 143, 144, 6),\n    Triangle(141, 142, 115, 116, 143, 144, 6),\n    Triangle(143, 144, 81, 82, 145, 146, 6),\n    Triangle(147, 148, 113, 114, 149, 150, 6),\n    Triangle(113, 114, 101, 102, 105, 106, 6),\n    Triangle(105, 106, 109, 110, 141, 142, 6),\n    Triangle(141, 142, 131, 132, 149, 150, 6),\n    Triangle(125, 126, 149, 150, 131, 132, 6),\n    Triangle(119, 120, 97, 98, 95, 96, 6),\n    Triangle(95, 96, 147, 148, 119, 120, 6),\n    Triangle(151, 152, 89, 90, 123, 124, 6),\n    Triangle(129, 130, 83, 84, 151, 152, 6),\n    Triangle(87, 88, 119, 120, 123, 124, 6),\n    Triangle(85, 86, 75, 76, 79, 80, 6),\n    Triangle(77, 78, 75, 76, 99, 100, 6),\n    Triangle(77, 78, 99, 100, 87, 88, 6),\n    Triangle(79, 80, 77, 78, 89, 90, 6),\n    Triangle(99, 100, 139, 140, 91, 92, 6),\n    Triangle(91, 92, 139, 140, 153, 154, 6),\n    Triangle(139, 140, 135, 136, 153, 154, 6),\n    Triangle(153, 154, 111, 112, 93, 94, 6),\n    Triangle(91, 92, 153, 154, 93, 94, 6),\n    Triangle(99, 100, 91, 92, 97, 98, 6),\n    Triangle(111, 112, 103, 104, 101, 102, 6),\n    Triangle(111, 112, 135, 136, 103, 104, 6),\n    Triangle(105, 106, 103, 104, 109, 110, 6),\n    Triangle(153, 154, 135, 136, 111, 112, 6),\n    Triangle(113, 114, 111, 112, 101, 102, 6),\n    Triangle(109, 110, 117, 118, 115, 116, 6),\n    Triangle(109, 110, 107, 108, 117, 118, 6),\n    Triangle(81, 82, 117, 118, 85, 86, 6),\n    Triangle(147, 148, 125, 126, 121, 122, 6),\n    Triangle(121, 122, 127, 128, 123, 124, 6),\n    Triangle(123, 124, 129, 130, 151, 152, 6),\n    Triangle(119, 120, 147, 148, 121, 122, 6),\n    Triangle(135, 136, 139, 140, 137, 138, 6),\n    Triangle(139, 140, 75, 76, 137, 138, 6),\n    Triangle(137, 138, 117, 118, 107, 108, 6),\n    Triangle(137, 138, 75, 76, 85, 86, 6),\n    Triangle(133, 134, 141, 142, 143, 144, 6),\n    Triangle(141, 142, 109, 110, 115, 116, 6),\n    Triangle(143, 144, 115, 116, 81, 82, 6),\n    Triangle(147, 148, 93, 94, 113, 114, 6),\n    Triangle(113, 114, 105, 106, 149, 150, 6),\n    Triangle(105, 106, 141, 142, 149, 150, 6),\n    Triangle(147, 148, 149, 150, 125, 126, 6),\n    Triangle(95, 96, 93, 94, 147, 148, 6),\n    Triangle(87, 88, 97, 98, 119, 120, 6),\n    Triangle(151, 152, 83, 84, 89, 90, 6),\n    Triangle(89, 90, 87, 88, 123, 124, 6),\n    Triangle(129, 130, 145, 146, 83, 84, 6),\n    Triangle(145, 146, 81, 82, 83, 84, 6),\n    Triangle(155, 156, 157, 158, 159, 160, 6),\n    Triangle(161, 162, 163, 164, 157, 158, 6),\n    Triangle(165, 166, 167, 168, 163, 164, 6),\n    Triangle(167, 168, 169, 170, 171, 172, 6),\n    Triangle(171, 172, 173, 174, 175, 176, 6),\n    Triangle(175, 176, 177, 178, 179, 180, 6),\n    Triangle(179, 180, 181, 182, 159, 160, 6),\n    Triangle(179, 180, 159, 160, 163, 164, 6),\n    Triangle(175, 176, 179, 180, 163, 164, 6),\n    Triangle(183, 156, 184, 185, 186, 187, 6),\n    Triangle(188, 162, 189, 190, 184, 185, 6),\n    Triangle(191, 192, 193, 194, 189, 190, 6),\n    Triangle(193, 194, 195, 196, 197, 198, 6),\n    Triangle(197, 198, 199, 200, 201, 202, 6),\n    Triangle(201, 202, 203, 204, 205, 206, 6),\n    Triangle(205, 206, 207, 178, 208, 209, 6),\n    Triangle(208, 209, 210, 182, 186, 187, 6),\n    Triangle(184, 185, 208, 209, 186, 187, 6),\n    Triangle(201, 202, 205, 206, 197, 198, 6),\n    Triangle(189, 190, 208, 209, 184, 185, 6),\n    Triangle(189, 190, 193, 194, 208, 209, 6),\n    Triangle(155, 156, 161, 162, 157, 158, 6),\n    Triangle(161, 162, 165, 166, 163, 164, 6),\n    Triangle(165, 166, 211, 212, 167, 168, 6),\n    Triangle(211, 212, 169, 170, 167, 168, 6),\n    Triangle(171, 172, 169, 170, 213, 214, 6),\n    Triangle(171, 172, 213, 214, 173, 174, 6),\n    Triangle(175, 176, 173, 174, 177, 178, 6),\n    Triangle(179, 180, 177, 178, 181, 182, 6),\n    Triangle(181, 182, 155, 156, 159, 160, 6),\n    Triangle(171, 172, 175, 176, 163, 164, 6),\n    Triangle(167, 168, 171, 172, 163, 164, 6),\n    Triangle(159, 160, 157, 158, 163, 164, 6),\n    Triangle(183, 156, 188, 162, 184, 185, 6),\n    Triangle(188, 162, 191, 192, 189, 190, 6),\n    Triangle(191, 192, 215, 212, 193, 194, 6),\n    Triangle(215, 212, 195, 196, 193, 194, 6),\n    Triangle(197, 198, 195, 196, 199, 200, 6),\n    Triangle(201, 202, 199, 200, 203, 204, 6),\n    Triangle(205, 206, 203, 204, 207, 178, 6),\n    Triangle(208, 209, 207, 178, 210, 182, 6),\n    Triangle(210, 182, 183, 156, 186, 187, 6),\n    Triangle(197, 198, 205, 206, 208, 209, 6),\n    Triangle(193, 194, 197, 198, 208, 209, 6),\n    Triangle(216, 217, 218, 219, 220, 221, 222),\n    Triangle(223, 224, 218, 219, 216, 217, 222),\n    Triangle(218, 219, 225, 226, 220, 221, 222),\n    Triangle(218, 219, 227, 228, 229, 230, 222),\n    Triangle(231, 232, 233, 234, 235, 236, 222),\n    Triangle(231, 232, 237, 238, 233, 234, 222),\n    Triangle(229, 230, 235, 236, 225, 226, 222),\n    Triangle(239, 240, 223, 224, 216, 217, 222),\n    Triangle(216, 217, 241, 242, 243, 244, 222),\n    Triangle(235, 236, 220, 221, 225, 226, 222),\n    Triangle(245, 246, 247, 248, 239, 240, 222),\n    Triangle(239, 240, 249, 250, 245, 246, 222),\n    Triangle(233, 234, 237, 238, 251, 252, 222),\n    Triangle(251, 252, 249, 250, 253, 254, 222),\n    Triangle(249, 250, 239, 240, 253, 254, 222),\n    Triangle(253, 254, 239, 240, 216, 217, 222),\n    Triangle(227, 228, 231, 232, 229, 230, 222),\n    Triangle(223, 224, 247, 248, 218, 219, 222),\n    Triangle(218, 219, 229, 230, 225, 226, 222),\n    Triangle(218, 219, 247, 248, 227, 228, 222),\n    Triangle(241, 242, 216, 217, 220, 221, 222),\n    Triangle(229, 230, 231, 232, 235, 236, 222),\n    Triangle(233, 234, 251, 252, 255, 256, 222),\n    Triangle(255, 256, 253, 254, 243, 244, 222),\n    Triangle(255, 256, 251, 252, 253, 254, 222),\n    Triangle(235, 236, 233, 234, 255, 256, 222),\n    Triangle(235, 236, 255, 256, 257, 258, 222),\n    Triangle(255, 256, 243, 244, 257, 258, 222),\n    Triangle(235, 236, 257, 258, 220, 221, 222),\n    Triangle(227, 228, 247, 248, 245, 246, 222),\n    Triangle(237, 238, 231, 232, 227, 228, 222),\n    Triangle(247, 248, 223, 224, 239, 240, 222),\n    Triangle(251, 252, 237, 238, 245, 246, 222),\n    Triangle(237, 238, 227, 228, 245, 246, 222),\n    Triangle(251, 252, 245, 246, 249, 250, 222),\n    Triangle(220, 221, 257, 258, 241, 242, 222),\n    Triangle(241, 242, 257, 258, 243, 244, 222),\n    Triangle(243, 244, 253, 254, 216, 217, 222)\n);\n\nconst vec3 vectors[] = vec3[](\n    vec3(-1.467723, 1.402789, 2.793147),\n    vec3(-0.9203  , 0.2487  , 0.3018  ),\n    vec3(-1.390775, 1.580521, 1.996575),\n    vec3(-0.7356  , 0.5517  ,-0.393   ),\n    vec3(-1.411498, 1.156415, 1.847106),\n    vec3(-0.8643  , 0.106   ,-0.4917  ),\n    vec3( 0.603827, 0.001314, 0.      ),\n    vec3(-1.36174 , 1.647689, 2.73756 ),\n    vec3(-0.5053  , 0.7799  , 0.3694  ),\n    vec3(-1.300665, 1.395768, 2.978765),\n    vec3(-0.3311  , 0.433   , 0.8384  ),\n    vec3(-1.28026 , 1.726427, 2.190668),\n    vec3(-0.3523  , 0.9208  ,-0.1676  ),\n    vec3(-1.268954, 1.508682, 1.840646),\n    vec3(-0.2984  , 0.5351  ,-0.7904  ),\n    vec3(-1.357872, 0.951839, 3.078538),\n    vec3(-0.5358  , 0.0964  , 0.8388  ),\n    vec3(-1.40081 ,-1.367545, 3.047107),\n    vec3(-0.6128  ,-0.3116  , 0.7262  ),\n    vec3(-1.295568,-1.061999, 3.118558),\n    vec3(-0.2574  ,-0.0679  , 0.9639  ),\n    vec3(-1.480515,-1.104696, 2.663844),\n    vec3(-0.9969  ,-0.0574  , 0.0541  ),\n    vec3( 1.352643,-1.110194, 1.804947),\n    vec3( 0.7963  ,-0.1519  ,-0.5856  ),\n    vec3( 1.365353, 1.0269  , 1.826562),\n    vec3( 0.869   , 0.0625  ,-0.4908  ),\n    vec3( 1.407727,-1.352349, 2.164311),\n    vec3( 0.9684  ,-0.2158  ,-0.1254  ),\n    vec3( 1.212074,-0.951105, 1.698061),\n    vec3( 0.2902  ,-0.0916  ,-0.9526  ),\n    vec3( 1.222955,-1.378182, 1.814199),\n    vec3( 0.3432  ,-0.5075  ,-0.7904  ),\n    vec3(-1.300193,-1.096719, 1.706141),\n    vec3(-0.4828  ,-0.1866  ,-0.8556  ),\n    vec3( 1.284787,-1.566153, 2.039392),\n    vec3( 0.5078  ,-0.7497  ,-0.4243  ),\n    vec3( 1.307832,-1.32026 , 3.060651),\n    vec3( 0.5811  ,-0.3151  , 0.7504  ),\n    vec3(-1.260415, 1.061015, 1.717737),\n    vec3(-0.3195  , 0.1121  ,-0.9409  ),\n    vec3(-1.32314 ,-1.659542, 2.685035),\n    vec3(-0.4541  ,-0.8825  , 0.1224  ),\n    vec3(-1.396928,-1.548611, 2.917764),\n    vec3(-0.6126  ,-0.6372  , 0.4677  ),\n    vec3(-1.428629,-1.405746, 1.99554 ),\n    vec3(-0.8667  ,-0.356   ,-0.3495  ),\n    vec3( 1.206166, 0.967467, 3.084249),\n    vec3( 0.3064  , 0.1041  , 0.9462  ),\n    vec3( 1.200113,-1.03675 , 3.119145),\n    vec3( 0.2298  ,-0.0535  , 0.9718  ),\n    vec3( 1.262524, 1.688401, 2.634125),\n    vec3( 0.4992  , 0.8075  , 0.3143  ),\n    vec3( 1.139729, 1.73404 , 2.328427),\n    vec3( 0.187   , 0.9814  ,-0.0435  ),\n    vec3( 1.289506, 1.440924, 2.956904),\n    vec3( 0.5483  , 0.4791  , 0.6855  ),\n    vec3( 1.365445, 1.065426, 2.951288),\n    vec3( 0.8815  , 0.0792  , 0.4656  ),\n    vec3( 1.250601, 1.651799, 1.990116),\n    vec3( 0.4023  , 0.7373  ,-0.5427  ),\n    vec3( 1.401426, 1.569483, 2.154963),\n    vec3( 0.877   , 0.454   ,-0.1572  ),\n    vec3( 1.401238,-1.12958 , 2.765244),\n    vec3( 0.9869  ,-0.067   , 0.147   ),\n    vec3( 1.291773,-1.66797 , 2.426756),\n    vec3( 0.5403  ,-0.8403  ,-0.044   ),\n    vec3(-1.302087,-1.646724, 2.252542),\n    vec3(-0.4463  ,-0.8738  ,-0.1928  ),\n    vec3( 1.301057,-1.609408, 2.844538),\n    vec3( 0.556   ,-0.7175  , 0.4195  ),\n    vec3( 1.227662, 1.19807 , 1.719471),\n    vec3( 0.3854  , 0.2605  ,-0.8852  ),\n    vec3(-1.285415,-1.493353, 1.922389),\n    vec3(-0.3093  ,-0.6951  ,-0.649   ),\n    vec3(-1.217086, 2.938846,-0.176011),\n    vec3(-0.6477  , 0.7552  ,-0.101   ),\n    vec3(-1.622429, 1.862037,-0.606663),\n    vec3(-0.9235  , 0.2141  ,-0.3182  ),\n    vec3(-1.68248 , 1.841972, 0.695523),\n    vec3(-0.9332  , 0.2348  , 0.2721  ),\n    vec3(-1.068662, 1.82449 , 1.552062),\n    vec3(-0.5704  , 0.2287  , 0.7889  ),\n    vec3(-1.689393,-0.869488, 1.075233),\n    vec3(-0.882   ,-0.144   , 0.4486  ),\n    vec3(-1.152853, 2.722428, 0.967582),\n    vec3(-0.6137  , 0.6536  , 0.4429  ),\n    vec3(-1.415963,-0.776979,-1.260082),\n    vec3(-0.7346  ,-0.1299  ,-0.666   ),\n    vec3(-1.93473 ,-0.922571,-0.08375 ),\n    vec3(-0.9794  ,-0.1716  ,-0.1068  ),\n    vec3(-0.175346, 1.971682,-1.629237),\n    vec3(-0.0857  , 0.2119  ,-0.9735  ),\n    vec3( 1.310212,-0.764196,-1.391554),\n    vec3( 0.6317  ,-0.1223  ,-0.7655  ),\n    vec3( 0.03659 ,-1.247743,-1.767346),\n    vec3( 0.034   ,-0.3467  ,-0.9374  ),\n    vec3(-0.709323,-0.873116,-1.673044),\n    vec3(-0.3481  ,-0.1378  ,-0.9273  ),\n    vec3(-1.142164, 2.421096,-1.127311),\n    vec3(-0.6135  , 0.4187  ,-0.6696  ),\n    vec3( 1.785885, 1.874228, 0.104558),\n    vec3( 0.9778  , 0.1951  , 0.0765  ),\n    vec3( 1.502465, 2.705021, 0.341846),\n    vec3( 0.7915  , 0.5977  , 0.1279  ),\n    vec3( 1.832933,-0.525335, 0.844863),\n    vec3( 0.9321  ,-0.069   , 0.3555  ),\n    vec3( 0.924295, 2.905094, 1.039198),\n    vec3( 0.4459  , 0.7508  , 0.4873  ),\n    vec3( 1.090202, 2.001804, 1.543903),\n    vec3( 0.5834  , 0.2657  , 0.7675  ),\n    vec3( 1.49786 , 2.053238,-0.864546),\n    vec3( 0.8192  , 0.2818  ,-0.4996  ),\n    vec3( 1.868159,-0.883777,-0.38379 ),\n    vec3( 0.9457  ,-0.1969  ,-0.2588  ),\n    vec3(-0.145196, 1.793973, 1.891736),\n    vec3(-0.0473  , 0.2204  , 0.9743  ),\n    vec3(-0.164957, 2.916597, 1.374194),\n    vec3(-0.0938  , 0.736   , 0.6704  ),\n    vec3(-1.001877,-1.804617,-1.106118),\n    vec3(-0.435   ,-0.6612  ,-0.6112  ),\n    vec3(-0.226168,-2.217284,-0.586741),\n    vec3(-0.05    ,-0.9624  ,-0.2671  ),\n    vec3(-1.453075,-1.949871,-0.244972),\n    vec3(-0.6469  ,-0.7469  ,-0.1538  ),\n    vec3( 1.180051,-2.03489 ,-0.146759),\n    vec3( 0.5018  ,-0.8558  ,-0.1257  ),\n    vec3( 0.247903,-2.215911, 0.783412),\n    vec3( 0.0869  ,-0.9714  , 0.2208  ),\n    vec3(-0.980138,-1.907405, 1.265499),\n    vec3(-0.3976  ,-0.7508  , 0.5275  ),\n    vec3( 1.117519,-1.737701, 1.234505),\n    vec3( 0.548   ,-0.653   , 0.5227  ),\n    vec3( 0.186035,-1.763462, 1.680504),\n    vec3( 0.1068  ,-0.6502  , 0.7522  ),\n    vec3( 0.859297, 3.033141,-0.69366 ),\n    vec3( 0.4295  , 0.8218  ,-0.3743  ),\n    vec3(-0.000116, 3.341052, 0.069966),\n    vec3(-0.0135  , 0.9999  , 0.0098  ),\n    vec3(-0.364997, 2.897427,-1.150696),\n    vec3(-0.1594  , 0.7449  ,-0.6479  ),\n    vec3( 1.204457,-0.873788, 1.658136),\n    vec3( 0.5741  ,-0.1682  , 0.8013  ),\n    vec3(-0.225264,-1.033825, 2.026991),\n    vec3(-0.0771  ,-0.2006  , 0.9766  ),\n    vec3(-1.187404,-0.920757, 1.666351),\n    vec3(-0.5754  ,-0.1717  , 0.7996  ),\n    vec3( 0.935133,-1.767241,-1.217108),\n    vec3( 0.4317  ,-0.6673  ,-0.6069  ),\n    vec3( 1.708557,-1.59444 , 0.34817 ),\n    vec3( 0.8348  ,-0.5396  , 0.1093  ),\n    vec3(-1.434041,-1.800185, 0.822176),\n    vec3(-0.7014  ,-0.6422  , 0.3094  ),\n    vec3( 0.831202, 2.356372,-1.365111),\n    vec3( 0.3996  , 0.3879  ,-0.8306  ),\n    vec3(-0.93491 ,-1.618467,-0.451282),\n    vec3(-0.1377  ,-0.1789  ,-0.9742  ),\n    vec3(-0.530737,-2.889741,-0.133112),\n    vec3( 0.3739  ,-0.7006  ,-0.6077  ),\n    vec3(-0.999855,-2.889733,-0.190104),\n    vec3(-0.2628  ,-0.6993  ,-0.6648  ),\n    vec3(-0.367151,-1.618192,-0.329993),\n    vec3( 0.5581  ,-0.1936  ,-0.8069  ),\n    vec3(-0.313601,-2.889274, 0.184539),\n    vec3( 0.6963  ,-0.7026  ,-0.1466  ),\n    vec3(-0.052068,-1.617912, 0.155811),\n    vec3( 0.9554  ,-0.2095  ,-0.2082  ),\n    vec3(-0.386844,-2.889226, 0.567175),\n    vec3( 0.5652  ,-0.7124  , 0.416   ),\n    vec3(-0.378584,-1.616668, 0.918831),\n    vec3( 0.52    ,-0.185   , 0.8339  ),\n    vec3(-0.813541,-2.889732, 0.804367),\n    vec3(-0.0313  ,-0.6939  , 0.7193  ),\n    vec3(-1.421094,-1.618265, 0.72398 ),\n    vec3(-0.8018  ,-0.2014  , 0.5626  ),\n    vec3(-1.226044,-2.889809, 0.562201),\n    vec3(-0.586   ,-0.6968  , 0.4137  ),\n    vec3(-1.542358,-1.618513, 0.15584 ),\n    vec3(-0.9715  ,-0.1871  ,-0.1454  ),\n    vec3(-1.298914,-2.889162, 0.186281),\n    vec3(-0.6986  ,-0.697   ,-0.1615  ),\n    vec3(-1.325592,-1.619295,-0.234516),\n    vec3(-0.7009  ,-0.1768  ,-0.691   ),\n    vec3( 0.58163 ,-1.618467,-0.451283),\n    vec3( 0.985781,-2.889972,-0.13307 ),\n    vec3( 0.4927  ,-0.6176  ,-0.6131  ),\n    vec3( 0.516732,-2.890274,-0.190001),\n    vec3(-0.2102  ,-0.7563  ,-0.6196  ),\n    vec3( 1.149391,-1.618192,-0.329991),\n    vec3( 1.202925,-2.889342, 0.184543),\n    vec3( 0.6914  ,-0.7222  , 0.0191  ),\n    vec3( 1.464474,-1.617913, 0.155839),\n    vec3( 0.9554  ,-0.2095  ,-0.2081  ),\n    vec3( 1.129697,-2.889226, 0.567173),\n    vec3( 0.5929  ,-0.7124  , 0.3755  ),\n    vec3( 1.137954,-1.616668, 0.918831),\n    vec3( 0.5166  ,-0.1866  , 0.8357  ),\n    vec3( 0.901738,-2.889104, 0.742969),\n    vec3( 0.2527  ,-0.7221  , 0.6439  ),\n    vec3( 0.581628,-1.617971, 1.039093),\n    vec3(-0.1784  ,-0.1914  , 0.9652  ),\n    vec3( 0.608176,-2.889617, 0.77928 ),\n    vec3(-0.1992  ,-0.8297  , 0.5215  ),\n    vec3( 0.095441,-1.618265, 0.723978),\n    vec3(-0.8072  ,-0.1916  , 0.5583  ),\n    vec3( 0.290496,-2.889809, 0.562202),\n    vec3(-0.5958  ,-0.7021  , 0.3899  ),\n    vec3(-0.02582 ,-1.618513, 0.155844),\n    vec3( 0.21772 ,-2.889588, 0.186276),\n    vec3(-0.6964  ,-0.7002  ,-0.1571  ),\n    vec3( 0.190945,-1.619295,-0.234516),\n    vec3(-0.106058,-1.618755, 0.580282),\n    vec3( 0.9054  ,-0.2039  , 0.3724  ),\n    vec3(-0.934912,-1.617971, 1.039093),\n    vec3(-0.1891  ,-0.1956  , 0.9623  ),\n    vec3( 1.410479,-1.618755, 0.580282),\n    vec3(-0.960804, 1.288955,-0.684665),\n    vec3(-0.5033  ,-0.2777  , 0.8182  ),\n    vec3(-1.358191, 1.751234,-1.389909),\n    vec3(-0.9951  , 0.0858  ,-0.0501  ),\n    vec3(-1.079545, 0.825385,-1.393688),\n    vec3(-0.648   ,-0.7599  ,-0.0525  ),\n    vec3( 0.012758, 0.233458, 0.8     ),\n    vec3(-1.062384, 1.96787 ,-0.8331  ),\n    vec3(-0.6389  , 0.3591  , 0.6804  ),\n    vec3(-0.887294, 0.954699,-1.876111),\n    vec3(-0.3988  ,-0.666   ,-0.6304  ),\n    vec3(-0.916477, 2.242859,-1.838715),\n    vec3(-0.4541  , 0.6825  ,-0.5727  ),\n    vec3(-0.97117 , 1.454208,-2.086228),\n    vec3(-0.5252  ,-0.116   ,-0.843   ),\n    vec3( 0.106831, 1.920776,-2.159937),\n    vec3( 0.0235  , 0.2341  ,-0.9719  ),\n    vec3( 1.307449, 1.70823 ,-1.950975),\n    vec3( 0.6963  , 0.1068  ,-0.7097  ),\n    vec3( 1.015787, 0.917776,-1.84717 ),\n    vec3( 0.4196  ,-0.688   ,-0.5921  ),\n    vec3( 0.844611, 2.298428,-1.840639),\n    vec3( 0.2996  , 0.7721  ,-0.5605  ),\n    vec3(-0.529151, 2.049039,-0.659852),\n    vec3(-0.1397  , 0.4637  , 0.8749  ),\n    vec3(-0.864466, 0.862488,-0.987976),\n    vec3(-0.3271  ,-0.7945  , 0.5116  ),\n    vec3( 1.044633, 1.046928,-0.817629),\n    vec3( 0.455   ,-0.5831  , 0.673   ),\n    vec3( 0.045353, 2.489471,-1.193927),\n    vec3(-0.0083  , 0.9822  , 0.1874  ),\n    vec3(-1.067586, 2.288848,-1.218919),\n    vec3(-0.5835  , 0.7928  , 0.176   ),\n    vec3( 0.793809, 2.103578,-0.737679),\n    vec3( 0.2323  , 0.5827  , 0.7788  ),\n    vec3( 1.2354  , 2.263201,-1.239253),\n    vec3( 0.6771  , 0.7184  , 0.1593  ),\n    vec3( 1.127047, 1.606074,-0.651544),\n    vec3( 0.5295  , 0.0297  , 0.8478  ),\n    vec3( 1.484032, 1.411086,-1.31485 ),\n    vec3( 0.9762  ,-0.2037  , 0.0747  ),\n    vec3( 0.858789, 0.754818,-1.180439),\n    vec3( 0.3027  ,-0.9355  , 0.1825  )\n);\n\nfloat cross2d( in vec2 a, in vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nconst vec3 lightDir = normalize(vec3(.5, 1, -1));\nconst vec3 lightCol = vec3(.3, .3, .3);\nconst float smoothness = 256.;\n\nvec3 shader(vec3 view, vec3 normal, vec3 color)\n{\n    float deltaA = dot(lightDir,normal);\n    if (deltaA < 0.) deltaA = 0.;\n    vec3 halfV = normalize(lightDir + view);\n    float deltaB = pow(max(dot(normal,halfV), 0.0), smoothness);\n    return color + lightCol * deltaA + deltaB;\n}", "buffer_d_code": "mat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x < 1)\n    {\n        float rx = iMouse.z <= 0. ? .3 + .3 * sin(iTime * .55) : (iMouse.y/iResolution.y-.5)*-3.1415;\n        float ry = iMouse.z <= 0. ? .3*iTime : iMouse.x/iResolution.x*10.;\n        if (coord.y < 5)\n        {\n            if (coord.y == 4)\n            {\n                fragColor = vec4(0,0,-8,0) * setRotation( rx, 0.,  0. ) * setRotation( 0., ry, 0. );\n            }\n            else\n            {\n                mat4 mvp = setTranslation(0., 0., -8. ) * \n                   setRotation( rx, 0.,  0. ) * \n                   setRotation( 0., ry, 0. );\n                fragColor = mvp[coord.y];\n            }\n        }\n    }\n}", "buffer_d_inputs": [], "buffer_c_code": "vec4 processTriangle(ivec2 coord)\n{\n\tmat4 mvp = mat4(\n        texelFetch(iChannel0,ivec2(0,0),0),\n        texelFetch(iChannel0,ivec2(0,1),0),\n        texelFetch(iChannel0,ivec2(0,2),0),\n        texelFetch(iChannel0,ivec2(0,3),0)\n    );\n    vec3 ep0 = (mvp * vec4(vectors[triangles[coord.x].a],1.0)).xyz;\n    vec3 ep1 = (mvp * vec4(vectors[triangles[coord.x].b],1.0)).xyz;\n    vec3 ep2 = (mvp * vec4(vectors[triangles[coord.x].c],1.0)).xyz;\n\n    // transform to clip space\n    float w0 = 1.0/ep0.z;\n    float w1 = 1.0/ep1.z;\n    float w2 = 1.0/ep2.z;\n\n    if (coord.y == 0)\n    {\n        return vec4(w0,w1,w2,0);\n    }\n\n    vec2 cp0 = 2.0*ep0.xy * -w0;\n    vec2 cp1 = 2.0*ep1.xy * -w1;\n    vec2 cp2 = 2.0*ep2.xy * -w2;\n    if (coord.y == 1)\n    {\n        return vec4(cp0, cp1);\n    }\n    else if (coord.y == 2)\n    {\n        return vec4(cp2, 0, 0);\n    }\n    float minY = min(min(cp0.y, cp1.y), cp2.y);\n    float maxY = max(max(cp0.y, cp1.y), cp2.y);\n    float minX = min(min(cp0.x, cp1.x), cp2.x);\n    float maxX = max(max(cp0.x, cp1.x), cp2.x);\n    return vec4(minX, maxX, minY, maxY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x < TRIANGLE_COUNT)\n    {\n        if (coord.y < 4)\n        {\n            fragColor = processTriangle(coord);\n        }\n    }\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fork of \"Space Ship with Anaglyph 3D\" by GetItemFromBlock. https://shadertoy.com/view/DdcSz8\n// GetItemFromBlock - 2023-04-07\n\n// Based on \"Rasterizer - Cube\" by iq. https://shadertoy.com/view/XdlGzn\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Update - 2023-05-30\n// Added reflection on the glass, not sure if this is an improvement...\n\nvec3 rasterize(in vec2 fragCoord)\n{\n    vec2 px = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0.478,0.478,0.478);\n    // clear zbuffer\n    float mindist = -1000000.0;\n    \n    for (int i = 0; i < TRIANGLE_COUNT; i++)\n    {\n        vec4 bounds = texelFetch(iChannel0, ivec2(i, 3), 0);\n        if (px.x < bounds.x || px.x > bounds.y || px.y < bounds.z || px.y > bounds.w)\n        {\n            continue;\n        }\n        vec4 frb = texelFetch(iChannel0, ivec2(i, 1), 0);\n        vec4 frc = texelFetch(iChannel0, ivec2(i, 2), 0);\n        vec2 cp0 = frb.xy;\n        vec2 cp1 = frb.zw;\n        vec2 cp2 = frc.xy;\n\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n                        \n        if( all(greaterThan(di,vec3(0.0))) )\n        {\n            vec4 fra = texelFetch(iChannel0, ivec2(i, 0), 0);\n            float w0 = fra.x;\n            float w1 = fra.y;\n            float w2 = fra.z;\n            \n            vec3 p0 = vectors[triangles[i].a] * w0;\n            vec3 p1 = vectors[triangles[i].b] * w1;\n            vec3 p2 = vectors[triangles[i].c] * w2;\n            \n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n            \n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n\n\t\t\t// depth (-1/z) buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n                \n                vec3 na = vectors[triangles[i].na] * w0;\n                vec3 nb = vectors[triangles[i].nb] * w1;\n                vec3 nc = vectors[triangles[i].nc] * w2;\n                vec3 n = ba.x*na + ba.y*nb + ba.z*nc;\n                \n\t\t\t\t// perform lighting/shading \n                vec3 cameraPos = texelFetch(iChannel1, ivec2(0,4), 0).rgb;\n                vec3 worldPos = p0 * ba.x + p1 * ba.y + p2 * ba.z;\n                worldPos *= z;\n                n = normalize(n*z);\n                vec3 viewdir = normalize(cameraPos-worldPos);\n\t\t\t\tcolor = shader(-viewdir, n, vectors[triangles[i].col]);\n                if (vectors[triangles[i].col].r < .5) color = mix(texture(iChannel2, reflect(viewdir, n)).rgb, color, .9);\n\t\t\t}\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(rasterize(fragCoord), 1);\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//   by Timothy Lottes\n//\n//   edited by getItemFromBlock\n\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n\n// Emulated input resolution.\n#define resizer (vec2(80,45))\n#define pixel_width (iResolution.y / resizer.y)\n\n// Hardness of scanline.\n//  8.0 = soft\n// 16.0 = medium\nfloat hardScan = 8.0;\n\n// Hardness of pixels in scanline.\n// 2.0 = soft\n// 4.0 = hard\nfloat hardPix = 3.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0/8.0 = extreme\nvec2 warp = vec2(1.0/16.0, 1.0/12.0); \n\n// Amount of shadow mask.\nfloat maskDark = 0.5;\nfloat maskLight = 1.5;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuming using sRGB typed textures this should not be needed.\nfloat ToLinear1(float c){\n    //return c <= 0.04045 ? c/12.92 : pow((c + 0.055)/1.055, 2.4);\n    return pow(c, 2.2); // straight up gamma coding \n}\nvec3 ToLinear(vec3 c){\n    return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));\n}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToSrgb1(float c){\n    //return c < 0.0031308 ? c*12.92 : 1.055 * pow(c, 0.41666) - 0.055;\n    return pow(c, 0.45454545454545454545454545454545); // 0.4545... ~= 1.0/2.2 \n}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec3 SampleLinear(vec2 position, vec2 offset){\n    position = floor(position * resizer + offset) / resizer;\n  \n    // any coordinate of position is out of image \n    if (max(abs(position.x-0.5), abs(position.y-0.5)) > 0.5)  \n        return vec3(0.0,0.0,0.0);\n    \n    // -32.0 to get 'lowest' resolution image?\n    return ToLinear( texture(iChannel0, position.xy, -32.0).rgb );\n}\n\n\n// Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos){\n    pos = pos * resizer; // scale\n\n    // how far is the true pixel from the center\n    return ( 0.5 - fract(pos)); \n}\n    \n// 1D Gaussian.\nfloat Gauss(float pos, float scale) {\n    // scale here is likely (1 / sigma^2)\n    return exp( -scale * pos*pos);\n}\n\n// interpolate + apply gaussian convolution to a \n// 3-pixel horizontal window\nvec3 Horz3(vec2 position, float vertical_offset, float scale){\n    vec3 b = SampleLinear(position, vec2(-1.0, vertical_offset));\n    vec3 c = SampleLinear(position, vec2( 0.0, vertical_offset));\n    vec3 d = SampleLinear(position, vec2( 1.0, vertical_offset));\n    float dst = Dist(position).x;\n\n    // Convert distance to weight.\n    float wb = Gauss(dst - 1.0, scale);\n    float wc = Gauss(dst      , scale); // dst + 0\n    float wd = Gauss(dst + 1.0, scale);\n\n    // Return filtered sample.\n    return (b*wb + c*wc + d*wd) / (wb + wc + wd);\n}\n\n\n// 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 position, float vertical_offset, float scale){\n    vec3 a = SampleLinear(position, vec2(-2.0, vertical_offset));\n    vec3 b = SampleLinear(position, vec2(-1.0, vertical_offset));\n    vec3 c = SampleLinear(position, vec2( 0.0, vertical_offset));\n    vec3 d = SampleLinear(position, vec2( 1.0, vertical_offset));\n    vec3 e = SampleLinear(position, vec2( 2.0, vertical_offset));\n    \n    float dst = Dist(position).x;\n    \n    // apply Gaussian envelope to interpolation weights\n    float wa = Gauss(dst - 2.0, scale);\n    float wb = Gauss(dst - 1.0, scale);\n    float wc = Gauss(dst      , scale); // dst + 0\n    float wd = Gauss(dst + 1.0, scale);\n    float we = Gauss(dst + 2.0, scale);\n    \n    // Return filtered sample.\n    return (a*wa + b*wb + c*wc + d*wd + e*we) / (wa + wb + wc + wd + we);\n}\n\n\n// Allow nearest three lines to affect pixel.\n// This is sort-of doing bilinear interpolation and\n// Gaussian filtering at the same time. Closer to bicubic  \n// due to 3 pixels taken into account but weights are a Gaussian curve\nvec3 TriGaussianInterpolation(vec2 position, float pixel_scale, float scanline_scale){\n    // interpolate 3 vertical pixels\n    vec3 a = Horz3(position, -1.0, pixel_scale); // above current pixel\n    vec3 b = Horz5(position,  0.0, pixel_scale); // current pixel\n    vec3 c = Horz3(position,  1.0, pixel_scale); // below current pixel\n    \n    float dst = Dist(position).y; // vertical distance to center of pixel\n    \n    // apply Gaussian envelope to interpolation weights\n    float wa = Gauss(dst - 1.0, scanline_scale); \n    float wb = Gauss(dst      , scanline_scale); // dst + 0\n    float wc = Gauss(dst + 1.0, scanline_scale);\n    \n    return a*wa + b*wb + c*wc;\n}\n\n// Distortion of scanlines, and end of screen alpha.\nvec2 Warp(vec2 pos){\n    // [0 -> 1] => [-0.5 -> 0.5]\n    pos = 2.0 * pos - 1.0; \n    // the closer pos is to 0,0 the less distortion is\n    // added to the multiplier\n    // because the coords are inverted, the corners are \n    // affected the most\n    pos *= vec2(1.0 + (pos.y*pos.y) * warp.y,  \n                1.0 + (pos.x*pos.x) * warp.x);\n\n    // get it back to the [0 -> 1] range\n    return (pos + 1.0) * 0.5;\n}\n\n// Shadow mask.\nvec3 Mask(vec2 pos, float mask_dark, float mask_light){\n    pos.x += pos.y * pixel_width * 3.0;//(pixels_width / 2.0);\n\n    vec3 mask = vec3(mask_dark, mask_dark, mask_dark);\n\n    pos.x = fract(pos.x / pixel_width); // 1/6\n\n    // simulating per-physical-pixel intensity\n    if(pos.x < 0.333) \n      mask.r = mask_light;\n    else if(pos.x<0.666) \n        mask.g = mask_light;\n    else \n        mask.b = mask_light;\n        \n    return mask;\n}\n\n// Entry.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Unmodified.\n    vec2 norm_coord = fragCoord.xy/iResolution.xy; // uv\n    norm_coord = norm_coord * 1.2 - .1;\n\n    if(texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5 || iResolution.x < 1000.)\n    {\n        // distortion + scanlines\n        vec2 pos = Warp(norm_coord); // warp uv coord to get screen edge distortion\n        \n        // interpolate + gaussian filter 3x3 window\n        fragColor.rgb= TriGaussianInterpolation(pos, hardPix, hardScan);\n    }\n    else {\n        // distortion + scanlines + 'bayer' masking\n        vec2 pos = Warp(norm_coord);\n        fragColor.rgb = TriGaussianInterpolation(pos, hardPix, hardScan) * \n                        Mask(fragCoord.xy, maskDark, maskLight); \n        // mask should take in the distorted uv in my opinion\n    }    \n\n    fragColor.a = 1.0;  \n\n    fragColor.rgb= ToSrgb(fragColor.rgb);\n\n\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2BR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 369, 369, 446], [448, 448, 468, 468, 636], [638, 638, 695, 695, 768]], "test": "untested"}
{"id": "cdSfR1", "name": "Mandelbrot unwound", "author": "ArmandB", "description": "unwinds the mandelbrot set from the main cardioid \nclick + drag to move view\nhold shift + mouse up/down to change zoom", "tags": ["mandelbrot"], "likes": 1, "viewed": 179, "published": 3, "date": "1689394065", "time_retrieved": "2024-07-30T17:44:37.424768", "image_code": "vec4 grad[] = vec4[](\n    vec4(0,0.027,0.391,0),\n    vec4(0.125,0.418,791,0.16),\n    vec4(0.926,1.0,1.0,0.42),\n    vec4(1.0,0.664,0,0.6425),\n    vec4(0,0.008,0,0.8575),\n    vec4(0,0.027,0.391,1.0)\n);\n\nvec3 lerpGrad(vec4[6] g, float x){\n    x = fract(x);\n    for (int i = 0; i < g.length(); i++){\n        if (g[i].a >= x){\n            vec4 gradStart = g[i - 1];\n            vec4 gradEnd = g[i];\n            return mix(gradStart.rgb,gradEnd.rgb,smoothstep(gradStart.a,gradEnd.a,x));\n        }\n    }\n}\n\nvec2 getBulbNormal(float t){\n    return vec2(cos(t) - cos(2.0*t),sin(t) - sin(2.0*t))/(2.0*sqrt((1.0 - cos(t))/2.0));\n}\n\nvec2 getBulbPoint(float t){\n    return vec2(cos(t)/2.0 - cos(2.0*t)/4.0, sin(t)*(1.0 - cos(t))/2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 drag_offset = texelFetch(iChannel1, ivec2(1,0), 0).xy/iResolution.y;\n    float zoom = texelFetch(iChannel0, ivec2(1,0), 0).y/iResolution.y;\n    vec2 uv = ((fragCoord - iResolution.xy/2.0)/iResolution.y)*pow(2.0,zoom) - drag_offset;\n    float t = uv.x*2.0*PI;\n    float l = length(getBulbPoint(t));\n    vec2 coord = getBulbPoint(t) + getBulbNormal(t)*abs(uv.y)*6.0;\n    \n    float n = -1.0;\n    int c = 0;\n    float r0 = coord.x;\n    float i0 = coord.y;\n    float r = 0.0;\n    float i = 0.0;\n    float r2 = 0.0;\n    float i2 = 0.0;\n\n    for (c; c < max_steps && r2 + i2 <= 4.0; c++) {        \n        i = 2.0*r*i + i0;\n        r = r2 - i2 + r0;\n        r2 = r*r;\n        i2 = i*i;\n    }\n    if (r2 + i2 > 4.0) {\n        n = float(c) + 1.0 - log(log(r2*r2 + i2*i2)/2.0)/log(2.0);\n    }\n    \n    vec3 col = n == -1.0 ? vec3(0) : lerpGrad(grad, n/100.0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int _shift = 16;\n\nbool keyPressed(int key){\n    return texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool iszooming = keyPressed(_shift);\n    vec4 col = vec4(0);\n    \n    //zoom\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw;\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0);\n        vec4 m = iMouse;\n        \n        if (m.z < 0.0 && mp.z >= 0.0 && iszooming){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0 && iszooming){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int max_steps = 1000;\nfloat PI = 3.14159265359;", "buffer_b_code": "const int _shift = 16;\n\nbool keyPressed(int key){\n    return texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool iszooming = keyPressed(_shift);\n    vec4 col = vec4(0);\n    \n    //drag\n    if (floor(fragCoord) == vec2(1,0)) {\n        float zoom = texelFetch(iChannel2, ivec2(1,0), 0).y/iResolution.y;\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw;\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0);\n        vec4 m = iMouse;\n        \n        if (m.z < 0.0 && mp.z >= 0.0 && !iszooming){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0 && !iszooming){\n            col = vec4((m.xy - abs(m.zw))*pow(2.0,zoom) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[500, 500, 528, 528, 619], [621, 621, 648, 648, 723], [725, 725, 782, 782, 1680]], "test": "untested"}
{"id": "stycDG", "name": "Disney Principle BRDF", "author": "73begonia", "description": "reference at https://www.shadertoy.com/view/tsBBWW by demofox;\nreference at https://blog.csdn.net/weixin_44176696/article/details/119791772 by AkagiSenpai", "tags": ["importancesampling", "brdf", "path"], "likes": 4, "viewed": 410, "published": 3, "date": "1689351969", "time_retrieved": "2024-07-30T17:44:38.450027", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float intersect_plane(Ray ray, vec3 center, vec3 normal)\n{\n    float denom = dot(ray.rd, normal);\n    float t = dot(center - ray.ro, normal) / denom;\n\treturn t > 0.0 ? t : c_superFar;\n}\n\nbool intersect_light(Ray r, inout HitResult res)\n{\n\tfloat t = intersect_plane(r, light_position, light_normal);\n\n\tvec3 p = ray_at(r, t);\n\tif(all(lessThan(abs(light_position - p).xz, vec2(light_size * 0.5))) && t < res.distance) {\n\t\tres.distance = t;\n        res.viewDir = r.rd;\n        res.hitPoint = p;\n        res.normal = light_normal;\n        return true;\n\t}\n\n\treturn false;\n}\n\nvec3 sample_light(vec2 rng)\n{\n\treturn light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * light_size;\n}\n\nbool iQuad(in Ray r, inout HitResult res, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, r.rd) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = r.ro;\n    vec3 q = r.ro + r.rd;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(r.rd.x) > 0.1f)\n    {\n        dist = (intersectPos.x - r.ro.x) / r.rd.x;\n    }\n    else if (abs(r.rd.y) > 0.1f)\n    {\n        dist = (intersectPos.y - r.ro.y) / r.rd.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - r.ro.z) / r.rd.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < res.distance)\n    {\n        res.distance = dist;\n        res.viewDir = r.rd;\n        res.hitPoint = r.ro + res.distance * r.rd;\n        res.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool iSphere(in Ray r, inout HitResult res, in vec4 sphere)\n{\n\tvec3 m = r.ro - sphere.xyz;\n\n\tfloat b = dot(m, r.rd);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\tfloat discr = b * b - c;\n\n\tif(discr < 0.0)\n\t\treturn false;\n    \n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < res.distance)\n    {\n        res.distance = dist;  \n        res.viewDir = r.rd;\n        res.hitPoint = r.ro + r.rd * res.distance;\n        res.normal = normalize((r.ro+r.rd*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid SceneTrace(in Ray r, inout HitResult res)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.7f, 0.7f, 0.7f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }\n\t}    \n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.7f, 0.7f, 0.7f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.7f, 0.7f, 0.7f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(1.0f, 0.1f, 0.1f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.1f, 1.0f, 0.1f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }        \n    }    \n    \n    // light\n    /*\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        \n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.0f, 0.0f, 0.0f);\n            res.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n        }        \n    }\n    */\n    \n    {\n        if(intersect_light(r, res))\n        {\n            res.material.baseColor = vec3(0.0f, 0.0f, 0.0f);\n            res.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n        }\n    }\n    \n\tif (iSphere(r, res, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        res.material.baseColor = vec3(1.0f, 0.59f, 0.60f);\n        res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        res.material.roughness = 0.1;\n        res.material.subsurface = 0.0;\n        res.material.specular = 0.5;\n        res.material.metallic = 0.9;\n        res.material.anisotropic = 0.0;\n    } \n    \n\tif (iSphere(r, res, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        res.material.baseColor = vec3(0.56f, 1.0f, 0.53f);\n        res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        res.material.roughness = 0.25;\n        res.material.subsurface = 1.0;\n        res.material.specular = 1.0;\n        res.material.metallic = 0.9;\n        res.material.anisotropic = 1.0;\n    }    \n    \n\tif (iSphere(r, res, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        res.material.baseColor = vec3(0.49f, 0.48f, 1.0f);\n        res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        res.material.roughness = 0.1;\n        res.material.specular = 0.5;\n    }    \n}\n\nbool test_visibility(vec3 p1, vec3 p2)\n{\n    const float eps = 1e-5;\n    \n    Ray r = Ray(p1, normalize(p2 - p1));\n    r.ro += eps * r.rd;\n    \n    HitResult res;\n    res.distance = c_superFar;\n    SceneTrace(r, res);\n    \n    if(res.distance > distance(p1, p2) - 2.0 * eps)\n        return true;\n    \n    return false;\n}\n\nvec3 pathTracing(in HitResult hit)\n{\n    vec3 Lo = vec3(0.);\n    vec3 history = vec3(1.);\n    \n    for(int bounce = 0; bounce < c_numBounces; bounce++)\n    {\n        vec3 V = -hit.viewDir;\n        vec3 N = hit.normal;\n        \n        vec2 uv = sobolVec2(uint(iFrame+1), uint(bounce));\n        uv = CranleyPattersonRotation(uv);\n        vec3 L = SampleHemisphere(uv.x, uv.y);\n        L = toNormalHemisphere(L, hit.normal);\n        //vec3 L = toNormalHemisphere(SampleHemisphere(), hit.normal);\n        \n        float pdf = 1.0 / c_twopi;\n        float cosine_o = max(0., dot(V, hit.normal));\n        float cosine_i = max(0., dot(L, hit.normal));\n        vec3 tangent, bitangent;\n        getTangent(N, tangent, bitangent);\n        \n        vec3 f_r = brdf_Evaluate_aniso(V, N, L, tangent, bitangent, hit.material);\n        \n        Ray randomRay;\n        randomRay.ro = hit.hitPoint;\n        randomRay.rd = L;\n        \n        HitResult newHit;\n        newHit.distance = c_superFar;\n        SceneTrace(randomRay, newHit);\n        \n        if(newHit.distance == c_superFar)\n        {\n            Lo += texture(iChannel1, randomRay.rd).rgb * history * f_r * cosine_i / pdf;\n            break;\n        }\n        \n        vec3 Le = newHit.material.emissive;\n        Lo += history * Le * f_r * cosine_i / pdf;\n        hit = newHit;\n        history *= f_r * cosine_i / pdf;\n    }\n    \n    return Lo;\n}\n\nvec3 hdrColor(vec3 L) \n{\n    vec3 color = texture(iChannel1, L).rgb;\n    return color;\n}\n\nvec3 pathTracingImportanceSampling(HitResult hit) \n{\n    vec3 Lo = vec3(0);\n    vec3 history = vec3(1);\n    \n    for(int bounce = 0; bounce< c_numBounces; bounce++) \n    {\n        vec3 V = -hit.viewDir;\n        vec3 N = hit.normal;\n        \n        vec2 uv = sobolVec2(uint(iFrame+1), uint(bounce));\n        uv = CranleyPattersonRotation(uv);\n        float xi_3 = RandomFloat01();\n        \n        vec3 L = SampleBRDF(uv.x, uv.y, xi_3, V, N, hit.material);\n        \n        float NdotL = dot(N, L);\n        if(NdotL <= 0.0) break;\n        \n        Ray randomRay;\n        randomRay.ro = hit.hitPoint;\n        randomRay.rd = L;\n        \n        HitResult newHit;\n        newHit.distance = c_superFar;\n        SceneTrace(randomRay, newHit);\n        \n        vec3 tangent, bitangent;\n        getTangent(N, tangent, bitangent);\n        \n        vec3 f_r = brdf_Evaluate_aniso(V, N, L, tangent, bitangent, hit.material);\n        \n        float pdf_brdf = brdf_Pdf(V, N, L, hit.material);\n        if(pdf_brdf <= 1e-7) break;\n        \n        if(newHit.distance == c_superFar)\n        {\n            vec3 color = texture(iChannel1, L).rgb;\n            Lo += history * color * f_r * NdotL / pdf_brdf;\n            break;\n        }\n        \n        vec3 Le = newHit.material.emissive;\n        Lo += history * Le * f_r * NdotL / pdf_brdf;\n        hit = newHit;\n        history *= f_r * NdotL / pdf_brdf;\n    }\n    return Lo;\n}\n\nvec3 pathTracingImportanceSampling2(in HitResult hit)\n{\n    vec3 Lo = vec3(0);\n    vec3 history = vec3(1);\n    \n    for(int bounce = 0; bounce < c_numBounces; bounce++)\n    {\n        vec3 V = -hit.viewDir;\n        vec3 N = hit.normal;\n        \n        {\n            vec3 pos_ls = sample_light(vec2(RandomFloat01(), RandomFloat01()));\n            vec3 l_nee = pos_ls - hit.hitPoint;\n            float rr_nee = dot(l_nee, l_nee);\n            l_nee /= sqrt(rr_nee);\n            float G = max(0., dot(hit.normal, l_nee)) * max(0., -dot(l_nee, light_normal)) / rr_nee;\n            vec3 L = l_nee;\n            \n            if(G > 0.0)\n            {\n                float light_pdf = 1.0 / (light_area * G);\n                float brdf_pdf = brdf_Pdf(V, N, L, hit.material);\n                float w = light_pdf / (light_pdf + brdf_pdf);\n                \n                vec3 tangent, bitangent;\n                getTangent(N, tangent, bitangent);\n                vec3 brdf = brdf_Evaluate_aniso(V, N, L, tangent, bitangent, hit.material);\n                \n                if(test_visibility(hit.hitPoint, pos_ls))\n                {\n                    vec3 Le = hit.material.baseColor;\n                    Lo += history * (Le * w * brdf) / light_pdf;\n                }\n            }\n        }\n        \n        {\n            vec3 V = -hit.viewDir;\n            vec3 N = hit.normal;\n\n            vec2 uv = sobolVec2(uint(iFrame+1), uint(bounce));\n            uv = CranleyPattersonRotation(uv);\n            float xi_3 = RandomFloat01();\n\n            vec3 L = SampleBRDF(uv.x, uv.y, xi_3, V, N, hit.material);\n\n            float NdotL = dot(N, L);\n            if(NdotL <= 0.0) break;\n\n            Ray randomRay;\n            randomRay.ro = hit.hitPoint;\n            randomRay.rd = L;\n\n            HitResult newHit;\n            newHit.distance = c_superFar;\n            SceneTrace(randomRay, newHit);\n\n            vec3 tangent, bitangent;\n            getTangent(N, tangent, bitangent);\n        \n            vec3 f_r = brdf_Evaluate_aniso(V, N, L, tangent, bitangent, hit.material);\n\n            float pdf_brdf = brdf_Pdf(V, N, L, hit.material);\n            if(pdf_brdf <= 1e-7) break;\n\n            if(newHit.distance == c_superFar)\n            {\n                vec3 color = texture(iChannel1, L).rgb;\n                Lo += history * color * f_r * NdotL / pdf_brdf;\n                break;\n            }\n\n            vec3 Le = newHit.material.emissive;\n            Lo += history * Le * f_r * NdotL / pdf_brdf;\n            hit = newHit;\n            history *= f_r * NdotL / pdf_brdf;\n        }\n    }\n    \n    return Lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    light_size = 8.0f;\n    light_area = light_size * light_size;\n    light_position = vec3(0.0f, 12.4f, 30.0f);\n    light_normal = vec3(0.f, -1.f, 0.f);\n    \n    vec3 ro = vec3(0.);\n    float cameraDistance = 1.0 / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);\n    vec3 rt = vec3((fragCoord/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    rt.y /= aspectRatio;\n    \n    vec3 rd = normalize(rt - ro);\n    \n    vec3 color = vec3(0.);\n    Ray r;\n    r.ro = ro;\n    r.rd = rd;\n    \n    HitResult firstHit;\n    firstHit.distance = c_superFar;\n    SceneTrace(r, firstHit);\n    \n    if(firstHit.distance == c_superFar)\n    {\n        color = texture(iChannel1, r.rd).rgb;\n    }\n    else\n    {\n        vec3 Le = firstHit.material.emissive;\n        vec3 Li;\n        for(int i = 0; i < c_numSPP; i++)\n        {\n            Li += pathTracingImportanceSampling2(firstHit);\n        }\n        Li /= float(c_numSPP);\n        color = Le + Li;\n    }\n    \n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    color = vec3(1.0) - exp(-1.0 * color);\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color = mix(lastFrameColor, color, 1.0f / float(iFrame+1));\n    \n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float c_minimumRayHitTime = 0.01f;\nconst float c_rayPosNormalNudge = 0.01f;\nconst float c_superFar = 10000.0f;\nconst float c_FOVDegrees = 90.0f;\nconst int   c_numBounces = 8;\nconst int   c_numSPP = 32;\n\nconst float c_pi = 3.1415926535;\nconst float c_twopi = 2.0f * c_pi;\n\nfloat light_size;\nfloat light_area;\nvec3  light_position;\nvec3  light_normal;\n\nuint  seed;\n\nconst uint V[8*32] = uint[](\n    2147483648U, 1073741824U, 536870912U, 268435456U, 134217728U, 67108864U, 33554432U,\n    16777216U, 8388608U, 4194304U, 2097152U, 1048576U, 524288U, 262144U, 131072U, 65536U,\n    32768U, 16384U, 8192U, 4096U, 2048U, 1024U, 512U, 256U, 128U, 64U, 32U, 16U, 8U, 4U, 2U, 1U,\n    2147483648U, 3221225472U, 2684354560U, 4026531840U, 2281701376U, 3422552064U,\n    2852126720U, 4278190080U, 2155872256U, 3233808384U, 2694840320U, 4042260480U,\n    2290614272U, 3435921408U, 2863267840U, 4294901760U, 2147516416U, 3221274624U,\n    2684395520U, 4026593280U, 2281736192U, 3422604288U, 2852170240U, 4278255360U,\n    2155905152U, 3233857728U, 2694881440U, 4042322160U, 2290649224U, 3435973836U,\n    2863311530U, 4294967295U,\n    2147483648U, 3221225472U, 1610612736U, 2415919104U, 3892314112U, 1543503872U,\n    2382364672U, 3305111552U, 1753219072U, 2629828608U, 3999268864U, 1435500544U,\n    2154299392U, 3231449088U, 1626210304U, 2421489664U, 3900735488U, 1556135936U,\n    2388680704U, 3314585600U, 1751705600U, 2627492864U, 4008611328U, 1431684352U,\n    2147543168U, 3221249216U, 1610649184U, 2415969680U, 3892340840U, 1543543964U,\n    2382425838U, 3305133397U,\n    2147483648U, 3221225472U, 536870912U, 1342177280U, 4160749568U, 1946157056U,\n    2717908992U, 2466250752U, 3632267264U, 624951296U, 1507852288U, 3872391168U,\n    2013790208U, 3020685312U, 2181169152U, 3271884800U, 546275328U, 1363623936U,\n    4226424832U, 1977167872U, 2693105664U, 2437829632U, 3689389568U, 635137280U,\n    1484783744U, 3846176960U, 2044723232U, 3067084880U, 2148008184U, 3222012020U,\n    537002146U, 1342505107U,\n    2147483648U, 1073741824U, 536870912U, 2952790016U, 4160749568U, 3690987520U,\n    2046820352U, 2634022912U, 1518338048U, 801112064U, 2707423232U, 4038066176U,\n    3666345984U, 1875116032U, 2170683392U, 1085997056U, 579305472U, 3016343552U,\n    4217741312U, 3719483392U, 2013407232U, 2617981952U, 1510979072U, 755882752U,\n    2726789248U, 4090085440U, 3680870432U, 1840435376U, 2147625208U, 1074478300U,\n    537900666U, 2953698205U,\n    2147483648U, 1073741824U, 1610612736U, 805306368U, 2818572288U, 335544320U,\n    2113929216U, 3472883712U, 2290089984U, 3829399552U, 3059744768U, 1127219200U,\n    3089629184U, 4199809024U, 3567124480U, 1891565568U, 394297344U, 3988799488U,\n    920674304U, 4193267712U, 2950604800U, 3977188352U, 3250028032U, 129093376U,\n    2231568512U, 2963678272U, 4281226848U, 432124720U, 803643432U, 1633613396U,\n    2672665246U, 3170194367U,\n    2147483648U, 3221225472U, 2684354560U, 3489660928U, 1476395008U, 2483027968U,\n    1040187392U, 3808428032U, 3196059648U, 599785472U, 505413632U, 4077912064U,\n    1182269440U, 1736704000U, 2017853440U, 2221342720U, 3329785856U, 2810494976U,\n    3628507136U, 1416089600U, 2658719744U, 864310272U, 3863387648U, 3076993792U,\n    553150080U, 272922560U, 4167467040U, 1148698640U, 1719673080U, 2009075780U,\n    2149644390U, 3222291575U,\n    2147483648U, 1073741824U, 2684354560U, 1342177280U, 2281701376U, 1946157056U,\n    436207616U, 2566914048U, 2625634304U, 3208642560U, 2720006144U, 2098200576U,\n    111673344U, 2354315264U, 3464626176U, 4027383808U, 2886631424U, 3770826752U,\n    1691164672U, 3357462528U, 1993345024U, 3752330240U, 873073152U, 2870150400U,\n    1700563072U, 87021376U, 1097028000U, 1222351248U, 1560027592U, 2977959924U, 23268898U,\n    437609937U\n);\n\nuint grayCode(uint i) {\n    return i ^ (i>>1);\n}\n\nfloat sobol(uint d, uint i) {\n    uint result = 0U;\n    uint offset = d * 32U;\n    for(uint j = 0U; i!=0U; i >>= 1, j++)\n        if((i & 1U)!=0U) result ^= V[j+offset];\n    return float(result) * (1.0f/float(0xFFFFFFFFU));\n}\n\nvec2 sobolVec2(uint i, uint b) {\n    float u = sobol(b*2U, grayCode(i));\n    float v = sobol(b*2U+1U, grayCode(i));\n    return vec2(u, v);\n}\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Material\n{\n    vec3 baseColor;\n    vec3 emissive;\n    float subsurface;\n    float metallic;\n    float specular;\n    float specularTint;\n    float roughness;\n    float anisotropic;\n    float sheen;\n    float sheenTint;\n    float clearcoat;\n    float clearcoatGloss;\n    float IOR;\n    float transmission;\n};\n\nstruct HitResult\n{\n    float distance;\n    vec3 hitPoint;\n    vec3 viewDir;\n    vec3 normal;\n\n    Material material;\n};\n\nvec3 ray_at(in Ray ray, float t)\n{\n\treturn ray.ro + t * ray.rd;\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01()\n{\n    return float(wang_hash(seed)) / 4294967296.0;\n}\n\nvec3 SampleHemisphere() {\n    float z = RandomFloat01();\n    float r = max(0.0, sqrt(1.0 - z*z));\n    float phi = 2.0 * c_pi * RandomFloat01();\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nvec3 SampleHemisphere(float xi_1, float xi_2) {\n    float z = xi_1;\n    float r = max(0.0, sqrt(1.0 - z*z));\n    float phi = 2.0 * c_pi * xi_2;\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nvec3 toNormalHemisphere(vec3 v, vec3 N) {\n    vec3 helper = vec3(1, 0, 0);\n    if(abs(N.x)>0.999) helper = vec3(0, 0, 1);\n    vec3 tangent = normalize(cross(N, helper));\n    vec3 bitangent = normalize(cross(N, tangent));\n    return v.x * tangent + v.y * bitangent + v.z * N;\n}\n\nvec2 CranleyPattersonRotation(vec2 p) {\n    uint pseed = seed;\n    float u = float(wang_hash(pseed)) / 4294967296.0;\n    float v = float(wang_hash(pseed)) / 4294967296.0;\n    p.x += u;\n    if(p.x>1.) p.x -= 1.;\n    if(p.x<0.) p.x += 1.;\n    p.y += v;\n    if(p.y>1.) p.y -= 1.;\n    if(p.y<0.) p.y += 1.;\n    return p;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nfloat sqr(float x) {\n    return x*x;\n}\n\nfloat SchlickFresnel(float u) {\n    float m = clamp(1.-u, 0., 1.);\n    float m2 = m*m;\n    return m2*m2*m; // pow(m,5)\n}\n\n\nfloat GTR1(float NdotH, float a) {\n    if (a >= 1.) return 1./c_pi;\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return (a2-1.) / (c_pi*log(a2)*t);\n}\nfloat GTR2(float NdotH, float a) {\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return a2 / (c_pi * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n    return 1. / (c_pi * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH\n    ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG) {\n    float a = alphaG*alphaG;\n    float b = NdotV*NdotV;\n    return 1. / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {\n    return 1. / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));\n}\n\nvoid getTangent(vec3 N, inout vec3 tangent, inout vec3 bitangent) {\n    vec3 helper = vec3(1, 0, 0);\n    if(abs(N.x)>0.999) helper = vec3(0, 0, 1);\n    bitangent = normalize(cross(N, helper));\n    tangent = normalize(cross(N, bitangent));\n}\n\n// 余弦加权的法向半球采样\nvec3 SampleCosineHemisphere(float xi_1, float xi_2, vec3 N) {\n    // 均匀采样 xy 圆盘然后投影到 z 半球\n    float r = sqrt(xi_1);\n    float theta = xi_2 * 2.0 * c_pi;\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    float z = sqrt(1.0 - x * x - y * y);\n\n    // 从 z 半球投影到法向半球\n    vec3 L = toNormalHemisphere(vec3(x, y, z), N);\n    return L;\n}\n\n// GTR2 重要性采样\nvec3 SampleGTR2(float xi_1, float xi_2, vec3 V, vec3 N, float alpha) {\n    \n    float phi_h = 2.0 * c_pi * xi_1;\n    float sin_phi_h = sin(phi_h);\n    float cos_phi_h = cos(phi_h);\n\n    float cos_theta_h = sqrt((1.0-xi_2)/(1.0+(alpha*alpha-1.0)*xi_2));\n    float sin_theta_h = sqrt(max(0.0, 1.0 - cos_theta_h * cos_theta_h));\n\n    // 采样 \"微平面\" 的法向量 作为镜面反射的半角向量 h \n    vec3 H = vec3(sin_theta_h*cos_phi_h, sin_theta_h*sin_phi_h, cos_theta_h);\n    H = toNormalHemisphere(H, N);   // 投影到真正的法向半球\n\n    // 根据 \"微法线\" 计算反射光方向\n    vec3 L = reflect(-V, H);\n\n    return L;\n}\n\n// GTR1 重要性采样\nvec3 SampleGTR1(float xi_1, float xi_2, vec3 V, vec3 N, float alpha) {\n    \n    float phi_h = 2.0 * c_pi * xi_1;\n    float sin_phi_h = sin(phi_h);\n    float cos_phi_h = cos(phi_h);\n\n    float cos_theta_h = sqrt((1.0-pow(alpha*alpha, 1.0-xi_2))/(1.0-alpha*alpha));\n    float sin_theta_h = sqrt(max(0.0, 1.0 - cos_theta_h * cos_theta_h));\n\n    // 采样 \"微平面\" 的法向量 作为镜面反射的半角向量 h \n    vec3 H = vec3(sin_theta_h*cos_phi_h, sin_theta_h*sin_phi_h, cos_theta_h);\n    H = toNormalHemisphere(H, N);   // 投影到真正的法向半球\n\n    // 根据 \"微法线\" 计算反射光方向\n    vec3 L = reflect(-V, H);\n\n    return L;\n}\n\n// 按照辐射度分布分别采样三种 BRDF\nvec3 SampleBRDF(float xi_1, float xi_2, float xi_3, vec3 V, vec3 N, in Material material) {\n    float alpha_GTR1 = mix(0.1, 0.001, material.clearcoatGloss);\n    float alpha_GTR2 = max(0.001, sqr(material.roughness));\n    \n    // 辐射度统计\n    float r_diffuse = (1.0 - material.metallic);\n    float r_specular = 1.0;\n    float r_clearcoat = 0.25 * material.clearcoat;\n    float r_sum = r_diffuse + r_specular + r_clearcoat;\n\n    // 根据辐射度计算概率\n    float p_diffuse = r_diffuse / r_sum;\n    float p_specular = r_specular / r_sum;\n    float p_clearcoat = r_clearcoat / r_sum;\n\n    // 按照概率采样\n    float rd = xi_3;\n\n    // 漫反射\n    if(rd <= p_diffuse) {\n        return SampleCosineHemisphere(xi_1, xi_2, N);\n    } \n    // 镜面反射\n    else if(p_diffuse < rd && rd <= p_diffuse + p_specular) {    \n        return SampleGTR2(xi_1, xi_2, V, N, alpha_GTR2);\n    } \n    // 清漆\n    else if(p_diffuse + p_specular < rd) {\n        return SampleGTR1(xi_1, xi_2, V, N, alpha_GTR1);\n    }\n    return vec3(0, 1, 0);\n}\n\nvec3 brdf_Evaluate_aniso(vec3 V, vec3 N, vec3 L, vec3 X, vec3 Y, in Material material)\n{\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if(NdotL < 0. || NdotV < 0.) return vec3(0);\n\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n\n    // 各种颜色\n    vec3 Cdlin = material.baseColor;\n    float Cdlum = 0.3 * Cdlin.r + 0.6 * Cdlin.g  + 0.1 * Cdlin.b;\n    vec3 Ctint = (Cdlum > 0.) ? (Cdlin/Cdlum) : (vec3(1.));   \n    vec3 Cspec = material.specular * mix(vec3(1), Ctint, material.specularTint);\n    vec3 Cspec0 = mix(0.08*Cspec, Cdlin, material.metallic); // 0° 镜面反射颜色\n    vec3 Csheen = mix(vec3(1), Ctint, material.sheenTint);   // 织物颜色\n\n    // 漫反射\n    float Fd90 = 0.5 + 2.0 * LdotH * LdotH * material.roughness;\n    float FL = SchlickFresnel(NdotL);\n    float FV = SchlickFresnel(NdotV);\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n    // 次表面散射\n    float Fss90 = LdotH * LdotH * material.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n    // 镜面反射 -- 各向异性\n    float aspect = sqrt(1.0 - material.anisotropic * 0.9);\n    float ax = max(0.001, sqr(material.roughness)/aspect);\n    float ay = max(0.001, sqr(material.roughness)*aspect);\n    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n\n    // 清漆\n    float Dr = GTR1(NdotH, mix(0.1, 0.001, material.clearcoatGloss));\n    float Fr = mix(0.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);\n\n    // sheen\n    vec3 Fsheen = FH * material.sheen * Csheen;\n    \n    vec3 diffuse = (1.0/c_pi) * mix(Fd, ss, material.subsurface) * Cdlin + Fsheen;\n    vec3 specular = Gs * Fs * Ds;\n    vec3 clearcoat = vec3(0.25 * Gr * Fr * Dr * material.clearcoat);\n\n    return diffuse * (1.0 - material.metallic) + specular + clearcoat;\n}\n\nvec3 brdf_Evaluate(vec3 V, vec3 N, vec3 L, in Material material)\n{\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if(NdotL < 0. || NdotV < 0.) return vec3(0.);\n\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n\n    // 各种颜色\n    vec3 Cdlin = material.baseColor;\n    float Cdlum = 0.3 * Cdlin.r + 0.6 * Cdlin.g  + 0.1 * Cdlin.b;\n    vec3 Ctint = (Cdlum > 0.) ? (Cdlin/Cdlum) : (vec3(1.));   \n    vec3 Cspec = material.specular * mix(vec3(1), Ctint, material.specularTint);\n    vec3 Cspec0 = mix(0.08*Cspec, Cdlin, material.metallic); // 0° 镜面反射颜色\n    vec3 Csheen = mix(vec3(1), Ctint, material.sheenTint);   // 织物颜色\n\n    // 漫反射\n    float Fd90 = 0.5 + 2.0 * LdotH * LdotH * material.roughness;\n    float FL = SchlickFresnel(NdotL);\n    float FV = SchlickFresnel(NdotV);\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n    // 次表面散射\n    float Fss90 = LdotH * LdotH * material.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n     \n    // 镜面反射 -- 各向同性\n    float alpha = max(0.001, sqr(material.roughness));\n    float Ds = GTR2(NdotH, alpha);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs = smithG_GGX(NdotL, material.roughness);\n    Gs *= smithG_GGX(NdotV, material.roughness);\n\n    // 清漆\n    float Dr = GTR1(NdotH, mix(0.1, 0.001, material.clearcoatGloss));\n    float Fr = mix(0.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);\n\n    // sheen\n    vec3 Fsheen = FH * material.sheen * Csheen;\n    \n    vec3 diffuse = (1.0/c_pi) * mix(Fd, ss, material.subsurface) * Cdlin + Fsheen;\n    vec3 specular = Gs * Fs * Ds;\n    vec3 clearcoat = vec3(0.25 * Gr * Fr * Dr * material.clearcoat);\n\n    return diffuse * (1.0 - material.metallic) + specular + clearcoat;\n}\n\nfloat brdf_Pdf(vec3 V, vec3 N, vec3 L, in Material material) {\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if(NdotL < 0. || NdotV < 0.) return 0.;\n\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n     \n    // 镜面反射 -- 各向同性\n    float alpha = max(0.001, sqr(material.roughness));\n    float Ds = GTR2(NdotH, alpha); \n    float Dr = GTR1(NdotH, mix(0.1, 0.001, material.clearcoatGloss));   // 清漆\n\n    // 分别计算三种 BRDF 的概率密度\n    float pdf_diffuse = NdotL / c_pi;\n    float pdf_specular = Ds * NdotH / (4.0 * dot(L, H));\n    float pdf_clearcoat = Dr * NdotH / (4.0 * dot(L, H));\n\n    // 辐射度统计\n    float r_diffuse = (1.0 - material.metallic);\n    float r_specular = 1.0;\n    float r_clearcoat = 0.25 * material.clearcoat;\n    float r_sum = r_diffuse + r_specular + r_clearcoat;\n\n    // 根据辐射度计算选择某种采样方式的概率\n    float p_diffuse = r_diffuse / r_sum;\n    float p_specular = r_specular / r_sum;\n    float p_clearcoat = r_clearcoat / r_sum;\n\n    // 根据概率混合 pdf\n    float pdf = p_diffuse   * pdf_diffuse \n              + p_specular  * pdf_specular\n              + p_clearcoat * pdf_clearcoat;\n\n    pdf = max(1e-7, pdf);\n    return pdf;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stycDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 163]], "test": "untested"}
{"id": "ddSfzz", "name": "Ellen [263 Char]", "author": "Kris_Katur", "description": "\"In Space, No One Can Hear You Scream.\"\n\nvariation with 140 characters in javascript on dwitter:\nhttps://beta.dwitter.net/d/28136", "tags": ["flame", "sine", "cosine"], "likes": 4, "viewed": 130, "published": 3, "date": "1689351432", "time_retrieved": "2024-07-30T17:44:39.349622", "image_code": "#define PI 3.1415926\n#define s(a) sin(a)\n#define c(a) cos(a)\n#define t iTime\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec2  uv=I/iResolution.xy;\n    float x=uv.x,\n          y=uv.y,\n          f=(s((x)*PI*2.+y*PI*s(c(t*.7-y)+s(y-t)*9.)*.2-PI/2.)-y)*(y*PI+.3);\n    O=vec4(f,f-y,f*.5-y*sin(x*PI*2.+t),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 116, 116, 306]], "test": "untested"}
{"id": "dsBBzR", "name": "Moving tile", "author": "Moumouke", "description": "Tiling", "tags": ["tiling"], "likes": 2, "viewed": 165, "published": 3, "date": "1689334167", "time_retrieved": "2024-07-30T17:44:40.180400", "image_code": "// https://iquilezles.org/articles/palettes/\nvec3 palette(float t) {\n    vec3 a=vec3(0.788,0.788,0.688);\n    vec3 b=vec3(0.000,0.048,-0.052);\n    vec3 c=vec3(3.138,-0.642,1.018);\n    vec3 d=vec3(2.488,0.333,0.667);\n    return a+b*cos(6.28318*(c*t+d));\n}\n\nfloat h2(vec2 p)\n{\n    p  = 75.0*fract(p* 1.414213562);\n    return fract(p.x*p.y*(p.x+p.y));\n}\n\nfloat h1(float x)\n{\n    x  = 75.0*fract(12.93145 + x * 1.414213562);\n    return fract(x);\n}\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 s = vec2(1.,0.);\n    float a = h2(p+s.yy);\n    float b = h2(p+s.xy);\n    float c = h2(p+s.yx);\n    float d = h2(p+s.xx);\n\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    return -1.+2.*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.xy;\n    uv *= 12.;\n\n    float s = iTime * h1(floor(uv.y + .5) * 10.) * 5.;\n    if (mod(uv.y +.5, 2.) <= 1.) s *= -1.;\n\n    float l = length(floor(uv.xyx + vec3(s, 0., s) - vec3(.5)));\n    vec3 col = palette(l);\n    col += noise((uv + vec2(s,0.) ) * 1.5) / 8.;\n    col /= 1.2;\n    float d = abs(fract(uv.x + s)  - .5);\n    d = min(d, abs(fract(uv.y)- .5));\n    if (d <= 0.1) {\n        float f = smoothstep(0., 0.1, d);\n        col = mix(vec3(f), col, f);\n    }\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 68, 68, 253], [255, 255, 273, 273, 349], [351, 351, 370, 370, 442], [444, 444, 468, 468, 768], [770, 770, 825, 825, 1374]], "test": "untested"}
{"id": "dssBDs", "name": "shine rot_2", "author": "chenxianming", "description": "original creation clip design source download for free\nhttp://benchart.cn/whirl_1170x2532@x2_60fps.mp4", "tags": ["raymarching", "cineshader"], "likes": 3, "viewed": 940, "published": 3, "date": "1689311318", "time_retrieved": "2024-07-30T17:44:40.993228", "image_code": "float m(float a) { return fract(iTime * a) * 3.141593 * 4.; }\nint n = 0;\nmat2 j(float a) {\n  float b = sin(a), c = cos(a);\n  return mat2(c, b, -b, c);\n}\nvec4 v = vec4(0), e = vec4(0);\nfloat g(vec3 a) {\n  float b = 5.;\n  a.y -= .1, a.yz *= j(.282743), a.xy *= j(m(-.025)), a.xy *= j(a.z * -.8),\n      a.z += fract(-iTime * .25),\n      a = mod(a, vec3(.5, .5, .5)) - vec3(.25, .25, .25),\n      b = max(length(a.xy) - .05, abs(a.z) - .251), n == 1 ? v.a = b : e.a = b;\n  return b;\n}\nvec3 o(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * g(b + a.xyy * 5e-4) + a.yyx * g(b + a.yyx * 5e-4) +\n                   a.yxy * g(b + a.yxy * 5e-4) + a.xxx * g(b + a.xxx * 5e-4));\n}\nvec3 l(vec2 a) {\n  vec2 b = a.xy - .5, c = b.xy * b.xy +\n                          sin(a.x * 18.) / 25. * sin(a.y * 7. + 1.5) +\n                          a.x * sin(0.) / 16. + a.y * sin(1.2) / 16. + a;\n  float d = sqrt(abs(c.x + c.y * .5) * 25.) * 5.;\n  return vec3(sin(d * 1.25 + 2.), abs(sin(d * 1. - 1.) - sin(d)),\n              abs(sin(d) * 1.));\n}\nfloat p(inout vec3 a, inout float b, inout float c, vec3 h, inout vec3 i,\n        int k) {\n  float d = 0.;\n  for (int f = 0; f < 130; f++) {\n    a = h + i * b, c = g(a);\n    if (b > 1000.)\n      break;\n    b += c * .32222, d += c * (1. - (a.z / 2. + .5));\n  }\n  return d;\n}\nvoid w(vec3 q, vec3 b) {\n  n++;\n  float r = 0., h = 0.;\n  vec3 i = normalize(vec3(.57703));\n  i.xy *= j(m(.25));\n  vec3 s = normalize(i - b), c = vec3(0);\n  float d = p(c, r, h, q, b, 0);\n  if (h < 1e-3) {\n    vec3 a = o(c);\n    float z = dot(a, vec3(0, -.3, 0)),\n          f = clamp(dot(a, vec3(2.1, -1, -5)), 0., 1.),\n          t = clamp(dot(a, vec3(0, -.5, .3)), 0., 1.),\n          x = clamp(dot(a, vec3(.5, -1.1, -5.1)), 0., 1.),\n          u = pow(clamp(dot(a, s), .52, 2.), 50.);\n    u *= f + t;\n    vec3 k = reflect(a, b * .1);\n    float y = exp(-.0121 * d * d);\n    e.rgb = f * l(k.xy) + t * l(k.xy) * .2 + x * l(k.xy) * .15, e.rgb *= .3,\n    e.rgb += sign(e.rgb) * .6, e.rgb *= f,\n    e.rgb += vec3(u * vec3(.5)) +\n             (.5 + .35 * cos(f + b.xyx * 2. + vec3(0, 2, 4))) * .4,\n    e.rgb *= y;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 a = fragCoord.xy / iResolution.xy;\n  a = (a - .5) * 2., a.x *= iResolution.x / iResolution.y;\n  vec3 b = vec3(1), c = vec3(0, 0, -3), d = vec3(a, 1);\n  w(c, d);\n  b = e.rgb;\n  fragColor = vec4(b, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [73, 73, 90, 90, 152], [184, 184, 201, 201, 479], [480, 480, 499, 499, 691], [692, 692, 708, 708, 1044], [1045, 1045, 1135, 1135, 1318], [1319, 1319, 1343, 1343, 2131], [2133, 2133, 2188, 2188, 2397]], "test": "untested"}
{"id": "cdlBDl", "name": "Multiple Color Ray Marching", "author": "tristanantonsen", "description": "How to assign multiple colors when ray marching. Based on the way iq does it: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=8470s", "tags": ["raymarching", "sdf", "tutorial", "colors", "comments"], "likes": 0, "viewed": 234, "published": 3, "date": "1689300073", "time_retrieved": "2024-07-30T17:44:41.914763", "image_code": "// Ray marching constants\n#define MAX_STEPS 100\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    float y = 0.1 * sin(iTime);\n    float x = 0.2 * cos(iTime);\n\n\n    vec2 res;\n    \n    // Sphere 1: red\n    float s1 = sdSphere(p, vec3(0.5, y, 0.),0.6);\n    res = vec2(s1, 1.0); // id to track color\n    \n    // Sphere 2: blue\n    float s2 = sdSphere(p, vec3(x, -y, 0.),0.7);\n    if (s2 < res.x) res.y = 2.0; // if the distance is smaller here, assign the color\n    res.x = opSmoothUnion(s1, s2, 0.1); // assign after combining, since it's a union\n    \n    // Sphere 3: green\n    float s3 = sdSphere(p, vec3(m.x, m.y, -1.),0.8);\n    res.x = opSmoothSubtraction(res.x, s3, 0.05); // combine before assigning, since it's a subtraction\n    if (s3 < res.x+SURF_DIST) res.y = 3.0; // offset slightly to prevent artifacts\n   \n   // Sphere 4: purple\n    float s4 = sdSphere(p, vec3(m.x, m.y, -1.),0.2);\n    if (s4 < res.x) res.y = 4.0; // if the distance is smaller here, assign the color\n    res.x = opUnion(res.x, s4); // assign after combining, since it's a union\n    \n\n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec2(d, mat);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., 0., -10.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec2 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(mix(0.1, 0.2, smoothstep(0.0, 1.0, uv.y)));\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 color = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n        fragColor = vec4(color, 1.0);\n        \n        // \n        if (d.y == 1.) fragColor.yz *= 0.5;\n        if (d.y == 2.) fragColor.xyz *= vec3(0.5, 0.5, 0.9);\n        if (d.y == 3.) fragColor.xyz *= vec3(0.5, 0.9, 0.5);     \n        if (d.y == 4.) fragColor.xyz *= vec3(0.9, 0.5, 0.9);        \n        \n        \n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 282, 324, 324, 360], [362, 362, 405, 405, 435], [586, 586, 622, 622, 643], [645, 645, 686, 746, 773], [774, 774, 816, 816, 842], [844, 844, 894, 894, 993], [994, 994, 1050, 1050, 1150], [1151, 1151, 1207, 1207, 1306], [1308, 1308, 1336, 1336, 1486], [1645, 1645, 1663, 1676, 2722], [2724, 2724, 2757, 2757, 3070], [3072, 3072, 3095, 3095, 3429], [3431, 3431, 3476, 3503, 4104], [4107, 4107, 4164, 4214, 5164]], "test": "untested"}
{"id": "cssfWs", "name": "2D Ray Marching Demo", "author": "tristanantonsen", "description": "A simple 2D visualization of how ray marching works. The ray \"marches\" along the direction from the mouse position to the target point.", "tags": ["2d", "raymarching", "sdf", "tutorial", "demo", "comments"], "likes": 7, "viewed": 282, "published": 3, "date": "1689297605", "time_retrieved": "2024-07-30T17:44:42.874198", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100. \n#define SURF_DIST 0.01\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return length(p-c) - r;\n}\n\n\n// SDFs and operations from iq:\n// https://iquilezles.org/articles/distfunctions2d/\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\n\n// Scene SDF\nfloat map(vec2 p) {\n    float d = sdCircle(p, vec2(-0.35, 0.5*sin(0.2*iTime)), 0.25);\n    d = abs(d)-0.05;\n    d = opUnion(d, sdCircle(p, vec2(0.15,0.5*cos(0.1*iTime)), 0.125));\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord - 0.5*iResolution .xy)/iResolution.y;\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y / 2.0;  \n\n    // Scene distance\n    float d = map(uv) * 255.;\n    \n    // Ripple frequency\n    float f = 1.;\n    \n    vec3 ripples = mix(vec3(1.), vec3(0.9), smoothstep(0., 1., sin(f*d)*0.5+0.5));\n    \n    // Mixing ripples with (black) SDF\n    vec3 col = mix(vec3(0.), ripples, smoothstep(0., 1., d));\n    \n    // Ray marching:\n    \n    // Ray origin\n    vec2 ro = m;\n    \n    // Ray direction\n    vec2 target = vec2(-0.8, 0.);\n    vec2 rd = normalize(target - ro);\n\n    float t = 0.0; // tracks total distance traveled from origin to target\n    float circles = 1.; // visualization\n    \n    // Ray marching\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec2 p = ro + rd * t; // move point to new evaluation step\n        float ts = map(p); // current SDF value @ p\n        t += ts; // add to total distance traveled\n        \n        // circles for visualization\n        circles = opUnion(circles, abs(sdCircle(uv, p, ts)+0.0001));\n        \n        if (t >= MAX_DIST || ts < SURF_DIST) break; // \"hit\"\n        i++;\n    }\n    \n    // Visuals\n    circles = smoothstep(1., 0., 255. * (circles));\n    \n    float line = udSegment(uv, m, target);\n    line = opUnion(line, sdCircle(uv, ro, 0.01));\n    line = opUnion(line, sdCircle(uv, target, 0.01));\n    line = smoothstep(1., 0., 255. *(line));\n    \n    vec3 fin = mix(col, vec3(0.4,0.7,0.5), circles);\n    fin = mix(fin, vec3(0.2,0.4,0.7), line);\n    \n    fragColor = vec4(fin, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 110, 110, 140], [143, 227, 279, 279, 402], [405, 405, 441, 441, 462], [465, 478, 497, 497, 671], [674, 674, 731, 767, 2377]], "test": "untested"}
{"id": "DslBWs", "name": "Learn Shaders", "author": "ishwish2008", "description": "Learn Shaders", "tags": ["learn"], "likes": 0, "viewed": 121, "published": 3, "date": "1689294421", "time_retrieved": "2024-07-30T17:44:44.070998", "image_code": "const uint k = 1103515245U;\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.0;\n    \n    fragColor = vec4(hash(uvec3(fragCoord.x, fragCoord.y, iTime)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 51, 51, 184], [188, 188, 245, 295, 423]], "test": "untested"}
{"id": "dd2yWz", "name": "Trippy wavez", "author": "Chick_Chicky", "description": "trippy shader", "tags": ["2d", "weird"], "likes": 0, "viewed": 138, "published": 3, "date": "1689284863", "time_retrieved": "2024-07-30T17:44:45.147121", "image_code": "const float pi = 3.14159265f;\n\nfloat fn(float x,float y,float n,float m) { \n    n *= pow(iTime,1.5);\n    m *= pow(iTime,1.5);\n    return sin(n*pi*x)*cos(m*pi*y) - sin(m*pi*x)*cos(n*pi*y); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float v = fn( uv.x*5.f, uv.y*5.f, 1.f, 4.f ) / 2.f;\n    vec3 col = vec3(v,0,v);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2yWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 74, 74, 190], [192, 192, 249, 249, 412]], "test": "untested"}
{"id": "msffDS", "name": "Shrinking Circles 2", "author": "Wheat", "description": "following a tutorial", "tags": ["simple"], "likes": 0, "viewed": 128, "published": 3, "date": "1689283190", "time_retrieved": "2024-07-30T17:44:45.957953", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set scale; sizes to y resolution\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // find points a certain distance from circle w/ .5 radius\n    float d = length(uv);\n    d = sin(d * 8.0 + iTime * 10.0) / 8.0;\n    d = abs(d) * 2.0;\n    \n    // \n    d = smoothstep(0.0, .1, d);\n    \n    vec3 col = vec3(d,d,d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msffDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 97, 454]], "test": "untested"}
{"id": "msfBWB", "name": "Spinning Spiral", "author": "Wheat", "description": "first experiment; spinoff of shrinking circles 2", "tags": ["simple"], "likes": 3, "viewed": 181, "published": 3, "date": "1689283144", "time_retrieved": "2024-07-30T17:44:46.787735", "image_code": "// Fork of \"Shrinking Circles 2\" by Wheat. https://shadertoy.com/view/msffDS\n// 2023-07-11 23:10:32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set scale; sizes to y resolution\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // find points a certain distance from circle w/ .5 radius\n        // float d = length(uv);\n        // d = sin(d * 8.0 + iTime) / 8.0;\n        // d = abs(d);\n        \n    // make a spiral (angle from x-axis: atan(y/x))\n    float tightness = 1.;\n    float speed = .6;\n    float sufficientlyLargeFloat = 100.;\n    float numPins = 8.0; // keep even\n    // makes distance from center, angle from x-axis,\n    // and time factors\n    float d = length(uv)\n        + atan(uv.y / uv.x) / tightness\n        + iTime * speed\n        + sufficientlyLargeFloat;\n    d = abs(d);\n    // makes it repeat\n    d = sin(d*numPins)/8.0;\n    \n    d = smoothstep(0.0, .1, d);\n    \n    vec3 col = vec3(d,d,d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 158, 198, 1011]], "test": "untested"}
{"id": "cslBWH", "name": "String of blobs", "author": "Larbagar", "description": "A bunch of blobs that like each other in a line", "tags": ["blobs"], "likes": 7, "viewed": 192, "published": 3, "date": "1689278977", "time_retrieved": "2024-07-30T17:44:47.657409", "image_code": "#define PI 3.1415926535897932384626433832795\n#define threshold 0.5\n#define range 0.2\n\nfloat blobFunc(float dist){\n    return pow(max(1. - dist, 0.), 2.);\n}\n\nvec2 path(float t){\n    return vec2(sin(t*2.*PI), sin(4.*t*PI)/2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float val1 = 0.;\n    float val2 = 0.;\n    float val3 = 0.;\n    \n    int points = 20;\n    for(int i = 0; i < points; i++){\n        float normalIndex = float(i)/float(points);\n        float size = 0.1 + normalIndex*0.2;\n        float time = iTime*0.5 + normalIndex*0.25;\n        \n        \n        float pointDist1 = time;\n        vec2 pos1 = path(pointDist1);\n        float dist1 = length(pos1 - uv);\n        val1 += blobFunc(dist1/size);\n        \n        \n        float pointDist2 = time - 2./3.;\n        vec2 pos2 = path(pointDist2);\n        float dist2 = length(pos2 - uv);\n        val2 += blobFunc(dist2/size);\n        \n        float pointDist3 = time - 4./3.;\n        vec2 pos3 = path(pointDist3);\n        float dist3 = length(pos3 - uv);\n        val3 += blobFunc(dist3/size);\n    }\n\n    float shape1 = smoothstep(threshold - range, threshold, val1);\n    float glow1 = (1. - shape1)*val1/threshold;\n\n    float shape2 = smoothstep(threshold - range, threshold, val2);\n    float glow2 = (1. - shape2)*val2/threshold;\n\n    float shape3 = smoothstep(threshold - range, threshold, val3);\n    float glow3 = (1. - shape3)*val3/threshold;\n    \n    col += shape1;\n    col += vec3(0., 0.5, 1.)*glow1;\n    \n    col += shape2;\n    col += vec3(1., 0., 0.5)*glow2;\n    \n    col += shape3;\n    col += vec3(0.5, 1., 0.)*glow3;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 113, 113, 155], [157, 157, 176, 176, 226], [228, 228, 285, 285, 1734]], "test": "untested"}
{"id": "dsffWl", "name": "Chromatic Descent [384 chars]", "author": "kishimisu", "description": "psychedelic raymarching", "tags": ["3d", "raymarching", "colorful", "space", "repetition", "psychedelic", "rgb", "code", "short", "golf", "golfing"], "likes": 29, "viewed": 835, "published": 3, "date": "1689272291", "time_retrieved": "2024-07-30T17:44:48.617841", "image_code": "/* \"Chromatic Descent\" by @kishimisu (2023) - https://www.shadertoy.com/view/dsffWl\n   [404 => 384 chars with the help of @SnoopethDuckDuck & @coyote]\n   \n   Inspired from my upcoming youtube tutorial about raymarching\n   (probably available in september)\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n*/\n\n#define r mat2(cos(.05*a + vec4(0,33,11,0))), p\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    float i, t, k = iTime, \n                d = k, \n                a = k*3.;\n    vec3  f,    p = iResolution, \n                U = vec3((u + u - p.xy) * r.y);\n    \n    for ( f++, f.z = .2; i++ < 6e1 && d > t/2e2;\n        p = t * U / length(U),\n        p.zy *= r.xz *= r.z += k*.5,\n        O = .7 * (.8 + cos(length(floor(p*5.))/3. + k + .7*vec4(0,1,2,0)))/exp(t/7.)            \n    )\n        a = sin(t += d = length(max( p = abs(mod(p, f)-f*.5)-cos(t)*.04-.06 , 0.)) \n                 + min(max(p, max(p, p.z).y).x, 0.));\n}\n\n/* Original version [404 chars]:\n\n#define r(a) mat2(cos(.05*a + vec4(0,33,11,0))),\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    float i, t, d = 1., k = iTime;\n    vec2 R = iResolution.xy;\n         u += u - R;\n          \n    for ( vec3 p, f = vec3(1,1,.2); i++ < 6e1 && d > t/2e2;\n        p = t * normalize(vec3(u * r(k*3.) R.y)),\n        p.zy *= r(sin(t)) \n        p.xz *= r(sin(t))\n        p.z  += k*.5,\n        O = .7 * (.8 + cos(length(floor(p*5.))/3. + k + .7*vec4(0,1,2,0)))/exp(t/7.)\n            \n    )   t += d = length(max( p = abs(mod(p, f) - f*.5) - cos(t)*.04-.06 , 0.)) \n                 + min(max(p.x, max(p.y, p.z)), 0.);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsffWl.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[486, 486, 524, 524, 1049]], "test": "untested"}
{"id": "csffWl", "name": "Colorful Sans Carne", "author": "timmaffett", "description": "I like color and tunnels!\nremoved carne, mouse controls additive shadow\nreducing MAX_STEPS from 200 -> 30 results in satisfying 'goop'.\nTry going back to 200 to get idea how forked shader looks with the color added.", "tags": ["tunnel", "color", "camera", "mine", "cave", "gyroid", "path", "goop", "lime", "osso"], "likes": 15, "viewed": 257, "published": 3, "date": "1689260249", "time_retrieved": "2024-07-30T17:44:49.532396", "image_code": "// Fork of \"Carne\" by Elsio. https://shadertoy.com/view/msXfDf\n// 2023-07-13 14:22:36\n// Altered color() function and reduced MAX_STEPS from 200->30\n// removed carne return from map(), mouse controls additive shadow\n#define MAX_STEPS 30\n#define MAX_DIST 200.0\n#define EPS 0.01\n#define STEP_COEF .3\n#define NORMAL_COEF EPS * .5\n\n#define funcRayMarch float step, t = 0.; for(int i = 0; i < MAX_STEPS; i++){step = map(ro + t * rd); t += step * STEP_COEF; if(t > MAX_DIST || step < EPS) break;} return t;\n#define funcNormal float d = map(p); vec2 e = vec2(NORMAL_COEF, 0); vec3 n = vec3(d) - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx)); return n;\n#define funcShadow return dot(normalize(normal(p)), normalize(lightPos - p));\n\n#define PI atan(.0, -1.)\n#define T (iTime/2.0)\n#define walk T * 4.\n\n#define rot(a) mat2 (cos(a), sin(a), -sin(a), cos(a))\n#define rotAbs(p, a) length(p) * vec2(sin(a), cos(a))\n#define wmod(s, w) mod(s, w) - w/2.\n\n vec2 mouse;\n\nfloat id;\n\nvec2 path(in float z) {\n    float a = sin(z * .07);\n    float b = cos(z * .09);\n    return 3. * vec2(a + b, a - b);\n}\n\n\nfloat smoothMin(float a, float b, float c, float t){\n    return -log(exp(t * -a) + exp(t * -b) + exp(t * -c)) / t;\n}\n\nfloat smoothMin(float a, float b, float t){\n    return -log(exp(t * -a) + exp(t * -b)) / t;\n}\n\n\n\n\nvec3 tri(vec3 p) {\n    return abs(fract(p) - .5);\n}\n\n\n\nfloat surf(in vec3 p) {\n    return dot(tri(p * .5), vec3(.5)) - p.y*.6;\n}\n\n\n\n\nfloat map(vec3 p) {\n    p.xy -= path(p.z);\n    \n    vec3 q = p * PI/2.;\n    \n    float gyr = dot(cos(q), sin(q.yzx));\n    \n    float osso =  gyr + 1.3;\n    \n    p.xy *= rot(T*.8);\n    \n    float cyl = length(p.xy) - 1.8;\n    float carne = -smoothMin(cyl, gyr, 2.) + surf(p);\n    \n    id = step(carne, osso);\n    \n    //return carne;\n    return osso;\n    return min(carne, osso);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd){funcRayMarch}\nvec3 normal(vec3 p) {funcNormal}\nfloat shadow(vec3 p, vec3 lightPos) {funcShadow}\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\nvec3 color(vec3 ro, float t, vec3 rd, vec3 lightPos){\n    \n    vec3 col2 = hsb2rgb(vec3(0.02*ro.y*3.1514,0.9,0.9))*0.5;\n    vec3 col3 = hsb2rgb(vec3(0.1*(ro.z + t * rd.z)*3.1514,0.9,0.9))*0.5;\n    vec3 col = id < 0.5 ? col3*vec3(1.) : col2+(col3*vec3(clamp(mouse.y/mouse.x,0.1,1.0)*0.8)); //vec3(4,3,2)*.1;\n    \n    col += mouse.y/mouse.x*shadow(ro + t * rd, lightPos); \n    \n    col = mix(/*vec3(1, .1, 0)*/col2, col, 1. / (t / MAX_DIST + .9));\n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mouse = (iMouse.xy == vec2(0.)) ? vec2(0.3,0.1) : iMouse.xy/iResolution.xy;\n    \n\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n#ifdef MOUSESTEERING\n    vec3 lookAt = vec3(mouse.x*3.,-mouse.y*.3, walk);\n#else\n    vec3 lookAt = vec3(0, 1, walk);\n#endif\n    vec3 ro = lookAt + vec3(0, 0, -0.1);\n    vec3 lightPos = ro + vec3(0, 0, 4);\n    \n    lookAt.xy += path(lookAt.z);\n    ro.xy += path(ro.z);\n    lightPos.xy += path(lightPos.z);\n\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n\n    float t = rayMarch(ro, rd);\n\n    \n    vec3 col = color(ro, t, rd, lightPos);\n    \n    fragColor = vec4(col * 2., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csffWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[963, 963, 986, 986, 1080], [1083, 1083, 1135, 1135, 1199], [1201, 1201, 1244, 1244, 1294], [1299, 1299, 1317, 1317, 1350], [1354, 1354, 1377, 1377, 1427], [1432, 1432, 1451, 1451, 1812], [1946, 1946, 1973, 1973, 2208], [2211, 2211, 2264, 2264, 2679], [2682, 2682, 2737, 2737, 3525]], "test": "untested"}
{"id": "dssfzs", "name": "eye creepy", "author": "tachyglossues", "description": "eye creepy", "tags": ["eyecineshader"], "likes": 1, "viewed": 1141, "published": 3, "date": "1689253214", "time_retrieved": "2024-07-30T17:44:50.478865", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n\n    float time =iTime+1.;\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    d = pow(d,0.8);\n    d =fract((time/6.5)+1192.*sqrt(d*d)*(d*(fract(tan(d)*0.07))))-(abs(uv.y*1.2))*length(uv);\n    \n    fragColor = vec4(d*1.9 ,0., 0.01,1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 340]], "test": "untested"}
{"id": "ddXfWj", "name": "Audio Passage", "author": "QuantumSuper", "description": "An auto-VJ utilizing the audio spectrum over time to draw passing surfaces. One could potentially use such passing sound textures as triggers for a more complex design, e.g. an audio-responsive train ride.\n\n- Use with music in iChannel0 of Buffer A - ", "tags": ["2d", "music", "buffer"], "likes": 2, "viewed": 255, "published": 3, "date": "1689242592", "time_retrieved": "2024-07-30T17:44:51.363500", "image_code": "// Audio Passage 0.8.230713 by QuantumSuper\n// 2.5d buffered auto-vj utilizing the audio spectrum over time to draw passing surfaces\n// \n// - use with music in iChannel0 of Buffer A -\n\nvec3 getCol(float id){ //color definitions, for triplets\n    vec3 setCol = vec3(0);\n    id = mod(id,15.);\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\n    else if (id<13.) setCol = vec3( 28,142, 77); //matrix green\n    else if (id<14.) setCol = vec3( 66,120, 91); //matrix green 2\n    else if (id<15.) setCol = vec3(173,  0, 27); //matrix red\n    return setCol/256.;\n}\n\nfloat aaStep( float fun){return smoothstep( fwidth(fun), .0, fun);} //simple antialiasing\n\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p) - b;\n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\n}\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b){//source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // Read compression values from buffer\n    vec4 fft, ffts;\n    for (int n=0;n<4;n++) \n        fft[n] = getDat( iChannel0, vec2( mod(float(iFrame),iResolution.x), n)).a,\n        ffts[n] = getDat( iChannel0, vec2( mod(float(iFrame),iResolution.x), n+4)).a;\n    if (getDat( iChannel0, vec2( mod(float(iFrame),iResolution.x), 1)).b > getDat( iChannel0, vec2( mod(float(iFrame-1),iResolution.x), 1)).b)\n        fft.x *= 10.; //amplify when 44.1kHz/512. to 44.1kHz/512.*2. amplitude is larger than buffered maximum amplitude\n\n    // Prepare view\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x,iResolution.y); //long edge -1 to 1\n    vec2 uv0 = uv; \n    uv.x = abs(uv.x); //1 to 0 to 1\n    uv.y /= uv.x*2.+.002; //approx. -.5 to -inf to inf to .5\n    float tmp = .93+.07*cos(iTime*.123)*sin(iTime*.456);\n    uv *= tmp, uv0 *= tmp; //scale over time\n    \n    // Front \"landscape\" layer\n    vec3 col = vec3(0.);\n    for (int n=0;n++<3;)\n        col.r += getDatN( iChannel0, vec2( mod( float(-pow(uv.x * iResolution.x,.6))*.5 + mod(float(iFrame)+pow(.105 * iResolution.x,.6)*.5,iResolution.x), iResolution.x) , n+1));\n    col.r = clamp( (pow((col.r/3.-.98)/.02,9.)-.75*uv.y)*4.*getDat( iChannel0, fragCoord).r, .0, 1.);\n    \n    // Mid \"landscape\" layer \n    tmp = mod( -pow(uv.x * iResolution.x,1e-3)*7e4+ mod(float(iFrame)+pow(.09 * iResolution.x,1e-3)*7e4,iResolution.x), iResolution.x);\n    col.g = (getDat( iChannel0, vec2( tmp, 1.)).a - .33) / .67;\n    col.g = clamp( (col.g*col.g - uv.y*3.) * getDat( iChannel0, vec2( tmp, (.4999+.5*cos(uv.y*3.))*iResolution.y)).r * 2., .0, 1.);\n    \n    // Back \"landscape\" layer\n    tmp = mod( -pow(uv.x * iResolution.x,1e-5)*13e6 + mod( float(iFrame)+pow(.09 * iResolution.x,1e-5)*13e6, iResolution.x), iResolution.x);\n    col.b = getDat( iChannel0, vec2( tmp, 7.)).a;\n    col.b = clamp( clamp( (col.b*col.b*col.b-uv.y*.6) * getDat( iChannel0, vec2( tmp, (.4999+.5*sin(uv.y*6.))*iResolution.y)).r, .0, 1.) * 1.3 - max(col.r,col.g), .0, 1.);\n    \n    // \"Hallway\" geometry \n    tmp = 1.-aaStep( sdBox( uv, vec2(1)));\n    float amp = min( \n        max( \n            aaStep( sdBox( uv, vec2(1.,.7))), //triangle shapes\n            sign(uv.y)*tmp), //top cutout\n        (1.-aaStep( sdBox( uv0, vec2(.095,.16))))); //center rectangular\n    if (uv0.y<-.16) amp *= (1.-tmp); //bottom delete\n    col *= amp; //delete col    \n    col += ((1.-amp) *.4 //hallway\n        + tmp * getDat( iChannel0, vec2(mod(float(iFrame),iResolution.x), (1.4+uv0.y*2.5)*iResolution.y)).r) //floor texture\n        * getDat( iChannel0, vec2(mod(float(iFrame),iResolution.x),mod((1.2+uv0.y*2.),1.)*iResolution.y)).b * (.017 + .08*fft.xyz*fft.xyz) * 1.8; //overall texture\n    col *= 1.-aaStep( sdBox( uv0, vec2(.05,.11))-.02); //delete col, \"door\"\n    \n    // Smiley\n    uv0 *= smoothstep( .0, .33, ffts.w); //scale\n    col += max( \n        .001 / length( vec2( abs(uv0.x), uv0.y) - vec2( .018, .05)), //\"eyes\"\n        .001 / sdSegment( uv0+vec2( .0, .013*cos(uv0.x*42.+3.142*(1.-max(fft.x,fft.y)))), vec2(-.02,.01), vec2(.02,.01))) //\"mouth\"\n        * (1.-fft.x) * vec3(ffts.x<=ffts.y,ffts.y<=ffts.z,ffts.z<=ffts.x); //color   \n    \n    // Remap colors\n    float colId = 3. * floor(mod(127./60./16.*iTime,5.)); //color set id \n    col = mat3(getCol(colId+0.),getCol(colId+1.),getCol(colId+2.)) * col;\n    col = (col + (fft.x-1.) * smoothstep(.1,.0,length(col))) * 1.7; //flashes \n    fragColor = vec4( col, 1.); //output \n    \n    // Utility\n    //fragColor = vec4( getDat( iChannel0, fragCoord).rrr, 1); //audio spectrum over time\n    //fragColor = vec4( getDat( iChannel0, fragCoord).ggg, 1); //wave form over time\n    //fragColor = vec4( getDat( iChannel0, fragCoord).bbb, 1); //average amplitude over time\n    //fragColor = vec4( getDat( iChannel0, vec2(fragCoord.x,fragCoord.y/iResolution.y*8.)).aaa, 1); //compressed over time\n    //fragColor = vec4(step(.0,(fragCoord.y/iResolution.y-.9)),vec2(dot(step(.0,fft-abs(floor(fragCoord.x/iResolution.x*4.-vec4(0,1,2,3)))-fragCoord.y/iResolution.y/.9),vec4(1))),1); //final compression data\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// COMMON (0.1) of Audio Passage Of Sound by QuantumSuper\n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define getDat( buf, addr) texelFetch( buf, ivec2(addr), 0)\n#define getDatN( buf, addr) getDat( buf, addr).r / getDat( buf, addr).b", "buffer_a_code": "// BUFFER A (0.1) of Audio Passage by QuantumSuper\n// audio spectrum over time\n// red: amplitude by brightness of frequency by y-axis at time by x-axis\n// green: waveform by brightness of frequency by y-axis at time by x-axis\n// blue: average amplitude by brightness of frequency by y-axis at time by x-axis\n// alpha: (fft,ffts,0..0)\n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define TRACKDURATIONINFRAMES 3600.\nvec4 fft, ffts; //compressed frequency amplitudes\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nfloat estMax(float p){ //estimate changing maximum over time of sound texel by weighted amplitude tracking\n    float curVal = clamp( getDat( iChannel0, vec2( p/iResolution.y*512., 0)).x, .0, 1.); //current amplitude\n    float maxVal = clamp( getDat( iChannel1, vec2( (mod(float(iFrame-1)+.001,iResolution.x)), p)).z, .0, 1.); //latest max amp\n    \n    if (curVal >= maxVal) maxVal = 0.; //check for new max    \n    \n    if (maxVal != 0.) //avoid uninitialized state & deprecated maxVal\n        curVal *=    1./TRACKDURATIONINFRAMES,\n        maxVal *= 1.-1./TRACKDURATIONINFRAMES;\n  \n    return maxVal+curVal; //returns value between 0 and 1\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    compressFft(); //initializes fft, ffts\n    fragColor = (mod(fragCoord.x-float(iFrame),iResolution.x)<1.)? vec4( \n        getDat( iChannel0, vec2( fragCoord.y/iResolution.y*512., 0)).x, //amplitudes\n        getDat( iChannel0, vec2( fragCoord.y/iResolution.y*512., 1)).x, //waveform\n        estMax( fragCoord.y), //average amplitude\n        (fragCoord.y<4.)? fft[int(fragCoord.y)] : (fragCoord.y<8.)? ffts[int(fragCoord.y)-4] : 0.) //compressed amplitude\n        : getDat( iChannel1, fragCoord); //carry over \"long-term\" memory    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33941, "src": "https://soundcloud.com/notmytype030/sweating-on-the-dancefloor", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 207, 241, 1274], [1276, 1276, 1301, 1301, 1343], [1367, 1367, 1396, 1455, 1535], [1537, 1537, 1578, 1636, 1754], [1756, 1756, 1811, 1855, 5880]], "test": "untested"}
{"id": "DslfWf", "name": "TruchetTiling4489", "author": "shaderNoob4489", "description": "generate truchet tiling", "tags": ["2d", "truchet"], "likes": 1, "viewed": 55, "published": 3, "date": "1689237517", "time_retrieved": "2024-07-30T17:44:52.188295", "image_code": "float Hash21(vec2 p)\n{\n    p = fract(p *vec2(234.34, 435.345));\n    p += dot(p, p + 34.32);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    uv += iTime * .2;\n    uv *= 5.;\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id);\n    float width = .2 * UV.y;\n    \n    if (n < .5) gv.x *= -1.;\n    \n    //straight line\n    //float d = abs(abs(gv.x + gv.y) - .5);\n    //float mask = smoothstep(.01, -.01, d - width);\n    \n    //circle\n    vec2 cUv = gv - sign(gv.x + gv.y + .001) * .5;\n    float d = length(cUv);\n    float mask = smoothstep(.01, -.01, abs(d - .5) - width);\n    float angle = atan(cUv.x, cUv.y);\n    float checker = mod(id.x + id.y, 2.) * 2. - 1.;\n    float flow = sin(iTime + checker * angle * 10.);\n    //col += flow * mask;\n    //float x = fract(angle / 1.5707 + checker * iTime * .3);\n    float x = angle / 1.5707 + checker * iTime * .3;\n    float y = (d - (.5 - width)) / (2. * width);\n    y = abs(y - .5) * 2.;\n    vec2 tUv = vec2(x, y);\n    col += texture(iChannel0, tUv).rgb * mask;\n    col *= (1. - tUv.y);\n    \n    //if (gv.x > .48 || gv.y > .48)\n    //{\n    //    col = vec3(1., 0., 0.);\n    //}\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslfWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 122], [124, 124, 181, 181, 1393]], "test": "untested"}
{"id": "DdlBWf", "name": "barycentric dithering (Cleanup)", "author": "gehtsiegarnixan", "description": "dithering schema using barycentric coordinates, with more comments and cleaned up a bit with a bit more control. \nI bet noone can figure out what this is used for lol. Maybe I'll make a demo at some point.", "tags": ["dither", "barycentric", "hash"], "likes": 4, "viewed": 239, "published": 3, "date": "1689235372", "time_retrieved": "2024-07-30T17:44:53.041015", "image_code": "/*\nThis shows how to dither a Barycentric coordinate system. \nI played around with a bunch of variations and performance tested them. \nsee https://www.shadertoy.com/view/msXfWs\n\nThis is a cleaned up and slightly improved version of dud31 original idea \n(https://www.shadertoy.com/view/DdlBDX)\n*/\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n// https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash12C(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n// valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nfloat ScreenSpaceDither12(vec2 vScreenPos) {\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iTime); \n    return fract( vDither / 103.0);\n}\n\nfloat deter(vec2 a, vec2 b) { \n    return a.x*b.y - a.y*b.x; \n}\n\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) {\n    float ar = deter(b - a, c - a);\n    float w = deter(b - a, p - a) / ar;\n    float v = deter(a - c, p - c) / ar;\n    vec3 s = vec3(1.0 - v - w, v, w);\n    return s;\n}\n\nvec2 rot(vec2 v, float th) {\n    return vec2(v.x*cos(th) - v.y*sin(th), v.x*sin(th) + v.y*cos(th));\n}\n\n// a is 0-1 and contrast is 1-inf with 1 being original contrast\nvec3 smoothContrast(vec3 a, float contrast) {\n    vec3 powA = vec3(pow(a.x, contrast), pow(a.y, contrast), pow(a.z, contrast));\n    return powA/(powA.x + powA.y + powA.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV coords centered on screen\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    // coordinates of corner\n\tvec2 v_a = vec2(1.5,1.0)*cos(iTime + vec2(0.0,1.0) + 0.0 );\n\tvec2 v_b = vec2(1.5,1.0)*cos(iTime + vec2(0.0,1.0) + 1.5 );\n\tvec2 v_c = vec2(1.5,1.0)*cos(iTime + vec2(0.0,1.0) + 3.0 );\n    \n    // 1.- distance to corner\n    vec3 cDist = bary(v_a, v_b, v_c, p);\n    \n    // black mask for outside of triangle\n    float mask = step(0., cDist.x) * step(0., cDist.y) * step(0., cDist.z);\n    \n    // change contrast value\n    float contrast = 2.0;\n    cDist = smoothContrast(cDist, contrast); \n        \n    // noise pattern with range 0-1\n    //float rnd = hash12C(p); // random dither\n    float rnd = ScreenSpaceDither12(fragCoord.xy); // valve animated dither\n    // smooth contrast creates artifacts in the dither. Clamp on the dither removes it\n    rnd = clamp(rnd, 0.01, 0.99); \n    \n    //apply float dither to three values of cDist\n    vec3 col;\n    if (cDist.x > rnd) {\n        col = vec3(1, 0, 0);\n    } else if (1.-cDist.z > rnd) {\n        col = vec3(0, 1, 0);\n    } else {\n        col = vec3(0, 0, 1);\n    }    \n    \n    // apply mask\n    col = col * mask;\n    \n\tfragColor = vec4(col, 1.);\n    \n    // test if all three values togethere are still 1.\n    float sumCheck = fract(col.x + col.y + col.z);\n    //fragColor = vec4(sumCheck);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlBWf.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[567, 567, 590, 590, 679], [681, 866, 910, 910, 1020], [1022, 1022, 1051, 1051, 1085], [1087, 1087, 1130, 1130, 1300], [1302, 1302, 1330, 1330, 1403], [1405, 1470, 1515, 1515, 1643], [1645, 1645, 1702, 1738, 3073]], "test": "untested"}
{"id": "cdsBDX", "name": "Biplanes in the Badlands 2", "author": "dr2", "description": "More antiquated flying machines; an alternative to the original (mouseable)", "tags": ["landscape", "aircraft", "flight"], "likes": 16, "viewed": 251, "published": 3, "date": "1689233778", "time_retrieved": "2024-07-30T17:44:53.995463", "image_code": "// \"Biplanes in the Badlands 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// The Red Baron's personal flyer (and Snoopy's nemesis)\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrConeDf (vec3 p, vec3 b);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Ssign (float x);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN    17\n#define N_FLYER 6\n\nmat3 flyerMat[N_FLYER];\nvec4 cPath[PLEN];\nvec3 flyerPos[N_FLYER], qHit, sunDir;\nvec2 cIdS, cMidS, cIdB, cMidB;\nfloat dstFar, tCur, tEnd[PLEN + 1], hgSizeB, hgSizeS, tLen, cDir, cType, colHt, flSzFac;\nint nFrame, idObj, idObjGrp;\nbool isSh;\nconst int idFus = 1, idPipe = 2, idWngM = 3, idStrut = 4, idWngT = 5, idTail = 6, idLeg = 7,\n   idWhl = 8, idNose = 9, idGun = 10, idPlt = 11, idWal = 12, idGrnd = 13;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n// When is a biplane not a biplane? (from \"Snoopy and the Red Baron 2\")\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 ws;\n  float d, wr, h, qy;\n  int ig;\n  ig = idObjGrp / 256;\n  dMin /= flSzFac;\n  p /= flSzFac;\n  if (! isSh) d = PrRoundBoxDf (p, vec3 (1.2, 0.5, 1.1), 0.02);\n  if (isSh || d < dMin) {\n    q = p;\n    wr = -0.2 + q.z;\n    d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n       0.11 * (1. - 0.6 * wr * wr), 1.), 0.05);\n    d = max (d, - PrRoundBoxDf (q - vec3 (0., 0.16, 0.), vec3 (0.04, 0.03, 0.07), 0.04));\n    DMINQ (idObjGrp + idFus);\n    q = p;\n    q.yz -= vec2 (0.17, 0.5);\n    d = PrCylDf (q, 0.015, 0.15);\n    DMINQ (idObjGrp + idGun);\n    q = p;\n    q.y -= 0.17;\n    d = PrSphDf (q, 0.04);\n    DMINQ (idObjGrp + idPlt);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.1, 0.03, 0.8);\n    d = PrCapsDf (q, 0.02, 0.15);\n    DMINQ (idObjGrp + idPipe);\n    q = p;\n    q.yz -= vec2 (0.03, 1.1);\n    d = PrConeDf (q, vec3 (0.8, 0.6, 0.06));\n    DMINQ (idObjGrp + idNose);\n    q = p;\n    q.yz -= vec2 (((ig == 1) ? 0.12 : 0.09), 0.4);\n    qy = q.y;\n    if (ig == 1) q.y += 0.12;\n    h = (ig == 1) ? 0.24 : 0.42;\n    q.y = mod (q.y, h) - 0.5 * h;\n    d = min (1.2 - abs (q.x), abs (PrBox2Df (vec2 (abs (q.x) - 1., q.z + 0.2), vec2 (0.25, 0.05))));\n    wr = 0.47;\n    h = (q.z - 0.1) / wr;\n    d = max (SmoothMax (PrCaps2Df (vec2 (q.y, q.z + 0.25), 0.03 * (wr - h * h), wr), - d, 0.01),\n       - q.z - 0.22);\n    d = max (d, abs (qy) - 0.26);\n    q.y = qy;\n    DMINQ (idObjGrp + idWngM);\n    q = p;\n    q.yz -= vec2 (((ig == 1) ? 0.12 : 0.09), 0.42);\n    q.xz = abs (q.xz) - vec2 (0.5, 0.1);\n    d = PrCylDf (q.xzy, 0.01, ((ig == 1) ? 0.24 : 0.21));\n    DMINQ (idObjGrp + idStrut);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.1, ((ig == 1) ? 0.24 : 0.15), 0.42);\n    d = PrCylDf (q.xzy, 0.01, ((ig == 1) ? 0.12 : 0.15));\n    DMINQ (idObjGrp + idStrut);\n    q = p;\n    q.z -= -0.9;\n    wr = 0.33;\n    h = (q.z - 0.05) / wr;\n    q.x = abs (q.x);\n    d = min (0.42 - q.x, abs (q.z + 0.06));\n    d = max (SmoothMax (PrCaps2Df (vec2 (q.y, q.z + 0.18), 0.03 * (wr - h * h), wr), - d, 0.01),\n       - q.z - 0.14);\n    d = max (d, 0.02 - 1.5 * q.x - q.z);\n    DMINQ (idObjGrp + idWngT);\n    q = p;\n    wr = 0.28;\n    q.yz -= vec2 (-0.1, -0.98);\n    h = (q.z - 0.1) / wr;\n    d = min (0.24 - abs (q.y - 0.3), abs (PrBox2Df (vec2 (q.y - 0.35, q.z + 0.02), vec2 (0.16, 0.04))));\n    d = SmoothMax (PrCaps2Df (vec2 (q.x, dot (q.zy, sin (0.1 * pi + vec2 (0.5 * pi, 0.)))),\n       0.03 * (wr - h * h), wr), - d, 0.01);\n    d = max (d, - q.z - 0.04);\n    DMINQ (idObjGrp + idTail);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.135, -0.24, 0.7);\n    q.xy = Rot2D (q.xy, -0.55);\n    q.yz = Rot2D (q.yz, 0.15);\n    d = PrCylDf (q.xzy, 0.012, 0.12);\n    DMINQ (idObjGrp + idLeg);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.22, -0.34, 0.715);\n    d = PrCylDf (q.yzx, 0.01, 0.035);\n    DMINQ (idObjGrp + idLeg);\n    q.x -= 0.01;\n    d = PrCylDf (q.yzx, 0.1, 0.015);\n    DMINQ (idObjGrp + idWhl);\n  } else dMin = min (dMin, d);\n  return flSzFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    idObjGrp = ((k < N_FLYER - 1) ? 2 : 1) * 256;\n    dMin = FlyerDf (flyerMat[k] * (p - flyerPos[k]), dMin);\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / flSzFac;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    idObjGrp = ((k < N_FLYER - 1) ? 2 : 1) * 256;\n    q = flyerMat[k] * (p - flyerPos[k]) / flSzFac - vec3 (0., 0.02, 1.07);\n    d = PrCylDf (q, 0.3, 0.007);\n    DMINQ (0);\n  }\n  return flSzFac * dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > 30.) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nfloat Insig (vec2 p, int ig)\n{\n  float s;\n  if (ig == 2) s = (1. - SmoothBump (0.08, 0.12, 0.005, length (p))) *\n     (1. - SmoothBump (-0.01, 0.03, 0.005, length (p)));\n  else s = 1. - SmoothBump (0.03, 0.06, 0.005, length (abs (p) - 0.07));\n  return s;\n}\n\nvec4 FlyerCol (int ig, int id, vec3 vn)\n{\n  vec4 col4;\n  vec2 w;\n  float s;\n  col4 = (ig == 2) ? vec4 (0.1, 1., 0.1, 0.2) : vec4 (1., 0.1, 0.1, 0.2);\n  if (id == idFus) {\n    if (qHit.z > 1.01) {\n      col4 = vec4 (0.9, 0.9, 0.9, 0.3);\n      if (length (abs (qHit.xy + vec2 (0., 0.05)) * vec2 (0.6, 1.)) < 0.03) col4.rgb *= 1. -\n         0.7 * SmoothBump (0.2, 0.8, 0.05, mod (64. * ((ig == 1) ? qHit.y : qHit.x), 1.));\n    }\n    w = abs (qHit.xz) - vec2 (0.09, 0.12);\n    if (abs (qHit.y - 0.1) < 0.04 && Maxv2 (w) < 0.) col4.rgb = vec3 (0.2, 0.15, 0.05);\n    col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (1.5 * qHit.yz + vec2 (0., 0.4), ig));\n  } else if (id == idWngM) {\n    col4.rgb = mix (col4.rgb, 1. - col4.rgb, step (0., qHit.z - 0.14 - 0.07 *\n       abs (sin ((8./1.2) * pi * qHit.x))));\n    s = 1.2 / 8.;\n    s = mod (qHit.x + 0.5 * s, s) - 0.5 * s;\n    col4.rgb *= 1. + 0.1 * SmoothBump (-0.01, 0.01, 0.002, s);\n    if (abs (qHit.y) > 0.1 && qHit.y * vn.y > 0.) {\n      col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (vec2 (abs (qHit.x) - 0.9, qHit.z), ig));\n    }\n  } else if (id == idWngT) {\n    col4.rgb = mix (col4.rgb, 1. - col4.rgb, step (0., qHit.z - 0.11 - 0.03 *\n       abs (sin (17. * pi * qHit.x))));\n    s = 1. / 17.;\n    s = mod (qHit.x + 0.5 * s, s) - 0.5 * s;\n    col4.rgb *= 1. + 0.1 * SmoothBump (-0.005, 0.005, 0.001, s);\n  } else if (id == idTail) {\n    col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (2.5 * qHit.yz + vec2 (-0.9, -0.25), ig));\n  } else if (id == idNose) {\n    col4 = (qHit.z > -0.04) ? mix (col4, vec4 (1., 1., 1., 0.5), 0.5) : vec4 (0.1);\n  } else if (id == idPipe) {\n    col4 = vec4 (0.8, 0.8, 0.85, 0.3) * (0.5 + 0.5 * SmoothBump (0.1, 0.9, 0.05,\n       mod (16. * qHit.z, 1.)));\n  } else if (id == idStrut || id == idLeg) {\n    col4.rgb = 0.6 * col4.rgb + vec3 (0.4);\n  } else if (id == idGun) {\n    col4.rgb = vec3 (0.6, 0.6, 0.7);\n  } else if (id == idPlt) {\n    col4 = vec4 (0.4, 0.2, 0.1, 0.);\n    if (qHit.z > 0.02 && qHit.y < 0.03) col4.rgb = (ig == 2) ? vec3 (0.9) : vec3 (0.6, 0.4, 0.4);\n    if (qHit.z > 0. && length (vec2 (abs (qHit.x) - 0.011, qHit.y - 0.015)) < 0.01)\n       col4 = vec4 (0., 0.2, 0., 0.2);\n    if (qHit.z > 0. && ig == 2 && length (qHit.xy - vec2 (0., -0.02)) < 0.012)\n       col4.rgb = vec3 (0.1);\n  } else if (id == idWhl) {\n    if (length (qHit.yz) > 0.07) col4 = vec4 (0.05);\n  }\n  return col4;\n}\n\n// (from \"Truchet Path Journey\")\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * Ssign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * Ssign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * Ssign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = Ssign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= Ssign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - Ssign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nvoid SConf ()\n{\n  vec2 q;\n  float h, hh, s;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  cIdB = PixToHex (cMidS / hgSizeB);\n  BConf ();\n  q = (cMidS - cMidB) / hgSizeB;\n  s = min (hgSizeB * abs (TruchSDist (q).x) - 6., hgSizeB * abs (HexEdgeDist (q)));\n  if (s > 0.) {\n    h = Fbm2 (0.05 * cMidS * vec2 (1., 0.5));\n    hh = h * h;\n    colHt = 1. + (2. * h + 2. * hh + 80. * hh * hh) * smoothstep (0., 4., s);\n    colHt = min (colHt, 40.);\n    if (colHt > 0.1) colHt = 0.5 * (floor (2. * colHt + 0.5) - 0.5);\n  } else colHt = 0.;\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p - vec3 (cMidS, colHt).xzy;\n  d = SmoothMax (length (q.xz) - hgSizeS * sqrt3/2. - 0.01, q.y, ((colHt > 0.3) ? 0.3 : 0.001));\n  DMINQ (idWal);\n  q = p;\n  d = q.y - 0.05;\n  DMINQ (idGrnd);\n  return dMin;\n}\n\nfloat SObjRay (vec3 ro, vec3 rd)\n{  // (from \"Hexagonally Discretized Waves\")\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.01;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= Ssign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSizeS;\n  dHit = 0.;\n  cIdS = PixToHex (ro.xz / hgSizeS);\n  pM = HexToPix (cIdS);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 420; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      SConf ();\n      cNu = false;\n    }\n    d = SObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cIdS = PixToHex ((ro.xz + dHit * rd.xz) / hgSizeS);\n      pM += sqrt3 * edN[(s == hv.x) ? 0 : ((s == hv.y) ? 1 : 2)];\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (4. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, cg4;\n  vec3 col, vn, roo, bgCol;\n  vec2 vf;\n  float dstObj, dstObjS, sh, c;\n  int ig, id;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  dstObjS = SObjRay (ro, rd);\n  bgCol = SkyCol (rd);\n  col = bgCol;\n  if (min (dstObj, dstObjS) < dstFar) {\n    ro += min (dstObj, dstObjS) * rd;\n    if (dstObj < dstObjS) {\n      vn = ObjNf (ro);\n    } else {\n      vn = SObjNf (ro);\n      dstObj = dstObjS;\n    }\n    if (dstObj == dstObjS) {\n      c = Fbm2 (ro.xz);\n      cg4 = vec4 (0.6, 0.4, 0., 0.) * (0.8 + 0.2 * c);\n      if (idObj == idWal) {\n        col4 = vec4 (0.9, 0.5, 0.2, 0.1) * (0.8 + 0.2 * smoothstep (4., 20., ro.y));\n        col4 *= 1. - 0.1 * smoothstep (0.4, 0.47, abs (fract (2. * (ro.y + 0.1) + 0.5) - 0.5));\n        if (vn.y > 0.2) col4 *= (0.8 + 0.2 * c) * (1. - 0.3 * smoothstep (0.2, 0.5, vn.y));\n        col4 = mix (cg4, col4, smoothstep (1., 2., ro.y));\n        col4 = mix (col4, vec4 (1., 1., 1., 0.5), smoothstep (20., 35., ro.y));\n        vf = vec2 (4., 2.);\n      } else if (idObj == idGrnd) {\n        col4 = cg4 * (0.98 + 0.02 * cos (pi * hgSizeB * TruchSDist ((ro.xz - cMidB) /\n           hgSizeB).x));\n        vf = vec2 (1., 1.);\n      }\n      vn = VaryNf (vf.x * ro, vn, vf.y * (1. - smoothstep (0.2, 0.5, dstObj / dstFar)));\n    } else {\n      ig = idObj / 256;\n      id = idObj - 256 * ig;\n      col4 = FlyerCol (ig, id, flyerMat[ig] * vn);\n    }\n    sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n    col = col4.rgb * (0.25 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n       0.75 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    col = mix (col, bgCol, 1. - exp (min (0., 2. - 5. * dstObj / dstFar)));\n  }\n  if (TrObjRay (roo, rd) < min (dstObj, dstFar)) col = mix (col, mix (vec3 (1.), vec3 (0.8),\n     step (0.02, abs (length (qHit.xy) - 0.26))), 0.2);\n  return clamp (col, 0., 1.);\n}\n\nfloat EvalPHt (vec2 p)\n{\n  return 2. + 5. * Fbm2 (0.01 * p);\n}\n\nvoid FlyerPM (float s, float flDir, out vec3 flPos, out mat3 flMat)\n{\n  vec3 p, pf, pb, vel, acc, va, ori, ca, sa;\n  float ds, vm, az, el, rl;\n  ds = 0.3;\n  p.xz = EvalPPos (s);\n  p.y = 0.;\n  flPos = p;\n  flPos.y = EvalPHt (p.xz);\n  pf.xz = EvalPPos (s + ds);\n  pf.y = 0.;\n  pb.xz = EvalPPos (s - ds);\n  pb.y = 0.;\n  vel = (pf - pb) / (2. * ds);\n  acc = (pf + pb - 2. * p) / (ds * ds);\n  vm = length (vel);\n  va = cross (acc, vel) / vm;\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  el = - sin (vel.y) / vm;\n  rl = 0.03 * sign (flDir) * length (va) * sign (va.y);\n  if (flDir < 0.) az += pi;\n  else rl += 0.06 * sin (0.5 * pi * tCur);\n  ori = vec3 (el, az, rl);\n  ca = cos (ori);\n  sa = sin (ori);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\n#define N_WIN  2\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, vd, p;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, zmFac, asp, sr, t, tGap, trVel, flDir;\n  int vuId, regId;\n  bool sWin;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 1200.) + 10. * floor (dateCur.w / 3600.) + 10.;\n  asp = canvas.x / canvas.y;\n  sWin = true;\n  if (sWin) {\n    mSize = (1./6.) * vec2 (asp, 1.);\n    mMid[0] = (1. - mSize.y) * vec2 (asp, -1.);\n    mMid[1] = (1. - mSize.y) * vec2 (- asp, -1.);\n    for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    if (sWin) {\n      for (int k = 0; k < N_WIN; k ++) {\n        msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n        if (Maxv2 (abs (msw)) < mSize.y) {\n          regId = k + 1;\n          msw /= 2. * mSize.y;\n          break;\n        }\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = k + 1;\n        break;\n      }\n    }\n    if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  }\n  hgSizeB = 64.;\n  hgSizeS = 1.;\n  SetPath ();\n  flSzFac = 2.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  tGap = 7.;\n  trVel = 0.5;\n  for (int k = 0; k < N_FLYER; k ++) {\n    flDir = (k < N_FLYER - 1) ? -1. : 1.;\n    t = (flDir < 0.) ? tGap * (floor (trVel * tCur / tGap + 0.5) - fract (tCur / tGap) -\n       0.5 * float (N_FLYER - 1)) : trVel * tCur;\n    FlyerPM (t + ((flDir < 0.) ? tGap * float (k + 1) : 0.), flDir, flyerPos[k], flyerMat[k]);\n    if (flDir > 0.) flyerPos[k].y += 6.;\n  }\n  if (vuId <= 1 && length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.01,\n     fract (tCur / 60.))) vuId = 1 - vuId;\n  t = trVel * tCur;\n  if (vuId == 0 || vuId == 1) {\n    ro.xz = EvalPPos (t - 0.8 * ((vuId == 0) ? 1. : -1.));\n    ro.y = EvalPHt (ro.xz) + 10.;\n    p.xz = EvalPPos (t - 0.6 * ((vuId == 0) ? 1. : -1.));\n    p.y = EvalPHt (p.xz) + 8.;\n    p = flyerPos[N_FLYER - 1];\n    p.y -= 4.;\n    vd = normalize (p - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += 0.5 * asin (vd.y);\n    el = clamp (el, -0.3 * pi, 0.1 * pi);\n    zmFac = 1.8 * (1. + 2. * SmoothBump (0.25, 0.75, 0.2, fract (0.03 * tCur)));\n    dstFar = 300.;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 80., (2. / tLen) * t * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.x -= 1.5 * hgSizeB;\n    p = flyerPos[N_FLYER - 1];\n    p.y -= 4.;\n    vd = normalize (p - ro);\n    az = 0.3 * az + atan (vd.z, - vd.x) - 0.5 * pi;\n    el = 0.3 * el + asin (vd.y);\n    el = clamp (el, -0.4 * pi, -0.12 * pi);\n    zmFac = 5.;\n    dstFar = 400.;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 2. * pi * sin (0.005 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.4, 0.6, 0.4);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (vec3 (p.xy, sign (p.z) * (max (0., abs (p.z) - h)))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (vec2 (p.x, sign (p.y) * (max (0., abs (p.y) - h)))) - r;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Ssign (float x)\n{\n  return (x != 0.) ? sign (x) : 1.;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsBDX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1652, 1652, 1688, 1688, 4658], [4660, 4660, 4682, 4682, 4896], [4898, 4898, 4931, 4931, 5115], [5117, 5117, 5138, 5138, 5393], [5395, 5395, 5419, 5419, 5723], [5725, 5725, 5760, 5760, 5944], [5946, 5946, 5983, 5983, 6223], [6225, 6225, 6255, 6255, 6481], [6483, 6483, 6524, 6524, 8865], [8901, 8901, 8922, 8922, 8945], [8947, 8947, 8973, 8973, 9961], [9963, 9963, 9980, 9980, 10825], [10827, 10827, 10852, 10852, 11506], [11508, 11508, 11523, 11523, 12232], [12234, 12234, 12249, 12249, 12758], [12760, 12760, 12783, 12783, 13038], [13040, 13040, 13074, 13117, 14273], [14275, 14275, 14297, 14297, 14553], [14555, 14555, 14578, 14578, 14741], [14743, 14743, 14778, 14778, 16685], [16687, 16687, 16711, 16711, 16749], [16751, 16751, 16820, 16820, 17636], [17656, 17656, 17712, 17712, 21490], [21492, 21492, 21524, 21524, 21624], [21626, 21626, 21659, 21659, 21748], [21750, 21750, 21796, 21796, 21843], [21845, 21845, 21878, 21878, 21905], [21907, 21907, 21949, 21949, 22000], [22002, 22002, 22045, 22045, 22122], [22124, 22124, 22168, 22168, 22244], [22246, 22246, 22279, 22279, 22352], [22354, 22354, 22378, 22378, 22608], [22610, 22610, 22634, 22634, 22690], [22692, 22692, 22720, 22720, 22800], [22802, 22802, 22824, 22824, 22851], [22853, 22853, 22875, 22875, 22902], [22904, 22904, 22926, 22926, 22964], [22966, 22966, 23011, 23011, 23103], [23105, 23105, 23150, 23150, 23188], [23190, 23190, 23247, 23247, 23330], [23332, 23332, 23362, 23362, 23475], [23477, 23477, 23508, 23508, 23572], [23574, 23574, 23610, 23610, 23816], [23818, 23818, 23841, 23841, 23879], [23913, 23913, 23937, 23937, 23997], [23999, 23999, 24023, 24023, 24088], [24090, 24090, 24114, 24114, 24226], [24228, 24228, 24252, 24252, 24395], [24397, 24397, 24422, 24422, 24606], [24608, 24608, 24633, 24633, 24858], [24860, 24860, 24881, 24881, 25036], [25038, 25038, 25059, 25059, 25214], [25216, 25216, 25245, 25245, 25457], [25459, 25459, 25498, 25498, 25750]], "test": "untested"}
{"id": "ddsfWj", "name": "Human Readable Zeppelin", "author": "spenceryonce", "description": "Human Readable Version of: https://www.shadertoy.com/view/cs2cWz\nThanks to @FabriceNeyret2 for the original code!\n\nComments and suggestions are welcomed!", "tags": ["raymarchingtutorial", "reproduction", "zeppelin", "humancode", "readablecode"], "likes": 8, "viewed": 274, "published": 3, "date": "1689192128", "time_retrieved": "2024-07-30T17:44:54.855164", "image_code": "// Rotation matrix \nmat2 rotateMatrix(float angle) {\n  return mat2(cos(angle + vec4(0,11,33,0))); \n}\n\n// Convert to ring coordinates\nvec3 toRingCoords(vec3 point, float radius) {\n  return 4.0 * vec3(length(point.xz) - radius, point.y, radius * atan(point.x, point.z));\n} \n\n// Truss structure distance field\nfloat trussGeometry(vec3 position) {\n\n  position.xy = length(position.xy) * \n    cos(mod(atan(position.y, position.x) + 1.05, 2.1) - 1.05 + vec2(0,11));\n  \n  position.z = mod(position.z, 2.0) - 1.0;\n\n  position.x -= 0.5;\n\n  return min(\n      length(vec2(position.x, abs(position.y) - 0.87)) - 0.1,\n      max(\n        length(vec2(position.x, 0.87 * abs(position.z) + 0.5 * position.y - 0.5)) - 0.1,\n        abs(position.y) - 0.9\n      )\n  );\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  \n  float rayDistance = 9.0;\n  float radius;\n  \n  vec3 resolution = iResolution;\n  vec3 rayDirection = normalize(vec3(fragCoord, -2.0 * resolution.y) - resolution);\n  vec3 rayOrigin = vec3(10, 6, 25);\n\n  vec3 cameraPos = mix(\n    3.0 * cos(0.3 * iTime + vec3(0, 11, 0)), // Camera position - demo mode\n    6.0 * iMouse.xyz / resolution - vec3(0, 3, 0), // Camera position - interactive\n    step(0.0, iMouse.z) // Mix factor\n  );\n   \n  // Ray march\n  for(outColor = vec4(1); outColor.x > 0.0 && rayDistance > 0.01; outColor -= 0.01) {\n\n    vec3 position = rayOrigin;\n    \n    // Rotate in YZ plane\n    position.yz *= rotateMatrix(-cameraPos.y);\n\n    // Rotate in XZ plane\n    position.xz *= rotateMatrix(-cameraPos.x); \n\n    vec3 beamPosition = position;\n    \n    // Longitudinal beams\n    beamPosition.xy = length(beamPosition.xy) * \n      cos(mod(atan(beamPosition.y, beamPosition.x) + 0.314, 0.628) - 0.314 + vec2(0, 11));\n    beamPosition.x += 5.0;\n    beamPosition = toRingCoords(beamPosition, 10.0);\n    rayDistance = trussGeometry(beamPosition);\n\n    // Latitudinal beams\n    radius = sqrt(1.0e2 - position.z * position.z) - 5.0;\n    position.z = mod(position.z, 3.0) - 1.5; \n    beamPosition = toRingCoords(position.xzy, radius);\n    rayDistance = min(rayDistance, trussGeometry(beamPosition));\n    \n      \n    rayOrigin += 0.1 * rayDistance * rayDirection; // March ray\n  }\n\n  outColor *= outColor*outColor*outColor*2.0; // Color scheme\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 20, 52, 52, 100], [102, 133, 178, 178, 270], [273, 307, 343, 343, 749], [751, 751, 802, 802, 2250]], "test": "untested"}
{"id": "cslfD2", "name": "Shader meta ball intro", "author": "mrange", "description": "CC0: Shader meta ball intro\nCreated this to show to hacker friend how to do some simple meta ball like effect\nin a fragment shader\n", "tags": ["2d"], "likes": 13, "viewed": 301, "published": 3, "date": "1689188446", "time_retrieved": "2024-07-30T17:44:55.929292", "image_code": "// CC0: Shader meta ball intro\n//  Created this to show to hacker friend how to do some simple meta ball like effect\n//  in a fragment shader\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// Distance field to circle\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;  // Range: 0..1\n  vec2 p = -1. + 2. * q; // Range: -1..1\n  // Adjust for screen ratio\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  // Approximation of pixel size, used for smooth steping the transparency\n  //  at the border of the distance field to reduce aliasing effects\n  float aa = 4.0/RESOLUTION.y;\n\n  // The final distance field\n  float d = 1E4;\n\n  // Let's do 5 balls\n  for (float i = 0.0; i < 5.0; ++i) {\n    // A sinusoidal movement of the balls\n    vec2 off = sin(vec2(1.0, sqrt(0.5))*TIME+i);\n    // Compute the distance from this ball\n    float dd = circle(p - off, 0.33);\n    if (p.y < -1.0+2.0*smoothstep(-0.5, 0.5, sin(TIME))) {\n      // On the bottom we create the final distance field by taking the union \n      //  of the balls shapes using the min function\n      // This make it looks like 5 distinct balls occassionally overlapping\n      d = min(d, dd);\n    } else {\n      // On the top though we that the union using the powerful soft min function\n      //  This gives a more meta ball look\n      d = pmin(d, dd, 1.0);\n    }\n  }\n\n  vec3 col = vec3(0.0);\n  // Add a bit of a glow effect around the meta balls\n  //  simplest way I found the to do is just use the inverted distance + finetuning\n  //  constants\n  col += vec3(1.0, 0.25, 0.125)*0.0001/max(d*d, 0.00001);\n  float a = 10.0*sqrt(abs(d))+TIME;\n  // Compute the ball color using this simple yet appealing way to generate\n  //  a palette of colors\n  vec3 bcol = 0.5*(1.0+cos(0.5*vec3(0.0, 1.0, 2.0)+a));\n  // Compute the transparency using the smoothstep function to reduce aliasing effects\n  float t = smoothstep(0.0, -aa, d);\n  // Mix the background color and the ball color using the transparency\n  col = mix(col, bcol, t);\n  // Distance fields makes certain operations simple\n  //  Take the abs() produces the outline of a shape and by subtracting with a \n  //  number we give the outline a width\n  float od = abs(d)-0.005;\n  // Compute the transparency for the outline \n  // Mix the background color and the outline color using the outline transparency\n  float ot = smoothstep(0.0, -aa, od);\n  col = mix(col, vec3(1.0), ot);\n  \n  // Approximative mapping of RGB to sRGB\n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 301, 340, 340, 425], [427, 455, 486, 486, 512], [514, 514, 569, 569, 2803]], "test": "untested"}
{"id": "cslBWj", "name": "Path Traced spheres", "author": "ChibiDenDen", "description": "Path tracing 3d spheres ", "tags": ["3d", "pathtracing"], "likes": 0, "viewed": 165, "published": 3, "date": "1689176274", "time_retrieved": "2024-07-30T17:44:56.812930", "image_code": "struct sphere {\nvec3 center;\nfloat r;\nvec3 color;\n};\n\nvec4 bgcolor = vec4(0.53, 0.81, 0.98, 1);\n\n#define MAX_SPHERES 4\n#define PI 3.14\n\nsphere spheres[MAX_SPHERES];\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sphereDist(vec3 pos, sphere s) {\n   return length(pos - s.center) - s.r;\n}\n\nfloat distScene(vec3 pos) {\n    float dist = sphereDist(pos, spheres[0]);\n    for (int i = 1; i < MAX_SPHERES; i++) {\n        if (spheres[i].r > 0.0) {\n          dist = smin(dist, sphereDist(pos, spheres[i]), 0.3);\n        }\n    }\n    return dist;\n}\n\n\nvec3 colorScene(vec3 pos) {\n    vec3 color = vec3(0);\n    for (int i = 0; i < MAX_SPHERES; i++) {\n        if (spheres[i].r > 0.0) {\n          float dist = sphereDist(pos, spheres[i]);\n          color += spheres[i].color * max((1.0 - dist/0.3), 0.0);\n        }\n    }\n     return color;\n}\n\n\nvec3 trace(vec3 ray, vec3 pos) {\n   ray = normalize(ray);\n   float dist = distScene(pos);\n   int steps = 128;\n   for (int i = 0; i < steps; i++) {\n      pos = pos + ray*dist;\n      dist = distScene(pos);\n   }\n   return pos;\n}\n\nvec3 getNormal(vec3 pos) {\n   float dist = distScene(pos);\n   vec2 e = vec2(0.01, 0.0);\n   vec3 n = dist - vec3(distScene(pos - e.xyy), distScene(pos - e.yxy), distScene(pos - e.yyx));\n   return normalize(n);\n}\n\nvec4 shade(vec3 pos, vec3 light, vec3 camera) {\n    vec3 sunDir = pos - light;\n    sunDir = normalize(sunDir);\n\n    vec3 normal = getNormal(pos);\n    float ambiant = 0.2;\n    float diffuse = clamp(dot(-sunDir, normal), 0.0, 1.0) * 0.5;\n    vec3 R = normalize(2.0 * dot(normal, -sunDir) * normal + (sunDir)); \n    float specular = pow(clamp(dot(R, normalize(camera - pos)), 0.0, 1.0), 8.0) * 2.0; \n\n    float val = ambiant + diffuse + specular;\n    return vec4(colorScene(pos) * val, 1.0) + ambiant * bgcolor * 0.5;\n}\n\n#define AA_SAMPLES 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera = vec3(5.0*sin(iTime*0.7), 0, -5.0*cos(iTime*0.7));\n    vec3 up = vec3(0, 1, 0);\n    vec3 lightPos = vec3(-2.5, 1, -1);\n   \n    spheres[0].center = vec3(0.5, 0, cos(iTime*1.2)+0.2);\n    spheres[0].r = 0.5;\n    spheres[0].color = vec3(1.0, 0.0, 0.0);\n    \n    spheres[1].center = vec3(-0.5 + sin(iTime*2.0) * 1.2, 0, 0);\n    spheres[1].r = 0.3;\n    spheres[1].color = vec3(0.0, 1.0, 0.0);\n    \n    \n    spheres[2].center = vec3(0, sin(iTime) * 0.8+0.3, 0);\n    spheres[2].r = 0.4;\n    spheres[2].color = vec3(0.0, 0.0, 1.0);\n    \n    \n    spheres[3].center = vec3(0, sin(iTime) * 0.8+0.3, sin(iTime)*0.66 + 0.2);\n    spheres[3].r = 0.1;\n    spheres[3].color = vec3(0.0, 1.0, 1.0);\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    \n    vec4 outcolor = vec4(0.0);\n    \n    for (int i = 0; i < AA_SAMPLES; i++) {\n        vec2 jitter = vec2(sin(2.0*PI*float(i) / float(AA_SAMPLES)), cos(2.0*PI*float(i) / float(AA_SAMPLES)))*1.75;\n\n        vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n        uv += jitter/iResolution.xx;\n\n        uv = uv * 2.0;\n        uv = uv * iResolution.xy;\n        uv = uv / iResolution.yy;\n\n        vec3 right = cross(camera, up);\n        right = normalize(right);\n\n        vec3 ray = right*uv.x + up*uv.y - camera;\n\n        vec3 tracePos = trace(ray, camera);\n        \n        \n        if (distScene(tracePos) < 0.1) {\n          outcolor += shade(tracePos, lightPos, camera) / float(AA_SAMPLES);\n        } else {\n          outcolor += bgcolor / float(AA_SAMPLES);\n        }\n    }\n    \n      fragColor = outcolor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 205, 205, 296], [298, 298, 336, 336, 378], [380, 380, 407, 407, 629], [632, 632, 659, 659, 918], [921, 921, 953, 953, 1146], [1148, 1148, 1174, 1174, 1358], [1360, 1360, 1407, 1407, 1876], [1900, 1900, 1957, 1957, 3533]], "test": "untested"}
{"id": "ddXBW2", "name": "SDF Predicate Uniformity Est.", "author": "GabeRundlett", "description": "Visualization of the estimate of a predicate's uniformity across quadtree regions. Also contains definitions of useful estimator functions, which allow for fast and/or exact estimates.", "tags": ["sdf", "voxel", "voxel", "tree", "uniform", "uniform", "quadtree", "hierarchy", "uniformity"], "likes": 13, "viewed": 419, "published": 3, "date": "1689171764", "time_retrieved": "2024-07-30T17:44:58.028680", "image_code": "\n// NOTE! The purpose of this ShaderToy is to show HOW an algorithm can improve the performance\n// of terrain generation, however, I can't think of a way that I could implement the algorithm\n// in ShaderToy where it's effectively applied. Therefore, this ShaderToy is just a visualization\n// of the algorithm.\n\n// You can change these!\nconst uint MAX_LOD = 12u;\nconst uint LOD_STEP = 1u;\n\nfloat WORLD_SCALE;\n\nconst bool USE_NAIVE_METHOD = true; // pointless variable, just exists as a explanatory device\n\nconst bool SHOW_ESTIMATED_SURFACE_VOXELS = false;\n\nconst vec3 BLUE = vec3(0.357, 0.612, 0.882);\nconst vec3 ORANGE = vec3(0.969, 0.663, 0.133);\n\nvec2 pixel_space_to_world_space(vec2 pixel_p) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = pixel_p / iResolution.xy * 2.0 - 1.0;\n    uv.x *= aspect;\n    uv *= WORLD_SCALE;\n    return uv;\n}\n\nvoid setup_scene() {\n    WORLD_SCALE = iResolution.y / 20.0 * 3.0;\n    circle_pos = vec2(-55.0, sin(iTime * 1.4) * 30.0);\n    if (iMouse.x > 0.0 && iMouse.y > 0.0) {\n        circle_pos = pixel_space_to_world_space(iMouse.xy);\n    }\n    rect_size = vec2(12.0 + sin(iTime * 2.0) * 6.0, 60.0);\n    noise_offset_a = vec2(0.0, -100.0 + sin(iTime) * 10.0);\n    noise_offset_b = vec2(cos(iTime) * 10.0, +100.0);\n    noise_offset_c = vec2(cos(iTime * 2.0) * 10.0, -sin(iTime) * 10.0);\n}\n\nfloat sd_grid(vec2 p) {\n    vec2 uv = abs(fract(p + 0.5) - 0.5);\n    return min(uv.x, uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    setup_scene();\n\n    vec2 uv = pixel_space_to_world_space(fragCoord);\n\n    // say this is the center of our voxel\n    vec2 voxel_pos = floor(uv) + 0.5;\n    vec3 voxel_color = vec3(0.0);\n\n    if (USE_NAIVE_METHOD) {\n        // normally, if we were generating a voxel world, we'd loop over every voxel to determine what\n        // the per-voxel data is. To do this, we run a function per-voxel, and then apply a predicate\n        // to the result of this function. Here, our predicate is just whether the value `d` is less\n        // than zero, which decides whether our voxel is BLUE or ORANGE. This function and predicate\n        // are very simple, but I am sure you can imagine how this idea can be extended.\n        float d = map(voxel_pos);\n        if (d < 0.0) {\n            voxel_color = BLUE;\n        } else {\n            voxel_color = ORANGE;\n        }\n        // This is already inefficient, but to add insult to injury, we may then generate a sparse data\n        // structure using this per-voxel data, in order to save memory. In this instance, we'd be using\n        // a \"bottom-up\" algorithm for generating our hierarchy. Anyone who has ever used tree data structures\n        // knows that this is inherently a bad idea, but how could we do our algorithm \"top-down\"?\n    } else {\n        // In order to do our algorithm \"top-down\", we'd need to determine whether this `d < 0.0` condition\n        // were uniform across a given region. Getting an *exact* answer isn't even necessary, it's just\n        // important that the estimate never says a region is uniform when it really isn't. Determining this\n        // is the purpose of this shadertoy, demonstrating the ability to generalize estimating a predicate's\n        // uniformity across the region encompassed by any given LOD level.\n\n        // The environment of a shader is not really the best place to implement this, since we'll still\n        // be running the predicate for every pixel, but if you had a CPU application, or custom GPU app\n        // which enabled you to do conditional generation, then this algorithm is relevant. Shaders are\n        // just the best way to visually demonstrate these things!\n        for (uint lod_i = 0u; lod_i <= MAX_LOD; lod_i += LOD_STEP) {\n            uint lod_level = MAX_LOD - lod_i;\n            if (is_map_uniform_on_lod(voxel_pos, lod_level)) {\n                float d = map(voxel_pos);\n                if (d < 0.0) {\n                    voxel_color = BLUE;\n                } else {\n                    voxel_color = ORANGE;\n                }\n                // A break here represents the early termination of a recursive function, which is why\n                // this would reduce cost if used in a different context.\n                break;\n            }\n        }\n    }\n\n    vec3 color = voxel_color;\n\n    if (SHOW_ESTIMATED_SURFACE_VOXELS) {\n        uint lod_i = MAX_LOD;\n        uint lod_level = MAX_LOD - lod_i;\n        float lod_scl = float(1u << lod_level);\n        if (is_map_uniform_on_lod(uv, lod_level + 1u)) {\n            color *= 0.0;\n        } else {\n            float grid_lines_fac = smoothstep(0.000, 0.25 / float(lod_scl), sd_grid(uv / lod_scl)) * 0.4 + 0.6;\n            color *= grid_lines_fac;\n        }\n    } else {\n        for (uint lod_i = 0u; lod_i <= MAX_LOD; lod_i += LOD_STEP) {\n            uint lod_level = MAX_LOD - lod_i;\n            float lod_scl = float(1u << lod_level);\n            if (is_map_uniform_on_lod(uv, lod_level)) {\n                float grid_lines_fac = smoothstep(0.000, 0.25 / float(lod_scl), sd_grid(uv / lod_scl)) * 0.4 + 0.6;\n                color *= grid_lines_fac;\n                break;\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "\n// These are set in the setup_scene() function of Image\nvec2 circle_pos;\nvec2 rect_size;\nvec2 noise_offset_a;\nvec2 noise_offset_b;\nvec2 noise_offset_c;\n\n// Here is where we actually define the map. We do this here as macros because\n// what we can do is swap out the `MAP_CIRCLE` and `MAP_BOX` functions can be\n// swapped out INDIVIDUALLY depending on the context where the map is consumed.\n#define USE_NOISE 1\n#if USE_NOISE\n#define MAP_DEF                                                        \\\n    MAP_CONSTANT(sd_union, 5.0)                                        \\\n    MAP_NOISE(sd_add, noise_offset_a, 0.01, 7.5)                       \\\n    MAP_NOISE(sd_add, noise_offset_b, 0.15, 1.1)                       \\\n    MAP_NOISE(sd_add, noise_offset_c, 0.60, 0.3)                       \\\n    MAP_GRADIENT_Y(sd_add, 0.17)                                       \\\n    MAP_CIRCLE(sd_union, circle_pos, 40.0)                             \\\n    MAP_BOX(sd_union, circle_pos - vec2(0.0, -10.0), vec2(50.0, 10.0)) \\\n    MAP_BOX(sd_union, vec2(80.0, 0.0), rect_size)\n#else\n#define MAP_DEF                                                        \\\n    MAP_CIRCLE(sd_union, circle_pos, 40.0)                             \\\n    MAP_BOX(sd_union, circle_pos - vec2(0.0, -10.0), vec2(50.0, 10.0)) \\\n    MAP_BOX(sd_union, vec2(0.0), rect_size)\n#endif\n\n// Below this is all just implementation details.\n\nconst float MAX_DIST = 1.0e9;\nconst float SQRT_2 = 1.41421356237;\n\nfloat nonzero_sign(float x) {\n    if (x < 0.0)\n        return -1.0;\n    return 1.0;\n}\nvec2 nonzero_sign(vec2 x) {\n    return vec2(nonzero_sign(x.x), nonzero_sign(x.y));\n}\n\nfloat sd_union(float a, float b) { return min(a, b); }\nfloat sd_add(float a, float b) { return (a + b); }\nfloat sd_mul(float a, float b) { return (a * b); }\n\n// assumed circle is at (0, 0)\nfloat sd_circle_nearest(vec2 p, float r) {\n    return length(p) - r;\n}\nfloat sd_circle_furthest(vec2 p, float r) {\n    return length(p) + r * 2.0;\n}\n\n// assumed box is centered at (0, 0)\nfloat sd_box_nearest(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat sd_box_furthest(vec2 p, vec2 b) {\n    return length(b * nonzero_sign(p) + p);\n}\n\n// assumed circle is at (0, 0)\nvec2 minmax_sd_circle_in_region(vec2 region_center, vec2 region_size, float r) {\n    float min_d = sd_box_nearest(-region_center, region_size);\n    float max_d = sd_box_furthest(-region_center, region_size);\n    return vec2(min_d, max_d) - r;\n}\n\nvec2 minmax_gradient_y_in_region(vec2 region_center, vec2 region_size, float f) {\n    float min_d = (region_center.y - region_size.y) * f;\n    float max_d = (region_center.y + region_size.y) * f;\n    return vec2(min_d, max_d);\n}\n\n// https://www.shadertoy.com/view/XttSz2\nfloat hash(float n) { return fract(sin(n) * 753.5453123); }\nvec4 noised(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w * w * (3.0 - 2.0 * w);\n    vec3 du = 6.0 * w * (1.0 - w);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    float a = hash(n + 0.0);\n    float b = hash(n + 1.0);\n    float c = hash(n + 157.0);\n    float d = hash(n + 158.0);\n    float e = hash(n + 113.0);\n    float f = hash(n + 114.0);\n    float g = hash(n + 270.0);\n    float h = hash(n + 271.0);\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = -a + b + c - d + e - f - g + h;\n\n    return vec4(k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z,\n                du * (vec3(k1, k2, k3) + u.yzx * vec3(k4, k5, k6) + u.zxy * vec3(k6, k4, k5) + k7 * u.yzx * u.zxy));\n}\n\nfloat sd_noise_conservative(vec2 p, float scale, float amp) {\n    float noise_val = noised(vec3(p * scale, 0.0)).x * 2.0 - 1.0;\n    return noise_val * amp;\n}\n\nvec2 minmax_noise_in_region(vec2 region_center, vec2 region_size, float scale, float amp) {\n    // Use the lipschitz constant to compute min/max est. For the cubic interpolation\n    // function of this noise function, said constant is 2.0 * 1.5 * scale * amp.\n    //  - 2.0 * amp comes from the re-scaling of the range between -amp and amp (line 112-113)\n    //  - scale comes from the re-scaling of the domain on the same line (p * scale)\n    //  - 1.5 comes from the maximum abs value of the first derivative of the noise\n    //    interpolation function (between 0 and 1): d/dx of 3x^2-2x^3 = 6x-6x^2.\n    float lipschitz = 2.0 * 1.5 * scale * amp;\n    float noise_val = sd_noise_conservative(region_center, scale, amp);\n    float max_dist = length(region_size);\n    return vec2(max(noise_val - max_dist * lipschitz, -amp), min(noise_val + max_dist * lipschitz, amp));\n}\n\nfloat map(vec2 p) {\n    float d = MAX_DIST;\n#define MAP_CIRCLE(op, x, r) \\\n    d = op(d, sd_circle_nearest(p - x, r));\n#define MAP_BOX(op, x, r) \\\n    d = op(d, sd_box_nearest(p - x, r));\n#define MAP_NOISE(op, x, s, a) \\\n    d = op(d, sd_noise_conservative(p - x, s, a));\n#define MAP_CONSTANT(op, x) \\\n    d = op(d, x);\n#define MAP_GRADIENT_Y(op, f) \\\n    d = op(d, p.y * f);\n    MAP_DEF\n#undef MAP_CIRCLE\n#undef MAP_BOX\n#undef MAP_NOISE\n#undef MAP_CONSTANT\n#undef MAP_GRADIENT_Y\n    return d;\n}\n\nvec2 map_at_lod(vec2 p, uint lod_level) {\n    float chunk_edge_length_at_lod = float(1u << lod_level);\n    vec2 lod_chunk_center_p = (floor(p / chunk_edge_length_at_lod) + 0.5) * chunk_edge_length_at_lod;\n    float chunk_diag_length_at_lod = SQRT_2 * 0.5 * chunk_edge_length_at_lod;\n\n    float min_d;\n    float max_d;\n\n    bool first = true;\n\n    // This is pretty self explanatory, but what we do here is estimate whether the\n    // chunk could be completely uniform at this LOD by ensuring the furthest distance\n    // in any direction from the chunk center is GREATER than the chunk's diagonal\n    // radius. This, in a sense, is like assuming the chunks are circles/spheres,\n    // which conservatively estimates the LOD-ing, especially when the nearest point\n    // of the SDF is in cardinal directions.\n\n#define MAP_CONSTANT(op, x)       \\\n    {                             \\\n        float d = x;              \\\n        if (first) {              \\\n            min_d = d;            \\\n            max_d = d;            \\\n        } else {                  \\\n            min_d = op(min_d, d); \\\n            max_d = op(max_d, d); \\\n        }                         \\\n        first = false;            \\\n    }\n\n#define MAP_GRADIENT_Y(op, f)                                                                              \\\n    {                                                                                                      \\\n        vec2 d = minmax_gradient_y_in_region(lod_chunk_center_p, vec2(chunk_edge_length_at_lod * 0.5), f); \\\n        if (first) {                                                                                       \\\n            min_d = d[0];                                                                                  \\\n            max_d = d[1];                                                                                  \\\n        } else {                                                                                           \\\n            min_d = op(min_d, d[0]);                                                                       \\\n            max_d = op(max_d, d[1]);                                                                       \\\n        }                                                                                                  \\\n        first = false;                                                                                     \\\n    }\n\n    // Using this function as the definition of the minmaxing of your function will result in\n    // an imperfect but FAST (and super simply implemented) estimate!\n#define SD_SPHERE_CHUNK_EST(op, f)                           \\\n    {                                                        \\\n        float d = f;                                         \\\n        if (first) {                                         \\\n            min_d = d - chunk_diag_length_at_lod;            \\\n            max_d = d + chunk_diag_length_at_lod;            \\\n        } else {                                             \\\n            min_d = op(min_d, d - chunk_diag_length_at_lod); \\\n            max_d = op(max_d, d + chunk_diag_length_at_lod); \\\n        }                                                    \\\n        first = false;                                       \\\n    }\n\n    // Using this function as the definition of the minmaxing of your function will result in\n    // an imperfect (but slightly better, slightly slower, and super simply implemented) estimate!\n#define SD_SPHERE_CHUNK_EST_4(op, f0, f1, f2, f3)                                              \\\n    {                                                                                          \\\n        float d0 = f0;                                                                         \\\n        float d1 = f1;                                                                         \\\n        float d2 = f2;                                                                         \\\n        float d3 = f3;                                                                         \\\n        if (first) {                                                                           \\\n            min_d = min(min(d0, d1), min(d2, d3)) - chunk_diag_length_at_lod * 0.5;            \\\n            max_d = max(max(d0, d1), max(d2, d3)) + chunk_diag_length_at_lod * 0.5;            \\\n        } else {                                                                               \\\n            min_d = op(min_d, min(min(d0, d1), min(d2, d3)) - chunk_diag_length_at_lod * 0.5); \\\n            max_d = op(max_d, max(max(d0, d1), max(d2, d3)) + chunk_diag_length_at_lod * 0.5); \\\n        }                                                                                      \\\n        first = false;                                                                         \\\n    }\n\n    // I defined a perfect circle estimator right below, so there's no need to use the SDF one\n    // #define MAP_CIRCLE(op, x, r) SD_SPHERE_CHUNK_EST(op, sd_circle(lod_chunk_center_p - x, r))\n#define MAP_CIRCLE(op, x, r)                                                                                  \\\n    {                                                                                                         \\\n        vec2 d = minmax_sd_circle_in_region(lod_chunk_center_p - x, vec2(chunk_edge_length_at_lod * 0.5), r); \\\n        if (first) {                                                                                          \\\n            min_d = d[0];                                                                                     \\\n            max_d = d[1];                                                                                     \\\n        } else {                                                                                              \\\n            min_d = op(min_d, d[0]);                                                                          \\\n            max_d = op(max_d, d[1]);                                                                          \\\n        }                                                                                                     \\\n        first = false;                                                                                        \\\n    }\n\n#define MAP_BOX(op, x, r) SD_SPHERE_CHUNK_EST(op, sd_box_nearest(lod_chunk_center_p - x, r))\n\n#define MAP_NOISE(op, x, s, a)                                                                               \\\n    {                                                                                                        \\\n        vec2 d = minmax_noise_in_region(lod_chunk_center_p - x, vec2(chunk_edge_length_at_lod * 0.5), s, a); \\\n        if (first) {                                                                                         \\\n            min_d = d[0];                                                                                    \\\n            max_d = d[1];                                                                                    \\\n        } else {                                                                                             \\\n            min_d = op(min_d, d[0]);                                                                         \\\n            max_d = op(max_d, d[1]);                                                                         \\\n        }                                                                                                    \\\n        first = false;                                                                                       \\\n    }\n\n    MAP_DEF\n#undef MAP_CIRCLE\n#undef MAP_BOX\n#undef MAP_NOISE\n#undef MAP_CONSTANT\n#undef MAP_GRADIENT_Y\n\n    return vec2(min_d, max_d);\n}\n\nbool is_map_uniform_on_lod(vec2 p, uint lod_level) {\n    if (lod_level == 0u)\n        return true;\n    vec2 minmax = map_at_lod(p, lod_level);\n    return minmax[0] >= 0.0 || minmax[1] < 0.0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[649, 649, 696, 696, 858], [860, 860, 880, 880, 1338], [1340, 1340, 1363, 1363, 1434], [1436, 1436, 1491, 1491, 5218]], "test": "untested"}
{"id": "cdXfD2", "name": "Baby Explosions", "author": "misol101", "description": "Fullscreen recommended\n\nCONTROLS:  c=color, 1-5=clear method, 7-9=speed, m=see automata, w=wrap, a=antialiasing, space=regenerate.  Mouse x zooms", "tags": ["2d", "simulation", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 4, "viewed": 218, "published": 3, "date": "1689163069", "time_retrieved": "2024-07-30T17:44:58.977143", "image_code": "float text(vec2 uv, float ix)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(ix*10.,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv); \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int mono = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    int showtext = int(texelFetch(iChannel1, ivec2(4,0), 0 ).x);\n    int aa = 1-int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (showtext == 1) text_pixel = text(fragCoord, ix);    \n\n    float mx= iMouse.x / iResolution.x;\n    vec2 mid = iResolution.xy / 2.;\n    float mmul = 1.-mx;\n    fragCoord = mid - (mid*mmul-fragCoord*mmul);\n\n    vec4 val = vec4(0.);\n    int am=0, ap=aa, j=0;\n    for (int j = -am; j <= ap; j++)\n        for (int i = -am; i <= ap; i++)\n            val += texelFetch( iChannel0, ivec2(int(fragCoord.x)+i,int(fragCoord.y)+j), 0 );\n    float n=float((am+ap+1));\n    if (am+ap > 0) val /= n*n-2.;\n    //if (am+ap > 0) val /= n-1.;\n    \n    if (aa == 0) val/=0.5;\n    \n    if (mono == 0) {\n        fragColor = val;\n    } else {\n        float v=(1./liveval)*val.w;\n        fragColor = vec4( v*0.9, v*0.95, v, 1.0 );\n    }\n    \n    fragColor += text_pixel;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).w;\n    return ( val == liveval ) ? 1 : 0;\n}\nvec4 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., 1.) * (liveval);\n}\n\nfloat restart(vec2 fragCoord, int method, bool preserve) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = iResolution.xy / 2.; \n    float w=100., h=100., radius=182., rradius=25.;\n    float xrad=569.,yrad=453.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;//randpix(fragCoord);\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 3) {\n//        if (length(fragCoord-mid)< radius)\n        if (length(vec2((fragCoord.x-mid.x)*0.793,(fragCoord.y-mid.y)*1.0))< radius) // ellipse\n            return liveval;//randpix(fragCoord);\n    }\n    if (method == 4) {\n        radius *= 0.5;\n        if (fragCoord.x > mid.x - rradius*1.2 && fragCoord.x < mid.x + rradius*1.2+1. && fragCoord.y > mid.y - rradius && fragCoord.y < mid.y + rradius +1.)\n            return randpix(fragCoord);\n    }\n    return preserve? -1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ix = texelFetch(iChannel2, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel2, ivec2(0,1), 0 ).x;\n    int method = int(texelFetch(iChannel2, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel2, ivec2(2,0), 0 ).x);\n    int mono = int(texelFetch(iChannel2, ivec2(3,0), 0 ).x);\n    int usecolor = int(texelFetch(iChannel2, ivec2(6,0), 0 ).x);\n    int usewrap = 1-int(texelFetch(iChannel2, ivec2(7,0), 0 ).x);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime*0.3+uv.xyx*44.);\n    if (usecolor == 0) col = vec3(0.);\n\n    setRules(int(ix*10.), col);\n\n    wrap = usewrap;\n\n    ivec2 px = ivec2( fragCoord );\n    vec4 curr = cellval(px);\n    float ev = curr.w;\n\n    if (wrap == 0 && (fragCoord.y < 2. || fragCoord.x < 2.) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, 0.);\n        return;\n    }\n\n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, setmethod, false));\n        return;\n    }\n\n    if( readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor = vec4( 0.0, 0.0, 0.0, restart(fragCoord, method, false));\n        return;\n    }\n\n    if (iFrame % (speed+1) > 0) {\n        fragColor = curr;\n        return;\n    }\n  \n    int k=0;\n    \n    if (nh == 0) {\n        // ..X..\n        // .X.X.\n        // X.*.X\n        // .X.X.\n        // ..X..\n        k =   cell(px+ivec2(0,-2)) + cell(px+ivec2(-1,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-2, 0))                        + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(1, 1)) + cell(px+ivec2(0, 2));\n    } else if (nh == 5) {\n        // XXXXX\n        // XXXXX\n        // XX*XX\n        // XXXXX\n        // XXXXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1))\n            + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2))\n            + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2))\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-2, -1)) + cell(px+ivec2(-2, 0))\n            + cell(px+ivec2(-2, 1)) + cell(px+ivec2(-2, 2))\n            + cell(px+ivec2(2, -2)) + cell(px+ivec2(2, -1)) + cell(px+ivec2(2, 0))\n            + cell(px+ivec2(2, 1)) + cell(px+ivec2(2, 2));\n    } else if (nh == 10) {\n        // XXXXX\n        // ..X..\n        // ..*..\n        // ..X..\n        // XXXXX    \n        k =   cell(px+ivec2(0,-1)) + cell(px+ivec2(0,1)) +\n            + cell(px+ivec2(-2, -2)) + cell(px+ivec2(-1, -2)) + cell(px+ivec2(0, -2)) + cell(px+ivec2(1, -2)) + cell(px+ivec2(2, -2))\n            + cell(px+ivec2(-2, 2)) + cell(px+ivec2(-1, 2)) + cell(px+ivec2(0, 2)) + cell(px+ivec2(1, 2)) + cell(px+ivec2(2, 2));\n    } else {\n        // XXX\n        // X*X\n        // XXX\n        k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    }\n    \n    float ff = 0.;\n    if (ev > 0.5) {\n        if (decimate > 0.) ff = ev-decimate; //clamp(ev-decimate, 0., 1000.);\n        if ((stayset & (1<<(k-1))) > 0 ) { ff = float(k); if (clampstay && ff > liveval) ff = liveval; }\n    }\n    else {\n        ff = (bornset & (1<<(k-1))) > 0 ? liveval : 0.;\n    }\n\n    if (mono == 0) {\n        if (ff >= 1.0) {\n            int st = int(ff);\n\n            float mulbase = float(k);\n            if (colch == 1) mulbase = ff;\n            else if (colch == 2) mulbase = 1.;\n            else if (colch == 3) mulbase = float(k^st);\n            \n            if ((st & ra) > 0) curr.x += cstep*mulbase*rp;\n            if ((st & ga) > 0) curr.y += cstep*mulbase*gp;\n            if ((st & ba) > 0) curr.z += cstep*mulbase*bp;\n            \n            if (staypatt == 5 || staypatt == 6) curr.z=curr.y=curr.x;\t\n\n        } else {\n            float stayt = cstep * stayval;\n            \n            if (staypatt == 0 || staypatt > 5) {\n                curr.x -= cstep*rm;\n                curr.y -= cstep*gm;\n                curr.z -= cstep*bm;\n            }\n            else if (staypatt == 1) {\n                if(curr.x > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 2) {\n                if(curr.y > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 3) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                    curr.z -= cstep*bm;\n                }\n            }\n            else if (staypatt == 4) {\n                if(curr.z > cstep) {\n                    curr.x -= cstep*rm;\n                    curr.y -= cstep*gm;\n                }\n                if(curr.x > cstep) curr.z -= cstep*bm;\n            }\n            else if (staypatt == 5) {\n                curr.x -= cstep*rm;\n                curr.z=curr.y=curr.x;\n            }\n        }\n    }\n\n\tfragColor = vec4( clamp(curr.xyz,0.,1.), ff );\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAST_PATT = 28.;\nconst float cstep=1./256.;\n\nfloat density=50.;\nfloat liveval = 2.0;\nint newmethod = 0;\nfloat decimate = 0.;\nfloat rp,gp,bp, rm,gm,bm, stayval;\nint colch, staypatt;\nint ra,ga,ba;\nbool clampstay;\nint setmethod;\nint stayset, bornset;\nint nh;\nint wrap;\n\nvoid setRules(int index, vec3 col) {\n    int v1, v2;\n    decimate = 1.;liveval=2.;\n\n    rp=4.,gp=3.,bp=10., rm=2.,gm=2.,bm=8., ra=7,ga=7,ba=7,staypatt=1,stayval=1.,colch=0, clampstay=false, setmethod=0; nh=10, wrap=0;\n\n    index = 0;\n    if (index == 0) {nh=5; v1 = 1175524, v2=1910512; setmethod=0, density=10., liveval=6., decimate=1., colch=1, staypatt=0, rp=3., gp=1.5, bp=1.5, rm=6., gm=8.,bm=13.,  ra=1,ga=2,ba=4; }\n//    if (index == 0) {nh=5; v1 = 1175524, v2=1910512; setmethod=0, density=10., liveval=6., decimate=1., colch=1, staypatt=0, rp=1.5, gp=1.5, bp=1.5, rm=6., gm=12.,bm=29.,  ra=7,ga=7,ba=7; }\n\n    rp=rp+col.x; gp=gp+col.y; bp=bp+col.z;\n    float mdiv = 2.;\n    //rm=rm/mdiv; gm=gm/mdiv; bm=bm/mdiv;\n    stayset = v1; bornset = v2;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_b_code": "// Persistive Keyboard Input buffer & resolution change check\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_A     = 65;\nconst int KEY_C     = 67;\nconst int KEY_H     = 72;\nconst int KEY_M     = 77;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=0.1;\n                    if (kx > LAST_PATT*0.1+0.05) kx=0.05;\n                } else {\n                    kx-=0.1;\n                    if (kx < 0.) kx=LAST_PATT*0.1+0.05;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_H, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_A, 1., 2.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_W, 1., 2.);\n        return;\n    }\n\n\n    if (ix == 0 && iy == 1) {\n        fragColor = vec4(iResolution.x,0.,0.,0.);\n        return;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 232], [234, 234, 291, 291, 1361]], "test": "untested"}
{"id": "dsXfWj", "name": "VoronoiGenerator4489", "author": "shaderNoob4489", "description": "genenate voronoi pattern", "tags": ["voronoinoise"], "likes": 0, "viewed": 75, "published": 3, "date": "1689162820", "time_retrieved": "2024-07-30T17:44:59.979463", "image_code": "vec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    // Remap pixel coordinates (from -1 to 1)\n    //uv = uv * 2. - 1.;\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) /  iResolution.y;\n    \n    float m = 0.;\n    float t = iTime * .2;\n    float minDist = 100.;\n    float cellIndex = 0.;\n    \n    vec3 col = vec3(0);\n    \n    if (false)\n    {\n        for (float i = 0.; i < 50.; i++)\n        {\n            vec2 n = N22(vec2(i));\n            vec2 p = sin(n * t);\n        \n            float d = length(uv - p);\n            m += smoothstep(.02, .01, d);\n        \n            if (d < minDist)\n            {\n                minDist = d;\n                cellIndex = i;\n            }    \n        }\n    }\n    else\n    {\n         uv *= 3.;\n         vec2 gv = fract(uv) - .5; // -.5 to make gv`s origon in gird center;\n         vec2 id = floor(uv);\n         vec2 cid = vec2(0.);\n         \n         for (float y = -1.; y <= 1.; y++)\n         {\n             for (float x = -1.; x <= 1.; x++)\n             {\n                 vec2 offs = vec2(x, y);\n                 vec2 n = N22(offs + id);\n                 vec2 p = offs + sin(n * t) * .5;\n                 float d = length(gv - p);\n                 \n                 if (d < minDist)\n                 {\n                     minDist = d;\n                     cid = id + offs;\n                 }\n             }\n         }\n         col = vec3(minDist);\n         //col.rg = cid * .1;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 152], [154, 154, 211, 379, 1746]], "test": "untested"}
{"id": "csXBW2", "name": "106 chars mosaic", "author": "ianertson", "description": "mosaic pattern in 106 chars", "tags": ["mosaic", "golf"], "likes": 3, "viewed": 192, "published": 3, "date": "1689156542", "time_retrieved": "2024-07-30T17:45:01.265027", "image_code": "void mainImage(out vec4 O,in vec2 F){\nO=vec4(texture(iChannel0,(F/iResolution.xy+float(0xEFFFF))).rgb,1.);}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 107]], "test": "untested"}
{"id": "mssBDB", "name": "Owen", "author": "martysh12", "description": "Owen the shadowless sheep (he's an Aries)\n\nhorrifying unoptimised shader don't even bother looking at the source code", "tags": ["raymarching", "displacement", "sheep", "owen"], "likes": 15, "viewed": 241, "published": 3, "date": "1689152317", "time_retrieved": "2024-07-30T17:45:02.280312", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define ITERS_MAX 200\n#define DIST_MIN 1e-3\n#define DIST_MAX 20.\n#define NORM_EPSILON 0.01\n\nstruct ray {\n  vec3 p;\n  bool hit;\n  float len;\n  int iters;\n\n  // material\n  vec3 c;\n  float shin;\n\n  float diffr;\n  float specr;\n};\n\nstruct sdfparams {\n  vec3 c;\n  float shin;\n\n  float diffr;\n  float specr;\n};\n\nstruct sdf {\n  float d;\n  sdfparams p;\n};\n\nstruct plight {\n  vec3 p;\n  vec3 c;\n};\n\nvec3 erot(vec3 p, vec3 ax, float r) {\n  return mix(dot(ax, p) * ax, p, cos(r)) + cross(ax, p) * sin(r);\n}\n\nsdf sdf_smooth_union(sdf a, sdf b, float k) {\n  float h = clamp(0.5 + (b.d - a.d) / k * 0.5, 0.0, 1.0);\n\n  return sdf(\n    mix(b.d, a.d, h) - k * h * (1. - h),\n    sdfparams(\n      mix(b.p.c, a.p.c, h),\n      mix(b.p.shin, a.p.shin, h),\n      mix(b.p.diffr, a.p.diffr, h),\n      mix(b.p.specr, a.p.specr, h)\n    )\n  );\n}\n\nsdf sdf_union(sdf a, sdf b) {\n  sdf chosen;\n  if (a.d < b.d) {\n    chosen = a;\n  } else {\n    chosen = b;\n  }\n  return chosen;\n}\n\nsdf sdf_wave_displace(vec3 p, float a, float b, sdf s) {\n  s.d += sin(p.x * a) * sin(p.y * a) * sin(p.z * a) * b;\n  return s;\n}\n\nsdf sdf_sphere(vec3 p, float r, sdfparams m) {\n  return sdf(\n    length(p) - r,\n    m\n  );\n}\n\nsdf sdf_cylinder(vec3 p, float r, float h, sdfparams m) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n\n  return sdf(\n    min(max(d.x, d.y), 0.) + length(max(d, 0.0)),\n    m\n  );\n}\n\nsdf sdf_plane(vec3 p, sdfparams m) {\n  return sdf(\n    p.y,\n    m\n  );\n}\n\nsdf wool(vec3 p, float wig, sdfparams wool_mat) {\n  vec3 np = p;\n  np /= vec3(1., 1., 1.2);\n  np = erot(np, vec3(0., 0., 1.), wig * 0.05);\n\n  sdf s = sdf_sphere(\n    np, 2.,\n    wool_mat\n  );\n\n  s.d *= 1.2;\n\n  s = sdf_wave_displace(np, 6., 0.05, s);\n\n  return s;\n}\n\nsdf eye(vec3 p, float blink, float eye_rad, float iris_rad, sdfparams head_mat) {\n  sdfparams eye_white = sdfparams(\n    vec3(1.),\n    100.,\n    1.,\n    1.\n  );\n\n  sdfparams eye_black = sdfparams(\n    vec3(0.05),\n    10.,\n    1.,\n    0.05\n  );\n\n  bool do_iris = length(p - vec3(0., 0., -eye_rad)) < iris_rad;\n\n  sdfparams mat;\n\n  if (blink == 1.0) {\n    mat = head_mat;\n  } else {\n    if (do_iris) {\n      mat = eye_black;\n    } else {\n      mat = eye_white;\n    }\n  }\n\n  sdf l = sdf_sphere(\n    p, eye_rad,\n    mat\n  );\n\n  return l;\n}\n\nsdf eyes(vec3 p, sdfparams head_mat) {\n  float blink = ceil(max(sin(iTime * 1.5) * 150. - 149., 0.));\n  float glance = floor(sin(iTime) * 0.55 + 0.5);\n\n  vec3 offs = vec3(0.21, 0., 0.);\n\n  vec3 lp = p;\n  lp /= vec3(1., 1.05, 1.);\n  lp += offs;\n  lp = erot(lp, vec3(0., 1., 0.), glance * 0.5);\n\n  vec3 rp = p;\n  rp /= vec3(1., 0.95, 1.);\n  rp -= offs;\n  rp = erot(rp, vec3(0., 1., 0.), glance * 0.5);\n\n  sdf leye = eye(lp, blink, 0.25, 0.06, head_mat);\n  leye.d *= 1.05;\n  sdf reye = eye(rp, blink, 0.2, 0.045, head_mat);\n  reye.d *= 0.95;\n\n  return sdf_union(leye, reye);\n}\n\nsdf ear(vec3 p, float wiggle, float m, sdfparams mat) {\n  vec3 np = p;\n  np = erot(np, vec3(0., 1., 0.), 0.25 * m);\n  np = erot(np, vec3(1., 0., 0.), wiggle);\n  np -= vec3(0., -0.75, 0.);\n  np = erot(np, vec3(0., 0., 1.), 3.14 / 3. * m);\n  np /= vec3(1., 1., .5);\n\n  sdf c = sdf_cylinder(\n    np,\n    0.5, 0.0,\n    mat\n  );\n  c.d *= 0.5;\n  c.d -= 0.025;\n\n  return c;\n}\n\nsdf ears(vec3 p, sdfparams mat) {\n  float ltime = iTime + 8.;\n  float rtime = iTime - 10.;\n  float lwiggle = max(fract(-ltime / 4.) * 3. - 2., 0.) * sin(ltime / 4. * 6.28 * 8.);\n  float rwiggle = max(fract(-rtime / 5.) * 4. - 3., 0.) * sin(rtime / 5. * 6.28 * 8.);\n\n  vec3 offs = vec3(1., 0., 0.);\n\n  sdf lear = ear(p - offs, lwiggle * 0.5, 1., mat);\n  sdf rear = ear(p + offs, rwiggle * 0.5, -1., mat); // haha\n\n  return sdf_union(lear, rear);\n}\n\nsdf head_base(vec3 p, sdfparams mat) {\n  sdf s = sdf_sphere(\n    p - vec3(0., -0.1, 0.),\n    1.,\n    mat\n  );\n\n  sdf c = sdf_cylinder(\n    p - vec3(0., 0.6, 0.4),\n    0.3, 0.5,\n    mat\n  );\n\n  c.d -= 0.5;\n\n  return sdf_smooth_union(s, c, 0.25);\n}\n\nsdf head(vec3 p, float wool_wiggle, sdfparams head_mat) {\n  vec3 np = p;\n  np = erot(np, vec3(0., 0., 1.), wool_wiggle * 0.015);\n\n  sdf head = head_base(np, head_mat);\n  sdf eyes = eyes(np - vec3(0., 0.9, -0.35), head_mat);\n  sdf ears = ears(np - vec3(0., 1.4, 0.5), head_mat);\n\n  return sdf_union(\n    sdf_smooth_union(head, ears, 0.1),\n    eyes\n  );\n}\n\nsdf leg(vec3 p, sdfparams wool_mat, sdfparams skin_mat) {\n  p -= vec3(0., 1.25, 0.);\n\n  sdf leg = sdf_cylinder(\n    p,\n    0.125, 1.25,\n    skin_mat\n  );\n\n  sdf thing = sdf_cylinder(\n    p - vec3(0., 1.25, 0.),\n    0.2, 0.4,\n    wool_mat\n  );\n\n  vec3 fp = p;\n  fp /= vec3(1., 1., 1.1);\n  fp -= vec3(0., -1.1, -0.1);\n\n  sdf foot = sdf_cylinder(\n    fp,\n    0.2, 0.05,\n    skin_mat\n  );\n\n  foot.d /= 1.1;\n  foot.d -= 0.05;\n\n  return sdf_union(sdf_smooth_union(leg, foot, 0.25), thing);\n}\n\nsdf legs(vec3 p, sdfparams wool_mat, sdfparams skin_mat) {\n  vec3 np = vec3(abs(p.x), p.yz);\n  np -= vec3(1., 0., 0.);\n\n  sdf front = leg(np, wool_mat, skin_mat);\n  sdf back = leg(np - vec3(0., 0., 2.5), wool_mat, skin_mat);\n\n  return sdf_union(front, back);\n}\n\nsdf owen(vec3 p) {\n  sdfparams skin_mat = sdfparams(\n    vec3(0.1),\n    20.,\n    1.,\n    0.03\n  );\n\n  sdfparams wool_mat = sdfparams(\n    vec3(0.95),\n    10.,\n    1.,\n    0.1\n  );\n\n  vec3 np = p;\n  np -= vec3(0., 4.2, 0.);\n\n  float wool_wiggle = max(sin(iTime * 1.5), 0.) * sin(iTime * 12.);\n\n  vec3 head_p = np;\n  head_p -= vec3(0., sin(iTime / 3.) * 0.4 - 0.25, -2.);\n  head_p = erot(head_p, vec3(0., 0., 1.), sin(iTime / 1.5) * 0.1);\n  head_p += vec3(0., 0.25, 0.);\n\n  sdf h = head(head_p, wool_wiggle, skin_mat);\n\n  sdf w = wool(\n    np - vec3(0., sin(iTime / 2. + 1.) * 0.1, 1.),\n    wool_wiggle,\n    wool_mat\n  );\n\n  sdf l = legs(\n    p - vec3(0., 0., -0.25),\n    wool_mat,\n    skin_mat\n  );\n\n  return sdf_union(h, sdf_smooth_union(w, l, 0.5));\n}\n\nsdf scene(vec3 p) {\n  sdfparams ground_mat = sdfparams(\n    vec3(0.1, 0.8, 0.1),\n    10.,\n    1.,\n    0.1\n  );\n\n  sdf o = owen(p - vec3(0., 0., -1.));\n  sdf g = sdf_cylinder(\n    p,\n    5., 0.,\n    ground_mat\n  );\n\n  return sdf_union(o, g);\n}\n\nray raymarch(vec3 ro, vec3 rd) {\n  ray r = ray(\n    ro,\n    false,\n    0.,\n    0,\n    vec3(0.),\n    0.,\n    0.,\n    0.\n  );\n\n  for (int i = 0; i < ITERS_MAX; i++) {\n    sdf s = scene(r.p);\n    r.p += rd * s.d;\n    r.len += s.d;\n    r.iters = i;\n    r.c = s.p.c;\n    r.shin = s.p.shin;\n    r.diffr = s.p.diffr;\n    r.specr = s.p.specr;\n\n    if (s.d < DIST_MIN) {\n      r.hit = true;\n      break;\n    }\n    if (r.len > DIST_MAX) {\n      break;\n    }\n  }\n\n  return r;\n}\n\nvec3 norm(ray r) {\n  sdf s = scene(r.p);\n  vec2 eps = vec2(NORM_EPSILON, 0.);\n\n  return normalize(s.d - vec3(\n    scene(r.p - eps.xyy).d,\n    scene(r.p - eps.yxy).d,\n    scene(r.p - eps.yyx).d\n  ));\n}\n\nvec3 _diffuse(ray r, plight l, vec3 lv, vec3 n) {\n  return max(dot(lv, n), 0.) * r.c * l.c;\n}\n\nvec3 _specular(ray r, plight l, vec3 lv, vec3 n, vec3 rd) {\n  vec3 ref = reflect(lv, n);\n  return pow(max(dot(ref, rd), 0.), r.shin) * l.c;\n}\n\nvec3 singular_light(ray r, plight l, vec3 rd) {\n  vec3 n = norm(r);\n  vec3 lv = normalize(l.p - r.p);\n\n  return r.diffr * _diffuse(r, l, lv, n) + r.specr * _specular(r, l, lv, n, rd);\n}\n\nvec3 light(ray r, vec3 rd, vec3 amb) {\n  plight l1 = plight(\n    vec3(1., 1., -1.) * 8.,\n    vec3(1., 0.7, 0.5)\n  );\n\n  plight l2 = plight(\n    vec3(-1., -1., -1.) * 16.,\n    vec3(0.9, 0.9, 1.) * 0.25\n  );\n\n  plight l3 = plight(\n    vec3(0., 0., 1.) * 32.,\n    vec3(1., 1., 1.) * 0.75\n  );\n\n  vec3 c = amb;\n  c += singular_light(r, l1, rd);\n  c += singular_light(r, l2, rd);\n  c += singular_light(r, l3, rd);\n\n  return c;\n}\n\nvec3 cam(vec3 p) {\n  p = erot(p, vec3(1., 0., 0.), 0.2 + sin(iTime / 3.) * 0.1);\n  p = erot(p, vec3(0., 1., 0.), sin(iTime / 2.) * 0.25);\n  //p = erot(p, vec3(1., 0., 0.), sin(time * 2.));\n  //p = erot(p, vec3(0., 1., 0.), time);\n\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n  vec3 ro = vec3(0., 3., -12.);\n  vec3 rd = normalize(vec3(uv, 1.));\n\n  ro = cam(ro);\n  rd = cam(rd);\n\n  ray r = raymarch(ro, rd);\n\n  vec3 fg = light(r, rd, vec3(.01, 0.025, 0.025));\n  vec3 bg = vec3(0.5, 0.8, 0.8);\n\n  vec3 col = r.hit ? fg : bg;\n\n  fragColor = vec4(sqrt(col), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 484, 521, 521, 589], [591, 591, 636, 636, 911], [913, 913, 942, 942, 1041], [1043, 1043, 1099, 1099, 1170], [1172, 1172, 1218, 1218, 1264], [1266, 1266, 1323, 1323, 1455], [1457, 1457, 1493, 1493, 1529], [1531, 1531, 1580, 1580, 1795], [1797, 1797, 1878, 1878, 2332], [2334, 2334, 2372, 2372, 2907], [2909, 2909, 2964, 2964, 3277], [3279, 3279, 3312, 3312, 3725], [3727, 3727, 3765, 3765, 3973], [3975, 3975, 4032, 4032, 4328], [4330, 4330, 4387, 4387, 4815], [4817, 4817, 4875, 4875, 5077], [5079, 5079, 5097, 5097, 5831], [5833, 5833, 5852, 5852, 6075], [6077, 6077, 6109, 6109, 6543], [6545, 6545, 6563, 6563, 6745], [6747, 6747, 6796, 6796, 6840], [6842, 6842, 6901, 6901, 6983], [6985, 6985, 7032, 7032, 7170], [7172, 7172, 7210, 7210, 7595], [7597, 7597, 7615, 7615, 7841], [7843, 7843, 7898, 7898, 8249]], "test": "untested"}
{"id": "ddsBDS", "name": "SmoothNoise4489", "author": "shaderNoob4489", "description": "a shader that generator a noise partten", "tags": ["noise"], "likes": 1, "viewed": 64, "published": 3, "date": "1689146014", "time_retrieved": "2024-07-30T17:45:03.320531", "image_code": "float N21(vec2 p)\n{\n    return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    lv = lv * lv * (3. - 2. * lv);\n    vec2 id = floor(uv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1., 0.));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id + vec2(0., 1.));\n    float tr = N21(id + vec2(1., 1.));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv)\n{\n    float c = SmoothNoise(uv * 4.);\n    c += SmoothNoise(uv * 8.) * .5;\n    c += SmoothNoise(uv * 16.) * .25;\n    c += SmoothNoise(uv * 32.) * .125;\n    c += SmoothNoise(uv * 64.) * .0625;\n    return c / 1.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv += iTime * .1;\n    float c = SmoothNoise2(uv);\n    vec3 col = vec3(c);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 78], [80, 80, 108, 108, 445], [447, 447, 476, 476, 690], [692, 692, 749, 799, 985]], "test": "untested"}
{"id": "dslBDS", "name": "Octaweb kernel", "author": "sndels", "description": "Functions for generating samples centered around (0, 0) with a ring based octaweb layout. Outer ring is placed at kernelRadius distance from the origin.\n\nIdea and name from 'A Life of a Bokeh' by Guillaume Abadie, but similar kernels have earlier sources.", "tags": ["sampling"], "likes": 3, "viewed": 247, "published": 3, "date": "1689145455", "time_retrieved": "2024-07-30T17:45:04.482424", "image_code": "// CC0\n\n#define PI 3.1415926535\n\n// The center sample counts as a ring, so ringCount should be at least 2\nint ringCount = 5;\nint ringSampleFactor = 8;\nfloat kernelRadius = 3.5;\n\nint octawebRingSampleCount(int ring)\n{\n    return ring == 0 ? 1 : ringSampleFactor * ring;\n}\n\nvec2 octawebSample(int ring, int s, int ringSampleCount, int ringCount, float kernelRadius)\n{\n    // Need to place n-1 rings along the radius since center is ring 0\n    float ringSpacing = kernelRadius / float(ringCount - 1);\n    float r = float(ring) * ringSpacing;\n    \n    float rimSpacing = 2.0 * PI / float(ringSampleCount);\n    float phi = float(s) * rimSpacing;\n    // Rings are 'interleaved', probably to make the pattern less obviously repeating\n    if (ring % 2 == 0)\n        phi += rimSpacing * 0.5;\n\n    float x = r * cos(phi);\n    float y = r * sin(phi);\n    \n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Setup a coordinate system over the frame\n    vec2 clip = uv * 2.0 - 1.0;\n    // Fix aspect ratio\n    clip.x *= iResolution.x / iResolution.y;\n    vec2 coord = clip * 6.0;\n    \n    vec3 col = vec3(0);\n    \n    // Draw gridlines\n    if (fract(coord.x) < 0.05 || fract(1.0 - coord.x) < 0.05)\n        col = vec3(0.1);\n    if (fract(coord.y) < 0.05 || fract(1.0 - coord.y) < 0.05)\n        col = vec3(0.1);\n        \n    // Draw samples\n    for (int ring = 0; ring < ringCount; ++ring)\n    {\n        int ringSampleCount = octawebRingSampleCount(ring);\n        for (int si = 0; si < ringSampleCount; ++si)\n        {\n            vec2 s = octawebSample(ring, si, ringSampleCount, ringCount, kernelRadius);\n            \n            if (distance(coord, s) < 0.1)\n            {\n                col = vec3(0.8);\n                break;\n            }\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 216, 216, 270], [272, 272, 365, 436, 869], [871, 871, 928, 928, 1865]], "test": "untested"}
{"id": "cssBDB", "name": "PCG Random", "author": "miyaokamarina", "description": "High-quality random right in GLSL!", "tags": ["noise", "random", "hash", "pcg", "lcg", "pcgrandom", "mcg", "splitmix", "murmurhash", "splitmix32"], "likes": 1, "viewed": 208, "published": 3, "date": "1689136527", "time_retrieved": "2024-07-30T17:45:05.436872", "image_code": "// SPDX-License-Identifier: CC0-1.0\n//\n// # GLSL PCG Random + SplitMix32\n//\n// This implementation supports three modes (see `MODE`)\n// and provides four output functions (see `initfn` and `outputfn`).\n//\n// It has 32 bits of state and produces 16-bit values.\n//\n// Usage:\n//\n// ```\n// rng my_rng = SeedRNG(seed, stream);\n//\n// uint x = rand_u16(my_rng); // random 16-bit int in `[0, 2^16)`\n// float y = rand_f32(my_rng); // random float in `[0, 1)` (16 bits of random)\n// float z = jitter_f32(my_rng, 2.0); // low discrepancy random\n// ```\n//\n// Streams allow a generator to produce 2^31 *different*\n// pseudorandom sequences, that will *never* overlap.\n// When using the `out_id` scrambler, these sequences\n// usually have correlations, so be careful.\n// Each stream is identified by an unsigned odd integer.\n\n// `0` - BW\n// `1` - RGB\n// `2` - RGBA\n#define COLOR 0\n\n// `0` - all pixels have the same seed\n// `1` - each pixel has a unique seed\n#define VAR_SEED 1\n\n//       mode                    - period - speed/quality\n// ------------------------------------------------------\n// `0` - LCG                     - 2^32   - best quality\n// ------------------------------------------------------\n// `1` - MCG, implies VAR_SEED   - 2^30   - faster, but has a reduced period\n//                                          and doesn’t support streams\n// ------------------------------------------------------\n// `2` - counter (SplitMix-like) - 2^32   - even faster, but requires\n//                                          a good seed and/or scrambler function\n#define MODE 0\n\n// Seed function:\n//\n// function        - details                  - speed       - quality\n// ------------------------------------------------------------------\n// `init_id`       - identity                 - the fastest - worst quality\n// ------------------------------------------------------------------\n// `init_xsh_rs`   - fixed xorsh              - fast        - somewhat acceptable quality\n// ------------------------------------------------------------------\n// `init_rxs_m_xs` - random xorsh, MCG, xorsh - slower      - even better\n// ------------------------------------------------------------------\n// `init_mmh3`     - MurmurHash3              - ±same here  - the bestest\n#define initfn init_mmh3\n\n// Scrambler function:\n//\n// `out_id`\n// `out_xsh_rs`\n// `out_rxs_m_xs`\n// `out_mmh3`\n#define outputfn out_mmh3\n\nstruct rng {\n    uint state;\n    #if MODE != 1\n    uint stream;\n    #endif\n};\n\nrng   SeedRNG(uint, uint);\nvoid  bump(inout uint, uint);\nvoid  bump(inout rng);\n\nuint  init_id(uint);\nuint  init_xsh_rs(uint);\nuint  init_rxs_m_xs(uint);\nuint  init_mmh3(uint);\n\nuint  out_id(uint);\nuint  out_xsh_rs(uint);\nuint  out_rxs_m_xs(uint);\nuint  out_mmh3(uint);\n\nuint  rand_u16(inout rng);\nfloat rand_f32(inout rng);\n\nrng SeedRNG(uint seed, uint line) {\n    seed = initfn(seed);\n    \n    #if MODE == 1\n        seed |= 3u;\n        rng rng = rng(seed);\n    #else\n        line = initfn(line);\n        rng rng = rng(seed, line | 1u);\n    #endif\n\n    bump(rng);\n    return rng;\n}\n\nvoid bump(inout uint s, uint c) {\n    #if   MODE == 0\n        s *= 747796405u;\n        s += c;\n    #elif MODE == 1\n        s *= 741103597u;\n    #else\n        s += c;\n    #endif\n}\n\nvoid bump(inout rng rng) {\n    #if MODE != 1\n        bump(rng.state, rng.stream);\n    #else\n        bump(rng.state, 0u);\n    #endif\n}\n\nuint init_id(uint old) {\n    return old;\n}\n\nuint init_xsh_rs(uint old) {\n    return old ^ old >> 16;\n}\n\nuint init_rxs_m_xs(uint old) {\n    uint shr = old >> 28;\n    old ^= old >> (4u + shr);\n    old *= 277803737u;\n    old ^= old >> 22;\n    return old;\n}\n\nuint init_mmh3(uint old) {\n    old ^= old >> 16;\n    old *= 0x85EBCA6Bu;\n    old ^= old >> 13;\n    old *= 0xC2B2AE35u;\n    old ^= old >> 16;\n    return old;\n}\n\nuint out_id(uint old) {\n    return old >> 16;\n}\n\nuint out_xsh_rs(uint old) {\n    uint rsh = old >> 30;\n    old  ^= old >> 19;\n    old >>= 11u + rsh;\n    old  &= 0xFFFFu;\n    return old;\n}\n\nuint out_rxs_m_xs(uint old) {\n    uint shr = old >> 29;\n    old  ^= old >> (3u + shr);\n    old  *= 277803737u;\n    old >>= 16;\n    old  ^= old >> 11;\n    return old;\n}\n\nuint out_mmh3(uint old) {\n    return init_mmh3(old) & 0xFFFFu;\n}\n\nuint rand_u16(inout rng rng) {\n    uint old = rng.state;\n    bump(rng);\n    return outputfn(old);\n}\n\nfloat rand_f32(inout rng rng) {\n    uint raw = 0x3F800000u | (rand_u16(rng) << 7);\n    return uintBitsToFloat(raw) - 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint x = uint(fragCoord.x) << 0xBu;\n    uint y = uint(fragCoord.y) << 0x2u;\n\n    uint line = x | y;\n    \n    #if VAR_SEED == 1 || MODE == 1\n        uint seed = line;\n    #else\n        uint seed = 2434u;\n    #endif\n\n    rng rng = SeedRNG(seed, line);\n\n    #if COLOR == 0\n        fragColor = vec4(vec3(rand_f32(rng)), 1.0);\n    #elif COLOR == 1\n        fragColor = vec4(rand_f32(rng), rand_f32(rng), rand_f32(rng), 1.0);\n    #else\n        fragColor = vec4(rand_f32(rng), rand_f32(rng), rand_f32(rng), rand_f32(rng));\n    #endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssBDB.jpg", "access": "api", "license": "unknown-spdx", "functions": [[2803, 2803, 2838, 2838, 3059], [3061, 3061, 3094, 3094, 3239], [3241, 3241, 3267, 3267, 3374], [3376, 3376, 3400, 3400, 3418], [3420, 3420, 3448, 3448, 3478], [3480, 3480, 3510, 3510, 3629], [3631, 3631, 3657, 3657, 3789], [3791, 3791, 3814, 3814, 3838], [3840, 3840, 3867, 3867, 3978], [3980, 3980, 4009, 4009, 4147], [4149, 4149, 4174, 4174, 4213], [4215, 4215, 4245, 4245, 4314], [4316, 4316, 4347, 4347, 4439], [4441, 4441, 4496, 4496, 5028]], "test": "untested"}
{"id": "DdlBDB", "name": "Video Contrast Enhancement Test", "author": "Hatchling", "description": "Borrowed from one of IQs shaders.\nAttempts to match the \"gradients\" of the source image (in oklab space) while clamping the colors to the target gamut (RGB).\nGradients are multi-scale finite differences biased towards high frequency details.", "tags": ["tonemapping"], "likes": 3, "viewed": 245, "published": 3, "date": "1689136238", "time_retrieved": "2024-07-30T17:45:06.357411", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = uv.x > 0.25 ? texture(iChannel0, uv) :  texture(iChannel1, uv);\n    fragColor.rgb = Srgb3(oklab_to_rgb(fragColor.rgb));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n\tfragColor.rgb = rgb_to_oklab(fragColor.rgb);\n    \n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    //if(labResult.x != 0.)\n    //    labResult.yz /= labResult.x;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    //c.yz *= c.x;\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 targetC = texture(iChannel0, uv).xyz;\n    vec3 currentC = texture(iChannel1, uv).xyz;\n    \n    if(iFrame == 0)\n        currentC = targetC;\n    \n    \n    vec4 noise = texture(iChannel2, fragCoord/iChannelResolution[2].xy) \n    + float(iFrame) * (vec4(0,1,2,3) + 0.61803398874989484820);\n    noise -= floor(noise);\n    \n    vec3 total = vec3(0);\n    float offsetScale = 0. + pow\n    (\n        2.0,\n        noise.y * (log2(iResolution.y) - 1.0)//1.0 / (noise.y*noise.y+0.125)\n    );\n    \n    float angle = noise.x * 3.1415927 * 2.;\n    float sinAng = sin(angle);\n    float cosAng = cos(angle);\n    \n    \n    mat2x2 rotationMatrix = mat2x2\n    (\n        vec2(cosAng, -sinAng),\n        vec2(sinAng, cosAng)\n    );\n    \n    \n    \n\n    int count = 0;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            if(x == 0 && y == 0) continue;\n            vec2 offset2D = vec2(x,y)*offsetScale;\n            \n            vec2 offset2DRotated = rotationMatrix * offset2D;\n            \n            vec2 coord = (fragCoord+offset2DRotated)/iResolution.xy;\n            \n            if(coord.x < 0. || coord.x > 1. || coord.y < 0. || coord.y > 1.)\n                continue;\n                \n                count++;\n                \n            vec3 target = texture\n            (\n                iChannel0, \n                coord\n            ).xyz;  \n            \n            vec3 current = texture\n            (\n                iChannel1, \n                coord\n            ).xyz;\n            \n            if(iFrame == 0)\n                current = target;\n            \n            vec3 targetDiff = (targetC - target);\n            \n            // Saturation boost.\n            targetDiff.yz *= 2.0;\n            \n            // Boost and limit gradient magnitudes.\n            targetDiff /= (length(targetDiff) + 0.0625) * 1.5;\n            \n            total += current + targetDiff - currentC;\n        }    \n    }\n    \n    if(count > 0)\n        currentC += total / float(count);\n    \n    // Hue correction, prevents hue drift when there is room in the gamut for it\n    // to drift around.\n    // Also helps preserve skin tones.\n    vec2 targetHueDir = normalize(targetC.yz);\n    if(!any(isnan(targetHueDir)) && !any(isinf(targetHueDir)))\n        currentC.yz = mix(currentC.yz, (dot(targetHueDir, currentC.yz)) * targetHueDir, 0.5);\n    \n    //currentC.y *= 0.1;\n    \n    fragColor.rgb = oklab_to_rgb(currentC.rgb);\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n    fragColor.rgb = rgb_to_oklab(fragColor.rgb);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 235]], "test": "untested"}
{"id": "tlycWG", "name": "Local Contrast Enhancement (WIP)", "author": "Hatchling", "description": "Borrowed from one of IQs shaders.\nAttempts to match the \"gradients\" of the source image (in oklab space) while clamping the colors to the target gamut (RGB).\nGradients are multi-scale finite differences biased towards high frequency details. See comment.", "tags": ["tonemapping"], "likes": 7, "viewed": 526, "published": 3, "date": "1689133933", "time_retrieved": "2024-07-30T17:45:07.309864", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = uv.x > 0.25 ? texture(iChannel0, uv) :  texture(iChannel1, uv);\n    fragColor.rgb = Srgb3(oklab_to_rgb(fragColor.rgb));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// on the derivatives based noise: https://iquilezles.org/articles/morenoise\n// on the soft shadow technique: https://iquilezles.org/articles/rmshadows\n// on the fog calculations: https://iquilezles.org/articles/fog\n// on the lighting: https://iquilezles.org/articles/outdoorslighting\n// on the raymarching: https://iquilezles.org/articles/terrainmarching\n\n\n#define AA 0   // make this 2 or even 3 if you have a really powerful GPU\n\n\n#define SC (250.0)\n\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n\nfloat terrainH( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<16; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn SC*120.0*a;\n}\n\nfloat terrainM( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn SC*120.0*a;\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn SC*120.0*a;\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<300; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( abs(h)<(0.0015*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainM( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y>(SC*200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.001*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0 ).x;\n    return f/0.9375;\n}\n\nconst float kMaxT = 5000.0*SC;\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = normalize( vec3(0.8,0.4,0.3) );\n    // bounding plane\n    float tmin = 1.0;\n    float tmax = kMaxT;\n#if 1\n    float maxh = 300.0*SC;\n    float tp = (maxh-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = raycast( ro, rd, tmin, tmax );\n    if( t>tmax)\n    {\n        // sky\t\t\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n        t = -1.0;\n\t}\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        //nor = normalize( nor + 0.5*( vec3(-1.0,0.0,-1.0) + vec3(2.0,1.0,2.0)*texture(iChannel1,0.01*pos.xz).xyz) );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n        // rock\n\t\tfloat r = texture( iChannel0, (7.0/SC)*pos.xz/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), \n                                     texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)/SC).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        \n        \n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\t\tcol *= 0.1+1.8*sqrt(fbm(pos.xz*0.04)*fbm(pos.xz*0.005));\n\n\t\t// snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y/SC + 25.0*fbm(0.01*pos.xz/SC) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         // lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*SC*0.05,light1);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(8.00,5.00,3.00)*1.3*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,1.00)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        col += (0.7+0.3*s)*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0))*\n               vec3(7.0,5.0,3.0)*dif*sh*\n               pow( clamp(dot(nor,hal), 0.0, 1.0),16.0);\n        \n        col += s*0.65*pow(fre,4.0)*vec3(0.3,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n        //col = col*3.0/(1.5+col);\n        \n\t\t// fog\n        float fo = 1.0-exp(-pow(0.001*t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);// + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n        col = mix( col, fco, fo );\n\n\t}\n    // sun scatter\n    col += 0.3*vec3(1.0,0.7,0.3)*pow( sundot, 8.0 );\n    \n\treturn vec4( col, t );\n}\n\nvec3 camPath( float time )\n{\n\treturn SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrainL( ro.xz ) + 22.0*SC;\n\tta.y = ro.y - 20.0*SC;\n\tfloat cr = 0.2*cos(0.1*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.05 - 0.1 + 12. + 4.0*iMouse.x/iResolution.x;\n\n    // camera position\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n\n    // camera2world transform    \n    mat3 cam = setCamera( ro, ta, cr );\n\n    // pixel\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    float t = kMaxT;\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 s = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t#else    \n        vec2 s = p;\n\t#endif\n\n        // camera ray    \n        vec3 rd = cam * normalize(vec3(s,fl));\n\n        vec4 res = render( ro, rd );\n        t = min( t, res.w );\n \n        tot += res.xyz;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n\n    //-------------------------------------\n\t// velocity vectors (through depth reprojection)\n    //-------------------------------------\n    float vel = 0.0;\n    if( t<0.0 )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        // old camera position\n        float oldTime = time - 0.1 * 1.0/24.0; // 1/24 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        // world space\n        #if AA>1\n        vec3 rd = cam * normalize(vec3(p,fl));\n        #endif\n        vec3 wpos = ro + rd*t;\n        // camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        // ndc space\n        vec2 npos = oldFl * cpos.xy / cpos.z;\n        // screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n\n\n        // compress velocity vector in a single float\n        vec2 uv = fragCoord/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n    \n\ttot = rgb_to_oklab(tot);\n    fragColor = vec4( tot, vel );\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    //if(labResult.x != 0.)\n    //    labResult.yz /= labResult.x;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    //c.yz *= c.x;\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 targetC = texture(iChannel0, uv).xyz;\n    vec3 currentC = texture(iChannel1, uv).xyz;\n    \n    if(iFrame == 0)\n        currentC = targetC;\n    \n    \n    vec4 noise = texture(iChannel2, fragCoord/iChannelResolution[2].xy) \n    + float(iFrame) * (vec4(0,1,2,3) + 0.61803398874989484820);\n    noise -= floor(noise);\n    \n    vec3 total = vec3(0);\n    float offsetScale = 0. + pow\n    (\n        2.0,\n        noise.y * (log2(iResolution.y) - 1.0)//1.0 / (noise.y*noise.y+0.125)\n    );\n    \n    float angle = noise.x * 3.1415927 * 2.;\n    float sinAng = sin(angle);\n    float cosAng = cos(angle);\n    \n    \n    mat2x2 rotationMatrix = mat2x2\n    (\n        vec2(cosAng, -sinAng),\n        vec2(sinAng, cosAng)\n    );\n    \n    \n    \n\n    int count = 0;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            if(x == 0 && y == 0) continue;\n            vec2 offset2D = vec2(x,y)*offsetScale;\n            \n            vec2 offset2DRotated = rotationMatrix * offset2D;\n            \n            vec2 coord = (fragCoord+offset2DRotated)/iResolution.xy;\n            \n            if(coord.x < 0. || coord.x > 1. || coord.y < 0. || coord.y > 1.)\n                continue;\n                \n                count++;\n                \n            vec3 target = texture\n            (\n                iChannel0, \n                coord\n            ).xyz;  \n            \n            vec3 current = texture\n            (\n                iChannel1, \n                coord\n            ).xyz;\n            \n            if(iFrame == 0)\n                current = target;\n            \n            vec3 targetDiff = (targetC - target);\n            \n            // Boost and limit gradient magnitudes.\n            targetDiff /= (length(targetDiff) + 0.125) * 1.5;\n            \n            total += current + targetDiff - currentC;\n        }    \n    }\n    \n    if(count > 0)\n        currentC += total / float(count);\n    \n    vec2 targetHueDir = normalize(targetC.yz);\n    currentC.yz = mix(currentC.yz, (dot(targetHueDir, currentC.yz)) * targetHueDir, 0.15);\n    \n    //currentC.y *= 0.1;\n    \n    fragColor.rgb = oklab_to_rgb(currentC.rgb);\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n    fragColor.rgb = rgb_to_oklab(fragColor.rgb);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlycWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 235]], "test": "untested"}
{"id": "cdlBWB", "name": "Glass canyons", "author": "jarble", "description": "A fractal structure with volumetric lighting.\nI discovered this effect only by accident, is this just an interesting raymarching artifact?", "tags": ["3d", "fractal", "shadow", "ao", "golf"], "likes": 6, "viewed": 228, "published": 3, "date": "1689133063", "time_retrieved": "2024-07-30T17:45:08.097757", "image_code": "//https://www.shadertoy.com/view/cdG3Wd\n\nmat2 M = mat2(6,8,-8,6)*.1;\nfloat i,t,s,j;\nfloat D(vec3 p)\n{\n\tfor(i=1e2,t = p.y+8.; i>.1; i/=4.)\n\t\tp.zx *= M,\n\t\tp.y += i*.5,\n\t\tp = i*vec3(.9,.6,.8) - abs(mod(p,i+i)-i),\n\t\ts = min(1.-p.x,2.-min(p.y,p.z)),\n        t<s? t=s, j=i : j;\n\treturn t;\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec3 r=iResolution, d=normalize(vec3(I+I,0)-r.xyy), p=2.-iTime/r/r/.1,n,e=vec3(1,1,-1)/1e2;\n    float i=0.,t=i,s=t;\n    for(d.yz *= M; r.z++<2e2; t += s)\n        s = D(p),\n        p += d*s;\n    O = cos(j*vec4(9,17,24,0))+1.;\n    n = normalize(D(p+e)*e+D(p+e.xzx)*e.xzx+D(p+e.zxx)*e.zxx+D(p+e.z)*e.z);\n   \n    for(s=.01; s<.2; s/=.8)\n        O *= max(D(p+n*s*t)/s/t,.02),\n        O *= max(D(p+s*t)/s/t,.01);\n    O = pow(O/1e3,vec4(.04))+t/6e2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 101, 101, 284], [286, 286, 322, 322, 771]], "test": "untested"}
{"id": "dsfBDS", "name": "PERLIN NOISE EXAMPLE", "author": "jackjackdev", "description": "Credits to Suboptimal Engineer's youtube tutorial on Perlin noise shaders https://www.youtube.com/watch?v=7fd331zsie0\n", "tags": ["noise", "perlin", "billow", "ridged"], "likes": 1, "viewed": 182, "published": 3, "date": "1689114039", "time_retrieved": "2024-07-30T17:45:08.857726", "image_code": "// PERLIN NOISE EXAMPLE\n// Credits to Suboptimal Engineer's youtube tutorial https://www.youtube.com/watch?v=7fd331zsie0\n\nvec2 randomGradient(vec2 p) {\n  p = p + 0.02;\n  float x = dot(p, vec2(123.4, 234.5));\n  float y = dot(p, vec2(234.5, 345.6));\n  vec2 gradient = vec2(x, y);\n  gradient = sin(gradient);\n  gradient = gradient * 43758.5453;\n\n  // update noise function with time\n  gradient = sin(gradient + iTime);\n  return gradient;\n}\n\n// inigo quilez - https://iquilezles.org/articles/distfunctions2d/\nfloat sdfCircle(in vec2 p, in float r) {\n  return length(p) - r;\n}\n\n// inigo quilez - https://iquilezles.org/articles/distfunctions2d/\nfloat sdfOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n  float l = length(b - a);\n  vec2 d = (b - a) / l;\n  vec2 q = (p - (a + b) * 0.5);\n  q = mat2(d.x, -d.y, d.y, d.x) * q;\n  q = abs(q) - vec2(l, th) * 0.5;\n  return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nvec2 cubic(vec2 p) {\n  return p * p * (3.0 - p * 2.0);\n}\n\nvec2 quintic(vec2 p) {\n  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // set up uv + colors\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv = fragCoord.xy / iResolution.y;\n\n  vec3 black = vec3(0.0);\n  vec3 white = vec3(1.0);\n  vec3 color = black;\n\n  // set up a grid\n  uv = uv * 4.0;\n  vec2 gridId = floor(uv);\n  vec2 gridUv = fract(uv);\n  color = vec3(gridId, 0.0);\n  color = vec3(gridUv, 0.0);\n\n  // coords of grid corners\n  vec2 bl = gridId + vec2(0.0, 0.0);\n  vec2 br = gridId + vec2(1.0, 0.0);\n  vec2 tl = gridId + vec2(0.0, 1.0);\n  vec2 tr = gridId + vec2(1.0, 1.0);\n\n  // random gradient for each grid corner\n  vec2 gradBl = randomGradient(bl);\n  vec2 gradBr = randomGradient(br);\n  vec2 gradTl = randomGradient(tl);\n  vec2 gradTr = randomGradient(tr);\n\n  // visualize gradients\n  vec2 gridCell = gridId + gridUv;\n  float distG1 = sdfOrientedBox(gridCell, bl, bl + gradBl / 2.0, 0.02);\n  float distG2 = sdfOrientedBox(gridCell, br, br + gradBr / 2.0, 0.02);\n  float distG3 = sdfOrientedBox(gridCell, tl, tl + gradTl / 2.0, 0.02);\n  float distG4 = sdfOrientedBox(gridCell, tr, tr + gradTr / 2.0, 0.02);\n  if (distG1 < 0.0 || distG2 < 0.0 || distG3 < 0.0 || distG4 < 0.0) {\n    color = vec3(1.0);\n  }\n\n  // visualize a single center pixel on each grid cell\n  float circleRadius = 0.025;\n  vec2 circleCenter = vec2(0.5, 0.5);\n  float distToCircle = sdfCircle(gridUv - circleCenter, circleRadius);\n  color = distToCircle > 0.0 ? color : white;\n\n  // find distance from current pixel to each grid corner\n  vec2 distFromPixelToBl = gridUv - vec2(0.0, 0.0);\n  vec2 distFromPixelToBr = gridUv - vec2(1.0, 0.0);\n  vec2 distFromPixelToTl = gridUv - vec2(0.0, 1.0);\n  vec2 distFromPixelToTr = gridUv - vec2(1.0, 1.0);\n\n  // calculate the dot products of gradients + distances\n  float dotBl = dot(gradBl, distFromPixelToBl);\n  float dotBr = dot(gradBr, distFromPixelToBr);\n  float dotTl = dot(gradTl, distFromPixelToTl);\n  float dotTr = dot(gradTr, distFromPixelToTr);\n\n  // smooth out gridUvs\n  // gridUv = smoothstep(0.0, 1.0, gridUv);\n  // gridUv = cubic(gridUv);\n  gridUv = quintic(gridUv);\n\n  // linear interpolation between 4 dot products\n  float b = mix(dotBl, dotBr, gridUv.x);\n  float t = mix(dotTl, dotTr, gridUv.x);\n  float perlin = mix(b, t, gridUv.y);\n  \n  \n\n  // display perlin noise (comment out the ridged noise and uncomment this next line for a pure perlin noise)\n  // color = vec3(perlin + 0.2);\n  \n  // display dots & arrows for visualizing the noise\n  // color = distToCircle > 0.0 ? color : white;\n  // if (distG1 < 0.0 || distG2 < 0.0 || distG3 < 0.0 || distG4 < 0.0) {\n  //   color = vec3(1.0);\n  // }\n\n  // billow noise\n  // float billow = abs(perlin);\n  // color = vec3(billow);\n\n  // ridged noise\n  vec2 spec = 1.0*texture(iChannel0, vec2(0.25,5.)).xx;\n  float ridgedNoise = 1.0 - abs(perlin);\n  ridgedNoise = pow(ridgedNoise, 5.); // + sin(iTime + uv.x)*spec.y;;\n  color = vec3(ridgedNoise, sin(iTime + uv.x)*spec.y, 0); // red-only right now\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 151, 151, 436], [438, 505, 545, 545, 571], [573, 640, 705, 705, 917], [919, 919, 939, 939, 975], [977, 977, 999, 999, 1054], [1056, 1056, 1113, 1137, 4046]], "test": "untested"}
{"id": "msXfWS", "name": "Fork Psychedeli initialfx 410", "author": "initialfx", "description": "Super colorful. Dutch color scheme goes boom!", "tags": ["2d", "plasma", "colorful", "psychedelic", "weird", "acid", "dutchcolorscheme", "rainbows"], "likes": 1, "viewed": 107, "published": 3, "date": "1689113419", "time_retrieved": "2024-07-30T17:45:09.623678", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 pos = (uv.xy-0.5);\n\tvec2 cir = ((pos.xy*pos.xy+sin(uv.x*18.0+iTime)/25.0*sin(uv.y*7.0+iTime*1.5)/1.0)+uv.x*sin(iTime)/16.0+uv.y*sin(iTime*1.2)/16.0);\n\tfloat circles = (sqrt(abs(cir.x+cir.y*0.5)*25.0)*5.0);\n\tfragColor = vec4(sin(circles*1.25+2.0),abs(sin(circles*1.0-1.0)-sin(circles)),abs(sin(circles)*1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 420]], "test": "untested"}
{"id": "dsfBWS", "name": "WORLEY / VORNOI NOISE EXAMPLE", "author": "jackjackdev", "description": "WORLEY / VORNOI NOISE EXAMPLE - ORGANIC NOISE SHADER\nCredits to Suboptimal Engineer's youtube tutorial https://www.youtube.com/watch?v=vcfIJ5Uu6Qw", "tags": ["noise", "vornoi", "organic"], "likes": 1, "viewed": 127, "published": 3, "date": "1689111911", "time_retrieved": "2024-07-30T17:45:10.470414", "image_code": "// WORLEY / VORNOI NOISE EXAMPLE - ORGANIC NOISE SHADER\n// Credits to Suboptimal Engineer's youtube tutorial https://www.youtube.com/watch?v=vcfIJ5Uu6Qw\n\nvec2 noise2x2(vec2 p) {\n  float x = dot(p, vec2(123.4, 234.5));\n  float y = dot(p, vec2(345.6, 456.7));\n  vec2 noise = vec2(x, y);\n  noise = sin(noise);\n  noise = noise * 43758.5453;\n  noise = fract(noise);\n  return noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // set up uv & base color\n  vec2 uv = fragCoord / iResolution.xy;\n  uv = fragCoord.xy / iResolution.y;\n\n  vec3 color = vec3(0.0);\n\n  // set up grid\n  uv = uv * 10.0; // adjust this for \"zoom in/out\"\n  vec2 currentGridId = floor(uv);\n  vec2 currentGridCoord = fract(uv);\n  color = vec3(currentGridCoord, 0.0);\n  currentGridCoord = currentGridCoord - 0.5;\n  color = vec3(currentGridCoord, 0.0);\n \n  // add a point at the center of each grid\n  float pointsOnGrid = 0.0;\n  float minDistFromPixel = 100.0;\n\n  for (float i = -1.0; i <= 1.0; i++) {\n    for (float j = -1.0; j <= 1.0; j++) {\n      vec2 adjGridCoords = vec2(i, j);\n      vec2 pointOnAdjGrid = adjGridCoords;\n\n      // vary the points based on time + noise\n      vec2 noise = noise2x2(currentGridId + adjGridCoords);\n      pointOnAdjGrid = adjGridCoords + sin(iTime * noise) * 0.5;\n\n      float dist = length(currentGridCoord - pointOnAdjGrid);\n      minDistFromPixel = min(dist, minDistFromPixel);\n    }\n  }\n\n  // display voronoi noise\n  color = vec3(minDistFromPixel);\n  color = vec3(smoothstep(0.0, 1.0, minDistFromPixel));\n\n  // display clouds\n  color = vec3(smoothstep(0.25, 1.0, 1.0 - minDistFromPixel));\n\n  // split into 2 color-opposite sections\n  if (uv.x > 8.8) {\n    color = vec3(smoothstep(0.0, 1.0, minDistFromPixel));\n  } else {\n    color = vec3(smoothstep(0.1, 1.0, 1.0 - minDistFromPixel));\n  }\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 177, 177, 378], [380, 380, 437, 465, 1842]], "test": "untested"}
{"id": "cdfBDS", "name": "One Zero Fields", "author": "theott", "description": "Visualizing some vector fields (VFs) in the plane.\nAll VFs have a zero at (0,0).\nAll VFs and their linear interpolations are visible at some point.\nbuffer B; VFs.\nbuffer A: pixel particle system.", "tags": ["visualization", "colors", "rainbow", "vectorfield"], "likes": 3, "viewed": 210, "published": 3, "date": "1689100972", "time_retrieved": "2024-07-30T17:45:11.248334", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = A(uv).xyz;\n    \n    // Glow\n    float d = sqrt3 - length(col);\n    //col *= pow(0.9 / d, 1.01);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (2.*fragCoord - iResolution.xy)/iResolution.y; // -1,1\n    vec2 V = fragCoord/iResolution.xy; // [0,1\n\n    vec2 field = B(V).xy; // get vector field \n    vec4 pre = A(V - 0.001 * field); // use vector field as gradient\n\n    vec3 col = pow3(clamp(pre.xyz,0.,.99),1.004); // color attenuation\n    \n    // Grid of points * Time varying pixel color * twinkle\n    float interval = 0.23;\n    vec2 UGrid = mod(U + interval * 0.5, interval);\n    float d = length(UGrid - vec2(interval*0.5));\n    vec3 grid = vec3(smoothstep(0.99, 1.0, (sqrt2 - d) / sqrt2));\n    vec3 palette = 0.5 + 0.5*cos(iTime+V.xyx+vec3(0,2,4));\n    float twinkle = map(sin(iTime/3.), -1.,1., 0.3, 1.);\n    col +=  grid * normalize(palette);// * twinkle;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//methods from https://www.shadertoy.com/view/3tBGzh\n#define A(U) texture(iChannel0, U)\n#define B(U) texture(iChannel1, U)\n#define C(U) texture(iChannel2, U)\n\nconst float sqrt2 = 1.4142135623730951;\nconst float sqrt3 = 1.7320508075688772;\n\n\n//utility functions\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat unipolar(float x){\n    return map(x,-1.,1.,0.,1.);\n}\n\nvec2 unipolar2(vec2 u){\n    return vec2(unipolar(u.x), unipolar(u.y));\n}\n\nvec3 pow3(vec3 u, float a){\n    return vec3(pow(u.x,a), pow(u.y,a), pow(u.z,a));\n}", "buffer_b_code": "float freqPlus(float T){\n    // positive part of a sine\n    float t = iTime / 20.0;\n    return clamp(step(0.0, sin(T*t)), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   float t = iTime / 20.0;\n\n   vec2 pos = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n   //pos += 0.5 * vec2(sin(t), sin(t*0.5));\n   \n   float x = pos.x;\n   float y = pos.y;\n   \n   // some vector fields\n   vec2 outVF = pos;\n   vec2 inVF = -pos;\n   vec2 rotVF = vec2(-y,x);\n   vec2 hyperbolaVF = vec2(x,-y);\n   vec2 rightVF = vec2(x*x + y*y, 0);\n   vec2 touchingCirclesVFA = vec2(x*x - y*y, 2.0 * x* y);\n   vec2 touchingCirclesVFB = vec2(-x*x + y*y, -2.0 * x* y);\n    \n   // interpolate between vector fields\n   vec2 VF =\n   freqPlus(1.0)  * inVF +\n   freqPlus(2.0)  * rotVF +\n   freqPlus(4.0)  * touchingCirclesVFA +\n   freqPlus(8.0)  * hyperbolaVF +\n   freqPlus(16.0) * rightVF;\n   \n   fragColor = vec4(VF,0,1.0);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 321]], "test": "untested"}
{"id": "DsfBWS", "name": "raymarched spheres", "author": "texl", "description": "some rarymarched spheres", "tags": ["raymarch"], "likes": 0, "viewed": 72, "published": 3, "date": "1689095800", "time_retrieved": "2024-07-30T17:45:12.018275", "image_code": "Surface sdScene(vec3 p, vec2 mouse, bool mouseActive, float time)\n{\n    Surface ret = EmptySurface;\n\n    vec3 c = vec3(1);\n    vec3 q = mod((p - vec3(0.5, 0.5, 0.0)) + 0.5 * c,c) - 0.5 * c;\n    float radius = 0.2;\n    vec3 color = vec3(1);\n    ret = minWithColor(ret, sdSphere(q, radius, color));\n    ret = minWithColor(ret, sdBasis(p, 1.0f));\n    return ret;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end, vec2 mouse, bool mouseActive, float time)\n{\n    float depth = start;\n    Surface co; // closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p, mouse, mouseActive, time);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > end) break;\n    }\n  \n    co.sd = depth;\n  \n    return co;\n}\n\nvec3 calcNormal(in vec3 p, vec2 mouse, bool mouseActive, in float time)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n        e.xyy * sdScene(p + e.xyy, mouse, mouseActive, time).sd +\n        e.yyx * sdScene(p + e.yyx, mouse, mouseActive, time).sd +\n        e.yxy * sdScene(p + e.yxy, mouse, mouseActive, time).sd +\n        e.xxx * sdScene(p + e.xxx, mouse, mouseActive, time).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.5);\n    float time = iTime;\n  \n    float cameraDistance = 4.25;\n  \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 mouse = cameraDistance * 0.5 * viewport_to_world(iMouse.xy, iResolution);\n    bool mouseActive = iMouse.z > 0.0;\n  \n    vec3 col = vec3(0);\n    vec3 ro = vec3(-0.25, 0, -cameraDistance); // ray origin that represents camera position\n    \n    float bob = sin(iTime * 0.1) * 0.05f;\n    ro += vec3(0, bob, 0);\n\n    vec3 target = vec3(0) + vec3(0.5, -0.5, 0.0);\n    if (mouseActive)\n    {\n        target = target + vec3(mouse, 0);\n    }\n    vec3 toTarget = target - ro;\n    mat3 lookAtInv = lookAtInv(toTarget);\n  \n//    vec3 rd = normalize(vec3(uv, 1) + vec3(0.15, -0.15, 0.0));\n//    if (mouseActive)\n//    {\n        vec3 rd = lookAtInv * normalize(vec3(uv, 1)); // ray direction\n//    }\n    \n\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST, mouse, mouseActive, time); // closest object\n\n    if (co.sd > MAX_DIST)\n    {\n        col = backgroundColor; // ray didn't hit anything\n    }\n    else\n    {\n        vec3 p = ro + rd * co.sd; // point on surface\n        vec3 normal = calcNormal(p, mouse, mouseActive, time);\n        vec3 lightPosition = vec3(4, -2, 0);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float ambientContrib = 0.01;\n        float diffuseContrib = 1.0 - ambientContrib;\n        vec3 ambient = ambientContrib * co.col;\n        vec3 diffuse = diffuseContrib * saturate(dot(normal, lightDirection)) * co.col;\n\n        col = ambient + diffuse;\n    }\n    \n    col = pow(col, vec3(1.0 / 2.2));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "const float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = 6.283185307179586476925286766559;\nconst float DEGREES_TO_RADIANS = PI / 180.0;\n\nvec3 lerp (in vec3 a, in vec3 b, in float t)\n{\n    return (1.0 - t) * a + t * b;\n}\n\nfloat saturate(in float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\n// origin at viewport center, y in range [-1, 1], corrected for aspect ratio\nvec2 viewport_to_world( in vec2 fragCoord, in vec3 resolution )\n{\n    return (2.0 * fragCoord - resolution.xy) / resolution.y;\n}\n\n// ray marching\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float PRECISION = 0.001;\n\nstruct Surface\n{\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nconst Surface EmptySurface = Surface(MAX_DIST, vec3(0));\n\n// operations\n\nSurface minWithColor(Surface obj1, Surface obj2)\n{\n    if (obj2.sd < obj1.sd)\n    {\n        return obj2;\n    }\n    else\n    {\n        return obj1;\n    }\n}\n\n// SDFs\n\n// torus\n// p = center\n// r1 = major radius (distance from center to circular cross-section center\n// r2 = radius of circular cross-section\nSurface sdTorus(vec3 p, float r1, float r2, vec3 col)\n{\n    vec2 q = vec2(length(p.xy) - r1, p.z);\n    return Surface(length(q) - r2, col);\n}\n\n// cone\n// p = center of base\n// c = sin/cos of angle\n// h = height\nSurface sdCone(vec3 p, vec2 c, float h, vec3 col)\n{\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xy), p.z);\n  vec2 a = w - q * saturate(dot(w,q) / dot(q,q));\n  vec2 b = w - q * vec2(saturate(w.x / q.x), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return Surface(sqrt(d) * sign(s), col);\n}\n\nSurface sdCone(vec3 p, float angle, float h, vec3 col)\n{\n    return sdCone(p, vec2(sin(angle), cos(angle)), h, col);\n}\n\n// infinite cylinder\n// p = point on center axis\n// r = radius\nSurface sdCylinder(vec3 p, float r, vec3 col)\n{\n    return Surface(length(p.xy) - r, col);\n}\n\n// finite cylinder\n// p = point on center axis\n// r = radius\n// h = height\nSurface sdCylinder(vec3 p, float r, float h, vec3 col)\n{\n  vec2 d = abs(vec2(length(p.xy), p.z - 0.5 * h)) - vec2(r, 0.5 * h);\n  return Surface(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), col);\n}\n\n// arrow\nSurface sdArrow(vec3 p, float shaftRadius, float totalLength, vec3 col)\n{\n    float capAngle = 20.0 * DEGREES_TO_RADIANS;\n    float capLength = 2.0 * shaftRadius / tan(capAngle);\n    Surface ret = EmptySurface;\n    ret = minWithColor(ret, sdCylinder(p, shaftRadius, totalLength - capLength, col));\n    ret = minWithColor(ret, sdCone((p - vec3(0, 0, totalLength)), capAngle, capLength, col));\n    return ret;\n}\n\n// sphere\n// p = center\n// r = radius\nSurface sdSphere(vec3 p, float r, vec3 col)\n{\n    return Surface(length(p) - r, col);\n}\n\n// box\n// p = center\n// b = size\nSurface sdBox(vec3 p, vec3 b, vec3 col)\n{\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return Surface(d, col);\n}\n\n// xz-plane\n// p = point on plane\nSurface sdFloor(vec3 p, vec3 col)\n{\n    float d = p.z + 1.0;\n    return Surface(d, col);\n}\n\nmat3 lookAtInv(vec3 lookAtDirection)\n{\n    vec3 forward = normalize(lookAtDirection);\n\n    const vec3 upHint = vec3(0, 1, 0);\n    vec3 rightTest = cross(upHint, forward);\n    vec3 right =\n        length(rightTest) < 0.0001\n            ? normalize(cross(forward, vec3(0, 0, 1)))\n            : normalize(rightTest);\n\n    vec3 up = normalize(cross(forward, right));\n\n    return mat3(right, up, forward);\n}\n\nSurface sdBasis( vec3 p, float scale )\n{\n    float arrowRadius = max(0.015, scale * 0.04);\n\n    vec3 colRed = vec3(1, 0, 0);\n    vec3 colGreen = vec3(0, 1, 0);\n    vec3 colBlue = vec3(0, 0, 1);\n\n    Surface col = EmptySurface;\n    col = minWithColor(col, sdBox(p, vec3(arrowRadius), vec3(1)));\n    col = minWithColor(col, sdArrow(p * lookAtInv(vec3(1, 0, 0)), arrowRadius, scale, colRed));\n    col = minWithColor(col, sdArrow(p * lookAtInv(vec3(0, 1, 0)), arrowRadius, scale, colGreen));\n    col = minWithColor(col, sdArrow(p * lookAtInv(vec3(0, 0, 1)), arrowRadius, scale, colBlue));\n    return col;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 67, 67, 361], [363, 363, 465, 465, 790], [792, 792, 865, 865, 1203], [1205, 1205, 1262, 1262, 2986]], "test": "untested"}
{"id": "dssfzl", "name": "Get Comfortable . [artfight2023]", "author": "oatmealine", "description": "attack for artfight 2023 @ redbirdrabbit!!!!!!\nseems to break on certain gpus - i didn't intend to turn this into a shadertoy upload, only exporting to gif, sorry!\nhttps://artfight.net/attack/4948553.get-comfortable", "tags": ["2d", "artfight", "artfight2023"], "likes": 24, "viewed": 392, "published": 3, "date": "1689086552", "time_retrieved": "2024-07-30T17:45:13.076446", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.141592653\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n  p = fract(p * .1031);\n  p *= p + 33.33;\n  p *= p + p;\n  return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n  p3 += dot(p3, p3.zyx + 31.32);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n  const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n  const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n  vec2  a = p - i + (i.x+i.y)*K2;\n  float m = step(a.y,a.x); \n  vec2  o = vec2(m,1.0-m);\n  vec2  b = a - o + K2;\n  vec2  c = a - 1.0 + 2.0*K2;\n  vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n  vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n  return dot( n, vec3(70.0) );\n}\n\n//perform one step of netwon's method to finalize the estimate\n#define ONE_NEWTON_STEP\n\n// of equation x^3+c1*x+c2=0\n/* Stolen from http://perso.ens-lyon.fr/christophe.winisdoerffer/INTRO_NUM/NumericalRecipesinF77.pdf,\n   page 179 */\n// subsequently stolen from https://www.shadertoy.com/view/MdfSDn\nfloat cubicRoot(float c1, float c2) {\n\tfloat q = -c1/3.;\n\tfloat r = c2/2.;\n\tfloat q3_r2 = q*q*q - r*r;\n\tif(q3_r2 < 0.) {\n\t\tfloat a = -sign(r)*pow(abs(r)+sqrt(-q3_r2),.333333);\n\t\tfloat b = a == 0. ? 0. : q/a;\n\t\treturn a+b;\n\t}\n\tfloat theta = acos(r/pow(q,1.5));\n\treturn -2.*pow(q,.5)*cos(theta/3.);\n}\n\nvec2 cls_one(vec2 p, float f) {\n  //sorry this is unreadable\n  float f2 = f*f; //sq\n  float cmn = 8.*f2*f2;\n  float x = sin(p.x*f)/f;\n  float pp = ((-4.*p.y-4.)*f2 + 1.)/cmn;\n  float qq = -x/cmn;\n  float sol = cubicRoot(pp, qq);\n  \n  x = asin(clamp(sol*f,-1.,1.))/f;\n  return vec2(x,-cos(f*2.*x));\n}\n\nvec3 sine_SDF(vec2 p, float freq) {\n  float wavelen = PI/freq;\n\n  //map p to be within the principal half cycle\n  float cell = round(p.x/wavelen)*wavelen;\n  float sgn = sign(cos(p.x*freq));\n  p.x = (p.x-cell)*sgn;\n  \n  vec2 off = vec2(-PI/freq/2.,0);\n  //approximate either side of the principal half cycle with\n  //the distance to the 2nd chebyshev polynomial of the 1st kind\n  vec2 a = -off+cls_one(off+p, freq/2.);\n  vec2 b =  off-cls_one(off-p, freq/2.);\n\n  //pick closest, comment out to see how the one-sided approximation looks\n  if (length(p-b) < length(p-a)) a = b;\n\n#ifdef ONE_NEWTON_STEP\n  //newton's method update via lagrange multipliers\n  //visually very close after one step, but more increases accuracy quadratically\n  vec3 K = vec3(a,p.x-p.y);\n  \n  //it might be possible to simplify this a lot...\n  vec3 lagrange = vec3(2.*(K.x-p.x)+K.z*-cos(K.x*freq)*freq,\n      2.*(K.y-p.y)-K.z,\n      K.y+sin(K.x*freq));\n  K -= (inverse(mat3(2.-K.z*-sin(K.x*freq)*freq*freq,0,cos(K.x*freq)*freq,0,2,1,-cos(K.x*freq)*freq,-1,0))*lagrange);\n  a = K.xy;\n  a.y = -sin(a.x*freq);\n#endif\n\n  float dist = length(p-a)*sign(p.y+sin(p.x*freq));\n  //map the closest point back to global coordinates\n  a.x *= sgn; a.x += cell;\n  return vec3(dist,a);\n}\n\nvec2 rotate(vec2 uv, float rot) {\n  // algebra formula for rotation by matrix , https://en.wikipedia.org/wiki/Rotation_matrix\n  mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n  // rotation of uv with matrix algebra formula where is set the rotation angle \n  return m * uv;\n}\n\n// ohhhhhh inigo quilez what would i do without you...\n\nfloat sdCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n  vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n  vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n  vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n  vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n  vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n  float s = sign( e0.x*e2.y - e0.y*e2.x );\n  vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                    vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                    vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n  return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w ) {\n  float r = 0.5*length(b-a);\n  float d = 0.5*(r*r-w*w)/w;\n  vec2 v = (b-a)/r;\n  vec2 c = (b+a)*0.5;\n  vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n  vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n  return length( q-h.xy) - h.z;\n}\n\n// polynomial smooth min\nfloat smin(float a, float b, float k) {\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat rand(vec2 n) { \n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noisenoise(vec2 p){\n  vec2 ip = floor(p);\n  vec2 u = fract(p);\n  u = u*u*(3.0-2.0*u);\n\n  float res = mix(\n    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n  return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm(vec2 p, float time) {\n  float f = 0.0;\n\n  f += 0.500000*noisenoise( p + time  ); p = mtx*p*2.02;\n  f += 0.031250*noisenoise( p ); p = mtx*p*2.01;\n  f += 0.250000*noisenoise( p ); p = mtx*p*2.03;\n  f += 0.125000*noisenoise( p ); p = mtx*p*2.01;\n  f += 0.062500*noisenoise( p ); p = mtx*p*2.04;\n  f += 0.015625*noisenoise( p + sin(time) );\n\n  return f/0.96875;\n}\n\nfloat pattern(in vec2 p, float time) {\n\treturn fbm(p + fbm(p + fbm(p, time), time), time);\n}\n\nvec4 maple(vec2 uv, vec2 pos, float rot, float scale) {\n  uv -= pos;\n  uv *= scale;\n  uv += pos;\n\n  uv.x += sin(uv.y * PI) * 0.05;\n\n  vec2 p = uv;\n\n  uv -= pos;\n  uv = rotate(uv, rot);\n  uv.x = -abs(min(uv.x, -uv.x));\n  uv += pos;\n\n  float round = 0.05;\n\n  float d = 9e9;\n  //d = smin(d, sdOrientedVesica(uv, pos, pos + vec2(-0.35, 0.0), 0.06), round);\n  d = smin(d, sdOrientedVesica(uv, pos, pos + vec2(-0.305, 0.15), 0.04), round);\n  d = smin(d, sdOrientedVesica(uv, pos, pos + vec2(-0.18, 0.3), 0.04), round);\n  d = smin(d, sdOrientedVesica(uv, pos + vec2(-0.07, 0.02), pos + vec2(-0.3, 0.3), 0.08), round);\n  d = smin(d, sdOrientedVesica(uv, pos, pos + vec2(0, 0.45), 0.1), round);\n  d = smin(d, sdOrientedVesica(uv, pos + vec2(0.0, 0.1), pos + vec2(-0.065, 0.4), 0.02), round);\n  d = smin(d, sdOrientedVesica(uv, pos + vec2(0.0, 0.1), pos + vec2(-0.1, 0.34), 0.05), round);\n\n  float rad = 0.01;\n  float alpha = smoothstep(rad, rad - 15. / iResolution.x, d);\n\n  vec3 col = vec3(1.0, 0.3, 0.0);\n  col -= max(0.02 - d, 0.0) * 1.0;\n  \n  // outline\n  col = mix(vec3(0.1), col, clamp(smoothstep(0.01, 0.05, rad - d), 0.0, 1.0));\n\n  col += (0.28 - length(vec2(p.x * 0.8, p.y) - vec2(-0.1, 0.5))) * 0.2;\n\n  return vec4(col, alpha);\n}\n\nvec4 eye(vec2 uv, vec2 pos, float t) {\n  uv -= pos;\n  vec2 uvI = uv;\n\n  float blink = 1.0 - pow(1.0 - ((sin(t * PI * 2.0)) * 0.5 + 0.5), 150.0);\n  //float blink = 1.0;\n\n  uv.y /= blink;\n\n  float size = 0.14 - blink * 0.02;\n  vec2 eyePos = vec2(uv.x, uv.y + sign(uv.y) * size);\n\n  float rad = 0.2;\n  float dist = length(eyePos);\n  bool inside = dist < rad;\n\n  float alpha = smoothstep(rad + 10. / iResolution.x, rad, dist);\n  vec3 col = vec3(1.0);\n\n  col -= smoothstep(0.8, 1.2, length(mix(uv, uvI, 0.6) * vec2(0.75, 1.0) - vec2(0.0, -0.1)) * 7.0) * 0.2;\n\n  vec2 irisPos = vec2(noise(vec2(t * 1.3, 0.0)), noise(vec2(0.0, -t * 1.3))) * 0.006;\n  float irisDist = 1.0 - length(irisPos - uvI) / 0.2;\n  float irisMix = smoothstep(0.6, 0.8, irisDist);\n  col = vec3(mix(col.r, 0.0, mix(irisMix, sqrt(irisMix), 0.3)), mix(col.g, 0.0, mix(irisMix, sqrt(irisMix), 0.8)), mix(col.b, 0.0, sqrt(irisMix)));\n\n  return vec4(col.rgb, alpha);\n}\n\nvec4 limb(vec2 uv, float t, float shift) {\n  if ((uv.y - uv.x) > 0.2) return vec4(0.0);\n  uv += vec2(0.1, -0.73);\n  float rad = 0.01 + noise(vec2(uv.y, shift)) * 0.01 + smoothstep(-0.3, -0.1, uv.y) * 0.1;\n  float dist = abs(sine_SDF((vec2(uv.y, uv.x) + vec2(0.0, -0.5)) * 2.0, 2.75 + sin(t * PI * 2.0) * 0.07).x);\n  float alpha = smoothstep(rad + 50. / iResolution.x, rad, dist);\n  return vec4(vec3(0.0), alpha);\n}\nvec4 limb2(vec2 uv, float t, float shift) {\n  //if (uv.x > 0.15) return vec4(0.0);\n  vec2 p = uv;\n  uv += vec2(-0.55, 0.55);\n  float rad = 0.01 + noise(vec2(uv.y, shift)) * 0.01;\n  float dist = abs(sine_SDF((uv + vec2(0.0, -0.5)) * 2.0, 1.25 + sin(t * PI * 2.0) * 0.07).x);\n  float alpha = smoothstep(rad + 50. / iResolution.x, rad, dist);\n  return mix(vec4(vec3(0.0), alpha), vec4(0.0), clamp((p.x - 0.13) / (0.13 - 0.1), 0.0, 1.0));\n}\nvec4 limb3(vec2 uv, float t, float shift) {\n  //if (uv.x > 0.4) return vec4(0.0);\n  vec2 p = uv;\n  uv += vec2(-0.9, 0.77);\n  float rad = 0.01 + noise(vec2(uv.y, shift)) * 0.01;\n  float dist = abs(sine_SDF((uv + vec2(0.0, -0.5)) * 2.0, 1.55 + sin(t * PI * 2.0 - 0.5) * 0.07).x);\n  float alpha = smoothstep(rad + 50. / iResolution.x, rad, dist);\n  return mix(vec4(vec3(0.0), alpha), vec4(0.0), clamp((p.x - 0.41) / (0.5 - 0.41), 0.0, 1.0));\n}\n\nvec4 head(vec2 uv, vec2 pos, float shift, float t) {\n  uv -= pos;\n\n  float dist = abs(uv.x) + abs(uv.y) + length(uv) * 0.2;\n  float rad = 0.36;\n\n  float alpha = smoothstep(rad + 15. / iResolution.x, rad, dist);\n  vec3 col = mix(vec3(0.1), vec3(0.5), clamp(smoothstep(0.01, 0.04, rad - dist), 0.0, 1.0));\n  col += ((0.28 + sin(shift) * 0.02) - length(vec2(uv.x * 0.8, uv.y) - vec2(-0.15, 0.2)));\n\n  vec4 l = maple(uv, vec2(0.0, 0.15), sin(t * PI * 2.0 - 1.5) * 0.2, 1.2);\n\n  return vec4(mix(l.rgb, col, alpha), max(alpha, l.a));\n}\n\nvec4 leaf(vec2 uv, vec2 pos, float angle, float scale, vec3 baseCol) {\n  uv -= pos;\n\n  uv *= scale;\n  uv = rotate(uv, angle);\n  uv += vec2(0.15, 0.0);\n\n  float size = 0.14;\n  vec2 eyePos = vec2(uv.x, uv.y + sign(uv.y) * size);\n\n  float rad = 0.2;\n  float dist = length(eyePos);\n  bool inside = dist < rad;\n\n  float alpha = smoothstep(rad + 15. / iResolution.x, rad, dist);\n  vec3 col = baseCol;\n\n  col -= smoothstep(0.8, 1.2, length(rotate(uv, -angle) + vec2(0.05, -0.1)) * 7.0) * 0.1;\n\n  float shadeScale = 1.0;\n  float xDist = shadeScale * 0.5 - (length(uv - vec2(0.0, 0.48)) * shadeScale);\n\n  col -= smoothstep(0.98, 1.0, shadeScale - abs(xDist)) * 0.1;\n\n  // outline\n  col = mix(vec3(0.1), col, clamp(smoothstep(0.0, 0.013, rad - dist), 0.0, 1.0));\n\n  return vec4(col, alpha);\n}\n\n#define rgb(r,g,b) (vec3(r,g,b) / 255.0)\n\n// see viewpalette.html\n#define PALETTE_SIZE 8\nvec3 colors[PALETTE_SIZE] = vec3[](\n  rgb(201, 204, 161),\n  rgb(202, 160, 90),\n  rgb(174, 106, 71),\n  rgb(139, 64, 73),\n  rgb(84, 51, 68),\n  rgb(81, 82, 98),\n  rgb(99, 120, 125),\n  rgb(142, 160, 145)\n);\n\nvec3 getPalette(vec3 col) {\n  // comparasion\n  float minDist = 9e9;\n  vec3 newCol;\n\n  for (int i = 0; i < PALETTE_SIZE; i++) {\n    vec3 compareCol = colors[i];\n\n    vec3 distVec = abs(col - compareCol);\n    float dist = (distVec.r + distVec.g + distVec.b) / 3.0;\n\n    if (dist < minDist) {\n      newCol = compareCol;\n      minDist = dist;\n    }\n  }\n\n  return newCol;\n}\n\n\nfloat Bayer2(vec2 a) {\n  a = floor(a);\n  return fract(a.x/2. + a.y*a.y * .75);\n}\n\n#define Bayer4(a)   ( Bayer2( .5*(a))/4. + Bayer2(a) )\n#define Bayer8(a)   ( Bayer4( .5*(a))/4. + Bayer2(a) )\n#define Bayer16(a)  ( Bayer8( .5*(a))/4. + Bayer2(a) )\n#define Bayer32(a)  ( Bayer16(.5*(a))/4. + Bayer2(a) )\n#define Bayer64(a)  ( Bayer32(.5*(a))/4. + Bayer2(a) )\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float t = fract(iTime * 0.2);\n  float shift = t * 5.0;\n\n  float itimer = fract(t + 0.2);\n  float downslope = pow(max(cos(itimer * 2.0 * PI * 0.188) * 2.0 - 1.0, 0.0), 0.6);\n  float downslope2 = max(pow(max(cos(fract(itimer + 0.05) * 2.0 * PI * 0.188) * 2.0 - 1.0, 0.0), 0.6), 0.0);\n  float upslope = pow(max(cos(itimer * 2.0 * PI * 2.0) + itimer - 1.0, 0.0), 0.5);\n  float intense = max(downslope, upslope);\n\n  // square & center\n  uv -= 0.5;\n  uv.x /= iResolution.y / iResolution.x;\n  uv += 0.5;\n  \n  if (uv.x < 0.0 || uv.x > 1.0) {\n    fragColor = vec4(vec3(0.0), 1.0);\n    return;\n  }\n\n  // pix\n  float pix = 256.0;\n  uv = floor(uv * pix) / pix + 0.001;\n\n  //uv.x += noise(uv * 2.0 + 0.5 * shift) * 0.003;\n  //uv.y += noise(uv * 2.0 - 0.5 * shift) * 0.003;\n\n  float fbmnoise = fbm(uv * 2.0, sin(t * PI * 2.0));\n  \n  // uncenter & unsquare\n  vec2 puv = uv;\n  puv -= 0.5;\n  puv.x *= iResolution.y / iResolution.x;\n  puv += 0.5;\n  \n  vec2 wuv = puv + vec2(sin(fbmnoise * 2.0 * PI), cos(fbmnoise * 2.0 * PI)) * 0.14 * (1.0 - intense);\n  float disp = 0.05 * (1.0 - intense);\n  vec3 bgcol = (\n    texture(iChannel0, wuv + vec2(disp, disp)).rgb +\n    texture(iChannel0, wuv + vec2(-disp, disp)).rgb +\n    texture(iChannel0, wuv + vec2(disp, -disp)).rgb +\n    texture(iChannel0, wuv + vec2(-disp, -disp)).rgb\n  ) / 4. - vec3(0.02);\n\n  vec3 chromacol = vec3(0.0, 0.25, 1.0);\n\n  vec3 col = chromacol;\n\n  vec4 ll = limb(vec2(1.0 - uv.x, uv.y), t, shift);\n  col = mix(col, ll.rgb, ll.a);\n  vec4 ll2 = limb2(uv, t, shift);\n  col = mix(col, ll2.rgb, ll2.a);\n  vec4 ll3 = limb3(uv, t, shift);\n  col = mix(col, ll3.rgb, ll3.a);\n\n  vec2 hpos = vec2(0.5, 0.6);\n  vec2 hmov1 = vec2(sin(t * PI * 2.0), cos(t * PI * 2.0));\n  vec2 hmov2 = vec2(cos(t * PI * 2.0), sin(t * PI * 2.0 + 1.0));\n  vec2 hmov = vec2(noise(hmov1.xy * 0.2 + 10.0), noise(hmov2.xy * 0.2 + 5.0));\n  vec2 huv = rotate((uv + hmov * 0.03) - hpos, sin(t * PI * 2.0) * 0.1) + hpos;\n  vec4 h = head(huv, hpos, intense, t);\n  col = mix(col, h.rgb, h.a);\n\n  vec4 e = eye(huv, hpos, t);\n  col = mix(col, e.rgb, e.a);\n\n  vec4 l1 = leaf(uv, vec2(0.5 + sin(t * PI * 2.0) * 0.02, 0.2 + sin(t * PI * 2.0) * 0.01), -sin(t * PI * 2.0 + 0.9) * 0.2 + 0.3 + PI, 1.0, vec3(1.0, 0.5, 0.1));\n  col = mix(col, l1.rgb, l1.a);\n  vec4 l2 = leaf(uv, vec2(0.15 + sin(t * PI * 2.0 - 0.5) * 0.04, 0.1), sin(t * PI * 2.0 - 1.2) * 0.2 - 0.5 + PI, 1.5, vec3(1.0, 0.3, 0.1));\n  col = mix(col, l2.rgb, l2.a);\n  vec4 l3 = leaf(uv, vec2(0.8 + sin(t * PI * 2.0) * 0.02, 0.08 + sin(t * PI * 2.0) * 0.01), -sin(t * PI * 2.0 + 0.1) * 0.2 + 0.4 + PI, 1.7, vec3(1.0, 0.55, 0.1));\n  col = mix(col, l3.rgb, l3.a);\n\n  float chroma = smoothstep(length(col - chromacol), 0.0, 0.5) / 0.3;\n\n  float posterize = 7.0;\n  col += mix(\n    hash13(vec3(uv.xy * iResolution.xy, shift)) * 1.4,\n    Bayer64(uv.xy * pix + shift) * 0.5,\n    intense\n  ) * (1. / posterize);\n  //col = floor(col.rgb * posterize + hash13(vec3(uv.xy * iResolution.xy, shift)) * 0.5) / posterize;\n  //col = floor(col.rgb * posterize + Bayer64(uv.xy * pix + shift) * 0.5) / posterize;\n  col = getPalette(col);\n  //col = floor(col.rgb * posterize) / posterize;\n\n  col = pow(col, vec3(mix(1.0, 2.5 + hash11(t * 50.0) * 1.0, 1.0 - intense)));\n\n  float bgblend = mix(chroma, 1.0, pow(intense, 1.5));\n  float fuckening = mix(bgblend, min(bgblend, 1.0 - e.a), 1.0 - downslope2);\n\n  vec3 back = mix(bgcol, vec3(0.0), 0.2);\n\n  fragColor = vec4(mix(back, col, fuckening), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 137]], "test": "untested"}
{"id": "msXfz2", "name": "Path Traced Quad Prism Traversal", "author": "Shane", "description": "Rendering a repeat irregular quad texture pattern to a cube map face, then using it to path trace an extruded asymmetric quad prism grid in realtime.", "tags": ["grid", "raycasting", "global", "illumination", "pathtracing", "city", "multisample", "quad", "reprojection", "emitter"], "likes": 92, "viewed": 1174, "published": 3, "date": "1689081720", "time_retrieved": "2024-07-30T17:45:14.330095", "image_code": "/*\n\n    Path Traced Quad Prism Traversal\n    --------------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n// This is an amalgamation of old blur and DOF functions with a couple of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// This function is only really suitable for this example. If you're interested in \n// bokeh, Dave's function above and some of Shadertoy user, Hornet's, are probably\n// the one's you should be looking at. Xor has some cool simple ones on here that I'm\n// yet to dig into, but they might worth a look also.\nvec4 bloom(sampler2D iCh, vec2 uv){\n\n\tvec4 tot = vec4(0);\n    \n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 4.5, coc = 1.5;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    //float r = smoothstep(.1, .9, abs(uv.y - .5)*2.)*2.;\n    float r = clamp(l/coc, 0., 2.);\n    //float r = mix(clamp(l/coc, 0., 2.), smoothstep(0., 1., abs(uv.y - .5)*2.)*2., .5);\n    \n    const int n = 4;\n    for (int j = -n; j<=n; j++){\n        for (int i = -n; i<=n; i++){\n           \n            // Random offset contained within a disk or radius n.\n            vec2 rnd2 = vec2(hash21B(vec2(i, j)), hash21B(vec2(i, j) + .1)*6.2831853);\n            vec2 offs = float(n)*rnd2.x*vec2(cos(rnd2.y), sin(rnd2.y));\n            \n            vec4 c = texture(iCh, uv + offs/vec2(800, 450)*r, r*iResolution.y/450.*.7); \n            tot += mix(c, pow(c, vec4(1.25))*3.5, rnd2.x*rnd2.x); //ow(c, vec4(1.5))*4.\n            \n        }\n    }\n    \n\treturn tot/float((n*2 + 1)*(n*2 + 1));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(abs(uv.y - .5)>.425){ fragColor = vec4(0); return; }\n    \n    // Bloom.\n    vec4 col = bloom(iChannel0, uv);\n    //\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n  \n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// If you want things to wrap, you need a wrapping scale.  Wrapping is not much \n// different to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash \n// function for anything that's procedurally generated with random numbers. If you're \n// using a repeat texture, then that'll have to wrap too.\nconst vec3 gSc = vec3(6);\n\n// Maximum frames to perform the precalculation.\nint maxFrames = 1;\n\n// Cube map resolution.\n#define cubemapRes vec2(1024)\n\n\n/* \n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube iCh, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(iCh, fcP[id]);\n}\n*/\n\n// Wrapping cube face conversion.\nvec2 convert(in vec2 p){ return fract((floor(p*cubemapRes) + .5)/cubemapRes) - .5; }\n\n// Cube face conversion with no wrapping.\nvec2 convert2(in vec2 p){ return ((floor(p*cubemapRes) + .5)/cubemapRes); }\n//float convert2(in float p){ return ((floor(p*cubemapRes.x) + .5)/cubemapRes.x); }\n\n\n// Cube face conversion with no wrapping.\nvec4 convert2(in vec4 p){ return ((floor(p*cubemapRes.xyxy) + .5)/cubemapRes.xyxy); }\n\n\nvec4 tx0(samplerCube iCh, vec2 p){\n    vec2 uv = convert(p);\n    return texture(iCh, vec3(-.5, uv.yx));\n \n}\n/*\nvec4 tx1(samplerCube iCh, vec2 p){\n\n    vec2 uv = convert(p);\n    return texture(iCh, vec3(.5, uv.y, -uv.x));\n}\n*/\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21B(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831853))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    p = mod(p, gSc.xy);\n    return fract(sin(mod(dot(p, vec2(27.609, 57.583)), 6.2831853))*43758.5453); \n}\n\n\n///////////////////\n\n// Standard bit encoding and decoding... Every coder's favorite task! :D\n// It's used for a specific task involving packing four low resolution \n// floats (stored in the form of integers) into one channel. Normally, you \n// could pack four large integers into one vector slot, but texture storage \n// complicates things, which traslates to smaller integers and less float\n// resolution... I won't bore you with it. :)\nconst uint ni = 6U;\nconst float fi = float(ni);\n\nconst uvec4 bitEnc = uvec4(1, ni, ni*ni, ni*ni*ni);\nvec4 EncodeFloatRGBA(float v) {\n    \n    return mod(vec4(uvec4(v)/bitEnc), fi);\n}\n\nfloat DecodeFloatRGBA(vec4 v) {\n\n    //return float(uint(v.x) + uint(v.y)*ni + uint(v.z)*ni*ni + uint(v.w)*ni*ni*ni);\n    return dot(vec4(uvec4(v)), vec4(bitEnc));\n}\n\n\n\n// Quad bound: We don't need an actual distance, so can take some shortcuts.\n// I hacked this together, so there would be faster ways to do it.\nfloat sdQuadBound(in vec2 p, mat4x2 v){\n \n     \n    //e[0] = normalize(v[0] - v[1]).yx*vec2(1, -1);\n    //e[1] = normalize(v[1] - v[2]).yx*vec2(1, -1);\n    //e[2] = normalize(v[2] - v[3]).yx*vec2(1, -1);\n    //e[3] = normalize(v[3] - v[0]).yx*vec2(1, -1); \n    float d = dot(p - v[0], normalize(v[0] - v[1]).yx*vec2(1, -1));\n    d = max(d, dot(p - v[1], normalize(v[1] - v[2]).yx*vec2(1, -1)));\n    d = max(d, dot(p - v[2], normalize(v[2] - v[3]).yx*vec2(1, -1)));\n    d = max(d, dot(p - v[3], normalize(v[3] - v[0]).yx*vec2(1, -1)));\n    return d;\n\n}\n\n\n// Rectangle dimensions: Any numbers should work. Obviously, vec2(1)\n// will produce squares.\nvec2 s = 1./gSc.xy; //vec2(1, 1)/6.;\n\n// IQ's vec2 to float hash.\nvec2 hash22T(vec2 p){ \n    \n    p = mod(p, 1./s);    \n    \n    p = fract(sin(mod(vec2(dot(p, vec2(12.783, 78.137)), \n                           dot(p, vec2(41.581, 57.263))), 6.2831853))\n                          *vec2(43758.5453, 23421.6361));\n    \n    return mod(floor(p*float(ni)), float(ni));\n    \n    //return texture(iChannel0, p/64.).xy*2. - 1.; \n}\n\n\n\n\n\n", "buffer_a_code": "/*\n\n    Path Traced Quad Prism Traversal\n    --------------------------------\n    \n    This is a realtime path traced asymmetric quad prism grid traversal. I put\n    it together as a fun exercise to see whether it was possible to produce a \n    passable looking globally illuminated scene with just a few samples. As with\n    other examples, I've used IQ's temporal reprojection routine to give the \n    appearance of a higher sample count. I also wanted to post an offset quad\n    cell by cell traversal to Shadertoy.\n    \n    Since this is realtime path tracing, things aren't going to be perfect on an\n    average system -- and apologies in advance for those with slower systems. A \n    basic static path traced scene normally takes seconds to minutes to produce in \n    a fast application like Blender, but realtime requirements only allow for a \n    fraction of a second per frame, so perfect quality is a big ask.\n    \n    Asymmetric grid cell traversals are not common at all, but there are some\n    pretty clever people on here, so they do exist on Shadertoy. There are a few \n    Voronoi traversals, and Fizzer put together a really cool asymmetric triangle \n    example that I'll link to below. I'm pretty sure I haven't come across a quad \n    version before, and I'm definitely sure there are no path traced ones.\n    \n    The obvious advantage to a path traced approach is the pretty lighting. The\n    downside is debilitating your GPU with multiple passes. I attempted to speed \n    up this particular scene by traversing a precalculated texture. If you peruse \n    the code, you'll see that it's not exactly user friendly. Unfortunately, some \n    plane tilings are too complicated to produce in realtime, let alone path \n    trace, so precalculation is the only way to do it on current hardware.\n    \n  \n    \n    \n    Other examples:\n    \n    // An offset triangle prism traversal. Fizzer was able to put his \n    // example together almost instantly. I did not finish mine instantly. :D\n    Irregular Trianglular Prisms - fizzer\n    https://www.shadertoy.com/view/wtjfDt\n    \n    // Path tracing a heap of boxes in realtime with the help of camera\n    // reprojection -- It's one of IQ's many understated examples that \n    // does something amazing.\n    Some boxes - iq\n    https://www.shadertoy.com/view/Xd2fzR\n\n\n*/\n\n\n\n// Unfortunately, if you have a slow machine IQ's temporal reprojection option\n// will usually result in blur. Regular accumulation might work, but you'll \n// probably have to use straight samples (BUFF_ACCUM 0).\n// Buffer accumulation style:\n// 0: No accumulation -- Noisy, sharper picture, but with no blur. \n// 1: Regular accumulation with no reprojection -- A mixture.\n// 2: Temporal reprojection. -- Smoother for faster machines.\n#define BUFF_ACCUM 2\n\n\n// Far plane. I've kept it close.\n#define FAR 25.\n\n\n///////////////\n\n// Random seed value.\nvec2 seed = vec2(.143, .217);\n\n \n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash22(){\n\n    // I should probably use a \"uvec2\" seed, but I hacked this from an old\n    // example. I'll update it later.\n    seed = fract(seed + vec2(.7123, .6457));\n    uvec2 p = floatBitsToUint(seed);\n    \n    // Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n    // Faster than \"full\" xxHash and good quality.\n    p = 1103515245U*((p>>1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n \n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir( in float seed, in vec3 n){\n\n    vec2 rnd = hash22();\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n\n\n// The following is based on John Hable's Uncharted 2 tone mapping, which\n// I feel does a really good job at toning down the high color frequencies\n// whilst leaving the essence of the gamma corrected linear image intact.\n//\n// To arrive at this non-tweakable overly simplified formula, I've plugged\n// in the most basic settings that work with scenes like this, then cut things\n// right back. Anyway, if you want to read about the extended formula, here\n// it is.\n//\n// http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/\n// A nice rounded article to read. \n// https://64.github.io/tonemapping/#uncharted-2\nvec4 uTone(vec4 x){\n    return ((x*(x*.6 + .1) + .004)/(x*(x*.6 + 1.)  + .06) - .0667)*1.933526;    \n}\n\n\n////////////////\n\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return dot(p - ro, n)/dot(rd, n);\n   float dn = dot(rd, n);\n   return dn>0.? dot(p - ro, n)/dn : 1e8;   \n\n}\n\n// Height function.\nfloat h(vec2 p){\n\n    //float f = dot(sin(p*.75 - cos(p.yx)*1.5), vec2(.25)) + .5;\n    //return f*3. + hash21(p)*1.;\n    \n    // Keeping things cheap and simple with only one texture read.\n    float h = texture(iChannel0, p/64.).x;\n    //h = mix(h - .1, h, smoothstep(.8, .9, sin(h*6.2831853 + iTime)));\n    return h*5.;\n}\n\nvec2 getUV(vec2 p){\n\n    // Cube map texture coordinate conversion.\n    p *= cubemapRes;\n    return fract((floor(p) + .5)/cubemapRes) - .5;\n    \n}\n\n// Rectangle scale: This was hacked in at the last minute and is a little\n// fickle. Sizes one to about 8 are OK. Lower numbers mean smaller rectangles,\n// which require more traversal steps in the \"raycast\" function.\nconst vec2 txSc = vec2(4);\n\n// Grid offset.\nmat4x2 gV;\n\n// Grid cell function.\nvec4 gridID(vec2 p){\n\n    // Same size squares, for comparison. \n    //return vec4(floor(p/txSc) + .5, txSc);\n\n    // Texture multiple ID.\n    vec2 p0 = (floor(p/txSc)*txSc.xy);\n\n    // Texture grid information -- Cube map faces are annoying to read into.\n    vec2 uv = getUV(p/txSc);\n    \n    // Read the texture face information.\n    vec4 hm2 = texture(iChannel3, vec3(-.5, uv.yx)); \n    // Converting to exact pixel positions for wrapping purposes.\n    hm2.xy = convert2(hm2).xy*txSc.xy;\n    //hm2.zw = convert2(hm2).zw*txSc.xy;\n\n    \n    // Read in and encode the vertex information.\n    vec4 v4A = EncodeFloatRGBA(hm2.z);\n    vec4 v4B = EncodeFloatRGBA(hm2.w);\n    mat4x2 sv = mat4x2(v4A, v4B);\n    \n    // Recreate the quad vertices.\n    gV = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5)); \n    gV += ((sv/float(ni))*2. - 1.)*.25;\n    // Scale.\n    //gV[0] *= s*txSc; gV[1] *= s*txSc; gV[2] *= s*txSc; gV[3] *= s*txSc;\n    gV *= s.x*txSc.x; // Only works for square dimensions, which is the case here.\n    \n    // Return the central position and dimension of the nearest quad.\n    return vec4((p0 + hm2.xy), hm2.zw);\n\n}\n\n\n\n// Sign function without the zero, which can cause problems for some routines.\nvec3 sign2(in vec3 p){ return vec3(p.x<0.? -1 : 1, p.y<0.? -1 : 1,  p.z<0.? -1 : 1); }\n//vec2 sign2(in vec2 p){ return vec2(p.x<0.? -1 : 1, p.y<0.? -1 : 1); }\n\nvec4 gGrid;\nvec3 gN = vec3(0);\n// A standard square cell by cell traversal. Not optimized enough for path tracing\n// purposes, but it's reasonable quick otherwise.\nvec4 raycast(vec3 ro, vec3 rd){\n \n    // Initializing to far.\n    vec4 res = vec4(FAR);\n    \n    \n    vec3 srd = sign2(rd);\n    \n   \n    // Initiate the ray position at the ray origin.\n    vec3 pos = ro;\n    \n    // Obtain the coordinates of the cell that the current ray position \n    // is contained in -- I've arranged for the cell coordinates to \n    // represent the cell center to make things easier.\n    //\n    // I found the following fudge in an old example of mine, and it gets rid \n    // of banding. It took ages to realize what I was thinking at the time. My \n    // notes mention stepping forward by a pixel (or scaled pixels) to the next \n    // cell. If you don't, your reflected rays, shadow rays, etc, risk counting\n    // the initial cell again -- This is the equivalent of a self-collision,\n    // which results in banded shadows, etc... Another explanation is, just make \n    // sure you do it. :D\n    vec4 ip4 = gridID(pos.xz + srd.xz*txSc/1024.);\n    vec2 ip = ip4.xy;\n    gGrid = ip4;\n    \n    // Set all distances to the maximum.\n    float t1 = 1e8, t2 = 1e8, t3 = 1e8, t4 = 1e8, tT = 1e8;\n    \n    // Clockwise edge direction vectors -- Used for jumping from cell to cell.\n    vec2 nn1 = vec2(-1, 0), nn2 = vec2(0, 1), nn3 = vec2(1, 0), nn4 = vec2(0, -1);\n    // Offset edge normal vectors.\n    vec2 n1, n2, n3, n4;\n  \n    \n    vec3 tn;\n    \n    int hit = 0;\n    \n    \n    // Iterate through the cells -- Obviously, if the cells were smaller,\n    // you'd need more to cover the distance.\n    for(int i = 0; i<32; i++){ \n\n         \n        // Height. \n        ip = ip4.xy;\n        float ma = h(ip);\n        \n         \n        // At this point, we haven't advanced the ray to the back of the cell boundary,\n        // so we're at one of the front cell face positions. Therefore, check to see if \n        // we're under the pylon height. If so, we've hit a face, so mark the face as hit, \n        // then break.\n        if(pos.y<ma){\n            // Hit a side.\n            hit = 1;\n            break; \n        \n        } \n        \n\n \n        // Edge normal calculation: You could precalculate these, but for some reason, \n        // it's faster on my machine to recalculate them in situ... No idea why, but \n        // probably special GPU cache reasons. :)\n        n1 = normalize((gV[1] - gV[0]).yx*vec2(1, -1));  \n        n2 = normalize((gV[2] - gV[1]).yx*vec2(1, -1));\n        n3 = normalize((gV[3] - gV[2]).yx*vec2(1, -1)); \n        n4 = normalize((gV[0] - gV[3]).yx*vec2(1, -1)); \n      \n\n       \n        // Ray intersection from the currect cell position to each of the \n        // visible cell walls. Normals face inward.\n        // You pass in the current position, the unit direction ray, a known \n        // point on the cell wall (any will do) and the cell wall's normal.\n        t1 = rayLine(pos.xz, rd.xz, (ip) + gV[0], -n1);\n        t2 = rayLine(pos.xz, rd.xz, (ip) + gV[1], -n2);\n        t3 = rayLine(pos.xz, rd.xz, (ip) + gV[2], -n3);\n        t4 = rayLine(pos.xz, rd.xz, (ip) + gV[3], -n4); \n        \n        // Determine the closest edge then record the closest distance and\n        // asign its normal index.         \n        tn = t1<t2 && t1<t3? vec3(t1, -nn1) : t2<t3? vec3(t2, -nn2) : vec3(t3, -nn3);\n        if(t4<tn.x) tn = vec3(t4, -nn4); \n        \n        //tn.x = min(min(t1, t2), min(t3, t4));\n         \n         \n        \n        \n        // Top face distance.\n        tT = (ma - pos.y)/rd.y;\n        tT = tT>0.? tT : 1e8;\n        \n        \n        // We've now advanced to one of the back faces of the cell. Check to see whether\n        // we're still under the pylon height, and if so, we've hit the top face --  \n        // I always have to think about this, but the logic is that we haven't hit a front\n        // cell face and we're still under the height, so we've hit the top. Anyway, mark \n        // the top face as hit, advance the distance in the Y direction to the top face, \n        // then break.\n        if(tT<tn.x){\n            gN = vec3(0, 1, 0);\n            //dist += tT;\n            pos += rd*tT; \n            hit = 2;\n            break;\n             \n        }       \n   \n        \n        // Advance the cell index position by the indices of the \n        // cell wall normal that you hit. \n        //ip += tn.yz;\n        // Advance the ray position by the distance to the next cell wall.\n        pos += rd*tn.x;\n        \n        // Textures have fixed size, so increasing the scale affects stepping from\n        // one grid cell to the next. Hence, the \"txSc\" variable.\n        ip4 = gridID((ip -  tn.yz*(txSc*s)));\n         \n        gGrid = ip4;\n    }\n    \n    // If we've hit one of the prism sides, return the correct side normal.\n    if(hit==1){\n    \n        tn = t1<t2? vec3(t1, n1) : vec3(t2, n2);\n        if(t3<tn.x) tn = vec3(t3, n3);\n        if(t4<tn.x) tn = vec3(t4, n4);\n        gN = normalize(vec3(tn.y, 0, tn.z));\n        \n    }\n  \n    \n    // Face ID.\n    float fID = tT<t1 && tT<t2 && tT<t3 && tT<t4? 0. : \n    t1<t2 && t1<t3 && t1<t4? 1. : t2<t3 && t2<t4? 2. : t3<t4? 3. : 4.;\n    \n    \n    // Distance.\n    res.x = length(pos - ro);\n    // If we haven't hit anything, set it to the maxium ray distance.\n    if(hit == 0) res.x = FAR;\n    \n    // Return the distance, face ID, and central position based ID.\n    return vec4(res.x, fID, ip);\n    \n}\n\n// Standard normal function.\nvec3 nr(float fID, vec3 rd) {\n\n    return gN;\n/*\n    if(fID==0.) return vec3(0, 1, 0);\n    vec2 n1, n2, n3, n4;\n    n1 = (gV[1] - gV[0]);\n    n2 = (gV[2] - gV[1]);\n    n3 = (gV[3] - gV[2]);\n    n4 = (gV[0] - gV[3]);\n \n    vec2 n = fID == 1.? n1 : n2;\n    if(fID==3.) n = n3;\n    if(fID==4.) n = n4;\n \n    // Tangent to normal conversion.\n    n = n.yx*vec2(1, -1);\n\treturn normalize(vec3(n.x, 0, n.y));*/\n}\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better one than this somewhere. \nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);    \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n\n\n    #if BUFF_ACCUM == 2\n    // Initial hit point and distance.\n    vec3 resPos = vec3(0);\n    #endif\n    float resT = 0.;\n\n    // Screen pixel coordinates.\n    vec2 uv0 = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n\n    // Initializing the seed value. It needs to be different every frame.\n    seed = uv0 + vec2(fract(iTime/113.671)*.123, fract(iTime/57.913)*.14527);\n    \n    // Ray origin.\n    vec3 ro = vec3(iTime*.2, 8., iTime*.2); \n    // Setting the camera to the ray origin. The ray origin vector will change\n    // from bounce to bounce, so we'll need a record of the initial camera position.\n    vec3 cam = ro;\n    \n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    \n    // Lazy identity camera -- No to and from. I might update it later.\n    mat3 mCam = mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n\n \n    mCam *= rot(vec3(0, 0, cos(iTime/8.*.25)/4. + .35)); // Camera yaw.\n    mCam *= rot(vec3(-sin(iTime/4.*.25)/8., 0, 0)); // Camera roll.\n    mCam *= rot(vec3(0, 1, 0)); // Y axis tilt, or pitch.\n    \n     \n    // Artistic black movie strips. 15% faster \"1337\" democoder move. :D\n    if(abs(uv0.y)>.425) { \n        ivec2 q = ivec2(fragCoord);\n        vec4 c = vec4(0, 0, 0, 1); \n    \tif(q.y == 0 && q.x<3){\n    \n    \t// Camera matrix in lower left three pixels, for next frame.\n        if(q.x == 0) c = vec4(mCam[0], -dot(mCam[0], cam));\n        else if(q.x == 1) c = vec4( mCam[1], -dot(mCam[1], cam));\n        else c = vec4( mCam[2], -dot(mCam[2], cam));\n        } \n        fragColor = c;\n        return; \n    }\n \n    \n    // Accumulative color and sample number.  Some computers would be able to \n    // handle more and others less.\n    vec3 atot = vec3(0);\n    const int sampNum = 3;\n    \n    for(int j = min(0, iFrame); j<sampNum; j++){\n    \n    \n        //vec2 jit = vec2(hash21(uv0 + seed + vec2(j, j + 1)), \n        //                hash21(uv0 - seed + vec2(j + 5, j + 7))) - .5;\n        \n        // Jittering for antialiasing.\n        vec2 jit = hash22() - .5;\n                        \n        vec2 uv = uv0 + jit/iResolution.y;\n    \n        // Unit direction vector.\n        vec3 rd = mCam*normalize(vec3(uv, 1./FOV)); \n        \n        /*      \n        // Depth of field. I hacked this in as an afterthought... It seems\n        // about right, but I'll have to take a closer look later.\n        float fDist = 6.;\n        vec2 jitDOF = hash22()*2. - 1.;\n        vec3 vDOF = mCam*vec3(jitDOF, 0.)*.06;\n        rd = normalize(rd - vDOF/fDist);\n        ro = cam + vDOF;\n        */        \n\n        ro = cam;\n        \n        // Accumulative, and thoughput.\n        vec3 acc = vec3(0);\n        \n        // Throughput -- Initialized to one.\n        vec3 through = vec3(1);\n\n        // First hit distance. It's used for fog, amongst other things.\n        float t0; \n        \n  \n        for(int i = min(0, iFrame); i<2; i++){\n\n            // Raycasting\n            vec4 res = raycast(ro, rd);\n\n            // Distance, face ID and central position based ID.\n            float t = res.x;\n            float fID = res.y;\n            vec2 id = res.zw;\n            \n            // Saving the face normal and vertices.\n            vec3 svN = gN;\n            mat4x2 svV = gV; \n            \n           \n            t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.\n\n            if(i == 0) t0 = t; // Recording the first hit distance.\n\n\n            // Hit point.\n            vec3 p = ro + rd*t;\n            \n            if(i==0){\n                #if BUFF_ACCUM == 2\n                // Only save the initial hit point and distance. Ignore other bounces.\n                resPos += p/float(sampNum); // Accumulative position.\n                #endif\n                resT += t/float(sampNum); // Accumulative distance.\n            }\n            \n    \n            // If we've hit an object, light it up.\n            if(t<FAR){\n            \n                \n                // Surface normal.\n                 \n                vec3 n = nr(fID, rd);//normalize(svN);//\n                 \n                // Scene object color.\n\n                vec2 qq = p.xz - id;\n                // Edging routine.\n                float h0 = h(id); // Square prism height.\n\n                \n                 // Local coordinates.\n                vec2 lc = p.xz - id*s;\n                \n                // Texture coordinates.\n                vec2 rp = lc*rot2(atan(n.x, n.z));\n                vec2 tuv = fID == 0.? p.xz : vec2(rp.x, p.y);\n                vec3 tx = texture(iChannel1, tuv/2.).xyz; tx *= tx;\n       \n                vec3 oCol = .125 + tx*2.5;\n                oCol *= vec3(.6, .8, 1.1)/4.;\n            \n                // Edge construction.\n              \n                \n                // Face edges.\n                /////\n                float fEdge = sdQuadBound(qq, svV);\n                fEdge = max(abs(fEdge), -(p.y - h0)) - .02;\n                // Side edges.\n                /////\n                float sEdge = 1e5;\n                for(int j = 0; j<4; j++){\n                    // Current vertex.\n                    vec2 g = svV[j];\n                    float ang = atan(g.y, g.x);\n                    // Polar transform to the corner.\n                    vec2 nP = qq - vec2(cos(ang), sin(ang))*length(g);\n                    // Corner edge.\n                    sEdge = min(sEdge, length(nP) - .02);\n                    \n                    /* \n                    // Corner dots.\n                    vec2 tn0 = normalize(svV[j] - svV[(j + 3)&3]);\n                    vec2 tn1 = normalize(svV[j] - svV[(j + 1)&3]);\n                    nP = qq - svV[j] + (tn0 + tn1)*.11;                    \n                    sEdge = min(sEdge, length(nP) - .035);\n                    */\n                }\n                /////////////\n                \n                \n           \n                // Smoothing facor... Not even sure if it's needed in a multisample\n                // example, but it's here anyway.\n                float sf = .02;//*(1. + res.x*res.x*.05);\n                \n                // Combining the side and face edges, then smoothstepping.\n                fEdge = min(fEdge, sEdge);\n                \n                // Lighter inner edges.\n                oCol = mix(oCol, oCol*3., (1. - smoothstep(0., sf, fEdge - .02)));\n \n                // Surface roughness. Larger values are duller in appearance, and lower\n                // values are more relective.\n                float rough = .9;\n\n                // Substance emissive color. Initialized to zero.\n                vec3 emissive = vec3(0);\n               \n                // Color random prisms and set their emission color. \n                if(hash21(id + .103)<.1){\n                //if(hash21(id + .103)<.2 && abs(p.y - h0 + .4) < .1){ // Strips only.\n                    \n                \n                    // Random emitter color.\n                    vec3 eCol = .5 + .45*cos(6.2831853*hash21(id +.17)/24. + \n                                vec3(0, 1.4, 2) + 1.);\n                  \n                    // Color variations.\n                    // Random alternate hues.\n                    //if(hash21(id + .027)<.25) eCol = mix(eCol, eCol.yzx, .25); \n                    // Height or screen height based color mixing.\n                    //eCol = mix(eCol.xzy, eCol, smoothstep(0., 2., p.y*.7)*.4 + .6);\n                    //eCol = mix(eCol, eCol.zyx, smoothstep(0., 1., uv0.y + .15));\n                    \n                    // Ramping it up.\n                    eCol *= eCol*4.;  \n                    \n                    \n                    // Randomly turn lights on and off for some visual interest.\n                    float blink = smoothstep(-.6, -.4, sin(hash21(id + .2)*6.2831853 + iTime));\n                    \n                    \n                   \n                    // Apply the edges.\n                    vec3 edCol = mix(eCol/32., vec3(0), blink);\n                    //oCol = mix(vec3(gre), oCol, blink);\n                    //oCol = mix(oCol, edCol, (1. - smoothstep(0., sf, fEdge))*.9);\n                    \n                    // Apply the edges.                    \n                    oCol = mix(oCol, edCol, (1. - smoothstep(0., sf, fEdge)));\n                    \n                    // Blinking emissive color -- ramped up to really glow.\n                    emissive = oCol*eCol*mix(1., 0., blink)*48.; // Fiery hues.\n                    \n                    // Make the glowing pylons less rough, and randomize a bit.\n                    rough = mix(.5, rough, blink); //hash21(id + .21)*.5 + .25;\n                    \n                }\n                else {\n                \n                    // Subtly Color the other pylons.\n                    oCol *= .9 + .2*hash21(id + .06);\n                    \n                     // Apply the edges.\n                    oCol = mix(oCol, vec3(0), (1. - smoothstep(0., sf, fEdge)));\n\n                }\n            \n                // Applying the edging to the emission value. You don't have to, \n                // but it looks better. \n                //emissive = mix(emissive, vec3(0), (1. - fEdge)*.5);\n \n                // Tapering emission into the distance.\n                //emissive = mix(emissive, vec4(0), smoothstep(.25, .99, t0/FAR));\n\n                // If an emissive sustance has been hit, use it to light the surface.\n                acc += emissive*through;\n                through *= oCol; // Integrate colors from previous surfaces. \n \n              \n                vec3 ref = reflect(rd, n); // Purely reflected vector.\n                vec3 rrd = cosDir(0., n); // Random half hemisphere vector.\n \n                // Mimicking surface inconsistancies with fuzzy reflections.\n                // Rougher surfaces have a greater chance of random reflecting at any \n                // direction and smoother surfaces are more likely to purely reflect.\n                float rChance = step(0., rough - hash21(uv + vec2(i*277, j*113) + \n                                fract(iTime*.97 + .137)));\n                rd = (mix(ref, rrd, rChance));\n                // Other variations. Not physically correct, but they have their purposes.\n                //float rChance = hash21(uv + vec2(i*277, j*113) + \n                //                  fract(iTime*.97 + .137))*rough;\n                //rd = normalize(ref + rrd*rChance);\n                //rd = normalize(mix(ref, rrd, rough));\n                //rd = normalize(ref + normalize(rnd23() - .5)*rChance);  \n                //rd = normalize(ref + rrd*rough*4.);\n\n                // Bump the ray off of the hit surface to avoid self collision.\n                ro = p + n*.001;\n\n            }\n            else { \n                // If the scene hasn't been hit, add a touch of atmospheric haze, then quit.\n                vec3 aCol = .2 + vec3(.03, .025, .035)*5.;//tx*.2;//vec3(.1);\n                acc += aCol*through/2.;//*.05; \n                \n                break;\n            }\n\n    \n        }\n       \n        // Very simple sky fog, or whatever. Not really the way you apply atmosphere \n        // in a path tracer, but way, way cheaper. :)\n        //vec3 sky = mix(vec3(1, .7, .5), vec3(.4, .6, 1), uv0.y*2.5 - .15);\n        //acc = mix(acc, sky/4., smoothstep(.35, .99, t0/FAR));\n        \n        \n        // Add this sample to the running total.\n        atot += acc;\n        \n    }\n    \n    // Average the samples.\n    vec3 col = atot/float(sampNum);\n    \n    \n    \n    // Toning down the high frequency values. A simple Reinhard toner would \n    // get the job done, but I've dropped in a heavily modified and trimmed \n    // down Uncharted 2 tone mapping formula.\n    col = uTone(col.xyzx).xyz;\n   \n    \n    // This is IQ's temporal reprojection code: It's well written and\n    // it makes sense. I wrote some 2D reprojection code and was not\n    // looking forward to writing the 3D version, and then this \n    // suddenly appeared on Shadertoy. If you're interested in rigid \n    // realtime path traced scenes with slowly moving cameras, this is \n    // much appreciated. :)\n    //\n    #if BUFF_ACCUM == 2\n    //-----------------------------------------------\n\t// Reproject to previous frame and pull history.\n    //-----------------------------------------------\n    \n    float kFocLen = 1./FOV;\n    vec3 pos = resPos;\n    ivec2 q = ivec2(fragCoord);\n    col = clamp(col, 0., 1.);\n\n    // Fetch previous camera matrix from the bottom left three pixels.\n    mat3x4 oldCam = mat3x4(texelFetch(iChannel2, ivec2(0, 0), 0),\n                           texelFetch(iChannel2, ivec2(1, 0), 0),\n                           texelFetch(iChannel2, ivec2(2, 0), 0));\n    // World space point.\n    vec4 wpos = vec4(pos, 1.);\n    // Convert to camera space (note inverse multiply).\n    vec3 cpos = wpos*oldCam;\n    // Convert to NDC space (project).\n    vec2 npos = (kFocLen*2.)*cpos.xy/cpos.z;//*iRes/iResolution.y;\n    // Convert to screen space.\n    vec2 spos = .5 + .5*npos*vec2(iResolution.y/iResolution.x, 1);\n\t// Convert to raster space.\n    vec2 rpos = spos*iResolution.xy;\n\n    // Read color+depth from this point's previous screen location.\n    vec4 ocolt = textureLod( iChannel2, spos, 0.);\n    // If we consider the data contains the history for this point.\n    if(iFrame>0 && resT<FAR && (rpos.y>1.5 ||rpos.x>3.5)){\n    \n        // Blend with history (it's an IIR low pas filter really).\n        col = mix( ocolt.xyz, col, 1./12.);\n    }\n    \n    // Color and depth.\n    fragColor = vec4(col, resT);\n    \n    // Output.\n\tif(q.y == 0 && q.x<3){\n    \n    \t// Camera matrix in lower left three pixels, for next frame.\n        if(q.x == 0) fragColor = vec4(mCam[0], -dot(mCam[0], cam));\n        else if(q.x == 1) fragColor = vec4( mCam[1], -dot(mCam[1], cam));\n        else fragColor = vec4( mCam[2], -dot(mCam[2], cam));\n    } \n    #elif BUFF_ACCUM == 1\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    #else\n    // No reprojection or temporal blur, for comparisson.\n    fragColor = vec4(clamp(col, 0., 1.), 1);\n    #endif\n    \n\n    \n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// The irregular quad pattern.\n\nvec4 gVal; // Storage for the cell contents.\n//vec2 gSID; // Static ID.\n\n\n\n// The asymmetric quad grid. \nvec4 pattern(vec2 p, vec2 sc){    \n    // Distance and edge width.\n    \n    float d = 1e5;\n    \n     \n    // Centers for all four tiles.\n    const mat4x2 cntr = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5)); \n    \n    // Because the asymmetric boundaries of the quads overlap neighboring cells, \n    // neighbors need to be considered. In this case four cell renders will do.\n    //const int n = 2;\n    //const float m = floor(float(n)/2. + .001) - .5;\n    for(int i = 0; i<4; i++){\n\n        // Local coordinates and ID.\n        vec2 q = p.xy;\n        vec2 iq = floor(q/sc - cntr[i]) + .5; \n        q -= (iq)*sc;\n        \n        // The four vertices for this cell.\n        mat4x2 v = cntr;\n        \n        // Offset vertices.\n        mat4x2 sv = mat4x2(hash22T(iq + v[0]), hash22T(iq + v[1]), \n                           hash22T(iq + v[2]), hash22T(iq + v[3]));\n        \n        // Offset the vertices.\n        v += (sv/float(ni)*2. - 1.)*.25;\n\n        // Scale.\n        v[0] *= sc; v[1] *= sc; v[2] *= sc; v[3] *= sc;        \n        \n\n        // Quad boundary normals.\n        mat4x2 e = v - mat4x2(v[1], v[2], v[3], v[0]);\n        e[0] = normalize(e[0]).yx*vec2(1, -1);\n        e[1] = normalize(e[1]).yx*vec2(1, -1);\n        e[2] = normalize(e[2]).yx*vec2(1, -1);\n        e[3] = normalize(e[3]).yx*vec2(1, -1);\n        \n        // Quad distance.\n        float d2 = dot(q - v[0], e[0]);\n        d2 = max(d2, dot(q - v[1], e[1]));\n        d2 = max(d2, dot(q - v[2], e[2]));\n        d2 = max(d2, dot(q - v[3], e[3]));\n  \n        // If this quad distance is nearer, update.\n        if(d2<d){\n            \n            // New distance, static ID and moving ID.\n            // The zero field is an unused height value holder.\n            d = d2;\n            //gSID = iq + (v[0] + v[1] + v[2] + v[3])/4./s;\n            \n            // Storing the four quad vertices into the final two channels.\n            vec2 gQV;\n            gQV.x = DecodeFloatRGBA(vec4(sv[0], sv[1]));\n            gQV.y = DecodeFloatRGBA(vec4(sv[2], sv[3]));\n            \n            // Saving the central coordinates and four vertices of the nearest quad. \n            // \"sc\" needs to be there for wrapping purposes.\n            gVal = vec4(iq*sc, gQV);\n        }\n    \n    }\n    \n    \n    // Combining the floor with the extruded object.\n    return  gVal;\n \n}\n\n\n\nvec4 funcFace0(vec3 q3){\n\n    // Cube map face pattern.\n    return pattern(q3.xy, s);\n}\n\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    \n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n    \n    // We're only using one cube map face, so don't calculate any others...\n    // or give the annoying compiler a chance to calculate others.\n    if(faceID > 0) return;\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n  \n  \n    // Pixel storage.\n    vec4 col = vec4(0);\n    \n    \n    \n    // Precalculation flag: GPUs are annoying. Sometimes, they'll will calculate\n    // both the \"if\" and \"else\" statements every time. The \"if\" part here is extremely\n    // expensive, so we don't want that. The solution is to not have an \"if-else\"\n    // statement at all.\n    int preCalc = 0;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's \n    // something I never would have considered. :)\n    if(textureSize(iChannel0, 0).x<2 || iFrame<maxFrames){\n        \n        //if(iFrame>=maxFrames) return;        \n        \n        // Fill the first cube face with a custom function.\n        if(faceID==0){\n            \n            //vec3 p = convert2DTo3D(uv);      \n            vec3 p = vec3(uv, 0);      \n            \n            col = funcFace0(p);\n            \n            preCalc = 1;\n           \n        }\n        \n    }\n    \n    // If precalculation has already occurred, read in the texture.\n    if(preCalc == 0) col = tx0(iChannel0, uv);\n    \n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 663, 698, 698, 1887], [1890, 1890, 1944, 1966, 2416]], "test": "untested"}
{"id": "DslfRs", "name": "First Shader:SDF Circle and Rect", "author": "justgoscha", "description": "CLICK to display rectangle and change size\n\nFirst try at creating a shader and learning some GLSL, followed tutorials from IQ, and tried to understand the code from: https://www.shadertoy.com/view/XsyGRW", "tags": ["interactive", "sdf", "circle", "rectangle"], "likes": 1, "viewed": 163, "published": 3, "date": "1689078858", "time_retrieved": "2024-07-30T17:45:15.091060", "image_code": "float shape_circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat shape_rect(vec2 p) {\n    // Size of the rectangle can be set with mouse click\n    float rx = .32 * 2.0 * iMouse.y/iResolution.xy.y;\n    float ry = .18 * 2.0 * iMouse.x/iResolution.xy.x;\n\n    return length(max(abs(p)-vec2(rx, ry),vec2(0,0)));\n}\n\n// Normalizes the coordinates to the screen resolution\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = squareFrame(iResolution.xy, fragCoord);\n    \n    float distance;\n\n    \n    //distance = max(shape_circle(uv, 0.2),0.0);\n    distance = max(shape_rect(uv),0.0);\n    \n    if (distance > 0.0) {\n        // Time varying pixel color... \n        // just to make the background less boring\n        vec3 col = vec3(\n            distance/3.0 - sin(0.5*iTime)/2.0,\n            distance/2.0 + sin(1.1*iTime-3.14159/5.0)/2.0,\n            0.5 + distance/2.0 + cos(iTime+3.14159/3.0)/2.0\n        );\n\n        // Output to screen\n        fragColor.rgb = col;\n        fragColor.a = 1.0;\n    } else {\n        vec3 col = vec3(1,1,1);\n\n        // Output to screen\n        fragColor.rgb = col;\n        fragColor.a = 1.0;\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 73], [75, 75, 101, 158, 324], [326, 381, 428, 428, 552], [554, 554, 611, 661, 1383]], "test": "untested"}
{"id": "mdfBzs", "name": "Tuesday infinite zoom", "author": "mrange", "description": "CC0: Tuesday infinite zoom\n  Inspired by some twitter art (can't find it again) I wanted to try it\n", "tags": ["zoom"], "likes": 39, "viewed": 503, "published": 3, "date": "1689067982", "time_retrieved": "2024-07-30T17:45:15.861998", "image_code": "// CC0: Tuesday infinite zoom\n//  Inspired by some twitter art (can't find it again) I wanted to try it\n\nconst float rep  = 7.0;\nconst float per  = 16.0;\nconst float zoom = log2(1.2);\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define REV(x)      exp2((x)*zoom)\n#define FWD(x)      (log2(x)/zoom)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SCA(a)      vec2(sin(a), cos(a))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  vec2 op = p;\n  p *= ROT(0.05*TIME);\n\n  vec2 zp = p;\n  float tm = TIME+14.0*TAU;\n  float ctm = floor(tm);\n  float ftm = fract(tm);\n  float z = REV(ftm);\n  zp /= z;\n  float np = modPolar(zp, rep);\n  float x = zp.x;\n  float n = floor(FWD(abs(x)));\n  float x0 = REV(n);\n  float x1 = REV(n+1.0);\n  n -= ctm;\n\n  float m = (x0+x1)*0.5;\n  float w = x1-x0;\n\n\n  float aa = 4.0/RESOLUTION.y;\n\n  float dz = abs(zp.x-m) - w*0.45;\n  dz *= z;\n  \n  vec2 ap = p;\n  vec2 cp0 = p;\n  vec2 cp1 = p;\n  float ltm = TIME+TAU*14.0;\n  float mp = mod(n, 2.0*per)/per;\n  mp = mix(mp, 2.0-mp, step(1.0, mp));\n  float ntm = ltm*(mp-0.55);\n  ap *= ROT(ntm);\n  ap.y = abs(ap.y);\n  const float a = PI*0.75;\n  const vec2 sca = SCA(a);\n  float da = dot(ap,sca);\n  float a0 = PI-a+ntm;\n  float a1 = PI+a+ntm;\n  cp0 *= ROT(a0);\n  mod1(a0, TAU/rep);\n  cp0 -= vec2(z*m/cos(a0),0.0);\n  cp1 *= ROT(a1); \n  mod1(a1, TAU/rep);\n  cp1 -= vec2(z*m/cos(a1),0.0);\n  float dc0 = length(cp0)-w*0.49*z;\n  float dc1 = length(cp1)-w*0.49*z;\n  float dc = min(dc0, dc1);\n  \n  float d = max(da, dz);\n\n  vec3 col = vec3(0.0);\n  vec3 ccol = (0.5)*(1.0+cos(1.5*vec3(0., 1.0, 2.0)+(n)+PI*op.x*op.y));\n  vec3 ccol0 = ccol+max(-3.0*dz, 0.0);\n  vec3 ccol1 = ccol0*ccol0*0.075;\n  vec3 ccol2 = ccol+max(2.0*sqrt(max(-dc, 0.0)), 0.0);\n  ccol2 = sqrt(ccol2);\n\n  col = mix(col, ccol1, smoothstep(0.0, -aa, dz));\n  col = mix(col, ccol0, smoothstep(0.0, -aa, d));\n  col = mix(col, ccol2, smoothstep(0.0, -aa, dc));\n  col *= smoothstep(0.025, 0.075, length(op));\n  col *= smoothstep(1.5, 0.75, length(pp));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[475, 561, 610, 610, 1009], [1011, 1097, 1136, 1136, 1261], [1263, 1263, 1293, 1293, 2866], [2868, 2868, 2923, 2923, 3095]], "test": "untested"}
{"id": "mdfBzl", "name": "waves test", "author": "tianluo970922", "description": "waves test", "tags": ["wavestest"], "likes": 0, "viewed": 93, "published": 3, "date": "1689061520", "time_retrieved": "2024-07-30T17:45:16.625956", "image_code": "\n// Redefine below to see the tiling...\n//#define SHOW_TILING\nconst vec2 target_resolution = vec2(940, 86);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5 + 23.0;\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5; \n    \n\tfloat inten = .009;\n    \n    float timeCtrl = smoothstep(0.0, 1.0, pow(iTime * 0.1, 1.0));\n  \n    //WhiteEdge\n    vec3 whiteEdge = vec3(1.000,1.000,1.000); \n\n    float whiteEdgeStart = -0.1;\n    float whiteEdgeEnd = 1.0;\n    float whiteEdgeMask = mix(whiteEdgeStart, whiteEdgeEnd, timeCtrl);\n    \n    float whiteRangeStart = 0.2;\n    float whiteRangeEnd = 1.0;\n    float whiteRangeMask = mix(whiteRangeStart, whiteRangeEnd, timeCtrl);\n    \n    float whiteOpacityStart = 0.2;\n    float whiteOpacityEnd = 0.6;\n    float whiteOpacityMask = mix(whiteOpacityStart, whiteOpacityEnd, timeCtrl);\n    \n    float whiteMask = cubicPulse(whiteEdgeMask, whiteRangeMask, uv.y);\n    \n\n    float scale = 3.0; \n    float timetest =sin((iTime * 1.0/scale - 0.25) * 3.1415926 * 4.0/2.0) * 0.5 + 0.5;\n    float offset = uv.y - iTime;\n    float y = mod(offset, scale);\n    \n    float d = smoothstep(0.2 * scale, -0.0  * scale, y) * 1.0;\n    float d1 = smoothstep(0.6  * scale, 1.0  * scale, y) * 1.0;\n    vec3 maskColor =  vec3(d) + vec3(d1);\n    maskColor *= timetest;\n    //maskColor *= sin(iTime * scale - 3.14/2.0) * 0.5 + 0.5;\n    \n    fragColor = vec4(maskColor,1.0);\n    \n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 201, 201, 295], [297, 297, 355, 355, 2130]], "test": "untested"}
{"id": "msXfRl", "name": "Matrix（黑客帝国）", "author": "Ride_A_Pig", "description": "My second shader.", "tags": ["matrix", "words"], "likes": 29, "viewed": 577, "published": 3, "date": "1689059736", "time_retrieved": "2024-07-30T17:45:17.388916", "image_code": "const float fontSize = 16.; //Control the size of fonts.\nconst float wordSpeed = .002; //Control the change speed of words\nconst float flowSpeed = .15; //Control the flow speed\n\nfloat words(vec2 fragCoord){\n    vec2 UV = mod(fragCoord, fontSize) / (fontSize * 16.);\n    vec2 noise = floor(fract(texture(iChannel1, fragCoord / (fontSize * 16.) - UV + iTime * wordSpeed).xy) * 16.) / 16.;\n    return texture(iChannel0, UV + noise).x; \n}\n\nvec3 flow(vec2 fragCoord){\n    vec2 uv = fragCoord - mod(fragCoord, fontSize);\n    float offset = cos(uv.x * 1.14 + 5.14) + 1.919810;\n    float y = fract(fragCoord.y/iResolution.y + offset * 3.14 + iTime * offset * flowSpeed);\n    return vec3(.2,1.,.2) / (y * 12.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(words(fragCoord) * flow(fragCoord), 1.);  \n\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 206, 206, 434], [436, 436, 462, 462, 703], [705, 705, 761, 761, 828]], "test": "untested"}
{"id": "DdffzB", "name": "Parabolic Reflectors", "author": "fenix", "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n\nDemonstration of the concept of a pair of parabolic reflectors. These might be a pair of satellite dishes pointed towards each other.\n\n* mouse: emit wave\n* space: reset", "tags": ["2d", "reflection", "wave", "simulation", "parabolic", "reflector"], "likes": 30, "viewed": 354, "published": 3, "date": "1689048256", "time_retrieved": "2024-07-30T17:45:18.296489", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  Demonstration of the concept of a pair of parabolic reflectors. These might be a\n//  pair of satellite dishes pointed towards each other.\n//  \n//  Waves are emitted at the focal point of the left reflector, and form a non-dispersing\n//  linear wavefront that travels from left to right. The coherence of this beam allows\n//  a signal to be transmitted great distances.\n//\n//  Notice how the higher-energy colors, yellow and especially reds, only appear briefly\n//  when first emanating from the left. After bouncing off the reflector (or not), while\n//  travelling across the screen, the wave is mostly blue and green. Only after it\n//  bounces off the far reflector and the wave converes into the opposite focal point do\n//  the yellows and reds appear again. This would allow a detector placed at the right\n//  focal point to recieve a signal transmitted from the left focal point.\n//\n//  The exterior boundaries are supposed to be absorbing, and they do a decent job, but\n//  there is still a small reflection. If anyone knows what I have wrong I would be very\n//  grateful for advice. Fighting with BOUND_GAMMA and the absorbing walls was the biggest\n//  challenge in making this shader, other than making sure it works comparably in multiple\n//  resolutions.\n//\n//  Click the mouse to emit a circular wave. Suggested experiments: You can emit a wave\n//  from the right focal point to transmit a coherent wave back to the left. Also, what\n//  happens if you emit a wave near, but not on a focal poiint, for example slightly\n//  above, below, or to the left or right. Space to reset once it gets too busy.\n//\n//  If it's going too fast, I noticed you can easily slow it down to x.25 by just setting\n//  Buffer A's iChannel0 to Buffer A to defeat the A->B->C->D->A loop.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    // get wave height\n    O = texelFetch(iChannel0, ivec2(u), 0);\n    O = sin(O.x * 500. * vec4(2, 4, 6, 0)); // colorize\n    O *= O;\n    \n    vec2 R = iResolution.xy, p = (u - .5 * R) / R.y;\n    \n    // draw parabolas\n    O = mix(O, vec4(1), smoothstep(3. / R.y + .003, .003, abs(map(p) + .003)));\n    \n    // draw foci\n    O = mix(O, vec4(1), .3 * smoothstep(.01 + 3. / R.y, .01, distance(p, vec2(FOCUS_DIST, 0))));\n    O = mix(O, vec4(1), .3 * smoothstep(.01 + 3. / R.y, .01, distance(p, vec2(-FOCUS_DIST, 0))));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, true); // true for last parameter => update state, emit waves\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define U(u) texelFetch(prevBuffer, ivec2(u), 0) //\nconst float FOCUS_DIST = .45;\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdParabola( in vec2 pos, in float k )\n{\n    if (pos.x == 0.) pos.x = .01; // fix for horizontal line (bug?)\n    pos.x = abs(pos.x);\n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat map(vec2 p)\n{\n    p.x = -abs(p.x);\n\n    float d = -sdParabola(p.yx + vec2(.0, .7), 1.);\n    d = max(d, abs(p.y) - .3);\n    return d;\n}\n\n#define keyClick(ascii)   ( texelFetch(keyBuffer,ivec2(ascii,1),0).x > 0.)\n\n#define KEY_SPACE 32\n\nconst float BOUND_GAMMA = .01; // damping factor for boundary\n\nfloat initWave(vec2 u, vec2 c, vec2 R)\n{\n    vec2 delta = u - c;\n    float d2 = dot(delta, delta);\n\n    return 1e-6 * R.x * cos(sqrt(d2 * .0001)) / (1. + d2 * .2);\n}\n\nvoid updateBuffer(out vec4 O, vec2 u, vec2 R, int iFrame, vec4 iMouse, sampler2D prevBuffer, sampler2D keyBuffer, bool addWaves)\n{\n    vec2 o = vec2(1, 0),\n         p = (u - .5 * R) / R.y;\n\n    vec4 state = texelFetch(prevBuffer, ivec2(0), 0);\n    \n    // handle persistent state\n    if (ivec2(u) == ivec2(0))\n    {\n        if (iFrame == 0 ||\n            state.w != R.x * R.y ||\n            keyClick(KEY_SPACE))\n        {\n            O = vec4(0);\n            O.w = R.x * R.y;\n            return;\n        }\n        \n        O = state;\n        \n        // timing is relative to horizontal dimension, to allow first bounce to complete before next wave encroaches\n        if (addWaves && ++O.z > R.y / 1.5)\n            O.z = 0.;\n        \n        return;\n    }\n    \n    if (iFrame == 0 ||\n        state.w != R.x * R.y ||\n        keyClick(KEY_SPACE))\n    {\n        // init\n        O = vec4(0);\n        return;\n    }\n    else\n    {\n        const float C = .5; // Courant\n\n        O = U(u).xxyy; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n\n        if (int(u.y) < 5)\n            O.x = O.x - C * (O.x - U(u + o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing bottom boundary\n        else if (int(u.y) == int(R.y) - 1)\n            O.x = O.x - C * (O.x - U(u - o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing top boundary\n        else if (int(u.x) == 0)\n            O.x = O.x - C * (O - U(u + o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing left boundary\n        else if (int(u.x) == int(R.x) - 1)\n            O.x = O.x - C * (O - U(u - o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing right boundary\n        else\n            O.x = -O.z + 2.*O.x + C*(U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx) - 4. * O).x; // apply wave equation\n    }\n\n    if (addWaves)\n    {\n        // add disturbance at left focal point\n        if (state.z < 1. || iFrame == 0)\n            O.y += initWave(u, vec2(-FOCUS_DIST, 0) * R.y + .5 * R.xy, R);\n\n        // add disturbance for mouse click\n        if (iMouse.z > 0. && iMouse.w > 0.)\n            O.y += initWave(u, iMouse.xy, R);\n    }\n\n    // parabola boundary (reflecting)\n    if (map(p) < 0.) O = vec4(0);\n}\n", "buffer_b_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdffzB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2184, 2184, 2222, 2245, 2741]], "test": "untested"}
{"id": "mdlfRX", "name": "weird fluid?", "author": "Elyades", "description": "recursive function application, blending", "tags": ["weirdcolors"], "likes": 0, "viewed": 148, "published": 3, "date": "1689021034", "time_retrieved": "2024-07-30T17:45:19.109316", "image_code": "vec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(0.5,0.5,0.5);\n    vec3 d = vec3(0.1,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*2.0;\n    \n    vec2 dummyuv = uv;\n    float weight = 1.0 - sin(iTime/3.0);\n    int currentIndex = int(iTime/3.0);\n    \n    \n    \n    for (int i = 0; i < currentIndex; i++){uv.x += cos(uv.y*4.0 + uv.x*5.0); uv.y += sin(uv.y*4.0- uv.x/5.0);}\n    dummyuv = uv; dummyuv.x += cos(dummyuv.y*4.0 + dummyuv.x*5.0); dummyuv.y += sin(dummyuv.y*4.0- dummyuv.x/5.0);\n    vec3 color = vec3(0.0);\n    \n    uv = weight*uv + (1.0-weight)*dummyuv;\n    \n    float d = length(uv - vec2(uv.y,uv.x));\n    color += smoothstep(0.03,0.02,d);\n    color.rg = exp(uv);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdlfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 48, 234], [236, 236, 293, 293, 940]], "test": "untested"}
{"id": "mssBRX", "name": "Recursive appearance", "author": "Elyades", "description": "Blending between f^n(uv) and f^(n+1)(uv), n+=1 every \"period\" seconds.", "tags": ["recursivegrid"], "likes": 2, "viewed": 119, "published": 3, "date": "1689019961", "time_retrieved": "2024-07-30T17:45:19.962036", "image_code": "vec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.4);\n    vec3 c = vec3(0.5,0.4,0.6);\n    vec3 d = vec3(0.5,iTime*1.5,0.5);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.6,0.5);\n    vec3 b = vec3(0.5,0.4,0.25+0.25*cos(iTime*3.0));\n    vec3 c = vec3(1.0,0.3+0.2*sin(iTime),1.2);\n    vec3 d = vec3(0.5+0.5*cos(iTime/3.0)*1.0,0.1,0.8);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*50.0;\n    vec3 color = vec3(0.0);\n    \n    float period = 2.0;\n    int currentIndex = int(iTime/period);\n    \n    float dummy;\n    for (int i = 0; i <= currentIndex; i++)\n    {\n        dummy = uv.x;\n        uv.x = uv.y;\n        uv.y = -dummy;\n    }\n    vec2 nextuv1;\n    nextuv1 = tan(-uv);\n    \n    vec2 nextuv2;\n    nextuv2.x = uv.y;\n    nextuv2.y = -uv.x;\n    \n    vec2 nextuv = 0.4*nextuv1 + 0.6*nextuv2;\n    \n    float weight = pow(sin(iTime/(period*(1.5+0.3*sin(3.14*iTime/5.0)))),2.0);\n    uv = (1.0-weight)*uv + weight*nextuv;\n    \n    \n    color += palette1(length(uv))/2.0;\n    color.rg += abs(cos(uv))/3.0;\n    color.b += palette2(cos(iTime/(period*5.0))).z;\n    \n    \n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 48, 240], [242, 242, 268, 290, 535], [537, 537, 594, 645, 1417]], "test": "untested"}
{"id": "mslfWr", "name": "mjal - ray marching", "author": "mlalisse", "description": "ray marching test", "tags": ["mjal"], "likes": 1, "viewed": 213, "published": 3, "date": "1689019575", "time_retrieved": "2024-07-30T17:45:20.910500", "image_code": "#define sat(a) clamp(a, 0., 1.)\n\n#define EPSILON    0.0001\n#define SPHERE_POS    vec3(.0, .0, 0.)\n#define SPHERE_RADIUS 1.\n#define SPHERE_COLOR  vec3(1., 0.0, 0.0)\n#define LIGHT_POS vec3(5.0, -7.0, 3.0)\n\nvec3  eye = vec3(.0, .0, -7.);\n\nfloat map( vec3 pos ) {\n    return max(\n        sdBox(pos, vec3(1.0, 1.0, 0.5)),\n        sdSphere(pos, 1.0)\n    );\n}\n\nvec3 gradiant( vec3 pos ) {\n    vec3 offset = vec3(EPSILON, 0.0, 0.0);\n    return normalize(vec3(\n        map(pos - offset.xyy) - map(pos + offset.xyy),\n        map(pos - offset.yxy) - map(pos + offset.yxy),\n        map(pos - offset.yyx) - map(pos + offset.yyx)\n    ));\n}\n\nvec3 lighting( vec3 pos ) {\n    vec3 normal = gradiant(pos);\n    vec3 dir = normalize(LIGHT_POS - pos);\n    return sat(dot(normal, dir) * SPHERE_COLOR);\n}\n\nvec3 rayMarching( vec3 pos, vec3 dir ) {\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        pos += dir * dist;\n        dist = map(pos);\n        if (dist < EPSILON) {\n            break;\n        }\n    }\n\n    if (dist < EPSILON) {\n        return lighting(pos) + vec3(.1,.0,.0);\n    } else {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv  = (fragCoord - 0.5 * iResolution.xy) / iResolution.xx;\n    vec3 dir = normalize(vec3(uv, 1.0));\n\n    fragColor = vec4(rayMarching(rotateY(eye, iTime), rotateY(dir, iTime)), 1.0);\n}", "image_inputs": [], "common_code": "// 3D Transformations\n\nmat4 matRotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c,  0., s,  0.),\n        vec4(0., 1., 0., 0.),\n        vec4(-s, 0., c,  0.),\n        vec4(0., 0., 0., 1.)\n    );\n}\n\nvec3 rotateY( vec3 p, float t ) {\n    return (matRotateY(t) * vec4(p, 1.0)).xyz;\n}\n\n// Signed Distance Functions\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 259, 259, 352], [354, 354, 381, 381, 625], [627, 627, 654, 654, 781], [783, 783, 823, 823, 1129], [1131, 1131, 1188, 1188, 1382]], "test": "untested"}
{"id": "msfBR2", "name": "Satured blinking", "author": "Elyades", "description": "zooming out, periodic blinking ", "tags": ["periodic"], "likes": 3, "viewed": 135, "published": 3, "date": "1689015387", "time_retrieved": "2024-07-30T17:45:21.783167", "image_code": "vec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(0.5,0.5,0.5);\n    vec3 d = vec3(0.1,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.6,0.5);\n    vec3 b = vec3(0.5,0.4,0.25+0.25*cos(iTime*3.0));\n    vec3 c = vec3(1.0,0.3+0.2*sin(iTime),1.2);\n    vec3 d = vec3(0.5+0.5*cos(iTime/3.0)*1.0,0.1,0.8);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scaling = max(1.0,iTime/3.0);\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*scaling;\n    vec3 color1 = palette1(6.28*length(uv)/scaling + iTime);\n\n    uv = exp(-abs(uv)/scaling)*cos(uv);\n    vec3 color2 = palette2(6.28*length(uv+iTime/20.0)/scaling);\n    \n    \n    uv = atan(uv);\n    vec3 color3 = palette1(length(exp(uv*(0.5+0.5*cos(iTime*uv.x))+uv.y*uv.x/iTime)));\n    \n    uv = tan(iTime+exp(-uv));\n    \n\n    vec3 finalColor = vec3(0.0);\n    float weight1 = 0.3 +0.2*cos(iTime*uv.x*uv.y);\n    float weight2 = 0.2 + 0.3*sin(iTime*uv.y/1.0); \n    finalColor += weight1*color1 + weight2*color2 + (1.0-weight1-weight2)*color3;\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfBR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 48, 234], [236, 236, 262, 284, 529], [532, 532, 589, 639, 1340]], "test": "untested"}
{"id": "DdXBD7", "name": "Year of Truchets #048", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! \n\nI'm moving, my life is in a lot of boxes for the next week - will be aching to code by this weekend!\n", "tags": ["3d", "raymarching", "truchet", "pattern", "maze", "tiles"], "likes": 20, "viewed": 354, "published": 3, "date": "1689012179", "time_retrieved": "2024-07-30T17:45:22.650847", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #048\n    07/10/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    75.\n\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){return fract(sin(dot(a,vec2(27.609,57.583)))*4376.545);}\n//@iq ALL THE SDFS\nfloat box(vec3 p, vec3 b){vec3 d=abs(p)-b;return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),.0);}\nfloat box(vec2 p, vec2 b){vec2 d=abs(p)-b;return length(max(d,0.))+min(max(d.x,d.y),.0);}\n\n//globals s = saved / g = global\nvec3 s_hit,g_hit;\nvec2 s_id,g_id;\nfloat travelspeed = 0.;\n\n//scales for all things\nconst float scale = 1./.245;\nconst float scale_h = scale*.5;\nconst vec2 s = vec2(scale)*2.;\nconst float bscale = scale*.46;\nconst vec2 pos = vec2(.5,-.5);\nconst vec2[4] ps4 = vec2[4](pos.yx,pos.xx,pos.xy,pos.yy);\n\n// 4 tap technique @Shane\nvec2 map(vec3 q3){\n    vec2 res = vec2(1e5,0.);\n\n    q3.xz += vec2(travelspeed,-travelspeed);\n    \n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    float t=1e5;\n\n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2. -  ps4[0]/2.;\n        p = q3.xz - ct*s;\n        ip = floor(p/s) + .5;\n        p -= (ip)*s;\n        vec2 idi = (ip + ct)*s;\n\n        float px = sin(idi.x*.873)*.275;\n        float py = cos(idi.y*.9325)*.265;\n        float ah = -floor((px+py)*scale)*scale;\n        float hs = hash21(idi)*2.;\n        ah+=.2*sin(T*hs);\n        vec3 q = vec3(p.x,q3.y+9.-ah,p.y);\n\n        // just a box\n        float b = box(q,vec3(bscale))-.125;\n        if(b<t) {\n            t = b;\n            s_id = idi+float(i)+hs;\n            s_hit = q;\n        }\n  \n    }\n    \n\tif(t<res.x) res = vec2(t,2.);\n\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++) {\n        p = ro + rd * d;\n        vec2 t = map(p);\n        if( t.x<d*MIN_DIST) hit = true;\n        d += i<32? t.x*.25:t.x*.75;\n        m  = t.y;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 getFace(int face, vec3 p, inout vec3 mask) {\n\n    vec3 color = vec3(.5);\n    float px = 10./R.x;\n    vec2 uv = fract(p.xy/scale_h)-.5;\n    vec2 id = floor(p.xy/scale_h);\n    \n    float rnd = hash21(id+g_id.x+id.y);\n    float hsh = fract(rnd*47.31);\n    if(rnd>.5) uv.x*=-1.;\n    \n    vec2 gx = length(uv-.5)<length(uv+.5)? vec2(uv-.5):vec2(uv+.5);\n\n    float cc = length(gx)-.5;\n    if(hsh>.85) cc = min(length(uv.x),length(uv.y));\n    cc=abs(cc)-.125;\n\n    mask=vec3(cc,0,1);\n    color = mix(color, vec3(.15),smoothstep(px,-px,cc));\n\n    return vec3(1.-color);\n}\n\n// based on bmp mapping from @Passion\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( vec3 p, vec3 n, float bf, float per, int face, inout vec3 mask){\n    vec2 e = vec2(per*MIN_DIST, 0);  \n    mat3 m = mat3( \n        getFace(face, p - e.xyy,mask), \n        getFace(face, p - e.yxy,mask), \n        getFace(face, p - e.yyx,mask)\n    );\n    vec3 g = vec3(.299,.587,.114) * m; \n    g = (g-dot(getFace(face, p,mask),vec3(.299,.587,.114)))/e.x; \n    g -= n*dot(n,g);  \n    return normalize(n+g*bf);\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    bool hit = false;\n\n    vec2 ray = marcher(ro,rd,p,hit,95);\n    d = ray.x;\n    m = ray.y;\n    g_hit = s_hit;\n    g_id = s_id;\n    \n    if(hit)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-8.,11,8.);\n        vec3 l = normalize(lpos);\n \n        vec3 h = vec3(.45);\n        \n        vec3 hp = g_hit;\n        vec3 tn = n;\n        \n        vec3 cuv;\n        int face;\n        \n        if(m==2.){\n            tn = n;\n            //@Shane https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n\n            // set coords\n            if(face==0) cuv = hp.yzx;\n            if(face==1) cuv = hp.zxy;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.xzy;\n            if(face==5) cuv = hp.yzx;\n\n            // get bump map surface\n            vec3 mask = vec3(0);\n\n            n=doBumpMap(cuv,n,.5,d,face,mask);\n         \n            vec3 tx1 = vec3(.667,.286,.031);\n            vec3 tx2 = texture(iChannel0,cuv.xy*.5).rgb;\n        \n            mask.x=smoothstep(.011,.01,mask.x);\n            \n            h=mix(h,tx1*tx2,mask.z);\n            h=mix(h,tx2,mask.x);\n\n            ref =min(mask.x,mask.z)<.5? h:vec3(.0001);\n        }\n        \n        float diff = clamp(dot(n,l),.1,1.);\n        float shdw = 1.;\n\n        for( float t=.01; t < 16.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h*.4;\n            if( shdw<MIN_DIST ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.65);\n        \n        float spec = .65 * pow(max(dot(normalize(p-ro),reflect(l,n)),.2),24.);\n\n        RC = (h*diff) + min(spec,shdw);\n\n        ro = p+n*.05;\n        rd = reflect(rd,n);\n\n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nconst vec3 FC = vec3(0.059,0.090,0.102);\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    travelspeed=T*.5;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,16);\n    vec3 rd = normalize(vec3(uv, -1.));\n\n    // mouse //\n    float x = M.xy==vec2(0)||M.z<0. ? .07+.02*sin(T*.1) : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0)||M.z<0. ? 0. : -(M.x/R.x*2.-1.)*PI;\n    \n    mat2 rx =rot(-.68+x),ry =rot(.58+y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0),RC=vec3(0),ref=vec3(0),fill=vec3(1),p = ro;\n    float d = 0., fA = 0.;\n    \n    // reflection loop + stop unroll\n    for(int i = 0; i < 2 + min(iFrame, 0); i++){\n        RC = render(ro,rd,ref,2-i,d);\n        C = mix(C,clamp(C+RC,vec3(0),vec3(1)),fill);\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    // fog dusting\n    C = mix(C,FC, 1.-exp(-.000025*fA*fA*fA));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXBD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[407, 407, 426, 426, 469], [470, 470, 491, 491, 547], [548, 567, 593, 593, 665], [666, 666, 692, 692, 755], [1087, 1113, 1131, 1131, 1949], [1951, 1951, 2024, 2024, 2297], [2299, 2299, 2348, 2348, 2867], [2869, 2948, 3028, 3028, 3372], [3374, 3374, 3404, 3404, 3643], [3645, 3645, 3728, 3728, 5807], [5850, 5850, 5891, 5891, 6732]], "test": "untested"}
{"id": "cssfRX", "name": "RayMarching-test", "author": "ProCeeDor", "description": "simple ray marching tutorial ", "tags": ["raymarching"], "likes": 0, "viewed": 103, "published": 3, "date": "1689003436", "time_retrieved": "2024-07-30T17:45:23.487610", "image_code": "// https://blog.csdn.net/weixin_28710515/article/details/89533138\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPISILON = 1e-4;\n\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint)-1.0;\n}\nfloat sceneSDF(vec3 samplePoint){\n    return sphereSDF(samplePoint);\n}\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n    float depth = start;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        float dist = sceneSDF(eye + marchingDirection*depth);\n        if(dist < EPISILON) return depth;\n        depth += dist;\n        if(depth >= end) return depth;\n    }\n    return depth;\n}\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord){\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(ro, rd, MIN_DIST, MAX_DIST);\n\n    if(dist > MAX_DIST - EPISILON){\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    // Output to screen\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 224, 224, 262], [263, 263, 296, 296, 333], [334, 334, 424, 424, 684], [685, 685, 741, 741, 865], [866, 866, 923, 923, 1261]], "test": "untested"}
{"id": "msXBzX", "name": "paleta simple", "author": "nictemeral", "description": "paleta simple", "tags": ["paleta"], "likes": 3, "viewed": 157, "published": 3, "date": "1688994019", "time_retrieved": "2024-07-30T17:45:24.275503", "image_code": "#define PI 3.145\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //http://dev.thi.ng/gradients/\n    float zoom = 10.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 fases =vec3(0.929,0.737,0.208)*uv.x*zoom*PI;\n    vec3 off =vec3(0.329,0.329,0.329);\n    vec3 amp =vec3(0.961,0.749,0.380);\n    vec3 vel =vec3(0.969,0.314,-0.596)* iTime *1.;\n    \n    vec3 pal = sin(vel+fases)*amp+off;\n\n    // Output to screen\n    fragColor = vec4(pal,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 109, 457]], "test": "untested"}
{"id": "cdXfRX", "name": "waves cc", "author": "tianluo970922", "description": "waves cc", "tags": ["wavescc"], "likes": 1, "viewed": 149, "published": 3, "date": "1688979123", "time_retrieved": "2024-07-30T17:45:25.031482", "image_code": "\n// Redefine below to see the tiling...\n//#define SHOW_TILING\nconst vec2 target_resolution = vec2(940, 86);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .3 + 23.0;\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5; \n    \n    vec2 uv0 = uv; \n    uv0.x *= 5.5;\n    uv0.y *= 1.;\n    uv0.y += iTime * 0.1;\n    \n    vec2 p = mod(uv0*TAU, TAU) - 250.0;\n    \n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .009;\n    \n    //pattern control\n    float iTimeCtrl = iTime * 0.12;\n    \n    float scale = 2.0; \n    float timetest = -sin((iTimeCtrl * 1.0/scale - 0.25) * 3.1415926 * 4.0/2.0) * 0.5 + 0.5;\n    float endPattern = mix(5.0, 3.5, uv.y + pow(1.0-uv.y, 5.0));\n    float pattern = mix(3.0, endPattern, timetest * 1.2);\n    \n    //通过算法测算出water的pattern，通过增大tiling的值可以增大pattern的密度\n\tfor (int n = 0; n < int(MAX_ITER); n++) \n\t{\n\t\tfloat t = time * (1.0 - (2.5/ float(n+1)));\n        float t1= time * .2;\n\t\ti = p + vec2(cos(t1 - i.x) + sin(t + i.y), sin(t - i.y) + cos(t1 + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+ t1)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(pattern);\n    \n    //1.12 可以调整白色的对比度，数值越高，对比度越高\n    //1. 1可以调整蓝色的深浅,数值越高，蓝色越浅，白色越多且会过曝\n\tc = 1.25 - pow(c, 1.1);\n    \n    float intensityblue = mix(13.0, 9.0, timetest);\n    vec3 blueChange = mix(vec3(0.000,0.212,0.302), vec3(0.000,0.349,0.502), timetest);\n    //7.5可以调整蓝色的深浅，数值越高，蓝色越深，但不会影响白色的细节\n\tvec3 colour = vec3(pow(abs(c), intensityblue));\n    colour = clamp(colour + blueChange, 0.0, 1.0);\n    \n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n    //WhiteEdge\n    float offset = uv.y + iTimeCtrl;\n    float y = mod(offset, scale);\n    \n    float d = smoothstep(0.2 * scale, 0.0  * scale, y) * 1.0;\n    float d1 = smoothstep(0.9  * scale, 1.0  * scale, y) * 1.0;\n    vec3 maskColor =  vec3(d) + vec3(d1);\n    \n    //maskColor *= pow(1.0 - uv.y, 2.0);   //test0 从0-1.0\n    //maskColor *= pow(1.0 - uv.y, 2.0)/2.0 + 0.5; //test1 从0.5-1.0\n    maskColor *= smoothstep(0.0, 1.0, pow(1.0 - uv.y, 1.0) + 0.15) * 0.8; //test2 从0.2-1.0\n    \n    float near = pow(uv.y, 3.5) * mix(0.75, 0.5, timetest);\n    vec3 frontEdge = vec3(near);\n    \n    fragColor.rgb = colour;\n    fragColor.rgb = colour + maskColor + frontEdge ; \n    \n    //结尾的mask\n    float mask = pow(uv.y, 1.0);\n    //0.492的值越小，黑色边缘越硬\n    mask = smoothstep(0.0,0.472,uv.y);\n    \n    //fragColor *= (mask);\n    //fragColor = vec4(endColor, 1.0);\n    //fragColor = vec4(frontEdge + maskColor,1.0);\n    \n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 201, 201, 295], [297, 297, 355, 355, 3771]], "test": "untested"}
{"id": "mslfR2", "name": "More \"cubes\" for the cube lovers", "author": "mrange", "description": "CC0: More \"cubes\" for the cube lovers\n  Tinkering around with glow effects and one bounce reflections\n  Produced a few interesting \"cubes\" that some might enjoy.\n", "tags": ["3d", "cubes"], "likes": 71, "viewed": 2015, "published": 3, "date": "1688974919", "time_retrieved": "2024-07-30T17:45:26.043775", "image_code": "// CC0: More \"cubes\" for the cube lovers\n//  Tinkering around with glow effects and one bounce reflections\n//  Produced a few interesting \"cubes\" that some might enjoy.\n\n// Song : Rush Connection - Culture Shock\n\n// Try different approximations of \"cubes\" by changing between DF0-DF7\n#define DF2\n// Some \"cubes\" can be more or less boxy\n//  define or comment out\n// #define BOXY\n// Some \"cubes\" have flair variants\n//  define or comment out\n#define FLAIR\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define LAYERS            5.0\n#define TTIME             (TAU*TIME)\n\n#define TOLERANCE           0.0001\n#define MAX_RAY_LENGTH      120.0\n#define MAX_RAY_MARCHES_LO  30\n#define MAX_RAY_MARCHES_HI  70\n#define NORM_OFF            0.005\n\nconst vec4 roadDim = vec4(normalize(vec3(0.0, 1.0, 0.15)), 20.0);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = -0.025;\nconst vec3 glowCol1   = HSV2RGB(vec3(hoff+0.65, 0.75, 0.2));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.75, 0.50, 0.5));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.40, 0.75, 0.125));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp) {\n  vec3 col = vec3(255.);\n  col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n  col.y = 100.04 * log(Temp) - 623.6;\n  if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n  col.z = 194.18 * log(Temp) - 1448.6;\n  col = clamp(col, 0., 255.)/255.;\n  if (Temp < 1000.) col *= Temp/1000.;\n  return col*col;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nvec3 pmin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec3 mod3(inout vec3 p, vec3 size) {\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat boxf(vec3 p, vec3 b, float e) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Intentionally bounded, not exact\nfloat bbox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return (max(q.x,max(q.y,q.z)));\n}\n\nfloat segmentx(vec2 p) {\n  float d0 = abs(p.y);\n  float d1 = length(p);\n  return p.x > 0.0 ? d0 : d1;\n}\n\nfloat segmentx(vec2 p, float l) {\n  float hl = 0.5*l;\n  p.x = abs(p.x);\n  float d0 = abs(p.y);\n  float d1 = length(p-vec2(hl, 0.0));\n  return p.x > hl ? d1 : d0;\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25) - r;\n}\n\nfloat sphere8(vec3 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p), 0.125) - r;\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  float d0 = circle(sp, 0.5);\n  float d = d0;\n  return d;\n}\n\nfloat synth(vec2 p, float aa, out float h, out float db) {\n  const float z = 75.0;\n  p.y -= -70.0;\n  const float st = 0.04;\n  p.x = abs(p.x);\n  p.x -= 20.0-3.5;\n  p.x += st*20.0;\n  p /= z;\n  float n = mod1(p.x, st);\n  float dib = 1E6;\n  const int around = 0;\n  for (int i = -around; i <=around ;++i) {\n    float fft = texture(iChannel0, vec2((n+float(i))*st, 0.25)).x; \n    fft *= fft;\n    if (i == 0) h = fft;\n    float dibb = segmentx((p-vec2(st*float(i), 0.0)).yx, fft+0.05)-st*0.4;\n    dib = min(dib, dibb);\n  }\n  \n  float d = dib;\n  db = abs(p.y)*z;\n  return smoothstep(aa, -aa, d*z);\n}\n\nvec3 road(vec3 ro, vec3 rd, vec3 nrd, float glare, out float pt) {\n  const float szoom   = 0.5;\n  const float bsz     = 25.0;\n  const float sm      = 1.0;\n  float off = abs(roadDim.w);\n  float t = rayPlane(ro, rd, roadDim);\n  pt = t;\n\n  vec3 p  = ro+rd*t;\n  vec3 np = ro+nrd*t;\n\n  vec2 pp   = p.xz;\n  vec2 npp  = np.xz;\n  vec2 opp  = pp;\n\n  float aa  = length(npp-pp)*sqrt(0.5);\n  pp.y += -60.0*TIME;\n\n  vec3 gcol = vec3(0.0);\n\n  float dr = abs(pp.x)-off;\n  vec2 cp = pp;\n  mod1(cp.y, 6.0*off);\n  vec2 sp = pp;\n  sp.x = abs(sp.x);\n  mod1(sp.y, off);\n  float dcl = segmentx(cp.yx, 1.5*off);\n  float dsl = segmentx((sp-vec2(0.95*off, 0.0)).yx, off*0.5);\n\n  vec2 mp = pp;\n  mod2(mp, vec2(off*0.5));\n    \n  vec2 dp = abs(mp);\n  float d = dp.x;\n  d = pmin(d, dp.y, sm);\n  d = max(d, -dr);\n  d = min(d, dcl); \n  d = min(d, dsl); \n  vec2 s2 = sin(TIME+2.0*p.xz/off);\n  float m = mix(0.75, 0.9, tanh_approx(s2.x+s2.y));\n  m *= m;\n  m *= m;\n  m *= m;\n  vec3 hsv = vec3(0.4+mix(0.5, 0.0, m), tanh_approx(0.15*mix(30.0, 10.0, m)*d), 1.0);\n  float fo = exp(-0.04*max(abs(t)-off*2., 0.0));\n  vec3 bcol = hsv2rgb(hsv);\n  gcol += 2.0*bcol*exp(-0.1*mix(30.0, 10.0, m)*d)*fo;\n\n  float sh;\n  float sdb;\n  float sd = synth(opp, 4.0*aa, sh, sdb)*smoothstep(aa, -aa, -0.5*dr);\n  sh = tanh_approx(sh);\n  sdb *= 0.075;\n  sdb *= sdb;\n  sdb += 0.05;\n  vec3 scol = sd*(sdb)*pow(tanh(vec3(0.1)+bcol), mix(vec3(1.0), vec3(1.5, 0.5, 0.5), smoothstep(0.4, 0.5, sh)));\n  gcol += scol;\n\n\n  gcol = t > 0.0 ? gcol : vec3(0.0);\n  return gcol+scol;\n}\n\nvec3 stars(vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 20000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    ccol *= mix(0.125, 1.0, smoothstep(1.0, 0.99, sin(0.33*TIME+TAU*h.y)));\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\nvec3 meteorite(vec2 sp) {\n  const float period = 3.0;\n  float mtime = mod(TIME, period);\n  float ntime = floor(TIME/period);\n  float h0 = hash(ntime+123.4);\n  float h1 = fract(1667.0*h0);\n  float h2 = fract(9967.0*h0);\n  vec2 mp = sp;\n  mp.x += -1.0;\n  mp.y += -0.5*h1;\n  mp.y += PI*0.5;\n  mp *= ROT(PI+mix(-PI/4.0, PI/4.0, h0));\n  float m = mtime/period;\n  mp.x += mix(-1.0, 2.0, m);\n  \n  float d0 = length(mp);\n  float d1 = segmentx(mp);\n  \n  vec3 col = vec3(0.0);\n  \n  col += 0.5*exp(-4.0*max(d0, 0.0))*exp(-1000.0*max(d1, 0.0));\n  col *= 2.0*HSV2RGB(vec3(0.8, 0.5, 1.0));\n  float fl = smoothstep(-0.5, 0.5, sin(12.0*TTIME));\n  col += mix(1.0, 0.5, fl)*exp(-mix(100.0, 150.0, fl)*max(d0, 0.0));\n  \n  col = h2 > 0.8 ? col: vec3(0.0);\n  return col;\n}\n\nvec3 skyGrid(vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/12.0*PI);\n  float y = sin(sp.x);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim*vec2(1.0/floor(1.0/y), 1.0));\n\n  vec3 col = vec3(0.0);\n\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 0.25*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return col;\n}\n\nvec3 sunset(vec2 sp, vec2 nsp) {\n  const float szoom   = 0.5;\n  float aa = length(nsp-sp)*sqrt(0.5);\n  sp -= vec2(vec2(0.5, -0.5)*PI);\n  sp /= szoom;\n  sp = sp.yx;\n  sp.y += 0.22;\n  sp.y = -sp.y;\n  float ds = sun(sp)*szoom;\n  \n  vec3 bscol = hsv2rgb(vec3(fract(0.7-0.25*(sp.y)), 1.0, 1.0));\n  vec3 gscol = 0.75*sqrt(bscol)*exp(-50.0*max(ds, 0.0));\n  vec3 scol = mix(gscol, bscol, smoothstep(aa, -aa, ds));\n  return scol;\n}\n\nvec3 glow(vec3 ro, vec3 rd, vec2 sp, vec3 lp) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y);\n  float h = 0.65;\n  vec3 col = hsv2rgb(vec3(h, 0.75, 0.35*exp(-15.0*y)))+HSV2RGB(vec3(0.8, 0.75, 0.5))*ci;\n  return col;\n}\n\nvec3 neonSky(vec3 ro, vec3 rd, vec3 nrd, out float gl) {\n  const vec3 lp       = 500.0*vec3(0.0, 0.25, -1.0);\n  const vec3 skyCol   = HSV2RGB(vec3(0.8, 0.75, 0.05));\n\n\n  float glare = pow(abs(dot(rd, normalize(lp))), 20.0);\n  \n  vec2 sp   = toSpherical(rd.xzy).yz;\n  vec2 nsp  = toSpherical(nrd.xzy).yz;\n  vec3 grd  = rd;\n  grd.xy *= ROT(0.025*TIME);\n  vec2 spp = toSpherical(grd).yz;\n\n  float gm = 1.0/abs(rd.y)*mix(0.005, 2.0, glare);\n  vec3 col = skyCol*gm;\n  float ig = 1.0-glare;\n  col += glow(ro, rd, sp, lp);\n  if (rd.y > 0.0) {\n    col += sunset(sp, nsp);\n    col += stars(sp, 0.0)*ig;\n    col += skyGrid(spp)*ig;\n    col += meteorite(sp)*ig;\n  }\n  gl = glare;\n  return col;\n}\n\nvec3 render0(vec3 ro, vec3 rd, vec3 nrd) {\n  float glare;\n  vec3 col = neonSky(ro, rd, nrd, glare);\n  if (rd.y < 0.0) {\n    float t;\n    col += road(ro, rd, nrd, glare, t);\n  }\n  return col;\n}\n\n\nfloat g_gd;\nmat3 g_rot = mat3(1.0);\n\n#if defined(DF0)\n\n#if !defined(BOXY)\n#define BACKSTEP\n#endif\n\n\nfloat dfeffect(vec3 p, out float ogd) {\n  const float sz = 20.0;\n#if defined(BOXY)\n  float d0 = box(p, vec3(sz));\n  float d1 = boxf(p, vec3(sz+0.01), 0.0)-0.01;\n#else\n  float d0 = sphere8(p, (sz));\n#endif\n  vec3 p2 = p;\n#if defined(FLAIR)\n  const float bsz = 2.0*sz/(3.-1.0);\n#else\n  const float bsz = 2.0*sz/(24.0-1.0);\n#endif\n  mod3(p2, vec3(bsz));\n  float d2 = box(p2, vec3(0.80*bsz*0.5))-0.15*bsz*0.5;\n\n  float d4 = sphere4(p, sz+-0.005);\n\n  float d = d2;\n  d = max(d, d0);\n#if defined(BOXY)\n  d = min(d, d1);\n#endif\n  d = min(d, d4);\n  \n  float gd = d4;\n#if defined(BOXY)\n  gd = min(gd, d1);\n#endif\n  ogd = gd;\n  \n  return d;\n\n}\n#elif defined(DF1)\n#if !defined(BOXY)\n#define BACKSTEP\n#endif\n\n#define ZOOM        (0.166)\n#define FWD(x)      exp2((x)*ZOOM)\n#define REV(x)      (log2(x)/ZOOM)\n\nfloat dfeffect(vec3 p, out float ogd) {\n  const float sz = 20.0;\n#if defined(BOXY)\n\n  float d0 = box(p, vec3(sz));\n  float d1 = boxf(p, vec3(sz+0.01), 0.0)-0.01;\n#else\n  float d0 = sphere8(p, (sz));\n#endif\n  float d3 = sphere4(p, sz);\n  float d4 = min(min(abs(p.x), abs(p.y)), abs(p.z))-0.015;\n#if defined(FLAIR)\n  float d5 = max(d0, d4);\n#endif  \n  vec3 p2 = p;\n\n  p2 = abs(p2);\n  p2 -= 20.0;\n  \n  vec3 fp2 = FWD(abs(p2));\n\n  float n = floor(max(max(fp2.x, fp2.y), fp2.z));\n  \n  float x0 = REV(n);\n  float x1 = REV(n+1.0);\n\n  float m = (x0+x1)*0.5;\n  float w = x1-x0;\n  \n  float d2 = abs(bbox(p2, vec3(m)))-(w*0.5)+0.125;\n\n  d0 = max(d0, d2);\n\n  float d = d0;\n  d = min(d, d3);\n#if defined(FLAIR)\n  d = min(d, d5);\n#endif\n#if defined(BOXY)\n  d = min(d, d1);\n#endif\n  \n  float gd = d3;\n#if defined(FLAIR)\n  gd = min(gd, d5);\n#endif  \n#if defined(BOXY)\n  gd = min(gd, d1);\n#endif\n  ogd = gd;\n  \n  return d;\n\n}\n#elif defined(DF2)\n#define BACKSTEP\n#define BOUNCE_ONCE\n\nfloat dfeffect(vec3 p, out float ogd) {\n  const float sz = (20.0);\n  vec3 p0 = p;\n  vec3 p1 = p;\n  p1 *= (g_rot);\n  p1 = pabs(p1, 10.0);\n  p1 -= 12.0;\n  p1 *= (g_rot);\n  float d0 = sphere8(p0, 20.0);\n  float d1 = torus(p1, 10.0*vec2(1.0, 0.0125));\n  \n  float d = d0;\n  d = pmax(d, -(d1-2.0), 5.0);\n  d = min(d, d1);\n  ogd = d1;\n\n  return d;\n}\n#elif defined(DF3)\n#define BACKSTEP\n#define BOUNCE_ONCE\nfloat dfeffect(vec3 p, out float ogd) {\n  const float sz = (20.0);\n  vec3 p0 = p;\n  vec3 p1 = p;\n  float d0 = sphere8(p0, 20.0);\n  float d1 = sphere(p1, 15.0);\n\n  float d = d0;\n  d = pmax(d, -(d1-5.0), 6.0);\n  d = min(d, d1);\n  ogd = d1;\n\n  return d;\n}\n#elif defined(DF4)\n//#define BACKSTEP\n#if !defined(FLAIR)\n#define BOUNCE_ONCE\n#endif\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2 = 0.1;\nconst float folding_limit = 1.0;\nconst float scale = -2.4;\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp;\n    dz *= temp;\n  } else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp;\n    dz *= temp;\n  }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat mb(vec3 z, out float ddd) {\n  vec3 offset = z;\n  float dr = 1.0;\n#if defined(FLAIR)\n  float d2 = 1E3;\n#else\n  float d2 = ((sphere4(z,2.0)));\n#endif\n\n  for(int n = 0; n < 5; ++n) {\n    box_fold(z, dr);\n    sphere_fold(z, dr);\n\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.5;\n#if defined(FLAIR)\n    if (n < 2) {\n      float d = (length(z))/abs(dr)-0.06;\n      d2 = min(d, d2);\n    }\n#endif\n  }\n  \n  float d = (length(z))/abs(dr)-0.04;\n#if !defined(FLAIR)\n  d2 = pmax(d2, -d, 0.5);\n#endif\n  d = min(d, d2);\n\n  ddd = d2;\n  \n  return d;\n}\n\n\nfloat dfeffect(vec3 p, out float ogd) {\n  const float z = 10.0;\n  vec3 p0 = p/z;\n  float d2;\n  float d0 = mb(p0, d2);\n  d0 *= z;\n  float d1 = d2*z; \n  \n  ogd = d1;\n  \n  float d = d0;\n  d = min(d, d1);\n  return d0;\n\n}\n#elif defined(DF5)\n#define BACKSTEP\n#define BOUNCE_ONCE\n\nfloat dfeffect(vec3 p, out float ogd) {\n  const float sz = (22.0);\n  float d = 1E3;\n  ogd = 1E3;\n  mat3 rot = g_rot;\n  vec3 pp = p;\n  const float zzz = 0.33;\n  float zz = 1.0;\n  const float MaxI = 5.0;\n  for (float i = 0.0; i < MaxI; ++i) {\n    pp = abs(pp);\n    vec3 p0 = pp;\n#if defined(BOXY)\n    float d0 = (sphere4(p0, sz));\n    float d1 = torus(p0, sz*vec2(1.1, 0.0033/(zz)));\n#else\n    float d0 = (sphere(p0, sz));\n    float d1 = torus(p0, sz*vec2(1.01, 0.0033/(zz)));\n#endif    \n    float dd = d0;\n    dd = pmax(dd, -(d1), 3.0);\n    dd = min(dd, d1);\n    ogd = min(ogd, d1);\n    dd *= zz;\n    d = pmax(d, -(dd-2.0*zz), 5.0*zz);\n    d = min(d, dd);\n#if defined(BOXY)\n    pp -= sz*(14.0/25.0);\n#else\n    pp -= sz*(11.0/25.0);\n#endif    \n    pp /= zzz;\n    zz *= zzz;\n    pp *= rot;\n    rot = transpose(rot);\n  }\n  \n  return d;\n}\n#elif defined(DF6)\n#define BACKSTEP\n#define BOUNCE_ONCE\nfloat dfeffect(vec3 p, out float ogd) {\n  vec3 p0 = p;\n  float d0 = sphere4(p0, 25.0);\n  vec3 p2 = p;\n  p2 *= transpose(g_rot);\n  float d2 = sphere4(p2, 22.0);\n  d0 = pmax(d0, -d2, 4.0);\n  float d3 = pmax(d0, d2-2.0, .5);\n  d0 = min(d0, d2);\n  \n  float d = d0;\n  ogd = d3;\n  return d;\n}\n#else\nfloat dfeffect(vec3 p, out float ogd) {\n  const float sz = (20.0);\n  vec3 p0 = p;\n  float d0 = box(p0, vec3(sz));\n  vec3 p1 = p;\n  float d1 = boxf(p1, vec3(sz+0.01), 0.)-0.01;\n\n  float d = d0;\n  d = min(d, d1);\n  \n  ogd = d1;\n\n  return d;\n}\n#endif\n\nfloat df(vec3 p) {\n  float d0 = dot(roadDim.xyz, p)+roadDim.w;\n  p.y += -20.0*1.30;\n  p.z += 66.0;\n  p *= g_rot;\n  float gd1;\n  float d1 = dfeffect(p, gd1);\n\n  float d = max(d1, -d0);\n  float gd = gd1;\n  g_gd = min(g_gd, gd);\n  \n  return d; \n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarchLo(vec3 ro, vec3 rd, float tinit, out int iter) {\n  float t = tinit;\n  const float tol = TOLERANCE;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES_LO; ++i) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nfloat rayMarchHi(vec3 ro, vec3 rd, float tinit, out int iter) {\n  float t = tinit;\n  const float tol = TOLERANCE;\n#if defined(BACKSTEP)\n  vec2 dti = vec2(1e10,0.0);\n#endif  \n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES_HI; ++i) {\n    float d = df(ro + rd*t);\n#if defined(BACKSTEP)\n    if (d<dti.x) { dti=vec2(d,t); }\n#endif  \n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n#if defined(BACKSTEP)\n  if(i==MAX_RAY_MARCHES_HI) { t=dti.y; };\n#endif  \n  iter = i;\n  return t;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nmat3 rotX(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    1.0 , 0.0 , 0.0\n  , 0.0 , +c  , +s\n  , 0.0 , -s  , +c\n  );\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nmat3 rotY(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , 0.0 , +s\n  , 0.0 , 1.0 , 0.0\n  , -s  , 0.0 , +c\n  );\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nmat3 rotZ(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , +s  , 0.0\n  , -s  , +c  , 0.0\n  , 0.0 , 0.0 , 1.0\n  );\n}\n\nvec3 render1(vec3 col, vec3 m, vec3 ro, vec3 rd, vec3 nrd) {\n  float tm = TIME*0.5;\n  g_rot = rotX(0.333*tm)*rotZ(0.5*tm)*rotY(0.23*tm);\n\n  int iter;\n  g_gd = 1E3;\n  float t = rayMarchHi(ro, rd, 0.0, iter);\n  float gd = g_gd;\n  vec3 ggcol = (glowCol1)*inversesqrt(max(gd, 0.00025));\n  if (t < MAX_RAY_LENGTH) {\n    vec3 p = ro+rd*t;\n    vec3 n = normal(p);\n    vec3 r = reflect(rd, n);\n    vec3 nr = reflect(nrd, n);\n    float fre0 = 1.0+dot(rd, n);\n    float fre = fre0;\n    fre *= fre;\n  \n    float ao = 1.0-float(iter)/float(MAX_RAY_MARCHES_HI);\n    float fo = mix(0.2, 1.0, ao);\n    vec3 rf = m*mix(0.33, 1.0, fre)*fo*0.75;\n\n    const vec3 fre1 = HSV2RGB(vec3(0.8, 0.5, 1.0)); \n#if defined(BOUNCE_ONCE)\n    g_gd = 1E3;\n    int riter;\n    float rt = rayMarchLo(p, r, 1.0, riter);\n    float rgd = g_gd;\n    vec3 rggcol = (glowCol1)*inversesqrt(max(rgd, 0.00025));\n\n    vec3 rcol = clamp(rggcol, 0.0, 4.0);\n    if (rt < MAX_RAY_LENGTH) {\n      rcol += diffCol*0.2;\n    } else {\n      rcol += render0(p, r, nr);\n    }\n#else\n    vec3 rcol = render0(p, r, nr);\n#endif\n    float dif = dot(sunDir1, n); \n    col *= (1.0-m);\n    col += m*sunCol1*dif*dif*diffCol*fo;\n    col += rf*rcol*fre1;\n  }\n  \n  col += clamp(m*ggcol, 0.0, 4.0);\n  return col;\n}\n\nvec3 render2(vec3 ro, vec3 rd, vec3 nrd) {\n  vec3 col = render0(ro, rd, nrd);\n\n  float t   = rayPlane(ro, rd, roadDim);\n  vec3 p    = ro+rd*t;\n  vec3 n    = roadDim.xyz;\n  vec3 r    = reflect(rd, n);\n  vec3 nr   = reflect(nrd, n);\n  float fre = 1.0+dot(n, rd);\n  fre *= fre;\n\n  vec3 ro0 = ro;\n  vec3 rd0 = rd;\n  vec3 nrd0= nrd;\n  vec3 m0 = vec3(1.0); \n\n  if (rd.y < -0.12) {\n    ro0 = p;\n    rd0 = r;\n    nrd0 = nr;\n    const vec3 fre0 = HSV2RGB(vec3(0.8, 0.9, 0.1)); \n    const vec3 fre1 = HSV2RGB(vec3(0.8, 0.3, 0.9)); \n    m0 = mix(fre0, fre1, fre);\n  }\n\n  col = render1(col, m0, ro0, rd0, nrd0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  const vec3 ro = vec3(0.0, 0.0, 10.0);\n  const vec3 la = vec3(0.0, 2.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  const vec3 ww = normalize(la - ro);\n  const vec3 uu = normalize(cross(up, ww ));\n  const vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.0);\n  vec2 np = p + vec2(aa); \n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n  vec3 nrd = normalize(-np.x*uu + np.y*vv + fov*ww);\n\n  vec3 col = render2(ro, rd, nrd);\n  col -= 0.0125*vec3(1.0, 2.0, 3.0)*(length(pp)+0.25);\n  col *= smoothstep(1.75, 0.5, length(pp));\n  col = aces_approx(col);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 33932, "src": "https://soundcloud.com/culture-shock/rush-connection?si=bc7d4408bdd545bd97f4e62c10137099&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1087, 1087, 1109, 1109, 1255], [1673, 1780, 1806, 1806, 1990], [1992, 2052, 2074, 2074, 2122], [2125, 2185, 2205, 2205, 2317], [2319, 2457, 2485, 2485, 2801], [2803, 2863, 2891, 2911, 2987], [2989, 3072, 3111, 3111, 3204], [3206, 3289, 3325, 3325, 3417], [3419, 3419, 3458, 3458, 3487], [3489, 3489, 3517, 3517, 3545], [3547, 3633, 3672, 3672, 3797], [3799, 3885, 3921, 3921, 4015], [4017, 4108, 4150, 4150, 4197], [4199, 4199, 4230, 4230, 4256], [4258, 4368, 4397, 4397, 4462], [4464, 4550, 4586, 4586, 4680], [4682, 4792, 4819, 4819, 4906], [4908, 5018, 5055, 5055, 5342], [5344, 5380, 5408, 5408, 5467], [5469, 5469, 5493, 5493, 5572], [5574, 5574, 5607, 5607, 5737], [5739, 5739, 5770, 5770, 5796], [5798, 5798, 5830, 5830, 5877], [5879, 5879, 5911, 5911, 5969], [5971, 5971, 5997, 5997, 6106], [6108, 6108, 6127, 6127, 6229], [6231, 6231, 6289, 6289, 6822], [6824, 6824, 6890, 6890, 8338], [8340, 8340, 8371, 8371, 9174], [9176, 9176, 9201, 9201, 9927], [9929, 9929, 9952, 9952, 10299], [10301, 10301, 10333, 10333, 10723], [10725, 10725, 10772, 10772, 11079], [11081, 11081, 11137, 11137, 11765], [11767, 11767, 11809, 11809, 11959], [17339, 17339, 17357, 17357, 17582], [17584, 17584, 17607, 17607, 17815], [17817, 17817, 17880, 17880, 18125], [18127, 18127, 18190, 18190, 18635], [18637, 18725, 18745, 18745, 18865], [18867, 18955, 18975, 18975, 19095], [19097, 19185, 19205, 19205, 19327], [19329, 19329, 19389, 19389, 20572], [20574, 20574, 20616, 20616, 21189], [21191, 21191, 21221, 21221, 21848], [21850, 21850, 21905, 21905, 22078]], "test": "untested"}
{"id": "cdXfRj", "name": "test232", "author": "lysol", "description": "test", "tags": ["test"], "likes": 0, "viewed": 125, "published": 3, "date": "1688920627", "time_retrieved": "2024-07-30T17:45:26.804740", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(sin(iTime), 0.500, 1.608);\n    vec3 b = vec3(0.918, cos(iTime), -0.862);\n    vec3 c = vec3(-1.691, 0.660, 0.660);\n    vec3 d = vec3(-2.312, -1.082, 0.667);\n    return a + b*cos(6.28318*(c*t+d));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.);\n    \n    for (float i =0.; i< 3.; i++){\n        uv = fract(uv*1.4) - .5;\n        float d = length(uv)*exp(length(uv0*.5));\n        vec3 col = palette(length(uv0)+i*1.5 + sin(iTime)*.3);\n        d=sin(d* 8. + iTime)/8.;\n        d = abs(d);\n        d =pow( 0.01/d,1.2);\n        \n        finalColor += col *d;    \n    }\n    \n\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 239], [241, 241, 298, 298, 778]], "test": "untested"}
{"id": "DdsfRB", "name": "perpetual fluidy fluid", "author": "hashtagexo", "description": "Q: \"Just change the gravitational constant of the universe\"\n\nmove a few decimal points, flip a couple signs, etc and presto: a fluid that remains in motion for eternity or \"your webGL implementation has crashed\" - whichever comes first", "tags": ["fluid", "particles", "reintegration", "mpm", "apic"], "likes": 8, "viewed": 251, "published": 3, "date": "1688898798", "time_retrieved": "2024-07-30T17:45:27.574682", "image_code": "// Fork of \"Fluidy fluid\" by michael0884. https://shadertoy.com/view/ftlXW8\n// 2023-07-09 09:56:19\n\n//MIT License\n//Copyright 2021 Mykhailo Moroz\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(5.0-0.001*rgb); \t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    P = floor(P);\n    \n    if(iMouse.z < 0.)\n    {\n        //P = iMouse.xy + 100.*(P/R.x - 0.5); \n    }\n    \n    float m = 0.01;\n    float rho = 1.1;\n    vec2 v = vec2(0.0);\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = A(P + di);\n        vec4 data1 = B(P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        vec2 x0 = 2.0*decode(data0.x) - fract(P);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        //update particle position\n    \n        //find cell contribution\n        vec3 o = overlap(2.0*x0 + di + v0*dt , vec2(0.1));\n            x0 = x0 + di; \n        \n        m += m0*o.z;\n        \n        float w = k1(1.0*x0);\n        \n        v += (v0 + 4.0*B0*x0)*w;\n        rho += m0*w;\n    }\n   // rho = step(0.1, rho)*rho; //isosurface\n    float arg = 0.5*(atan(v.y, v.x)/PI + 1.0);\n    float d = 2.1*length(v);\n    vec3 fluid = hsv2rgb(vec3(arg, 0.5, 0.3*d +0.*rho));\n    \n    C = vec4(mix( vec3(1.000,1.000,1.000),fluid, smoothstep(0.,0.5,sqrt(rho))), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 Mouse;\nfloat time;\nint frame;\n\n#define A(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define B(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n\n#define CH(c, p) texelFetch(c, ivec2(mod(p,R)), 0)\n\n//loop in range\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.0\n#define max_vel 0.6\n#define rad 1\n\n#define diffusion 10.25\n#define gravity 0.00005\n\n#define PI 3.04159265\n\n#define rest_rho -2.0\n#define eos_pressure 0.1\n\n//reduce rotation/shearing of low density particles\n//without this the vacuum and border state very chaotic, but it still works fine\n//in usual MPM that isn't necessary since the particles don't change mass\nfloat affine_str(float m)\n{\n    return 1.1; //full APIC\n    //return smoothstep(0.5*rest_rho,0.55*rest_rho,m);\n}\n\n//pressure equation of state\nfloat pressure(float rho)\n{\n    return 1.2*(rho - 0.5); //gas\n   // return eos_pressure*(pow(rho/rest_rho,4.) - 1.0); //Tait EOS (water)\n}\n\nvoid InitialConditions(inout float m, inout vec2 v, vec2 P)\n{\n    vec2 dx = P - R*vec2(0.3, 0.5);\n\n    float d = smoothstep(R.y*0.3, R.y*0.19, length(dx));  \n    m = 2.0*d;\n\n    v = d*0.3*normalize(vec2(dx.y,-dx.x));\n}\n\n//KERNEL FUNCTIONS\n\nfloat k0(vec2 dx) //linear kernel\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return k.x*k.y;\n}\n\nvec3 K0(vec2 dx) //linear kernel with the center of mass\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return vec3(dx*0.5, k.x*k.y);\n}\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\n//box size enstimator\nvec2 destimator(vec2 dx)\n{\n    return clamp(1.0 - 2.0*abs(dx), 0.0001, 1.0);\n}\n\n//box overlap with center of mass\nvec3 overlap(vec2 dx, vec2 box)\n{\n    vec2 min0 = max(dx - box*0.5, -0.5); \n    vec2 max0 = min(dx + box*0.5, 0.5); \n    vec2 size = max(max0 - min0, 0.); \n    return vec3(0.5*(max0 + min0), size.x*size.y/(box.x*box.y));\n}\n\n//boundary\n#define border_h 3.\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -border_h-sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n\n    return bound;\n}\n\n#define h 2.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n//DATA PACKING\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X)*1.0; \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x/1.);\n    return uintBitsToFloat(X); \n}\n\n//particle to grid\nvec4 P2G(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 x = vec2(0.0);\n    vec2 v = vec2(0.0);\n    float m = 0.0;\n    float rho = 0.0;\n    \n    range(i, -rad, rad) range(j, -rad, rad)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec4 data1 = CH(b, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float r0 = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 v0 = decode(data1.x);\n       // mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        \n        //estimate the shape of the distribution\n        vec2 box = destimator(x0);\n        \n        //update particle position\n        x0 = x0 + di + v0*dt;\n    \n        //find cell contribution\n        vec3 o = overlap(x0, box);\n         \n        //update distribution\n        x += m0*o.xy*o.z;\n        m += m0*o.z;\n        \n        //find grid node contribution\n        float w = k1(x0);\n        \n        //distribute momentum onto grid\n        v += v0*w*m0;\n        rho += m0*w;\n    }\n    \n    //normalize\n    if(rho > 0.0) v /= rho;\n    if(m > 0.0) x /= m;\n    \n    //initial conditions\n    if(frame < 20)\n    {\n        InitialConditions(m, v, P);\n    }\n    \n    v = (length(v)>max_vel)?normalize(v)*max_vel:v;\n    \n    return vec4(encode(x), m, encode(v), rho);\n}\n\n//grid to particle\nvec4 G2P(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 V = vec2(0.0);\n    mat2 B = mat2(0.0);\n    \n    vec4 data = CH(a, P);\n    float m = data.y;\n    vec2 x = decode(data.x);\n    \n    range(i, -rad, rad) range(j, -rad, rad)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float rho = data0.w;\n        vec2 dx = x - di;\n        vec2 v0 = decode(data0.z);\n        \n        //find grid node contribution\n        float w = k1(dx);\n        \n        float P = clamp(pressure(rho), -0.5, 0.5);\n        vec2 F = rho*dx*P;\n        \n        //distribute velocities/forces to particles\n        V += (F*dt)*w;\n        B += affine_str(m)*mat2(v0*dx.x,v0*dx.y)*w;\n    }\n    \n    V += 1.0005*decode(data.z);\n    \n    //gravity\n    V += vec2(0.0, -gravity)*dt;\n    \n    //push fluid\n   // V += vec2(0.0, 0.5)*exp(-0.02*pow(distance(P, R*vec2(0.7,0.3)), 2.));\n    \n    if(Mouse.z > 0.)\n    {\n        vec2 dx = (Mouse.xy - P); \n        V += -0.05*exp(-0.05*length(dx))*dx*dt; \n    }\n    \n    //border \n    vec3 N = bN(P + x);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, V);\n    //V *= 1. - 0.1*exp(-N.z);\n    V += (0. + 1.5*max(vdotN, 0.0))*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    V = (length(V)>max_vel)?normalize(V)*max_vel:V;\n\n    return vec4(encode(V), encode(B[0]), encode(B[1]), 1.0);\n}\n\n", "buffer_a_code": "//Advect mass distributions and distrubute the momentum and density to grid\n\n//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Distribute grid velocities to the mass distributions\n\n//G2P\n\n//technically its more correct to do the force in the P2G step 2\n//but I didn't want to waste a buffer here\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdsfRB.jpg", "access": "api", "license": "mit", "functions": [[147, 147, 174, 174, 334]], "test": "untested"}
{"id": "msfBzB", "name": "Satisfying Rainbow Loop", "author": "tristanantonsen", "description": "Satisfying Rainbow Loop\nReference:\nhttps://iquilezles.org/articles/distfunctions/", "tags": ["sdf", "gyroid", "satisfying"], "likes": 0, "viewed": 141, "published": 3, "date": "1688880030", "time_retrieved": "2024-07-30T17:45:28.347615", "image_code": "float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec2 p, float f, float z) {\n    return sin(f*p.x)*cos(f*p.y) + sin(f*p.y)*cos(f*z) + sin(f*z)*cos(f*p.x);\n} \n\nfloat SceneDist(vec2 p) {\n    float d = sdGyroid(p, 20.0, 0.025*iTime);\n    float t = sin(0.5 * iTime) * 0.02;\n    \n    return d + t;\n\n}\n\nvec2 GetNormal(vec2 p) {\n\n    float epsilon = 0.0001;\n    vec2 dx = vec2(epsilon, 0.);\n    vec2 dy = vec2(0., epsilon);\n\n    float ddx = SceneDist(p + dx) - SceneDist(p - dx);\n    float ddy = SceneDist(p + dy) - SceneDist(p - dy);\n    \n    return normalize(vec2(ddx, ddy));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution .xy)/iResolution.y;\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y / 2.0;\n    \n    if (iMouse.z == 0.0) { m.x = 0.0; };\n    \n    float f = 0.1;\n    float d = SceneDist(uv) * 255.;\n    \n    float t = d * 0.5;\n    float fac = 0.5 * cos(f * d) + 0.5; // creating ripples & shifting from 0 to 1\n    \n    vec4 solidColor = vec4(0.1, 0.1, 0.1, 1.0);\n    \n    vec4 col1 = vec4(1.0);\n    vec4 col2 = vec4(0.85, 0.85, 0.85, 1.0);\n    vec2 n = GetNormal(uv);\n    vec4 col3 = vec4(n, 1.0, 1.0);\n    \n    vec4 prettyColor = mix(col1, col3, fac); \n\n    fragColor = mix(solidColor, prettyColor, smoothstep(0.0,1.0,d) );\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [157, 157, 200, 200, 222], [224, 224, 243, 243, 305], [307, 307, 349, 349, 429], [432, 432, 457, 457, 568], [570, 570, 594, 594, 846], [849, 849, 906, 956, 1622]], "test": "untested"}
{"id": "csffzB", "name": "Panotools Lens Distortion", "author": "KartaVR", "description": "License:\n- GPL v3\n\nBased Upon:\n- aleklesovoi CRT TV Shader Shadertoy Example (https://www.shadertoy.com/view/DldXWS)\n- Natron OpenFX-Misc (/openfx-misc/Distortion/DistortionModel.cpp)\n- Blender Tracking Brown-Conrady Distortion Model (https://archive.blen", "tags": ["distortion", "lens", "panotools"], "likes": 1, "viewed": 234, "published": 3, "date": "1688859284", "time_retrieved": "2024-07-30T17:45:29.116559", "image_code": "// Panotools Lens Distortion\n\n// Open-Source License:\n// GPL v3\n\n// Fragment Shader Based Upon:\n// aleklesovoi's \"CRT TV Shader\" Shadertoy Example (https://www.shadertoy.com/view/DldXWS)\n// Natron OpenFX-Misc (/openfx-misc/Distortion/DistortionModel.cpp)\n// Blender Tracking Brown-Conrady Distortion Model (https://archive.blender.org/developer/D9037)\n\nvec2 PanotoolsDistortion(in vec2 uv)\n{\n    // Distortion\n    float a = 0.0;\n    float b = 0.346;\n    float c = 0.0;\n\n    // Center Offset\n    float cx = 0.0;\n    float cy = 0.0;\n\n    vec2 offset = vec2(cx / iResolution.x, cy / iResolution.y);\n\n    // Panotools uses UV coordinates with a [-1:1] range\n    uv = ((uv + offset) * 2.0) - 1.0;\n\n    // Compute the distortion\n    float x2 = uv.x * uv.x;\n    float y2 = uv.y * uv.y;\n\n    float r2 = x2 + y2;\n    float d = 1.0 - (a + b + c);\n    float r = sqrt(r2);\n    float scale = (a * r2 + c) * r + b * r2 + d;\n\n    uv.x *= scale;\n    uv.y *= scale;\n\n    // Transform the UV coordinates back to a [0:1] range\n    uv = (uv * 0.5) + 0.5;\n\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Use a \"Screen Space\" UV Coordinate [0;1] range\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Apply the lens distortion\n    uv = PanotoolsDistortion(uv);\n    vec3 result = texture(iChannel0, uv).rgb;\n\n    // Return the final output\n    fragColor = vec4(result, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csffzB.jpg", "access": "api", "license": "free-unknown", "functions": [[353, 353, 391, 409, 1052], [1054, 1054, 1109, 1163, 1391]], "test": "untested"}
{"id": "ddsfW4", "name": "More glyph magic", "author": "fishy", "description": "Testing my bloom implementation (kinda slow 😭)\nhttps://theowlhouse.fandom.com/wiki/Glyph_Magic", "tags": ["sdf", "glow", "glyphs", "owlhouse", "toh"], "likes": 17, "viewed": 348, "published": 3, "date": "1688855557", "time_retrieved": "2024-07-30T17:45:29.879520", "image_code": "#define BLOOM_PASS iChannel1\n\n// https://github.com/GarrettGunnell/AcerolaFX/blob/main/Shaders/AcerolaFX_Tonemapping.fx\nconst mat3 ACESInputMat = mat3(\n    vec3(0.59719, 0.35458, 0.04823),\n    vec3(0.07600, 0.90834, 0.01566),\n    vec3(0.02840, 0.13383, 0.83777)\n);\n\nconst mat3 ACESOutputMat = mat3(\n    vec3( 1.60475, -0.53108, -0.07367),\n    vec3(-0.10208,  1.10813, -0.00605),\n    vec3(-0.00327, -0.07276,  1.07602)\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec3 HillACES(vec3 col) {\n    col = col * ACESInputMat;\n    col = RRTAndODTFit(col);\n    return clamp(col * ACESOutputMat, 0.0, 1.0);\n}\n\nvec2 getTile(vec2 p, float tile)\n{\n    float tileWidth = 1.-exp2(-floor(tile));\n    return vec2((p)/exp2(floor(tile))/2.+vec2(tileWidth, 0));\n}\n\nvec4 computeBloom(sampler2D bloomTex, vec2 uv, float mip, float power, float str, float threshold)\n{\n    vec4 albedo = vec4(0);\n\tfor(float i = 0.; i < mip; i++)\n\t{\n        vec4 col = max(vec4(0), texture(bloomTex, getTile(uv.xy, i)) - threshold);\n\t\talbedo += col * exp2(-power*i);\n\t}\n    return albedo * str;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 outputColor = texture(iChannel0, uv, 0.0).rgb + computeBloom(BLOOM_PASS, uv, 6.0, 0.7, 0.5, 0.0).rgb;\n\n    fragColor = vec4(HillACES(outputColor), 1.0);\n    //fragColor = log(texture(iChannel1, uv) + 1.0)*4.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define csgInit() float r = 1e30\n#define csgEnd() return r\n#define csgUnion(d) r = min(r, d)\n#define csgMirrorX(p) vec2(abs(p.x), p.y)\n#define csgMirrorY(p) vec2(p.x, abs(p.y))\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRing(vec2 p, vec2 o, float r)\n{\n    return abs(distance(p, o) - r);\n}\n\nfloat sdPoint(vec2 p, vec2 o)\n{\n    return distance(p, o);\n}\n\nfloat sdPointedEggRing(vec2 p, vec2 o, float r, float h)\n{\n    return abs(p.y - o.y > 0.0? length(vec2(abs(p.x), p.y) - o + vec2(h, 0.0)) - (r+h) : length(p - o) - r);\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat sdGlyph(vec2 uv, int type)\n{\n    csgInit();\n    csgUnion(sdRing(uv, vec2(0), 1.0));\n    switch(type)\n    {\n        case 0:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.15, 0.7)));\n            csgUnion(sdRing(uv, vec2(0, 0.66), 0.154));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.506), vec2(0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0, 0.506), vec2(0, -1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, 0), vec2(0.1, 0.1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, -0.1), vec2(0.1, 0)));\n            csgEnd();\n        case 1:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.4, 0.6)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.4, 0.6), vec2(0.0, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdCubicBezier(csgMirrorX(uv), vec2(0.0, 0.2), vec2(0.2, 0.2), vec2(0.6, 0.1), vec2(0.97, -0.2), 3.0));\n            csgUnion(sdSegment(uv, vec2(0, 1), vec2(0, -0.3)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.3), vec2(0.15, -0.45)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.15, -0.45), vec2(0, -0.6)));\n            csgEnd();\n        case 2:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.2), vec2(0.25, 0.05)));\n            csgUnion(sdRing(uv, vec2(0, -0.5), 0.3));\n            csgUnion(sdPoint(uv, vec2(0, -0.5)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.4), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0.1, 0.5), vec2(-0.1, 0.5)));\n            csgUnion(sdSegment(uv, vec2(-0.25, 0.65), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0, -0.2), vec2(0, 0.4)));\n            csgEnd();\n        case 3:\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, -0.5), 0.5, 0.95));\n            csgUnion(sdRing(uv, vec2(0.0, -0.5), 0.5));\n            csgUnion(sdPoint(uv, vec2(0.0, -0.5)));\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, 0.3), 0.3, 0.65));\n            csgUnion(sdRing(uv, vec2(0.0, 0.3), 0.3));\n            csgEnd();\n    }\n        \n}\n\nvec3[] colors = vec3[](vec3(1.000,0.812,0.251), vec3(0.110,0.667,1.000), vec3(0.200,1.000,0.082), vec3(1.000,0.271,0.059));\nvec3 glyph(vec2 uv, float thickness, int type)\n{\n    float sdf = sdGlyph(uv, type);\n    return smoothstep(0.02, 0.0, sdf - thickness) * colors[type];\n}\n\nvec2 transformCoordinates(in vec2 uv, float scale, float rotA, float rotB)\n{\n    uv *= rotMat(rotA);\n    uv.x /= scale;\n    uv *= rotMat(rotB);\n    return uv;\n}\n\nvec3 glyphLayer(vec2 uv, float prob, float time, float speed)\n{\n    vec2 cid = floor(uv);\n    vec4 cellRand0 = hash42(cid) * vec4(vec3(40.0), 1.0);\n    vec4 cellRand1 = hash42(cid + 10.0);\n    vec4 cellRand2 = hash42(cid + 20.0);\n    float scale = 3.0 + cellRand2.x*3.0;\n    vec2 cp = scale*fract(uv)-scale*0.5;\n    if (cellRand1.w > prob)\n    {\n        return vec3(0.0);\n    }\n    return glyph(transformCoordinates(cp, sin(time*speed*(1.0 + cellRand1.x) + cellRand0.x), time*speed*0.5*cellRand1.y + cellRand0.y, -time*speed + cellRand0.z), 0.01, int(cellRand0.w * 4.0));\n}\n\nvec3 glyph3d(vec2 uv, vec2 offset)\n{\n    float scale = 0.5;\n    vec3 col = vec3(0);\n    for(float i = 0.0; i < 12.0; i++)\n    {\n        col += glyphLayer(uv*scale + offset + hash21(scale)*100.0, 0.5, iTime, 1.);\n        scale *= 1.2;\n    }\n    return col;\n}\n\nvec3 glyphRow(vec2 uv, float time)\n{\n    uv.y += time;\n    float xrand = hash12(floor(uv.yy));\n    uv.x += time * (xrand-0.5)*4.0;\n    float rand = hash12(floor(uv));\n    return glyph(3.0 * fract(uv) - 1.5, 0.01, int(rand*4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    fragCoord += hash22(fragCoord + fract(iTime) * 300.0)-0.5;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 2.0/iResolution.y;\n    \n    vec3 col = glyph3d(uv, vec2(sin(iTime*0.5), -iTime));\n    //col = glyphRow(uv, iTime*0.2);\n    \n    col *= 5.0;\n    fragColor = mix(texture(iChannel0, ouv), vec4(col, 1.0), 0.5);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float size = exp2(floor(log2(1.-uv.x)));\n    \n\tfragColor = texture(iChannel0, vec2(fract(uv.x/size), uv.y/size));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = 2./(H_BLUR_RES+1.);\n    vec4 a = vec4(0);\n    float m = 0.;\n    float mip = exp2(floor(log2(1.-uv.x)));\n    vec2 rot = vec2(1, 0);\n    vec2 ratio = vec2(iResolution.y/iResolution.x, 1);\n    for(float o = 0.; o < H_BLUR_RES; o++)\n    {\n        float t = ((o\n        #if DO_JITTER == 1\n         + hash12(fragCoord+fract(iTime))-0.5\n        #endif\n        )/H_BLUR_RES)*2.-1.;\n        float w = exp(-5.0*t*t);\n        m += w;\n        vec2 newCoords = uv.xy + H_BLUR_SIZE*rot*t*ratio;\n        #if DO_MIPMAP_CHECK == 1\n        float newCoordsMip = exp2(floor(log2(1.-newCoords.x)));\n        if(newCoordsMip == mip)\n        #endif\n            a += texture(iChannel0, newCoords)*w;\n    }\n    \n\tfragColor = a/m;\n    fragColor = mix(texture(iChannel1, uv), fragColor, 0.3);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = 2./(V_BLUR_RES+1.);\n    vec4 a = vec4(0);\n    float m = 0.;\n    float mip = exp2(floor(log2(1.-uv.x)));\n    vec2 rot = vec2(0, 1);\n    vec2 ratio = vec2(iResolution.y/iResolution.x, 1);\n    for(float o = 0.; o < V_BLUR_RES; o++)\n    {\n        float t = ((o\n        #if DO_JITTER == 1\n         + hash12(fragCoord+fract(iTime) + 100.0)-0.5\n        #endif\n        )/H_BLUR_RES)*2.-1.;\n        float w = exp(-5.0*t*t);\n        m += w;\n        vec2 newCoords = uv.xy + V_BLUR_SIZE*rot*t*ratio;\n        #if DO_MIPMAP_CHECK == 1\n        float newCoordsMip = exp2(floor(log2(1.-newCoords.x)));\n        if(newCoordsMip == mip)\n        #endif\n            a += texture(iChannel0, newCoords)*w;\n    }\n    \n\tfragColor = a/m;\n    fragColor = mix(texture(iChannel1, uv), fragColor, 0.3);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define H_BLUR_SIZE 0.05\n#define H_BLUR_RES 16.0\n\n#define V_BLUR_SIZE 0.05\n#define V_BLUR_RES 16.0\n\n#define DO_MIPMAP_CHECK 1\n#define DO_JITTER 1\n\n#define rotMat(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 422, 449, 449, 578], [580, 580, 605, 605, 715], [717, 717, 751, 751, 860], [862, 862, 962, 962, 1172], [1174, 1174, 1231, 1231, 1497]], "test": "untested"}
{"id": "mssfD7", "name": "TOH Glyphs", "author": "fishy", "description": "Glyphs from TOH\nhttps://theowlhouse.fandom.com/wiki/Glyph_Magic", "tags": ["sdf", "glow", "glyphs", "owlhouse", "toh"], "likes": 9, "viewed": 223, "published": 3, "date": "1688855149", "time_retrieved": "2024-07-30T17:45:30.636496", "image_code": "float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define init() float r = 0.0\n#define end() return r\n#define add(d) r += 1.0 / (15.0*max(0.0001, d))\n#define mirrorX(p) vec2(abs(p.x), p.y)\n\n// https://github.com/GarrettGunnell/AcerolaFX/blob/main/Shaders/AcerolaFX_Tonemapping.fx\nconst mat3 ACESInputMat = mat3(\n    vec3(0.59719, 0.35458, 0.04823),\n    vec3(0.07600, 0.90834, 0.01566),\n    vec3(0.02840, 0.13383, 0.83777)\n);\n\nconst mat3 ACESOutputMat = mat3(\n    vec3( 1.60475, -0.53108, -0.07367),\n    vec3(-0.10208,  1.10813, -0.00605),\n    vec3(-0.00327, -0.07276,  1.07602)\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec3 HillACES(vec3 col) {\n    col = col * ACESInputMat;\n    col = RRTAndODTFit(col);\n    return clamp(col * ACESOutputMat, 0.0, 1.0);\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRing(vec2 p, vec2 o, float r)\n{\n    return abs(distance(p, o) - r);\n}\n\nfloat sdPoint(vec2 p, vec2 o)\n{\n    return distance(p, o);\n}\n\nfloat sdPointedEggRing(vec2 p, vec2 o, float r, float h)\n{\n    return abs(p.y - o.y > 0.0? length(vec2(abs(p.x), p.y) - o + vec2(h, 0.0)) - (r+h) : length(p - o) - r);\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat sdGlyph(vec2 uv, int type)\n{\n    init();\n    add(sdRing(uv, vec2(0), 1.0));\n    switch(type)\n    {\n        case 0:\n            add(sdSegment(mirrorX(uv), vec2(0, 1), vec2(0.15, 0.7)));\n            add(sdRing(uv, vec2(0, 0.66), 0.154));\n            add(sdSegment(mirrorX(uv), vec2(0, 0.506), vec2(0.953, -0.3)));\n            add(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            add(sdSegment(uv, vec2(0, 0.506), vec2(0, -1)));\n            add(sdSegment(uv, vec2(-0.1, 0), vec2(0.1, 0.1)));\n            add(sdSegment(uv, vec2(-0.1, -0.1), vec2(0.1, 0)));\n            end();\n        case 1:\n            add(sdSegment(mirrorX(uv), vec2(0, 1), vec2(0.4, 0.6)));\n            add(sdSegment(mirrorX(uv), vec2(0.4, 0.6), vec2(0.0, -0.3)));\n            add(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            add(sdCubicBezier(mirrorX(uv), vec2(0.0, 0.2), vec2(0.2, 0.2), vec2(0.6, 0.1), vec2(0.97, -0.2), 8.0));\n            add(sdSegment(uv, vec2(0, 1), vec2(0, -0.3)));\n            add(sdSegment(mirrorX(uv), vec2(0, -0.3), vec2(0.15, -0.45)));\n            add(sdSegment(mirrorX(uv), vec2(0.15, -0.45), vec2(0, -0.6)));\n            end();\n        case 2:\n            add(sdSegment(mirrorX(uv), vec2(0, -0.2), vec2(0.25, 0.05)));\n            add(sdRing(uv, vec2(0, -0.5), 0.3));\n            add(sdPoint(uv, vec2(0, -0.5)));\n            add(sdSegment(mirrorX(uv), vec2(0, 0.4), vec2(0.25, 0.65)));\n            add(sdSegment(uv, vec2(0.1, 0.5), vec2(-0.1, 0.5)));\n            add(sdSegment(uv, vec2(-0.25, 0.65), vec2(0.25, 0.65)));\n            add(sdSegment(uv, vec2(0, -0.2), vec2(0, 0.4)));\n            end();\n        case 3:\n            add(sdPointedEggRing(uv, vec2(0.0, -0.5), 0.5, 0.95));\n            add(sdRing(uv, vec2(0.0, -0.5), 0.5));\n            add(sdPoint(uv, vec2(0.0, -0.5)));\n            add(sdPointedEggRing(uv, vec2(0.0, 0.3), 0.3, 0.65));\n            add(sdRing(uv, vec2(0.0, 0.3), 0.3));\n            end();\n    }\n        \n}\n\nvec3[] colors = vec3[](vec3(1.000,0.8,0.325), vec3(0.110,0.667,1.000), vec3(0.200,1.000,0.082), vec3(1.000,0.553,0.059));\nvec3 glyph(vec2 uv, float thickness, int type)\n{\n    float sdf = sdGlyph(uv, type);\n    return sdf * colors[type];\n}\n\nvec3 glyphRow(vec2 uv, float time)\n{\n    uv.y += time;\n    float xrand = hash12(floor(uv.yy));\n    uv.x += time * (xrand-0.5)*4.0;\n    float rand = hash12(floor(uv));\n    return glyph(4.0 * fract(uv) - 2.0, 0.01, int(rand*4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 2.0/iResolution.y;\n\n    //vec3 col = HillACES(glyph(uv*1.5 + m.xy*0.1, 0.01, int(iTime) % 4));\n    vec3 col = max(vec3(0), glyphRow(uv, iTime*0.2)-0.3) / 0.7;\n\n    // Output to screen\n    fragColor = vec4(HillACES(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 139], [673, 673, 700, 700, 829], [831, 831, 856, 856, 966], [968, 968, 1009, 1009, 1128], [1130, 1130, 1169, 1169, 1207], [1209, 1209, 1240, 1240, 1269], [1271, 1271, 1329, 1329, 1440], [1442, 1442, 1517, 1517, 1842], [1844, 1844, 1878, 1878, 3817], [3941, 3941, 3989, 3989, 4057], [4059, 4059, 4095, 4095, 4288], [4290, 4290, 4347, 4397, 4773]], "test": "untested"}
{"id": "csXfRS", "name": "Wave Equation (263 chars)", "author": "fenix", "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n", "tags": ["2d", "wave", "simulation", "codegolf"], "likes": 17, "viewed": 294, "published": 3, "date": "1688849047", "time_retrieved": "2024-07-30T17:45:31.431370", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  Buffer A stores the displacement at each pixel in the x coordinate, and the previous\n//  displacement in the y coordinate. The simulation runs according to the formula @28:30:\n//\n//      u(n+1,i,j) = 2u(n,i,j) - u(n-1,i,j) +\n//                   C[u(n,i+1,j) + u(n,i-1,j) + u(n,i,j+1) + u(n,i,j-1) - 4u(n,i,j)]\n//\n//  This simulation looks like it will be fun to experiment with, but for my first very\n//  simple wave equation shader it seemed like a golfing style would be appropriate. If\n//  I do more of these I'll use a clearer style.\n//\n// ---------------------------------------------------------------------------------------\n\nM;\n    O = sin(O.x + vec4(0, 11, 16, 0)); // colorize\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// From SnoopethDuckDuck, -34 chars\n//*\nM.xxyy; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n    vec2 o = vec2(1, 0), R = iResolution.xy;\n    O.x = .5 * (U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx)).x - O.z; // apply wave equation\n    O = iFrame == 0 ? step(length(u+u-R), R.y * .2) * o.xyyy : O; // initial condition\n}\n/**/\n\n// Original:\n/*\nM.xxyx; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n    vec2 o = vec2(1, 0), R = iResolution.xy;\n    O.x = 2. * O.x - O.z + .5 * (U(u + o.xy).x + U(u - o.xy).x + U(u + o.yx).x + U(u - o.yx).x - 4. * O.x); // apply wave equation\n    O = iFrame == 0 ? (length(u - .5 * R.xy) < R.y * .1) ? o.xyyy : vec4(0) : O; // initial condition\n}\n/**/\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define U(u) texelFetch(iChannel0, ivec2(u), 0) //\n#define M void mainImage( out vec4 O, vec2 u ) { O = U(u) //", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXfRS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "DsXfRS", "name": "first fract", "author": "tondoa", "description": "first fract", "tags": ["fract"], "likes": 2, "viewed": 161, "published": 3, "date": "1688846774", "time_retrieved": "2024-07-30T17:45:32.190341", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    uv = fract(uv * 0.35) -0.5;\n    \n    vec3 finalColor = vec3(230., 190., 138.)/360.;\n\n\n    float d = length(uv);\n    d = tan(sin(d*7.)* sin(iTime)*15.);\n    vec3 color = cos(vec3(14,23, 14)) * 10. * length(uv0);\n    finalColor = mix(0.1/color, finalColor, d);\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 445]], "test": "untested"}
{"id": "mdsfD7", "name": "TOH Glyph SDFs", "author": "fishy", "description": "Glyphs from TOH\nhttps://theowlhouse.fandom.com/wiki/Glyph_Magic", "tags": ["sdf", "glyphs", "owlhouse", "toh"], "likes": 4, "viewed": 119, "published": 3, "date": "1688842892", "time_retrieved": "2024-07-30T17:45:32.956293", "image_code": "#define csgInit() float r = 1e30\n#define csgEnd() return r\n#define csgUnion(d) r = min(r, d)\n#define csgMirrorX(p) vec2(abs(p.x), p.y)\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRing(vec2 p, vec2 o, float r)\n{\n    return abs(distance(p, o) - r);\n}\n\nfloat sdPoint(vec2 p, vec2 o)\n{\n    return distance(p, o);\n}\n\nfloat sdPointedEggRing(vec2 p, vec2 o, float r, float h)\n{\n    return abs(p.y - o.y > 0.0? length(vec2(abs(p.x), p.y) - o + vec2(h, 0.0)) - (r+h) : length(p - o) - r);\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat sdGlpyh(vec2 uv, int type)\n{\n    csgInit();\n    csgUnion(sdRing(uv, vec2(0), 1.0));\n    switch(type)\n    {\n        case 0:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.15, 0.7)));\n            csgUnion(sdRing(uv, vec2(0, 0.66), 0.154));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.506), vec2(0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0, 0.506), vec2(0, -1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, 0), vec2(0.1, 0.1)));\n            csgUnion(sdSegment(uv, vec2(-0.1, -0.1), vec2(0.1, 0)));\n            csgEnd();\n        case 1:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 1), vec2(0.4, 0.6)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.4, 0.6), vec2(0.0, -0.3)));\n            csgUnion(sdSegment(uv, vec2(0.953, -0.3), vec2(-0.953, -0.3)));\n            csgUnion(sdCubicBezier(csgMirrorX(uv), vec2(0.0, 0.2), vec2(0.2, 0.2), vec2(0.6, 0.1), vec2(0.97, -0.2), 8.0));\n            csgUnion(sdSegment(uv, vec2(0, 1), vec2(0, -0.3)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.3), vec2(0.15, -0.45)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0.15, -0.45), vec2(0, -0.6)));\n            csgEnd();\n        case 2:\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, -0.2), vec2(0.25, 0.05)));\n            csgUnion(sdRing(uv, vec2(0, -0.5), 0.3));\n            csgUnion(sdPoint(uv, vec2(0, -0.5)));\n            csgUnion(sdSegment(csgMirrorX(uv), vec2(0, 0.4), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0.1, 0.5), vec2(-0.1, 0.5)));\n            csgUnion(sdSegment(uv, vec2(-0.25, 0.65), vec2(0.25, 0.65)));\n            csgUnion(sdSegment(uv, vec2(0, -0.2), vec2(0, 0.4)));\n            csgEnd();\n        case 3:\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, -0.5), 0.5, 0.95));\n            csgUnion(sdRing(uv, vec2(0.0, -0.5), 0.5));\n            csgUnion(sdPoint(uv, vec2(0.0, -0.5)));\n            csgUnion(sdPointedEggRing(uv, vec2(0.0, 0.3), 0.3, 0.65));\n            csgUnion(sdRing(uv, vec2(0.0, 0.3), 0.3));\n            csgEnd();\n    }\n        \n}\n\nfloat map(vec2 uv)\n{\n    return sdGlpyh(uv, int(iTime) % 4);\n}\n\nvec3 colorSdf(vec2 uv, vec4 m)\n{\n    #define PERIOD 200.\n    #define STR 0.2\n    #define STROKE_WIDTH 0.01\n    #define MOUSE_WIDTH 0.005\n    float d = map(uv);\n    float px = fwidth(d);\n    float md = abs(map(m.xy));\n    vec3 col = mix(vec3(0.094,0.494,0.988), vec3(1.000,0.082,0.980), sign(d)*0.5+0.5);\n    col *= smoothstep(-px*PERIOD, px*PERIOD, cos(d*PERIOD))*STR+1.-STR;\n    col = mix(col, vec3(1), smoothstep(STROKE_WIDTH+px, STROKE_WIDTH-px, abs(d)));\n    if(m.z > 0.)\n    {\n        float mdc = smoothstep(px, -px, min(abs(distance(m.xy, uv)-md+MOUSE_WIDTH)-MOUSE_WIDTH, distance(m.xy, uv)-MOUSE_WIDTH*2.));\n        col = mix(col, vec3(1.000,0.875,0.000), mdc);\n    }\n    col /= d+1.;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 2.0/iResolution.y;\n\n    vec3 col = vec3(colorSdf(uv*1.2, m*1.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 177, 177, 296], [298, 298, 337, 337, 375], [377, 377, 408, 408, 437], [439, 439, 497, 497, 608], [610, 610, 685, 685, 1010], [1012, 1012, 1046, 1046, 3162], [3164, 3164, 3184, 3184, 3226], [3228, 3228, 3260, 3260, 3937], [3939, 3939, 3996, 4046, 4319]], "test": "untested"}
{"id": "ddsfDM", "name": "Trippy Bullseye", "author": "exocortex", "description": "very simple trials", "tags": ["trippyunfinished"], "likes": 3, "viewed": 134, "published": 3, "date": "1688836574", "time_retrieved": "2024-07-30T17:45:33.723243", "image_code": "\nvec3 pow3(float d, float phase) {\n    float basepower = 2.0 + cos(phase * 0.321) * 0.85;\n    float PI = 3.14159;\n\n    float offset = 0.08;\n\n    vec3 offsets = 0.4 * phase + offset * vec3(\n                cos(phase + PI * 2.0 / 3.0),\n                cos(phase + PI * 4.0 / 3.0),\n                cos(phase));\n    \n    vec3 powers = vec3(basepower, basepower, basepower);\n    \n    return vec3(pow(d, powers.x) + offsets.x, \n                pow(d, powers.y) + offsets.y, \n                pow(d, powers.z) + offsets.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    float d = length(uv);\n\n    vec3 col = 0.5 + 0.5*cos(20.0 * pow3(d, iTime));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 34, 34, 517], [519, 519, 576, 576, 757]], "test": "untested"}
{"id": "DsffWM", "name": "Spicy Plasma", "author": "space928", "description": "Curvy and green.", "tags": ["procedural", "2d", "plasma"], "likes": 4, "viewed": 194, "published": 3, "date": "1688827700", "time_retrieved": "2024-07-30T17:45:34.483211", "image_code": "const float motionBlur = 0.3;\nconst float aa = 0.6;\nconst vec3 col1 = vec3(13., 45., 140.)/100.;\nconst vec3 col2 = vec3(255., 20., 50.)/255.;\nconst vec3 col3 = vec3(21., 191., 112.)/600.;\nconst vec3 col4 = vec3(0.35, 1., 0.7)*0.65;\nconst float speed = 0.1;\n\n// AA = 0, 1, 2\n#define AA 1\n\nfloat sigmoid(float x)\n{\n    return 1.*x/(abs(x)+1.);\n}\nvec3 sigmoid(vec3 x)\n{\n    return x/(abs(x)+vec3(1.));\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, 0., 1.);\n}\nvec3 blend(float x, vec3 c)\n{\n    c = pow(c, vec3(x+2.));\n    return mix(x*c, x*(1.-c), step(x, 0.));\n}\n\nfloat f(vec2 p, float t, vec4 o, vec4 o1, float s, vec4 scale)\n{\n    vec4 i0 = cos(t+o)*vec4(o.xw, o1.xw);\n    vec4 i1 = sin(t+o1)*vec4(o.xw, o1.xw);\n    vec4 x0 = i0*s*sin(scale*length(p*o.xy+4.*scale.zw)+o.z+t*o.w);\n    vec4 x1 = i1*s*sin(scale*length(p*o1.xy)+o1.z+t*o1.w);\n    return sigmoid(dot(x0+x1, vec4(1.)));\n}\n\nvec3 scene(float t, float emphasis, vec2 uv)\n{\n    // \"Beautiful\" randomness, tuned for aesthetics, not performance\n    vec2 p = uv * 3.;\n    t += 160.;\n    t *= speed;\n    vec4 scale = vec4(sin(t*vec3(0.25, .5, .75)), cos(t*.95))*.25+.5;\n    float s0 = f(p, t, vec4(6.,9.,2.,1.5), vec4(2.,9.,7.,3.), .25, scale);\n    float s1 = f(p, t, vec4(2.,6.5,1.5,4.0), vec4(3.,2.5,3.8,1.6), .5, scale);\n    float s2 = sigmoid(s0/s1)*0.5;\n    float s3 = f(p, t, vec4(2.,9.,7.,3.), vec4(6.,3.,2.,1.5), .125, scale);\n    float s6 = f(p*1.5, t, vec4(6.,4.,8.,2.5), vec4(3.2,1.6,9.7,7.9), .25, scale);\n    float s7 = f(p*1.3, t, vec4(2.,6.5,1.5,4.0), vec4(3.,2.5,3.8,1.6), .5, scale);\n    float s8 = sigmoid(s6/s7+s0)*0.7;\n    \n    vec3 c = vec3(sigmoid((blend(s8,col1)+blend(s2,col2)+blend(s1,col3)+s7*1.)*1.1)*.7+.5);\n    float grad = sigmoid(pow(length(uv*2.-1.)+s3*.3, 5.))*1.5;\n    float accent = 1.-sigmoid((pow(2.5, abs(sigmoid(s8+s0+s1))-1.)-.45-(emphasis*0.1))*1000./(1.+30.*grad+20.*emphasis));\n    c = mix(c, c.r*.3+col4*.8, accent);\n    return clamp(vec3(c), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    float aaScale = 1./iResolution.x;\n\n    vec2 mouse = uv-iMouse.xy/iResolution.xx;\n    float emp = sigmoid(1./pow(length(mouse*1.), 1.8)*.02);\n\n    // Time varying pixel color\n    vec3 col = scene(iTime, emp, uv);\n    #ifdef AA\n    #if AA >= 1\n    col     += scene(iTime + motionBlur*0.001, emp, uv + aaScale*aa*vec2(0.,1.))\n             + scene(iTime + motionBlur*0.002, emp, uv + aaScale*aa*vec2(1.,0.));\n    #endif\n    #if AA >= 2\n    col     += scene(iTime + motionBlur*0.003, emp, uv + aaScale*aa*vec2(0.,-1.))\n             + scene(iTime + motionBlur*0.004, emp, uv + aaScale*aa*vec2(-1.,0.))\n             + scene(iTime + motionBlur*0.005, emp, uv + aaScale*aa*vec2(1.,1.))\n             + scene(iTime + motionBlur*0.006, emp, uv + aaScale*aa*vec2(1.,-1.))\n             + scene(iTime + motionBlur*0.007, emp, uv + aaScale*aa*vec2(-1.,1.));\n    col /= 8.;\n    #elif AA >= 1\n    col /= 3.;\n    #endif\n    #endif\n\n    // Output to screen\n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsffWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 312, 312, 343], [344, 344, 366, 366, 400], [401, 401, 424, 424, 455], [456, 456, 485, 485, 559], [561, 561, 625, 625, 881], [883, 883, 929, 998, 1949], [1951, 1951, 2008, 2058, 3079]], "test": "untested"}
{"id": "ddffDM", "name": "Static Shader", "author": "SnapSkull", "description": "Randomizes every pixel to a random greyscale pixel.", "tags": ["static"], "likes": 1, "viewed": 231, "published": 3, "date": "1688791761", "time_retrieved": "2024-07-30T17:45:35.240187", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float currentTime = iTime * 10.0;\n    float randomColor = fract(sin(dot(fragCoord.xy + vec2(currentTime), vec2(12.9898, 78.233))) * 43758.5453);\n    fragColor = vec4(randomColor, randomColor, randomColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddffDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 272]], "test": "untested"}
{"id": "mtGXRD", "name": "Psy Radiance", "author": "PhiVape", "description": "My first experiment, have fun.\n\nMouse controls:\nleft: changing complexity over time\nright: constant complexity over time\n", "tags": ["interactive", "psychedelic"], "likes": 5, "viewed": 154, "published": 3, "date": "1688771719", "time_retrieved": "2024-07-30T17:45:35.997163", "image_code": "float sdEquilateralTriangle(  in vec2 p, in float r ){\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\nvec3 palette1( float t ) {\n\n    vec3 a = vec3(0.550, 0.580, 0.550);\n    vec3 b = vec3(0.500, 0.500, 0.500);\n    vec3 c = vec3(2.025, 2.025, 2.025);\n    vec3 d = vec3(0.110, 0.333, 0.577);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette5( float t ) {\n\n    vec3 a = vec3(0.718, 0.768, 0.548);\n    vec3 b = vec3(0.515, 0.550, 0.550);\n    vec3 c = vec3(1.120, 1.120, 1.120);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iMouse = iMouse.xy / iResolution.xy;\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv.x = abs(uv.x);\n    vec2 polar = vec2(distance(uv.xy, vec2(0,0)), atan(uv.y,uv.x));\n    \n    for(int i = 0; i < 2;i++){\n        polar.xy = abs(polar.xy);\n        float complexity = mix(0.5*(sin(0.3*iTime)+2.3),2. , iMouse.x);\n        polar = fract(complexity*polar)-0.5;\n    }\n      \n    vec2 triangle = vec2(0.,0.15);\n    float factor = 3.+0.0005*sin(iTime)*sin(iTime);\n  \n    polar.xy = factor*abs(polar.xy);\n    float d_t = sdEquilateralTriangle(polar + triangle, 0.6 );\n    d_t = 0.5*sin(1.5*sin(0.4*iTime+d_t*0.7)*abs(d_t));\n      \n    vec4 col1 = vec4(palette1(3.*d_t + 0.5*iTime),1.0);\n    vec4 col2 = vec4(palette5(3.*d_t + 0.5*iTime),1.0);\n    float col_slider = 0.5*sin(1.5*iTime)+0.5;\n    vec4 col = mix(col1, col2, col_slider);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 261], [262, 262, 288, 288, 493], [494, 494, 520, 520, 725], [727, 727, 784, 784, 1670]], "test": "untested"}
{"id": "mdsBDN", "name": "Archipelago v2", "author": "Moumouke", "description": "Refraction and depth", "tags": ["fractal", "raymarch", "refraction"], "likes": 2, "viewed": 195, "published": 3, "date": "1688762228", "time_retrieved": "2024-07-30T17:45:36.858859", "image_code": "\nfloat hash1(vec2 p) {\n\tp = 57.0 * fract(p * 1.4142135623);\n\treturn fract(p.x * p.y);\n}\n\nvec3 noised(vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 w = fract(x);\n\tvec2 s = vec2(1.0, 0.0);\n\n\tfloat a = hash1(p + s.yy);\n\tfloat b = hash1(p + s.xy);\n\tfloat c = hash1(p + s.yx);\n\tfloat d = hash1(p + s.xx);\n\n\tfloat k0 = a;\n\tfloat k1 = b - a;\n\tfloat k2 = c - a;\n\tfloat k4 = a - b - c + d;\n\n\treturn vec3( -1.0 + 2.0 * (a + (b - a) * w.x + (c - a) * w.y + (a - b - c + d) * w.x * w.y), 2.0 * vec2(k1 + k4 * w.y, k2 + k4 * w.x));\n}\n\nfloat c01(float p) {\n\treturn clamp(p, 0.0, 1.0);\n}\n\nconst mat2 ma = mat2(\n\t 0.8,  0.6,\n\t-0.6,  0.8\n);\n\nconst mat2 mai = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n// https://iquilezles.org/articles/fbm/\nvec3 fbmd(vec2 x) {\n\tfloat f = 1.9;\n\tfloat s = 0.55;\n\tfloat a = 0.0;\n\tfloat b = 0.5;\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n\tvec2 d = vec2(0.0);\n\tfor (int i = 0; i < 7; i++) {\n\t\tvec2 offset = vec2(1.0, 1.5) * float(i);\n\t\tvec3 n = noised(x );\n\t\ta += b * n.x;\n\t\td += b * m * n.yz;\n\t\tb *= s;\n\t\tx = f * ma * x;\n        m = f*mai*m;\n\n\t}\n\treturn vec3(a, d);\n}\n\n\nvec3 sdfPlaned(vec3 p) {\n    vec3 n = fbmd(p.xz * 0.8) ;\n\treturn vec3(p.y + n.x, n.yz);\n}\n\nvec3 minSdfd(in vec3 a, in vec3 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nvec3 sdfd(vec3 p) {\n\tvec3 a = sdfPlaned(p + vec3(10.0, 2.0, 10.0));\n\tvec3 b = vec3(abs(p.y + 1.7), 0.,0.);\n\treturn minSdfd(a, b);\n}\n\nvec3 raymarchd(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat distance = 0.0;\n\tfloat maxDistance = 50.0;\n\tfloat minHitDistance = 0.001;\n\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tif (distance > maxDistance) break;\n\n\t\tvec3 pos = rayOrigin + rayDirection * distance;\n\n\t\tvec3 res = sdfd(pos);\n\n\t\tif (res.x < minHitDistance) return vec3(distance + res.x, res.y, res.z);\n\n\t\tdistance += res.x * 0.4;\n\t}\n\n\treturn vec3(-1.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 256; i++) {\n\t\tfloat h = sdfd(ro + rd * t).x;\n\n\t\tif (t > tmax) return res;\n\t\tif (h < 0.001) return 0.0;\n\t\tres = min(res, 18.0 * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nvec3 directionalLight(\n\tvec3 rayDirection,\n\tvec3 normal,\n\tvec3 point,\n\tvec3 baseColor,\n\tvec3 lightDir,\n\tvec3 lightColor,\n\tfloat shininess\n) {\n\tlightDir = normalize(lightDir);\n\tvec3 hal = normalize(lightDir - rayDirection);\n\tfloat diffuse = dot(normal, lightDir);\n\tdiffuse = c01(diffuse);\n\tdiffuse *= shadow(point, lightDir, 0.02, 2.5);\n\n\tfloat pho = c01(pow(dot(normal, hal), shininess));\n\tfloat spe = pho * diffuse * 0.3;\n\n\treturn baseColor * 2.2 * diffuse * lightColor + 5.0 * spe * lightColor * 0.4;\n\n}\n\nvec3 lightning(float distance, vec3 col, vec3 point, vec3 rayDirection, vec3 rayOrigin, vec3 normal) {\n\tvec3 newColor = col;\n\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(2.0, 2.0, 2.0), vec3(0.902, 0.902, 0.902), 64.0);\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(0.0, 2.0, 2.0), vec3(0.8392, 0.8078, 0.3529), 64.0);\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(-2.0, 2.0, -1.5), vec3(0.8863, 0.3608, 0.3608), 64.0);\n\n\treturn newColor / 4.0;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n\tvec3 col = vec3(0.0);\n\n\tvec3 hit = raymarchd(rayOrigin, rayDirection);\n\n\tif (hit.x > 0.0) {\n\t\tvec3 p = rayOrigin + rayDirection * hit.x;\n\t\tvec3 n = normalize(vec3(hit.y, 1., hit.z));\n\t\tfloat l = smoothstep(0.6, .8, n.y);\n\t\tif (hit.y == 0. && hit.z == 0.) {\n\t\t\tcol = vec3(0.1882, 0.1882, 0.5216);\n\t\t\tvec3 refracted = refract(rayDirection, n, .9);\n\t\t\tvec3 h2 = raymarchd(p + refracted * 0.01, refracted);\n\t\t\tvec3 n2 = normalize(vec3(h2.y, 1., h2.z));\n\t\t\tfloat l2 = smoothstep(0.6, .8, n2.y);\n\t\t\tcol = vec3(0.1882, 0.1882, 0.5216) * .7;\n\t\t\tcol +=  l2 * vec3(0.0392, 0.1294, 0.3137);\n\t\t\tcol /= 2.;\n\t\t\tcol = lightning(hit.x, col, p, rayDirection, rayOrigin, n);\n\t\t\tvec3 depthColor = vec3(0.1882, 0.1882, 0.5216);\n\t\t\tcol = mix(col, depthColor, c01(0.4+pow(h2.x, 1.3)));\n\t\t\t\n\t\t\t\n\t\t} else {\n\t\t\tcol = vec3(0.0941, 0.0784, 0.0275) * (1.-l) + l * vec3(0.0588, 0.1176, 0.0471);\n\t\t\tcol = lightning(hit.x, col, p, rayDirection, rayOrigin, n);\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat time = iTime / 25.0 * 1.5;\n\n\tfloat camspeed = 7.0;\n\tvec3 ta = vec3(0.0, .0, .0);\n\tvec3 ro = vec3(1.2 , .8, .0);\n\tvec3 t = -vec3(iTime, 0., iTime);\n\n\tta +=t;\n\tro +=t;\n\n\tvec3 cf = normalize(ta-ro);\n\tvec3 cs = normalize(cross(cf, vec3(sin(0.0), cos(0.0), 0.0)));\n\tvec3 cu = normalize(cross(cs, cf));\n\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(p.x * cs + p.y * cu + 2.5 * cf);\n\n\tvec3 col = render(ro, rd);\n\tcol = pow(col, vec3(1.0 / 2.2));\n\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 87], [89, 89, 110, 110, 510], [512, 512, 532, 532, 562], [690, 730, 749, 749, 1081], [1084, 1084, 1108, 1108, 1173], [1175, 1175, 1211, 1211, 1240], [1242, 1242, 1261, 1261, 1373], [1375, 1375, 1426, 1426, 1785], [1787, 1787, 1843, 1843, 2062], [2064, 2064, 2205, 2205, 2569], [2571, 2571, 2673, 2673, 3088], [3090, 3090, 3138, 3138, 4091], [4093, 4093, 4145, 4145, 4664]], "test": "untested"}
{"id": "ddsBWN", "name": "Constant Collision", "author": "misol101", "description": "FULLSCREEN RECOMMENDED\n\nMouse x controls \"blurring\", mouse y controls regeneration frequency", "tags": ["2d", "simulation", "explosion", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 13, "viewed": 280, "published": 3, "date": "1688760946", "time_retrieved": "2024-07-30T17:45:37.714571", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx;\n    //fragColor = vec4( val.x*0.95, val.x*0.95, val.x, 1.0 );\n\n    fragColor = vec4( (0.7-val)*1.5, 1.0 );\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int Key_SPACE = 32;\n\nbool ReadKey( int key )\n{\n\tbool toggle = false;\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nconst int stayrules[9] = int[9](0,0,1,1,0,0,0,0,1);\nconst int bornrules[9] = int[9](0,0,1,0,0,0,1,1,0);\nconst float liveval = 0.01;\n\n\nint cell2( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val == liveval) ? 1 : 0;\n}\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nvec2 cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).xw;\n}\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int v1 = 134, v2=98; float density=90.;\n    \n    ivec2 px = ivec2( fragCoord );\n    \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    vec2 cvv=cellval(px);\n    int ev = int(cvv.x*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = ev - 1;\n        if (stayrules[k]==1) f = k;\n    }\n    else {\n        f = bornrules[k]==1? k : 0;\n    }\n\n    float ff = float(f)/10.;\n\n    if( iFrame==0 || ReadKey(Key_SPACE) || iResolution.x != cvv.y) ff = 2.7;\n    \n    float maxregen = iResolution.x*iResolution.y/(1920.*1080.)*30.;  \n    for (float i=0.; i<maxregen - clamp((iMouse.y/iResolution.y), 0., 1.) * maxregen; i++) {\n        int sz = int(1. + hash1(iTime + i) * 1.5);\n        if (abs(int(hash1(iTime+i)*iResolution.x) - int(fragCoord.x)) < sz && abs(int(hash1(iTime + i + 0.287)*iResolution.y) - int(fragCoord.y)) < sz)\n            ff = -1.;\n    }\n\n\tfragColor = vec4( ff, 0.0, 0.0, iResolution.x);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx;\n \n    vec2 screenCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    vec3 val2 = texture(iChannel1, (fragCoord - screenCenter) * (1.-0.015*iMouse.x/iResolution.x) / iResolution.xy + 0.5).xxx;\n\n    fragColor = vec4( (val*0.5+val2*0.9)/1.4, 1.0 );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 231]], "test": "untested"}
{"id": "mdsBWN", "name": "Blank/New Shader", "author": "kowbell", "description": "Default shader created by shadertoy when I hit \"New\". Just usin it for testin somethin.", "tags": ["dummy"], "likes": 0, "viewed": 116, "published": 3, "date": "1688759408", "time_retrieved": "2024-07-30T17:45:38.474539", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "dssfW4", "name": "Archipelago", "author": "Moumouke", "description": "same as https://www.shadertoy.com/view/msXBD8 but i colored the fractal according to it's derived normal.", "tags": ["fractal", "raymarch"], "likes": 2, "viewed": 150, "published": 3, "date": "1688755712", "time_retrieved": "2024-07-30T17:45:39.282379", "image_code": "\nfloat hash1(vec2 p) {\n\tp = 57.0 * fract(p * 1.4142135623);\n\treturn fract(p.x * p.y);\n}\n\nvec3 noised(vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 w = fract(x);\n\tvec2 s = vec2(1.0, 0.0);\n\n\tfloat a = hash1(p + s.yy);\n\tfloat b = hash1(p + s.xy);\n\tfloat c = hash1(p + s.yx);\n\tfloat d = hash1(p + s.xx);\n\n\tfloat k0 = a;\n\tfloat k1 = b - a;\n\tfloat k2 = c - a;\n\tfloat k4 = a - b - c + d;\n\n\treturn vec3( -1.0 + 2.0 * (a + (b - a) * w.x + (c - a) * w.y + (a - b - c + d) * w.x * w.y), 2.0 * vec2(k1 + k4 * w.y, k2 + k4 * w.x));\n}\n\nfloat c01(float p) {\n\treturn clamp(p, 0.0, 1.0);\n}\n\nconst mat2 ma = mat2(\n\t 0.8,  0.6,\n\t-0.6,  0.8\n);\n\nconst mat2 mai = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n// https://iquilezles.org/articles/fbm/\nvec3 fbmd(vec2 x) {\n\tfloat f = 1.9;\n\tfloat s = 0.55;\n\tfloat a = 0.0;\n\tfloat b = 0.5;\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n\tvec2 d = vec2(0.0);\n\tfor (int i = 0; i < 7; i++) {\n\t\tvec2 offset = vec2(1.0, 1.5) * float(i);\n\t\tvec3 n = noised(x );\n\t\ta += b * n.x;\n\t\td += b * m * n.yz;\n\t\tb *= s;\n\t\tx = f * ma * x;\n        m = f*mai*m;\n\n\t}\n\treturn vec3(a, d);\n}\n\n\nvec3 sdfPlaned(vec3 p) {\n    vec3 n = fbmd(p.xz * 0.8) ;\n\treturn vec3(p.y + n.x, n.yz);\n}\n\nvec3 minSdfd(in vec3 a, in vec3 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nvec3 sdfd(vec3 p) {\n\tvec3 a = sdfPlaned(p + vec3(10.0, 2.0, 10.0));\n\tvec3 b = vec3(abs(p.y + 1.7), 0.,0.);\n\treturn minSdfd(a, b);\n}\n\nvec3 raymarchd(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat distance = 0.0;\n\tfloat maxDistance = 50.0;\n\tfloat minHitDistance = 0.001;\n\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tif (distance > maxDistance) break;\n\n\t\tvec3 pos = rayOrigin + rayDirection * distance;\n\n\t\tvec3 res = sdfd(pos);\n\n\t\tif (res.x < minHitDistance) return vec3(distance + res.x, res.y, res.z);\n\n\t\tdistance += res.x * 0.4;\n\t}\n\n\treturn vec3(-1.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 256; i++) {\n\t\tfloat h = sdfd(ro + rd * t).x;\n\n\t\tif (t > tmax) return res;\n\t\tif (h < 0.001) return 0.0;\n\t\tres = min(res, 18.0 * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nvec3 directionalLight(\n\tvec3 rayDirection,\n\tvec3 normal,\n\tvec3 point,\n\tvec3 baseColor,\n\tvec3 lightDir,\n\tvec3 lightColor,\n\tfloat shininess\n) {\n\tlightDir = normalize(lightDir);\n\tvec3 hal = normalize(lightDir - rayDirection);\n\tfloat diffuse = dot(normal, lightDir);\n\tdiffuse = c01(diffuse);\n\tdiffuse *= shadow(point, lightDir, 0.02, 2.5);\n\n\tfloat pho = c01(pow(dot(normal, hal), shininess));\n\tfloat spe = pho * diffuse * 0.3;\n\n\treturn baseColor * 2.2 * diffuse * lightColor + 5.0 * spe * lightColor * 0.4;\n\n}\n\nvec3 lightning(float distance, vec3 col, vec3 point, vec3 rayDirection, vec3 rayOrigin, vec3 normal) {\n\tvec3 newColor = col;\n\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(2.0, 2.0, 2.0), vec3(0.902, 0.902, 0.902), 64.0);\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(0.0, 2.0, 2.0), vec3(0.8392, 0.8078, 0.3529), 64.0);\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(-2.0, 2.0, -1.5), vec3(0.8863, 0.3608, 0.3608), 64.0);\n\n\treturn newColor / 4.0;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n\tvec3 col = vec3(0.0);\n\n\tvec3 hit = raymarchd(rayOrigin, rayDirection);\n\n\tif (hit.x > 0.0) {\n\t\tvec3 p = rayOrigin + rayDirection * hit.x;\n\t\tvec3 n = normalize(vec3(hit.y, 1., hit.z));\n\t\tfloat l = smoothstep(0.6, .8, n.y);\n\t\tif (hit.y == 0. && hit.z == 0.) {\n\t\t\tcol = vec3(0.1882, 0.1882, 0.5216);\n\t\t} else {\n\t\t\tcol = vec3(0.0941, 0.0784, 0.0275) * (1.-l) + l * vec3(0.0588, 0.1176, 0.0471);\n\t\t}\n\t\tcol = lightning(hit.x, col, p, rayDirection, rayOrigin, n);\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat time = iTime / 25.0 * 1.5;\n\n\tfloat camspeed = 7.0;\n\tvec3 ta = vec3(0.0, .0, .0);\n\tvec3 ro = vec3(1.2 , .8, .0);\n\tvec3 t = -vec3(iTime, 0., iTime);\n\n\tta +=t;\n\tro +=t;\n\n\tvec3 cf = normalize(ta-ro);\n\tvec3 cs = normalize(cross(cf, vec3(sin(0.0), cos(0.0), 0.0)));\n\tvec3 cu = normalize(cross(cs, cf));\n\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(p.x * cs + p.y * cu + 2.5 * cf);\n\n\tvec3 col = render(ro, rd);\n\tcol = pow(col, vec3(1.0 / 2.2));\n\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 87], [89, 89, 110, 110, 510], [512, 512, 532, 532, 562], [690, 730, 749, 749, 1081], [1084, 1084, 1108, 1108, 1173], [1175, 1175, 1211, 1211, 1240], [1242, 1242, 1261, 1261, 1373], [1375, 1375, 1426, 1426, 1785], [1787, 1787, 1843, 1843, 2062], [2064, 2064, 2205, 2205, 2569], [2571, 2571, 2673, 2673, 3088], [3090, 3090, 3138, 3138, 3614], [3616, 3616, 3668, 3668, 4187]], "test": "untested"}
{"id": "cdsBWN", "name": "spinning Hexagons", "author": "tondoa", "description": "Spinning Hexagons", "tags": ["hexagon"], "likes": 8, "viewed": 145, "published": 3, "date": "1688748592", "time_retrieved": "2024-07-30T17:45:40.051323", "image_code": "#define NUM_HEXAGON 32.\n#define RADIUS 0.05\n#define ROTATION 20.\n#define LINE_SIZE 0.005\n\n\n\nconst float PI = 3.14;\n\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float eps = min((2. + iTime*0.25), 9.) / iResolution.y;\n    \n    \n    vec3 finalColor = vec3(0.03);\n    \n   \n    for(float i = 1.; i < NUM_HEXAGON+1.; i++) {\n        //radius of each hexagon\n        float r = RADIUS * i /** (iTime/2.)*/;\n        //rotation mat2 of each hexagon\n        mat2 rot = rotationMatrix(iTime*ROTATION*i);\n        \n        float sdistance = sdHexagon(uv * min(iTime*0.05, 0.8) * rot, r);\n        float res = smoothstep(LINE_SIZE, eps, abs(sdistance));\n        vec3 color = 0.5 + 0.5 * cos(iTime + vec3(0,1,2) + i/8.);\n        finalColor = mix(color, finalColor, res);\n    }   \n\n\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 159, 159, 349], [351, 351, 385, 385, 479], [482, 482, 539, 594, 1308]], "test": "untested"}
{"id": "ddlfWH", "name": "4 worlds of base3 symetryB ", "author": "lomateron", "description": "click to interact\ntool used to find these worlds https://www.shadertoy.com/view/ddsBD8", "tags": ["automata"], "likes": 8, "viewed": 191, "published": 3, "date": "1688710392", "time_retrieved": "2024-07-30T17:45:40.938950", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0)*(1./2.);\n    int f = iFrame%2;\n    if(f==0){a = a.xyzw;}\n    if(f==1){a = a.yxwz;}\n    fragColor = a;\n}\n//a function has N inputs and 1 output\n//each input and output is in base2\n//then there are 2^2^N different functions\n//each function can be used in a world simulation\n//exploring all 2^2^N worlds is immpossible for a human so lets decrease the worlds to explore\n//functions were doesnt matter how inputs are swaped the output stays the same\n//then there are 2^(N+1) different functions to explore\n//if using base3 then there are 3^((N+1)(N+2)/2) different functions to explore\n//thats a lot of worlds so lets decrease the worlds to explore\n//functions were doesnt matter how inputs are swaped the output stays the same   and also\n//were FFFFFFFFFFFF (there is no simple description for this other rule...)\n//then there are 3^((N+1)(N+2)/2/3) different functions to explore\n//in this shader N=9 because 3*3 grid of pixels is read per pixel\n//so there are 3^19 worlds to explore\n\n//I name functions with first rule(swapping inputs...) symetryA functions\n//and functions with symetryA + second rule(FFFFFFFFFFFF...) symetryB functions", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define base 3U    //cant be changed\nvec4 read(vec2 u, vec2 m)\n{\n    vec2 z = floor(iResolution.xy/vec2(4,1));\n    vec2 o = mod(u+m,z);\n         u = floor(u/z)*z+o;\n    return texelFetch(iChannel0,ivec2(u),0);\n}\nfloat shiftEq(float a, float b, float c,\n              float x, float y, float z)\n{\n                       float r =-1.;\n    if(a==x && b==y && c==z){r = 0.;}\n    if(c==x && a==y && b==z){r = 1.;}\n    if(b==x && c==y && a==z){r = 2.;}\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    uint a1 = +( 8U +18U*1U)\n              +(13U +18U*0U) *18U*9U\n              +18U*9U*18U*9U *0U;\n         a1 = +( 4U +18U*1U)\n              +( 4U +18U*0U) *18U*9U\n              +18U*9U*18U*9U *0U;\n    uint a2 = +( 8U +18U*4U)\n              +(10U +18U*4U) *18U*9U\n              +18U*9U*18U*9U *0U;\n    uint a3 = +(13U +18U*6U)\n              +(13U +18U*0U) *18U*9U\n              +18U*9U*18U*9U *0U;\n    uint a4 = +( 9U +18U*1U)\n              +( 0U +18U*9U) *18U*9U\n              +18U*9U*18U*9U *0U;\n    float x = floor(4.*u.x/iResolution.x);\n         uint a = 0U;\n    if(x==0.){a = a1;}\n    if(x==1.){a = a2;}\n    if(x==2.){a = a3;}\n    if(x==3.){a = a4;}\n    float c0 = 0.;\n    float c1 = 0.;\n    float c2 = 0.;\n    float z = 1.;\n    for(float y=-z; y<=z; y+=1.){\n    for(float x=-z; x<=z; x+=1.){\n        float v = read(u,vec2(x,y)).x;\n        c0 += float(v==0.);\n        c1 += float(v==1.);\n        c2 += float(v==2.);\n    }}\n    float h = 0.;\n    float dv = 0.; //divisor\n    float md = 0.; //modulo\n    h = shiftEq(c0,c1,c2, 9.,0.,0.); if(h>=0.){dv =  0.;  md = h;}\n    h = shiftEq(c0,c1,c2, 8.,1.,0.); if(h>=0.){dv =  1.;  md = h;}\n    h = shiftEq(c0,c1,c2, 7.,2.,0.); if(h>=0.){dv =  2.;  md = h;}\n    h = shiftEq(c0,c1,c2, 6.,3.,0.); if(h>=0.){dv =  3.;  md = h;}\n    h = shiftEq(c0,c1,c2, 5.,4.,0.); if(h>=0.){dv =  4.;  md = h;}\n    h = shiftEq(c0,c1,c2, 4.,5.,0.); if(h>=0.){dv =  5.;  md = h;}\n    h = shiftEq(c0,c1,c2, 3.,6.,0.); if(h>=0.){dv =  6.;  md = h;}\n    h = shiftEq(c0,c1,c2, 2.,7.,0.); if(h>=0.){dv =  7.;  md = h;}\n    h = shiftEq(c0,c1,c2, 1.,8.,0.); if(h>=0.){dv =  8.;  md = h;}\n    h = shiftEq(c0,c1,c2, 7.,1.,1.); if(h>=0.){dv =  9.;  md = h;}\n    h = shiftEq(c0,c1,c2, 6.,2.,1.); if(h>=0.){dv = 10.;  md = h;}\n    h = shiftEq(c0,c1,c2, 5.,3.,1.); if(h>=0.){dv = 11.;  md = h;}\n    h = shiftEq(c0,c1,c2, 4.,4.,1.); if(h>=0.){dv = 12.;  md = h;}\n    h = shiftEq(c0,c1,c2, 3.,5.,1.); if(h>=0.){dv = 13.;  md = h;}\n    h = shiftEq(c0,c1,c2, 2.,6.,1.); if(h>=0.){dv = 14.;  md = h;}\n    h = shiftEq(c0,c1,c2, 5.,2.,2.); if(h>=0.){dv = 15.;  md = h;}\n    h = shiftEq(c0,c1,c2, 4.,3.,2.); if(h>=0.){dv = 16.;  md = h;}\n    h = shiftEq(c0,c1,c2, 3.,4.,2.); if(h>=0.){dv = 17.;  md = h;}\n    h = shiftEq(c0,c1,c2, 3.,3.,3.); if(h>=0.){dv = 18.;  md = h;}\n    uint dp = uint(dv);\n    uint mp = uint(md);\n    for(uint i=0U; i<dp; i++){a =  a    /base;}\n                              a = (a+mp)%base;\n                              //a = (a+1U)%base;\n    fragColor = vec4(a,read(u,vec2(0)).xyz);\n    {\n        uvec2 p = uvec2(u) + 1920U*1080U*uint(iFrame);\n              p = 1103515245U * ( (p>>1U) ^ (p.yx   ) );\n        uint  q = 1103515245U * ( (p.x  ) ^ (p.y>>3U) );\n        vec2  v = fract(vec2(4,1)*u.xy/iResolution.xy)-.5;\n        float s = .02;\n        if(iMouse.z>.5){s = .001;}\n        if(iMouse.z>.5){v = +(     u.xy/iResolution.xy-.5)\n                            -(iMouse.xy/iResolution.xy-.5);}\n        uint m = uint(step(dot(v,v),s));\n        if(iFrame==0           ){fragColor = vec4((q%3U*m+1U)%3U);}\n        if(iMouse.z>.5 && m!=0U){fragColor = vec4((q%3U*m+1U)%3U);}\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 215]], "test": "untested"}
{"id": "dslBR8", "name": "Unorm Vec4 Packing", "author": "piyushslayer", "description": "Mimicking glsl's packUnorm4x8/unpackUnorm4x8 functionality for easy packing and unpacking unorm textures/color values in a single uint. Can export upto 4 vec4s for the price of 1. ", "tags": ["compression", "packing"], "likes": 4, "viewed": 226, "published": 3, "date": "1688676842", "time_retrieved": "2024-07-30T17:45:41.826577", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord/iResolution.xy;   \n    vec2 mouse = bool(dot(vec2(lessThan(iMouse.xy, vec2(0.5))), vec2(1.0))) ? (vec2(0.5)) : (iMouse.xy / iResolution.xy);\n    vec4 packedAll = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    mat4 unpackedAll = mat4(\n                                unpackUnorm4x8(floatBitsToUint(packedAll.x)),\n                                unpackUnorm4x8(floatBitsToUint(packedAll.y)),\n                                unpackUnorm4x8(floatBitsToUint(packedAll.z)),\n                                unpackUnorm4x8(floatBitsToUint(packedAll.w))\n                            );\n    \n    fragColor = unpackedAll[uint(dot(vec2(greaterThan(uv, mouse.xy)), vec2(1.0, 2.0)))]; \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(\n                        uintBitsToFloat(packUnorm4x8(textureLod(iChannel0, uv, 0.0))),\n                        uintBitsToFloat(packUnorm4x8(textureLod(iChannel1, uv, 0.0))),\n                        uintBitsToFloat(packUnorm4x8(textureLod(iChannel2, uv, 0.0))),\n                        uintBitsToFloat(packUnorm4x8(textureLod(iChannel3, uv, 0.0)))\n                    );\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "uint packUnorm4x8(in vec4 unpacked)\n{\n    uvec4 utex = uvec4(unpacked * 255.0);\n    return ((utex.x << 24) | (utex.y << 16) | (utex.z << 8) | (utex.w));\n}\n\nvec4 unpackUnorm4x8(in uint packed)\n{\n    return vec4(\n        float((packed & 4278190080u) >> 24),\n        float((packed & 16711680u) >> 16),\n        float((packed & 65280u) >> 8),\n        float((packed & 255u))\n    ) * 0.0039215686;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 756]], "test": "untested"}
{"id": "msXBD8", "name": "Plane distortion", "author": "Moumouke", "description": "Standard raymarch to a plane distorted by a Fractional Brownian Motion (FBM).\n\nI removed any polinomial component from the noise function to keep sharp edge.", "tags": ["fractal"], "likes": 5, "viewed": 211, "published": 3, "date": "1688667099", "time_retrieved": "2024-07-30T17:45:42.681291", "image_code": "float hash1(vec2 p) {\n\tp = 57.0 * fract(p * 1.4142135623);\n\treturn fract(p.x * p.y);\n}\n\nfloat noise(vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 w = fract(x);\n    vec2 s = vec2(1.,0.);\n\n\tfloat a = hash1(p + s.yy);\n\tfloat b = hash1(p + s.xy);\n\tfloat c = hash1(p + s.yx);\n\tfloat d = hash1(p + s.xx);\n\n\treturn 2.*(a + (b - a) * w.x + (c - a) * w.y + (a - b - c + d) * w.x * w.y);\n}\n\nfloat c01(float p) {\n\treturn clamp(p, 0.0, 1.0);\n}\n\nconst mat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm(vec2 x) {\n\tfloat f = 1.9;\n\tfloat s = 0.55;\n\tfloat a = 0.0;\n\tfloat b = 0.5;\n\tfor (int i = 0; i < 5; i++) {\n\t\tvec2 offset = vec2(1.0, 1.5) * float(i);\n\t\tfloat n = noise(x + offset);\n\t\ta += b * n;\n\t\tb *= s;\n\t\tx = f * m * x;\n\t}\n\treturn a;\n}\n\nfloat sdfPlane(vec3 p) {\n\tvec3 p2 = p;\n\treturn p.y + fbm(p2.xz * 0.8) * cos(iTime / 2.0);\n}\n\nfloat sdf(vec3 p) {\n\treturn sdfPlane(p + vec3(10., 2., 10.));\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(\n\t\te.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx)\n\t);\n}\n\nvec3 normal(vec3 point) {\n\tconst vec3 smallStep = vec3(0.00001, 0, 0);\n\n\treturn normalize(\n\t\tvec3(\n\t\t\tsdf(point + smallStep.xyy) - sdf(point - smallStep.xyy),\n\t\t\tsdf(point + smallStep.yxy) - sdf(point - smallStep.yxy),\n\t\t\tsdf(point + smallStep.yyx) - sdf(point - smallStep.yyx)\n\t\t)\n\t);\n}\n\nfloat raymarch(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat distance = 0.0;\n\tfloat maxDistance = 50.0;\n\tfloat minHitDistance = 0.001;\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tif (distance > maxDistance) break;\n\n\t\tvec3 pos = rayOrigin + rayDirection * distance;\n\n\t\tfloat res = sdf(pos);\n\n\t\tif (res < minHitDistance) return distance + res;\n\n\t\tdistance += res * 0.4;\n\t}\n\n\treturn -1.0;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 256; i++) {\n\t\tfloat h = sdf(ro + rd * t);\n\n\t\tif (t > tmax) return res;\n\t\tif (h < 0.001) return 0.0;\n\t\tres = min(res, 18.0 * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nvec3 directionalLight(\n\tvec3 rayDirection,\n\tvec3 normal,\n\tvec3 point,\n\tvec3 baseColor,\n\tvec3 lightDir,\n\tvec3 lightColor,\n\tfloat shininess\n) {\n\tlightDir = normalize(lightDir);\n\tvec3 hal = normalize(lightDir - rayDirection);\n\tfloat diffuse = dot(normal, lightDir);\n\tdiffuse = c01(diffuse);\n\tdiffuse *= shadow(point, lightDir, 0.02, 2.5);\n\n\tfloat pho = c01(pow(dot(normal, hal), shininess));\n\tfloat spe = pho * diffuse * 0.3;\n\n\treturn baseColor * 2.2 * diffuse * lightColor + 5.0 * spe * lightColor * 0.4;\n\n}\n\nvec3 lightning(float distance, vec3 col, vec3 point, vec3 rayDirection, vec3 rayOrigin, vec3 normal) {\n\tvec3 newColor = col;\n\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(2.0, 2.0, 2.0), vec3(0.902, 0.902, 0.902), 32.0);\n\n    return newColor / 2.;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n\tvec3 col = vec3(0.0);\n\n\tfloat hit = raymarch(rayOrigin, rayDirection);\n\n\tif (hit > 0.0) {\n\t\tvec3 point = rayOrigin + rayDirection * hit;\n\t\tvec3 normal = calcNormal(point);\n\t\t\n        col =  vec3(0.3451, 0.3176, 0.3098);\n\t\tcol = lightning(hit, col, point, rayDirection, rayOrigin, normal);\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat camspeed = .4 * iTime;\n\tvec3 ta = vec3(0.0);\n\tvec3 ro = vec3(5.2 * cos(camspeed), 3.0, 5.2 * sin(camspeed));\n\n\tvec3 cf = normalize(-ro);\n\tvec3 cs = normalize(cross(cf, vec3(sin(0.0), cos(0.0), 0.0)));\n\tvec3 cu = normalize(cross(cs, cf));\n\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(p.x * cs + p.y * cu + 2.5 * cf);\n\n\tvec3 col = render(ro, rd);\n\tcol = pow(col, vec3(1.0 / 2.2));\n\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 86], [88, 88, 109, 109, 369], [371, 371, 391, 391, 421], [466, 506, 525, 525, 752], [754, 754, 778, 778, 845], [847, 847, 866, 866, 910], [912, 912, 939, 939, 1117], [1119, 1119, 1144, 1144, 1406], [1408, 1408, 1459, 1459, 1785], [1787, 1787, 1843, 1843, 2059], [2061, 2061, 2202, 2202, 2566], [2568, 2568, 2670, 2670, 2841], [2843, 2843, 2891, 2891, 3200], [3202, 3202, 3254, 3254, 3714]], "test": "untested"}
{"id": "cdffDH", "name": "Pixel Tiles [217 Chars]", "author": "SnoopethDuckDuck", "description": "Found this pattern by accident and thought it looked cool :)\nGolfing always welcome", "tags": ["pixelart", "tweet", "onetweet", "golf", "250chars"], "likes": 17, "viewed": 277, "published": 3, "date": "1688662106", "time_retrieved": "2024-07-30T17:45:43.547974", "image_code": "// -9  thanks to kishimisu\n// -11 thanks to iq\n// -3  thanks to Xor\nvoid mainImage( out vec4 O, vec2 I )\n{\n    float b, i;\n\n    for(vec2 u = I/iResolution.y + .1*iTime; \n        i++<10.; \n        u += .1+26.*floor(.7*iTime))\n        b = .5*(b + fract(dot(atan(I=floor(9.*u)),I)));\n     \n    O = .7 * sqrt(1. - cos(19.*b) + cos(69.*(b-=b*b)*b + vec4(6,1,2,3)) );\n}\n\n// Original [240]\n/*\nvoid mainImage( out vec4 O, vec2 I )\n{\n    float b,\n          i,\n          t = iTime,\n          o = .05 + 13. * floor(.7 * t);\n          \n    vec2 u = .5 * I/iResolution.y + .05 * t; \n   \n    for (i; i++ < 10.; u += o)\n        b = .5*b +.5 *\n        fract(dot(atan(I = floor(18. * u)), I));\n     \n    O = .7 * sqrt(1. - cos(19.*b)\n                     + cos(69.*b*b*(1.-b)*(1.-b)+vec3(6,1,2))\n                 ).xyzx;\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdffDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 68, 106, 106, 363]], "test": "untested"}
{"id": "DssBDr", "name": "Fork Protean cl electrogly 904", "author": "electroglyph", "description": "Fully procedural 3D animated volume with three evaluations per step (for shading) running fast enough for 1080p rendering.", "tags": ["procedural", "3d", "fast", "volumetric"], "likes": 3, "viewed": 263, "published": 3, "date": "1688638910", "time_retrieved": "2024-07-30T17:45:44.315921", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarily rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.47;\n        trk *= 1.1;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.1 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 2.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = .1;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<90; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.22;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.025,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.15)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,1e-6);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(1.*ic.x - ic.y - ic.z, 1.*ic.y - ic.x - ic.z, 1.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    //bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.1,sin(iTime*0.1)*0.,0);\n        \n    float dspAmp = .15;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 5.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    //ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,-1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2);// + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssBDr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1131, 1131, 1152, 1152, 1204], [1316, 1316, 1335, 1335, 1352], [1353, 1353, 1405, 1405, 1449], [1489, 1489, 1508, 1508, 1559], [1561, 1561, 1579, 1579, 2106], [2108, 2108, 2159, 2159, 3192], [3194, 3194, 3216, 3216, 3331], [3333, 3406, 3452, 3452, 3799], [3801, 3801, 3858, 3858, 4965]], "test": "untested"}
{"id": "cdlBWr", "name": "(Broken) XOR SDF demo", "author": "AShaderBeginner", "description": "Searched up \"xor sdf\" in Shadertoy and found nothing...\n...guess it's time to make one myself!\n\nNOTE: It can be broken. Whoops!", "tags": ["sdf"], "likes": 3, "viewed": 203, "published": 3, "date": "1688633457", "time_retrieved": "2024-07-30T17:45:45.192577", "image_code": "// #define BREAKME\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(vec2 pos, vec2 bound){\n    vec2 d = abs(pos) - bound;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// xor\n// Note that this can break.\n\n// We take the positive distance function (abs sd1 and sd2)\n// and invert it whenever sd1 xor sd2 is negative.\n// Negative times negative is positive.\n// So:\n\nfloat sdXor(float sd1, float sd2){\n    return sign(sd1 * sd2) * min(abs(sd1), abs(sd2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // cool transition\n    float a = .1 + .3 * smoothstep(5., 2., iTime);\n#ifdef BREAKME\n    vec2 v = vec2(1., 0.) * a;\n#else\n    vec2 v = vec2(1., 1.) * a;\n#endif\n    \n    // sdf\n    vec2 dims = vec2(0.3);\n    float sd = sdXor(\n                sdBox(uv - v, dims),\n                sdBox(uv + v, dims)\n               );\n    // float sd = sdBox(uv, vec2(0.5));\n    \n    // coloring\n    // Inspired by https://www.shadertoy.com/playlist/MXdSRf\n    float sdm = mod(sd - iTime * .2, .1) / .1;\n    vec3 col = sd > 0. ? vec3(.3, 1., .3) : vec3(1., .3, .3);\n    col *= mix(0.7, 1., smoothstep(0.4, 0.45, sdm) * smoothstep(0.55, 0.6, sdm));\n    col = mix(vec3(1.), col, smoothstep(0.01, 0.02, abs(sd)));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 72, 106, 106, 197], [395, 395, 429, 429, 485], [487, 487, 544, 561, 1393]], "test": "untested"}
{"id": "msXfDr", "name": "SIX Shaders in 487 chars", "author": "GregRostami", "description": "SIX shaders squeezed into 487 chars (with wipe transitions) ... That's an average of 81 chars per shader!!\nThanks to Smake's amazing DigEggs shader:\n[url]https://www.shadertoy.com/view/wdlfDH[/url]\nLet me know if this does not work on your computer.\n", "tags": ["raymarching", "short", "golf", "multiple"], "likes": 11, "viewed": 275, "published": 3, "date": "1688626162", "time_retrieved": "2024-07-30T17:45:45.956534", "image_code": "// SIX shaders squeezed into 487 chars ... That's an average of 81 chars per shader!!\n// I tried to combine shaders together in a way that saves chars and embed multiple \n// calculations in one loop for greater efficiency.\n\n// 487 chars - Xor made another 5 chars DISAPPEAR!!\nvoid mainImage (out vec4 O, vec2 u)\n{  \n    vec3 m, r, o, C = vec3(u/=iResolution.x, 1); \n    float t = iTime, c = fract (.04*(t-u.x)), i;\n    O *= i;\n    r.z = t;\n    for ( ++o.y; i++<98.; o += C * (length (cos (o + t)) - .3))\n        m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+(u-.4)*cos(.3*t),\n        r += C*(length(cos(r))-.6);\n    u -= .4;\n    for (ivec4 b; (b.x^b.y^b.z)%99 > b.z-7; )\n        b = ivec4 ( t*vec2(2,4) + 6.*u*O.a, O+=.1 );\n    O.rgb =\n        c < .2 ? o/50.\n      : c < .3 ? max ( u = fract( u/dot(u,u)-t ), u.x-u ).yyy\n      : c < .5 ? m\n      : c < .7 ? fract(r*3.) - (r.z-t)/30.\n      : ( c < .8 ? texture(iChannel1, vec2(t + .3/length(u), atan(u.yx, u)/3.14))\n      :  O/74.).rgb;\n}\n\n// 492 chars - Master Fabrice eradicated 3 chars!\n/*\nvoid mainImage (out vec4 O, vec2 u)\n{  \n    vec3 m, r, o, C = vec3(u/=iResolution.x, 1); \n    float t = iTime, c = fract (.04*(t-u.x)), i;\n    O *= i;\n    r.z = t;\n    for ( ++o.y; i++<98.; o += C * (length (cos (o + t)) - .3))\n        m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+(u-.4)*cos(.3*t),\n        r += C*(length(fract(r)-.5)-.2);\n    u -= .4;\n    for (ivec4 b; (b.x^b.y^b.z)%99 > b.z-7; )\n        b = ivec4 ( t*vec2(2,4) + 6.*u*O.a, O+=.1 );\n    O.rgb =\n        c < .2 ? o/50.\n      : c < .3 ? max ( u = fract( u/dot(u,u)-t ), u.x-u ).yyy\n      : c < .5 ? m\n      : c < .7 ? fract(r*9.) - .1*(r.z-t)\n      : ( c < .8 ? texture(iChannel1, vec2(t + .3/length(u), atan(u.y, u.x)/3.14))\n      :  O/74.).rgb;\n}\n*/\n\n// 495 chars - Greg Rostami's best version\n/*\nvoid mainImage (out vec4 o, vec2 u)\n{\n    u /= iResolution.x;\n    float t = iTime, c = fract (.03*(t-u.x));\n    vec4 x,m,r,C = vec4(u, 1, 0); o *= x;\n    r.z = t;\n    for ( ++o.y; o.a++<98.; o += C * (length (cos (o.xyz + t)) - .3))\n        m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+(u-.4)*cos(.3*t),\n        r += C*(length(fract(r.xyz)-.5)-.2);\n    u -= .4;\n    for (ivec4 b; (b.x^b.y^b.z)%99 > b.z-7; )\n        b = ivec4 ( t*vec2(2,4) + 6.*u*x.a, x+=.1 );\n    o = c < .2 ? o/50.\n      : c < .3 ? max ( u = fract( u/dot(u,u)-t ), u.x-u ).yyyy\n      : c < .4 ? texture( iChannel1, vec2(t + .3/length(u), atan(u.y, u.x)/3.14) )\n      : c < .6 ? m\n      : c < .8 ? fract(r*9.) - .1*(r.z-t)\n      : x/74.;\n}\n*/", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33909, "src": "https://soundcloud.com/the-flying-camel/iaso-tomita-debussy-arabesque", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 276, 313, 313, 976]], "test": "untested"}
{"id": "dsffWr", "name": "Sw0rd3x First tutorial", "author": "Sw0rd3x", "description": "itterative geometric chapes", "tags": ["geometric"], "likes": 0, "viewed": 150, "published": 3, "date": "1688621455", "time_retrieved": "2024-07-30T17:45:46.759388", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    \n    return a + b * cos(6.28318*(c*t*d));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n        \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y; \n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 3.0; i++){\n        uv = fract(uv *1.5) -0.5;\n\n        float d = length(uv)* exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 +iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime)/8.0;\n        d = abs(d);\n\n        d = 0.01/d;\n\n        finalColor += col * d;\n       \n        }\n        \n        fragColor = vec4(finalColor,1.0);\n   }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsffWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 208], [211, 211, 267, 267, 776]], "test": "untested"}
{"id": "msXfDn", "name": "Vanilla cherry coke blossom", "author": "BakingBeans", "description": "wait for it .. Vanilla Cherry Coke Blossoms", "tags": ["flower"], "likes": 0, "viewed": 138, "published": 3, "date": "1688619418", "time_retrieved": "2024-07-30T17:45:47.518358", "image_code": "vec3 palette(float t) {\n  vec3 a = vec3(0.5, 0.5, 0.5);\n  vec3 b = vec3(0.75, 0.5, 0.5);\n  vec3 c = vec3(1.0, 0.55, 0.60);\n  vec3 d = vec3(0.8, 0.333, 0.667);\n\n  return a + b * cos(6.28318 * t + c - d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n  vec2 uv0 = uv * (iTime - 5.0) * uv.yx;\n  vec3 fCol = vec3(0.0);\n\n  for (float i = 0.0; i < 3.0; i++) {\n    float d = length(uv + (0.1 / iTime));\n\n    d = sin(d * 8.0 + iTime) / 8.0;\n    d *= cos(5.0 / iTime);\n    d *= sin(iTime * 0.02);\n    uv.y -= d + cos(iTime * 0.15); // Up/Down\n    uv.x /= iResolution.y + sin(iTime / d + uv.y); // Left/Right\n\n    d = abs(d) / 0.2;\n    // Time varying pixel color\n    vec3 col = palette(length(uv0) + iTime * 4.0);\n    d = 0.2 * d;\n\n    col *= d;\n    fCol -= sin(iTime * col) - d;\n  }\n\n  uv += (iTime * uv.x) + (iTime - uv.y);\n\n  // Apply audio data from channel 1\n  vec2 audioUV = vec2(iTime * 0.2, iTime * 0.3); // Adjust the scaling factor as needed\n  float audioData = texture(iChannel0, audioUV + (iTime + 0.2)).r;\n\n  fCol *= audioData + iTime * 0.5;\n\n  // Apply fractal coloring\n  fCol -= (0.5 * 0.25) * iTime + sin(fCol / (iTime - 2.0) + vec3(0.0, 3.0, 4.0));\n\n  // Output to screen\n  fragColor = vec4(fCol, 1.0);\n}\n", "image_inputs": [{"id": 33907, "src": "https://soundcloud.com/catchingfliesmusic/change-of-hearts-1?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 204], [206, 206, 261, 309, 1337]], "test": "untested"}
{"id": "DsXBWn", "name": "learning circle + Triangle ", "author": "tondoa", "description": "learning circle and triangle", "tags": ["triangle", "cirlce"], "likes": 2, "viewed": 118, "published": 3, "date": "1688594973", "time_retrieved": "2024-07-30T17:45:48.327196", "image_code": "float sdfCircle(vec2 uv, float r, vec2 offset) {\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n    \n    return length(vec2(x, y)) - r;\n}\n\nfloat sdfTriangle ( in vec2 p, in float r)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    \n    return-length(p)*sign(p.y);\n}\n\nvec2 offset(float t, float r, float o) \n{\n    vec2 rv = vec2(sin(iTime*t - o), cos(iTime*t - o))*r;\n    return rv *(sin(iTime*t)* 0.4 + 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy -0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float eps = 4.  /iResolution.y;\n\n    vec3 col = vec3(0.15);\n    for (float i = 1.; i < 7.; i++) {\n        float circle = smoothstep(0., eps, sdfCircle(uv, 0.05, offset(2., 0.3, i)));\n        vec3 color = 0.5 + 0.5 * i * cos(iTime + uv.xyx + vec3(0,2,4));\n        col = mix(color, col, circle);\n    }\n    \n    float triangle = smoothstep(0., eps, sdfTriangle(uv,(2.+sin(iTime*2.))*0.1-0.05));\n    \n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n    \n    col = mix(color, col, triangle);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 152], [154, 154, 198, 198, 411], [413, 413, 454, 454, 555], [557, 557, 614, 664, 1296]], "test": "untested"}
{"id": "ddsfR7", "name": "Magic Sigil", "author": "shlynz", "description": "With the recent influx of posts I wanted to try myself at some shaders as well, this was the first thing I could come up with.\n\nChanges:\nAdded some noise to the SDFs & introduced a slow color gradient with complementary colors", "tags": ["wip", "glow", "magic", "sigil"], "likes": 11, "viewed": 331, "published": 3, "date": "1688588766", "time_retrieved": "2024-07-30T17:45:49.170940", "image_code": "#define PI 3.1415926536\n#define LINE_INTENSITY .5\n#define GLOW_INTENSITY 1.1\n#define COLOR_CHANGE_SPEED .1\n\n/* TODOs:\n * - implement more shapes (tri-, penta-, hexa-, octagon)\n * - reduce brightness blow-out of bright colors\n */\n\nfloat noise21(vec2 p){\n    return fract(sin(p.x*100.+p.y*8943.)*5647.);\n}\n\nfloat smoothNoise(vec2 uv){\n    vec2 localUv = smoothstep(.0, 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bottomLeft = noise21(id);\n    float bottomRight = noise21(id+vec2(1.,.0));\n    float bottom = mix(bottomLeft, bottomRight, localUv.x);\n\n    float topLeft = noise21(id+vec2(.0,1.));\n    float topRight = noise21(id+vec2(1.,1.));\n    float top = mix(topLeft, topRight, localUv.x);\n\n    return mix(bottom, top, localUv.y);\n}\n\nfloat smoothNoiseLayers(vec2 uv, float amountOfLayers){\n    float result = .0;\n    float sumOfAmplitudes = .0;\n    float frequency = 4.;\n    float amplitude = 1.;\n    for(float i = .0; i < amountOfLayers; i++){\n        result += smoothNoise(uv*frequency)*amplitude;\n        sumOfAmplitudes += amplitude;\n        frequency *= 2.;\n        amplitude /= 2.;\n    }\n    return result/sumOfAmplitudes;\n}\n\nvec2 rotateUv(vec2 uv, float rotation){\n    vec2 cosVal = uv * cos(rotation);\n    vec2 sinVal = uv * sin(rotation);\n    return vec2(cosVal.x +sinVal.y, cosVal.y -sinVal.x);\n}\n\nvec2 remapRotateUv(vec2 uv, vec2 newOrigin, float rotation){\n    vec2 newPoint = rotateUv(newOrigin, rotation);\n    vec2 movingUv = uv -newPoint;\n    return movingUv;\n}\n\nfloat glowyOutline(float sdfValue, vec2 point){\n    float noiseOffset = .5-smoothNoiseLayers(point +(iTime *.2), 5.);\n    sdfValue += noiseOffset * .02;\n    noiseOffset *= .1;\n    return pow(.01 *(LINE_INTENSITY +noiseOffset) /abs(sdfValue), 1. /(GLOW_INTENSITY +noiseOffset));\n}\n\nvec3 runeCircle(vec2 point, float size, vec3 color){\n    float sdf = length(point) -size;\n    return color *glowyOutline(sdf, point);\n}\n\nvec3 runeSquare(vec2 point, float size, vec3 color){\n    vec2 dist = abs(point) -vec2(size);\n    float outerDistance = length(max(dist, .0));\n    float innerDistance = min(max(dist.x, dist.y), .0);\n    float sdf = outerDistance +innerDistance;\n    return color *glowyOutline(sdf, point);\n}\n\nvec3 getColor(){\n    return .5 +.5 *cos(iTime *COLOR_CHANGE_SPEED +vec3(0, 2, 4));\n}\n\nvec3 getComplementaryColor(){\n    vec3 color = getColor();\n    float minVal = min(color.r, min(color.g, color.b));\n    float maxVal = max(color.r, max(color.g, color.b));\n    return vec3(maxVal - minVal)-color;\n}\n\nvec3 glowySeal(vec2 uv){\n    float piFourth = PI /4.;\n    \n    float randomBrightnessReduction = .9 +smoothNoiseLayers(uv +iTime, 5.) *.1;\n    vec3 col = getColor() * randomBrightnessReduction;\n    vec3 inverseCol = getComplementaryColor() * randomBrightnessReduction;\n    \n    vec3 finalColor = vec3(.0);\n    finalColor += runeSquare(rotateUv(uv, iTime), .6, col);           // outer square\n    finalColor += runeSquare(rotateUv(uv, iTime +piFourth), .6, col); // outer square (offset)\n    finalColor += runeSquare(rotateUv(uv, -iTime), .35, inverseCol);  // inner square\n    finalColor += runeCircle(uv, .7, col);                            // outer circle\n    finalColor += runeCircle(uv, .42, inverseCol);                    // inner circle\n    for(float i = .0; i < 8.; i++){                                   // small circles on the outside\n        finalColor += runeCircle(remapRotateUv(uv, vec2(.6), -iTime -piFourth *i), .15, col);\n    }\n                    \n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy *2. -1.;\n    uv.x *= iResolution.x /iResolution.y;\n    fragColor = vec4(glowySeal(uv), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 252, 252, 303], [305, 305, 332, 332, 739], [741, 741, 796, 796, 1137], [1139, 1139, 1178, 1178, 1313], [1315, 1315, 1375, 1375, 1483], [1485, 1485, 1532, 1532, 1764], [1766, 1766, 1818, 1818, 1901], [1903, 1903, 1955, 1955, 2192], [2194, 2194, 2210, 2210, 2278], [2280, 2280, 2309, 2309, 2492], [2494, 2494, 2518, 2518, 3486], [3488, 3488, 3544, 3544, 3678]], "test": "untested"}
{"id": "DslfR7", "name": "A space flower?", "author": "mrange", "description": "A space flower?\n@byt3m3chanic doing pretty cool with variable cell size truchets.\nDidn't really understand what he did so I tried something inspired by it\nI both failed and succeeded. It didn't turn out as intended but kind of neat anyway.", "tags": ["2d"], "likes": 19, "viewed": 477, "published": 3, "date": "1688576153", "time_retrieved": "2024-07-30T17:45:49.930908", "image_code": "// CC0: A space flower?\n//  @byt3m3chanic doing pretty cool with variable cell size truchets.\n//  Didn't really understand what he did so I tried something inspired by it\n//  I both failed and succeeded. It didn't turn out as intended but kind of neat anyway.\n\n\n// See @byt3m3chanic's tweet: https://twitter.com/byt3m3chanic/status/1676035945320046592?s=20\n\n// Music: Fearbace & Nostre - Still Isolated\n//  Which I happened to be listening to at the time.\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define REV(x)      exp2((x)*zoom)\n#define FWD(x)      (log2(x)/zoom)\n\nconst float zoom = log2(1.3);\n\n#define REP 26.0\n#define KALEIDOSCOPE\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return length(pa - ba*h);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  vec2 op = p;\n  float tm = TIME;\n  float mtm = fract(tm);\n  float ftm = floor(tm);\n\n  mat2 rot = ROT(0.075*TIME); \n\n  const float rep = REP;\n  const float sm  = 0.1*36.0/REP;\n  p *= transpose(rot);\n#if defined(KALEIDOSCOPE)\n  float nn = smoothKaleidoscope(p, sm, rep);\n#endif  \n  p *= rot;\n  p *= ROT(-0.5*length(p));\n  p += 0.5*sin(vec2(1.0, sqrt(0.5))*TIME*0.08);\n\n  \n  float zz = REV(mtm);\n  vec2 p2 = p;\n  p2 /= zz;\n  vec2 s2 = sign(p2);\n  p2 = abs(p2);\n  vec2 fp2 = FWD((p2));\n\n  vec2 n = floor(fp2);\n  float h = hash(s2.x+s2.y+n-ftm);\n  \n  vec2 x0 = REV(n);\n  vec2 x1 = REV(n+1.0);\n\n  vec2 m = (x0+x1)*0.5;\n  vec2 w = x1-x0;\n\n  vec2 modi = h > 0.5 ? vec2(1.0, 1.0) : vec2(1.0, -1.0);\n\n  vec2 p3 = p2;\n  p3 -= m;\n  p3 = abs(p3);\n  p3 -= 0.5*w;\n  float d3 = length(p3);\n\n  vec2 p4 = p2;\n  p4 -= m;\n  float d4 = segment(p4, -0.5*w*modi, 0.5*w*modi);\n  d4 = min(d4, d4);\n  d4 *= zz;\n  \n  float d6 = min(abs(p.x), abs(p.y));\n  vec3 col = vec3(0.0);\n  \n  float fo =1.0 - exp(-10.0*(d6-0.02));\n  float ll = length(pp);\n  vec3 gcol4 = 0.0025*(1.0+cos(vec3(0.0, 1.0, 2.0)+TIME+TAU*h+ll));\n  vec3 gcol6 = 0.005*(1.0+cos(vec3(0.0, 1.0, 2.0)+TIME+ll));\n  \n  col += fo*gcol4/max(d4, 0.001);\n  col = clamp(col, 0.0, 1.0);\n  col += gcol6/max(d6, 0.0001);\n  col = clamp(col, 0.0, 1.0);\n  col -= 0.05*vec3(0.0,1.0,2.0).zyx*(ll);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 33904, "src": "https://soundcloud.com/fearbace/fearbace-nostre-still?si=2fed3cd0cf404921ac989c6db4d5eae2&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[776, 836, 857, 857, 927], [929, 929, 951, 951, 995], [997, 997, 1018, 1018, 1063], [1065, 1165, 1204, 1204, 1289], [1291, 1291, 1321, 1321, 1349], [1351, 1437, 1482, 1482, 1636], [1638, 1638, 1699, 1699, 1912], [1914, 2032, 2071, 2071, 2180], [2182, 2182, 2212, 2212, 3566], [3568, 3568, 3623, 3623, 3795]], "test": "untested"}
{"id": "dsXfR7", "name": "10 x 10", "author": "Trixelized", "description": "https://10.pcmusic.info/", "tags": ["gradient", "atan", "aa", "conic", "10"], "likes": 1, "viewed": 210, "published": 3, "date": "1688566843", "time_retrieved": "2024-07-30T17:45:50.757697", "image_code": "// Constants\nconst float sqsize = 0.35; // Size\nconst float pi = 3.14159265;\nconst float tau = pi * 2.0;\nconst float dur = 600.0; // 10 x 10\n// Function for rotating UV\nmat2 rot2d(float angle) {\n    float s = sin(angle); float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Center UV, fix aspect ratio\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y);\n    // Rotate UV, create gradient\n    vec2 sq_uv = uv * rot2d(iTime / dur * tau);\n    float sq_rot = 0.5 - 0.5 * (atan(-sq_uv.x, -sq_uv.y) / pi);\n    // Anti-alias the gradient\n    float cgaa = length(fwidth(sq_rot));\n    sq_rot *= smoothstep(1.0, 1.0 - cgaa * 2.0, sq_rot);\n    // Set colors\n    vec3 sq = vec3(0.0, 0.0, sq_rot);\n    vec3 bg = vec3(0.0, 0.0, 1.0);\n    // Mix colors based on anti-aliased box shape\n    // This is excessive\n    float aa = length(fwidth(uv));\n    vec3 col = mix(sq, bg, smoothstep(sqsize, sqsize + aa,\n    max(abs(uv.x), abs(uv.y))));\n    // Final\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33898, "src": "https://soundcloud.com/pcmus/ten", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 169, 194, 194, 274], [275, 283, 338, 373, 1081]], "test": "untested"}
{"id": "ddfBRM", "name": "Stochastic Bilinear filtering", "author": "koiava", "description": "Implementation of a stochastic bilinear interpolation.\nLeft - Nearest neighbor, middle - Bilkinear, right - stochastic bilinear\nPlease see \"STOCHASTIC TEXTURE FILTERING\" from M. Fajardo et al.\nhttps://arxiv.org/pdf/2305.05810.pdf\n", "tags": ["interpolation", "bilinear", "stochastic", "filrtering"], "likes": 6, "viewed": 286, "published": 3, "date": "1688561034", "time_retrieved": "2024-07-30T17:45:51.526641", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5, 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= (cos(iTime) + 1.2)*0.23;\n    uv += vec2(0.5, 0.5);\n    \n    vec2 tc = uv*iChannelResolution[0].xy;\n    vec2 fr = fract(tc);\n    \n    int split1 = int(iMouse.x*(iMouse.x/iResolution.x));\n    float mx = iResolution.x-iMouse.x;\n    int split2 = int(iResolution.x - mx*(mx/iResolution.x));\n    \n    vec3 col;\n    if(int(fragCoord.x) == split1 || int(fragCoord.x) == split2) {\n        col = vec3(1.0);\n    } else {\n        if(fragCoord.x < float(split1)) {\n            ivec2 itc = ivec2(floor(tc + vec2(0.5, 0.5)));\n            col = texelFetch(iChannel0, itc + ivec2(0, 0), 0).xyz;\n        } else if(fragCoord.x < float(split2)) {\n            ivec2 itc = ivec2(floor(tc));\n\n            vec3 c0 = texelFetch(iChannel0, itc + ivec2(0, 0), 0).xyz;\n            vec3 c1 = texelFetch(iChannel0, itc + ivec2(1, 0), 0).xyz;\n            vec3 c2 = texelFetch(iChannel0, itc + ivec2(0, 1), 0).xyz;\n            vec3 c3 = texelFetch(iChannel0, itc + ivec2(1, 1), 0).xyz;\n\n            col =  mix(mix(c0, c1, fr.x), mix(c2, c3, fr.x), fr.y);\n        } else {\n            vec2 bn_res = iChannelResolution[1].xy;\n            vec4 bn = texture(iChannel1, mod(fragCoord, bn_res) / bn_res);\n            ivec2 itc = ivec2(floor(tc));\n\n            if(bn.x > fr.x) {\n                if(bn.y > fr.y) {\n                    col = texelFetch(iChannel0, itc + ivec2(0, 0), 0).xyz;\n                } else {\n                    col = texelFetch(iChannel0, itc + ivec2(0, 1), 0).xyz;\n                }\n            } else {\n                if(bn.y > fr.y) {\n                    col = texelFetch(iChannel0, itc + ivec2(1, 0), 0).xyz;\n                } else {\n                    col = texelFetch(iChannel0, itc + ivec2(1, 1), 0).xyz;\n                }\n            }\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 2044]], "test": "untested"}
{"id": "ddBcWd", "name": "Year of Truchets #047", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! \n", "tags": ["3d", "raymarching", "truchet", "pattern", "maze", "tiles"], "likes": 24, "viewed": 348, "published": 3, "date": "1688558250", "time_retrieved": "2024-07-30T17:45:52.294588", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #047\n    07/05/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n\n#define HI          1.57079632679\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    55.\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4314.23); }\n\n//@iq sdfs & extrude\nfloat box(vec3 p, vec3 b){vec3 q=abs(p)-b;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat box(vec2 p, vec2 a){vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\nfloat cap(vec3 p, float h, float r){p.y-=clamp(p.y,0.,h);return length(p)-r;}\nfloat opx(in float sdf, in float pz, in float h){vec2 w=vec2(sdf,abs(pz)-h);return min(max(w.x,w.y),0.)+length(max(w,0.));}\n\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\nconst float scale = .5;\nconst float tc = .0125;\nconst float amt = 2.;\n\nfloat glow,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,time = 0.,speed = 0.,movement;\nmat2 r45,cam;\nvec3 hit,hp;\nvec2 sid,gid;\n\nvec2 map (vec3 pos, float sg) {\n    vec2 res=vec2(1e5,0.);\n \n    pos.xz-=movement;\n    pos*=scale;\n    \n    vec2 id= floor(pos.xz), q = fract(pos.xz)-.5; \n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    //mod vars to mix things up\n    float m = floor(mod(id.y,3.)+1.);//1.75;//\n    float n = floor(mod(3.+2.5*sin(id.x*.4),5.)+1.);//2.15;//\n    //mod for long slices\n    vec2 cd=vec2(mod(id.x,n),mod(id.y,m))*2.-1.;\n    \n    float rnd = hash21(id);\n    if(rnd>.5) q.y=-q.y;\n\n    float sn = (id.x*.95)+(id.y*1.25);\n    sn = mod(sn,8.);\n    \n    float t1 = lsp(sn,sn+1.,tmod);\n    float t2 = lsp(sn+4.,sn+5.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    if(cd.y<.5 && cd.x<.5) q*=rot((t1+t2)*1.5707);\n    \n    float dir = (ck>.5^^rnd<.5)? 1.:-1.;\n\n    float hs=fract(rnd*32.83);\n    vec3 qp= vec3(q.x,pos.y,q.y);\n    vec2 p = length(q.xy-.5) < length(q.xy+.5) ? q.xy-.5 : q.yx+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-tc;\n    if(hs>.85) d = min(length(q.x),length(q.y))-tc;\n    rnd=fract(rnd*32.83);\n    \n    float d1 = length(q)-.465;\n    float d4 = min(length(vec2(q.x,abs(q.y)-.44)),length(vec2(abs(q.x)-.44,q.y)))-.028;\n    float sw = 0.;\n    \n    if(cd.x>.5 ) { d = length(q.y)-tc;d4=length(vec2(abs(q.x)-.44,q.y))-.028;}\n    if(cd.y>.5 ) { d = length(q.x)-tc;d4=length(vec2(q.x,abs(q.y)-.44))-.028;}\n    if(cd.y>.5 && cd.x>.5) { d = 1.; d4 = 1.; sw = (t1-t2)*.25;}\n   \n    \n    d=min(max(d,d1),d4);\n    d= opx(d,qp.y-.1,.5);\n    d1= opx(d1,qp.y-sw+.275,.3);\n    \n    if(rnd>.5&&hs<.85) { qp.xz*=r45;float c1 = box(qp-vec3(0,.35,0),vec3(1,.1,.2));d=max(d,-c1);}\n\n    if(d<res.x) {\n        res = vec2(d/scale,1.);\n        hp = vec3(q.x,pos.y,q.y);\n    }\n    \n    if(d1<res.x) {\n        res = vec2(d1,5.);\n        hp = vec3(q.x,pos.y,q.y);\n    }\n    \n    rnd=fract(rnd*52.71);\n    float lp = rnd>.925 ? length(vec3(q.x,pos.y-1.,q.y))-.1 : 1e5;\n    if(sg==1. && (cd.y>.5 && cd.x>.5)) { glow += .00075/(.00075+lp*lp);}\n    if(lp<res.x&& (cd.y>.5 && cd.x>.5)) {\n        res = vec2(lp,6.);\n        hp = pos;\n    }\n    \n    float f = pos.y;\n    if(f<res.x) {\n        res = vec2(f,2.);\n        hp = pos;\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e,0.).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e,0.).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e,0.).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e,0.).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<128;i++){\n        vec2 ray = map(ro + rd * d,1.);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<64?ray.x*.35:ray.x*.85;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 F){\n\n    r45=rot(.78539816339);\n    speed = T*.4;\n    movement = T*.43;\n    tmod = mod(speed,13.);\n        \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,8);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) || M.z <0. ? .0 : (M.y/R.y * .1-.05)*PI;\n    float y = M.xy==vec2(0) || M.z <0. ? .0 : (M.x/R.x * 1.-.5)*PI;\n\n    float ff = .3*sin(T*.08);\n    mat2 rx = rot(-.82-ff-x), ry = rot(.88+ff-y);\n    \n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0),p= vec3(0);\n    \n    vec2 ray = marcher(ro,rd);\n    float d=ray.x, m=ray.y;\n    hit = hp;\n    sid = gid;\n\n    if(d<MAX_DIST)\n    {\n             p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(6.,12.,-12.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        float shdw = 1.;\n\n        for( float t=.01; t < 16.; ) {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h*.4;\n            if( shdw<MIN_DIST ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.1);\n        if(m==1.) {\n            vec2 hp = vec2(abs(hit.x),hit.y);\n            vec3 clx = texture(iChannel0,vec2(abs(hit.x),hit.y)).rgb;\n            vec3 clm = texture(iChannel0,vec2(abs(hit.z),hit.y)).rgb;\n            h = clm*clx;\n        }\n        \n        if(m==2.) h=texture(iChannel1,hit.xz*.5).rgb;\n\n        if(m==5.) h=texture(iChannel0,abs(hit.xz)).rgb;\n\n        if(m==6.) h=vec3(1);\n        \n        C = (diff*h);\n    } \n\n    C = mix(C,vec3(.89),clamp(glow*.5,0.,1.));\n    C = mix(C,vec3(.102,.086,.059),1.-exp(-.0005*d*d*d));\n    C = pow(max(C,0.),vec3(.4545));\n\n    fragColor = vec4(C,1);\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBcWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[440, 440, 458, 458, 502], [503, 503, 524, 524, 579], [581, 602, 628, 628, 700], [701, 701, 727, 727, 790], [791, 791, 827, 827, 868], [869, 869, 918, 918, 992], [994, 994, 1031, 1031, 1065], [1066, 1066, 1085, 1085, 1112], [3472, 3541, 3571, 3571, 3803], [3805, 3805, 3837, 3837, 4068], [4070, 4070, 4115, 4115, 5900]], "test": "untested"}
{"id": "DsXBz4", "name": "stream of squares and circles", "author": "AShaderBeginner", "description": "i've got into shadertoy again, sorry for my bad code\nyou can change INTERP_TECHNIQUE in Common and GRAD_METHOD in Image to get different kinds of results", "tags": ["sdf", "shape", "repeat"], "likes": 20, "viewed": 265, "published": 3, "date": "1688542059", "time_retrieved": "2024-07-30T17:45:53.162268", "image_code": "#define rep1 0.7\n#define rep2 0.5\n#define rep rep1 + rep2\n#define r1 rep1 / 3.\n#define r2 rep2 / 3.\n\n#define PI 3.14159265359\n#define GRAD_METHOD 0\n\n// === customizable functions ===\n\n// HACK: as long as this shortly returns max/min\n// after a small positive value, nothing will visually break :)\nfloat fromsd(float x){\n#if GRAD_METHOD == 0\n    // normal\n    return smoothstep(0.02, 0.0, x);\n#elif GRAD_METHOD == 1\n    // hole\n    return smoothstep(-0.02, 0.0, x) * smoothstep(0.02, 0.0, x);\n#elif GRAD_METHOD == 2\n    // pyramid\n    return (1. - smoothstep(-0.01, 0.01, sin(20.*2.*PI*(x)))) * smoothstep(0.02, 0.0, x);\n#elif GRAD_METHOD == 3\n    // don't know how to describe this\n    return smoothstep(0.02, 0., x) + sin(20.*PI*clamp(x,-.1,.1))*abs(1./(10.*PI*x));\n#else\n    // neon, i guess\n    return clamp(0.03/max(0., x + 0.03)-0.34, 0., 1.);\n#endif\n}\n\nvec4 getcol(vec2 pos){\n    vec2 posdiff = vec2(0.25 * sin(iTime / 5.), 0.0);\n    return vec4(vec3(1.0, 0.0, 0.0) * (1. - length(pos + posdiff))\n                + vec3(0.0, 1.0, 0.0) * (1. - length(pos))\n                + vec3(0.0, 0.0, 1.0) * (1. - length(pos - posdiff)), 1.0);\n}\n\n// === main driver, for rotation and such ===\n#define halfsqrt2 0.70710678118\n#define scale 2.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= scale;\n    \n    // 45deg\n    mat2 invrot = mat2(halfsqrt2, -halfsqrt2, halfsqrt2, halfsqrt2);\n    mat2 rot    = mat2(halfsqrt2, halfsqrt2, -halfsqrt2, halfsqrt2);\n    uv = invrot * uv;\n    \n    vec2 uv_part = uv;\n    uv_part.y = mod(uv_part.y, rep);\n    vec2 uv_pos = uv - uv_part;\n    \n    float dx1 = iTime / 4.0;\n    float dx2 = iTime / 2.0;\n    vec2 cent1 = vec2(repCenter(rep1, uv_part.x - dx1) + dx1, rep1 / 2.0) + uv_pos;\n    vec2 cent2 = vec2(repCenter(rep2, uv_part.x - dx2) + dx2, rep1 + rep2 / 2.0) + uv_pos;\n    float intr1 = smoothstep(-0.3, 0.3, sin(-cent1.x * .4 + iTime));\n    float intr2 = smoothstep(0.3, -0.3, sin(-cent2.x * .2 + iTime));\n    float sd1 = sdInterpRep(rep1, r1, uv_part - vec2(dx1, rep1 / 2.0), intr1);\n    float sd2 = sdInterpRep(rep2, r2, uv_part - vec2(dx2, rep1 + rep2 / 2.0), intr2);\n    cent1 /= scale;\n    cent2 /= scale;\n    \n    cent1 = rot * cent1;\n    cent2 = rot * cent2;\n    \n    fragColor = getcol(cent1) * fromsd(sd1) + getcol(cent2) * fromsd(sd2);\n}", "image_inputs": [], "common_code": "#define INTERP_TECHNIQUE 1\n\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdSquare(float r, vec2 pos){\n    vec2 d = abs(pos) - r;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\nfloat sdCirc(float r, vec2 pos){\n    return length(pos) - r;\n}\n\nfloat sdInterp(float r, vec2 pos, float interp){\n    float interp_c = clamp(interp, 0.0, 1.0);\n#if INTERP_TECHNIQUE == 0\n    // directly interpolating the SDFs\n    return sdSquare(r, pos) * interp_c + sdCirc(r, pos) * (1. - interp_c);\n#else\n    // interpolate the square radius instead\n    return sdSquare(r * (1. - interp_c), pos) - r * interp_c;\n#endif\n}\n\n// Infinite.\n// The reason why I modulo'd everything is because the sd functions kind of\n// clash into each other.\n// Reasonable if rep > 2 * r.\nfloat sdInterpRep(float rep, float r, vec2 pos, float interp) {\n    vec2 pos_2 = vec2(mod(pos.x + rep / 2.0, rep) - rep / 2.0, pos.y);\n    return sdInterp(r, pos_2, interp);\n}\n\nfloat repCenter(float r, float x) {\n    return round(x / r) * r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 297, 319, 319, 857], [859, 859, 881, 881, 1139], [1237, 1237, 1294, 1294, 2401]], "test": "untested"}
{"id": "dssBz4", "name": "Sleepyhead", "author": "BakingBeans", "description": "sleepyhead vibes", "tags": ["wave"], "likes": 1, "viewed": 137, "published": 3, "date": "1688540909", "time_retrieved": "2024-07-30T17:45:54.005015", "image_code": "vec3 palette(float t) {\n  vec3 a = vec3(0.5, 0.5, 0.5);\n  vec3 b = vec3(0.75, 0.5, 0.5);\n  vec3 c = vec3(1.0, 0.55, 0.60);\n  vec3 d = vec3(0.8, 0.333, 0.667);\n\n  return a + b * cos(6.28318 / iTime - (c + t - d));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv * (iTime - 5.0 / uv.yx);\n    vec3 fCol = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        float d = length(uv + (0.1 / iTime));\n        \n        d = sin(d * 8.0 + iTime) / 8.0;\n        d *= cos(5.0 / iTime);\n        d *= sin(iTime * 0.02);\n        uv.y -= d + cos(iTime * 0.15); // Up/Down\n        uv.x /= iResolution.y + sin(iTime / d + uv.y); // Left/Right\n        \n        d = abs(d) / 0.2;\n        // Time varying pixel color\n        vec3 col = palette(length(uv0) + iTime * 4.0);\n        d = 0.2 * d;\n        \n        col *= d;\n        fCol += col - d;\n    }\n    \n    uv += (iTime * uv.x) + (iTime - uv.y);\n    \n    // Apply audio data from channel 1\n    vec2 audioUV = vec2(iTime * 0.2, iTime + 0.3); // Adjust the scaling factor as needed\n    float audioData = texture(iChannel0, audioUV - (iTime + .2)).r;\n    fCol *= audioData + iTime * .5;\n    \n    // Apply fractal coloring\n    fCol *= (0.5 - 0.25) /iTime + sin(fCol / (iTime - 2.0) + vec3(0.0, 3.0, 4.0));\n    \n    // Output to screen\n    fragColor = vec4(fCol, 1.0);\n}\n", "image_inputs": [{"id": 33887, "src": "https://soundcloud.com/ovcmusic/sleepyhead-redo?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 214], [217, 217, 272, 322, 1453]], "test": "untested"}
{"id": "DslfR4", "name": "Brown-Conrady Lens Distortion", "author": "KartaVR", "description": "License:\n- GPL v3\n\nBased Upon:\n- aleklesovoi CRT TV Shader Shadertoy Example (https://www.shadertoy.com/view/DldXWS)\n- Blender Tracking Brown-Conrady Distortion Model (https://archive.blender.org/developer/D9037)", "tags": ["distortion", "lens", "opencv"], "likes": 4, "viewed": 493, "published": 3, "date": "1688516754", "time_retrieved": "2024-07-30T17:45:54.838786", "image_code": "// Brown-Conrady Lens Distortion\n\n// Open-Source License:\n// GPL v3\n\n// Fragment Shader Based Upon:\n// aleklesovoi's \"CRT TV Shader\" Shadertoy Example (https://www.shadertoy.com/view/DldXWS)\n\n// Blender Tracking Brown-Conrady Distortion Model \"ApplyBrownDistortionModel()\" function in \"rna_tracking.c\"\n// https://archive.blender.org/developer/D9037\n\nvec2 BrownConradyDistortion(in vec2 uv)\n{\n    // Radial Distortion\n    float k1 = 0.3;\n    float k2 = 0.1;\n    float k3 = 0.0;\n    float k4 = 0.0;\n\n    // Tangential Distortion\n    float p1 = 0.0;\n    float p2 = 0.0;\n\n    // Brown Conrady uses UV coordinates with a [-1:1] range\n    uv = (uv * 2.0) - 1.0;\n\n    // Compute the distortion\n    float x2 = uv.x * uv.x;\n    float y2 = uv.y * uv.y;\n\n    float xy2 = uv.x * uv.y;\n    float r2 = x2 + y2;\n\n    float r_coeff = 1.0 + (((k4 * r2 + k3) * r2 + k2) * r2 + k1) * r2;\n    float tx = p1 * (r2 + (2.0 * x2)) + (p2 * xy2);\n    float ty = p2 * (r2 + (2.0 * y2)) + (p1 * xy2);\n\n    uv.x *= r_coeff + tx;\n    uv.y *= r_coeff + ty;\n\n    // Transform the UV coordinates back to a [0:1] range\n    uv = (uv * 0.5) + 0.5;\n\n    // Use the distortion parameter as a scaling factor to keep the image resized as close as possible to the actual viewport dimensions\n    float scale = abs(k1) < 1.0 ? 1.0 - abs(k1) : 1.0 / (k1 + 1.0);\n\n    // Scale the image from center\n    uv = (uv * scale) - (scale * 0.5) + 0.5;\n\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Use a \"Screen Space\" UV Coordinate [0;1] range\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Apply the lens distortion\n    uv = BrownConradyDistortion(uv);\n    vec3 result = texture(iChannel0, uv).rgb;\n\n    // Return the final output\n    fragColor = vec4(result, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslfR4.jpg", "access": "api", "license": "free-unknown", "functions": [[350, 350, 391, 416, 1416], [1418, 1418, 1473, 1527, 1758]], "test": "untested"}
{"id": "mslBRr", "name": "FBM Sphere (raycasting)", "author": "jsulpis", "description": "Sphere using raycasting and fbm noise from a texture.\n\nOther version using raymarching and procedural noise : https://www.shadertoy.com/view/ddsBRr", "tags": ["raycasting", "fbm"], "likes": 5, "viewed": 222, "published": 3, "date": "1688509150", "time_retrieved": "2024-07-30T17:45:55.698487", "image_code": "// FBM Sphere (raycasting) by Julien Sulpis (https://twitter.com/jsulpis)\n// https://www.shadertoy.com/view/mslBRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Sphere params\n#define SPHERE_POSITION vec3(0, 1, 6)\n#define SPHERE_RADIUS 2.\n#define NOISE_STRENGTH .5\n#define ROTATION_SPEED .1\n\n// Ray casting\n#define INFINITY 1e10\n\n//===============================================//\n//  Generic utilities stolen from smarter people //\n//===============================================//\n\n// https://iquilezles.org/articles/intersectors/\n// sphere of size ra centered at point ce\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra ) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return INFINITY; // no intersection\n    return -b - sqrt(h);\n}\n\nfloat noise(vec3 p) {\n    return texture(iChannel0, p * .05).r;\n}\n\n// Comes from a course by SimonDev (https://www.youtube.com/channel/UCEwhtpXrg5MmwlH04ANpL8A)\n// https://simondev.teachable.com/p/glsl-shaders-from-scratch\nfloat fbm(vec3 p, int octaves, float persistence, float lacunarity, float exponentiation) {\n  float amplitude = 0.5;\n  float frequency = 2.0;\n  float total = 0.0;\n  float normalization = 0.0;\n\n  for(int i = 0; i < octaves; ++i) {\n    float noiseValue = noise(p * frequency);\n    total += noiseValue * amplitude;\n    normalization += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n\n  total /= normalization;\n  total = total * 0.8 + 0.1;\n  total = pow(total, exponentiation);\n\n  return total;\n}\n\n// Inigo Quilez - https://www.shadertoy.com/view/4djSDy\nfloat sphOcclusion(in vec3 pos, in vec3 nor, in vec3 origin, in float radius) {\n  vec3 di = origin - pos;\n  float l = length(di);\n  float nl = dot(nor, di / l);\n  float h = l / radius;\n  float h2 = h * h;\n  float k2 = 1.0 - h2 * nl * nl;\n\n  // above/below horizon\n  // EXACT: Quilez - https://iquilezles.org/articles/sphereao\n  float res = max(0.0, nl) / h2;\n\n  // intersecting horizon \n  if(k2 > 0.001) {\n    // EXACT : Lagarde/de Rousiers - https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    res = nl * acos(-nl * sqrt((h2 - 1.0) / (1.0 - nl * nl))) - sqrt(k2 * (h2 - 1.0));\n    res = res / h2 + atan(sqrt(k2 / (h2 - 1.0)));\n    res /= 3.141593;\n  }\n\n  return res;\n}\n\nmat3 rotateY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(//\n    vec3(c, 0, s),//\n    vec3(0, 1, 0),//\n    vec3(-s, 0, c)//\n  );\n}\n\n//================//\n//  Project code  //\n//================//\n\nfloat fbmSphereDist(in vec3 ro, in vec3 rd) {\n    float smoothSphereDist = sphIntersect(ro, rd, SPHERE_POSITION, SPHERE_RADIUS);\n\n    vec3 intersection = ro + smoothSphereDist * rd;\n    \n    float fresnel = clamp(dot(rd, SPHERE_POSITION - intersection), 0., 1.);\n\n    vec3 intersectionWithRotation = (intersection - SPHERE_POSITION) * rotateY(iTime * ROTATION_SPEED) + SPHERE_POSITION;\n    float noise = fbm(intersectionWithRotation, 6, .5, 2., 4.5) * NOISE_STRENGTH * fresnel;\n\n\n  return sphIntersect(ro, rd, SPHERE_POSITION, SPHERE_RADIUS + noise);\n}\n\n\nvec3 getNormal(vec3 p) {\n  vec3 rd = SPHERE_POSITION - p;\n  float dist = fbmSphereDist(p, rd);\n  vec2 e = vec2(.001, 0);\n\n  vec3 normal = dist - vec3(\n    fbmSphereDist(p - e.xyy, rd), \n    fbmSphereDist(p - e.yxy, rd), \n    fbmSphereDist(p + e.yyx, rd)\n  );\n  return normalize(normal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord / iResolution.xy - 0.5) * iResolution.xy / iResolution.y;\n\n  vec3 ro = vec3(0, 1, 0);\n  vec3 rd = normalize(vec3(uv, 1));\n\n  // background\n  vec3 color = vec3(0.01);\n\n  // sphere\n  float distance = fbmSphereDist(ro, rd);\n  vec3 position = ro + rd * distance;\n  float backgroundMask = step(INFINITY, distance);\n\n  float sphereAO = sphOcclusion(position, getNormal(position), SPHERE_POSITION, SPHERE_RADIUS);\n  vec3 sphereColor = vec3(sphereAO);\n\n  color = mix(color, sphereColor, 1.0 - backgroundMask);\n\n  // gamma\n  color = pow(color, vec3(1.0 / 2.2));\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslBRr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[530, 621, 689, 689, 880], [882, 882, 903, 903, 947], [949, 1105, 1196, 1196, 1624], [1626, 1682, 1761, 1761, 2395], [2397, 2397, 2424, 2424, 2559], [2625, 2625, 2670, 2670, 3177], [3180, 3180, 3204, 3204, 3468], [3470, 3470, 3525, 3525, 4136]], "test": "untested"}
{"id": "ddsBRr", "name": "FBM Sphere (raymarching)", "author": "jsulpis", "description": "Sphere using raymarching and procedural fbm noise.\n\nFaster version using raycasting and texture noise : https://www.shadertoy.com/view/mslBRr", "tags": ["raymarching", "fbm"], "likes": 5, "viewed": 250, "published": 3, "date": "1688509145", "time_retrieved": "2024-07-30T17:45:56.514306", "image_code": "// FBM Sphere (raymarching) by Julien Sulpis (https://twitter.com/jsulpis)\n// https://www.shadertoy.com/view/ddsBRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Sphere params\n#define SPHERE_POSITION vec3(0, 1, 6)\n#define SPHERE_RADIUS 2.\n#define NOISE_STRENGTH .5\n#define ROTATION_SPEED .1\n\n// Ray marching params\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//===============================================//\n//  Generic utilities stolen from smarter people //\n//===============================================//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\n// https://github.com/yiwenl/glsl-fbm/blob/master/3d.glsl\nfloat noise(vec3 p) {\n  vec3 a = floor(p);\n  vec3 d = p - a;\n  d = d * d * (3.0 - 2.0 * d);\n\n  vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n  vec4 k1 = permute(b.xyxy);\n  vec4 k2 = permute(k1.xyxy + b.zzww);\n\n  vec4 c = k2 + a.zzzz;\n  vec4 k3 = permute(c);\n  vec4 k4 = permute(c + 1.0);\n\n  vec4 o1 = fract(k3 * (1.0 / 41.0));\n  vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n  vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n  vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n  return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// Comes from a course by SimonDev (https://www.youtube.com/channel/UCEwhtpXrg5MmwlH04ANpL8A)\n// https://simondev.teachable.com/p/glsl-shaders-from-scratch\nfloat fbm(vec3 p, int octaves, float persistence, float lacunarity, float exponentiation) {\n  float amplitude = 0.5;\n  float frequency = 2.0;\n  float total = 0.0;\n  float normalization = 0.0;\n\n  for(int i = 0; i < octaves; ++i) {\n    float noiseValue = noise(p * frequency);\n    total += noiseValue * amplitude;\n    normalization += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n\n  total /= normalization;\n  total = total * 0.8 + 0.1;\n  total = pow(total, exponentiation);\n\n  return total;\n}\n\n// Inigo Quilez - https://www.shadertoy.com/view/4djSDy\nfloat sphOcclusion(in vec3 pos, in vec3 nor, in vec3 origin, in float radius) {\n  vec3 di = origin - pos;\n  float l = length(di);\n  float nl = dot(nor, di / l);\n  float h = l / radius;\n  float h2 = h * h;\n  float k2 = 1.0 - h2 * nl * nl;\n\n  // above/below horizon\n  // EXACT: Quilez - https://iquilezles.org/articles/sphereao\n  float res = max(0.0, nl) / h2;\n\n  // intersecting horizon \n  if(k2 > 0.001) {\n    // EXACT : Lagarde/de Rousiers - https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    res = nl * acos(-nl * sqrt((h2 - 1.0) / (1.0 - nl * nl))) - sqrt(k2 * (h2 - 1.0));\n    res = res / h2 + atan(sqrt(k2 / (h2 - 1.0)));\n    res /= 3.141593;\n  }\n\n  return res;\n}\n\nmat3 rotateY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(//\n    vec3(c, 0, s),//\n    vec3(0, 1, 0),//\n    vec3(-s, 0, c)//\n  );\n}\n\n//================//\n//  Project code  //\n//================//\n\n/**\n* Standard SDF function for a sphere but with fbm noise added on the radius\n*/\nfloat sphereSDF(vec3 p) {\n  vec3 position = (p - SPHERE_POSITION) * rotateY(iTime * ROTATION_SPEED) + SPHERE_POSITION;\n  float noise = fbm(position, 6, .5, 2., 4.) * NOISE_STRENGTH;\n\n  return length(position - SPHERE_POSITION) - (SPHERE_RADIUS + noise);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.;\n\n  for(int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    float dS = sphereSDF(p);\n    dO += dS;\n    if(dO > MAX_DIST || dS < SURF_DIST)\n      break;\n  }\n  return dO;\n}\n\nvec3 getNormal(vec3 p) {\n  float dist = sphereSDF(p);\n  vec2 e = vec2(.001, 0);\n\n  vec3 normal = dist - vec3(\n    sphereSDF(p - e.xyy), \n    sphereSDF(p - e.yxy), \n    sphereSDF(p + e.yyx)\n  );\n  return normalize(normal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord / iResolution.xy - 0.5) * iResolution.xy / iResolution.y;\n\n  vec3 ro = vec3(0, 1, 0);\n  vec3 rd = normalize(vec3(uv, 1));\n\n  // background\n  vec3 color = vec3(0.01);\n\n  // sphere\n  float distance = rayMarch(ro, rd);\n  vec3 position = ro + rd * distance;\n  float backgroundMask = step(MAX_DIST, distance);\n\n  float sphereAO = sphOcclusion(position, getNormal(position), SPHERE_POSITION, SPHERE_RADIUS);\n  vec3 sphereColor = vec3(sphereAO);\n\n  color = mix(color, sphereColor, 1.0 - backgroundMask);\n\n  // gamma\n  color = pow(color, vec3(1.0 / 2.2));\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsBRr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[584, 584, 605, 605, 654], [656, 656, 678, 678, 721], [723, 781, 802, 802, 1277], [1279, 1435, 1526, 1526, 1954], [1956, 2012, 2091, 2091, 2725], [2727, 2727, 2754, 2754, 2889], [2955, 3038, 3063, 3063, 3293], [3295, 3295, 3329, 3329, 3528], [3530, 3530, 3554, 3554, 3753], [3755, 3755, 3810, 3810, 4416]], "test": "untested"}
{"id": "DdXBzN", "name": "Xpose Flag", "author": "misol101", "description": "Attempt at making a flag like in the Amiga demo Xpose by Silents.\n\nNote: you need high fps or things will look weird", "tags": ["line", "amiga", "flag", "draw", "silents", "reproduction", "xpose"], "likes": 8, "viewed": 361, "published": 3, "date": "1688498793", "time_retrieved": "2024-07-30T17:45:57.335112", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 hist = texelFetch( iChannel1, ivec2(fragCoord), 0 );\n    float val = (hist.x + hist.y + hist.z) * (0.54/3.);\n    \n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float blue = abs(uv.y) < 0.43 ? 0.15 : 0.;\n    float white = blue>0. && abs(uv.y) > 0.427 && abs(uv.x)<0.85 ? 1. : 0.;\n    \n    fragColor = vec4( white+val*0.95, white+val*0.95, white+blue+val, 1.0 );\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 37318, "src": "https://soundcloud.com/mattgrayc64/driller-2015-remake-preview", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Line draw function from https://www.shadertoy.com/view/4ljfRD by Loeizd\n\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float width)\n{\n    p1=(p1-0.5)*0.7;p2=(p2-0.5)*0.7;uv=(uv-0.5)*0.7;\n\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(width*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime * 1.5;\n\n    if (abs(uv.y-0.5) > 0.425) { fragColor=vec4(0.); return; }; // we don't draw here\n\n    const float xmstep = 0.4;\n    const float ymstep = 0.36;\n    const float xmul = 0.08;\n    const float ymul = 0.14;\n\n    const float xstart = 0.155;\n    const float ystart = 0.25;\n    \n    const float xsegments = 14.;\n    const float ysegments = 9.;\n\n    const float xstep = (1.01-xstart*2.) / (xsegments - 1.);\n    const float ystep = (0.98-ystart*2.) / (ysegments - 1.);\n\n    float tm=time*0.275;\n    vec2 cp = vec2(xstart, ystart);\n    \n    const float xtmul = 2.;\n    const float ytmul = 2.1;\n    \n    const float linesize = 0.8;\n    \n    float lines= 0.;\n    for (float y=0.; y<ysegments; y+=1.) {\n        float stx = xmstep+time*xtmul+ymstep*y;\n        float sty = xmstep+time*ytmul+ymstep*(y+1.);\n        vec2 lastp= vec2(-1.);\n        for (float x=0.; x<xsegments; x+=1.) {\n            vec2 p1 = vec2(cp.x+sin(stx)*xmul,cp.y+cos(sty+tm)*ymul);\n            if (lastp.x >= 0.) lines += drawLine(lastp, p1, uv, linesize);\n            if (y < ysegments - 1.) lines += drawLine(p1, vec2(cp.x+sin(stx+ymstep)*xmul, cp.y+ystep+cos(sty+ymstep+tm)*ymul), uv, linesize);\n\n            lastp = p1;\n            cp.x += xstep;\n            stx += xmstep;\n            sty += xmstep;\n        }\n        cp = vec2(xstart, cp.y + ystep);\n    }\n\n    fragColor = vec4(clamp(lines, 0.,1.));\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 O, vec2 F) {\n    vec4 curr = texelFetch(iChannel0, ivec2(F), 0);\n    curr[iFrame % 3] = texelFetch(iChannel1, ivec2(F) ,0).x;\n    O = curr;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXBzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 479]], "test": "untested"}
{"id": "csfBRN", "name": "Menger sphere", "author": "Moumouke", "description": "Code is a bit messy as it was generated by my own engine, tried to adapt it a little but got lazy.\n\nWhat you see is essentialy the intersection of a sphere and a menger sponge where the size vary over time.\n\n", "tags": ["raymarch"], "likes": 12, "viewed": 249, "published": 3, "date": "1688487405", "time_retrieved": "2024-07-30T17:45:58.097074", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI (3.14159265359)\n\nfloat c01(float p) {\n  return clamp(p, 0.0, 1.0);\n}\n\nvoid fa(inout vec3 p) {\n  p.xyz = abs(p.xyz);\n}\n\nvoid fm(inout vec3 p) {\n  float a = min(p.x - p.y, 0.0);\n  p.x -= a;\n  p.y += a;\n  a = min(p.x - p.z, 0.0);\n  p.x -= a;\n  p.z += a;\n  a = min(p.y - p.z, 0.0);\n  p.y -= a;\n  p.z += a;\n}\n\nvoid fp(inout vec3 p, vec3 n, float d) {\n  p.xyz -= 2.0 * min(0.0, dot(p.xyz, n) - d) * n;\n}\n\nvoid scale(inout vec3 p, float f) {\n  p *= f;\n}\n\nvoid rotateX(inout vec3 p, float angle) {\n  p *= mat3(\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    cos(angle),\n    -sin(angle),\n    0.0,\n    sin(angle),\n    cos(angle)\n  );\n}\n\nvoid rotateY(inout vec3 p, float angle) {\n  p *= mat3(\n    cos(angle),\n    0.0,\n    sin(angle),\n    0.0,\n    1.0,\n    0.0,\n    -sin(angle),\n    0.0,\n    cos(angle)\n  );\n}\n\nvoid rotateZ(inout vec3 p, float angle) {\n  p *= mat3(\n    cos(angle),\n    -sin(angle),\n    0.0,\n    sin(angle),\n    cos(angle),\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  );\n}\n\nvoid inverseTranslate(inout vec3 p, vec3 t) {\n  p -= t;\n}\n\nvoid rotate(inout vec3 p, vec3 angles) {\n  rotateX(p, angles.x);\n  rotateY(p, angles.y);\n  rotateZ(p, angles.z);\n}\n\nvoid translate(inout vec3 p, vec3 t) {\n  p += t;\n}\n\nstruct hitData {\n  float distance;\n  vec3 hitColor;\n  bool canReflect;\n};\n\nhitData minhitData(hitData a, hitData b) {\n  if (a.distance < b.distance) return a;\n  return b;\n}\n\nfloat sdfBox(vec3 point, vec3 size) {\n  vec3 d = abs(point) - size;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdfPlane(vec3 p) {\n  return p.y;\n}\n\nfloat sdf_mengerb5c5e786_7b59_439b_9b77_49b133c6f47e(vec3 p) {\n    vec3 t = vec3(1.5 + cos(iTime * 1.0) * 0.8, 1.0, 1.0);\n\n    for (int i = 0; i < 3; i++) {\n        fa(p);\n        fm(p);\n        scale(p, 3.0);\n        translate(\n            p,\n            t * vec3(-2.0, -2.0, 0.0)\n        );\n        fp(\n            p,\n            vec3(0.0, 0.0, -1.0),\n            t.x * -1.0\n        );\n    }\n \n\n    return sdfBox(p, vec3(1.5 + cos(iTime * 1.0) * 0.8, 1.0, 1.0)) / 27.0;\n\n}\n\nhitData sdf_sphere_7064d573_52bb_4c0f_8c8f_9d1962bfa45d(vec3 p) {\n  vec3 o = p;\n\n  hitData res;\n  hitData res2;\n  res = hitData(sdfSphere(p, 1.4) / 1.0, vec3(0.0667, 0.5843, 0.7294), false);\n\n  return res;\n\n}\n\nhitData sdf_menger_78a3d364_8ac6_4348_b521_a04e36c86545(vec3 p) {\n  vec3 o = p;\n  rotate(p, vec3(0.0, 0.0, 0.0) + cos(iTime * 0.5) * vec3(2.0, 2.0, 2.0));\n\n  hitData res;\n  hitData res2;\n  res = hitData(\n    sdf_mengerb5c5e786_7b59_439b_9b77_49b133c6f47e(p) / 1.0,\n    vec3(0.4431, 0.6627, 0.7216),\n    false\n  );\n\n  res2 = sdf_sphere_7064d573_52bb_4c0f_8c8f_9d1962bfa45d(o);\n  if (res.distance < res2.distance) res = res2;\n\n  return res;\n\n}\n\nhitData sdf_plane_c72c613d_1c9b_408b_b88a_b63bfcc53acb(vec3 p) {\n  vec3 o = p;\n  inverseTranslate(p, vec3(0.0, 0.0, 0.0));\n  translate(p, vec3(0.0, 3.0, 0.0));\n\n  hitData res;\n  hitData res2;\n  res = hitData(\n    sdfPlane(p) / 1.0,\n    mod(p.x * 3.0, 2.0) <= 1.0 ^^ mod(p.z * 3.0, 2.0) >= 1.0\n      ? vec3(0.0667, 0.0588, 0.0588)\n      : vec3(0.5059, 0.4784, 0.4784),\n    false\n  );\n\n  return res;\n\n}\n\nhitData sdf(vec3 p) {\n  hitData res = sdf_menger_78a3d364_8ac6_4348_b521_a04e36c86545(p);\n\n  res = minhitData(res, sdf_plane_c72c613d_1c9b_408b_b88a_b63bfcc53acb(p));\n\n  return res;\n}\n\nvec3 calcNormal(vec3 pos) {\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n  return normalize(\n    e.xyy * sdf(pos + e.xyy).distance +\n      e.yyx * sdf(pos + e.yyx).distance +\n      e.yxy * sdf(pos + e.yxy).distance +\n      e.xxx * sdf(pos + e.xxx).distance\n  );\n}\n\nvec3 normal(vec3 point) {\n  const vec3 smallStep = vec3(0.00001, 0, 0);\n\n  return normalize(\n    vec3(\n      sdf(point + smallStep.xyy).distance - sdf(point - smallStep.xyy).distance,\n      sdf(point + smallStep.yxy).distance - sdf(point - smallStep.yxy).distance,\n      sdf(point + smallStep.yyx).distance - sdf(point - smallStep.yyx).distance\n    )\n  );\n}\n\nhitData raymarch(vec3 rayOrigin, vec3 rayDirection) {\n  float distance = 0.0;\n  float maxDistance = 50.0;\n  float minHitDistance = 0.001;\n\n  for (int i = 0; i < 256; i++) {\n    if (distance > maxDistance) break;\n\n    vec3 pos = rayOrigin + rayDirection * distance;\n\n    hitData res = sdf(pos);\n\n    if (res.distance < minHitDistance)\n      return hitData(distance + res.distance, res.hitColor, res.canReflect);\n\n    distance += res.distance;\n  }\n\n  return hitData(-1.0, vec3(0.0), false);\n}\n\nfloat ambientOcc(vec3 point, vec3 normal) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = sdf(point + h * normal).distance;\n    occ += (h - d) * sca;\n    sca *= 0.95;\n    if (occ > 0.35) break;\n  }\n  return c01(1.0 - 3.0 * occ) * (0.5 + 0.5 * normal.y);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n  for (int i = 0; i < 256; i++) {\n    float h = sdf(ro + rd * t).distance;\n\n    if (t > tmax) return res;\n    if (h < 0.001) return 0.0;\n    res = min(res, 18.0 * h / t);\n    t += h;\n  }\n  return res;\n}\n\nvec3 spotlight(\n  vec3 rayDirection,\n  vec3 normal,\n  vec3 point,\n  vec3 baseColor,\n  vec3 lightPos,\n  vec3 lightColor,\n  float shininess\n) {\n  vec3 lightDir = normalize(lightPos - point);\n  vec3 hal = normalize(lightDir - rayDirection);\n  float diffuse = dot(normal, lightDir);\n  diffuse = c01(diffuse);\n  diffuse *= ambientOcc(point, normal);\n  diffuse *= shadow(point, lightDir, 0.02, 2.5);\n\n  float pho = c01(pow(dot(normal, hal), shininess));\n  float spe = pho * diffuse * 0.3;\n\n  return baseColor * 2.2 * diffuse * lightColor + 5.0 * spe * lightColor * 0.4;\n}\n\nvec3 lightning(\n  float distance,\n  vec3 col,\n  vec3 point,\n  vec3 rayDirection,\n  vec3 rayOrigin,\n  vec3 normal\n) {\n  vec3 newColor = col;\n\n  newColor += spotlight(\n    rayDirection,\n    normal,\n    point,\n    col,\n    vec3(10.0, 10.0, 0.0),\n    vec3(0.4, 0.8314, 0.9294),\n    32.0\n  );\n\n  newColor += spotlight(\n    rayDirection,\n    normal,\n    point,\n    col,\n    vec3(0.0 + cos(iTime * 1.0) * 1.0, 13.0, 0.0 + sin(iTime * 1.0) * 1.0),\n    vec3(0.4, 0.8314, 0.9294),\n    32.0\n  );\n\n\n  newColor /= 3.;\n  vec3 distanceColor = vec3(0.0314, 0.1373, 0.4039);\n  float distanceColorIntensity =\n    1.0 - exp(-0.0001 * distance * distance * distance);\n  return mix(newColor, vec3(0.0314, 0.1373, 0.4039), distanceColorIntensity);\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n  vec3 col = vec3(0.);\n\n  hitData hit = raymarch(rayOrigin, rayDirection);\n\n  if (hit.distance > 0.0) {\n    vec3 point = rayOrigin + rayDirection * hit.distance;\n    vec3 normal = calcNormal(point);\n    col = hit.hitColor;\n    col = lightning(hit.distance, col, point, rayDirection, rayOrigin, normal);\n  }\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime / 25.0 * 1.5;\n\n    float camspeed = 7.0;\n    vec3 ta = vec3(0.);\n    vec3 ro = vec3(\n        4.9 * cos(time * camspeed),\n        3.0,\n        4.9 * sin(time * camspeed)\n    );\n\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(sin(.0), cos(.0), 0.0)));\n    vec3 cu = normalize(cross(cs, cf));\n\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(p.x * cs + p.y * cu  + 2.5 * cf);\n\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(1.0/2.2)) ;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csfBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 94, 94, 125], [127, 127, 150, 150, 174], [176, 176, 199, 199, 360], [362, 362, 402, 402, 454], [456, 456, 491, 491, 503], [505, 505, 546, 546, 675], [677, 677, 718, 718, 847], [849, 849, 890, 890, 1019], [1021, 1021, 1066, 1066, 1078], [1080, 1080, 1120, 1120, 1194], [1196, 1196, 1234, 1234, 1246], [1323, 1323, 1365, 1365, 1420], [1422, 1422, 1459, 1459, 1557], [1559, 1559, 1593, 1593, 1619], [1621, 1621, 1645, 1645, 1661], [1663, 1663, 1725, 1725, 2137], [2139, 2139, 2204, 2204, 2347], [2349, 2349, 2414, 2414, 2790], [3194, 3194, 3215, 3215, 3377], [3379, 3379, 3406, 3406, 3643], [3645, 3645, 3670, 3670, 4002], [4004, 4004, 4057, 4057, 4494], [4496, 4496, 4539, 4539, 4833], [4835, 4835, 4891, 4891, 5131], [5133, 5133, 5274, 5274, 5698], [5700, 5700, 5816, 5816, 6427], [6429, 6429, 6477, 6477, 6801], [6803, 6803, 6860, 6860, 7425]], "test": "untested"}
{"id": "cdffz4", "name": "Colorful Zoom-o-rotors", "author": "timmaffett", "description": "Adding color (as always) and as time goes on this gets more complex and the original spiral illusion becomes even more pronounced. -tmm\nCreates a bit of an spiral illusion -@Xecutor", "tags": ["zoom", "rotation"], "likes": 6, "viewed": 210, "published": 3, "date": "1688484465", "time_retrieved": "2024-07-30T17:45:58.873997", "image_code": "// Fork of \"Zoom-o-rotors\" by Xecutor. https://shadertoy.com/view/dslBz8\n// 2023-07-04 15:24:58\n\n#define R iResolution\n#define T iTime/5.0\n\n\nvec4 hsb2rgb( in vec4 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return vec4(c.z * mix( vec3(1.0), rgb, c.y), 1.);\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    vec2 u = (p*2.0-R.xy)/R.x;\n    float l = pow(length(u),0.5);\n    float l0 = l;\n    l -= fract(T)/5.0;\n    \n    float tSlice = fract(T/100.0);\n    float invtSlice = 1.0 - tSlice;\n    \n    \n    float tt = T * sign(sin(20.0*l*acos(0.0)));\n    u *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    l = l - floor(l*10.0) / 10.0;\n    l = l > 0.01 ? pow(l, 0.15):0.0;\n    l *= l0;\n    float t = atan(u.y,u.x)/3.1415;\n    float rawt = t * 3.1415;\n    t = abs(t-floor(t*20.0)/20.0);\n    t = clamp(t,0.0,0.05)*20.0;\n    t = t>0.05?pow(t,0.15):0.0;\n    t *= 1.4;\n    o = vec4(t*l,t*l,t*l,1.0) * hsb2rgb( vec4( tSlice*rawt + invtSlice*(l0+tt+l/t), 1.0, 1.0, 1.0) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdffz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 168, 168, 411], [415, 415, 456, 456, 1114]], "test": "untested"}
{"id": "dslfzH", "name": "opOnion with bound SDF artifacts", "author": "Frizi", "description": "This shader shows how the usual union SDF operator implemented with min() produces the incorrect SDF in the interior of the shapes or exterior (if doing exterior modeling), but never produces correct distances everywhere.", "tags": ["2d", "distancefield", "sdf", "stroke", "distance", "min", "union", "onion"], "likes": 4, "viewed": 241, "published": 3, "date": "1688478495", "time_retrieved": "2024-07-30T17:45:59.638952", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader shows how the usual union SDF operator implemented\n// with min() produces the incorrect SDF in the interior of the shapes.\n// If the modeling is reversed and the exterior of the negative\n// space of the shape is modeled, then the exterior distance is wrong.\n//\n// While this is not an issue in most cases in practice, it can be\n// a problem in shaders that need to raymarch or do some other\n// distance based volumetric operations in the interior of the\n// shapes.\n//\n// This shader implements both correct interior and exterior distances\n// by modeling the boundary of the shape instead. Alternativelly, the\n// appropriate interior or exterior correct SDF could be chosen as\n// needed, but then there is double modeling work.\n//\n// More info here:\n// https://iquilezles.org/articles/interiordistance\n\n// This fork additionally contains:\n// - comparison of all three shapes side to side.\n// - visualization of \"onion\" (stroke) operator in combination, to show how it behaves with imprecise SDFs.\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 c, in vec2 b ) \n{\n    vec2 q = abs(p-c) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n              \n// correct outside, incorrect inside\nfloat sdA( in vec2 p )\n{\n    float d = sdCircle( p, vec2(-0.4, 0.3), 0.5);\n    d = min(d,sdBox( p, vec2( 0.4,-0.4), vec2(0.4,0.4) ));\n    d = min(d,sdBox( p, vec2( 0.0, 0.0), vec2(0.4,0.8) ));\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n   float d =     sdBox( p, vec2( 0.0, 2.0), vec2(5.0,1.2) );\n       d = min(d,sdBox( p, vec2( 1.2, 1.0), vec2(0.8,1.0) ));\n       d = min(d,sdBox( p, vec2( 1.4,-0.3), vec2(0.6,5.0) ));\n       d = min(d,sdBox( p, vec2( 0.0,-2.0), vec2(2.0,1.2) ));\n       d = min(d,sdBox( p, vec2(-1.2,-0.8), vec2(0.8,0.6) ));\n       d = min(d,sdBox( p, vec2(-1.5, 0.3), vec2(0.6,0.7) ));\n       d = min(d,sdCrescent( p-vec2(-0.4-1.0, 0.3), 1.1, 0.5, 1.0, 1.0, -1.0 ));\n    return -d;\n}\n\n// correct both in side and outside\nfloat sdC( in vec2 p )\n{\n\tint kType[] = int[](0,0,0,0,0,0,1);\n\tfloat kPath[] = float[](-0.4, 0.8,\n                             0.4, 0.8,\n                             0.4,-0.0,\n                             0.8,-0.0,\n                             0.8,-0.8,\n                            -0.4,-0.8,\n                            -0.4,-0.2, 0.0,\n                            -0.4, 0.8 );\n    return sdShape(p,kType,kPath );\n}\n\nfloat opOnion( in float d, in float r )\n{\n  return abs(d) - r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // split screen horizontally into 3 parts.\n    int numSplitScreens = 3;\n    vec2 splitRes = vec2(iResolution.x / float(numSplitScreens), iResolution.y);\n    int splitScreenIdx = int(floor(fragCoord.x / splitRes.x));\n    vec2 splitCoord = vec2(fragCoord.x - float(splitScreenIdx) * splitRes.x, fragCoord.y);\n    vec2 splitMouseCoord = vec2(iMouse.x - float(splitScreenIdx) * splitRes.x, iMouse.y);\n    fragColor = vec4(splitCoord/splitRes.x, 0.0, 1.0);\n    \n    // normalized pixel coordinates within given split screen\n    vec2 p = (splitCoord*2.0-splitRes.xy)/min(splitRes.y, splitRes.x);\n    vec2 m = (splitMouseCoord*2.0-splitRes.xy)/min(splitRes.y, splitRes.x);\n\n    p *= 1.3; // zoom out\n    m *= 1.3;\n    \n    // distance computations:\n    // render each distance at different part of the screen.\n    float d;\n    switch (splitScreenIdx) {\n        case 0: d = sdA(p); break; // interior modeling (exact only inside)\n        case 1: d = sdC(p); break; // boundary modeling (exact everywhere)\n        case 2: d = sdB(p); break; // exterior modeling (exact only outside)\n    }\n\n    float onionMix = smoothstep(0.0, 1.0, clamp(0.5 + sin(iTime * 0.5 - 0.4) * 3.0, 0.0, 1.0));\n    float onionMixSdf = float(onionMix > 0.0);\n    \n    float strokeWidth = 0.15 + 0.05 * sin(iTime);\n    strokeWidth *= onionMix;\n    d = mix(d, opOnion(d, strokeWidth), onionMixSdf);\n    \n    \n    // coloring\n    vec3 col = (d<0.0) ? vec3(0.6,0.2,1.0) : vec3(0.9,0.1,0.3);\n    col *= 1.0 - exp(-9.0*abs(d));\n\tcol *= 1.0 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    \n    int mouseScreenIdx = int(floor(iMouse.x / splitRes.x));\n    if( iMouse.z>0.001 && mouseScreenIdx == splitScreenIdx)\n    {\n        switch (splitScreenIdx) {\n            case 0: d = sdA(m); break;\n            case 1: d = sdC(m); break;\n            case 2: d = sdB(m); break;\n        }\n        d = mix(d, opOnion(d, strokeWidth), onionMixSdf);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    float divLine = pow(abs(fract(fragCoord.x / splitRes.x) * 2.0 - 1.0), 300.0);\n    divLine *= 1.0 - clamp(abs(fragCoord.x - iResolution.x * 0.5) - iResolution.x * 0.5 + 10.0, 0.0, 1.0);\n    \n    col = mix(col, vec3(1.0,1.0,1.0), divLine);\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslfzH.jpg", "access": "api", "license": "mit", "functions": [[2091, 2091, 2116, 2116, 2135], [2136, 2136, 2163, 2163, 2190], [2192, 2243, 2295, 2295, 2325], [2327, 2378, 2427, 2427, 2511], [2513, 2564, 2614, 2614, 2747], [2749, 2749, 2830, 2830, 3265], [3267, 3318, 3392, 3392, 3771], [3840, 3894, 3953, 3953, 4718], [4734, 4771, 4795, 4795, 4979], [4981, 5018, 5042, 5042, 5511], [5966, 5966, 6007, 6007, 6030], [6033, 6033, 6090, 6137, 8525]], "test": "untested"}
{"id": "mssfR8", "name": "Year of Truchets #046", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! \n\nMouse click to see grid", "tags": ["2d", "mod", "truchet", "pattern", "tile"], "likes": 17, "viewed": 224, "published": 3, "date": "1688468553", "time_retrieved": "2024-07-30T17:46:00.435821", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #046\n    07/04/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    50.\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat scale = 8.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(.005);\n    vec2 vv = uv;\n    \n    //split screen\n\n    if(vv.x>-.3) {\n        uv = uv-vec2(.3535,0);\n        uv.x -= .25;\n        uv /= uv.x*uv.x + uv.y*uv.y;\n        uv.x += 2.;\n\n        uv *= rot(-T*.11);\n        uv = vec2(log(length(uv)), atan(uv.y, uv.x))*.6365;//.3175\n    }else{\n        uv = uv+vec2(.635,0);\n        uv *= rot(-T*.11);\n        uv = vec2(log(length(uv)), atan(uv.y, uv.x))*.6365;//.3175\n    }\n\n    uv.x -= T*.15;\n    \n    float px = fwidth(uv.x)*PI2;\n    \n    vec2 id=floor(uv*scale);\n    float ck=mod(id.x+id.y,2.)*2.-1.;\n    //using mod on the id's to skip sections\n    //or replace with horz/vert lines to increase\n    //the visual space. Click mouse to see grid.\n    \n    //mod vars to mix things up\n    float m = floor(mod(T*.085+id.y,5.)+1.);//1.75;//\n    float n = floor(mod(T*.1+id.x,6.)+1.);//2.15;//\n    //mod for long slices\n    vec2 cd=vec2(mod(id.x,n),mod(id.y,m))*2.-1.;\n\n    uv=fract(uv*scale)-.5;\n    \n    float hs = hash21(id);\n    if(hs>.5) uv.x=-uv.x;\n    \n    float rd = fract(hs*37.39);\n    \n    vec2 p = length(uv-.5) < length(uv+.5) ? uv-.5 : uv+.5;\n    \n    float d = length(p)-.5;\n    float l = abs(max(abs(uv.x),abs(uv.y))-.5)-.01;\n    \n    if(rd>.85) d = min(length(uv.x),length(uv.y));\n    //skip section logic\n    if(cd.x>.5 ) d = length(uv.y);\n    if(cd.y>.5 ) d = length(uv.x);\n    if(cd.y>.5 && cd.x>.5) d = 1.;\n    \n    C = mix(C,vec3(0,.9,.1),smoothstep(px,-px,abs(d)-.15));\n    C = mix(C,vec3(.4,0,.9),smoothstep(px,-px,abs(abs(d)-.35)-.1));\n    \n    if(M.z>0.) C = mix(C,vec3(.1),smoothstep(px,-px,l));\n    if(vv.x<-.3&&vv.x>-.305) C = vec3(0,.9,.1);\n    \n    // Gamma & Output\n    C = pow(C,vec3(.4545));\n    fragColor = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssfR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[375, 375, 396, 396, 451], [452, 452, 470, 470, 514], [534, 534, 591, 591, 2354]], "test": "untested"}
{"id": "dssfR8", "name": "water direction", "author": "tianluo970922", "description": "water direction", "tags": ["waterdirection"], "likes": 0, "viewed": 197, "published": 3, "date": "1688468066", "time_retrieved": "2024-07-30T17:46:01.195789", "image_code": "// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\n// :)\n// by David Hoskins.\n// Original water turbulence effect by joltz0r\n\n\n// Redefine below to see the tiling...\n//#define SHOW_TILING\nconst vec2 target_resolution = vec2(940, 86);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5 + 23.0;\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5; \n    \n    vec2 uv0 = uv; \n    uv0.x *= 3.;\n    //uv0.x += iTime * 0.3;\n    uv0.y *= 1.;\n    uv0.y -= iTime * 0.1;\n  \n    \n    vec2 p = mod(uv0*TAU, TAU) - 250.0;\n    \n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .009;\n    \n    //通过算法测算出water的pattern，通过增大tiling的值可以增大pattern的密度\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (2.5/ float(n+1)));\n        float t1= time * .2;\n\t\ti = p + vec2(cos(t1 - i.x) + sin(t + i.y), sin(t - i.y) + cos(t1 + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+ t1)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(MAX_ITER);\n    \n    //1.12 可以调整白色的对比度，数值越高，对比度越高\n    //1. 1可以调整蓝色的深浅,数值越高，蓝色越浅，白色越多且会过曝\n\tc = 1.2 - pow(c, 1.1);\n    \n    //7.5可以调整蓝色的深浅，数值越高，蓝色越深，但不会影响白色的细节\n\tvec3 colour = vec3(pow(abs(c), 10.5));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    \n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n    float timeMotion = smoothstep(0.0, 1.0, sin(iTime) * 0.5 + 0.5 + sin(iTime * 0.2) * 0.5);\n    //float timeMotion = sin(iTime) * 0.5 + 0.5;\n    \n    //headColor\n    vec3 headColor = vec3(1.000,1.000,1.000); \n\t//headColor *= pow(uv.y,  3.5) ; //起始\n    //headColor *= pow(uv.y,  10.5) ; //结束\n    headColor *= pow(uv.y, mix(3.5, 10.5, timeMotion));\n    colour *= mix(1.0, 0.8, timeMotion);\n    fragColor = vec4(colour + headColor, 1.0);\n    \n    //endColor\n    vec3 endColor = vec3(0.000,0.118,0.200); \n    float endColorMask1 = smoothstep(0.0, 0.2,uv.y);\n    float endColorMask2 = smoothstep(0.1, 0.9,uv.y);\n    //fragColor.rgb = mix(endColor, fragColor.rgb, endColorMask1); //起始\n    //fragColor.rgb = mix(endColor, fragColor.rgb, endColorMask2); //结束\n    fragColor.rgb = mix(endColor, fragColor.rgb, mix(endColorMask1,endColorMask2, timeMotion));\n    \n    //结尾的mask\n    float mask = pow(uv.y, 1.0);\n    //0.492的值越小，黑色边缘越硬\n    mask = smoothstep(0.0,0.472,uv.y);\n    \n    //fragColor *= (mask);\n    //fragColor = vec4(endColor, 1.0);\n    //fragColor = vec4(mask);\n    \n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 381, 381, 3547]], "test": "untested"}
{"id": "dsfBRr", "name": "SDF Teapot", "author": "KZubatov", "description": "Homework 1", "tags": ["test"], "likes": 6, "viewed": 190, "published": 3, "date": "1688462305", "time_retrieved": "2024-07-30T17:46:01.960744", "image_code": "#define DIZERING 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    #if DIZERING\n        fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n    #else\n        fragColor = texture(iChannel0, uv);\n    #endif\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define DIZERING 1\n#define MAX_STEPS 300\nconst float PI = 3.14159265359;    \n\nconst vec3 lightPos   = vec3(2, 2, 1);\nconst vec4 lightColor = vec4(1.5, 1, 1, 1) * .7;\n\nconst vec4 ambientColor = vec4(1, 1, 1, 1) * 0.1;\n\nconst float MAX_DIST = 6.0;\nconst float EPS = 0.001;\n\nmat3 rotationX(float a) {\n    return mat3(1, 0, 0,\n                0, cos(a), -sin(a),\n                0, sin(a), cos(a));\n}\n\nmat3 rotationY(float a) {\n    return mat3(cos(a), 0, sin(a),\n            0, 1, 0,\n            -sin(a), 0, cos(a));\n}\n\nmat3 rotationZ(float a) {\n    return mat3(cos(a), -sin(a), 0,\n            sin(a), cos(a), 0,\n            0, 0, 1);\n}\n\nfloat smoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h); \n}\n\nfloat smoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h); \n}\n\nfloat smoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h); \n}\n\nfloat rand(float frame) {\n    return fract(sin(dot(vec3(frame), vec3(12.9898,78.233,45.5432))) * 43758.5453);\n}\n\nfloat sdf_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdf_capped_cone(vec3 p, float h, float r1, float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, q.y < 0.0 ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdf_torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdf_cut_sphere(vec3 p, float r, float h) {\n    float w = sqrt(r * r - h * h);\n    vec2 q = vec2(length(p.xz), p.y);\n    float s = max((h - r) * q.x * q.x + w * w * (h + r - 2.0 * q.y), h * q.x - w * q.y);\n    return s < 0.0 ? length(q) - r : q.x < w ? h - q.y : length(q - vec2(w, h));\n}\n\nfloat sdf_cylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r,h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat length_n(vec2 t, float n) {\n    return pow(pow(abs(t.x), n) + pow(abs(t.y), n), 1.0 / n);\n}\n\nfloat sdf_torus(vec3 p, vec2 t, float n, float m) {\n    vec2 q = vec2(length_n(p.xz, n) - t.x, p.y);\n    return length_n(q, m) - t.y;\n}\n\nfloat sdf_round_cone(vec3 p, float r1, float r2, float h) {\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if (k < 0.0) \n        return length(q) - r1;\n    if (k > a * h) \n        return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a,b)) - r1;\n}\n\nfloat sdf_plane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdf(vec3 p) {\n    float dTorus = sdf_torus(p - vec3(0, 0.2, 0), vec2(0.31, 0.02));\n    float dCappedCone = sdf_capped_cone(p, 0.2, 0.5, 0.35);\n    float dCutSphereUp = sdf_cut_sphere(p + vec3(0, 0.55, 0), 0.8, 0.75);\n    float subtraction1 = smoothSubtraction(dTorus, dCappedCone, 0.02);\n    float union1 = smoothUnion(subtraction1, dCutSphereUp, 0.03);\n    float dCutSphereDown = sdf_cut_sphere(p * vec3(1, -1, 1), sqrt(0.29), 0.2);\n    float union2 = min(union1, dCutSphereDown);\n    float dInvisibleCylinder = sdf_cylinder(p + vec3(0, sqrt(0.29) - 0.05, 0), 0.19, 0.45);\n    float subtraction2 = max(union2, -dInvisibleCylinder);\n    float dVisibleCylinder = sdf_cylinder(p + vec3(0, sqrt(0.29) - 0.22, 0), 0.01, 0.45);\n    float union3 = smoothUnion(subtraction2, dVisibleCylinder, 0.03);\n    float dTorus42 = sdf_torus((p - vec3(0, 0.22, 0)) * rotationX(PI / 2.0), vec2(0.1, 0.02), 4.0, 2.0);\n    float union4 = smoothUnion(union3, dTorus42, 0.03);\n    float dTorus24 = sdf_torus((p + vec3(0.5, 0, 0)) * rotationX(PI / 2.0), vec2(0.14, 0.035), 2.0, 4.0);  \n    float union5 = smoothUnion(union4, dTorus24, 0.05);\n    float dRoundCone = sdf_round_cone(rotationZ(-PI / 4.0) * (p - vec3(0.46, -0.1, 0)), 0.1, 0.04, 0.35);\n    float union6 = smoothUnion(union5, dRoundCone, 0.05);\n    float dInvisibleSphere = sdf_sphere(p, vec3(0.73, 0.17, 0), 0.025);\n    float subtraction3 = smoothSubtraction(dInvisibleSphere, union6, 0.03);\n    float dPlane = sdf_plane(p, vec3(0, 1, 0), 0.34);\n    return min(subtraction3, dPlane);\n}\n\nvec3 generateNormal(vec3 p) {\n    float dx1 = sdf(p + vec3(EPS, 0, 0));\n    float dx2 = sdf(p - vec3(EPS, 0, 0));\n    float dy1 = sdf(p + vec3(0, EPS, 0));\n    float dy2 = sdf(p - vec3(0, EPS, 0));\n    float dz1 = sdf(p + vec3(0, 0, EPS));\n    float dz2 = sdf(p - vec3(0, 0, EPS));\n    \n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 normal) {\n    const float stepSize = 0.03;\n    \n    float occ = 0.0;\n    float sca = 1.0;\n    \n    float h = 0.01;\n    for (int i = 0; i < 10; ++i) {\n        float d = sdf(p + h * normal);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n\n        if (occ > 0.35) \n            break;\n        \n        h += stepSize;\n    }\n\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.3 + 0.5 * normal.y + 0.8 * normal.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #if DIZERING\n        vec3 CAMERA_POS = vec3(0, 1, 3);\n        vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy + (randVals.xy - 0.5)) / iResolution.x;\n    #else \n        vec3 CAMERA_POS = vec3(3.0 * cos(iTime), 1, 3.0 * sin(iTime));\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    #endif\n    \n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    \n    vec3 rayDir = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 p = CAMERA_POS;\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float dist = sdf(p);\n        \n        if (abs(dist) < EPS) {\n            if (abs(dist - sdf_plane(p, vec3(0, 1, 0), 0.34)) < EPS) {\n                fragColor = vec4(0.357, 0.631, 0.6, 1);\n            } else {\n                fragColor = vec4(0.867, 0.749, 0.667, 1);\n            }\n            vec3 normal = generateNormal(p);\n            vec3 towardLight = normalize(lightPos - p);\n            fragColor *= max(0.0, dot(towardLight, normal)) * lightColor + ambientOcclusion(p, normal) * ambientColor;\n            fragColor += pow(max(0.0, dot(reflect(towardLight, normal), normalize(p - CAMERA_POS))), 128.0) * lightColor;\n            break;\n        }\n        \n        totalDist += dist;\n        if (totalDist > MAX_DIST) {\n            fragColor = vec4(0.733, 0.776, 0.784, 1);\n            break;\n        }\n        \n        p += rayDir * dist;\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "#define DIZERING 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    #if DIZERING\n        fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n    #else\n        fragColor = texture(iChannel0, uv);\n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 74, 74, 262]], "test": "untested"}
{"id": "DssfRH", "name": "[RMO] - lighting", "author": "silica163", "description": "playing with lighting techniques", "tags": ["raymarch", "lighting", "experiment"], "likes": 1, "viewed": 141, "published": 3, "date": "1688461327", "time_retrieved": "2024-07-30T17:46:02.749635", "image_code": "float dist(vec3 p){\n\tfloat d = 0.;\n    \n    d = prismSDF(p,0);\n    d = min(d,sphereSDF(p,0));\n    d = min(d,cubeSDF(p,0));\n    d = min(d,octahedronSDF(p,0));\n    d = min(d,lineSDF(p,0));\n    d = min(d,cylinderSDF(p,0));\n    d = min(d,torusSDF(p,0));\n    \n    d = min(d,p.y+4.);\n    \n\treturn d;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\n// phong\nfloat phong(Light l,Ray r){\n    float c = 0.;\n    float d = diffuse(r.p,l.L);\n    vec3 lRef = reflect(-l.L,N);\n    \n    c = pow(max(dot(lRef,-r.dir),0.),32.) * d;\n    \n    return c;\n}\n\n// blinn phong\nfloat bPhong(Light l,Ray r){\n\tfloat c = 0.;\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += pow(max(dot(normalize(l.L+V),N),0.),32.) * d;\n\t\n\treturn c;\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += .2;\n        c += diffuse(r.p,l[i].L);\n        c += bPhong(l[i],r);\n    }\n    //c = .5+.5*N;\n    c *= normalize(vec3(1));\n    \n    if(r.dist > MAX_DIST)c = vec3(0);\n    return c;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvoid mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 1.5;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/1.5,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv*2.,0)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    cu[0].p = vec3(1.5,0,1.5);\n    cu[0].s = vec3(.4);\n    \n    pr[0].p = vec3(1.5,0,0);\n    pr[0].s = vec3(.2,.4,6);\n    \n    l[0].p = vec3(2)*rotX(ca.x)*rotY(ca.x);\n    \n    sp[0].p = vec4(0,0,1.5,.4);\n    \n    line[0].a = vec3(.5,.5,-.5)+vec3(-.9,0,-.9);\n    line[0].b = vec3(-.5,-.5,.5)+vec3(-.9,0,-.9);\n    line[0].r = .2;\n    \n    cyl[0].p = vec3(1.5,0,-1.5);\n    cyl[0].s = vec2(.5,.4);\n    \n    tor[0].r = vec2(.4,.2);\n    tor[0].p = vec3(-1.5,0,1.5);\n    \n    oc[0].p = vec4(0,0,0,.5);\n    \n    //l[0].p = vec3(5);//*rotX(ca.x)*rotY(ca.y);\n    //l[1].p = vec3(1,2,1);//*rotX(ca.x)*rotY(ca.y);\n\n    l[0].p.xz = l[0].p.xz * rot2D(iTime*.5);\n    \n    march(r,0);\n    N = sNormal(r.p);\n    V = -r.dir;\n    \n    //c = N*.5+.5;\n    //c = r.p;\n    c += render(r);\n    //c = vec3(1./r.rl);\n    fColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define MAX_STEP  256\n#define MAX_REF   2\n\n#define rotX(a) mat3(      1,      0,       0,       0, sin(a), cos(a),      0,- cos(a), sin(a))\n#define rotY(a) mat3( sin(a),      0, -cos(a),       0,      1,      0, cos(a),       0, sin(a))\n#define rotZ(a) mat3( sin(a), cos(a),       0, -cos(a), sin(a),      0,      0,       0,      1)\n#define rot2D(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n\nconst int LIGHTS = 1;\nconst int PRISM = 1;\nconst int OCTS  = 1;\nconst int TORUS = 1;\nconst int SPHERES = 1;\nconst int CUBES = 1;\nconst int LINES = 1;\nconst int CYLS = 1;\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nstruct Octahedron {\n    vec4 p;\n    vec3 c;\n},oc[OCTS];\n\nstruct Prism {\n    vec3 p;\n    vec3 s;\n    vec3 c;\n},pr[PRISM];\n\nstruct Torus {\n    vec3 p;\n    vec2 r;\n    vec3 c;\n},tor[TORUS];\n\nstruct Cyl {\n    vec3 p;\n    vec2 s;\n    vec3 c;\n},cyl[CYLS];\n\nstruct Line {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    float r;\n},line[LINES];\n\nstruct Cube {\n\tvec3 p;\n\tvec3 c;\n\tvec3 s;\n},cu[CUBES];\n\nstruct Sphere {\n    vec4 p;\n    vec3 c;\n},sp[SPHERES];\n\n\n// octahedron\nfloat octahedronSDF(vec3 p,int id){\n    Octahedron o = oc[id];\n    float d;\n    \n    p = abs(p-o.p.xyz);\n    float face = p.x+p.y+p.z - o.p.w;\n        \n    vec3 q = p;\n    \n    if(p.x*3.< face)q = p.xyz;\n    else if(p.y*3. < face)q = p.yzx;\n    else if(p.z*3. < face)q = p.zxy;\n    else return face* (1./sqrt(3.));\n    \n    float k = clamp(0.5*(q.z-q.y+o.p.w),0.0,o.p.w);\n    float edge = length(vec3(q.x,q.y-o.p.w+k,q.z-k));\n    \n    d = edge;\n    return d;\n}\n\n// torus / donut\nfloat torusSDF(vec3 p,int id){\n    float d = 0.;\n    Torus t = tor[id];\n    \n    vec3 sp;\n    sp.xz = normalize(p.xz-t.p.xz)*t.r.x;\n    d = length(p-t.p-sp)-t.r.y;\n    \n    return d;\n}\n\n// cylinder\nfloat cylinderSDF(vec3 p,int id){\n    vec2 d = vec2(0);\n    Cyl c = cyl[id];\n    vec3 cp = p - c.p;\n    \n    d = vec2(abs(cp.y),length(cp.xz)) - c.s * vec2(.5,1);\n    \n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\n// line / capsule\nfloat lineSDF(vec3 p,int id){\n    float d = 0.;\n    Line li = line[id];\n    vec3 p1 = p - li.a;\n    vec3 p2 = li.b - li.a;\n    \n    d = length(p1 - clamp(dot(p1,p2)/dot(p2,p2),0.,1.)*p2) - li.r;\n    return d;\n}\n\n// sphere\nfloat sphereSDF(vec3 p,int id){\n    return length(p-sp[id].p.xyz) - sp[id].p.w;\n}\n\nfloat max3(vec3 n){\n    return max(max(n.x,n.y),n.z);\n}\n\n// cube sdf\nfloat cubeSDF(vec3 p,int id){\n    vec3 c = abs((p-cu[id].p))-cu[id].s;\n    return length(max(c,0.)) + min(0.,max3(c));\n}\n\n//2d polygon sdf\nfloat polygon(vec2 uv,vec2 p,float r,float n){\n    uv = uv - p;\n    n = floor(n);\n    float pa = PI-atan(uv.x,uv.y);      // position angle\n    float sa = 2.*PI/n;                 // side angle\n    float id = (pa - mod(pa,sa)) / sa ;\n    float ra = id * (sa) + sa/2.;       // rotate angle\n    float ir = cos(sa/2.)*r;            // inner radius\n    float sl = sin(sa/2.)*r;            // half side length\n    \n    uv = rot2D(ra)*uv;\n    uv += vec2(-ir,0);\n    \n    if(uv.x < 0.)return uv.x;\n    \n    return length(vec2(uv.x,uv.y - clamp(uv.y,-sl,sl)));\n}\n\n// prism sdf\nfloat prismSDF(vec3 p,int id){\n    vec2 d = vec2(0);\n    Prism ps = pr[id];\n    vec3 cp = p - ps.p;\n    \n    d = vec2(abs(cp.y)-ps.s.x,polygon(cp.xz,vec2(0),ps.s.y,ps.s.z)-.05) * vec2(.5,1);\n    \n    return min(max(d.y,d.x),0.) + length(max(d,0.));\n}\n\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n    //l.L = normalize(l.p);\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\n\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = .5;\n    r.rl = 0.;\n    return r;\n}\n\nfloat smin(float a, float b, float k){\n    float r = min(a,b) - pow(max(0.,k - abs(a - b)/k)*.5,2.);\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 295], [297, 297, 318, 318, 449], [451, 451, 480, 480, 528], [530, 539, 566, 566, 722], [724, 739, 767, 767, 880], [882, 882, 901, 901, 1198], [1200, 1200, 1230, 1230, 1439], [1441, 1441, 1492, 1492, 2787]], "test": "untested"}
{"id": "msXBzH", "name": "moving, not as small shader", "author": "timmaffett", "description": "Making @SnoopethDuckDuck 's small shader less small, but moving", "tags": ["tiny", "small", "tweet", "golf", "100chars"], "likes": 4, "viewed": 152, "published": 3, "date": "1688443298", "time_retrieved": "2024-07-30T17:46:03.602355", "image_code": "// Fork of \"ᵛᵉʳʸ ˢᵐᵃˡˡ ˢʰᵃᵈᵉʳˢ [85 Chars]\" by SnoopethDuckDuck. https://shadertoy.com/view/csScWt\n// 2023-07-04 03:57:52\n\n// Abstract fractal [85] \n// >>> DON'T PLAY WITH THIS OR YOUR WEBGL WILL CRASH <<<\nvoid mainImage( out vec4 O, vec2 I )\n{ \n   for(O-=O; O.x<0.4;)\n       O += .05/length(tan(O.x-(I*=.5+(sin(fract(mod(iTime,100.0)/200.))/2.0))));\n}\n// >>> DON'T PLAY WITH THIS OR YOUR WEBGL WILL CRASH <<<\n\n/*\n\n// Stars [85]\nvoid mainImage( out vec4 O, vec2 I )\n{ \n    for(O-=O; O.w++ < 9.;)\n    O += atan(2.-length(tan(I*=.5)));\n}\n\n// 2^n fractal [85]\nvoid mainImage( out vec4 O, vec2 I )\n{ \n    for(int i; i++ < 8;)\n    O = 0.*O + cos(O/length(cos(I*=.5)));\n}\n\n// Grid [93]\nvoid mainImage( out vec4 O, vec2 I )\n{ \n    O *= 0.;\n    //I += 100. * iTime;\n    for(int i; i++ < 9;)\n    O += .1*atan(2.-length(tan(I*=.25)));\n}\n\n//*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 228, 266, 266, 374]], "test": "untested"}
{"id": "mdsfzn", "name": "Multipass pixel art scaler", "author": "sh1boot", "description": "Going to try making a vector field for every pixel, then use that to define sharper upscaling edges.  This is the first part of that effort.", "tags": ["vectorfield", "pixelscaling"], "likes": 8, "viewed": 152, "published": 3, "date": "1688429503", "time_retrieved": "2024-07-30T17:46:04.392243", "image_code": "vec4 getvec(vec2 uv) {\n    uv = fract(uv / iChannelResolution[1].xy) * iChannelResolution[1].xy;\n    return texture(iChannel0, fract((vec2(uv) + 0.5 / SubDiv) / iChannelResolution[0].xy));\n}\n\nvec4 getpix(ivec2 uv) {\n    return texture(iChannel1, fract((vec2(uv) + 0.5) / iChannelResolution[1].xy));\n}\n\n// gShaderToy.SetTexture(1, {mSrc:'https://i.postimg.cc/2m6hY0vm/test-original.gif', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n// gShaderToy.SetTexture(1, {mSrc:'https://i.postimg.cc/csh04MYG/r-place.png', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\nfloat aastep(float f, float threshold) {\n    float margin = clamp(fwidth(f) * 0.7, 0.0, 0.1);\n    return smoothstep(threshold - margin, threshold + margin, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord ) * Scale + 0.5 * iTime;\n    vec2 iuv = round(uv * SubDiv) / SubDiv;\n    vec2 fuv = uv - iuv;\n    vec2 vf = getvec(iuv).xy;\n    float len = length(vf.xy);\n    bool aimless = len < 0.0001;\n    float dir = aimless ? 0.0 : atan(vf.y, vf.x) * 0.5;\n    vf = vec2(cos(dir), -sin(dir));\n    fuv = vec2(vf.x * fuv.x - vf.y * fuv.y,  \n               vf.x * fuv.y + vf.y * fuv.x);\n    fragColor = getpix(ivec2(iuv));\n    fragColor.a = 1.0;\n    if (aimless) {\n        fragColor *= 1.0 - aastep(length(fuv.xy), .15 / SubDiv);\n    } else {\n        fragColor.a *= 1.0 - aastep(abs(fuv.y), .1 / SubDiv);\n        float clip = len * 0.5;\n        clip = clamp(clip, 0.15, 0.45);\n        fragColor.a *= 1.0 - aastep(abs(fuv.x), clip / SubDiv);\n    }\n    fragColor = fragColor * fragColor.a + vec4(0.25) * (1.0 - fragColor.a);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 getpix(ivec2 uv) {\n    return texture(iChannel1, fract((vec2(uv) + 0.5) / iChannelResolution[1].xy));\n}\n\nfloat match(vec3 p, vec3 q) {\n    return max(0.0, 1.0 - distance(p, q) * MatchDerate);\n}\n\nvec2 invdist(vec2 uv) {\n    // TODO: probably gaussian would be better.\n    return uv / dot(uv, uv);\n}\n\n\nvec2 csq(vec2 v) {\n    return vec2(v.x * v.x - v.y * v.y, 2.0 * v.x * v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (all(lessThan(fragCoord.xy, iChannelResolution[1].xy))) {\n      ivec2 uv = ivec2(fragCoord);\n\n      vec3 p = getpix(uv).rgb;\n      \n      vec2 acc = vec2(0);\n      for (int y = -Radius; y <= Radius; ++y) {\n          for (int x = -Radius; x <= Radius; ++x) {\n              if (x == 0 && y == 0) continue;\n              if (abs(x) + abs(y) > Radius * 3 / 2) continue;\n              ivec2 o = ivec2(x, y);\n              vec3 q = getpix(uv + o).rgb;\n              acc += csq(invdist(vec2(o))) * match(p, q);\n          }\n      }\n      p.rg = acc;\n      fragColor = vec4(p, 1.0);\n    } else {\n      fragColor = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int Radius = 2;\nconst float MatchDerate = 16.0;\nconst float Scale = 1.0 / 20.0;\nconst float SubDiv = 1.0;\n\nconst float FilterCorner = 4./64.;\nconst float FilterEdge = 6./64.;\n", "buffer_b_code": "vec4 getvec(ivec2 uv) {\n    uv = ivec2(fract(vec2(uv) / iChannelResolution[1].xy) * iChannelResolution[1].xy);\n    return texture(iChannel0, fract((vec2(uv) + 0.5) / iChannelResolution[0].xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (all(lessThan(fragCoord.xy, iChannelResolution[1].xy))) {\n      ivec2 uv = ivec2(floor(fragCoord));\n\n      vec4 acc = vec4(0);\n      for (int y = -1; y <= 1; ++y) {\n          for (int x = -1; x <= 1; ++x) {\n              float scale = FilterCorner;\n              if (x == 0 || y == 0) scale = FilterEdge;\n              if (x == 0 && y == 0) scale = 1.0 - 4.0 * (FilterCorner + FilterEdge);\n              acc += getvec(uv + ivec2(x, y)) * scale;\n          }\n      }\n      fragColor = acc;\n    } else {\n      fragColor = vec4(0);\n    }\n}", "buffer_b_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsfzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 190], [192, 192, 215, 215, 300], [703, 703, 743, 743, 864], [866, 866, 923, 923, 1757]], "test": "untested"}
{"id": "DdfBzH", "name": "B&W dithering: Sunrise on Saturn", "author": "rplacd", "description": "Test of B&W conversion, with probability-based dithering. \nExample image from mrange's \"Sunrise on Saturn\":\n-------------\nCC0: Ringed planet\nWas tinkering with trying to recreate a sweet sci fi image\nStopped working and forgot to share at the time.\n", "tags": ["3d", "postproc"], "likes": 1, "viewed": 211, "published": 3, "date": "1688429401", "time_retrieved": "2024-07-30T17:46:05.151213", "image_code": "#define BW(fl) vec4(fl, fl, fl, 1.0f);\n\nvec4 grayscaleToBW(in vec4 rgba, in vec2 fragCoord) {\n    // Obtain the luma of the current rgba, using\n    // ITU Rec.601 weights:\n    float grayscale = 0.299*rgba.r + 0.587*rgba.g + 0.114*rgba.b;\n    \n    // Convert to grayscale using a simple midpoint rule:\n    float bOrW = (grayscale < 0.5f) ? 0.0f : 1.0f;\n    \n    // For grayscale values close/r to the midpoint (127), compensate\n    // for the terrible approximation by probabilistically\n    // dithering, with probability falling off rapidly from\n    // grayscale value = .5      |--> dither with probability 1/2, to\n    // grayscale value = 1 or 0  |--> dither with probability 0.\n    //\n    // Cram the two below calculations into a graphiing calculator\n    // to see how they work.\n    float probabilityParameter = 1.0f - abs(0.5f - grayscale)/0.5f;\n    float ditherProbability = asin(probabilityParameter)/1.570796;\n        // 1.570796 \\approx \\pi/2.\n    \n    // To sample with the above probability, obtain a random value\n    // between 0 < 1 from iChannel1, gray noise, assumed to be\n    // equally distributed;\n    float randomSample = texture(iChannel1, fragCoord/iResolution.xy).x;\n    \n    \n    // For the top half of the screen, return the original grayscale colour;\n    // for the bottom half of the screen, compare our random sample in 0...1 against our\n    // probability (assuming random samply is equally distributed, \n    // effectively sampling with said probability distribution.\n    if(fragCoord.y > iResolution.y/2.0f) {\n        return BW(grayscale);\n    } else {    \n        if(randomSample < ditherProbability) {\n            return (bOrW == 1.0f) ? vec4(0.0f, 0.0f, 0.0f, 1.0f) : vec4(1.0f, 1.0f, 1.0f, 1.0f);\n        } else {\n            return vec4(bOrW, bOrW, bOrW, 1.0f);\n        }   \n    }\n}\n\n\n// CC0: Sunrise on saturn\n// Was tinkering with trying to recreate a sweet sci fi image\n// Stopped working and forgot to share at the time.\n// I strongly doubt there's mist like blur in space but it looked\n// nice on original image so tried to recreate it.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec3 col = vec3(0.0);\n  col = texture(iChannel0, q).xyz;\n  col = sqrt(col);\n\n  vec4 rawColor = vec4(col, 1.0);\n  fragColor = grayscaleToBW(rawColor, fragCoord);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere2(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  if(h<0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nconst float far           = 1E5;\nconst vec3 sunDir         = normalize(vec3(2.5, -2.0, 10.0));\nconst float planetRadius  = 425.0;\nconst vec3 planetCenter   = vec3(0.0, -1.05*planetRadius, 0.0);\nconst vec4 planetDim      = vec4(planetCenter, planetRadius);\nconst vec4 surfaceDim     = vec4(planetCenter, 0.95*planetRadius);\nconst vec3 ringNor        = normalize(vec3(-3.2, 1.0, 1.75));\nconst vec4 ringDim        = vec4(ringNor, -dot(ringNor, planetCenter));\n\nvec3 sky(vec3 ro, vec3 rd) {\n  const vec3 sunCol = HSV2RGB(vec3(0.066, 0.66, 0.000025));\n\n  float sf = 1.001-dot(rd, sunDir);\n//  sf *= sf;\n  sf *= sf;\n  vec3 col = vec3(0.0);\n  col += sunCol/sf;\n  return col;\n}\n\nvec3 sky(vec3 col, inout float hit, vec3 ro, vec3 rd) {\n\n  if (far > hit) {\n    return col;\n  }\n  hit = 1E5;\n\n  col += sky(ro, rd);\n\n\n  return col;\n}\n\nvec3 planet(vec3 col, inout float hit, vec3 ro, vec3 rd) {\n  vec2 pi   = raySphere2(ro, rd, planetDim);\n  if (pi.x == -1.0) {\n    return col;\n  }\n  if (pi.x > hit) {\n    return col;\n  }\n  hit = pi.x;\n  \n  vec3 pos  = ro+rd*pi.x;\n  vec3 nor  = normalize(pos-planetDim.xyz);\n  float fre = 1.0+dot(rd, nor);\n  fre *= fre;\n  vec3 refl = reflect(rd, nor);\n  float rr = mix(1.0, 0.7, tanh_approx(0.0025*(pi.y-pi.x)));\n  vec3 refr = refract(rd, nor, rr);\n  \n  vec2 pri  = raySphere2(pos, refr, planetDim);\n  vec2 sri  = raySphere2(pos, refr, surfaceDim);\n  vec3 rpos = pos+refr*pri.y;\n  vec3 rnor = normalize(rpos-planetDim.xyz);\n  vec3 rrefr= refract(refr, -rnor, rr);\n  \n  vec3 pcol   = vec3(0.0);\n  vec3 prefl  = sky(pos, refl);\n  vec3 prefr  = sky(pos, rrefr);\n  prefr = pow((prefr), vec3(1.25, 1.0, 0.75));\n  pcol += prefl*fre;\n  pcol += prefr*(1.0-tanh_approx(0.004*(sri.y-sri.x)));\n\n  float pt = tanh_approx(0.025*(pi.y-pi.x));\n  col = mix(col, pcol, pt);\n  return col;\n}\n\nvec3 rings(vec3 col, inout float hit, vec3 ro, vec3 rd) {\n  float pt = rayPlane(ro, rd, ringDim);\n  if (pt < 0.0) {\n    return col;\n  }\n  if (pt > hit) {\n    return col;\n  }\n  \n  vec3 pos = ro+rd*pt;\n  vec3 nor = ringDim.xyz;\n  vec2 sri  = raySphere2(pos, sunDir, planetDim);\n  vec3 spos = pos+sunDir*sri.x;\n  vec3 snor = normalize(spos - planetDim.xyz);\n  float sfre = 1.0+dot(sunDir, snor);\n//  sfre *= sfre;\n\n  float r = length(pos-planetCenter);\n  float rr = 1.0*r;\n  float ri0 = sin(.5*rr);\n  float ri1 = sin(.2*rr);\n  float ri2 = sin(.12*rr);\n  float ri3 = sin(.033*rr-2.);\n//  float ri = (0.5+0.5*ri0*ri1*ri2);\n  float ri = smoothstep(-0.95, 0.75, ri0*ri1*ri2);\n  ri = 0.5*ri+0.2*ri3;\n  ri *= 1.75;\n  float sf = sri.x < 0.0 ? 1.0 : mix(0.05, 1.0, smoothstep(0.5, 1.0, sfre));\n  float rdif = max(dot(nor, sunDir), 0.0);\n  rdif = sqrt(rdif);\n  vec3 rcol = hsv2rgb(vec3(0.066, 0.85+0.1*ri0*ri1, ri))*sf*rdif;\n  rcol *= smoothstep(550.0, 560.0, r)*smoothstep(860.0, 850.0, r);\n  col += rcol;\n  return col;\n}\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  float hit = far;\n  \n  col = sky(col, hit, ro, rd);\n  col = planet(col, hit, ro, rd);\n  col = rings(col, hit, ro, rd);\n  \n  return col;\n}\n\nvec3 effect(vec2 p) {\n  float gd = min(abs(p.x), abs(p.y))-0.005;\n\n  const vec3 ro = vec3(0.0, 0.0, -1000.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = 4.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  float aa = 4.0/RESOLUTION.y;\n  vec3 col = render(ro, rd);\n//  col = mix(col, vec3(0.25, 0.0 ,0.), smoothstep(0.0, -aa, gd));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 brot = ROT(2.399);\n// License: Unknown, author: Dave Hoskins, found: Forgot where\nvec3 dblur(vec2 q,float rad) {\n  vec3 acc=vec3(0);\n  const float m = 0.0025;\n  vec2 pixel=vec2(m*RESOLUTION.y/RESOLUTION.x,m);\n  vec2 angle=vec2(0,rad);\n  rad=1.;\n  const int iter = 30;\n  for (int j=0; j<iter; ++j) {  \n    rad += 1./rad;\n    angle*=brot;\n    vec4 col=texture(iChannel1,q+pixel*(rad-1.)*angle);\n    acc+=clamp(col.xyz, 0.0, 10.0);\n  }\n  return acc*(1.0/float(iter));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec3 col = texture(iChannel0, q).xyz;\n  \n  col -= 0.005*vec3(0.0, 1.0, 2.0).zyx;\n  col = aces_approx(col);\n  col += 0.5*dblur(q, 1.0);\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 93, 171, 1818], [2199, 2199, 2256, 2256, 2457]], "test": "untested"}
{"id": "csXBzH", "name": "B&W dithering test – Psychedelix", "author": "rplacd", "description": "Port of a B&W conversion scheme, with probabilistic dithering (closer to gray = higher probability of dithering).\nTested with the Psychedelix shader by (TomoAlien).", "tags": ["2d", "plasma", "colorful", "psychedelic", "weird", "acid", "dutchcolorscheme", "rainbows"], "likes": 0, "viewed": 163, "published": 3, "date": "1688429339", "time_retrieved": "2024-07-30T17:46:05.913176", "image_code": "#define BW(fl) vec4(fl, fl, fl, 1.0f);\n\nvec4 grayscaleToBW(in vec4 rgba, in vec2 fragCoord) {\n    // Obtain the luma of the current rgba, using\n    // ITU Rec.601 weights:\n    float grayscale = 0.299*rgba.r + 0.587*rgba.g + 0.114*rgba.b;\n    \n    // Convert to grayscale using a simple midpoint rule:\n    float bOrW = (grayscale < 0.5f) ? 0.0f : 1.0f;\n    \n    // For grayscale values close/r to the midpoint (127), compensate\n    // for the terrible approximation by probabilistically\n    // dithering, with probability falling off rapidly from\n    // grayscale value = .5      |--> dither with probability 1/2, to\n    // grayscale value = 1 or 0  |--> dither with probability 0.\n    //\n    // Cram the two below calculations into a graphiing calculator\n    // to see how they work.\n    float probabilityParameter = 1.0f - abs(0.5f - grayscale)/0.5f;\n    float ditherProbability = asin(probabilityParameter)/1.570796;\n        // 1.570796 \\approx \\pi/2.\n    \n    // To sample with the above probability, obtain a random value\n    // between 0 < 1 from iChannel0, gray noise, assumed to be\n    // equally distributed;\n    float randomSample = texture(iChannel0, fragCoord/iResolution.xy).x;\n    \n    // For the left half of the screen, return the original grayscale colour;\n    // for the right half of the screen, compare our random sample in 0...1 against our\n    // probability (assuming random samply is equally distributed, \n    // effectively sampling with said probability distribution.\n    if(fragCoord.x < iResolution.x/2.0f) {\n        return BW(grayscale);\n    } else {    \n        if(randomSample < ditherProbability) {\n            return (bOrW == 1.0f) ? vec4(0.0f, 0.0f, 0.0f, 1.0f) : vec4(1.0f, 1.0f, 1.0f, 1.0f);\n        } else {\n            return vec4(bOrW, bOrW, bOrW, 1.0f);\n        }   \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Original\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 pos = (uv.xy-0.5);\n\tvec2 cir = ((pos.xy*pos.xy+sin(uv.x*18.0+iTime)/25.0*sin(uv.y*7.0+iTime*1.5)/1.0)+uv.x*sin(iTime)/16.0+uv.y*sin(iTime*1.2)/16.0);\n\tfloat circles = (sqrt(abs(cir.x+cir.y*0.5)*25.0)*5.0);\n    \n\tvec4 rawColour = vec4(sin(circles*1.25+2.0),abs(sin(circles*1.0-1.0)-sin(circles)),abs(sin(circles)*1.0),1.0);\n    fragColor = grayscaleToBW(rawColour, fragCoord);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 93, 171, 1813], [1816, 1816, 1873, 1889, 2315]], "test": "untested"}
{"id": "cdBcWV", "name": "octo-fractal", "author": "bronson113", "description": "Cool! 2\n\n", "tags": ["fractal"], "likes": 6, "viewed": 1249, "published": 3, "date": "1688417092", "time_retrieved": "2024-07-30T17:46:06.751933", "image_code": "//https://iquilezles.org/articles/distfunctions2d/\nfloat sdStar( in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n//http://dev.thi.ng/gradients/\n//[[1.028 0.078 0.858] [3.138 1.388 -0.442] [-0.993 1.853 1.288] [-0.885 2.115 5.774]]\n//https://iquilezles.org/articles/palettes/\n// cosine based palette, 4 vec3 params\nvec3 palette( float t ) {\n    vec3 a = vec3(1.028, 0.078, 0.858);\n    vec3 b = vec3(3.138, 1.388, -0.442);\n    vec3 c = vec3(-0.993, 1.853, 1.288);\n    vec3 d = vec3(-0.885, 2.115, 5.774);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coord without streching\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = vec4(0,0,0,0);\n    for(float k=1.0; k<3.1; k+=1.0){\n        vec2 uv0 = fract(uv*k-0.5) - 0.5;\n        float l = length(uv);\n        \n        float d = sdStar(uv0, k*0.6, 10,  k*2.0);\n\n        d = abs(sin(d*8.0-iTime/6.0));\n\n        d = (0.05/k) / d;\n        \n        // Time varying pixel color\n        vec3 col = palette(l-iTime/1.8+length(uv0))*d;\n\n        // Output to screen\n        fragColor += vec4(col, 1.0);\n    }\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 111, 168, 567], [569, 770, 795, 795, 1002], [1005, 1005, 1062, 1110, 1620]], "test": "untested"}
{"id": "ddsfRr", "name": "Tentacle on drugs", "author": "Moumouke", "description": "Tried something, failed terribly.\nIt look way too trippy but somehow i grew fond of it.", "tags": ["juliaset"], "likes": 6, "viewed": 178, "published": 3, "date": "1688415482", "time_retrieved": "2024-07-30T17:46:07.520878", "image_code": "// https://iquilezles.org/articles/palettes/\n// Also http://dev.thi.ng/gradients/\nvec3 palette(in float t)\n{\n    vec3 a=vec3(0.500,0.500,0.500);\n    vec3 b=vec3(0.500,0.500,0.500);\n    vec3 c=vec3(1.000,0.700,0.400);\n    vec3 d=vec3(0.000,0.015,0.200);\n\n    /*\n    vec3 a=vec3(0.50000, 0.50000, 0.50000);\n    vec3 b=vec3(0.50000, 0.50000, 0.50000);\n    vec3 c=vec3(1.00000, 1.00000, 1.00000);\n    vec3 d=vec3(0.00000, 0.33300, 0.66700);\n    */\n    return clamp(a+b*cos(6.28318*(c*t+d)), 0., 1.);\n}\n\nfloat tWave(float x, float p)\n{\n    return p * abs(x/p-floor(x/p+.5));\n}\n\nfloat dist(in vec2 p, in vec3 f) {\n    return abs(p.x * f.x + p.y * f.y + f.z) / sqrt(f.x * f.x + f.y + f.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 julia(in vec2 p){\n    const vec2 c = vec2(.285, .01);\n    float o = 200.;\n    float o1 = 200.;\n    float o2 = 200.;\n    vec2 z = vec2(p);\n\n    for(int i=0;i<128;i++){\n        float sr=z.x*z.x-z.y*z.y;\n        float sc=2.*z.y*z.x;\n        \n        z.x=sr+c.x;\n        z.y=sc+c.y;\n\n        o1 = min(o1, dist(z, vec3(1, .0, 0. )));\n        o2 = min(o2,  sdBox(z, vec2(1.) * cos(iTime)));\n        o2 = min(o2,  sdStar5(z, 2., 1.));\n    }\n\n    o = min(o, o2);\n\n    return .3/palette(o * tWave(iTime, 25.));\n}\n\nvoid rotate(inout vec2 p, float a) {\n    p = vec2(\n        p.x * cos(a) - sin(a) * p.y,\n        p.x * sin(a) + cos(a) * p.y\n    );\n}\n\nvoid relocate(inout vec2 p, float zoom, vec2 t) {\n    p/=zoom;\n    p+=t;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 st=(2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 uv=(st) * 1.8;\n    float a = 2.4;\n    rotate(uv, a);\n    relocate(uv, 55., vec2(.6, .75));\n    vec3 color=julia(uv);\n    \n    fragColor=vec4(color,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddsfRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 108, 108, 497], [499, 499, 530, 530, 571], [573, 573, 607, 607, 684], [686, 686, 723, 723, 803], [805, 857, 908, 908, 1286], [1288, 1288, 1310, 1310, 1796], [1798, 1798, 1834, 1834, 1930], [1932, 1932, 1981, 1981, 2006], [2008, 2008, 2059, 2059, 2282]], "test": "untested"}
{"id": "cslfRn", "name": "Milk inside a bag of shader", "author": "KodiCraft", "description": "Reproduce the visual effects present in 'Milk inside a bag of milk inside a bag of milk'\n\nThis also works as a general color and resolution reduction shader", "tags": ["retro", "pixel", "videogame"], "likes": 1, "viewed": 170, "published": 3, "date": "1688405096", "time_retrieved": "2024-07-30T17:46:08.285832", "image_code": "// ========================== Configuration  ==========================\n\n// Comment to disable shader reduction\n#define ENABLE\n\n// Target resolution\n// I'm unsure if this is respected as intended, it sets how pixelated the image is.\n// Smaller means more pixelated. The image will be stretched to fill the viewport.\n#define RES vec2(320., 200.)\n\n// Score function\n// The closer the color, the smaller the score\n// The smallest score will be our chosen one\n// It's worth playing around with, maybe you'll find a better function!\nfloat score( in vec4 in1, in vec4 in2 ) {\n    return distance(in1, in2);\n}\n\n// Color options\n// These are the only colors we're allowed to use\n// Feel free to play with different colors if you'd like!\nconst vec4[] COLORS = vec4[] (\n      vec4(0., 0., 0., 1.), // Black\n      vec4(124. / 256., 18. / 256., 140. / 256., 1.), // Pink\n      vec4(92. / 256., 1. / 256., 32. / 256., 1.) // Red\n);\n\n// ========================== Main Shader Code ==========================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Recalculate fragCoord according to our pizel size\n    vec2 pSize = iResolution.xy / RES; // Size of a vPixel\n    vec2 pos = floor(fragCoord / pSize); // Position in our vPixel grid\n    \n    fragCoord = (pos * pSize) + (pSize / 2.); // Find appropriate full-scale pixel for our vPixel\n    \n    // Take the color from iChannel0 (input image)\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    #ifdef ENABLE\n    // Find the closest color in terms of the color space\n    int best_color = 0; // Color index\n    float best_score = 999999999999999.; // Distance\n    \n    for (int i = 0; i < COLORS.length(); i++) {\n        float score = score(fragColor, COLORS[i]);\n        if (score < best_score) {\n            best_color = i;\n            best_score = score;\n        }\n    }\n    \n    fragColor = COLORS[best_color];\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 528, 569, 569, 602], [995, 995, 1052, 1109, 1904]], "test": "untested"}
{"id": "ds2cD3", "name": "Advancing tunnel", "author": "eudaimon", "description": "Nice walk through a never ending simple tunnel that changes color with time.\nIntended to work as a wallpaper, so no excessive attention is drawn.\nThis is my first public creation, so all comments to help me optimize it are more than welcome. ", "tags": ["tunnel", "calm", "wallpaper"], "likes": 5, "viewed": 109, "published": 3, "date": "1688381540", "time_retrieved": "2024-07-30T17:46:09.121598", "image_code": "#define SPEED 1.\n#define DARKEN 2.5\n\nfloat grid (vec2 uv) {\n    //uv -= vec2(0,0.5);\n    float steepVP=iResolution.x / iResolution.y; // steepness of viewport diagonals\n    float uvSteep=abs(uv.x/uv.y);\n    float c;\n    float dist;\n    if (uvSteep > steepVP) { //vertical walls\n        \n        c=abs(uv.x)/steepVP / DARKEN;\n    }\n    else { // horizontal walls\n        c=abs(uv.y) / DARKEN;\n    }\n    dist=1./c+iTime*SPEED;\n    c*=step(0.8, fract(dist)); // percentage of the wall that stays black (to create the illusion of rings)\n    \n    //float dE=abs(uvSteep - steepVP ); //distance to edge\n    \n    return c;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates uv from (-1,-1) to (1,1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/ iResolution.y;\n    \n    //paint according to distance to center\n    //float d =  length(uv)/2.;\n    //vec3 col = vec3 (d, d, d);\n    \n    float col = grid(uv);\n    float r=col*(0.5 + sin(iTime)/2.);\n    float g=col*(0.5 + sin(iTime*2.)/2.);\n    float b=col*(0.5 + sin(iTime*1.5)/2.);\n    \n    // Output to screen\n    \n    \n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2cD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 59, 84, 617], [622, 622, 679, 740, 1148]], "test": "untested"}
{"id": "DdXfzr", "name": "Little 3D Scene [132 Chars]", "author": "SnoopethDuckDuck", "description": "Any improvements are more than welcome!", "tags": ["tweet", "onetweet", "golf", "150chars"], "likes": 22, "viewed": 286, "published": 3, "date": "1688380840", "time_retrieved": "2024-07-30T17:46:09.913480", "image_code": "// Rough explanation:\n// O accumulates value as ray moves\n// abs(tex-.3) lets us move inside the noise, is step distance\n// vec3(I/res.y,1) is ray direction\n// so O += accumulate(p += step distance * ray direction)\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec3 p;\n    for(O-=O; O.w++ < 2e2; p+=abs(texture(iChannel0, .02*(p+iTime)).r-.2)\n                            *vec3(I/7e2, 2))     \n        O += p.z/1e4;\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 254, 254, 414]], "test": "untested"}
{"id": "dd2cDd", "name": "Random Grid Color", "author": "Ride_A_Pig", "description": "My first shader.", "tags": ["2d", "grid"], "likes": 4, "viewed": 181, "published": 3, "date": "1688372599", "time_retrieved": "2024-07-30T17:46:10.680430", "image_code": "#define zoom 1.0\n\nvec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy/zoom;\n    vec2 uv2 = cos(uv*32.0*2.0*3.14159265)-0.8;\n    float board = ceil(clamp(uv2.x,0.0,1.0)+clamp(uv2.y,0.0,1.0));\n    vec2 uv3 = floor(uv*32.0)/32.0;\n    float r = texture(iChannel0, uv3).x;\n    float g = texture(iChannel0, uv3).y;\n    float b = texture(iChannel0, uv3).b;\n    vec3 color = vec3(fract(r*iTime*2.0),fract(g*iTime),fract(b*iTime/2.0));\n    vec3 final = lerp(color,vec3(0.0),board);\n    fragColor = vec4(final,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2cDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 72, 72, 122], [124, 124, 181, 181, 658]], "test": "untested"}
{"id": "mdjcWd", "name": "water cc", "author": "tianluo970922", "description": "water cc", "tags": ["water"], "likes": 0, "viewed": 158, "published": 3, "date": "1688371080", "time_retrieved": "2024-07-30T17:46:11.526169", "image_code": "// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\n// :)\n// by David Hoskins.\n// Original water turbulence effect by joltz0r\n\n\n// Redefine below to see the tiling...\n//#define SHOW_TILING\nconst vec2 target_resolution = vec2(940, 86);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\n\tfloat time = iTime * .5 + 23.0;\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5; \n    \n    vec2 uv0 = uv; \n    uv0.x *= 3.;\n    //uv0.x += iTime * 0.3;\n    uv0.y *= 1.;\n    uv0.y += iTime * 0.1;\n  \n     \n    vec2 p = mod(uv0*TAU, TAU)-250.0;\n    \n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .009;\n    \n    //通过算法测算出water的pattern，通过增大tiling的值可以增大pattern的密度\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (2.5/ float(n+1)));\n        float t1= time * .2;\n\t\ti = p + vec2(cos(t1 - i.x) + sin(t + i.y), sin(t - i.y) + cos(t1 + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+ t1)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(MAX_ITER);\n    \n    //1.12 可以调整白色的对比度，数值越高，对比度越高\n    //1. 1可以调整蓝色的深浅,数值越高，蓝色越浅，白色越多且会过曝\n\tc = 1.2 - pow(c, 1.1);\n    \n    //7.5可以调整蓝色的深浅，数值越高，蓝色越深，但不会影响白色的细节\n\tvec3 colour = vec3(pow(abs(c), 10.5));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    \n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n    //headColor\n    vec3 headColor = vec3(1.000,1.000,1.000); \n    headColor *= pow(uv.y, (sin(iTime) * 0.5 + 0.5) *6.0  + 5.5 ) ;\n\tfragColor = vec4(colour + headColor, 1.0);\n    \n   \n    //endColor\n    vec3 endColor = vec3(0.000,0.3,1.000); \n    //endColor *= pow(1.0 - uv.y, 1.0); \n    fragColor.rgb = mix(endColor, fragColor.rgb, smoothstep(0.0,(sin(iTime) * 0.5 + 0.5) * 0.7 + 0.,uv.y));\n    \n    //结尾的mask\n    float mask = pow(uv.y, 1.0);\n    //0.492的值越小，黑色边缘越硬\n    mask = smoothstep(0.0,0.472,uv.y);\n    \n    fragColor *= (mask);\n    //fragColor = vec4(endColor, 1.0);\n    //fragColor = vec4(mask);\n    \n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 381, 381, 3072]], "test": "untested"}
{"id": "ds2cDt", "name": "THREE Shaders in 301 chars", "author": "GregRostami", "description": "Here are three of my previous shaders (with wipe transitions) in 301 chars.", "tags": ["raymarching", "short", "golf", "multiple"], "likes": 13, "viewed": 209, "published": 3, "date": "1688368639", "time_retrieved": "2024-07-30T17:46:12.415790", "image_code": "void mainImage (out vec4 o, vec2 u)\n{\n    u /= iResolution.x;\n    float t = iTime, c = fract (.04*(t+u.x));\n    vec4 x; o *= x;\n    for ( ++o.y; o.a++<99.; )\n        o += vec4 (1, u, 0) * (length (cos (o.xyz + t)) - .3);\n    u -= .5;\n    for (ivec4 b; (b.x^b.y^b.z)%99 > b.z-7; )\n        b = ivec4 ( t*vec2(2,4) + 6.*u*x.a, x+=.1 );\n    o = c < .3 ? o/50.\n      : c < .6 ? max ( u = fract (u/dot (u,u)-t), u.x - u ).yyyy \n      : x/74.;\n}", "image_inputs": [{"id": 33853, "src": "https://soundcloud.com/nikolaipetrov-sc/the-old-castle", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2cDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 438]], "test": "untested"}
{"id": "dsByzD", "name": "Introduction to Ray Marching", "author": "rohtas", "description": "This is my rendition of how I imagine earth from P0\nThis code is well commented for you to follow an introductory solution to Ray Marching.\n\n\n#earth #sun #space #nothingforchandrayaan #nomoon #moonmissing #starrysky #raymarching #shading #ai #tensorflow", "tags": ["sdf"], "likes": 2, "viewed": 159, "published": 3, "date": "1688368016", "time_retrieved": "2024-07-30T17:46:13.548761", "image_code": "const int STEPS = 50;\nconst float TRACE_DISTANCE = 200.0;\nconst float HIT_DISTANCE = 1e-3;\nconst float SPHERE_RADIUS = 1.0;\nconst float LIGHT_RADIUS = 0.1;\nconst float TILE_SIZE = 8.0;\nconst float PI = 3.14;\n\nvec3 GetSphere() {\n    vec3 sphere = vec3(0., 0., 3.);\n    // float omega = 1e-2;\n    // float freq = 2.0 * PI * omega;\n    // sphere.x = 2.0 * ( mod(freq*iTime, 1.0) - 0.5 );\n    return sphere;\n}\n\nfloat SdSphere(vec3 p) {\n    vec3 sphere = GetSphere();\n    \n    float d = length(p-sphere.xyz) - SPHERE_RADIUS;\n    return d;\n}\n\nvec3 GetLightPos() {\n    vec3 pos = GetSphere();\n    //pos.xy += vec2(cos(iTime * 0.2), sin(iTime * 5.8));\n    float freq = 2.0*PI*0.01;\n    pos.xz += 4.9*vec2(sin(freq*iTime), cos(freq*iTime));\n    return pos;\n}\n\nvec3 GetLight(vec3 p, vec3 n, float power) {\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 pos = GetLightPos();\n    vec3 l = normalize(pos-p);\n    // Diffuse Light\n    float diffuse = max(0.0, dot(n, l));\n    vec3 intensity = diffuse*lightColor;\n    return power*intensity; \n}\n\nfloat SdLight(vec3 p) {\n    vec3 pos = GetLightPos();\n    float d = length(p-pos) - LIGHT_RADIUS;\n    return d;\n}\n\nvec2 GetScene(vec3 p) {\n\n      // Check Spheres\n     float sdSphere = SdSphere(p);\n     \n     // Check Light\n     float sdLight = SdLight(p);\n     \n     // Return Map\n     if ( sdLight < sdSphere ) {\n         return vec2(sdLight, 2.0);\n     } else {\n         return vec2(sdSphere, 1.0);\n     }\n}\n\nfloat BloomEffect(float sd, float amp, float sigma, float falloff) {\n    return amp/pow((2.0*PI*sigma*sigma), 0.5)*exp(-falloff*sd*sd);\n}\n\n// Shader Ops\nvec3 GetNormal(vec3 p) {\n    vec2 delta = vec2(1e-2, 0.0);\n    vec3 n = vec3(\n        GetScene(p+delta.xyy).s - GetScene(p-delta.xyy).s,\n        GetScene(p+delta.yxy).s - GetScene(p-delta.yxy).s,\n        GetScene(p+delta.yyx).s - GetScene(p-delta.yyx).s\n    );\n    return normalize(n);\n}\n\nvec2 LambertAzimuthalProjection(vec3 p) {\n    vec3 normalizedPoint = normalize(p);\n    float theta = atan(normalizedPoint.y, normalizedPoint.x);\n    float phi = acos(normalizedPoint.z);\n\n    // Normalize theta and phi to the range [0, 1]\n    float u = (theta + PI) / (2.0 * PI);\n    float v = phi / PI;\n    \n    return vec2(u, v);\n}\n\nvec3 RotatePlanet(vec3 p, float thetaX, float thetaY, float thetaZ) {\n\n    float cosThetaX = cos(thetaX);\n    float sinThetaX = sin(thetaX);\n    mat3 rotationMatrixX = mat3(\n        1.0,  0.0,       0.0,\n        0.0,  cosThetaX, -sinThetaX,\n        0.0,  sinThetaX, cosThetaX\n    );\n\n    float cosThetaY = cos(thetaY);\n    float sinThetaY = sin(thetaY);\n    mat3 rotationMatrixY = mat3(\n        cosThetaY, 0.0, -sinThetaY,\n        0.0,       1.0,  0.0,\n        sinThetaY, 0.0, cosThetaY\n    );\n\n    float cosThetaZ = cos(thetaZ);\n    float sinThetaZ = sin(thetaZ);\n    mat3 rotationMatrixZ = mat3(\n        cosThetaZ, -sinThetaZ, 0.0,\n        sinThetaZ, cosThetaZ,  0.0,\n        0.0,       0.0,        1.0\n    );\n\n    // Apply the rotations in the desired order (Z, then Y, then X)\n    mat3 combinedRotationMatrix = rotationMatrixZ * rotationMatrixY * rotationMatrixX;\n\n    return combinedRotationMatrix * p;\n}\n\nvec3 GetPlanetCoordinate(vec3 p) {\n   p = normalize(p-GetSphere());\n   vec3 theta = vec3(-105., -0., iTime*-10.);      \n   p = RotatePlanet(p, radians(theta.x), radians(theta.y), radians(theta.z));\n   return p;\n}\nvec3 PlanetColor(vec3 p, vec3 light) {\n    p = GetPlanetCoordinate(p); \n    vec2 angular = LambertAzimuthalProjection(p); \n    vec3 col = mapEarth(vec3(p.y,p.x,p.z));\n    col = smoothstep(0.,1.,sqrt(col));\n    col = smoothstep(0.,1.,col);\n    if (length(light) < 1e-2 ) {\n        float time = 1.;\n        float temp = NoiseT(time*0.004, p.xyz, 4.0);\n        temp = mix(temp, NoiseT(time*0.008, p.xyz, 34.0), 0.8);\n        temp = mix(temp, NoiseT(time*0.01, p.xyz, 164.0), 0.4);\n        temp = smoothstep(0.76, .82, temp);\n        float value = temp*length(col.rg)/pow(2., 0.5);\n        col = value*vec3(1.0, 1.0, 0.0);\n    } else {\n        col = col*light;\n    }\n    return col;   \n}\n\nvec3 SunColor(vec3 p, vec2 uv)\n{\n    float time = iTime;\n    p = normalize(p - GetLightPos());\n    float temp = NoiseT(time*0.004, p.xyz, 4.0);\n    temp = mix(temp, NoiseT(time*0.008, p.xyz, 34.0), 0.8);\n    temp = mix(temp, NoiseT(time*0.01, p.xyz, 164.0), 0.4);\n    float spots = NoiseT(time*0.004, p.xyz, 4.0);\n    float h = 0.75;\n    float c = 0.2;\n    if(true && spots < c)\n        temp = mix(temp, 0.0, min(1.0, 2.0 * (c-spots)*(1.0/c)));\n    else if(true && spots > h)\n    \ttemp = temp * (1.0 + min(1.0, 2.0 * (spots-h)*(1.0/(1.0-h))));\n    temp = pow(temp, 2.0) ;\n   \tvec3 col = vec3(min(1.0, sqrt(temp) * 3.5), min(1.0, temp * 1.2), min(1.0, temp * 0.0));\n    float w = 0.38;\n    if(temp > w)\n        col = mix(col, vec3(1.0),  (temp-w)*(1.0/(1.0-w))); \n        \n    float k = (1.0 + cnoise(vec4(normalize(uv),time*0.01, 0.0) * 64.0)) * 0.5;\n    float d = k - 0.999;\n    if(d >= 0.0)\n    {\n        col = mix(col, vec3(2.0,0.9*k,0.05), 1.0 * min(1.0, sqrt(d)) );\n    }    \n    return col;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd, vec2 uv) {\n    // Fragment Color\n    vec3 C = vec3(0.0);\n    // Distance To Scene\n    float dS = 0.0;\n    // Loop\n    vec2 bounce;\n    for(int i=0; i<STEPS; i+=1) {\n        vec3 p = ro + dS*rd;\n        bounce = GetScene(p);\n        if(bounce.s < HIT_DISTANCE || dS > TRACE_DISTANCE) {\n            break;\n        }\n        dS += bounce.s;\n    }\n    // Position\n    vec3 p = ro+dS*rd;\n    vec3 n = GetNormal(p);\n    \n    // Color Shading\n    if(bounce.s < HIT_DISTANCE) {     \n        // Check Object on Ray Bounce\n        if ( bounce.t == 1.0 ) {\n            vec3 light = GetLight(p, n, 1.0);\n            C = PlanetColor(p, light);\n        } else if ( bounce.t == 2.0) {\n            C = SunColor(p, uv);\n        }\n    // Environment Shading        \n    } else {\n        // Star Field\n        vec2 pos = (uv + 1.) * 1. / 2.0;\n        pos.x += iTime*1e-1;\n        vec3 texel = texture(iChannel1, pos).rgb;\n        float value = length(texel) / 3.0;\n        value = smoothstep(0.30, 0.35, value)*3.0;\n        C = vec3(value);   \n        // Sun Field\n        vec3 center = GetLightPos().xyz;\n        value = dot(normalize(p), normalize(center));\n        value = pow(value, 55.0);\n        float b = value * (1.0 + cnoise(vec4(uv, iTime*0.06, 0.0)*1.5)) * 0.5; \n        float k = (1.5 + cnoise(vec4(normalize(uv),iTime*0.01, 0.0) * 32.0)) * 0.5;\n        vec3 bloom = vec3(b*1.5, pow(b, 3.0) * k, b*0.0) ;\n        C = mix(C, bloom, 0.5);\n    }\n\n    return vec4(C, dS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - 0.5) * 2.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Ray Marching\n    // Ray Origin\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    // Ray Direction\n    vec3 rd = vec3(uv, 2.0);\n    rd = normalize(rd);\n    // Transform Based on Mouse Movement\n    vec2 mm = ( iMouse.xy / iResolution.xy - 0.5 ) * 2.0;\n    ro.z += max(mm.y, 0.0) * SPHERE_RADIUS; // Adjust the scaling factor as needed\n    // Transform the ray direction based on mouse movement\n    // rd.xy += mm * 0.1; // Adjust the scaling factor as needed\n\n    // Bounce the Ray\n    vec4 bounce = RayMarch(ro, rd, uv);\n    // Bounce Color\n    vec3 C = bounce.xyz;\n    float sd = bounce.w;\n    \n    fragColor = vec4(C,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sigmoid(x) (1./(1.+exp(-(x))))\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\n\n// Classic Perlin noise\nfloat cnoise(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\nfloat NoiseT(float T, vec3 loc, float scale)\n{\n    return (1.0 + cnoise(vec4(loc, T*1.) * scale)) * 0.5;\n}\n\n// Color, neural network\n// https://github.com/harry7557558/Graphics/blob/master/fitting/neural-earth.ipynb\nvec3 mapEarth(vec3 p) {\n  // (12, 3) (12,)\n  vec4 v00 = sin(vec4(2.18,2.07,-.05,.04)*p.x+vec4(-1.16,2.08,1.81,-.2)*p.y+vec4(-.05,.05,-.81,-.96)*p.z+vec4(.59,-.09,-.03,-.77));\n  vec4 v01 = sin(vec4(-.53,.36,.87,-1.57)*p.x+vec4(-1.84,-2.31,-.71,1.15)*p.y+vec4(.53,.02,-1.08,-.41)*p.z+vec4(.16,.15,-.68,-.43));\n  vec4 v02 = sin(vec4(.75,-2.02,-.46,2.03)*p.x+vec4(-.64,1.16,-.56,-.29)*p.y+vec4(.75,.47,-.6,-.91)*p.z+vec4(-.69,-.53,.98,-.8));\n  // (12, 12) (12,)\n  vec4 v10 = sin(mat4(-1.98,2.1,-.12,-.7,-.17,.55,.35,-1.75,-.92,-.03,-.79,1.02,.21,-1.14,.01,1.08)*v00+mat4(-.27,2.59,-.41,.37,-1.55,-.59,-1.15,.88,.8,.8,0,.19,.22,1.48,.66,.49)*v01+mat4(-1.7,-1.18,1.5,.63,-1.35,1.04,-.39,-.32,.68,2.29,-.28,-.68,-2.15,-1.66,-.37,-1.34)*v02+vec4(-.22,-.5,-.02,1.34));\n  vec4 v11 = sin(mat4(1.09,1.62,-.72,2.4,.74,-.86,2.04,-.07,.65,-.85,1.16,.34,-1.85,1.28,1.14,.3)*v00+mat4(2.43,-2.37,1.71,-2.44,-.74,.51,-1.83,1.02,-.28,-.2,-2.83,1.08,-1.04,.83,.33,1.27)*v01+mat4(.05,-.43,-.77,1.04,1.77,1.44,-2.19,1.4,-3.9,1.1,1.22,1.57,.48,.55,2.61,1.01)*v02+vec4(-.4,.69,-2.1,-.43));\n  vec4 v12 = sin(mat4(-.15,.75,1.32,-.29,-.18,.21,.01,-2.14,.95,-1.85,1.95,-2.53,.94,.54,1.2,1.19)*v00+mat4(.31,-.66,1.91,-1.75,.87,-1.56,1.28,1.72,-.07,-1.4,-1.21,-.07,.96,-.56,-.28,1.24)*v01+mat4(.93,-1.07,2.83,-1.15,-1.29,1.83,1.59,-.15,2.55,-1.7,-2.03,-2.1,.26,-.5,1.05,-.01)*v02+vec4(-1.11,.33,3.23,2.4));\n  // (12, 12) (12,)\n  vec4 v20 = sin(mat4(-1.22,1.04,-.4,.05,.61,-1.16,-1.25,-.9,-.41,-.48,-1.4,.6,-1.37,.45,-.1,-1.82)*v10+mat4(-.53,-1.64,1.07,-.02,1.93,.9,.55,-2.21,1.2,1.01,-.92,-.92,.46,.11,-1.88,-2.65)*v11+mat4(-1.03,.62,-1.22,-.89,-2.27,-.92,-.59,.02,-.43,-1.38,2.93,1.32,2.02,.84,-.57,.91)*v12+vec4(-.6,.73,-1.59,.64));\n  vec4 v21 = sin(mat4(-3.2,.97,-.82,-.94,.42,-.26,-1.6,1.28,-.26,-2.17,.28,1.62,1.6,-.63,-1.1,.57)*v10+mat4(.81,1.76,-1.23,-1.59,-1.88,-.75,-.9,.13,-2.21,1.07,-.39,-1.54,-3.04,.5,-.56,-2.26)*v11+mat4(-.98,-.73,.83,-2.97,-1.61,-.3,1.55,-2.04,1.46,.09,-.13,.88,-.18,.5,-.43,-.2)*v12+vec4(-.08,-2.18,-1.3,1.15));\n  vec4 v22 = sin(mat4(2,.27,.01,-.38,-.11,-.9,.38,-1.35,.3,3.89,-.1,.9,-1.36,-.66,-.52,-.22)*v10+mat4(-.09,-.52,.42,.15,2.85,.16,-.53,-1.15,.27,.32,.81,1.42,-.6,-.22,1.11,2.13)*v11+mat4(-1.96,-1.06,.06,.68,-.58,-1.41,.43,.43,-1.77,-.66,-1.72,-1.22,.19,1.11,1.15,.24)*v12+vec4(.05,.85,-.72,-1.05));\n  // (8, 12) (8,)\n  vec4 v30 = sigmoid(mat4(3.74,2.98,-2.85,1.67,2.69,2.42,-2,2.01,-6.28,-1.99,4.83,-1.36,-5.06,-3.07,1.08,-6.41)*v20+mat4(-2.42,-.87,1.32,-.82,1.25,-6.41,-.49,-5.09,-.04,-.47,3.35,6.26,-3.75,-5.87,3.62,-3.36)*v21+mat4(-4.54,.41,-1.18,-3.14,-8.28,-.79,7.43,-2.98,8.06,-2.25,3.2,.48,-7.99,-3.18,1.12,-7.99)*v22+vec4(5.54,1.15,-2.06,2.02));\n  vec4 v31 = sigmoid(mat4(4.2,-6.97,1.37,2.04,3.42,.97,4.22,1.71,-6.85,2.56,-4,-2.37,-2.77,-2.33,.46,-1.98)*v20+mat4(-2.43,1.87,-2.57,-1.06,-6.1,3.38,-2.83,-2.97,.16,9.4,-4.07,-.43,-4.72,4.07,-3.46,-3.17)*v21+mat4(-1.52,5.93,-1.74,-.6,-3.53,-1.03,-2.08,-1.59,-2.03,6.98,-.7,-.64,-5.34,2.52,-2.22,-2.92)*v22+vec4(.07,-4.84,.67,.98));\n  // (3, 8) (3,)\n  float v40 = sigmoid(dot(vec4(-.93,-3.13,1.01,-1.07),v30)+dot(vec4(-1.65,2.54,-1.78,5.45),v31)+.43);\n  float v41 = sigmoid(dot(vec4(-.26,-2.16,.86,-.87),v30)+dot(vec4(-1.08,2.09,-1.23,3.8),v31)+.01);\n  float v42 = sigmoid(dot(vec4(1.31,-1.13,.97,-.65),v30)+dot(vec4(-.61,1.37,-1.19,2.14),v31)+-.71);\n  return vec3(v40, v41, v42);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsByzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 227, 227, 405], [407, 407, 431, 431, 535], [537, 537, 557, 557, 749], [751, 751, 795, 795, 1033], [1035, 1035, 1058, 1058, 1148], [1150, 1150, 1173, 1197, 1445], [1447, 1447, 1515, 1515, 1584], [1586, 1600, 1624, 1624, 1887], [1889, 1889, 1930, 1930, 2221], [2223, 2223, 2292, 2292, 3132], [3134, 3134, 3168, 3168, 3346], [3347, 3347, 3385, 3385, 4030], [4032, 4032, 4064, 4064, 5030], [5032, 5032, 5074, 5096, 6526], [6528, 6528, 6585, 6635, 7372]], "test": "untested"}
{"id": "mdScDd", "name": "Brushstroke tangent finder", "author": "sh1boot", "description": "Click on the scene to see the tangent to the curve (ie., stoke direction) at that point.\n\nBufA: Per-pixel stroke direction estimate\nBufC: hblur of BufA (time-varying strength)\nBufD: vblur of BufC (as above)\nImage: pixels blurred in BufD direction", "tags": ["blur", "filtering", "bilateral"], "likes": 4, "viewed": 262, "published": 3, "date": "1688331306", "time_retrieved": "2024-07-30T17:46:14.314713", "image_code": "float distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float filter_len = smoothstep(-1.0, 0.0, cos(iTime * 0.7 + dot(uv, vec2(-0.3, 0.4)))) * 0.002;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 blurry = texture(iChannel0, uv);\n    float len = length(blurry.xy);\n    if (len < 0.0001) {\n        col = texture(iChannel1, uv).rgb;\n    } else if (any(isnan(blurry.xy))) {\n        col = vec3(0.0);\n    } else {\n        float t = atan(blurry.y, blurry.x) * 0.5;\n        vec2 dir = vec2(cos(t), sin(t)) * filter_len;\n        vec4 sum = vec4(0.0);\n        for (int i = -stroke_length; i <= stroke_length; ++i) {\n            sum += texture(iChannel1, uv + dir * float(i));\n        }\n        col = sum.rgb / float(2 * stroke_length + 1);\n#if 0\n        if (fract(uv.y * 10.0) < 0.1) {\n            col.g = blurry.x < 0.0 ? 0.1 : 0.9;\n        } else if (fract(uv.y * 10.0) < 0.2) {\n            col.r = blurry.y < 0.0 ? 0.1 : 0.9;\n        }\n#endif\n    }\n\n    vec4 undermouse = texture(iChannel0, iMouse.xy / iResolution.xy);\n    len = length(undermouse.xy);\n    bool highlight = false;\n    if (len < 0.0001) {\n        highlight = length(iMouse.xy - fragCoord.xy) < 10.0;\n    } else if (any(isnan(blurry.xy))) {\n        highlight = length(iMouse.xy - fragCoord.xy) < 5.0;\n    } else {\n        float t = atan(undermouse.y, undermouse.x) * 0.5;\n        vec2 dir = vec2(cos(t), sin(t)) * 80.0 * len;\n        highlight = distanceToSegment(iMouse.xy - dir, iMouse.xy + dir, fragCoord.xy) < 3.0;\n    }\n    if (highlight) col = vec3(0.0, 1.0, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 getPixel(vec2 uv) {\n    return textureLod(iChannel0, uv, 0.0);\n}\n\n// Simple sRGB->Y\nfloat srgb_to_y(in vec3 colour)\n{\n    return dot(vec3(0.2126, 0.7152, 0.0722), colour);\n}\n\n// Simple polynomial weighting functions.\nfloat linear_weight(in float ref, in float val, in float threshold)\n{   \n    float dist = 1.0 - (abs(ref - val) / threshold);\n    \n    return max(dist, 0.0);\n}\n\nfloat quadratic_weight(in float ref, in float val, in float threshold)\n{\n    float lw = linear_weight(ref, val, threshold);\n    return lw * lw;\n}\n\nvec2 csquare(vec2 v) {\n    return vec2(v.x * v.x - v.y * v.y, 2.0 * v.x * v.y);\n}\n\nvec4 bilat(vec2 uv)\n{\n    vec2 max_siz = vec2(24) / iResolution.xy;\n\n    // reference value at centre of filter.\n    vec4 ref = getPixel(uv);\n    float ref_intensity = srgb_to_y(ref.xyz);\n#if 1\n    vec4 sum = vec4(0);\n\n    for (int i = 0; i < estimator_taps; i++)\n    {\n        vec4 seed = vec4(1.2, 4.5, 6.7, 8.9) * float(i);\n        vec2 ofs = vec2(gaussian(uv.xyyx, seed),\n                        gaussian(uv.yxxy, seed));\n \n        // point sample and intensity.\n        vec4 spl = getPixel(uv + ofs * max_siz);\n        float spl_intensity = srgb_to_y(spl.xyz);\n\n        // Weight depends on sample distance from reference intensity.\n        const float THRESHOLD = 0.4;\n        float weight = quadratic_weight(ref_intensity, spl_intensity, THRESHOLD);\n\n        weight *= 1.0 - clamp(abs(ref.a - spl.a), 0.0, 1.0);\n        if (dot(ofs, ofs) > 0.0000001) sum.xy += normalize(csquare(ofs)) * weight;\n    }\n#else\n    vec2 cs = vec2(cos(uv.x + iTime), sin(uv.x + iTime));\n    vec2 sum = csquare(cs);\n#endif\n    return vec4(sum.xy, ref.aa);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = vec4(bilat(uv).rgb, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 seed2 = uv.xyyx + vec4(1.2, 4.5, 6.7, 8.9) + fract(iTime);\n    float radius = blur_radius * (0.5 - 0.5 * cos(iTime * 0.5 + dot(uv, vec2(0.4, 0.3))));\n\n    fragColor = gsample(iChannel0, uv, vec2(0.1, 0.0), radius);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 seed2 = uv.xyyx + vec4(1.2, 4.5, 6.7, 8.9) + fract(iTime);\n    float radius = blur_radius * (0.5 - 0.5 * cos(iTime * 0.5 + dot(uv, vec2(0.4, 0.3))));\n\n    fragColor = gsample(iChannel0, uv, vec2(0.0, 0.1), radius);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float blur_radius = 1.0;\nconst int blur_taps = 31;\nconst int stroke_length = 6;\nconst int estimator_taps = 64;\n\n\nfloat nrand( vec2 n ) {\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\nvec2 nrand2( vec2 n ) { return vec2(nrand(n * vec2(-3.2145, 1.2345)),\n                                    nrand(n * vec2(-5.4321, 3.4521))); }\n\nfloat gaussian(vec4 seed1, vec4 seed2) {\n    return (nrand(seed1.zz + seed2.xy)\n          + nrand(seed1.ww + seed2.yz)\n          - nrand(seed1.xx + seed2.zw)\n          - nrand(seed1.yy + seed2.wx)) * 0.25;\n}\n\nfloat pdf(float x) {\n#if 0\n    // pdf for s=0.1667: `sum(uniform(-.5,.5, 3)/3)`\n    return 2.39365*exp(-18. * x * x);\n#else\n    // pdf for s=0.144: `sum(uniform(-.5,.5, 4)/4)`\n    return 2.77043 * exp(-24.1126 * x * x);\n#endif\n}\n\n\nvec4 gsample(sampler2D tex, vec2 uv, vec2 v, float radius) {\n#if 1\n    vec4 sum = vec4(0);\n    float den = 0.0;\n\n    for (int i=-blur_taps; i <= blur_taps; i++) {\n        float f = float(i) / float(blur_taps);\n        float w = pdf(f / radius);\n        vec2 ofs = v * f;\n        sum += texture(tex, uv + ofs) * w;\n        den += w;\n    }\n    return sum / den;\n#else\n    return texture(tex, uv);\n#endif\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdScDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 165], [168, 168, 225, 275, 1904]], "test": "untested"}
{"id": "ddSyDd", "name": "First Intro Shader", "author": "IronPrime99", "description": "This exercise was made following the video from YouTuber Kishimisu \"An Introduction to Shader Art Coding\".  I'm new to shader coding so, any feedback is appreciated.", "tags": ["tutorial"], "likes": 1, "viewed": 155, "published": 3, "date": "1688329383", "time_retrieved": "2024-07-30T17:46:15.164441", "image_code": "vec3 palette (float t) \n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b * cos(6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Prevoius operation to render the shader vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;//\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i++)\n    {\n        //uv *= 2.0;\n        //uv = fract(uv);\n        //uv -= 0.5;\n        uv = fract(uv * 1.5) -0.5;\n    \n        float d = length(uv) * exp(-length(uv0));\n    \n        vec3 col = palette(length(uv0) +i*0.4 + iTime*0.4);\n    \n        d = sin(d * 8. + iTime)/8.; //iTime is a global constant\n        d = abs(d);\n    \n        d = pow(0.01 / d, 1.5);\n    \n        finalColor += col * d;\n     }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 216], [218, 218, 275, 374, 985]], "test": "untested"}
{"id": "cdXyWr", "name": "Shadertoy ID database in 28Kb", "author": "morimea", "description": "this is just \"sorted array compression with dictionary\"\n168Kb of original data 28476 elements 6x8-bit char per element to:\ntotal - 28.5Kb\nCompressed without saving original order of elements.\n\nThis compression is - 1.37 bits per ASCII character in token.", "tags": ["compression", "database"], "likes": 20, "viewed": 530, "published": 3, "date": "1688315223", "time_retrieved": "2024-07-30T17:46:16.771145", "image_code": "// Created by Danil (2023+) https://github.com/danilw\n\n// self https://www.shadertoy.com/view/cdXyWr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// NOTE:\n// Shaders IDs from shadertoy public API\n// Get all shaders - https://www.shadertoy.com/howto\n\n\n// USE/CONTROL:\n// 1. type \"shaderID\" on keyboard to test if it in DB - cdXyWr - for example\n// 2. use * char/key as any character, example - **XyWr\n// 3. Input text will be highlighted green/red when its found/not found\n// 4. Enter - find next, if there no next index will not move\n// 5. Delete/Backspace to clean input\n\n\n// COLORS:\n// Green - search result\n// Red - tokens with red-number of connections, less than orange, first smallest, most rare\n// Orange - second rare tokens, number of connections under color\n// Yellow - third rare tokens, number of connections under color\n// ... Ren-Orange-Yellow is tokens with fewer connections of all tokens\n// ... right side tokens is 10+ connections, this why left only\n\n// Purple - my shaders\n// White - this shader\n\n\n// This DB version from July 2, 2023\n// im updating this DB sometime\n// previous versions:\n// https://www.shadertoy.com/view/csScDd\n// alternative version - https://www.shadertoy.com/view/mdSyDd - to test AMD Angle Cubemap performance bug\n\n\n// RESULT:\n\n// Original data - 168Kb of original data - not compressed\n\n// Sorted\n// 45Kb - 7z compression\n// 37Kb - 7z compression left+right side as separate files\n// 28.5Kb - This Shadertoy shader all data\n\n// TEST to see data is correct:\n// 1. define TEST_debug below\n// 2. make screenshot of region, rename screenshot to db_scr.png\n// 3. download this python script to compare to original data, put screenshot there to test\n// TEST LINK https://danilw.github.io/GLSL-howto/shadertoy_db_shader/test_jul0223.zip\n//#define TEST_debug\n\n// for more - read description in CubeA\n\n// Possible Shadertoy chars in tokens, order from left to right\n// 1. ['3' '4' '7' 'D' 'M' 'N' 'W' 'X' 'c' 'd' 'f' 'l' 'm' 's' 't' 'w']\n// 2. ['d' 'l' 's' 't']\n// 3. ['2' '3' 'B' 'G' 'K' 'S' 'V' 'X' 'c' 'd' 'f' 'j' 'l' 's' 't' 'y']\n// 4. ['3' 'B' 'G' 'S' 'X' 'c' 'f' 'y']\n// 5. ['D' 'R' 'W' 'z']\n// 6. ['1' '2' '3' '4' '7' '8' 'B' 'D' 'G' 'H' 'K' 'M' 'N' 'R' 'S' 'V' 'W' 'X'\n//     'c' 'd' 'f' 'h' 'j' 'l' 'm' 'n' 'r' 's' 't' 'w' 'y' 'z']\n\nconst int conet[] = int[](3,4,5);\nconst int vtxt[] = int[](74, 117, 108, 121, 32, 50, 44, 32, 50, 48, 50, 51 );\n\nconst vec3 white = vec3(0xa4, 0xc4, 0xd8) / float(0xff);\nconst vec3 whitel = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 dark = vec3(0x1d, 0x1d, 0x2b) / float(0xff);\nconst vec3 darkb = vec3(0x20, 0x40, 0x89) / float(0xff);\nconst vec3 redd = vec3(0xe1, 0x46, 0x14) / float(0xff);\nconst vec3 blue = vec3(0x05, 0x86, 0xb3) / float(0xff);\nconst vec3 green = vec3(0x05, 0xb3, 0x86) / float(0xff);\nconst vec3 orange = vec3(0xcb, 0x73, 0x3b) / float(0xff);\n\nconst vec3 col_red = vec3(0xFF, 0x28, 0x24) / float(0xff);\nconst vec3 col_ora = vec3(0xFB, 0x90, 0x39) / float(0xff);\nconst vec3 col_yel = vec3(0xFA, 0xCD, 0x3D) / float(0xff);\nconst vec3 col_p = vec3(0xA0, 0x40, 0xB0) / float(0xff);\n\nconst ivec2 tables_size = ivec2(cube_num_elems_use_sz,cube_num_elems_use_sz);\nconst float top_panel = 0.05;\nconst float borders = 0.1;\nconst vec2 text_len = vec2(3.5,1.);\n\nconst float blines = 0.065;\nconst float cell_border = 0.25;\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat lines(vec2 p, vec2 bsz, float px, float a, float b) {\n    float d = 0.;\n    d = max(d, smoothstep(px, -px, abs(sdBox(p, bsz / 2.) - a) - b));\n    return d;\n}\n\nfloat lines1d(vec2 p, vec2 bsz, float px, float a, float b) {\n    float d = 0.;\n    d = max(d, smoothstep(px, -px, (sdBox(p, bsz / 2.) - a) - b));\n    return d;\n}\n\n\n\n//using https://www.shadertoy.com/view/llyXRW\nvoid C(sampler2D tex, inout vec2 U, inout vec4 T, in int c, bool dir, float loc_scale){\n    loc_scale = clamp(loc_scale*2.,0.05*1024./iResolution.y,1.);\n    U.x+=dir?.5:-0.5;\n    vec2 tu=U/16. + fract( vec2(float(c), float(15-c/16)) / 16.);\n    tu.y=1.-tu.y;\n    vec4 tr = textureGrad(tex, tu, dFdx(tu/(16.*loc_scale)),dFdy(tu/(16.*loc_scale)));\n    if(U.x<.0||U.x>1.||U.y<0.||U.y>1. ){\n        tr*=0.;\n    }\n    T+=tr;\n}\n\nfloat print_text(sampler2D tex, vec2 U, ivec3 text){\n    vec4 T=vec4(0.);\n    for(int i=0;i<3;i++){\n        C(tex,U,T,text[i],false,scale);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\n\nfloat print_text2d(sampler2D tex, vec2 U, ivec3 text, vec3 pw){\n    mat4 T=mat4(0.);\n    for(int i=0;i<3;i++){\n        C(tex,U,T[i],text[i],false,scale);\n        T[i].x+=T[i].x*pw[i];\n    }\n    vec4 Tr = T[0]+T[1]+T[2];\n    if(length(Tr.yz)==0.)\n        return 0.;\n    return Tr.x;\n}\n\nmat3 get_int(int cval, out int nlen) {\n    mat3 ret=mat3(0.);\n    nlen=0;\n    if(cval==0){\n        ret[0][0]=float(48);\n        nlen+=1;\n        return ret;\n    }\n    int neg = 0;\n    if(cval<0){\n        neg=45;\n        cval = abs(cval);\n    }\n    for(int i=0;i<9;i++){\n        if(cval>0){\n            int tv=cval%10;\n            ret[i/3][i%3]=float(48+tv);\n            cval=cval/10;\n            nlen+=1;\n        }\n        else{\n            break;\n        }\n    }\n    if(neg!=0){\n        ret[nlen/3][nlen%3]=float(neg);\n        nlen+=1;\n    }\n    return ret;\n}\n\nfloat print_int(sampler2D tex, vec2 U, int val, float loc_scale) {\n    int num_length;\n    mat3 str = get_int(val, num_length);\n    vec4 T=vec4(0.);\n    for(int i=0;i<num_length;i++){\n        C(tex, U,T,int(str[i/3][i%3]), true, loc_scale);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\n\n\nconst ivec4 bar_xy =   ivec4(0,0+cube_num_elems_use_sz+10,1,0+cube_num_elems_use_sz+10);\nconst ivec4 im_xy =    ivec4(0,1+cube_num_elems_use_sz+10,1,1+cube_num_elems_use_sz+10);\nconst ivec4 click_xy = ivec4(0,2+cube_num_elems_use_sz+10,1,2+cube_num_elems_use_sz+10);\nconst ivec4 click_pm = ivec4(0,3+cube_num_elems_use_sz+10,1,3+cube_num_elems_use_sz+10);\nconst ivec2 inp_buf1 = ivec2(0,4+cube_num_elems_use_sz+10);\nconst ivec2 inp_buf2 = ivec2(1,4+cube_num_elems_use_sz+10);\n\nconst ivec2 unp_reg = ivec2(cube_num_elems_use_sz*2, cube_num_elems_use_sz);\nconst ivec2 unp_buf = ivec2(0,7+cube_num_elems_use_sz+10);\nconst ivec2 sest_idx_res = ivec2(0,8+cube_num_elems_use_sz+10+unp_reg.y);\nconst ivec2 is_toka = ivec2(0,5+cube_num_elems_use_sz+10);\nconst ivec2 is_tokb = ivec2(1,5+cube_num_elems_use_sz+10);\n\n\nconst vec4 bar_xy_sc = vec4(vec2(10.),vec2(10.));\nconst vec4 im_xy_sc = vec4(vec2(1.),vec2(1.));\nconst vec4 click_xy_sc = vec4(vec2(cube_num_elems_use_sz+1,cube_num_elems_use_sz+1),vec2(10.));\nconst vec4 click_pm_sc = vec4(vec2(1.),vec2(10.));\n\nvec4 loadval16(ivec2 ipx) {\n    ivec2 side_sz = textureSize(iChannel0,0).xy;\n    return read_cubem(iChannel0, ipx, cube_side, side_sz);\n}\n\nconst ivec2 resetx = ivec2(2,2+cube_num_elems_use_sz+10);\nbool is_reset(){\n    return loadval16(resetx).w<0.5;\n}\n\nvec4 loadval2x16(ivec4 ipx, vec4 scale) {\n    if(is_reset())return vec4(0.);\n    ivec4 a = ivec4(loadval16(ipx.xy)+float(0x7ff/2));\n    ivec4 b = ivec4(loadval16(ipx.zw)+float(0x7ff/2));\n    return scale*2.*(vec4((a<<11)+b)/float(0x3FFFFF)-0.5);\n}\nvec3 print_tk(vec2 sop, vec2 res, vec2 im, vec2 p, ivec2 idx, vec3 col, bool rbrd, float panel, float nidx, float px, vec3 clc){\n    float d = 0.;\n    int l_idx = idx.x+idx.y*cube_num_elems_use_sz;\n    \n    float fm = 1.;\n    vec3 bcol = darkb;\n    vec3 embcol = darkb;\n    vec3 tacol = dark;\n    vec3 tbcol = dark;\n    \n    vec4 ta = loadval16(unp_buf+idx*ivec2(2,1));\n    vec4 tb = loadval16(unp_buf+idx*ivec2(2,1)+ivec2(1,0));\n    ivec3 taa = ivec3(32,32,32);\n    ivec3 tbb = ivec3(32,32,32);\n    if(int(ta.x)>0){\n        taa=ivec3(ta.xyz);\n        tbb=ivec3(tb.xyz);\n    }\n    \n    int tfo = int(ta.w);\n    int tfob = int(tb.w);\n    bool tfio = tfo>50&&tfob>50;\n    if(tfo>50)tfo=tfo-100;\n    bool fo = tfo>0;\n    \n    switch(tfo/10){\n        case 1:bcol = col_red;tacol = -col_red*0.5;fm = 0.95;break;\n        case 2:bcol = col_ora;tacol = -col_ora*0.5;fm = 0.95;break;\n        case 3:bcol = col_yel;tacol = -col_yel*0.5;fm = 0.75;break;\n    }\n   \n    switch(tfo-(tfo/10)*10){\n        case 1:{vec3 tc = col_p;if(bcol==darkb){bcol = tc;fm = 0.5;}else{embcol = tc;tacol = tc;tbcol = tc;}}break;\n        case 2:{vec3 tc = whitel;if(bcol==darkb){bcol = tc;fm = 0.85;}else{embcol = tc;tacol = tc;tbcol = tc;}}break;\n    }\n    \n    if(fo){\n        d = lines1d(p, text_len-cell_border, px*1./scale, 0.051, 0.005);\n        col = mix(col, bcol, fm*d*panel*nidx);\n    }\n    \n    if(tfio){\n        d = lines1d(p, text_len-cell_border, px*1./scale, 0.051, 0.005);\n        col = mix(col, green, 0.55*d*panel*nidx);\n    }\n    \n    \n    \n    if(idx==ivec2(clc.xy)){\n        d = lines1d(p, text_len-cell_border, px*1./scale, 0.051, 0.005);\n        col = mix(col, whitel, clamp(1.-clc.z,0.,1.)*0.45*d*panel*nidx);\n    }\n    \n    d = lines(p, text_len-cell_border, 1.*px*1./scale, 0.051, 0.005);\n    col = mix(col, embcol, d*panel*nidx);\n    d = 0.;\n    \n    vec3 tma = vec3(0.);\n    vec3 tmb = vec3(0.);\n    if(tfio){\n        vec4 tv = loadval16(inp_buf1);\n        vec4 tv2 = loadval16(inp_buf2);\n        ivec3 tsa = ivec3(abs(tv.xyz));\n        ivec3 tsb = ivec3(abs(tv2.xyz));\n        const int ka_mul = 42;\n        bvec3 tsta = bvec3(tsa.x>0&&tsa.x!=95&&tsa.x!=ka_mul,tsa.y>0&&tsa.y!=95&&tsa.y!=ka_mul,tsa.z>0&&tsa.z!=95&&tsa.z!=ka_mul);\n        bvec3 tstb = bvec3(tsb.x>0&&tsb.x!=95&&tsb.x!=ka_mul,tsb.y>0&&tsb.y!=95&&tsb.y!=ka_mul,tsb.z>0&&tsb.z!=95&&tsb.z!=ka_mul);\n        tma+=vec3(tsta);\n        tmb+=vec3(tstb);\n    }\n    vec4 tv = loadval16(sest_idx_res);\n    vec4 lsta = loadval16(is_toka);\n    int flgsa = int(abs(lsta.w));\n    vec4 lstb = loadval16(is_tokb);\n    int flgsb = int(abs(lstb.w));\n    ivec2 sid = ivec2(-1);\n    if(tv.w>0.&&(flgsa!=20&&flgsb!=20)){\n        sid = ivec2((int(abs(tv).x)<<8)+int(abs(tv).y),(int(abs(tv).z)<<8)+int(abs(tv).w));;\n                    \n        if(sid==idx){\n            d = lines1d(p, text_len-cell_border, px*1./scale, 0.051, 0.005);\n            col = mix(col, green*green, 0.55*d*panel*nidx);\n        }\n    }\n    d = print_text2d(iChannel3, p*1.25+vec2(2.25,0.5), taa, tma);\n    if(rbrd) d = clamp(d,0.,1.)*0.;// text dfd fix, it still confused on cells\n    col = mix(col, tacol, d*.47*panel*nidx);\n    d = print_text2d(iChannel3, p*1.25+vec2(0.75,0.5), tbb, tmb);\n    if(rbrd) d = clamp(d,0.,1.)*0.;// text dfd fix, it still confused on cells\n    col = mix(col, tbcol, d*.47*panel*nidx);\n    \n    \n    if(tv.w>0.&&(flgsa!=20&&flgsb!=20)){\n        vec2 tpi = vec2(sid)*(text_len);\n\n        vec2 tp = -tpi+(im)/scale-0.5*text_len;\n        vec2 szi = vec2(borders,borders+top_panel);\n        tp = clamp(tp,(-res+szi)/scale,vec2(0.));\n        d = 1.-smoothstep(0.75,0.75+px/scale,length(tp+sop/scale));\n        d = min(d,smoothstep(text_len.y*.25,text_len.y*.25+px/scale,abs(tp+sop/scale).y));\n        col = mix(col, green*green*0.85, 0.75*d);\n    }\n    return col;\n}\n\n\nvec3 print_st(vec2 p, vec3 col);\nvec4 draw(vec2 p, float px, vec2 ires){\n    vec2 res=ires.xy/ires.y;\n    \n    vec2 im = ((loadval2x16(bar_xy,bar_xy_sc).xy*ires.xy)/ires.y);\n    vec3 clc = loadval2x16(click_xy,click_xy_sc).xyz;\n    \n    vec4 bp = vec4(0.2, 0.045, vec2(0.,-res.y*0.5+0.045));\n    \n    vec3 col = white;\n    \n    vec2 sop = p;\n    \n    p+=0.5*res-vec2(borders*0.5);\n    vec2 local_sc = (vec2(tables_size)-(res-vec2(borders,borders+top_panel))/(scale*text_len))*scale*text_len;\n    p+=(im/res)*local_sc;\n    \n    vec2 op = p;\n    float a = 0.;\n    float d = 0.;\n    \n    vec2 tp = sop+vec2(0.,0.5*top_panel);\n    d = lines(tp, res-vec2(borders,borders+top_panel), px, 0.01, 0.001);\n    col = mix(col, dark, d);\n    \n    // not bool to avoid dfd bugs with texture font\n    float panel = lines1d(tp, res-vec2(borders,borders+top_panel), px, 0.01, 0.001); \n    \n    p=sop+vec2(0.,-0.5+0.5*top_panel+0.5*borders);\n    if(p.y>0.&&p.x<0.){\n        d = lines1d(p+2.*vec2(0.0151)*vec2(1.,-1.), vec2(0.0151), px, 0.01, 0.001);\n        col = mix(col, whitel, 0.75*d);\n        d = lines1d(p+2.*vec2(0.0151)*vec2(2.75,-1.), vec2(0.0151), px, 0.01, 0.001);\n        col = mix(col, col_p, 0.5*d);\n        d = lines1d(p+2.*vec2(0.0151)*vec2(5.5,-1.), vec2(0.0151), px, 0.01, 0.001);\n        col = mix(col, col_yel, 0.65*d);\n        d = lines1d(p+2.*vec2(0.0151)*vec2(7.25,-1.), vec2(0.0151), px, 0.01, 0.001);\n        col = mix(col, col_ora, 0.65*d);\n        d = lines1d(p+2.*vec2(0.0151)*vec2(9.,-1.), vec2(0.0151), px, 0.01, 0.001);\n        col = mix(col, col_red, 0.65*d);\n        float td = lines(p+2.*vec2(0.0151)*vec2(1.,-1.), vec2(0.0151), px, 0.01, 0.001);\n        td = max(td,lines(p+2.*vec2(0.0151)*vec2(2.75,-1.), vec2(0.0151), px, 0.01, 0.001));\n        td = max(td,lines(p+2.*vec2(0.0151)*vec2(5.5,-1.), vec2(0.0151), px, 0.01, 0.001));\n        td = max(td,lines(p+2.*vec2(0.0151)*vec2(7.25,-1.), vec2(0.0151), px, 0.01, 0.001));\n        td = max(td,lines(p+2.*vec2(0.0151)*vec2(9.,-1.), vec2(0.0151), px, 0.01, 0.001));\n        col = mix(col, dark, td);\n    }\n    \n    d = print_int(iChannel3, 35.*(p+vec2(0.025+0.246,0.015)),conet[0], 1.);\n    d = max(d,print_int(iChannel3, 35.*(p+vec2(0.025+0.195,0.015)),conet[1], 1.));\n    d = max(d,print_int(iChannel3, 35.*(p+vec2(0.025+0.14,0.015)),conet[2], 1.));\n    col = mix(col, dark, 0.75*d);\n    \n    ivec2 idx = ivec2(op/(text_len*scale));\n    float nidx = ((op.x<0.||op.y<0.)||(idx.x>=tables_size.x||idx.y>=tables_size.y))?0.:1.;\n    \n    p = fract(op/(text_len*scale))-0.5;\n    p=p*text_len;\n    \n    bool rbrd = lines1d(p, text_len-cell_border, 1.*px*1./scale, 2.*0.051, 2.*0.005)<0.99;\n    \n    if(((idx.x)%4)==0){\n        //d = lines1d(p, text_len-cell_border, px*1./scale, 0.051, 0.005);\n        //col = mix(col, whitel, 0.123*d*panel*nidx);\n    }else\n    if(((idx.y*2)%3)==0){\n        d = lines1d(p, text_len-cell_border, px*1./scale, 0.051, 0.005);\n        col = mix(col, darkb, 0.073*d*panel*nidx);\n    }\n    \n    col = print_tk(sop+0.5*res-vec2(borders*0.5), res, (im/res)*local_sc, p, idx, col, rbrd, panel, nidx, px, clc);\n    \n    im*=(1.-0.5*2.*blines);\n    if(step(res.x*0.5-sop.x,blines*0.5)>0.5){\n        col = mix(col, dark, 0.5*step(abs(sop.y-im.y+0.5*res.y-0.5*blines),blines));\n    }\n    if(step(res.y*0.5+sop.y,blines*0.5)>0.5){\n        col = mix(col, dark, 0.5*step(abs(sop.x-im.x+0.5*res.x-0.5*blines*res.x),blines));\n    }\n    \n    col = print_st(sop, col);\n    \n    \n    \n    float vignetteAmt = 1. - dot(sop * 0.65, sop * 0.65);\n    col *= max(vignetteAmt,0.6);\n    col = col / 2. + col*col;\n    col += (hash12(sop*ires*2.33) - .5)*.07;\n    col = clamp(col, vec3(0.), vec3(1.));\n    \n    return vec4(col,a);\n}\n\n#ifdef TEST_debug\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx=ivec2(fragCoord);\n    if(ipx.x>=cube_num_elems_use_sz*2||ipx.y>=cube_num_elems_use_sz){\n        fragColor=vec4(0.);\n        return;\n    }\n    \n    // v1\n    vec4 tval = loadval16(ipx+unp_buf);\n    ivec3 chrs = ivec3(abs(tval.xyz));\n    fragColor = vec4(vec3(chrs)/255.,1.0);\n    \n    // v2\n    // equal but from token id\n/*\n    ivec2 new_db_reg = ivec2(0,cube_num_elems_use_sz);\n    ivec2 ta_reg = ivec2(new_db_reg.x+new_db_reg.y,0);\n    ivec2 tb_reg = ivec2(ta_reg.x+cube_tokens_use_sz,0);\n    \n    ivec2 lipx = ipx/ivec2(2,1);\n    \n    vec4 t_idx = loadval16(lipx);\n    ivec3 taa = ivec3(0);\n    ivec3 tbb = ivec3(0);\n    if(t_idx.x>0.){\n        int a_idx = (int(t_idx.x)<<8)+int(t_idx.y);\n        ivec2 aidx = ivec2(a_idx%32,a_idx/32);\n        vec4 ta = loadval16(ivec2(ta_reg) + aidx);\n        int b_idx = (int(t_idx.z)<<8)+int(t_idx.w);\n        ivec2 bidx = ivec2(b_idx%32,b_idx/32);\n        vec4 tb = loadval16(ivec2(tb_reg) + bidx);\n        taa = ivec3(ta.xyz);\n        tbb = ivec3(tb.xyz);\n    }\n    if(ipx.x%2==0) fragColor = vec4(vec3(taa)/255.,1.0);\n    else fragColor = vec4(vec3(tbb)/255.,1.0);\n*/\n}\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px=1.5/iResolution.y;\n    vec2 res=iResolution.xy/iResolution.y;\n    vec2 uv=fragCoord/iResolution.y-0.5*res;\n    vec4 c=draw(uv, px, iResolution.xy);\n    \n    fragColor = vec4(c.rgb,1.0);\n}\n#endif\n\n\n\n\n\n\n\n\n\n\nint text_l[] = int[](87, 97, 105, 116, 105, 110, 103, 46, 46, 46) ;\nint text_i[] = int[](73, 110, 112, 117, 116, 58) ;\nint text_e[] = int[](69, 114, 114, 111, 114, 44, 32, 116, 114, 121, 32, 116, 111, 32, \n                    114, 101, 102, 114, 101, 115, 104, 32, 112, 97, 103, 101 ) ;\n\n\nvec3 print_st(vec2 p, vec3 col){\n    float d = 0.;\n    vec4 T=vec4(0.);\n    p.y+=-0.5+0.09;\n    p*=10.;\n    vec2 tp = p;\n    /*tp.x+=7.;\n    for(int i=0;i<text_l.length();i++){\n        C(iChannel3,tp,T,text_l[i],false,1.);\n    }\n    if(length(T.yz)!=0.) d = max(d, T.x);\n    */\n    T=vec4(0.);\n    tp = p;\n    for(int i=0;i<text_i.length();i++){\n        C(iChannel3,tp,T,text_i[i],false,1.);\n    }\n    if(length(T.yz)!=0.) d = max(d, T.x);\n    col = mix(col, darkb, d*0.47);\n    T=vec4(0.);\n    tp = p+vec2(.9,-0.0035)*10.;tp*=1.27;d = 0.;\n    for(int i=0;i<vtxt.length();i++){\n        C(iChannel3,tp,T,vtxt[i],false,1.);\n    }\n    if(length(T.yz)!=0.) d = max(d, T.x);\n    col = mix(col, darkb, d*0.27);\n    T=vec4(0.);\n    tp = p;d = 0.;\n    tp.y-=(-0.5+0.09)*10.;tp.x+=0.65*10.;\n#ifdef NO_COMPILE\n    int text_tmpe1[] = int[](100, 111, 101, 115, 32, 78, 79, 84, 32, 119, 111, 114, 107, 32 ,105, 110, 32, 65, 78, 71, 76, 69, 32, 33, 33, 33) ;\n    int text_tmpe2[] = int[](84, 111, 32, 99, 111, 109, 112, 105, 108, 101, 32, 45, 32, 114, 101, 97, 100, 32, 67, 111, 109, 109, 111, 110 ) ;\n    for(int i=0;i<text_tmpe1.length();i++){\n        C(iChannel3,tp,T,text_tmpe1[i],false,1.);\n    }\n    if(length(T.yz)!=0.) d = max(d, T.x);\n    col = mix(col, redd, d);\n    tp = p;d = 0.;\n    tp.y-=(-0.65+0.09)*10.;tp.x+=0.65*10.;\n    for(int i=0;i<text_tmpe2.length();i++){\n        C(iChannel3,tp,T,text_tmpe2[i],false,1.);\n    }\n    if(length(T.yz)!=0.) d = max(d, T.x);\n    col = mix(col, redd, d);\n#else\n    if(iFrame>120&&(loadval16(ivec2(0,0)).x<0.5||loadval16(ivec2(1,0)).x<0.5||loadval16(ivec2(0,1)).x<0.5||loadval16(ivec2(10,10)).x<0.5||abs(loadval16(ivec2(unp_buf))).x<0.5||abs(loadval16(ivec2(unp_buf+5))).x<0.5)){\n        for(int i=0;i<text_e.length();i++){\n            C(iChannel3,tp,T,text_e[i],false,1.);\n        }\n        if(length(T.yz)!=0.) d = max(d, T.x);\n        col = mix(col, redd, d);\n    }\n#endif\n    T=vec4(0.);\n    tp = p;\n    tp.x+=-3.;\n    int text_b[] = int[](95, 95, 95, 95, 95, 95) ;\n    vec3 tcol = darkb;\n    float tca = 0.47;\n    if(p.x>0.&&p.y>0.){\n        if(!is_reset()){\n            vec4 tv = loadval16(inp_buf1);\n            text_b[0] = int(tv[0]);text_b[1] = int(tv[1]);text_b[2] = int(tv[2]);\n            tv = loadval16(inp_buf2);\n            text_b[3] = int(tv[0]);text_b[4] = int(tv[1]);text_b[5] = int(tv[2]);\n        }\n\n        vec4 lsta = loadval16(is_toka);\n        int flgsa = int(abs(lsta.w));\n        vec4 lstb = loadval16(is_tokb);\n        int flgsb = int(abs(lstb.w));\n        if(flgsa==20||flgsb==20){\n            tcol = redd;\n            tca = 0.87;\n        }else{\n            vec4 lsta = loadval16(sest_idx_res);\n            if(lsta.w>0.){\n                tcol = green;\n                tca = 0.87;\n            }else{\n                if(lsta.z>0.){\n                    tcol = redd;\n                    tca = 0.87;\n                }\n            }\n        }\n    }\n    T=vec4(0.);d = 0.;\n    for(int i=0;i<text_b.length();i++){\n        C(iChannel3,tp,T,text_b[i],false,1.);\n    }\n    \n\n    if(length(T.yz)!=0.) d = max(d, T.x);\n    \n    // debug\n/*\n    ivec4 tva = ivec4(1.*loadval16(inp_buf1));\n    //tva.y=int(texelFetch(iChannel1,ivec2(0+33*2+3,0),0).x);\n    //ivec4 tva = ivec4(1.*sign(loadval16(inp_buf1)));\n    //const ivec2 sest_idx_reg = ivec2(0,9+cube_num_elems_use_sz+10+unp_reg.y);\n    //ivec4 tva = ivec4((loadval16(sest_idx_reg+ivec2(0,0))));\n\n    d+= print_int(iChannel3, 1.35*(tp+0.5)-vec2(-17.5,0.5),tva.x,1.);\n    d+= print_int(iChannel3, 1.35*(tp+0.5)-vec2(-16.0,0.5),tva.y,1.);\n    d+= print_int(iChannel3, 1.35*(tp+0.5)-vec2(-14.5,0.5),tva.z,1.);\n    d+= print_int(iChannel3, 1.35*(tp+0.5)-vec2(-13.0,0.5),tva.w,1.);\n*/\n    \n    col = mix(col, tcol, d*tca);\n    return col;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// map of connections 1 and 2\n\nuint map_uint_0[] = uint[](\n0x64A16929u, 0x48BF0DC5u, 0xD56029B3u, 0xFC6D27A8u, 0xEEF9049Cu, 0x7841DA73u, \n0xAD62E349u, 0x23E931BBu, 0x2959F5BDu, 0x62129734u, 0x53315299u, 0xB2199DFBu, \n0x50F06153u, 0xE463590Au, 0x940895F9u, 0xB4D69285u, 0xCD7DDBDBu, 0x61347532u, \n0x0F612077u, 0x7B1C9459u, 0x9E35E8ECu, 0xCD8788BCu, 0xB1487CFDu, 0x635072EBu, \n0xB08E82C4u, 0x726C3446u, 0x4EEEC0ABu, 0x25E0AE92u, 0x9B0BB4B7u, 0x22C650BBu, \n0x20953FAEu, 0x3F1CB076u, 0x07326414u, 0x50CE3DE5u, 0xC630CA05u, 0xC6535857u, \n0x6EDB0CB4u, 0x5B5A3833u, 0x028F7EA9u, 0x751F7A71u, 0xAC531A28u, 0x59C5EBF9u, \n0x12FC7EA9u, 0x0F3A884Fu, 0x82849022u, 0x4246078Bu, 0xED3FCCC9u, 0xB8DFA03Au, \n0xAF800AD5u, 0x310BF40Du, 0xBF33D3A4u, 0x40F234B1u, 0x14EC583Bu, 0xBA34BB81u, \n0xE520F554u, 0x2EB85BFAu, 0x0624A65Cu, 0x2D8F13B9u, 0x2318BD63u, 0x0CA060F7u, \n0x9CD1E4E5u, 0x4D948B3Fu, 0x310F0915u, 0x5021F779u, 0x8E7B7A16u, 0xB1BD6361u, \n0x50AC7238u, 0x293F316Bu, 0x84C7E670u, 0x4F2C6329u, 0x83B77CD5u, 0xAF890A7Au, \n0x1D7C3D8Au, 0x58ACEF39u, 0xC92042ACu, 0x7D954EFAu, 0x2D4349B3u, 0xB0799402u, \n0x5B6C42FAu, 0xBCE287BBu, 0xE3E75F61u, 0x334CC068u, 0xDB766C5Cu, 0x19C5F269u, \n0x37185E15u, 0x376068FCu, 0x92C8B986u, 0x576B07EFu, 0xB216C252u, 0x6318242Du, \n0x4E59DF58u, 0xFEB1C962u, 0x8C5D36D8u, 0x03F88BC7u, 0x0940B89Fu, 0xC425A7CEu, \n0x32D1FD7Bu, 0xEA5F36F8u, 0xE6E50BBBu, 0x2115CEDCu, 0xB2B29A25u, 0x9C868F8Fu, \n0xCA96310Du, 0x517311B3u, 0x8A7D46F0u, 0xD0C13A80u, 0x34626CCEu, 0xAA7BD51Bu, \n0x6F10DFA1u, 0x6F2AAF8Eu, 0x8F457F05u, 0x884F43B8u, 0x25431726u, 0x1083DF8Eu, \n0x8DA45162u, 0x52F7E918u, 0x8D45D690u, 0xD7AC6ACFu, 0xAEC5824Eu, 0xC72EB715u, \n0x616649AEu, 0xB8F70578u, 0xE086136Eu, 0x626EEA77u, 0x5929061Au, 0x3B752250u, \n0x3DE195F0u, 0xFA06A221u, 0xAFB0E7F4u, 0xEAA08EB4u, 0xE13DFF0Cu, 0x533D0A2Du, \n0x9C85A1A1u, 0x13242FADu, 0xC671A92Eu, 0x2CA82BE4u, 0xB9C2B38Fu, 0x666D9273u, \n0x372EED13u, 0x2AAF7E75u, 0x01ABC7A2u, 0x947FAD9Au, 0x4A9F35F2u, 0xA415A61Fu, \n0x878B908Du, 0xF6A3078Fu, 0xAB2A5C83u, 0x7A4F10F7u, 0x89362307u, 0x1AA31833u, \n0x208C0D57u, 0xF8F0FF68u, 0x7E765258u, 0xE3DAAEF3u, 0xCE2800D8u, 0xEF4C1E1Eu, \n0xAA3A7738u, 0x618B35DBu, 0x32EC96D3u, 0x232D46B6u, 0x5FA72F10u, 0x35DF271Au, \n0x9104807Du, 0x8854D452u, 0x28C7C4F0u, 0xC7020A94u, 0x53207814u, 0x82663530u, \n0xD8593594u, 0x6EA21756u, 0x5933635Eu, 0x462BE3DEu, 0x58DBF004u, 0x6239E18Du, \n0x4082F73Au, 0x8D68A416u, 0x259468E4u, 0xAB115FDBu, 0xBD9D4136u, 0x43FD5577u, \n0xF81B547Eu, 0x07842674u, 0x6FAE2175u, 0x896DB7AFu, 0x304A8AA4u, 0x20F93752u, \n0x30B481AEu, 0x507D410Fu, 0x1F73E438u, 0x3D3CF2D1u, 0xF7E19BEDu, 0xE4B391DEu, \n0x6D9BDDC4u, 0xA45235B4u, 0xF370D403u, 0xFF0E5301u, 0x8D25725Cu, 0x6DE0842Cu, \n0x6F190F13u, 0x76E2A740u, 0x2AC4748Au, 0x98D473A9u, 0x304E07EFu, 0x40804360u, \n0x86F1B792u, 0xA5266A19u, 0xC8557313u, 0xB451D272u, 0xC5161A3Fu, 0x59E0094Au, \n0xDEBB2062u, 0xE077FF3Eu, 0xC25123AFu, 0x880FE53Cu, 0x9DE91F36u, 0x6B6F14BCu, \n0x3B526B65u, 0x68A7B71Eu, 0x021FE08Fu, 0x3ABE1F5Au, 0x5D71B326u, 0x0F6D2D69u, \n0xDDD17FF8u, 0x071D0B2Cu, 0x3AC8AE2Au, 0x62AF1DAAu, 0xA9E12617u, 0x09A27F7Eu, \n0xAD394EBDu, 0x6C19A674u, 0x94AEDA46u, 0xF5ACC9A5u, 0x99CEA9B7u, 0x86261B49u, \n0x42FB2E6Cu, 0xB021477Fu, 0xAD60487Du, 0xFFD3C802u, 0x38C55C5Bu, 0x8897CAFBu, \n0x23AA2F17u, 0xF52F31F3u, 0x7806A41Eu, 0x7F411ED5u, 0x6B6D020Eu, 0xEFE62B91u, \n0x858DD4EEu, 0x511CB9FBu, 0x4ED555CAu, 0x1C69D99Au, 0x41CAA6B8u, 0x6B211ECFu, \n0xE5F5F58Fu, 0x118B2399u, 0x34FD0159u, 0xC01EA1BEu, 0xE3EA74A1u, 0x4D554342u, \n0xFDA619FDu, 0xE1E80C9Au, 0xC2F2E6D8u, 0x25CCC8D4u, 0x464112B3u, 0xCFB926B1u, \n0x99B59EE3u, 0xA92E7329u, 0xD7A6A253u, 0x412D030Cu, 0xC53C7152u, 0x0C22FA71u, \n0xE4AFE610u, 0x3811A2A9u, 0xCB2678FAu, 0x62A28554u, 0x5E06FEDAu, 0x7F900A54u, \n0x0F07CFFDu, 0xC5E80B5Fu, 0x1D8E2CB8u, 0x91945896u, 0x4C0F4811u, 0x91832E75u, \n0x2F0DB89Au, 0xF08880E3u, 0x1A14DE86u, 0x57082E4Du, 0x974C71F7u, 0x8A57055Eu, \n0xB0A91DDAu, 0x73966F66u, 0xA3B2BAFFu, 0xAEAC5FB8u, 0x582B4193u, 0x32B1D256u, \n0xEE304A9Au, 0x90D5991Du, 0x90225021u, 0x8CEB58A2u, 0xC12DB738u, 0xF437E6A0u, \n0x61DBB629u, 0x566775BAu, 0xF90BC9D6u, 0x3CEFC513u, 0xDE9ED92Fu, 0x49783519u, \n0x3FB8D6C7u, 0xE7C75E4Du, 0x64F8ED29u, 0xAA8E5F95u, 0x43C0E68Bu, 0x8D792992u, \n0x889CBAE6u, 0xAAB063C1u, 0xD9925B54u, 0x0C17C947u, 0xF7A3E0C1u, 0x0992FDBCu, \n0xAFCFAAA4u, 0x8EA7C4E7u, 0xF515B4E3u, 0xDBED695Du, 0xE0A430BAu, 0xF15CD663u, \n0xE5621136u, 0xF5916363u, 0x68E2F463u, 0x03ECA44Au, 0x32278393u, 0x4E4A6BEFu, \n0x52576C28u, 0x9E53E8FAu, 0x87AAB8CAu, 0xE907CE13u, 0xF32B4FF3u, 0x04FF7F27u, \n0xDFA27FAEu, 0xF59B6308u, 0x93B65765u, 0x03219D67u, 0x73B23555u, 0x30B4855Eu, \n0xE1CB0D3Au, 0xB001F4A9u, 0xB71E60B2u, 0x6831D904u, 0xBE1F3FF3u, 0x9D8B081Eu, \n0xDF45CAB0u, 0x3CBDF8C9u, 0x08644C42u, 0x9588B7F7u, 0x2DB779C1u, 0x6CCDF022u, \n0x1432D93Au, 0x2BB2DE71u, 0xA8B478D7u, 0x72D1BD14u, 0xCAC2409Eu, 0x8A42C5CCu, \n0x356727A3u, 0x532DECD6u, 0xC29F1C95u, 0x30F0A970u, 0xB25AD140u, 0x3AEB19D7u, \n0xD009ACC5u, 0xACE558E8u, 0xAB2C5BC3u, 0xA228B84Du, 0x70797217u, 0x8CB070B4u, \n0xAFBE554Fu, 0xF3432FD3u, 0x75C40D4Au, 0xF3E05FFFu, 0x6F807247u, 0x3042A793u, \n0xA649F8F5u, 0xE4C07FE0u, 0xF57B7DC6u, 0xE1A4DD65u, 0xBA3566A2u, 0xEB9238B7u, \n0x75267D6Eu, 0x03D7F184u, 0xE9AD4CF5u, 0x97377E2Bu, 0x3C852915u, 0x305E3384u, \n0x0D500B04u, 0xA5E8AA69u, 0xDDD3BDC5u, 0xA9C17CD4u, 0x701004EFu, 0x0AB28436u, \n0x53EC40BEu, 0x429B1822u, 0x50AD1594u, 0xC685B57Cu, 0xBDC23BA4u, 0xFFFD3B0Du, \n0xCCA3F60Du, 0x08689907u, 0x438CE6BEu, 0x3969670Eu, 0x391F79F2u, 0x589015EAu, \n0x6DA4E125u, 0x29735B23u, 0xECDF1FCAu, 0xFEA0F2C0u, 0x8252A155u, 0x06E7676Bu, \n0x4C52D9B5u, 0x6D6065D0u, 0x42443753u, 0x326738C7u, 0x0F38D518u, 0xBD8EB586u, \n0x06150E18u, 0x8E2AAD3Au, 0x1EF4DE5Bu, 0x59690847u, 0x2F7575EFu, 0x9DA6F257u, \n0x020BCFEFu, 0xFACC69DBu, 0x01F7C039u, 0x1D907F86u, 0x1A9EDABFu, 0xC0DB0B9Au, \n0x0903E4C9u, 0x6CD0C5D6u, 0xB793B855u, 0xD5BA7B0Cu, 0xD416DE22u, 0xEB3AB330u, \n0x0E1492E6u, 0x7416652Cu, 0x3088C7ADu, 0xDBC0A29Bu, 0x23A35B62u, 0x8C2AEA58u, \n0x1992912Bu, 0x9308FF01u, 0x4244B59Eu, 0x74E487B3u, 0x4E7C526Cu, 0xA18D39ECu, \n0x8F08628Du, 0x1DC4735Au, 0xD71726A3u, 0x69E3E4BBu, 0x70BD248Eu, 0x1268B71Au, \n0x2B9CCEA9u, 0xF49B89AFu, 0x56E27BE3u, 0x900B22CAu, 0x090DDCC4u, 0x70F2AE38u, \n0x10FBFC25u, 0x07DE6060u, 0x4985FD04u, 0x2C1E7487u, 0x0D1EE2C2u, 0x01176C8Bu, \n0x94C3270Eu, 0x4610BD47u, 0x5E572622u, 0x43A06239u, 0x267992DBu, 0x0A608666u, \n0x71B31A5Fu, 0x2FD7F9EAu, 0x7077148Du, 0xE23D834Au, 0x9F0472B8u, 0xB382DE60u, \n0x832D17B2u, 0x14529B89u, 0xD50AB497u, 0x08E49FC6u, 0xB73ADDA4u, 0x11281962u, \n0x412AE41Cu, 0xE2D1F9FEu, 0xDD152A80u, 0x87F1D9DEu, 0x951CAE7Eu, 0xF5A581E2u, \n0x47A52BF7u, 0x69EF46DBu, 0xD3662B32u, 0x6B68B741u, 0xE5BC2815u, 0x21F801F3u, \n0xA9CE6FCFu, 0x08FF8E14u, 0xEE8676BAu, 0xDE6E38F7u, 0x14EE0FD4u, 0x66FF2447u, \n0x2AF87774u, 0x29548543u, 0xDF8F6584u, 0xBFF526BEu, 0x3B99960Eu, 0x1591F886u, \n0xAFBC8A9Fu, 0xDF79591Eu, 0x8DDD3B6Fu, 0x19774CBAu, 0xF27BD5E2u, 0xC0D838CCu, \n0x8183D309u, 0x1452AE47u, 0xE9852B19u, 0x29B7BDEBu, 0x3F42AFCFu, 0x97CDD0B7u, \n0x13F6A290u, 0x125F1A4Cu, 0xC482DBFBu, 0xF6ED59B6u, 0xD29822BDu, 0x71C79D99u, \n0x98A35711u, 0xDA4571EEu, 0x3C43C3E4u, 0xA3C77A8Au, 0x4579FA29u, 0x14E4DA59u, \n0xBABF7B49u, 0x073B4650u, 0x2793A4CFu, 0x0A957AD6u, 0x5ACAF4DAu, 0x62D00DAFu, \n0x7F7C7385u, 0x7817361Cu, 0x1DC458A9u, 0x438607FEu, 0xD32B2B92u, 0xFE47432Eu, \n0xF6EEA744u, 0x993B2BE3u, 0x5A115269u, 0x75ACC394u, 0x2343A57Fu, 0xB24597D0u, \n0xD0F88E53u, 0x6BB74783u, 0xB4EFFE1Eu, 0x414449C5u, 0x85CBC785u, 0x0ABB65EFu, \n0x5CBE68DBu, 0x76DD8D01u, 0xB43ABD19u, 0x4CD16D27u, 0x43C8CC3Du, 0x73924E7Bu, \n0x3EF201D3u, 0xADBA2883u, 0x0707555Cu, 0x39EACDB0u, 0xB59A06A9u, 0x66D79AFAu, \n0xFDF102E5u, 0x7B0AC932u, 0xF9B7E88Cu, 0x9AE31B76u, 0x734728E9u, 0x1CC82865u, \n0x8BE12152u, 0x993CCA33u, 0x58375EEAu, 0x00D41D55u, 0xCDEF07FEu, 0xE5F907EFu, \n0x80A6A73Cu, 0x237BBD31u, 0x623977C6u, 0x2F92358Au, 0x23C21723u, 0x17458BB6u, \n0xB09D54DAu, 0x091B2ED3u, 0xB9377B45u, 0x3246AD6Cu, 0x43FABFAFu, 0xEFE5ADD2u, \n0x3C75BE62u, 0xB91F6C7Eu, 0x6FBEA778u, 0xFA39E2B9u, 0xB8EB8B2Eu, 0x19472866u, \n0x19F5BAA3u, 0x64D462AEu, 0x6A61F634u, 0x3980C502u, 0x25BCE3CAu, 0x150A64F6u, \n0x2D629504u, 0x1861B5E8u, 0x0BFFDE40u, 0xFDF3A87Cu, 0x07B56278u, 0x4C663E23u, \n0xAC81DDDAu, 0x2D616E6Au, 0x7123A574u, 0xF368DCD7u, 0xAE9329B4u, 0x746B4C26u, \n0x3DEB17FCu, 0x8A8085BDu, 0x99DAAC07u, 0xE7E4CE47u, 0x5B94EE7Au, 0xB7B90BA3u, \n0x25B66922u, 0x6BD14723u, 0x149A3157u, 0x445D9DFCu, 0x8E2F865Cu, 0x38DE98D7u, \n0x321561AEu, 0xF155AE01u, 0xE085CAB2u, 0xACEC8A6Du, 0x5C0D1CA8u, 0x7E4FA9F1u, \n0xFBA60F4Du, 0xB9FFE3E5u, 0x5CE87FF0u, 0xF681D78Fu, 0x7D7BCD06u, 0xB25D26F2u, \n0xF6075872u, 0xC8D66BBFu, 0xDF78ECF8u, 0x04BBCB0Bu, 0xA567B366u, 0xAA648707u, \n0xDF62CB1Cu, 0x88E01D11u, 0x2FE6351Eu, 0x19C6B349u, 0x99F682A7u, 0xF2162F0Fu, \n0x183531BEu, 0x99C64839u, 0x523F4CFCu, 0x31325D1Bu, 0x12D01ACAu, 0x25C37A1Du, \n0xD81C9F41u, 0x382982E6u, 0xC94F5EC3u, 0x14E88D23u, 0x9826A4F5u, 0xDA81AFD5u, \n0x100E756Bu, 0x81514B43u, 0x35D9EF9Du, 0x51DA7FF6u, 0x95700B55u, 0x8441E3E7u, \n0xF0FDC58Fu, 0xF579A8CEu, 0xFDC683A2u, 0xFA11F6A6u, 0xD43489ACu, 0xACAF2D26u, \n0x12916097u, 0x8327B702u, 0x50BAC0BBu, 0x9EA852C1u, 0xA2F9B20Eu, 0x89B6917Au, \n0x3189B9DFu, 0x2B088E0Au, 0x3DE8A0E6u, 0xBBEF985Fu, 0x61980919u, 0xC79DA462u, \n0x4A673EA6u, 0x4E07D10Fu, 0x021428A9u, 0x22682056u, 0xFC506071u, 0x35E417B8u, \n0x1FA73A7Cu, 0x3E2CE3C9u, 0xC750BEE0u, 0xC6892BA6u, 0xCD68CD6Eu, 0xDEEDB74Du, \n0x4EFF463Du, 0xBB340395u, 0x0C064743u, 0xA704C285u, 0x827E58CAu, 0xDF56C007u, \n0xCBF9EFB0u, 0x3594C865u, 0xCD41F291u, 0x7742CDA4u, 0x8637DEB8u, 0x22A89680u, \n0x8B996170u, 0x69B0E244u, 0x0A6C80A2u, 0x5D7F21E3u, 0xF2A0FF5Au, 0xAFC4369Au, \n0x9995D303u, 0x43692418u, 0x852D7748u, 0x94F62D44u, 0xC4024C94u, 0x36B4DD36u, \n0x17ACA465u, 0xAAED1603u, 0x925BA7DDu, 0xB62FC75Eu, 0xC365A42Du, 0xA7730F80u, \n0x0557A809u, 0x5EEBF23Du, 0x8DE02AC1u, 0x0A8D61AEu, 0xC0565885u, 0x48907F8Bu, \n0x20CEC32Eu, 0x8ABCD47Bu, 0xD63690BBu, 0x9E26A759u, 0x6680F2F1u, 0xF2B20329u, \n0x45F123BAu, 0x8ADEBECDu, 0x44D7F3F7u, 0xC8ABBDFAu, 0x6F5448E4u, 0xE3E734B2u, \n0xE1177726u, 0xB50240CBu, 0x24B76D2Cu, 0xDFB6FACBu, 0xE52C44C1u, 0xFCEDF336u, \n0x3862853Bu, 0x90803C1Au, 0x729FCA03u, 0xFAED3EF0u, 0x0DA8C64Cu, 0xDAEC94D3u, \n0xA0DA48A1u, 0xA454F7FCu, 0xFA61D68Au, 0x948B6F36u, 0xE2C97B4Du, 0x44D6A2B0u, \n0x5D5BD6E6u, 0xE68302D6u, 0x6603EC0Bu, 0xAFA870C0u, 0x09AC2CEBu, 0x6EFEA63Bu, \n0x726B647Cu, 0xAE289B74u, 0x9B2A74F6u, 0x2C12728Bu, 0x19DECEC7u, 0x9470B575u, \n0x1D2EAE6Au, 0xDD406590u, 0x785491BEu, 0xFC5719BDu, 0x708397E2u, 0x44C818A0u, \n0xCCFEF101u, 0xD50D797Eu, 0x55CBB600u, 0xB492E628u, 0xE732616Du, 0xBF8E2BA4u, \n0xD985DB99u, 0x64A2CEDAu, 0xDD70D574u, 0x6B3BEE15u, 0x0A017753u, 0x92EAE677u, \n0x6FA904D5u, 0xF3492A67u, 0x5699CE0Fu, 0xEF7D7F4Eu, 0x231F6EA6u, 0x4E739228u, \n0x6D727BC3u, 0x5DE4C910u, 0xCB2276D2u, 0xECA318BFu, 0xBA5A06AEu, 0x32B63EE8u, \n0xFA2E6EB2u, 0x11789138u, 0x85375024u, 0xFC2FF3BAu, 0x1C711426u, 0x5DBF31A0u, \n0xAAF04CE6u, 0xFC840946u, 0xD664A98Cu, 0xD9D2297Du, 0x6C5BCE73u, 0xD18E967Cu, \n0xC70BADDEu, 0x31A6E94Bu, 0x11B3563Du, 0x05B4255Du, 0x5F4D5549u, 0x7462355Eu, \n0xB793F248u, 0x250D26F1u, 0x11EB8559u, 0x4FEAF86Au, 0x78072393u, 0xC1042442u, \n0xC1774B09u, 0xDF30E4C6u, 0x8B0D7D8Cu, 0x6646D2C5u, 0x81AF6D61u, 0x723AD5A5u, \n0xE3390B82u, 0x4FA95CE7u, 0xDCD24639u, 0x84995442u, 0xA82F1359u, 0xEF2B1D07u, \n0x4C6DEDC9u, 0xE3307444u, 0x8D3267B1u, 0x4AFECD70u, 0x4B796174u, 0x14D54817u, \n0xF8B66D0Au, 0x7D0FD812u, 0x6734C508u, 0x47AE0825u, 0x11094AE8u, 0x6621A299u, \n0xD298B2F7u, 0xDD242968u, 0x07EC0BE1u, 0x190ED0B6u, 0x27885204u, 0x1D86724Du, \n0xC60E02F1u, 0xF827ACDAu, 0xE2D5703Eu, 0x0C4893DFu, 0x2454458Au, 0xB2936CD2u, \n0x664B649Au, 0x789700B4u, 0x0AE9CAF4u, 0xE68A9BA4u, 0x1B0F1155u, 0x01798505u, \n0x9860DA42u, 0x6DFA7F88u, 0x87F0FB89u, 0x94F844BAu, 0x827021FFu, 0x085CFFADu, \n0x409FE90Cu, 0xD13196C2u, 0x2FA03E35u, 0x8DD4F6ACu, 0x31443332u, 0xBE50CF54u, \n0x31696CB6u, 0x56A40DACu, 0x3454C668u, 0x848986BFu, 0x69000000u); // array len 893\n\nuint map_uint_1[] = uint[](\n0xBE7E0529u, 0x915CB6FFu, 0xAB94ABE2u, 0x3F70AA3Du, 0xAFCBE48Au, 0xC7944F9Cu, \n0x5F7E574Cu, 0x03460853u, 0x2AF5D635u, 0x2421672Eu, 0xE215C124u, 0xB03A3302u, \n0x79EEEA8Au, 0x49679067u, 0xFA3E11D1u, 0x5F77C845u, 0x38B48E62u, 0x2C002A61u, \n0x12F00804u, 0x40FD4C90u, 0x02818096u, 0x065E369Bu, 0x5BB37BD7u, 0x328A5999u, \n0x45898BE6u, 0xE0064820u, 0x35EA3472u, 0x5AC68D8Eu, 0x02EFD1B0u, 0xB58D3BEEu, \n0x964BC917u, 0xFE4F9FBFu, 0xFD5A0042u, 0x5AF310D0u, 0x61992093u, 0x1EF74181u, \n0xF7EE223Eu, 0xFEC13503u, 0xF44227D4u, 0xEA6F6E92u, 0x1A89EEDBu, 0xB8C3A1C1u, \n0xD735C352u, 0xED12AE28u, 0x27259E62u, 0x1995947Fu, 0x7AFBBD98u, 0x8189188Fu, \n0xB214D455u, 0x9F70F8F2u, 0x5F7ACA71u, 0x8106FD0Au, 0x11679CB1u, 0xD2E97A7Bu, \n0x646FB9C9u, 0x1695874Bu, 0x356DBBBEu, 0x2BAD5BF6u, 0x2D34494Eu, 0x5D373491u, \n0x34999877u, 0x90BFF400u, 0xD80FDC1Eu, 0x922F3079u, 0xACB7C0A5u, 0xAA41CBD7u, \n0x5C5390FCu, 0xE6270CD9u, 0x40A4367Bu, 0x0DEC9040u, 0x26A88415u, 0x25DA7607u, \n0x25651E30u, 0x5DB1D766u, 0xA4C732C3u, 0x651A41C2u, 0x8254CCD7u, 0x2CDE0A47u, \n0x78FB19A9u, 0x5DBE6752u, 0x42FB27B6u, 0x7CA844BAu, 0xF34C17DEu, 0x47048EDDu, \n0x5B3C6D88u, 0xFE379FBBu, 0x0B3C0835u, 0xACA14A86u, 0xBE6CB1A4u, 0xF6746DF5u, \n0x3787C2ABu, 0x6E5049A4u, 0x26BB4C36u, 0xAF668443u, 0xC840154Cu, 0x04D6BFE0u, \n0x78789D22u, 0x58C2AA8Du, 0xBCF313E1u, 0xF367E200u, 0x4B96A4F4u, 0x1C426734u, \n0xF8A7F4E3u, 0xDEC4FEE7u, 0xA0316641u, 0x28EC8978u, 0x8DF25B0Au, 0x670A48B6u, \n0x5D259DEAu, 0xCC5EC210u, 0x6A03E818u, 0xB9DE5DABu, 0xADEBB9C3u, 0x10A9F5DEu, \n0xF2143BA2u, 0x83E89A74u, 0x42F26F31u, 0x75FD0AF1u, 0x27028853u, 0x3B60FB5Eu, \n0xBF4FF53Bu, 0x82D3B535u, 0xFCFBA865u, 0xDAB9353Cu, 0xB44B84DBu, 0xF2BD59C9u, \n0xCA6DBC63u, 0x41365602u, 0x0E581690u, 0x53585F56u, 0xC48DF549u, 0xC25EDFF9u, \n0x2502B382u, 0x3903982Bu, 0xE78792B8u, 0x9809B82Eu, 0xDB19AE68u, 0xB6831E28u, \n0x7D68EE24u, 0x14894CABu, 0x075DCACCu, 0x4E2E35FFu, 0x565AB0C9u, 0xC958BB1Du, \n0x57C05030u, 0x67C15519u, 0xAC7EAD06u, 0x2D6405B4u, 0xA2CBF774u, 0xE80A97B4u, \n0x8510E101u, 0x138C3B17u, 0xD8D5C07Du, 0xEFDF451Fu, 0x05B6AD2Fu, 0x03FE1067u, \n0xAA957E36u, 0xC1C11D06u, 0x3B803C72u, 0x568BEDD8u, 0x9E09DAB3u, 0x30FF6B88u, \n0x17327BF5u, 0x104852F9u, 0xB22E6314u, 0x61A4FB4Bu, 0xCC332E2Au, 0xBD36585Fu, \n0xE14316FEu, 0x557244D5u, 0x223DFD06u, 0x257FB8CEu, 0x91E793C1u, 0x325EF098u, \n0x280FA50Au, 0x043DE05Fu, 0x39BB6EAEu, 0xEF365599u, 0x0D59636Du, 0x211EE523u, \n0x3B5885F5u, 0xFB079544u, 0xC8174C6Cu, 0x2C6284B2u, 0x174A54C6u, 0x497D1121u, \n0x14D5581Cu, 0x1F9A0BDBu, 0x6A76140Du, 0x9F238723u, 0xE3452D25u, 0x4C0358BDu, \n0x32E32CEFu, 0xD89B568Cu, 0xC9F021EFu, 0xC57510BAu, 0x99DB48CCu, 0xC5A0DB06u, \n0x66B6C47Au, 0x60E4CC3Bu, 0x1BB18CE5u, 0x2AD0C352u, 0x0791C562u, 0x718A9D2Du, \n0x1BF62168u, 0xA7DB831Eu, 0x07D57E00u, 0x87D0EBC4u, 0x306B36F7u, 0x21B4F81Fu, \n0x2403BB18u, 0x69A3034Bu, 0x1418B325u, 0xF8DB8AAFu, 0x36BD3C53u, 0x8D9473A7u, \n0x7C8191FBu, 0xAC658E39u, 0x36D1A4E1u, 0xF24729ACu, 0x212D2D05u, 0x754BAB6Fu, \n0x2760C0E5u, 0x3BBA8920u, 0xBD9F968Bu, 0xBA1ECDF8u, 0x0993FEE5u, 0x0744AC46u, \n0xC8C17EDDu, 0x86778764u, 0xB683233Au, 0xAED6FBF7u, 0x17B79288u, 0x6CB258ACu, \n0x62A96FD3u, 0xCD156BB2u, 0xAC09547Eu, 0x740DDDB2u, 0xA6BFAFEBu, 0xB92A0CE8u, \n0x877236DEu, 0x4D971C3Eu, 0xE7FA12F7u, 0x34AC6720u, 0xC01A19CDu, 0x90695D99u, \n0x86D1523Cu, 0x8A9ED852u, 0x1F8A8582u, 0xF60E11FFu, 0xEE32EDA0u, 0x9726D756u, \n0x6D15C771u, 0xDAEB79D8u, 0xEC34EB11u, 0xEE1908A6u, 0x8555A4CEu, 0x98ABF2AFu, \n0x6332FCE5u, 0xD7189105u, 0x88E09162u, 0x2EC8EB44u, 0x76E826C8u, 0x00D66BEAu, \n0xFCCF4E52u, 0x903C4D34u, 0xB790D50Eu, 0x2D0DC68Au, 0xA52C711Bu, 0x7F1D5968u, \n0x2566F8A1u, 0x674588EDu, 0xC64A33C8u, 0x204F6C7Bu, 0xDCD7938Eu, 0x2A7C2158u, \n0x09C3A8EBu, 0xA69AC1BDu, 0x262D2C21u, 0x6D3C0FCDu, 0x8A240EEBu, 0x3E64EB74u, \n0xB9238C17u, 0x46CF7491u, 0x2F742A40u, 0xAEDE0317u, 0x3E408072u, 0xE19C3FDBu, \n0xB8111DE4u, 0x71E6D1E7u, 0x69FFB052u, 0x2B903302u, 0x7A820F36u, 0x9ECEC452u, \n0x718A7918u, 0x786D41F6u, 0x5B585F28u, 0xB973B0F6u, 0x03CE46EDu, 0xF4DDA508u, \n0x1088853Du, 0xEAC29331u, 0x04B85890u, 0x4F44D7F4u, 0xC7B2EA81u, 0x3F0E4541u, \n0x47EFB818u, 0x4CDEF203u, 0xF4DF49B0u, 0x66835A29u, 0x961B0501u, 0xE0223923u, \n0x914C3861u, 0xD9480E2Cu, 0x1D886F67u, 0xA7490479u, 0x4347A189u, 0x5B36B00Cu, \n0xBF404F7Cu, 0x3E2B1483u, 0xB894FE80u, 0x240A3554u, 0x6FD3D71Eu, 0xED975687u, \n0x878BAE9Bu, 0xDFC0B439u, 0x4F4128FBu, 0xBA6FB867u, 0xC5FC8C3Du, 0xFB62F9C7u, \n0x0FF841F3u, 0x2774CC7Eu, 0x841F6AB6u, 0x82720607u, 0xD0393CEDu, 0xD26A387Cu, \n0xB1B69FCCu, 0x53548917u, 0xD0A26CA5u, 0xDDD4230Fu, 0xDB6DD5F8u, 0x830B674Fu, \n0x693DF779u, 0xB921F151u, 0xA88ECA1Fu, 0xF55F183Eu, 0x9099C6C4u, 0x8F612928u, \n0xDAACDD0Cu, 0x9D267679u, 0xB3D7FB29u, 0x51E9C03Du, 0x75E2306Du, 0x86C85A1Cu, \n0x46F384AEu, 0x1EE4C86Au, 0x27AC3062u, 0x3FE087C4u, 0x53CF4055u, 0x1C0D6EF6u, \n0xE77A6C90u, 0xB37D3EABu, 0x5957DACAu, 0x40310BC2u, 0x6A8890AFu, 0x9BEF976Cu, \n0x04A16DC7u, 0x8E88FCCAu, 0x6D5F1F3Du, 0xAC7B3599u, 0x8057CE6Au, 0x10A1553Bu, \n0x98A7FC15u, 0x82FF2F04u, 0x9C0D3FB7u, 0x15580288u, 0xE9A3252Au, 0x9B7E9B21u, \n0x8A52D05Cu, 0x72CB098Du, 0x64DC3DC6u, 0x283C4128u, 0x04DFABA8u, 0xC14A5D1Bu, \n0x4E3A4D34u, 0xADE63644u, 0x39889AB2u, 0x4854A514u, 0xC43D14CCu, 0x30BE2E76u, \n0xFEDB706Cu, 0x8A05797Fu, 0x0E2B02A2u, 0x63DE81D8u, 0xE7D8B93Bu, 0x08C61291u, \n0x5ECC7522u, 0x1D0E0957u, 0x32C6EB2Eu, 0xC2EEBC4Au, 0x29A086B2u, 0xC4756A03u, \n0xDC753D2Eu, 0xA26EF886u, 0x987CF4ECu, 0x9B3EC0AEu, 0x178FB7B1u, 0x996EC7EAu, \n0x37D456FEu, 0xDB7D0FE3u, 0x82B1BE2Eu, 0xFD1E77C1u, 0xC0EF79E6u, 0xCA0F23A3u, \n0x699DCEF2u, 0x2D0C3A52u, 0x98360953u, 0xCE64FF04u, 0x6D45D53Cu, 0x96A1C050u, \n0x5BF6E359u, 0xBA8C203Du, 0x7F2FA8CEu, 0xB21BD616u, 0x8E1B0481u, 0x389C3AA4u, \n0x1699E388u, 0xC8E7C4F6u, 0xAC1EB83Eu, 0x4EDC5771u, 0x55EEA857u, 0x46E06B02u, \n0x8688CCC5u, 0xE4F419BCu, 0x3D7F58E2u, 0x80DCC9C8u, 0x60E95208u, 0x1E706089u, \n0x98A5EF1Cu, 0x1C3C0A87u, 0xF1F027A2u, 0x5B994E93u, 0x6DA31917u, 0x16CF1B6Au, \n0x5D8303EFu, 0x5A353F20u, 0x3E7A546Au, 0xFEAB1585u, 0xA8C728C7u, 0x2AF2D774u, \n0xA621983Eu, 0x2698449Eu, 0xFEDE77EAu, 0x7A44FEF6u, 0x0DFCC178u, 0x26BC3D57u, \n0x87C4A9B2u, 0x0CCC11D1u, 0xB234EF07u, 0xF9EBFE06u, 0xB5FA295Bu, 0x9B296734u, \n0x1C9237BFu, 0x41880FF1u, 0xFA6BEC0Au, 0x1E7E2470u, 0x4C1F45ECu, 0xA69D796Eu, \n0xF6502430u, 0xB034ADD1u, 0x460A933Bu, 0x496D55F7u, 0x9F157177u, 0xB060A915u, \n0xC3689B88u, 0x11292DA6u, 0x77EF1B94u, 0xE7A450C1u, 0x7B95FC9Du, 0xC8EED25Bu, \n0x29B17E98u, 0xC9065FCAu, 0x444CB3AFu, 0xBE1CF731u, 0x00B44196u, 0xC7D90F1Au, \n0xB7BF404Du, 0x9BF79A07u, 0xD27960E8u, 0x8C81728Cu, 0x82D86393u, 0x7B31D6B5u, \n0xAF617E8Du, 0xA25691FDu, 0xFAA8B3BDu, 0xFA89B036u, 0x117B9FDFu, 0xB02A42FAu, \n0xA3C9D4B1u, 0xE39826B0u, 0xAA8A6477u, 0x952AA341u, 0x1F25E3D9u, 0xBB7EC736u, \n0x76BFF8A9u, 0x592D8996u, 0x654B49C2u, 0x885C7EB6u, 0xACFC80D5u, 0xDB244CABu, \n0x5FC76470u, 0xA1CD9B5Fu, 0x0496E29Fu, 0x8622ECB0u, 0x6D811639u, 0x4508EC50u, \n0xBA394D05u, 0xF7A48AB5u, 0x79F72A3Du, 0x39081285u, 0xA83D254Fu, 0xF982C154u, \n0xE7F80FDCu, 0x121AF18Cu, 0x16D3A296u, 0x296F77DFu, 0xEE3F1632u, 0xBAADCA02u, \n0x99B0D5FBu, 0x9D50F79Au, 0x88F800FEu, 0x2A47405Cu, 0x75523364u, 0x7A436BC9u, \n0xEDB0EA7Cu, 0x3597931Bu, 0xD094101Au, 0xBD3B0912u, 0x2B0B4CC8u, 0x10723E72u, \n0x6CB9E281u, 0x4AE5E554u, 0xAEF204F6u, 0x2B42F670u, 0xD108ADA1u, 0xB462F0A4u, \n0x12520C6Eu, 0x881F68FDu, 0x62515D29u, 0x1765C618u, 0x1F4F6D1Cu, 0x972C6A23u, \n0xC2A613CFu, 0x9521FCA4u, 0x61ADD9DDu, 0x2557C672u, 0xA042D44Bu, 0xC53B0887u, \n0xDDF8CAEAu, 0x711F3A87u, 0x45554386u, 0x79F22587u, 0x8577792Eu, 0x7BA982EBu, \n0xA6117DC6u, 0x6BDC3889u, 0x963EBBB6u, 0xBD7C7874u, 0x76E5BA87u, 0x2FDEEE9Eu, \n0x5D11EDB8u, 0x345E7FA8u, 0x5F10D7C0u, 0x9A18B69Du, 0x45803FCBu, 0xE7F478B8u, \n0x8B9907B4u, 0xB56ED6B8u, 0x67BCCEB0u, 0xE512681Au, 0xB57461D9u, 0x6DFE69E6u, \n0x7102544Au, 0x4633AF49u, 0x5D246636u, 0xAE85EAB8u, 0x5354FF0Au, 0xE53EB289u, \n0x6EEACDFFu, 0x9FD51C5Au, 0xBCABE3C4u, 0xF38F1136u, 0x44DB9BE0u, 0x22E77F69u, \n0xD7894DCEu, 0xDC6DDB19u, 0x238259CDu, 0xDBBE9DD6u, 0xFB1137E8u, 0x4EE08A3Fu, \n0xEF908B2Bu, 0x4755E0BAu, 0x745BD718u, 0x18092884u, 0x629E1EF0u, 0x8F73C162u, \n0x05551A04u, 0x125B83ABu, 0x8104D9AAu, 0xF7DCDE30u, 0x368BE959u, 0xB98AB758u, \n0xC8C3CD6Fu, 0xCE6EC67Du, 0x56C4CA3Fu, 0x343D2B4Eu, 0xC68E3611u, 0x9448AF01u, \n0x2BAFD6A6u, 0x291C9EBDu, 0x9EAFDE97u, 0x5E8155F4u, 0x87176567u, 0x103F9CFCu, \n0xF638554Fu, 0xBFCB732Du, 0x37057633u, 0x8CE1121Cu, 0xDB979774u, 0x187134E1u, \n0x9695B372u, 0xEC6C1C67u, 0x3CEDF153u, 0xD8475FD1u, 0xDC71F364u, 0x08DE9E9Au, \n0xD2B82F40u, 0x391C9F59u, 0x1F305CE6u, 0xA904E691u, 0x6DE3EF25u, 0x36ECB2E0u, \n0xA1482436u, 0x5B438107u, 0x13DF8D4Au, 0x2D32FBC3u, 0x6FE981FDu, 0x57D295C9u, \n0x51890C44u, 0xFB847703u, 0x3D5F1F5Fu, 0x0ECC6E2Du, 0xB76008ABu, 0xB7A9C4F4u, \n0xF53DBD29u, 0x7A36D86Du, 0xB4A80663u, 0xAE8530EAu, 0x81B43934u, 0xBE5CD497u, \n0x5F5EE221u, 0x1D6B9915u, 0x6EAA4000u); // array len 663\n\nuint map_map_uint_0[] = uint[](\n0xA1134422u, 0x26355613u, 0x21446222u, 0x97565443u, 0x65751534u, 0x54634563u, \n0x76674274u, 0x22555313u, 0x15087144u, 0x36315356u, 0x48695473u, 0x58346764u, \n0x18267543u, 0x63314246u, 0x34695587u, 0x9B6236A6u, 0x43213267u, 0x42364155u, \n0x43431261u, 0x32455433u, 0x44242624u, 0xB1043312u, 0x51144624u, 0x08772464u, \n0x32323524u, 0x53134223u, 0x13411125u, 0x25562842u, 0x53232522u, 0x12443432u, \n0x55207345u, 0x14453544u, 0x43555244u, 0x34524449u, 0x53583424u, 0x55468225u, \n0x24165395u, 0x8652564Au, 0x85292654u, 0x87335467u, 0x33163332u, 0x95356585u, \n0x26362552u, 0x43262154u, 0x92412252u, 0x64422353u, 0x45536666u, 0x56132243u, \n0x53324338u, 0x45442991u, 0x32443444u, 0x44669223u, 0x63286552u, 0x67745933u, \n0x5522B342u, 0x44556767u, 0x25074345u, 0x69332365u, 0x575A6464u, 0x45736753u, \n0x1A1B5246u, 0x55508276u, 0x56275267u, 0x86418637u, 0x43422142u, 0x21031213u, \n0x45551562u, 0x21253423u, 0x50911122u, 0x35452453u, 0x32351314u, 0x23544042u, \n0x26216645u, 0x22362530u, 0x31243224u, 0x44265423u, 0x63420431u, 0x43433131u, \n0x42412723u, 0x23335332u, 0x43443361u, 0x16924668u, 0x47633624u, 0x85451571u, \n0x65443134u, 0x35734232u, 0x44534444u, 0x94014171u, 0x21457215u, 0x4533A562u, \n0x45476645u, 0x37277469u, 0x05296324u, 0x66314486u, 0x66584567u, 0x38484A23u, \n0x33441412u, 0x41232243u, 0x21602616u, 0x23323321u, 0x92322324u, 0x43554030u, \n0x53244202u, 0x55364A55u, 0x25206711u, 0x05268473u, 0x34324533u, 0x35236542u, \n0x13444244u, 0x52352452u, 0x95372323u, 0x83444561u, 0x223A4643u, 0x21235546u, \n0x6635144Au, 0x56614748u, 0x55262334u, 0x52225423u, 0x74584547u, 0x03424954u, \n0x27030535u, 0x23241044u, 0x43342232u, 0x32683223u, 0x54445445u, 0x12223702u, \n0x66684446u, 0x16644574u); // array len 128\n\nuint map_map_uint_1[] = uint[](\n0x44424453u, 0x62922737u, 0x52913222u, 0x94785485u, 0x5A455336u, 0x01733145u, \n0x47455515u, 0x96813246u, 0x43852B69u, 0x32767834u, 0x44522612u, 0x34547428u, \n0x73539762u, 0x7C534524u, 0x41679444u, 0x35546463u, 0x71324422u, 0x24253543u, \n0x33315223u, 0x31111535u, 0x32365432u, 0x21221612u, 0x00204025u, 0x24322153u, \n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x52177577u, 0x55655557u, 0x52410654u, 0x3234E47Bu, \n0x65922555u, 0x18646534u, 0x44523777u, 0x45576743u, 0x12032102u, 0x42442413u, \n0x25154342u, 0x23414233u, 0x03132120u, 0x31324420u, 0x20314122u, 0x11411333u, \n0x254A5256u, 0x32333263u, 0x28673722u, 0x52453344u, 0x48496534u, 0x66382274u, \n0x55363523u, 0x44333445u, 0x7762484Bu, 0x546A8877u, 0x33555A37u, 0x73483303u, \n0x62665586u, 0x26987585u, 0x44173245u, 0x26353492u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x34021121u, 0x23541312u, 0x21112522u, 0x43431224u, \n0x31222442u, 0x41342211u, 0x22013222u, 0x30221234u, 0x5783571Au, 0x51486916u, \n0x32322253u, 0x04588047u, 0x57917355u, 0x34687635u, 0x64603355u, 0x62743255u, \n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x41172441u, 0x32141433u, 0x44352161u, 0x03530215u, \n0x54544432u, 0x13341114u, 0x30146223u, 0x42325107u, 0x31176328u, 0x44374656u, \n0x36457666u, 0x76745565u, 0x2121A248u, 0x53244436u, 0x49546654u, 0x85753343u, \n0x42304486u, 0x39644346u, 0x82913333u, 0x06127636u, 0x52575436u, 0x45426316u, \n0x53626944u, 0x24256533u); // array len 128\n\n\n#define self_buf iChannel0\n#define map1 map_uint_0\n#define map2 map_uint_1\n\n#define mapmap1 map_map_uint_0\n#define mapmap2 map_map_uint_1\nconst ivec2 mapmap_reg = ivec2(0,34);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord);\n    \n    if(ipx==ivec2(32,32)){\n        fragColor = vec4(1.,map1.length(),map2.length(),0.);\n        return;\n    }\n    \n    if(ipx.x>=32||ipx.y>=32){\n        if(ipx.y!=mapmap_reg.y||((ipx.y==mapmap_reg.y)&&ipx.x>=mapmap1.length())){\n            fragColor = vec4(0.,0.,0.,0.);\n            return;\n        }\n    }\n    \n    bool reset = texelFetch(self_buf, ivec2(32,32),0).x<0.5;\n    vec4 self_col = texelFetch(self_buf, ipx,0);\n    \n    if(iFrame>0&&!reset) {\n        fragColor = self_col;\n        return;\n    }\n    \n    if((ipx.y==mapmap_reg.y)&&ipx.x<mapmap1.length()){\n        fragColor = vec4(0.);\n        fragColor.x = uintBitsToFloat(mapmap1[ipx.x]);\n        fragColor.y = uintBitsToFloat(mapmap2[ipx.x]);\n    }else{\n        int idx_x = ipx.x+ipx.y*int(32);\n        fragColor = vec4(0.);\n        if(idx_x<map1.length())\n            fragColor.x = uintBitsToFloat(map1[idx_x]);\n        if(idx_x<map2.length())\n            fragColor.y = uintBitsToFloat(map2[idx_x]);\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// map of connections 3 and 4\n\nuint map_uint_2[] = uint[](\n0x0ED5EB74u, 0xDBBE07BCu, 0x4D9F83CAu, 0xA7A74123u, 0x962FD195u, 0xCB59E622u, \n0x18917DF0u, 0xDFF2E495u, 0x7C48EC96u, 0x2F724990u, 0xFC844A0Du, 0x314307D6u, \n0x8D7E1171u, 0xBAE626CAu, 0x7FB58384u, 0x0F016D15u, 0x83FD5A77u, 0xCF08FA99u, \n0x1E9292C1u, 0x8162B90Du, 0xBD2C4CF6u, 0x728D305Au, 0x9879F1D2u, 0x1271AB49u, \n0xADD607DDu, 0xB1A0ACDEu, 0x156076EAu, 0x260834F9u, 0x06F28783u, 0x14B3C7EBu, \n0xFAF607E7u, 0xFEDC7F79u, 0x6A745F33u, 0xCFCBDE5Au, 0xC2F0DB91u, 0xECB3091Cu, \n0xC15B21B5u, 0x3A3571D6u, 0x0AA99DA6u, 0x5BA0BD2Bu, 0x86D7E5A4u, 0x66F5D497u, \n0xFEF2FFDAu, 0x1C26B338u, 0x9CF4A641u, 0xA4D7EA1Fu, 0xEE231F25u, 0x1005353Cu, \n0x08FBCF5Eu, 0x5A7EF9C1u, 0xF4B11584u, 0x86C9B0C8u, 0xCC9B6C90u, 0xDF996DB1u, \n0xC5475FB2u, 0x32BF5FB3u, 0xC739D43Du, 0xD06D9786u, 0xD924688Eu, 0xDBEB0AFEu, \n0xEB2F33A2u, 0x3ADC3642u, 0x0C17312Au, 0xD19CFC8Bu, 0x0F102F80u, 0x7987D5BCu, \n0xEE919CE7u, 0xC996304Au, 0x391DE8C8u, 0x682940D4u, 0xD3D2CF1Fu, 0x7E71B935u, \n0x0E64D6A3u, 0x023982EAu, 0x2D934E5Du, 0x99971ABBu, 0x080C2C32u, 0x102D8B91u, \n0xCD48728Fu, 0x7EE3D3BFu, 0xEC283963u, 0xEA2EAB5Fu, 0x729B74F1u, 0xDB123737u, \n0x2F6A4D98u, 0x61B18669u, 0x9858C99Du, 0xDD5AB601u, 0xA938188Fu, 0x7F9624BDu, \n0x6233318Eu, 0x290DD86Du, 0xA807CD6Au, 0x756EAE03u, 0xE09B0DACu, 0x01E04B45u, \n0x6F903D42u, 0x0044EFDCu, 0x37E5CB11u, 0x23389AC3u, 0x584D4893u, 0x0DCC0BEEu, \n0x886DCE52u, 0x004EB468u, 0x3C727CD9u, 0x96D14B93u, 0x530CF963u, 0xC7651ED6u, \n0x40C66F2Bu, 0xF40FA4C8u, 0x514D1B63u, 0x8273E073u, 0xF962ED06u, 0x6A83CF7Au, \n0xE29BF9BAu, 0xAEBFFC67u, 0xA145C24Bu, 0x3A0D465Bu, 0x498C6DD4u, 0x6E16D57Fu, \n0x4AC3415Cu, 0xD606844Eu, 0x37EE3604u, 0xD311797Au, 0x041CDD75u, 0xB8944289u, \n0x970F67A8u, 0xC2A17031u, 0x9EFF3AE1u, 0x55C2012Bu, 0xE1C95A3Eu, 0xCA9A4F02u, \n0xD41F2910u, 0x67182D1Cu, 0xD8576E4Au, 0x500D1ACDu, 0xB3315BD5u, 0x38769990u, \n0xA54D9736u, 0xC6E427FEu, 0xBD367A21u, 0xC856C2D1u, 0x1D9AF7BCu, 0xBEDF9E8Bu, \n0x68A3DE3Au, 0xE7514256u, 0xCA8AD70Eu, 0x74528D9Eu, 0xF580B40Bu, 0xDF6C7D4Bu, \n0xC5064DEFu, 0xB015297Bu, 0x977F89E1u, 0xF808A6D2u, 0x29276EA2u, 0x483AD0A6u, \n0x9EF3390Fu, 0xA1505F20u, 0x87F1EAA3u, 0x92B00246u, 0x86667A2Bu, 0x96B9D56Au, \n0x986DDA75u, 0x1FEBD52Eu, 0x774476DAu, 0x1B6E3B10u, 0xFB414293u, 0xC3D63AFDu, \n0xC8EA8E02u, 0x67946AC4u, 0x42FB241Au, 0x88600FE0u, 0xF7DD155Du, 0xD68D45A5u, \n0x12304D66u, 0xF50CD81Du, 0xC6621E2Au, 0x43BF1C86u, 0x9344CD69u, 0x099479A0u, \n0x58BF4EA2u, 0x38500F8Du, 0xABF83C74u, 0x48115922u, 0xC4DC1E94u, 0xFE852DB8u, \n0xA4C0317Bu, 0x873A80E5u, 0x8BCD4522u, 0x8A151138u, 0x04D96D54u, 0xC8E3D397u, \n0xB03B53B8u, 0x30974B07u, 0x1B9252CBu, 0x7E346641u, 0x1F827263u, 0x4FF87E0Fu, \n0xA29EA7C9u, 0xC7DDF85Cu, 0xB6613D94u, 0xCB74502Eu, 0x9A2B23DDu, 0xF9C20524u, \n0x484D9968u, 0x0489A2BBu, 0x7DD0613Eu, 0x402667CCu, 0x725E3EE6u, 0x09F7B6F5u, \n0x8F81BF45u, 0x22EBC319u, 0x3BC91A76u, 0x1AF814A2u, 0x1757431Du, 0xAEE88EDCu, \n0x5E81B678u, 0xE50369E9u, 0xA8F8D413u, 0xAF40A91Bu, 0x53C27BC3u, 0x448F941Fu, \n0xBCDF48C3u, 0x261626B5u, 0x14426B2Au, 0xA55E7E3Eu, 0x3E0E3F53u, 0xBB576EBBu, \n0xA4198942u, 0x2E6365D3u, 0x9126BD2Bu, 0x4136279Cu, 0x62FB7A5Cu, 0x2DB814DDu, \n0xB1D5DA7Du, 0x8484FF45u, 0x3DBC3747u, 0xC41493E5u, 0xB6948D70u, 0x2E64FA95u, \n0xFEC35BF8u, 0xA1622A76u, 0x00A84625u, 0x277E2080u, 0x7E7B6390u, 0xB0D5E2D5u, \n0x52FA1992u, 0xDD48428Du, 0x0BD9EF59u, 0xB979DE78u, 0xA3564670u, 0x598CDC53u, \n0x630661B9u, 0xCDC74B29u, 0xAEBCC765u, 0xBDCDF1B6u, 0xFD5269E3u, 0xFF314FC1u, \n0x21C53701u, 0xB02807DBu, 0xD7A6FD60u, 0x3F13C7CEu, 0x002890F9u, 0xE5A69ACBu, \n0x63CBE8CCu, 0xE983BD94u, 0xEF87C813u, 0x7935BAF4u, 0xE5E250B6u, 0x61C1F38Eu, \n0x4A4B5B3Eu, 0x8F3EF639u, 0xF384299Eu, 0xC306B792u, 0xE04725CAu, 0xF13D01B2u, \n0xAAD23E0Au, 0xACACE1E6u, 0xBD45C145u, 0xC4E2A9C8u, 0x7A70AA77u, 0x19F68BA9u, \n0xEDD8929Du, 0xB597D36Fu, 0xD99428E5u, 0x9917E598u, 0xFC41E5B9u, 0x4339DC9Fu, \n0x20F36334u, 0xDB614DF2u, 0xBF07DA3Cu, 0xE5D5B828u, 0x7EA7F574u, 0x916B3A8Du, \n0x44415023u, 0xFD6A9D81u, 0x21F8FC47u, 0x086FBED6u, 0x0012CEB7u, 0x2EADAE2Eu, \n0x9F2BB24Cu, 0x5239CEBBu, 0x46055F1Fu, 0xEE726733u, 0xB0B1A4FEu, 0xE27BDF74u, \n0x8598EF0Cu, 0x128563E2u, 0x44790225u, 0xFA8F7C95u, 0x55E7D50Cu, 0x95383D88u, \n0x55022904u, 0x9697EA8Au, 0xE295FD9Au, 0x75B37115u, 0xC813D362u, 0x93B97B56u, \n0xD8BFA7E3u, 0x12BB3F91u, 0x27459EF2u, 0x01FCEAE0u, 0xA5203B1Cu, 0xA8525417u, \n0x5C88C6DEu, 0xFCB498A0u, 0x12C9D5A3u, 0x092C2FA1u, 0xB1FF2807u, 0xDB349B0Bu, \n0xC624CC97u, 0x3AD69458u, 0x89E8B172u, 0x3C754CA5u, 0x4825FBE1u, 0x841E311Au, \n0x181173A8u, 0x9B24A6AEu, 0x19897C86u, 0xC4AC9D27u, 0xB84B7595u, 0x84613D11u, \n0xFDE43FFCu, 0xDBAF1834u, 0xCEE898E5u, 0x35F8081Cu, 0xC7D50E22u, 0xC5EF97F0u, \n0x33B8A96Eu, 0xDF97A47Cu, 0x95C90364u, 0xBDCB3A07u, 0x522E5724u, 0x60C45F09u, \n0xA5175DD3u, 0x0E99E429u, 0xB07A5291u, 0xEF526740u, 0xBA437E9Bu, 0x4E38FC0Fu, \n0xF95EA03Eu, 0x8AB2FC51u, 0xEF5ABFE2u, 0xAAB3580Du, 0x787207E1u, 0x4FCC0867u, \n0x8B6B0D5Fu, 0x59AF4BAEu, 0x8896CB10u, 0xCB9251BEu, 0xEED579D9u, 0x73EC22B2u, \n0xF8C701D8u, 0x902A3AD3u, 0x71423ACFu, 0xE3B89B98u, 0x3E7FA8C4u, 0x2E6B73A0u, \n0x79229EF7u, 0xE1E7DEF9u, 0x80C671E6u, 0xD20957D0u, 0x2C9CA25Cu, 0x8557EEB3u, \n0x1C6B24D7u, 0x66FD6CD7u, 0x95F1ECDDu, 0xACD1B3AAu, 0x879C507Eu, 0x5359071Fu, \n0xFF18BADEu, 0x33E0394Du, 0x1408EDD3u, 0x108E983Cu, 0x3C169AD0u, 0xC0B662BAu, \n0xCE3F446Cu, 0xC9531170u, 0x6D9DCF3Du, 0xDC1A7611u, 0x89AD7ACDu, 0x0DD29B21u, \n0x77F8FF89u, 0x16D84B7Eu, 0x032F65A6u, 0xBD86F993u, 0xF023AFDFu, 0xB1D51E2Bu, \n0x02E273C4u, 0xB0674F15u, 0x30EF3697u, 0x4EA9EA8Eu, 0x6D7A7C86u, 0x59592947u, \n0x3E4D3B37u, 0xEB4F9E21u, 0xADC93485u, 0xD7ABB731u, 0x32B1D94Eu, 0x11C682E2u, \n0xF1CBEFEEu, 0xB4812F71u, 0x74F8A302u, 0x2EFF2521u, 0x6CD459D1u, 0x3F7BFAEDu, \n0x48214A6Eu, 0xAFE62067u, 0x3680D418u, 0x2E2C9E3Au, 0x5194CD47u, 0xD051678Fu, \n0xA240DC4Fu, 0x79669CB7u, 0x362660E5u, 0x910D3168u, 0xAC8331E6u, 0x099DB1AAu, \n0x0F499AD5u, 0xD9AC3C95u, 0xD38F5C3Fu, 0x61A9FF8Au, 0x5A2C126Bu, 0xFCECDD0Bu, \n0xBC8B28E6u, 0xBDB88452u, 0x8B0DC7D9u, 0x9720C769u, 0xF25CD6B8u, 0xC719BD74u, \n0x6BBAEF21u, 0x1CE56EEDu, 0x8D434A5Au, 0x544A3ACBu, 0x7D98CA30u, 0xFE4B3CA9u, \n0x1B592771u, 0xFEB2BE26u, 0x37EAD17Au, 0xEB8848ACu, 0x0A0E2942u, 0xFB80243Cu, \n0x7FF4812Cu, 0xEB6C5D6Cu, 0xAE896B22u, 0xE08E2E5Cu, 0x0FBF4A43u, 0x7948EF35u, \n0xA6252A6Cu, 0xE95DB931u, 0x28766E74u, 0x2DBA1699u, 0x24AB2844u, 0x1EF8FC90u, \n0x5C1B2801u, 0xF51ABDC4u, 0xF1F5F603u, 0x043E33BFu, 0xBFF3F21Cu, 0xEC3C8EE2u, \n0xA99486BAu, 0x7B19D266u, 0x4F6ED369u, 0xE2DF3FD5u, 0xB7A510A4u, 0xDFA3976Du, \n0xB27B633Fu, 0xF9D805C5u, 0xC4637438u, 0x27D37FC0u, 0x954C79FAu, 0xA9CEB563u, \n0xC41F4563u, 0x8A760AEEu, 0x2E153DFCu, 0x9C5E4BD4u, 0x64D87A37u, 0xB35D0A2Cu, \n0x175C2929u, 0x62E4DAAEu, 0x1167441Fu, 0xE64DD6CBu, 0xD1E370C1u, 0x38402EC0u, \n0x17D364E5u, 0x6D34BB42u, 0x7D9FF147u, 0x20C98C6Du, 0x3F3267EFu, 0x58817D86u, \n0x895556CFu, 0xD429A85Au, 0x2D0306F6u, 0x50BAA41Eu, 0x289BEF8Du, 0xA74020FDu, \n0x37526E3Du, 0xFA4FA842u, 0x73E3428Eu, 0x7731105Eu, 0xF49EFF10u, 0x3301E914u, \n0xB91D9191u, 0xAE88B8F6u, 0x95CC476Cu, 0xC6192E67u, 0xE7E97304u, 0xFE191648u, \n0xAFD34002u, 0x43E5FCAFu, 0x47B01E95u, 0x5201C577u, 0x595A4CB8u, 0x2594ECCCu, \n0x5E8A3AE1u, 0x9D4EBE0Bu, 0x807A1043u, 0x766E520Au, 0x94D6A323u, 0xFFF4F676u, \n0x07F165B6u, 0xE1AF0847u, 0x57D805F7u, 0xE6AF0C84u, 0x3E9D6F1Cu, 0x1932F266u, \n0x6DEE4F67u, 0x39DF8279u, 0x1772197Au, 0x7634C35Au, 0x74C0FCB9u, 0x2F2ACCBEu, \n0x617BA4F5u, 0xBAFF5330u, 0xFB445544u, 0xD6440A10u, 0xEB0608EAu, 0x597E3171u, \n0xAC87DCBDu, 0x66E12C95u, 0x65BDCF40u, 0x26572BB5u, 0x5AE2A7A1u, 0xEE05C87Fu, \n0x9908E9C3u, 0x9E397AE9u, 0xD7DF345Eu, 0x2540B942u, 0x845B6153u, 0x9171BF31u, \n0x52F14907u, 0xD8E0DEB7u, 0x69CA11A6u, 0x18A70462u, 0x4FD49A20u, 0xDB8D6387u, \n0x281733DFu, 0x2E92BC88u, 0xF6D64A05u, 0x0A20F3C5u, 0xCE54200Du, 0x2452234Bu, \n0x4E788683u, 0x95DD45DCu, 0x531A5866u, 0x2F380412u, 0x3A35504Bu, 0x409E5744u, \n0xD2399BFAu, 0x01F39DE1u, 0x559908ECu, 0xB1BE2ACEu, 0x44D7C22Fu, 0x503CB799u, \n0xDB95275Au, 0x1385083Au, 0x92CC862Eu, 0x8FDC43C4u, 0x0981E917u, 0xA240C330u, \n0x810476F4u, 0x7E4A279Fu, 0x4EAFDA4Cu, 0xB60E0A0Fu, 0x1EC7EBFBu, 0xFC1FB974u, \n0xF7820D5Du, 0xBAD36426u, 0x5B7E9B26u, 0x29B2D699u, 0x3127BCACu, 0x24C975C5u, \n0x2364938Fu, 0x5AEA31F5u, 0x3030CF3Bu, 0xFDB868DAu, 0xF6451D02u, 0x45711C51u, \n0x776A7396u, 0x357526B5u, 0x56AA121Fu, 0x6D60726Du, 0x2C482E6Au, 0x7837E3F8u, \n0x6698EC33u, 0xEAB8E975u, 0xCB216D2Cu, 0x7260D643u, 0x01AF48EAu, 0x45C92CD6u, \n0x8368D580u, 0xFC1E8281u, 0x796F51F4u, 0xB52BB311u, 0x36575DF0u, 0x40FF8BACu, \n0x09AB6932u, 0xE4609802u, 0xAE38105Au, 0xC86ADFA8u, 0xD8D49804u, 0x18E3638Au, \n0x4E86B1D1u, 0xA6D93C8Bu, 0x06D91986u, 0x7F8BC943u, 0x5A8C5C71u, 0x220357EBu, \n0xA4158DF3u, 0x250DB6ACu, 0x7794A70Bu, 0x5C6AD32Bu, 0xC887CF61u, 0x8A47C78Cu, \n0x9FF51B89u, 0x99591AA9u, 0xE038F34Eu, 0x5E9AFD01u, 0x355FCE3Cu, 0xC58B3B92u, \n0x2574629Du, 0x037A7432u, 0x22FEE643u, 0x2B2DE621u, 0x93699DF1u, 0x090903FFu, \n0xA4FE2F38u, 0x78ACFA4Du, 0xA3631916u, 0x19BE42B4u, 0x5F31CB3Cu, 0x77EC9EC2u, \n0xFF2154F8u, 0x10DB4EB3u, 0x0566C16Du, 0xF67B07B8u, 0xB57E953Du, 0x9726FC07u, \n0x051CC433u, 0x1817A769u, 0x2C71D907u, 0xB0CBAF32u, 0xDCFB4EBDu, 0xF476A1EFu, \n0x3C61CA99u, 0x58CE48A1u, 0xD25C3F56u, 0x7CEAAFD5u, 0xFEA82E79u, 0xD94870D2u, \n0xBA19CD35u, 0xB67646E1u, 0x25A2BC54u, 0x46473C85u, 0xBC8FA298u, 0x87A178B3u, \n0xD060A7B6u, 0xF33849F9u, 0x1E81C039u, 0xEBDEF641u, 0xC3D3BA45u, 0x704CA80Eu, \n0x49F66D3Eu, 0xD3044772u, 0x44F843E6u, 0xE96C68A6u, 0x6F3BBC5Du, 0xDB9E4586u, \n0xBCC07331u, 0xB4E98654u, 0x38686BFFu, 0x93188BA5u, 0x9117F7FCu, 0x79AC65F9u, \n0x695AA217u, 0x05C75AADu, 0xDD01FEA7u, 0x66D83AC2u, 0x39CF9E31u, 0x307C87D7u, \n0xAEE6ECACu, 0x57440979u, 0x397583BFu, 0x75814F5Du, 0xACCB4B14u, 0x32623456u, \n0x25928DBDu, 0xEBEAA475u, 0x8EE26BE8u, 0x42324755u, 0x2BE0D1A4u, 0xB15C4F0Au, \n0x7BD31547u, 0xEA66813Du, 0x0C9158C9u, 0x8C992D48u, 0x95AD64CDu, 0x4696DB07u, \n0x13CD986Au, 0xCD9ED511u, 0x1EBEC881u, 0x345691CEu, 0xB346AE76u, 0xB7C3DD7Au, \n0xA37B3C03u, 0xE6A7273Fu, 0x40C53643u, 0x54639118u, 0xB5D44A14u, 0x83EED6C0u, \n0x68CDBBBEu, 0x7B3C0434u, 0x489B6DB9u, 0xA1619018u, 0x7E6AE0FDu, 0x2E18212Au, \n0x51533D31u, 0x0B6EADA7u, 0xD5850B0Fu, 0x4C4820ACu, 0x31468452u, 0xC9C7AD8Du, \n0x747B10CBu, 0x1650EDE7u, 0xB563719Du, 0xE75ABF9Du, 0x59BE6480u, 0xDBA493B5u, \n0xFB4DBBC2u, 0xF314EAD2u, 0xFE735189u, 0x44B41F5Eu, 0xC143D2AFu, 0xB7FF2B51u, \n0x72417254u, 0x94C6DE67u, 0x4B6D0616u, 0x4D67D19Cu, 0x6BBCC74Fu, 0x48793FC5u, \n0x3B89B2D9u, 0xBE6D892Au, 0x064D6F76u, 0x68D673FCu, 0x71D7958Bu, 0x86C0CE92u, \n0xF50309F0u, 0x07D32A83u, 0x100DE80Eu, 0x5DFFE245u, 0xAD2A5C8Cu, 0x996CA097u, \n0x7D1886F6u, 0x271B7790u, 0xAFA1F315u, 0x186A3386u, 0x2B4AC5B4u, 0xA808981Du, \n0xBF07D20Bu, 0xBE36D55Bu, 0x22F95CFCu, 0x196DE6FEu, 0xF1C25809u, 0xB7A3C520u, \n0x34D06D85u, 0x07D02631u, 0xCC4BCC6Du, 0x217FF075u, 0x80A4C2E6u, 0xCC6426C0u, \n0xC94B5BB7u, 0x483521B2u, 0x25ECBA34u, 0x9C6E8745u, 0x73E00DEFu, 0x46A2EB8Bu, \n0x7AA67FFEu, 0x0BC7D24Au, 0x92E982B1u, 0x576E185Cu, 0x25BBE6D2u, 0x4D107619u, \n0xDC5FC96Au, 0xDC918C5Bu, 0xC5E36EB4u, 0x9C320028u, 0x6648C323u, 0xEBF56259u, \n0x053F294Au, 0x0F92BF9Cu, 0xE5D5A299u, 0x67AB3479u, 0x581FE4DAu, 0x99E51D40u, \n0xBEAB59D2u, 0xEEDC4E31u, 0x50AC8D5Fu, 0x4E6EC313u, 0x5C474508u, 0x3E28E614u, \n0x2F993444u, 0x72F8528Fu, 0x8AAC2A50u, 0x1ACB9825u, 0x21BE31A3u, 0x9585B482u, \n0x0BE3D688u, 0xA454F723u, 0x18A87E6Au, 0x0901A532u, 0x6DC99D6Bu, 0x1CBED92Bu, \n0x7AD2AD8Fu, 0x90C0D950u, 0x807D664Bu, 0x73B1E659u, 0xEECA9931u, 0x0B587837u, \n0x7BFFCA2Eu, 0x554FC6B1u, 0x46824410u, 0x67CA45D2u, 0x49DC42B0u, 0x88E62BC7u, \n0x4ABFFEC1u, 0xF985E365u, 0x324F8940u, 0x6A213A66u, 0xCD0CDC5Au, 0xC14209CDu, \n0x66C7ADD9u, 0x9A113794u, 0xB99081A6u, 0x2E9DAF75u, 0xB6EFFF35u, 0x81809C7Eu, \n0x47026537u, 0x4F69D797u, 0xDE4D31D6u, 0x047FBFA7u, 0xB8114DFAu, 0x7C4F7410u, \n0x24FEE7C9u, 0xD2D65153u, 0x101C32F1u, 0xA671923Bu, 0x71935A6Bu, 0x3B2E2A84u, \n0x8854B22Bu, 0xF6BA3234u, 0x827E1350u, 0xD510F4EAu, 0x881F2654u, 0xF4FADBB6u, \n0xA7247607u, 0x3C4CB838u, 0xBDFE50DEu, 0x04F142DDu, 0xC5B8BB45u, 0x9B66530Cu, \n0xDD746967u, 0x4B37F0EFu, 0xEC173110u, 0x520D8DBBu, 0x3DE5A15Cu, 0xE6643F5Eu, \n0x692DBF79u, 0x38000000u); // array len 908\n\nuint map_uint_3[] = uint[](\n0xF0D5EA85u, 0xC181C29Eu, 0xCEF5F7D7u, 0x0C4DDA09u, 0xE129A9DFu, 0x5F1A4296u, \n0x2DC0CDB1u, 0x0CAC0E57u, 0x6519879Au, 0x09E18FBEu, 0xE219296Cu, 0x3049997Cu, \n0xB6AE2E4Eu, 0x124606A7u, 0x1A4FE6BFu, 0x5B13EA81u, 0xCAE22708u, 0xB1081F54u, \n0x113104AEu, 0x60BA709Bu, 0x988DF2FBu, 0x62DA0A57u, 0x25165458u, 0x19226296u, \n0x665E1FE2u, 0xB74D93B2u, 0xF443BB09u, 0x7C707599u, 0xDD6E5F95u, 0x9C07AF45u, \n0xF8AD297Bu, 0x0CABB22Eu, 0x94761789u, 0xD0BEA117u, 0x23142402u, 0x3D00680Fu, \n0x8F87D802u, 0xC7BC51CEu, 0x574E17ACu, 0x48A71E1Bu, 0xAC92D25Fu, 0x9490E0A3u, \n0x1C96CC6Fu, 0x5B2BAAFDu, 0x72C6D61Cu, 0x298389B2u, 0xEF244883u, 0xCDAA37C1u, \n0x0553DF7Eu, 0x39F61730u, 0xEE1AC750u, 0x78146C25u, 0x92392DC6u, 0x656E8908u, \n0xEBEC776Eu, 0x9582F59Au, 0x97EA881Cu, 0x7C61AEAEu, 0x196E296Eu, 0x9623ED6Cu, \n0x8B7AEA8Eu, 0x0D9B09E6u, 0x26BB47C8u, 0x2662E288u, 0x13EE6A21u, 0x37C81C6Cu, \n0x4D2C6C25u, 0xA66523BDu, 0xD4F266BDu, 0xB376D81Eu, 0x04910A43u, 0x7A759A7Bu, \n0x09AE7F14u, 0x897361A7u, 0x0A375478u, 0x380E08EFu, 0xECFFE87Du, 0x91A8F3E7u, \n0x1CDFEA24u, 0x88A5746Eu, 0x748528B3u, 0x281478D6u, 0x4662508Eu, 0xE87EEB99u, \n0x08AFA6B0u, 0x7E56C094u, 0xCAA19DC1u, 0x4771ED1Bu, 0x0AE8A320u, 0x9B9D0CBCu, \n0xCFD4EE1Fu, 0xEA36840Fu, 0xF89603D9u, 0x6E8CE5E4u, 0xF93CC108u, 0x035B07B3u, \n0xE861F16Du, 0xF9ECCC7Fu, 0x90D53D33u, 0xE152C3B3u, 0x99CA9D3Bu, 0x2BA480F2u, \n0xA4CECDD8u, 0xDB58D12Cu, 0xE8C6F254u, 0x15F69287u, 0x1B6870D9u, 0xD8217854u, \n0xCF2D4FC3u, 0xF7F3E29Au, 0xFCA748C3u, 0xC41B7F8Du, 0x28B15E1Bu, 0x68CBA359u, \n0x68896991u, 0x4339DC5Bu, 0x0D1F284Eu, 0x55790890u, 0xDAFDED4Eu, 0x499BDD7Bu, \n0x691B6EA8u, 0x2DB2CAE1u, 0x94909473u, 0x0071A224u, 0x0E2F18A6u, 0x3713D13Du, \n0xB96141F5u, 0xF0011D6Bu, 0x60497C95u, 0xFDCE88C4u, 0xD5116110u, 0xF9835E35u, \n0x7F266D9Au, 0x1BABE7A4u, 0x924A1732u, 0xF5968FFAu, 0x0C91B6A8u, 0x148853E8u, \n0x4AB0D414u, 0x70E54502u, 0x37B84C1Bu, 0x2870E9AFu, 0xE9768DE1u, 0x47573659u, \n0xB242EB8Fu, 0xAAAAFF17u, 0xD67BEE3Fu, 0xE9C6B94Fu, 0x6FFACD91u, 0x499C2D17u, \n0x77BCE6D4u, 0x98F7B619u, 0x88C7941Au, 0x4D652D8Eu, 0xD95CD616u, 0x91653CA0u, \n0xD470BC8Eu, 0xFBDA0795u, 0x1D6E9B32u, 0xD4EED031u, 0x3DF88450u, 0xE5BC6CD8u, \n0xA5037658u, 0x817FE71Eu, 0x2E7C0F61u, 0x395BA7B2u, 0xAE330C19u, 0x1725F36Bu, \n0xB5B3D157u, 0xCCD1107Fu, 0xC0329869u, 0x919BAEB8u, 0x089B9367u, 0xB5AAF27Bu, \n0xFF181C29u, 0xA2F19028u, 0x1B6B3669u, 0x161AE2FDu, 0x9D6D7BA8u, 0x440F01B8u, \n0xF6B46B72u, 0xECDA4A23u, 0xE0C9FD82u, 0x0AAA9C9Au, 0x1359D264u, 0x39DF84F0u, \n0xAFDBE4B0u, 0x477111D9u, 0x776BA37Au, 0x75455A6Fu, 0x5453DD25u, 0x73460A91u, \n0xBB7F3A61u, 0xC3F3D7B7u, 0xFDF0CC7Bu, 0xEE62FA34u, 0x3599DE1Au, 0xDB1D26A1u, \n0xC8FD8F0Eu, 0x1DE45D86u, 0x1F4ED192u, 0xB8FD344Bu, 0x67739D5Du, 0x6B4A995Du, \n0xA409A8E1u, 0x6347E05Bu, 0xD5FB4A53u, 0x5E6A3E44u, 0xA6B4DDDDu, 0x5A6FE137u, \n0xAF563EA4u, 0x448F8E22u, 0x9F17CF97u, 0x9F5FB17Fu, 0x68F4E80Fu, 0x15DB829Du, \n0xE4167771u, 0xF3178F67u, 0x6D9D054Cu, 0xEE0B7A3Eu, 0x44C47771u, 0x59198ED5u, \n0x83F2DEA1u, 0xA84B6F07u, 0x9F58194Cu, 0xB98779A0u, 0x436B866Fu, 0x8C02E18Au, \n0x02D8E81Cu, 0x6DA1E1F2u, 0x0D0B67F2u, 0x7C3C6A70u, 0x48B07DA4u, 0x41ED1378u, \n0xD2E1F392u, 0x731726D1u, 0xCCCBEA2Eu, 0x94A0C8DAu, 0x59928C34u, 0xF81F739Bu, \n0x79E71EC4u, 0x5216AFDFu, 0x5F4F3B84u, 0x8506E661u, 0xBA7C0875u, 0x4ED4E80Au, \n0x1BF33A93u, 0x6A0AE425u, 0xF48984CDu, 0x6889F70Fu, 0xFCA6D7C8u, 0x608EAB99u, \n0xF35DBB61u, 0x76BCC912u, 0x2C283835u, 0x255FBB03u, 0x46DE179Au, 0xA0F54737u, \n0x3103DF30u, 0xA57DC75Du, 0x4A190DDAu, 0x4F127BA2u, 0x07A8C4FBu, 0x7046C5EDu, \n0x45493B1Du, 0xB5739CB1u, 0xB36862BCu, 0xB99A2CB4u, 0x8F8E592Au, 0xDEF2D135u, \n0x056E2AF5u, 0xB4DC24DCu, 0xB924408Fu, 0x3D4FFE0Eu, 0x745C92C1u, 0xE3F427E6u, \n0x28550E23u, 0x9CF3AF91u, 0x28BE807Du, 0x2E637A54u, 0xCB67CEBBu, 0x7DFDB962u, \n0x5E63A4E1u, 0x788649B8u, 0x703F2AFBu, 0x817614B4u, 0x804557A2u, 0x64F7390Fu, \n0x1A0E2A5Bu, 0x6CBA6ED3u, 0x6F7DBFF6u, 0x9EF90F10u, 0x1FFDA1EFu, 0xD10BDF22u, \n0x65C39803u, 0xE4010E63u, 0xD159AB72u, 0x53364913u, 0xD6B880E6u, 0x162EAC61u, \n0x6F2AD4E2u, 0x7A4B7E8Eu, 0x0A913D59u, 0xA19BFF90u, 0x841085C0u, 0xAAA60B6Cu, \n0x00DB7683u, 0xDBDFD736u, 0xF3868C19u, 0x99BB5B13u, 0xB2D94AD0u, 0xD2A6A8F9u, \n0xCABC91A2u, 0xC1E898DDu, 0x4330424Cu, 0x065C35B0u, 0x5FE43E65u, 0xCBC0FFB4u, \n0x02A675C6u, 0xFE2DAD5Fu, 0xB0C57F53u, 0x5D440140u, 0xFC36AA3Eu, 0xED258357u, \n0x2C256332u, 0x708EE7A2u, 0x11BCB2FAu, 0x39F5E566u, 0x6749AC2Fu, 0xDE827AAEu, \n0xA73E4A22u, 0x19BE36C2u, 0xE687A681u, 0x522304FFu, 0xF2818B3Du, 0x07C3595Fu, \n0x3F71E536u, 0x641D44F3u, 0x5A605126u, 0xACEB0B8Cu, 0xD168806Cu, 0x2A0F7DF6u, \n0xA675DBCCu, 0xF4252190u, 0xD2E0BA8Bu, 0x07E9854Cu, 0x2452249Cu, 0x5BAE7086u, \n0xBD78CC07u, 0xD6B4BFE7u, 0xEBE0E18Du, 0xB89820F3u, 0x660C3680u, 0x71B96D47u, \n0x23BACADDu, 0xE109BAFAu, 0x0FA2D5FBu, 0xF2870890u, 0x3A4BC11Cu, 0xA4B2609Bu, \n0x25A43554u, 0xE12CFFA4u, 0x75A4D550u, 0xF15FD717u, 0xEFB9F6D7u, 0x037E2838u, \n0xF15129B2u, 0x17172D92u, 0x2F62FB85u, 0xE657AE0Eu, 0xE290C271u, 0x937CE67Eu, \n0x48203828u, 0x5922DCE4u, 0x80420543u, 0x5201134Fu, 0x2AE7F1FCu, 0x7D0629FEu, \n0xDBE16E23u, 0x8BE7E449u, 0x921F7ED2u, 0x58A92DE7u, 0xB211D66Eu, 0x0F7FF65Au, \n0x4031B085u, 0xAD844CCFu, 0x4180F6E3u, 0xB0A6BF2Bu, 0x91C265BFu, 0x568B1CCDu, \n0xD132E95Fu, 0x305A268Du, 0xA4F21270u, 0x54C7AF27u, 0xB6032909u, 0x66693668u, \n0x62B9CA60u, 0xB1D2B2CCu, 0x64CE4357u, 0x3645B057u, 0xB9CF0806u, 0x91D2C48Eu, \n0x44CC93DEu, 0xB9145095u, 0x3C719D6Bu, 0x3510B369u, 0x7E429FE0u, 0x4C36FD01u, \n0x75048E1Du, 0x7530DECEu, 0xAA07E4BAu, 0x61F2DB0Du, 0x946E9A21u, 0x369630E0u, \n0x95C1D69Cu, 0x5FB58550u, 0xBF0DA9EDu, 0x66ED62F1u, 0xE1F28FB5u, 0x668DE4F1u, \n0x32C36FCCu, 0x1F76F607u, 0x1978D70Bu, 0xCFAD619Eu, 0x87081237u, 0x92CEFB1Cu, \n0xC2FEBB61u, 0x88390DB8u, 0xD10083D9u, 0xCB7BB491u, 0x0631D8C6u, 0x8F61C580u, \n0x9005486Cu, 0x21E49AA8u, 0xE35DDF6Cu, 0x77AFCD90u, 0x036EA4F4u, 0x2AFE8E60u, \n0x41F8EABCu, 0x0FCF299Eu, 0x06A4AD91u, 0x72EE581Fu, 0x2118D1A3u, 0x114B632Eu, \n0x70F9E838u, 0xD0A70A0Au, 0xED8EBCC0u, 0x4E293719u, 0xB7A6B493u, 0x7861B68Au, \n0xACF1FDB7u, 0x9C67542Au, 0x8A7DFA15u, 0x5094F641u, 0xFACE5A24u, 0x632D0A45u, \n0x2EF1CBEEu, 0x175D1A8Eu, 0xB078244Du, 0xBD42F04Du, 0x3486394Eu, 0x57370840u, \n0x71C226BFu, 0x1CCFFD9Fu, 0x63EBC153u, 0x46FFA090u, 0xBE437395u, 0xA67A4BBBu, \n0x9978E4ACu, 0xF3A4719Au, 0xEDB638E6u, 0x80E7831Au, 0xC37DBE03u, 0x848A54A9u, \n0xBFDDE9A6u, 0x3C7DF0F9u, 0x74B362E4u, 0x8E69802Bu, 0xA83B8C4Eu, 0x98E9F314u, \n0x5A134ED2u, 0xCC93FBADu, 0x841F66F7u, 0x48B6E129u, 0xBF4415A0u, 0x4312FD03u, \n0xD3A58604u, 0xDCEB6B9Bu, 0xEDD61573u, 0xA5D46E93u, 0xAA573BD6u, 0x6C932C65u, \n0x76F33157u, 0xA3AA70A0u, 0xC137CE9Au, 0x46ACE95Eu, 0x4C1C33C0u, 0x7149EB9Eu, \n0x2DFB4C6Cu, 0xEFDEC8DFu, 0xFE489409u, 0x13AD846Fu, 0x27BAFC00u, 0xF1455C5Eu, \n0x1E8ACD48u, 0xD96BFA75u, 0x8C594AC8u, 0xE2318696u, 0xDA45CC8Eu, 0xBDDB9F4Fu, \n0xDA1D4918u, 0xB8549BF3u, 0xC0D4D493u, 0xE62AB40Fu, 0x453F1C8Du, 0xA0CA3841u, \n0xD437B850u, 0x0D50139Cu, 0x78B4A7B7u, 0xE757BEB1u, 0x3F0271ACu, 0x06BF1F82u, \n0xC50FA7FAu, 0x9DE568A7u, 0xB7297CB9u, 0xF7331AE7u, 0x74191E67u, 0x254FB690u, \n0x632C74B6u, 0x51E5AD3Bu, 0xAC19A5CCu, 0x1C343C3Fu, 0x1182E100u, 0x18843F90u, \n0x376878F8u, 0x1E5F113Cu, 0x1E12366Du, 0x64CDB24Au, 0xC47C7DF7u, 0xA88C4B67u, \n0x794F301Au, 0x5CCAE73Du, 0xDD16E8DDu, 0xCCBA9576u, 0x95A1E07Au, 0x8C5A23B3u, \n0x183BE9E6u, 0x14F7AF14u, 0x79C4FCFCu, 0x8F3F7889u, 0x3A87993Du, 0x894907D6u, \n0x19CA534Eu, 0xC893BA9Eu, 0x7E3785B2u, 0xADA65AFDu, 0x2754B39Au, 0xA47417AFu, \n0xB8AC5D70u, 0x453B163Eu, 0xA7BFF47Fu, 0xA1DFE8B9u, 0xF687E9B3u, 0xF9CC77ECu, \n0xD6393E42u, 0xE9520F5Eu, 0xCDD66DF0u, 0x3FEED4C7u, 0x61B0DBB2u, 0xC5BBBB00u, \n0x89C8E54Eu, 0xE387A57Fu, 0x7A0D4C91u, 0x51FCAFBCu, 0x9A4EF98Fu, 0xC71FA75Bu, \n0x766FDA44u, 0xC82E83C4u, 0x297096DBu, 0xCE352D1Cu, 0xE8A13BF1u, 0x926D355Eu, \n0x77999106u, 0x2CA5BF46u, 0x67234A67u, 0x6B201618u, 0x3CE1A9D1u, 0x7F63B257u, \n0x66099028u, 0xE2099826u, 0x55E1DDB7u, 0x106F7101u, 0x6860A196u, 0x05CD6A29u, \n0x9D85BB97u, 0x4306BDBBu, 0x5C767942u, 0xE91B7EE6u, 0xD4CF11C3u, 0x6FC7D4E8u, \n0x3F155D8Cu, 0xE1811C9Fu, 0xA42BE870u, 0x42911F10u, 0xF7F22DB4u, 0x238FFC9Du, \n0xC2A3FD75u, 0x007D6A0Fu, 0x60AE964Cu, 0x47334AB5u, 0x86709E79u, 0x799FE268u, \n0x775A48ACu, 0xA64F39BBu, 0x495694C8u, 0x36ABEAF5u, 0x71483C28u, 0xFEB1BA28u, \n0x16A185B2u, 0x99F2109Cu, 0x5539A7DEu, 0x18DA9FFCu, 0xF6048ADFu, 0x7E2A4004u, \n0x1E7BF92Cu, 0xBB7172C4u, 0x5CB6144Du, 0xCB692B95u, 0xCCC7539Du, 0xDFA1FF2Fu, \n0x414A398Du, 0x179E129Bu, 0xA674575Fu, 0x1F0FDFCAu, 0x052A11F6u, 0xE7D0FD47u, \n0xEC4CB160u, 0x1ECCAAF1u, 0x0A9C50C4u, 0x7C97D0C4u, 0x5D4CA85Cu, 0x4F7B5934u, \n0x9A5D522Du, 0xBEF1AC97u, 0x74B2D43Du, 0x73D398E0u, 0xBC7D46EDu, 0xBDF789E4u, \n0xCD7F3C48u, 0x9A79D794u, 0xAE7E8663u, 0xB3B18757u, 0xA9F52FBDu, 0x92BD46C1u, \n0xA281488Eu, 0xA76B624Fu, 0xB2E6F516u, 0x02B33236u, 0xA8100F75u, 0xC65205BCu, \n0x9ABA32F4u, 0xAF00DF74u, 0xC301ABE6u, 0x2BED1ADBu, 0xACB3C80Eu, 0x6947B494u, \n0xB5E07C85u, 0xCD64AA72u, 0xB9A14DE7u, 0xDB95D2D2u, 0x432E5BDCu, 0x595A3C43u, \n0x77B98F65u, 0x3242CEB3u, 0xD1C0C758u, 0x8E9570C1u, 0xE2A1BC13u, 0xD8245543u, \n0x33CA8A09u, 0x35E8224Du, 0x3603DE09u, 0x942EA3DFu, 0x2AD09948u, 0x80F3FCA6u, \n0xFC014C9Du, 0x3DF2391Cu, 0xFEA995CBu, 0xCE1A2BCCu, 0xE62E1896u, 0x48B4B753u, \n0x2FAB2F13u, 0x93E035BFu, 0xB2F5D086u, 0x0AEF099Fu, 0x722AF811u, 0xA3DB9F5Du, \n0x27F2BA3Du, 0x10D4EF2Fu, 0xFCC463F7u, 0x5F81DF66u, 0x82ADA365u, 0xC2DBB649u, \n0x314F31C5u, 0xDB6CA39Bu, 0x4A936964u, 0xA1DD3C16u, 0xF4E3FC20u, 0xD1B5FE58u, \n0x9EB4FD55u, 0xFCAFD302u, 0x9A9F1FCAu, 0x92A5A4DAu, 0xAF31F243u, 0x266A9BBBu, \n0x3206CA38u, 0x366A4C2Fu, 0x4628F38Fu, 0x52A498C7u, 0x8CED7580u, 0xC4493A08u, \n0xF3C0B7C0u, 0x2BA8043Bu, 0xA3F90AF1u, 0x41EA267Fu, 0x2EC61398u, 0xDD703072u, \n0xA516B0A4u, 0x35CD260Cu, 0x737CADDAu, 0xAF851C51u, 0x3E1EBA81u, 0x5B1913E8u, \n0x36E8952Fu, 0x9238C1F6u, 0x83F6BB51u, 0x1364CC50u, 0x6166EF5Fu, 0xF998FBABu, \n0x5FBDF0FAu, 0xEEF38A3Eu, 0x53C0BAA1u, 0xBC764CA4u, 0xA8C7A16Cu, 0x36D19148u, \n0x7669E14Eu, 0x6B6483D1u, 0x3174B5BDu, 0xC070F916u, 0x4CAEB9EDu, 0x7FAA3B0Cu, \n0x57B79F1Fu, 0xCA3B0F28u, 0x622C4BEFu, 0x4C553524u, 0xB6E9C71Du, 0x9D81B2CBu, \n0xC97C7CFDu, 0x4E1456F3u, 0xDC29B4DDu, 0x80FAAC6Du, 0xD5B8BACCu, 0xA6F03F6Bu, \n0xF8FE0B3Bu, 0xE86AA933u, 0xFD57F238u, 0x4BEAA70Fu, 0xAC35BB3Eu, 0xEF0D4565u, \n0x185B0A42u, 0x0FBFC4E5u, 0xF38E7641u, 0x266A44F3u, 0x11A76836u, 0xA76319A0u, \n0x398C847Cu, 0xDA9C5C60u, 0x49368C9Bu, 0xE80B9B5Fu, 0xF37A8A30u, 0x82314E8Fu, \n0x295DE4A0u, 0x3FC9B0A7u, 0xA2312A11u, 0x018E7751u, 0x0BE81AB4u, 0x21B2BA98u, \n0xB1237752u, 0xD140DBF4u, 0x45E50B4Bu, 0xA1740FD0u, 0x90BDBA6Bu, 0x13EE599Du, \n0xDFFE6244u, 0xCFC3F3D9u, 0xF9029F34u, 0x5043311Cu, 0x325F2807u, 0x2A7F1C5Du, \n0x5576A9E3u, 0x163F1201u, 0x64DB9C75u, 0x22F9D38Fu, 0xA69163BBu, 0xDA531447u, \n0xFE083AF9u, 0x87AD8DB9u, 0xC5825406u, 0x8E1A98B2u, 0x2C3E7873u, 0x6A2DFED1u, \n0xFC1EF296u, 0x0847A7BEu, 0xBD20E021u, 0x58B004F4u, 0x8DB65A92u, 0x6D6643A4u, \n0x8C6A2126u, 0x612AFDEBu, 0xA5C8CDCCu, 0x0B5C0FB8u, 0x7B9719B3u, 0xA64BCA46u, \n0x238AEFC6u, 0xA392F817u, 0xD3812252u, 0x88FCB473u, 0x7D4A6A72u, 0x6AB95000u, \n0xDDA6B8D0u, 0x61B7E21Au, 0xA57C6323u, 0xC03829D6u, 0x4065C216u, 0x09245E09u, \n0x05543030u, 0xB7F0F7DAu, 0x9F10EB8Bu, 0x856C68DBu, 0xB67374F0u, 0xAF8F745Eu, \n0x101DC482u, 0x6A1EE7A1u, 0xFF9D2300u, 0x951FF1ABu, 0x9EB49165u, 0xEC29274Au, \n0x5E36F4EEu, 0x5C5884FEu, 0xF6720462u, 0x3234C56Bu, 0xA8C76A4Cu); // array len 851\n\nuint map_map_uint_2[] = uint[](\n0x33632402u, 0x22444852u, 0x34235737u, 0x48215634u, 0x53636352u, 0x64928637u, \n0x63437656u, 0x37345753u, 0x05384256u, 0x69728332u, 0x44555283u, 0x59272469u, \n0x14315149u, 0x6354C284u, 0x24345555u, 0x37967965u, 0x23323192u, 0x43642073u, \n0x42571353u, 0x65154235u, 0x32644943u, 0x24333452u, 0x63535332u, 0x28535433u, \n0x12220523u, 0x01223231u, 0x82323145u, 0x42202112u, 0x03412321u, 0x71473220u, \n0x21526333u, 0x23280742u, 0x4533A5B3u, 0x56825359u, 0x79777446u, 0x8463366Au, \n0x34149238u, 0x56413174u, 0x69628864u, 0x55545458u, 0x64427531u, 0x77342322u, \n0x47657325u, 0x46233133u, 0x12114265u, 0x33322435u, 0x56344534u, 0x36004624u, \n0x56856454u, 0x4232A565u, 0x65254863u, 0x44224554u, 0x23623573u, 0x55655114u, \n0x84403264u, 0x24928424u, 0x57654226u, 0xA3504433u, 0x26565755u, 0x84946748u, \n0x07435443u, 0x47A37797u, 0x433814B9u, 0x77416638u, 0x32313755u, 0x03773412u, \n0x24423333u, 0x33635043u, 0x12212144u, 0x02073242u, 0x34351352u, 0x23132733u, \n0x31243313u, 0x43216032u, 0x42623447u, 0x43354614u, 0x32311731u, 0x46244522u, \n0x45143426u, 0x43535032u, 0x32506332u, 0x72605324u, 0x35752372u, 0x96133547u, \n0x51365001u, 0x52732435u, 0x44433343u, 0x65222566u, 0x26587496u, 0x38421344u, \n0x87383548u, 0x65338563u, 0x25037496u, 0x68513554u, 0x87414267u, 0x32786465u, \n0x76123634u, 0x21250302u, 0x45534315u, 0x11345012u, 0x47832622u, 0x11242321u, \n0x05243512u, 0x33735564u, 0x71524372u, 0x44461232u, 0x55145255u, 0x73644056u, \n0x61433415u, 0x36341321u, 0x58564444u, 0x3A564674u, 0x34314287u, 0x33437414u, \n0x22444445u, 0x55334962u, 0x05732236u, 0x32773828u, 0x32444447u, 0x66614556u, \n0x37862324u, 0x44743556u, 0x45464695u, 0x34317476u, 0x33555849u, 0x31852338u, \n0x62133657u, 0x42475545u); // array len 128\n\nuint map_map_uint_3[] = uint[](\n0x43844320u, 0x23574653u, 0x43715267u, 0x54435682u, 0x56852616u, 0x22134676u, \n0x23383562u, 0x26423392u, 0x09275343u, 0x88131244u, 0x55463163u, 0x68B45499u, \n0x160B4281u, 0x63123385u, 0x34324567u, 0x26767574u, 0x45234326u, 0x56532133u, \n0x23231543u, 0x43123334u, 0x65546223u, 0x33543775u, 0x45412511u, 0x43573614u, \n0x72112012u, 0x12466143u, 0x62413423u, 0x10104222u, 0x43432234u, 0x20565221u, \n0x25531423u, 0x13641014u, 0x22346163u, 0x85413343u, 0x27865B54u, 0x98478547u, \n0x3A121151u, 0x66000345u, 0x53565437u, 0x4A754623u, 0x32436554u, 0x25314645u, \n0x94474657u, 0x45401034u, 0x51114967u, 0x543135A6u, 0x44542242u, 0x34432546u, \n0x46755344u, 0x35473733u, 0x52225834u, 0x3743767Bu, 0x24333304u, 0x36104016u, \n0x13598242u, 0x72447867u, 0x05474122u, 0x8C143276u, 0x42527444u, 0x68354675u, \n0x13213374u, 0x45224265u, 0x45456733u, 0x43B85557u, 0x11211415u, 0x15745332u, \n0x32222342u, 0x20323554u, 0x22231304u, 0x32578312u, 0x42631223u, 0x12214204u, \n0x42131532u, 0x02374243u, 0x33324211u, 0x42307110u, 0x51151300u, 0x20545414u, \n0x42631653u, 0x31544043u, 0x18424567u, 0x63434444u, 0x72471344u, 0x53336333u, \n0x27221565u, 0x42524256u, 0x52357527u, 0x35546327u, 0x16348222u, 0xC2201185u, \n0x56357567u, 0x11565739u, 0x06546291u, 0x62220356u, 0x94539689u, 0x45765443u, \n0x25101144u, 0x52274520u, 0x14402030u, 0x12424212u, 0x21110204u, 0x41435241u, \n0x02421731u, 0x12331112u, 0x31645245u, 0x52356143u, 0x24423351u, 0x53319225u, \n0x54346554u, 0x21634364u, 0x41203429u, 0x24392371u, 0x69346427u, 0x51343253u, \n0x13208313u, 0x76566653u, 0x34583665u, 0x54536435u, 0x43463114u, 0x92384653u, \n0xB3375134u, 0x63453564u, 0x42234434u, 0x26534753u, 0x25236454u, 0x7024234Bu, \n0x56757434u, 0x43424433u); // array len 128\n\n\n#define self_buf iChannel0\n#define map1 map_uint_2\n#define map2 map_uint_3\n\n#define mapmap1 map_map_uint_2\n#define mapmap2 map_map_uint_3\nconst ivec2 mapmap_reg = ivec2(0,34);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord);\n    \n    if(ipx==ivec2(32,32)){\n        fragColor = vec4(1.,map1.length(),map2.length(),0.);\n        return;\n    }\n    \n    if(ipx.x>=32||ipx.y>=32){\n        if(ipx.y!=mapmap_reg.y||((ipx.y==mapmap_reg.y)&&ipx.x>=mapmap1.length())){\n            fragColor = vec4(0.,0.,0.,0.);\n            return;\n        }\n    }\n    \n    bool reset = texelFetch(self_buf, ivec2(32,32),0).x<0.5;\n    vec4 self_col = texelFetch(self_buf, ipx,0);\n    \n    if(iFrame>0&&!reset) {\n        fragColor = self_col;\n        return;\n    }\n    \n    if((ipx.y==mapmap_reg.y)&&ipx.x<mapmap1.length()){\n        fragColor = vec4(0.);\n        fragColor.x = uintBitsToFloat(mapmap1[ipx.x]);\n        fragColor.y = uintBitsToFloat(mapmap2[ipx.x]);\n    }else{\n        int idx_x = ipx.x+ipx.y*int(32);\n        fragColor = vec4(0.);\n        if(idx_x<map1.length())\n            fragColor.x = uintBitsToFloat(map1[idx_x]);\n        if(idx_x<map2.length())\n            fragColor.y = uintBitsToFloat(map2[idx_x]);\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// map of connections 5 and 6\n\nuint map_uint_4[] = uint[](\n0xB1CF6B20u, 0x15E2B065u, 0x7184D380u, 0x345FFCF9u, 0xC183EC09u, 0x426DEA77u, \n0xBAC07291u, 0xF3531AC8u, 0xD5F71622u, 0x57AC7411u, 0x7CB6A80Eu, 0xA0EADE82u, \n0x6BCEFCF7u, 0x894E3C3Du, 0xCE6BA765u, 0x94A78765u, 0x4247C50Au, 0x0C3DC143u, \n0x14241443u, 0x444A16CEu, 0xEEF591E6u, 0x03B0BD48u, 0xBD171395u, 0x79F68478u, \n0x6217E81Bu, 0xB7A4BEB3u, 0x673FFD11u, 0xC9F367E7u, 0xC50D75A7u, 0x341C3531u, \n0x9C04A7D2u, 0x057EE109u, 0x53FFC709u, 0x5C5B806Cu, 0xABFFD585u, 0x23192C66u, \n0x3E94C523u, 0xEAF94771u, 0x8B248C94u, 0xD261C32Bu, 0x6623B3E0u, 0x7A4BD53Fu, \n0xDE0BF707u, 0xA6AA44E7u, 0x036F2FF4u, 0x816265C1u, 0xF28B0A2Cu, 0x7D39F997u, \n0x24F7E572u, 0x61C75AEEu, 0x85C591A2u, 0x2DD512F5u, 0x9B0CCD4Du, 0x03D9C9ADu, \n0xDA520F88u, 0x6D7D8B4Cu, 0x88E873CAu, 0xAFC8089Fu, 0xF7902745u, 0xD4E226FEu, \n0x6A021F8Fu, 0x22C4289Du, 0xC9BB4E5Eu, 0xBF02AED0u, 0x2EB65B1Du, 0xD162B8A6u, \n0xC8D687FCu, 0xF35472F6u, 0x59DC8DCCu, 0xC87C4DD4u, 0x8FF691CAu, 0xB2885D71u, \n0xDDCAD5E3u, 0x4947D020u, 0xE1FE7718u, 0x7500636Au, 0x254E2E8Du, 0x39344B4Du, \n0x22E4C447u, 0xD3B179A8u, 0x016F9508u, 0x257DC320u, 0xF613275Du, 0xB6FD8927u, \n0x653F872Du, 0x9DED0142u, 0x9849635Eu, 0x483D1E2Bu, 0xFAD7B417u, 0xDF91FAE0u, \n0xF6A2269Fu, 0x848A9DD5u, 0x893CC6C3u, 0x3B2E4344u, 0x4B83A22Du, 0xBE86BE91u, \n0x84B2C60Bu, 0x7B293CAFu, 0x4EA8E0A5u, 0xBFFE4ACBu, 0xDECB7402u, 0x89D084BEu, \n0x69EDFFFCu, 0x2FBA9C6Bu, 0xF6B71C52u, 0x613E9AF4u, 0x1BC51CB8u, 0xE75C3F3Au, \n0x5D17188Fu, 0xA2B96AF0u, 0xF71915B8u, 0x93E3D823u, 0xD35F5FABu, 0x3995F65Du, \n0xE88A9088u, 0xCA541AC0u, 0x988C0296u, 0x9227D63Bu, 0x462172F3u, 0xDE77F82Fu, \n0x9A9E1F1Au, 0x4017D31Fu, 0x8E7D719Fu, 0x9ED0E481u, 0x8CB38CC8u, 0x66D538FAu, \n0x07151E94u, 0x3E7D4B08u, 0xBB35B375u, 0x38AE6C64u, 0xF1F21F1Fu, 0x989BCE0Fu, \n0xB433A855u, 0x0F746F81u, 0xFFE93250u, 0xF0F4A2A4u, 0xB57DE547u, 0x34909E8Du, \n0x97295DA2u, 0x54D70068u, 0xFA74B6CCu, 0xA87B575Du, 0x1832B77Au, 0xE8A4ACE6u, \n0xFC2D5834u, 0x336041E1u, 0x27FDC5D0u, 0x100356D1u, 0xE217BF85u, 0xFD94A9B4u, \n0xA3C05F9Cu, 0x17D82C4Bu, 0x5482070Au, 0x95D93DF1u, 0x33D1D236u, 0x914203DBu, \n0x86B8C93Au, 0x7B9EBECBu, 0xEEF1E4EEu, 0xE5F49331u, 0x5E6F6075u, 0x3FA29A22u, \n0x778878F9u, 0xCB43C3B4u, 0x90129A06u, 0x5B96DACBu, 0x513683ADu, 0x38EF33D4u, \n0xF28D2AE3u, 0x58623996u, 0x767D2FA8u, 0xB9B85C72u, 0xEF095C07u, 0xDFA5B330u, \n0xB6DB15C5u, 0x86ABC383u, 0x2DBD0582u, 0xAF8E27F1u, 0xDF6009E5u, 0x25B73028u, \n0x0A05F817u, 0xD25CFAFCu, 0x41CE413Fu, 0x10BF13BFu, 0x20058252u, 0x956FC887u, \n0x62BE9104u, 0xD7F36C8Bu, 0x49DDD182u, 0x47E61D4Eu, 0x3E5D3928u, 0x6A4B3958u, \n0x99AFF0E3u, 0xE83C0E29u, 0x87BC7886u, 0x8E17E99Du, 0xD583423Eu, 0xE8C0B14Bu, \n0x1433A022u, 0x9AB8F105u, 0x20487460u, 0xB768B01Bu, 0xB2328556u, 0x47E0C483u, \n0xC70FFF7Fu, 0x8BF1D444u, 0xAEC26A3Eu, 0x7D265A9Fu, 0x085C98D3u, 0x1C798308u, \n0x201CE786u, 0xF2EA0943u, 0xDA03E016u, 0x62C19651u, 0x1559029Fu, 0x2A0EE19Fu, \n0x20460395u, 0xB94DAFFDu, 0x0C2F8FFCu, 0xD56F5BA8u, 0xFC9BCA91u, 0xBF7D88E9u, \n0x0F79941Du, 0xA352531Au, 0xA3EE5F98u, 0x6DCA28BAu, 0x9CE30B94u, 0xD0C9F1FCu, \n0xE381EC31u, 0x583BA8FFu, 0xF30BD9D3u, 0xB0B547E9u, 0xF779E745u, 0x0142D0DAu, \n0x4A0B7418u, 0xB446F468u, 0xAE598F65u, 0x788B8EFFu, 0xBD209899u, 0x793B1934u, \n0x51605C36u, 0xEA65D745u, 0xB8F2B790u, 0x40CEF264u, 0x3D7E5575u, 0x1075ADDEu, \n0xB40E38E4u, 0xB79DD892u, 0x5D69F2A4u, 0x26E28665u, 0xD1025B4Du, 0x9EC51A39u, \n0xD6CCFE50u, 0xA66759D9u, 0x920A8607u, 0x4788249Cu, 0xF4593A76u, 0x2EAE2C0Fu, \n0x7D129AF2u, 0x8E49E9F7u, 0x08386081u, 0xC83F000Fu, 0xF94744D3u, 0x1A6F45D4u, \n0xB73786D3u, 0x44C12DFAu, 0x862D72CFu, 0x430BAF54u, 0x8EB0E57Du, 0xFA314AB0u, \n0x18BECDD8u, 0x2D64AB9Au, 0x9D68B7B8u, 0x7B543A23u, 0x161C4895u, 0x4EE5C3FBu, \n0xEF1DBF25u, 0xB762E6A2u, 0x8E8B5ADBu, 0x1885D226u, 0xA357E877u, 0xB9FD910Cu, \n0xB9DA6EF0u, 0x46452C50u, 0x2A5022EBu, 0x9C26F203u, 0x370C2C4Au, 0x27C3105Au, \n0x20DD3463u, 0x36508E5Fu, 0xD820A442u, 0xE1EFE497u, 0xC26681FBu, 0x3F730B1Au, \n0x4AEA0B44u, 0xB1AA0B98u, 0x2454A00Fu, 0x9431E88Du, 0x274B251Bu, 0xCF6AC8C2u, \n0xAA5D4E02u, 0x25511F41u, 0xD5F4220Eu, 0xCCF9E5AFu, 0x6C525488u, 0x6CA91F9Cu, \n0x0FA6B1B4u, 0xCC32F5A5u, 0x6FA51ABAu, 0x815A5BB2u, 0x7C3E0D42u, 0xE7699610u, \n0x0FBCD5D8u, 0xD4682FFDu, 0xCBB1C478u, 0x5E2CD4F2u, 0x0F840F64u, 0x41F753B3u, \n0x6C3821D4u, 0xEBC129A6u, 0x56AE5DCCu, 0x916EABD9u, 0xD7E7AC0Du, 0x567A09CDu, \n0x45A21575u, 0xD757C04Du, 0x867DA680u, 0xCFA65446u, 0x86521453u, 0x6072F629u, \n0x53EFDCE4u, 0xFAF6771Bu, 0x70EE872Eu, 0x3246E5F0u, 0xC44B0D6Du, 0x31072EC4u, \n0x8A38B348u, 0x6E676CF7u, 0x86DAB59Bu, 0x139D411Fu, 0x84FD5B40u, 0xFA579739u, \n0x0807153Cu, 0xFF7B13F2u, 0x520C4F5Au, 0xC0C307D2u, 0x8C0FB9A8u, 0xF9099112u, \n0x4546BB63u, 0x7528FA64u, 0x170D6717u, 0x5BBD81B1u, 0xFA9662F2u, 0xE3361731u, \n0x2E672902u, 0xAA9FB6FFu, 0x8555FD36u, 0xE572C53Fu, 0xD36C1E2Bu, 0x549B37DFu, \n0x2FFF250Au, 0x6B46D6A0u, 0xF12C5D20u, 0x69CEE27Bu, 0x88D550ACu, 0x161EF5B4u, \n0x33D6E825u, 0x870C16DCu, 0x8CE84375u, 0x6AA6698Eu, 0x459B92E5u, 0x88E55FDDu, \n0x1FE387B0u, 0xC9EBC91Du, 0x681D7E0Bu, 0xFDD7A489u, 0x90E6C9CBu, 0x602582D1u, \n0x22953566u, 0x28C8EB9Cu, 0x53376D89u, 0x38AED179u, 0x78A9CB9Bu, 0xEC68EC73u, \n0xA87EE0FAu, 0x42DE8E87u, 0xD63E736Bu, 0x70D4EC2Eu, 0xAB82C5E0u, 0xE7E6A4B1u, \n0x75AB71ADu, 0x23E8A9F5u, 0xFDA31AEBu, 0x3E4629D2u, 0x3A2546C9u, 0x6C8B9C64u, \n0x34E59A66u, 0x2694CCD5u, 0x186531D9u, 0x2846B828u, 0x4D643020u, 0xA354B460u, \n0x6ED2E73Eu, 0x03F5BFC0u, 0x421A1C96u, 0x790FC112u, 0xE67FACD6u, 0x14EB1BD2u, \n0x475ACD26u, 0xE29747ACu, 0x5D48C694u, 0x22FF8B7Fu, 0x0EB8210Fu, 0xF9CD9CC6u, \n0x9AC28C0Cu, 0xAF61472Eu, 0xAA4C6E6Eu, 0x70A54F28u, 0x6786EF67u, 0x70C5EE2Fu, \n0x253498FFu, 0x9A900AE4u, 0xD4F62D1Fu, 0x879E0121u, 0xA9EE17FFu, 0x0F3227CBu, \n0xB6E46C96u, 0x6EAE29A0u, 0x3B107C83u, 0x650818CDu, 0xB27B7447u, 0xEAA2BBFFu, \n0xD5E056C1u, 0x02409E69u, 0xEFE421F3u, 0xB09C670Fu, 0x29570C1Cu, 0xAFDC2A08u, \n0x7CFDF765u, 0x7204A466u, 0x946B1D97u, 0x28EA6668u, 0xA33639AEu, 0xA74908F8u, \n0xA1272484u, 0x5A60AADDu, 0xF92EC5CDu, 0x1031A0E3u, 0x588C0F08u, 0x1F7E5FCFu, \n0x816F5552u, 0xAE2FFD7Fu, 0xED870869u, 0x30FC2AF0u, 0xFFAB598Fu, 0xFC4C44C4u, \n0xCBBA6E48u, 0xC627ABBEu, 0x1138FA26u, 0xD7782C64u, 0xA6F6B127u, 0xF63D3E98u, \n0x9F097F5Fu, 0xB4AE1841u, 0xD0331689u, 0x2D6BA93Fu, 0x3C3D85A5u, 0xECD72294u, \n0x7C57A3B8u, 0xF098A212u, 0xB7B01E65u, 0xB6EBD61Bu, 0xF575DB19u, 0xCC5D9117u, \n0x192A8BE3u, 0x8F1F5DA4u, 0x12DE0A95u, 0x659F2F77u, 0xBCE0A2B0u, 0x9C18C442u, \n0x975B2878u, 0xA552D8D5u, 0xB6CEF5A3u, 0x3936D6C0u, 0xCC6D147Fu, 0x0A44D7D0u, \n0xB1D08482u, 0xF6FDAA1Au, 0xD50522AAu, 0x061C0150u, 0x10F5C64Cu, 0xD318D6D7u, \n0x905A2B13u, 0x468E070Cu, 0xDE6232DAu, 0x038786BBu, 0x142D5440u, 0x8962AE80u, \n0x09C85F5Au, 0x4997476Eu, 0x91CB4991u, 0xCD47F795u, 0x3713978Au, 0x49297585u, \n0x13E55737u, 0x99E74D41u, 0x1E11C50Cu, 0xF14F26A9u, 0xAA983A7Du, 0xD1186CD8u, \n0xC3260BC3u, 0x49B3337Fu, 0x7C42CC15u, 0x036E726Bu, 0x7E672E67u, 0x5A4AA4A0u, \n0x2DFAD6C4u, 0x8582FC97u, 0xA82E5508u, 0x1E124358u, 0x9AD7A03Cu, 0x73F53DF5u, \n0x51280826u, 0xAEAC05BFu, 0xEC4B6ED0u, 0x547BFB24u, 0x4B4C73BDu, 0x70135BAEu, \n0x29236287u, 0xB868A667u, 0x49096E64u, 0x4A853BD7u, 0xA53F3877u, 0xB0718669u, \n0x44D37890u, 0x7FCA8420u, 0x6937075Fu, 0x18E7D4B0u, 0xEF4D3995u, 0x64E3158Fu, \n0xC8A3EADAu, 0xF6AAAD07u, 0xD85BCC96u, 0x1A96E5DCu, 0xCE5284CFu, 0x413723C2u, \n0x6BFB5774u, 0x2DCDA96Eu, 0x16EE76A0u, 0xA1131619u, 0x40725CA4u, 0x68B90369u, \n0x811887CDu, 0xF0B70670u, 0x4C8C48FDu, 0xC64E1B5Bu, 0x8A1A8B1Au, 0x8D6C9DA5u, \n0x81EC6934u, 0x8E74F54Eu, 0x09DB637Au, 0x394EDEBBu, 0xA0FD5FE2u, 0x35E32E2Fu, \n0x62593F21u, 0x6FFE80C1u, 0xFD07078Du, 0x71299487u, 0x073167BFu, 0x44A6E2E1u, \n0x860B6890u, 0x23772918u, 0xC64E4E2Cu, 0x633675C1u, 0xB7942F95u, 0x95BB2900u, \n0x7DD4CB5Eu, 0x4C3CA541u, 0xFC8F173Eu, 0x0878FC11u, 0x82D16337u, 0x56B377B2u, \n0x9BBC96CCu, 0x0940C974u, 0x70C92C94u, 0x2AE28F49u, 0xB8BBF183u, 0x0413FA39u, \n0xC96D1A7Eu, 0x449C0DDAu, 0x42AF56B7u, 0xCE7255A8u, 0x9BF6741Au, 0xF35BC31Au, \n0x50711BD1u, 0x96B828CEu, 0xD117345Du, 0xB15C80FFu, 0xB05CC769u, 0xDA163133u, \n0x5A0AEBA4u, 0x40385BE5u, 0x73D87D56u, 0x0D56EFF2u, 0xDE599751u, 0x6310CE02u, \n0x54840F61u, 0x5351FB16u, 0x714773B5u, 0xB902FBD7u, 0xE8006CCAu, 0x24CB9A30u, \n0x6D940215u, 0xCEB3292Du, 0x77938CB9u, 0x284162B6u, 0xC3382E16u, 0xF1677B4Au, \n0x4452A00Au, 0x13D30B91u, 0x5832662Fu, 0x523D2153u, 0xE111CE7Fu, 0x7F7EE73Cu, \n0x4FC41EF4u, 0x3332E863u, 0xB1FB1939u, 0xD2E486D2u, 0xE5173AD0u, 0x15790DE9u, \n0x194F9CDFu, 0x943B9A63u, 0xBA22EC8Au, 0xFBA53284u, 0x8B9EC801u, 0x386BF66Fu, \n0x8617CABAu, 0x13570401u, 0x0F3E9841u, 0x2C256C78u, 0x7DE62C04u, 0x64358CF9u, \n0x13CEE091u, 0xFD55C761u, 0xF26E21E4u, 0xE889DCE2u, 0x1950DD02u, 0x0F2F1157u, \n0x82A9A2EBu, 0x31B7A4B8u, 0x37FA0FE7u, 0x6D970A52u, 0xC310F4B3u, 0x7604DA6Du, \n0x3189263Eu, 0x50AFD013u, 0x877B1D97u, 0xF1BCB58Eu, 0x13C4CF9Du, 0x7A5DB9E2u, \n0xEF6C7EACu, 0xEF4BCAACu, 0xA61A36DBu, 0x498B8517u, 0xC26889BDu, 0xAD548485u, \n0x12842071u, 0xB417FE8Eu, 0x666C125Du, 0x2B906162u, 0x7BD17CDBu, 0x15DB37EFu, \n0xABB9496Au, 0x2120DC79u, 0x613C7FDBu, 0xF98DE5A8u, 0xC67F8546u, 0x9D5F28C3u, \n0x3BA6C5C6u, 0xCCB2CD4Fu, 0x5058F499u, 0x9AEBE6C9u, 0x3DF4B550u, 0x66CB7B9Au, \n0x66989A0Bu, 0x4F65FB6Eu, 0x0C2F1FCAu, 0x1557BE44u, 0x70C07BAEu, 0x4DD28FF5u, \n0x4531E0A6u, 0xB0BABEC5u, 0x3DE5593Fu, 0x409E003Eu, 0xF15B4EECu, 0x05BF7D22u, \n0x4F8DFCFCu, 0xB6572B34u, 0xA956B21Bu, 0x7A26E97Du, 0x318BAF6Au, 0x331C7851u, \n0x4C413014u, 0x014765F6u, 0x95C7956Eu, 0x1304FAE1u, 0x8FBD6C7Cu, 0xAB4EAC83u, \n0x01E90E99u, 0x6CB616D6u, 0x4DCBF56Du, 0xDB1CC5D4u, 0xA6B1AA7Cu, 0x8E207625u, \n0x8BE52633u, 0xACDF805Du, 0x983E7446u, 0x351D1A79u, 0x00851BC6u, 0x954EC99Eu, \n0x7EEEECCBu, 0xF21127BDu, 0x3B8DE41Du, 0x642A12C1u, 0x570C7636u, 0x79D2AAB5u, \n0xEC4610BFu, 0x98BBBD8Du, 0xC11D9479u, 0x7C62C1A8u, 0xC3ADD256u, 0x3AEA7DBCu, \n0x11DFFBC4u, 0x28E4CA03u, 0xC85D57CFu, 0x3E0212BEu, 0xFE4A41D2u, 0xE78A3839u, \n0x8A77B4EDu, 0x59A6A4E9u, 0x55150FDCu, 0x608ADB31u, 0x7446A696u, 0xF50DEA70u, \n0x019F53FAu, 0x14680EB2u, 0xCB6566CBu, 0x4598EC37u, 0x3944F6D2u, 0x7F22807Du, \n0xFA8FDDD5u, 0xE0AA27FAu, 0x1F824599u, 0x7178C142u, 0x2B594525u, 0x9CD2505Eu, \n0xB9F2787Cu, 0xECFB4C58u, 0x8C64B11Au, 0x0E92A623u, 0x12D391EAu, 0x16D309ABu, \n0x0B14B458u, 0x7C233F54u, 0x5CCAB3E1u, 0xFB51239Du, 0x4175DAADu, 0xB0C48958u, \n0x94C26724u, 0x593C4D86u, 0x8DC68B14u, 0x7B0B8FCEu, 0x0146F2BEu, 0x289AAF96u, \n0xA36C66A4u, 0xA452D586u, 0xF9FFB40Fu, 0xBAAA9E23u, 0x290A2635u, 0x91AB8503u, \n0x47FCFD83u, 0x6F2B84BFu, 0x0A0FCAE6u, 0x71E8BA05u, 0x9831D032u, 0xDB00D1E2u, \n0xD0297421u, 0xBB6CA286u, 0x5D18DB45u, 0x53C101A7u, 0x64D5A1C4u, 0xD6197054u, \n0xC96A012Fu, 0xF09BD7CBu, 0x53E25925u, 0xB4168932u, 0xB0043EEEu, 0xDDE779BDu, \n0x5B20EED7u, 0xFAA078DFu, 0xF3A8F30Bu, 0xF3E22675u, 0x7F2DF062u, 0x196C682Au, \n0xC29381CBu, 0x368FD54Au, 0x27653EFCu, 0x28D391D8u, 0x6B4537A6u, 0xBF41C916u, \n0x74F35824u, 0xE825F9CAu, 0x7C0BE2E4u, 0xA1A55F04u, 0x9FFD0D14u, 0xB7F5E7F7u, \n0x152910AFu, 0x935F79CAu, 0xE75DB374u, 0x6D241815u, 0xCDED4696u, 0x9966C077u, \n0x8FB59F01u, 0x75B16382u, 0xC60AED28u, 0xBF8F1EB5u, 0x4ED56906u, 0x868B85C3u, \n0xA4E12414u, 0x93BFAA02u, 0x9155B609u, 0xCAFB7D53u, 0x22A217F2u, 0xFE7392F7u, \n0xEB6FE7B2u, 0x4558C472u, 0xC5971D8Du, 0xCA3F552Au, 0x9C25837Au, 0x2376BD57u, \n0x97042A3Cu, 0xA2E6EA60u, 0x8B7DFF1Cu, 0x913F465Au, 0x1A908D2Au, 0xFC9E1D17u, \n0x8E4F4E73u, 0x9E413ED3u, 0xC779221Fu, 0x88922840u, 0x4BE507ADu, 0xCC1938E8u, \n0xA4760CB4u, 0xBC6EB4C1u, 0x075DC961u, 0x9E6E3D53u, 0x68277AD9u, 0x74C3CA5Cu, \n0x5835CE84u, 0xCFF04990u); // array len 860\n\nuint map_uint_5[] = uint[](\n0x5FA0DF18u, 0xEBE0627Fu, 0xAB7E7014u, 0x99536575u, 0x56AA8875u, 0x972E8F60u, \n0x983848A5u, 0xE728F302u, 0xB417D7B4u, 0xE84B62E9u, 0x764E5D53u, 0xA06C8E96u, \n0x7948AF14u, 0x02BBE418u, 0x5F490E42u, 0x231D94BCu, 0xCEFEF7F0u, 0x2F47601Fu, \n0xFAD51377u, 0xF3D0FC9Au, 0x88BB3D74u, 0xCD9425ADu, 0xD6FBB908u, 0x944816B7u, \n0xBF157A7Eu, 0xE926C652u, 0xD98630BAu, 0x9D2BA2FAu, 0xB76BB47Fu, 0xF4996A44u, \n0x29C5ACB6u, 0x4B62F854u, 0x13E3C09Fu, 0xB3E473ECu, 0xD6B297B7u, 0xD21474CFu, \n0x6A763759u, 0xD10996D9u, 0x660C1F63u, 0x419F750Bu, 0x69B631A2u, 0x9314AEF5u, \n0x1482EEA3u, 0x049ABAF7u, 0xF2C486ACu, 0xAE5DA6AAu, 0x3FF54B69u, 0xC224F354u, \n0xD3F3CAF6u, 0x8AEFCD4Cu, 0x68EA39F5u, 0x0ED562DEu, 0x532E0AE8u, 0x27BB3E31u, \n0x609E62ECu, 0x5C6B128Eu, 0xC96A0E9Eu, 0x33FAB3E5u, 0xCD3D0BBFu, 0x0F472C3Cu, \n0x55EF8CDFu, 0xF32BF43Du, 0x39460F7Eu, 0x79496A85u, 0xA6106A64u, 0xAAD0B748u, \n0xEB3ACBEBu, 0x739595DBu, 0x54930666u, 0x3331618Bu, 0x389F6F8Fu, 0xA7B4A94Cu, \n0xC7B63DD6u, 0xFA21CC0Eu, 0x75A5E41Fu, 0x02614206u, 0xA3F3B2C4u, 0x19DDC02Du, \n0xACF02FA4u, 0x83E4A0EFu, 0x7902BEF8u, 0xEBDBDACBu, 0x964D9274u, 0x6DD86634u, \n0x8669BA96u, 0x89337CFCu, 0x8ECD66E2u, 0x574E335Bu, 0x2C108E5Bu, 0xD1EC93B3u, \n0x9DC0F24Au, 0x152B5589u, 0xFB5E50E4u, 0xC17F5753u, 0x2A82B8BEu, 0x9AABEC2Fu, \n0x08FF9FE2u, 0x23D09E82u, 0x66BF56FCu, 0x423C1319u, 0xB2D36A3Du, 0x86631C16u, \n0x617EFB30u, 0xF6EE6D48u, 0x5C1E1986u, 0x5D04C8ECu, 0x2EB27B56u, 0x9E07570Au, \n0x8020901Cu, 0xC6ABA417u, 0xB0C40735u, 0x98B7F17Eu, 0xC0BE3F2Cu, 0xFFC3B20Eu, \n0x093D815Eu, 0x184240DCu, 0xBEB52921u, 0xEE9D6777u, 0x78A0F604u, 0x5331B61Cu, \n0x7DDA2E2Eu, 0xF66AFC4Au, 0xAB1ACB91u, 0xC9716946u, 0x2BEF30C8u, 0x3BCFE9EFu, \n0x9B3CFAEFu, 0x103F009Bu, 0xD650DA9Du, 0xE2C42891u, 0xD7988D98u, 0xC4E736E6u, \n0xA415226Eu, 0x5685B411u, 0xEA9FA306u, 0x1575E9F6u, 0x0F488FFBu, 0x3FD1A4E8u, \n0x38917912u, 0x03A0E2C1u, 0x083B60E5u, 0x8A6CD1B4u, 0x302205A7u, 0x7EDBE947u, \n0xB8C8BBCFu, 0x15BD48F8u, 0x3965451Fu, 0x1B8106ABu, 0xD28ED571u, 0xCD5D942Eu, \n0xE24448D8u, 0x8E3D6134u, 0x6A9B758Du, 0x6E30F211u, 0x478855F4u, 0x8E381E9Bu, \n0xA97BF117u, 0x9C6AB920u, 0x51031C24u, 0x50913AD2u, 0x422DA59Du, 0xCA5ADDBAu, \n0xE583CDBEu, 0x7957890Au, 0x97A0A5FFu, 0xB25B79A4u, 0xB4E9A146u, 0xD9B56C2Au, \n0xEAB6CC34u, 0xF1E325B3u, 0x293AF67Au, 0x3C4CAD09u, 0xE12A0C00u, 0x70914869u, \n0x27C29533u, 0x9BFAE019u, 0x3D0754B5u, 0xE5586C96u, 0xFA6C5CEDu, 0x8B6EE4FEu, \n0xC90C385Fu, 0x6726E0D9u, 0x33AC7D51u, 0x4A894830u, 0x82AD8B73u, 0x07065211u, \n0x7A201820u, 0x1E3EFF44u, 0x73A1EFA0u, 0x794B9B58u, 0x5B41533Eu, 0x7143CCE4u, \n0xFE03873Au, 0xCF418518u, 0xFB080F5Au, 0x59CAD0E9u, 0x19B02434u, 0xB64CF4D5u, \n0x8A975520u, 0x51E6E906u, 0x8D9C896Du, 0x06C23922u, 0xB33AC60Bu, 0xB409F3C6u, \n0x534FB3BFu, 0xC51FA54Au, 0x3F12BFCAu, 0x552719E9u, 0x9C6B7E91u, 0xC4FD4C32u, \n0xBE7099F9u, 0x1C37F2EBu, 0xCED6E075u, 0x8279C965u, 0x2EE76682u, 0xF8E52893u, \n0x33E981F1u, 0x07C5CF9Bu, 0x613DCAABu, 0x234183BAu, 0xBA2EA9C7u, 0x622FBFD0u, \n0x52C562AEu, 0xA1141968u, 0xA7431608u, 0x1B73DC9Bu, 0xBFCF46F1u, 0x9D643305u, \n0x254D2655u, 0xEB990D7Eu, 0x8B84E8E9u, 0x3366BE15u, 0x68FDECD3u, 0xBAD310E4u, \n0x045CC4CEu, 0x2E1AD919u, 0xDFBA4F78u, 0x7E51D15Eu, 0xF1369A54u, 0x7118CC35u, \n0xD91F6D8Eu, 0xCDCC0E72u, 0x558E82EAu, 0x14370581u, 0xF45AD9C0u, 0x3DC1C4A9u, \n0xA7003E3Fu, 0x54F2103Eu, 0xAA3AE9EAu, 0xA612DA72u, 0x2392AEBEu, 0xB0CAFB54u, \n0xB4DDA60Au, 0x7668CF0Eu, 0x609E861Fu, 0xAC6231A2u, 0xFDC1FFB8u, 0x295D1266u, \n0x12F17A6Eu, 0x5C974D6Au, 0x82CAE804u, 0x10CE6D8Fu, 0x97C8267Cu, 0x1F3FB8AAu, \n0xFC3C9FE9u, 0x85020435u, 0x018315FEu, 0x46BDC10Du, 0x330F6358u, 0xD19A8C54u, \n0x4325F76Au, 0x2617044Fu, 0xBC9EBB4Au, 0x2AA103AFu, 0x25C7F2FAu, 0xBCE00F07u, \n0xB83C2182u, 0x982CF77Fu, 0x3211D6E8u, 0x0E0F6390u, 0x7E9F4E65u, 0xC5A24652u, \n0xAC5A1D30u, 0x7D812708u, 0x462F041Bu, 0x4B22D31Fu, 0x96ED1DCCu, 0x36C6CA66u, \n0xDB9EB565u, 0x0295CCE7u, 0x1E535CADu, 0x27935A2Eu, 0x956609C1u, 0xC3F5755Fu, \n0x54A205FDu, 0x57A3CDEBu, 0x79870660u, 0x3FCABDFDu, 0xADCD2B0Bu, 0x3A56EF8Fu, \n0x94A5ABB4u, 0x89EEA6EDu, 0x639CC5A9u, 0x5B737ECAu, 0x0EFD25AAu, 0xB7636B85u, \n0xD602EFD3u, 0x6B5E5496u, 0x7356EA2Bu, 0x8A9AC0FCu, 0xC9802AD9u, 0x61D7493Cu, \n0x687A47B9u, 0x380F4F92u, 0xAF80B80Au, 0xEB9CC02Eu, 0x6CAC3381u, 0x353D90D2u, \n0x60A1C8B8u, 0xA4E735A2u, 0xC40CBE19u, 0x6F2C532Cu, 0x5393D1E8u, 0xFFD81DB1u, \n0x3506DD62u, 0x7A083FF1u, 0x9C03B293u, 0xD3EB8AEDu, 0xEE4C2C2Fu, 0x39E1C6DDu, \n0x054FDF01u, 0xD7E708D5u, 0xA0DBA224u, 0x20672513u, 0x2CA991BFu, 0x48332CE9u, \n0x338F6C0Fu, 0xB44B1AEFu, 0x0D771081u, 0x6D094BD9u, 0x36E7F40Eu, 0x1FC1D6E2u, \n0x84A9AA4Bu, 0x67A153E4u, 0xFF47BD10u, 0x7FC0078Bu, 0x4430FCF5u, 0xC2656DC7u, \n0x2C3766CBu, 0xA9D5DCFBu, 0x1696BA14u, 0xF4B3F026u, 0x7E877A96u, 0x92F9CC24u, \n0xB235C307u, 0x2BCD23FDu, 0x87E79689u, 0x976F73BFu, 0x7197A8E1u, 0x563A7DA0u, \n0x397C7973u, 0x81F7B799u, 0x436C2D8Fu, 0x6F593B6Bu, 0x5DD9D0B3u, 0x330609CBu, \n0xDB035D59u, 0x38896E91u, 0x0CC8DDC1u, 0xD57B4D02u, 0x7D5F981Fu, 0x393D472Du, \n0xF78955FFu, 0x9C162FA8u, 0x13BF707Au, 0x95E013CFu, 0x10E1E34Cu, 0xE88DF8FBu, \n0xEFDCD7AFu, 0x659D85CDu, 0xA191CB20u, 0x78C54817u, 0xAB027BF0u, 0x5F6AF4E5u, \n0xEF80AED7u, 0x9D981559u, 0x44D0225Fu, 0xAAEBD31Eu, 0x2ADCDFF9u, 0x86F2B4C7u, \n0x5BD90FA6u, 0x3ED6588Bu, 0x9C924A6Du, 0x8C476B88u, 0xAE17D5F7u, 0x6403E344u, \n0xBC6B591Bu, 0xD9EEDBCDu, 0x9C3BA599u, 0x1C0C0205u, 0x5D699DBDu, 0xF83F8A59u, \n0x52850887u, 0xBAB83165u, 0x9AC3E63Du, 0xF3D7AE49u, 0x9CCE676Bu, 0x60FA466Eu, \n0x7580A712u, 0x3BEBA956u, 0x4387AEDDu, 0x0BE2FA81u, 0x241FE7EDu, 0x6C24BEE5u, \n0xB95B13BEu, 0xF5336250u, 0x93987F4Cu, 0xED3BBF07u, 0xAD268341u, 0x7228E223u, \n0x4A194FA8u, 0xA6EC381Eu, 0xF39B1525u, 0x86614858u, 0x0F748029u, 0xC83E70B9u, \n0x6A460F22u, 0xBD7DE0F3u, 0xA09AF83Fu, 0x370E40DDu, 0x2BFA2CC6u, 0xB236D647u, \n0x48D04FDDu, 0x1B4D25A5u, 0x600B428Au, 0x40894792u, 0x2069F917u, 0x798F7B83u, \n0x6E35C056u, 0x1A88D1BFu, 0x1523320Bu, 0x628FFEDFu, 0xA3D40E4Bu, 0xD84C4A86u, \n0xC8D474A7u, 0x27525A89u, 0xE095D291u, 0xE051DC55u, 0x50BC7E81u, 0x573E3DA7u, \n0xF817303Au, 0x6BBA8CACu, 0x896A3EF8u, 0xFA714816u, 0x7FC6AA64u, 0x86E71C44u, \n0xAAEE5DFFu, 0xF66566C1u, 0x8E7815ABu, 0x15F5028Au, 0xDD78707Bu, 0x87EA893Cu, \n0xE6113661u, 0x30EB44CCu, 0x4428E35Bu, 0x9704D76Fu, 0x98210D0Cu, 0xD10B27A0u, \n0xB4DA6B03u, 0xE33A08BCu, 0x8E55429Fu, 0xC39CD944u, 0xC908AAB5u, 0x32359CBEu, \n0x9D807CC1u, 0x0DF77FA2u, 0x5A619024u, 0x177EFF64u, 0x7D473CE2u, 0xC2F4490Du, \n0x294F411Cu, 0xAE8CC5BEu, 0x9B6388A5u, 0xFE80C4A8u, 0x6DC8E1CBu, 0x24657629u, \n0x23AD1E1Fu, 0x15039B6Au, 0xA3DD2659u, 0xAECA8E5Fu, 0xB9627F39u, 0x5D43B5E5u, \n0x4E90AC1Du, 0x6C08A4BFu, 0x7D879CEDu, 0xCE53DD2Fu, 0xA0D06D84u, 0x08C57759u, \n0xE9F57DA5u, 0x4DC894C3u, 0xA4AB8612u, 0xA3703EF3u, 0x50E00142u, 0xD141EAE7u, \n0xC8384FA2u, 0x3C990231u, 0xF4EB05AFu, 0xEAA0BE71u, 0x470709E8u, 0x273156E7u, \n0x69869D19u, 0x6E138CCCu, 0xD1125173u, 0xAC243996u, 0x48EACBDFu, 0x1C3CB656u, \n0x0308DB2Cu, 0x3E8E1FFFu, 0xDE0B112Cu, 0xEFE01782u, 0x5A2017ABu, 0x58A9A189u, \n0xE4D0D2F0u, 0xFAF2E578u, 0x2A3CE133u, 0xF70D5963u, 0xBABC0ACEu, 0xB6508D4Fu, \n0x4FF5BF73u, 0x7CFE0345u, 0x7A895CB3u, 0x47713D58u, 0xD000E968u, 0xB45DBA63u, \n0xB9D95FCDu, 0x64FBDB20u, 0xF7C39FDAu, 0xDF3CFE42u, 0x38C5B20Eu, 0xF659CE67u, \n0x45BD1DA0u, 0x4A928534u, 0x40818B59u, 0x5F418D11u, 0xC0E67417u, 0xFC4FEC0Au, \n0x56E81F8Eu, 0x0B43BD9Fu, 0x7E9E01A7u, 0x2FFD4F57u, 0x3C422186u, 0x2349100Au, \n0x358865AEu, 0x4FCA13B0u, 0x616CC46Cu, 0x5C6FCE7Au, 0x879A6302u, 0xF48254E7u, \n0xD0413ABCu, 0x669878D4u, 0x98FED56Du, 0x82F4C6A2u, 0x708133C8u, 0xE128FBB7u, \n0x3EFF1CDAu, 0xC8F8F0C7u, 0x50403EB2u, 0x7D35F4B5u, 0x2960834Du, 0x5FA175C9u, \n0x2FF598B1u, 0x2045DAE3u, 0x4175871Cu, 0x98D85ACFu, 0x4F6396FDu, 0x46D4BAFDu, \n0x4DFDE005u, 0x583DE78Au, 0x1078E291u, 0x153E4DC7u, 0x85557147u, 0xEAFC1471u, \n0xB11C9A47u, 0x33B9B62Au, 0x43015C65u, 0x0A5EF642u, 0x0E61799Au, 0x1236DD25u, \n0x88ED1AB5u, 0xCC5B77EDu, 0x9E00F156u, 0x1F35BA13u, 0x2A614CFEu, 0x4F01D7F9u, \n0x8AB7D508u, 0x5174E484u, 0x1BEE1F39u, 0x9D53F9A8u, 0x58C656DBu, 0xD2C0B476u, \n0x541C69B0u, 0x6AF31FB2u, 0x5474143Du, 0x92CD1436u, 0x9B706984u, 0x42506463u, \n0x0704025Du, 0xE589617Cu, 0xDAA56175u, 0x217BC283u, 0xEC386001u, 0x9FEEFE5Cu, \n0x34606BA2u, 0xEBC8F7A1u, 0x06EE0F73u, 0x6F387A29u, 0x2316BAE0u, 0x25C1A196u, \n0xAD8EE2F5u, 0xD9334E6Cu, 0x1BA722FAu, 0x59ECB3BDu, 0x7A359B66u, 0xA17214F0u, \n0x056C1C11u, 0xD797BF2Cu, 0x5ECDD1C1u, 0x55231D4Eu, 0x9CFBFBF4u, 0xFDF7C6CDu, \n0xBB700584u, 0xF9CE3EE6u, 0xBF279E38u, 0xFCC48387u, 0xB8C93850u, 0xA9C6E06Cu, \n0xCD3988D9u, 0xD6651F67u, 0x77A0187Cu, 0xF2420D65u, 0xA1CE5C2Du, 0xB84F397Fu, \n0x0F5B2005u, 0xE3FCE838u, 0xA579047Du, 0xAF477448u, 0xED5B6F4Bu, 0x34A1135Bu, \n0x20683695u, 0x8342E789u, 0x37EF78B6u, 0x6FB166B6u, 0x9454E958u, 0xD1BF95D1u, \n0x08ADF8BDu, 0x7BC9B5CBu, 0x71031CE3u, 0x0D1A3FD8u, 0xA77255D5u, 0x0E2E7FA1u, \n0xC37D330Au, 0xBEBD0F98u, 0x481691BCu, 0x9B35DD73u, 0x1D997BEFu, 0xA1A0A541u, \n0xD9633977u, 0x6F321639u, 0x255C011Cu, 0x553C0F3Au, 0xF85B36AEu, 0x3691BD44u, \n0xB7ED19ADu, 0x721858BEu, 0xF6992058u, 0x97BF81E3u, 0x7B565427u, 0xC801D6FFu, \n0xD3AFC7A3u, 0x82E7761Eu, 0x88E36486u, 0xB80C9758u, 0x76F561B9u, 0x2A199987u, \n0x175D9764u, 0xBA339614u, 0x0DAC3EF9u, 0x128ABC1Fu, 0xF4000000u); // array len 689\n\nuint map_map_uint_4[] = uint[](\n0x52353422u, 0x57345335u, 0x44352338u, 0x25354436u, 0x44455562u, 0x35215736u, \n0x53767235u, 0x34435465u, 0x43254463u, 0x35233364u, 0x52453653u, 0x34063815u, \n0x1A066552u, 0x76024337u, 0x24359665u, 0x62635398u, 0x34353485u, 0x24404364u, \n0x44253183u, 0x23453765u, 0x62246363u, 0x36811146u, 0x24463361u, 0x33167123u, \n0x41300413u, 0x22132321u, 0x45483844u, 0x62314523u, 0x51413431u, 0x32445430u, \n0x22873413u, 0x20254113u, 0x05278281u, 0x43135272u, 0x52246A65u, 0x54455476u, \n0x14124074u, 0x95322155u, 0x39026769u, 0x54424364u, 0x12437336u, 0x13654495u, \n0x76454426u, 0x44052515u, 0x55815326u, 0x61343553u, 0x42344334u, 0x22634613u, \n0x22574341u, 0x34454564u, 0x444A3364u, 0x46632282u, 0x43633526u, 0x33274533u, \n0x2A483174u, 0x39645916u, 0x15046183u, 0x58623244u, 0x43495153u, 0x256D4844u, \n0x16467272u, 0x35422086u, 0x74743354u, 0x5366873Bu, 0x71233323u, 0x40252530u, \n0x12321142u, 0x42024024u, 0x43321431u, 0x02463501u, 0x11321325u, 0x12424023u, \n0x31543710u, 0x11646532u, 0x11322213u, 0x22234341u, 0x31432035u, 0x20312625u, \n0x34203211u, 0x31143502u, 0x74644157u, 0x35252524u, 0x84136613u, 0x53363135u, \n0x12354654u, 0x54542322u, 0x67072474u, 0x44324552u, 0x04134151u, 0x35423256u, \n0x35444563u, 0x82454776u, 0x07438183u, 0x77324364u, 0x24345177u, 0x36956458u, \n0x22002331u, 0x42584204u, 0x12312322u, 0x50044501u, 0x33521153u, 0x43253443u, \n0x31320334u, 0x31422111u, 0x26434563u, 0x23524B85u, 0x52424552u, 0x32445343u, \n0x23594963u, 0x83343053u, 0x12245615u, 0x65552433u, 0x25475643u, 0x55454827u, \n0x3A565334u, 0x34281325u, 0x53656525u, 0x95373265u, 0x66436349u, 0x28455464u, \n0x37436A73u, 0x45457673u, 0x23345449u, 0x36156135u, 0x36886350u, 0x35662356u, \n0x46555358u, 0x54822674u); // array len 128\n\nuint map_map_uint_5[] = uint[](\n0x22017352u, 0x22677573u, 0x56523464u, 0x36388436u, 0x24533325u, 0x05731443u, \n0x82553637u, 0x27663439u, 0x21652663u, 0x67665543u, 0x65462522u, 0x28627A52u, \n0xB2683452u, 0x47733346u, 0xA4552355u, 0x2A757253u, 0x41312115u, 0x32252322u, \n0x14434345u, 0x35141414u, 0x22124515u, 0x23243313u, 0x01572421u, 0x21213212u, \n0x50100402u, 0x00202100u, 0x00000000u, 0x00000000u, 0x20400301u, 0x00121200u, \n0x00000000u, 0x00000000u, 0x62253351u, 0x38627225u, 0x56656574u, 0x56A465A6u, \n0x23574A42u, 0x32663342u, 0x55725366u, 0x44245455u, 0x14523213u, 0x23543301u, \n0x21324405u, 0x53303320u, 0x22543223u, 0x33632111u, 0x41722524u, 0x33253421u, \n0x3344A552u, 0x23765563u, 0x75847758u, 0x65652855u, 0x65644665u, 0x31512344u, \n0x53944846u, 0x55634745u, 0x34442545u, 0x27379325u, 0x17332456u, 0x46332353u, \n0x80943444u, 0x36232318u, 0x53823435u, 0x54655778u, 0x30000003u, 0x00503200u, \n0x00000000u, 0x00000000u, 0x40000100u, 0x00213400u, 0x00000000u, 0x00000000u, \n0x10300102u, 0x00143100u, 0x00000000u, 0x00000000u, 0x30100303u, 0x00111100u, \n0x00000000u, 0x00000000u, 0x32313444u, 0x32254422u, 0x32351325u, 0x42232135u, \n0x31224118u, 0x34057412u, 0x41273155u, 0x32251352u, 0x24224744u, 0x43634768u, \n0x43546542u, 0x38646134u, 0x56366463u, 0x61374454u, 0x55634455u, 0x56411754u, \n0x10200302u, 0x00321100u, 0x00000000u, 0x00000000u, 0x30000104u, 0x00221000u, \n0x00000000u, 0x00000000u, 0x34645222u, 0x02444311u, 0x22203602u, 0x32553624u, \n0x53552313u, 0x42433133u, 0x22331011u, 0x13311421u, 0x31843424u, 0x04327435u, \n0x23975356u, 0x15735274u, 0x43361872u, 0x15954352u, 0x44946568u, 0x67236456u, \n0x53484574u, 0x25422354u, 0x3A343426u, 0x86137733u, 0x34463562u, 0x35438318u, \n0x5A755455u, 0x43338458u); // array len 128\n\n#define self_buf iChannel0\n#define map1 map_uint_4\n#define map2 map_uint_5\n\n#define mapmap1 map_map_uint_4\n#define mapmap2 map_map_uint_5\nconst ivec2 mapmap_reg = ivec2(0,34);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord);\n    \n    if(ipx==ivec2(32,32)){\n        fragColor = vec4(1.,map1.length(),map2.length(),0.);\n        return;\n    }\n    \n    if(ipx.x>=32||ipx.y>=32){\n        if(ipx.y!=mapmap_reg.y||((ipx.y==mapmap_reg.y)&&ipx.x>=mapmap1.length())){\n            fragColor = vec4(0.,0.,0.,0.);\n            return;\n        }\n    }\n    \n    bool reset = texelFetch(self_buf, ivec2(32,32),0).x<0.5;\n    vec4 self_col = texelFetch(self_buf, ipx,0);\n    \n    if(iFrame>0&&!reset) {\n        fragColor = self_col;\n        return;\n    }\n    \n    if((ipx.y==mapmap_reg.y)&&ipx.x<mapmap1.length()){\n        fragColor = vec4(0.);\n        fragColor.x = uintBitsToFloat(mapmap1[ipx.x]);\n        fragColor.y = uintBitsToFloat(mapmap2[ipx.x]);\n    }else{\n        int idx_x = ipx.x+ipx.y*int(32);\n        fragColor = vec4(0.);\n        if(idx_x<map1.length())\n            fragColor.x = uintBitsToFloat(map1[idx_x]);\n        if(idx_x<map2.length())\n            fragColor.y = uintBitsToFloat(map2[idx_x]);\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n// map of connections 7 and 8\n\nuint map_uint_6[] = uint[](\n0xD475C261u, 0xC19D2BC5u, 0xA802DBA9u, 0xEC2A25D7u, 0xE1311C8Fu, 0xC226300Au, \n0x1635B306u, 0x3358B6B9u, 0x293D0E22u, 0x5BC92A01u, 0xE7C93764u, 0x4D7F7DDDu, \n0x9A0DE098u, 0xF25833CFu, 0xC471AFDEu, 0x863FD04Fu, 0x3F7F33BCu, 0xB020EBE0u, \n0x7DDA0F97u, 0xA2257FACu, 0xF7BE94C4u, 0xAD045A5Du, 0x96664602u, 0xB825A590u, \n0xF583DCABu, 0x7A0504C7u, 0xC79BE1BAu, 0xE8A12229u, 0x4611CE41u, 0x9075E3A8u, \n0xDFE98400u, 0x943CE619u, 0x7511B008u, 0x525B6090u, 0xFFA70F9Eu, 0x5F4CC10Bu, \n0x17B7B236u, 0xA42762D4u, 0x633B0C5Bu, 0x0502F2DDu, 0xC1B3EF0Eu, 0x3F2EC5B6u, \n0x0BDBFA29u, 0x4F051413u, 0x1B32B10Fu, 0x7822E4A8u, 0x3D5DA29Cu, 0x4061F47Eu, \n0xA5BC912Fu, 0xDBB31C16u, 0x3EE6145Du, 0x534D6879u, 0x80B1B425u, 0x6298FD65u, \n0x7221FA7Bu, 0xB1839281u, 0x28118F42u, 0x96ADEF90u, 0xF2792CE0u, 0x022B0641u, \n0x520CF2AAu, 0xCFF0BD98u, 0xFF135967u, 0xF8CE6C75u, 0xA8A9CA8Eu, 0x099C0C80u, \n0xE2A4F514u, 0x8C9B56BDu, 0xE38AA763u, 0xB46D84C9u, 0x5D7210DAu, 0x0C99FDD0u, \n0x93B54CC5u, 0xFA691CE5u, 0xA1B7766Du, 0x648B34FBu, 0x2F863979u, 0x4EE356D2u, \n0x0F810727u, 0x73502250u, 0x19CA9079u, 0x96A9F28Cu, 0x0D39D4AFu, 0x38483CC6u, \n0x6E5A4BB3u, 0x45DDA392u, 0x69D5BE99u, 0xBDB63543u, 0xEEF1420Fu, 0x8E4797B7u, \n0x4350DB04u, 0x77F498D8u, 0x427BC585u, 0xF5E5F21Au, 0x1EE05B54u, 0x13025A94u, \n0x626436C4u, 0xA008AECDu, 0xC075973Eu, 0x11CAAA95u, 0x70B11EC8u, 0x5BA12831u, \n0x20EF290Bu, 0xAEDDE0C5u, 0x0BF08460u, 0xE654E325u, 0x3140D7D3u, 0xE7B6B2D1u, \n0x54B1B565u, 0xEB21F2AEu, 0xBFBB0107u, 0xCDE3325Bu, 0x9935A80Cu, 0x5E2F6A66u, \n0x1E7F51EAu, 0x06942FA5u, 0x2C5E26E4u, 0x8E465860u, 0x51C99BD3u, 0x869B679Au, \n0xD98D166Cu, 0x40AD2687u, 0x3EF87174u, 0x3BDCFC0Fu, 0x5CDBF4EFu, 0xEE456533u, \n0x1A24A264u, 0xD1BCE5C5u, 0x427B88B6u, 0x77746864u, 0xB112ED19u, 0x70A0F97Eu, \n0xFE5FE758u, 0x6570F9EAu, 0x1736DDEBu, 0xCB56A90Cu, 0xF886C96Cu, 0x0EEEEA30u, \n0x831D1E6Bu, 0xDBFF9C07u, 0x5E6D6073u, 0x0CB7F026u, 0xA37ED01Cu, 0xAEE75162u, \n0x53812912u, 0xAC06331Cu, 0xB8B62F7Eu, 0x940A3CFAu, 0x2A58CCF6u, 0x470D9BF2u, \n0x1547F7A5u, 0x282FF78Fu, 0xC239CDC6u, 0x05FD67EFu, 0xB03D6C8Cu, 0xD5B20F02u, \n0x8C1A6372u, 0xC4EB28ADu, 0x4A6D3A94u, 0x6FAB7FC3u, 0xCDC165AAu, 0x41FFC1CEu, \n0xA7C93ECFu, 0x365159E4u, 0xBF336B2Au, 0x7FCB14B3u, 0xB33A4215u, 0xEBB20689u, \n0x866E7160u, 0xC3B0DAD9u, 0x253090ADu, 0xE2A4AC39u, 0x71934DFAu, 0xCA81C396u, \n0x06EDA499u, 0x57B9B047u, 0x590A7712u, 0xB030BE23u, 0x0BCC0C05u, 0x5A31FCD7u, \n0xDF54F796u, 0x23003AF8u, 0x91592694u, 0x269B41B2u, 0xBF45F11Eu, 0x0F08FEB5u, \n0x9DC1BA3Fu, 0x5CC424A3u, 0x70C64259u, 0x76462AC3u, 0x706EFED5u, 0xBD991E9Eu, \n0xA623F6C4u, 0xB56E9304u, 0xBE5456A9u, 0xCC17D138u, 0x631B2544u, 0x009C783Du, \n0xFCE00A44u, 0xF00894F7u, 0x4471BC3Eu, 0xF2AB4811u, 0x39A3F030u, 0xFDBE963Eu, \n0xC13D4C0Du, 0x178B6972u, 0x573A3416u, 0xA596F5CBu, 0x74CDE7DFu, 0x6B36B23Bu, \n0x14CDC3F2u, 0x8E6B59EFu, 0x5DBC5085u, 0x0249758Eu, 0xBF983A68u, 0xF62FE464u, \n0x2718079Cu, 0xB9AB3ED3u, 0x84D7B392u, 0xDF2A9C30u, 0x6EADDAFEu, 0x55E554F6u, \n0x824F7EF2u, 0xDBEE217Cu, 0x2D662F6Bu, 0x3524A4B7u, 0x5EB661C5u, 0x02221030u, \n0xB2BAD33Bu, 0x4152DE09u, 0x634871AAu, 0x61F0C7E4u, 0x04CEA442u, 0xD201ED1Fu, \n0xD38D610Bu, 0x14010F9Au, 0xEAE135C6u, 0xBB66559Bu, 0x3591BCCEu, 0xD239D46Cu, \n0x38DC3485u, 0x0B51ACFEu, 0xF48AEC5Fu, 0x7EDF737Au, 0x0BC7FC07u, 0x5028223Du, \n0xC98749B3u, 0xC518923Bu, 0xFE354ECCu, 0x91F162E6u, 0x6B5384DEu, 0xB208BF68u, \n0x8051A1F8u, 0x17E87FB9u, 0x28E52FD7u, 0xEF4B5DBBu, 0x4F4EF048u, 0xEB57300Du, \n0x68DA0FBEu, 0x6A76C0B8u, 0xC0EB6397u, 0x93967D0Fu, 0x3FDD4C46u, 0xFDD2BF3Fu, \n0x32BA579Fu, 0x12264A7Du, 0xCC99B46Bu, 0x20F7630Cu, 0xC9E2D41Bu, 0xD4730A26u, \n0x6047D709u, 0x136B1F15u, 0xD3FC0153u, 0x277F3DF3u, 0xC704326Au, 0xCD7E09A0u, \n0xBBB936EDu, 0x6310768Cu, 0x96B6962Du, 0x92D6C288u, 0xC5F127B7u, 0x68F33708u, \n0xD219948Du, 0x979824C0u, 0x6DE3D0AAu, 0x8D79B75Au, 0xBA2074B4u, 0x079E6C8Cu, \n0xE2B130A1u, 0x49C477A6u, 0x2452314Fu, 0xDC49CD17u, 0x16930E31u, 0x9A399D9Fu, \n0xA648514Cu, 0xDDC20C2Cu, 0x105EBC96u, 0x9F60FBBFu, 0x4250D06Bu, 0x5C8F4984u, \n0x204D5853u, 0xA03D06A3u, 0x842ABC3Du, 0x9C9A9AD9u, 0x0CB79CB9u, 0xB0E8BEBBu, \n0x2EEF124Eu, 0x18C7394Fu, 0x87D026EDu, 0x3DF76C48u, 0x05B3AD81u, 0x0281DAD7u, \n0x575DEA86u, 0xF83BB736u, 0x5C2636BDu, 0x4100AE80u, 0xFF013805u, 0xA26DD94Fu, \n0x8932DAFAu, 0x40F4FCCDu, 0xDB43C71Du, 0xAD33B1ACu, 0x282436C9u, 0x2470CBF4u, \n0xC6D461CAu, 0xF351DCF6u, 0xA9CB888Eu, 0x9416275Cu, 0xCDDA5A56u, 0x498DC856u, \n0x282E58DAu, 0x026C01AAu, 0xA3E07C92u, 0x66AE0BFCu, 0x58BE36EAu, 0x25A40132u, \n0xB98B3F3Cu, 0x57EF224Fu, 0xC9C13E74u, 0xB65B86DEu, 0x5BA28912u, 0x976F124Au, \n0x98D1589Bu, 0x6EB11E64u, 0x3DF07E7Eu, 0x00B836F1u, 0x6A0E03A7u, 0x8C34C6F4u, \n0xE40ABA2Bu, 0xE95F5EF2u, 0x55739BDDu, 0xF5036146u, 0x9FF35402u, 0x969D4461u, \n0xC2A9BC3Fu, 0xF8D581A9u, 0xB03854BBu, 0xDC6A8811u, 0x304771A3u, 0x8608BECEu, \n0x7A5A65F6u, 0x42FDFDC8u, 0xC9ED8FBFu, 0x992501F1u, 0xECDC719Eu, 0x47B510A6u, \n0x5638D3A8u, 0xD3161CC0u, 0xE101B3F5u, 0x539E1CAAu, 0x7A7D6F88u, 0x5B4A04D1u, \n0xBBEFA29Fu, 0x76FC23F3u, 0x54E10845u, 0x183AD9A0u, 0x975C6560u, 0x96386B6Eu, \n0x76EA0D71u, 0x120FF281u, 0x5D08C6FDu, 0x0B34E398u, 0xD0508262u, 0xD98C09F1u, \n0xCBB2BAEFu, 0xD61BA519u, 0x3FF04DBEu, 0x2397D50Cu, 0x310D80BDu, 0x7D0A5F43u, \n0x9E67287Bu, 0x0911CF93u, 0x1D668ABDu, 0xC6D4F7ECu, 0xE7A64836u, 0xABC5E3D1u, \n0x61E05D5Eu, 0x6F6664DBu, 0x7C346DABu, 0xCB39DA69u, 0xD9160510u, 0x0198724Cu, \n0x91721500u, 0x01D25FB2u, 0x0C00F853u, 0xFC10115Du, 0x9A74E52Au, 0xA9C913ABu, \n0x92356464u, 0x5B597386u, 0xB8E36509u, 0x3F79F67Du, 0x00696DD9u, 0x4D518C12u, \n0x62000ABBu, 0xEA734F00u, 0x1128BC77u, 0xAE83AA25u, 0x1C8F22E7u, 0xB713696Bu, \n0xB3B91ECDu, 0x3A997C41u, 0x1E9791B7u, 0x7140FD8Au, 0xE1CE0A1Cu, 0x2A9AFE67u, \n0xA691A2A9u, 0x863A1832u, 0xCA46DD16u, 0x32B2B393u, 0xE50B8D46u, 0xC133A283u, \n0xEF9E4A83u, 0xE3D3E838u, 0x5C52283Eu, 0xE2C8C553u, 0x5ACCC294u, 0x2E14B3E4u, \n0xA7922C4Cu, 0xD6F94CC6u, 0xFFB7CDE9u, 0x2F2FA1A7u, 0x235072B9u, 0x83FDF7F7u, \n0x006F1F4Bu, 0x102BC770u, 0x289E43C7u, 0x2043EC68u, 0xB074F36Eu, 0xD6DB9BC3u, \n0x240AE49Eu, 0x709B6E5Eu, 0x4861C526u, 0x5B9C1F98u, 0xDDA57C01u, 0x5725BD90u, \n0xCBA6698Cu, 0x102E5496u, 0x470C368Du, 0x0DBE4231u, 0x4AF93E46u, 0x07EC2563u, \n0x235DB6DFu, 0xA205425Fu, 0xC1C48617u, 0x494A79F7u, 0xAD270E92u, 0xB776D2A4u, \n0x4AE975C9u, 0x48685DB2u, 0x9053C0E7u, 0xC178EED9u, 0x1B21F55Eu, 0x08E77902u, \n0x366A34FCu, 0x881A86A8u, 0xA580004Eu, 0xCC9EFE8Fu, 0x033DFA63u, 0xE118BD80u, \n0xFCFF81F1u, 0x5F8EC99Eu, 0xA81F0FB4u, 0x62D823A5u, 0xDE64AC35u, 0x642812F4u, \n0x45A5E35Eu, 0xDFB88518u, 0x83EDBAF3u, 0xDF0E299Cu, 0x2AB12592u, 0x83B5BB6Eu, \n0x8789B876u, 0x7B812D8Eu, 0x8AC49DC0u, 0x8EE23E95u, 0xEA67001Eu, 0x0EFFE2A1u, \n0xD16B0BECu, 0x9F99366Cu, 0xB920DEA3u, 0xFDE10805u, 0x4250E8BBu, 0x7F459CE1u, \n0x1938CC90u, 0x3C634BDDu, 0xDC8E68A8u, 0x15B983C5u, 0xBB409941u, 0xEE37B322u, \n0x6C6960B1u, 0x34630276u, 0x17DF20ABu, 0x39371165u, 0x41337A49u, 0xEC8FD776u, \n0x82ED191Cu, 0xC46C03B6u, 0x6E255A58u, 0x9A46AA7Du, 0x0943F364u, 0x63CDC11Eu, \n0x16A65753u, 0xD29ACBE4u, 0x2A6ABC7Fu, 0x01C8F75Au, 0x26E4FAD7u, 0x92D831C4u, \n0x47178C10u, 0x38E8D11Du, 0xBBAC2E76u, 0x4784910Au, 0xBE885C38u, 0x98BAD3F0u, \n0x75A932A8u, 0x29F07B76u, 0xABFDA37Eu, 0x9244BD68u, 0x082C74B6u, 0xD607CB41u, \n0x11F40044u, 0xE3229736u, 0x67572DAEu, 0xB4A45815u, 0x1C68B1F9u, 0xD3D7692Du, \n0x41BCB4E4u, 0x807CABD6u, 0x95B434ADu, 0xF279788Du, 0x231F43B1u, 0xD3009D68u, \n0xF3C73256u, 0x21E3F73Fu, 0xF8294DE5u, 0x02ED07CAu, 0x199C6423u, 0x3F8762C3u, \n0x6BF2B129u, 0x9AC6848Cu, 0xF36A18DDu, 0xB499A3D3u, 0x46705C29u, 0x6BF41C6Au, \n0xD8EE8DD6u, 0xD315717Cu, 0x7A11C967u, 0x90A15421u, 0xB074AEB6u, 0x5F0222B7u, \n0xCE6F7888u, 0x5302ACF5u, 0x7F1F0B78u, 0xA7EA8E32u, 0x1171F809u, 0xCA5286A2u, \n0x998E6562u, 0x5C860B31u, 0xD56DC463u, 0x3CBBC397u, 0x7E8B9094u, 0x9293A774u, \n0x79970574u, 0x12A19070u, 0x71D499D8u, 0x7FC389D7u, 0xC219B139u, 0x378CC06Fu, \n0x78CA79E9u, 0x4A09DE54u, 0xA0447F1Cu, 0xD5114AEBu, 0x49A8A512u, 0x6B68845Bu, \n0x92AD5EE7u, 0x4E72DEB6u, 0xD0627B07u, 0xD321E5B7u, 0x49987BA3u, 0x7DE6224Cu, \n0xBA58D8B2u, 0x22A4B06Du, 0x4062E28Du, 0x4C36AA3Eu, 0x4B6C814Bu, 0x797E17BAu, \n0x49A52133u, 0x4477D0A0u, 0x65C9B727u, 0x7F74E2BEu, 0x95A5B4F6u, 0x16CAB525u, \n0x90AC5D0Du, 0xA21F527Bu, 0xB4CC783Cu, 0x7968798Au, 0x3B024530u, 0x4CF3DE80u, \n0xF639C274u, 0xBED895C1u, 0xFEAB84BAu, 0xF867F055u, 0x5BC8B65Bu, 0xCB384FA9u, \n0x798B0E17u, 0xAC186471u, 0x52712CD3u, 0x17514F2Bu, 0x6312454Cu, 0xE13B3251u, \n0x0AB17165u, 0xD440EB16u, 0x1BDEC0E2u, 0x8FC01EFFu, 0xF344826Du, 0x4C198787u, \n0x864BF918u, 0xF8706A09u, 0x5026DCE0u, 0x1DC2D9FFu, 0x27695205u, 0x7444310Bu, \n0x540D16D7u, 0x6B614379u, 0x5876FFFEu, 0x6C93ED47u, 0x1B336685u, 0x01B977C6u, \n0x20EF326Au, 0x61BA23EFu, 0xF9F1FF92u, 0x2189539Du, 0x47F87FE6u, 0x0A68091Fu, \n0xCFFECFCBu, 0x99F5939Du, 0x19430CD7u, 0x16FEEBCBu, 0x32D0CA14u, 0xE4B83305u, \n0x73AF1D79u, 0x136C2E12u, 0x8DAAC0D1u, 0xC32D9939u, 0x23F7EE87u, 0xE54FF801u, \n0x3C4CC5F4u, 0x16D385ECu, 0x9F5D7970u, 0x3D2BA028u, 0x473B486Eu, 0xA94BE6E7u, \n0xF8A58863u, 0x6BB5D7A3u, 0xE876517Du, 0x979E679Fu, 0x7A247241u, 0xAE172CD0u, \n0x3D86F596u, 0x62F7FC2Bu, 0x80000000u); // array len 681\n\nuint map_uint_7[] = uint[](\n0xBD5550AEu, 0x96E2A04Fu, 0xA9992BDCu, 0x8555B0C1u, 0x44F5FD74u, 0x7C041F17u, \n0x2BFB2B51u, 0xE3151EE8u, 0x259A761Cu, 0xE94F7F55u, 0x9D31A123u, 0xE07C17BFu, \n0x6A0ADE33u, 0x1160F1A9u, 0xF489F52Cu, 0xE654FAC8u, 0x1151E71Du, 0x46F8AACFu, \n0x9121A489u, 0xC22BCB82u, 0xD5E23FB5u, 0xC0760506u, 0x61D900C5u, 0xB790F421u, \n0x9A694944u, 0x0E10C692u, 0xE346B83Du, 0xC21DF4FBu, 0x56875E14u, 0xDEA2D947u, \n0x6D0CE4DCu, 0x7952B1BEu, 0xAB1B2040u, 0x6844CB99u, 0xDE574F27u, 0xFA71C32Bu, \n0xE746A080u, 0xB76CA7FCu, 0xB31AC792u, 0x7011C650u, 0x99CAD00Au, 0x31DE54C1u, \n0x08B40311u, 0x9E6A6452u, 0x6ED07BB4u, 0x212702DFu, 0xD46479A9u, 0xFD66D507u, \n0x50FBD3BCu, 0xD1001429u, 0xE4A04FE5u, 0x03B2B1C1u, 0x34F7C6E5u, 0x32E0B94Cu, \n0xB66326F4u, 0xA1AA913Au, 0x5305B77Eu, 0xF5EA7687u, 0x2FCE66EEu, 0xDB4E3FC8u, \n0xED8FCF00u, 0x38E0CEC1u, 0x48C67970u, 0x7ACCC3CDu, 0xA71FA7BAu, 0x4CC0D668u, \n0xAE2A2700u, 0xEF204B9Bu, 0xC3E3AC0Eu, 0x9A82C899u, 0x4AD829ABu, 0x7A9E7E05u, \n0x4E910A31u, 0x85D71D97u, 0xBC5492C2u, 0xA0F078A8u, 0x7A01158Eu, 0x979F54A8u, \n0x18A692B1u, 0x4B9D514Eu, 0x0C78D5A3u, 0xAEDA0366u, 0x7656A459u, 0x4A217CA6u, \n0x0316D454u, 0xA0662162u, 0x938DB18Cu, 0x93D25490u, 0x1FAD612Cu, 0xB9175B1Eu, \n0xBB551672u, 0xF9D56C03u, 0xD75EC0BFu, 0x4B9E71F5u, 0x538969B9u, 0x0DF0FBC6u, \n0xBCB8B498u, 0xF3D55573u, 0xE09DC7CCu, 0x08AF2027u, 0x80800947u, 0x2AE01186u, \n0x21AD897Bu, 0x9696331Au, 0x6EDBA305u, 0x9CEBF33Eu, 0x0424C5C6u, 0x9ADF6428u, \n0xEEC24E1Cu, 0xF4DEC6F1u, 0x38B87FC6u, 0xDC0F492Au, 0x9A03932Fu, 0xCFF3A88Eu, \n0xC2E93316u, 0xE6092EB1u, 0x26C886C8u, 0xFA595C48u, 0xE99D0F88u, 0xD41EDA3Eu, \n0x9E670589u, 0xE5B5BF63u, 0x0C607A9Eu, 0x72B83F5Eu, 0x08317A3Eu, 0xF1BF76BCu, \n0xF2ECA041u, 0x365D3136u, 0x5BD79299u, 0x2A23539Au, 0x654007A8u, 0x0725B224u, \n0x11CDC184u, 0xA2F9FD83u, 0x936AE3E3u, 0x69339177u, 0x057D1E03u, 0xF5D1E4B0u, \n0x0F3C22EEu, 0x2962F2E6u, 0xF2511945u, 0x31133BB2u, 0xD8896C91u, 0x1FCA15CDu, \n0xB318E9CAu, 0xBFDE7622u, 0xE6BD6AF3u, 0xE1B4C5F5u, 0x85CCD702u, 0x5F751A30u, \n0x6B790714u, 0x3276DAD2u, 0x8413EB60u, 0x55D5A712u, 0x1E3596A2u, 0x5B22B93Cu, \n0x22542911u, 0xDE9E6B7Au, 0x96DC4CEFu, 0x410D9BD3u, 0x7F65DD44u, 0x6FCB1693u, \n0x6ECD8B42u, 0xD0240A57u, 0x08727808u, 0x87545918u, 0x994C914Au, 0x675D585Eu, \n0xB1A39D50u, 0x59F7F210u, 0x692C65BFu, 0xC2C408D2u, 0x68D2622Eu, 0xBDB09A65u, \n0x769A4587u, 0xB8AB818Au, 0x7289207Bu, 0x4241EBC2u, 0x0F801178u, 0x78D31C52u, \n0xE4CCEF34u, 0xE9346491u, 0xEE95C686u, 0x19E12D1Fu, 0xE0DA162Du, 0x9CC64C47u, \n0x357B5DB4u, 0x67797255u, 0x21AA811Eu, 0x0F0DD42Du, 0xBA83D8A0u, 0x286B2E17u, \n0x99D0540Bu, 0xF6DEA34Bu, 0xD1DC9AA2u, 0x5359448Cu, 0xB2C70CC9u, 0xDE599C19u, \n0x8D8EB989u, 0x1DF026CAu, 0xE0A41F53u, 0xA91DD993u, 0x0942340Au, 0xF0899471u, \n0xA21F9EBEu, 0x7E56ADB3u, 0xFE48D995u, 0x58BE2A70u, 0xB4F40EDCu, 0x172D2168u, \n0x9AAAC3F1u, 0x813A45AFu, 0x27205C23u, 0x97579108u, 0x3FF65AB1u, 0x852C51AAu, \n0x730FD958u, 0xFB373F21u, 0x4FC97570u, 0x55F53652u, 0xB961DD04u, 0x2C5E9EEBu, \n0x668BB123u, 0x1D7DE1FBu, 0x067278ADu, 0x5636D550u, 0x96CA9E8Du, 0x1B57C20Du, \n0x2410BC79u, 0x907FE3C3u, 0x121CCE8Du, 0x5E9DA933u, 0xCA997FE0u, 0xC2ED6893u, \n0x12B756A7u, 0x1F798A62u, 0x385B79ACu, 0xFA0161B6u, 0x02687435u, 0x64615E51u, \n0x1CF08F81u, 0xEC15334Cu, 0xF3DE18AFu, 0x3526BF9Fu, 0x0A403030u, 0xB822A444u, \n0x9D35B62Eu, 0x27239866u, 0x6BD5BB51u, 0x6216D84Du, 0x711D4437u, 0xB595498Fu, \n0x004B01EBu, 0x6BA61931u, 0x29E02502u, 0x07E766F4u, 0xF2257106u, 0x0E99D11Du, \n0x6ED58DA9u, 0x2970175Bu, 0x205A2635u, 0x1AB85884u, 0x28426778u, 0x49B192D8u, \n0x96E0AB40u, 0x76A28A92u, 0xF14E8522u, 0x503AC907u, 0x6C66B376u, 0xA286332Fu, \n0xD166D38Du, 0x57757411u, 0xC4F47BF9u, 0x1DEB1A1Bu, 0x604E585Bu, 0x56E3CBA7u, \n0xBC305F73u, 0xE7BC8987u, 0xBF60CF51u, 0xFE4F8ECDu, 0xBC63E12Eu, 0x0CA7EDD4u, \n0xF999065Au, 0x0B659C07u, 0xCD453EF7u, 0x45ECEFD1u, 0x7F1B478Cu, 0x776648BFu, \n0x6E6B495Du, 0xEFD3B8A9u, 0x37214680u, 0x95314F2Cu, 0x5D211635u, 0x6A8C3F70u, \n0xD4094350u, 0x1B6E3C0Fu, 0xD7470844u, 0xD7FCC489u, 0x0E158642u, 0x1999D833u, \n0x683EC586u, 0x329BBC57u, 0x76ADFA5Eu, 0xFFBDB93Cu, 0x50A58784u, 0x1C1752FCu, \n0x96866F32u, 0x4DDC588Cu, 0x2A1DEC3Du, 0x3640FA52u, 0xEEBB6D50u, 0x101E154Bu, \n0x4353F7DEu, 0x6F2157EBu, 0xD39AB953u, 0x7D9F6237u, 0x2BA24357u, 0x87A05569u, \n0xB23643C4u, 0x4E3F3614u, 0x3FE25E1Cu, 0xECC908CEu, 0xD798BF7Au, 0xC8B40FBEu, \n0xF6AC5CD3u, 0x14EF1A54u, 0x86DFB019u, 0xA79EF86Fu, 0xE7BB4822u, 0xBCF37C89u, \n0xF0E0A658u, 0x31C8B631u, 0x136CEE5Au, 0x25636ED7u, 0x460A876Cu, 0xF3F56E5Bu, \n0x2C8E76BBu, 0x4A421B59u, 0x45B3B42Au, 0x8C000ECCu, 0x6D18DF81u, 0x7264296Cu, \n0x0D5CB042u, 0x96DCD0C8u, 0xA2DA1742u, 0x180CB883u, 0xA72686E2u, 0x39D04F69u, \n0xB3DD5237u, 0x1598ED59u, 0xC269DB98u, 0xC3C9F8BBu, 0xF485D316u, 0x17EA01BFu, \n0xFB7D6621u, 0x68FECF15u, 0xD7B78FCFu, 0x509FC3F4u, 0xDDA5A549u, 0x302A1621u, \n0x0D9717D3u, 0x5D7D8EA3u, 0x2D8B3A27u, 0x4A2324FAu, 0x0AD1345Au, 0x21DF125Bu, \n0x0B809D93u, 0x376AF1CCu, 0x83CE055Cu, 0x525B72F7u, 0x2DED46ADu, 0xB83CE95Cu, \n0x0F793F02u, 0x5C614026u, 0xCB6E185Fu, 0x18EAC0C3u, 0x24745F48u, 0xBA2E2970u, \n0x612084A0u, 0x4494812Fu, 0xDFA77C21u, 0xF570B1F3u, 0x987E508Eu, 0x8E03AE74u, \n0xBB2C17A2u, 0x38F6A8D2u, 0x709EA7D0u, 0xC93D0EBFu, 0xDFEF047Du, 0x7FF7E661u, \n0xF718A489u, 0x4F50F1C4u, 0x8224CD69u, 0xC6ACCC5Cu, 0x46DF7577u, 0xDE550FDCu, \n0xC97B69A8u, 0xC374E5D9u, 0xA991465Au, 0xA21D85D2u, 0x4CDA872Fu, 0xDAD1B43Du, \n0x63826FAFu, 0x1D1D17CCu, 0x200E6721u, 0xE128D47Du, 0x3E80F675u, 0xC182097Au, \n0xA23C1E9Bu, 0x8624AA89u, 0xB74A850Eu, 0xF937A477u, 0x410350C5u, 0xC17114DAu, \n0x17E995DAu, 0x3D8C4F7Eu, 0xBDCC0664u, 0x4EC18EEBu, 0x465331DCu, 0x45FFAE4Bu, \n0x9CC530B0u, 0xA24B5162u, 0xDF622A5Au, 0x282D7C75u, 0xBC6F20EBu, 0xF8FCE09Fu, \n0x8A49DE58u, 0x39BD542Bu, 0xFE06E0ABu, 0xF37FE5CDu, 0xC62482DAu, 0x0CBC915Bu, \n0xB9F5C4BAu, 0xA76DA88Bu, 0x39798081u, 0x6DCA596Du, 0xD4F88144u, 0x8F8A3F48u, \n0x8722D448u, 0x860B104Au, 0xE47642F6u, 0x8692A1A8u, 0x88839287u, 0x32DF7C85u, \n0x0DD6D29Bu, 0xB274F490u, 0xD91748A8u, 0x730F93F8u, 0x1ECAE52Eu, 0xB7740134u, \n0xC6DF997Eu, 0xA1C58D31u, 0x5A35C39Du, 0x8ADFB63Au, 0x0E8168F4u, 0x5915A6B4u, \n0xB8667DC5u, 0x54F87E6Eu, 0x536E2AA8u, 0xE8F79738u, 0x5C9FB406u, 0xF67A9508u, \n0x00AAE087u, 0x2651E30Du, 0xEB5C18DDu, 0xEDB98217u, 0x95D5581Eu, 0xB20224B8u, \n0x4C6E4085u, 0x7163915Au, 0xA7BF12F9u, 0x5BB1B689u, 0x38526603u, 0xF33D183Eu, \n0x9C7BD401u, 0x5FE9D6EAu, 0xDBF19504u, 0x7665E388u, 0xE808C179u, 0x2354D712u, \n0x23633526u, 0xD3AB6144u, 0x5F533881u, 0x4850CEEAu, 0xE2D276E2u, 0xCC43F454u, \n0xFE8AD2E1u, 0x47CD473Cu, 0x50EB2A7Eu, 0x0BEF4F98u, 0x67C313E3u, 0x0A974CE2u, \n0x5C277871u, 0x7EED1AE6u, 0xD0593074u, 0x99D91A4Du, 0x7B45F928u, 0xFD88F096u, \n0x985750FBu, 0x497E07F0u, 0xAFA0519Du, 0xE9F25714u, 0x326755FFu, 0xDEA77703u, \n0xB412094Au, 0xCADB9618u, 0x3A896086u, 0xBB43AFB2u, 0xA5132E36u, 0xCD9E3456u, \n0x328A7D6Cu, 0xAFDDD1BAu, 0xE85B248Bu, 0x6EFB27F5u, 0x5C47A025u, 0x304CB291u, \n0x74B22EA3u, 0xD9AF5422u, 0x13DDD417u, 0xFD58A33Bu, 0xFA845821u, 0x676FEABDu, \n0x16D8F22Cu, 0x10DA2317u, 0xC9521FBEu, 0xA54AE558u, 0x8C5334F6u, 0x131E4ACBu, \n0x1B21F63Bu, 0x61BC60FAu, 0x6E5E7479u, 0x19997BC3u, 0xFBA213C5u, 0x7B223920u, \n0x79E82112u, 0x2E7E3ABDu, 0x9FF107D9u, 0x94EDE9CAu, 0x5AD98CA9u, 0x34E47103u, \n0x4DD58C99u, 0x8F248A5Cu, 0x09D31114u, 0x4BD1EFE0u, 0x5E15C885u, 0xF4E780CCu, \n0xCDC44ECFu, 0x366CA34Du, 0x5A199E34u, 0x84753DA2u, 0x60669DC2u, 0x4C3251B6u, \n0xB82543A8u, 0x143703D2u, 0x2930E0E6u, 0x2247CB03u, 0xEE33CEC1u, 0x11ED08A4u, \n0x1C2A8AD3u, 0x9C95E2E3u, 0x4CB98BA2u, 0x2A5CD17Au, 0xB5D71561u, 0x6CA1883Eu, \n0x38D25576u, 0xAD1CB3D8u, 0x445CFFBCu, 0xAACAC15Fu, 0xBBF8223Fu, 0x0C6295C8u, \n0x45E6B75Eu, 0x2764CA62u, 0x9A6E0537u, 0xF7FA085Au, 0x77E5D434u, 0x398B3487u, \n0x0759BED0u, 0x6D17E475u, 0xE7E7022Cu, 0x1F9BB318u, 0x49C0566Du, 0x3B806B83u, \n0xAC2E9FDEu, 0xFFAD5A07u, 0xFD49C80Du, 0x4DA52DADu, 0x214C2474u, 0xCD9B96A8u, \n0xB14B3ABAu, 0x904DE4A2u, 0x050AE53Eu, 0xCBC67287u, 0xB74E6767u, 0xCAD4819Fu, \n0xD0865631u, 0x30E3E206u, 0x708F5070u, 0x9FE18904u, 0x3927FACCu, 0x022A5236u, \n0xBEF874E7u, 0x2CB15497u, 0xB697A219u, 0x7DA3266Du, 0x6E36F106u, 0x314FFFF4u, \n0xD2653A6Au, 0x0E82AC25u, 0x0CF2A83Fu, 0xDB3D4A19u, 0x70D63470u, 0x75390D0Cu, \n0x247550B5u, 0xAC23077Au, 0xB385F594u, 0xE1D1171Bu, 0x5919B976u, 0xC5DDFBCBu, \n0x523512C0u, 0xDD9DDA36u, 0x3C6A858Au, 0x2973658Eu, 0xBCC1AA7Bu, 0x8B67A017u, \n0x26EC9BCDu, 0xC8147B8Eu, 0x3FDD50B3u, 0xB877A82Fu, 0xA0EAF557u, 0xEE49C470u, \n0x609F9DD0u, 0x4BCAFDB0u, 0x74F22A50u, 0xB4C39CBAu, 0x0ACE8674u, 0xEC2DEA7Du, \n0x5E076B11u, 0xDC584EBFu, 0x3B2B0B22u, 0x9695F5A3u, 0xDAFC4EE0u, 0x91C7A400u, \n0x51AC6D18u, 0xC5B4983Fu, 0x7A81F1E8u, 0xF209BFE6u, 0xB6EC8BE6u, 0x08F64C06u, \n0x5B623D1Bu, 0x6B83B32Cu, 0x6ED2EDE0u, 0x9A376394u, 0x20D0A558u, 0x10BBA8F0u, \n0x0F53279Du, 0x84A79C8Au, 0xB5BEB137u, 0x49FD6FFCu, 0x2BF743E3u, 0xF4240D71u, \n0x4D910DB1u, 0xFE4FA1E3u, 0x3F87BBC2u, 0xDB83AE1Bu, 0x9A9DB22Bu, 0x03A631B0u, \n0x3C6E0FD2u, 0x5B711C95u, 0xFBA67974u, 0xF3DEABD9u, 0x7DC0CB80u, 0x2388CE75u, \n0x0460EEA5u, 0xBCBEDC30u, 0x82FADB0Fu, 0x953C1BD4u, 0x84A84C0Fu, 0xA8AB9F1Cu, \n0xC8C12D25u, 0x586C3349u, 0xCEBBC183u, 0xEE330BDCu, 0xB4CBE8EFu, 0x61B72878u, \n0x8B6833DCu, 0xC5CE42A9u, 0x8C454A64u, 0x99638AC4u); // array len 688\n\nuint map_map_uint_6[] = uint[](\n0x35235255u, 0x45444427u, 0x41645545u, 0x66394752u, 0x53456232u, 0x43127610u, \n0x55255816u, 0x73375253u, 0x43634775u, 0x44884570u, 0x61794467u, 0x33663252u, \n0x234459C5u, 0x433B5635u, 0x64340346u, 0x42413240u, 0x31493222u, 0x12246312u, \n0x61237121u, 0x41113004u, 0x42418401u, 0x42273502u, 0x23263332u, 0x01013642u, \n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x5356795Au, 0x44566999u, 0x48313452u, 0x24554441u, \n0x84A35858u, 0x68749A46u, 0x76417244u, 0x22725454u, 0x43136252u, 0x35024421u, \n0x22034325u, 0x32171522u, 0x32440314u, 0x42464120u, 0x62133022u, 0x20015314u, \n0x34455577u, 0x34336337u, 0x57361524u, 0x31545244u, 0x14553254u, 0x26636553u, \n0x73294377u, 0x96562753u, 0x92953646u, 0x48645487u, 0x34642334u, 0x55755646u, \n0x34764847u, 0x45651784u, 0x35674556u, 0x54469428u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x62580043u, 0x14561343u, 0x23243420u, 0x00135100u, \n0x61531322u, 0x23520223u, 0x03271134u, 0x16223423u, 0x37747846u, 0x65568764u, \n0x74274324u, 0x63453822u, 0x92435955u, 0x54D79A58u, 0x35603434u, 0x5741B445u, \n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \n0x00000000u, 0x00000000u, 0x34401242u, 0x02123224u, 0x22277152u, 0x53411354u, \n0x23453921u, 0x32265221u, 0x42120144u, 0x42411411u, 0x62452455u, 0x15444747u, \n0x85627564u, 0x84347973u, 0x32424563u, 0x34363155u, 0x47334473u, 0x61546A61u, \n0x22879714u, 0x65546794u, 0x37407276u, 0x35577636u, 0x51533145u, 0x35375463u, \n0x77336555u, 0x42264454u); // array len 128\n\nuint map_map_uint_7[] = uint[](\n0x43525466u, 0x56281443u, 0x15739962u, 0x43537825u, 0x034A2268u, 0x54225032u, \n0x36526433u, 0x52655755u, 0x63453653u, 0x73377223u, 0x34335557u, 0x55641588u, \n0x84678546u, 0x33542332u, 0x42725639u, 0x43142551u, 0x33411415u, 0x56453414u, \n0x26343322u, 0x56540111u, 0x52102323u, 0x51615424u, 0x23502355u, 0x22123414u, \n0x20100301u, 0x00403000u, 0x00000000u, 0x00000000u, 0x30500400u, 0x00323100u, \n0x00000000u, 0x00000000u, 0x76456434u, 0x44186518u, 0x32633347u, 0x14423134u, \n0x43255736u, 0x33265345u, 0x14623643u, 0x29487424u, 0x11204452u, 0x25363336u, \n0x41432533u, 0x26225164u, 0x34325202u, 0x34434232u, 0x36542319u, 0x42343245u, \n0x83862444u, 0x36136575u, 0x34853144u, 0x75629853u, 0x09754246u, 0x29235531u, \n0x54627254u, 0x62954374u, 0x22322224u, 0x43675535u, 0x92523326u, 0x45413644u, \n0x24635564u, 0x84595114u, 0x66562657u, 0x48544754u, 0x20000103u, 0x00230400u, \n0x00000000u, 0x00000000u, 0x20200101u, 0x00112000u, 0x00000000u, 0x00000000u, \n0x40100102u, 0x00232300u, 0x00000000u, 0x00000000u, 0x10100002u, 0x00211400u, \n0x00000000u, 0x00000000u, 0x22031513u, 0x73531562u, 0x55355444u, 0x16412202u, \n0x25213416u, 0x53336411u, 0x23343227u, 0x72052543u, 0x33623542u, 0x34563325u, \n0x45445816u, 0x44453832u, 0x51456244u, 0x10332563u, 0x24445464u, 0x97365462u, \n0x20300003u, 0x00122200u, 0x00000000u, 0x00000000u, 0x10200203u, 0x00121100u, \n0x00000000u, 0x00000000u, 0x34234936u, 0x24830322u, 0x24641224u, 0x32311155u, \n0x12414117u, 0x11655515u, 0x23453433u, 0x54221514u, 0x34228107u, 0x17345754u, \n0x56503436u, 0x34359532u, 0x64577726u, 0x14475313u, 0x46365233u, 0x75548B34u, \n0x42455763u, 0x43244355u, 0x85235441u, 0x72733617u, 0x63773547u, 0x42323238u, \n0x51544874u, 0x7333B763u); // array len 128\n\n// moved here because ANGLE in AMD GPU broke on arrays in cubemap shader\nuint map_ta2[] = uint[](\n0x3364336Cu, 0x33733374u, 0x3464346Cu, 0x34733474u, 0x3764376Cu, 0x37733774u, \n0x4464446Cu, 0x44734474u, 0x4D644D6Cu, 0x4D734D74u, 0x4E644E6Cu, 0x4E734E74u, \n0x5764576Cu, 0x57735774u, 0x5864586Cu, 0x58735874u, 0x6364636Cu, 0x63736374u, \n0x6464646Cu, 0x64736474u, 0x6664666Cu, 0x66736674u, 0x6C646C6Cu, 0x6C736C74u, \n0x6D646D6Cu, 0x6D736D74u, 0x7364736Cu, 0x73737374u, 0x7464746Cu, 0x74737474u, \n0x7764776Cu, 0x77737774u); // array len 32\nuint map_ta1[] = uint[](\n0x32334247u, 0x4B535658u, 0x6364666Au, 0x6C737479u); // array len 4\nuint map_tb2[] = uint[](\n0x33443352u, 0x3357337Au, 0x42444252u, 0x4257427Au, 0x47444752u, 0x4757477Au, \n0x53445352u, 0x5357537Au, 0x58445852u, 0x5857587Au, 0x63446352u, 0x6357637Au, \n0x66446652u, 0x6657667Au, 0x79447952u, 0x7957797Au); // array len 16\nuint map_tb1[] = uint[](\n0x31323334u, 0x37384244u, 0x47484B4Du, 0x4E525356u, 0x57586364u, 0x66686A6Cu, \n0x6D6E7273u, 0x7477797Au); // array len 8\n\n\nconst int et_a1[] = int[](239);\nconst int et_a2[] = int[](564, 612, 787, 798);\nconst int et_a3[] = int[](195, 196, 233, 548, 804, 815);\n\nconst int et_am[] = int[](364, 857, 12, 347, 938, 985, 84, 47, 965, 386, 1008, 766, 67, 105, 341, 519);\nconst int et_bm[] = int[](300, 276, 507, 879, 323, 705, 647, 519, 2, 370, 861, 805, 222, 153, 671, 986);\n\n\n#define self_buf iChannel0\n#define map1 map_uint_6\n#define map2 map_uint_7\n\n#define mapmap1 map_map_uint_6\n#define mapmap2 map_map_uint_7\nconst ivec2 mapmap_reg = ivec2(0,34);\n\nvoid mainImage_self_m1( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord);\n    \n    if(ipx==ivec2(32,32)){\n        fragColor = vec4(1.,map1.length(),map2.length(),0.);\n        return;\n    }\n    \n    if(ipx.x>=32||ipx.y>=32){\n        fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n    bool reset = texelFetch(self_buf, ivec2(32,32),0).x<0.5;\n    vec4 self_col = texelFetch(self_buf, ipx,0);\n    \n    if(iFrame>0&&!reset) {\n        fragColor = self_col;\n        return;\n    }\n    \n    int idx_x = ipx.x+ipx.y*int(32);\n    fragColor = vec4(0.);\n    if(idx_x<map1.length())\n        fragColor.x = uintBitsToFloat(map1[idx_x]);\n    if(idx_x<map2.length())\n        fragColor.y = uintBitsToFloat(map2[idx_x]);\n    \n}\n\nvoid mainImage_self_m2( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord);\n    \n    if(ipx.y!=mapmap_reg.y||((ipx.y==mapmap_reg.y)&&ipx.x>=mapmap1.length())){\n        fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n    bool reset = texelFetch(self_buf, ivec2(32,32),0).x<0.5;\n    vec4 self_col = texelFetch(self_buf, ipx,0);\n    \n    if(iFrame>0&&!reset) {\n        fragColor = self_col;\n        return;\n    }\n    \n    fragColor = vec4(0.);\n    fragColor.x = uintBitsToFloat(mapmap1[ipx.x]);\n    fragColor.y = uintBitsToFloat(mapmap2[ipx.x]);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord);\n    \n    ivec2 local_ipx = ipx%33;\n    ivec2 lid = ipx/33;\n    \n    if((lid.x>1||lid.y>1)&&!(ipx.y>=33*2+3&&ipx.y<33*2+3+4&&ipx.x<128)&&!(ipx.x>=33*2+3&&ipx.x<33*2+3+32&&ipx.y<9)){\n        fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n    bool reset = texelFetch(iChannel3, ivec2(32,32),0).x<0.5;\n    vec4 self_col = texelFetch(iChannel3, ipx,0);\n    \n    if(iFrame>0&&!reset) {\n        fragColor = self_col;\n        return;\n    }\n    \n    if(ipx.y>=33*2+3&&ipx.y<33*2+3+4&&ipx.x<128){\n        local_ipx = ivec2(ipx.x,ipx.y-(33*2+3));\n        if(local_ipx.y==3){\n            mainImage_self_m2(fragColor, vec2(local_ipx.x,mapmap_reg.y)+0.5);\n            return;\n        }else{\n        if(local_ipx.y==0){\n            fragColor = texelFetch(iChannel0, ivec2(local_ipx.x,mapmap_reg.y),0);\n            return;\n        }else{\n        if(local_ipx.y==1){\n            fragColor = texelFetch(iChannel1, ivec2(local_ipx.x,mapmap_reg.y),0);\n            return;\n        }else{\n        if(local_ipx.y==2){\n            fragColor = texelFetch(iChannel2, ivec2(local_ipx.x,mapmap_reg.y),0);\n            return;\n        }}}}\n        \n    }else{\n    if(ipx.x>=33*2+3&&ipx.x<33*2+3+32&&ipx.y<9){\n        ivec2 lipx = ivec2(ipx.x-(33*2+3),ipx.y);\n        fragColor = vec4(0.,0.,0.,0.);\n        if(lipx.x<map_ta2.length()&&ipx.y==0){\n            fragColor.x = uintBitsToFloat(map_ta2[lipx.x]);\n            return;\n        }else{\n            if(lipx.x<map_ta1.length()&&ipx.y==1){\n                fragColor.x = uintBitsToFloat(map_ta1[lipx.x]);\n                return;\n            }else{\n            if(lipx.x<map_tb2.length()&&ipx.y==2){\n                fragColor.x = uintBitsToFloat(map_tb2[lipx.x]);\n                return;\n            }else{\n            if(lipx.x<map_tb1.length()&&ipx.y==3){\n                fragColor.x = uintBitsToFloat(map_tb1[lipx.x]);\n                return;\n            }else{\n            if(lipx.x<et_a1.length()&&ipx.y==4){\n                fragColor.x = float(et_a1[lipx.x])+0.5;\n                return;\n            }else{\n            if(lipx.x<et_a2.length()&&ipx.y==5){\n                fragColor.x = float(et_a2[lipx.x])+0.5;\n                return;\n            }else{\n            if(lipx.x<et_a3.length()&&ipx.y==6){\n                fragColor.x = float(et_a3[lipx.x])+0.5;\n                return;\n            }else{\n            if(lipx.x<et_am.length()&&ipx.y==7){\n                fragColor.x = float(et_am[lipx.x])+0.5;\n                return;\n            }else{\n            if(lipx.x<et_bm.length()&&ipx.y==8){\n                fragColor.x = float(et_bm[lipx.x])+0.5;\n                return;\n            }}}}}}}}\n        }\n    }else{\n        if(lid.x==0&&lid.y==0){\n            mainImage_self_m1(fragColor, vec2(local_ipx)+0.5);\n            return;\n        } else{\n        if(lid.x==1&&lid.y==0){\n            fragColor = texelFetch(iChannel0, local_ipx,0);\n            return;\n        } else{\n        if(lid.x==0&&lid.y==1){\n            fragColor = texelFetch(iChannel1, local_ipx,0);\n            return;\n        } else{\n        if(lid.x==1&&lid.y==1){\n            fragColor = texelFetch(iChannel2, local_ipx,0);\n            return;\n        }}}}\n    }}\n    \n    \n}\n\n\n\n\n\n\n\n\n\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n// map of arrays \n// and UI control\n// UI-control:\n// CubeA is 16-bit - so I have to use two 16 bit pixels per one value to have better UI control\n// but there nothing complex - its cheap in performance\n\n\n\n// Descrioption:\n\n// Idea: \n// compress all Shadertoy website shader IDs to shader with less than 4096 bytes per shader\n// All shader IDs - only that returnde by Shadertoy API\n// 4096*6=24576 bytes, x6 because 4 buffers + Image shader and CubeA shader\n// Get all shaders - https://www.shadertoy.com/howto\n\n// But... :\n// I have not found way to do \"exact 4096 bytes per shader\" as I wanted\n// in this my version - compressed to:\n// uint-per-shader\n// 893+663 +128*2 in BufA\n// 908+851 +128*2 in BufB\n// 860+689 +128*2 in BufC\n// 681+688 +128*2 + 32+4+16+8 in BufD\n// =7317 uint *4 byte per uint = 29268 bytes\n\n// This my compression is 4692 bytes larger than \"I wanted to make\"\n// maybe there some other way to do it - this is my best result\n\n\n// Note - data 128x2x4 supposed to be in Cubemap\n// and this data is Not compressed, it can be compressed saving about 1Kb\n// but for \"ideal\" I need to remove 4692 bytes - more than entire CubeA data size\n// I mean - even if there is way to generalize entire CubeA data to single superformula\n// it stil will be not enough to fit \"ideal conditions\" - 4096 bytes per shader\n\n\n// Shadertoy token:\n//               6 characters length\n//     3 characters -> |___|___| <- 3 characters\n// 1024 unique tokens left | 1024 unique tokens right\n\n// Compression - simple \"tokens\" and \"connections\" and \"compression of connections\"\n// compression of connections - distribution of connections is not even\n// so it possible to \"collapse regions\" - by separating on multiple regions\n// example connections [1, 2, 4, 18, 25, 27, 48] - 6 bits per element\n// compresed to 8x4bits regions [1,2,4][18-8*2][25-8*3,27-8*3][48-8*6]\n// result [1,2,4,2,1,3,0] with map [3,1,2,0,0,1]\n// and map of \"regions\" is compression - because distribution of tokens is not even\n\n\n// Result:\n\n// Original data - 27981 elements 6x8-bit ASCII char per element\n// 167886 bytes=168Kb of original data - not compressed\n\n// SORTED - this is sorted result, order of original data is not saved\n// 73Kb - zip compression\n// 45Kb - 7z compression\n// 37Kb - 7z compression left+right side as separate files\n// 28.5Kb - This Shadertoy shader all data\n\n// this shader restore exact sorted data\n// I think this why comparison of \"Sorted\" compressed data is fair\n\n\n// This compression is:\n// 28792*8/27981 = 8.232 bits per token that 6-ASCII character\n// 8.232/6 = 1.37 bits per ASCII character in token\n\n\n// Possible Shadertoy chars in tokens, order from left to right\n// 1. ['3' '4' '7' 'D' 'M' 'N' 'W' 'X' 'c' 'd' 'f' 'l' 'm' 's' 't' 'w']\n// 2. ['d' 'l' 's' 't']\n// 3. ['2' '3' 'B' 'G' 'K' 'S' 'V' 'X' 'c' 'd' 'f' 'j' 'l' 's' 't' 'y']\n// 4. ['3' 'B' 'G' 'S' 'X' 'c' 'f' 'y']\n// 5. ['D' 'R' 'W' 'z']\n// 6. ['1' '2' '3' '4' '7' '8' 'B' 'D' 'G' 'H' 'K' 'M' 'N' 'R' 'S' 'V' 'W' 'X'\n//     'c' 'd' 'f' 'h' 'j' 'l' 'm' 'n' 'r' 's' 't' 'w' 'y' 'z']\n\n\n// Update:\n// Originally map of arrays map_map_uint_ were located in CubeA shader\n// But because \"AMD in ANGLE\" have very bad performance when arrays in CubeA shader\n// all arrays moved to BufA-D\n// This change MAY broke OpenGL compatibility \n// because BufA-D use more than 4Kb const data per shader\n// Previous version, that 100% work/tested in OpenGL \n// https://www.shadertoy.com/view/mdSyDd - there\n\n\nint map_ta2_len = 32;\nint map_ta1_len = 4;\nint map_tb2_len = 16;\nint map_tb1_len = 8;\n\nint et_a1_len = 1;\nint et_a2_len = 4;\nint et_a3_len = 6;\n\nint et_am_len = 16;\nint et_bm_len = 16;\n\n\nint getside_idx(vec3 rd);\nvec4 read_cubem(samplerCube textr, ivec2 px, int side_idx, vec2 side_res);\nvec4 restore_db(int idx);\nivec3 get_token_left(int idx);\nivec3 get_token_right(int idx);\nvec4 mapabuf(ivec2 ipx);\nvoid process_UI( inout vec4 fragColor, in vec2 fragCoord );\n\n// from my observation - number of frames till Cubemap initialization in Shadertoy/webgl\n// depends on \"how fast webbrowser allocating memory-RAM for web page\"\n// on webbrowser \"cold start\" while webbrower loading 50 other tabs - it sometime even 5 sec or 300 frames\n// so I mean - making it 300 frames to wait will be too annoying\n// better ask user to reload/restart shader if it does not load after few sec, so 15 frames is enough\n// https://www.shadertoy.com/view/mt33RH\nconst int wfr = 15; \n\nivec2 side_sz;\n\n#ifdef NO_COMPILE\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    discard;\n}\n#else\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    side_sz = textureSize(iChannel0,0).xy; // 1024 here\n    int side_idx = getside_idx(rayDir);\n    vec4 self = textureLod(iChannel0, rayDir, 0.);\n    fragColor = self;\n    if(iFrame<wfr) return; // dodge cubemap bugs https://www.shadertoy.com/view/mt33RH\n    \n    vec4 status = read_cubem(iChannel0, side_sz-1, cube_side, side_sz);\n    int load_state = int(status.y); //1 - load ta/tb and tidx_new, 2 load map\n    bool map_done = status.x>2.5;\n    ivec2 ipx = ivec2(fragCoord);\n    \n    if(side_idx!=cube_side){\n        if(side_idx==cube_side+1&&load_state==0){\n            fragColor = mapabuf(ipx);\n            //fragColor = self;\n        }\n        return;\n    }\n    \n    \n    if(ipx==side_sz-1)\n    {\n        fragColor = vec4(1.+clamp(self.x,0.,3.), 1.+clamp(self.y,0.,3.), 0., 1.); // (map_status, state, 0., reset)\n        return;\n    }\n    \n    process_UI(fragColor, fragCoord);\n    \n    ivec2 new_db_reg = ivec2(0,cube_num_elems_use_sz);\n    ivec2 ta_reg = ivec2(new_db_reg.x+new_db_reg.y,cube_tokens_use_sz);\n    ivec2 tb_reg = ivec2(ta_reg.x+ta_reg.y,cube_tokens_use_sz);\n    ivec2 tidx_new_reg = ivec2(tb_reg.x+tb_reg.y,cube_num_elems_use_sz);\n    \n    \n    if(load_state==1)\n    {\n        \n        ivec2 reg = ivec2(0.);\n        \n        reg = ivec2(ta_reg.x,ta_reg.x+ta_reg.y);\n        if((ipx.x<reg.y&&ipx.y<(reg.y-reg.x))&&(ipx.x>=reg.x&&ipx.y>=0))\n        {\n            ivec2 local_ipx = ivec2(ipx.x-reg.x,ipx.y);\n            int local_idx = local_ipx.x+local_ipx.y*(reg.y-reg.x);\n            ivec3 ta = get_token_left(local_idx);\n            fragColor = vec4(float(ta.x)+0.5,float(ta.y)+0.5,float(ta.z)+0.5,0.);\n        } else {\n            reg = ivec2(tb_reg.x,tb_reg.x+tb_reg.y);\n            if((ipx.x<reg.y&&ipx.y<(reg.y-reg.x))&&(ipx.x>=reg.x&&ipx.y>=0))\n            {\n                ivec2 local_ipx = ivec2(ipx.x-reg.x,ipx.y);\n                int local_idx = local_ipx.x+local_ipx.y*(reg.y-reg.x);\n                ivec3 tb = get_token_right(local_idx);\n                fragColor = vec4(float(tb.x)+0.5,float(tb.y)+0.5,float(tb.z)+0.5,0.);\n            } else{\n                // nop\n            }\n        }\n        \n    } else\n    if(load_state==2&&!map_done)\n    {\n        if((ipx.x<cube_num_elems_use_sz&&ipx.y<cube_num_elems_use_sz))\n        {\n            ivec2 local_ipx = ipx%cube_num_elems_use_sz;\n            int l_idx = local_ipx.x+local_ipx.y*cube_num_elems_use_sz;\n            fragColor = restore_db(l_idx);\n        }\n    }\n    \n}\n#endif\n\n\n// scrollbars control\n\nconst ivec4 bar_xy =   ivec4(0,0+cube_num_elems_use_sz+10,1,0+cube_num_elems_use_sz+10);\nconst ivec4 im_xy =    ivec4(0,1+cube_num_elems_use_sz+10,1,1+cube_num_elems_use_sz+10);\nconst ivec4 click_xy = ivec4(0,2+cube_num_elems_use_sz+10,1,2+cube_num_elems_use_sz+10);\nconst ivec4 click_pm = ivec4(0,3+cube_num_elems_use_sz+10,1,3+cube_num_elems_use_sz+10);\n\nconst ivec2 inp_buf1 = ivec2(0,4+cube_num_elems_use_sz+10);\nconst ivec2 inp_buf2 = ivec2(1,4+cube_num_elems_use_sz+10);\nconst ivec2 is_toka =  ivec2(0,5+cube_num_elems_use_sz+10);\nconst ivec2 is_tokb =  ivec2(1,5+cube_num_elems_use_sz+10);\n\nconst ivec2 unp_reg = ivec2(cube_num_elems_use_sz*2, cube_num_elems_use_sz);\nconst ivec2 unp_buf = ivec2(0,7+cube_num_elems_use_sz+10);\n\nconst ivec2 sest_idx_res = ivec2(0,8+cube_num_elems_use_sz+10+unp_reg.y);\n\nconst ivec2 sest_reg_sz = ivec2(4,20);\nconst ivec2 sest_idx_reg = ivec2(0,9+cube_num_elems_use_sz+10+unp_reg.y);\n\nconst ivec2 resetx = ivec2(2,2+cube_num_elems_use_sz+10);\n\nconst vec4 bar_xy_sc = vec4(vec2(10.),vec2(10.));\nconst vec4 im_xy_sc = vec4(vec2(1.),vec2(1.));\nconst vec4 click_xy_sc = vec4(vec2(cube_num_elems_use_sz+1,cube_num_elems_use_sz+1),vec2(10.));\nconst vec4 click_pm_sc = vec4(vec2(1.),vec2(10.));\n\nconst ivec2 tables_size = ivec2(cube_num_elems_use_sz,cube_num_elems_use_sz);\nconst float top_panel = 0.05;\nconst float borders = 0.1;\nconst vec2 text_len = vec2(3.5,1.); // X x2 and include boreder\nconst float blines = 0.065;\n\nvec4 loadval16(ivec2 ipx) {\n    //ivec2 side_sz = textureSize(iChannel0,0).xy;\n    return read_cubem(iChannel0, ipx, cube_side, side_sz);\n}\nvec4 loadval16_s2(ivec2 ipx) {\n    //ivec2 side_sz = textureSize(iChannel0,0).xy;\n    return read_cubem(iChannel0, ipx, cube_side+1, side_sz);\n}\n\n// 16bit 2x16 save\n// scale max 0xfffff\n// val min/max= +-scale\n// loss <0.000001 on scale=1\nvec4 save2x16(vec4 val, ivec2 tpx, ivec4 ipx, vec4 scale) {\n    vec4 tv = clamp((val/scale+1.)*0.5,0.,1.);\n    ivec4 itv=ivec4(tv*float(0x3fffff));\n    ivec4 ret =ivec4(0);\n    if(tpx==ipx.xy)ret = (itv>>11);\n    else ret = (itv)&0x7ff;\n    return vec4(ret-0x7ff/2);\n}\n\nbool is_reset(){\n    return loadval16(resetx).w<0.5;\n}\n\nvec4 loadval2x16(ivec4 ipx, vec4 scale) {\n    if(is_reset())return vec4(0.);\n    ivec4 a = ivec4(loadval16(ipx.xy)+float(0x7ff/2));\n    ivec4 b = ivec4(loadval16(ipx.zw)+float(0x7ff/2));\n    vec4 ret = scale*2.*(vec4((a<<11)+b)/float(0x3FFFFF)-0.5);\n    if(abs(ret.x)<0.000035)ret.x=0.; // 16-bit scale for loadval2x16\n    if(abs(ret.y)<0.000035)ret.y=0.;\n    if(abs(ret.z)<0.000035)ret.z=0.;\n    if(abs(ret.w)<0.000035)ret.w=0.;\n    return ret;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat lines1d(vec2 p, vec2 bsz, float px, float a, float b) {\n    float d = 0.;\n    d = max(d, smoothstep(px, -px, (sdBox(p, bsz / 2.) - a) - b));\n    return d;\n}\n\nvec2 postmove_bar(vec2 mzw) {\n    float fps = clamp(1./max(iTimeDelta,0.001),1.,9999.);\n    vec2 pm = loadval2x16(click_pm,click_pm_sc).xy;\n    for(int i = 0; i<2; i++){\n        if(mzw[i]<0.){\n            mzw[i]+= max((-1.5*(mzw[i])/fps+0.00001),0.00001);\n            if(mzw[i]>0.)mzw[i]=0.;\n        }else{\n            if(mzw[i]>1.){\n                mzw[i]-= max((1.5*(mzw[i]-1.)/fps+0.00001),0.00001);\n                if(mzw[i]<1.)mzw[i]=1.;\n            }else{\n                \n            }\n        }\n        mzw[i]+=pm[i];\n    }\n    return mzw;\n}\n\nvec4 process_bar(out ivec2 cidx, out float mtimer, out bool dx_bar, out bool dy_bar, out bool panel) {\n    bool reset = (iFrame-wfr)<=0||is_reset();\n    panel = false;dx_bar=false;dy_bar=false;\n    if(reset){\n        cidx = ivec2(-1000.);\n        mtimer = 0.;\n        return vec4(0.);\n    }\n    vec4 self = loadval2x16(bar_xy,bar_xy_sc);\n    vec4 ret = self;\n    vec2 screen_ires = vec2(textureSize(iChannel3,0).xy);\n    vec2 res=screen_ires.xy/screen_ires.y;\n    vec2 im=iMouse.xy/screen_ires.y-0.5*res;\n    vec2 im_local=iMouse.xy/screen_ires.xy;\n    \n    vec4 tclc = loadval2x16(click_xy,click_xy_sc);\n    cidx = ivec2(tclc.xy);\n    mtimer = tclc.z;\n    if(iMouse.z<=0.)mtimer+=iTimeDelta;\n    \n    if(iMouse.z>0.){\n        vec2 lc_local = self.zw;\n        if(lc_local.x<=0.)lc_local.xy = iMouse.zw/screen_ires.xy;\n        \n        vec2 lc = (lc_local.xy*screen_ires.xy)/screen_ires.y-0.5*res;\n        \n        panel = lines1d(lc+vec2(0.,0.5*top_panel), res-vec2(borders,borders+top_panel), 0.0001, 0.01, 0.001)>0.00001; \n        dx_bar = step(res.x*0.5-lc.x,blines*0.5)>0.5;\n        dy_bar = step(res.y*0.5+lc.y,blines*0.5)>0.5;\n        \n        if(dx_bar||dy_bar){\n            if(dx_bar)ret.y=(im_local.y)*(1.+0.5*2.*blines)-0.5*blines;\n            if(dy_bar)ret.x=(im_local.x)*(1.+0.5*2.*blines)-0.5*blines;\n        }else{\n            if(panel){\n                vec2 tp = lc;\n                tp+= 0.5*res-vec2(borders*0.5);\n                vec2 t_im = ((ret.xy*screen_ires.xy)/screen_ires.y);\n                \n                vec2 local_sc = (vec2(tables_size)-(res-vec2(borders,borders+top_panel))/(scale*text_len))*scale*text_len;\n                tp+= t_im*vec2(local_sc/res);\n                \n                if(self.z<=0.){\n                    ivec2 idx = ivec2(tp/(text_len*scale));\n                    mtimer=0.;\n                    cidx = idx;\n                }\n                vec4 limm = loadval2x16(im_xy,im_xy_sc);\n                vec2 imov = vec2(0.);\n                if(self.z>0.)imov = (im_local-limm.xy)*1.;\n                if(abs(imov.x)<0.000035)imov.x=0.; // 16-bit scale for 2x16\n                if(abs(imov.y)<0.000035)imov.y=0.; // 16-bit scale for 2x16\n                \n                ret.xy+=-(imov.xy)*1./(local_sc/res);\n            }\n        }\n        ret.zw = lc_local;\n        \n    }else{\n        ret.zw = iMouse.zw/screen_ires.xy;\n    }\n    return ret;\n    \n}\n\nvec4 postmove_im() {\n    vec4 self = loadval2x16(click_pm,click_pm_sc);\n    vec4 last_m = loadval2x16(click_xy,click_xy_sc);\n    vec4 bar = loadval2x16(bar_xy,bar_xy_sc);\n    vec4 ret = self;\n    float fps = clamp(1./max(iTimeDelta,0.001),1.,9999.);\n    ivec2 tp; float tm; bool dx; bool dy; bool pa;\n    vec4 tc = process_bar(tp, tm, dx, dy, pa);\n    if(iMouse.z<=0.){\n        vec2 sdir = self.xy;\n        if(bar.z>0.){\n            sdir = (bar.xy-self.zw);\n            sdir = 10.*scale*(sdir);\n        }else {\n            sdir = sdir*(0.999-0.169*clamp(25./fps,0.01,1.));\n            if(bar.x<0.||bar.x>1.)sdir.x*=(0.999-0.499*clamp(25./fps,0.01,1.));\n            if(bar.y<0.||bar.y>1.)sdir.y*=(0.999-0.499*clamp(25./fps,0.01,1.));\n        }\n        ret.xy = sdir;\n    }else{\n        if(!(pa||dx||dy)){\n            vec2 sdir = self.xy;\n            vec4 tim = loadval2x16(im_xy,im_xy_sc);\n            if(bar.z>0.&&tim.z<=0.){\n                sdir = (bar.xy-self.zw);\n            }else {\n                sdir = sdir*(0.999-0.169*clamp(25./fps,0.01,1.));\n                if(bar.x<0.||bar.x>1.)sdir.x*=(0.999-0.499*clamp(25./fps,0.01,1.));\n                if(bar.y<0.||bar.y>1.)sdir.y*=(0.999-0.499*clamp(25./fps,0.01,1.));\n            }\n            ret.xy = sdir;\n        }else{\n            ret.xy = vec2(0.);\n        }\n        ret.zw = bar.xy;\n    }\n    if(abs(ret.x)<0.000035)ret.x=0.; // 16-bit scale for 2x16\n    if(abs(ret.y)<0.000035)ret.y=0.; // 16-bit scale for 2x16\n    return ret;\n}\n\n#define keyboard_texture iChannel2\n\nconst int Key_Backspace = 8, Key_Enter = 13, Key_Shift = 16, Key_Delete = 46, \nKey_0 = 48, Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52,\nKey_5 = 53, Key_6 = 54, Key_7 = 55, Key_8 = 56, Key_9 = 57, \nKey_A = 65, Key_B = 66, \nKey_C = 67, Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72,Key_I = 73, \nKey_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, Key_O = 79, Key_P = 80,\nKey_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, Key_U = 85,Key_V = 86, Key_W = 87, \nKey_X = 88, Key_Y = 89, Key_Z = 90,\nKey_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99,\nKey_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, Key_Numpad7 = 103, \nKey_Numpad8 = 104, Key_Numpad9 = 105, Key_NumpadMultiply = 106;\n\nconst int ka_mul = 42;\nbool key(int K){return step(0.5, texelFetch(keyboard_texture, ivec2(K, 0), 0).x)>0.5;}\nint get_key(){\n    if(key(Key_Backspace))return -1;\n    if(key(Key_Delete))return -1;\n    if(key(Key_NumpadMultiply))return ka_mul;\n    bool sft = key(Key_Shift);\n    int kf = 0;\n    for(int i=Key_0;i<=Key_9+ANGLE_loops;i++){\n        if(key(i)||key(i-Key_0+Key_Numpad0)){\n            kf=i;\n            break;\n        }\n    }\n    if(kf>0){\n        if(sft&&kf==Key_8)return ka_mul;\n        else return kf;\n    }\n    for(int i=Key_A;i<=Key_Z+ANGLE_loops;i++){\n        if(key(i)){\n            kf=i;\n            break;\n        }\n    }\n    if(kf>0){\n        if(!sft){\n            kf+=32;\n            return kf;\n        }\n    }\n    return kf;\n    \n}\n\nvec4 proinp_left()\n{\n    bool reset = (iFrame-wfr)<=0||is_reset();\n    reset=reset||key(Key_Backspace)||key(Key_Delete);\n    if(reset){\n        return vec4(95.,95.,95.,0.005);\n    }\n    vec4 self = loadval16(inp_buf1);\n    int tk = get_key();\n    if(self.w<0.&&tk>0){\n        return self;\n    }\n    self.w=abs(self.w);\n    ivec3 skey = ivec3(self.xyz);\n    bvec3 st = bvec3(fract(self.w/1000.)*10.>0.5,fract(self.w/100.)*10.>0.5,fract(self.w/10.)*10.>0.5);\n    bvec3 ost = st;\n    if(tk<0){\n        skey = ivec3(95,95,95);\n        st = bvec3(false);\n    }else{\n        if(tk>0){\n            if(!st.x){skey[0]=tk;st.x = true;}\n            else{\n                if(!st.y){skey[1]=tk;st.y = true;}\n                else{\n                    if(!st.z){skey[2]=tk;st.z = true;}\n                }\n            }\n        }\n    }\n    \n    float est = 0.;\n    est+=100.*float(st.x);\n    est+=10.*float(st.y);\n    est+=1.*float(st.z);\n    float sig = 1.;\n    if(tk!=0&&(!ost.x||!ost.y||!ost.z))sig=-1.;\n    return vec4(vec3(skey)+0.5,sig*(est+0.005));\n}\n\nvec4 proinp_right()\n{\n    bool reset = (iFrame-wfr)<=0||is_reset();\n    reset=reset||key(Key_Backspace)||key(Key_Delete);\n    if(reset){\n        return vec4(95.,95.,95.,0.005);\n    }\n    vec4 self = loadval16(inp_buf2);\n    vec4 pbs = loadval16(inp_buf1);\n    bvec3 st0 = bvec3(fract(abs(pbs.w)/1000.)*10.>0.5,fract(abs(pbs.w)/100.)*10.>0.5,fract(abs(pbs.w)/10.)*10.>0.5);\n    \n    int tk = get_key();\n    if(self.w<0.&&tk>0||pbs.w<0.||!st0.x||!st0.y||!st0.z){\n        return self;\n    }\n    self.w=abs(self.w);\n    ivec3 skey = ivec3(self.xyz);\n    bvec3 st = bvec3(fract(self.w/1000.)*10.>0.5,fract(self.w/100.)*10.>0.5,fract(self.w/10.)*10.>0.5);\n    bvec3 ost = st;\n    if(tk<0){\n        skey = ivec3(95,95,95);\n        st = bvec3(false);\n    }else{\n        if(tk>0){\n            if(!st.x){skey[0]=tk;st.x = true;}\n            else{\n                if(!st.y){skey[1]=tk;st.y = true;}\n                else{\n                    if(!st.z){skey[2]=tk;st.z = true;}\n                }\n            }\n        }\n    }\n    \n    float est = 0.;\n    est+=100.*float(st.x);\n    est+=10.*float(st.y);\n    est+=1.*float(st.z);\n    float sig = 1.;\n    if(tk!=0&&(!ost.x||!ost.y||!ost.z))sig=-1.;\n    return vec4(vec3(skey)+0.5,sig*(est+0.005));\n}\n\nuint get_map_ta2(int idx){\n    return floatBitsToUint(texelFetch(iChannel3,ivec2(idx+33*2+3,0),0).x);\n}\nuint get_map_ta1(int idx){\n    return floatBitsToUint(texelFetch(iChannel3,ivec2(idx+33*2+3,1),0).x);\n}\nuint get_map_tb2(int idx){\n    return floatBitsToUint(texelFetch(iChannel3,ivec2(idx+33*2+3,2),0).x);\n}\nuint get_map_tb1(int idx){\n    return floatBitsToUint(texelFetch(iChannel3,ivec2(idx+33*2+3,3),0).x);\n}\nint get_et_a1(int idx){\n    return int(texelFetch(iChannel3,ivec2(idx+33*2+3,4),0).x);\n}\nint get_et_a2(int idx){\n    return int(texelFetch(iChannel3,ivec2(idx+33*2+3,5),0).x);\n}\nint get_et_a3(int idx){\n    return int(texelFetch(iChannel3,ivec2(idx+33*2+3,6),0).x);\n}\nint get_et_am(int idx){\n    return int(texelFetch(iChannel3,ivec2(idx+33*2+3,7),0).x);\n}\nint get_et_bm(int idx){\n    return int(texelFetch(iChannel3,ivec2(idx+33*2+3,8),0).x);\n}\n\nvec4 unp_reg_fn(ivec2 ipx){\n    bool reset = (iFrame-wfr)<=0||is_reset();\n    if(reset){\n        return vec4(0.,0.,0.,0.);\n    }\n    vec4 self = loadval16(ipx);\n    ipx = ipx - unp_buf;\n    if(ipx.x>=unp_reg.x||ipx.y>=unp_reg.y){\n        return vec4(0.);\n    }\n    \n    ivec2 new_db_reg = ivec2(0,cube_num_elems_use_sz);\n    ivec2 ta_reg = ivec2(new_db_reg.x+new_db_reg.y,0);\n    ivec2 tb_reg = ivec2(ta_reg.x+cube_tokens_use_sz,0);\n    \n    ivec2 lipx = ipx/ivec2(2,1);\n    \n    if(lipx.x+lipx.y*cube_num_elems_use_sz>=num_elems){\n        return vec4(0.,0.,0.,0.);\n    }\n    \n    ivec2 side_sz = textureSize(iChannel0,0).xy;\n    vec4 status = read_cubem(iChannel0, side_sz-1, cube_side, side_sz);\n    bool map_done = status.x>2.5;\n    \n    if(self.x==0.&&map_done)\n    {\n        vec4 t_idx = loadval16(lipx);\n        ivec3 taa = ivec3(0);\n        ivec3 tbb = ivec3(0);\n        int cidx = -1;\n        if(t_idx.x>0.){\n            int a_idx = (int(t_idx.x)<<8)+int(t_idx.y);\n            ivec2 aidx = ivec2(a_idx%32,a_idx/32);\n            vec4 ta = loadval16(ivec2(ta_reg) + aidx);\n            int b_idx = (int(t_idx.z)<<8)+int(t_idx.w);\n            ivec2 bidx = ivec2(b_idx%32,b_idx/32);\n            vec4 tb = loadval16(ivec2(tb_reg) + bidx);\n            taa = ivec3(ta.xyz);\n            tbb = ivec3(tb.xyz);\n            bool fo = false;\n            for(int i = 0;i<et_a1_len+ANGLE_loops&&!fo;i++){\n                if(a_idx==get_et_a1(i)){\n                    fo = true;\n                    cidx = 10;\n                }\n            }\n            for(int i = 0;i<et_a2_len+ANGLE_loops&&!fo;i++){\n                if(a_idx==get_et_a2(i)){\n                    fo = true;\n                    cidx = 20;\n                }\n            }\n            for(int i = 0;i<et_a3_len+ANGLE_loops&&!fo;i++){\n                if(a_idx==get_et_a3(i)){\n                    fo = true;\n                    cidx = 30;\n                }\n            }\n            bool tfo = false;\n            for(int i = 0;i<et_am_len+ANGLE_loops&&!tfo;i++){\n                if(a_idx==get_et_am(i)&&b_idx==get_et_bm(i)){\n                    if(cidx<0)cidx=0;\n                    if(i==et_am_len-1)cidx+=2;else cidx+=1;\n                    tfo = true;\n                }\n            }\n        }\n        \n        if(ipx.x%2==0) return vec4(vec3(taa)+0.5,sign(float(cidx))*(float(abs(cidx))+0.5));\n        else return vec4(vec3(tbb)+0.5,sign(float(cidx))*(float(abs(cidx))+0.5));\n   }else{\n       if(self.x!=0.&&map_done){\n            vec4 lsta = loadval16(is_toka);\n            int flgsa = int(abs(lsta.w));\n            vec4 lstb = loadval16(is_tokb);\n            int flgsb = int(abs(lstb.w));\n            ivec3 st = ivec3(self.xyz);\n            int cidx = int(self.w);\n\n            if((flgsa==1&&(flgsb==1||flgsb==2||flgsb==3||flgsb==4||flgsb==5||flgsb==6||flgsb==30||flgsb==0))||\n                (flgsb==1&&(flgsa==1||flgsa==2||flgsa==3||flgsa==4||flgsa==5||flgsa==6||flgsa==30))){\n                ivec3 ttt = ivec3(0);\n                if(ipx.x%2==0) ttt = ivec3(lsta.xyz); else ttt = ivec3(lstb.xyz);\n                bvec3 tst = not(bvec3(ttt.x>0&&ttt.x!=95&&ttt.x!=ka_mul,ttt.y>0&&ttt.y!=95&&ttt.y!=ka_mul,ttt.z>0&&ttt.z!=95&&ttt.z!=ka_mul));\n                \n                bvec3 tst_t = bvec3(ttt.x==st.x||tst.x,ttt.y==st.y||tst.y,ttt.z==st.z||tst.z);\n                if(all(tst_t)){\n                    if(cidx>50)cidx=cidx-100;\n                    cidx+=100;\n                }else {\n                    if(cidx>50)cidx=cidx-100;\n                }\n            }else{\n                if(flgsa==20||flgsb==20){\n                    if(cidx>50)cidx=cidx-100;\n                }\n            }\n            bool kd = key(Key_Backspace)||key(Key_Delete);\n            if(cidx>50&&kd)cidx=cidx-100;\n            \n            return vec4(vec3(st)+0.5,sign(float(cidx))*(float(abs(cidx))+0.5));\n       }else return vec4(0.,0.,0.,0.);\n   }\n   \n   return vec4(0.,0.,0.,0.);\n    \n}\n\nvec4 is_token(int ti){\n    bool reset = (iFrame-wfr)<=0||is_reset();\n    reset=reset||key(Key_Backspace)||key(Key_Delete);\n    if(reset){\n        return vec4(0.,0.,0.,0.);\n    }\n    \n    ivec2 new_db_reg = ivec2(0,cube_num_elems_use_sz);\n    ivec2 ta_reg = ivec2(new_db_reg.x+new_db_reg.y,0);\n    ivec2 tb_reg = ivec2(ta_reg.x+cube_tokens_use_sz,0);\n    \n    ivec2 sidx = is_toka;\n    ivec2 inp = inp_buf1;\n    ivec2 tt_reg = ta_reg;\n    if(ti==1){\n        sidx = is_tokb;\n        inp = inp_buf2;\n        tt_reg = tb_reg;\n    }\n    vec4 self = loadval16(sidx);\n    ivec3 st = ivec3(self.xyz);\n    int flgs = int(abs(self.w));\n    if(flgs>=1&&flgs<6)flgs+=1;\n    bool tkey = key(Key_Enter);\n    if(flgs>=4){\n        if(!(self.w>0.)&&tkey){\n            flgs=4;\n        }\n    }\n    vec4 pbs = loadval16(inp);\n    ivec3 ch = ivec3(abs(pbs.xyz));\n    bvec3 tst = not(bvec3(ch.x>0&&ch.x!=95&&ch.x!=ka_mul,ch.y>0&&ch.y!=95&&ch.y!=ka_mul,ch.z>0&&ch.z!=95&&ch.z!=ka_mul));\n    if(ch!=st&&!all(tst)){\n        st = ch;\n        int fidx = 0;\n        bool fbd = false;\n        for(int i=0;i<tokens+ANGLE_loops&&!fbd;i++){\n            ivec2 ttidx = ivec2(i%32,i/32); \n            vec4 tt = loadval16(ivec2(tt_reg) + ttidx);\n            ivec3 ttt = ivec3(tt.xyz);\n            bvec3 tst_t = bvec3(ttt.x==st.x||tst.x,ttt.y==st.y||tst.y,ttt.z==st.z||tst.z);\n            if(all(tst_t)){\n                fbd = true;\n                fidx = i;\n                break;\n            }\n        }\n        if(fbd){\n            flgs=1;\n        }else{\n            flgs=20;\n        }\n    }else{\n        if(ch==ivec3(ka_mul,95,95)||ch==ivec3(ka_mul,ka_mul,95)||ch==ivec3(ka_mul)){\n            flgs=30;\n        }\n    }\n    return vec4(vec3(st)+0.5,(float(tkey)*2.-1.)*(float(flgs)+0.5));\n}\n\nvec4 sest_idx_reg_fn(ivec2 ipx){\n    bool reset = (iFrame-wfr)<=0||is_reset();\n    reset=reset||key(Key_Backspace)||key(Key_Delete);\n    if(reset){\n        return vec4(0.,0.,0.,0.);\n    }\n    \n    vec4 self = loadval16(ipx);\n    ivec2 nfidx = ivec2((int(abs(self).x)<<8)+int(abs(self).y),(int(abs(self).z)<<8)+int(abs(self).w));;\n    vec4 ls = loadval16(sest_idx_res);\n    ivec2 lfidx = ivec2((int(abs(ls).x)<<8)+int(abs(ls).y),(int(abs(ls).z)<<8)+int(abs(ls).w));;\n    bvec4 ft = greaterThan(self,vec4(0.));\n    ivec2 onfidx = lfidx;\n    int oix = onfidx.x+onfidx.y*cube_num_elems_use_sz;\n    \n    ivec2 lipx = ipx-sest_idx_reg;\n    int l_idx = lipx.x+lipx.y*sest_reg_sz.x;\n    \n    vec4 lsta = loadval16(is_toka);\n    int flgsa = int(abs(lsta.w));\n    vec4 lstb = loadval16(is_tokb);\n    int flgsb = int(abs(lstb.w));\n    \n    ivec2 fidx = ivec2(0);\n    \n    bool ra = (flgsa==2&&(flgsb==2||flgsb==3||flgsb==4||flgsb==5||flgsb==6||flgsb==30||flgsb==0))||(flgsb==2&&(flgsa==2||flgsa==3||flgsa==4||flgsa==5||flgsa==6||flgsa==30));\n    bool rb = (flgsa==4&&(flgsb==4||flgsb==30||flgsb==0))||(flgsb==4&&(flgsa==4||flgsa==30));\n    bool lke = ft.x;\n    bool tkey = key(Key_Enter);\n    if(rb)ft.x = false;else if(!ft.x)ft.x = tkey;\n    rb = rb&&(tkey||lke)&&ls.w>0.;\n    \n    if(ra||rb){\n        ft.zw = bvec2(false);\n        int rsz = sest_reg_sz.x*sest_reg_sz.y;\n        int lfst = num_elems/rsz;\n        int olfst = lfst;\n        if(l_idx==rsz-1)lfst+=num_elems-lfst*rsz;\n        bool fndt = false;\n        for(int i=0;i<lfst+ANGLE_loops;i++){\n            int ti = i+l_idx*olfst;\n            ivec2 tidx = ivec2(ti%cube_num_elems_use_sz, ti/cube_num_elems_use_sz);\n            vec4 ta = loadval16(unp_buf+tidx*ivec2(2,1));\n            vec4 tb = loadval16(unp_buf+tidx*ivec2(2,1)+ivec2(1,0));\n            if(!(ta.x>0.)||!(tb.x>0.))break;\n            int tfo = int(ta.w);\n            int tfob = int(tb.w);\n            bool tfio = tfo>50&&tfob>50;\n            if(tfio){\n                if(rb){\n                    int nix = tidx.x+tidx.y*cube_num_elems_use_sz;\n                    if(nix<=oix){\n                        fidx=tidx;\n                        fndt=true;\n                        continue;\n                    }else{\n                        fidx=tidx;\n                        fndt=true;\n                        break;\n                    }\n                }else{\n                    fidx=tidx;\n                    fndt=true;\n                    break;\n                }\n            }\n        }\n        ft.w=fndt;\n        \n    }\n    nfidx=fidx;\n    \n    vec4 tft = vec4(ft)*2.-1.;\n    return tft*vec4(float(nfidx.x>>8)+0.5,float(nfidx.x&0xff)+0.5,float(nfidx.y>>8)+0.5,float(nfidx.y&0xff)+0.5);\n}\n\nvec4 sest_idx_res_fn(){\n    bool reset = (iFrame-wfr)<=0||is_reset();\n    reset=reset||key(Key_Backspace)||key(Key_Delete);\n    if(reset){\n        return vec4(0.,0.,0.,0.);\n    }\n    \n    vec4 self = loadval16(sest_idx_res);\n    ivec2 nfidx = ivec2((int(abs(self).x)<<8)+int(abs(self).y),(int(abs(self).z)<<8)+int(abs(self).w));;\n    ivec2 onfidx = nfidx;\n    int oix = onfidx.x+onfidx.y*cube_num_elems_use_sz;\n    bvec4 ft = greaterThan(self,vec4(0.));\n    \n    vec4 lsta = loadval16(is_toka);\n    int flgsa = int(abs(lsta.w));\n    vec4 lstb = loadval16(is_tokb);\n    int flgsb = int(abs(lstb.w));\n    \n    bool ra = (flgsa==3&&(flgsb==3||flgsb==4||flgsb==5||flgsb==6||flgsb==30||flgsb==0))||(flgsb==3&&(flgsa==3||flgsa==4||flgsa==5||flgsa==6||flgsa==30));\n    bool rb = (flgsa==5&&(flgsb==5||flgsb==30||flgsb==0))||(flgsb==5&&(flgsa==5||flgsa==30));\n    bool lke = ft.x;\n    bool tkey = key(Key_Enter);\n    if(rb)ft.x = false;else if(!ft.x)ft.x = tkey;\n    rb = rb&&(tkey||lke);\n    \n    if(ra||rb){\n        ft.zw = bvec2(false);\n        bool brk = false;\n        for(int j=0;j<sest_reg_sz.y+ANGLE_loops&&!brk;j++){\n            for(int i=0;i<sest_reg_sz.x+ANGLE_loops&&!brk;i++){ \n                vec4 tv = loadval16(sest_idx_reg+ivec2(i,j));\n                \n                if(tv.w>0.){\n                    ivec2 nw = ivec2((int(abs(tv).x)<<8)+int(abs(tv).y),(int(abs(tv).z)<<8)+int(abs(tv).w));;\n                    if(rb){\n                        int nix = nw.x+nw.y*cube_num_elems_use_sz;\n                        if(nix<=oix){\n                            ft.w = true;\n                            continue;\n                        }else{\n                            nfidx=nw;\n                            ft.w = true;\n                            brk = true;\n                        }\n                    }else{\n                        nfidx=nw;\n                        ft.w = true;\n                        brk = true;\n                    }\n                }\n            }\n        }\n        if(!ft.w){ft.z=true;}\n    }\n    \n    vec4 tft = vec4(ft)*2.-1.;\n    return tft*vec4(float(nfidx.x>>8)+0.5,float(nfidx.x&0xff)+0.5,float(nfidx.y>>8)+0.5,float(nfidx.y&0xff)+0.5);\n}\n\n\nvoid process_UI( inout vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 ipx = ivec2(fragCoord);\n    \n    if(ipx==resetx){\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n    \n    if(ipx==bar_xy.xy||ipx==bar_xy.zw){\n        ivec2 tp; float tm; bool dx; bool dy; bool pa;\n        fragColor = process_bar(tp,tm, dx, dy, pa);\n        if(iMouse.z>0.&&dx){\n            fragColor.x = postmove_bar(fragColor.xy).x;\n        }else if(iMouse.z>0.&&dy){\n            fragColor.y = postmove_bar(fragColor.xy).y;\n        }else if(iMouse.z>0.&&!pa&&!dx&&!dy){\n            fragColor.xy = postmove_bar(fragColor.xy);\n        }else if(iMouse.z<=0.){\n            fragColor.xy = postmove_bar(fragColor.xy);\n        }\n        fragColor = save2x16(fragColor, ipx, bar_xy, bar_xy_sc);\n        return;\n    }\n    \n    if(ipx==click_xy.xy||ipx==click_xy.zw){\n        ivec2 tp; float tm; bool dx; bool dy; bool pa;\n        vec4 tc = process_bar(tp,tm, dx, dy, pa);\n        fragColor = vec4(vec2(tp)+0.5,tm,0.);\n        fragColor = save2x16(fragColor, ipx, click_xy, click_xy_sc);\n        return;\n    }\n    \n    if(ipx==im_xy.xy||ipx==im_xy.zw){\n        vec2 screen_ires = vec2(textureSize(iChannel3,0).xy);\n        fragColor = vec4(iMouse.xyzw/screen_ires.xyxy);\n        fragColor = save2x16(fragColor, ipx, im_xy, im_xy_sc);\n        return;\n    }\n    \n    if(ipx==click_pm.xy||ipx==click_pm.zw){\n        fragColor = postmove_im();\n        fragColor = save2x16(fragColor, ipx, click_pm, click_pm_sc);\n        return;\n    }\n    \n    if(ipx==inp_buf1){\n        fragColor = proinp_left();\n        return;\n    }\n    if(ipx==inp_buf2){\n        fragColor = proinp_right();\n        return;\n    }\n    \n    if(ipx.x>=unp_buf.x&&ipx.x<unp_buf.x+unp_reg.x&&ipx.y>=unp_buf.y&&ipx.y<unp_buf.y+unp_reg.y){\n        fragColor = unp_reg_fn(ipx);\n        return;\n    }\n    if(ipx==is_toka){\n        fragColor = is_token(0);\n        return;\n    }\n    if(ipx==is_tokb){\n        fragColor = is_token(1);\n        return;\n    }\n    if(ipx.x>=sest_idx_reg.x&&ipx.x<sest_idx_reg.x+sest_reg_sz.x&&ipx.y>=sest_idx_reg.y&&ipx.y<sest_idx_reg.y+sest_reg_sz.y){\n        fragColor = sest_idx_reg_fn(ipx);\n        return;\n    }\n    if(ipx==sest_idx_res){\n        fragColor = sest_idx_res_fn();\n        return;\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// DO NOT REUSE/COPY ANY OF THIS\n// this is made only for this exact case\n// HALF OF THIS CODE IS HARD-CODED, parameters may be not what you think it is\n// for example 32 is bits region size of uint but also size of array side, and bits reading is 8bit max\n// you will waste more time debugging/adopting/fixing this my code than do it from scratch\n// this code is \"reading bits by index from arrays\" - basically reading bits from linear list\n// and code around is just indexing with shifts\n\nint get_8bits_byidx_map_ta2(int idx);\nint get_8bits_byidx_map_ta1(int idx);\nint get_8bits_byidx_map_tb2(int idx);\nint get_8bits_byidx_map_tb1(int idx);\nivec3 get_token_left(int idx){\n    int ida2 = idx/(map_ta1_len*4);\n    int ida1 = idx%(map_ta1_len*4);\n    \n    int a = get_8bits_byidx_map_ta2(ida2*2);\n    int b = get_8bits_byidx_map_ta2(ida2*2+1);\n    int c = get_8bits_byidx_map_ta1(ida1);\n    return ivec3(a,b,c);\n}\n\nivec3 get_token_right(int idx){\n    int ida2 = idx/(map_tb1_len*4);\n    int ida1 = idx%(map_tb1_len*4);\n    \n    int a = get_8bits_byidx_map_tb2(ida2*2);\n    int b = get_8bits_byidx_map_tb2(ida2*2+1);\n    int c = get_8bits_byidx_map_tb1(ida1);\n    return ivec3(a,b,c);\n}\n\nint get_8bits_byidx_map_map_uint_angle(int idx, int jdx);\n\nint get_by_idx(int idx, int slf, int nsfl, int bits){\n  int local_idx = idx*bits/8;\n  int local_ndx = idx*bits-local_idx*8;\n  int to_read = 8-local_ndx;\n\n  int tval = slf;\n  to_read+=-bits;\n  to_read=max(to_read, 0);\n  int lbs = min(8-local_ndx, bits);\n  int m = (1 << lbs) - 1;\n  int v = (tval >> to_read) & m;\n  if(8-local_ndx<bits)\n  {\n    local_idx = (idx*bits+lbs)/8;\n    tval = nsfl;\n    to_read = 8-(bits-(8-local_ndx));\n    m = (1 << (8-to_read)) - 1;\n    v = (v<<(8-to_read))+((tval >> (to_read)) & m);\n  }\n  return v;\n}\n\n\nivec3 get_mxz(int idx){\n    int fpos = 0;\n    int floc[] = int[](0,0,0,0,0,0,0,0);\n    for(int i=0;i<1024+ANGLE_loops;i++){\n        for(int j=0;j<8+ANGLE_loops;j++)\n        {\n            int tval = -1;\n            int ntval = -1;\n            tval=get_8bits_byidx_map_map_uint_angle(((i+0)*size_map_bits_size)/8,j);\n            if((i+1)<1024){\n                ntval=get_8bits_byidx_map_map_uint_angle(((i+1)*size_map_bits_size)/8,j);\n            }else {ntval = 0;}\n            int tsz=get_by_idx(i, tval, ntval, size_map_bits_size);\n            fpos+=tsz;\n            if(idx<fpos){\n                return ivec3(j,floc[j]+idx-(fpos-tsz),i);\n            }\n            floc[j]+=tsz;\n        }\n    }\n    return ivec3(-1,-1,-1);\n}\n\nivec4 to8bitsa(uint val){\n  ivec4 ret = ivec4(0);\n  for(int i=0;i<4+ANGLE_loops;i++){\n    ret[i] = int(val>>((3-i)*8))&0xFF;\n  }\n  return ret;\n}\n\nint get_map_by_idx(int midx, int lidx){\n    \n    ivec2 m1p[] = ivec2[](ivec2(1,0), ivec2(0,1), ivec2(1,1), ivec2(0,0));\n    \n    int xidx = lidx*map_bits_rnge;\n    int xidx2 = (lidx+1)*map_bits_rnge;\n    int xidx4 = xidx/32;\n    ivec2 tidx = ivec2(xidx4%32, (xidx4/32));\n    \n    int xidx42 = xidx2/32;\n    ivec2 tidx2 = ivec2(xidx42%32, (xidx42/32));\n    \n    float tval=texelFetch(iChannel3, m1p[midx/2]*ivec2(33,33)+tidx, 0)[midx%2];\n    float ntval=texelFetch(iChannel3, m1p[midx/2]*ivec2(33,33)+tidx2, 0)[midx%2];\n    \n    int rde = xidx4*32;\n    int tsft = xidx-rde;\n    int ldxi = tsft/8;\n    int ldxi2 = (tsft+map_bits_rnge)/8;\n    \n    ivec4 a1 = to8bitsa(floatBitsToUint(tval));\n    ivec4 a2 = to8bitsa(floatBitsToUint(ntval));\n    \n    int tarr[] = int[](a1[0],a1[1],a1[2],a1[3],a2[0],a2[1],a2[2],a2[3]);\n    int tval8 = tarr[ldxi];\n    int ntval8 = tarr[ldxi2];\n    \n    return get_by_idx(lidx, tval8, ntval8, map_bits_rnge);\n    \n    \n}\n\nvec4 restore_db(int idx){\n    if(idx>=num_elems){\n        return vec4(-1.);;\n    }\n    \n    ivec3 fi = get_mxz(idx);\n    int tv = get_map_by_idx(fi.x, fi.y);\n    int tvf = (fi.x*dvdr+tv);\n    \n    // return token left, token right ID\n    vec4 tret = vec4(vec2(fi.z>>8,fi.z&0xff)+0.5,vec2(tvf>>8,tvf&0xff)+0.5);\n    return tret;\n    \n}\n\n\nvec4 mapabuf(ivec2 ipx){\n\n    vec4 ret = vec4(0.);\n    int lidx = ipx.x+ipx.y*side_sz.x;\n    int jdx = lidx/128;\n    if(jdx>7)return ret;\n    float tret = texelFetch(iChannel3,ivec2(lidx%128,33*2+3+jdx/2),0)[jdx%2];\n    ret = vec4(to8bitsa(floatBitsToUint(tret)))+0.5;\n    return ret;\n}\n\n//-----------------------------------------\n\nint get_8bits_byidx_map_ta2(int idx){\n    int local_idx = idx/4;\n    uint val = get_map_ta2(local_idx);\n    val = (val>>((3-(idx%4))*8))&0xFFu;\n    return int(val);\n}\n\nint get_8bits_byidx_map_ta1(int idx){\n    int local_idx = idx/4;\n    uint val = get_map_ta1(local_idx);\n    val = (val>>((3-(idx%4))*8))&0xFFu;\n    return int(val);\n}\n\nint get_8bits_byidx_map_tb2(int idx){\n    int local_idx = idx/4;\n    uint val = get_map_tb2(local_idx);\n    val = (val>>((3-(idx%4))*8))&0xFFu;\n    return int(val);\n}\n\nint get_8bits_byidx_map_tb1(int idx){\n    int local_idx = idx/4;\n    uint val = get_map_tb1(local_idx);\n    val = (val>>((3-(idx%4))*8))&0xFFu;\n    return int(val);\n}\n\nint get_8bits_byidx_map_map_uint_angle(int idx, int jdx){\n    int local_idx = idx/4;\n    int tidx = local_idx+jdx*128;\n    ivec2 ipx = ivec2(tidx%side_sz.x,tidx/side_sz.x);\n    vec4 tval = loadval16_s2(ipx);\n    return int(tval[idx%4]);\n}\n\n//-----------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "cube_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// this shader works better with Vulkan\n// chrome.exe --use-angle=vulkan\n\nconst float scale = .051;\n\nconst int num_elems = 28476;\nconst int cube_num_elems_use_sz = 169; // sqrt(num_elems)\n\nconst int tokens = 1024;\nconst int cube_tokens_use_sz = 32; // sqrt(tokens)\n\nconst int map_bits_rnge = 7;\nconst int size_map_bits_size = 4;\nconst int dvdr = (1<<map_bits_rnge);\n\nconst int cube_side = 0;\n\n#define ANGLE_loops min(iFrame,0)\n\nvoid convert_cube_uv_to_xyz(in int index, in vec2 uv, out vec3 rd);\nvec4 read_cubem(samplerCube textr, ivec2 px, int side_idx, ivec2 side_res){\n    px.y = (side_res.y-1) - px.y; //vflip\n    vec2 tuv = (vec2(px)+0.5)/vec2(side_res);\n    vec3 trd;\n    convert_cube_uv_to_xyz(side_idx, tuv, trd);\n    return textureLod(textr, trd, 0.);\n}\n\n// https://www.shadertoy.com/view/NttGWr\nint getside_idx(vec3 rd){\n    int Front_side = 0;\n    int Back_side = 1;\n    int Up_side = 2;\n    int Down_side = 3;\n    int Left_side = 4;\n    int Right_side = 5;\n    \n    if(length(rd)<0.0001)return -1;\n    \n    vec3 a = abs(rd);\n    bvec3 ip = greaterThan(rd,vec3(0.));\n    if (ip.x && a.x >= a.y && a.x >= a.z) {return Front_side;}else\n    if (!ip.x && a.x >= a.y && a.x >= a.z) {return Back_side;}else\n    if (ip.y && a.y >= a.x && a.y >= a.z) {return Up_side;}else\n    if (!ip.y && a.y >= a.x && a.y >= a.z) {return Down_side;}else\n    if (ip.z && a.z >= a.x && a.z >= a.y) {return Left_side;}else\n    if (!ip.z && a.z >= a.x && a.z >= a.y) {return Right_side;}\n}\n\nvoid convert_cube_uv_to_xyz(in int index, in vec2 uv, out vec3 rd)\n{\n  float uc = 2.0 * uv.x - 1.0;\n  float vc = 2.0 * uv.y - 1.0;\n  rd=vec3(0.0001,0.9999,0.0001);\n  if(index==0){rd=normalize(vec3(1.0, vc, -uc));return;}\n  if(index==1){rd=normalize(vec3(-1.0, vc, uc));return;}\n  if(index==2){rd=normalize(vec3(uc, 1.0, -vc));return;}\n  if(index==3){rd=normalize(vec3(uc,-1.0, vc));return;}\n  if(index==4){rd=normalize(vec3(uc, vc, 1.0));return;}\n  if(index==5){rd=normalize(vec3(-uc, vc, -1.0));return;}\n}", "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXyWr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3359, 3359, 3381, 3381, 3498], [3501, 3501, 3538, 3538, 3622], [3624, 3624, 3683, 3683, 3787], [3789, 3789, 3850, 3850, 3951], [3955, 4001, 4088, 4088, 4422], [4424, 4424, 4476, 4476, 4631], [4633, 4633, 4696, 4696, 4916], [4918, 4918, 4956, 4956, 5478], [5480, 5480, 5546, 5546, 5788], [6843, 6843, 6870, 6870, 6980], [7040, 7040, 7056, 7056, 7094], [7096, 7096, 7137, 7137, 7343], [11186, 11186, 11225, 11225, 14850]], "test": "untested"}
{"id": "csScWt", "name": "ᵛᵉʳʸ ˢᵐᵃˡˡ ˢʰᵃᵈᵉʳˢ [85 Chars]", "author": "SnoopethDuckDuck", "description": "This was an attempt to get something cool with as few characters possible", "tags": ["tiny", "small", "tweet", "golf", "100chars"], "likes": 19, "viewed": 344, "published": 3, "date": "1688304902", "time_retrieved": "2024-07-30T17:46:17.793412", "image_code": "// Abstract fractal [85] \n// >>> DON'T PLAY WITH THIS OR YOUR WEBGL WILL CRASH <<<\nvoid mainImage( out vec4 O, vec2 I )\n{ \n   for(O-=O; O.x<0.4;)\n       O += .05/length(tan(O.x-(I*=.5)));\n}\n// >>> DON'T PLAY WITH THIS OR YOUR WEBGL WILL CRASH <<<\n\n/*\n\n// Stars [85]\nvoid mainImage( out vec4 O, vec2 I )\n{ \n    for(O-=O; O.w++ < 9.;)\n    O += atan(2.-length(tan(I*=.5)));\n}\n\n// 2^n fractal [85]\nvoid mainImage( out vec4 O, vec2 I )\n{ \n    for(int i; i++ < 8;)\n    O = 0.*O + cos(O/length(cos(I*=.5)));\n}\n\n// Grid [93]\nvoid mainImage( out vec4 O, vec2 I )\n{ \n    O *= 0.;\n    //I += 100. * iTime;\n    for(int i; i++ < 9;)\n    O += .1*atan(2.-length(tan(I*=.25)));\n}\n\n//*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csScWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 83, 121, 121, 189]], "test": "untested"}
{"id": "md2cD3", "name": "The Veil - TS", "author": "cnfrm", "description": "The Veil", "tags": ["veil"], "likes": 2, "viewed": 237, "published": 3, "date": "1688291590", "time_retrieved": "2024-07-30T17:46:18.569337", "image_code": "\n//Edit of https://www.shadertoy.com/view/MdVSWt#\n\n\nconst float dispValue = 1.;\nconst float dispOffset = .5;\nconst float sphereBaseRadius = .6;\nconst vec3 ld = vec3(.4,0.3,.0);\n\n\nfloat hash( vec3 p ) {\n    float h = dot(p,vec3(127.1,311.7,79.1));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nvec3 rotateX(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\n\nfloat noise( in vec3 p ) { // base noise\n\n    // iq 3d noise\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    float v = mix( mix( mix( hash( i + vec3(0.,0.,0.) ), \n                             hash( i + vec3(1.,0.,0.) ), u.x),\n                        mix( hash( i + vec3(0.,1.,0.) ), \n                             hash( i + vec3(1.,1.,0.) ), u.x), u.y),\n                   mix( mix( hash( i + vec3(0.,0.,1.) ), \n                             hash( i + vec3(1.,0.,1.) ), u.x),\n                        mix( hash( i + vec3(0.,1.,1.) ), \n                             hash( i + vec3(1.,1.,1.) ), u.x), u.y),u.z); \n    \n    // bubble style\n    v = v * 2. - .5;    \n    float cv = abs(cos(v));    \n    float sv = abs(sin(v));    \n    v = mix(sv,cv,sv);\n    \n    return v;\n}\n\nfloat noiseLayer(vec3 p) { // layered noise\n        \n    float freq = 1.2; // base frequency / size\n    const int iter = 11; // iteration / depth\n    float lacunarity = 1.; // lacunarity: relative \"importance\" of smaller octaves\n    float v = 0.;\n    float sum = 0.;\n    for(int i = 0; i < iter; i++) {\n        float layerUp = 1. / pow(freq,lacunarity);\n        v += noise(p*freq) * layerUp;\n        sum += layerUp;\n        freq *= 1.8;\n    }\n    v /= sum;\n    return v;\n}\n\nfloat map(vec3 p){\n    \n    //rotate ball\n    p = rotateX(p,iMouse.y/100. + iTime/7.);\n    p = rotateY(p,iMouse.x/100. + iTime/7.); \n\n    // animate noise\n    float timeOffset = iTime/70.;\n    \n  \treturn noiseLayer(p+timeOffset) - dispOffset;  \n}\n\nvec3 calcNormal( in vec3 pos, float t ) // iq get normal\n{\n    vec2 eps = vec2( 0.005*t, 0.0 );\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat shadowRay(vec3 startP, vec3 lightDir){ // iq soft shadows \n    \n    float t = 0.0;\n    float shadowHardness = 10.;\n    float minD = 1.; // close-by distance \n    \n    for (int r = 0; r < 8; ++r){\n        \n        vec3 p = startP + vec3(t*lightDir.x,t*lightDir.y,t*lightDir.z) + normalize(startP)/shadowHardness; // safe offset\n        \n        vec3 pp = normalize(p) * sphereBaseRadius;                 \n        float sp = sphereBaseRadius + map(pp) * dispValue;\n        float d = length(p) - sp;\n        \n        minD = min(minD,d);        \n        if ( d < 0.0){  \n       \t\tbreak;   \n        }        \n        t += 0.08;\n    }    \n    return smoothstep(0.,1.0,minD*shadowHardness);\n}\n\nvec3 skyColor(vec2 uv, float minD){\n \n    float stars = ((1.-noiseLayer(vec3(uv*100.+iTime/40.,0.)))*10.-8. )*0.0f ;\n    \n    float stars2 = (((1.-noiseLayer(vec3(uv*30.+iTime/120.,3.)))*10.-8.8 )*0.0f);\n    \n    vec3 sky = max(0.,1.0) * vec3(0.,0.,0.);\n    sky += max(0.,0.02*10.) * vec3(0.39,0.31,0.35);\n    \n    float halo = (1.-length(uv*0.7)) * 2.;\n        \n    sky *= halo;\n    \n    minD = 1.-minD;\n    minD = pow(minD,3.)*.3;\n    \n    sky += minD * vec3 (0.78,0.79,0.8);\n    \n    return sky;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(skyColor(uv,0.));\n    float minD = 1.; // store minimum distance to make halo ;)\n    \n    float t = 0.0; // travelled distance\n    for (int r = 0; r < 16; ++r)\n    {\n        // current pos    \n        vec3 p = vec3(uv.x,uv.y,-2.+t) ;\n        \n        // sphere distance\n        vec3 pp = normalize(p) * sphereBaseRadius;                 \n        float sp = sphereBaseRadius + map(pp) * dispValue;\n        float d = length(p) - sp;\n\n        minD = min(minD,d);\n        \n        if ( d < 0.01) // if intersect\n        {   \n                        \n            float rayCount = float(r);\n            rayCount /= 16.;\n           \t// color = vec3(rayCount);\n                                    \n            // get normals\n            vec3 n = mix ( calcNormal(pp,0.1), calcNormal(pp,10.), .5);\n            \n            // main light / sun\n            float light1 = max(dot(n,-ld),.0) * 1.2;\n            if (light1 > 0.1){\n            \tlight1 *= shadowRay(p,ld);\n            }\n           \tlight1 += pow(light1,15.)/500.; // fake specular\n            \n            color = vec3(0.78,0.79,0.8) * light1;\n            \n            // secondary light / kick\n           \tcolor += max(dot(n,vec3(0.39,0.31,0.35)),.0) * .15 * vec3 (0.21,0.13,0.17);\n            \n            // lava incandescence\n            color += vec3(0.21,0.13,0.17) * pow(max(.0,-map(pp)+.2),3.) * 8. * max(.0,1.-n.z);\n            \n            // inverse ambient occ\n            color += pow(rayCount,3.) * vec3(0.81,0.49,0.6);  \n            \n            break;\n            \n            \n        }else if( t > 4.){  // if gone too far\n            \n            color = skyColor(uv,minD);\n            break;\n            \n        }\n        \n        t +=d;\n    }\n    \n        \n    fragColor = vec4(color, 1.);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2cD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 201, 201, 289], [291, 291, 321, 321, 442], [444, 444, 474, 474, 594], [597, 597, 623, 657, 1409], [1411, 1411, 1437, 1454, 1883], [1885, 1885, 1903, 1926, 2131], [2133, 2133, 2191, 2191, 2403], [2405, 2405, 2449, 2469, 3096], [3098, 3098, 3133, 3133, 3603], [3605, 3605, 3662, 3681, 5576]], "test": "untested"}
{"id": "msjcD3", "name": "proton  :::. [223 chars]", "author": "ENDESGA", "description": "just an experimental thing while thinking about the 3 quarks of a proton.\n\nfeel free to golf this down even further!", "tags": ["experiment", "golf", "proton"], "likes": 4, "viewed": 218, "published": 3, "date": "1688290298", "time_retrieved": "2024-07-30T17:46:19.337284", "image_code": "// (adjusted) ENDESGA [223 chars]\n#define C(x, y) length( cross( vec3( sin(x), sin(y), 1.5 ), D ) )\n\nvoid mainImage( out vec4 c, vec2 f )\n{\n    float t = iTime*2.;\n\tvec3  R = iResolution, \n          D = vec3(f - R.xy*.5, R.y*.1);\n         \n    c = C(0., 0.) *\n             vec4( C( 0. ,  t ),\n                   C( t - .5 , 0. ),\n                   C( t - 2. , t - 1. ), 1 ) / dot(D,D);\n                      \n\tc = exp( -c * c);\n}\n\n/* // kishimisu [225 chars]\n#define C(x, y) length( cross( vec3( sin(x), sin(y), 1.5 ), D ) )\n\nvoid mainImage( out vec4 c, vec2 f )\n{\n    float t = iTime;\n\tvec3  R = iResolution, \n          D = vec3(f - R.xy*.5, R.y*.2);\n         \n    c = C(0., 0.) *\n             vec4( C( 0. ,  t+t ),\n                   C( t - .5 , 0. ),\n                   C( t*.5 - 1. , t - 2. ), 1 ) / dot(D,D);\n                      \n\tc = exp( -c * c);\n}\n*/\n\n//\n\n/* // SnoopethDuckDuck [228 chars]\n#define C(x, y) length( cross( vec3( sin(x), sin(y), 1.5 ), D ) )\n\nvoid mainImage( out vec4 c, vec2 f )\n{\n    float t = iTime;\n\tvec3 R = iResolution, \n         D = vec3(f - R.xy*.5, R.y*.2),\n         \n         a = C(0., 0.) *\n             vec3( C( 0. ,  t*2. ),\n                   C( t - .5 , 0. ),\n                   C( t*.5 - 1. , t - 2. ) ) / dot(D,D);\n                      \n\tc.rgb = exp( -a * a );\n}\n*/\n\n//\n\n/* // kishimisu [235 chars]\n#define C( a,b ) length( cross( vec3(sin(a), sin(b), 1.5 ), D ) )\n\nvoid mainImage( out vec4 O, in vec2 I)\n{ \n    float t = iTime;   \n    vec3 R = iResolution.xyx,    \n         D = vec3(I - .5 * R.xy, .2*R.y),\n    a = C(0., 0.) //1.5 * length(D.xy)\n\t  * vec3( C(0.,  t+t ),\n\t\t      C( t - .5 , 0.),\n\t\t      C( t/2. - 1. , t - 2. ) ) / dot(D,D);      \n\tO = exp(-a*a).xyzx;\n}\n*/\n\n//\n\n/* // ENDESGA [361 chars]\n#define D vec3( ( f - .5 * iResolution.xy ) / iResolution.y, 0. ) - vec3( 0., 0., -.2 )\n#define C( P ) length( cross( P - vec3( 0., 0., -1. ), D ) ) / length( D )\n#define t iTime* vec3( 4, 2, 1 )\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n\tvec3 a = vec3( C( vec3( 0., 0., .5 ) ) );\n\ta *= vec3( C( vec3( 0., sin( t.x / 2. ), .5 ) ),\n\t\t\t\t\t\t C( vec3( sin( ( t.y - 1. ) / 2. ), 0., .5 ) ),\n\t\t\t\t\t\t C( vec3( sin( ( t.z - 2. ) / 2. ), sin( t.z - 2. ), .5 ) ) );\n\tc = 1. - vec4( 1. - exp( -a * a ), 0. );\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 139, 139, 430]], "test": "untested"}
{"id": "DsScRR", "name": "Experiment Ek", "author": "rohtas", "description": "sdf", "tags": ["sdf"], "likes": 1, "viewed": 134, "published": 3, "date": "1688282536", "time_retrieved": "2024-07-30T17:46:20.155098", "image_code": "const int MAX_STEPS = 20;\nconst float HIT_DISTANCE = 1e-2;\nconst float TRACE_DISTANCE = 20.0;\n// Focal Distance\nconst float focalDistance = 1.5;\n// Scene Geometry\nconst int SPHERE_GRID_RESOLUTION = 3;\nconst int COLUMNS = SPHERE_GRID_RESOLUTION;\nconst int ROWS = SPHERE_GRID_RESOLUTION;\nconst int COUNT = COLUMNS * ROWS;\nconst float SPHERE_RADIUS = 0.2;\nconst float PI = 3.141;\n\nfloat random(float x) {\n  return fract(sin(x) * 43758.5453);\n}\n\nfloat perlinNoise(float x) {\n  float x0 = floor(x);\n  float x1 = x0 + 1.0;\n  \n  float t = x - x0;\n  \n  float r0 = random(x0);\n  float r1 = random(x1);\n  \n  float n0 = mix(r0, r1, smoothstep(0.0, 1.0, t));\n  \n  return n0;\n}\n\nvec3 rotateRayDirection(vec3 rayDirection) {\n  // Get the normalized mouse position\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Convert mouse position to rotation angles\n    float rotationX = mouse.x * 2.0 * 3.14159;\n    float rotationY = mouse.y * 2.0 * 3.14159;\n    \n    // Compute camera rotation matrix\n    mat2 rotationMatrix = mat2(cos(rotationX), -sin(rotationX),\n                               sin(rotationX), cos(rotationX));\n    \n    // Apply camera rotation to the ray direction\n    rayDirection.xy = rotationMatrix * rayDirection.xy;\n    return rayDirection;\n}\n\n// credit: http://erkaman.github.io/glsl-cos-palette/\nvec3 cosPalette(  float t,  vec3 a,  vec3 b,  vec3 c, vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n// Function to retrieve audio data from texture\nvec4 getAudioSample(float position) {\n  vec2 uv = vec2(position / 512., 0.5);\n  return texture(iChannel0, uv);\n}\n\nfloat getFrequencyBand(float frequency) {\n  float bandWidth = 48.;\n  float bandIndex = floor(frequency / bandWidth);\n  float bandStart = bandIndex * bandWidth;\n  float bandEnd = (bandIndex + 1.0) * bandWidth;\n  float bandCenter = (bandStart + bandEnd) * 0.5;\n  return bandCenter;\n}\n\nvec3 applyNormalMap(vec3 p, vec3 n) {\n    return 0.01*n;;\n}\n\nvec3 getSphereCenter(int index) {\n    \n    if ( COUNT == 1 ) {\n        return vec3(0.0, 0.0, 0.);\n    }\n    \n    int colIndex = index % COLUMNS;\n    int rowIndex = index / COLUMNS;\n    float x = (float(colIndex) / float(COLUMNS / 2) - 1.) * iResolution.x / iResolution.y;\n    float y = 1. - float(rowIndex) / float(ROWS / 2);\n    return vec3(x, y, 0.0);\n}\n\n\nvec2 mapTheSpheres(vec3 p, float map) {\n    int mapIndex = -1;\n    for(int i=0; i<COUNT; i+=1) {\n        vec3 location = getSphereCenter(i);\n        vec4 sphere = vec4(location, SPHERE_RADIUS);\n        float distanceToSurface = length(p-sphere.xyz) - sphere.w;\n        if(distanceToSurface < map) {\n            map = distanceToSurface;\n            mapIndex = i;\n        }\n    }\n    return vec2(map, mapIndex);\n}\n\n\nvec2 mapTheStage(vec3 p, float map) {\n    \n    // Plane\n    vec2 zPlane = vec2(0.0, 0.0);\n    \n    // Set Distance\n    float planeDist = zPlane.x - p.z;\n    \n    if(planeDist < map) {\n        return vec2(planeDist, COUNT);\n    } else {\n        return vec2(map, -1);\n    }\n\n}\n\n\n\nvec2 mapTheScene(vec3 p) {\n\n    vec2 map_stage = mapTheStage(p, TRACE_DISTANCE);\n    vec2 map_spheres = mapTheSpheres(p, map_stage.x);\n    vec2 map = map_spheres.y == -1.0 ? map_stage : map_spheres;\n    return map;\n}\n\nvec3 GetNormal(vec3 p) {\n\n    const vec3 small_step = vec3(HIT_DISTANCE, 0.0, 0.0);\n    float gradient_x = mapTheScene(p + small_step.xyy).s - mapTheScene(p - small_step.xyy).s;\n    float gradient_y = mapTheScene(p + small_step.yxy).s - mapTheScene(p - small_step.yxy).s;\n    float gradient_z = mapTheScene(p + small_step.yyx).s - mapTheScene(p - small_step.yyx).s;\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 GetLight(vec3 p, vec3 n, float power) {\n\n    vec3 lightPos = vec3(0., 0., -1.);\n    vec3 lightColor = vec3(1.0);\n    // lightPos.xy += vec2(cos(iTime * 0.2), sin(iTime * 5.8));\n    // lightPos.xz += vec2(sin(1.*iTime), cos(1.*iTime));\n    vec3 l = normalize(lightPos-p);\n    // Diffuse Light\n    float diffuse_intensity = max(0.0, dot(n, l));\n    vec3 lightIntensity = diffuse_intensity*lightColor;\n    return power*lightIntensity;\n}\n\n\n\nvec3 getShader(vec3 p, vec2 uvCoord, vec2 reflectAt) { \n    \n    // Init Color\n    vec3 material = vec3(0.0);\n    \n        \n    // Set Material\n    if(reflectAt.y < float(COUNT)) {\n        material = vec3(0.0, 0.0, 1.0);\n        //material = vec3(0.0, 0.0, 1.0);\n        vec3 closestCenter = getSphereCenter(int(reflectAt.y));\n        float d = distance(p.xy, closestCenter.xy);\n       \n        material = vec3(\n            cosPalette(\n                1.0 - (d / SPHERE_RADIUS)*0.7,\n                vec3(0.31,0.83,0.95),\n                vec3(0.97,1.00,0.00),\n                vec3(0.83,0.64,0.00),\n                vec3(0.92,1.00,0.39)\n             )\n        );\n        d = sin(2.*PI*40.0*d - 5.*iTime);\n        material = material * ( d > 0.5 ? 1.0 : 0.0);    \n    } else {\n    \n        vec2 map = mapTheSpheres(p, TRACE_DISTANCE);\n        vec3 closestCenter = getSphereCenter(int(map.y));\n        float d = distance(p.xy, closestCenter.xy) - SPHERE_RADIUS;\n        \n        if(d < 0.02) {\n          material = vec3(sin(2.0*PI*d + iTime) + 0.8\n          );\n        } else if (d < 0.03) {\n           material = vec3(1.0, 1.0, 0.0);\n        } else {\n           \n            material = vec3(1.0, 0.0, 0.0);\n            \n            // Animation progress between 0 and 1\n            // float progress = mod(iTime * 1.0, 1.0); \n            // Convert progress to sample position\n            //float samplePosition = progress * 512.; \n            //  float waveform = getAudioSample(samplePosition).r;\n            // vec3 audioPalette = cosPalette(\n            //    waveform * 5.,\n            //    vec3(0.8,0.5,0.4),\n            //    vec3(0.2,0.4,0.2),\n            //    vec3(1.0,1.0,1.0),\n            //    vec3(0.0,0.25,0.25)\n            // );\n            // material += (audioPalette * 5.0 * d); \n            \n            material = material * (1.0 - 3.5*d);\n            d = (1.0 - abs(sin(2.*PI*20.0*d - iTime))) <0.3 ? 0. : 1.;\n            material = material*d;\n        }\n    }\n    // Filter\n    return material;\n}\n\n\n\nvec3 RayMarch(vec3 rayOrigin, vec2 uvCoord) {\n    // Define State Variables\n    vec3 intersectionAtImagePlane = vec3(uvCoord, focalDistance);\n    vec3 rayDirection = normalize(intersectionAtImagePlane);\n    // Rotate Ray Direction\n    if (iMouse.z > 0.0) {\n        rayDirection = rotateRayDirection(rayDirection);\n    }\n    // Run Accumulator \n    float distanceToScene = 0.0;\n    vec3 p = vec3(0.0);\n    // Set Environment Lighting\n    vec3 light = vec3(0.0);\n    vec3 color = vec3(0.0);\n    // Get March on the Scene and Set Color\n    for(int i=0; i<MAX_STEPS;i+=1) {\n        p = rayOrigin + distanceToScene * rayDirection;\n        vec2 reflectAt = mapTheScene(p);\n        vec3 n = GetNormal(p);\n        distanceToScene += reflectAt.x;\n        if(reflectAt.x<HIT_DISTANCE) {\n            // Get Light\n            color = GetLight(p, n, 2.50);\n            // Get Material\n            color = color*getShader(p, uvCoord, reflectAt);\n            // Get Sound Effect\n            // vec3 sound = getSoundEffect(uvCoord);\n            // color = color+(0.1*sound);\n            break;\n        }\n        if(distanceToScene > TRACE_DISTANCE) {\n            break;\n        }\n    }\n    // Return the color at raymarch\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvCoord = fragCoord.xy / iResolution.xy;\n    // Translate origin to center and scale coordinates to -1 to 1\n    uvCoord = (uvCoord - 0.5) * 2.0;\n    \n    // Scale coordiantes to aspect ratio\n    uvCoord.x *= iResolution.x / iResolution.y;\n    \n    // Save Original Value\n    vec2 uv0 = uvCoord;\n    \n    // Locate the camera\n    vec3 p = vec3(0, 0, -2);\n    // Run the RayMarcher renderer\n    vec3 color = RayMarch(p, uvCoord);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsScRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 378, 401, 401, 440], [442, 442, 470, 470, 664], [666, 666, 710, 749, 1251], [1253, 1307, 1370, 1370, 1413], [1416, 1464, 1501, 1501, 1576], [1578, 1578, 1619, 1619, 1859], [1861, 1861, 1898, 1898, 1920], [2280, 2280, 2319, 2319, 2691], [2694, 2694, 2731, 2749, 2968], [2972, 2972, 2998, 2998, 3188], [3190, 3190, 3214, 3214, 3649], [3651, 3651, 3695, 3695, 4089], [4093, 4093, 4147, 4171, 6109], [6113, 6113, 6158, 6188, 7338], [7341, 7341, 7398, 7448, 7949]], "test": "untested"}
{"id": "ddBcRm", "name": "Clouds 2136", "author": "ArmandB", "description": "who needs volumetrics anyways?\nwasd + space + shift to move\nmouse to pan\ngo to common to mess with the variables", "tags": ["3d"], "likes": 4, "viewed": 286, "published": 3, "date": "1688272921", "time_retrieved": "2024-07-30T17:46:21.518452", "image_code": "//cloud color gradients (rgb = color, a = color mid point)\nconst vec4 cloudLit[] = vec4[](\n    vec4(0.7,0.7,0.8,0.2),\n    vec4(0.8,0.3,0.4,0.25),\n    vec4(1,0.95,0.9,0.3),\n    vec4(1,0.95,0.9,0.7),\n    vec4(0.8,0.3,0.4,0.75),\n    vec4(0.7,0.7,0.8,0.8),\n    vec4(0.7,0.7,0.8,1)\n);\n\nconst vec4 cloudShadowed[] = vec4[](\n    vec4(0.4,0.4,0.5,0.2),\n    vec4(0.5,0.3,0.4,0.25),\n    vec4(0.7,0.7,0.8,0.3),\n    vec4(0.7,0.7,0.8,0.7),\n    vec4(0.5,0.3,0.4,0.75),\n    vec4(0.4,0.4,0.5,0.8),\n    vec4(0.4,0.4,0.5,1)\n);\n\n//gets a color at a position on a gradient\nvec3 grad(vec4[7] grad, float x){\n    x = fract(x);\n    for (int i = 0; i < grad.length(); i++){\n        if (grad[i].a > x){\n            vec4 gradStart = grad[i - 1];\n            vec4 gradEnd = grad[i];\n            return mix(gradStart.rgb,gradEnd.rgb,smoothstep(gradStart.a,gradEnd.a,x));\n        }\n    }\n}\n\n//samples the cloud renderer using a median filter (sort of) for the nice smoothing\nvec4 medianSampler(in vec2 uv, in vec2 ires, in int radius){\n    vec4 avg = vec4(0);\n    float elements = pow(float(radius*2 + 1),2.0);\n    for (int x = -radius; x <= radius; x++){\n        for (int y = -radius; y <= radius; y++){\n            avg += texture(iChannel1, (uv + vec2(x,y)/ires)*(min(res,iResolution.xy)/ires));\n        }\n    }\n    avg /= elements;\n    \n    vec4 data = vec4(0.0);\n    float dist = 999.0;\n    for (int x = -radius; x <= radius; x++){\n        for (int y = -radius; y <= radius; y++){\n            vec4 pxcol = texture(iChannel1, (uv + vec2(x,y)/ires)*(min(res,iResolution.xy)/ires));\n            float d = abs((pxcol.x - avg.x)*(pxcol.y - avg.y));\n            if (d < dist){\n                data = pxcol;\n                dist = d;\n            }\n        }\n    }\n    data.z = avg.z;\n    return data;\n}\n\n//renders a lens flare\nvec3 renderLensFlare(vec3 rd, vec3 light, vec3 position, vec3 rotation, vec2 uv){\n    vec3 lr = rotate3dbackwards(-light,rotation,vec3(0));\n    if (lr.z > 0.0){\n        vec2 luv = lr.xy*cameraFrustum/lr.z;\n        float ld = distance(luv,uv);\n        vec2 ln = (luv-uv)/ld;\n                \n        //ghosts\n        vec3 ghosts = vec3(0);\n        ghosts += renderhex(uv, -luv*0.25, 0.35, vec3(0.25,0.75,0));\n        ghosts += renderhex(uv, luv*0.25, 0.125, vec3(1,0.5,0.5));\n        ghosts += renderhex(uv, luv*0.1, 0.4, vec3(1,1,1));\n        ghosts += renderhex(uv, luv*1.8, 0.5, vec3(0,0.5,0.75));\n        ghosts += renderhex(uv, luv*1.25, 0.2, vec3(1,1,0.5));\n        ghosts += renderhex(uv, -luv*1.25, 1.25, vec3(0.5,0.5,0.25));\n        ghosts += fpow(1.0 - abs(distance(luv*0.8,uv) - 0.35),0.985)*vec3(0.15,0.1,0);\n        \n        float flare = fpow(textureLod(iChannel2,ln*0.25,0.0).r,0.3)*0.01/ld;\n        float bloom = fpow(max(1.01 - ld,0.0),0.9);\n        \n        return (ghosts/(1.0 + distance(uv,luv)) + vec3(1.0,0.8,0.1)*min(bloom + flare,1.0));\n    }\n    return vec3(0);\n}\n\nvec3 getSkyColor(vec3 dir){\n    vec3 skycol = vec3(0);\n    vec3 water = vec3(0.3,0.4,0.8);\n    vec3 sky = vec3(0,0.6,1);\n    vec3 haze = vec3(0.9,0.9,0.9);\n    if (dir.y < 0.0) {\n        skycol = mix(haze, water, clamp(-dir.y,0.0,1.0));\n    } else {\n        skycol = mix(haze, sky, clamp(dir.y,0.0,1.0));\n    }\n    return skycol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n    Ray ray = cam.ray;\n    float t = fract(texelFetch(iChannel0, ivec2(6,0),0).w);\n    vec3 lightDirection = texelFetch(iChannel0, ivec2(6,0),0).xyz*(t > 0.25 && t < 0.75 ? 1.0 : -1.0);\n    vec3 col = vec3(0);\n        \n    //sample cloud render\n    vec4 renderdata = medianSampler(fragCoord/iResolution.xy, iResolution.xy, medianRadius);\n    float shadow = max(renderdata.x,0.0); //used to determine cloud base color\n    float depth = renderdata.y; //used to blend sky and cloud at distance\n    float density = renderdata.w;\n    float hit = renderdata.z;\n    vec3 point = depth*ray.direction + position;\n    //from https://advances.realtimerendering.com/s2015/The%20Real-time%20Volumetric%20Cloudscapes%20of%20Horizon%20-%20Zero%20Dawn%20-%20ARTR.pdf\n    float densshade = (1.0 - pow(2.0,-2.0*density))*0.3 - 0.2;\n\n    //cloud colors\n    float lining = fpow(max(dot(ray.direction,-lightDirection),0.0),0.8);\n    col = mix(grad(cloudLit,t), grad(cloudShadowed,t), clamp(shadow - lining - densshade,-0.5,1.0));\n    //fade out at distance\n    col = mix(col,getSkyColor(ray.direction),clamp(depth/far,0.0,1.0));\n\n    //sun effects\n    vec3 flare = renderLensFlare(ray.direction, lightDirection, position, rotation, cam.uv);\n    col += max(flare/(1.0 + shadow*10.0),0.0);\n    \n    fragColor = col.rgbb;\n    //fragColor = vec4(hit);\n}\n\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//resolution to render clouds at (must be less than or equal to screen res)\n#define res vec2(800,450)\n//sets smoothing (higher res screen = use more smoothing)\n#define medianRadius 2 \n\n#define PI 3.14159265\n#define maxsteps 512\n#define maxlightsteps 16\n#define far 500.0\n#define cameraFrustum 0.7\n\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    vec2 uv;\n    mat3 transmat;\n};\n\nstruct Hit {\n    bool hit;\n    float dist;\n    vec3 point;\n    float shadow;\n    float density;\n};\n\n//fakes x^n for specular effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3dbackwards(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= inverse(rotationMatrix(angle)); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//https://iquilezles.org/articles/noacos/\nmat3 rotationAlign(vec3 d, vec3 z){\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0f/(1.0f+c);\n\n    return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                 v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                 v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    vec3 uvd = normalize(uv);\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 ro = uv*rotmat + cameraPos;\n    vec3 rd = uvd*rotmat;\n    mat3 rottomat = rotationAlign(uvd,vec3(0,0,1));\n    mat3 TransitionMatrix = mat3(\n        vec3(1,0,0)*rottomat*rotmat, \n        vec3(0,1,0)*rottomat*rotmat, \n        vec3(0,0,1)*rottomat*rotmat\n    );\n    return Camera(cameraPos, Ray(ro, rd), uv.xy, TransitionMatrix);\n}\n\nfloat smin( float a, float b, float k){\n     float h = max(k-abs(a-b), 0.0)/k;\n     return min(a, b) - h*h*k*0.25;\n}\n\nfloat sdHex(vec2 p){\n    p = abs(p);\n\tvec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n\treturn dot(step(q.xy,q.yx), 1.0-q.yx);\n}\n\nvec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n    uv -= p;\n    if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n        return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.3,sdHex(uv*5.0/s)));\n    }\n    return vec3(0);\n}", "buffer_a_code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0.35,0.09).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity*iTimeDelta*60.0;\n        \n        if (position.y < -500.0){\n            position = vec3(0,24,0);\n        }\n        \n        if (iFrame == 0){\n            position = vec3(0,-40,0);\n        }\n        col.xyz = position;\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nfloat hash13(vec3 p3){\n  p3 = floor(p3);\n  p3 = fract(p3*0.1031);\n  p3 += dot(p3, p3.zyx + 31.32);\n  return fract((p3.x + p3.y)*p3.z);\n}\n\n//3d noise from texture\nfloat noise(vec3 p){\n  p -= 0.5;\n  vec3 i = p - floor(p); //interpolant\n  vec2 o = vec2(0.0, 1.0);\n\n  float r0 = hash13(p + o.xxx);\n  float r1 = hash13(p + o.yxx);\n  float r2 = hash13(p + o.xyx);\n  float r3 = hash13(p + o.yyx);\n  float r4 = hash13(p + o.xxy);\n  float r5 = hash13(p + o.yxy);\n  float r6 = hash13(p + o.xyy);\n  float r7 = hash13(p + o.yyy);\n\n  vec3 k = smoothstep(0.0,1.0,i);\n  float k1 = mix(r0,r1,k.x);\n  float k2 = mix(r2,r3,k.x);\n  float k3 = mix(r4,r5,k.x);\n  float k4 = mix(r6,r7,k.x);\n\n  float c1 = mix(k1,k2,k.y);\n  float c2 = mix(k3,k4,k.y);\n\n  return mix(c1,c2,k.z);\n}\n*/\n\n//3d noise from texture\nfloat noise(vec3 p){\n  p -= 0.5;\n  vec3 i = p - floor(p); //interpolant\n  vec2 o = vec2(0.0, 1.0);\n\n  float r0 = texelFetch(iChannel1, ivec3(mod(p + o.xxx,32.0)),0).r;\n  float r1 = texelFetch(iChannel1, ivec3(mod(p + o.yxx,32.0)),0).r;\n  float r2 = texelFetch(iChannel1, ivec3(mod(p + o.xyx,32.0)),0).r;\n  float r3 = texelFetch(iChannel1, ivec3(mod(p + o.yyx,32.0)),0).r;\n  float r4 = texelFetch(iChannel1, ivec3(mod(p + o.xxy,32.0)),0).r;\n  float r5 = texelFetch(iChannel1, ivec3(mod(p + o.yxy,32.0)),0).r;\n  float r6 = texelFetch(iChannel1, ivec3(mod(p + o.xyy,32.0)),0).r;\n  float r7 = texelFetch(iChannel1, ivec3(mod(p + o.yyy,32.0)),0).r;\n\n  vec3 k = smoothstep(0.0,1.0,i);\n  float k1 = mix(r0,r1,k.x);\n  float k2 = mix(r2,r3,k.x);\n  float k3 = mix(r4,r5,k.x);\n  float k4 = mix(r6,r7,k.x);\n\n  float c1 = mix(k1,k2,k.y);\n  float c2 = mix(k3,k4,k.y);\n\n  return mix(c1,c2,k.z);\n}\n\n/*vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}*/\n\n/*vec3 hash33(vec3 p3){\n    return texelFetch(iChannel3,ivec3(mod(p3,32.0)),0).xyz;\n\n}\n\nfloat noise(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n            for (int z = -1; z <= 1; z++){\n                vec3 d = floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)) - uv;\n                n = min(n,dot(d,d));\n            }\n        }\n    }\n    return sqrt(n);\n}*/\n\n/*//thanks fad (same function as above, but using hardware interpolation (less accurate))\nfloat noise(vec3 p){\n    vec3 s = vec3(textureSize(iChannel1, 0));\n    p /= s;\n    p = p*s - 0.5;\n    return texture(iChannel1, (floor(p) + smoothstep(0.0, 1.0, fract(p)) + 0.5)/s).r;\n}*/\n\n//sigmoid wave similar to cos\nfloat fcos(float x){\n  x = abs(2.0*fract(x) - 1.0)/(2.0*PI);\n  return 2.0*x*x*(3.0 - 2.0*x) - 1.0;\n}\n\n//cloud sdf\nfloat sceneSdf(vec3 p){\n    p.x += iTime;\n    float v0 = noise(p/64.0 + vec3(fcos(iTime*0.02 - PI/2.0),0,fcos(iTime*0.02)));\n    if (v0 > 0.7) return 5.0;\n    float v1 = noise(p/16.0 + v0);\n    float v2 = noise(p/4.0 + v1);\n    float v3 = noise(p);\n    float highcloud = p.y*0.6 - 40.0;\n    float yshape = min(max(-0.2*p.y, 0.07*p.y), highcloud*highcloud + 0.2);\n    float n = v0*4.0 + v1*2.0 + v2*v1 + v3*v2*0.25 - 2.5 + yshape;\n    return n/2.0;\n}\n\n//cloud raymarcher\nHit marchRay(Ray ray, vec3 lightDir){\n    vec3 pos = ray.origin;\n    vec3 dir = ray.direction;\n    float t = 0.0;\n    bool hit = false;\n    float multiplier = 1.5;\n    \n    //depth cast\n    for(int i = 0; i < maxsteps; i++){ \n        if (t >= far || (pos.y > 70.0 && dir.y > 0.0) || (pos.y < -15.0 && dir.y < 0.0)) break;\n        if (i == maxsteps-1) pos = dir*10.0;\n        float sdf = sceneSdf(pos);\n        if (sdf <= 0.01){\n            hit = true;\n            break;\n        }\n        t += abs(sdf)*(multiplier + t*0.001);\n        pos += dir*abs(sdf)*(multiplier + t*0.001);\n    }\n    \n    if (hit){\n        vec3 lightpos = pos;\n        float shadow = 0.0;\n\n        //shadow cast\n        for(int i = 0; i < maxlightsteps; i++){\n            float sdf = sceneSdf(lightpos);\n            if (lightpos.y > 70.0 || lightpos.y < -15.0) break;\n            if (sdf < 0.0){\n                shadow += -sdf;\n            }\n            lightpos += -lightDir*0.5;\n        }\n        \n        vec3 pos2 = pos;\n        float density = 0.0;\n\n        //density cast\n        for(int i = 0; i < maxlightsteps; i++){\n            float sdf = sceneSdf(pos2);\n            if (pos2.y > 70.0 || pos2.y < -15.0) break;\n            if (sdf < 0.0){\n                density += -sdf;\n            }\n            pos2 += dir*0.5;\n        }\n        \n        //hit\n        return Hit(hit, t, pos, sqrt(shadow), density);\n    }\n    //no hit\n    return Hit(hit, far, pos, 0.5, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //limit resolution\n    if (fragCoord.x > min(res.x,iResolution.x) || fragCoord.y > min(res.y,iResolution.y)) return;\n    //cam setup\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, min(res,iResolution.xy), position, rotation, cameraFrustum);\n    Ray ray = cam.ray;\n    float t = fract(texelFetch(iChannel0, ivec2(6,0),0).w);\n    vec3 lightDirection = texelFetch(iChannel0, ivec2(6,0),0).xyz*(t > 0.25 && t < 0.75 ? 1.0 : -1.0);\n\n    //raymarch\n    Hit hit = marchRay(ray, lightDirection);\n\n    fragColor = vec4(hit.shadow, hit.dist, hit.hit, hit.density);\n}", "buffer_b_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[862, 946, 1006, 1006, 1770], [1772, 1795, 1876, 1876, 2882], [2884, 2884, 2911, 2911, 3215], [3217, 3217, 3273, 3273, 4851]], "test": "untested"}
{"id": "cd2cWc", "name": "Goldilocks Sunrise", "author": "matheusgirola", "description": "A nice simple shader that I was playing with that turns out to make some goldilock shapes, hope you like it", "tags": ["shader"], "likes": 2, "viewed": 140, "published": 3, "date": "1688270331", "time_retrieved": "2024-07-30T17:46:22.276426", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette( float t )\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 0.5);\n    vec3 d = vec3(0.80, 0.90, 0.30);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n\n    vec2 pos = fract(uv*0.5) - uv;\n    float r = length(pos)*2.;\n    float a = atan(pos.y,uv.x);\n\n    float f = abs(sin(a*(9000. + iTime)));\n    f = pow(0.9/(f/abs(sin((200. + iTime)*a))*r), 100.);\n    col = vec3(palette(0.3)-smoothstep(f,f+ abs(sin(0.5)), palette(0.2)*r) );\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2cWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 64, 64, 247], [249, 249, 306, 356, 737]], "test": "untested"}
{"id": "cdjyD3", "name": "TomYum sea food", "author": "chenxianming", "description": "see you", "tags": ["raymarching", "cineshader"], "likes": 3, "viewed": 1274, "published": 3, "date": "1688264247", "time_retrieved": "2024-07-30T17:46:23.034399", "image_code": "float e(float a) { return fract(iTime * a) * 3.141593 * 4.; } \nint t = 0; \nfloat n(float a, float b, float c) { float d = clamp(.5 + .5 * (b - a) / c, 0., 1.); return mix(b, a, d) - c * d * (1. - d); } \nmat2 k(float a) { float b = sin(a), c = cos(a); return mat2(c, b, -b, c); } \nfloat z(in vec2 a, in float c) { const vec3 b = vec3(-.92388, .382683, .414214); a = abs(a), a -= 2. * min(dot(vec2(b.x, b.y), a), 0.) * vec2(b.x, b.y), a -= 2. * min(dot(vec2(-b.x, b.y), a), 0.) * vec2(-b.x, b.y), a -= vec2(clamp(a.x, -b.z * c, b.z * c), c); return length(a) * sign(a.y); } \nfloat A(vec3 a, float c) { vec2 b = a.xy; b *= k(e(.25)), b.x += cos(a.z + e(.25) * c) * .3, b.y += sin(a.z + e(.25) * c) * .3; \nreturn max(z(b, .05), abs(a.z) - 20.); } vec2 B(in vec2 a, float c) { float b = 6.283185 / c, d = (atan(a.y, a.x) + b * .5) / b, f = floor(d), g = b * f; a *= k(g); return a; } float o(vec3 a, float d, float b) { float c = 0.; a.yz *= k(.502655), a.xy *= k(-e(.025) + b * 3.141593), a.xy = B(a.xy, 10.), c = A(a - vec3(d, 0, 0), b); return c; } vec4 l = vec4(0), h = vec4(0); float i(vec3 b) { float a = 5.; a = n(a, o(b, 1.2, 0.), .1), a = n(a, o(b, 1.5, 1.5), .1), a = n(a, o(b, 2.5, 2.), .1), t == 1 ? l.a = a : h.a = a; return a; } vec3 p(in vec3 b) { vec2 a = vec2(1, -1) * .5773; return normalize(a.xyy * i(b + a.xyy * 5e-4) + a.yyx * i(b + a.yyx * 5e-4) + a.yxy * i(b + a.yxy * 5e-4) + a.xxx * i(b + a.xxx * 5e-4)); } vec3 q(vec2 a) { vec2 b = a.xy - .5, c = b.xy * b.xy + sin(a.x * 18.) / 25. * sin(a.y * 7. + 1.5) + a.x * sin(0.) / 16. + a.y * sin(1.2) / 16. + a * fract(iTime - .5); float d = sqrt(abs(c.x + c.y * .5) * 25.) * 5.; return vec3(sin(d * 1.25 + 2.), abs(sin(d * 1. - 1.) - sin(d)), abs(sin(d) * 1.)); } float u(inout vec3 b, inout float c, inout float a, vec3 d, vec3 f, int m) { if (m == 1000) for (int g = 0; g < 256; g++) { b = d + f * a, c = i(b); if (a > 1000.) break; a += c * .111112; } else for (int j = 0; j < 32; j++) { b = d + f * a, c = i(b); if (a > 1000.) break; a += c * .333332; } return 1.; } void v(vec3 w, vec3 b) { t++; float x = 0., y = 0., j = 0.; vec3 m = normalize(vec3(.57703)); m.xy *= k(e(.5)); vec3 r = normalize(m - b), c = vec3(0); y = u(c, j, x, w, b, 1000); if (j < 1e-3) { vec3 a = p(c); float E = dot(a, vec3(0, -.3, 0)), d = clamp(dot(a, vec3(.5, .5, -.3)), 0., 1.), s = clamp(dot(a, vec3(0, -.5, .3)), 0., 1.), C = clamp(dot(a, vec3(.5, -1.1, -5.1)), 0., 1.), f = pow(clamp(dot(a, r), .52, 2.), 10.); f *= d + s; vec3 g = reflect(a, b * .2); h.rgb = d * q(g.xy) + s * q(g.xy) + C * q(g.xy) * .15, h.rgb += sign(h.rgb) * .6, b = reflect(b, a), y = u(c, j, x, w, b * .04, 128), a = p(c), d = clamp(dot(a, vec3(.5, .5, -.3)), 0., 1.), f = pow(clamp(dot(a, r), .52, 2.), 10.), f *= d + s, g = reflect(a, b * .3), h.rgb += vec3(f * vec3(.5)) + (.5 + .35 * cos(d + e(.25) + b.xyx * 2. + vec3(0, 2, 4))) * .2; } } \n\nfloat D(vec2 a) { \n\n    a.x += cos( e( .125 ) ) * .3;\n    a.y += sin( e( .125 ) ) * .3;\n    \n    a = mod( a, 1. ) - .5;\n\n    float d =  length( a ) - .5;\n    \n    d = max(\n        d,\n        -( length( a ) - .1 )\n    );\n\n    return d;\n\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ \n    vec2 b = fragCoord.xy / iResolution.xy; b = (b - .5) * 2., b.x *= iResolution.x / iResolution.y; vec3 a = vec3(.1), d = vec3(0, 0, -5), c = vec3(b, 2); \n    c.x += cos(e(.25)) * .1, c.z += sin(e(.25)) * .12; \n    vec3 col = vec3( .1 );\n    v(d, c); // raymarching outline\n    c.xy *= 1.03; // outline width\n    v(d, c); // raymarching inline\n    \n    // draw outline\n    l.a = mix(\n      l.a,\n      1.,\n      h.a\n    );\n    \n    // normalized pixel depth\n    l.a = clamp( l.a, 0., 1. ),h.a = clamp( h.a, 0., 1. );\n    \n    // mix background through path\n    col = mix(\n        vec3( 0.00, 0.99, 1.00 ),\n        vec3(1.),\n        step( D( b ), 0. )\n    );\n    \n    // draw outline to pixel\n    col = mix(\n        col,\n        vec3( 0. ),\n        l.a\n    );\n    \n    // put rshape pixel\n    col = mix(\n        col,\n        h.rgb,\n        1. - h.a\n    );\n    \n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [75, 75, 111, 111, 201], [203, 203, 220, 220, 278], [280, 280, 312, 312, 571], [573, 573, 599, 599, 742], [743, 743, 771, 771, 878], [879, 879, 914, 914, 1046], [1078, 1078, 1095, 1095, 1237], [1238, 1238, 1257, 1257, 1426], [1427, 1427, 1443, 1443, 1727], [1728, 1728, 1804, 1804, 2034], [2035, 2035, 2059, 2059, 2867], [2870, 2870, 2887, 2887, 3107], [3111, 3111, 3167, 3167, 4061]], "test": "untested"}
{"id": "cs2cW3", "name": "Two Body Apollonian and Conics", "author": "bcourter", "description": "Apollonian circles and conic sections via the two-body field.  Illustration for: https://www.blakecourter.com/2023/07/01/two-body-field.html", "tags": ["sdf", "ugf", "twobody"], "likes": 3, "viewed": 833, "published": 3, "date": "1688263522", "time_retrieved": "2024-07-30T17:46:23.989845", "image_code": "// Apollonian and conic two-body fields\n// Illustration for: https://www.blakecourter.com/2023/07/01/two-body-field.html\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat offset = 0.5;\nvec2 direction = vec2(1.0, 1.0);\nint viz = 0;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    \n    float interp = clamp(width * 0.5 - abs(a.Distance) / length(a.Gradient), 0.0, 1.);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    if (a.Distance <= 0.0)\n        return mix(opColor, a.Color, a.Color.a);\n\n    return opColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    offset = readFloat(0.);\n    viz = int(readFloat(1.) * 2.);\n    \n    vec2 p = fragCoord - 0.5 * iResolution.xy; // * iResolution.xy;\n    \n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    float paddingAmt = 0.33;\n    float padding = iResolution.x * paddingAmt; // * (0.3 + cos(iTime) * 0.05);\n    float size = iResolution.x * (0.5 - paddingAmt) * sin(iTime) * offset;   \n    \n    Implicit a;\n    vec2 aCenter = vec2(padding, iResolution.y / 2.0);\n    float aRadius = size;\n    vec4 red = vec4(1., 0., 0., 1);\n    switch (viz) {\n    case 0:\n        a = Circle(fragCoord, aCenter, aRadius, red);\n        break;\n    default:\n        a = Plane(fragCoord, aCenter + vec2(aRadius, 0.), vec2(1, 0), red);\n    }\n \n    \n    Implicit b = Circle(fragCoord, vec2(iResolution.x - padding, iResolution.y / 2.0), -size, vec4(0., 0., 1., 1));\n    \n    Implicit shapes = Min(a, b);\n    Implicit sum = Add(a, b);   \n    Implicit diff = Subtract(a, b);\n    Implicit interp = Divide(diff, sum);\n    \n    opColor = min(\n        drawImplicit(Multiply(interp, 100.), opColor),\n        drawImplicit(Multiply(Subtract(1., Abs(interp)), 100.), opColor)\n    );\n \n \n    if (shapes.Distance < 0.)\n        opColor.rgb = min(opColor.rgb, opColor.rgb * 0.65 + shapes.Color.rgb * 0.2);\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n //   opColor = DrawVectorField(p3, Divide(shape, length(shape.Gradient)), opColor, 25., 1.);\n    \n    fragColor = opColor;\n}\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloatCentered(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloatCentered(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 2.));\n    if (data.r * 2. < increment) {\n        _A P O L L O N I A N\n    }\n    else {\n        _C O N I C S\n    }\n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,0.0,1)  _V I S U A L I Z A T I O N      \n    EASYSLIDER(0,0.2)  _W I G G L E\n//    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 bounds = vec4(30,100,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Mod(Implicit iImplicit, float iM)\n{\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n //   centered = rot * centered;\n    size *= 0.5;\n    \n    Implicit x = Plane(centered, vec2(0.), rot * vec2(-1., 0.), color);\n    Implicit y = Plane(centered, vec2(0.), rot * vec2(0., -1.), color);\n    Implicit cornerA = Subtract(Max(x, y), size);\n    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);\n   \n\treturn IntersectionEuclidean(cornerA, cornerB, 0.);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n\n// Viz\nvec4 DrawVectorField(vec3 p, Implicit iImplicit, vec4 iColor, float iSpacing, float iLineHalfThick)\n{\n\tvec2 spacingVec = vec2(iSpacing);\n\tvec2 param = mod(p.xy, spacingVec);\n\tvec2 center = p.xy - param + 0.5 * spacingVec;\n\tvec2 toCenter = p.xy - center;\n\n\tfloat gradParam = dot(toCenter, iImplicit.Gradient.xy) / length(iImplicit.Gradient);\n\tfloat gradLength = length(iImplicit.Gradient);\n\t\n\tbool isInCircle = length(p.xy - center) < iSpacing * 0.45 * max(length(iImplicit.Gradient.xy) / gradLength, 0.2);\n\tbool isNearLine = abs(dot(toCenter, vec2(-iImplicit.Gradient.y, iImplicit.Gradient.x))) / gradLength < iLineHalfThick + (-gradParam + iSpacing * 0.5) * 0.125;\n\t\n\tif (isInCircle && isNearLine)\n\t\treturn vec4(iColor.rgb * 0.5, 1.);\n\n\treturn iColor;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2cW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 346, 378, 378, 467], [468, 468, 497, 497, 575], [577, 577, 634, 634, 851], [853, 853, 895, 895, 1360], [1362, 1362, 1403, 1403, 1471], [1473, 1473, 1514, 1514, 1613], [1615, 1615, 1670, 1670, 3320]], "test": "untested"}
{"id": "cd2yW3", "name": "Polaris Star Trails", "author": "13rac1", "description": "Long exposure of star trails around Polaris, the North Star, Click/tap mouse to move the star, drag for pointless rotations.", "tags": ["camera", "space", "stars"], "likes": 4, "viewed": 187, "published": 3, "date": "1688262173", "time_retrieved": "2024-07-30T17:46:24.847551", "image_code": "/*\n * Polaris Star Trails\n * \n * My first shader\n *\n * Inspired by:\n * https://www.rmg.co.uk/sites/default/files/styles/large/public/2023-06/BN-256390-11%20Radio%20Polaris%20by%20Jo%C3%A3o%20Yordanov%20Serralheiro.jpg?itok=nlSUd2Ms\n * https://image.winudf.com/v2/image/Y29tLkRyZWFtV2FsbHBhcGVycy5TdGFyVHJhaWwwMV9zY3JlZW5zaG90c18zXzU5NGJhZmQ3/screen-3.jpg?fakeurl=1&type=.jpg\n */\n\n#define PI 3.1415926538\n#define TWOPI 2.0 * PI\n#define VIEW_SCALE 13.0\n#define TRAIL_COUNT 60.0\n// Radian length of the star trails, aka \"exposure time\"\n#define TRAIL_RAD TWOPI * 0.05\n#define TRAIL_LAYERS 18.0\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n\n// Screen Blend Mode\n// src: https://www.shadertoy.com/view/4tSGWV\nvec3 screen(vec3 target, vec3 blend){\n    return 1.0 - (1.0 - target) * (1.0 - blend);\n}\n\n// src: https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( TWOPI*(c*t+d) );\n}\n\nvec3 pSky(in float t) {    \n    // [[0.138 0.668 0.408] [0.000 0.500 0.500] [0.000 0.178 0.178] [0.000 0.338 1.148]]    \n    return palette(t,\n        vec3(0.138, 0.668, 0.408),\n        vec3(0.000, 0.500, 0.500),\n        vec3(0.000, 0.178, 0.178),\n        vec3(0.000, 0.338, 1.148)\n    );\n}\n\nvec3 pStars(in float t) {        \n    // [[0.718 0.718 1.388] [-0.922 -0.922 0.725] [-0.060 -0.060 1.028] [0.738 0.738 -0.072]]\n    return palette(t,\n        vec3(0.718, 0.718, 1.388),\n        vec3(-0.922, -0.922, 0.725),\n        vec3(-0.060, -0.060, 1.028),\n        vec3(0.738, 0.738, -0.072)\n    );\n}\n\nvec3 drawStarTrail(vec2 randSeed, float starTrail, float trailId, float dist, vec2 cStarUv) {\n    // Not all of them\n    if (random(sin(randSeed)) < 0.3) {\n        return vec3(0);\n    }\n\n    // TEST - Change all star trail starts with time\n    //float radStart = mod(0.0 + iTime, TWOPI);\n    // Radians around the circle where the star starts    \n    float radStart = random(cos(randSeed)) * TWOPI;\n    // starRadStart will never be greater than TWOPI, but starRadEnd can be\n    float radEnd = radStart + TRAIL_RAD;\n\n    // Find the coordinates of the star trail start\n    vec2 posStart = vec2(dist * cos(radStart), dist * sin(radStart));\n    // Find the coordinates of the star trail end\n    vec2 posEnd = vec2(dist * cos(radEnd), dist * sin(radEnd));\n\n    // Find the angle of the current coord, range [0, TWOPI]\n    float radCurrent = PI + atan(cStarUv.y, cStarUv.x);\n    // Find the coordinates of the current star trail\n    vec2 posCurrent= vec2(dist * cos(radCurrent), dist * sin(radCurrent));\n\n    // If the current is less than the start value, then atan() looped.\n    if (radCurrent < radStart) {\n        // Add TWOPI to also push it out of bounds.\n        // range [0, TWOPI + TRAIL_RAD]\n        radCurrent += TWOPI;\n    }\n\n    // Return nothing if we are anywhere other than the star trail\n    if (radStart > radCurrent || radCurrent > radEnd) {\n        return vec3(0);\n    }\n    \n    // Find a reasonable star trail edge fade lenth\n    // TODO: Is there a better option for this calculation?\n    float edgeSize = sqrt(dist/1000.0);\n    \n    // Find the start/end edge distance\n    float edgeStart = distance(posStart, posCurrent);\n    float edgeEnd = distance(posCurrent, posEnd);\n    \n    // Default to no fade\n    float edgeDistance = 1.0;\n    // Fade near the start and end to avoid flat edges to star trails\n    if (edgeStart < edgeSize) {\n        edgeDistance = edgeStart/edgeSize;\n    }\n    else if (edgeEnd < edgeSize) {\n        edgeDistance = edgeEnd/edgeSize;\n    }\n    \n    // Fill star trail\n    float rand = random(randSeed * trailId);\n    // Fade out the selected color by distance to all edges\n    return edgeDistance * pow(starTrail+0.1,2.0) * pStars(rand);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Find the diviser to handle vertical and horizontal screens.\n    float resolutionDiviser = min(iResolution.y,iResolution.x);\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/resolutionDiviser;\n    \n    // Sky Palette [0,1]\n    vec3 col = pSky(uv.y+.5);\n    \n    uv *= VIEW_SCALE;\n   \n    // Draw Center Star\n    vec2 cStarPos = -(iMouse.xy-iResolution.xy*.5)/resolutionDiviser*VIEW_SCALE;\n    // Center the star at startup\n    if (iMouse.x < 0.00001 && iMouse.y < 0.00001) {\n        cStarPos.x = -(iResolution.x/2.0-iResolution.x*.5)/resolutionDiviser*VIEW_SCALE;\n        cStarPos.y = -(iResolution.y/2.0-iResolution.y*.5)/resolutionDiviser*VIEW_SCALE;\n    }\n    vec2 cStarUv = uv + cStarPos;\n        \n    vec2 scaledMouse = iMouse.xy/resolutionDiviser;\n    // Rotate around the center start\n    cStarUv = rotate(cStarUv, iTime/(10.) + length(scaledMouse.xy)*5.);\n    // Draw the center star\n\tfloat cStar = sdCircle(cStarUv,0.13);    \n    col += vec3(smoothstep(0.0,0.15,-cStar));\n        \n    // Find distance to center star\n    float dist = distance(-cStarPos,uv);\n               \n    // Create a unique ID for each trail\n    float trailId = floor(dist * TRAIL_COUNT/PI) + 1.0;\n    \n    // Create star trails from a sine wave emanating from the center star\n    float starTrail = abs(sin(dist * TRAIL_COUNT));\n        \n    // TEST - Select a color for the trail background\n    //vec3 trailColor = (mod(trailId, 2.0) < 0.5) ? vec3(0,0.7,0.2) : vec3(0,1,0.8);    \n    // TEST - Draw star trails\n    //col += trailColor * step(0.6, starTrail);\n    \n    vec2 randSeed = vec2(sin(trailId), cos(trailId));\n    \n    // Draw a few bright layers\n    for(float i = 1.0; i<3.0; i++) {\n        randSeed = tan(randSeed);\n        col = screen(col, drawStarTrail(randSeed, starTrail, trailId, dist, cStarUv));\n    }\n    // Draw many dim layers for depth\n    for(float i = 1.0; i<TRAIL_LAYERS; i++) {\n        randSeed = tan(randSeed);\n        col = screen(col, i/TRAIL_LAYERS*0.6 * drawStarTrail(randSeed, starTrail, trailId, dist, cStarUv));\n    }\n     \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2yW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[591, 591, 618, 618, 735], [737, 737, 769, 769, 828], [831, 831, 864, 864, 892], [895, 962, 999, 999, 1050], [1052, 1102, 1174, 1174, 1215], [1217, 1217, 1240, 1337, 1507], [1509, 1509, 1534, 1636, 1811], [1813, 1813, 1906, 1929, 4004], [4006, 4006, 4063, 4130, 6141]], "test": "untested"}
{"id": "DsByD3", "name": "E̴̡̳͉̾̉̃̉͠Y̷̹͔͈̲̒͐̓̕͘͠ͅÈ̸̔̔̀̍̈̽", "author": "Elyades", "description": "The all-seeing eye which clears the fog.", "tags": ["basicshader"], "likes": 5, "viewed": 200, "published": 3, "date": "1688256879", "time_retrieved": "2024-07-30T17:46:25.771082", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    float scaling = 2.0;\n    vec2 olduv = uv;\n    uv *= scaling;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Output to screen \n    uv = exp(-abs(uv*1.1)+max(min(iTime-2.0,40.0),0.0))*max(min(iTime-5.4,0.0),-2.0)  + min(max(iTime - 5.4,0.0),25.0)*exp(abs(uv))*length(uv);\n    vec3 color1 = palette(abs(1.0-(sin(uv.x)))/scaling);\n    vec3 color2 = palette(sin(uv.y)/scaling);\n    \n    uv = 0.2*uv + 0.8*exp(-uv); //optional\n    float weight = floor(uv.x*uv.y/pow(scaling,2.0))*pow(abs(cos(iTime+1.57)),2.0);\n    vec3 color3 = palette(weight);\n    \n    vec3 color = weight*color1 + (1.0-weight)*color2 + color3/2.0;\n    color += texture(iChannel0,olduv*scaling).rgb*0.5;\n    \n    //vec3 color = palette(value*exp(-length(uv)/scaling) + iTime*0.5);\n    float intensity = abs(cos(length(uv)*100000.0));\n    \n    fragColor = vec4(color,1.0);\n    fragColor = -exp(-tan(length(uv))*fragColor*max(min(iTime-5.3,0.0),-2.0))*min(iTime-5.3,0.0) + min(max(iTime - 5.4,0.0),1.0)*fragColor;\n    fragColor = vec4(fragColor.xyz*intensity,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsByD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 209], [215, 215, 272, 327, 1413]], "test": "untested"}
{"id": "msScWc", "name": "minified flim", "author": "01000001", "description": "[url=dd2yDz]Original shader[/url] by beans_please\n\nEverything in the image tab can be deleted.  All you need to do is type flim, and pass in the colour and exposure as seen on line 16", "tags": ["post", "tool", "processing"], "likes": 6, "viewed": 173, "published": 3, "date": "1688255036", "time_retrieved": "2024-07-30T17:46:26.679653", "image_code": "void mainImage(out vec4 O, in vec2 U)\n{\n    vec2 u = U.xy / iResolution.xy;\n\n    // RGB sweep test\n    vec3 col = sw(u);\n\n    // alternate between flim and native sRGB\n    if (mod(iTime, 3.) > 1.5)\n    {\n        col = pow(col, vec3(1. / 2.2));\n    }\n    else\n    {\n        float exposure = 0.;\n        col = flim(col, exposure, true);\n           // Inputs:\n          // colour\n         // exposure\n        // convert to srgb or not. (If you did pow(O, 1./2.2), then false)\n        \n    }\n\n    // output\n    O = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nMinified by:\n  Ahsen (01000001 on shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n\nconst vec3 pf=vec3(1),pb=vec3(1),pff=vec3(1);\nconst float pe=4.3,ps=0.,gr=1.05,gg=1.12,gb=1.045,rr=.5,rg=2.,br=.1,rm=1.,gm=1.,bm=1.,lm=-10.,lx=22.,tx=.44,ty=.28,sx=.591,sy=.779,fe=6.,fd=5.,pfe=6.,pfd=27.5,ffs=0.,ms=1.02;\n\nvec3 op(vec3 c,float p){return pow(c,vec3(1./p));}\nfloat fw(float v,float s,float e){return s + mod(v-s,e-s);}\nfloat fr(float v,float s,float e,float r,float f){return r + ((f-r)/(e-s))*(v-s);}\nfloat f0( float v,float s,float e){return clamp((v-s)/(e-s),0.,1.);}\nvec3 rh(vec3 r){\n    float a,i,h,s,v,d;\n    vec3 c;\n    a=max(r[0],max(r[1],r[2]));\n    i=min(r[0],min(r[1],r[2]));\n    d=a-i;\n    v=a;\n    if (a!=0.){s=d/a;}\n    else{s=0.; h=0.;}\n    if (s==0.){h=0.;}\n    else{c=(vec3(a)-r.xyz)/d;\n        if (r.x==a){h=c[2]-c[1];}\n        else if (r.y==a){h=2.+ c[0]-c[2];}\n        else{h=4.+ c[1]-c[0];}\n        h/=6.;\n        if (h < 0.){h +=1.;}\n    }\n    return vec3(h,s,v);\n}\n\nvec3 hr(vec3 w){\n    float f,p,q,t,h,s,v;\n    vec3 g;\n    h=w[0];\n    s=w[1];\n    v=w[2];\n    if (s==0.){g=vec3(v,v,v);}\n    else{\n        if (h==1.){h=0.;}\n        h*=6.;\n        int i=int(floor(h));\n        f=h-float(i);\n        g=vec3(f,f,f);\n        p=v*(1.-s);\n        q=v*(1.-(s*f));\n        t=v*(1.-(s*(1.-f)));\n        if (i==0){g=vec3(v,t,p);}\n        else if (i==1){g=vec3(q,v,p);}\n        else if (i==2){g=vec3(p,v,t);}\n        else if (i==3){g=vec3(p,q,v);}\n        else if (i==4){g=vec3(t,p,v);}\n        else{g=vec3(v,p,q);}\n    }\n    return g;\n}\n\nvec3 bs(vec3 c,float h,float s,float v)\n{\n    vec3 r=rh(c);\n    r[0]=fract(r[0] + h + .5);\n    r[1]=clamp(r[1]*s,0.,1.);\n    r[2]=r[2]*v;\n    return hr(r);\n}\n\nfloat fa(vec3 c){return (c.x + c.y + c.z)/3.;}\nfloat fs(vec3 c){return c.x + c.y + c.z;}\nfloat fr(vec3 c){return max(max(c.x,c.y),c.z);}\nvec3 uo(vec3 c,float p,float w){\n    float m=fa(c);\n    float n=f0(m,p/1000.,1.-(w/1000.));\n    return c*(n/m);\n}\n\nvec3 s(float h){\n    h=fw(h*360.,0.,360.);\n    vec3 c=vec3(1,0,0);\n    c=mix(c,vec3(1,1,0),f0(h,0.,60.));\n    c=mix(c,vec3(0,1,0),f0(h,60.,120.));\n    c=mix(c,vec3(0,1,1),f0(h,120.,180.));\n    c=mix(c,vec3(0,0,1),f0(h,180.,240.));\n    c=mix(c,vec3(1,0,1),f0(h,240.,300.));\n    c=mix(c,vec3(1,0,0),f0(h,300.,360.));\n    return c;\n}\n\nvec3 sw(vec2 u){\n    float h=1.-u.y;\n    float e=fr(u.x,0.,1.,-5.,10.);\n    return s(h)*pow(2.,e);\n}\n\nfloat ss(float v,float x,float y,float sx,float sy){\n    v=clamp(v,0.,1.);\n    x=clamp(x,0.,1.);\n    y=clamp(y,0.,1.);\n    sx=clamp(sx,0.,1.);\n    sy=clamp(sy,0.,1.);\n    float s=(sy-y)/(sx-x);\n    if (v < x){\n        float t=s*x/y;\n        return y*pow(v/x,t);\n    }\n    if (v < sx){\n        float i=y-(s*x);\n        return s*v + i;\n    }\n    float sp=-s/(((sx-1.)/pow(1.-sx,2.))*(1.-sy));\n    return (1.-pow(1.-(v-sx)/(1.-sx),sp))*(1.-sy)+sy;\n}\n\nfloat dm(float m,float d){\n    float o=pow(2.,lm);\n    float f=f0(log2(m + o),lm,lx);\n    f=ss(f,tx,ty,sx,sy);\n    f*=d;\n    f=pow(2.,-f);\n    return clamp(f,0.,1.);\n}\n\nvec3 rl(vec3 c,vec3 st,vec3 dt,float d){\n    vec3 sn=st/fs(st);\n    vec3 dn=dt/fr(dt );\n    float m=dot(c,sn);\n    float f=dm(m,d);\n    return mix(dn,vec3(1),f);\n}\n\nvec3 rd(vec3 c,float e,float d){\n    c*=pow(2.,e);\n    vec3 r=rl(c,vec3(0,0,1),vec3(1,1,0),d);\n    r*=rl(c,vec3(0,1,0),vec3(1,0,1),d);\n    r*=rl(c,vec3(1,0,0),vec3(0,1,1),d);\n    return r;\n}\n\nvec3 ge(float p,float s,float r,float m){\n    vec3 o=hr(vec3(fw(p + (r/360.),0.,1.),1./s,1.));\n    o/=fs(o);\n    o*=m;\n    return o;\n}\n\nmat3 fm(float rs,float gs,float bs,float rr,float gr,float br,float rm,float gm,float bm){\n    mat3 m;\n    m[0]=ge(0.,rs,rr,rm);\n    m[1]=ge(1./3.,gs,gr,gm);\n    m[2]=ge(2./3.,bs,br,bm);\n    return m;\n}\n\nvec3 np(vec3 c,vec3 b){\n    c=rd(c,fe,fd);\n    c*=b;\n    c=rd(c,pfe,pfd);\n    return c;\n}\n\nvec3 flim(vec3 c,float e,bool t){\n    c=max(c,0.);\n    c*=pow(2.,pe + e);\n    c=min(c,5000.);\n    mat3 x=fm(gr,gg,gb,rr,rg,br,rm,gm,bm);\n    mat3 i=inverse(x);\n    vec3 b=pb*x;\n    const float g=1e7;\n    vec3 w=np(vec3(g),b);\n    c=mix(c,c*pf,ps);\n    c*=x;\n    c=np(c,b);\n    c*=i;\n    c=max(c,0.);\n    c/=w;\n    vec3 f=np(vec3(0.),b);\n    f/=w;\n    c=uo(c,fa(f)*1000.,0.);\n    c=mix(c,c*pff,ffs);\n    c=clamp(c,0.,1.);\n    float m=fa(c);\n    float mix_fac =(m<.5)? f0(m,.05,.5):f0(m,.95,.5);\n    c=mix(c,bs(c,.5,ms,1.),mix_fac);\n    c=clamp(c,0.,1.);\n    if (t) c=op(c,2.2);\n    return c;\n}\n\n/*____________________ end ____________________*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msScWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 527]], "test": "untested"}
{"id": "DdScWc", "name": "Fractal and orbit trap", "author": "Moumouke", "description": "https://iquilezles.org/articles/ftrapsgeometric/", "tags": ["fractal"], "likes": 6, "viewed": 188, "published": 3, "date": "1688231943", "time_retrieved": "2024-07-30T17:46:27.946266", "image_code": "// https://iquilezles.org/articles/palettes/\n// Also http://dev.thi.ng/gradients/\nvec3 palette(in float t)\n{\n    vec3 a=vec3(0.000,0.500,0.500);\n    vec3 b=vec3(0.000 ,0.500 ,0.500);\n    vec3 c=vec3(0.000, 0.500 ,0.333);\n    vec3 d=vec3(0.00, 0.500 ,0.667);\n    return a+b*cos(6.28318*(c*t+d));\n}\n\nvec3 mandelbroot(vec2 point){\n    vec2 c = vec2(0.); \n    float o1=2000.;\n    float o2=2000.;\n    \n    for(int i=0;i<64;i++){\n        float sr=c.x*c.x-c.y*c.y;\n        float sc=2.*c.y*c.x;\n        \n        c.x=sr+point.x;\n        c.y=sc+point.y;\n        float l = length(vec2(c.x+2.,0.));\n        float l2 = length(vec2(c.x,c.y) - vec2(cos(iTime), sin(iTime)));\n        o1=min(o1, l);\n        o2=min(o2, l2);\n    }\n    \n    vec3 col = (palette(o2) + palette(o1)) / 2.;\n    return .3 / col;\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 st=(2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 st=(2.*fragCoord+vec2(i,j)/3.0-iResolution.xy)/iResolution.y;\n            vec2 uv=(st-vec2(0.5,0)) * 1.2;\n    \t\tcolor+=mandelbroot(uv);\n        }\n    }\n    fragColor=vec4(color/9.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdScWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 108, 108, 296], [298, 298, 327, 327, 789], [792, 792, 843, 843, 1214]], "test": "untested"}
{"id": "DdByD3", "name": "Rotating Colour Wheel ", "author": "o0CHT0o", "description": "Rotating Color Wheel, a easy test code.", "tags": ["2d"], "likes": 2, "viewed": 184, "published": 3, "date": "1688228805", "time_retrieved": "2024-07-30T17:46:28.872789", "image_code": "// thx some advice from Envy24\n\n//#define rotate(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nconst float r=.95,\n            R=1.,\n            pi = 4.*atan(1.);\n//const mat2 r_3 = rotate(pi*2./3.), r_3_ = rotate(pi*4./3.);\n\nvec3 trans(float th){\n    vec3 t=vec3(th,th-pi/3.*2.,th+pi/3.*2.);\n    return abs(fract((t+iTime)/pi/2.)-0.5)*6.-1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)/min(iResolution.x, iResolution.y)*2.;\n    float l = length(uv);\n    //vec2 sc = uv/l*rotate(iTime);\n    float th = atan(uv.x,uv.y);\n\n    // Time varying pixel color\n    /*\n    vec3 col = max(0., 1.-l/r) +\n               clamp((R-l)/(R-r),0.,1.) * clamp(l/r,0.,1.) *\n               vec3(sc.y+0.5,(sc*r_3).y+0.5,(sc*r_3_).y+0.5);*/\n    vec3 col = smoothstep(R,r,l) * mix(vec3(1), trans(th), l/r);\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdByD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 239, 239, 336], [338, 338, 395, 445, 941]], "test": "untested"}
{"id": "dd2cWy", "name": "UGF Sum and Diff are Orthogonal", "author": "bcourter", "description": "The sum and difference of unit gradient fields are orthogonal.  Good luck using this property for mapping.  Illustation for: https://www.blakecourter.com/2023/07/01/two-body-field.html", "tags": ["sdf", "ugf"], "likes": 5, "viewed": 844, "published": 3, "date": "1688223883", "time_retrieved": "2024-07-30T17:46:29.944922", "image_code": "// The sum and difference fields are orthogonal  \n// Illustration for: https://www.blakecourter.com/2023/07/01/two-body-field.html\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 center = vec2(0.0);\nvec2 direction = vec2(1.0, 1.0);\nbool isSDF = false;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    float interp = clamp(width * 0.5 - abs(a.Distance), 0.0, 1.0);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);    \n\n    wave.Color.a = 0.5 * max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 blend(vec4 c, vec4 base) {\n    return mix(base, c, c.a);\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n  //  if (a.Distance <= 0.0)\n    float d = clamp(a.Distance + 0.5, 0., 1.);\n    return mix(opColor, a.Color, mix(a.Color.a, 0., d));\n\n    return opColor;\n}\n\nvec4 white = vec4(1.);\nvec4 black = vec4(vec3(0.), 1.);   \nfloat pointRadius = 5.0;  \nfloat arrowRadius = 8.0;\nfloat arrowSize = 30.0;\n    \nvec4 drawPoint(vec2 p, vec2 center, vec4 opColor) {\n    Implicit circle = Circle(p, center, pointRadius, white);\n    opColor = drawFill(circle, opColor);\n    circle.Color = black;\n    return strokeImplicit(circle, 3.0, opColor);\n}\n\nvec4 drawArrow(vec2 p, vec2 startPt, vec2 endPt, vec4 color, vec4 opColor) {\n    vec2 delta = startPt - endPt;\n    vec2 arrowNormal = vec2(delta.y, -delta.x);\n    Implicit arrowSpine = Plane(p, endPt, arrowNormal, color);\n    mat2 arrowSideRotation = Rotate2(pi / 12.0);\n    Implicit arrowTip = Max(\n        Plane(p, endPt, -arrowNormal * arrowSideRotation, color),\n        Plane(p, endPt, arrowNormal * inverse(arrowSideRotation), color)\n    );\n    \n    vec2 spineDir = normalize(delta);\n    vec2 arrowBackPt = endPt + arrowSize * spineDir;\n    vec2 arrowTailPt = startPt;\n\n    arrowTip = Max(arrowTip, Plane(p, arrowBackPt, delta, color));\n    \n    Implicit bound = Shell(Plane(p, 0.5 * (arrowBackPt + arrowTailPt), spineDir, color), length(arrowBackPt - arrowTailPt), 0.0);\n    if (bound.Distance < 0.0 && dot(spineDir, arrowBackPt - arrowTailPt) < 0.)\n        opColor = strokeImplicit(arrowSpine, 4.0, opColor);\n    \n    return drawFill(arrowTip, opColor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    float angledot = readFloat(2.) - 0.5 + 0.1 * sin(iTime);\n    float angle = angledot * pi;\n    direction = vec2(cos(angle), sin(angle));\n    isSDF = readFloat(1.) > 0.5;\n    \n    vec2 p = (fragCoord - vec2(0.5, 0.333) * iResolution.xy); // * iResolution.xy;    \n\n    // planes\n    Implicit a = Plane(p, center, vec2(0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0));\n    Implicit b = Plane(p, center, direction, vec4(0.0, 0.0, 1.0, 1.0));\n    Implicit abOrig = Max(a, b);\n    Implicit aNorm = Plane(p, center, vec2(a.Gradient.y, -a.Gradient.x), a.Color);\n    Implicit bNorm = Plane(p, center, vec2(-b.Gradient.y, b.Gradient.x), b.Color);\n    \n    \n    // normal cone\n    if (min(aNorm.Distance, bNorm.Distance) > 0.)\n        opColor = vec4(0.9, 1., 0.9, 1.);\n        \n        \n    float size = iResolution.y * 0.33;\n    Implicit unitCircle = Circle(p, center, size, vec4(vec3(0.), 0.25));\n    opColor = strokeImplicit(unitCircle, 2., opColor);\n\n    opColor = drawLine(aNorm, opColor);\n    opColor = drawLine(bNorm, opColor);\n    \n    // layout\n    opColor = drawImplicit(a, opColor);\n    opColor = drawImplicit(b, opColor);\n\n    opColor = drawLine(a, opColor);\n    opColor = drawLine(b, opColor);\n\n    Implicit sum = Add(a, b);\n    Implicit diff = Subtract(a, b);\n\n    // arrows\n    vec2 pointA = center + size * a.Gradient.xy;    \n    vec2 pointB = center + size * b.Gradient.xy;\n    vec2 sumVec = size * sum.Gradient.xy;\n    vec2 pointAB = center + sumVec;\n    \n    vec4 red = vec4(0.5, 0., 0., 1.0);    \n    vec4 blue = vec4(0., 0., 0.5, 1.0);\n    opColor = drawArrow(p, center, pointA, red, opColor);\n    opColor = drawArrow(p, center, pointB, blue, opColor); \n    red.a = 0.5;\n    blue.a = 0.5;    \n    opColor = drawArrow(p, pointA, pointAB, blue, opColor);\n    opColor = drawArrow(p, pointB, pointAB, red, opColor);\n    \n    if (abs(angledot) != 0.5) {\n        opColor = drawArrow(p, center, pointAB, black, opColor); // sum\n        opColor = drawArrow(p, pointB, pointA, black, opColor); // diff\n    }\n    \n    opColor = drawPoint(p, center, opColor);    \n    opColor = drawPoint(p, pointA, opColor);    \n    opColor = drawPoint(p, pointB, opColor);    \n    opColor = drawPoint(p, pointAB, opColor);\n    \n    // perp square\n    float perpSize = 12.;\n    float halfPerpSize = perpSize * 0.5;\n    Implicit square = Max(Abs(Subtract(Sampson(sum), halfPerpSize + 0.5 * length(sumVec))), Abs(Subtract(Sampson(Negate(diff)), halfPerpSize)));\n    square = Subtract(square, halfPerpSize);\n    square.Color = black;\n    opColor = strokeImplicit(square, 3., opColor);\n\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n    fragColor = opColor;\n}\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 bounds = vec4(30,70,160,18);\n\n//////////////////\n// Work in progress\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0),iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\nImplicit Sampson(Implicit a) {\n    return Multiply(1. / length(a.Gradient), a);\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Add(a, r), zero);\n    Implicit ub = Max(Add(b, r), zero);\n    \n    Implicit maxab = Max(a, b);\n\n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance < 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    return op;\n}\n\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    \n    Implicit ab = Min(a, b);\n\n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit UnionRound(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(Multiply(h, h), 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n", "buffer_a_code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val * 2. - 1., prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2cWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 308, 340, 340, 429], [430, 430, 459, 459, 537], [539, 539, 596, 596, 788], [790, 790, 832, 832, 1305], [1307, 1307, 1338, 1338, 1370], [1372, 1372, 1413, 1413, 1481], [1483, 1483, 1524, 1553, 1680], [1822, 1822, 1873, 1873, 2052], [2054, 2054, 2130, 2130, 3016], [3018, 3018, 3073, 3073, 5799]], "test": "untested"}
{"id": "csjcRd", "name": "KIFS Structure", "author": "Dragonpeak", "description": "My first attempt at working with KIFS fractals. I don't quite understand how to design them yet, but I thought this result was cool.", "tags": ["fractal", "raymarch", "sdf", "kifs"], "likes": 5, "viewed": 201, "published": 3, "date": "1688223633", "time_retrieved": "2024-07-30T17:46:30.908347", "image_code": "const float EPS = .001;\nconst float FAR = 40.;\nconst int ITRS = 16;\nconst float FOCAL_LEN = .9;\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\nRay constructViewRay(vec2 screen_pos, vec3 pos, vec3 look_dir, vec3 up, float len)\n{\n    Ray r = Ray(pos, vec3(0));\n    \n    vec3 side = cross(up, look_dir);\n    vec3 cam_up = cross(look_dir,side);\n    \n    r.dir = normalize(side*screen_pos.x+cam_up*screen_pos.y+look_dir*len);\n    \n    return r;\n}\nfloat smin( float a, float b, float k )\n{//https://iquilezles.org/articles/smin/\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdBox(vec3 p, vec3 b)\n{\n  //https://iquilezles.org/articles/distfunctions/\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nconst vec3 degr2 = vec3(0.7071,-0.7071,0);\n\nfloat map(vec3 p, out float depth)\n{\n    float im = iMouse.x/iResolution.x*6.28;\n    float dist = FAR;\n    float sc = 1.;\n    int id = 0;\n    \n    for(int i = 0; i < ITRS; i++)\n    {\n        float di = float(i)*.2+sin(iTime-3.)*.1+.05;\n        vec3 plane = normalize(vec3(sin(di), cos(di), cos(di)));\n        \n        p -= plane*min(dot(plane, p),0.)*2.;\n        \n        p -= degr2.yyz*min(dot(degr2.yyz, p),0.)*2.;\n        p -= degr2.xzx*min(dot(degr2.xzx, p),0.)*2.;\n        \n        p -= vec3(0,0,1)*min(dot(vec3(0,0,1), p),0.)*2.;\n        float it = sin(iTime*.1)*.15+.075;\n        p = mat3(vec3(cos(it),0,sin(it)),\n        vec3(0,1,0),\n        vec3(-sin(it),0,cos(it)))*p;\n        \n        float box = sdBox(p, vec3(1,1,4))*sc;\n        depth = (box < dist) ? depth : float(i);\n        dist = smin(dist, box,.2);\n        \n        p.z -=2.2;\n        p.x -=.3;\n        p.y +=.3;\n        \n        p*=1.1;\n        sc/=1.1;\n        \n    }\n    return dist;\n}\nfloat march(Ray r, out float itrDepth)\n{\n    float depth = .01;\n    itrDepth = 0.;\n    while(depth < FAR)\n    {\n        float dist = map(r.origin+r.dir*depth, itrDepth);\n        if(dist < EPS)\n        {\n            break;\n        }\n        depth+=dist;\n    }\n    return depth;\n}\n\nvec3 mapNormal(vec3 pos)\n{\n    float ignore = 0.; \n    vec3 eps = vec3(.001, 0, 0);\n    return normalize(vec3(map(pos+eps,ignore)-map(pos-eps,ignore),\n    map(pos+eps.yxy,ignore)-map(pos-eps.yxy,ignore),\n    map(pos+eps.yyx,ignore)-map(pos-eps.yyx,ignore)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n    vec2 screenPos = (fragCoord.xy/iResolution.x*2.-1.)+vec2(0,iResolution.y/iResolution.x)*.75;\n    vec3 eye = vec3(sin(iTime-5.), cos(iTime-5.), 0.)*25.;\n    Ray viewRay = constructViewRay(screenPos, eye, normalize(-eye), vec3(0,0,1), FOCAL_LEN);\n    float itrDepth = 0.;\n    \n    float dist = march(viewRay, itrDepth);\n    vec3 col = texture(iChannel0, viewRay.dir.xzy).xyz;\n    if(dist<FAR)\n    {\n        vec3 nrm = mapNormal(viewRay.origin+viewRay.dir*dist); \n        col = mix(vec3(0.855,0.463,0.106), vec3(0.008,0.043,0.094), float(itrDepth)/float(ITRS));\n        col *= max(dot(nrm, normalize(vec3(.4,.4,.6))),0.)*vec3(4.)+texture(iChannel0, nrm.xzy).xyz;\n    }\n\n    fragColor = vec4(pow(col*vec3(0.867,0.765,0.675), vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 227, 227, 441], [442, 442, 483, 522, 615], [616, 616, 645, 696, 783], [828, 828, 864, 864, 1785], [1786, 1786, 1826, 1826, 2064], [2066, 2066, 2092, 2092, 2326], [2328, 2328, 2385, 2385, 3177]], "test": "untested"}
{"id": "mdjyWK", "name": "Image Mouse Bulge", "author": "alphardex", "description": "Use mouse to distort the image.", "tags": ["distort"], "likes": 5, "viewed": 265, "published": 3, "date": "1688201310", "time_retrieved": "2024-07-30T17:46:31.831877", "image_code": "vec2 distort(vec2 p){\n    // vec2 center=vec2(.5);\n    vec2 center=iMouse.xy/iResolution.xy;\n    float radius=.9;\n    float strength=1.1;\n    \n    p-=center;\n    \n    float d=length(p);\n    // p*=d;\n    \n    d/=radius;\n    \n    float dPow=pow(d,2.);\n    // p*=dPow;\n    \n    float dRev=strength/(1.+dPow);\n    p*=dRev;\n    \n    p+=center;\n    \n    return p;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    uv=distort(uv);\n    vec4 tex=texture(iChannel0,uv);\n    vec4 col=tex;\n    fragColor=col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 50, 359], [361, 361, 415, 415, 548]], "test": "untested"}
{"id": "cdjyWV", "name": "oooowl", "author": "chenxianming", "description": "DESIGN this scene\ninspiration from a pillow", "tags": ["cineshader", "oooowl"], "likes": 7, "viewed": 974, "published": 3, "date": "1688189299", "time_retrieved": "2024-07-30T17:46:32.929941", "image_code": "#define PI 3.1415926\n#define TAU 6.2831852\n#define T(s) fract(iTime * s) * PI * 4.\n\n#define calcLine( a ) step( mod( a, .5 ) - .25, 0. )\n#define calcLine2( a ) step( mod( a, .5 ) - .1, 0. )\n\n#define enableMouse 1\n\nvec2 m = vec2( 0.6, 0.55 ); \nmat2 m2 = mat2( .1, .1, -.7, .5 );\n\nfloat noise( in vec2 f ){\n  f *= m2;\n  return ( cos( f.x + .18975 ) * sin( f.y + .494516 ) + .1615246 );\n}\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*noise(f*x);\n    }\n    return t;\n}\n\nint eyeInt = 0;\n\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat smax(float a, float b, float c) {\n    return -smin(-a, -b, c);\n}\n\nfloat getPath( vec2[3] path, in vec2 uv ){\n    return path[0].x * pow( uv.x, 2. ) + path[0].y * pow( uv.y, 2. ) + path[1].x * uv.x * uv.y + path[1].y * uv.x + path[2].x * uv.y + path[2].y;\n}\n\nvec2 path1[3] = vec2[]( vec2( 0.0036000000000000337, 0.008099999999999927 ), vec2( 0.010800000000000087, -0.008496000000000004  ), vec2( 0.003480000000000096, -0.004072799999999995 ) );\n\nvec2 path2[3] = vec2[]( vec2( 0.03609999999999998, 0.003600000000000006 ), vec2( -0.022800000000000015, 0.03411199999999999  ), vec2( -0.003252000000000005, 0.005616280000000001 ) );\n\t\nvec2 path3[3] = vec2[]( vec2( 0.010000000000000007, 0.0001000000000000445 ), vec2( -0.0020000000000000157, 0.005656000000000005  ), vec2( 0.0028940000000000007, 0.0005264499999999997 ) );\n\n\nfloat calcBody( vec2 uv ){\n\n    float d = 0.5;\n    \n    // body\n    d = min( d,\n        length( uv * vec2( 1.2, 1. ) ) - .5\n    );\n    \n    d = smin( d, length( uv + vec2( .27, -.25 ) ) - .2, .3 );\n    d = smin( d, length( uv + vec2( -.27, -.25 ) ) - .2, .3 );\n    \n    d = smin( d, length( uv + vec2( .15, .2 ) ) - .25, .3 );\n    d = smin( d, length( uv + vec2( -.15, .2 ) ) - .25, .3 );\n\n    return d;\n}\n\nfloat calcEar( vec2 uv ){\n    return max(\n        max(\n            getPath( path1, uv ),\n            getPath( path2, uv )\n        ),\n        -getPath( path3, uv )\n    );\n}\n\nfloat calcWing( vec2 uv ){\n    float d = .1;\n    \n    uv.x -= .08;\n    uv.y += .25;\n    \n    uv.x -= cos( T( .25 ) ) * .01;\n    uv.y -= cos( T( .25 ) ) * .02;\n    \n    d = min(\n        d,\n        length( uv * rotation( .1 )  * vec2( 1., 1.5 ) + vec2( .33, -.3 ) ) - .35\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( .35, -.05 ) ) - .2,\n        .2\n    );\n    \n    return d;\n    \n}\n\nfloat calcEyeSockets( vec2 uv ){\n    float d = .1;\n    \n    d = min(\n        d,\n        length( uv * vec2( 1., 1.5 ) + vec2( 0.25, -.3 ) ) - .25\n    );\n    \n    d = min(\n        d,\n        length( uv * vec2( 1., 1.5 ) + vec2( -0.25, -.3 ) ) - .25\n    );\n    \n    d = smin(\n        d,\n        length( uv * vec2( 1., 1.3 ) + vec2( -0.0, -.32 ) ) - .1,\n        .3\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( -0.25, -.27 ) ) - .1,\n        .2\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( 0.25, -.27 ) ) - .1,\n        .2\n    );\n    \n    return d;\n}\n\nfloat calcEyeOline( vec2 uv ){\n    return length( uv + vec2( .25, -.23 ) ) - .13;\n}\n\nfloat calcEye( vec2 uv ){\n    float d = .1;\n    eyeInt++;\n    \n    d = min(\n        d,\n        length( uv + vec2( .28, -.24 ) ) - .07\n    );\n    \n    d = max(\n        d,\n        eyeInt == 1 ?\n        -( length( uv * rotation( -.1 )  * vec2( 1., 1.2 ) + vec2( .33, -.3 ) ) - .03 ) :\n        -( length( uv * rotation( -.15 )  * vec2( 1., 1.5 ) + vec2( .35, -.35 ) ) - .025 )\n    );\n    \n    return d;\n    \n}\n\nfloat calcBeak( vec2 uv ){\n\n    float d = .1;\n    \n    d = min(\n        d,\n        length( uv + vec2( 0., -.05 ) ) - .05\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( 0.05, -0.03 - .05 ) ) - .03,\n        .03\n    );\n    \n    d = smin(\n        d,\n        length( uv + vec2( -0.03, -0.03 - .05 ) ) - .03,\n        .04\n    );\n    \n    return d;\n\n}\n\nfloat calcChesty( vec2 uv ){\n\n    float d = .1;\n    \n    d = min(\n        d,\n        length( uv * vec2( .6, 1. ) + vec2( 0.02, .25 ) ) - .19\n    );\n    \n    return d;\n\n}\n\nfloat getPat( vec2 uv ){\n    float wave = 0.;\n    \n    uv.x -= cos( T( .025 ) ) * .1;\n    uv.y += sin( T( .025 ) ) * .1;\n    \n    uv.y -= .05;\n    uv.y = mod( uv.y, .1 ) - .05;\n    \n    vec2 uv2 = uv;\n    vec2 uv3 = uv;\n    \n    uv2.x = mod( uv2.x, .1 ) - .05;\n    wave = ( length( uv2 ) - .05 );\n    \n    uv3.x = mod( uv3.x, .1 ) - .05;\n    wave = max(\n        wave,\n        -( length( uv3 + vec2( 0., -.01 ) ) - .05 )\n    );\n\n    return wave;\n}\n\nfloat calcClawu( vec2 uv ){\n    float p = 0.;\n\n    float py = uv.y;\n    \n    if( py < 0. ){\n        py *= 6.;\n    }\n    \n    if( py <= -1. ){\n        py = -1.;\n    }\n    \n    if( py > 0. ){\n        py *= 3.;\n    }\n    \n    if( py >= 1. ){\n        py = 1.;\n    }\n    \n    py = abs( pow( py, 2. ) ) - 1.;\n    py = abs( py );\n    \n    p = abs( uv.x ) - .1 * py;\n    \n    return p;\n}\n\nfloat calcClawg( vec2 uv ){\n\n    float d = .1;\n\n    d = min( d,\n        calcClawu( uv * 3. * rotation( PI * 1.05 ) + vec2( 0.3, 0.1 ) )\n    );\n    \n    d = min( d,\n        calcClawu( uv * 3. * rotation( PI * 1.05 ) + vec2( -0.25, 0. ) )\n    );\n    \n    d = min( d,\n        calcClawu( uv * 2.6 * rotation( PI * 1.1 ) )\n    );\n\n    return d;\n}\n\nfloat calcWoocry( vec2 uv ){\n\n    float d = .1;\n    \n    float py = uv.y;\n    \n    py /= 2.;\n    py += .5;\n\n    d = min(\n        d,\n        max(\n            abs( uv.x ) - .1 * py,\n            abs( uv.y ) - .15\n        )\n    );\n\n    return d;\n}\n\nvec3 texMap( vec2 uv )\n{\n\n    vec3 col = vec3( \n        mix( vec3( 1. ), vec3( 0.73, 0.82, 0.84 ), calcLine( uv.y * .6 + abs(uv.x -.0 ) * .5 - ( iTime * .05 ) ) )\n    );\n    \n    uv.y += cos( T( .25 ) ) * .005;\n    \n    float d = 0.;\n    \n    // ears\n    d = .1;\n    d = min( d,\n        calcEar( uv * vec2( -1., 1. ) * rotation( .3 ) + vec2( -.12, -.35 ) )\n    );\n    \n    d = min( d,\n        calcEar( uv * vec2( 1., 1. ) * rotation( .1 ) + vec2( 0., -.3 ) )\n    );\n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n    \n    // wings\n    d = .1;\n    d = min( d,\n        calcWing( uv )\n    );\n    \n    d = min( d,\n        calcWing( uv * vec2( -1., 1. ) + vec2( .01, -.05 ) )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    // body\n    d = .1;\n    d = min( d,\n        calcBody( uv )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0.91, 0.8, 0.15 ),\n        d\n    );\n    \n    // eye\n    d = max(\n        calcBody( uv ),\n        -calcEyeSockets( uv )\n    );\n    \n    d = max(\n        d,\n        -( uv.y - .2 )\n    );\n\n    d = step( d, 0. );\n       col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n    \n    d = .1;\n    d = min( d,\n        calcEyeSockets( uv )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 1. ),\n        d\n    );\n    \n    d = .1;\n    d = min( d,\n        calcEyeOline( uv + vec2( -.5, 0. ) )\n    );\n    \n    d = min( d,\n        calcEyeOline( uv + vec2( 0., 0. ) )\n    );\n    \n    d = smoothstep( 0., d, .01 );\n    d = dot(d, d);\n    d = dot(d, d);\n    d = dot(d, d);\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    \n    // eye2\n    d = .1;\n    d = min( d,\n        calcEye( uv )\n    );\n    \n    d = min( d,\n        calcEye( uv * vec2( -1., 1. ) )\n    );\n    \n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    // beak\n    d = .1;\n    d = min( d,\n        calcBeak( uv )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    // chesty\n    d = .1;\n    d = min( d,\n        calcChesty( uv )\n    );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0.15, 0.53, 0.60 ),\n        d\n    );\n    \n    \n    col = mix(\n        col,\n        vec3( 1. ),\n        d * step( getPat( uv ), 0. )\n    );\n    \n   \n    // claw\n    d = .1;\n    \n    d = min( d, calcClawg( uv + vec2( -.22, 0.62 ) ) );\n    d = min( d, calcClawg( uv * vec2( -1., .95 ) + vec2( -.2, 0.6 ) ) );\n    \n    d = step( d, 0. );\n    \n    col = mix(\n        col,\n        vec3( 0. ),\n        d\n    );\n    \n    // woocry\n    d = .1;\n    \n    uv += vec2( -.55, -.65 );\n    uv *= 1.2;\n    d = min( d, calcWoocry( uv * rotation( PI * -.25 ) + vec2( -.1, -0.1 ) ) );\n    d = step( d, -1. + round( fract( iTime + 1. ) ) );\n    \n    col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n    \n    d = .1;\n    d = min( d, calcWoocry( uv * 1.2 * rotation( PI * -.3 ) + vec2( -.3, -0.15 ) ) );\n    \n    d = step( d, -1. + round( fract( iTime * .25 ) ) );\n    \n    col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n    \n    d = .1;\n    d = min( d, calcWoocry( uv * 1.2 * rotation( PI * -.35 ) + vec2( -.45, -0.15 ) ) );\n    \n    d = step( d, -1. + round( fract( iTime * .5 ) ) );\n    \n    col = mix(\n        col,\n        vec3( 0.92, 0.40, 0.15 ),\n        d\n    );\n\n    return col;\n}\n\nfloat calcB( vec3 p ){\n    float d = .1;\n    \n    p.xz *= rotation( clamp( m.x, -1., 1. ) );\n    p.yz *= rotation( clamp( m.y, -.5, .3 ) );\n    \n    // p.z += fbm( p.yz, 1.1 ) * .5;\n    \n    d = smax(\n      smax( abs( p.x ) - .8, abs( p.z ) - .15, .1 ),\n      abs( p.y ) - .8,\n      .3\n    );\n    \n    d = smin( d,\n        max(\n            length( p.yz * vec2( 1., 2.1 ) + vec2( 0., fbm( p.yz, 1. ) * .05 ) ) - .5,\n            abs( p.x ) - .7\n        )\n        ,.5\n    );\n    \n    return d;\n}\n\nfloat ground( vec3 p ){\n    float d = .1;\n    \n    p.xz *= rotation( PI * -.5 );\n    \n    d = min(\n        d,\n        p.y + .7\n    );\n    \n    d = min(\n        d,\n        p.x + 1.1\n    );\n    \n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = .1;\n    \n    d = min(\n        d,\n        calcB( p )\n    );\n    \n    d = min(\n        d,\n        ground( p )\n    );\n    \n    \n    return d;\n}\n\n// IQ\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nvec3 raymarching( vec3 ro, vec3 rd ){\n    \n    float t = 0.,\n          dist = 0.;\n          \n    vec3 lig = normalize(vec3(.57703));\n    lig.xz *= rotation( PI * 1.3 );\n    lig.xy *= rotation(  PI * .5 );\n    \n    vec3 hal = normalize(lig - rd);\n    \n    vec3 pos = vec3( 0. );\n    \n    for( int i = 0; i < 64; i++ ){\n        \n        pos = ro + rd * t;\n\n        dist = map( pos );\n        \n        if( t > 1e3 ){\n            break ;\n        }\n        \n        t += dist;\n    }\n    \n    \n    if( dist < 1e-3 ){\n    \n        vec3 nor = calcNormal(pos);\n\n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n\n        float shadow = calcSoftshadow( pos, lig, 0.1, 3.0, 1 );\n        dif *= shadow;\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n\n        vec3 reflection = reflect(rd, nor);\n        \n        vec3 col = vec3( 0. );\n        \n        if( map( pos ) == ground( pos ) ){\n            \n            vec3 posg = pos;\n            posg.zx *= rotation( PI * .2 );\n            float pt = fbm( vec2( fbm( posg.zx - ( 100. ), 1. ) ), .1 );\n\n            posg.xy += calcLine( pos.x );\n            \n            col += spe + vec3( .3 ) * dif + amb * .2 + mix( vec3( vec3(pt) * vec3( .1 ) ), vec3(pt) * vec3( 0.37, 0.34, 0.31 ) * .7, calcLine( pos.x ) ) * .25 ;\n            col += vec3( 0.73, 0.82, 0.84 ) * .1;\n        }\n        \n        if( map( pos ) == calcB( pos ) ){\n            \n            vec3 posg = pos;\n            posg.xz *= rotation( clamp( m.x, -1., 1. ) );\n            posg.yz *= rotation( clamp( m.y, -.5, .3 ) );\n            nor.xz *= rotation( clamp( m.x, -1., 1. ) );\n            nor.yz *= rotation( clamp( m.y, -.5, .3 ) );\n        \n            col = spe + vec3( .1 ) * dif + ( .3 + calcLine2( posg.y * 1.5 )) * max( nor.x, 0. ) + (  vec3( 0.73, 0.82, 0.84 ) * .5 +  calcLine2( posg.y * 1.5 )) * max( -nor.x, 0. );\n            col += max( -nor.z, .0 ) * texMap( posg.xy * 1.5 );\n        }\n        \n        return col;\n        \n    }\n        \n    return vec3( 0. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if( iMouse.z > .01 && enableMouse == 1 ){\n        m = iMouse.xy/iResolution.xy;\n    }\n    \n    uv = (uv - .5) * 2.;\n    m = (m - .5) * 2.;\n\n    uv.x *= iResolution.x / iResolution.y;\n    m.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3( 0. );\n    \n    vec3 ro = vec3( 0., 0., -2. );\n    vec3 rd = vec3( uv, 1. );\n    \n    col = raymarching( ro, rd );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 304, 304, 385], [387, 387, 423, 423, 603], [623, 623, 647, 647, 713], [715, 715, 755, 755, 837], [839, 839, 878, 878, 909], [1665, 1665, 1691, 1691, 2070], [2072, 2072, 2097, 2097, 2243], [2245, 2245, 2271, 2271, 2642], [2644, 2644, 2676, 2676, 3225], [3227, 3227, 3257, 3257, 3310], [3312, 3312, 3337, 3337, 3717], [3719, 3719, 3745, 3745, 4079], [4081, 4081, 4109, 4109, 4250], [4252, 4252, 4276, 4276, 4698], [4700, 4700, 4727, 4727, 5079], [5081, 5081, 5108, 5108, 5422], [5424, 5424, 5452, 5452, 5667], [5669, 5669, 5693, 5693, 9232], [9234, 9234, 9256, 9256, 9726], [9728, 9728, 9751, 9751, 9936], [9938, 9938, 9957, 9957, 10112], [10121, 10121, 10214, 10214, 11069], [11071, 11117, 11148, 11148, 11396], [11398, 11398, 11435, 11435, 13484], [13486, 13486, 13543, 13593, 14089]], "test": "untested"}
