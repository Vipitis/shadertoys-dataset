{"id": "4d2Szd", "name": "Triangle functions", "author": "TDM", "description": "triangle tools", "tags": ["intersection", "distance", "triamgle"], "likes": 10, "viewed": 451, "date": "1474232204", "time_retrieved": "2024-06-20T18:40:33.807653", "image_code": "/*\n\t\"Triangle functions\" by Alexander Alekseev aka TDM - 2016\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\tPapers:\n\thttp://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\n\thttp://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\n*/\n\nconst int NUM_STEPS = 32;\nconst int AO_SAMPLES = 4;\nconst vec2 AO_PARAM = vec2(1.2, 3.8);\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.2;\nconst float EPSILON \t= 1e-4;\nconst float LIGHT_INTENSITY = 0.3;\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\n\nvec3 tri[3];\n\n// math\nfloat saturate(float x) { return clamp(x,0.,1.); }\nfloat boolUnion(float a,float b) { return min(a,b); }\t\n\n#define RAY_TRIANGLE_INTERSECTION triangleIntersectionCramer\n\n/******************************************************************\n triangle distance\n ******************************************************************/\n\nfloat triangleDistance(vec3 p,vec3 v0,vec3 v1,vec3 v2) {\n    vec3 e0 = v1-v0, e1 = v2-v0, e2 = v2-v1;\n    vec3 pe0 = p-v0, pe1 = p-v1;\n    vec3 normal = cross(e0,e1);\n                      \n    // distance to plane  \n    if(dot(normal,cross(pe0,e0)) < 0.0 &&\n       dot(normal,cross(pe1,e2)) < 0.0 &&\n       dot(normal,cross(pe0,e1)) > 0.0) {\n        \n        return abs(dot(p-v0,normalize(normal)));\n        \n    // distance to edges\n    } else {\n        vec3 dp0 = e0 * saturate(dot(e0,pe0) / dot(e0,e0)) - pe0;\n        vec3 dp1 = e1 * saturate(dot(e1,pe0) / dot(e1,e1)) - pe0;\n        vec3 dp2 = e2 * saturate(dot(e2,pe1) / dot(e2,e2)) - pe1;                                 \n        return sqrt(min(min(dot(dp0,dp0),dot(dp1,dp1)),dot(dp2,dp2)));\n    }\n}\n\n/******************************************************************\n culled triangle intersection - based on Cramer's rule\n \t24 multiplications (6*2+3*4)\n \t1 division\n ******************************************************************/\n\nfloat triangleIntersectionCramerCulled(vec3 o,vec3 d, vec3 v0,vec3 v1,vec3 v2) {\n    vec3 e0 = v1-v0, e1 = v2-v0, r = o - v0;\n    vec3 ce0d = cross(e0,d);\n    float det = dot(e1,ce0d);\n    \n    // check intersection\n   \tfloat v = dot(r,ce0d);    \n    if(v < 0.0 || v > det) return -1.0;\n    \n    vec3 ce1r = cross(e1,r);\n   \tfloat u = dot(d,ce1r);\n    if(u < 0.0 || (u+v) > det) return -1.0;\n    \n    // distance to triangle\n\treturn dot(e0,ce1r) / det;\n}\n\n/******************************************************************\n triangle intersection - based on Cramer's rule\n \t27 multiplications (6*2+3*4+3)\n \t1 division\n ******************************************************************/\n\nfloat triangleIntersectionCramer(vec3 o,vec3 d, vec3 v0,vec3 v1,vec3 v2) {\n    vec3 e0 = v1-v0, e1 = v2-v0, r = o - v0;\n    vec3 ce0d = cross(e0,d);\n    float idet = 1.0 / dot(e1,ce0d);\n    \n    // check intersection\n   \tfloat v = dot(r,ce0d) * idet;    \n    if(v < 0.0 || v > 1.0) return -1.0;\n    \n    vec3 ce1r = cross(e1,r);\n   \tfloat u = dot(d,ce1r) * idet;    \n    if(u < 0.0 || (u+v) > 1.0) return -1.0;\n    \n    // distance to triangle\n\treturn dot(e0,ce1r) * idet;\n}\n\n/******************************************************************\n triangle intersection - simple approach\n \t45 multiplications (6×4+3×6+3)\n \t1 division\n ******************************************************************/\n\nfloat triangleIntersectionSimple(vec3 o,vec3 d, vec3 v0,vec3 v1,vec3 v2) {\n    vec3 e0 = v1-v0, e1 = v2-v0;\n    vec3 normal = cross(e0,e1);\n    \n    // ray vs plane    \n    float t = -(dot(normal,o) - dot(normal,v0)) / dot(normal,d);\n    \n    // point inside triangle\n    vec3 point = o + d * t;\n    if(dot(normal, cross(e0,point-v0)) < 0.0 ||\n       dot(normal, cross(e1,v2-point)) < 0.0 ||\n       dot(normal, cross(v2-v1,point-v1)) < 0.0) return -1.0;   \n    \n\treturn t;\n}\n\n\n\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\n\n// world\nfloat map_tri(vec3 p) {        \n    return triangleDistance(p, tri[0],tri[1],tri[2]);\n}\nfloat map(vec3 p) {\n    float d = map_tri(p);\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.3)));\n    return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map(p));\n}\nfloat getOcclusion(vec3 p, vec3 n) {\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.01+f*AO_PARAM.x;\n        float d = map(p + n * h) - TRESHOLD;\n        r += clamp(h-d,0.0,1.0) * (1.0-f);\n    }    \n    return pow(clamp(1.0-r*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0),0.25);\n}\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    vec2 td = vec2(0.0);\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * td.x;\n        td.y = map(p);\n        if(td.y < TRESHOLD) break;\n        td.x += td.y-TRESHOLD;\n    }\n    return td;\n}\n\n// object\nvec3 getObjectColor(vec3 p, vec3 l, vec3 n, vec3 e) {\n    vec3 color = vec3(0.0,0.5,0.5);\n    color += vec3(diffuse(n,l,1.0) * WHITE);\n    color += vec3(specular(n,l,e,20.0) * WHITE); \n    color *= (n.y * 0.2 + 0.8);\n    return color;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 iuv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec2 uv = iuv;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray    \n    vec3 ori = vec3(0.0,0.1,4.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));\n    vec2 sc = vec2(cos(iTime),sin(iTime));\n    dir.xz = vec2(dir.x * sc.x - dir.z * sc.y, dir.x * sc.y + dir.z * sc.x);\n    ori.xz = vec2(ori.x * sc.x - ori.z * sc.y, ori.x * sc.y + ori.z * sc.x);\n    \n    // triangle    \n    vec2 sc2 = vec2(sin(iTime),cos(iTime)) * 0.3;\n    tri[0] = vec3(-1.0+sc2.x,\t-0.4+sc2.y,\t-sc2.x*2.0);\n    tri[1] = vec3( 0.0+sc2.y,\t 1.2+sc2.x,\tsc2.y);\n    tri[2] = vec3( 1.0-sc2.x,\t-0.4-sc2.y,\tsc2.x*2.0);        \n        \n    // tracing\n    vec3 p;\n    vec2 td = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,td.y);\n    float occ = getOcclusion(p,n);\n    vec3 light = normalize(-dir); \n         \n    // color\n    vec3 color = vec3(1.0);    \n    if(map_tri(p) - EPSILON <= td.y) color = getObjectColor(p,light,n,dir);\n    \n    float t = RAY_TRIANGLE_INTERSECTION(ori, dir, tri[0],tri[1],tri[2]);\n    if(t > 0.0) color *= 0.75;    \n    \n    color *= occ;    \n    color = pow(color,vec3(1.0/2.2));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2Szd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dGSDW", "name": "coolant tubes", "author": "jameswilddev", "description": "I'l confess that I don't know enough maths to make the cylinder function in any way &amp;quot;right&amp;quot;.\n\nBeen draft a long time, making public so I can link it!", "tags": ["volumetrics"], "likes": 5, "viewed": 113, "date": "1474100628", "time_retrieved": "2024-06-20T18:40:33.807653", "image_code": "#define INFINITY 10000.0\n#define PI 3.142\n#define HALFPI (PI / 2.0)\n\nvec3 plane(vec2 pos, vec3 ndc) {\n    float divisor = length(pos) / abs(dot(normalize(pos), ndc.xy));\n    return vec3(dot(vec2(-ndc.y, ndc.x), normalize(pos)) * divisor, abs(divisor) + ndc.z, abs(divisor));\n}\n\nvec3 planeZ(float z, vec3 ndc) {\n    return vec3(ndc.xy * (z - ndc.z), z - ndc.z);\n}\n\nvec3 cylinder(vec2 pos, float radius, vec3 ndc, bool inside) {\n    float dist = length(pos) / abs(dot(normalize(pos), ndc.xy));\n    float onX = dot(vec2(-ndc.y, ndc.x), normalize(pos)) * dist;\n    onX = asin(onX / radius);\n    float z = abs(dist) - (cos(onX) * radius * dist);\n    return vec3(onX * radius + (onX < 0.0 ? 1.0 : -1.0) * (cos(onX) * radius), abs(dist) - (cos(onX) * radius * dist) + ndc.z, z > 0.0 ? z : INFINITY);\n}\n\nvec3 cylinderZ(float z, float radius, vec3 ndc) {\n    float relX = ndc.x * (z - ndc.z) / radius;\n    if (abs(relX) > 1.0) return vec3(0.0, 0.0, INFINITY);\n    float ang = asin(relX);\n    return vec3(\n        sin(ang * radius), \n        ndc.y * (z - ndc.z - cos(ang) * radius), \n        z - ndc.z - cos(ang) * radius);\n}\n    \nvec3 light(vec3 ndc, vec3 location, vec3 color, float size, float rate, float scene) {\n    vec3 sampleFrom = vec3(ndc.xy * abs(location.z - ndc.z), max(ndc.z, min(scene + ndc.z, location.z)));\n    return color * pow(1.0 / (1.0 + (distance(location, sampleFrom) / size)), rate);\n}\n\nvec3 combine(vec3 a, vec3 b) {\n    return a.z < b.z ? a : b;\n}\n\nvec3 difference(vec3 a, vec3 b) {\n    return a.z > b.z ? a : b;\n}\n\nbool inChequer(vec3 ndc) {\n    vec2 local = fract(ndc.xy);\n    return local.x > 0.5 != local.y > 0.5;\n}\n\nvec3 chequer(vec3 ndc, float falloff) {\n    vec2 local = fract(ndc.xy);\n    return (local.x > 0.5 != local.y > 0.5 ? vec3(1.0, 1.0, 0.3) : vec3(0.3, 0.3, 1.0)) / (1.0 + ndc.z * falloff);\n}\n\nvec3 gammaCorrect(vec3 c) {\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec2 forAngle(float angle) {\n    return vec2(cos(angle), sin(angle));\n}\n\nvec3 render(vec2 fragCoord, vec2 res, float seconds) {\n    vec3 ndc = vec3((fragCoord - res / 2.0) / min(res.x, res.y), 5.0 + seconds);\n    vec3 scene = \n        combine(cylinder(forAngle(0.0), 0.1, ndc, true),\n        combine(cylinder(forAngle(PI / 3.0) * 0.5, 0.1, ndc, true),\n        combine(cylinder(forAngle(2.0 * PI / 3.0) * 0.5, 0.1, ndc, true),\n        combine(plane(forAngle(PI / 3.0), ndc),\n        combine(plane(forAngle(2.0 * PI / 3.0), ndc), \n        plane(forAngle(0.0), ndc))))));\n    return gammaCorrect(\n        chequer(scene * 4.0, 80.0) \n        + light(ndc, vec3(cos(seconds), sin(seconds), 8.5), vec3(0.0, 1.5, 0.0), 0.5, 4.0, scene.z)\n    \t+ light(ndc, vec3(-cos(seconds), -sin(seconds), 12.5), vec3(0.0, 2.0, 0.4), 0.5, 4.0, scene.z)\n        + light(ndc, vec3(0.0, 0.5, mod(seconds * 10.0, 100.0)), vec3(0.0, 0.8, 2.0), 1.0, 8.0, scene.z)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(render(fragCoord.xy, iResolution.xy, iTime), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGSDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lG3Dm", "name": "Big3D RayTracer", "author": "sohale", "description": "Click and drag the mouse around to change the camera angle. \nA Ray-Tracing demo. Features: reflection, Phong shading, Ellipsoids. It's a mini version of my very old program Big3D.\nSee https://github.com/sohale/shaders/blob/master/raytrace1.glsl", "tags": ["raytracing"], "likes": 0, "viewed": 236, "date": "1474886827", "time_retrieved": "2024-06-20T18:40:36.256170", "image_code": "#define USE_CAMERA 1\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nconst vec3 e1=vec3(1.0, 0.0, 0.0);\nconst vec3 e2=vec3(0.0, 1.0, 0.0);\nconst vec3 e3=vec3(0.0, 0.0, 1.0);\nconst vec3 o0=vec3(0.0, 0.0, 0.0);\n\nconst vec4 e4=vec4(0.0, 0.0, 0.0, 1.0);\n\n/*\nmat3 inverse(mat3 m) {\n  // from https://github.com/stackgl/glsl-inverse/blob/master/index.glsl\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n*/\n\n\nconst int SPHERE = 5;\n\nstruct Obj\n{\n    int type;\n    vec3 center;\n    mat3 forward_matrix;\n    mat3 inverse_matrix;\n    vec3 rgb;\n};\n\nObj make_ellipsoid(float rx, float ry, float rz) {\n    // vec4 loc=vec4(0.0, 0.0, 0.0, 0.0);\n    Obj obj;\n    obj.type = SPHERE;\n    // obj.matrix = mat3(e1, e2*2.0, e3);\n    obj.center= e3*6.0 * 0.0;  // Ellipsoid\n    // mat3 im = inverse(obj.matrix);\n    obj.rgb = vec3(1.0,1.0,1.0);\n\n    // rx = 1.0;\n    // ry = 1.0;\n    // rz = 1.0;\n\n    // obj.inverse_matrix = inverse(obj.matrix);\n    obj.inverse_matrix = mat3(e1 / rx, e2 / ry, e3 / rz);\n    obj.forward_matrix = mat3(e1*rx, e2*ry, e3*rz);\n    return obj;\n}\n\n\n// todo: cleanup and fix careless code.\nbool solveQuadratic(in vec3 abc, out float x0, out float x1)\n{\n    float discr = abc.y * abc.y - 4.0 * abc.x * abc.z;\n    if (discr < 0.0) return false;\n    else if (discr == 0.0)\n        x0 = x1 = - 0.5 * abc.y / abc.x;\n    else {\n        float q = (abc.y > 0.0) ?\n            -0.5 * (abc.y + sqrt(discr)) :\n            -0.5 * (abc.y - sqrt(discr));\n        x0 = q / abc.x;\n        x1 = abc.z / q;\n    }\n    if (x0 > x1) {\n        float t = x0;\n        x0 = x1;\n        x1 = t;\n    }\n    return true;\n}\n\nbool sphere_intersect(in Ray ray, out float t, out vec3 where)\n{\n    const float radius2 = 1.0;\n\n    // analytic solution\n    vec3 L = ray.org; // - center;\n    float a = ray.dir.x * ray.dir.x + ray.dir.y * ray.dir.y + ray.dir.z * ray.dir.z ;\n    float b = 2.0 * (ray.dir.x*L.x + ray.dir.y*L.y + ray.dir.z*L.z);\n    float c = (L.x*L.x + L.y*L.y + L.z*L.z) - radius2;\n    vec3 abc = vec3(a,b,c);\n\n    float t0, t1; // solutions for t if the ray intersects\n    if (!solveQuadratic(abc, t0, t1)) return false;\n\n    if (t0 > t1) {\n        float tt = t0;\n        t0 = t1;\n        t1 = tt;\n    }\n\n    if (t0 < 0.0) {\n        t0 = t1; // if t0 is negative, let's use t1 instead\n        if (t0 < 0.0) return false; // both t0 and t1 are negative\n    }\n\n    t = t0;\n\n    where = t * ray.dir + ray.org;\n    return true;\n}\n\nmat3 transpose_(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nvec3 sphere_normal(in Obj obj, in vec3 where) {\n    // vec3 d = vec3(where - obj.center);\n    //d = normalize(d);\n\n    vec3 d = obj.inverse_matrix * (where - obj.center);\n    d = transpose_(obj.forward_matrix) * d;\n\n    d = normalize(d);\n    return d;\n}\n\nbool raycast(in Ray ray, in Obj obj, out float t, out vec3 where)\n{\n    if (obj.type == SPHERE) {\n        Ray ray2 = ray;\n        ray2.dir = obj.inverse_matrix * ray.dir;\n        ray2.org = obj.inverse_matrix * (ray.org - obj.center);\n        float new_norm = length(ray2.dir);\n\n\n        vec3 where2;\n        float t2;\n        bool did = sphere_intersect(ray2, t2, where2);\n\n        where = obj.forward_matrix * where2 + obj.center;\n        t = t2 ; //* new_norm;\n        ////////////////\n        return did;\n    }\n    // error: unrecognised object type\n    return false;\n}\n\n\nvec3 my_reflect(in vec3 ray, in vec3 normal) {\n    float cos_ = dot(ray, normal);\n    vec3 p = cos_ * normal;\n    return 2.0 * p - ray;\n}\n\nfloat my_inner(in vec3 a, in vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec4 phong_material(in vec3 light_dir, in vec3 ray_dir, in vec3 normal, in vec3 obj_rgb) {\n    float diffuse = - (light_dir.x * normal.x + light_dir.y * normal.y + light_dir.z * normal.z);\n    diffuse = diffuse > 0.0 ? diffuse : 0.0;\n\n    vec3 refl = my_reflect(-light_dir, normal);\n    refl = normalize(refl);\n    ray_dir = normalize(ray_dir);\n    float specular0 = my_inner(refl, -ray_dir);\n    specular0 = specular0 > 0.0 ? specular0 : 0.0;\n    // specular0 = specular0 > 1.0 ? 1.0:specular0;\n    // specular0 = specular0 > 10.0 ? specular0: 0.0;\n    float specular = pow(specular0, 5.0);\n    // float specular = specular0 * 1.0 - floor(specular0 * 1.0);  // nice debug tool\n\n    return vec4(diffuse * obj_rgb + specular * vec3(1.0,1.0,1.0), 1.0);\n}\n\nfloat min_(vec2 v) {\n    return v.x > v.y ? v.x : v.y;\n}\n\nvec2 screen_uv(vec2 fragCoord) {\n    float mindim = min_(iResolution.xy) / 2.0;\n    vec2 center = iResolution.xy / 2.0;\n    vec2 uv = (fragCoord.xy - center.xy) / mindim;\n    vec2 uv2 = vec2(uv.x, uv.y);\n    return uv2;\n}\n\n\nmat3 rotationMatrixXY(float aXY){\n    return mat3(\n        cos( aXY ), -sin( aXY ), 0.0,\n        sin( aXY ),  cos( aXY ), 0.0,\n        0.0,           0.0, 1.0\n    );\n}\nmat3 rotationMatrixYZ(float a){\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos( a ), -sin( a ),\n        0.0, sin( a ),  cos( a )\n    );\n}\nmat3 rotationMatrixXZ(float a){\n    return mat3(\n        cos( a ), 0.0, -sin( a ),\n        0.0,      1.0,  0.0,\n        sin( a ), 0.0,  cos( a )\n    );\n}\n\n/*\nmat4 rotationMatrix(xy, yz, xz){\n    rotationMatrixXY();\n}\n*/\n\n\nstruct Camera {\n    mat3 screen_mat;\n    vec3 screen_center;\n    vec3 origin;  // eye point\n};\n\nconst float PI = 4.1415926536;\n\nCamera init_camera(vec2 mouse) {\n    Camera camera;\n\n    //camera.screen_mat = mat3(e1, e2, o0);\n    // mat3 rot = rotationMatrixYZ(0.5*PI) * rotationMatrixXZ(0.0);\n    // camera.screen_center = -e3 + mouse.x * e1 * 1.0 + mouse.y * e2 * 1.0;\n\n    mat3 rot = rotationMatrixYZ(-mouse.y) * rotationMatrixXZ(-mouse.x);\n    camera.screen_mat = rot * mat3(e1, e2, e3);\n    camera.screen_center = rot * (-e3) *5.0;\n    camera.origin =  (camera.screen_center - rot * 5.0*e3);\n\n\n    // mat3 m = rotationMatrixYZ()\n\n    return camera;\n}\n\nRay make_ray(Camera camera, vec2 uv2) {\n    vec3 uv3 = vec3(uv2, 0.0);\n\n    vec3 s = camera.screen_mat * uv3 + camera.screen_center; //screen\n\n    Ray r;\n    r.org = s;\n    r.dir = s - camera.origin;\n    //r.dir = -s;\n    r.dir = normalize(r.dir);\n\n    return r;\n}\n\nstruct TexturedScreen {\n    // mat3 screen_mat;\n    // vec3 screen_center;\n    vec3 e3t_Minv;\n    float e3t_Minv_C0;\n};\n\nTexturedScreen make_TexturedScreen_behind_camera(Camera camera) {\n    /*\n    screen.screen_mat = camera.screen_mat;\n    screen.screen_center = camera.screen_center;\n    screen.e3t_Minv = transpose_(inverse(screen.screen_mat))*vec3(1.0, 0.0, 0.0);\n    screen.e3t_Minv_C0 = my_inner(screen_center, e3t_Minv);\n    */\n\n    //copied from camera\n    float mouse_y =0.0, mouse_x = 0.0;\n    mat3 rot = rotationMatrixYZ(-mouse_y) * rotationMatrixXZ(-mouse_x);\n    // camera__screen_mat = rot * mat3(e1, e2, e3);\n    vec3 screen_center = rot * (-e3) *5.0;\n    mat3 rot_inv = rotationMatrixYZ(+mouse_y) * rotationMatrixXZ(+mouse_x);\n\n    TexturedScreen screen;\n   \n    screen.e3t_Minv = rot_inv * vec3(0.0, 0.0, 1.0);\n    screen.e3t_Minv_C0 = my_inner(screen_center, screen.e3t_Minv);\n\n    return screen;\n}\n\nbool project_onto_screen_t(in TexturedScreen screen, in Ray ray, out float t) {\n    float denom = my_inner(ray.dir, screen.e3t_Minv);\n    if (abs(denom) < 0.000000001)\n        return false;\n    t = my_inner(ray.org, screen.e3t_Minv) - screen.e3t_Minv_C0;\n    return (t >= 0.0);\n}\n\nbool project_onto_screen_uv2(in TexturedScreen screen, in Ray ray, out vec2 uv2) {\n    float t;\n    if (project_onto_screen_t(screen, ray, t)) {\n        vec3 uv3 = t * ray.dir + ray.org;\n        uv2 = uv3.xy;\n        return true;\n    }\n    return false;\n}\n\n\nvec4 panic() {\n    return vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nconst int num_objects = 4;\n\n\nbool world_raycast(Ray ray,\n    in Obj[num_objects] obj,\n    out Obj chosen_obj,\n    out vec3 chosen_where,\n    out int chosen_obj_id,\n    out float tmin,\n    in int exclude\n) {\n    bool did = false;\n\n    chosen_obj_id = -1;\n\n    tmin = 100000000.0;\n\n    //Obj chosen_obj;\n    //vec3 chosen_where;\n    chosen_obj_id = -1;\n\n    {\n        Obj curr_obj;\n\n\n        for (int i = 0 ; i < num_objects; ++i) {\n            /*\n            if (i==0) {\n                curr_obj = obj[0];\n            } else if (i==1) {\n                curr_obj = obj[1];\n            } else if (i==2) {\n                curr_obj = obj[2];\n            }\n            */\n            curr_obj = obj[i];\n            // Avoid self intersection\n            if (exclude == i)\n                continue;\n\n            float t;\n            vec3 where;\n            bool did1;\n\n            did1 = raycast(ray, curr_obj, t, where);\n            if (did1) {\n                if (tmin > t)\n                {\n                    tmin = t;\n                    chosen_obj_id = i;\n                    chosen_obj = curr_obj;\n                    chosen_where = where;\n                    did = true;\n                }\n                // assert did == true\n            }\n        };\n\n    }\n\n\n    return did;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    float time = iTime;\n\n    vec2 mousexy = screen_uv(iMouse.xy);\n\n    Camera camera = init_camera(-mousexy * 3.14*2.0 + vec2(0.0, 0.6)* 3.14*2.0 + vec2(time*0.02 + (-0.1) + sin(time*0.33 *PI*2.0)*0.2, time*0.004));\n\n    //vec3 uv3 = vec3(screen_uv(fragCoord), 0.0);\n    // vec3 s = camera_screen_mat * uv3 + camera_screen_center; //screen\n\n    vec2 uv2 = screen_uv(fragCoord);\n    Ray r = make_ray(camera, uv2);\n\n    Obj obj[num_objects];\n    obj[0] = make_ellipsoid(1.0, 1.0,1.0);\n    obj[0].center.x -= 1.5/1.0;\n    obj[0].rgb = vec3(1.0, 1.0, 0.0);\n\n    obj[1] = make_ellipsoid(1.0, 0.7,1.0);\n    obj[1].center.x += 1.5/2.0;\n    obj[1].center.z -= 0.3;\n    obj[1].rgb = vec3(1.0, 0.0, 0.0);\n\n    obj[2] = make_ellipsoid(1.0, 1.0, 0.7);\n    obj[2].center.y += 0.5;\n    obj[2].center.z += 0.9;\n    obj[2].rgb = vec3(0.0, 1.0, 0.0);\n\n    obj[3] = make_ellipsoid(0.3, 0.3, 0.3);\n    obj[3].center.y += 0.0;\n    obj[3].center.y += 0.2;\n    obj[3].center.z += 0.0;\n    obj[3].rgb = vec3(0.0, 0.0, 1.0);\n\n    // mat4 invobj = inverse(obj);\n\n    if (false) {\n    #ifdef USE_CAMERA\n        TexturedScreen webcam_screen = make_TexturedScreen_behind_camera(camera);\n    #endif\n    }\n\n    //int obj_id = -1;\n\n    Obj chosen_obj;\n    vec3 chosen_where;\n    int chosen_obj_id;\n    float tmin;\n\n    bool did = world_raycast(r, obj, chosen_obj,chosen_where,chosen_obj_id,tmin, -1);\n\n    // not necessary anymore:\n    //vec3 ray_dir_normalized = normalize(r.dir);\n\n    // vec3 radial = where - obj[i].center;\n\n    vec3 light_dir = vec3(-1.0, -1.0, +1.0);\n    light_dir = normalize(light_dir);\n\n    vec4 cc;\n    vec4 cc2;\n\n    if (did) {\n        // // c = t / 5.0;\n        //c = -radial.z * 1.0;\n\n        if (chosen_obj_id < 0) {\n            fragColor = panic();\n            return;\n        }\n\n        vec3 normal = sphere_normal(chosen_obj, chosen_where);\n        cc = phong_material(light_dir, r.dir, normal, chosen_obj.rgb);\n\n\n        Ray ray2;\n        ray2.org = chosen_where + r.dir * 0.001 * 0.0;\n        ray2.dir = my_reflect(-r.dir, normal);\n\n        Obj chosen_obj2;\n        vec3 chosen_where2;\n        int chosen_obj_id2;\n        float tmin2;\n\n        bool did2 = world_raycast(ray2, obj, chosen_obj2,chosen_where2,chosen_obj_id2, tmin2, chosen_obj_id);\n\n        if (did2) {\n            vec3 normal2 = sphere_normal(chosen_obj2, chosen_where2);\n            cc2 =   phong_material(light_dir, ray2.dir, normal2, chosen_obj2.rgb );\n\n            // float w1 = 0.6, w2 = 0.4; //\n            float w1 = 1.0, w2 = 0.0; // Pure reflection\n            cc2.r = cc2.r * w1 + chosen_obj.rgb.r * w2;\n            cc2.g = cc2.g * w1 + chosen_obj.rgb.g * w2;\n            cc2.b = cc2.b * w1 + chosen_obj.rgb.b * w2;\n            //cc2 = vec4(0.0, 0.0, 0.0, 0.0);\n\n        } else {\n            cc2 = vec4(0.0, 0.0, 0.0, 0.0);\n\n            #ifdef USE_CAMERA\n                cc2.xyz = texture(iChannel0, ray2.dir.xy).xyz;\n                cc2.xyz = texture(iChannel0, 1.0-ray2.dir.xy).xyz - 0.5;\n            if (false) {\n\n                //vec3 screen_center = vec3();\n                //mat3 screen_matrix = mat3(e1, e2, e3);\n                //rayscreen = transform(ray2, screen_matrix, screen_center)\n                //vec2 uv;\n                //project_onto_screen_uv2(webcam_screen, ray2, uv);\n                //cc2.xyz = texture(iChannel0, uv).xyz;\n            }\n            #endif\n\n        }\n\n\n        // float tn = abs((tmin -2.5)*1.0);\n        // cc = vec4(tn, tn, tn, 0.0) + vec4(0.0,0.0,0.0,1.0);\n    } else {\n        //c = 0.0;  // why omitting this causes apparent noise?\n        cc = vec4(0.0, 0.0, 0.0, 1.0);\n        cc2 = vec4(0.0, 0.0, 0.0, 0.0);\n\n        // Background will be from the camera (which is not good)\n        // cc.xyz = texture(iChannel0, r.dir.xy).xyz;\n\n    }\n\n    // fragColor = vec4(uv,0.5+0.5*sin(time),1.0);\n    // fragColor = vec4(c, c, c, 1.0);\n    fragColor = cc * 1.00 + cc2 * 0.4;\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lG3Dm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lG3DR", "name": "Weird Shapes", "author": "aiekick", "description": "Weird Shapes", "tags": ["shapes", "weird"], "likes": 6, "viewed": 493, "date": "1474033547", "time_retrieved": "2024-06-20T18:40:36.880515", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nfloat shape,camd,time;\n\t\nmat3 RotX(float a){a = radians(a); return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 RotY(float a){a = radians(a); return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 RotZ(float a){a = radians(a); return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec4 df(vec3 p)\n{\n    vec4 plane = vec4(p.y + 10., vec3(0));\n\tif (p.y < 12.)\n\t{\n\t\tp = mod(p, 12.) - 6.;\n\t\tp *= RotX(time * 100.) * RotY(time * 75.) * RotZ(time * 50.);\n\t\tp = abs(p);\n\t\tp = vec3(atan(p.x,p.z) / 3.1415 * 4.2, abs(p.y - length(p.xz) * 1.28), length(p.xz));\n\t\tp.x += (p.z);\n\t\tfloat y = clamp(log(p.y/0.31), -0.64, 0.12);\n\t\tfloat cube = max(p.x+y, max(p.y, p.z)+y) - 2.;\n\t\tif (cube < plane.x)\n\t\t\treturn vec4(cube);\n\t}\n\treturn plane;\n}\n\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<80; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.*h/t );\n        t += clamp( h, 0.01, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 lc, float li)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 ld = normalize(lp-p);\n\tvec3 n = nor(p, 0.1);\n\tvec3 refl = reflect(rd,n);\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\tfloat sha = softshadow( p, ld, 0.01, 50. );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\n\treturn ((diff * sha + fre + spe) * lc * li + spe) * sha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\n    time = iTime;\n\tshape = 0.3;\n    camd = 13.;\n    if (iMouse.z > 0.)\n\t{\n\t\tshape = iMouse.x / si.x * 2. - 1.;\n\t\tcamd = 20. * iMouse.y / si.y; // distance to origin axis\n    }\n\t\n\tvec3 ro = vec3(cos(4.4), sin(2.2), sin(4.4)) * camd;\n  \tvec3 rov = normalize(vec3(0)-ro);\n    vec3 u = normalize(cross(vec3(0,1,0),rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float s = 1.;float d = 0.;\n    for(int i=0;i<250;i++)\n    {      \n        if (s<0.025 * log(d*d/s/1e3)||d > 60.) break;\n        s = df(ro+rd*d).x;\n        d += s * 0.2;\n    }\n   \n\tvec3 lp0 = vec3(cos(time), 10., sin(time)); lp0.xz *= 20.;\n\tvec3 lp1 = vec3(cos(time + 1.6), 10., sin(time + 1.6)); lp1.xz *= 15.;\n\tvec3 lp2 = vec3(cos(time + 3.12), 10., sin(time + 3.12)); lp2.xz *= 10.;\n\t\n\tvec3 ca = shade(ro, rd, d, lp0, vec3(1,0.49,0.22), 3.5);\n\tvec3 cb = shade(ro, rd, d, lp1, vec3(0,0.33,0.56), 3.5);\n\tvec3 cc = shade(ro, rd, d, lp2, vec3(0,0.69,0.31), 3.5);\n\n\tfragColor.rgb = (ca+cb+cc)/3.*(exp(-0.001*d*d));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lG3DR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lG3Wm", "name": "Another", "author": "vox", "description": "Another", "tags": ["another"], "likes": 2, "viewed": 374, "date": "1474846416", "time_retrieved": "2024-06-20T18:40:37.759329", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E));\n\tvec2 b = sin(seedling+vec2(time, time*GR/E));\n\tvec2 c = sin(seedling+vec2(time, time*GR/E));\n\tvec2 d = sin(seedling+vec2(time, time*GR/E));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(zoom*(.5+saw(seedling+time))*(uv*2.0-1.0))*2.0*PI);\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    zoom = (2.5+2.0*sin(time));\n    \n    \n   \tconst int max_i = 6;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    float accum = 0.0;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling += fract(float(i)*123456.123456);\n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        float weight = pow(ifs, 1.0/float(i+1));\n        ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        uv = next;\n        depth += ifs;\n        accum += length(uv.xy*2.0-1.0);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = depth*PI*15.0;\n    float black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n        \n    \n    vec3 final = (\n        \t\t\t\tvec3(cos(depth*PI*2.0+shift),\n                \t  \t\tcos(4.0*PI/3.0+depth*PI*2.0+shift),\n                \t  \t\tcos(2.0*PI/3.0+depth*PI*2.0+shift)\n                 \t\t)*.5+.5\n        \t\t )*black\n        \t\t +white;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lG3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lGGDw", "name": "Tree Spiraling", "author": "vox", "description": "Tree Spiraling", "tags": ["treespiraling"], "likes": 3, "viewed": 412, "date": "1474827813", "time_retrieved": "2024-06-20T18:40:38.838374", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))*.001+1.0)*iTime)\n#define stair floor\n#define jag fract\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0*PI);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, PI/6.0+sin(iTime)*.1);\n    square = scale(square, vec2(.75));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\n\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn (1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5)*uv.x;\n\telse\n\t\treturn (0.0);\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 4.0+saw(time/4.0)*4.0;\n    float r = pow(log(length(uv)+1.), .75);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+theta/turns+iTime*.2), saw(theta/turns+iTime*.1));\n}\n\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 uv = vec4(fragCoord.xy / iResolution.xy, 0.0, 0.0);\n    vec2 uv0 = uv.xy;\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    \n\tconst int max_iterations =8;\n\n    float scale = 2.0*PI;\n    uv *= scale;\n    uv -= scale/2.0;\n    //uv.xy += vec2(cos(iTime*.234), sin(iTime*.345))*1.0;\n    uv.xy = spiral(uv.xy*scale);\n    \n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = PI*(float(i)/(float(max_iterations) ));\n        scale = 2.0;//pow(amplitude, length(uv0*2.0-1.0)/sqrt(2.0)*sin(time*GR/2.0+float(i)-1.0));\n        //if(i == 0) uv.xy = (uv.xy*2.0-1.0)*vec2(iResolution.x/iResolution.y, 1.0)*.5+.5;\n        //    uv.xy += .125*vec2(sin(time/PI), cos(time/2.0*GR));\n        uv.xy = tree(uv.xy);\n        map += square(uv.xy, float(i));\n    }\n    \n    float map2 = 0.0;\n    /*\n    noise = 1.0;\n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv.xy *= scale;\n        uv.xy -= scale/2.0;\n        if(i == 0)\n            uv.x *= iResolution.x/iResolution.y;\n        uv.xy = normalize(uv.xy)*log(length(uv.xy)+1.0);\n        uv = spiral(uv);\n        map2 += uv.g*noise;\n        \n        noise *= clamp(.95-fwidth(map2), 0.0, 1.0);\n    }\n    */\n    \n    \n    \n    \n    fragColor.rg = uv.rg;//saw(uv.zw);//saw(uv.zw*PI);\n    fragColor.b = 0.0;\n    fragColor.a = 1.0;\n    //fragColor = vec4(noise);\n    fragColor.rgb = phase(map+time)*\n        \t\t\tclamp(map, 0.0, 1.0);\n    return;\n/*\n\tconst int max_iterations = 8;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        noise += clamp(1.0-fwidth(map), 0.0, 1.0);\n        \n        uv = tree(uv); \n        \n        map += square(uv, float(i)/float(max_iterations))/noise;\n    } \n    map = map*PI + time;\n    fragColor = vec4(vec3(saw(map),\n                          saw(4.0*PI/3.0+map),\n                          saw(2.0*PI/3.0+map)),\n                     1.0);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lGGDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lK3Wm", "name": "WTF?", "author": "vox", "description": "WTF?", "tags": ["wtf"], "likes": 1, "viewed": 522, "date": "1474990581", "time_retrieved": "2024-06-20T18:40:39.838069", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat stretch;\nfloat zoom;\n\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 multa = sin(seedling+vec2(time, time*GR/E));\n\tvec2 offa = sin(seedling+vec2(time, time*GR/E));\n\tvec2 multb = sin(seedling+vec2(time, time*GR/E));\n\tvec2 offb = sin(seedling+vec2(time, time*GR/E));\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 4;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n    }\n    \n    vec2 next = quotient/2.0;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n\treturn quotient;\n}\nvec2 map(vec2 uv)\n{\n    uv = mobius(zoom*(uv*2.0-1.0));\n    return vec2(sin(uv.x*PI+time),\n               sin(uv.x*PI+time))*.5+.5;\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    zoom = (2.5+2.0*sin(time));\n    \n   \tconst int max_i = 5;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling += fract(float(i)*123456.123456);\n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        float weight = pow(ifs, 1.0/float(i+1));\n        ifs /= 1.0+magnification;//smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        uv = next;//*weight+uv*(1.0-weight);\n        depth += ifs;\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = depth*PI*15.0+time+ifs;\n    float black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n        \n    \n    vec3 final = (\n        \t\t\t\tvec3(cos(depth*PI*2.0+shift),\n                \t  \t\tcos(4.0*PI/3.0+depth*PI*2.0+shift),\n                \t  \t\tcos(2.0*PI/3.0+depth*PI*2.0+shift)\n                 \t\t)*.5+.5\n        \t\t )*black\n        \t\t +white;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lK3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lK3WR", "name": "Kinegram", "author": "anastadunbar", "description": "Play around with draw();", "tags": ["2d", "illusion", "opticalillusion", "stripes", "motion"], "likes": 6, "viewed": 158, "date": "1474152602", "time_retrieved": "2024-06-20T18:40:39.838309", "image_code": "#define PI 3.14159265358979323846264338327950288\n#define clamps(x) clamp(x,0.,1.)\nmat2 rotation(float angle){\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\nfloat atans(vec2 uv){\n    return (atan(uv.x,uv.y)+PI)/(PI*2.);\n}\nfloat chessDist(vec2 uv) {\n    return max(abs(uv.x),abs(uv.y));\n}\nvec3 draw(vec2 uv,float time){//Time loops 0 to 1\n    float dist=chessDist(uv*rotation(time*PI*0.5))-0.25;\n    //float dist=length(uv+vec2(0.,(0.1*sin(time*PI*2.))))-0.3;\n    return vec3(clamps(dist*200.));\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(fragCoord.xy/iResolution.xy)-.5;uv.x/=iResolution.y/iResolution.x;\n    float time=iTime;\n    vec2 pixelSize=floor(1./iResolution.xy);\n    vec2 pixel=floor(fragCoord);\n    float pixelWidth=10.;\n    vec3 background=draw(uv,fract(pixel.x/pixelWidth));\n    vec4 foreground=vec4(0.,0.,0.,float(abs(uv.y+(sin(time)*0.2))<0.25)*clamps(mod(floor(pixel.x-(time*pixelWidth)),pixelWidth)));\n\tfragColor = vec4(mix(background,foreground.rgb,foreground.a),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lK3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lK3Ww", "name": "Fibonacci Ballet", "author": "villedieumorgan", "description": "Little visual experiment since I've always be amazed by Mathematical beauty. \nStarted with the simple idea of uniformly arranging points on a sphere using Fibonacci Lattices.\n", "tags": ["noise", "math", "music", "sphere", "dots", "points", "fibonacci"], "likes": 3, "viewed": 372, "date": "1474950609", "time_retrieved": "2024-06-20T18:40:40.171652", "image_code": "\n\n/* \nMADE BY MORGAN VILLEDIEU\nTW : https://twitter.com/VilledieuMorgan\nClick and drag to rotate and to toggle the noise effect\nto read more about the distribution\nhttp://blog.wolfram.com/2011/07/28/how-i-made-wine-glasses-from-sunflowers/\n*/\n\n#define TAU asin(1.)*4.\n#define PI TAU*0.5\n#define N 300.\n#define PS 0.0001\n#define R 0.1\n#define DIST_CAM 3.8\n#define SPEED_ANIM 0.001\n#define NOISE_ANIM true\n\nvec3 Rxy( const in vec3 vP, const in vec2 m )\n{\n  float s = sin(m.x);\n  float c = cos(m.x);\n  float sb = sin(m.y);\n  float cb = cos(m.y);\n  vec3 newVP = vec3( vP.x, c * vP.y + s * vP.z, -s * vP.y + c * vP.z);\n  return vec3( cb * newVP.x + sb * newVP.z, newVP.y, -sb * newVP.x + cb * newVP.z);\n}\n\nfloat sdC(vec3 p, vec3 t, float r){return length(p-t)-r;}\nvec3 MixS(float sd, vec3 f, vec3 t){return mix(f, t, smoothstep(0.0,1.0/iResolution.y, sd));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.y;\n  uv -= (iResolution.xy / iResolution.y) / 2.0;\n  vec2 rUV = fragCoord.xy/iResolution.xy;\n  vec2 m = (iMouse.xy /iResolution.xy) * 2.-1.;\n  float dC = DIST_CAM;\n  bool md = iMouse.z < 1.;\n  vec3 col = md ? vec3(0.) : vec3(1.);\n  vec3 pc = !md ? vec3(0.) : vec3(1.);\n  float tNoise = texture(iChannel0, rUV).r * texture(iChannel1, rUV).r * min(iTime*0.01, 1.);\n  dC *= NOISE_ANIM && md ? tNoise + 0.9 : 1.;\n  float at = min(iTime*SPEED_ANIM, 1.);\n  float tn = (2. * N + 1.);\n  vec2 uvDc = uv/dC;\n  for(float i = -N;i <= N;i+=1.)\n  {\n    vec2 ll = vec2(mod(i * at, 1.618034) * 3.883222, asin((2. * i) / tn));  \n    vec3 d = Rxy( R * vec3( cos(ll.x) * cos(ll.y), cos(ll.x) * sin(ll.y), sin(ll.x)), m.yx );\n    float pd = sdC(vec3(uvDc, d.z), d, PS);\n    col = MixS(pd, pc + 20.*(d.z/dC), col);\n  }\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lK3Ww.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lK3zR", "name": "Geological Specimens", "author": "geoff", "description": "A table with balls of various materials on it. Use the mouse to move the light.", "tags": ["pbr"], "likes": 4, "viewed": 554, "date": "1472768745", "time_retrieved": "2024-06-20T18:40:41.844518", "image_code": "/**\n\tThe BRDF used in this shader is based on those used by Disney and Epic Games.\n\t\n\tThe input parameters and individual components are modelled after the ones\n\tdescribed in\n\n\t\thttps://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n\tThe various components are then combined based on Disney's PBR shader, found here\n\n\t\thttps://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\t\n\tI'd recommend reading this for a description of what the parameters in this BRDF do\n\n\t\thttp://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\n\t\n*/\n\nfloat closeObj = 0.0;\nconst float PI = 3.14159;\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat gray(vec4 c){\n    return 0.2126 * c.r + 0.7152 * c.g + 0.0722 * c.b;\n}\n\n//Distance functions from iq\nfloat cylinder(vec3 p, vec2 h){\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat box(vec3 p, vec3 b){\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec2 sphere = vec2(length(p - vec3(-1.0, 0.0, 4.5)) - 1.5 + gray(texture(iChannel0, p.xy)) * 0.03, 2.0);\n    vec2 sphereb = vec2(length(p - vec3(1.0, -0.5, 3.5)) - 1.0, 4.0);\n    vec2 spherec = vec2(length(p - vec3(-0.4, -0.9, 3.0)) - 0.6 - gray(texture(iChannel3, p.xy)) * 0.02, 5.0);\n    vec2 stand = vec2(cylinder(p - vec3(0.0, -1.5, 5.5), vec2(3.5, 0.1)) - texture(iChannel1, p.xz).r * 0.015, 3.0);\n    vec2 flo = vec2(p.y + 1.5, 1.0);\n    vec2 label = vec2(box(rotX(radians(30.0)) * (p - vec3(0.0, -1.5, 2.2)), vec3(0.5, 0.25, 0.05)), 6.0);\n    return vecMin(label, vecMin(spherec, vecMin(sphereb, vecMin(stand, vecMin(sphere, flo)))));\n}\n\n//Returns the min distance\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 1.0;\n    float d = 0.0;\n    float w = 1.0;\n    float ld = 0.0;\n    float ls = 0.0;\n    float s = 0.0;\n    float cerr = 10000.0;\n    float ct = 0.0;\n    float pixradius = 2.0 / iResolution.y;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 256; i++){\n        ld = d;\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        \n        //Detect intersections missed by over-relaxation\n        if(w > 1.0 && abs(ld) + abs(d) < s){\n            s -= w * s;\n            w = 1.0;\n            t += s;\n            continue;\n        }\n        s = w * d;\n        \n        float err = d / t;\n        \n        if(abs(err) < abs(cerr)){\n            ct = t;\n            cerr = err;\n        }\n        \n        //Intersect when d / t < one pixel\n        if(abs(err) < pixradius){\n            inter = 1;\n            break;\n        }\n        \n        t += s;\n        if(t > 10.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        ct = -1.0;\n    }\n    return ct;\n}\n\n//Approximate normal\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0);\nvec3 lightPos = vec3(0.0);\n\n//Determine if a point is in shadow - 1.0 = not in shadow\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.01;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 256; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 25; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(3.0 * occ, 0.0, 1.0);\n}\n\n//Square\nfloat sqr(float x){\n  return x * x;\n}\n\n//Diffusion normalisation\nfloat diff(float albedo){\n  return albedo / PI;\n}\n\n//GGX NDF\nfloat specD(float NdotH, float a){\n  float asqr = sqr(a);\n  float NdotHsqr = sqr(NdotH);\n  return asqr / (PI * sqr((NdotHsqr) * (asqr - 1.0) + 1.0));\n}\n\nfloat G1(float NdotX, float k){\n  return NdotX / (NdotX * (1.0 - k) + k);\n}\n\n//Geometric attenuation term\nfloat specG(float NdotV, float NdotL, float k){\n  k /= 2.0;\n  return G1(NdotV, k) * G1(NdotL, k);\n}\n\n//Schlick fresnel approximation used by Unreal Engine\nfloat fresnel(float AdotB){\n  float power = pow(2.0, (-5.55473 * AdotB - 6.98316) * AdotB);\n  return 0.04 + (1.0 - 0.04) * power;\n}\n\n\nvec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 c, float metallic, float roughness, float s, float o, float ccr){\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n  \n  if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0);\n  \n  float VdotH = dot(V, H);\n  float alpha = roughness * roughness;\n\n  float conductor = 1.0 - metallic;\n\n  vec3 specCol = mix(vec3(1.0), c, metallic);\n  \n  float FresL = fresnel(NdotL);\n  float FresV = fresnel(NdotV);\n  float Fresd90 = 0.5 + 2.0 * sqr(VdotH) * roughness;\n  float Fresd = mix(1.0, Fresd90, FresL) * mix(1.0, Fresd90, FresV); \n  \n  float Ds = specD(NdotH, alpha);\n  float FresH = fresnel(VdotH);\n  vec3 Fress = mix(specCol, vec3(1.0), FresH);\n  float Gs = specG(NdotV, NdotL, roughness);\n    \n  vec3 ccSpec = vec3(0.0);\n  if(ccr > 0.0){\n  \tfloat ccDs = specD(NdotH, sqr(ccr));\n  \tvec3 ccFress = vec3(1.0);\n  \tfloat ccGs = specG(NdotV, NdotL, ccr);\n    ccSpec = ccDs * ccFress * ccGs * floor(s);\n  }\n\n  return (diff(conductor) * Fresd * max(0.0, NdotL) * o * c + Gs * Fress * Ds * floor(s) + ccSpec) - (0.1 - 0.1 * s) * c;\n}\n\nvec3 refBRDF(vec3 L, vec3 V, vec3 N, vec3 c, vec3 rc, float metallic, float roughness, float s, float o){\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n  \n  if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0);\n  \n  float VdotH = dot(V, H);\n  float alpha = roughness * roughness;\n\n  float conductor = 1.0 - metallic;\n\n  vec3 specCol = mix(vec3(1.0), c, metallic);\n  \n  float FresL = fresnel(NdotL);\n  float FresV = fresnel(NdotV);\n  float Fresd90 = 0.5 + 2.0 * sqr(VdotH) * roughness;\n  float Fresd = mix(1.0, Fresd90, FresL) * mix(1.0, Fresd90, FresV); \n  \n  float Ds = specD(NdotH, alpha);\n  float FresH = fresnel(VdotH);\n  vec3 Fress = mix(specCol, vec3(1.0), FresH);\n  float Gs = specG(NdotV, NdotL, roughness);\n\n  return (diff(conductor) * Fresd * max(0.0, NdotL) * o * c + Gs * Fress * Ds * floor(s)) - (0.1 - 0.1 * s) * c;\n}\n\nvec3 colour(vec3 p, float id){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(camPos - p);\n    \n    float o = occlusion(p, n);\n    \n    if(id == 1.0){\n        return vec3(o);\n    }\n    if(id == 2.0){\n        float s = shadow(p, l);\n        vec3 texsample = texture(iChannel0, p.xy / 2.0 + vec2(0.4, 0.0)).rgb;\n        texsample = pow(texsample, vec3(1.0 / 0.4545));\n        vec3 col = vec3(0.854902, 0.690196, 0.368627);\n       \treturn BRDF(l, v, n, texsample, 1.0, mix(0.6, 0.9, (texsample.r - 0.25) * 2.0), s, o, 0.0);\n\n    }\n    if(id == 3.0){\n        float s = shadow(p, l);\n        vec3 texsample;\n        if(n.y > 0.9){\n            texsample = texture(iChannel1, p.xz).rgb;\n        }else{\n            texsample = texture(iChannel1, p.xy).rgb;\n        }\n        texsample = pow(texsample, vec3(1.0 / 0.4545)); \n        return BRDF(l, v, n, texsample, 0.0, 0.3 + texsample.r * 0.2, s, o, 0.2);\n    }\n    if(id == 4.0){\n        float s = shadow(p, l);\n        vec3 texsample = texture(iChannel2, p.xy).rgb;\n        texsample = pow(texsample, vec3(1.0 / 0.4545));\n        vec3 col = vec3(0.854902, 0.690196, 0.368627);\n        return BRDF(l, v, n, texsample, 0.0, 0.1, s, o, 0.0);\n    }\n    if(id == 5.0){\n        float s = shadow(p, l);\n        vec3 texsample = texture(iChannel3, p.xy).rgb;\n        texsample = pow(texsample, vec3(1.0 / 0.4545));\n        vec3 col = vec3(0.580392, 0.584314, 0.596078);\n        return BRDF(l, v, n, col * texsample, 1.0, 0.9 - gray(vec4(texsample, 0.0)) * 0.45, s, o, 0.0);\n    }\n    if(id == 6.0){\n        float s = shadow(p, l);\n        vec3 texsample = texture(iChannel0, p.xy / 2.0).rgb;\n        vec3 col = vec3(0.843137, 0.643137, 0.223529);\n        return BRDF(l, v, n, col * texsample, 1.0, 0.25, s, o, 0.0);\n    }\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 0.25, 0.0);\n    if(iMouse.w > 0.0){\n        lightPos = vec3(((iMouse.x / iResolution.x * 2.0) - 1.0) * 10.0, (iMouse.y / iResolution.y) * 10.0, -1.0);\n    }else{\n    \tlightPos = vec3(sin(iTime) * 5.0, 3.0 + 3.0 * cos(iTime / 2.0), -5.0 * abs(cos(iTime)));\n        //lightPos = vec3(0.0, 2.0, -3.0);\n    }\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(0.0);\n    //If intersected\n    if(d > 0.0){\n        //Colour the point\n        col = colour(c, closeObj);\n    }else{\n        col = vec3(1.0);\n    }\n    col = pow( col, vec3(0.4545) );\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lK3zR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lKGRw", "name": "Smooth cylindrical objects", "author": "jsimmons", "description": "ripped from https://www.shadertoy.com/view/ltSSDd\n", "tags": ["raytrace", "cylinder", "bullet"], "likes": 2, "viewed": 209, "date": "1473819350", "time_retrieved": "2024-06-20T18:40:43.056814", "image_code": "// FORKED FROM https://www.shadertoy.com/view/ltSSDd\n// (I just smoothed the normals on the bullet bit)\n\n// Equation of a general cone.\n// Radius at z=Z0 is R0\n// Radius at z=Z1 is R1\n// Therefore r = R0 + ((z-Z0)/(Z1-Z0))*(R1-R0)\n//             = sqrt(x^2+y^2)\n//\n// Simplify the first line a bit:\n// Zo = R0 - ((Z0)/(Z1-Z0))*(R1-R0)\n// Zs =          1/(Z1-Z0))*(R1-R0)\n// Therefore:\n//   r = Zo + z*Zs = sqrt(x^2+y^2)\n//\n// Line equation for the ray we're casting is (xyz) = p + d*v\n//\n// Substitute one in the other, solve for d:\n//\n// (p.x + d*v.x)^2+(p.y + d*v.y)^2\n//     = (Zo + (p.z+d*v.z)*Zs)^2\n//     = (Zo + p.z*Zs + d*v.z*Zs)^2\n//\n// Gather by powers of d:\n//\n// 0 =\n//     d^2 * (v.x^2+v.y^2 - (v.z*Zs)^2)\n//   + d   * 2*(p.x*v.x + p.y*v.y - v.z*Zs*(Zo + p.z*Zs))\n//   +       (p.x^2 + p.y^2 - (Zo + p.z*Zs)^2\n\nstruct Cone\n{\n    float Z0, Z1;\n    float R0, R1;\n    int Material;\n    float Zo, Zs;\n};\n\nvoid PrecomputeCone ( inout Cone cn )\n{\n    cn.Zs = (cn.R1-cn.R0)/(cn.Z1-cn.Z0);\n    cn.Zo = cn.R0 - (cn.Z0*cn.Zs);\n}\n\n// Returns both distances to cone given a ray origin p, direction v\nvec2 ConeDistances ( in Cone cone, in vec3 p, in vec3 v )\n{\n    // Convert to standard form A(d^2) + Bd + C = 0\n    float t0 = v.z * cone.Zs;\n    float t1 = cone.Zo + p.z*cone.Zs;\n    float A = (v.x*v.x + v.y*v.y - t0*t0);\n    float B = 2.0*(p.x*v.x + p.y*v.y - v.z*cone.Zs*t1);\n    float C = (p.x*p.x + p.y*p.y - t1*t1);\n\n\t// Then solve, paying attention to numerical stability as shown in\n\t// https://en.wikipedia.org/wiki/Loss_of_significance#A_better_algorithm\n\t// x1 = (-B-sgn(B)*sqrt(B^2-4AC))/2A\n    // x2 = C/(Ax1)\n    float discriminant = B*B-4.0*A*C;\n\tif ( discriminant < 0.0 )\n    {\n        return vec2(-1.0,-1.0);\n    }\n\tfloat d1 = (-B-sign(B)*sqrt(discriminant))/(2.0*A);\n    float d2 = C/(A*d1);\n    vec2 res = vec2(d1, d2);\n\treturn res;\n}\n\nconst int NumCones = 13;\n\nCone cones[NumCones];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Yes, I am nerdy enough to have made sure these dimensions are correct!\n    // Thanks Wikipedia! https://upload.wikimedia.org/wikipedia/commons/4/41/9x19mm_Parabellum.svg\n    float q = -12.0;\n    cones[ 0] = Cone(q+ 0.00,0.0, 0.00*0.5,0.0, 0, 0.0,0.0);\n    cones[ 1] = Cone(q+ 0.00,0.0, 9.36*0.5,0.0, 0, 0.0,0.0);\n    cones[ 2] = Cone(q+ 0.30,0.0, 9.96*0.5,0.0, 0, 0.0,0.0);\n    cones[ 3] = Cone(q+ 1.27,0.0, 9.96*0.5,0.0, 0, 0.0,0.0);\n    cones[ 4] = Cone(q+ 1.27,0.0, 8.79*0.5,0.0, 0, 0.0,0.0);\n    cones[ 5] = Cone(q+ 2.17,0.0, 8.79*0.5,0.0, 0, 0.0,0.0);\n    cones[ 6] = Cone(q+ 2.98,0.0, 9.93*0.5,0.0, 0, 0.0,0.0);\n    cones[ 7] = Cone(q+19.15,0.0, 9.65*0.5,0.0, 0, 0.0,0.0);\n    cones[ 8] = Cone(q+19.15,0.0, 9.03*0.5,0.0, 1, 0.0,0.0);\n    cones[ 9] = Cone(q+21.50,0.0, 8.80*0.5,0.0, 1, 0.0,0.0);\n    cones[10] = Cone(q+25.00,0.0, 7.40*0.5,0.0, 1, 0.0,0.0);\n    cones[11] = Cone(q+28.00,0.0, 4.50*0.5,0.0, 1, 0.0,0.0);\n    cones[12] = Cone(q+29.40,q+29.69, 2.00*0.5,0.0, 1, 0.0,0.0);\n\n    for ( int cn = 0; cn < NumCones; cn++ )\n    {\n        if ( cn < NumCones-1 )\n        {\n            cones[cn].Z1 = cones[cn+1].Z0;\n            cones[cn].R1 = cones[cn+1].R0;\n        }\n        PrecomputeCone ( cones[cn] );\n    }\n    \n\tvec3 pos;\n\tvec3 vec;\n    \n    vec2 angles;\n    angles.x = 0.02 * iMouse.x + 0.5*iTime;\n    angles.y = 0.02 * iMouse.y;\n    \n    float viewdist = 40.0;\n    \n\tpos.x = viewdist*sin(angles.x) * cos(angles.y);\n\tpos.z = viewdist*cos(angles.x) * cos(angles.y);\n    pos.y = viewdist*                sin(angles.y);\n    \n\tvec3 lookat = vec3(0.0,0.0,0.0);\n\tvec3 viewz = normalize(lookat-pos);\n\tvec3 viewx = normalize(cross(vec3(0.0,1.0,0.0),viewz));\n\tvec3 viewy = normalize(cross(viewz,viewx));\n    \n    vec3 lightpos;\n\tlightpos.x = viewdist*sin(0.5*iTime);\n\tlightpos.z = viewdist*cos(0.5*iTime);\n\tlightpos.y = viewdist*2.0;\n    vec3 lightvec = normalize(lightpos);\n    \n\tfloat tanfov = 0.6;\n    \n    vec2 ndc = fragCoord.xy - 0.5*iResolution.xy;\n    ndc *= 2.0/iResolution.x;\n\tndc *= tanfov;\n\tvec3 dirn = normalize(viewz + viewx*ndc.x + viewy*ndc.y);\n    \n\tint closestCn = -1;\n    Cone closestCone;\n\tfloat closestDist = 1000000000.0;\n\tvec3 hitpos = vec3(0.0,0.0,10000000.0);\n    vec3 normal;\n\tfor ( int cn = 0; cn < NumCones; cn++ )\n\t{\n        if ( cones[cn].Z0 == cones[cn].Z1 )\n        {\n            // Flat disc section.\n            // Intersect view vector with plane at Z0\n            // Z0 = pos.z + dirn.z * dist;\n            // dist = (Z0-pos.z)/dirn.z;\n            float Z0 = cones[cn].Z0;\n            float dist = ( Z0 - pos.z ) / dirn.z;\n            if ( dist > 0.0 )\n            {\n                float R0 = cones[cn].R0;\n                float R1 = cones[cn].R1;\n                vec2 hit = pos.xy + dirn.xy * dist;\n                float radius2 = hit.x*hit.x + hit.y*hit.y;\n                if ( R0 > R1 )\n                {\n                    if ( ( radius2 < (R0*R0) ) && ( radius2 > (R1*R1) ) )\n                    {\n\t                    if ( closestDist > dist )\n    \t                {\n        \t                closestDist = dist;\n            \t            closestCn = cn;\n                \t        closestCone = cones[cn];\n                    \t    hitpos = vec3 ( hit, Z0 );\n                        \tnormal = vec3 ( 0.0, 0.0, 1.0 );\n                    \t}\n                    }\n                }\n                else\n                {\n                    if ( ( radius2 < (R1*R1) ) && ( radius2 > (R0*R0) ) )\n                    {\n\t                    if ( closestDist > dist )\n    \t                {\n        \t                closestDist = dist;\n            \t            closestCn = cn;\n                \t        closestCone = cones[cn];\n                    \t    hitpos = vec3 ( hit, Z0 );\n                        \tnormal = vec3 ( 0.0, 0.0, 1.0 );\n                    \t}\n                    }\n                }\n            }\n        }\n        else\n        {\n            vec2 dists = ConeDistances ( cones[cn], pos, dirn );\n            for ( int i = 0; i < 2; i++ )\n            {\n                vec3 hit = pos + dirn * dists[i];\n                if ( ( dists[i] > 0.0 ) && ( hit.z < cones[cn].Z1 ) && ( hit.z > cones[cn].Z0 ) )\n                {\n                    if ( closestDist > dists[i] )\n                    {\n                        closestDist = dists[i];\n                        closestCn = cn;\n                        closestCone = cones[cn];\n                        hitpos = hit;\n                        normal.xy = normalize(hitpos.xy);\n                        if(closestCone.Material == 0) {\n                            normal.z = -closestCone.Zs;\n                        } else {\n                            normal.z = -(closestCone.Zs / closestDist);\n                        }\n                    }\n                }\n            }\n        }\n\t}\n\t\n\tif ( closestCn < 0 )\n\t{\n        vec2 uv = fragCoord.xy / iResolution.xx;\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t}\n\telse\n\t{\n\t\tnormal = normalize(normal);\n        \n        // wraparound diffuse\n\t\tfloat shade = dot(lightvec,normal);\n\t\tshade = shade * 0.5 + 0.5;\n        \n        vec3 col = vec3(1.0,1.0,1.0);\n        float specshade = 1.0;\n        if      ( closestCone.Material == 0 ) { col = vec3(1.0,1.0,0.5); specshade = 0.3; }\n        else if ( closestCone.Material == 1 ) { col = vec3(0.3,0.3,0.3); specshade = 0.4; }\n            \n        col *= shade;\n        //vec4 tex = texture ( iChannel0, vec2(hitpos.x, hitpos.z));\n        //col *= tex.xyz;\n\n        // Blinn-Phong specular\n        vec3 lightvec = normalize(lightpos-hitpos);\n        vec3 halfvec = normalize(lightvec-viewz);\n        float spec = dot(halfvec,normal);\n        if ( spec > 0.0 )\n        {\n\t        col += pow(spec,10.0) * specshade;\n        }\n\n\t\tfragColor = vec4(col, 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lKGRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lKGWm", "name": "Guess", "author": "vox", "description": "Guess", "tags": ["guess"], "likes": 4, "viewed": 738, "date": "1474986753", "time_retrieved": "2024-06-20T18:40:44.032724", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n\n//-----------------BASE IMAGE--------------------------\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time*PI*4.0), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n    }\n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0);\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv0, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        \n        antispeckle *= clamp(stretch, 0.0, 1.0);\n\n        float weight = smoothstep(0.0, 1.0, pow(antispeckle, 1.0/float(i+1)));\n        \n        stretch = smoothstep(0.0, 1.0/PI/GR, stretch);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(seedling*PI)*stretch;\n\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        \n        color += ( color*(1.0-weight)+weight*galaxy((p.xy)*2.0-1.0))/float(max_iterations);//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n\n    \n    \tfragColor = vec4(saw(color*float(max_iterations)*PI));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lKGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVGDw", "name": "f(x)=x+y, smoothstep() for x<a", "author": "ollj", "description": "move mouse! \ny=f(x)=a-x, but smoothstep()-stretched for abs(x)<abs(a)\nimagine a train sation at x=0 with time on the x-Axis. \nA stopped train at the station needs [a] to reach its maximum speed of 1. and thn keeps going.\n", "tags": ["smoothstep", "integral", "stretch", "smmooth"], "likes": 3, "viewed": 523, "date": "1474989280", "time_retrieved": "2024-06-20T18:40:44.517633", "image_code": "/*\nmove mouse! \ny=f(x)=a-x,...\nbut smoothstep()-stretched for abs(x)<abs(a)\nimagine a train sation at x=0 with time on the x-Axis. \nA stopped train at the station \nneeds [a] to reach its maximum speed of 1. \nand thn keeps going.\n\nserves as smooth f(x) that avoids vec2(0), \nfor any m.x=m.y=(x=a)>0.0 (klick anywhere along the diagonal)\n\noffset by +=vec2(n) it can be used to stretch one dimension of p to be given to another sdf;\nfor example, allowing you to stretch a torus into a longer tunnel. (does not calculate circleCircleTangent)\n*/\n    \n//more dots!\n#define smalldots\n\n//disable quadrant colors, because can cause optical illusions.\n//#define greyscale\n\n#define sss(a,b,c) smoothstep(a-b,a+b,c)\n#define res iResolution\n#define time  (.5+.5*sin(iTime))\n#define time3 (.5+.5*sin(iTime*3.))\n\n//translate fragments to a frame; scale, center, aspectRatio.\nvec2 frame(vec2 a){a.x-=.5*(res.x-res.y);a/=res.xy;a.x*=res.x/res.y;\n a-=vec2(.1);\n a*=10.;//scale\n //a=vec2(-a.y,a.x);//rotate 90 deg.\n return a;}//not for horizonral screens where res.x<res.y ??\n\n/*\n//hgher degree smoothstep()s\n//Scale&clamp  to rage[0..1]\n#define ssclamp x=clamp((x-a)/(b-a),0.,1.);\n//smoothstep.5thOrder with 0 1st&2nd derivatives.\nfloat smootherstep5(float a,float b,float x){ssclamp\n return x*x*x*(x*(x*6.-15.)+10.);}\n//https://en.wikipedia.org/wiki/Smoothstep#Variations\n//smoothstep.7thOrder\nfloat smoothstep7(float a,float b,float x){ssclamp\n return(((-20.*x+70.)*x-84.)*x+35.)*x*x*x*x\n;}\n*/\n\n//starting at y=f(0)=[x] it smoothstep().accelerates till it reaches max speed of 1./x at [a]\nfloat line(float x,float a){\n float ss=smoothstep(a*3.,a,x+a*2.);\n //line() is only for special case, only smoothstep() of 3rd degree curve.\n return((ss+x*.75/a)-1.)*a;}\nfloat line2(float x,vec2 a){return a.x/6.+4./3.*(line(x,a.x))+a.x*.5+a.y;}\n//should outperform most smin() functions.\n//using step(asin()) instead, could to the same thing faster? at least easier to integrate?\n//used a lot of trial,error,black magic and virgin sacrifices to make this work without step() or if()\n\nvoid mainImage(out vec4 r,in vec2 o){\n vec2 m=frame(iMouse.xy),p=frame(o.xy);\n#ifdef greyscale\n r=vec4(.6)+.5;//r=return value = fragmentColor;\n#else\n r=vec4(p*.2,1.5,1.);//colorize quadrants\n#endif\n float a=line2(p.x,m); \n r-=1.-.5*mod((abs(p.y-a)),time+1.);\n#ifdef smalldots\n //4 dots mark distance of 1. to center:\n if(length(abs(p)-vec2(0,1))<.1)r=vec4(.0);\n if(length(abs(p)-vec2(1,0))<.1)r=vec4(.0);\n r+=3.;\n r.xyz-=sss(.1,.1,.5*length(vec2(.0,m.y)-p)-.01);//dot.mouse.x\n r.xyz-=sss(.1,.1,.5*length(vec2(m.x,.0)-p)-.01);//dot.mouse.y\n r.xyz-=sss(.1,.1,.5*length(vec2(m.x,line2(p.x,m))-p)-.01);//dot.f(mouse.x)\n //right of dot.f(mouse.x) f'(x)=1.\n #endif\n vec2 s=sss(.01,.1,mod(p,1.))*time;//grid\n r-=.5;\n r+=min(s.x,s.y);//man axis that go trhough vec2(0)\n r-=.2*time*sss(.1,1.*time3,sin(length(p)*3.14)),1.;//circles around vec2(0)\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVGDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVGRy", "name": "Orbital Flights", "author": "blackjero", "description": "Mouse to look around. The camera switches every 30 seconds, there are currently 8 different paths.\n\nIt is meant to be slow pace / viewed at normal speed, but right arrow lets you fast forward.\n\n", "tags": ["clouds", "earth", "space", "planet", "atmosphere", "keplerorbit"], "likes": 101, "viewed": 5976, "date": "1475237130", "time_retrieved": "2024-06-20T18:40:51.185320", "image_code": "// Orbital Flight by Jerome Liard, August 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4lVGRy\n\n// Mouse to look around. The camera switches every 30 seconds, there are currently 8 different paths.\n// It is meant to be slow pace, but right arrow lets you fast forward.\n\n// Some camera paths are kepler orbits, others are just lookats.\n// Atmosphere sections of the shader could be way faster using buffers, but I just brute forced instead.\n// Disclaimer: important physical constants use garbage values, also there is no gamma correction.\n\n// The shader tries to make the most of shadertoy's mushroom texture using layering,\n// tiling, bombing of vortex distortions and silly exaggerations to make clouds shine more in the penumbra zone.\n\n//#define FORCE_CAMERA 2.0 // force camera, int values in [0,CAMERA_NUM[\n#define CAMERA_TIME_RESET // make camera predictable by resetting\n#define CAMERA_PERIOD 30.0 // time we stay on each camera, in seconds\n#define GLOBALTIME (iTime+0.0) // offset sets initial view\n//#define GLOBALTIME (CAMERA_PERIOD*0.0+25.0)\n\n#define CAMERA_NUM 8.0\n\n// set camera order\n#define CAMERA_SPECULAR_CLOSE   0.0\n#define CAMERA_CLOUDS           1.0\n#define CAMERA_TAKE_OFF_BLUE    2.0\n#define CAMERA_ORBITING_FAR     3.0\n#define CAMERA_SPECULAR_FAR     4.0\n#define CAMERA_TAKE_OFF_SUNRISE 5.0\n#define CAMERA_ORBITING_CLOSE   6.0\n#define CAMERA_MOON_WIP         7.0 // moon has no surface shader yet...\n\n#define CLOUD_FLOW\n#define EARTH_ROTATION\n//#define HD_BLACK_BANDS\n//#define SUPER_SAMPLE_HORIZON\n//#define NO_EXPOSE\n\n#define PI\t\t\t3.141592654\n#define FLT_MAX\t\t1000000.0\n\n#define RED\t\t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE\t\tvec3(0,0,1)\n#define WHITE\t\tvec3(1,1,1)\n#define BLACK\t\tvec3(0,0,0)\n#define MAGENTA\t\tvec3(1,0,1)\n#define YELLOW\t\tvec3(1,1,0)\n#define CYAN\t\tvec3(0,1,1)\n#define GREY50\t\tvec3(0.5,0.5,0.5)\n\n#define R01         vec2( 0.999847695, 0.017452406 )\n\n#define const\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\nfloat hash11( float p )\n{\n\tvec2 p2 = fract( vec2( p * 5.3983, p * 5.4427 ) );\n\tp2 += dot( p2.yx, p2.xy + vec2( 21.5351, 14.3137 ) );\n\treturn fract( p2.x * p2.y * 95.4337 );\n}\n\nvec3 hash32( vec2 p )\n{\n\tp  = fract( p * vec2( 5.3983, 5.4427 ) );\n\tp += dot( p.yx, p.xy +  vec2( 21.5351, 14.3137 ) );\n\treturn fract( vec3( p.x * p.y * 95.4337, p.x * p.y * 97.597, p.x * p.y * 93.8365 ) );\n}\n\nvec4 xyz1( vec3 v ) { return vec4( v, 1. ); }\nvec4 xyz0( vec3 v ) { return vec4( v, 0. ); }\nvec3 xy0( vec2 v ) { return vec3( v, 0. ); }\nvec4 xy01( vec2 v ) { return vec4( v, 0., 1. ); }\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nfloat smoothstep_unchecked_6( float x ) { return x * x * x * x * x * ( 6.0 - 5.0 * x ); }\nfloat smoothbump( float c, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - c ), r ) / r ); }\nfloat remap( float x, float a, float b ) { return clamp( ( x - a ) / ( b - a ), 0., 1. ); }\nfloat tri( float x, float spacing ) { return spacing - ( abs( ( spacing * fract( x / spacing ) - spacing * 0.5 ) ) + spacing * 0.5 ); }\nfloat tri( float x ) { return 1.0 - abs( fract( x * 0.5 ) - 0.5 ) * 2.0; }\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nfloat pow3( float x ) { return x * x * x; }\nfloat pow4( float x ) { x *= x; x *= x; return x; }\nvec4 pow2( vec4 x ) { return x * x; }\nvec4 pow3( vec4 x ) { return x * x * x; }\nvec4 pow4( vec4 x ) { x *= x; x *= x; return x; }\nfloat soft_max( float x, float y, float k ) { return log( exp( k * x ) + exp( k * y ) ) / k; }\nfloat soft_max( float x, float y, float z, float k ) { return log( exp( k * x ) + exp( k * y ) + exp( k * z ) ) / k; }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )\n{\n\tRay view_ray;\n\tview_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;\n\tview_ray.d = normalize( view_ray.o );\n\treturn view_ray;\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n\tvec3 x = normalize( cross( up, z ) );\n\tvec3 y = cross( z, x );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) ));\n}\n\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\nvec3 zup_spherical_coords_to_vector( float theta, float phi )\n{\n\tvec2 theta_vec = unit_vector2( theta );\n\tvec2 phi_vec = unit_vector2( phi );\n\treturn vec3( theta_vec.y * phi_vec, theta_vec.x );\n}\n\nmat4 zup_spherical_lookat2( float theta, float phi )\n{\n\tvec3 z = zup_spherical_coords_to_vector( theta, phi );\n\tvec3 x = zup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 y = cross( z, x );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) ));\n}\n\nvec3 yup_spherical_coords_to_vector( float theta, float phi )\n{\n\treturn zup_spherical_coords_to_vector( theta, phi ).yzx;\n}\n\nmat4 yup_spherical_offset( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) ));\n}\n\nmat4 z_rotation( float angle )\n{\n\tvec2 v = unit_vector2( angle );\n\treturn mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) );\n}\n\n// use with constants...\n#define POW0(x) 1.0\n#define POW1(x) (x)\n#define POW2(x) (POW1(x)*(x))\n#define POW3(x) (POW2(x)*(x))\n#define POW4(x) (POW3(x)*(x))\n#define POW5(x) (POW4(x)*(x))\n#define POW6(x) (POW5(x)*(x))\n\n// project this on line (O,d), d is assumed to be unit length\nvec3 project_on_line1( vec3 P, vec3 O, vec3 d ) { return O + d * dot( P - O, d ); }\n\n#define layered5_pass_scale(func,p,a)((func(p,POW0(2.0),a)*POW1(0.5)+func(p,POW1(2.0),a)*POW2(0.5)+func(p,POW2(2.0),a)*POW3(0.5)+func(p,POW3(2.0),a)*POW4(0.5)+func(p,POW4(2.0),a)*POW5(0.5))*(1.0/(1.0-POW5(0.5))))\n\nstruct NoiseTiledParams\n{\n\tvec3 eye, n, p;\n\tfloat bias;\n};\n\nvec2 grid3( vec2 x, vec2 r ) { return smoothstep( r, vec2( 1.0 ), abs( ( fract( x ) - vec2( 0.5 ) ) * 2.0 ) ); }\n\nfloat tile_tex( in vec2 uv, float s, NoiseTiledParams ntp )\n{\n\tuv *= s;\n\n\tfloat bias = 0.0;\n\n\tfloat edge = 1.0 - dot( normalize( ntp.eye - ntp.p ), ntp.n );\n\tbias = -1.2 * edge; // bias the mipmap blur horror on edges\n\n\tbias += ntp.bias;\n\n\t// make the texture tilable\n\tfloat a0 = texture( iChannel1, vec2( uv.x - 0.0, uv.y - 0.0 ), bias ).x; // main image\n\tfloat b0 = texture( iChannel1, vec2( uv.x - 0.0, uv.y - 0.5 ), bias ).x; // fill seams\n\t// it's ok to fract on the seam filling lookups\n\t// without fract we are smooth tiled everywhere but at mipmap horror line\n\tfloat a1 = texture( iChannel1, vec2( fract( uv.x - 0.5 ), uv.y - 0.0 ), bias ).x; // fill seams\n\tfloat b1 = texture( iChannel1, vec2( fract( uv.x - 0.5 ), uv.y - 0.5 ), bias ).x; // fill seams\n\n\tfloat r = 1.0 - 0.2; // note: don't divide by s... 0,1 here\n\tuv = grid3( uv, vec2( r ) );\n\treturn mix( mix( a0, b0, uv.y ), mix( a1, b1, uv.y ), uv.x );\n}\n\nfloat fbm5_tiled_clouds( vec2 p, NoiseTiledParams ntp ) { return layered5_pass_scale( tile_tex, p, ntp ); }\n\n// just return the delta\nvec3 vortex( vec2 q, float max_twist, float aa_scale )\n{\n\tvec2 c = vec2( 0.5, 0.5 );\n\tfloat r0 = 0.5;\n\tvec2 v = ( q - c );\n\tfloat r = length( v );\n\tfloat x = min( r / r0, 1.0 );\n\tfloat aa = pow2( 1.0 - x );\n\treturn vec3( c + rotate_with_angle( q - c, aa * max_twist ) - q, aa * aa_scale );\n}\n\nvec3 vortex_bombing( vec2 p, float scale, float max_twist, float aa_scale, float probability )\n{\n\tp *= scale;\n\tvec2 pi = floor( p );\n\tvec2 pf = fract( p );\n\tvec3 x = vec3( 0.0, 0.0, 0.0 );\n\tfor ( int i = -1; i <= 1; ++i )\n\t{\n\t\tfor ( int j = -1; j <= 1; ++j )\n\t\t{\n\t\t\tvec2 o = vec2( float( i ), float( j ) );\n\t\t\tvec2 pj = pi + o;\n\t\t\tpj.x = mod( pj.x, scale ); // we are mapping a sphere so want same distortion at the u=0, u=1 limit\n\t\t\tvec3 rj = hash32( pj );\n\t\t\tif ( rj.z <= probability ) x += vortex( pf - o - rj.xy, max_twist * rj.z, aa_scale * rj.z ); //p - ( pj + rj.xy ) == ( pi + pf ) - ( pj + rj.xy ) == pf - o - rj.xy\n\t\t}\n\t}\n\treturn x;\n}\n\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\n\nvec2 sphere_trace( Ray ray, float radius, vec3 C )\n{\n\tvec3 O = ray.o;\n\tvec3 d = ray.d;\n\tfloat tp = dot( C - O, d ); // P = project C on line (O,d)\n\tvec3 P = O + d * tp;\n\tfloat h_sqr = lensqr( P - C );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n//\tbool start_inside = lensqr( O - C ) <= radius_sqr; // start inside the sphere?\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n//\tif ( start_inside )\treturn vec2(FLT_MAX,tp+dt);\t// order In->O->If // record only far hit If\n//\tif ( tp < 0.0 )\treturn vec2(FLT_MAX,FLT_MAX); // order In->If->O // O is outside the sphere and beyhond If, no hit\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\n#define earth_center vec3(0.0,0.0,0.0)\n//const float atm_scale=1e+3f; // 1=1m\n#define atm_scale 1.0 // 1=1km\n#define sun_direction vec3(0.0,1.0,0.0) // normalized please\nconst float earth_angular_velocity = ( 2.0 * PI / ( 24.0 * 60.0 * 60.0 ) );\nconst float earth_radius = 6378.15 * atm_scale;\nconst float sun_radius = 6.955e+5 * atm_scale; // for render only\n#define sun_dist (1.49e+8*atm_scale) // for render only\nconst float sun_cos = 0.999989; // for render only\nconst float sun_solid_angle = 0.0093355;  // sun view angle\nconst vec3 sun_center = earth_center + sun_direction * sun_dist;\n//const vec3 moon_direction=sun_direction; // full sun eclipse\n#define moon_direction /*normalize(*/vec3(1.0,0.0,0.0)/*)*/\t// moon close to sun\n//const vec3 moon_direction=normalize(vec3(0.01f,1.0,0.0)); // moon close to sun\n//const vec3 moon_direction=normalize(vec3(0.015f,1.0,-0.02f));\t// moon close to sun, a bit far appart\n//const vec3 moon_direction=normalize(vec3(0.0,-1.0,0.0)); // moon fully occluded\n//const vec3 moon_direction=normalize(vec3(0.016f,-1.0,0.0)); // half moon\nconst float moon_radius = 1738.14 * atm_scale;\n#define moon_dist (384400.0*atm_scale)\nconst float moon_cos = 0.99999;\nconst vec3 moon_center = earth_center + moon_direction * moon_dist;\nconst float H0_r = 0.7994 * atm_scale; // normally this is 8km\nconst float H0_m = 1.2 * atm_scale;\nconst float atm_max = 20.0 * atm_scale; // as small as possible, large enough to accomodate H0_ values\nconst vec3 beta_r = 2.504 * ( 1e+3f / atm_scale ) * vec3( 5.19673e-006, 1.21427e-005, 2.96453e-005 ); // fudge factor & account for km\nconst vec3 beta_m = 2.504 * ( 1e+3f / atm_scale ) * vec3( 5.19673e-006, 1.21427e-005, 2.96453e-005 ); // beta_m is normally a scalar (2.10e-005/m in \"Precomputed Atmospheric Scattering\" Fig7), but I tweaked this shader before fixing the constants\nconst vec3 Is = vec3( 1.0, 1.0, 1.0 ) * 35.0;\nconst vec3 earth_diffuse_reflection = vec3( 0.2 );\nconst float cloud_start = 1.0 * atm_scale;\nconst float cloud_end = 10.0 * atm_scale;\nconst float ie_cost_min = -0.3420; //110deg\n\nfloat sunh( float viewdist )\n{\n\treturn viewdist * ( sun_radius / sun_dist );\n//\treturn viewdist * tan( sun_solid_angle * 0.5 );\n}\n\n// params for Ie term manual fit\nstruct IeApproxS\n{\n\tfloat a;\n\tfloat k;\n\tfloat sx;\n\tfloat sy;\n\tfloat last_bit;\n};\n\nIeApproxS ie_params_r;\nIeApproxS ie_params_g;\nIeApproxS ie_params_b;\n\nvec2 calc_rho( float h ) { return exp( -vec2( h ) / vec2( H0_r, H0_m ) ); }\n\nstruct vec6 { vec3 r; vec3 m; };\n\nvec6 mkvec6( vec2 s ) { vec6 val; val.r = vec3( s.x ); val.m = vec3( s.y ); return val; }\nvec6 mkvec6( float s ) { return mkvec6( vec2( s, s ) ); }\n\nvoid add_vec6( inout vec6 od, vec6 value, float ds )\n{\n\tod.r += value.r * beta_r * ds;\n\tod.m += value.m * beta_m * ds;\n}\n\nvec6 opticalDepth( Ray ray, float t, float t2 )\n{\n\tvec6 ret = mkvec6( 0.0 );\n\t#define num_segments 20\n\tfloat dt = ( t2 - t ) / float( num_segments );\n\tfor ( int i = 0; i < num_segments + 1; ++i )\n\t{\n\t\tvec3 p = ray.o + ray.d * t;\n\t\tvec2 rho = calc_rho( length( p - earth_center ) - earth_radius );\n\t\tadd_vec6( ret, mkvec6( rho ), dt * ( ( i == 0 || i == num_segments ) ? 0.5 : 1.0 ) );\n\t\tt += dt;\n\t}\n\treturn ret;\n}\n\n// http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\nfloat CornetteSingleScatteringPhaseFunction( float cos_theta, float g ) { float g2 = g * g; return 3.0 * ( 1.0 - g2 ) * ( 1.0 + pow2( cos_theta ) ) / ( 2.0 * ( 2.0 + g2 ) * pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ) ); }\n\n// == CornetteSingleScatteringPhaseFunction( cos_theta, 0.0 )\nfloat RayleighScattering( float cos_theta ) { return 0.75 * ( 1.0 + cos_theta * cos_theta ); }\n\n// https://www.astro.umd.edu/~jph/HG_note.pdf HG, g in [-1,1]\nfloat HenyeyGreensteinPhaseFunction( float cos_theta, float g ) { float g2 = g * g; return ( 1.0 / ( 4.0 * PI ) ) * ( 1.0 - g2 ) / pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ); }\n\nfloat calc_Fr_r( float cos_theta ) { return RayleighScattering( cos_theta  ); }\nfloat calc_Fr_m( float cos_theta, float g ) { return CornetteSingleScatteringPhaseFunction( cos_theta, g ); }\n\nbool in_earth_shadow( vec3 p )\n{\n\treturn ( dot( p, sun_direction ) < 0.0 )\n\t\t   && ( lensqr( p - project_on_line1( p, earth_center, sun_direction ) ) < earth_radius * earth_radius );\n}\n\nbool in_moon_shadow( vec3 p )\n{\n\treturn ( dot( p - moon_center, sun_direction ) < 0.0 )\n\t\t   && ( lensqr( p - project_on_line1( p, moon_center, sun_direction ) ) < moon_radius * moon_radius );\n}\n\n// this is a manual fit of the offline precalculated Ie 1d table (with various wrong physical constant) for each r,g,b, plus slight tweaks\nfloat ie_approx_S( float cos_alpha, IeApproxS params )\n{\n\tfloat y =\n\t\tsoft_max( cos_alpha * params.sx, params.a, params.k ) * params.sy\n\t\t- soft_max( 0.0, params.a, params.k ) * params.sy;\n\n\tfloat c = 0.98;\n\tif ( cos_alpha > c ) y *= ( 1.0 + params.last_bit * ( cos_alpha - c ) / ( 1.0 - c ) );\n\treturn max( 0.0, y );\n}\n\nvoid Ie_ie_params_init()\n{\n\tie_params_r.a = 1.07143104;\n\tie_params_r.k = 0.578571617;\n\tie_params_r.sx = 12.857152938;\n\tie_params_r.sy = 2.785715818;\n\tie_params_r.last_bit = 0.042857192;\n\n\tie_params_g.a = 5.250002384;\n\tie_params_g.k = 0.385714441;\n\tie_params_g.sx = 24.000009536;\n\tie_params_g.sy = 1.357144474;\n\tie_params_g.last_bit = 0.126428619;\n\n\tie_params_b.a = 7.285716533;\n\tie_params_b.k = 0.435714453;\n\tie_params_b.sx = 13.285723686;\n\tie_params_b.sy = 2.928573131;\n\tie_params_b.last_bit = 0.300000011;\n}\n\nvec3 calc_Ie_shaderfunc( float cos_alpha )\n{\n\tIe_ie_params_init();\n\tfloat bleed = 0.02; //0.0 means no bleed, sunset cameras need enough bleeding to look interesting\n\tcos_alpha = 1.0 + ( cos_alpha - 1.0 ) * ( 1.0 - bleed ); // exaggerate Ie bleed a little bit\n\tcos_alpha = clamp( cos_alpha, ie_cost_min, 1.0 - 0.019 ); // cos alpha=1 has a weird blob, clamp a bit...\n\treturn vec3( ie_approx_S( cos_alpha, ie_params_r ),\n\t\t\t\t ie_approx_S( cos_alpha, ie_params_g ),\n\t\t\t\t ie_approx_S( cos_alpha, ie_params_b ) );\n}\n\nstruct LameTweaks\n{\n\tfloat earth_rot_time;\n\tfloat cloud_flow_time;\n\t// no PBR no life\n\tfloat specular_hack;\n\tvec3 cloud_hack;\n};\n\nfloat cloudSphereMap( vec2 p, mat4 camera, vec3 n, float bias, LameTweaks lame_tweaks )\n{\n\tvec2 p0 = p;\n\n\tfloat pole = 0.1;\n\tp.y = ( p.y - pole ) / ( 1.0 - 2.0 * pole );\n\n\t// p0 is in x 0,1\n\t// q0 is in x 0,2\n\n\tvec3 q = vec3( p * vec2( 2, 1 ), 0.0 );\n\n\tvec3 q0 = q;\n\n//\tq += vortex_bombing( q.xy,  1.0, 1.0, 1.0, 0.0 ) * POW0( 0.5 ); // 1\n//\tq += vortex_bombing( q.xy,  2.0, 1.0, 1.0, 0.0 ) * POW1( 0.5 ); // 2\n//\tq += vortex_bombing( q.xy,  4.0, 1.0, 1.0, 0.0 ) * POW2( 0.5 ); // 3\n\tq += vortex_bombing( q.xy,  8.0, 3.0, 1.0, 0.9 ) * POW3( 0.5 ); // 4\n//\tq += vortex_bombing( q.xy, 16.0, 3.0, 1.0, 1.0 ) * POW4( 0.5 ); // 5\n\tq += vortex_bombing( q.xy, 32.0, 2.7, 5.5, 0.85 ) * POW5( 0.5 ); // 6\n//\tq += vortex_bombing( q.xy, 64.0, 1.0, 1.0, 0.0 ) * POW6( 0.5 ); // 7\n\n\tvec2 qoff = vec2( 0.0, 0 );\n#ifdef CLOUD_FLOW\n\tqoff.x = lame_tweaks.cloud_flow_time * earth_angular_velocity; //cloud flow (doesn't fix black line)\n#endif\n\n\tNoiseTiledParams ntp;\n\tntp.eye = camera[3].xyz;\n\tntp.n = n;\n\tntp.p = n * earth_radius;\n\tntp.bias = bias;\n\n\tfloat a = fbm5_tiled_clouds( q.xy * 4.0 + qoff, ntp );\n\n\ta *= 1.0 - smoothstep( 0.5 - pole * 3.4, 0.5, abs( p0.y - 0.5 ) ); // would like to do better than that...\n\n\tfloat a0 = a;\n\n\t{\n\t\t//increase density on areas that have vortices\n\t\ta += length( q - q0 ) * 0.5;\n\t\ta += q.z * q.z * 5.0;\n\t}\n\n\t// add a little bit more oompf detail, helps overall + on cloud close ups\n\ta += a0 * fbm5_tiled_clouds( q.xy * 8.0 + qoff, ntp ) * 0.5;\n\n\ta = contrast( a + 0.05, 2.75 ); // higher contrast = deeper blue if we keep negative cloud\n\ta = soft_max( a, 0.0, 15.0 );\n\treturn a;\n}\n\nfloat cloudMap( vec3 n, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tvec3 n0 = n;\n#ifdef EARTH_ROTATION\n\tn.xy = rotate_with_angle( n.xy, lame_tweaks.earth_rot_time * earth_angular_velocity );\n#endif\n\tfloat theta = acos( n.z );\n\tfloat phi = calc_angle( n.xy ) + PI; // assume range 0,1\n\n\treturn cloudSphereMap( vec2( phi * 0.5, theta ) * ( 1.0 / PI ), camera, n0, bias, lame_tweaks );\n}\n\nstruct CloudOut\n{\n\tvec3 sphere_point, sphere_normal;\n\tfloat cloud;\n\tbool hit;\n};\n\n// just one sphere lookup\nCloudOut cloudTraceFlat( Ray ray, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tCloudOut ret;\n\tret.cloud = 0.0;\n\tret.hit = false;\n\tfloat cloud_height = mix( cloud_start, cloud_end, 0.5 ); // cloud alt should be a number in 0-1\n//\tfloat cloud_height = mix( cloud_start, cloud_end, 10.0 ); // over the top shadow... fun\n\tvec2 tb = sphere_trace( ray, earth_radius, earth_center );\n\tvec2 tc = sphere_trace( ray, earth_radius + cloud_height, earth_center );\n\tif ( tc.x == FLT_MAX ) return ret; // no intersection with cloud sphere\n\tif ( tc.x < 0.0 && tb.x != FLT_MAX && tb.x >= 0.0 ) return ret;\n\tvec3 p = ray.o + ( tc.x < 0.0 ? tc.y : tc.x ) * ray.d;\n\tret.sphere_point = p;\n\tret.sphere_normal = normalize( p - earth_center );\n\tret.cloud = cloudMap( ret.sphere_normal, camera, bias, lame_tweaks );\n\tret.hit = true;\n\treturn ret;\n}\n\n// get a bit of volume\nCloudOut cloudTrace( Ray ray, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tCloudOut ret;\n\tret.cloud = 0.0;\n\tret.hit = false;\n\n\tfloat hcs = mix( cloud_start, cloud_end, 0.55 );\n\tfloat hce = mix( cloud_start, cloud_end, 0.8 );\n\tvec2 ts = sphere_trace( ray, earth_radius + hcs, earth_center ); // start\n\tvec2 te = sphere_trace( ray, earth_radius + hce, earth_center ); // end\n\tif ( te.x == FLT_MAX ) return ret; // ray line doesn't intersect a (and therefore, b since b is inside a)\n\tif ( te.y <= 0.0 ) return ret; // ray line intersects a(atm) but behind us\n\tvec2 range;\n\tif ( ts.x == FLT_MAX )\n\t{\n\t\t// inside cloud altitude range, looking at upper cloud shell\n\t\t// ray line intersects a\n\t\t// ray line doesn't intersect b\n\t\trange.x = max( 0.0, te.x );\n\t\trange.y = te.y;\n\t}\n\telse\n\t{\n\t\t// ray line intersects a\n\t\t// ray line intersects b\n\t\tif ( te.x > 0.0 )\n\t\t{\n\t\t\t// hitting clouds from above\n\t\t\t// ray hitting a from outside\n\t\t\trange.x = te.x;\n\t\t\trange.y = ts.x;\n\t\t}\n\t\telse if ( ts.x > 0.0 )\n\t\t{\n\t\t\t// below lower cloud layer, looking at lower cloud layer\n\t\t\trange.x = 0.0;\n\t\t\trange.y = ts.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// between cloud layers, looking at upper cloud layer\n\t\t\trange.x = 0.0;\n\t\t\trange.y = te.y;\n\t\t}\n\t}\n\n\tfloat t = range.x;\n\tfloat dt = ( range.y - range.x ) * ( 1.0 / 8.0 );\n\tfloat min_dist = FLT_MAX;\n\tfloat hcdv = 1.0 / ( hce - hcs );\n\n\tfor ( int i = 0; i < 8; ++i )\n\t{\n\t\tvec3 p = ray.o + t * ray.d;\n\t\tfloat hr = length( p - earth_center );\n\t\tfloat hp = hr - earth_radius;\n\t\tvec3 n = ( p - earth_center ) / hr;\n\n\t\tfloat c = cloudMap( n, camera, bias, lame_tweaks );\n\t\tfloat hc = hcs + ( hce - hcs ) * saturate( c );\n\n\t\tfloat dh = hp - hc;\n\n\t\tif ( abs( dh ) < 0.4 && t <= range.y )\n\t\t{\n\t\t\tret.cloud = c;\n\t\t\tret.sphere_normal = n;\n\t\t\tret.hit = true;\n\n\t\t\tt += dt * 0.5; // note: don't break, keep homing\n\t\t}\n\t\telse t += dt;\n\t}\n\n\treturn ret;\n}\n\n// fade shadow term based on distance\nfloat shadow_falloff( vec3 pa, vec3 pb )\n{\n\tvec3 d = ( pa - pb );\n\treturn 1.0 / ( 1.0 + lensqr( d ) * 0.00005 );\n}\n\n// losely based on http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\n\nstruct AtmOut\n{\n\tvec3 vod_attn; //view ray atm scattering\n\tvec3 earth_p;\n\tvec3 earth_n;\n\tbool earth_surface;\n\tvec3 Iv;\n};\n\nvec3 calc_Iv( Ray view_ray, inout AtmOut atm_out, mat4 camera, LameTweaks lame_tweaks )\n{\n\tvec2 te = sphere_trace( view_ray, earth_radius, earth_center );\n\tvec2 ta = sphere_trace( view_ray, earth_radius + atm_max, earth_center );\n\n\tatm_out.earth_surface = ( te.x > 0.0 && te.x != FLT_MAX );\n\tatm_out.vod_attn = vec3( 1.0 );\n\tatm_out.Iv = vec3( 0.0 );\n\n//\tvec3 spacecolor = MAGENTA; // debug\n\tvec3 spacecolor = BLACK;\n\n\tif ( ta.x == FLT_MAX ) return spacecolor; // view_ray line doesn't intersect a (and therefore, e since e is inside a)\n\tif ( ta.y <= 0.0 ) return spacecolor; // return mix(SPACECOLOR,WHITE,0.7);\t// view_ray line intersects a(atm) but behind us\n\tif ( te.x <= 0.0 && te.y >= 0.0 ) return GREEN; // inside (e)earth\n\n\tvec2 range; // range segment we integrate things on along view_ray\n\t\n\tif ( te.x == FLT_MAX ) range = vec2( max( 0.0, ta.x ), ta.y ); // view_ray line intersects a, doesn't intersect e\n\t// view_ray line intersects a and e\n\telse if ( ta.x > 0.0 ) range = vec2( ta.x, te.x ); // ray hitting a from outside atm\n\telse if ( te.x > 0.0 ) range = vec2( 0.0, te.x ); // ray hitting e from inside atm\n\telse range = vec2( 0.0, ta.y ); // ray hitting a from inside atm\n\t\n\tRay sun_ray;\n\tsun_ray.d = sun_direction;\n\n\tfloat tp = range.x;\n\n\t#define num_view_ray_segments 50 // we have to bump this number quite a bit to get decent integration\n\tfloat dl = ( range.y - range.x ) / float( num_view_ray_segments );\n\tif ( dl < 0.0 )\treturn YELLOW;\n\t\n\tvec3 p;\n\tvec6 tppc = mkvec6( 0.0 ); // the last of those is a earth hit -> sun ray when earth_surface is true\n\tvec6 tppa = mkvec6( 0.0 ); // the last of those is a earth hit -> eye ray when earth_surface is true\n\tvec6 Iv_sum = mkvec6( 0.0 );\n\tfor ( int i = 0; i < num_view_ray_segments + 1; ++i )\n\t{\n\t\tp = view_ray.o + view_ray.d * tp;\n\t\tp = earth_center + normalize( p ) * max( earth_radius * 1.00001, length( p ) ); // make sure we don't start inside the earth when P is a hit point\n\t\tvec2 rho = calc_rho( length( p - earth_center ) - earth_radius );\n\t\ttppc = mkvec6( 0.0 );\n\t\tif ( !in_earth_shadow( p ) )\n//\t\tif ( !in_moon_sun_shadow( p ) )\n\t\t{\n\t\t\tsun_ray.o = p;\n\t\t\tvec2 ta_sun = sphere_trace( sun_ray, earth_radius + atm_max, earth_center );\n\t\t\ttppc = opticalDepth( sun_ray, 0.0/*p*/, ta_sun.y/*pc*/ ); // note: ta_sun.y > 0.0\n\t\t\tvec6 tmp;\n\t\t\t#if 1\n\t\t\t// note: this is not the correct way to combine the r,m transmittance at all, but too late to fix\n\t\t\ttmp.r = rho.x * exp( -tppc.r - tppa.r );\n\t\t\ttmp.m = rho.y * exp( -tppc.m - tppa.m );\n\t\t\t#else\n\t\t\t// normally attenuation should affect both\n\t\t\tvec3 tr = exp( -tppc.r - tppa.r - tppc.m - tppa.m );\n\t\t\ttmp.r = rho.x * tr;\n\t\t\ttmp.m = rho.y * tr;\n\t\t\t#endif\n\t\t\tadd_vec6( Iv_sum, tmp, dl * ( ( i == 0 || i == num_view_ray_segments ) ? 0.5 : 1.0 ) );\n\t\t}\n\t\tadd_vec6( tppa, mkvec6( rho ), dl );\n\t\ttp += dl;\n\t}\n\n\tfloat cos_theta = dot( sun_direction, view_ray.d );\n\tvec3 Iv = Is *\n\t\t( ( Iv_sum.r / ( 4.0 * PI ) ) * calc_Fr_r( cos_theta ) + \n\t\t  ( Iv_sum.m / ( 4.0 * PI ) ) * calc_Fr_m( cos_theta, 0.8 ) );\n\n\tatm_out.Iv = Iv;\n\n\tvec3 Ie = vec3( 0, 0, 0 );\n\tvec6 tPaPb = mkvec6( 0.0 );\n\n\tfloat cloud_shadow = 0.0;\n\tfloat specular = 0.0;\n\n\tif ( atm_out.earth_surface )\n\t{\n\t\t//return RED; // check earth pixel\n\t\tp = view_ray.o + view_ray.d * te.x; // note: we shouldn't need to update p here\n\t\tvec3 n = normalize( p - earth_center );\n\t\tfloat cos_alpha = dot( sun_direction, n );\n\t\tIe = calc_Ie_shaderfunc( cos_alpha );\n//\t\ttPaPb = opticalDepth( view_ray, range.x/*Pa*/, te.x/*Pb*/ );\n\t\ttPaPb = tppa; // tppa already has the value\n\n\t\tatm_out.earth_p = p;\n\t\tatm_out.earth_n = n;\n\n\t\tRay cloud_shadow_ray;\n\t\tcloud_shadow_ray.d = sun_direction;\n\t\tcloud_shadow_ray.o = p + n * max( 1.00001, cloud_start * 0.5 ); //anything smaller than cloud_start and greater than a separation epsilon\n\n\t\tvec3 tangent = cross( sun_direction, n );\n\t\tvec3 np = normalize( cross( tangent, sun_direction ) );\n\n//\t\tvec2 acs = unit_vector2( radians( 5.0 ) );\n\t\tvec2 acs = R01;\n\t\tfloat w1 = 1.0;\n\t\tfloat w2 = 0.5;\n\n\t\tCloudOut cs;\n\n\t\tcloud_shadow_ray.d = sun_direction;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w1 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow_ray.d = sun_direction * acs.x + np * acs.y;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w2 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow_ray.d = sun_direction * acs.x - np * acs.y;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w2 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow *= ( 1.0 / ( w1 + w2 * 2.0 ) );\n\n\t\tvec3 l = sun_direction;\n\t\tvec3 e = -view_ray.d;\n\t\tvec3 h = normalize( e + l );\n\t\tfloat dp = dot( n, l );\n\n\t\tfloat specular_power = 75.0;\n\n\t\tspecular = pow( max( dot( n, h ), 0.0 ), specular_power )\n\t\t\t* ( ( specular_power + 8.0 ) / ( 8.0 * PI ) )\n\t\t\t* max( 0.0, dp );\n\t}\n\n\tCloudOut co = cloudTrace( view_ray, camera, 0.0, lame_tweaks );\n\tfloat cloud = co.cloud;\n\n\tatm_out.vod_attn = exp( -tppa.r ); // for sun attn\n\n\tfloat dp = dot( co.sphere_normal, sun_direction );\n\n\tfloat s = ( 1.0 - saturate( cloud_shadow * ( 1.0 - cloud ) ) );\n\n//\treturn vec3( ( 1.0 - s ) * 3.0, cloud, 0.0 );\n\n\tfloat earth_diffuse = 0.008;  // controls blue depth\n\n\treturn ( 0.0\n\t\t\t + earth_diffuse * s\n\t\t\t + specular * ( 1.0 - saturate( cloud ) ) * lame_tweaks.specular_hack * s * s\n\t\t\t + cloud\n\t\t\t * // this add specks of gold to the clouds in the penumbra zone\n\t\t\t ( 1.0\n\t\t\t   + smoothstep( -0.02, 0.012, dp )\n\t\t\t   * exp( ( cloud - cloud_shadow ) * lame_tweaks.cloud_hack.x )\n\t\t\t   * lame_tweaks.cloud_hack.y ) * lame_tweaks.cloud_hack.z\n\n\t\t\t) * Ie * exp( -tPaPb.r - tPaPb.m )\n\n\t\t   + Iv * ( 2.4 - ( 1.0 - s ) * 0.7 );\n}\n\n// linearly remap nl, cut is the value of nl that maps to 0\nfloat warp_nl( float nl, float cut ) { return max( 0.0, ( nl - cut ) ) / ( 1.0 - cut ); }\n\nfloat noise1s( in float x )\n{\n\tx -= 0.5;\n\n\tfloat x0 = floor( x );\n\tfloat y0 = hash11( x0 );\n\tfloat y1 = hash11( x0 + 1.0 );\n\n\treturn mix( y0, y1, smoothstep_unchecked( x - x0 ) );\n}\n\nfloat calcFallOff( float sd, float r, float p1, float p2 )\n{\n\tfloat sd_last = sun_cos - r; //length of rays\n\tfloat g = 1.0 - saturate( max( sun_cos - sd, 0.0 ) / ( sun_cos - sd_last ) );\n\treturn powerful_scurve( g, p1, p2 );\n}\n\nvec3 earthShader( Ray view_ray, mat4 camera, LameTweaks lame_tweaks, float exposure )\n{\n\tAtmOut atm_out;\n\n\tvec3 ret = calc_Iv( view_ray, atm_out, camera, lame_tweaks );\n\n\tvec3 sun_color = atm_out.vod_attn * vec3( 1.0, 0.85, 0.71 );\n\tfloat sun_intensity = 0.0;\n\n\tfloat sd = dot( normalize( view_ray.d ), sun_direction ); // assumes sun very far... view_ray.d needs renormalize for some obscure reason\n\n\tbool long_sun_flare = true;\n\tbool thin_flares = true;\n\tbool sun_glare = true;\n\tbool earth_clamped_sun_glare = true;\n\n\tif ( !atm_out.earth_surface )\n\t{\n\t\tvec2 tm = sphere_trace( view_ray, moon_radius, moon_center );\n\t\tif ( tm.x != FLT_MAX && tm.x > 0.0 )\n\t\t{\n\t\t\tvec3 moon_P = view_ray.o + view_ray.d * tm.x;\n\t\t\tfloat moon_sun_shadow = warp_nl( dot( normalize( moon_P - moon_center ), sun_direction ), -0.01 );\n\t\t\tfloat earth_sun_shadow = in_earth_shadow( moon_P ) ? 0.0 : 1.0; // fixme: don't want sharp... precalc or fit something\n\n\t\t\tret += vec3( 0.04 );\n\t\t\tret += min( pow( moon_sun_shadow, 0.57 ), earth_sun_shadow ) * atm_out.vod_attn * 2.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( earth_clamped_sun_glare )\n\t\t\t{\n\t\t\t\tfloat gs = calcFallOff( sd, 0.01, 1.4, 0.05 );\n\t\t\t\tsun_intensity += 16.0 * gs;\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat theta = acos( clamp( sd, -1., 1. ) );\n\tfloat phi = calc_angle( view_ray.d.zx );\n\tvec2 phi_vec = unit_vector2( phi );\n\n\tfloat sun_visibility = 0.0;\n\tvec3 ep_sv = view_ray.o + sun_direction * dot( earth_center - view_ray.o, sun_direction );\n\t{\n\t\tfloat sh = sunh( length( ep_sv - view_ray.o ) );\n\t\tfloat h = length( ep_sv - earth_center );\n\t\tsun_visibility = saturate( smoothstep( -sh, sh, h - earth_radius ) );\n//\t\tfloat darkness = saturate( smoothstep( 0, earth_radius - sh, h ) );\n//\t\tif ( sun_visibility != 0.0 ) ret += RED;\n\t}\n\n\tfloat xsum = 0.0;\n\n\tif ( long_sun_flare )\n\t{\n\t\tfloat gs = calcFallOff( sd, 1e-3 * 12., 1.2, 0.07 );\n\n\t\tfloat spacing = 2.0 * PI / 6.0;\n\t\tfor ( int i = 0; i < 6; ++i )\n\t\t{\n\t\t\tvec2 v = unit_vector2( float( i ) * spacing + 0.4 );\n\t\t\tfloat vv = abs( dot( phi_vec * theta, v ) );\n\t\t\tvv /= PI;\n\t\t\tvv *= 0.4;\n\t\t\txsum += exp( -vv * 1500.0 ) * gs * 0.8;\n\t\t}\n\t}\n\n\tif ( thin_flares )\n\t{\n\t\tfloat gs = calcFallOff( sd, 1e-5 * 4.0, 1.4, 0.3 );\n\n\t\t// thin flares\n\t\tfor ( int i = 0; i < 5; ++i )\n\t\t{\n\t\t\tfloat fi = float( i );\n\t\t\tfloat x = noise1s( phi * 3.5 + fi * 3.0 + 0.5 * sin( GLOBALTIME + fi ) );\n\t\t\tx = pow4( x );\n\t\t\tx = max( 0.0, contrast( x, 1.1 ) );\n\t\t\tx = gs * mix( 0.0, 1.0, x );\n\t\t\txsum += x * 2.0 * gs;\n\t\t}\n\t}\n\n\tret += xsum * ( atm_out.earth_surface ? 0.0 : 1.0 ) * pow( sun_visibility, 0.15 );\n\n\tif ( sun_glare )\n\t{\n\t\t// diffuse fall off\n\t\tsun_intensity += exp( -theta / PI * ( atm_out.earth_surface ? 70.0 : 27.0 ) ) * pow( sun_visibility, 0.20 );\n\t}\n\n\tret += sun_intensity * sun_color;\n\n//\tfloat scene_luminance = 0.0;\n//\tscene_luminance = max( 0.0, dot( view_ray.d, sun_direction ) );\n\n#ifndef NO_EXPOSE\n//\tret = 1.0 - exp( -mix( 0.85, 0.05, scene_luminance/**sun_visibility*/ ) * ret );\n\tret = 1.0 - exp( -exposure * ret );\n#endif\n\treturn ret;\n}\n\n// https://en.wikipedia.org/wiki/Kepler%27s_equation\nfloat kepler_eq_solve( float M, float e/*,float& err*/ )\n{\n\tfloat En = M;\n\tif ( e > 0.8 ) En = PI;\n\tfor ( int i = 0; i < 3; ++i ) En = En - ( En - e * sin( En ) - M ) / ( 1.0 - e * cos( En ) );\n//\terr = max( fabsf( ( En - e * sin( En ) - M ) ), err );\n\treturn En;\n}\n\n// n = mean motion n https://en.wikipedia.org/wiki/Mean_motion (consider this as the \"angular speed\")\n// n = 2pi/period\n// p,e see https://en.wikipedia.org/wiki/Kepler%27s_laws_of_planetary_motion\n// p is the scale of the trajectory\n// e the eccentricity, 0 for circle\n// becomes ellipsoid (and smaller, so compensate by increasing p) as we get closer to 1\n// above 0.8 kepler_eq_solve needs more iterations\n// rmin=p/(1+e) closest distance to focus...perihelion\n// rmax=p/(1-e) farthest distance to focus..aphelion\nvec2 kepler_orbit( float t, float p, float e, float n/*, float& err*/ )\n{\n\tfloat M = n * t;\n\tfloat E = kepler_eq_solve( M, e/*,err*/ );\n\tfloat a = p / ( 1.0 - e * e );\n\tfloat b = p / sqrt( 1.0 - e * e );\n\tfloat x = a * ( cos( E ) - e );\n\tfloat y = b * sin( E );\n\treturn vec2( x, y );\n}\n\n// calculate p given rmin\nfloat kepler_orbit_calc_p( float rmin, float e )\n{\n\treturn rmin * ( 1.0 + e );\n}\n\nstruct KeplerOrbit\n{\n\tfloat rmin; // min radius\n\tfloat period;\n\tfloat e; // ellipse eccentricity\n};\n\nstruct KeplerOrbitRetval\n{\n\tvec3 orbit_position;\n\tvec3 orbit_plane_normal;\n};\n\nKeplerOrbitRetval get_earth_camera_path_kepler( float t, in KeplerOrbit ko )\n{\n\tKeplerOrbitRetval ret;\n\t// you can can play with highly elliptical orbits here, see\n\t// http://www.polaris.iastate.edu/EveningStar/Unit4/unit4_sub3.htm\n\tfloat n = 2.0 * PI / ko.period;\n\tvec2 p = kepler_orbit( t, kepler_orbit_calc_p( ko.rmin, ko.e ), ko.e, n );\n\tp = perp( p ); // start on y, where the sun is, symmetry more convenient to tweak orbit period\n#if 1\n\t// define trajectory plane here (theta must be non zero if you want an inclination)\n//\tmat4 rep = zup_spherical_lookat2( radians( 90.0 ), radians( 90.0 ) ); // circle around penumbra zone\n\tmat4 rep = zup_spherical_lookat2( radians( 0.0 ), radians( 0.0 ) ); // trajectory inclination\n\tret.orbit_plane_normal = rep[2].xyz;\n\tret.orbit_position = ( rep * xy01( p ) ).xyz;\n#else\n\tret.orbit_plane_normal = vec3( 0, 0, 1 );\n\tret.orbit_position = xy0( xx );\n#endif\n\treturn ret;\n}\n\nvec3 get_earth_camera_path_iss( float t, inout vec3 up )\n{\n\t// needs high fov values\n\tfloat h = 340.0; //ISS\n\tfloat er = earth_radius / atm_scale;\n\tfloat dtheta = t * ( 27.6e+3 / 3600.0 ) / ( er + h ); //27.6km/h\n\tvec2 xx = unit_vector2( dtheta ) * ( er + h );\n\tmat4 rep = zup_spherical_lookat2( radians( 0.0 ), radians( 0.0 ) ); // trajectory inclination\n\tup = rep[2].xyz;\n\treturn ( rep * xy01( xx ) ).xyz;\n}\n\nstruct TangentView\n{\n\tvec3 target_vector; // sphere center -> target unit vector\n\tvec3 tangent_disk_center;\n\tfloat tangent_disk_radius;\n};\n\nTangentView get_tangent_view( vec3 p, vec3 c, float r )\n{\n\tTangentView ret;\n\tret.target_vector = p - c;\n\tfloat dt = length( ret.target_vector );\n\tret.target_vector /= dt;\n\tfloat e = ( r * r ) / dt;\n\tret.tangent_disk_radius = sqrt( r * r - e * e );\n\tret.tangent_disk_center = c + ret.target_vector * e;\n\treturn ret;\n}\n\n// set view center on tangent of a sphere c,r\nvec3 get_tangent_point( vec3 p, vec3 c, float r, vec3 up )\n{\n\tTangentView tv = get_tangent_view( p, c, r );\n\treturn tv.tangent_disk_center +\n\t\t   tv.tangent_disk_radius * normalize( cross( tv.target_vector, cross( up, tv.target_vector ) ) );\n}\n\n// reflect is builtin so use different name\nfloat myreflect( float x, float a ) { return a + ( a - x ); }\n\n// bounce time to make sure we are always travelling above the lit face of the earth\nfloat bounce_time( float t, float period, inout float fade )\n{\n\tt = mod( t, period );\n\tif ( t > period * 0.5 ) t -= period; // want mirrored time values\n\tfloat r = period * 0.005;\n\tfloat a = period * 0.25;\n\tfade *= 1.0 - smoothbump( a + r, r, clamp( abs( t ), a, a + r + r ) );\n\tif ( abs( t ) > ( a + r ) ) t = myreflect( t, ( ( t < 0.0 ) ? -1.0 : 1.0 ) * period * 0.25 );\n\treturn t;\n}\n\nvec3 rotate_around( vec3 c, vec3 z, vec3 p, float angle )\n{\n\tvec3 v = p - c;\n\tvec3 pp = project_on_line1( p, c, z );\n\tvec3 x = normalize( p - pp );\n\tvec3 y = cross( z, x );\n\tvec2 v2 = vec2( dot( v, x ), dot( v, y ) );\n\tv2 = rotate_with_angle( v2, angle );\n\treturn pp + v2.x * x + v2.y * y;\n}\n\n// can't find the source shadertoy for those functions...\n#define KEY_SPACE 32.\n#define KEY_RIGHT 39.\nbool key_toggle( float ascii ) { return (texture( iChannel0, vec2( ( ascii + .5 ) / 256., 0.75 ) ).x > 0.); }\nbool key_state( float ascii ) { return (texture( iChannel0, vec2( ( ascii + .5 ) / 256., 0.25 ) ).x > 0.); }\n\nmat4 get_earth_camera( inout float tan_half_fovy\n\t\t\t\t\t   , inout float fade\n\t\t\t\t\t   , float time\n\t\t\t\t\t   , out LameTweaks lame_tweaks\n\t\t\t\t\t   , inout float exposure )\n{\n\tvec3 eye = vec3( 0, 0, 2.0 );\n\tvec3 center = vec3( 0, 0, 0 );\n\n\tfloat roll = 0.0;\n\n#define IS_NEXT_INDEX(nn) ( abs( camera_index - nn ) < 0.01 )\n\n#ifdef FORCE_CAMERA\n\tfloat camera_index = FORCE_CAMERA;\n#else\n\tfloat camera_index = mod( floor( time / CAMERA_PERIOD ), CAMERA_NUM );\n#endif\n\tfade = pow2( saturate( tri( time, CAMERA_PERIOD ) ) );\n\n\tfloat camera_time = mod( time, CAMERA_PERIOD );\n\n\tfloat earth_rot_time_scale = 1.0;\n\tfloat earth_rot_time_offset = 0.0;\n\tfloat cloud_flow_time_scale = 1.0;\n\tfloat cloud_flow_time_offset = 0.0;\n\tlame_tweaks.specular_hack = 0.25;\n\tlame_tweaks.cloud_hack = vec3( 2.0, 0.12, 0.5 );\n\n#ifdef CAMERA_TIME_RESET\n\ttime = camera_time;\n#endif\n\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, 0.0 );\n\n\tfloat x = camera_time * ( 1.0 / CAMERA_PERIOD );\n\tfloat xs6 = smoothstep_unchecked_6( x );\n\n\tif ( IS_NEXT_INDEX( CAMERA_ORBITING_CLOSE ) )\n\t{\n\t\tKeplerOrbit ko;\n\t\tko.rmin = earth_radius + atm_max * 100.0;\n\t\tko.period = 60.0 * 180.0;\n\t\tko.e = 0.0024;\n\t\tfloat t = time * 20.0;\n#ifdef CAMERA_TIME_RESET\n\t\tt = bounce_time( t, ko.period, fade );\n#endif\n\t\t// time = 0; // eye should be on y=0,1,0 at time=0\n\t\tKeplerOrbitRetval kr = get_earth_camera_path_kepler( t, ko );\n\t\teye = kr.orbit_position;\n\t\tvec3 up = normalize( cross( kr.orbit_plane_normal, eye ) );\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * 0.98, up );\n\t\ttan_half_fovy = 0.09;\n\t\troll = time * 0.02;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = 2000.0;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tmouse_ctrl = 1.5;\n\t\tmm_offset = vec2( 0.0, 0.0 );\n//\t\texposure = 0.45;\n\t\tlame_tweaks.cloud_hack.z = 0.35;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_ORBITING_FAR ) )\n\t{\n\t\tvec3 up = vec3( 0, 0,  1 );\n\t\tKeplerOrbit ko;\n\t\tko.rmin = earth_radius + atm_max * 100.0;\n\t\tko.period = 60.0 * 25.0;\n\t\tko.e = 0.0024;\n\t\tfloat t = time * 10.0;\n#ifdef CAMERA_TIME_RESET\n\t\tt = bounce_time( t, ko.period, fade );\n#endif\n\t\tKeplerOrbitRetval kr = get_earth_camera_path_kepler( t, ko );\n\t\teye = kr.orbit_position;\n\t\tup = normalize( cross( kr.orbit_plane_normal, eye ) );\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * 0.965, up ); // don't look at real horizon, show more earth\n\t\ttan_half_fovy = 0.3; // 0.3 for sphere\n//\t\troll = time*0.02;\n\t\troll = PI * 3.0 / 4.0;\n\t\tearth_rot_time_scale = 12.0;\n\t\tearth_rot_time_offset = 0.0;\n\t\tcloud_flow_time_scale = 12.0;\n\t\tcloud_flow_time_offset = -10.0;\n\t\tmouse_ctrl = 0.6;\n\t\tmm_offset = vec2( 0.37, -0.08 );\n\t\texposure = 0.75;\n\t\tlame_tweaks.specular_hack = 0.07;\n\t\tlame_tweaks.cloud_hack = vec3( 4.2, 0.12, 0.27 ); // too much decal\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_TAKE_OFF_BLUE ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.382552146, 3.343272924, -0.757502257 ) * cam_scale;\n\t\tvec3 n = normalize( eye );\n\t\tvec3 up = sun_direction;\n\t\teye += n * 500.0 * xs6;\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * mix( 1.0, 0.96, xs6 ), up ); // don't look at real horizon, show more earth\n\t\ttan_half_fovy = mix( 0.2, 0.09, xs6 );\n\t\troll = PI * mix( 0.25, -0.02, 1.0 - exp( -x * 2.0 ) );\n\t\tearth_rot_time_scale = 198.0;\n\t\tearth_rot_time_offset = 39.9;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tlame_tweaks.specular_hack = 0.25;\n\t\tlame_tweaks.cloud_hack = vec3( 2.0, 0.12, 0.3 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_CLOUDS ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( -5.704154491, -0.459553778, -3.58820796 ) * cam_scale;\n\t\tcenter = vec3( -5.828063488, -0.007100194, -2.705070018 ) * cam_scale;\n\t\tcenter = eye + ( center - eye ) * mix( 0.8, 0.8, x );\n\t\teye = rotate_around( center, normalize( center ), eye, x * PI * 0.12 );\n\t\ttan_half_fovy = 0.05;\n\t\troll = mix( -0.2, -0.3, x ) * PI;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = -1600.0;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = -900.0;\n\t\tmouse_ctrl = 2.5;\n\t\texposure = 0.8;\n\t\tlame_tweaks.cloud_hack = vec3( 4.0, 0.12, 0.6 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_SPECULAR_FAR ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.421999931, -0.140298634, -3.804290771 ) * cam_scale;\n\t\tcenter = vec3( 5.581956386, 0.285743594, -2.913840293 ) * cam_scale;\n\t\tfloat rt = 0.25;\n\t\teye.xz = rotate_with_angle( eye.xz, PI * rt );\n\t\tcenter.xz = rotate_with_angle( center.xz, PI * rt );\n\t\ttan_half_fovy = 0.62;\n\t\tearth_rot_time_scale = 60.0;\n\t\tearth_rot_time_offset = 20.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 100.0;\n\t\tmouse_ctrl = 0.26;\n\t\tmm_offset = vec2( -0.5, -0.29 );\n\t\tlame_tweaks.specular_hack = 150.0;\n\t\tlame_tweaks.cloud_hack = vec3( 4.5, 0.15, 1.0 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_SPECULAR_CLOSE ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.421999931, -0.140298634, -3.804290771 ) * cam_scale;\n\t\tcenter = vec3( 5.581956386, 0.285743594, -2.913840293 ) * cam_scale;\n\t\tfloat r = 0.0603;\n\t\teye.xz = rotate_with_angle( eye.xz, PI * r );\n\t\tcenter.xz = rotate_with_angle( center.xz, PI * r );\n\t\ttan_half_fovy = 0.3;\n\t\tearth_rot_time_scale = 60.0;\n\t\tearth_rot_time_offset = 22.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tmouse_ctrl = 0.9;\n\t\tmm_offset = vec2( -0.84, -0.28 );\n\t\tlame_tweaks.specular_hack = 100.0;\n\t\tlame_tweaks.cloud_hack = vec3( 3.4, 0.15, 0.9 );\n\t\texposure = 0.5;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_TAKE_OFF_SUNRISE ) )\n\t{\n\t\tfloat at1 = exp( -x * 10.0 ); // anim time 1: approach\n\t\tfloat at2 = smoothstep_unchecked_6( remap( x, 0.3, 1.0 ) ); // anim time 2: ascension\n\t\tfloat r = earth_radius + cloud_start * 5.0 + atm_max * at2 * 200.0;\n\t\tvec3 up = vec3( 0, 0, 0 ); up.zx = unit_vector2( -PI * 0.56 );\n\t\tvec3 sun_pos = sun_dist * sun_direction;\n\t\tvec3 tangent_point = get_tangent_point( sun_pos, earth_center, r, up );\n\t\tcenter = tangent_point;\n\t\tvec3 rail = normalize( sun_pos - tangent_point );\n\t\tfloat d0 = earth_radius * 0.08; // distance to tangent point is d\n\t\tfloat d1 = earth_radius * 0.03;\n\t\teye = tangent_point + rail * mix( -d0, d1, x ); //\n\t\tvec3 end_center = get_tangent_point( eye, earth_center, earth_radius * 0.984, sun_direction );\n\t\tcenter = eye + rail;\n\t\tcenter = mix( center, end_center, at2 );\n\t\ttan_half_fovy = 0.15;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = 0.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 90.0;\n\t\texposure = mix( 0.4, 0.75, xs6 );\n\t\tlame_tweaks.cloud_hack = vec3( 3.0, 0.12, 0.65 );\n\t\tmm_offset = vec2( 0.0, -0.1 * xs6 );\n\t\tmouse_ctrl = 1.2;\n\t\troll = PI * 0.0;\n\t\tlame_tweaks.specular_hack = 0.1;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_MOON_WIP ) )\n\t{\n\t\tfloat d = earth_radius * 0.5; // distance to tangent point is d\n\t\tfloat r = earth_radius + 4.0 * atm_max;\n\t\tvec3 moon_pos = moon_dist * moon_direction * 1.0;\n\t\tvec3 tangent_point = get_tangent_point( moon_pos, earth_center, r, vec3( 0, 1, 0 ) );\n\t\tcenter = tangent_point;\n\t\teye = tangent_point + d * normalize( tangent_point - moon_pos ); //\n\t\ttan_half_fovy = 0.045;\n\t\tearth_rot_time_scale = 30.0;\n\t\tearth_rot_time_offset = 1700.0;\n\t\tcloud_flow_time_scale = 3.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\troll = -PI * 0.5;\n\t\tlame_tweaks.cloud_hack = vec3( 2.6, 0.12, 0.22 );\n\t\tmouse_ctrl = 0.5;\n\t\tmm_offset = vec2( -0.07, 0.018 );\n\t}\n\n\tvec3 up = normalize( eye ); // horizontal views\n\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 ) mm = ( iMouse.xy - iResolution.xy * 0.5 ) / ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n//\tcamera_time = GLOBALTIME; // comment to always show the same time slice\n\tlame_tweaks.cloud_flow_time = ( cloud_flow_time_offset + camera_time ) * cloud_flow_time_scale;\n\tlame_tweaks.earth_rot_time = ( earth_rot_time_offset + camera_time ) * earth_rot_time_scale;\n\n\treturn lookat( eye, center, up ) * z_rotation( roll ) * yup_spherical_offset( mm.y, mm.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 resolution = iResolution.xy;\n\tvec2 pixel = fragCoord.xy;\n\tfragColor = vec4( 0., 0., 0., 1 );\n\n#ifdef HD_BLACK_BANDS\n\tfloat aspect = ( 16.0 / 9.0 ); // the ratio we want\n\tif ( iResolution.x < aspect * iResolution.y )\n\t{\n\t\tresolution.y = resolution.x * ( 1.0 / aspect );\n\t\tpixel.y -= ( iResolution.y - resolution.y ) * 0.5;\n\t\tif ( abs( pixel.y * 2.0 - resolution.y ) > resolution.y ) return;\n\t}\n\telse\n\t{\n\t\tresolution.x = resolution.y * aspect;\n\t\tpixel.x -= ( iResolution.x - resolution.x ) * 0.5;\n\t\tif ( abs( pixel.x * 2.0 - resolution.x ) > resolution.x  ) return;\n\t}\n#else\n\tfloat aspect = ( resolution.x / resolution.y );\n#endif\n\tvec2 uv = pixel / resolution.xy;\n\n\tfloat fade = 1.0;\n\tfloat tan_half_fovy = 0.06; // so we can see then sun\n\tfloat znear = 0.1;\n\tLameTweaks lame_tweaks;\n\tfloat exposure = 0.6;\n\n#ifdef EXTRA_3D_CAMERA\n\tmat4 camera;\n\tcamera[0] = iCamera[0];\n\tcamera[1] = iCamera[1];\n\tcamera[2] = iCamera[2];\n\tcamera[3] = iCamera[3];\n\tcamera[3].xyz *= 1e+3 * atm_scale;\n#else\n\tfloat fast_forward = ( key_state( KEY_RIGHT ) ? 5.0 : 1.0 );\n\tmat4 camera = get_earth_camera( tan_half_fovy, fade, GLOBALTIME * fast_forward, lame_tweaks, exposure );\n#endif\n\n\tRay view_ray = get_view_ray( ( uv - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\n\tview_ray.o = camera[3].xyz;\n\tview_ray.d = ( camera * vec4( view_ray.d, 0 ) ).xyz;\n\n#ifdef SUPER_SAMPLE_HORIZON\n\t// do SS on edge pixels... still expensive\n\tfloat ss = vec3( 1 - exp( -abs( length( project_on_line1( earth_center, view_ray.o, view_ray.d ) - earth_center ) - earth_radius ) * 0.1 ) );\n\tfragColor = vec4( ss, ss, ss, 1.0 );\n\tif ( ss < 0.7 )\n\t{\n\t\tvec2 pmin = ( pixel + vec2( 0.0, 0.0 ) ) / resolution.xy;\n\t\tvec2 pmax = ( pixel + vec2( 1.0, 1.0 ) ) / resolution.xy;\n\n\t\tfragColor.rgb = vec3( 0 );\n\t\tfor ( int i = 0; i < 2; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < 2; j++ )\n\t\t\t{\n\t\t\t\tvec2 uv2 = pmin + ( pmax - pmin )\n\t\t\t\t\t* vec2(\n\t\t\t\t\t0.5 + float( i ) / 2.0,\n\t\t\t\t\t0.5 + float( j ) / 2.0 );\n\t\t\t\tRay subray = get_view_ray( ( uv2 - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\t\t\t\tsubray.o = camera[3].xyz; // make sure all rays have same origin! we don't really care about havnig a znear here\n\t\t\t\tsubray.d = ( camera * vec4( subray.d, 0 ) ).xyz;\n\t\t\t\tfragColor.rgb += earthShader( subray, camera, lame_tweaks, exposure );\n\t\t\t}\n\t\t}\n\t\tfragColor.rgb /= 4.0;\n\t\treturn;\n\t}\n#endif\n\n\tfragColor.rgb = earthShader( view_ray, camera, lame_tweaks, exposure ) * fade;\n\treturn;\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVGRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVGWm", "name": "demosplash2016-cxw-01", "author": "cxw", "description": "Part 01: default shader (plus one important change)\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016", "tags": ["tutorial", "demoparty"], "likes": 0, "viewed": 472, "date": "1474990314", "time_retrieved": "2024-06-20T18:40:51.342265", "image_code": "// Mouseover everything - help is mostly in the tooltips\n// Hotkeys work... but only when the editor has focus.\n//      Ctrl+S to save - blue outline flash means it worked\n//      Alt+Enter to compile - green outline flash means it worked\n//      Alt+Up = play/pause\n//      Alt+Down = reset to the beginning\n// \n// Tabs are real, but autoindent is spaces.  If you want consistency,\n// use an outside editor and paste into here rather than the other way around.\n//                   ---> http://www.vim.org ;) <---\n// ... but if you do use an outside editor, don't forget to save after you \n// paste in an update!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;  // <-- Don't forget to add this!  DON'T FORGET!!!!\n                            // You'll see why soon.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(uv,0.5+0.5*sin(t),1.0);\n}\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lVGzm", "name": "Hypercomplex Exp #1", "author": "Aspect", "description": "hypercomplex systems experiments... didn't work out too well so I figured I should pretend it's artistic instead", "tags": ["raymarching", "fractal", "hypercomplex"], "likes": 1, "viewed": 134, "date": "1473891485", "time_retrieved": "2024-06-20T18:40:52.906423", "image_code": "vec3 gradient=vec3(0.0);\nfloat orbitno=0.0;\nvec3 grad=vec3(1.0);\n vec3 xdir=vec3(1.0,0.0,0.0);\n    vec3 ydir=vec3(0.0,1.0,0.0);\n    vec3 zdir=vec3(0.0,0.0,1.0);\n#define PI 3.1415926535\n\nvec3 hsquare(vec3 w)\n{\n vec3 new=vec3(0.0);   \n     new.x=w.x*w.x -1.* (w.y*w.y)+2.*w.y*w.z;\n        new.y= 2.*w.x*w.y- w.z*w.z  ;\n        new.z= 2.*w.x*w.z;\t\n    w=new;\n    return w;\n\n}\n\nvec3 mulpl(vec3 a,vec3 b)\n{\n vec3 new=vec3(0.0);\n    \n   new.x= a.x*b.x- a.y*b.y   - a.z*b.z + a.z*b.y;\n    new.y= a.x*b.y + a.y*b.x;\n    new.z= a.x*b.z + a.z*b.x+ a.y*b.z;\n    \n    return new;\n}\n\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\n\n//from iq's raymarching primitives\n\nvec2 box( vec3 p, vec3 b)\n{\n  //  mat4 rotmat=rotationMatrix(p,10.1*cos(iTime));\n  //  p=(rotmat*vec4(p,1.0)).xyz;\n //   b=b*2.;\n //   p=p*1.0;\n return vec2(length(max(abs(p)-b,0.0))-0.0,-44.0);\n}\n\n\n\nfloat mandel(vec3 pos)\n{\n    float dr=1.0;\n    pos=rotate(pos,cos(0.35*iTime),sin(0.35*iTime),0.0);\n    pos=pos*1.00;\n    float r=1.0;\n    vec3 zeta= pos;\n    vec3 w=pos;\n    float wr=2.0;\n    vec2 mdb=vec2(0.0);\n    vec3 c= vec3(0.0);\n    grad=vec3(1.0);\n    \n    for(int i=0;i<10;++i)\n    {\n        w=rotate(w,15.*cos(0.05*iTime),45.*sin(0.05*iTime),1.);\n      // w=w*(abs(cos(4.*iTime)/24.)+0.8);\n        //c=vec3(cos(iTime),sin(iTime),0.0);\n\n            wr=length(w);\n           if(((wr*wr>2.0)))\n        {\n            orbitno=float(i);\n\n             break;\n        }\n        \n        vec3 new=vec3(0.0);\n                grad=4.*mulpl(mulpl(mulpl(w,w)-w,mulpl(w,w)-w),2.*mulpl(grad,w)-w)+vec3(1.0,1.0,1.0);\n\n        w=mulpl(mulpl(w,w)-w,mulpl(w,w)-w);\n      // w=mulpl(w,w);\n      // w=mulpl(w,w);\n     // w=hsquare(w);\n\n        \n         w+=1.*(pos);     \n\n    }\n      \n    return wr;\n}\n\n\nfloat manDE(vec3 pos)\n{\n    float epsilon=0.0001;\n    orbitno=0.0;\n   float rad=mandel(pos);\n   \n    return 0.5*rad*log(rad)/length(grad);\n}\n\n\nfloat distfunc(vec3 pos)\n{  \n  //return min(box(pos,vec3(0.9,0.9,0.9)),mandel(pos));\n // return mandel(pos);\n    return manDE(pos);\n\n}\n\nvec2 distfunc2(vec3 pos)\n{  \n  return box(pos,vec3(1.05,1.05,1.1));\n//  return mandel(pos);\n //   return manDE(pos);\n\n}\n\n\nvec3 rayMarch2(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 10; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        dist = distfunc2(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n\nvec3 rayMarch(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    for (int i = 0; i < 150; i++)\n    {       \n        if ((dist.x < EPSILON))   continue;   \n        dist.x = distfunc(pos);\n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\nvec3 shadMarch(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 70; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist.x= distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n//https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nvec3 calculateNormal(float EPSILON, vec3 pos,in vec2 dist)\n{\n  \tvec2 eps = vec2(0.0, EPSILON);\nvec3 normal = normalize(vec3(\n    distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n   distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n    distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n      \t//vec2 eps = vec2(0.0, EPSILON);\n//\tvec3 normal = normalize(vec3(\n  //  distfunc(pos + eps.yxx).x -dist.x,\n  // distfunc(pos + eps.xyx).x - dist.x,\n  //  distfunc(pos + eps.xxy).x - dist.x));\n    \n    return normal;\n}\n\n\n\nvoid getRay(vec2 screenPos,out vec3 cameraOrigin,out vec3 rayDir)\n{\n    cameraOrigin = vec3(0.0+0.0*cos(iTime), 0.0+0.0*sin(iTime), 1.9+0.0*cos(iTime));  \n    vec3 cameraTarget = vec3(0.0, 0.0, 1.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(cameraDir,upDirection));\n\tvec3 cameraUp = normalize(cross(cameraRight,cameraDir));\n    rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n   //rayDir=normalize(cameraDir+vec3(screenPos,0.0));\n                  \n\n\n}\n\n\nvec4 render(vec2 ScreenPos)\n{\n    vec3 rayDir=vec3(0.0);\n    vec3 pos=vec3(0.0);\n    getRay(ScreenPos,pos,rayDir);\n    \n \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0; \n    float EPSILON = 0.001;\n    float totalDist = 0.0;\n    vec2 dist = vec2(EPSILON,0.0);\n    vec3 lightpos=vec3(5.0,5.0,5.0);\n\n    //initial march towards objects\n    vec3 dummypos=pos;\n \tpos=rayMarch2(dummypos,rayDir,EPSILON,dist);\n             if (dist.x <EPSILON)\n        {  \n               vec3 color=vec3(0.0);\n\n        vec2 dist = vec2(EPSILON,0.0);\n\t\t\t\t\n   \t\t\t pos=rayMarch(pos,rayDir,EPSILON,dist);\n   \t\t\t\t\n            \n            if (dist.x <EPSILON)\n     \t\t\t{  \n\n\t\t\n\n                EPSILON=0.5;\n\n             pos=pos-0.0001*rayDir;\n            vec3 normal=calculateNormal(EPSILON,pos,dist);\n\t\t\t//\tvec3 normal=normalize(grad);\n\n            vec3  lightdir=   normalize(lightpos-pos);  \n            vec3 halfvec= normalize(lightdir-rayDir);\n            vec3 reflected= normalize(reflect(rayDir,normal));\n\n\n                 //shadow ray \n          //  EPSILON=0.005;\n          //  vec2 shadowdist=vec2(EPSILON,dist.y);\n         //   vec3 shadowpos=shadMarch(pos+0.01*lightdir,lightdir,EPSILON,shadowdist);\n         //   if(shadowdist.x<EPSILON)\n        //    {\n         //      color=vec3(0.0,0.0,0.0);\n\n         //   }\n         //   else\n            {\n\n        \n        \n   \n        \n    float diffuse = max(0.0, dot(lightdir, normal));\n       \n    float specular = pow(dot(normal,halfvec), 16.0);\n        \n        \n        // diffuse=1.0;\n      //  specular=1.0;\n  //      vec3 colz=vec3(0.0);\n     //   colz.x=texture(iChannel0,512.*vec2(5.0,5.0)).x;\n    //            colz.y=texture(iChannel0,512.*vec2(415.0,315.0)).y;\n   //     colz.z=texture(iChannel0,512.*vec2(125.0,625.0)).z;\n\n//            color = vec3(colz*(diffuse + specular));\n\n   // color = vec3(vec3(0.15*fbm(pos*cos(iTime)),0.24*fbm(ScreenPos.xyx*sin(iTime)),0.55*fbm(pos))*(diffuse + specular)*2.1);\n     \n          //  color = vec3(vec3(0.2*noise(pos.xy*cos(iTime)),0.34*noise(ScreenPos.xy*sin(iTime)),0.55*noise(pos.xy))*(diffuse + specular)*14.1);\n\n \t\t\t// color = vec3(vec3(0.1,0.24,0.55)*(diffuse + specular));\n             color = vec3(vec3(0.1,0.24,0.55)*(diffuse + specular));\n                \n                           \n                vec3 bg=vec3(0.0,0.0,0.45);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.0*iTime)+1.55)))*bg;\n                       color+=bg*(orbitno/5.);\n//\n                   \n\n    \t\t}     \n             return vec4(color, 1.0);\n\n\t\t}\n            \n        \nelse{\n    vec3 bg=vec3(0.0,0.0,0.1);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.5*iTime)+1.25)))*bg;\n    return vec4(bg,1.0);\n}\n        }\n            else{\n                \n                vec3 bg=vec3(0.0,0.0,0.1);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.5*iTime)+1.25)))*bg;\n    return vec4(bg,1.0);\n            }\n            \n            \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{         \n\n \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n     screenPos.x *= iResolution.x / iResolution.y; \n\n    vec2 fc2=fragCoord.xy + vec2(-0.125, -0.375); \n\tvec2 fc3=fragCoord.xy + vec2(+0.375, -0.125);\n\tvec2 fc4=fragCoord.xy + vec2(+0.125, +0.375);\n    vec2 fc5=fragCoord.xy + vec2(-0.375, +0.125);\n    \n     vec2 scpos2=-1.0 +2.0*fc2.xy/iResolution.xy;\n     vec2 scpos3=-1.0 +2.0*fc3.xy/iResolution.xy;\n     vec2 scpos4=-1.0 +2.0*fc4.xy/iResolution.xy;\n     vec2 scpos5=-1.0 +2.0*fc5.xy/iResolution.xy;\n    \n    scpos2.x*=iResolution.x / iResolution.y;\n    scpos3.x*=iResolution.x / iResolution.y;\n    scpos4.x*=iResolution.x / iResolution.y;\n    scpos5.x*=iResolution.x / iResolution.y;\n    \n    \n  \n    fragColor=render(screenPos);\n  // fragColor+=render(scpos2)+render(scpos3)+render(scpos4)+render(scpos5);\n //   fragColor/=5.;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lVGzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ly3D1", "name": "Test Bounding Volume", "author": "wachel", "description": "test speed up by bounding volume", "tags": ["boundingvolume", "boundingbox", "boundingsphere"], "likes": 25, "viewed": 399, "date": "1474509951", "time_retrieved": "2024-06-20T18:40:52.918965", "image_code": "#define PI 3.141592654\n\n#define BOUNDING_VOLUME\t\t\t//turn on/off bounding_volume\n#define MAX_DETAIL_LEVEL 2\t\t//value in [0,1,2],2 will show all detail\n\nfloat smax(float a,float b,float k)\n{\t\n\tfloat h = clamp(0.5 + 0.5*(b - a) / (k + 1e-10), 0.0, 1.0);\n\th = h * h;\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat smin(float a, float b, float k)\n{\n\t\n\tfloat h = clamp(0.5 + 0.5*(b - a) / (k + 1e-10), 0.0, 1.0);\n\th = h * h;\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b * 0.5, 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b * 0.5;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(vec3 p, vec2 c)\n{\n\tvec2 p2d = vec2(length(p.xy),p.z);\n\treturn dot(p2d, c) > 0.0 ? dot(p2d, vec2(c.y, -c.x)) : length(p2d);\n}\n\nfloat sdCircle(vec3 p, float r)\n{\n\tvec2 q = vec2(length(p.xz) - r, p.y);\n\treturn length(q);\n}\n\nfloat sdHalf(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\t\n}\n\nfloat sdPlane(vec3 p, float h)\n{\n    return p.y - h;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x)? d1 : d2;\n}\n\nfloat opU(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat opS(float d1, float d2)\n{\n\treturn max(d1, -d2);\n}\n\nfloat opI(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\nfloat opBlend(float d1, float d2, float k)\n{\n\treturn smin(d1, d2, k);\n}\n\nfloat opSS(float d1, float d2, float k) //Smooth Substraction\n{\n\treturn smax(d1, -d2, k);\n}\n\nfloat opMix(float d1, float d2, float s)\n{\n\treturn mix(d1, d2, s);\n}\n\nvec3 opRot( vec4 q, vec3 v ){ \n\treturn v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);\n}\n\nvec3 opInvRot(in vec4 q,in vec3 v){\n\treturn opRot(vec4(q.x,q.y,q.z,q.w),v);\n}\n\n\n\n//scene start=========================\nvec2 model_floor(vec3 p){\n    p = (p - vec3(0.0,4.16,0.0));\n    float d = sdBox((p - vec3(0.38,-2.54,1.01)), vec3(6.07,0.1,8.0));\n    return vec2(d,2);\n}\n\nvec2 model_closet(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(2.32,4.3,2.3);\n    float dist = udBox(p - vec3(2.15,3.74,3.71), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(2.09,3.71,3.81)), vec3(2.0,4.0,2.0));\n    d = opI(d, sdHalf(p, vec4(-0.7071,0.0002,-0.7071,3.513452)));\n    d = opU(d, (sdBox(opInvRot(vec4(0.0,0.3827,0.0,0.92388),(p - vec3(1.61,3.844,3.33))), vec3(1.4,3.7,0.05)) - 0.02));\n    return vec2(d,8);\n}\n\nvec2 model_left_wall(vec3 p){\n    p = (p - vec3(-0.02,0.15,0.08));\n    float d = sdBox(p, vec3(0.33,5.0,8.0));\n    d = opSS(d, sdBox((p - vec3(0.1,-0.989,0.8)), vec3(0.5,3.2,1.5)), 0.05);\n    return vec2(d,3);\n}\n\nvec2 model_maindoor_main(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.3,3.8,1.73);\n    float dist = udBox(p - vec3(-0.31,-0.15,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.37,-0.24,0.0)), vec3(0.16,3.47,1.7)) - 0.02);\n    d = opSS(d, sdBox((p - vec3(-0.178,-0.389,0.0)), vec3(0.5,3.2,1.48)), 0.05);\n    d = opS(d, sdBox((p - vec3(-0.413,0.44,0.0)), vec3(0.2,1.2,1.1)));\n    return vec2(d,9);\n}\n\nvec2 model_maindoor_up(vec3 p){\n    p = (p - vec3(-0.33,0.48,0.0));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.26,1.36,1.34);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(-0.066,-0.026,0.0)), vec3(0.05,1.3,1.2));\n    d = opS(d, sdBox((p - vec3(-0.078,-0.037,0.0)), vec3(0.2,1.2,1.1)));\n    return vec2(d,9);\n}\n\nvec2 model_maindoor_glass(vec3 p){\n    p = (p - vec3(-0.49,0.44,0.0));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.2,1.27,1.16);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(0.007,0.0,0.0)), vec3(0.11,1.2,1.1));\n    return vec2(d,5);\n}\n\nvec2 model_maindoor_top(vec3 p){\n    p = (p - vec3(-0.272,1.485,0.0));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.26,0.22,2.09);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.086,-0.035,0.0)), vec3(0.25,0.1,1.8)) - 0.02);\n    d = opU(d, (sdBox((p - vec3(-0.056,0.039,0.0)), vec3(0.3,0.05,1.9)) - 0.02));\n    return vec2(d,9);\n}\n\nvec2 model_maindoor(vec3 p){\n    p = (p - vec3(0.2,0.25,0.05));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.42,3.52,2.0);\n    float dist = udBox(p - vec3(-0.27,-0.15,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_maindoor_main(p);\n    d = opU(d, model_maindoor_up(p));\n    d = opU(d, model_maindoor_glass(p));\n#if MAX_DETAIL_LEVEL >= 1\n    d = opU(d, model_maindoor_top(p));\n#endif\n    return d;\n}\n\nvec2 model_vase3(vec3 p){\n    p = (p - vec3(0.314,-0.53,1.28));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.36,1.57,0.36);\n    float dist = udBox(p - vec3(-0.2,-0.49,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdEllipsoid((p - vec3(-0.19,-0.52,0.0)), vec3(0.1,0.8,0.1));\n    d = opBlend(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.155,0.0))), vec2(0.314,0.9494)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,0.061,0.0))), vec2(0.4863,0.8738)), 0.05);\n    return vec2(d,6);\n}\n\nvec2 model_vase4(vec3 p){\n    p = (p - vec3(0.254,-0.53,-1.229));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.36,1.57,0.36);\n    float dist = udBox(p - vec3(-0.2,-0.49,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdEllipsoid((p - vec3(-0.19,-0.52,0.0)), vec3(0.1,0.8,0.1));\n    d = opBlend(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.155,0.0))), vec2(0.314,0.9494)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,0.061,0.0))), vec2(0.4863,0.8738)), 0.05);\n    return vec2(d,6);\n}\n\nvec2 model_left_door_vase(vec3 p){\n    p = (p - vec3(0.3,-0.7,0.83));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.6,4.03,3.17);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_maindoor(p);\n#if MAX_DETAIL_LEVEL >= 1\n    d = opU(d, model_vase3(p));\n#endif\n#if MAX_DETAIL_LEVEL >= 1\n    d = opU(d, model_vase4(p));\n#endif\n    return d;\n}\n\nvec2 model_lamp1(vec3 p){\n    p = (p - vec3(0.163,0.643,-0.929));\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.27;\n    float dist = length(p - vec3(0.0,0.0,0.0));\n    if(dist > boundingSphereRadius + 0.1){\n         return vec2(dist - boundingSphereRadius,0);\n    }\n#endif\n    float d = sdCappedCylinder(opInvRot(vec4(0.0,0.0,-0.7071,0.707107),p), vec2(0.23,0.015));\n    d = opU(d, sdSphere((p - vec3(0.026,0.0,0.0)), 0.2));\n    d = opSS(d, sdHalf(p, vec4(0.0,-1.0,0.0,0.05)), 0.01);\n    return vec2(d,12);\n}\n\nvec2 model_lamp2(vec3 p){\n    p = (p - vec3(0.163,0.643,2.69));\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.29;\n    float dist = length(p - vec3(0.0,0.0,0.0));\n    if(dist > boundingSphereRadius + 0.1){\n         return vec2(dist - boundingSphereRadius,0);\n    }\n#endif\n    float d = sdCappedCylinder(opInvRot(vec4(0.0,0.0,-0.7071,0.707107),p), vec2(0.23,0.015));\n    d = opU(d, sdSphere((p - vec3(0.026,0.0,0.0)), 0.2));\n    d = opSS(d, sdHalf(p, vec4(0.0,-1.0,0.0,0.05)), 0.01);\n    return vec2(d,12);\n}\n\nvec2 model_left(vec3 p){\n    p = (p - vec3(-2.5,4.01,0.83));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.0,5.81,8.0);\n    float dist = udBox(p - vec3(0.15,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_left_wall(p);\n    d = opU(d, model_left_door_vase(p));\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_lamp1(p));\n#endif\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_lamp2(p));\n#endif\n    return d;\n}\n\nvec2 model_front_wall(vec3 p){\n    p = (p - vec3(-0.14,-0.03,0.2));\n    float d = sdBox(p, vec3(5.5,5.0,0.2));\n    return vec2(d,3);\n}\n\nvec2 model_rack(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.0,0.13,0.2);\n    float dist = udBox(p - vec3(0.0,0.03,0.04), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox(p, vec3(1.0,0.0,0.0)) - 0.02);\n    d = opU(d, (sdBox((p - vec3(-0.414,0.0,0.098)), vec3(0.0,0.0,0.2)) - 0.01));\n    d = opU(d, (sdBox((p - vec3(0.432,0.0,0.107)), vec3(0.0,0.0,0.2)) - 0.01));\n    return vec2(d,4);\n}\n\nvec2 model_towel(vec3 p){\n    p = (p - vec3(0.012,0.0,0.107));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.66,1.0,0.24);\n    float dist = udBox(p - vec3(0.0,-0.45,-0.13), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox((p - vec3(0.0,-0.45,-0.105)), vec3(0.6,0.96,0.03)) - 0.03);\n    d = opSS(d, sdCone(opInvRot(vec4(0.7132,0.0115,0.0113,0.700798),(p - vec3(0.151,0.079,-0.18))), vec2(0.0872,0.9962)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(0.7209,0.0,0.0,0.693059),(p - vec3(-0.026,0.079,-0.18))), vec2(0.1219,0.9925)), 0.1);\n    return vec2(d,7);\n}\n\nvec2 model_towelrack(vec3 p){\n    p = (p - vec3(-1.27,-0.64,0.004));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.0,1.0,0.28);\n    float dist = udBox(p - vec3(0.0,-0.44,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_rack(p);\n    d = opU(d, model_towel(p));\n    return d;\n}\n\nvec2 model_vase1(vec3 p){\n    p = (p - vec3(1.46,0.33,2.309));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.36,1.57,0.36);\n    float dist = udBox(p - vec3(-0.2,-0.49,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdEllipsoid((p - vec3(-0.19,-0.52,0.0)), vec3(0.1,0.8,0.1));\n    d = opBlend(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.155,0.0))), vec2(0.314,0.9494)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,0.061,0.0))), vec2(0.4863,0.8738)), 0.05);\n    return vec2(d,6);\n}\n\nvec2 model_vase2(vec3 p){\n    p = (p - vec3(1.09,-0.022,2.309));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.3,1.4,0.3);\n    float dist = udBox(p - vec3(-0.2,-0.4,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdEllipsoid((p - vec3(-0.19,-0.52,0.0)), vec3(0.07,0.6,0.07));\n    d = opBlend(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.155,0.0))), vec2(0.314,0.9494)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.003,0.0))), vec2(0.4863,0.8738)), 0.05);\n    return vec2(d,6);\n}\n\nvec2 model_vase_group(vec3 p){\n    p = (p - vec3(-0.97,-1.74,-2.42));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.94,1.55,0.61);\n    float dist = udBox(p - vec3(1.09,-0.13,2.27), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_vase1(p);\n    d = opU(d, model_vase2(p));\n    return d;\n}\n\nvec2 model_front(vec3 p){\n    p = (p - vec3(0.49,4.19,4.68));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(5.64,5.01,1.0);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_front_wall(p);\n#if MAX_DETAIL_LEVEL >= 1\n    d = opU(d, model_towelrack(p));\n#endif\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_vase_group(p));\n#endif\n    return d;\n}\n\nvec2 model_right_wall(vec3 p){\n    p = (p - vec3(0.52,0.0,0.07));\n    float d = sdBox(p, vec3(0.33,5.0,8.0));\n    return vec2(d,3);\n}\n\nfloat node_taptop(vec3 p){\n    p = p;\n    float d = (sdCircle(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.092,0.352,0.0))), 0.12) - 0.03);\n    d = opS(d, (sdHalf(p, vec4(0.0,1.0,0.0,-0.319)) - 0.03));\n    return d;\n}\n\nfloat node_tap(vec3 p){\n    p = (p - vec3(0.133,0.851,-0.08));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.46,0.63,0.13);\n    float dist = udBox(p - vec3(-0.06,0.18,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return dist;\n    }\n#endif\n    float d = sdCappedCylinder((p - vec3(0.028,0.0,0.0)), vec2(0.05,0.05));\n    d = opU(d, sdCappedCylinder((p - vec3(0.028,0.202,0.0)), vec2(0.03,0.15)));\n    d = opU(d, node_taptop(p));\n    d = opU(d, sdCappedCylinder(opInvRot(vec4(0.0,0.0,-0.0448,0.998994),(p - vec3(-0.213,0.332,0.0))), vec2(0.04,0.025)));\n    return d;\n}\n\nfloat node_valve_left(vec3 p){\n    p = (p - vec3(0.133,0.851,0.152));\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.14;\n    float dist = length(p - vec3(0.0,0.05,0.0));\n    if(dist > boundingSphereRadius + 0.1){\n         return dist - boundingSphereRadius;\n    }\n#endif\n    float d = sdCappedCylinder((p - vec3(0.028,0.025,0.0)), vec2(0.03,0.07));\n    d = opU(d, sdCappedCylinder((p - vec3(0.028,0.105,0.0)), vec2(0.05,0.05)));\n    return d;\n}\n\nfloat node_valve_right(vec3 p){\n    p = (p - vec3(0.133,0.851,-0.293));\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.14;\n    float dist = length(p - vec3(0.0,0.05,0.0));\n    if(dist > boundingSphereRadius + 0.1){\n         return dist - boundingSphereRadius;\n    }\n#endif\n    float d = sdCappedCylinder((p - vec3(0.028,0.025,0.0)), vec2(0.03,0.07));\n    d = opU(d, sdCappedCylinder((p - vec3(0.028,0.105,0.0)), vec2(0.05,0.05)));\n    return d;\n}\n\nvec2 model_tap_and_basin(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.37;\n    float dist = length(p - vec3(0.0,1.04,-0.05));\n    if(dist > boundingSphereRadius + 0.1){\n         return vec2(dist - boundingSphereRadius,0);\n    }\n#endif\n    float d = node_tap(p);\n    d = opU(d, node_valve_left(p));\n    d = opU(d, node_valve_right(p));\n    return vec2(d,4);\n}\n\nvec2 model_box_basin(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.0,1.8,3.23);\n    float dist = udBox(p - vec3(-0.12,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.18,0.07,-0.03)), vec3(0.8,1.5,3.0)) - 0.01);\n    d = opSS(d, sdEllipsoid((p - vec3(-0.198,0.851,-0.08)), vec3(0.3,0.3,0.6)), 0.02);\n    return vec2(d,11);\n}\n\nfloat node_handle_left(vec3 p){\n    p = (p - vec3(-0.031,0.128,-0.419));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.1,0.1,0.1);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return dist;\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.024,0.0,0.0)), vec3(0.0,0.1,0.0)) - 0.01);\n    d = opU(d, (sdBox((p - vec3(0.004,-0.0321,0.0)), vec3(0.05,0.0,0.0)) - 0.005));\n    d = opU(d, (sdBox((p - vec3(0.004,0.0323,0.0)), vec3(0.05,0.0,0.0)) - 0.005));\n    return d;\n}\n\nvec2 model_leftdoor(vec3 p){\n    p = (p - vec3(-0.57,0.01,0.6));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.2,1.3,1.3);\n    float dist = udBox(p - vec3(-0.03,0.06,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(-0.03,0.06,-0.02)), vec3(0.025,1.2,1.2));\n    d = opU(d, sdBox((p - vec3(-0.053,0.06,-0.02)), vec3(0.025,1.1,1.1)));\n    d = opS(d, sdBox((p - vec3(-0.05,0.06,-0.02)), vec3(0.05,1.0,1.0)));\n    d = opU(d, node_handle_left(p));\n    return vec2(d,10);\n}\n\nfloat node_handle_right(vec3 p){\n    p = (p - vec3(-0.031,0.128,0.376));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.1,0.1,0.1);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return dist;\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.024,0.0,0.0)), vec3(0.0,0.1,0.0)) - 0.01);\n    d = opU(d, (sdBox((p - vec3(0.004,-0.0321,0.0)), vec3(0.05,0.0,0.0)) - 0.005));\n    d = opU(d, (sdBox((p - vec3(0.004,0.0323,0.0)), vec3(0.05,0.0,0.0)) - 0.005));\n    return d;\n}\n\nvec2 model_rightdoor(vec3 p){\n    p = (p - vec3(-0.57,0.01,-0.69));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.2,1.3,1.3);\n    float dist = udBox(p - vec3(-0.03,0.06,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(-0.03,0.06,-0.02)), vec3(0.025,1.2,1.2));\n    d = opU(d, sdBox((p - vec3(-0.053,0.06,-0.02)), vec3(0.025,1.1,1.1)));\n    d = opS(d, sdBox((p - vec3(-0.05,0.06,-0.02)), vec3(0.05,1.0,1.0)));\n    d = opU(d, node_handle_right(p));\n    return vec2(d,10);\n}\n\nvec2 model_bottom(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.3,1.8,3.14);\n    float dist = udBox(p - vec3(-0.12,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_box_basin(p);\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_leftdoor(p));\n#endif\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_rightdoor(p));\n#endif\n    return d;\n}\n\nvec2 model_sink(vec3 p){\n    p = (p - vec3(0.1,-1.79,-0.24));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.4,2.42,3.17);\n    float dist = udBox(p - vec3(-0.26,0.15,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_tap_and_basin(p);\n    d = opU(d, model_bottom(p));\n    return d;\n}\n\nvec2 model_mirror(vec3 p){\n    p = (p - vec3(0.389,0.48,0.0));\n    float d = sdBox((p - vec3(-0.012,-0.285,-0.29)), vec3(0.07,1.74,1.27));\n    return vec2(d,1);\n}\n\nvec2 model_right(vec3 p){\n    p = (p - vec3(2.77,4.16,0.93));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.32,5.22,8.13);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_right_wall(p);\n    d = opU(d, model_sink(p));\n    d = opU(d, model_mirror(p));\n    return d;\n}\n\nvec2 model_top(vec3 p){\n    p = (p - vec3(0.4,6.62,0.87));\n    float d = sdBox((p - vec3(0.0,0.11,0.08)), vec3(5.9,0.26,7.89));\n    d = opS(d, sdBox((p - vec3(0.0,-0.082,0.08)), vec3(5.12,0.3,7.22)));\n    return vec2(d,0);\n}\n\nvec2 model_wall(vec3 p){\n    p = p;\n    float d = sdBox(p, vec3(6.21,5.09,0.16));\n    return vec2(d,3);\n}\n\nvec2 model_back(vec3 p){\n    p = (p - vec3(0.49,4.08,-2.97));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(6.21,5.78,0.42);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_wall(p);\n    return d;\n}\n\nvec2 scene(vec3 p){\n    p = (p - vec3(0.0,0.0,0.235));\n    vec2 d = model_floor(p);\n    d = opU(d, model_closet(p));\n    d = opU(d, model_left(p));\n    d = opU(d, model_front(p));\n    d = opU(d, model_right(p));\n    d = opU(d, model_top(p));\n    d = opU(d, model_back(p));\n    return d;\n}\n\nvec2 map(in vec3 p){\n    vec2 d = scene(p);\n    return d;\n}\n\n#define MAT_NUM 13\nvec3 getAlbedoColor(int index){\n    if(index == 0)return vec3(1.0,1.0,1.0);//default\n    if(index == 1)return vec3(0.7058,0.7801,0.7868);//mirror\n    if(index == 2)return vec3(1.0,1.0,1.0);//floor\n    if(index == 3)return vec3(0.9851,1.0,1.0);//wall\n    if(index == 4)return vec3(1.0,1.0,1.0);//metal\n    if(index == 5)return vec3(0.0822,0.088,0.1471);//glass\n    if(index == 6)return vec3(0.4326,0.5812,0.9338);//vase\n    if(index == 7)return vec3(0.5493,0.5609,0.5882);//towel\n    if(index == 8)return vec3(0.9044,0.8732,0.7714);//wood\n    if(index == 9)return vec3(0.6912,0.6014,0.4879);//wood2\n    if(index == 10)return vec3(1.0,1.0,1.0);//basin\n    if(index == 11)return vec3(0.977,1.0,1.0);//basin2\n    if(index == 12)return vec3(0.977,1.0,1.0);//lamp\n    return vec3(1.0, 1.0, 1.0);\n}\n\nvec3 getSceneMaterial(int index){\n    if(index == 0)return vec3(1.0,0.0,0.0);//default\n    if(index == 1)return vec3(1.0,1.0,1.0);//mirror\n    if(index == 2)return vec3(1.0,0.0,0.0);//floor\n    if(index == 3)return vec3(1.0,0.0,0.0);//wall\n    if(index == 4)return vec3(1.0,1.0,0.3);//metal\n    if(index == 5)return vec3(1.0,0.0,0.0);//glass\n    if(index == 6)return vec3(1.0,0.0,0.35);//vase\n    if(index == 7)return vec3(1.0,0.0,0.35);//towel\n    if(index == 8)return vec3(1.0,0.0,0.35);//wood\n    if(index == 9)return vec3(1.0,0.0,0.35);//wood2\n    if(index == 10)return vec3(1.0,0.0,0.35);//basin\n    if(index == 11)return vec3(1.0,0.0,0.0);//basin2\n    if(index == 12)return vec3(1.0,0.0,0.5);//lamp\n    return vec3(1.0, 0.0, 0.0);\n}\n\n\n\n//scene end=========================\n\n\n \nvec3 intersect(in vec3 ro, in vec3 rd)\n{\n\tfloat tmin = 0.1;\n\tfloat tmax = 30.0;\n\tconst int imax = 64;\n\n\tfloat precis = 0.001;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0; \n\tfor (int i = 0; i<imax; i++)\n\t{\n\t\tvec2 res = map(ro + rd*t);\n\t\td = res.x;\n\t\tif (res.x<precis || t>tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * 0.95;\n\t\tm = res.y;\n\t\tc += 1.0;\n\t}\n\n\tif (t>tmax) m = -1.0;\n\treturn vec3(t, m, c/float(imax));\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd,in float len )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.02;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = map(p).x;\n\t\tres = min( res, 60.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(len) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.005, 0.0, 0.0);\n    vec3 nor;\n    nor.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    nor.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    nor.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(nor);\n}\n\nvec3 getAlbedo(int index,vec3 p,vec3 nor)\n{\n\tvec3 color = vec3(1.0,1.0,1.0);\n\tif(index >=0 && index < MAT_NUM){\n\t\tcolor = pow(getAlbedoColor(index),vec3(2.2));\n\t}\n\tif (index == 2) {//floor\n\t\tcolor *= (sin(p.x * 7.0) < 0.0 == sin(p.z * 7.0) < 0.0) ? vec3(0.8, 0.9, 0.8) : vec3(0.7, 0.8, 0.7);\n\t}\n\telse if (index == 3) {//wall\n\t\tcolor *= p.y < 2.0 ? vec3(0.15, 0.15, 0.15) : vec3(1.0, 1.0, 1.0);\n\t}\n\telse if (index == 4) {//metal\n\t\tcolor *= 1.6;\n\t}\n\telse if (index == 7) {//towel\n\t\t//color *= 0.5 + (sin(p.x * 30.0) + sin(p.y * 30.0 + sin(p.z * 24.0) * 5.0)) * 0.3;\n\t}\n    else if(index == 9){ //wood for door\n        //color = texture(iChannel0,vec2(p.y,p.x + p.z) * 2.0).xyz * 0.9 + vec3(0.2,0.2,0.2);\n    }\n\telse if (index == 11) {\n\t\tif (nor.y < 0.001) {\n\t\t\tcolor *= p.y < 3.1 ? vec3(0.2, 0.3, 0.4) : vec3(1.0, 1.0, 1.0);\n\t\t}\n\t}\n\treturn color;\n}\n\nvec3 getMaterial(int index)\n{\n\tvec3 material = vec3(1.0,0.0,0.0);\n\tif(index >=0 && index < MAT_NUM){\n\t\tmaterial = getSceneMaterial(index);\n\t}\n\treturn material;\n}\n\nfloat fresnelSchlick(float InCosine, float normalReflectance)\n{\n    float oneMinusCos = 1.0 - InCosine;\n    float oneMinusCosSqr = oneMinusCos * oneMinusCos;\n    float fresnel = normalReflectance +\n        (1.0 - normalReflectance) * oneMinusCosSqr * oneMinusCosSqr * oneMinusCos;\n\n    return fresnel;\n}\n\nvec3 getLightColor(float length) \n{\n\treturn vec3(1.0, 0.95, 0.85) * 2.0 * (1.0 / (length + 1.0));\n}\n\nvec4 getLightDirLength(vec3 pos)\n{\n\tvec3 lightPos = vec3(0.4, 5.0, 0.87);\n\treturn vec4(normalize(lightPos - pos), length(lightPos - pos));\n}\n\nvec3 getColor(vec3 pos, vec3 albedo, vec3 material, vec3 n,vec3 h)\n{\n\tvec4 light = getLightDirLength(pos);\n\tvec3 lightColor = getLightColor(light.w);\n\tfloat alpha = material.x;\n\tfloat metalness = material.y;\n\tfloat glossiness = material.z;\n\tvec3 diffuse = albedo * (1.0 - metalness);\n\tvec3 specular = mix(vec3(0.1,0.1,0.1), albedo, metalness);\n\tfloat shininess = pow(8192.0, glossiness);\n\tvec3 colDiff = (diffuse + (shininess + 2.0) * 0.125 * pow(max(dot(n,h),0.0),shininess) * specular) * lightColor * max(dot(n, light.xyz),0.0);\n\n\treturn colDiff;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(1,1,1);\n    \n    vec3 tmat = intersect(ro, rd);\n    //return vec3(tmat.zzz);\n\n    int index = int(tmat.y);\n\n    if(index == -1){\n        col = mix(vec3(0.3, 0.2, 0.1)*0.5, vec3(0.7, 0.9, 1.0), 0.5 + 0.5*rd.y);\n    }\n    else if (index == -2){\n        vec3 pos = ro + tmat.x*rd;\n        float d = scene(pos).x;\n        float s = cos(d * 100.0) * 0.5 + 0.5;\n        col = vec3(s,s,s) * 0.2;\n    }\n    else\n    {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n        vec4 lightDirLength = getLightDirLength(pos);\n\n        vec3 h = normalize(-rd + lightDirLength.xyz);\n        float sha = softShadow(pos, lightDirLength.xyz, lightDirLength.w);\n\n        vec3 albedo = getAlbedo(index,pos,nor);\n        vec3 material = getMaterial(index);\n\n        col = getColor(pos,albedo,material,nor,h) * sha * 0.9 + (dot(h,nor) * 0.05 + 0.05) * albedo;\n\n    }\n\n    return col;\n}\n\nvec3 rayDir(in vec3 dir, in vec3 up ,in vec3 uvw)\n{\n\tvec3 uu = normalize( cross(up,dir) );\n\tvec3 vv = normalize( cross(dir,uu) );\n    return normalize(uu * uvw.x + vv * uvw.y + dir * uvw.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\t//p.x *= -1.0;\n\tfloat pixelSize = tan(PI / 6.0) * 2.0 / iResolution.y;\n\tvec2 p = (fragCoord.xy - iResolution.xy * 0.5) * pixelSize;\n\t\n\n    \n    float yaw = (iMouse.x == 0.0 && iMouse.y == 0.0)?iTime * 0.1 + 1.2:-iMouse.x * 0.01;\n    float pitch = (iMouse.x == 0.0 && iMouse.y == 0.0)?-0.1:clamp(iMouse.y/iResolution.y - 0.4,-PI * 0.5,PI * 0.5);\n\n    vec3 camDir = vec3(cos(yaw) * cos(pitch),sin(pitch),sin(yaw) * cos(pitch));\n    \n    vec3 lookAt = vec3(0.3,3.8,-0.0);\n    vec3 camPos = lookAt - camDir * 2.5;//vec3(0.0,4.0,-3.0);\n    //vec3 camDir = normalize(vec3(0,-0.1,1.0));\n    \n    vec3 ro = camPos;\n\tvec3 rd = rayDir(camDir,vec3(0.0,1.0,0.0),vec3(p,1.0));\n\n    vec3 col = render(ro, rd);\n\n    fragColor = vec4(pow(clamp(col, 0.0, 1.0), vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ly3D1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ly3Dm", "name": "cubic butterfly shape", "author": "ollj", "description": "trigonometry basics, but\nan error in a specific variant of calculating a circumcircle resulted in this cubic butterly.\nthe distance field comes comes down to length(p.x,cubicf(p.x,abs(p.y)))\n\nhow to simplify cubicf(x,y)=(x+y-x*x/y)?\nvariations are fun!", "tags": ["basic", "frame"], "likes": 2, "viewed": 138, "date": "1474894956", "time_retrieved": "2024-06-20T18:40:53.257566", "image_code": "//#define greyscale\n\n#define sss(a,b,c) smoothstep(a-b,a+b,c)\n#define res iResolution\n\n#define time  (.4+.15*cos(iTime))\n#define time2 (.8+.2*cos(iTime*.1))\n\n//translate fragments to a frame; scale, center, aspectRatio.\nvec2 frame(vec2 a){a.x-=.5*(res.x-res.y);a/=res.xy;a.x*=res.x/res.y;\n a-=vec2(.5);\n a*=3.;\n a=vec2(-a.y,a.x);//rotate 90 deg.\n return a;}//not for horizonral screens where res.x<res.y ??\n\n//accidental cubic butterfly shaped gradient!\nfloat ButterflyCubic(float x,float h){\n return (x+h-x*x/h)*2.*time;}\n //return (x+h+x*x/h)*.5;} \n\nvoid mainImage(out vec4 r,in vec2 o){\n //m=mousePos;\n //vec2 m=frame(iMouse.xy);\n //p=fragmentPos;\n vec2 p=frame(o.xy);\n r=vec4(p,.4,1.);//return value = fragmentColor;\n#ifdef greyscale\n r=vec4(.6);\n#endif\n //vec2 pm=p-m;\n //float d=length(pm);\n //r*=sss(.5,.01,d);\n r*=step(.05,mod(length(p)*9.,1.));//circles\n vec2 s=step(.01,abs(p));\n //if(length(p)<.05)r=vec4(.5);//central point\n //4 dots mark distance of 1. to center:\n if(length(abs(p)-vec2(0,1))<.03)r=vec4(.1);\n if(length(abs(p)-vec2(1,0))<.03)r=vec4(.1);\n r*=min(s.x,s.y);//main axes that go trough vec2(0):\n\n float c=ButterflyCubic(p.x,p.y);\n //if(length(vec2(0,c))<.03)r=vec4(.5); \n vec2 a=vec2(0.,0.)-p;\n vec2 b=abs(p)-abs(vec2(0,0));\n //if(length(a)<.04)r=vec4(.5);\n //if(length(b)<.04)r=vec4(.5);\n vec2 e=p;\n e.y=ButterflyCubic(p.x,abs(p.y));\n //e.x=ButterflyCubic(a.x,b.y);//also works\n //e is a butterfly-shaped gradient = distanceField.\n if(length(e)<time2   )r+=vec4(.4);//highlight one distance.\n if(length(e)<time2/2.)r+=vec4(.8);//highlight one distance.\n if(length(e)<time2/4.)r+=vec4(1.);//highlight one distance.\n r*=length(e);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ly3Dm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ly3Wm", "name": "Yet Another", "author": "vox", "description": "Yet Another", "tags": ["another", "yet"], "likes": 0, "viewed": 399, "date": "1474850894", "time_retrieved": "2024-06-20T18:40:54.403202", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define circle(x) (vec2(cos(x),sin(x)))\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    \n    return saw(res);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nfloat magnification;\nvec2 tree(vec2 uv)\n{\n    float w1 = saw(time);\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = scale(square, vec2(2.0));\n    square = translate(square, vec2(-1.0));\n    float t1 = time;\n    \n    //square = scale(square, (1.0-saw(uv.xy))*vec2(saw(t1)+.5));\n    square = RotateZ(square, time+seedling);\n    \n    square = scale(square, vec2(.25)*sin(time+seedling+uv.x+uv.y)+.5);\n    \n    square = scale(square, vec2(.5));\n    square = translate(square, vec2(.5));\n    \n    \n    float t = time;\n    vec3 f = flux(time);\n    \n    \n    vec2 dxdy = sqrt(4.0)/iResolution.xy;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(1.0, \t0.0);\n    vec2 c = uv+vec2(0.0, \t\t1.0);\n    \n    vec2 a2 = invBilinear(a, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 b2 = invBilinear(b, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 c2 = invBilinear(c, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    \n    magnification = abs(cross(square[1].xy-square[0].xy, square[3].xy-square[0].xy)/cross(b2-a2, c2-a2));\n    \n    return a2;\n}\n\nfloat draw(vec2 uv)\n{\n    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i =4;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float zoom = 1.5+sin(time);\n    \n    uv = uv*2.0-1.0;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = float(i)/float(max_i);\n        vec2 next = tree((uv));\n        ifs *= clamp(magnification, 0.0, 1.0);\n    \tfloat weight = pow(ifs, 1.0/float(i+1));\n        depth += (saw(uv.x+time)\n                  +saw(uv.y+time)\n                  +draw(next))*weight;\n        uv = next;//*weight+uv*(1.0-weight);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    depth /= float(max_i)/5.0;\n\n    float weight = pow(ifs, 1.0/float(max_i));\n\n    float black = smoothstep(0.0, 1.0/5.0, saw(depth-time));\n    float white = smoothstep(4.0/5.0, 1.0, saw(depth-time));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*weight;\n    fragColor = vec4(clamp(ifs, 0.0, 1.0)*(flux(time+depth)*black+white), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ly3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ly3zD", "name": "NAFORB1", "author": "parameterized", "description": "wavy", "tags": ["procedural", "2d", "abstract"], "likes": 2, "viewed": 500, "date": "1473425933", "time_retrieved": "2024-06-20T18:40:55.021423", "image_code": "float rand(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//(n1x, n1y, n2x, n2y) n=closest points\nvec4 voronoi(vec2 pos, float jitter)\n{\n\tvec2 posi = floor(pos);\n\tvec2 pos2 = vec2(0, 0);\n\tfloat dist = 0.0;\n\tvec2 n1 = vec2(0, 0);\n\tvec2 n2 = vec2(0, 0);\n\tfloat n1d = 1.0/0.0;\n\tfloat n2d = 1.0/0.0;\n\tfor (int i=-2; i < 2; i++) {\n\t\tfor (int j=-2; j < 2; j++) {\n\t\t\tpos2 = posi+vec2(i,j)+vec2(0.5)+(vec2(rand(posi+vec2(i,j)), rand(posi+vec2(i,j)+0.5))*2.0-1.0)*jitter*0.5;\n\t\t\tdist = dot(pos-pos2, pos-pos2);\n\t\t\tif (dist < n2d) {\n\t\t\t\tif (dist < n1d) {\n\t\t\t\t\tn2d = n1d;\n\t\t\t\t\tn1d = dist;\n\t\t\t\t\tn2 = n1;\n\t\t\t\t\tn1 = pos2;\n\t\t\t\t} else {\n\t\t\t\t\tn2d = dist;\n\t\t\t\t\tn2 = pos2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vec4(n1, n2);\n}\n\nvec4 voronoi(vec2 pos)\n{\n\treturn voronoi(pos, 1.0);\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec2 P)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi);\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec4 pixel = vec4(1);\n\tvec2 uv = fragCoord.xy/max(iResolution.x, iResolution.y)\n\t\t\t\t- iResolution.xy/max(iResolution.x, iResolution.y)/2.0;\n\tvec2 globalOffset = vec2(sin(iTime)*0.05, cos(iTime)*0.05);\n\tvec2 uvgo = uv + globalOffset;\n\tpixel.rgb = vec3(40.0/255.0, 110.0/255.0, 160.0/255.0);\n\tfloat freq = 16.0;\n\tfloat p1 = cnoise(uvgo*freq);\n\tfreq = 32.0;\n\tfloat p2 = cnoise((uvgo+p1*0.04)*freq);\n\tfreq = 512.0;\n\tfloat p3 = cnoise(uvgo*freq);\n\tpixel.rgb += (p3*2.0-1.0)*0.02+(p2*2.0-1.0 > 0.2 ? 0.05 : (p2 < 0.2 ? -0.05 : 0.0));\n\tfreq = 12.0;\n\tfreq += (p1*2.0-1.0)*(2.0+sin(iTime)*0.2);\n\tvec4 v1 = voronoi(uvgo*freq, 0.5);\n\tpixel.rgb -= max(abs(uv.x*freq-v1.x), abs(uv.y*freq-v1.y)) < 0.3 ? 0.1 : 0.0;\n\tfreq = 12.0;\n\tfreq += (p1*2.0-1.0)*(2.0+sin(iTime)*0.2);\n\tvec4 v2 = voronoi((uvgo+vec2(0.0, 0.08))*freq, 0.5);\n\tpixel.rgb += max(abs(uv.x*freq-v2.x), abs(uv.y*freq-v2.y)) < 0.3 ? 0.1 : 0.0;\n\tpixel.rgb -= pow(distance(vec2(0), uv)/(1.0+sin(iTime*2.0)/12.0), 2.0);\n\tfragColor = pixel;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ly3zD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ly3zh", "name": "[OLD] Simple shading ", "author": "Sabouh", "description": "Displaying a light and applying shading to the objects accordingly.\n+ cheap Anti-aliasing\n\nYou can move the camera using your mouse", "tags": ["raymarching", "shading"], "likes": 0, "viewed": 62, "date": "1472941458", "time_retrieved": "2024-06-20T18:40:56.966892", "image_code": "/*Inspired by inigo quilez's articles \n http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n + Romain Vergne's lectures http://maverick.inria.fr/~Romain.Vergne/blog/\n Shader : Simple Shading\n Author Sabouh\n*/\n \n//to get a higher float precision\nprecision highp float;\nconst float PI = 3.1415926535897932384626433832795;\nconst int PLANE_NB = 3;\nconst int SPHERE_NB = 2;\nconst int OBJ_NB = PLANE_NB + SPHERE_NB;\nconst int LIGHT =  OBJ_NB+1;\nconst int MAX_NB = 10;\nconst float MAX_VALUE = 100.;\nconst int MAX_INT_VALUE = 100;\nconst vec4 background = vec4(1.,1.,1.,1.);\n\n//*******************************Tools**************************\n//Structures definition\n\n//Light\nstruct Light{\n\tvec3 p;//position\t\n};\n\n//MarchingPack\nstruct MarchingPack{\n\tfloat dist;\n\tfloat index;\n\tbool hit;\n\t\n};\n\n//Ray\nstruct Ray{\n\tvec3 o; //origin\n\tvec3 d; //direction\n};\n\n//Camera\nstruct Camera{\n\tvec3 e;//eye\n    vec3 r;//right\n    vec3 u;//up\n    vec3 v;//view\n\t\n};\n\nstruct Color{\n\tvec4 c;\n};\n\n//Plane\nstruct Plane{\n\tvec3 n; //normal\n\tfloat d; //offset\n};\n\n//Sphere\nstruct Sphere{\n\tvec3 c; //center\n\tfloat r; //rayon\n};\n\n//Distance operations\n\n//union\nvec2 opU(vec2 d1,vec2 d2){\n\treturn d1.x<d2.x ? d1 : d2; //if d1.x < d2.x return d1 else d2\n}\n\n//substraction\nfloat opS(float d1, float d2){\n\treturn max(-d1,d2);\n}\n\n//intersection\nfloat opI(float d1,float d2){\n\treturn max(d1,d2);\n}\n\n\n//------------------\nfloat fPlane(Ray r,float t,vec4 n){\n    vec3 norma = normalize(n.xyz);\n    vec3 norm = n.xyz;\n    vec3 pos = r.o +r.d*t;\n    vec3 Q = norma*n.w ; //Q is in Plane\n    \n    if(dot(r.d,norm ) == 0.){\n       if(dot(r.o-Q,norm)==0.){\n        \treturn 0.;\n       }else{\n        \treturn MAX_VALUE;\n       }\n    }else{\n        if(dot(Q-r.o,norm)  /dot(r.d,norm) < 0.){\n            return MAX_VALUE;\n        }else if(dot(Q-pos,norm) == 0.){\n            return 0.;\n        }else{\n    \t\treturn  ( dot(Q-r.o,norm)  /dot(r.d,norm) ) -t;\n        }\n    }\n        \n}\n\nfloat fSphere(Ray r, float t,vec4 o){\n    vec3 pos = r.o+r.d*t;\n    if(dot(o.xyz-pos,r.d) >=0.){\n        return distance(o.xyz,pos) - o.w ;\n    }else{\n        if(length(o.xyz-pos) <= o.w ){\n            return distance(o.xyz,pos) - o.w ;\n        }else{\n            return MAX_VALUE;\n        }\n    }\n}\n\n//----------\n\n//intersection Ray-Sphere\nvec2 intersectSphere(Ray r, vec4 o, float index){\n\tfloat a,b,c;\n\ta = dot(r.d,r.d);\n\tb = dot(2.*(r.o-o.xyz),r.d);\n\tc =(dot(r.o-o.xyz,r.o-o.xyz)) - pow(o.w,2.) ;\n\t\n\tfloat delta =  pow(b,2.)-4.*a*c ;\n\tif(delta <0.){\n\t\treturn vec2(MAX_VALUE,-1);\n\t}else{\n\t\tfloat t1,t2;\n\t\tt1 = (-b + sqrt(delta) )/(2.*a);\n\t\tt2 = (-b - sqrt(delta) )/(2.*a);\n\t\tif(t1 <0.){\n\t\t\treturn vec2(t2,index);\n\t\t}else if(t2<0.){\n\t\t\treturn vec2(t1,index);\n\t\t}else{\n\t\t\treturn t1<t2 ? vec2(t1,index) : vec2(t2,index);\n\t\t}\n\t}\n}\n\n//intersection Ray-Plane\nvec2 intersectPlane(Ray r, vec4 n,float index){\n    vec3 norm = normalize(n.xyz);\n\tfloat t = -( n.w + dot(r.o,norm)) / dot(r.d,norm);\n\tif(t>=0.){\n\t\treturn vec2(t,index);\n\t\t\n\t}else{\n\t\treturn vec2(MAX_VALUE,-1);\n\t}\n}\n\n//manage intersections \nvec2 checkIntersection(Ray r, vec4 o, float index){\n\tif(index <= float(PLANE_NB) ){\n\t\treturn intersectPlane(r,o,index);\n\t}else{\n\t\treturn intersectSphere(r,o,index);\n\t}\n}\n\n//Init\nvec4 getColor(float index){\n\tif(index == 1.){\n\t\treturn vec4(0.,1.,1.,1.); //cyan\n\t}else if(index == 2.){\n\t\treturn vec4(0.,1.,0.,1.); //green\n\t}else if(index == 3.){\n\t\treturn vec4(0.,0.,1.,1.); //blue\n\t}else if(index == 4.){\n\t\treturn vec4(1.,0.,0.,1.); //red\n\t}else if(index == 5.){ \n\t\treturn vec4(1.,0.,1.,0.); //magenta\n\t}else if(index == float(LIGHT)){ \n\t\treturn vec4(1.,1.,0.,0.); //yellow\n\t}else{\n\t\treturn background;//ERROR WHITE\n\t\t\n\t}\n}\n\nvec4 createSphere(vec3 c, float r, float phi, float teta){\n\tfloat x,y,z;\n\tx = c.x + r*sin(phi)*cos(teta);\n\ty = c.y + r*sin(phi)*sin(teta);\n\tz = c.z + r*cos(phi);\n    return vec4(x,y,z,r);\n    \n}\n\nvec4 getObject(float index){\n    vec4 res ;\n\tif(index == 1.){\n\t\tres =  vec4(0.,0.,1.,0.); //Plane (x,y)\n\t}else if(index == 2.){\n\t\tres = vec4(1.,0.,0.,0.); //Plane (y,z)\n\t}else if(index == 3.){\n\t\tres = vec4(0.,1.,0.,0.); //Plane (x,z)\n\t}else if(index == 4.){\n\t\tres = createSphere(vec3(2.,2.,2.),1., PI/2., PI/2.*iTime); \n\t}else if(index == 5.){ \n\t\tres = createSphere(vec3(2.,2.,2.), 0.8, PI/2.*iTime, PI); \n\t}else if(index == float(LIGHT)){ \n\t\tres = createSphere(vec3(2.,1.,4.), 1., PI*iTime, PI); \n\t}else{\n\t\tvec4 res = vec4(MAX_VALUE,MAX_VALUE,MAX_VALUE,MAX_VALUE);//ERROR \n\t\t\n\t}\t\n    return res;\n}\n\n\n\nvec2 map(Ray r,float t){\n\tvec2 res =  vec2(  fPlane(r,t,getObject(1.)  ),1.) ;\n\tfor(int i = 2;i<= OBJ_NB;i++){\n\t\tif(i<=PLANE_NB){\n\t\t\tres = opU(res, vec2(  fPlane(r,t,getObject(float(i))) ,float(i)) );\n\t\t}else{\n\t\t\tres = opU(res, vec2( fSphere(r,t,getObject(float(i)) ),float(i)) );\t\t\n\t\t}\n\t}\n\treturn res;\n}\n\nvec4 directIllumination(Light l,vec3 pos,float dist, float index,float D){\n\t//compute the normale\n\tvec3 n;\n    if(index <= float(PLANE_NB)){\n       \tn = normalize( getObject(index).xyz );\n    }else{\n       \tn = normalize( pos - getObject(index).xyz );\n    }\n\t//compute intensity\n\tfloat intensity =   dot(normalize(l.p -pos),n) ;\n\t//float intensity = min(1., max(0.,dot(l.p -pos,n)));\n\t\n    if(mod(iTime,9.) <3.){\n    \t//color map\n\t\tvec3 color = getColor(index).xyz;\n\t\treturn vec4(intensity*color,1.0);\n    }else if(mod(iTime,9.) <6. ){\n    \t//height map\n        float h = intensity* (dist/(D));\n     \treturn vec4(h,h,h,1.);\n    }else{\n    \t//normal map\n    \tif(index <= float(PLANE_NB)){\n        \treturn vec4(intensity*n,1.0) ;\n    \t}else{\n\t\t\treturn vec4(intensity*n,1.0);\n    \t}\n    }\n}\n\nvec4 displayColor(vec3 pos,float dist, float index,float D){\n\t\n\t\n    if(mod(iTime,9.) <3.){\n    \t//color map\n\t\treturn getColor(index);\n    }else if(mod(iTime,9.) <3. ){\n    \t//height map\n        float h = dist/(D);\n     \treturn vec4(h,h,h,1.);\n    }else{\n    \t//normal map\n    \tif(index <= float(PLANE_NB)){\n        \treturn vec4((getObject(index)).xyz,1.0) ;\n    \t}else{\n        \tvec3 n = pos - getObject(index).xyz;\n\t\t\treturn vec4(n,1.0);\n    \t}\n    }\n\t\n}\n\n//ray Marching Algorithme\nMarchingPack rayM(Ray r){\n\t\n\tfloat j;\n\tfloat t = 0.00;\n\tvec2 d;\n\tfloat epsilon = 0.0017;\n\tvec3 pos;\n\tfor(int i = 0; i< MAX_INT_VALUE;i++){\n        pos = r.o+ r.d*t;\n\t\td = map(r,t);\n\t\t\n        if( d.x <= epsilon){\n\t\t\tMarchingPack mp = MarchingPack(t,d.y,true);\n\t\t\treturn mp;\n        }\n        \n\t\t\n\t\tt = t + d.x;\t\n\t}\n    \n\tMarchingPack mp = MarchingPack(t,d.y,false);\n\treturn mp;\t\n\t\n\t\n}\n//RayMarching\nvec4 rayMarching(vec2 fragCoord){\n\t//cast a ray w/ camera\n\t\n\t//(x,y) in range [-1;1] \n\tfloat x = (2.*fragCoord.x - iResolution.x )/iResolution.x;\n\tfloat y = (2.*fragCoord.y - iResolution.y )/iResolution.y;\n    \n\tfloat x1 = (2.*fragCoord.x+1. - iResolution.x )/iResolution.x;\n\tfloat y1 = (2.*fragCoord.y+1. - iResolution.y )/iResolution.y;\n    \n\tfloat x2 = (2.*fragCoord.x+1. - iResolution.x )/iResolution.x;\n\tfloat y2 = (2.*fragCoord.y-1. - iResolution.y )/iResolution.y;\n    \n\tfloat x3 = (2.*fragCoord.x-1. - iResolution.x )/iResolution.x;\n\tfloat y3 = (2.*fragCoord.y+1. - iResolution.y )/iResolution.y;\n    \n\tfloat x4 = (2.*fragCoord.x-1. - iResolution.x )/iResolution.x;\n\tfloat y4 = (2.*fragCoord.y-1. - iResolution.y )/iResolution.y;\n    \n\tfloat xMouse = (2.*iMouse.x - iResolution.x )/iResolution.x;\n\tfloat yMouse = (2.*iMouse.y - iResolution.y )/iResolution.y;\n\t\n\t//camera\n\tCamera c;\n    vec3 u1;\n\tc.e = vec3(xMouse*10.,yMouse*10.,5.);//camera\n\tc.v = normalize(-c.e);\n\tu1 = vec3(0.,1.,0.);\n\tc.r = normalize(cross(c.v,u1));\n\tc.u = normalize(cross(c.r,c.v));\n\t\n\t//Ray\n\tRay r;\n\tfloat D = 1./tan(PI/4.);\n\tr.o = c.e;\n\tvec3 rd = x*c.r + y *c.u+ D*c.v;\n\tr.d = normalize(rd);\n\t\n\tRay r1,r2,r3,r4;\n\tr1.o = c.e;\n\tr2.o = c.e;\n\tr3.o = c.e;\n\tr4.o = c.e;\n\tvec3 rd1 = x1*c.r + y1 *c.u+ D*c.v;\n\tr1.d = normalize(rd1);\n\tvec3 rd2 = x2*c.r + y2 *c.u+ D*c.v;\n\tr2.d = normalize(rd2);\n\tvec3 rd3 = x3*c.r + y3 *c.u+ D*c.v;\n\tr3.d = normalize(rd3);\n\tvec3 rd4 = x4*c.r + y4 *c.u+ D*c.v;\n\tr4.d = normalize(rd4);\n    \n\tLight l = Light( getObject(float(LIGHT)).xyz );\n\tvec4 color,color1,color2,color3,color4;\n\tMarchingPack rmp = rayM(r);\n    vec3 pos = r.o+r.d*rmp.dist;\n\tif(rmp.hit){\n        //return\n\t\tcolor= directIllumination(l,pos,rmp.dist,rmp.index,c.e.z*2.);\n\t}else{\n        //return\n\t\tcolor= background;\n\t}\n    \n\tMarchingPack rmp1 = rayM(r1);\n    vec3 pos1 = r1.o+r1.d*rmp1.dist;\n\tif(rmp1.hit){\n\t\tcolor1= directIllumination(l,pos1,rmp1.dist,rmp1.index,c.e.z*2.);\n\t}else{\n\t\tcolor1= background;\n\t}\n    \n\tMarchingPack rmp2 = rayM(r2);\n    vec3 pos2 = r2.o+r2.d*rmp2.dist;\n\tif(rmp2.hit){\n\t\tcolor2= directIllumination(l,pos2,rmp2.dist,rmp2.index,c.e.z*2.);\n\t}else{\n\t\tcolor2= background;\n\t}\n    \n\tMarchingPack rmp3 = rayM(r3);\n    vec3 pos3 = r3.o+r3.d*rmp3.dist;\n\tif(rmp3.hit){\n\t\tcolor3= directIllumination(l,pos3,rmp3.dist,rmp3.index,c.e.z*2.);\n\t}else{\n\t\tcolor3= background;\n\t}\n    \n\tMarchingPack rmp4 = rayM(r4);\n    vec3 pos4 = r4.o+r4.d*rmp4.dist;\n\tif(rmp4.hit){\n\t\tcolor4= directIllumination(l,pos4,rmp4.dist,rmp4.index,c.e.z*2.);\n\t}else{\n\t\tcolor4= background;\n\t}\n    \n    //AA\n    //return color;\n    return (color+ (color1+color2+color3+color4)/4.)/2.;\n}\n\n\n\n//************************Application********************************************\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t  \n\tfragColor = rayMarching(fragCoord);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ly3zh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lyGDw", "name": "Another Liquid", "author": "vox", "description": "Another Liquid", "tags": ["liquid", "another"], "likes": 1, "viewed": 474, "date": "1474829763", "time_retrieved": "2024-06-20T18:40:58.124634", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    \n    return saw(res);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nfloat magnification;\nvec2 tree(vec2 uv)\n{\n    float w1 = saw(time);\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = scale(square, vec2(2.0));\n    square = translate(square, vec2(-1.0));\n    float t1 = time;\n    \n    //square = scale(square, (1.0-saw(uv.xy))*vec2(saw(t1)+.5));\n    \n    square = RotateZ(square, time+seedling);\n    \n    square[1].xy *= vec2(saw(uv.y+time)*.25+.5);\n    \n    square = scale(square, vec2(.5));\n    square = translate(square, vec2(.5));\n    \n    \n    float t = time;\n    vec3 f = flux(time);\n    \n    \n    vec2 dxdy = sqrt(4.0)/iResolution.xy;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(1.0, \t0.0);\n    vec2 c = uv+vec2(0.0, \t\t1.0);\n    \n    vec2 a2 = invBilinear(a, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 b2 = invBilinear(b, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 c2 = invBilinear(c, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    \n    magnification = abs(cross(b2-a2, c2-a2)/2.0);\n    \n    return a2;\n}\n\nfloat draw(vec2 uv)\n{\n    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 8;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float zoom = 1.5+saw(time);\n    \n    uv = uv*2.0-1.0;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = float(i)/float(max_i);\n        vec2 next = tree((uv));\n        ifs /= magnification+1.0;\n    \tfloat weight = pow(ifs, 1.0/float(i+1));\n        depth += (saw(uv.x+time)\n                  +saw(uv.y+time)\n                  +draw(next))*weight;\n        uv = next;//*weight+uv*(1.0-weight);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    depth /= float(max_i)/5.0;\n\n    float weight = pow(ifs, 1.0/float(max_i));\n\n    float black = smoothstep(0.0, 1.0/5.0, saw(depth-time));\n    float white = smoothstep(4.0/5.0, 1.0, saw(depth-time));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*weight;\n    fragColor = vec4(clamp(ifs, 0.0, 1.0)*(flux(time+depth)*black+white), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lyGDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lyGzh", "name": "Radial difference", "author": "Sjeiti", "description": "69 radial gradients with a difference", "tags": ["difference"], "likes": 8, "viewed": 287, "date": "1472940480", "time_retrieved": "2024-06-20T18:40:58.124634", "image_code": "// hash and noise from iqs 'Noise - gradient - 2D': https://www.shadertoy.com/view/XdXGW8\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// main code moving radial gradients around through noise using difference\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float dist = 0.0;\n    vec3 color = vec3(0.0);\n    float time = 0.05*iTime;\n    for(float f=0.0;f<69.0;f++){\n        float size = .005+.01*noise(vec2(0.83+0.231*f+time));\n        vec2 point = iResolution.xy/2.0 + 0.5*iResolution.xy*vec2(\n             noise(vec2(3.97+0.123*f+time))\n            ,noise(vec2(2.01+0.421*f+time))\n        );\n        float dist = length(fragCoord.xy-point);\n        dist *= size;\n        if (mod(f,3.0)!=0.0) color.r = dist - abs(color.r);\n        if (mod(f,4.0)!=0.0) color.g = dist - abs(color.g);\n        if (mod(f,5.0)!=0.0) color.b = dist - abs(color.b);\n        //dist = length(fragCoord.xy-point) - abs(dist);\n    }\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(vec3(dist/iResolution.y),1.0);\n\tfragColor = vec4(color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lyGzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lyGzR", "name": "Biomine", "author": "Shane", "description": "Using a combination of simple gyroid surfaces to create a dual mineral and organic looking scene.", "tags": ["raymarching", "voronoi", "tunnel", "cellular", "gyroid", "bio"], "likes": 129, "viewed": 17248, "date": "1472884858", "time_retrieved": "2024-06-20T18:41:00.930937", "image_code": "/*\n    Biomine\n    -------\n    \n    A biocooling system for a futuristic, off-world mine... or a feeding mechanisn for an alien \n\thatchery? I wasn't really sure what I was creating when I started, and I'm still not. :) I at \n\tleast wanted to create the sense that the tubes were pumping some form of biomatter around \n\twithout having to resort to full reflective and refractive passes... I kind of got there. :)\n\n\tAll things considered, there's not a lot to this. Combine a couple of gyroid surfaces, ID them,\n\tthen add their respective material properties. The scene is simple to create, and explained in\n\tthe distance function. There's also some function based, 2nd order cellular bump mapping, for \n\tanyone interested.\n\n\tThe fluid pumped through the tubes was created by indexing the reflected and refracted rays \n\tinto a basic environment mapping function. Not accurate, but simple, effective and way cheaper\n\tthan the real thing.\n\n\tI'd just finished watching some of the Assembly 2016 entries on YouTube, so for better or\n\tworse, wanted to produce the scene without the help of any in-house textures.\n\n    Related examples: \n\n    Cellular Tiling - Shane\n    https://www.shadertoy.com/view/4scXz2\n\n\tCellular Tiled Tunnel - Shane\n\thttps://www.shadertoy.com/view/MscSDB\n\n*/\n\n// Max ray distance.\n#define FAR 50. \n\n// Variables used to identify the objects. In this case, there are just two - the biotubes and\n// the tunnel walls.\nfloat objID = 0.; // Biotubes: 0, Tunnel walls: 1.\nfloat saveID = 0.;\n\n\n// Standard 1x1 hash functions. Using \"cos\" for non-zero origin result.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat noise3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n////////\n// The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n// blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n// objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as three spheres. If you sum the total \n// instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n// Not requiring a hash function provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost.\n//\nfloat drawSphere(in vec3 p){\n  \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.5));  \n}\n\n\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    return d.x*2.66; // Normalize... roughly.\n    \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0);\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. - b*1.5, b*1.7 + a*1.5); \n}\n\n\n// Smooth maximum, based on IQ's smooth minimum function.\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n\n// The distance function. It's a lot simpler than it looks: The biological tubes are just a gyroid lattice.\n// The mine tunnel, is created by takoing the negative space, and bore out the center with a cylinder. The\n// two are combined with a smooth maximum to produce the tunnel with biotube lattice. On top of that, the \n// whole scene is wrapped around a path and slightly mutated (the first two lines), but that's it.\n\nfloat map(vec3 p){\n  \n    p.xy -= path(p.z); // Wrap the scene around a path.\n\n    p += cos(p.zxy*1.5707963)*.2; // Perturb slightly. The mutation gives it a bit more of an organic feel.\n\n    // If you're not familiar with a gyroid lattice, this is basically it. Not so great to hone in on, but\n    // pretty cool looking and simple to produce.\n    float d = dot(cos(p*1.5707963), sin(p.yzx*1.5707963)) + 1.;\n\n\t// Biotube lattice. The final time-based term makes is heave in and out.\n    float bio = d + .25 +  dot(sin(p*1. + iTime*6.283 + sin(p.yzx*.5)), vec3(.033));\n\n    // The tunnel. Created with a bit of trial and error. The smooth maximum against the gyroid rounds it off\n    // a bit. The abs term at the end just adds some variation via the beveled edges. Also trial and error.\n    float tun = smaxP(3.25 - length(p.xy - vec2(0, 1)) + .5*cos(p.z*3.14159/32.), .75-d, 1.) - abs(1.5-d)*.375;;// - sf*.25;\n\n\n    objID = step(tun, bio); // Tunnel and biolattice IDs, for coloring, lighting, bumping, etc, later.\n\n    return min(tun, bio); // Return the distance to the scene.\n\n \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float bmp;\n    float noi = noise3D(p*96.);\n    \n    if(saveID>.5){\n    \tfloat sf = cellTile(p*.75); \n    \tfloat vor = cellTile(p*1.5);\n    \n        bmp = sf*.66 + (vor*.94 + noi*.06)*.34;\n    }\n    else {\n        p/=3.;//\n        float ct = cellTile(p*2. + sin(p*12.)*.5)*.66+cellTile(p*6. + sin(p*36.)*.5)*.34;\n        bmp = (1.-smoothstep(-.2, .25, ct))*.9 + noi*.1;\n\n        \n    }\n    \n    return bmp;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 72; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)        \n        t += step(h, 1.)*h*.2 + h*.5;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n/*\n// Shadows.\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 20;\n\n    float dist = start;\n    //float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    for (int i=0; i<maxIterationsShad; i++){\n    \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n\n        // +=h, +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        dist += clamp( h, 0.01, 0.25);//min(h, stepDist);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // Shadow value.\n    return min(max(shade, 0.) + 0.5, 1.0); \n}\n*/\n\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 4.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n/*\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Four layers of cheap cell tile noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/64.; // Edge the ray a little forward to begin.\n    \n    for (int i = 0; i<8; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = min(1./(1. + sDi*0.25 + sDi*sDi*0.25), 1.);\n\t    // Noise layer.\n        //float n = trigNoise3D(ro/2.);//noise3D(ro/2.)*.66 + noise3D(ro/1.)*.34;\n        float n = cellTile(ro/2.);\n        mist += n*sAtt;//trigNoise3D\n        // Advance the starting point towards the hit point.\n        ro += rd*t/8.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/4. + hash31(ro)*0.2-0.1, 0., 1.);\n\n}\n*/\n\n//////\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.y += iTime;\n    rd /= 3.;\n\n    // Biotube texturing.\n    float ct = cellTile(rd*2. + sin(rd*12.)*.5)*.66 + cellTile(rd*6. + sin(rd*36.)*.5)*.34;\n    vec3 texCol = (vec3(.25, .2, .15)*(1.-smoothstep(-.1, .3, ct)) + vec3(0.02, 0.02, 0.53)/6.); \n    return smoothstep(0., 1., texCol);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0, 1, iTime*2. + 0.1);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, .5, 5);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Unit ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion, if preferable.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);\n    \n    // Save the object ID just after the \"trace\" function, since other map calls can change it, which\n    // will distort the results.\n    saveID = objID; \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);       \n\n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        if(saveID>.5) sn = doBumpMap(sp, sn, .2);\n        else sn = doBumpMap(sp, sn, .008);\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lightPos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + distlpsp*0.25); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.5;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n     \n\n        // Object texturing and coloring. \n        vec3 texCol;        \n        \n        if(saveID>.5){ // Tunnel walls.\n            // Two second texture algorithm. Terrible, but it's dark, so no one will notice. :)\n            texCol = vec3(.3)*(noise3D(sp*32.)*.66 + noise3D(sp*64.)*.34)*(1.-cellTile(sp*16.)*.75);\n            // Darkening the crevices with the bump function. Cheap, but effective.\n            texCol *= smoothstep(-.1, .5, cellTile(sp*.75)*.66+cellTile(sp*1.5)*.34)*.85+.15; \n        }\n        else { // The biotubes.\n            // Cheap, sinewy, vein-like covering. Smoothstepping Voronoi is the main mechanism involved.\n            vec3 sps = sp/3.;\n            float ct = cellTile(sps*2. + sin(sps*12.)*.5)*.66 + cellTile(sps*6. + sin(sps*36.)*.5)*.34;\n            texCol = vec3(.35, .25, .2)*(1.-smoothstep(-.1, .25, ct)) + vec3(0.1, 0.01, 0.004);\n        }\n        \n        \n    \t/////////   \n        // Translucency, courtesy of XT95. See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        float th = thickness( sp, sn, 1., 1. );\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 1.), 1.);\n        float trans = (tdiff + .0)*th;  \n        trans = pow(trans, 4.);        \n    \t////////        \n\n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading = 1.;//crv*0.5+0.5; \n        \n    \t\n        // Shadows - Better, but they really drain the GPU, so I ramped up the fake shadowing so \n        // that it's not as noticeable.\n        //shading *= softShadow(sp, ld, 0.05, distlpsp, 8.);\n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(.7, .9, 1.)*spec;// + vec3(.5, .8, 1)*spec2;\n        if(saveID<.5) sceneCol += vec3(.7, .9, 1.)*spec*spec;\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 4.)*2.;\n        sceneCol += vec3(1, .07, .15)*trans*1.5;\n        \n        \n        // Fake reflection and refraction on the biotubes. Not a proper reflective and \n        // refractive pass, but it does a reasonable job, and is much cheaper.\n        vec3 ref, em;\n        \n        if(saveID<.5){ // Biotubes.\n            \n            // Fake reflection and refraction to give a bit of a fluid look, albeit\n            // in a less than physically correct fashion.\n            ref = reflect(rd, sn);\n            em = eMap(ref, sn);\n            sceneCol += em*.5;\n            ref = refract(rd, sn, 1./1.3);//svn*.5 + n*.5\n        \tem = eMap(ref, sn);\n            sceneCol += em*vec3(2, .2, .3)*1.5;\n        }\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n\t   \n\t\n\t}\n       \n    // Blend the scene and the background; It's commented out, but you could also integrate some some \n    // very basic, 8-layered smokey haze.\n    //float mist = getMist(camPos, rd, lightPos, t);\n    vec3 sky = vec3(2., .9, .8);//* mix(1., .75, mist);//*(rd.y*.25 + 1.);\n    sceneCol = mix(sky, sceneCol, 1./(t*t/FAR/FAR*8. + 1.));\n\n    // Clamp and present the pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lyGzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tG3Dw", "name": "Yet Another Liquid", "author": "vox", "description": "Yet Another Liquid", "tags": ["liquid", "another", "yet"], "likes": 0, "viewed": 405, "date": "1474831177", "time_retrieved": "2024-06-20T18:41:02.112856", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    \n    return res;\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nfloat magnification;\nvec2 tree(vec2 uv)\n{\n    float w1 = saw(time);\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = scale(square, vec2(2.0));\n    square = translate(square, vec2(-1.0));\n    float t1 = time;\n    \n    //square = scale(square, (1.0-saw(uv.xy))*vec2(saw(t1)+.5));\n    \n    square = RotateZ(square, time+seedling);\n    \n    square[2].xy *= vec2(saw(uv.y+time)*.25+.75);\n    square[0].xy *= vec2(saw(uv.y+time)*.25+.75);\n    \n    square = scale(square, vec2(.5));\n    square = translate(square, vec2(.5));\n    \n    \n    float t = time;\n    vec3 f = flux(time);\n    \n    \n    vec2 dxdy = sqrt(4.0)/iResolution.xy;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(1.0, \t0.0);\n    vec2 c = uv+vec2(0.0, \t\t1.0);\n    \n    vec2 a2 = invBilinear(a, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 b2 = invBilinear(b, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 c2 = invBilinear(c, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    \n    magnification = abs(cross(square[3].xy-square[0].xy, square[1].xy-square[0].xy)/cross(b2-a2, c2-a2));\n    \n    return saw(a2);\n}\n\nfloat draw(vec2 uv)\n{\n    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 8;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float zoom = 1.5+saw(time);\n    \n    uv = uv*2.0-1.0;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = float(i)/float(max_i);\n        vec2 next = tree((uv));\n        ifs /= magnification;\n    \tfloat weight = pow(ifs, 1.0/float(i+1));\n        depth += (saw(uv.x+time)\n                  +saw(uv.y+time)\n                  +draw(next))*weight;\n        uv = next;//*weight+uv*(1.0-weight);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    depth /= float(max_i)/5.0;\n\n    float weight = pow(ifs, 1.0/float(max_i));\n\n    float black = smoothstep(0.0, 1.0/5.0, saw(depth-time));\n    float white = smoothstep(4.0/5.0, 1.0, saw(depth-time));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*weight;\n    fragColor = vec4(clamp(weight, 0.0, 1.0)*(flux(time+depth)*black+white), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tG3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tGGRm", "name": "RoundRect experiment", "author": "ReubenScratton", "description": "A2 D rounded rect that allows a different radius for each corner.\n\nSDF is one of iq's.", "tags": ["2droundrect"], "likes": 3, "viewed": 100, "date": "1473716992", "time_retrieved": "2024-06-20T18:41:02.476687", "image_code": "// Original by Marc Lepage - mlepage/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Extended by me to allow per-corner radii\n\n\n\n// Rect half size\nvec2 hsize = vec2(150.0,80.0);\n\n// Corner radii\nvec4 radii = vec4(32.0,32.0,32.0,32.0);\n\n// Background color\nvec4 bgColor = vec4(0, 0, 0, 1);\n\n// Stroke color\nvec4 strokeColor = vec4(1, 0, 0, 1);\n\n// Stroke width\nfloat strokeWidth = 8.0;\n\n// Rounded rect distance function\nfloat sdRoundRect(vec2 p, vec2 b, vec4 r) {\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    // Rect center\n    vec2 center = iResolution.xy / 2.0;\n\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec4 innerColor = vec4(uv, 0.5 + 0.5*sin(iTime), 1.0);\n\n    // Simple animation (comment out to fill viewport)\n    center += iResolution.xy * 0.25*sin(iTime/3.0);\n    radii.x += 24.0*sin(iTime*2.0);\n    radii.y += 20.0*sin(iTime*5.0);\n    radii.z += 32.0*sin(iTime*4.0);\n    radii.w += 16.0*sin(iTime*3.0);\n    \n    // Mix content with background using rounded rectangle\n\tfloat dOuter = sdRoundRect(fragCoord - center, hsize, radii);\n\tfloat dInner = sdRoundRect(fragCoord - center, hsize - strokeWidth, radii - strokeWidth);\n\n    fragColor = mix(bgColor, mix(strokeColor, innerColor, clamp(0.5-dInner, 0.0, 1.0)), \n                    clamp(0.5-dOuter, 0.0, 1.0));\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGGRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tGGWm", "name": "Rainbow Mercury", "author": "vox", "description": "Rainbow Mercury", "tags": ["rainbowmercury"], "likes": 3, "viewed": 439, "date": "1474836179", "time_retrieved": "2024-06-20T18:41:03.628292", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n#define circle(x) (vec2(cos(x),sin(x)))\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    \n    return res;\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nfloat magnification;\nvec2 tree(vec2 uv)\n{\n    float w1 = saw(time);\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = scale(square, vec2(2.0));\n    square = translate(square, vec2(-1.0));\n    \n    //square = scale(square, (1.0-saw(uv.xy))*vec2(saw(t1)+.5));\n    \n    square = RotateZ(square, time+seedling);\n    \n    float t1 = time;\n    float t2 = time;\n    square = scale(square, vec2(saw(uv.y*uv.x+t2+seedling)*.25+.75));\n    \n    square = scale(square, vec2(.5));\n    square = translate(square, circle(uv.x*PI*2.0+time+seedling)/(6.0+5.0*saw(time)));\n    square = translate(square, circle(uv.y*PI*2.0+time+seedling)/(6.0+5.0*saw(time)));\n    \n    \n    float t = time;\n    vec3 f = flux(time);\n    \n    \n    vec2 dxdy = sqrt(4.0)/iResolution.xy;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(1.0, \t0.0);\n    vec2 c = uv+vec2(0.0, \t\t1.0);\n    \n    vec2 a2 = invBilinear(a, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 b2 = invBilinear(b, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 c2 = invBilinear(c, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    \n    magnification = abs(cross(square[3].xy-square[0].xy, square[1].xy-square[0].xy)/cross(b2-a2, c2-a2));\n    \n    return saw(a2);\n}\n\nfloat draw(vec2 uv)\n{\n    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 5;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float zoom = 1.5+saw(time);\n    \n    uv = uv*2.0-1.0;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = float(i)/float(max_i);\n        vec2 next = tree((uv));\n        ifs /= magnification+1.0;\n    \tfloat weight = pow(ifs, 1.0/float(i+1)/2.0);\n        depth += (length(uv*2.0-1.0))*weight;\n        uv = saw(time+(next*2.0-1.0)*weight);//*weight+vec2(.5)*(1.0-weight);//*weight+uv*(1.0-weight);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    depth /= float(max_i)/5.0;\n\n    float weight = pow(ifs, 1.0/float(max_i)/2.0);\n\n    float black = smoothstep(0.0, 1.0/5.0, saw(depth-time));\n    float white = smoothstep(4.0/5.0, 1.0, saw(depth-time));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*weight;\n    fragColor = vec4(clamp(sqrt(weight), 0.0, 1.0)*(flux(time+depth)*black+white), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tK3RD", "name": "Stpeh the Rom", "author": "Julia_Sets", "description": "Modified Julia Set.", "tags": ["thing"], "likes": 0, "viewed": 90, "date": "1473554205", "time_retrieved": "2024-06-20T18:41:03.840446", "image_code": "// (a + bi)^2 = a^2 - b^2 + 2abi\nvec2 squareComplexNumber(vec2 complexNumber) {\n    float realComponentOfProduct = (complexNumber.x * complexNumber.x) - (complexNumber.y * complexNumber.y);\n    float imaginaryComponentOfProduct = 2.0 * complexNumber.x * complexNumber.y;\n    return vec2(realComponentOfProduct, imaginaryComponentOfProduct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 rainbow[7];\n    rainbow[0] = vec4(1.0, 0.0, 0.0, 1.0); // Red\n    rainbow[1] = vec4(1.0, 0.5, 0.0, 1.0); // Orange\n    rainbow[2] = vec4(1.0, 1.0, 0.0, 1.0); // Yellow\n    rainbow[3] = vec4(0.0, 1.0, 0.0, 1.0); // Green\n    rainbow[4] = vec4(0.0, 0.0, 1.0, 1.0); // Blue\n    rainbow[5] = vec4(0.294117647, 0.0, 0.509803922, 1.0); // Indigo (according to Wikipedia)\n    rainbow[6] = vec4(0.5, 0.0, 1.0, 1.0); // Violet (according to Wikipedia)\n    \n\tfloat zoom = 2.0;\n    vec2 c = vec2(sin(iTime), cos(iTime));\n    //vec2 c = vec2(-1.0, 0.0);\n    \n    vec2 z = fragCoord.xy / iResolution.xy;\n    z = z * vec2(zoom * 2.0);\n    z = z - vec2(zoom);\n    \n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    for (int i = 0; i < 14; i++) {\n        z = squareComplexNumber(z) + c;\n        \n    \tif (z.x < 2.0 && z.y < 2.0) {\n            fragColor = rainbow[i / 2];\n    \t}\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tK3RD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tK3z1", "name": "Green & Purple", "author": "innovati", "description": "Stripes!", "tags": ["green", "purple"], "likes": 0, "viewed": 442, "date": "1473223191", "time_retrieved": "2024-06-20T18:41:03.840446", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = ceil(log(atan(vec4(radians(tan(0.3)), 1.5, 1.2, iTime), reflect(max(vec4(1.6, float(iFrame), 0.9, 0.2), step(vec4(float(iFrame), 0.6, max(0.6, min(1.5, 0.7)), 1.3), sqrt(exp2(vec4(iTime, ((0.8 + 1.5) + 0.1), 0.5, 1.8))))), cos(reflect(atan(mod(atan(vec4(0.8, (fragCoord.y / iResolution.y), (0.6 * (fragCoord.x / iResolution.x)), iTime)), floor(max(vec4((((0.2 + (fragCoord.x / iResolution.x)) / (iTime * float(iFrame))) - (reflect((1.4 - 0.7), 0.1) - 0.9)), float(iFrame), ((fragCoord.y / iResolution.y) - 0.8), (((1.9 + mod(((0.1 - 0.1) + 1.7), 1.3)) * 1.6) - abs(((0.4 + 1.9) - 1.2)))), max(floor(step(vec4((fragCoord.y / iResolution.y), (fragCoord.y / iResolution.y), 0.3, 1.8), inversesqrt(ceil(vec4(0.6, 0.7, atan(1.3, (1.0 - 1.8)), 1.0))))), vec4(iTime, (((fragCoord.x / iResolution.x) - 0.7) / 1.8), (mod(1.9, (fragCoord.y / iResolution.y)) * 1.3), 1.0))))), vec4(0.9, float(iFrame), 1.3, (fragCoord.y / iResolution.y))), vec4((0.2 / 1.1), (1.4 * iTime), 0.1, (fragCoord.y / iResolution.y))))))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tK3z1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tK3zG", "name": "fft experiment", "author": "nshelton", "description": "thought it would be cool to modulate the size by a spherical fft", "tags": ["fft", "deformation", "lattice"], "likes": 9, "viewed": 400, "date": "1475222966", "time_retrieved": "2024-06-20T18:41:04.561688", "image_code": "\n// based on :\n// https://www.shadertoy.com/view/XtSGDK#\n// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat thresh = 10.0;\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat manhattan(vec3 p) {\n \treturn max(max(p.x, p.y), p.z);   \n}\n\nfloat shape( vec3 p, float t)\n{\n    \n    \n    float fftSpace = manhattan(abs(p) /20.) ;\n    \n    float fft = texture(iChannel0, vec2(fftSpace, 0.25)).r;\n    \n    vec3 dim = vec3(pow(fft, 4.0)) / 2.;// vec3(p0,p1,p2);\n\n\tdim.x = 2.0 ;\n\n    vec3 c = vec3(2.);\n\tvec3 q = mod(p,c)-0.5*c;\n\n    float d1 = udBox(q,dim.xyz);\n    float d2 = udBox(q,dim.zyx);\n    float d3 = udBox(q,dim.zxy);\n\n    return min( min(d1,d2), d3);\n}\n\nfloat map( vec3 p, float t )\n{\n    float s = 1.1;\n    //p = deform( p, t, s );\n    return shape( p, t ) * s;\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, float time)\n{\n\n    vec3 p = rd;\n    \n    float contour = abs(sin(length(p))  ) < 0.1 ? 1.0 : 0.0;\n\n    float fftSpace = length(rd /10.) + 0.2 ;\n    float fft = texture(iChannel0, vec2(fftSpace, 0.25)).r;\n\n    return vec3(1. - t) * abs(rd);\n}\n\nconst int ITER = 50;\n\nfloat intersect( in vec3 ro, in vec3 rd, const float maxdist, float time)\n{\n\n    float t = 0.2;\n    float iter = 0.0;\n    for( int i=0; i<ITER; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = map( p, time);\n\n        if( h<exp(-thresh) || t>maxdist ) break;\n        \n        t += h * 0.9 ;\n        iter++;\n    }\n\treturn iter / float(ITER);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 43.0;\n    float t = intersect( ro, rd, maxdist, time );\n    if( t < maxdist )\n    {\n        col = shade( ro, rd, t, time );\n    }\n\n    return pow( col, vec3(0.5) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(cr,cr,0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\n    vec2 p = (-iResolution.xy+2.0*(fragCoord.xy))/iResolution.y;\n    \n    float time = iTime * 0.05;\n\n    float rad = 5.;\n\n    //vec3 ro = vec3(0.5,0.0,0.5) + 2.0*vec3(cos(an),1.0,sin(an));\n\tvec3 ro = vec3(rad * cos(time), rad * sin(time), 2. * sin(time/10.0)); \n    //mat3 ca = setCamera( vec3(0.0), ta, 0.1 );\n    \n    mat3 rot = calcLookAtMatrix(ro, vec3(0.0), 0.0);\n    vec3 rd = rot * normalize(vec3(p, 1.0));\n\n    vec3 col = render( ro, rd, time );\n\tfragColor = vec4( col, 1.0 );\n    //fragColor =  texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n", "image_inputs": [{"id": "4sS3Rw", "previewfilepath": "https://soundcloud.com/bassacemusic/kendrick-lamar-m-a-a-d-city", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/bassacemusic/kendrick-lamar-m-a-a-d-city", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tK3zG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tK3zR", "name": "circle noise", "author": "Leukbaars", "description": "Simple method to draw a bunch of circles at random positions using value noise.\n\nUseful for:\n-craters\n-cheese\n-confetti\n-bubbles\n-you name it :)\n\nedit: now more optimized!", "tags": ["procedural", "2d", "noise", "circle"], "likes": 16, "viewed": 848, "date": "1472789602", "time_retrieved": "2024-06-20T18:41:04.888840", "image_code": "// Created by Bram Eulaers 2016 - www.brameulaers.net\n// License: Creative Commons Attribution-ShareAlike 3.0 Unported License.\n// -------------------------------------------------------------------------------------\n// Offsets and scales circles using simple value noise. \n\nconst mat2 rot = mat2( 0.6,  0.2, -0.2,  0.6 );\n\nvec2 hash( float n )\n{\n    float sn = sin(n);\n    return fract(vec2(sn,sn*42125.13));\n}\n\nfloat circleNoise( vec2 uv )\n{\n    float uv_y = floor(uv.y);\n    uv.x += uv_y*.31;\n    vec2 f = fract(uv);\n    vec2 h = hash(floor(uv.x)*uv_y);\n    float m = (length(f-.25-(h.x*.5)));\n    float r = h.y*.25;\n    return m = smoothstep(r-.10*r,r,m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv *= sin(iTime*.5)+2.0;\n    uv += iTime*.4;\n          \n    //3 iterations for demo:\n    float m = 1.0;\n    for(float i=1.;i<=3.;i++)\n    {\n    \tuv = uv*rot*2.0+1121.13;\n    \tm *= clamp(circleNoise(uv)+.25*i,0.,1.);  \n    }    \n    \n\tfragColor = vec4(m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0-plus OR cc-by-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tK3zR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKGRD", "name": "Fun With Julia Sets Part 5", "author": "Julia_Sets", "description": "So I had some more fun with Julia sets.", "tags": ["julia", "sets"], "likes": 0, "viewed": 73, "date": "1473547281", "time_retrieved": "2024-06-20T18:41:05.100984", "image_code": "// (a + bi)^2 = a^2 - b^2 + 2abi\nvec2 squareComplexNumber(vec2 complexNumber) {\n    float realComponentOfProduct = (complexNumber.x * complexNumber.x) - (complexNumber.y * complexNumber.y);\n    float imaginaryComponentOfProduct = 2.0 * complexNumber.x * complexNumber.y;\n    return vec2(realComponentOfProduct, imaginaryComponentOfProduct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 rainbow[7];\n    rainbow[0] = vec4(1.0, 0.0, 0.0, 1.0); // Red\n    rainbow[1] = vec4(1.0, 0.5, 0.0, 1.0); // Orange\n    rainbow[2] = vec4(1.0, 1.0, 0.0, 1.0); // Yellow\n    rainbow[3] = vec4(0.0, 1.0, 0.0, 1.0); // Green\n    rainbow[4] = vec4(0.0, 0.0, 1.0, 1.0); // Blue\n    rainbow[5] = vec4(0.294117647, 0.0, 0.509803922, 1.0); // Indigo (according to Wikipedia)\n    rainbow[6] = vec4(0.5, 0.0, 1.0, 1.0); // Violet (according to Wikipedia)\n    \n\tfloat zoom = 2.0;\n    vec2 c = vec2(sin(iTime), cos(iTime));\n    //vec2 c = vec2(-1.0, 0.0);\n    \n    vec2 z = fragCoord.xy / iResolution.xy;\n    z = z * vec2(zoom * 2.0);\n    z = z - vec2(zoom);\n    \n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    for (int i = 0; i < 14; i++) {\n        z = squareComplexNumber(z) + c;\n        \n    \tif (abs(z.x) < 2.0 && abs(z.y) < 2.0) {\n            fragColor = rainbow[i / 2];\n    \t}\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKGRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKGRh", "name": "Fractal Fun", "author": "ragecryx", "description": "My first fractal in shader code.", "tags": ["fractal"], "likes": 4, "viewed": 179, "date": "1473131538", "time_retrieved": "2024-06-20T18:41:05.100984", "image_code": "\nconst float ITER = 100.0;\nfloat INFI = 26.0;\n\nconst float FRminX = -0.8;\nconst float FRminY = -0.6;\nconst float FRmaxX = 0.8;\nconst float FRmaxY = 0.6;\n\nconst float FRangeX = FRmaxX - FRminX;\nconst float FRangeY = FRmaxY - FRminY;\n\nconst float C = 0.279;\nconst float dC = 0.005;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float newC = C + iTime * dC;\n    float N=0.0;\n    vec2 P = vec2(FRminX+FRangeX*(fragCoord.x/iResolution.x),\n                  FRminY+FRangeY*(fragCoord.y/iResolution.y));\n\n    for(float n=0.0; n<ITER; ++n){\n        float aa = P.x * P.x;\n        float bb = P.y * P.y;\n        P.x = aa - bb + newC * 0.85;\n        P.y = 2.0 * P.x * P.y * 0.85;\n        if (aa + bb > INFI) {\n            N = n;\n            break;\n        }\n    }\n    \n    float g = N / INFI / 10.0;\n    fragColor = vec4(g*3.0, g*5.0, g*7.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKGRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKGWw", "name": "A Ton of Galaxies", "author": "vox", "description": "A Ton of Galaxies", "tags": ["atonofgalaxies"], "likes": 2, "viewed": 557, "date": "1474935558", "time_retrieved": "2024-06-20T18:41:06.175744", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0/GR/PI/E)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time*PI*4.0), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n    }\n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0);\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv0, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        \n        antispeckle = stretch;\n\n        stretch = smoothstep(0.0, 1.0/PI/GR, stretch);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(seedling*PI)*stretch;\n\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        \n        color += clamp( galaxy((p.xy)*2.0-1.0)*draw, 0.0, 1.0);//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n\n    \n    \tfragColor = vec4(color);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKGWz", "name": "rgba noise scaling", "author": "ollj", "description": "zooming tinto a QUICK hash24 over time.\nfract(x*time) is less seiture inducing than fract(x+-time)", "tags": ["noise", "hash24"], "likes": 1, "viewed": 244, "date": "1474189120", "time_retrieved": "2024-06-20T18:41:06.525333", "image_code": "/*\n#define highp\n#ifdef highp\nhighp const float tau=sqrt(5.)*.5+.5;//1.6180339887498948482045868343656\nhighp const float pi =asin(1.)*2.;   //3.1415926535897932384626433832795\nhighp const float phi=asin(1.)*4.;   //6.283185307179586476925286766559\n#else\nconst float tau=1.618034; \nconst float pi =3.1415927;\nconst float phi=6.2831853;\n#endif\n//higher precision can not be reached with 32-bit-IEEE754-signed-float.\n*/\n\n//iq gradient noise\nfloat hash(in vec2 p){return fract(sin(p.x*15.32758341+p.y*39.786792357-7.5312)*43758.236237153);}\n/*vec2 hash2(vec2 p){return vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-1.;}\n//https://www.shadertoy.com/view/4tsSW7\n*/\n\n#define bbsm 1739.\n#define bbsopt(a) (fract(a*a/bbsm)*bbsm)\n//vec2 bbsopt(in vec2 a){return fract(a*a/bbsm)*bbsm;}\n//fast hash24 function without sin() for webgl \nvec4 hash24(in vec2 p){vec2 a=mod((p),1024.);vec2 b=bbsopt(a);vec2 c=a.yx+bbsopt(b);\n return fract((b.xyyx+c.xyxy+(c.yx+bbsopt(c)).xxyy)/bbsm);}//https://www.shadertoy.com/view/4ssXzX\n//based on Blum,Blum&Shub 1986 and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\n//github.com/victor-shepardson\n\nvec4 noiseRgb(vec2 i){vec2 p=floor(i);\n    const float num=2.; //average multiple instances\n\tvec4 c=vec4(0.);\n\tfor(float i=0.;i<num;i+=1.)c+=hash24(p+i*1024.);\n\treturn c/num;}\n\n/*\nconst vec2 texSize = vec2(64,64);\n#define time sin(iTime)\n#define f32 (3.-2.*f)*f*f;\n#define oi vec2(0,1)\n#define doh(A) dot(20.*time*hash2(i+A),f-A)\nfloat noise(vec2 p){vec2 f=fract(p),i=floor(p),u=f32\nreturn mix(mix(doh(oi.xx),doh(oi.yx),u.x), \n           mix(doh(oi.xy),doh(oi.yy),u.x),u.y);}\n//https://www.shadertoy.com/view/4tsSW7\n*/\n\nvoid mainImage( out vec4 r,in vec2 fragCoord){\n\tvec2 v =.1*fragCoord.xy/iResolution.xy; \n    //r=texture(iChannel0,floor(v/10.0));\n    v=v*(iTime+25.)*9.;//this is tame\n    //v=v+iTime*9.;//this is not tame\n    //v=v-iTime*9.;//this seizure\n    \n    r=hash24(iResolution.xy/v);\n    /*\n    v*=texSize+0.5;\t  //to texels\n    v+=.2*noise(4.*v);//noise\n    vec2 f=fract(v);\n    v=floor(v)+f32    //smooth between texels\n    v=(v-.5)/texSize; //convert back to texcoords\n*/\n\t//r=texture(iChannel0,v);\n//r=hash24(iResolution.xy/v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tKGzD", "name": "3d l system", "author": "sillsm", "description": "Two bounding spheres have a seam where they intersect which prevents the right branches from rendering. Trying to compensate by throwing a few different sphere systems at the tree and taking the best measurement.", "tags": ["raymarching", "tree", "lsystem"], "likes": 33, "viewed": 1269, "date": "1473565116", "time_retrieved": "2024-06-20T18:41:08.077144", "image_code": "// Copyright Max Sills 2016, licensed under the MIT license.\n// 3d L Systems.\n// Stackless. O(depth*branches*ray march steps*samples)\n//\n#define PI 3.14159265\n#define MAT_PLANE 3.     \n#define MAT_TREE  5.\n// Uncomment to visualize the bounding volumes.\n//#define DEBUG\n\n//--------------------------------------------------------------------------\nmat4 Ry (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, 0, -s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Rz (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Disp (vec3 displacement)\n{\nreturn  mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(displacement, 1)\n); \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n//--------------------------------------------------------------------------\n\nvec2 opU( float d1, float d2, float m1, float m2 )\n{\n    return (d1<d2) ? vec2(d1, m1) : vec2(d2, m2);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  p -= vec3(0.,h.y, 0);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p )\n{ \n\treturn p.y;\n}\n//--------------------------------------------------------------------------\nfloat c_t(vec3 pt, float x1, float x2, float x3)\n{    \n    mat4 posR = Rz(-(25.7/360.)*2.*PI);\n    mat4 negR = Rz(25.7/360.*2.*PI);\n    mat4 bendP = Ry(25.7/360.*2.*PI);\n    mat4 bendR = Ry(-25.7/360.*2.*PI);\n    \n    const int depth = 7;\n    const int branches = 3; \n    float len = 1.5;\n    float wid = .05;\n    float widf= .9;\n    \n    float trunk = sdCappedCylinder(pt-vec3(0.,0., 0.), vec2(wid,len));\n    float d = trunk;\n    float x = sdSphere((Disp(vec3(0.,-2.5*len,0.))*vec4(pt, 1.)).xyz,1.8*len);\n    if (x > 2.*len/2.) return min(x,d);\n\n    vec3 pt_n = pt;\n      for (int i = 1; i <= depth; ++i)\n      {\n        wid *= widf;\n        float l = len*pow(.5,float(i));\n       \n        mat4 mx1 = Rz(-0.2*sin(iTime+6.2))*posR*bendP*Disp(vec3(0,-2.*l - l/2.,0));\n\n        mat4 wind = Rz(0.2*sin(iTime+6.2));\n        mat4 mx2 = wind*negR*bendP*Disp(vec3(0,-2.*l,0));\n\n        wind = Rz(0.2*sin(iTime+1.));\n        mat4 mx3 = wind*Disp(vec3(0,-4.*l,0)) ;\n        \n        vec3 pt_1 = (mx1 * vec4(pt_n,1)).xyz;\n        vec3 pt_2 = (mx2 * vec4(pt_n,1)).xyz;\n        vec3 pt_3 = (mx3 * vec4(pt_n,1)).xyz;\n          \n        // bounding sphere test\n        float z1 = sdSphere((Disp(vec3(0.,-x1*l,0.))*vec4(pt_1, 1.)).xyz,2.5*l);\n        float z2 = sdSphere((Disp(vec3(0.,-x2*l,0.))*vec4(pt_2, 1.)).xyz,2.5*l);\n        float z3 = sdSphere((Disp(vec3(0.,-x3*l,0.))*vec4(pt_3, 1.)).xyz,2.5*l);\n          \n        // potential cylinders\n        float y1= sdCappedCylinder(pt_1, vec2(wid,l));\n        float y2= sdCappedCylinder(pt_2, vec2(wid,l));\n        float y3= sdCappedCylinder(pt_3, vec2(wid,l));\n\n        // calc closest\n        float mi = min(z1, min(z2,z3));\n          \n        vec3 pt = (z1<z2) ? pt_1 : pt_2;\n        pt_n = (min(z1,z2)<z3) ? pt   : pt_3;\n\n        d = min( d, min(y1,min(y2,y3)) );\n        float epsilon = .5;\n        #ifdef DEBUG\n        epsilon = .0;\n        #endif\n        if (mi < epsilon) {continue;} \n          //break;\n          return min(mi,d);\n     }\n   return d; \n    \n}\n\n// Any system of bounding spheres will capture some pieces\n// and miss others due to confusion at the overlap of two spheres. \n// So we throw a few different\n// systems at the tree and take the best estimate.\nfloat c(vec3 pt)\n{\n    // I culled some bounding volumes for speed leading to small artifacts.\n    float y1 = c_t(pt, 3., 3., 2.);\n    //float y4 = c_t(pt, 2., 3., 3.);\n    //float y = min(y4,y1);\n    return y1;\n}\n\n// Returns distance_to_shape, material index\nvec2 scene(vec3 ray)  \n{\n    vec2 objs = opU(c(ray), sdPlane(ray), MAT_TREE, MAT_PLANE);\n    return objs ;\n}\n\n//iq's softshadow\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.01 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec2 trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    float tmax = 21.0;\n    float tmin = .1;\n    float m = 0.0;\n    for (int i = 0; i < 70; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* ray);\n        vec2 data = scene(p);\n        float dist = data.x;\n        m  = data.y;\n        t += dist;//;*.5;//;// * .9;\n        \n        if ( (t > tmax) || ((t < tmin) && (t > 0.))){\n            break;\n        }\n    }\n    if( t>tmax ) m=-1.0;\n    return vec2(t, m);\t\t\t\t\t\t\n}\n\n// iq normal\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\n// Stolen from ming's tutorial.\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.1;\n\tfloat vis = softshadow( pos, toLight, 0.02, 2.5 );\n\t//float vis = 1.;//shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tcomb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\n// Given distance to shape, material index, world coord, and pixel, color.\nvec4 color (float t, float m, vec3 p)\n{\n\n    vec4 col = vec4(0.0);\n    float f = mod( floor(p.z) + floor(p.x), 2.0);\n    \n    if (abs(p.x) > 10. || abs(p.z) > 10.) {\n        return vec4(0.);\n    }\n    else if (abs(m -MAT_TREE) < .001) {\n         vec4 brown = vec4(.8, .6, .45, 1.);\n         vec4 green = vec4(.125,.49,.22,1.);\n         col = mix(brown,green,p.y/10.);\n         //col = vec4(.8, .6, .45, 1.);\n         //return col;\n    }else if( abs(m -MAT_PLANE) < .001 ){\n         \n         col = vec4( 0.8 + 0.1*f*vec3(1.0), 1.);\n    } \n    vec3 nrm = calcNormal(p);\n    vec4 light1 = vec4(2., 8., 2.,   10.0 );\n    vec4 light2 = vec4(-2., 8., -2., 10.0 );\n    vec3 cc  = shade(p,nrm,light1);\n    vec3 cc1 = shade(p,nrm,light2);\n    \n    return (cc.x+cc1.x)*col;\n}\n\n// returns pixel color\nvec4 render(vec3 ray, vec3 pt)\n{\n    vec2 tm    = trace(ray, pt);\n    float t    = tm.x;\n    float mat  = tm.y;\n    vec3 point = pt + (t* ray);\n    return color(t, mat, point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float f = 3.; // f-stop.\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    vec3 position = vec3(cos(iMouse.x/100. - .8)*10., 3., sin(iMouse.y/100.-.3)*10.);\n    \n    mat4 mat = LookAtRH(position, vec3(0,3,0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(mat*(pixel - vec4(0,0,-f,1))).xyz;\n    \n    fragColor   = render(ray, pt);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4tKGzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tV3DD", "name": "Another Yet Another IFS", "author": "vox", "description": "Another.", "tags": ["ifs", "another", "yet"], "likes": 6, "viewed": 435, "date": "1474732054", "time_retrieved": "2024-06-20T18:41:08.968043", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n#define GRID_WIDTH 8.0\n#define GRID_HEIGHT 8.0\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))*GR/2.0/PI*(-1.0)+1.0)*iTime+100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//#define iTime (iTime*.1)\n\nvoid plane1(in vec2 uv, out vec3 p1, out vec3 p2)\n{\n        \n    float theta1 = uv.x*2.0*PI;\n    float theta2 = theta1+uv.y*PI*2.0;\n\n\n    float omega1 = theta1;\n    float omega2 = theta2+time*sign(cos(uv.x*PI));\n\n    float index = (uv.x*GRID_WIDTH+uv.y*GRID_WIDTH*GRID_HEIGHT);\n    \n    float t = time;\n    vec2 c1 = vec2(cos(index*PI/2.0+t),\n                   sin(index*PI/2.0+t));\n\n    p1 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n\t\n    omega1 += c1.x/PI/GR/E;\n    omega2 += c1.y/PI/GR/E;\n    \n    p2 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n}\n\nvoid plane2(in vec2 uv, out vec3 p1, out vec3 p2)\n{\n        \n    float theta1 = uv.x*2.0*PI;\n    float theta2 = theta1+uv.y*PI*2.0;\n\n\n    float omega1 = theta1;\n    float omega2 = theta2+time*sign(cos(uv.x*PI));\n\n    float index = (uv.x*GRID_WIDTH+uv.y*GRID_WIDTH*GRID_HEIGHT);\n    \n    float t = time;\n    vec2 c1 = vec2(cos(index*PI/2.0+t),\n                   sin(index*PI/2.0+t));\n\n    p1 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n\t\n    omega1 += c1.x/PI/GR/E;\n    omega2 += c1.y/PI/GR/E;\n    \n    p2 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n}\n\nvoid plane3(in vec2 uv, out vec3 p1, out vec3 p2)\n{\n        \n    float theta1 = uv.x*2.0*PI;\n    float theta2 = theta1+uv.y*PI*2.0;\n\n\n    float omega1 = theta1;\n    float omega2 = theta2+time*sign(cos(uv.x*PI));\n\n    float index = (uv.x*GRID_WIDTH+uv.y*GRID_WIDTH*GRID_HEIGHT);\n    \n    float t = time;\n    vec2 c1 = vec2(cos(index*PI/2.0+t),\n                   sin(index*PI/2.0+t));\n\n    p1 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n\t\n    omega1 += c1.x/PI/GR/E;\n    omega2 += c1.y/PI/GR/E;\n    \n    p2 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\t//vec3 eye = vec3(0.0, 0.0, 3.0);\n\tvec3 eye = vec3(cos(iTime), sin(iTime*.5), sin(iTime))*2.0;\n    vec3 look = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 foward = normalize(look-eye);\n    vec3 right = normalize(cross(foward, up));\n    up = normalize(cross(right, foward));\n    vec3 ray = normalize(foward+uv.x*right+uv.y*up);\n    \n    fragColor = vec4(0.0);\n    \n \tconst float outerCount = GRID_WIDTH;\n \tconst float innerCount = GRID_HEIGHT;\n        \n    float map = 0.0;\n    float sum = 0.0;\n    \n    for(float i = 0.0; i < outerCount; i+=1.0)\n    {\n        if(i >= outerCount)\n            break;\n        \n        for(float j = 0.0; j < innerCount; j+=1.0)\n        {\n            if(j >= innerCount)\n                break;\n            vec3 p1 = vec3(0.0);\n            vec3 p2 = vec3(0.0);\n            \n            vec2 xy = vec2(i, j)/vec2(outerCount, innerCount);\n            \n            vec3 weight = flux(time/PI/2.0);\n            \n            vec3 temp1, temp2;\n            plane1(xy, temp1, temp2);\n            p1 += weight.x*temp1;\n            p2 += weight.x*temp2;\n            plane2(xy, temp1, temp2);\n            p1 += weight.y*temp1;\n            p2 += weight.y*temp2;\n            plane3(xy, temp1, temp2);\n            p1 += weight.z*temp1;\n            p2 += weight.z*temp2;\n            vec3 ray2 = normalize(p2-p1);\n            \n            float a = dot(ray,ray);\n            float b = dot(ray,ray2);\n            float c = dot(ray2,ray2);\n            float d = dot(ray,eye-p1);\n            float e = dot(eye-p1,ray2);\n            \n            float t1 = (b*e-c*d)/(a*c-b*b);\n            float t2 = (a*e-b*d)/(a*c-b*b);\n            \n            float dist = length((eye+ray*t1)-(p1+ray2*t2));\n            \n            float lineWidth = 50.0/max(iResolution.x, iResolution.y);\n            \n            float lineLength = 2.5+.5*sin(time);\n            \n            float isFoward = (sign(t1)*.5+.5);\n            \n            \n            \n                float sides = (1.0-smoothstep(0.0, lineWidth, dist));\n                float ends = (1.0-smoothstep(0.0, lineLength, abs(t2)));\n                float line = sides*ends*isFoward;\n                \n                map += line*(1.0+i/innerCount+j/outerCount)/2.0;\n                sum += 1.0*line*isFoward;\n        }\n    }\n    \n\tfragColor = vec4(flux(PI*map/sum+time), 1.0)*clamp(map, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tV3R1", "name": "epilepsy tunnel", "author": "Atlas", "description": "My first shader after a while of learning and trying.", "tags": ["tunnel", "epilepsy"], "likes": 5, "viewed": 186, "date": "1473199778", "time_retrieved": "2024-06-20T18:41:08.968043", "image_code": "#define t iTime\n#define PI 3.1415297\n#define TWOPI 2.0*PI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0+2.0*(fragCoord.xy / iResolution.xy))*vec2(iResolution.x/iResolution.y, 1.0);\n    \n    float a = atan( uv.y, uv.x);\n    float r = length(uv);\n    \n   \tvec3 pixel = vec3(0.0);\n\n    float w = TWOPI * t;\n    vec3 col = vec3(0.5+0.5*sin(0.2*w), 0.5+0.5*sin(0.5*w), 0.5+0.5*sin(1.0*w));\n    \n    pixel += col*smoothstep(0.0, 0.1,sin(10.0*(1.0/r+t))-0.9);\n    pixel += col*smoothstep(0.0, 0.1,sin(10.0*(a-t))-0.9);\n    pixel *= smoothstep(0.1, 0.6, r);\n    \n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3R1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tV3Rh", "name": "5a170e6b-c5ac-4ddb-b5e2-a894c309", "author": "bysse", "description": "Zooming checker pattern", "tags": ["checkers"], "likes": 0, "viewed": 155, "date": "1473152337", "time_retrieved": "2024-06-20T18:41:09.101487", "image_code": "vec3 checker(vec2 uv, vec2 size) {\n    vec2 m = sign(fract(uv*size) - .5);\n    return vec3(m.x*m.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;        \n    vec2 size = 2. + vec2(sin(iTime), cos(iTime));\n    vec3 color = checker(uv, size);    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3Rh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tV3RW", "name": "Gackt", "author": "lara", "description": "Squint your eyes!\nSee shader comment for more info.", "tags": ["compression", "image", "mutation", "gackt"], "likes": 13, "viewed": 866, "date": "1473577646", "time_retrieved": "2024-06-20T18:41:10.556112", "image_code": "/*\n\n    Inspired by:       http://www.iquilezles.org/www/articles/genetic/genetic.htm\n    Generation script: https://gist.github.com/literallylara/6d391c329b9f3d5e01accd56dd2c8e83\n\n\tThe script uses a fragment shader to draw and compute the image differences.\n\tGeneration of the image took about 39 hours on a GT730M.\n\n*/\n\nvec2 hash22(vec2 p)\n{\n    return vec2(\n        fract(sin(dot(p.xy, vec2(50159.91193,49681.51239))) * 73943.1699),\n        fract(sin(dot(p.xy, vec2(90821.40973,2287.62201))) * 557.96557)\n    );\n}\n\nconst float W = 128.;\nconst float H = 128.;\nconst float R = 128.;\n\nvoid plot(vec2 uv, inout vec4 colA, vec4 colB, vec3 b)\n{\n    vec2 p = vec2(mod(b.x*W*H,W)/W, floor(b.x*H)/H);\n    vec2 d = vec2(mod(b.y*R*R,R)/R, floor(b.y*R)/R);\n    \n    p += (hash22(p)-.5)*2. / exp(iTime);\n    \n    float s = sin(b.z*6.283185);\n    float c = cos(b.z*6.283185);\n    float r = max(b.x,b.y);\n    \n    float f = colB.a * max(1.-length(mat2(c,s,-s,c)*(uv-p)/d*r)/r,0.);\n    \n    colA.rgb = colA.rgb*(1.-f) + colB.rgb*f;\n    colA.w = clamp(colA.a+f,0.,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x,iResolution.y-fragCoord.y)/iResolution.yy + vec2(-.3,0);\n\tvec4 col = vec4(1);\n    \n    uv += (hash22(uv+iTime)-.5)*.01;\n\n\tplot(uv, col, vec4(0.381,0.288,0.160,0.571), vec3(0.858816,0.367491,0.556801));\n\tplot(uv, col, vec4(0.560,0.425,0.250,0.175), vec3(0.575926,0.211968,0.274033));\n\tplot(uv, col, vec4(0.447,0.333,0.139,0.348), vec3(0.197020,0.055903,0.176482));\n\tplot(uv, col, vec4(0.736,0.397,0.196,0.477), vec3(0.478285,0.133381,0.388667));\n\tplot(uv, col, vec4(0.483,0.432,0.354,0.755), vec3(0.198778,0.203355,0.604573));\n\tplot(uv, col, vec4(0.868,0.427,0.300,0.264), vec3(0.957239,0.360083,0.671671));\n\tplot(uv, col, vec4(0.538,0.407,0.621,0.555), vec3(0.770679,0.461302,0.418360));\n\tplot(uv, col, vec4(0.521,0.166,0.230,0.577), vec3(0.724086,0.258039,0.391295));\n\tplot(uv, col, vec4(0.855,0.815,0.666,0.761), vec3(0.965502,0.228126,0.960625));\n\tplot(uv, col, vec4(0.473,0.598,0.192,0.018), vec3(0.054293,0.588466,0.706540));\n\tplot(uv, col, vec4(0.327,0.099,0.281,0.385), vec3(0.316460,0.195399,0.586579));\n\tplot(uv, col, vec4(0.372,0.277,0.151,0.718), vec3(0.580814,0.125205,0.283354));\n\tplot(uv, col, vec4(0.859,0.670,0.137,0.737), vec3(0.513552,0.118552,0.556112));\n\tplot(uv, col, vec4(0.324,0.302,0.268,0.484), vec3(0.837890,0.101707,0.394337));\n\tplot(uv, col, vec4(0.279,0.190,0.276,0.390), vec3(0.563365,0.078216,0.511810));\n\tplot(uv, col, vec4(0.610,0.544,0.326,0.821), vec3(0.193233,0.093901,0.152802));\n\tplot(uv, col, vec4(0.657,0.897,0.668,0.053), vec3(0.422945,0.903838,0.293514));\n\tplot(uv, col, vec4(0.164,0.851,0.559,0.024), vec3(0.106034,0.721535,0.159595));\n\tplot(uv, col, vec4(0.916,0.563,0.186,0.160), vec3(0.433994,0.212697,0.265771));\n\tplot(uv, col, vec4(0.929,0.579,0.247,0.623), vec3(0.889912,0.101414,0.324352));\n\tplot(uv, col, vec4(0.302,0.492,0.137,0.397), vec3(0.894449,0.195910,0.654731));\n\tplot(uv, col, vec4(0.860,0.370,0.159,0.566), vec3(0.317787,0.103026,0.595501));\n\tplot(uv, col, vec4(0.860,0.654,0.276,0.194), vec3(0.314324,0.329055,0.447417));\n\tplot(uv, col, vec4(0.074,0.110,0.366,0.505), vec3(0.580940,0.039159,0.717334));\n\tplot(uv, col, vec4(0.545,0.414,0.427,0.623), vec3(0.729303,0.078353,0.799642));\n\tplot(uv, col, vec4(0.934,0.874,0.549,0.553), vec3(0.826027,0.612059,0.115266));\n\tplot(uv, col, vec4(0.583,0.218,0.340,0.707), vec3(0.385658,0.054828,0.311331));\n\tplot(uv, col, vec4(0.760,0.568,0.398,0.195), vec3(0.244837,0.126634,0.410436));\n\tplot(uv, col, vec4(0.922,0.501,0.045,0.069), vec3(0.801255,0.123036,0.321713));\n\tplot(uv, col, vec4(0.555,0.174,0.199,0.520), vec3(0.924522,0.095050,0.150204));\n\tplot(uv, col, vec4(0.458,0.404,0.478,0.630), vec3(0.608325,0.140709,0.135990));\n\tplot(uv, col, vec4(0.590,0.228,0.226,0.375), vec3(0.854799,0.070582,0.261565));\n\tplot(uv, col, vec4(0.916,0.305,0.194,0.349), vec3(0.857969,0.066681,0.269606));\n\tplot(uv, col, vec4(0.404,0.404,0.584,0.721), vec3(0.410676,0.025037,0.291801));\n\tplot(uv, col, vec4(0.702,0.526,0.615,0.339), vec3(0.635129,0.226681,0.523093));\n\tplot(uv, col, vec4(0.673,0.536,0.334,0.712), vec3(0.191831,0.133739,0.239331));\n\tplot(uv, col, vec4(0.212,0.465,0.181,0.900), vec3(0.493771,0.109521,0.275719));\n\tplot(uv, col, vec4(0.306,0.203,0.146,0.552), vec3(0.874574,0.044416,0.339438));\n\tplot(uv, col, vec4(0.476,0.457,0.096,0.574), vec3(0.190469,0.226959,0.801222));\n\tplot(uv, col, vec4(0.217,0.096,0.238,0.494), vec3(0.189869,0.064295,0.611167));\n\tplot(uv, col, vec4(0.422,0.183,0.193,0.718), vec3(0.504583,0.156381,0.532666));\n\tplot(uv, col, vec4(0.380,0.413,0.332,0.445), vec3(0.909989,0.273738,0.142846));\n\tplot(uv, col, vec4(0.226,0.233,0.172,0.837), vec3(0.168632,0.195726,0.141235));\n\tplot(uv, col, vec4(0.869,0.427,0.300,0.264), vec3(0.957305,0.359782,0.671872));\n\tplot(uv, col, vec4(0.221,0.287,0.206,0.591), vec3(0.921327,0.125953,0.501161));\n\tplot(uv, col, vec4(0.936,0.498,0.033,0.137), vec3(0.725100,0.105388,0.260377));\n\tplot(uv, col, vec4(0.306,0.204,0.135,0.547), vec3(0.877293,0.041898,0.332959));\n\tplot(uv, col, vec4(0.620,0.879,0.523,0.022), vec3(0.039810,0.970223,0.445125));\n\tplot(uv, col, vec4(0.414,0.250,0.221,0.492), vec3(0.682267,0.101823,0.362089));\n\tplot(uv, col, vec4(0.331,0.092,0.152,0.421), vec3(0.685713,0.086293,0.282163));\n\tplot(uv, col, vec4(0.237,0.334,0.136,0.789), vec3(0.498931,0.226790,0.525437));\n\tplot(uv, col, vec4(0.402,0.374,0.332,0.564), vec3(0.580567,0.047201,0.657550));\n\tplot(uv, col, vec4(0.150,0.177,0.411,0.496), vec3(0.423610,0.117433,0.252689));\n\tplot(uv, col, vec4(0.352,0.096,0.245,0.339), vec3(0.697651,0.047033,0.435861));\n\tplot(uv, col, vec4(0.250,0.112,0.254,0.704), vec3(0.501845,0.039468,0.652890));\n\tplot(uv, col, vec4(0.947,0.184,0.292,0.082), vec3(0.713749,0.145009,0.254790));\n\tplot(uv, col, vec4(0.207,0.290,0.175,0.711), vec3(0.728182,0.281455,0.575801));\n\tplot(uv, col, vec4(0.393,0.400,0.346,0.633), vec3(0.378059,0.046964,0.356431));\n\tplot(uv, col, vec4(0.864,0.420,0.125,0.133), vec3(0.817192,0.073775,0.195904));\n\tplot(uv, col, vec4(0.392,0.141,0.142,0.415), vec3(0.790387,0.086150,0.384364));\n\tplot(uv, col, vec4(0.533,0.045,0.265,0.588), vec3(0.118979,0.016595,0.146515));\n\tplot(uv, col, vec4(0.696,0.074,0.152,0.345), vec3(0.674869,0.032557,0.519143));\n\tplot(uv, col, vec4(0.238,0.305,0.155,0.491), vec3(0.863641,0.125521,0.447260));\n\tplot(uv, col, vec4(0.393,0.064,0.425,0.502), vec3(0.128499,0.211422,0.726846));\n\tplot(uv, col, vec4(0.392,0.207,0.173,0.458), vec3(0.709549,0.084262,0.325726));\n\tplot(uv, col, vec4(0.153,0.252,0.211,0.764), vec3(0.894519,0.055094,0.681667));\n\tplot(uv, col, vec4(0.188,0.316,0.193,0.749), vec3(0.169068,0.017546,0.401583));\n\tplot(uv, col, vec4(0.949,0.181,0.292,0.078), vec3(0.713201,0.144713,0.251810));\n\tplot(uv, col, vec4(0.860,0.455,0.218,0.201), vec3(0.457645,0.337697,0.502957));\n\tplot(uv, col, vec4(0.174,0.131,0.161,0.885), vec3(0.450623,0.125179,0.523593));\n\tplot(uv, col, vec4(0.190,0.235,0.128,0.647), vec3(0.839989,0.086823,0.657757));\n\tplot(uv, col, vec4(0.217,0.096,0.238,0.494), vec3(0.189968,0.064424,0.610876));\n\tplot(uv, col, vec4(0.101,0.251,0.328,0.503), vec3(0.494043,0.047057,0.761732));\n\tplot(uv, col, vec4(0.016,0.272,0.268,0.238), vec3(0.979062,0.156988,0.520754));\n\tplot(uv, col, vec4(0.165,0.114,0.086,0.887), vec3(0.396076,0.072775,0.343785));\n\tplot(uv, col, vec4(0.267,0.325,0.181,0.813), vec3(0.481865,0.273551,0.568347));\n\tplot(uv, col, vec4(0.480,0.649,0.161,0.837), vec3(0.166481,0.102980,0.088736));\n\tplot(uv, col, vec4(0.195,0.081,0.258,0.491), vec3(0.174529,0.079741,0.589055));\n\tplot(uv, col, vec4(0.237,0.334,0.136,0.789), vec3(0.498908,0.226783,0.525416));\n\tplot(uv, col, vec4(0.401,0.238,0.179,0.746), vec3(0.426234,0.179750,0.570048));\n\tplot(uv, col, vec4(0.956,0.135,0.180,0.682), vec3(0.279722,0.109672,0.598101));\n\tplot(uv, col, vec4(0.939,0.181,0.305,0.094), vec3(0.693643,0.167930,0.270524));\n\tplot(uv, col, vec4(0.632,0.831,0.081,0.360), vec3(0.975864,0.136885,0.057565));\n\tplot(uv, col, vec4(0.192,0.075,0.270,0.635), vec3(0.207402,0.072769,0.430940));\n\tplot(uv, col, vec4(0.266,0.217,0.381,0.774), vec3(0.822337,0.234677,0.608585));\n\tplot(uv, col, vec4(0.146,0.256,0.186,0.802), vec3(0.901288,0.055235,0.665682));\n\tplot(uv, col, vec4(0.937,0.683,0.092,0.145), vec3(0.276074,0.251040,0.954713));\n\tplot(uv, col, vec4(0.109,0.185,0.231,0.836), vec3(0.735787,0.125203,0.557877));\n\tplot(uv, col, vec4(0.145,0.257,0.176,0.647), vec3(0.216710,0.117523,0.171371));\n\tplot(uv, col, vec4(0.452,0.426,0.101,0.369), vec3(0.817339,0.055463,0.739639));\n\tplot(uv, col, vec4(0.273,0.608,0.636,0.034), vec3(0.398109,0.302660,0.912959));\n\tplot(uv, col, vec4(0.069,0.506,0.073,0.798), vec3(0.779892,0.034409,0.242212));\n\tplot(uv, col, vec4(0.764,0.439,0.149,0.488), vec3(0.824490,0.531873,0.358884));\n\tplot(uv, col, vec4(0.274,0.088,0.235,0.473), vec3(0.649755,0.320682,0.524322));\n\tplot(uv, col, vec4(0.889,0.371,0.022,0.120), vec3(0.909610,0.197848,0.037981));\n\tplot(uv, col, vec4(0.920,0.622,0.582,0.392), vec3(0.590702,0.094828,0.499811));\n\tplot(uv, col, vec4(0.489,0.392,0.423,0.575), vec3(0.708449,0.033718,0.118785));\n\tplot(uv, col, vec4(0.616,0.194,0.101,0.805), vec3(0.254873,0.282326,0.684165));\n\tplot(uv, col, vec4(0.561,0.211,0.218,0.544), vec3(0.968677,0.105350,0.136887));\n\tplot(uv, col, vec4(0.379,0.327,0.184,0.864), vec3(0.599523,0.172169,0.433297));\n\tplot(uv, col, vec4(0.188,0.231,0.213,0.217), vec3(0.932149,0.180104,0.527324));\n\tplot(uv, col, vec4(0.204,0.237,0.203,0.864), vec3(0.255397,0.219246,0.134864));\n\tplot(uv, col, vec4(0.919,0.651,0.163,0.333), vec3(0.572299,0.290238,0.448560));\n\tplot(uv, col, vec4(0.545,0.414,0.427,0.623), vec3(0.729376,0.078287,0.800929));\n\tplot(uv, col, vec4(0.228,0.282,0.492,0.674), vec3(0.626109,0.156340,0.487460));\n\tplot(uv, col, vec4(0.388,0.110,0.113,0.396), vec3(0.835369,0.052990,0.344155));\n\tplot(uv, col, vec4(0.197,0.879,0.379,0.033), vec3(0.976501,0.837784,0.505095));\n\tplot(uv, col, vec4(0.245,0.189,0.292,0.234), vec3(0.910769,0.172353,0.429587));\n\tplot(uv, col, vec4(0.473,0.221,0.461,0.323), vec3(0.878483,0.094153,0.380020));\n\tplot(uv, col, vec4(0.274,0.256,0.162,0.558), vec3(0.411406,0.476756,0.574660));\n\tplot(uv, col, vec4(0.217,0.096,0.238,0.494), vec3(0.189995,0.064148,0.611306));\n\tplot(uv, col, vec4(0.382,0.397,0.209,0.255), vec3(0.825109,0.034975,0.641549));\n\tplot(uv, col, vec4(0.378,0.165,0.105,0.864), vec3(0.318675,0.070964,0.159054));\n\tplot(uv, col, vec4(0.233,0.116,0.268,0.488), vec3(0.255991,0.140960,0.630100));\n\tplot(uv, col, vec4(0.154,0.848,0.646,0.023), vec3(0.046778,0.790110,0.115199));\n\tplot(uv, col, vec4(0.237,0.335,0.137,0.789), vec3(0.499029,0.226626,0.525820));\n\tplot(uv, col, vec4(0.135,0.252,0.186,0.807), vec3(0.904760,0.040193,0.679495));\n\tplot(uv, col, vec4(0.651,0.518,0.186,0.272), vec3(0.721487,0.180156,0.312179));\n\tplot(uv, col, vec4(0.370,0.053,0.025,0.932), vec3(0.161097,0.024064,0.203318));\n\tplot(uv, col, vec4(0.187,0.249,0.076,0.620), vec3(0.228801,0.172243,0.355274));\n\tplot(uv, col, vec4(0.124,0.161,0.176,0.876), vec3(0.568939,0.086616,0.385948));\n\tplot(uv, col, vec4(0.866,0.582,0.300,0.278), vec3(0.386384,0.172524,0.450504));\n\tplot(uv, col, vec4(0.118,0.259,0.234,0.786), vec3(0.548080,0.219135,0.525674));\n\tplot(uv, col, vec4(0.590,0.228,0.226,0.375), vec3(0.854717,0.070498,0.261140));\n\tplot(uv, col, vec4(0.860,0.430,0.204,0.323), vec3(0.720440,0.117925,0.502468));\n\tplot(uv, col, vec4(0.217,0.097,0.238,0.494), vec3(0.189951,0.064276,0.611328));\n\tplot(uv, col, vec4(0.870,0.362,0.043,0.130), vec3(0.901735,0.197712,0.042626));\n\tplot(uv, col, vec4(0.109,0.186,0.231,0.836), vec3(0.736179,0.125151,0.557532));\n\tplot(uv, col, vec4(0.668,0.279,0.300,0.775), vec3(0.376317,0.219202,0.454768));\n\tplot(uv, col, vec4(0.216,0.103,0.242,0.498), vec3(0.189888,0.064371,0.604558));\n\tplot(uv, col, vec4(0.733,0.544,0.256,0.663), vec3(0.238813,0.118395,0.453693));\n\tplot(uv, col, vec4(0.663,0.294,0.311,0.774), vec3(0.368387,0.226892,0.456120));\n\tplot(uv, col, vec4(0.161,0.220,0.190,0.798), vec3(0.482856,0.313137,0.525808));\n\tplot(uv, col, vec4(0.703,0.112,0.879,0.037), vec3(0.851091,0.175348,0.139874));\n\tplot(uv, col, vec4(0.960,0.329,0.116,0.098), vec3(0.353433,0.203885,0.448827));\n\tplot(uv, col, vec4(0.100,0.163,0.208,0.847), vec3(0.733415,0.125356,0.544157));\n\tplot(uv, col, vec4(0.634,0.967,0.863,0.019), vec3(0.227314,0.783042,0.420232));\n\tplot(uv, col, vec4(0.776,0.768,0.831,0.070), vec3(0.843831,0.289047,0.804879));\n\tplot(uv, col, vec4(0.426,0.250,0.178,0.857), vec3(0.425404,0.078339,0.281296));\n\tplot(uv, col, vec4(0.203,0.070,0.249,0.581), vec3(0.352868,0.156515,0.417392));\n\tplot(uv, col, vec4(0.233,0.116,0.268,0.488), vec3(0.255995,0.140955,0.630112));\n\tplot(uv, col, vec4(0.195,0.255,0.151,0.621), vec3(0.859292,0.148646,0.634381));\n\tplot(uv, col, vec4(0.206,0.106,0.289,0.499), vec3(0.166188,0.079170,0.583440));\n\tplot(uv, col, vec4(0.433,0.289,0.164,0.575), vec3(0.667202,0.093872,0.299158));\n\tplot(uv, col, vec4(0.145,0.257,0.176,0.647), vec3(0.216629,0.117526,0.171383));\n\tplot(uv, col, vec4(0.405,0.146,0.269,0.431), vec3(0.611759,0.054845,0.319415));\n\tplot(uv, col, vec4(0.908,0.217,0.353,0.112), vec3(0.863988,0.270072,0.232850));\n\tplot(uv, col, vec4(0.370,0.363,0.216,0.301), vec3(0.825091,0.041141,0.662445));\n\tplot(uv, col, vec4(0.109,0.224,0.185,0.788), vec3(0.490090,0.242903,0.516068));\n\tplot(uv, col, vec4(0.875,0.638,0.148,0.102), vec3(0.394458,0.187801,0.333491));\n\tplot(uv, col, vec4(0.335,0.395,0.259,0.815), vec3(0.143934,0.071762,0.444326));\n\tplot(uv, col, vec4(0.229,0.144,0.249,0.437), vec3(0.855799,0.110004,0.339225));\n\tplot(uv, col, vec4(0.287,0.274,0.134,0.739), vec3(0.230470,0.195440,0.202063));\n\tplot(uv, col, vec4(0.324,0.227,0.300,0.707), vec3(0.893184,0.265840,0.643248));\n\tplot(uv, col, vec4(0.561,0.222,0.216,0.545), vec3(0.959795,0.118406,0.136857));\n\tplot(uv, col, vec4(0.327,0.189,0.211,0.612), vec3(0.376351,0.064113,0.697808));\n\tplot(uv, col, vec4(0.156,0.232,0.228,0.570), vec3(0.317464,0.117802,0.196177));\n\tplot(uv, col, vec4(0.711,0.194,0.097,0.446), vec3(0.238156,0.242521,0.575374));\n\tplot(uv, col, vec4(0.203,0.070,0.249,0.581), vec3(0.352834,0.156543,0.417370));\n\tplot(uv, col, vec4(0.405,0.146,0.269,0.431), vec3(0.611770,0.054882,0.319407));\n\tplot(uv, col, vec4(0.475,0.373,0.224,0.812), vec3(0.801260,0.203311,0.324234));\n\tplot(uv, col, vec4(0.393,0.063,0.425,0.501), vec3(0.128296,0.211338,0.726810));\n\tplot(uv, col, vec4(0.214,0.048,0.088,0.784), vec3(0.151868,0.125460,0.275872));\n\tplot(uv, col, vec4(0.211,0.321,0.131,0.801), vec3(0.501242,0.227053,0.517771));\n\tplot(uv, col, vec4(0.198,0.257,0.223,0.756), vec3(0.152252,0.195937,0.187190));\n\tplot(uv, col, vec4(0.069,0.506,0.073,0.798), vec3(0.779849,0.034389,0.242259));\n\tplot(uv, col, vec4(0.900,0.604,0.180,0.129), vec3(0.636194,0.281760,0.335503));\n\tplot(uv, col, vec4(0.603,0.512,0.553,0.296), vec3(0.262838,0.087006,0.887673));\n\tplot(uv, col, vec4(0.876,0.412,0.122,0.123), vec3(0.814936,0.064743,0.194618));\n\tplot(uv, col, vec4(0.575,0.425,0.262,0.759), vec3(0.205036,0.187878,0.410755));\n\tplot(uv, col, vec4(0.631,0.249,0.316,0.426), vec3(0.416948,0.086363,0.735817));\n\tplot(uv, col, vec4(0.162,0.189,0.208,0.489), vec3(0.740889,0.059084,0.756350));\n\tplot(uv, col, vec4(0.232,0.109,0.153,0.397), vec3(0.823937,0.109609,0.293775));\n\tplot(uv, col, vec4(0.405,0.197,0.182,0.865), vec3(0.439292,0.086101,0.262585));\n\tplot(uv, col, vec4(0.200,0.204,0.221,0.555), vec3(0.845579,0.156380,0.513437));\n\tplot(uv, col, vec4(0.327,0.189,0.211,0.612), vec3(0.376358,0.064121,0.697797));\n\tplot(uv, col, vec4(0.194,0.260,0.248,0.786), vec3(0.881498,0.048622,0.688452));\n\tplot(uv, col, vec4(0.426,0.250,0.177,0.857), vec3(0.425343,0.078295,0.281320));\n\tplot(uv, col, vec4(0.655,0.870,0.963,0.051), vec3(0.022341,0.283208,0.668920));\n\tplot(uv, col, vec4(0.913,0.391,0.216,0.122), vec3(0.771055,0.267808,0.435822));\n\tplot(uv, col, vec4(0.221,0.286,0.205,0.591), vec3(0.921418,0.125643,0.501132));\n\tplot(uv, col, vec4(0.426,0.250,0.177,0.857), vec3(0.425308,0.078291,0.281408));\n\tplot(uv, col, vec4(0.161,0.220,0.190,0.799), vec3(0.482913,0.313132,0.525821));\n\tplot(uv, col, vec4(0.117,0.055,0.265,0.670), vec3(0.145483,0.025115,0.416216));\n\tplot(uv, col, vec4(0.152,0.181,0.191,0.812), vec3(0.748530,0.117373,0.538835));\n\tplot(uv, col, vec4(0.151,0.107,0.080,0.889), vec3(0.380843,0.071804,0.344331));\n\tplot(uv, col, vec4(0.223,0.144,0.270,0.480), vec3(0.247399,0.179836,0.611096));\n\tplot(uv, col, vec4(0.212,0.225,0.172,0.856), vec3(0.167935,0.188317,0.118131));\n\tplot(uv, col, vec4(0.373,0.142,0.087,0.867), vec3(0.314322,0.048839,0.148551));\n\tplot(uv, col, vec4(0.162,0.189,0.208,0.489), vec3(0.740874,0.059051,0.756336));\n\tplot(uv, col, vec4(0.109,0.185,0.231,0.836), vec3(0.735798,0.125174,0.557887));\n\tplot(uv, col, vec4(0.567,0.883,0.886,0.047), vec3(0.914317,0.427252,0.840240));\n\tplot(uv, col, vec4(0.232,0.109,0.153,0.397), vec3(0.823604,0.109596,0.293385));\n\tplot(uv, col, vec4(0.694,0.469,0.462,0.816), vec3(0.940626,0.078926,0.894489));\n\tplot(uv, col, vec4(0.390,0.140,0.139,0.417), vec3(0.793882,0.086357,0.386013));\n\tplot(uv, col, vec4(0.133,0.234,0.208,0.786), vec3(0.477869,0.265872,0.501450));\n\tplot(uv, col, vec4(0.325,0.193,0.209,0.598), vec3(0.364199,0.070591,0.699073));\n\tplot(uv, col, vec4(0.154,0.174,0.185,0.817), vec3(0.756646,0.109971,0.541723));\n\tplot(uv, col, vec4(0.213,0.143,0.091,0.856), vec3(0.412434,0.080273,0.295376));\n\tplot(uv, col, vec4(0.691,0.468,0.455,0.826), vec3(0.940490,0.078980,0.898945));\n\tplot(uv, col, vec4(0.108,0.153,0.188,0.845), vec3(0.764595,0.063104,0.562240));\n\tplot(uv, col, vec4(0.131,0.253,0.169,0.806), vec3(0.912397,0.031722,0.682781));\n\tplot(uv, col, vec4(0.914,0.484,0.048,0.071), vec3(0.783528,0.128136,0.304062));\n\tplot(uv, col, vec4(0.572,0.519,0.293,0.669), vec3(0.370354,0.062702,0.316230));\n\tplot(uv, col, vec4(0.184,0.141,0.114,0.862), vec3(0.396568,0.125602,0.358795));\n\tplot(uv, col, vec4(0.185,0.233,0.069,0.629), vec3(0.174706,0.148886,0.354731));\n\tplot(uv, col, vec4(0.111,0.186,0.232,0.834), vec3(0.736189,0.125067,0.556882));\n\tplot(uv, col, vec4(0.043,0.022,0.355,0.446), vec3(0.552515,0.032923,0.817638));\n\tplot(uv, col, vec4(0.226,0.324,0.135,0.790), vec3(0.504651,0.242305,0.528617));\n\tplot(uv, col, vec4(0.035,0.267,0.247,0.234), vec3(0.948458,0.195568,0.491457));\n\tplot(uv, col, vec4(0.795,0.893,0.789,0.090), vec3(0.931548,0.367840,0.796213));\n\tplot(uv, col, vec4(0.560,0.204,0.208,0.539), vec3(0.968510,0.101127,0.137736));\n\tplot(uv, col, vec4(0.452,0.563,0.393,0.352), vec3(0.979655,0.188634,0.827277));\n\tplot(uv, col, vec4(0.213,0.142,0.091,0.856), vec3(0.412447,0.080118,0.295414));\n\tplot(uv, col, vec4(0.241,0.219,0.295,0.474), vec3(0.277662,0.172463,0.565653));\n\tplot(uv, col, vec4(0.823,0.420,0.042,0.047), vec3(0.551249,0.445641,0.497380));\n\tplot(uv, col, vec4(0.131,0.253,0.169,0.806), vec3(0.912565,0.033319,0.681748));\n\tplot(uv, col, vec4(0.564,0.179,0.204,0.559), vec3(0.967675,0.087858,0.100046));\n\tplot(uv, col, vec4(0.933,0.491,0.026,0.063), vec3(0.802754,0.115132,0.299400));\n\tplot(uv, col, vec4(0.925,0.717,0.426,0.625), vec3(0.707325,0.516241,0.804046));\n\tplot(uv, col, vec4(0.959,0.337,0.172,0.112), vec3(0.400818,0.273840,0.401715));\n\tplot(uv, col, vec4(0.728,0.655,0.551,0.493), vec3(0.552926,0.063434,0.291923));\n\tplot(uv, col, vec4(0.107,0.179,0.188,0.743), vec3(0.693835,0.187849,0.546111));\n\tplot(uv, col, vec4(0.150,0.107,0.079,0.890), vec3(0.381024,0.071636,0.344119));\n\tplot(uv, col, vec4(0.926,0.626,0.468,0.490), vec3(0.568434,0.102169,0.495347));\n\tplot(uv, col, vec4(0.242,0.117,0.238,0.529), vec3(0.563880,0.156570,0.479926));\n\tplot(uv, col, vec4(0.457,0.434,0.154,0.338), vec3(0.790951,0.064679,0.804688));\n\tplot(uv, col, vec4(0.874,0.359,0.178,0.595), vec3(0.466879,0.055265,0.756886));\n\tplot(uv, col, vec4(0.728,0.656,0.551,0.493), vec3(0.553049,0.063427,0.291808));\n\tplot(uv, col, vec4(0.150,0.107,0.079,0.890), vec3(0.381164,0.071163,0.344334));\n\tplot(uv, col, vec4(0.126,0.133,0.148,0.878), vec3(0.592599,0.070875,0.400931));\n\tplot(uv, col, vec4(0.262,0.320,0.247,0.611), vec3(0.916237,0.156377,0.507270));\n\tplot(uv, col, vec4(0.109,0.185,0.231,0.836), vec3(0.736206,0.125144,0.557410));\n\tplot(uv, col, vec4(0.109,0.226,0.185,0.787), vec3(0.490985,0.242492,0.517117));\n\tplot(uv, col, vec4(0.093,0.188,0.132,0.608), vec3(0.615801,0.094113,0.412379));\n\tplot(uv, col, vec4(0.168,0.132,0.151,0.812), vec3(0.368493,0.133032,0.410780));\n\tplot(uv, col, vec4(0.168,0.132,0.151,0.812), vec3(0.368534,0.133133,0.410804));\n\tplot(uv, col, vec4(0.018,0.280,0.271,0.242), vec3(0.975650,0.165347,0.517531));\n\tplot(uv, col, vec4(0.904,0.404,0.074,0.092), vec3(0.837936,0.044944,0.203312));\n\tplot(uv, col, vec4(0.432,0.248,0.177,0.858), vec3(0.431667,0.086091,0.286237));\n\tplot(uv, col, vec4(0.201,0.187,0.172,0.784), vec3(0.936062,0.021414,0.758847));\n\tplot(uv, col, vec4(0.121,0.132,0.141,0.871), vec3(0.592336,0.117298,0.400937));\n\tplot(uv, col, vec4(0.705,0.731,0.455,0.251), vec3(0.384447,0.024765,0.313092));\n\tplot(uv, col, vec4(0.118,0.258,0.122,0.627), vec3(0.221205,0.048441,0.608698));\n\tplot(uv, col, vec4(0.692,0.884,0.937,0.951), vec3(0.576289,0.086168,0.431304));\n\tplot(uv, col, vec4(0.334,0.093,0.156,0.423), vec3(0.702052,0.066011,0.273273));\n\tplot(uv, col, vec4(0.133,0.163,0.145,0.514), vec3(0.462248,0.218936,0.460210));\n\tplot(uv, col, vec4(0.919,0.606,0.457,0.494), vec3(0.552808,0.141122,0.477015));\n\tplot(uv, col, vec4(0.093,0.188,0.132,0.608), vec3(0.615726,0.093954,0.412422));\n\tplot(uv, col, vec4(0.124,0.162,0.240,0.617), vec3(0.357265,0.118122,0.494946));\n\tplot(uv, col, vec4(0.236,0.130,0.226,0.496), vec3(0.190825,0.070540,0.613192));\n\tplot(uv, col, vec4(0.223,0.126,0.229,0.496), vec3(0.190128,0.056721,0.617188));\n\tplot(uv, col, vec4(0.223,0.302,0.213,0.336), vec3(0.936984,0.196319,0.253078));\n\tplot(uv, col, vec4(0.422,0.183,0.193,0.718), vec3(0.504627,0.156405,0.532834));\n\tplot(uv, col, vec4(0.911,0.639,0.502,0.407), vec3(0.626760,0.094170,0.497557));\n\tplot(uv, col, vec4(0.315,0.258,0.251,0.622), vec3(0.254097,0.086390,0.524072));\n\n\tfragColor = vec4(col.rgb,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3RW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tV3WD", "name": "Pool Like Template", "author": "Imsure1200q_1UWE130", "description": "asfdasdfasdfa", "tags": ["template"], "likes": 0, "viewed": 391, "date": "1474711995", "time_retrieved": "2024-06-20T18:41:11.131984", "image_code": "//Random Number\nfloat rand(vec2 co){\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n//Noise\nfloat noise(float p){\n    float fl = floor(p);\n  float fc = fract(p);\n    return float(mix(rand(vec2(fl)), rand(vec2(fl + 1.0)), fc));\n}\n//Noise 2\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n//Central Development Of Shader (CDS)        -|• |\n//Shader Central Processing Function (SCPF)  -|• v\n//Xylem of Mental Target of Shader (XMTS)    -|•\n//                                            \\-/\n// /-------------------------------------------/\n// v\nfloat xmts(vec2 u, vec4 gram, float t, vec3 x, float a)\n{\n    //Increase Activity Level For Better Performance\n    a *= 3.0;\n    //Increase Limit Of Activity Steps For Bigger And Cleaner Scene\n    t += length(a);\n    //Make Rhombuses\n    //Corner 1\n    if(vec4(u, u) == vec4(gram.xz,gram.xz)){\n        gram.yw += u;}\n    //Corner 2\n    else if(vec4(u, u) == vec4(gram.yw,gram.yw)){\n        gram.xz += u;}\n    //Corner 3\n    else if(vec4(u, u) == vec4(gram.xz,gram.xz)){\n        gram.yw -= u;}\n    //Corner 4\n    else if(vec4(u, u) == vec4(gram.yw,gram.yw)){\n        gram.xz -= u;}\n    //Make Good Noise to make background realistic and rough (glass with rain)\n    float q =mix(mix(rand(u + vec2(0.0, 0.0)),\n                     rand(u + vec2(0.0, 1.0)), u.y),\n                 mix(rand(u + vec2(1.0, 0.0)),\n                     rand(u + vec2(1.0, 1.0)), u.y),u.x);\n    //Prepare for locating scene\n    x += length(q)*a+0.1;\n    //if this --------------\\ is increased, The Background Will Become Smoother, Depends On How You\n    //Increase It.          v\n    for(float i = 0.0; i < 0.1; i++)//Recommended: 40.013\n    {\n        //Prepare to Shape The Grid Using Gram\n        vec3 p = x * 0.5 + normalize(vec3(u, 1.0)) + gram.xyz;\n        //Use a raytracing technique\n        float d = length(p) - 1.0;\n        //something\n        t += d * 0.5;\n    }\n    //Add fog\n    float fog = 1.0/(1.0+t*t*0.1);\n    //Result fog\n    return fog;\n    \n}\n//Get Gram Color For Pool Effect\nvec4 getGramColor(vec2 u, float i)\n{\n    return vec4(length(u*2.0-1.0)-i);\n}\n//Get Frame \nvec3 getFrame(vec2 u, float i, vec3 rd)\n{\n    vec2 p = floor(u);\n    vec2 f = fract(u);\n    vec2 q = f*f*(-1.0+2.0*p-rd.xy);\n    return length(q) + rd * i;\n}\n//Get Limit And Activity\nvec2 getLimit_Activity(float k, float s, vec2 u)\n{\n    float x = max(k-min(u.x,u.y),s-min(u.x,u.y));\n    float ox = (u.x+u.y)-(u.y+u.x);\n    return vec2(x, ox)+vec2(k, s);\n}\n//Obvious. Just an UltraViolet Ray.\nvec2 getUv(vec2 u)\n{\n    return u+(max(u.x+u.y,u.y+u.x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0-  1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 u = getUv(uv);\n    vec2 lax = getLimit_Activity(noise(u), noise(u + u.x), u);\n    vec3 x = getFrame(u, length(sqrt(u)), normalize(vec3(u, 1.0)));\n    vec4 gram = getGramColor(u, max(lax.x,lax.y));\n    float col = xmts(u/noise(u), gram, lax.x, x, lax.y);\n\tfragColor = vec4(col+noise(lax+iTime))*length(uv)+vec4(-0.025,0.025,0.6,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3WD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tV3zW", "name": "Fun With Julia Sets Part 1", "author": "Julia_Sets", "description": "So I had some fun with Julia sets.", "tags": ["julia", "set"], "likes": 0, "viewed": 74, "date": "1473546942", "time_retrieved": "2024-06-20T18:41:11.343914", "image_code": "// (a + bi)^2 = a^2 - b^2 + 2abi\nvec2 squareComplexNumber(vec2 complexNumber) {\n    float realComponentOfProduct = (complexNumber.x * complexNumber.x) - (complexNumber.y * complexNumber.y);\n    float imaginaryComponentOfProduct = 2.0 * complexNumber.x * complexNumber.y;\n    return vec2(realComponentOfProduct, imaginaryComponentOfProduct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 rainbow[7];\n    rainbow[0] = vec4(1.0, 0.0, 0.0, 1.0); // Red\n    rainbow[1] = vec4(1.0, 0.5, 0.0, 1.0); // Orange\n    rainbow[2] = vec4(1.0, 1.0, 0.0, 1.0); // Yellow\n    rainbow[3] = vec4(0.0, 1.0, 0.0, 1.0); // Green\n    rainbow[4] = vec4(0.0, 0.0, 1.0, 1.0); // Blue\n    rainbow[5] = vec4(0.294117647, 0.0, 0.509803922, 1.0); // Indigo (according to Wikipedia)\n    rainbow[6] = vec4(0.5, 0.0, 1.0, 1.0); // Violet (according to Wikipedia)\n    \n\tfloat zoom = 2.0;\n    vec2 c = vec2(sin(iTime), sin(iTime * 2.0));\n    //vec2 c = vec2(-1.0, 0.0);\n    \n    vec2 z = fragCoord.xy / iResolution.xy;\n    z = z * vec2(zoom * 2.0);\n    z = z - vec2(zoom);\n    \n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    for (int i = 0; i < 14; i++) {\n        z = squareComplexNumber(z) + c;\n        \n    \tif (abs(z.x) < 2.0 && abs(z.y) < 2.0) {\n            fragColor = rainbow[i / 2];\n    \t}\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3zW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tVGWw", "name": "Faster Galaxies", "author": "vox", "description": "Faster Galaxies", "tags": ["fastergalaxies"], "likes": 1, "viewed": 456, "date": "1474937035", "time_retrieved": "2024-06-20T18:41:12.356144", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0/GR/PI/E)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+stretch*2.0*PI;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5*2.0*PI;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n    \n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    return final;\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n    }\n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv0, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        \n        antispeckle *= stretch;\n\n        float draw = border*(1.0-color.a);\n\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        \n        color += clamp( galaxy((p.xy)*2.0-1.0)*draw*border, 0.0, 1.0);//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n\n    \n    \tfragColor = vec4(color);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tVGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ty3RW", "name": "Wave mixer", "author": "rush_2112", "description": "Wave mixer", "tags": ["wave2d"], "likes": 0, "viewed": 81, "date": "1473353684", "time_retrieved": "2024-06-20T18:41:12.356144", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t    \n\tfloat ca = 0.04;\n\tfloat cb = 0.101;\n\tfloat gt = iTime;\n    float gtc = 2.0 + (30.0 * sin(gt * 0.125));\n\t\n\tfloat algo = 0.0;\n    \n\talgo += (1.32 * ca) * ceil(((1.0-uv.x) * 0.50 * gtc)*((1.0-uv.y) * 0.271 * gtc) * 21.00 * cb);\n    algo -= (1.32 * ca) * ceil(((uv.x) * 0.50 * gtc)*((uv.y) * 0.271 * gtc) * 21.00 * cb);\n        \n\tfragColor = vec4(algo*0.1, algo*0.1, algo*0.9, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ty3RW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ty3WW", "name": "Another IFS", "author": "vox", "description": "Another IFS", "tags": ["anotherifs"], "likes": 16, "viewed": 4275, "date": "1474536174", "time_retrieved": "2024-06-20T18:41:12.877561", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))*GR/2.0/PI+GR/PI)*iTime+100.0)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\tvec3 eye = vec3(cos(iTime), sin(iTime*.5), sin(iTime))*2.0;\n    vec3 look = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 foward = normalize(look-eye);\n    vec3 right = normalize(cross(foward, up));\n    up = normalize(cross(right, foward));\n    vec3 ray = normalize(foward+uv.x*right+uv.y*up);\n    \n \tconst float outerCount = 8.0;\n \tconst float innerCount = 8.0;\n        \n    float map = 0.0;\n    float sum = 0.0;\n    \n    for(float i = 0.0; i < outerCount; i+=1.0)\n    {\n        float theta1 = i/outerCount*2.0*PI;\n        \n        for(float j = 0.0; j < innerCount; j+=1.0)\n        {\n            float theta2 = theta1+j/innerCount*PI*2.0;\n\n            \n            float omega1 = theta1;\n            float omega2 = theta2+time*sign(cos(i*PI));\n            \n            \n       \t \tvec3 p1 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2));\n                           \n       \t \tvec3 p2 = vec3(cos(omega1)*sin(omega2+PI/8.0),\n                           sin(omega1)*sin(omega2+PI/8.0),\n                           cos(omega2+PI/8.0));\n            \n            vec3 ray2 = normalize(p2-p1);\n            \n            float a = dot(ray,ray);\n            float b = dot(ray,ray2);\n            float c = dot(ray2,ray2);\n            float d = dot(ray,eye-p1);\n            float e = dot(eye-p1,ray2);\n            \n            float t1 = (b*e-c*d)/(a*c-b*b);\n            float t2 = (a*e-b*d)/(a*c-b*b);\n            \n            float dist = length((eye+ray*t1)-(p1+ray2*t2));\n            \n            float lineWidth = 50.0/max(iResolution.x, iResolution.y);\n            \n            float lineLength = 2.5+.5*sin(time);\n            \n            float isFoward = (sign(t1)*.5+.5);\n            \n            \n            \n                float sides = (1.0-smoothstep(0.0, lineWidth, dist));\n                float ends = (1.0-smoothstep(0.0, lineLength, abs(t2)));\n                float line = sides*ends*isFoward;\n                \n                map += (1.-map)*line;\n                sum += 1.0*line*isFoward;\n        }\n    }\n    \n\tfragColor = vec4(flux(PI*map/sum+time)*clamp(map, 0.0, 1.0), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ty3WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldsGDl", "name": "Line Test", "author": "kimau", "description": "Working on a test", "tags": ["line", "wip"], "likes": 0, "viewed": 77, "date": "1475094916", "time_retrieved": "2024-06-20T18:41:12.877561", "image_code": "float distToLine(vec2 a, vec2 b, vec2 p)\n{\n\tvec2 topA = p - a;\n\tvec2 topB = b - a;\n\tfloat t = dot(topA, topB ) / (topB.x*topB.x + topB.y*topB.y);\n\tvec2 np = a + t * topB;\n\t\n\treturn length(np - p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 p1 = vec4(1,0,\n\t\t\t\t   0, iResolution.y * 0.5);\n\t\t\t\t   //(cos(iTime*1.3)*0.5+0.5)*iResolution.y);\n\tvec4 p2 = vec4(1,0,\n\t\t\t\t   iResolution.x, iResolution.y * 0.5);\n\t\t\t\t   //(sin(iTime)*0.5+0.5)*iResolution.y);\n\n\t\n\t// RandomTans\n\tp1.xy = vec2(1.0,sin(iTime) * 6.0);\n\tp2.xy = vec2(1.0,cos(iTime*1.4+3.2));\n\tp1.xy = p1.xy / p1.x * iResolution.x;\n\tp2.xy = p2.xy / p2.x * iResolution.x;\n\t\n\tvec2 a,b,c,d;\n\tvec2 ln = p2.zw - p1.zw;\n\t\n\tif(dot(ln,p1.xy) > 0.0)\n\t{ // AB\n\t\ta = p1.zw - p1.xy;\n\t\tb = p1.zw;\n\t\tc = p2.zw;\n\t\td = p2.zw + p2.xy;\n\t}\n\telse\n\t{\t// BA\n\t\td = p1.zw + p1.xy;\n\t\tc = p1.zw;\n\t\tb = p2.zw;\n\t\ta = p2.zw - p2.xy;\n\t}\n\t\n\tfloat t = fragCoord.x / iResolution.x;\n\tvec2 p = 0.5 *((2.0*b) + \n\t\t\t\t   (-a+c)*t + \n\t\t\t\t   (2.0*a-5.0*b+4.0*c-d)*t*t + \n\t\t\t\t   (-a+3.0*b-3.0*c+d)*t*t*t );\n\t\n\tfloat dist = length(p - fragCoord.xy) * 0.01;\n\t\n\tfragColor = vec4(1.0);\n\tfragColor.rgb = vec3(1.0 - dist);\n    fragColor.r = dFdx(fragColor.g)*100.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsGDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll3GRM", "name": "Rounded Voronoi Borders", "author": "Shane", "description": "Just playing around with one of the many interesting snippets that Fabrice Neyret has magically managed to conjure up. :)", "tags": ["voronoi", "bump", "cell", "border", "trabeculae"], "likes": 131, "viewed": 4971, "date": "1472884796", "time_retrieved": "2024-06-20T18:41:13.738052", "image_code": "/*\n\tRounded Voronoi Borders\n\t-----------------------\n\n\tFabrice came up with an interesting formula to produce more evenly distributed Voronoi values. \n\tI'm sure there are more interesting ways to use it, but I like the fact that it facilitates \n\tthe creation of more rounded looking borders. I'm sure there are more sophisticated ways to \n\tproduce more accurate borders, but Fabrice's version is simple and elegant.\n\n\tThe process is explained below. The link to the original is below also.\n\n\tI didn't want to cloud the example with too much window dressing, so just for fun, I tried \n\tto pretty it up by using as little code as possible.\n\n\t// 2D version\n\t2D trabeculum - FabriceNeyret2\n\thttps://www.shadertoy.com/view/4dKSDV\n\n\t// 3D version\n\thypertexture - trabeculum - FabriceNeyret2\n\thttps://www.shadertoy.com/view/ltj3Dc\n\n\t// Straight borders - accurate geometric solution.\n\tVoronoi - distances - iq\n\thttps://www.shadertoy.com/view/ldl3W8\n\n*/\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as other combinations. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n)*.75 + .25; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    return sin( p*6.2831853 + iTime )*.35 + .65; \n    \n}\n\n// IQ's polynomial-based smooth minimum function.\nfloat smin( float a, float b, float k ){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// 2D 3rd-order Voronoi: This is just a rehash of Fabrice Neyret's version, which is in\n// turn based on IQ's original. I've simplified it slightly, and tidied up the \"if-statements,\"\n// but the clever bit at the end came from Fabrice.\n//\n// Using a bit of science and art, Fabrice came up with the following formula to produce a more \n// rounded, evenly distributed, cellular value:\n\n// d1, d2, d3 - First, second and third closest points (nodes).\n// val = 1./(1./(d2 - d1) + 1./(d3 - d1));\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); // 1.4, etc.\n    \n    float r = 0.;\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\tr = dot(o, o);\n            \n            // 1st, 2nd and 3rd nearest squared distances.\n            d.z = max(d.x, max(d.y, min(d.z, r))); // 3rd.\n            d.y = max(d.x, min(d.y, r)); // 2nd.\n            d.x = min(d.x, r); // Closest.\n                       \n\t\t}\n\t}\n    \n\td = sqrt(d); // Squared distance to distance.\n    \n    // Fabrice's formula.\n    return min(2./(1./max(d.y - d.x, .001) + 1./max(d.z - d.x, .001)), 1.);\n    // Dr2's variation - See \"Voronoi Of The Week\": https://www.shadertoy.com/view/lsjBz1\n    //return min(smin(d.z, d.y, .2) - d.x, 1.);\n    \n}\n\nvec2 hMap(vec2 uv){\n    \n    // Plain Voronoi value. We're saving it and returning it to use when coloring.\n    // It's a little less tidy, but saves the need for recalculation later.\n    float h = Voronoi(uv*6.);\n    \n    // Adding some bordering and returning the result as the height map value.\n    float c = smoothstep(0., fwidth(h)*2., h - .09)*h;\n    c += (1.-smoothstep(0., fwidth(h)*3., h - .22))*c*.5; \n    \n    // Returning the rounded border Voronoi, and the straight Voronoi values.\n    return vec2(c, h);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Moving screen coordinates.\n\tvec2 uv = fragCoord/iResolution.y + vec2(-.2, .05)*iTime;\n    \n    // Obtain the height map (rounded Voronoi border) value, then another nearby. \n    vec2 c = hMap(uv);\n    vec2 c2 = hMap(uv + .004);\n    \n    // Take a factored difference of the values above to obtain a very, very basic gradient value.\n    // Ie. - a measurement of the bumpiness, or bump value.\n    float b = max(c2.x - c.x, 0.)*16.;\n    \n    // Use the height map value to produce some color. It's all made up on the spot, so don't pay it\n    // too much attention.\n    //\n    vec3 col = vec3(1, .05, .25)*c.x; // Red base.\n    float sv = Voronoi(uv*16. + c.y)*.66 + (1.-Voronoi(uv*48. + c.y*2.))*.34; // Finer overlay pattern.\n    col = col*.85 + vec3(1, .7, .5)*sv*sqrt(sv)*.3; // Mix in a little of the overlay.\n    col += (1. - col)*(1.-smoothstep(0., fwidth(c.y)*3., c.y - .22))*c.x; // Highlighting the border.\n    col *= col; // Ramping up the contrast, simply because the deeper color seems to look better.\n    \n    // Taking a pattern sample a little off to the right, ramping it up, then combining a bit of it\n    // with the color above. The result is the flecks of yellowy orange that you see. There's no physics\n    // behind it, but the offset tricks your eyes into believing something's happening. :)\n    sv = col.x*Voronoi(uv*6. + .5);\n    col += vec3(.7, 1, .3)*pow(sv, 4.)*8.;\n    \n    // Apply the bump - or a powered variation of it - to the color for a bit of highlighting.\n    col += vec3(.5, .7, 1)*(b*b*.5 + b*b*b*b*.5);\n\t \n    \n    // Basic gamma correction\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3GRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llcGDS", "name": "Collatz", "author": "iq", "description": "The visuals for the third part of my video \"Collatz and Self Similarity\": [url]https://www.youtube.com/watch?v=GJDz4kQqTV4[/url] (minus the text overlays, which cannot do in the online version of Shadertoy cause we don't support custom textures)", "tags": ["2d", "fractal", "mathematics", "maths", "collatzconjecture", "collatz"], "likes": 30, "viewed": 2564, "date": "1473885630", "time_retrieved": "2024-06-20T18:41:15.465481", "image_code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// The visuals for the last part of \"Collatz and Self Similarity\": \n//\n// https://www.youtube.com/watch?v=GJDz4kQqTV4\n\n\n//------------------------------------------------------\n// global\n//------------------------------------------------------\n\n#define AA 3 // supersampling level. Make higher for more quality.\n\nconst float pi = 3.1415926535897932384626433832795; // should be pronounced \"pee\" not \"pie\", dear english speakers!\n\n//------------------------------------------------------\n// complex numbers\n//------------------------------------------------------\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cmulj( vec2 z ) { return vec2(-z.y,z.x); }\nvec3 cexp( vec2 z ) { return vec3( exp(z.x), vec2( cos(z.y), sin(z.y) ) ); }\nvec3 cexpj( vec2 z ) { return vec3( exp(-z.y), vec2( cos(z.x), sin(z.x) ) ); }\n\n//------------------------------------------------------\n// signed distance functions\n//------------------------------------------------------\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCurveb( in vec2 p, vec2 k0, vec2 k1, vec2 k2, float h)\n{\n    h = smoothstep(0.0,0.8,h);\n    vec2 c = k0;\n    vec2 b = (4.0*k1 - k2 - 3.0*k0);\n    vec2 a = 2.0*k0 - 4.0*k1 + 2.0*k2;\n    float res = length(p-k0);\n    for( int i=0; i<50; i++ )\n    {\n        float t1 = float(i+0)/50.0;\n        float t2 = float(i+1)/50.0;\n        if( t1>=h ) break;\n        t2 = min(t2,h);\n        \n        vec2 p1 = a*t1*t1 + b*t1 + c;\n        vec2 p2 = a*t2*t2 + b*t2 + c;\n        \n        res = min( res, sdSegment( p, p1, p2 ) );\n    }\n    \n    return res;    \n}\n\n//------------------------------------------------------\n// Visualization\n//------------------------------------------------------\n\nconst vec2 fp4 = vec2(-4.001318,0.1870178);\nconst vec2 fp3 = vec2(-2.008426,0.2190410);\nconst vec2 fp2 = vec2(-0.5185009860894,0.124974296258);\nconst vec2 fp1 = vec2( 0.0);\nconst vec2 fp5 = vec2( 1.9982895,0.1291284);\n\nvec3 render( in vec2 fragCoord, float time )\n{\n    float sc = 4.5;\n    vec2 ce = vec2(0.0,0.0);    \n\n    if( time>0.0 )\n    {\n        sc = 4.5 * pow( 0.9, 0.2*time );\n    }\n    if( time>43.0 )\n    {\n        sc = 4.5 * pow( 0.9, 0.2*time ) * pow( 0.9, 88.0*smoothstep( 43.0, 60.0, time ) );\n    }\n    if( time>60.0 )\n    {\n        float f = smoothstep( 60.0, 75.0, time );\n    \tsc = mix( sc, 2.5, 1.0-exp(-0.001*pow(time-60.0,3.0)) );\n    \tce = mix( ce, vec2(3.0,0.0), pow(smoothstep(60.0,75.0,time), 3.0 ) );\n    }\n    if( time>75.0 )\n    {\n        sc = mix( sc, 3.5 * pow( 0.9, 6.3*smin(time-75.0,15.0,5.0) ), smoothstep(75.0,80.0,time) );\n    }\n    if( time>96.0 )\n    {\n\tfloat f = smin(time-96.0,5.0,0.5)/5.0;\n        sc = mix( sc, 2.5, pow( f, 6.0 ) );\n        sc = mix( sc, 2.5/pow(0.9, 0.08*smin(time-100.0,35.0,2.0) ), smoothstep(100.0,103.0,time) );\n    }\n    if( time>157.5 )\n    {\n        sc = mix( sc, 2.5*pow(0.9, 1.4*smin(time-157.5,5.5,0.5) ), pow(smoothstep(157.5,162.5,time),2.0) );\n    }\n    if( time>187.0 )\n    {\n        sc = mix( sc, sc*pow(0.9, 8.2*smin(time-187.5,5.5,0.5) ), pow(smoothstep(187.0,192.5,time),2.0) );\n    }\n    if( time>212.0 )\n    {\n        sc = mix( sc, sc*pow(0.9, 2.4*smin(time-212.0,6.0,0.2) ), pow(smoothstep(212.0,218.0,time),2.0) );\n    }\n\n\n    if( time>268.0 )\n    {\n        sc = mix( sc, sc/pow(0.9, 3.5*smin(time-268.0,19.0,0.2) ), pow(smoothstep(268.0,268.0+19.0,time),2.0) );\n    }\n\n    vec2 p = ce + sc*(-iResolution.xy+2.0*fragCoord) / iResolution.x;\n    float e = sc*2.0/iResolution.x;\n    \n    vec2 z = p;\n    \n    const float th = 10000000000.0;\n    \n    vec2 lz = z;\n    float d = 0.0;\n    float f = 0.0;\n    float rmin = th;\n    vec2 dz = vec2(1.0,0.0);\n    vec2 ldz = dz;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 k = cexpj( pi*z );\n        \n        lz = z;\n        ldz = dz;\n\n        dz = cmul( (vec2(7.0,0.0) - k.x*cmul(k.yz,vec2(5.0-5.0*pi*z.y, pi*(5.0*z.x+2.0))))/4.0, dz );\n        \n        z = ( cadd(7.0*z,2.0) - k.x*cmul(k.yz,cadd(5.0*z,2.0)) )/4.0;\n\n        float r = length(z);\n        rmin = min( rmin, r );\n        if( r>th ) { d=1.0; break; }\n        f += 1.0;\n    }\n    \n    vec3 col = vec3(0.0);\n    if( d<0.5 )\n    {\n        col = vec3(0.0,0.0,0.0);\n    }\n    else if( d<1.5 )\n    {\n        col = vec3(1.0,0.6,0.2);\n        \n        f += clamp( log(th/length(lz))*1.8, 0.0, 1.0 ) - 1.0;\n        col = 0.5 + 0.5*cos(0.15*f + 1.5 + vec3(0.2,0.9,1.0));\n        col *= 0.027*f;\n        \n        float dis = log(length(lz))*length(lz)/length(ldz);\n        col += 0.025*sqrt(dis/sc) - 0.1;\n        col *= 1.1;\n    }\n    else //if( d<0.5 )\n    {\n        col = vec3(1.0,1.0,0.0);\n    }\n    \n    // anchor\n    #if 1\n    float ra = 1.0*sqrt(abs(p.x))/5.0;\n    col = mix( col, vec3(1.0,1.0,0.0), (1.0 - smoothstep( ra, ra+0.01, rmin ))*smoothstep(100.0,103.0,time)*(1.0-smoothstep(268.0,273.0,time )) );\n    #endif\n\n    // fixed point\n    #if 1\n    {\n    float show = smoothstep( 21.0, 22.0, time ) - smoothstep( 32.0, 33.0, time );\n    col = mix( col, vec3(1.0,0.9,0.4), show*(1.0 - smoothstep( sc*0.002, sc*0.004, abs(length(p-fp1)-0.03*sc) )) );\n    col = mix( col, vec3(1.0,0.9,0.4), show*(1.0 - smoothstep( sc*0.002, sc*0.004, abs(length(p-fp2)-0.03*sc) )) );\n    col = mix( col, vec3(1.0,0.9,0.4), show*(1.0 - smoothstep( sc*0.002, sc*0.004, abs(length(p-fp3)-0.03*sc) )) );\n    col = mix( col, vec3(1.0,0.9,0.4), show*(1.0 - smoothstep( sc*0.002, sc*0.004, abs(length(p-fp4)-0.03*sc) )) );\n    col = mix( col, vec3(1.0,0.9,0.4), show*(1.0 - smoothstep( sc*0.002, sc*0.004, abs(length(p-fp5)-0.03*sc) )) );\n    }\n    #endif\n\n    // integers\n    #if 1\n    {\n    float show = smoothstep( 16.0, 17.0, time ) - smoothstep( 19.0, 20.0, time );\n    if( abs(p.y)<0.5 )\n    {\n    float f = length( fract(p+0.5) - 0.5 );\n    col = mix( col, vec3(1.0,1.0,0.0), (1.0 - smoothstep( sc*0.002, sc*0.004, abs(f-0.03*sc) ))*show );\n    }\n    }\n    #endif\n\n    // first preimages of 0\n    #if 0\n    {\n    vec2 z = p;\n    vec3 k = cexpj( pi*z );\n    vec2 dz = cdiv( cadd(7.0*z,2.0) , cadd(5.0*z,2.0) ) - k.x*k.yz;\n    float f = length(dz);\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.15,0.2,f) );\n    }\n    #endif\n    \n    col = clamp( col, 0.0, 1.0 );\n    \n    // axis\n    #if 1\n    float show = 1.0 - smoothstep(268.0,273.0,time );\n    float g  = smoothstep( 0.0, 1.0*e, abs( fract(p.y+0.5)-0.5 ) );\n          g *= smoothstep( 0.0, 1.0*e, abs( fract(p.x+0.5)-0.5) );\n    col = mix( col, vec3(0.0,0.0,0.0), (1.0-g)*show );\n\n          g  = smoothstep( 0.5*e, 2.0*e, abs(p.y) );\n          g *= smoothstep( 0.5*e, 2.0*e, abs(p.x) );\n    col = mix( col, vec3(0.0,0.0,0.0), (1.0-g)*show );\n   \n    #endif\n\n    // zoom point\n    #if 1\n    {\n    float show = smoothstep(142.0,143.0,time ) - smoothstep(268.0,273.0,time );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0-smoothstep( 17.0*e, 18.0*e, length(p - ce)))*show );\n    }\n    #endif\n\n    // fingers\n    #if 1\n    {\n    float d1 = sdSegment( p, vec2(0.4,-2.0), vec2(-0.0,1.0) );\n    float d2 = sdSegment( p, vec2(1.32,-2.0), vec2(0.95,1.0) );\n    float d3 = sdSegment( p, vec2(2.2,-2.0), vec2(1.9,1.0) );\n    float d4 = sdSegment( p, vec2(3.2,-2.0), vec2(2.9,1.0) );\n    float ct = smoothstep( 156.0, 158.0, time );\n    col = mix( col, vec3(1.0,1.0,0.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d1 ))*(smoothstep(150.0,151.0,time)-ct) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d2 ))*(smoothstep(151.0,152.0,time)-ct) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d3 ))*(smoothstep(152.0,153.0,time)-ct) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d4 ))*(smoothstep(153.0,154.0,time)-ct) );\n    }\n    #endif\n\n    // fingers2\n    #if 1\n    {\n    float show = smoothstep( 172.5, 173.0, time ) - smoothstep( 185.0, 187.0, time );\n\n    float f0 = smoothstep(173.0,174.5,time);\n    float f1 = smoothstep(174.9,175.4,time);\n    float f2 = smoothstep(175.3,175.8,time);\n    float f3 = smoothstep(175.7,176.2,time);\n    float f4 = smoothstep(176.8,177.3,time);\n    float f5 = smoothstep(177.1,177.6,time);\n    float f6 = smoothstep(177.4,177.9,time);\n    float f7 = smoothstep(178.0,178.5,time);\n    float f8 = smoothstep(178.3,178.8,time);\n    float f9 = smoothstep(178.6,179.1,time);\n    float f10 = smoothstep(179.1,179.6,time);\n\n    float d0 = sdCurveb( p, vec2(2.28,-0.17), vec2(2.12,-0.08), vec2(1.92,-0.08), f0 );\n    float d1 = sdCurveb( p, vec2(2.32,-0.14), vec2(2.12,-0.01), vec2(1.92,0.05), f1 );\n    float d2 = sdCurveb( p, vec2(2.36,-0.10), vec2(2.20,0.05), vec2(1.95,0.15), f2 );\n    float d3 = sdCurveb( p, vec2(2.41,-0.08), vec2(2.20,0.22), vec2(2.0,0.35), f3 );\n    float d4 = sdCurveb( p, vec2(2.46,-0.05), vec2(2.37,0.22), vec2(2.2,0.5), f4 );\n    float d5 = sdCurveb( p, vec2(2.53,-0.04), vec2(2.50,0.30), vec2(2.5,0.6), f5 );\n    float d6 = sdCurveb( p, vec2(2.59,-0.04), vec2(2.65,0.30), vec2(2.76,0.55), f6 );\n    float d7 = sdCurveb( p, vec2(2.65,-0.05), vec2(2.81,0.25), vec2(3.1,0.5), f7 );\n    float d8 = sdCurveb( p, vec2(2.70,-0.06), vec2(2.84,0.12), vec2(3.0,0.25), f8 );\n    float d9 = sdCurveb( p, vec2(2.76,-0.09), vec2(2.93,0.06), vec2(3.1,0.12), f9 );\n    float d10 = sdCurveb( p, vec2(2.8,-0.12), vec2(2.95,-0.01), vec2(3.1,0.02), f10 );\n\n    col = mix( col, vec3(1.0,1.0,0.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d0 ))*show*step(0.0001,f0) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d1 ))*show*step(0.0001,f1) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d2 ))*show*step(0.0001,f2) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d3 ))*show*step(0.0001,f3) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d4 ))*show*step(0.0001,f4) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d5 ))*show*step(0.0001,f5) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d6 ))*show*step(0.0001,f6) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d7 ))*show*step(0.0001,f7) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d8 ))*show*step(0.0001,f8) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d9 ))*show*step(0.0001,f9) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d10 ))*show*step(0.0001,f10) );\n    }\n    #endif\n\n    // fingers3\n    #if 1\n    {\n    float show = smoothstep( 197.5, 198.0, time ) - smoothstep( 210.0, 212.0, time );\n\n    float f0 = smoothstep(198.0,198.5,time);\n    float f1 = smoothstep(202.2,202.7,time);\n    float f2 = smoothstep(202.6,203.1,time);\n    float f3 = smoothstep(203.0,203.5,time);\n    float f4 = smoothstep(203.9,204.4,time);\n    float f5 = smoothstep(204.5,205.0,time);\n\n    float d0 = sdCurveb( p, vec2(2.9936,-0.004), vec2(2.9926,-0.001), vec2(2.9915,0.0005), f0 );\n    float d1 = sdCurveb( p, vec2(2.9948,-0.004), vec2(2.994,-0.001), vec2(2.993,0.001), f1 );\n    float d2 = sdCurveb( p, vec2(2.9959,-0.003), vec2(2.9953,-0.001), vec2(2.9941,0.0015), f2 );\n    float d3 = sdCurveb( p, vec2(2.9973,-0.0027), vec2(2.9967,0.0), vec2(2.996,0.002), f3 );\n    float d4 = sdCurveb( p, vec2(2.9988,-0.0024), vec2(2.9983,0.0), vec2(2.9975,0.0028), f4 );\n    float d5 = sdCurveb( p, vec2(3.00045,-0.0021), vec2(3.00005,0.0), vec2(2.9994,0.0031), f5 );\n\n    col = mix( col, vec3(1.0,1.0,0.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d0 ))*show*step(0.0001,f0) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d1 ))*show*step(0.0001,f1) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d2 ))*show*step(0.0001,f2) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d3 ))*show*step(0.0001,f3) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d4 ))*show*step(0.0001,f4) );\n    col = mix( col, vec3(1.0,1.0,1.0), (1.0 - smoothstep( sc*0.005, sc*0.006, d5 ))*show*step(0.0001,f5) );\n    }\n    #endif\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    int ZERO = min(iFrame,0);\n    \n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 px = fragCoord + vec2(float(m),float(n))/float(AA);\n    \tcol += render( px, iTime );    \n    }\n    col /= float(AA*AA);\n#else\n        \n    col = render( fragCoord, iTime );\n#endif            \n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcGDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llG3Dz", "name": "Heat Tunnel", "author": "aiekick", "description": "based on my [url=https://www.shadertoy.com/view/4dVXW1]Heat Bloc[/url]", "tags": ["tunnel", "heat"], "likes": 8, "viewed": 532, "date": "1474133413", "time_retrieved": "2024-06-20T18:41:16.404720", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nvec2 m = vec2(1.2, 0.6);\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.3), sin(t*0.3)) * 2.;\n}\n\n// famous function from shane\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p+dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(5.46,62.8,164.98); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*1000.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y);\n}\n\nvec2 df(vec3 p)\n{\n\tp.xy -= path(p.z);\n\tfloat y = 1.-length(p.xy)+Voronesque(p) * m.x;\n\tvec2 res = vec2(max(-y, y)-m.y, 1);\n    return res;\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// Steel Lattice - https://www.shadertoy.com/view/4tlSWl\nvec3 blackbody(float t)\n{\n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, \n                    -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n   return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\tn = doBumpMap(iChannel0, p, n, s * 0.02);\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvec4 light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.01);\n\tvec3 refl = reflect(rd,n);\n\t\t\n\tvec3 lightdir = normalize(lightpos - p);\n\tfloat lightlen = length(lightpos - p);\n\t\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, lightdir ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, lightdir ), 0.0, 1.0 ),16.);\n        \n\tvec3 brdf = vec3(0);\n\tbrdf += amb * vec3(1,0,0); // color mat\n\tbrdf += diff * 0.6;\n\tbrdf += spe * lc * 0.8;\n\t\n\treturn vec4(brdf, lightlen);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n     \n\tvec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord.xy-si)/si.y;\n    \n\tvec3 col = vec3(0.);\n    \n\tfloat elev = 0.;\n\tfloat ang = t * 0.24;\n\tfloat dist = 4.;\n\tvec3 ro = vec3(path(t),t);\n  \tvec3 cv = vec3(path(t+0.1),t+0.1);\n\tvec3 rd = cam(uv, ro, cv, t);\n     \n\t// first point close to the cam, light for the first plane\n    vec3 lpNear = ro;\n\n\tfloat md = 9.;\n    float s = 1., so = s;\n    float d = 0.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        // from shane shader Maze Lattice https://www.shadertoy.com/view/llGGzh\n        if (abs(s) < 0.005*(d*.25 + 1.)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s * 0.3;\n    }\n    \n\tif (d<md)\n\t{\n\t\t// light close to cam\n\t\tvec4 lightNear = light(ro, rd, d, lpNear, vec3(1));\n\t\tfloat attenNear = 0.35 / lightNear.w; // basic attenuation\n\t\tcol += lightNear.rgb * attenNear;\n\t\t\n        // heat\n        vec3 p = ro + rd * d;\n\t\tfloat sb = 1.-SubDensity(p, 0.2)/0.18;\n\t\tcol += blackbody(900.*sb-600.);\n\t}\n\tfragColor = vec4(col,1);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llG3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llG3RD", "name": "Voxel Towers", "author": "Zanzlanz", "description": "Ported some of my AS3 raytracer! It's great to actually see it run in real-time.\nIt's my first time creating a true shader, which can explain why my code is CPU-minded. ;) Enjoy!\n(I wish GLSL had a call stack for multiple reflection&refraction bounces)", "tags": ["3d", "raycast", "voxel", "raytrace"], "likes": 25, "viewed": 3353, "date": "1473489972", "time_retrieved": "2024-06-20T18:41:17.132339", "image_code": "// Shader by Zanzlanz ;)\n// You can freely use and alter this shader (please give credit of course).\n\nconst float worldSize = 150.0;\nconst float pi = 3.1415926536;\nconst vec3 skyColor = vec3(22.0/255.0, 86.0/255.0, 129.0/255.0);\n\nvec3 cam;\nvec3 camRot;\nfloat tick = 0.0;\n\n// One of my favorite utilities :)\nfloat mod2(float a, float b) {\n\tfloat c = mod(a, b);\n\treturn (c < 0.0) ? c + b : c;\n}\n\n// For coloring blocks, but current not used\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy*.01, vec2(25.5254, -15.5254))) * 52352.323);\n}\n\n// For block heights\nfloat rand(vec2 co){\n\treturn min(rand2(co)+sin(co.x*.1-co.y*.5+tick*.2)*.1+cos(co.y*.3+co.x*.5+tick*.4)*.1,\n               .87+length(vec2(mod2(co.x-cam.x+worldSize*.5, worldSize)-worldSize*.5, mod2(co.y-cam.z+worldSize*.5, worldSize)-worldSize*.5))*.1);\n}\n\nvec3 getFG(vec3 co) {\n    if(co.y/worldSize*3.0 < rand(vec2(co.x, co.z))) {\n        //Uncomment below for randomly colored blocks\n        //return vec3(rand(vec2(co.x+co.y+1., co.z+2.)), rand(vec2(co.x+3., co.z+co.y+4.)), rand(vec2(co.x+co.y+5., co.z+co.y+6.)));\n    \n        return vec3(1.0, 1.0, 1.0);\n    }\n    return vec3(-1, 0, 0);\n}\nvec4 raycast(vec3 start, vec3 castSpeedStart) {\n\tvec3 castSpeed = vec3(castSpeedStart.xyz);\n    float skyAmount = castSpeed.y*.4;\n    \n\tvec4 returnValue = vec4(skyColor*skyAmount, 0.0);\n\tvec3 ray = vec3(start.xyz);\n\t\n    float shadowing = 1.0;\n    vec3 currentCast = vec3(floor(ray));\n    \n    int collideWith = 0;\n\t\n    bool skipLoop = false;\n    for(float its=0.0; its<200.0; its++) {\n        if(skipLoop) {\n            skipLoop = false;\n            continue;\n        }\n\t\tif(currentCast.y<0.0 || currentCast.y>=worldSize*.4) {\n\t\t\treturnValue = vec4(skyColor*skyAmount, 0);\n\t\t\tbreak;\n\t\t}\n        \n\t\tvec3 inBlock = getFG(vec3(mod(currentCast.x, worldSize), mod(currentCast.y, worldSize), mod(currentCast.z, worldSize)));\n\t\tif(inBlock.x != -1.0) {\n            float finalShadowing = clamp(shadowing-length(ray-start)/60.0, 0.0, 1.0);\n            \n            finalShadowing *= mod(.7*(float(collideWith)+5.0), 1.0)*.8+.2;\n            \n            returnValue = vec4(inBlock*finalShadowing+(1.0-finalShadowing)*skyColor*skyAmount, 0.0 );\n            break;\n\t\t} // Here is also where I used to do reflections and fun stuff... recursively though\n        \n        // These last three IFs are checking if the ray passes the next voxel plane\n\t\tif(castSpeed.x != 0.0) {\n\t\t\tfloat t = ( floor(currentCast.x+clamp(sign(castSpeed.x), 0.0, 1.0)) -ray.x)/castSpeed.x;\n\t\t\tvec3 cast1Tmp = ray+castSpeed*t;\n\t\t\tif(cast1Tmp.y>=currentCast.y && cast1Tmp.y<=currentCast.y+1.0 && cast1Tmp.z>=currentCast.z && cast1Tmp.z<=currentCast.z+1.0) {\n\t\t\t\tray = cast1Tmp;\n\t\t\t\tcurrentCast.x += sign(castSpeed.x);\n\t\t\t\tcollideWith = (castSpeed.x>0.0?0:1);\n                skipLoop = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(castSpeed.y != 0.0) {\n\t\t\tfloat t = ( floor(currentCast.y+clamp(sign(castSpeed.y), 0.0, 1.0)) -ray.y)/castSpeed.y;\n\t\t\tvec3 cast1Tmp = ray+castSpeed*t;\n\t\t\tif(cast1Tmp.x>=currentCast.x && cast1Tmp.x<=currentCast.x+1.0 && cast1Tmp.z>=currentCast.z && cast1Tmp.z<=currentCast.z+1.0) {\n\t\t\t\tray = cast1Tmp;\n\t\t\t\tcurrentCast.y += sign(castSpeed.y);\n\t\t\t\tcollideWith = (castSpeed.y>0.0?2:3);\n                skipLoop = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(castSpeed.z != 0.0) {\n\t\t\tfloat t = ( floor(currentCast.z+clamp(sign(castSpeed.z), 0.0, 1.0)) -ray.z)/castSpeed.z;\n\t\t\tvec3 cast1Tmp = ray+castSpeed*t;\n\t\t\tif(cast1Tmp.y>=currentCast.y && cast1Tmp.y<=currentCast.y+1.0 && cast1Tmp.x>=currentCast.x && cast1Tmp.x<=currentCast.x+1.0) {\n\t\t\t\tray = cast1Tmp;\n\t\t\t\tcurrentCast.z += sign(castSpeed.z);\n\t\t\t\tcollideWith = (castSpeed.z>0.0?4:5);\n                skipLoop = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\treturnValue.w = length(ray-start);\n    float val = 1.0-returnValue.w/70.0;\n\treturn vec4(returnValue.xyz*val, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 f) {\n    vec2 f2 = vec2(f.x, iResolution.y-f.y);\n\tvec2 uv = f.xy / iResolution.xy;\n    tick = iTime;\n    \n    cam.x = worldSize/2.0+sin(tick/worldSize*14.0*pi)*10.0;\n    cam.y = worldSize-100.0;\n    cam.z = worldSize/2.0+tick*8.0;\n    \n    camRot = vec3(sin(tick/worldSize*22.0*pi)*.5+.5, 0.0, sin(tick/worldSize*14.0*pi)*.5);\n    \n    vec3 castDir = vec3(0, 0, 0);\n    vec3 cast1 = vec3(cam+.5);\n    vec3 cast2 = vec3(0, 0, 0);\n\n    // Getting raycast speed based on the pixel in the frustrum\n    castDir.x = f2.x/iResolution.y*5.0-(iResolution.x-iResolution.y)/2.0/iResolution.y*5.0-.5*5.0;\n    castDir.y = (.5-f2.y/iResolution.y)*5.0;\n    castDir.z = 3.0;\n\n    // Rotating camera in 3D\n    cast2.x = castDir.x*(cos(camRot.y)*cos(camRot.z))+castDir.y*(cos(camRot.z)*sin(camRot.x)*sin(camRot.y)-cos(camRot.x)*sin(camRot.z))+castDir.z*(cos(camRot.x)*cos(camRot.z)*sin(camRot.y)+sin(camRot.x)*sin(camRot.z));\n    cast2.y = castDir.x*(cos(camRot.y)*sin(camRot.z))+castDir.y*(cos(camRot.x)*cos(camRot.z)+sin(camRot.x)*sin(camRot.y)*sin(camRot.z))-castDir.z*(cos(camRot.z)*sin(camRot.x)-cos(camRot.x)*sin(camRot.y)*sin(camRot.z));\n    cast2.z = -castDir.x*(sin(camRot.y))+castDir.y*(cos(camRot.y)*sin(camRot.x))+castDir.z*(cos(camRot.x)*cos(camRot.y));\n \n    vec3 castResult = raycast(cast1, cast2).xyz;\n    \n    fragColor = vec4(clamp(castResult, 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llG3RD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llG3zW", "name": "AsGreyWolf_test1", "author": "AsGreyWolf", "description": "deform", "tags": ["deform"], "likes": 1, "viewed": 149, "date": "1473450006", "time_retrieved": "2024-06-20T18:41:17.132339", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat sinR(float c){\n\tfloat sinR = c;\n    sinR *= 2.0;\n    if(sinR>1.0)\n    \tsinR = 2.0-sinR;\n    sinR*=0.5;\n    return sinR;\n}\nfloat sinF(float c){\n    return c*6.28*2.0;\n}\n\nfloat triangleCircle(vec2 pos, float c){\n    float a = sqrt(3.0)/2.0;\n    float h = sqrt(3.0)*a;\n    float R = 1.0/max(c,0.0001)+sin(atan(pos.y,pos.x)*10.0+sinF(c))*sinR(c);\n    pos.x=abs(pos.x);\n    pos.y+=h/3.0;\n\tvec2 center = vec2(0.0, sqrt(R*R-a*a));\n    if(pos.y<center.y-sqrt(R*R-pos.x*pos.x)) return 0.0;\n    float L = sqrt(R*R - (h*h+a*a)/4.0);\n    vec2 dir = normalize(vec2(-h, -a));\n    center = vec2(a/2.0,h/2.0) + dir*L;\n    float maxy = sqrt(R*R - pow(pos.x-center.x,2.0))+center.y;\n    if(pos.y>maxy) return 0.0;\n    return 1.0;\n    \n}\nfloat circleSquare(vec2 pos, float c){\n\tpos=abs(pos);\n\tif(pos.x>1.0 || pos.y>1.0)\n        return 0.0;\n    float R = mix(1.0, 0.0, c);\n    if(pos.x > 1.0-R && pos.y-1.0+R > sqrt(R*R-pow(pos.x-1.0+R,2.0)))\n        return 0.0;\n    return 1.0;\n}\nfloat squareTriangle(vec2 pos, float c){\n    if(c<0.5)\n        return circleSquare(pos,1.0-c*2.0);\n    c-=0.5;\n    return triangleCircle(pos,1.0-c*2.0);\n}\nfloat coeff(){\n    float t = iTime/3.0;\n    t -= floor(t);\n    //return 0.8+t*0.1;\n    t *= 2.0;\n    if(t<=1.0)\n        return t;\n    return 2.0-t;\n}\nfloat coeff2(){\n    //return 0.0;\n    float t = iTime/5.0;\n    t -= floor(t);\n    t *= 2.0;\n    if(t<=1.0)\n        return t;\n    return 2.0-t;\n}\nfloat quintic(float t){\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tex = fragCoord/iResolution.y;\n\tvec2 pos = tex*2.0-vec2(1.0);\n    float fi = coeff2()*2.0*M_PI;\n    pos = vec2(pos.x*cos(fi)-pos.y*sin(fi),pos.x*sin(fi)+pos.y*cos(fi));\n    pos*=1.414;\n    float t = coeff()*3.0;\n    float a;\n    if(t>2.0)\n    \ta=circleSquare(pos,quintic(t-2.0));\n    else if(t>1.0)\n    \ta=triangleCircle(pos,quintic(t-1.0));\n    else\n    \ta=squareTriangle(pos,quintic(t));\n        \n\tfragColor = vec4(a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llG3zW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llG3zy", "name": "Faster Voronoi Edge Distance", "author": "tomkh", "description": "Improved version of [url=https://www.shadertoy.com/view/ldl3W8]Inigo Quilez's implementation[/url]: 32 iterations vs 34, plus approx. variants with 18 and 25 iterations.\nAlso in [url=http://polycu.be/edit/?h=Gbhigy]PolyCube[/url] with EvalDraw controls.", "tags": ["2d", "voronoi", "worley"], "likes": 38, "viewed": 4315, "date": "1475176036", "time_retrieved": "2024-06-20T18:41:18.835595", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2016\n\n// Based on https://www.shadertoy.com/view/ldl3W8 by Inigo Quilez\n// And his article: http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n// This is based on Inigo Quilez's distance to egdes,\n// except I consider here faster variants:\n// * 3x3 scan at the cost of small inaccuracies\n// * 4x4 scan in the second pass that has no accuracy-loss to IQ's version\n// * 4x4 in both passes that is more accurate than original IQ's version\n//   (and still has less iterations 32=4*4*2 vs 34=3*3+5*5)\n\n// Original IQ's algorithm is flawed (mathematically incorrect)\n// i.e. for all possible hash functions, as in this counter-example:\n// https://www.shadertoy.com/view/4lKGRG\n\n// Basically in the original IQ's implementation,\n// he was storing closest cell \"mg\" in the first pass\n// and using it for the second pass.\n// If we want 3x3 scan in the second pass it is enough to continue search\n// from the same (current fragment) cell and limit search space\n// to only neighbouring cells (thus \"mg\" can be ignored).\n// In fact, searching around \"mg\" makes it worse (see my illustration below).\n// For 4x4 variant we have to set the center of search \n// based on which half of the current fragment cell we are in.\n// Note: \n//   The second pass scan area has nothing to do with the position\n//   of the closest point.\n//   Here is an illustration of my improved algorithm:\n//   http://ricedit.com/second_order_voronoi_03.png\n\n// Pick approximation level:\n//   0 = 3x3 scan for both passes (occasional issues, but the fastest)\n//   1 = 3x3 + 4x4 scan (good in most cases, if every cell has diameter < 1)\n//   2 = 4x4 scan for both passes (improved accuracy)\n//   3 = 3x3 + 5x5 scan (original IQ's)\n#define SECOND_PASS 2\n\n#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\nvec2 hash2(vec2 p)\n{\n    #if 0\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    #else\n       // Texture-based\n       vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    #endif\n    #ifdef ANIMATE\n       o = 0.5 + ANIMATE_D*sin( iTime + o*6.2831853 );\n    #endif\n   return o;\n}\n\n#if SECOND_PASS == 0\n//---------------------------------------------------------------\n// Fastest version with 3x3 scan in the second pass\n//---------------------------------------------------------------\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n#elif SECOND_PASS == 1\n//---------------------------------------------------------------\n// Approximation with 4x4 scan in the second pass\n// Good enough in most cases\n//---------------------------------------------------------------\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n    \n    // Set center of search based on which half of the cell we are in,\n    // since 4x4 is not centered around \"n\".\n    vec2 mg = step(.5,f) - 1.;\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits two neighbours to the right/down\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=2; j++ )\n    for( int i=-1; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n#elif SECOND_PASS == 2\n//---------------------------------------------------------------\n// 4x4 scan in both passes = most accurate\n//---------------------------------------------------------------\n\nvec3 voronoi( in vec2 x )\n{\n#if 1\n    // slower, but better handles big numbers\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n#else\n    vec2 n = floor(x - 1.5);\n    vec2 f = x - n;\n#endif\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n#else\n//---------------------------------------------------------------\n// Slowest with 5x5 scan in the second pass\n// Original Implementation by Inigo Quilez \n// as in https://www.shadertoy.com/view/ldl3W8\n//---------------------------------------------------------------\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n//---------------------------------------------------------------\n#endif\n\nvec3 plot( vec2 p, float ss )\n{\n    vec3 c = voronoi( p );\n    \n    // Colors:\n    vec3 interior = vec3(.2,.8,1.);\n    vec3 border = vec3(.2,.8,.4);\n    vec3 point = vec3(1.,.7,0.);\n    \n    float d = length(c.yz);\n    vec3 col =\n        mix(\n            mix(\n                c.x*2.*(sin(c.x*120.)*.1+.9)*interior,\n                border,\n                smoothstep(.08,.06,c.x)\n            )*min(1.,d*9.),\n            point,\n            smoothstep(.07,.05,d)\n        );\n    if (iMouse.z > 0.) // show grid\n    {\n\t\tvec2 g = abs(fract(p)-.5);\n        col = mix(col,vec3(.8),smoothstep(.5-ss*1.5,.5,max(g.x,g.y)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tfloat ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llG3zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llGGRG", "name": "Daltonize", "author": "daeken", "description": "Test shader for daltonizing images.", "tags": ["test", "colorblindness", "daltonize"], "likes": 1, "viewed": 186, "date": "1475109560", "time_retrieved": "2024-06-20T18:41:19.465860", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ distance-2d ]\n\n:globals\n\ttrue =>shadertoy\n\t\t{\n\t\t\t@vec3 uniform =iResolution @float uniform =iTime\n\t\t\tiResolution .xy =>resolution\n\t\t\tiTime =>time\n\t\t}\n\t\t{\n\t\t\t@vec2 uniform =R @float uniform =T\n\t\t\tR =>resolution\n\t\t\tT =>time\n\t\t}\n\tshadertoy cif\n;\n\nresolution frag->position =p\n\n: distance-field ( p:vec2 -> vec4 )\n\t[\n\t\t[ p [ .9 0 ] + time 60 * rotate-deg [ .2 .2 ] ubox ##f00 ]\n\t\t[ p time 60 * rotate-deg [ .2 .2 ] ubox ##0f0 ]\n\t\t[ p [ .9 0 ] - time 60 * rotate-deg [ .2 .2 ] ubox ##00f ]\n\t] matunion\n;\n\n:m background\n\t[\n\t\tp .x -.45 < { ##0f0 }\n\t\tp .x .45 > { ##ff0 }\n\t\t{ ##f00 }\n\t] cond\n;\n\n:m texture ( d )\n\t\tbackground\n\t\td .yzw\n\t\t.01 d .x - 500 * 0 1 clamp\n\tmix\n;\n\n: daltonize ( c:vec3 -> vec3 )\n\t[\n\t\t[ 0.0 2.02344 -2.52581 ]\n\t\t[ 0.0 1.0      0.0 ]\n\t\t[ 0.0 0.0      1.0 ]\n\t] =>protanope\n\n\tprotanope =>[ cvda cvdb cvdc ] ( Select appropriate type of color blindness )\n\n\t[\n\t\t[ 17.8824 43.5161 4.11935 ] c * \\+\n\t\t[ 3.45565 27.1554 3.86714 ] c * \\+\n\t\t[ 0.0299566 0.184309 1.46709 ] c * \\+\n\t] =LMS\n\n\t[\n\t\tcvda LMS * \\+\n\t\tcvdb LMS * \\+\n\t\tcvdc LMS * \\+\n\t] =LMS\n\n\tc [\n\t\t[ 0.0809444479 -0.130504409 0.116721066 ] LMS * \\+\n\t\t[ -0.0102485335 0.0540193266 -0.113614708 ] LMS * \\+\n\t\t[ -0.000365296938 -0.00412161469 0.693511405 ] LMS * \\+\n\t] - =NC\n\n\t[\n\t\t0\n\t\t[ .7 1 0 ] NC * \\+\n\t\t[ .7 0 1 ] NC * \\+\n\t] =error\n\n\tc error + 0 1 clamp\n;\n\n:m apply-filter ( $c )\n\t\tc\n\t\tc daltonize\n\t\t1 1 time 4 + sin - 2 ** - 3 * p .x - 0 1 clamp\n\tmix\n;\n\np distance-field texture apply-filter ->fragcolor\n*/\n\nvec2 rotate_02d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec4 distance_1field(vec2 p) {\n\tvec4 macro_temp_34_a = vec4(length(max(abs(rotate_02d(p + vec2(.9, 0.), iTime * 60. * .017453)) - .2, 0.)), 1., 0., 0.);\n\tvec4 macro_temp_34_b = vec4(length(max(abs(rotate_02d(p, iTime * 60. * .017453)) - .2, 0.)), 0., 1., 0.);\n\tmacro_temp_34_a = (macro_temp_34_a.x == min(macro_temp_34_a.x, macro_temp_34_b.x) ? macro_temp_34_a : macro_temp_34_b);\n\tmacro_temp_34_b = vec4(length(max(abs(rotate_02d(p - vec2(.9, 0.), iTime * 60. * .017453)) - .2, 0.)), 0., 0., 1.);\n\treturn (macro_temp_34_a.x == min(macro_temp_34_a.x, macro_temp_34_b.x) ? macro_temp_34_a : macro_temp_34_b);\n}\nvec3 daltonize(vec3 c) {\n\tvec3 var_1 = vec3(17.8824, 43.5161, 4.11935) * c;\n\tvec3 var_2 = vec3(3.45565, 27.1554, 3.86714) * c;\n\tvec3 var_3 = vec3(.029957, .184309, 1.46709) * c;\n\tvec3 LMS = vec3(var_1.x + var_1.y + var_1.z, var_2.x + var_2.y + var_2.z, var_3.x + var_3.y + var_3.z);\n\tvec3 var_5 = vec3(0., 2.02344, -2.52581) * LMS;\n\tvec3 var_6 = vec3(0., 1., 0.) * LMS;\n\tvec3 var_7 = vec3(0., 0., 1.) * LMS;\n\tLMS = vec3(var_5.x + var_5.y + var_5.z, var_6.x + var_6.y + var_6.z, var_7.x + var_7.y + var_7.z);\n\tvec3 var_8 = vec3(.080944, -.130504, .116721) * LMS;\n\tvec3 var_9 = vec3(-.010249, .054019, -.113615) * LMS;\n\tvec3 var_10 = vec3(-.000365, -.004122, .693511) * LMS;\n\tvec3 NC = c - vec3(var_8.x + var_8.y + var_8.z, var_9.x + var_9.y + var_9.z, var_10.x + var_10.y + var_10.z);\n\tvec3 var_12 = vec3(.7, 1., 0.) * NC;\n\tvec3 var_13 = vec3(.7, 0., 1.) * NC;\n\tvec3 error = vec3(0., var_12.x + var_12.y + var_12.z, var_13.x + var_13.y + var_13.z);\n\treturn clamp(c + error, 0., 1.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 temp_41;\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tif(p.x < -.45) {\n\t\ttemp_41 = vec3(0., 1., 0.);\n\t} else if(p.x > .45) {\n\t\ttemp_41 = vec3(1., 1., 0.);\n\t} else {\n\t\ttemp_41 = vec3(1., 0., 0.);\n\t}\n\tvec3 macro_apply_2filter_c = mix(temp_41, distance_1field(p).yzw, clamp((.01 - distance_1field(p).x) * 500., 0., 1.));\n\tfragColor = vec4(mix(macro_apply_2filter_c, daltonize(macro_apply_2filter_c), clamp((1. - pow(1. - sin(iTime + 4.), 2.)) * 3. - p.x, 0., 1.)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llGGRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llGGW1", "name": "Tuning noise without sliding pb2", "author": "FabriceNeyret2", "description": "Tuning the scale of a perturbation (right) without creating parasitic motion (as in left).\nPerlin noise version.\n\nThis is also useful when interpolating the noise parameter along the surface.", "tags": ["noise", "filtering", "interpolation", "smartblend"], "likes": 8, "viewed": 957, "date": "1474390763", "time_retrieved": "2024-06-20T18:41:19.738686", "image_code": "// Perlin noise version of https://www.shadertoy.com/view/ltG3Dh\n// for spacial interpolation issue, see https://www.shadertoy.com/view/MlGGW1\n\n// --- noise from from IQ's https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(  vec2 p )\n{\n    vec2 i = floor( p ), f = fract( p ), u = f*f*(3.-2.*f);\n    float v = mix( mix( dot( hash( i + vec2(0,0) ), f - vec2(0,0) ), \n                     dot( hash( i + vec2(1,0) ), f - vec2(1,0) ), u.x),\n                mix( dot( hash( i + vec2(0,1) ), f - vec2(0,1) ), \n                     dot( hash( i + vec2(1,1) ), f - vec2(1,1) ), u.x), u.y);\n    return v;\n    //return 1.-abs(2.*v-1.);\n    //return abs(2.*v-1.);\n}\n// ---\n\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    vec2 R = iResolution.xy,\n         U = uv/R;\n    O-=O;\n    \n    float l = (.5-.5*cos(iTime))*6., f=fract(l);                 // noise scaling\n    if (U.x<.5)\n        O += noise((uv-R/2.)/exp2(l));\n    else\n      //O += mix(noise(uv/exp2(floor(l))),noise(uv/exp2(ceil(l))),f);\n        O += mix(noise(uv/exp2(floor(l))),noise(uv/exp2(ceil(l))),f)/sqrt(2.*(f*f-f)+1.); // + contrast-preserving\n      //O += mix(noise(uv/exp2(floor(l/.1)*.1)),noise(uv/exp2(ceil(l/.1)*.1)),f);\n \n    //O = 1.-abs(2.*O-1.);\n    //O = abs(2.*O-1.);\n    O = vec4(.5+.5*sin(20.*(U.x+U.y)+O.x));                            // marble pattern\n    O = sqrt(O);                                                       // gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llGGW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llGGzD", "name": "Double kifs", "author": "stduhpf", "description": "A basic kif with spheres replaced by others basic kifs", "tags": ["fractal"], "likes": 13, "viewed": 216, "date": "1473505911", "time_retrieved": "2024-06-20T18:41:20.459756", "image_code": "#define fr_it 8\n\n#define axis vec3(2,1,0)\n\n#define axis2 vec3(0,1,2)\n\n#define mainshape vec3(.2)\n\n#define mainshape2 vec3(.04)\n\n#define scaling vec3(2)\n\n#define speed .4\n\n#define speed2 -.23\n\n#define dotsize .005\n\n#define camera_distance 2.\n#define pseudo_fov .75\n#define viewdist 5.\n\n#define prec .0001\n#define raymaxit 300\n\nmat3 r(float a, vec3 m)\n{\n    m= normalize(m);\n    float c = cos(a),s=sin(a);\n    return mat3(c+(1.-c)*m.x*m.x,\n                (1.-c)*m.x*m.y-s*m.z,\n                (1.-c)*m.x*m.z+s*m.y,\n                (1.-c)*m.x*m.y+s*m.z,\n                c+(1.-c)*m.y*m.y,\n                (1.-c)*m.y*m.z-s*m.x,\n                (1.-c)*m.x*m.z-s*m.y,\n                (1.-c)*m.y*m.z+s*m.x,\n                c+(1.-c)*m.z*m.z);\n}\n\nfloat ifs(vec3 p,float t, vec3 m,vec3 s)\n{\n    mat3 rot=r(t,m);\n    for(int i =0;i<fr_it;i++)\n    {\n        p= abs(p)-s;\n        p*=rot;\n        s/=scaling;\n      }\n return length(p)-dotsize ;    \n}  \nvec2 map(vec3 p)\n{\n    float t = iTime*speed;\n    //t = 0.;  //modulo 2pi : when the center of faces are flat\n    vec3 m =axis;\n    vec3 s =mainshape;\n    mat3 rot=r(t,m);\n    for(int i =0;i<fr_it;i++)\n    {\n        p= abs(p)-s;\n        p*=rot;\n        s/=scaling;\n      }\n return vec2(ifs(p,iTime*speed2,axis2,mainshape2),1) ;    \n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.01,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd,float n)\n{\n    float f=0.;\n    for(int i = 0; i <raymaxit; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<prec)\n                return vec2(f,h.x);\n               \tif(f > n)\n           break;\n            f+=h.x;\n    }\n    return vec2(0);\n}\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float f=0.01;\n    float e = 1.;\n    for(int i = 0; i <raymaxit; i++)\n    {\n        float d = map(ro+f*rd).x;\n        \n            if(d<.00001)\n            {\n                e=0.;\n             break;\n            }\n            f+=d;\n        e=min(e,8.*d/f);\n    }\n    return clamp(e,0.,1.);\n}\n\n\n\nfloat ao(vec3 p, vec3 n,float d)\n{\n    float h = map(p+d*n).x;\n    return d/(d+(d-h));\n}\n\n\nvoid mainImage( out vec4 fcol, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.x- vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    mse*=8.;\n    if(iMouse.xy==vec2(0))\n        mse*=0.;\nmat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nmat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n\n    vec3 ro = vec3(0,0,-camera_distance)*rdroty*rdrotx;\n    vec3 rd = normalize(vec3(uv,pseudo_fov))*rdroty*rdrotx;\n    float m =0.;\n    vec2 i = intersect(ro,rd,viewdist);\n    vec3 ld = normalize(vec3(1,1,-1));\n    \n    m+=.02/distance(rd,ld);\n    if(i.x>0.)\n    {\n    vec3 pos = ro+i.x*rd;\n    vec3 nor = normal(pos); \n    float amb =ao(pos,nor,.03);//cheap fake ambiant occlusion\n        m=amb;\n        float sh =shadow(pos,ld); //softshadows\n        m*=max(.1,dot(nor,ld)*sh); //aplly lighting\n        rd = reflect(rd,nor);\n    m+=.02/distance(rd,ld)*sh;; //specular highlighting\n        \n    }\n   \n    vec3 col = vec3(m);\n    fcol = vec4(col,m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llGGzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llGGzh", "name": "Maze Lattice", "author": "Shane", "description": "Applying a geometric pattern and edging to Fizzer's infinite, maze-like lattice structure.", "tags": ["3d", "random", "truchet", "edge", "bump", "tech", "maze", "hexagonal"], "likes": 123, "viewed": 5230, "date": "1473945929", "time_retrieved": "2024-06-20T18:41:23.084278", "image_code": "/*\n\n    Maze Lattice\n    ------------\n\n\tApplying a geometric pattern and edging to Fizzer's maze lattice. I'm not sure what he technically \n\tcalls it, but it has a lattice feel, and as he infers in his article, it's a 3D structure with \n\tmaze-like qualities. Either way, I particularly like it because it's cleverly constructed, interesting \n\tlooking, and very cheap to produce. Basically, it's one of those distance fields that gives you your \n\tmoney's worth. :)\n\n\tThe only interesting thing here is the distance field equation that contains the maze-like lattice. I've \n\tgiven a rough explanation behind its construction, but it's much better to read Fizzer's well explained \n\tarticle, which I've provided a link to below.\n\n\tThe geometric surfacing pattern is a 2D hexagonal Truchet design, which is applied to each of the flat \n    face sections in accordance to the surface normal orientation. It's a standard way to apply 2D patterns \n\tto a cuboid-based surface, and is contained in the \"texFaces\" function.\n\n\tI used an edging algorithm to obtain the edges, which involves extra distance function and bump calls. \n\tI've since thought of a better way to make that happen which will cut down on cost and complexity, so \n\tI'll apply that in due course.\n\n\tAnyway, I have a reflection\\refraction version, based on the same surface that I'll release later.\n\t\n\tDistance field based on the article accompanying the following:\n\tMaze Explorer - fizzer\n    https://www.shadertoy.com/view/XsdGzM\n\n\tAccompanying article is here:\n\tImplicit Maze-Like Patterns\n    http://amietia.com/slashmaze.html\n\n\tTruchet shaders:\n\n    hexagonal truchet ( 352 ) - FabriceNeyret2\n    https://www.shadertoy.com/view/Xdt3D8\n \n    hexagonal tiling - mattz\n    https://www.shadertoy.com/view/4d2GzV\n    \n\n\n*/\n\n// Maximum ray distance.\n#define FAR 40.\n\n// I love this distance field. So elegant, and I can thank Fizzer for coming up with it.\n// The idea is about as simple as it gets. Break space into octahedrons then use each\n// otahedral cell to obtain a unique ID. Use that ID to render a randomly oriented square \n// tube and you're done.\n//\n// I've done a little trimming and shuffling, which probably confuses things slightly. \n// Either way, it's worth reading the following article for a much clearer explanation:\n//\n// Implicit Maze-Like Patterns - Fizzer\n// http://amietia.com/slashmaze.html\n//\nfloat map(in vec3 p) {\n    \n    \n   // Cubes, for a simpler, more orderly scene.\n   //p = abs(fract(p) - .5);    \n   //return max(max(p.x, p.y), p.z) - .225;\n   \n   // Unique identifier for the cube, but needs to be converted to a unique ID\n   // for the nearest octahedron. The extra \".5\" is to save a couple of \n   // of calculations. See below.\n   vec3 ip = floor(p) + .5;\n    \n   p -= ip; // Break space into cubes. Equivalent to: fract(p) - .5.\n    \n   // Stepping trick used to identify faces in a cube. The center of the cube face also\n   // happens to be the center of the nearest octahedron, so that works out rather well. \n   // The result needs to be factored a little (see the hash line), but it basically  \n   // provides a unique octahedral ID. Fizzer provided a visual of this, which is easier \n   // to understand, and worth taking a look at.\n   vec3 q = abs(p); \n   q = step(q.yzx, q.xyz)*step(q.zxy, q.xyz)*sign(p); // Used for cube mapping also.\n   \n   // Put the ID into a hash function to produce a unique random number. Reusing \"q\" to\n   // save declaring a float. Don't know if it's faster, but it looks neater, I guess.\n   q.x = fract(sin(dot(ip + q*.5, vec3(111.67, 147.31, 27.53)))*43758.5453);\n    \n   // Use the random number to orient a square tube in one of three random axial\n   // directions... See Fizzer's article explanation. It's better. :) By the way, it's\n   // possible to rewrite this in \"step\" form, but I don't know if it's quicker, so I'll\n   // leave it as is for now.\n   p.xy = abs(q.x>.333 ? q.x>.666 ? p.xz : p.yz : p.xy);\n   return max(p.x, p.y) - .2;   \n\n}\n\n// Very basic raymarching equation. I thought I might need to use something more sophisticated,\n// but it turns out that this structure raymarches reasonably well. Not all surfaces do.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0.0;\n    for(int i=0; i< 72; i++){\n        float d = map(ro + rd*t);\n        if (abs(d) < 0.002*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    } \n    return min(t, FAR);\n}\n\n// The reflections are pretty subtle, so not much effort is being put into them. Only a few iterations.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0.0;\n    for(int i=0; i< 16; i++){\n        float d = map(ro + rd*t);\n        if (abs(d) < 0.005*(t*.25 + 1.) || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 normal(in vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.034, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    //\n    edge = smoothstep(0., 1., sqrt(edge/e.x*8.));\n    \n    // Curvature. All this, just to take out the inner edges.\n    float crv = (d1 + d2 + d3 + d4 + d5 + d6 - d*3.)/e.x;;\n    //crv = clamp(crv*32., 0., 1.);\n    if (crv<0.) edge = 0.; // Comment out to see what it does.\n\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value. If you can roll the \n    // edge and normal into one, it saves a lot of map calls. Unfortunately, we want wide edges, so\n    // there are six more, making 12 map calls in all. Ouch! :)\n    e = vec2(.005, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calcAO( in vec3 p, in vec3 n )\n{\n    \n\tfloat ao = 0.0, l;\n\tconst float nbIte = 12.0;\n\tconst float falloff = 1.;\n    \n    const float maxDist = 1.;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + fract(cos(i)*45758.5453))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1. - ao*2./nbIte, 0., 1.);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.02, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n\n\n// Simple hexagonal truchet patten. This is based on something Fabrice and Mattz did.\n//\n// hexagonal truchet ( 352 ) - FabriceNeyret2\n// https://www.shadertoy.com/view/Xdt3D8\n//\n// hexagonal tiling - mattz\n// https://www.shadertoy.com/view/4d2GzV\nfloat hexTruchet(in vec2 p) { \n    \n    p *= 6.;\n    \n\t// Hexagonal coordinates.\n    vec2 h = vec2(p.x + p.y*.577350269, p.y*1.154700538);\n    \n    // Closest hexagon center.\n    vec2 f = fract(h); h -= f;\n    float c = fract((h.x + h.y)/3.);\n    h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f); \n\n    p -= vec2(h.x - h.y*.5, h.y*.8660254);\n    \n    // Rotate (flip, in this case) random hexagons. Otherwise, you'd hava a bunch of circles only.\n    // Note that \"h\" is unique to each hexagon, so we can use it as the random ID.\n    c = fract(cos(dot(h, vec2(41.13, 289.57)))*43758.5453); // Reusing \"c.\"\n    p -= p*step(c, .5)*2.; // Equivalent to: if (c<.5) p *= -1.;\n    \n    // Minimum squared distance to neighbors. Taking the square root after comparing, for speed.\n    // Three partitions need to be checked due to the flipping process.\n    p -= vec2(-1, 0);\n    c = dot(p, p); // Reusing \"c\" again.\n    p -= vec2(1.5, .8660254);\n    c = min(c, dot(p, p));\n    p -= vec2(0, -1.73205);\n    c = min(c, dot(p, p));\n    \n    return sqrt(c);\n    \n    // Wrapping the values - or folding the values over (abs(c-.5)*2., cos(c*6.283*1.), etc) - to produce \n    // the nicely lined-up, wavy patterns. I\"m perfoming this step in the \"map\" function. It has to do \n    // with coloring and so forth.\n    //c = sqrt(c);\n    //c = cos(c*6.283*2.) + cos(c*6.283*4.);\n    //return (clamp(c*.6+.5, 0., 1.));\n\n}\n\n// Bumping the faces.\nfloat bumpFunc(vec3 p, vec3 n){\n    \n    // Mapping the 3D object position to the 2D UV coordinate of one of three\n    // orientations, which are determined by the dominant normal axis.    \n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n    \n    // Wavy, 70s looking, hexagonal Truchet pattern.\n    vec2 sc = (cos(hexTruchet(p.xy)*6.283*vec2(2, 4)));\n    return clamp(dot(sc, vec2(.6)) + .5, 0., 1.);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 bumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc(p, n);                 \n    vec3 grad = (vec3(bumpFunc(p - e.xyy, n),\n                      bumpFunc(p - e.yxy, n),\n                      bumpFunc(p - e.yyx, n) )-ref)/e.x;                     \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n// Bumping the edges with some block partitions. Made up on the spot. \nfloat bumpFunc2(vec3 p, vec3 n){\n    \n    // Partition space to produce some smooth blocks.\n    p = abs(fract(p*3.) - .5);\n    float c = max(max(p.x, p.y), p.z);\n    \n    return 1. - smoothstep(0., .025, c - .47);\n    \n}\n\n// A second function-based bump mapping function. Used for\n// the edging. Messy, but probably faster... probably. :)\nvec3 bumpMap2(in vec3 p, in vec3 n, float bumpfactor){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc2(p, n);                 \n    vec3 grad = (vec3(bumpFunc2(p - e.xyy, n),\n                      bumpFunc2(p - e.yxy, n),\n                      bumpFunc2(p - e.yyx, n) )-ref)/e.x;                     \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// Texturing the sides with a 70s looking hexagonal Truchet pattern.\nvec3 texFaces(in vec3 p, in vec3 n){\n    \n    // Use the normal to determine the face. Dominant \"n.z,\" then use the XY plane, etc.\n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n\n    // Some fBm noise based bluish red coloring.\n    n = mix(vec3(.3, .1, .02), vec3(.35, .5, .65), n2D(p.xy*8.)*.66 + n2D(p.xy*16.)*.34);\n    n *= n2D(p.xy*512.)*1.2 + 1.4;\n    \n    //n =  n*.3 + min(n.zyx*vec3(1.3, .6, .2)*.75, 1.)*.7;\n   \n    // Overlaying with the hexagonal Truchet pattern.\n    vec2 sc = (cos(hexTruchet(p.xy)*6.283*vec2(2, 4)));\n    n *= clamp(dot(sc, vec2(.6))+.5, 0., 1.)*.95 + .05;\n    \n    return min(n, 1.);\n\n}\n\n// Terxturing the edges with something subtle.\nvec3 texEdges(in vec3 p, in vec3 n){\n    \n    float bf = bumpFunc2(p, n); // Bump function.\n    \n    // 2D face selection.\n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n\n    // Mixing color with some fBm noise.\n    n = mix(vec3(.3, .1, .02), vec3(.35, .5, .65), n2D(p.xy*8.)*.66 + n2D(p.xy*16.)*.34);\n    n *= n2D(p.xy*512.)*.85 + .15; \n    \n    // More coloring.\n    n = min((n + .35)*vec3(1.05, 1, .9), 1.);\n    \n    // Running the bump function over the top for some extra depth.\n    n *= bf*.75+.25;\n    \n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty happy with this.\n    vec3 rd = vec3(2.*fragCoord - iResolution.xy, iResolution.y);\n    \n    // Barrel distortion;\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(1.57079632, 0) + iTime/4.);\n    rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);\n    \n    // Ray origin: Sending it along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime);\n    // Alternate: Set off in the YZ direction. Note the \".5.\" It's an old lattice trick.\n    //vec3 ro = vec3(0, iTime/2. + .5, iTime/2.);\n    \n    vec3 lp = ro + vec3(.2, 1., .3); // Light, near the ray origin.\n    \n    // Set the initial scene color to black.\n    vec3 col = vec3(0);\n\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Normally, you'd only light up the scene if the distance is less than the outer boundary.\n    // However, in this case, since most rays hit, I'm clamping to the far distance, and doing\n    // the few extra calculations. The payoff (I hope) is not having a heap of nested code.\n    // Whether that results in more speed, or not, I couldn't really say, but I'd imagine you'd\n    // receive a slight gain... maybe. If the scene were more open, you wouldn't do this.\n    //if(t<FAR){\n        \n        float edge;\n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp, edge); // Surface normal.\n\n    \t// Saving a copy of the unbumped normal, since the texture routine require it.\n    \t// I found that out the hard way. :)\n        vec3 svn = sn;\n\t\t\n    \t// Bump mapping the faces and edges. The bump factor is reduced with distance\n    \t// to lessen artifacts.\n        if(edge<.001) sn = bumpMap(sp, sn, .01/(1. + t*.25));\n        else sn = bumpMap2(sp, sn, .03/(1. + t*.25));\n\n        vec3 ref = reflect(rd, sn); // Reflected ray.\n\n        vec3 oCol = texFaces(sp, svn); // Texture color at the surface point.\n        if(edge>.001) oCol = texEdges(sp, svn);\n\n\n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calcAO(sp, sn); // Self shadows. Not too much.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 32.); // Specular.\n\n        float atten = 1.25/(1.0 + lDist*0.1 + lDist*lDist*.05); // Attenuation.\n\n\n\n        ///////////////\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n        // effort is being put in.\n        //\n        float rt = refTrace(sp + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        float rEdge;\n        vec3 rsp = sp + ref*rt; // Reflected surface hit point.\n        vec3 rsn = normal(rsp, rEdge); // Normal at the reflected surface.\n        //rsn = bumpMap(rsp, rsn, .005); // We're skipping the reflection bump to save some calculations.\n\n        vec3 rCol = texFaces(rsp, rsn); // Texel at \"rsp.\"    \n        if(rEdge>.001)rCol = texEdges(rsp, rsn); // Reflection edges.\n\n        float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); // Diffuse light at \"rsp.\"\n        float rSpec = pow(max(dot(reflect(-normalize(lp-rsp), rsn), -ref), 0.), 8.); // Diffuse light at \"rsp.\"\n        float rlDist = length(lp - rsp);\n        // Reflected color. Not entirely accurate, but close enough. \n        rCol = (rCol*(rDiff*1. + vec3(.45, .4, .3)) + vec3(1., .6, .2)*rSpec*2.);\n        rCol *= 1.25/(1.0 + rlDist*0.1 + rlDist*rlDist*.05);    \n        ////////////////\n\n\n        // Combining the elements above to light and color the scene.\n        col = oCol*(diff*1. + vec3(.45, .4, .3)) + vec3(1., .6, .2)*spec*2.;\n\n\n        // Adding the reflection to the edges and faces. Technically, there should be less on the faces,\n        // but after all that trouble, I thought I'd bump it up a bit. :)\n        if(edge<.001) col += rCol*.2;\n        else col += rCol*.35;\n        // Alternate way to mix in the reflection. Sometimes, it's preferable, but not here.\n        //if(edge<.001) col = mix(col, rCol, .35)*1.4;\n        //else col = mix(col, rCol, .5)*1.4;\n\n\n        // Shading the scene color and clamping. By the way, we're letting the color go beyond the maximum to\n        // let the structure subtly glow a bit... Not really natural, but it looks a little shinier.\n        col = min(col*atten*sh*ao, 1.);\n    \n    //}\n    \n    // Mixing in some hazy bluish orange background.\n    vec3 bg = mix(vec3(.5, .7, 1).zyx, vec3(1, .7, .3).zyx, -rd.y*.35 + .35);\n    col = mix(col, bg, smoothstep(0., FAR-25., t));//min(bg.zyx*vec3(1.3, .6, .2)*1.5, 1.)\n    \n    // Postprocesing - A subtle vignette with a bit of warm coloring... I wanted to warm the atmosphere up\n    // a bit. Uncomment it, if you want to see the bluer -possibly more natural looking - unprocessed version.\n    vec2 uv = fragCoord/iResolution.xy;\n    float vig = pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125);\n    col *= vec3(1.2, 1.1, .85)*vig;\n\n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llGGzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llGGzy", "name": "RayTracer", "author": "Tacoa", "description": "dsadas", "tags": ["ray"], "likes": 2, "viewed": 71, "date": "1475174968", "time_retrieved": "2024-06-20T18:41:23.084278", "image_code": "vec3 eyePos = vec3(0.0,0.0,-5.0);\nvec3 spherePos = vec3(0.0, 0.0, 10.0 * cos(iTime*3.0)+10.0);\nfloat r = 1.0;\n\nvec3 lightPos = vec3(-5.0, 5.0, -5.0);\nfloat lightIntensity = 1.0;\nfloat ambientIntensity = 0.1;\n\n//phong parameter\nfloat ka = 0.01;\nfloat kd = 0.69;\nfloat ks = 0.3;\nfloat alpha = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 pw = vec3(p,0.0);\n\n    //ray direction\n    vec3 eyeDir = pw - eyePos; //pw-eyePos\n\t\n    vec3 tmp = eyePos - spherePos;\n\n    float a = dot(eyeDir, eyeDir);\t// dot\n    float b = 2.0 * dot(eyeDir, tmp);\n    float c = dot(tmp, tmp) - r * r;\n\n    float d = b * b - 4.0 * a * c;\n    \n    float t = -1.0;\n\n    if (d == 0.0) {\n        t = -b / 2.0 * a;\n    } else if (d > 0.0) {\n        float t1 = (-b - sqrt(d)) / (2.0*a);\n        float t2 = (-b + sqrt(d)) / (2.0*a);\n        \n        t = t1 > 0.0 && t2 > 0.0 ? min(t1, t2) : max(t1, t2);\n    }\n\n    if (t > 0.0) {\n        //ambient\n        float radianceAmb = ka * ambientIntensity;\n\n        //diffuse\n        vec3 intPos = eyePos + t*eyeDir;\t// mult\n        vec3 lightDir = lightPos - intPos;\n        lightDir = normalize(lightDir);\n        vec3 sphereN = intPos - spherePos;\n        sphereN = normalize(sphereN);\n\n        float nlDot = clamp(dot(sphereN,lightDir), 0.0, 1.0);\n\n        float radianceDif = kd * lightIntensity * nlDot;\n\n        //specular\n        float radianceSpe = 0.0;\n\n        if (nlDot > 0.0) {\n            vec3 refDir = sphereN * nlDot * 2.0 - lightDir;\n            vec3 invEyeDir = eyeDir * -1.0;\n            invEyeDir = normalize(invEyeDir);\n\n            float vrDot = clamp(dot(invEyeDir,refDir), 0.0, 1.0);\n\n            radianceSpe = ks * lightIntensity * pow(vrDot, alpha);\n        }\n\n        float radiance = clamp(radianceAmb + radianceDif + radianceSpe, 0.0, 1.0);\n        float colorVal = radiance;\n        fragColor = vec4(colorVal, 0.0, 0.0, 1.0);\n    } else{\n    \tfragColor = vec4(0.0, 0.0, 0.1, 1.0);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llGGzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llK3WR", "name": "Mountain Peak", "author": "TDM", "description": "Terrain with procedural hydraulic erosion.", "tags": ["terrain", "rocks", "mountains", "snow", "wind", "hills", "erosion", "snowy"], "likes": 67, "viewed": 2954, "date": "1474231663", "time_retrieved": "2024-06-20T18:41:24.526833", "image_code": "// \"Mountain Peak\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define WIND\n\nconst int NUM_STEPS = 64;\nconst int NUM_STEPS_VOLUME = 10;\nconst float STRIDE = 0.75;\nconst float STRIDE_VOLUME = 1.0;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n\n// terrain\nconst int ITER_GEOMETRY = 7;\nconst int ITER_FRAGMENT = 10;\n\nconst float TERR_HEIGHT = 12.0;\nconst float TERR_WARP = 0.7;\nconst float TERR_OCTAVE_AMP = 0.58;\nconst float TERR_OCTAVE_FREQ = 2.5;\nconst float TERR_MULTIFRACT = 0.27;\nconst float TERR_CHOPPY = 1.9;\nconst float TERR_FREQ = 0.24;\nconst vec2 TERR_OFFSET = vec2(13.5,15.);\n\nconst vec3 SKY_COLOR = vec3(0.5,0.59,0.75) * 0.6;\nconst vec3 SUN_COLOR = vec3(1.,1.,0.98) * 0.7;\nconst vec3 COLOR_SNOW = vec3(1.0,1.0,1.1) * 2.2;\nconst vec3 COLOR_ROCK = vec3(0.0,0.0,0.1);\nvec3 light = normalize(vec3(1.0,1.0,-0.3));\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat saturate(float x) { return clamp(x,0.,1.); }\n\n/*float hash(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}*/\nfloat hash(vec2 p) {\n    uint n = floatBitsToUint(p.x * 122.0 + p.y);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash3(vec3 p) {\n    return fract(sin(p.x*p.y*p.z)*347624.531834);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor( p );\n    vec3 f = fract( p );\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    float a = hash3( i + vec3(0.0,0.0,0.0) );\n\tfloat b = hash3( i + vec3(1.0,0.0,0.0) );    \n    float c = hash3( i + vec3(0.0,1.0,0.0) );\n\tfloat d = hash3( i + vec3(1.0,1.0,0.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    a = hash3( i + vec3(0.0,0.0,1.0) );\n\tb = hash3( i + vec3(1.0,0.0,1.0) );    \n    c = hash3( i + vec3(0.0,1.0,1.0) );\n\td = hash3( i + vec3(1.0,1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return abs(mix(v1,v2,u.z));\n}\n\n// noise with analytical derivatives (thanks to iq)\nvec3 noise_deriv(in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    \n    float a = hash( i + vec2(0.0,0.0) );\n\tfloat b = hash( i + vec2(1.0,0.0) );    \n    float c = hash( i + vec2(0.0,1.0) );\n\tfloat d = hash( i + vec2(1.0,1.0) );    \n    float h1 = mix(a,b,u.x);\n    float h2 = mix(c,d,u.x);\n                                  \n    return vec3(abs(mix(h1,h2,u.y)),\n               6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// terrain\nvec3 octave(vec2 uv) {\n    vec3 n = noise_deriv(uv);\n    return vec3(pow(n.x,TERR_CHOPPY), n.y, n.z);\n}\n\nfloat map(vec3 p) {\n    float frq = TERR_FREQ;\n    float amp = 1.0;\n    vec2 uv = p.xz * frq + TERR_OFFSET;\n    vec2 dsum = vec2(0.0);\n    \n    float h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {          \n    \tvec3 n = octave((uv - dsum * TERR_WARP) * frq);\n        h += n.x * amp;       \n        \n        dsum += n.yz * (n.x*2.0-1.0) * amp;\n        frq *= TERR_OCTAVE_FREQ;\n        amp *= TERR_OCTAVE_AMP;        \n        amp *= pow(n.x,TERR_MULTIFRACT);\n    }\n    h *= TERR_HEIGHT / (1.0 + dot(p.xz,p.xz) * 1e-3);\n    return p.y - h;\n}\nfloat map_detailed(vec3 p) {\n    float frq = TERR_FREQ;\n    float amp = 1.0;\n    vec2 uv = p.xz * frq + TERR_OFFSET;\n    vec2 dsum = vec2(0.0);\n    \n    float h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \tvec3 n = octave((uv - dsum * TERR_WARP) * frq);\n        h += n.x * amp;\n        \n        dsum += n.yz * (n.x*2.0-1.0) * amp;\n        frq *= TERR_OCTAVE_FREQ;\n        amp *= TERR_OCTAVE_AMP;\n        amp *= pow(n.x,TERR_MULTIFRACT);\n    }\n    h *= TERR_HEIGHT / (1.0 + dot(p.xz,p.xz) * 1e-3);\n    return p.y - h;\n}\n\nfloat getAO(vec3 p) {\n    float frq = TERR_FREQ;\n    float amp = 1.0;\n    vec2 uv = p.xz * frq + TERR_OFFSET;\n    vec2 dsum = vec2(0.0);\n    \n    float h = 1.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \tvec3 n = octave((uv - dsum * TERR_WARP) * frq);\n        \n        float it = float(i)/float(ITER_FRAGMENT-1);\n        float iao = mix(sqrt(n.x),1.0, it*0.9);\n        iao = mix(iao, 1.0 ,1.0 - it);\n        h *= iao;\n        \n        dsum += n.yz * (n.x*2.0-1.0) * amp;\n        frq *= TERR_OCTAVE_FREQ;\n        amp *= TERR_OCTAVE_AMP;\n        amp *= pow(n.x,TERR_MULTIFRACT);\n    }\n    \n    return sqrt(h*2.0);\n}\nfloat map_noise(vec3 p) {\n    p *= 0.5;    \n    float ret = noise_3(p);\n    ret += noise_3(p * 2.0) * 0.5;\n    ret = (ret - 1.0) * 5.0;\n    return saturate(ret * 0.5 + 0.5);\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat hftracing(vec3 ori, vec3 dir, out vec3 p, out float t) {\n    float d = 0.0;\n    t = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        d = map(p);\n        if(d < 0.0) break;\n        t += d*0.6;\n    }\n    return d;\n}\n\nfloat volume_tracing(vec3 ori, vec3 dir, float maxt) { \n    float d = 0.0;\n    float t = 0.0;\n    float count = 0.0;\n    for(int i = 0; i < NUM_STEPS_VOLUME; i++) {\n        vec3 p = ori + dir * t;\n        d += map_noise(p);\n        if(t >= maxt) break;  \n        t += STRIDE_VOLUME;\n        count += 1.0;\n    }\n    return d / count;\n}\n\n// color\nvec3 sky_color(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,3.0);\n    ret.y = pow(1.0-e.y, 1.2);\n    ret.z = 0.8+(1.0-e.y)*0.3;    \n    return ret;\n}\nvec3 terr_color(in vec3 p, in vec3 n, in vec3 eye, in vec3 dist) {\n    float slope = 1.0-dot(n,vec3(0.,1.,0.));     \n    vec3 ret = mix(COLOR_SNOW,COLOR_ROCK,smoothstep(0.0,0.2,slope*slope));\n    ret = mix(ret,COLOR_SNOW,saturate(smoothstep(0.6,0.8,slope+(p.y-TERR_HEIGHT*0.5)*0.05)));\n    return ret;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.1;\n        \n    // ray\n    vec3 ang = vec3(sin(time*6.0)*0.1,0.1,-time + iMouse.x*0.01);\n\tmat3 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,5.0,40.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));\n    dir.z += length(uv) * 0.12;\n    dir = normalize(dir) * rot;\n    ori = ori * rot;\n    ori.y -= map(ori) * 0.75 - 3.0;\n    \n    // tracing\n    vec3 p;\n    float t;\n    float dens = hftracing(ori,dir,p,t);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist)* (1e-1 / iResolution.x));\n             \n    // terrain\n    float ao = getAO(p);\n    vec3 color = terr_color(p,n,dir,dist) * SKY_COLOR;\n    color += vec3(diffuse(n,light,2.0) * SUN_COLOR);\n    color += vec3(specular(n,light,dir,20.0) * SUN_COLOR*0.4);\n    color *= ao;\n        \n    // fog\n    vec3 fog = sky_color(vec3(dir.x,0.,dir.z));\n    color = mix(color,fog,saturate(min(length(dist)*0.018, dot(p.xz,p.xz)*0.001)));\n    \n    // sky\n    color = mix(sky_color(dir),color,step(dens,4.0));\n    color += pow(max(dot(dir,light),0.0),3.0)*0.3;\n    \n    // wind\n#ifdef WIND\n    float wind = volume_tracing(ori,dir,t) * saturate(1.8 - p.y * 0.2);\n    color = mix(color,fog, wind * 1.6);\n#endif\n    \n    // post\n    //color = (1.0 - exp(-color)) * 1.5;\n    color = (color - 1.0) * 1.2 + 1.0;\n    color = pow(color * 0.8,vec3(1.0/2.2));\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llK3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llKGDm", "name": "repeat xyz", "author": "AEthyr", "description": "repeating signed distance functions as learned at https://www.youtube.com/watch?v=s8nFqwOho-s and http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/", "tags": ["3d", "sdf"], "likes": 2, "viewed": 506, "date": "1475036773", "time_retrieved": "2024-06-20T18:41:26.169385", "image_code": "/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat pMod(float t, float d) {\n    return mod(t + d/2.0, d) - d/2.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {    \n    // Slowly spin the whole scene\n    p = rotateY(iTime / 16.0) * p;\n    p.z = pMod(p.z, 4.8 + 4.8*(1.0+cos(iTime)));\n    p.y = pMod(p.y, 4.8 + 4.8*(1.0-sin(iTime)));\n    p.x = pMod(p.x, 4.8 + 4.8*(1.0+sin(iTime)));\n    \n    //float cylinderRadius = 0.4 + (2.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 4.0;\n    float cylinderRadius = 0.2;\n    float cylinderHeight = 5.0;\n    float cylinder1 = cylinderSDF(p, cylinderHeight, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * p, cylinderHeight, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * p, cylinderHeight, cylinderRadius);\n    \n    float cube = boxSDF(p, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(p, .2);\n    \n    //float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);\n    //float ballRadius = 0.3;\n    //float balls = sphereSDF(p - vec3(ballOffset, 0.0, 0.0), ballRadius);\n    //balls = unionSDF(balls, sphereSDF(p + vec3(ballOffset, 0.0, 0.0), ballRadius));\n    //balls = unionSDF(balls, sphereSDF(p - vec3(0.0, ballOffset, 0.0), ballRadius));\n    //balls = unionSDF(balls, sphereSDF(p + vec3(0.0, ballOffset, 0.0), ballRadius));\n    //balls = unionSDF(balls, sphereSDF(p - vec3(0.0, 0.0, ballOffset), ballRadius));\n    //balls = unionSDF(balls, sphereSDF(p + vec3(0.0, 0.0, ballOffset), ballRadius));\n    \n    \n    \n    float csgNut = differenceSDF(sphere,//intersectSDF(cube, sphere),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n    \n    //return unionSDF(balls, csgNut);\n    return unionSDF(cylinder1, unionSDF(cylinder2, cylinder3));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llKGDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llV3WR", "name": "Mandelbrot Set", "author": "10098", "description": "graphic representation of the mandelbrot set", "tags": ["fractal"], "likes": 0, "viewed": 106, "date": "1474233689", "time_retrieved": "2024-06-20T18:41:26.169385", "image_code": "precision highp float;\n\nvec2 f(vec2 x, vec2 c) {\n\treturn mat2(x,-x.y,x.x)*x + c;\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) ); /* thanks, iq */\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 c = vec2(-iResolution.x/iResolution.y + cos(iTime/4.0)/4.0, sin(iTime/4.0)/4.0) + abs(sin(iTime/8.0))*(uv * 4.0 - vec2(2.0));\n    vec2 x = vec2(0.0);\n    bool escaped = false;\n    int iterations = 0;   \n    for (int i = 0; i < 1000; i++) {\n        if (float(i) > 10.0 + abs(sin(iTime / 2.0)) * 40.0) break;\n        iterations = i;\n    \tx = f(x, c);\n        if (length(x) > 2.0) {\n            escaped = true;\n            break;\n        }\n    }\n\n\tfragColor =\n        escaped \n        \t? vec4(palette(float(iterations) / 50.0,  vec3(0.3, 0.2, 0.4), vec3(0.2, 0.1, 0.0), vec3(1.0), vec3(0.3,0.5,0.2)),1.0)\n        \t: vec4(0.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llV3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llV3WW", "name": "Warp Bubbles", "author": "vox", "description": "Warp Bubbles", "tags": ["warp", "bubbles"], "likes": 5, "viewed": 658, "date": "1474743649", "time_retrieved": "2024-06-20T18:41:27.018007", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E));\n\tvec2 b = sin(seedling+vec2(time, time*GR/E));\n\tvec2 c = sin(seedling+vec2(time, time*GR/E));\n\tvec2 d = sin(seedling+vec2(time, time*GR/E));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(zoom*(uv*2.0-1.0))*2.0*PI);\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    zoom = (2.5+2.0*sin(time));\n    \n    \n   \tconst int max_i = 5;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling += fract(float(i)*123456.123456);\n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        float weight = pow(ifs, 1.0/float(i+1));\n        ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        uv = next*weight+uv*(1.0-weight);\n        depth += ifs;\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = depth*PI*15.0;\n    float black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n        \n    \n    vec3 final = (\n        \t\t\t\tvec3(cos(depth*PI*2.0+shift),\n                \t  \t\tcos(4.0*PI/3.0+depth*PI*2.0+shift),\n                \t  \t\tcos(2.0*PI/3.0+depth*PI*2.0+shift)\n                 \t\t)*.5+.5\n        \t\t )*black\n        \t\t +white;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llV3WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llV3zz", "name": "p + h(p) practice.00", "author": "seeyouspace", "description": "Learning warp by practice", "tags": ["2d", "warp", "practice"], "likes": 0, "viewed": 114, "date": "1472920400", "time_retrieved": "2024-06-20T18:41:27.018007", "image_code": "#define CS(n) (0.5*cos(iTime*n) + 0.5)\n#define COS(n) cos(iTime*n)\n#define PI 3.1415926535897932384626\n\nvec3 cc(float x, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a + b*cos(2.0*PI*(c*x + d));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy *2.0 - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float l = length(p);\n    p.x += 0.05*sin(0.27*iTime + l*4.1);\n    \n    float w = smoothstep(CS(1.)*COS(0.5), CS(1.)*COS(0.5)+0.01, p.x);\n    \n    vec3 color = mix(vec3(0.8, 0.6, 0.1), vec3(1.0, 1.0, 0.0), p.x);\n    if (w < 0.1)\n        color = cc(p.x, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.1, 0.2, 0.3));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llV3zz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llVGDR", "name": "Prisoner Bulb", "author": "Aspect", "description": "I had to lock this bad boy up. I'll come back to fix the texture/colors at some point.", "tags": ["fractal", "mandelbulb", "distanceestimation", "geometricorbittraps"], "likes": 5, "viewed": 881, "date": "1474236587", "time_retrieved": "2024-06-20T18:41:28.818223", "image_code": "vec3 gradient=vec3(0.0);\n\n\n#define PI 3.1415926535\n#define oversample 0\n#define shadows 1\n\nvec3 whotrapped;\n\nfloat orbtrap=100000.0;\nfloat casez=0.;\n\nfloat opS( float d1, float d2 )\n{\n    return (-d2>d1)? -d2:d1;\n}\n\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\n\n\n\n\n//from iq's raymarching primitives\n\nvec2 box( vec3 p, vec3 b)\n{\n  //  mat4 rotmat=rotationMatrix(p,10.1*cos(iTime));\n  //  p=(rotmat*vec4(p,1.0)).xyz;\n //   b=b*2.;\n //   p=p*1.0;\n return vec2(length(max(abs(p)-b,0.0))-0.0,-44.0);\n}\n\n\nfloat shBox(vec3 p, vec3 b,float thickness)\n{\n float dist= opS(sdBox(p,b),sdBox(p+vec3(0.0,-p.y,0.0),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(0.0,p.y,0.0),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(p.x,0.0,0.0),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(-p.x,0.0,0.0),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(0.0,0.0,p.z),b/thickness));\n  dist= opS(dist,sdBox(p+vec3(0.0,0.0,-p.z),b/thickness));\n\n    \n\n    \n                return dist;\n}\n\nfloat mandel(vec3 pos)\n{\n    float dr=1.0;\n    pos=rotate(pos,cos(0.35*iTime),sin(0.35*iTime),0.0);\n    pos=pos*1.00;\n    float r=1.0;\n    vec3 zeta= pos;\n    vec3 w=pos;\n    float wr=2.0;\n    vec2 mdb=vec2(0.0);\n    vec3 c= vec3(0.0);\n    orbtrap=1.0;\n    \n    for(int i=0;i<10;++i)\n    {\n        w=rotate(w,cos(0.75*iTime),sin(0.75*iTime),0.0);\n      // w=w*(abs(cos(4.*iTime)/24.)+0.8);\n        //c=vec3(cos(iTime),sin(iTime),0.0);\n\n            wr=length(w);\n           if(wr*wr>2.)\n        {\norbtrap=float(i);\n            whotrapped=w;\n             break;\n        }\n          float wo = acos(w.y/wr);\n          float wi = atan(w.x,w.z);\n\n          dr= 8.0*pow(wr,7.0)*dr +1.;\n\n\n          wr = pow( wr, 7. );\n         // wr= wr*r + 10.*wr +1.;\n          wo = wo * 7.;\n          wi = wi * 7.;\n\n        \n          w.x = wr * sin(wo)*sin(wi);\n          w.y = wr * cos(wo);\n          w.z = wr * sin(wo)*cos(wi);\n        \t\n        \n       //  w.x = wr * cos(wo)*cos(wi);\n       //   w.y = wr * cos(wo)*sin(wi);\n       //  w.z = wr * sin(wo);\n        \t\n        \n       //  cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta)\n\n        w+=1.*pos;     \n\n    }\n    if(wr*wr<=14.)\n    {\n        float bboy1=    shBox(w,vec3(1.2),1.1)*pow(20.0,-orbtrap-0.0);\n        float bboy2=(1.00*0.5*log(wr)*wr/dr);\n        if(bboy1<bboy2)\n        {\n            casez=1.;\n         return bboy1;   \n        }\n        else\n        {\n            casez=2.;\n           return bboy2;\n        }\n        \n      \n      }\n    else{\n        casez=3.;\n     return   0.85*0.5*log(wr)*wr/dr;\n    }\n}\n\n\n\n\n\nfloat distfunc(vec3 pos)\n{  \n  //return min(box(pos,vec3(0.9,0.9,0.9)),mandel(pos));\n  return mandel(pos);\n //   return manDE(pos);\n\n}\n\nvec2 distfunc2(vec3 pos)\n{  \n  return box(pos,vec3(1.55,1.55,1.5));\n//  return mandel(pos);\n //   return manDE(pos);\n\n}\n\n\nvec3 rayMarch2(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 10; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist = distfunc2(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n\nvec3 rayMarch(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    dist.y=0.;\n    for (int i = 0; i < 170; i++)\n    {       \n        if ((dist.x < EPSILON))   continue;   \n        \n        dist.x = distfunc(pos);\n        dist.y+=dist.x;\n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\nvec3 shadMarch(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 30; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist.x= distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n//https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nvec3 calculateNormal(float EPSILON, vec3 pos,in vec2 dist)\n{\n  \tvec2 eps = vec2(0.0, EPSILON);\nvec3 normal = normalize(vec3(\n    distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n   distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n    distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n      \t//vec2 eps = vec2(0.0, EPSILON);\n//\tvec3 normal = normalize(vec3(\n  //  distfunc(pos + eps.yxx).x -dist.x,\n  // distfunc(pos + eps.xyx).x - dist.x,\n  //  distfunc(pos + eps.xxy).x - dist.x));\n    \n    return normal;\n}\n\n\n\nvoid getRay(vec2 screenPos,out vec3 cameraOrigin,out vec3 rayDir)\n{\n    cameraOrigin = vec3(0.0+0.0*cos(iTime), 0.0+0.0*sin(iTime), 1.35+0.2*cos(iTime));  \n    vec3 cameraTarget = vec3(0.0, 0.0, 1.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(cameraDir,upDirection));\n\tvec3 cameraUp = normalize(cross(cameraRight,cameraDir));\n    rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n   //rayDir=normalize(cameraDir+vec3(screenPos,0.0));\n                  \n\n\n}\n\n\nvec4 render(vec2 ScreenPos)\n{\n    vec3 rayDir=vec3(0.0);\n    vec3 pos=vec3(0.0);\n    getRay(ScreenPos,pos,rayDir);\n    \n \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0; \n    float EPSILON = 0.00085;\n    float totalDist = 0.0;\n    vec2 dist = vec2(EPSILON,0.0);\n    vec3 lightpos=vec3(5.0,5.0,5.0);\n\n    //initial march towards objects\n    vec3 dummypos=pos;\n \tpos=rayMarch2(dummypos,rayDir,EPSILON,dist);\n             if (dist.x <EPSILON)\n        {  \n               vec3 color=vec3(0.0);\n\n        vec2 dist = vec2(EPSILON,0.0);\n\n   \t\t\t pos=rayMarch(pos,rayDir,EPSILON,dist);\n   \t\t\t\t\n            \n            if (dist.x <EPSILON)\n     \t\t\t{  \n\n\t\t\n\n                EPSILON=0.00001;\n\n            // pos=pos-0.0001*rayDir;\n             vec3 normal=calculateNormal(EPSILON,pos,dist);\n\n\n            vec3  lightdir=   normalize(lightpos-pos);  \n            vec3 halfvec= normalize(lightdir-rayDir);\n            vec3 reflected= normalize(reflect(rayDir,normal));\n#if shadows\n\n                 //shadow ray \n            EPSILON=0.005;\n            vec2 shadowdist=vec2(EPSILON,dist.y);\n           vec3 shadowpos=shadMarch(pos+0.01*lightdir,lightdir,EPSILON,shadowdist);\n            if(shadowdist.x<EPSILON)\n            {\n                color=vec3(0.0,0.0,0.0);\n\n            }\n            else\n#endif                \n            {\n\n        \n        \n   \n        \n    float diffuse = max(0.0, dot(lightdir, normal));\n       \n    float specular = pow(dot(normal,halfvec), 32.0);\n        \n     \n\n                \n             vec3 texcol=texture(iChannel0,pos.xy).xyz;\n  \t\t\t color = vec3(0.5,0.75,0.5);\n                \n                if(casez==2.)\n                {\n                    color=mix(texcol*1.,color,0.0);\n                }\n                if(casez==3.)\n                {\n                    color=mix(texcol*1.,color,0.50);\n                }\n     \n                          \n                          color*=(diffuse + specular);\n\n                \n                  //  color *= clamp(2.0*dot(pos,pos),0.0,1.0);\n\t\t\t\t color *= exp( -0.5*dist.y );\n    \t\t}     \n             return vec4(color, 1.0);\n\n\t\t}\n            \n        \nelse{\n     vec3 bg=vec3(1.0,1.0,1.00);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.0*iTime)+1.55)))*bg;\n    return vec4(bg,1.0);\n}\n        }\n            else{\n                \n     vec3 bg=vec3(1.00,1.0,1.00);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.0*iTime)+1.55)))*bg;\n    return vec4(bg,1.0);\n            }\n            \n            \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{         \n\n \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n     screenPos.x *= iResolution.x / iResolution.y; \n\n    vec2 fc2=fragCoord.xy + vec2(-0.125, -0.375); \n\tvec2 fc3=fragCoord.xy + vec2(+0.375, -0.125);\n\tvec2 fc4=fragCoord.xy + vec2(+0.125, +0.375);\n    vec2 fc5=fragCoord.xy + vec2(-0.375, +0.125);\n    \n     vec2 scpos2=-1.0 +2.0*fc2.xy/iResolution.xy;\n     vec2 scpos3=-1.0 +2.0*fc3.xy/iResolution.xy;\n     vec2 scpos4=-1.0 +2.0*fc4.xy/iResolution.xy;\n     vec2 scpos5=-1.0 +2.0*fc5.xy/iResolution.xy;\n    \n    scpos2.x*=iResolution.x / iResolution.y;\n    scpos3.x*=iResolution.x / iResolution.y;\n    scpos4.x*=iResolution.x / iResolution.y;\n    scpos5.x*=iResolution.x / iResolution.y;\n    \n    \n  \n    fragColor=render(screenPos);\n    \n    \n#if oversample\n   fragColor+=render(scpos2)+render(scpos3)+render(scpos4);\n    fragColor/=4.;\n#endif\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llVGDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llVGzW", "name": "sosi-hypnocycles-1", "author": "sohale", "description": "sandbox, Just for practice\n\n** Click the mouse on the center and move around **", "tags": ["sandbox"], "likes": 1, "viewed": 94, "date": "1474979955", "time_retrieved": "2024-06-20T18:41:28.818223", "image_code": "float distrt(float x)\n{\n    for(int i=0;i<6;i++){\n        x = x*x;\n        x = 1.0-x;\n    }\n    return x;\n}\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float u = uv.x+iTime*0.05 + sin(uv.y*3.1415926536*2.0 * 8.0) * 0.02;\n    float red = distrt((sin(u * 3.1415*2.0*5.0)*0.5+0.5));\n    float green = uv.y;\n    float blue = 0.5+0.5*sin(iTime);\n    float alpha = 1.0;\n\tfragColor = vec4(red, green, blue, alpha);\n}\n\nfloat pi2 = 3.14159265*2.0;\n// vec2 mouse_change_detector = vec2(0,0);\nfloat t0 = 0.0; // 1820.0;\n\n/*\nClick around the shader screen to set the center.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 mouse = iMouse.xy;\n    \n    // mouse change (move) detection failed.\n    // float changex = (abs(floor(mouse_change_detector.x) - floor(mouse.x)) < 1.0)? 1.0: 0.0;\n    // float changey = (abs(floor(mouse_change_detector.y) - floor(mouse.y)) < 1.0)? 1.0: 0.0;\n    // float mchange = changex + changey;\n    // if (mchange > 0.0) {\n    //    t0 = iTime;\n    // }\n    // mouse_change_detector.x = mouse.x;\n    // mouse_change_detector.y = mouse.y;\n\n    \n    float t = iTime - t0;\n    t = t + t*t*0.02;\n\n    \n    \n    float dur = 2.0;\n    float anim1 = (t>0.0)?(t/dur):0.0;\n    anim1 = 1.0; // anim1>1.0?anim1:1.0;\n    // vec2 center=vec2(iResolution.x / 2.0, iResolution.y / 2.0);\n\n    vec2 mousekey = iMouse.zw;  // ?\n    vec2 mcenter = mouse;\n    float minwh = min(iResolution.x, iResolution.y);\n    vec2 normxy = vec2(minwh, minwh);\n\tvec2 uv = (fragCoord.xy - mcenter) / normxy; // - vec2(0.5,0.5);\n    float r = sqrt(uv.x*uv.x + uv.y*uv.y);\n    float th = atan(uv.y, uv.x);\n    \n    float grey = sin(((r + (log(r+1.0)*0.0) + t*0.08 ) *5.0 + (th/pi2)*anim1 ) * pi2);\n\n    float red = distrt(grey);\n    float green = distrt(grey); // * mchange;\n    float blue = distrt(grey); // +  changex*((abs(fragCoord.x - mouse.x) < 1.0)  ? 1.0 : 0.0);\n    float alpha = 1.0;\n\tfragColor = vec4(red, green, blue, alpha);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llVGzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lly3DD", "name": "F*ck yeah", "author": "koiava", "description": "F*ck yeah", "tags": ["fun"], "likes": 5, "viewed": 596, "date": "1474642594", "time_retrieved": "2024-06-20T18:41:28.824330", "image_code": "float theta(in float x) { return x > 0.0? 1.0 : 0.0; }\n\n//curve from https://www.wolframalpha.com/input/?i=f*ck+yeah+curve\nvec2 f(float t) {\n    float x = \n((-34.08 - (7.*sin(1.5576923076923077 - 11.*t))/27. - (151.*sin(1.5483870967741935 - 4.*t))/30. - (53.*sin(1.53125 - 3.*t))/37. + (5.*sin(4.666666666666667 + t))/18. + (59.*sin(1.5806451612903225 + 2.*t))/22. + (45.*sin(1.574468085106383 + 5.*t))/29. + \n        (19.*sin(1.8125 + 6.*t))/94. + (8.*sin(1.6041666666666667 + 7.*t))/15. + (10.*sin(1.625 + 8.*t))/33. + sin(3.8076923076923075 + 9.*t)/43. + (9.*sin(1.5909090909090908 + 10.*t))/28. + sin(1.6111111111111112 + 12.*t)/8.)*theta(31.*3.1415926 - t)*\n      theta(-27.*3.1415926 + t) + (119.99551569506727 - (8.*sin(1.5588235294117647 - 12.*t))/29. - (26.*sin(1.5675675675675675 - 10.*t))/43. - (218.*sin(1.5714285714285714 - 8.*t))/145. - (11.*sin(1.55 - 7.*t))/26. - (98.*sin(1.5625 - 6.*t))/29. - \n        (7.*sin(1.5666666666666667 - 3.*t))/8. + (56.*sin(1.5757575757575757 + t))/41. + 2.*sin(1.5675675675675675 + 2.*t) + (103.*sin(1.5789473684210527 + 4.*t))/27. + (30.*sin(1.5813953488372092 + 5.*t))/37. + (5.*sin(1.5833333333333333 + 9.*t))/29. + \n        (7.*sin(1.5897435897435896 + 11.*t))/29.)*theta(27.*3.1415926 - t)*theta(-23.*3.1415926 + t) + (103.89655172413794 - (13.*sin(1.564102564102564 - 11.*t))/30. - (11.*sin(1.5476190476190477 - 8.*t))/8. - (2059.*sin(1.565217391304348 - 3.*t))/57. - \n        (545.*sin(1.5666666666666667 - 2.*t))/44. + (132.*sin(1.6346153846153846 + t))/133. + (239.*sin(1.5769230769230769 + 4.*t))/24. + (35.*sin(1.6129032258064515 + 5.*t))/33. + (529.*sin(1.5714285714285714 + 6.*t))/265. + \n        (5.*sin(1.6129032258064515 + 7.*t))/19. + (47.*sin(4.708333333333333 + 9.*t))/36. + (109.*sin(1.59375 + 10.*t))/42. + (4.*sin(1.5434782608695652 + 12.*t))/7.)*theta(23.*3.1415926 - t)*theta(-19.*3.1415926 + t) + \n     (-46.758620689655174 - (514.*sin(1.5588235294117647 - 7.*t))/67. - (337.*sin(1.565217391304348 - 5.*t))/32. - (2905.*sin(1.5675675675675675 - t))/121. + (398.*sin(4.7105263157894735 + 2.*t))/59. + (1707.*sin(1.5789473684210527 + 3.*t))/31. + \n        (689.*sin(1.5806451612903225 + 4.*t))/25. + (521.*sin(1.5769230769230769 + 6.*t))/53. + (241.*sin(1.5833333333333333 + 8.*t))/107. + (19.*sin(4.708333333333333 + 9.*t))/11. + (249.*sin(1.5925925925925926 + 10.*t))/40. + \n        (28.*sin(4.709677419354839 + 11.*t))/33. + (85.*sin(1.6296296296296295 + 12.*t))/171.)*theta(19.*3.1415926 - t)*theta(-15.*3.1415926 + t) + \n     (30.44 - (11.*sin(1.55 - 11.*t))/39. - (3.*sin(1.53125 - 10.*t))/28. - (10.*sin(1.5555555555555556 - 9.*t))/19. - sin(1.2592592592592593 - 6.*t)/23. - (31.*sin(1.5625 - 5.*t))/21. - sin(1.0555555555555556 - 4.*t)/47. - \n        (141.*sin(1.5666666666666667 - 3.*t))/32. - (3039.*sin(1.5714285714285714 - t))/86. + (4.*sin(1.5454545454545454 + 2.*t))/25. + (33.*sin(4.711111111111111 + 7.*t))/47. + (3.*sin(1.52 + 8.*t))/31. + sin(1.4923076923076923 + 12.*t)/15.)*\n      theta(15.*3.1415926 - t)*theta(-11.*3.1415926 + t) + (-8.133333333333333 - (15.*sin(1.5454545454545454 - 2.*t))/43. + (1659.*sin(1.5689655172413792 + t))/13. + (193.*sin(1.565217391304348 + 3.*t))/28. + (77.*sin(1.5483870967741935 + 4.*t))/29. + \n        (74.*sin(1.56 + 5.*t))/47. + (164.*sin(1.55 + 6.*t))/63. + (25.*sin(1.5384615384615385 + 7.*t))/32. + (10.*sin(1.5625 + 8.*t))/7. + (23.*sin(1.5517241379310345 + 9.*t))/61. + (13.*sin(1.5625 + 10.*t))/35. + (19.*sin(1.6071428571428572 + 11.*t))/94. + \n        sin(3.6875 + 12.*t)/185.)*theta(11.*3.1415926 - t)*theta(-7.*3.1415926 + t) + (-32.00574712643678 - (131.*sin(1.5333333333333334 - 11.*t))/41. - sin(1.3076923076923077 - 10.*t)/4. - (315.*sin(1.558139534883721 - 9.*t))/86. - \n        (79.*sin(1.511111111111111 - 8.*t))/36. - (416.*sin(1.5555555555555556 - 7.*t))/31. - (758.*sin(1.5666666666666667 - 5.*t))/25. - (3913.*sin(1.5689655172413792 - 3.*t))/36. - (2955.*sin(1.5694444444444444 - 2.*t))/37. + \n        (13436.*sin(1.5714285714285714 + t))/77. + (192.*sin(1.5714285714285714 + 4.*t))/29. + (23.*sin(1.5789473684210527 + 6.*t))/7. + (16.*sin(1.5319148936170213 + 12.*t))/21.)*theta(7.*3.1415926 - t)*theta(-3.*3.1415926 + t) + \n     (-104.05 + (4101.*sin(1.5555555555555556 + t))/13. + (769.*sin(4.708333333333333 + 2.*t))/57. + (1058.*sin(1.525 + 3.*t))/19. + (1973.*sin(1.505050505050505 + 4.*t))/28. + (349.*sin(4.566666666666666 + 5.*t))/87. + \n        (314.*sin(4.633333333333334 + 6.*t))/13. + (7.*sin(2.5076923076923077 + 7.*t))/18. + (611.*sin(4.594594594594595 + 8.*t))/31. + (11.*sin(4.3 + 9.*t))/9. + (307.*sin(1.434782608695652 + 10.*t))/30. + (114.*sin(4.571428571428571 + 11.*t))/25. + \n        (26.*sin(1.3375 + 12.*t))/21.)*theta(3.*3.1415926 - t)*theta(3.1415926 + t))*theta(sqrt(sign(sin(t/2.))));\n\n    float y = \n    ((166.78571428571428 - (2.*sin(1.3902439024390243 - 11.*t))/27. - (25.*sin(1.542857142857143 - 10.*t))/62. - (24.*sin(1.553191489361702 - 3.*t))/11. + (29.*sin(4.705882352941177 + t))/37. + (5.*sin(1.4411764705882353 + 2.*t))/41. + \n        (13.*sin(1.6111111111111112 + 4.*t))/14. + (131.*sin(1.6071428571428572 + 5.*t))/45. + (38.*sin(1.6666666666666667 + 6.*t))/49. + (41.*sin(1.605263157894737 + 7.*t))/38. + sin(3.85 + 8.*t)/20. + (9.*sin(1.6129032258064515 + 9.*t))/10. + \n        (7.*sin(1.68 + 12.*t))/30.)*theta(31.*3.1415926 - t)*theta(-27.*3.1415926 + t) + (134.32432432432432 - (8.*sin(1.565217391304348 - 10.*t))/29. - (48.*sin(1.5625 - 6.*t))/37. - (211.*sin(1.564102564102564 - 5.*t))/47. - \n        (137.*sin(1.5666666666666667 - 2.*t))/73. + (8.*sin(1.558139534883721 + t))/23. + (23.*sin(1.5833333333333333 + 3.*t))/18. + (12.*sin(1.588235294117647 + 4.*t))/17. + (29.*sin(1.59375 + 7.*t))/39. + (7.*sin(4.6976744186046515 + 8.*t))/33. + \n        sin(1.565217391304348 + 9.*t)/3. + (2.*sin(1.5555555555555556 + 11.*t))/31. + (6.*sin(4.708333333333333 + 12.*t))/41.)*theta(27.*3.1415926 - t)*theta(-23.*3.1415926 + t) + \n     (152.27272727272728 - (11.*sin(1.5161290322580645 - 12.*t))/31. - (730.*sin(1.5675675675675675 - t))/23. + (733.*sin(1.574468085106383 + 2.*t))/51. + (141.*sin(1.5769230769230769 + 3.*t))/23. + (109.*sin(1.5757575757575757 + 4.*t))/14. + \n        (105.*sin(1.5769230769230769 + 5.*t))/19. + (18.*sin(1.553191489361702 + 6.*t))/19. + (10.*sin(1.53125 + 7.*t))/33. + (55.*sin(1.5806451612903225 + 8.*t))/26. + (29.*sin(1.5769230769230769 + 9.*t))/28. + (44.*sin(1.5769230769230769 + 10.*t))/35. + \n        (37.*sin(1.5769230769230769 + 11.*t))/59.)*theta(23.*3.1415926 - t)*theta(-19.*3.1415926 + t) + (183.81578947368422 - (11.*sin(1.5573770491803278 - 9.*t))/19. - (259.*sin(1.564102564102564 - 3.*t))/39. - (1257.*sin(1.5675675675675675 - t))/41. + \n        (40.*sin(1.565217391304348 + 2.*t))/19. + (124.*sin(1.5833333333333333 + 4.*t))/29. + (311.*sin(1.5833333333333333 + 5.*t))/41. + (61.*sin(1.6111111111111112 + 6.*t))/43. + (301.*sin(1.5862068965517242 + 7.*t))/47. + (16.*sin(4.7 + 8.*t))/27. + \n        (7.*sin(1.5909090909090908 + 10.*t))/6. + (31.*sin(1.608695652173913 + 11.*t))/27. + (21.*sin(1.6216216216216217 + 12.*t))/31.)*theta(19.*3.1415926 - t)*theta(-15.*3.1415926 + t) + \n     (69.72727272727273 - (3.*sin(1.5694444444444444 - 10.*t))/11. + (178.*sin(1.5714285714285714 + t))/19. + (5.*sin(1.5714285714285714 + 2.*t))/11. + (13.*sin(4.705882352941177 + 3.*t))/28. + sin(1.5970149253731343 + 4.*t)/23. + \n        sin(4.669902912621359 + 5.*t)/64. + sin(1.6046511627906976 + 6.*t)/28. + (6.*sin(1.5609756097560976 + 7.*t))/35. + sin(1.565217391304348 + 8.*t)/6. + (8.*sin(4.709677419354839 + 9.*t))/31. + sin(1.5625 + 11.*t)/16. + \n        (4.*sin(1.565217391304348 + 12.*t))/33.)*theta(15.*3.1415926 - t)*theta(-11.*3.1415926 + t) + (93.6842105263158 - (79.*sin(1.5689655172413792 - 11.*t))/32. + (1109.*sin(4.7105263157894735 + t))/55. + (934.*sin(4.709677419354839 + 2.*t))/35. + \n        (71.*sin(4.702702702702703 + 3.*t))/23. + (186.*sin(4.703703703703703 + 4.*t))/35. + (49.*sin(4.689655172413793 + 5.*t))/32. + (27.*sin(1.6153846153846154 + 6.*t))/43. + (34.*sin(4.702702702702703 + 7.*t))/15. + \n        (29.*sin(1.5862068965517242 + 8.*t))/23. + (59.*sin(4.7105263157894735 + 9.*t))/26. + (35.*sin(1.5789473684210527 + 10.*t))/27. + (25.*sin(1.5789473684210527 + 12.*t))/23.)*theta(11.*3.1415926 - t)*theta(-7.*3.1415926 + t) + \n     (24.096774193548388 - (6686.*sin(1.5692307692307692 - 2.*t))/35. + (1829.*sin(4.7105263157894735 + t))/28. + (473.*sin(1.5769230769230769 + 3.*t))/14. + (142.*sin(1.5714285714285714 + 4.*t))/23. + (400.*sin(1.5675675675675675 + 5.*t))/27. + \n        (13.*sin(1.5555555555555556 + 6.*t))/10. + (149.*sin(1.5625 + 7.*t))/38. + (105.*sin(1.5757575757575757 + 8.*t))/34. + (12.*sin(1.6111111111111112 + 9.*t))/7. + sin(0.6923076923076923 + 10.*t)/26. + (22.*sin(1.596774193548387 + 11.*t))/9. + \n        (13.*sin(4.68 + 12.*t))/14.)*theta(7.*3.1415926 - t)*theta(-3.*3.1415926 + t) + (-330.44117647058823 + (40.*sin(1.8571428571428572 + t))/37. + (8754.*sin(4.681818181818182 + 2.*t))/103. + (1769.*sin(1.5454545454545454 + 3.*t))/72. + \n        (883.*sin(4.653846153846154 + 4.*t))/15. + (2161.*sin(4.638297872340425 + 5.*t))/34. + (2791.*sin(1.4827586206896552 + 6.*t))/47. + (803.*sin(1.4642857142857142 + 7.*t))/16. + (106.*sin(4.571428571428571 + 8.*t))/13. + (451.*sin(4.6 + 9.*t))/27. + \n        (69.*sin(4.576923076923077 + 10.*t))/7. + (919.*sin(1.4423076923076923 + 11.*t))/153. + (212.*sin(1.4166666666666667 + 12.*t))/39.)*theta(3.*3.1415926 - t)*theta(3.1415926 + t))*theta(sqrt(sign(sin(t/2.))));\n    return vec2(x, y);\n}\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n#define STEPS 64\nfloat rad = 4.0;\n\nfloat getDist2(in vec2 fragCoord, float p) {\n    vec2 uv = (fragCoord.xy / iResolution.xy)*vec2(320, 240);\n    float t = p*(32.0*3.1415926);\n    vec2 xy = f(t);\n    \n    if(dot(xy,xy) < 0.001){\n        return 1000.0;\n    }\n        \n    xy *= 0.3;\n    xy += vec2(160.0, 140.0);\n    vec2 v = uv-xy;\n    return dot(v, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    for(int i=0; i<STEPS; i++) {\n        float d2 = getDist2(fragCoord, (float(i)+rnd())/float(STEPS));\n        if(d2 < rad*rad) {\n        \tfloat d = sqrt(d2);\n            color = vec3(1.0, 1.0, 1.0)*((rad - d)/rad);\n            break;\n        }\n    }\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lly3DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lly3Wz", "name": "raymarching-16091702", "author": "francisco", "description": "cone intersetion", "tags": ["raymarching"], "likes": 0, "viewed": 70, "date": "1474125706", "time_retrieved": "2024-06-20T18:41:29.375851", "image_code": "float sdFloor(vec3 p){\n    return p.y;\n}\nfloat plane(vec3 p,vec3 po,vec3 n){\n    n=normalize(n);\n    vec3 dp=po-p;\n    return dot(dp,n);\n}\nfloat sphere(vec3 p,float r){\n    return length(p)-r;\n}\nfloat line(vec3 p,vec3 po,vec3 n){\n    n=normalize(n);\n    vec3 dp=po-p;\n    vec3 prj_dp=dot(n,dp)*n;\n    vec3 d=dp-prj_dp;\n    return length(d);\n}\nfloat cylinder(vec3 p,vec3 po,vec3 n,float r){\n    return line(p,po,n)-r;\n}\nfloat cone(vec3 p,vec3 po,vec3 n,float dr){\n    n=normalize(n);\n    vec3 dp=po-p;\n    vec3 prj_dp=dot(n,dp)*n;\n    float r=length(prj_dp)*dr;\n    vec3 d=dp-prj_dp;\n    return length(d)-r;\n}\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat map(vec3 p){\n    vec3 q=fract(p)*2.0-1.0;\n    float dl0=cone(p,vec3( 1.0,0.0,0.0),vec3(-1.0,1.0,0.0),0.5);\n    float dl1=cone(p,vec3(-1.0,0.0,0.0),vec3( 1.0,1.0,0.0),0.5);\n    float dc=cylinder(p,vec3(0,0,0),vec3(1,0,0),0.2);\n    return opI(dl0,dl1);\n}\nvec3 grad(vec3 p){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    float d=map(p);\n\tvec3 g = vec3(\n\t    map(p+eps.xyy) - d,\n\t    map(p+eps.yxy) - d,\n\t    map(p+eps.yyx) - d );\n\treturn g;\n}\nfloat trace(vec3 o,vec3 r){\n    float t=0.0;\n    for(int i=0;i<128;i++){\n        vec3 p=o+r*t;\n        float d=map(p);\n        t+=d*0.95;\n    }\n    return t;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = iTime;\n\n\t// camera\t\n\tvec3 ro = vec3(3.5*cos(0.1*time + 6.0*mo.x), 4.0 - 4.0*mo.y, 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0.0, .0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.0) );\n    vec3 r=normalize(vec3(uv,1.0));\n    float the=iTime;\n    //r.xz*=mat2(cos(the),-sin(the),sin(the),cos(the));\n    vec3 o=vec3(0.0,0.0,-3);\n    float t=trace(ro,rd);\n    vec3 p=ro+rd*t;\n    vec3 l=normalize(vec3(0.0,1.0,-1.0));\n    vec3 n=normalize(grad(p));\n    float dif=dot(l,n);\n    float fog=1.0/(1.0+t*t*0.1);\n    //vec3 fc=vec3(fog);\n    vec3 fc=vec3(dif,dif,0.0);\n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lly3Wz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llyGzy", "name": "Glitchy rainbow pixels", "author": "hawthornbunny", "description": "Experimenting with deresing and sine waves", "tags": ["rainbow", "glitchy", "pixels"], "likes": 9, "viewed": 225, "date": "1475173350", "time_retrieved": "2024-06-20T18:41:29.375851", "image_code": "float deres( float value, int res ) {\n    return floor(value / float(res)) * float(res);\n}\n\nvec2 deres( vec2 vector, int res) {\n    return vec2(deres(vector.x, res), deres(vector.y, res));\n}\n\nint modfloor( float value, float m ) {\n    return int(mod(floor(value), m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int res = (modfloor(iTime,5.0)+1) * (modfloor(iTime, 7.0)+1);\n    \n\tvec2 uv = deres(fragCoord.xy, res) / iResolution.xy;\n    float v = uv.x + uv.y;\n\tfragColor = vec4(\n        abs(sin((v+1.0)*iTime)),\n        abs(sin((v+2.0)*iTime)),\n        abs(sin((v+3.0)*iTime)),\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llyGzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsS3Dz", "name": "Wavey Day", "author": "sonofbryce", "description": "learning something new", "tags": ["wave"], "likes": 0, "viewed": 342, "date": "1473451282", "time_retrieved": "2024-06-20T18:41:29.375851", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 r =  2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 colorTop = vec3(1.0, 0.0, 0.0); // red\n    vec3 colorBottom = vec3(0.0, 0.0, 1.0); // blue\n    vec3 colorDeep = vec3(0.0, 0.0, 0.6); // blue darker\n    vec3 colorSurface = vec3(0.4, 0.8, 0.8); // lighter\n    vec3 colorClouds = vec3(0.6, 0.0, 0.0); \n    \n    float cloudPoint = 0.7 + cos((r.x * 1.5) - (iTime * 0.25) ) * 0.05;\n    cloudPoint += sin( (14.0 * r.x) - (iTime * 1.5)  ) * 0.02;\n    cloudPoint += cos( (4.0 * r.x) - (iTime * 0.5)  ) * 0.05;\n    \n    float midPoint = sin(r.x + (iTime * 5.0) ) * 0.3;\n    midPoint += sin( (10.0 * r.x) + (iTime * 20.0) ) * 0.05;\n    \n    float darkWavePoint = -0.2 + sin(r.x + (iTime * 3.0) ) * 0.2;\n    darkWavePoint += sin( (20.0 * r.x) + (iTime * 20.0) ) * 0.015;\n    \n    float surfaceOffset = 0.2;\n    \n    vec3 pixel;\n    float alpha = 1.0;\n    \n    \n    if (r.y >= cloudPoint)\n    {\n        pixel = colorClouds;\n        //pixel = colorTop; \n    }\n    else if (r.y >= midPoint)\n    {\n        if (r.y > darkWavePoint + surfaceOffset)\n        {\n          pixel = colorTop;  \n        }\n        else\n        {\n            pixel = colorSurface;\n        }\n    }\n    else if (r.y >= darkWavePoint)\n    {\n        pixel = colorDeep;\n    }\n    else\n    {\n        pixel = colorBottom;\n        \n    }\n    \n    fragColor = vec4(pixel, alpha);\n        \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsS3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGGDm", "name": "Super Awesome IFS", "author": "vox", "description": "Super Awesome IFS", "tags": ["superawesomeifs"], "likes": 5, "viewed": 533, "date": "1474924389", "time_retrieved": "2024-06-20T18:41:30.078781", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define circle(x) (vec2(cos(x),sin(x)))\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nmat3 jacobian(vec3 x[8], vec3 q)\n{\n\tvec3 f0 = (x[7] + x[6] + x[5] + x[4] + x[3] + x[2] + x[1] + x[0]) * 0.125;\t\n\tvec3 f1 = (x[7] - x[6] + x[5] - x[4] + x[3] - x[2] + x[1] - x[0]) * 0.125;\n\tvec3 f2 = (x[7] + x[6] - x[5] - x[4] + x[3] + x[2] - x[1] - x[0]) * 0.125;\n\tvec3 f3 = (x[7] + x[6] + x[5] + x[4] - x[3] - x[2] - x[1] - x[0]) * 0.125;\n\tvec3 f4 = (x[7] - x[6] - x[5] + x[4] + x[3] - x[2] - x[1] + x[0]) * 0.125;\n\tvec3 f5 = (x[7] - x[6] + x[5] - x[4] - x[3] + x[2] - x[1] + x[0]) * 0.125;\n\tvec3 f6 = (x[7] + x[6] - x[5] - x[4] - x[3] - x[2] + x[1] + x[0]) * 0.125;\n\tvec3 f7 = (x[7] - x[6] - x[5] + x[4] - x[3] + x[2] + x[1] - x[0]) * 0.125;\n\n\tfloat a=q.x;\n\tfloat b=q.y;\n\tfloat g=q.z;\n\t\t\n\tvec3 f = f0      + f1*a     + f2*b     + f3*g     +\n\t\t\tf4*(a*b) + f5*(a*g) + f6*(b*g) + f7*(a*b*g);\n\t\n\tmat3 M;\n\tM[0]=   (f1 + f4*b + f5*g + f7*(b*g));\n\tM[1]=\t(f2 + f4*a + f6*g + f7*(a*g));\n\tM[2]=\t(f3 + f5*a + f6*b + f7*(a*b));\n\t\n\treturn M;\n}\n\nvec3 storage[8];\n\nvoid load_cube(out vec3[8] corners)\n{\n\tfloat t_corner=1e10;\n\tvec3 c_corner=vec3(0);\n\tfor (int k=0; k<2; k++)\n\t{\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tfor (int i=0; i<2; i++)\n\t\t\t{\n\t\t\t\tvec3 x = vec3(i,j,k)*2.-1.;\n\t\t\t\tcorners[k*4+j*2+i]=x;\n\t\t\t}\t\n\t\t}\n\t}\n}\n\nfloat det(mat3 m)\n{\n\tvec3 a;\n\ta=cross(m[0],m[1]);\t\n\tfloat det = dot(a,m[2]);\n\treturn det;\n}\n\nfloat determinate;\n\nvec3 transform1(vec3 p, vec3[8] frust)\n{\n    const int volume_count = 8;\n    \n    for(int i = 0; i < volume_count; i++)\n    {\n        float iteration = float(i)/float(volume_count);\n        \n        vec3 f = flux((time*iteration*2.0*PI)+p.x+p.y+p.z)*2.0-1.0;\n        \n        storage[i].x += f.x/10.0;\n        storage[i].y += f.y/10.0;\n        storage[i].z += f.z/10.0;\n    }\n    \n    mat3 j = jacobian(storage, p);\n    determinate = det(j);\n    return p*j;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 p = vec3(uv, 0.0)*2.0-1.0;\n    p.z = (sqrt(2.0)-length(p.xy))/sqrt(2.0);\n    \n    load_cube(storage);\n\n    float ifs = 1.0;\n    \n    const int max_i = 8;\n    \n    vec3 d = sqrt(3.0)/vec3(iResolution.xy, max(iResolution.x, iResolution.y));\n    vec3 d1 = d * vec3(0.0, 0.0, 0.0);\n    vec3 d2 = d * vec3(1.0, 0.0, 0.0);\n    vec3 d3 = d * vec3(0.0, 1.0, 0.0);\n    \n    for(int i = 0; i < max_i; i++)\n    {\n   \t\tvec3 p3 = (transform1(p+d3, storage));\n   \t\tvec3 p2 = (transform1(p+d2, storage));\n   \t\tvec3 p1 = (transform1(p+d1, storage));\n        \n        float v = length(cross(p2-p1, p3-p1).z/d.x/d.y);\n        \n        ifs /= v;\n        \n   \t\tp = saw(p1);\n    }\n    \n    ifs = pow(ifs, 1.0/float(max_i));\n    \n    fragColor = vec4(p, 1.0)*ifs;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGGDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltGGRD", "name": "Raymarch first test", "author": "otah007", "description": "First raymarch shader, quite pleased I managed to get anything on the screen at all!", "tags": ["raymarch"], "likes": 0, "viewed": 76, "date": "1473504333", "time_retrieved": "2024-06-20T18:41:31.436639", "image_code": "#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 20.0\n#define MAX_STEPS 100\n#define EPSILON 0.01\n#define DISTANCE_BIAS 0.95\n#define RECURSION_LIMIT 4\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530717958647692\n\nfloat ssphere(vec3 position, float radius)\n{\n    return length(position) - radius;\n}\n\nfloat ubox(vec3 position, vec3 dimensions)\n{\n    return length(max(abs(position) - dimensions, 0.0));\n}\n\nfloat uroundbox(vec3 position, vec3 dimensions, float roundness)\n{\n    return length(max(abs(position) - dimensions, 0.0)) - roundness;\n}\n\nfloat storus(vec3 position, vec2 torus)\n{\n    vec2 q = vec2(length(position.xz) - torus.x, position.y);\n    return length(q) - torus.y;\n}\n\nfloat splane(vec3 position, vec4 normal)\n{\n    return dot(position, normal.xyz) + normal.w;\n}\n\nfloat ucube(vec3 position, float len)\n{\n    return ubox(position, vec3(len, len, len));\n}\n\nvec3 repeat(vec3 position, vec3 repeat)\n{\n    position = mod(position, repeat) - 0.5 * repeat;    \n    return position;\n}\n\nstruct object\n{\n    vec3 transform;\n    vec3 repeat;\n    float material;\n    int primitive;\n    vec4 data;\n};\n\nconst int n = 5;\nobject objects[5];\n\nvec2 scene(vec3 position)\n{   \n    vec2 result = vec2(FAR_CLIPPING_PLANE, 0.0);\n    \n    for (int i = 0; i < n; ++i)\n    {\n        object o = objects[i];\n        vec3 p = repeat(position - o.transform, o.repeat);\n        float d = 0.0;\n        \n        if (o.primitive == 0)\n            d = ssphere(p, o.data.x);\n        else if (o.primitive == 1)\n            d = ubox(p, o.data.xyz);\n\t\telse if (o.primitive == 2)\n            d = uroundbox(p, o.data.xyz, o.data.w);\n\t\telse if (o.primitive == 3)\n            d = storus(p, o.data.xy);\n\t\telse if (o.primitive == 4)\n            d = splane(p, o.data);\n        else\n            d = FAR_CLIPPING_PLANE;\n        \n        if (d < result.x)\n        {\n            result.x = d;\n            result.y = objects[i].material;\n        }\n    }\n    \n    return result;\n}\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float totalDistance = NEAR_CLIPPING_PLANE;\n    \n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec2 result = scene(position + totalDistance * direction);\n        \n        if (result.x < EPSILON)\n            return vec2(totalDistance, result.y);\n        \n        totalDistance += result.x * DISTANCE_BIAS;\n        \n        if (totalDistance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    \n    return vec2(FAR_CLIPPING_PLANE, 0.0);\n}\n\nfloat shadow(vec3 origin, vec3 objectPos, float mint, float k)\n{\n    float result = 1.0;\n    vec3 direction = normalize(objectPos - origin);\n    float t = mint;\n    float maxt = abs(length(origin - objectPos)) - 0.1;\n    \n   for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float r = scene(origin + direction * t).x;\n        \n        if (r < EPSILON)\n            return 0.0;\n        \n        result = min(result, k * r / t);\n        \n        if (t + r > maxt)\n            return result;\n        \n        t += r * DISTANCE_BIAS;\n    }\n    \n    return result;\n}\n\nfloat ao(vec3 origin, vec3 norm)\n{\n    float ao = 1.0;\n   \t\n    for (int i = 0; i < 5; ++i)\n    {\n        float d1 = 0.02 * float(i) * float(i);\n        float d2 = scene(origin + norm * d1).x;\n        ao -= (d1 - d2);\n    }\n    \n    return ao;\n}\n\nvec3 normal(vec3 position, float smoothness)\n{\n    vec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(position + dn.xyy).x - scene(position - dn.xyy).x;\n\tn.y\t= scene(position + dn.yxy).x - scene(position - dn.yxy).x;\n\tn.z\t= scene(position + dn.yyx).x - scene(position - dn.yyx).x;\n\treturn normalize(n);\n}\n\nvec3 rotateX(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = vec.x;\n    v.y = (vec.y * cos(angle)) - (vec.z * sin(angle));\n    v.z = (vec.y * sin(angle)) + (vec.z * cos(angle));\n    return v;\n}\n\nvec3 rotateY(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = (vec.x * cos(angle)) + (vec.z * sin(angle));\n    v.y = vec.y;\n    v.z = (-vec.x * sin(angle)) + (vec.z * cos(angle));\n    return v;\n}\n\nvec3 rotateZ(vec3 vec, float angle)\n{\n    vec3 v;\n    v.x = (vec.x * cos(angle)) - (vec.y * sin(angle));\n    v.y = (vec.x * sin(angle)) + (vec.y * cos(angle));\n    v.z = vec.z;\n    return v;\n}\n\nvec3 materialToColour(float colour)\n{\n    if (colour == 0.0)\n        return vec3(0.7, 0.7, 0.7);\n    if (colour == 1.0)\n        return vec3(1.0, 0.0, 0.0);\n    if (colour == 2.0)\n        return vec3(0.0, 1.0, 0.0);\n   \tif (colour == 3.0)\n        return vec3(0.0, 0.0, 1.0);\n    if (colour == 4.0)\n        return vec3(1.0, 0.0, 1.0);\n    else\n        return vec3(0.0, 0.0, 0.0);\n}\n\n\nvec3 getFinalColour(vec3 intersection, vec3 norm)\n{\n    vec3 light = vec3(0.0, 3.0, -1.0);\n    vec3 lightDir = normalize(light - intersection);\n    vec3 intensity = vec3(1.0, 1.0, 1.0);\n    vec3 lambert = dot(norm, lightDir) * intensity;\n    float i = shadow(light, intersection, 0.5, 48.0);\n    float amb = ao(intersection, norm);\n\treturn lambert * i * amb;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 direction = normalize(vec3(uv, 2.5));\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse.x = mouse.x * 2.0 - 1.0;\n    mouse.y = mouse.y * 2.0 - 1.0;\n    vec3 cameraOrigin = vec3(0.0, 0.0, -10.0);\n    cameraOrigin = rotateX(cameraOrigin, mouse.y * TWO_PI * 0.5);\n    cameraOrigin = rotateY(cameraOrigin, mouse.x * TWO_PI);\n    direction = rotateX(direction, mouse.y * TWO_PI * 0.5);\n    direction = rotateY(direction, mouse.x * TWO_PI);\n    \n    objects[0].transform = vec3(0.0, 0.0, 0.0);\n    objects[0].repeat = vec3(0.0, 0.0, 0.0);\n    objects[0].material = 1.0;\n    objects[0].primitive = 0;\n    objects[0].data = vec4(1.0, 0.0, 0.0, 0.0);\n    \n    objects[1].transform = vec3(0.0, 0.5, 0.5);\n    objects[1].repeat = vec3(0.0, 0.0, 0.0);\n    objects[1].material = 2.0;\n    objects[1].primitive = 1;\n    objects[1].data = vec4(0.5, 0.25, 0.2, 0.05);\n    \n    objects[2].transform = vec3(0.0, -1.0 * sin(iTime), 0.0);\n    objects[2].repeat = vec3(2.5, 0.0, 2.5);\n    objects[2].material = 3.0;\n    objects[2].primitive = 3;\n    objects[2].data = vec4(0.5, 0.15, 0.0, 0.0);\n    \n    objects[3].transform = vec3(0.0, -4.0, 0.0);\n    objects[3].repeat = vec3(0.0, 0.0, 0.0);\n    objects[3].material = 4.0;\n    objects[3].primitive = 4;\n    objects[3].data = vec4(0.0, 1.0, 0.0, 0.0);\n    \n    objects[4].transform = vec3(0.0, 1.2, 0.8);\n    objects[4].repeat = vec3(0.0, 0.0, 0.0);\n    objects[4].material = 2.0;\n    objects[4].primitive = 0;\n    objects[4].data = vec4(0.4, 0.0, 0.0, 0.0);\n    \n    vec2 result;\n    vec3 materialColour;\n    vec3 intersection = cameraOrigin;\n    vec3 norm = direction;\n    vec3 colour = vec3(1.0, 1.0, 1.0);\n    \n    for (int i = 0; i < RECURSION_LIMIT; ++i)\n    {\n        result = raymarch(intersection, norm);\n        \n        if (result.y == 0.0)\n            break;\n        \n        materialColour = materialToColour(result.y);\n        intersection = intersection + norm * result.x;\n        norm = normal(intersection, 0.01);\n        colour *= getFinalColour(intersection, norm);\n    }\n    \n    colour *= materialColour;\n    \n    fragColour = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltGGRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltV3Rm", "name": "city", "author": "FabriceNeyret2", "description": "A very simple city map (american suburb like :-) ).", "tags": ["procedural", "short"], "likes": 2, "viewed": 974, "date": "1473953688", "time_retrieved": "2024-06-20T18:41:31.436639", "image_code": "#define rnd(v) (2.*fract(4521.7*sin(dot(v,vec2(131,1743.1))))-1.)\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n\tU = U/iResolution.y - vec2(0,.3*iTime);\n    \n    vec2 V = (2.*fract(U*2.)-1.)*1.2, // pos in block\n         T=floor(U*2.),               // block index\n         D = abs(V),N;\n    float a = max(D.x,D.y), l,\n          b = fract(100.*length(3e2+T)), m = b<.2 ? 0. : 1.; // type of block\n\n    if (a > 1.) {                     // --- street\n        O = vec4(0,0,.6,1); \n        if (a>1.19 && min(D.x,D.y)<.96 ) O += step(cos(63.*min(D.x,D.y)),0.);\n        return; \n    }\n    \n    O =  a+1.-m<.86 ? vec4(0,.7,0,1) : a<.98 ? vec4(.5) : O-O; // block color / border\n    \n    V *= 3.5;                         // --- houses\n    N = floor(V+.5);                  // house index \n    D = abs(N); a = max(D.x,D.y); \n    if (a == 2.) {                    // crown in block\n        D = abs(2.*fract(3.5+V+m*.2*rnd(N+T))-1.)*(1.1+.6*m); // house pos\n        a = max(D.x,D.y);\n        O =  a<.95 ? m<1.?vec4(.8):vec4(1,0,0,1) : a<1. ? O-O : O;    \n    }\n    if (b+1.-m>.7 && dot(V,V)<2.) {   // --- block pond or trees\n        a=0.; for(int i=0; i<4; i++) \n            l = length(V-.2*vec2(rnd(N+T),rnd(N+T+.3))), \n            a += b<.9 ? l : 1./l;\n        if (a<4.) O = m<1.||b<.8 ?vec4(0,.4,0,1):vec4(0,0,1,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltV3Rm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltV3Rz", "name": "Surveillance", "author": "Virgill", "description": "Dusty menger scene from my 4k intro Surveillance\n\nhttps://www.youtube.com/watch?v=kiE2c06EzBQ\nhttp://www.pouet.net/prod.php?which=67120", "tags": ["raymarching", "4k", "demoscene", "menger", "density", "coc"], "likes": 42, "viewed": 1351, "date": "1472895979", "time_retrieved": "2024-06-20T18:41:32.382081", "image_code": "//**********************************************************************************\n// dusty menger scene from my 4k intro Surveillance\n// Virgill 2016\n// https://www.youtube.com/watch?v=kiE2c06EzBQ\n// http://www.pouet.net/prod.php?which=67120\n//**********************************************************************************\n\n// circle of confusion idea by eiffie\n// more interesting menger by shane\nfloat focalDistance=20.;\nfloat aperature=.04;\nfloat fudgeFactor=.9; \nfloat shadowCone=.5;\nvec4 orbitTrap = vec4(0.);\nfloat blend =0.;\nfloat d = 0.;\nfloat m = 0.;\nvec3 pcoc = vec3(0.);\nfloat rCoC,h;\nvec4 col=vec4(0.);\t\nfloat pixelSize;\n\n// coc (eiffie)\nfloat CircleOfConfusion(float t)\n{ \nreturn max(abs(focalDistance-t)*aperature,pixelSize*(1.0+t));\n}\n\n// linestep (knighty)\nfloat linstep(float a, float b, float t)\n{\n    float v=(t-a)/(b-a);\n    return clamp(v,0.,1.);\n}\n\nvec3 rotXaxis(vec3 p, float rad)\n{\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\n\tp.z = z2;\n\tp.y = y2;\n\treturn p;\n}\n\nvec3 rotYaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\n\tp.x = x2;\n\tp.z = z2;\n\treturn p;\n}\n\nvec3 rotZaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\n\tp.x = x2;\n\tp.y = y2;\n\treturn p;\n}\n\nfloat rand1(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n// new and interesting menger formula (shane)\nfloat NewMenger(vec3 q)\n{\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\n    p =  abs(fract(q) - .5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\n}\n\n\n//***************************************************************************************************\n// MAP\n//***************************************************************************************************\n\nfloat map(in vec3 p)\n{\n\torbitTrap = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*1.0;\n\treturn NewMenger(p);\n}\n\n\n//***************************************************************************************************\n// fuzzy shadow\n//***************************************************************************************************\n\nconst float ShadowContrast = 0.99;\nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){\n\tfloat  t=rCoC*2.0,s=1.0;\n\tfor(int i=0;i<9;i++)\n\t{\n\t\tif(s<0.1)continue;\n\t\tfloat r=rCoC+t*coneGrad+0.05;\n\t\tfloat d=map(ro+rd*t)+r*0.6;\n\t\ts*=linstep(-r,r,d);\n\t\tt+=abs(d)*(0.8+0.2*rand1(gl_FragCoord.xy*vec2(i)));\n\t}\n\treturn clamp(s*ShadowContrast+(1.0-ShadowContrast),0.0,1.0);\n}\n\n\n//***************************************************************************************************\n// Orbit color\n//***************************************************************************************************\n\nfloat Cycles = 4.0;\nvec3 cycle(vec3 c, float s) \n{\n\treturn vec3(0.5)+0.5*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));\n}\n\nvec3 BaseColor = vec3(0.2,0.2,0.2);\nvec3 OrbitStrength = vec3(0.8, 0.8, 0.8);\nvec4 X = vec4(0.6, 0.5, 0.6, 0.2);\nvec4 Y = vec4(1.0, 0.5, 0.1, 0.7);\nvec4 Z = vec4(0.7, 0.8, 1.0, 0.3);\nvec4 R = vec4(0.7, 0.7, 0.5, 0.1);\n\nvec3 getColor()\n{\n\torbitTrap.w = sqrt(orbitTrap.w);\n\tvec3 orbitColor = cycle(X.xyz,orbitTrap.x)*X.w*orbitTrap.x + cycle(Y.xyz,orbitTrap.y)*Y.w*orbitTrap.y + cycle(Z.xyz,orbitTrap.z)*Z.w*orbitTrap.z + cycle(R.xyz,orbitTrap.w)*R.w*orbitTrap.w;\n\tvec3 color = mix(BaseColor, 3.0*orbitColor,  OrbitStrength);\n\treturn color;\n}\n\n\n \n//***************************************************************************************************\n// Cast ray\n//***************************************************************************************************\n\n// coc (eiffie)\nvoid castRay(in vec3 ro, in vec3 rd) \n{\n\tvec3 lig = normalize(vec3(0.4+cos((25.+iTime)*0.33), 0.2, 0.6));\t\t\n    float t = 0.;\n    for (int i = 0; i < 70; i++) \n\t{\n\t\tif(col.w>0.999 ||t>15.0)continue;\n\t\trCoC=CircleOfConfusion(t);\n\t\th = map(ro)+0.5*rCoC;\n\t\tif(h<rCoC)\n\t\t{\n\t\t\tpcoc=ro-rd*abs(h-rCoC);\n\t\t\tvec2 v=vec2(rCoC*0.5,0.0);\n\t\t\tvec3 N=normalize(vec3(-map(pcoc-v.xyy)+map(pcoc+v.xyy),-map(pcoc-v.yxy)+map(pcoc+v.yxy),-map(pcoc-v.yyx)+map(pcoc+v.yyx)));\n\t\t\tvec3 scol=2.3*getColor();\t\n\t\t\tfloat newdiff = clamp(dot(lig, N), 0.0, 1.0);\n\t\t\tfloat newspec = pow(clamp(dot(reflect(rd, N), lig), 0.0, 1.0), 16.0);\n\t\t\tfloat newsh   = FuzzyShadow(pcoc,lig,shadowCone,rCoC+0.00);\t\t\t\n\t\t\tscol *= 0.5*newdiff+newspec;\n\t\t \tscol *= newsh;\n\t\t\tfloat alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-h*1.7);\n\t\t\tcol+=vec4(scol*alpha,alpha);\n\t\t}\n\t\th=abs(fudgeFactor*h*(0.3+0.05*rand1(gl_FragCoord.xy*vec2(i))));\n\t\tro+=h*rd;\n\t\tt += h;\n\t}\n}\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfocalDistance=6.5+3.*cos((25.+iTime)*0.133);\n\tpixelSize=1.0/iResolution.y;\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec2 p = uv * 2.0 - 1.0;\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); \n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\n    vec2 m = sin(vec2(0, 1.57079632) + (25.+iTime)/4.);\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\n    vec3 ro = vec3(0.0, 2.0, 5.+sin((25.+iTime)/2.));\n    \n\tcastRay(ro, rd);\n\n\tvec2 uv2=-0.3+2.*gl_FragCoord.xy/iResolution.xy;\n\t//anti branding noise\n    col-=0.10*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\n\n\n\tfragColor = col*0.7;\n}\n\n", "image_inputs": [{"id": "4sBGRW", "previewfilepath": "https://soundcloud.com/virgill/4klang-surveillance", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/virgill/4klang-surveillance", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltV3Rz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltV3z1", "name": "Bad TV Communication", "author": "gigatron", "description": "Firts realtime communication simulation with mars...", "tags": ["tv", "crt", "scanline"], "likes": 3, "viewed": 429, "date": "1473342068", "time_retrieved": "2024-06-20T18:41:32.382081", "image_code": "// Gigatron France ;; 2022 first Realtime Quantic tele-communication from Mars\n// intriquation  ;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t=iTime;\n    \n    float fx=0.0+25.*abs(sin(t)/10.)-mod(1.+t,25.);\n    float s = 500.0; \n    float x = (floor(uv.x * 300.0) ) + (floor(uv.y * 300.0 )) * (t * 0.1);\n\tvec4 dtv = vec4(mod((mod(x, 2.0) + 1.0) * (mod(x, 0.0) + 0.0), 0.01)-0.005) * s;\n    \n    \n    vec3 col = vec3(0.1, 0.1,0.1)+ dtv.xyz/fx;\n  \n    col.xyz += texture( iChannel0,uv  ).xyz;\n \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltV3z1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltVGzz", "name": "Rigging Template", "author": "lara", "description": "This is the basis for another shader I am working on.\nThe skeleton is based on female proportions.\n\nAlready running quite low on fps unfortunately.", "tags": ["template", "rigging"], "likes": 17, "viewed": 962, "date": "1472939076", "time_retrieved": "2024-06-20T18:41:32.388133", "image_code": "#define SHADOW\n#define AMBIENT_OCCLUSION\n\n#define T iTime\n#define PI 3.141592653\n#define TAU (PI*2.)\n#define D2R (PI/180.)\n\n#define P 0.001  // Precision\n#define D 20.    // Max distance\n#define S 256     // Marching steps\n#define R 1.     // Marching substeps\n#define K 32.    // Shadow softness\n#define A 4.     // AO steps\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nvoid rotX(inout vec3 p,vec3 o,mat2 m){p-=o;p.yz*=m;p+=o;}\nvoid rotY(inout vec3 p,vec3 o,mat2 m){p-=o;p.xz*=m;p+=o;}\nvoid rotZ(inout vec3 p,vec3 o,mat2 m){p-=o;p.xy*=m;p+=o;}\n\nstruct RotRange\n{\n    vec2 x,y,z;\n};\n\n/* =============== */\n/* === Rigging === */\n/* =============== */\n\n// joint position (based on: http://image.shutterstock.com/z/stock-vector-female-body-from-three-angles-276920123.jpg)\nvec3 _p_head      = vec3(   0, 1300, 0) / 1400.;\nvec3 _p_shoulderL = vec3(-126, 1150, 0) / 1400.;\nvec3 _p_shoulderR = vec3( 126, 1150, 0) / 1400.;\nvec3 _p_elbowL    = vec3(-143,  915, 0) / 1400.;\nvec3 _p_elbowR    = vec3( 143,  915, 0) / 1400.;\nvec3 _p_wristL    = vec3(-143,  680, 0) / 1400.;\nvec3 _p_wristR    = vec3( 143,  680, 0) / 1400.;\nvec3 _p_chest     = vec3(   0, 1045, 0) / 1400.;\nvec3 _p_pelvis    = vec3(   0,  750, 0) / 1400.;\nvec3 _p_legL      = vec3( -75,  750, 0) / 1400.;\nvec3 _p_legR      = vec3(  75,  750, 0) / 1400.;\nvec3 _p_kneeL     = vec3( -60,  400, 0) / 1400.;\nvec3 _p_kneeR     = vec3(  60,  400, 0) / 1400.;\nvec3 _p_footL     = vec3( -50,    0, 0) / 1400.;\nvec3 _p_footR     = vec3(  50,    0, 0) / 1400.;\n\n// joint rotation angle restraints\nconst RotRange _rr_shoulder = RotRange(vec2( -45, 165)*D2R, vec2( -90, 180)*D2R, vec2(  10, 120)*D2R);\nconst RotRange _rr_chest    = RotRange(vec2(   0,   0)*D2R, vec2( -45,  45)*D2R, vec2(   0,   0)*D2R);\nconst RotRange _rr_leg      = RotRange(vec2( -45, 160)*D2R, vec2(   0,   0)*D2R, vec2(   0,  90)*D2R);\nconst RotRange _rr_pelvis   = RotRange(vec2( -10, 160)*D2R, vec2( -20,  20)*D2R, vec2(   0,   0)*D2R);\nconst RotRange _rr_elbow    = RotRange(vec2(   0, 170)*D2R, vec2(   0,   0)*D2R, vec2(   0,   0)*D2R);\nconst RotRange _rr_wrist    = RotRange(vec2(   0,   0)*D2R, vec2(   0,   0)*D2R, vec2(   0,   0)*D2R);\nconst RotRange _rr_knee     = RotRange(vec2(-130,   0)*D2R, vec2(   0,   0)*D2R, vec2(   0,   0)*D2R);\n\n// joint rotation angles\nvec3 _r_shoulderL = vec3(0,0,0);\nvec3 _r_shoulderR = vec3(0,0,0);\nvec3 _r_chest     = vec3(0,0,0);\nvec3 _r_legL      = vec3(0,0,0);\nvec3 _r_legR      = vec3(0,0,0);\nvec3 _r_pelvis    = vec3(0,0,0);\nvec3 _r_elbowL    = vec3(0,0,0);\nvec3 _r_elbowR    = vec3(0,0,0);\nvec3 _r_wristL    = vec3(0,0,0);\nvec3 _r_wristR    = vec3(0,0,0);\nvec3 _r_kneeL     = vec3(0,0,0);\nvec3 _r_kneeR     = vec3(0,0,0);\n\nvec3 _ground = vec3(0);\n\nvoid waveHands()\n{\n     _r_shoulderL.y = -PI/3.;\n     _r_shoulderL.z = _rr_shoulder.z.x + (sin(T*4.)+1.)/2. * (_rr_shoulder.z.y - _rr_shoulder.z.x);\n\n     _r_shoulderR.y = -PI/3.;\n     _r_shoulderR.z = _rr_shoulder.z.x + (sin(T*4.)+1.)/2. * (_rr_shoulder.z.y - _rr_shoulder.z.x);\n    \n     _r_elbowL.x = (sin(T*4.)+1.)/2.*PI/4.;\n     _r_elbowR.x = (sin(T*4.)+1.)/2.*PI/4.;\n}\n\nvoid doCrazyStuff()\n{\n    _r_shoulderL = sin(vec3(T/01.,T/01.*2.,T/01.*3.)) * PI;\n    _r_shoulderR = sin(vec3(T/02.,T/02.*2.,T/02.*3.)) * PI;\n    _r_chest     = sin(vec3(T/03.,T/03.*2.,T/03.*3.)) * PI;\n    _r_legL      = sin(vec3(T/04.,T/04.*2.,T/04.*3.)) * PI;\n    _r_legR      = sin(vec3(T/05.,T/05.*2.,T/05.*3.)) * PI;\n    _r_pelvis    = sin(vec3(T/06.,T/06.*2.,T/06.*3.)) * PI;\n    _r_elbowL    = sin(vec3(T/07.,T/07.*2.,T/07.*3.)) * PI;\n    _r_elbowR    = sin(vec3(T/08.,T/08.*2.,T/08.*3.)) * PI;\n    _r_wristL    = sin(vec3(T/09.,T/09.*2.,T/09.*3.)) * PI;\n    _r_wristR    = sin(vec3(T/10.,T/10.*2.,T/10.*3.)) * PI;\n    _r_kneeL     = sin(vec3(T/11.,T/11.*2.,T/11.*3.)) * PI;\n    _r_kneeR     = sin(vec3(T/12.,T/12.*2.,T/12.*3.)) * PI;\n}\n\nvoid walk(float s)\n{\n    float t1 = (sin(T*s)+1.)/2.;\n    float t2 = (sin(T*s-TAU/3.5)+1.)/2.;\n    \n    float t3 = (sin(T*s+PI)+1.)/2.;\n    float t4 = (sin(T*s+PI-TAU/3.5)+1.)/2.;\n    \n    _r_legL.x  = t1 * _rr_leg.x.x/2. + (1.-t1) * _rr_leg.x.y/5.;\n    _r_kneeL.x = t2 * _rr_knee.x.x/2.;\n    \n    _r_legR.x  = t3 * _rr_leg.x.x/2. + (1.-t3) * _rr_leg.x.y/5.;\n    _r_kneeR.x = t4 * _rr_knee.x.x/2.;\n    \n    _r_shoulderL.x = t3 * _rr_shoulder.x.x/4. + (1.-t3) * _rr_shoulder.x.y/8.;\n    _r_shoulderR.x = t1 * _rr_shoulder.x.x/4. + (1.-t1) * _rr_shoulder.x.y/8.;\n    \n    _r_elbowL.x = t4 * _rr_elbow.x.y/8.;\n    _r_elbowR.x = t2 * _rr_elbow.x.y/8.;\n    \n    _r_pelvis.y = (_rr_pelvis.y.x + t1 * _rr_pelvis.y.y * 2.) / 2.;\n    _r_chest.y  = (_rr_chest.y.x + t3 * _rr_chest.y.y * 2.) / 4.;\n    \n    _r_pelvis.x = -PI/128.;\n    \n    _ground.z = T*s/8.;\n}\n\nvoid rig()\n{    \n    mat2 m;\n    \n    // Legs (x-axis-rotation)\n    rotX(_p_kneeL,_p_legL,m=rot(-clamp(_r_legL.x,_rr_leg.x.x,_rr_leg.x.y)));\n    rotX(_p_footL,_p_legL,m);\n    rotX(_p_footL,_p_kneeL,rot(-clamp(_r_kneeL.x,_rr_knee.x.x,_rr_knee.x.y)));\n    \n    rotX(_p_kneeR,_p_legR,m=rot(-clamp(_r_legR.x,_rr_leg.x.x,_rr_leg.x.y)));\n    rotX(_p_footR,_p_legR,m);\n    rotX(_p_footR,_p_kneeR,rot(-clamp(_r_kneeR.x,_rr_knee.x.x,_rr_knee.x.y)));\n    \n    // Arms (x-axis-rotation)\n    rotX(_p_elbowL,_p_shoulderL,m=rot(-clamp(_r_shoulderL.x,_rr_shoulder.x.x,_rr_shoulder.x.y)));\n    rotX(_p_wristL,_p_shoulderL,m);\n    rotX(_p_wristL,_p_elbowL,rot(-clamp(_r_elbowL.x,_rr_elbow.x.x,_rr_elbow.x.y)));\n    \n    rotX(_p_elbowR,_p_shoulderR,m=rot(-clamp(_r_shoulderR.x,_rr_shoulder.x.x,_rr_shoulder.x.y)));\n    rotX(_p_wristR,_p_shoulderR,m);\n    rotX(_p_wristR,_p_elbowR,rot(-clamp(_r_elbowR.x,_rr_elbow.x.x,_rr_elbow.x.y)));\n    \n    // Arms (y-axis-rotation)\n    rotY(_p_elbowL,_p_shoulderL,m=rot(-clamp(_r_shoulderL.y,_rr_shoulder.y.x,_rr_shoulder.y.y)));\n    rotY(_p_wristL,_p_shoulderL,m);\n    rotY(_p_wristL,_p_elbowL,rot(-clamp(_r_elbowL.y,_rr_elbow.y.x,_rr_elbow.x.y)));\n    \n    rotY(_p_elbowR,_p_shoulderR,m=rot(clamp(_r_shoulderR.y,_rr_shoulder.y.x,_rr_shoulder.y.y)));\n    rotY(_p_wristR,_p_shoulderR,m);\n    rotY(_p_wristR,_p_elbowR,rot(clamp(_r_elbowR.y,_rr_elbow.y.x,_rr_elbow.x.y)));\n    \n    // Legs (z-axis-rotation)\n    rotZ(_p_kneeL,_p_legL,m=rot(clamp(_r_legL.z,_rr_leg.z.x,_rr_leg.z.y)));\n    rotZ(_p_footL,_p_legL,m);\n    // rotX(_p_footL,_p_kneeL,rot(clamp(_r_kneeL.x,_rr_knee.x,_rr_knee.y)));\n    \n    rotZ(_p_kneeR,_p_legR,m=rot(-clamp(_r_legR.z,_rr_leg.z.x,_rr_leg.z.y)));\n    rotZ(_p_footR,_p_legR,m);\n    // rotX(_p_footL,_p_kneeL,rot(-clamp(_r_kneeL.x,_rr_knee.x,_rr_knee.y)));\n    \n    // Arms (z-axis-rotation)\n    rotZ(_p_elbowL,_p_shoulderL,m=rot(clamp(_r_shoulderL.z,_rr_shoulder.z.x,_rr_shoulder.z.y)));\n    rotZ(_p_wristL,_p_shoulderL,m);\n    // rotZ(_p_wristL,_p_elbowL,rot(clamp(_r_elbowL.z,_rr_elbow.z,_rr_elbow.w)));\n    \n    rotZ(_p_elbowR,_p_shoulderR,m=rot(-clamp(_r_shoulderR.z,_rr_shoulder.z.x,_rr_shoulder.z.y)));\n    rotZ(_p_wristR,_p_shoulderR,m);\n    // rotZ(_p_wristR,_p_elbowR,rot(-clamp(_r_elbowR.z,_rr_elbow.z.x,_rr_elbow.z.y)));\n\n    // Pelvis (x-axis-rotation)\n    rotX(_p_head,_p_pelvis,m=rot(clamp(_r_pelvis.x,_rr_pelvis.x.x,_rr_pelvis.x.y)));\n    rotX(_p_shoulderL,_p_pelvis,m);\n    rotX(_p_elbowL,_p_pelvis,m);\n    rotX(_p_wristL,_p_pelvis,m);\n    rotX(_p_shoulderR,_p_pelvis,m);\n    rotX(_p_elbowR,_p_pelvis,m);\n    rotX(_p_wristR,_p_pelvis,m);\n    \n    // Pelvis (y-axis-rotation)\n    rotY(_p_legL,_p_pelvis,m=rot(clamp(_r_pelvis.y,_rr_pelvis.y.x,_rr_pelvis.y.y)));\n    rotY(_p_kneeL,_p_pelvis,m);\n    rotY(_p_footL,_p_pelvis,m);\n    rotY(_p_legR,_p_pelvis,m);\n    rotY(_p_kneeR,_p_pelvis,m);\n    rotY(_p_footR,_p_pelvis,m);\n\n    // Chest (y-axis-rotation)\n    rotY(_p_head,_p_chest,m=rot(clamp(_r_chest.y,_rr_chest.y.x,_rr_chest.y.y)));\n    rotY(_p_shoulderL,_p_chest,m);\n    rotY(_p_elbowL,_p_chest,m);\n    rotY(_p_wristL,_p_chest,m);\n    rotY(_p_shoulderR,_p_chest,m);\n    rotY(_p_elbowR,_p_chest,m);\n    rotY(_p_wristR,_p_chest,m);\n}\n\n/* ======================== */\n/* === Marching Globals === */\n/* ======================== */\n\nstruct Hit {\n\tvec3 p;\n\tfloat t;\n\tfloat d;\n\tfloat s;\n};\n\nstruct Ray {\n\tvec3 o;\n\tvec3 d;\n}, _ray;\n\nstruct Cam {\n\tvec3 p;\n\tvec3 t;\n    vec3 u;\n    float f;\n}, _cam;\n\nvec2 _uv;\nconst int _num_objects = 3;\nfloat _d, _obj[_num_objects];\n\nint _ignore = -1;\n\nbool _ambientOccMarch = false;\nbool _shadowMarch = false;\nbool _normalMarch = false;\n\n/* ================= */\n/* === Utilities === */\n/* ================= */\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEll(vec3 p,vec3 r){return (length(p/r)-1.)*min(min(r.x,r.y),r.z);}\nfloat udBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s+r,0.))-r;}\nfloat sdBox(vec3 p,vec3 s,float r){vec3 d = abs(p)-s+r;return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.))-r;}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a, ap = p-a;\n    return length(ap-ab*clamp(dot(ap,ab)/dot(ab,ab),0.,1.))-r;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b-a, ap = p-a;\n    float t = clamp(dot(ap,ab)/dot(ab,ab),0.,1.);\n    return length(ap-ab*t)-mix(r1,r2,t);\n}\n\nfloat patternCheckered(vec2 p)\n{\n    return mod(floor(p.x)+mod(floor(p.y),2.),2.);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/* ============ */\n/* === Scene=== */\n/* ============ */\n\nfloat sdJoints(vec3 p, float r)\n{\n    float d = 1e10;\n    \n    d = min(d,length(p-_p_head)-r*2.);\n    d = min(d,length(p-_p_shoulderL)-r);\n    d = min(d,length(p-_p_shoulderR)-r);\n    d = min(d,length(p-_p_elbowL)-r);\n    d = min(d,length(p-_p_elbowR)-r);\n    d = min(d,length(p-_p_wristL)-r);\n    d = min(d,length(p-_p_wristR)-r);\n    d = min(d,length(p-_p_legL)-r);\n    d = min(d,length(p-_p_legR)-r);\n    d = min(d,length(p-_p_kneeL)-r);\n    d = min(d,length(p-_p_kneeR)-r);\n    d = min(d,length(p-_p_footL)-r);\n    d = min(d,length(p-_p_footR)-r);\n    \n    return d;\n}\n\nfloat sdFrame(vec3 p, float r)\n{\n    float d = 1e10;\n    \n    d = min(d,sdLine(p,_p_shoulderL,_p_shoulderR,r));\n    //d = min(d,sdLine(p,_p_legL,_p_legR,r));\n    \n    d = min(d,sdLine(p,_p_shoulderL,_p_elbowL,r));\n    //d = min(d,sdLine(p,_p_shoulderL,_p_legL,r));\n    d = min(d,sdLine(p,_p_elbowL,_p_wristL,r));\n    d = min(d,sdLine(p,_p_legL,_p_kneeL,r));\n    d = min(d,sdLine(p,_p_kneeL,_p_footL,r));\n     \n    d = min(d,sdLine(p,_p_shoulderR,_p_elbowR,r));\n    //d = min(d,sdLine(p,_p_shoulderR,_p_legR,r));\n    d = min(d,sdLine(p,_p_elbowR,_p_wristR,r));\n    d = min(d,sdLine(p,_p_legR,_p_kneeR,r));\n    d = min(d,sdLine(p,_p_kneeR,_p_footR,r));\n    \n    return d;\n}\n\nfloat sdBody(vec3 p)\n{\n    float d = 1e10;\n\n    d = min(d,sdCone(p,_p_shoulderL,_p_elbowL,.03,.025));\n    d = min(d,sdCone(p,_p_elbowL,_p_wristL,.025,.02));\n    \n    d = min(d,sdCone(p,_p_shoulderR,_p_elbowR,.03,.027));\n    d = min(d,sdCone(p,_p_elbowR,_p_wristR,.027,.02));\n    \n    d = min(d,sdCone(p,_p_legL,_p_kneeL,.05,.03));\n    d = min(d,sdCone(p,_p_kneeL,_p_footL,.03,.025));\n    d = min(d,sdCone(p,_p_legR,_p_kneeR,.05,.03));\n    d = min(d,sdCone(p,_p_kneeR,_p_footR,.03,.025));\n    \n    return d;\n}\n\nfloat scene(vec3 p)\n{\n\tvec3 q, s; float d = 1e10;\n\n    // Floor\n\td = sdBox(p*vec3(1,1,0)+vec3(0,1.1,0),vec3(.2,.1,0),.01);\n    _obj[0] = d; d = 1e10;\n    \n    if (_ambientOccMarch == true) _obj[0] = 1e10;\n    \n    p.y += 1.;\n\n    _obj[1] = min(sdFrame(p,0.01),sdJoints(p,.025));\n    _obj[2] = mod(floor(T*.25),2.) == 0. ? 1e10 : sdBody(p);\n\n\tfor(int i = 0; i < _num_objects; i++)\n\t{\n\t\t//if (_ignore == i) continue;\n\t\td = min(d,_obj[i]);\n\t}\n\n\t_d = d;\n\n\treturn d;\n}\n\n/* ================ */\n/* === Marching === */\n/* ================ */\n\nRay lookAt(Cam c, vec2 uv)\n{\n\tvec3 d = normalize(c.t - c.p);\n\tvec3 r = normalize(cross(d,c.u));\n\tvec3 u = cross(r,d);\n\n\treturn Ray(c.p*c.f, normalize(uv.x*r + uv.y*u + d*c.f));\n}\n\nHit march(Ray r)\n{\n\tfloat t = 0., d, s;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(p = r.o + r.d*t);\n\n\t\tif (d < P || t > D)\n\t\t{\n\t\t\ts = float(i);\n\t\t\tbreak;\n\t\t}\n\n\t\tt += d/R;\n\t}\n\n\treturn Hit(p, t, d, s);\n}\n\nvec3 getNormal(vec3 p)\n{\n    _normalMarch = true;\n    \n\tvec2 e = vec2(P,0.);\n\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\n/* =============== */\n/* === Shading === */\n/* =============== */\n\nfloat getShadow(vec3 light, vec3 origin)\n{\n\t_shadowMarch = true;\n\n\tvec3 d = normalize(light - origin);\n\tfloat t = 0.;\n\tfloat maxt = length(light - origin)-.1;\n\tfloat s = 1.0;\n    \n    const int n = S/4;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfloat d = scene(origin + d * t);\n\t\tif (t > maxt || t > D) { break; }\n\t\tt += d; s = min(s,d/t*K);\n\t}\n\n\treturn s;\n}\n\nfloat getAmbientOcclusion(Hit h) \n{\n    _ambientOccMarch = true;\n    \n    float t = 0., a = 0.;\n    \n\tfor(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i/A*.2);\n        t += d;\n    }\n\n\treturn clamp(t/A*20.,0.,1.);\n}\n\nvec3 getColor(Hit h)\n{\n\tif (h.d > P) { return vec3(_uv.y-h.s/float(S)*2.); }\n\n\tvec3 col = vec3(0);\n\tvec3 n = getNormal(h.p);\n    vec3 light = vec3(0,5,0);\n\n\tfloat diff = max(dot(n, normalize(light-h.p)),.1);\n\tfloat spec = pow(max(dot(reflect(normalize(h.p-light),n),normalize(_cam.p-h.p)),0.),100.);\n\tfloat dist = clamp(10./exp(length(h.p-light)*.3),0.,1.);\n    \n    if (_d == _obj[0])\n    {\n        vec2 c = h.p.xz;\n        if (abs(n.x) > .9) c = h.p.yz;\n        else if (abs(n.z) > .9) c = h.p.xy;\n            \n        c.y -= _ground.z;\n\t\tcol = vec3(1) - texture(iChannel0,c*.2).r * .3;\n    }\n    else if(_d == _obj[1])\n    {\n\t\tcol = vec3(1,0,0);\n    }\n    else if(_d == _obj[2])\n    {\n\t\tcol = vec3(1);\n    }\n    \n    #ifdef SHADOW\n    col *= max(getShadow(light,h.p),.5);\n    #endif\n    \n    #ifdef AMBIENT_OCCLUSION\n  \tcol *= getAmbientOcclusion(h);\n    #endif\n\n    return mix(vec3(_uv.y-h.s/float(S)*2.),col*1.5,dist);\n}\n\n/* ============ */\n/* === Main === */\n/* ============ */\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(50159.91193,49681.51239))) * 73943.1699);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvm = iMouse.xy/iResolution.xy;\n    if (iMouse.x < 10. && iMouse.y < 10.) { uvm = vec2(.5+T*.025,.5); }\n    \n    _cam = Cam(vec3(.5,.5,-1), vec3(0,-.2,0),vec3(0,1,0),2.);\n    _cam.p.yz *= rot((uvm.y*.25+.5)*PI + PI/1.8);\n    _cam.p.xz *= rot(uvm.x*TAU - PI/4.);\n    \n    _uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.xx;\n    _ray = lookAt(_cam,_uv);\n    \n    //doCrazyStuff();\n    \n    if(cos(T*.5)<0.)\n    waveHands();\n    else\n    walk(4.);\n    \n    rig();\n    \n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)/iResolution.xy)*0.5;\n\tfragColor = vec4(getColor(march(_ray))*f,1);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltVGzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyGDD", "name": "Lette.GraphingTest", "author": "lette", "description": "Baby steps. Smooth graphs with adjustable range/size/ticks. Resolution independent - uses zoom level to determine pixel resolution.", "tags": ["test", "graphs"], "likes": 5, "viewed": 150, "date": "1474654507", "time_retrieved": "2024-06-20T18:41:32.388133", "image_code": "const float pi = 3.14159265;\n\nconst float xMax = 5.;\nconst float xMin = -5.;\nconst float xTick = pi / 4.;\n\nconst float yMax = 3.5;\nconst float yMin = -3.5;\nconst float yTick = .5;\n\nfloat theFunc(float x)\n{\n\tfloat time = iTime / 3.;\n    \n    return\n        0.75 * sin((3. * x + pi / 7. + time * -.5 * pi) / 2. * pi) +\n        2.00 * cos( 2. * x + time * 2. * pi);\n}\n\nconst vec3 white = vec3(1., 1., 1.);\nconst vec3 gray = vec3(.5, .5, .5);\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 orange = vec3(1.0, 0.39, 0.);\nconst vec3 red = vec3(1., .3, .3);\nconst vec3 blue = vec3(.3, .3, 1.);\n\nconst vec3 background = white;\nconst vec3 axes = orange;\nconst vec3 ticks = black;\nconst vec3 gridLines = gray;\nconst vec3 graph = blue;\n\nvec4 getCoordinateInGraphSystem(vec2 coordinate)\n{\n    vec2 normalizedCoordinate = coordinate / iResolution.xy;\n    vec2 zoom = vec2(xMax - xMin, yMax - yMin);\n    vec2 pan = vec2(xMin, yMin);\n    \n    vec2 c = normalizedCoordinate * zoom + pan;\n    \n    return vec4(c, zoom / iResolution.xy);\n}\n\nvoid drawAxes(inout vec4 color, in vec4 coord)\n{\n    float absX = abs(coord.x);\n    float absY = abs(coord.y);\n    float resX = coord.z;\n    float resY = coord.w;\n    \n    // main x-axis\n    if (absY <= 2. * resY)\n    {\n        color = vec4(axes, 1.);\n    }\n\n    // main y-axis\n    if (absX <= 2. * resX)\n    {\n        color = vec4(axes, 1.);\n    }\n\n    if (absX > xTick / 2. && mod(absX, xTick) <= 1. * resX)\n    {\n        if (absY <= 4. * resY)\n        {\n\t\t    // ticks on x-axis\n\t        color = vec4(ticks, 1.);\n        }\n        else if (mod(absY, 4.0 * resY) < 2.0 * resY)\n        {\n            // x-grid-lines\n            color = vec4(gridLines, 1.);\n        }\n    }\n            \n    if (absY > yTick / 2. && mod(absY, yTick) <= 1. * resY)\n    {\n        if (absX <= 4. * resX)\n        {\n\t\t\t// ticks on y-axis\n        \tcolor = vec4(ticks, 1.);\n        }\n        else if (mod(absX, 4.0 * resX) < 2.0 * resX)\n        {\n        \t// y-grid-lines\n            color = vec4(gridLines, 1.);\n        }\n    }\n}\n\nvoid alphaBlend(inout vec4 color, in vec4 newColor)\n{\n    color = newColor + color * (1. - newColor.a);\n}\n\nvoid drawFunc(inout vec4 color, in vec4 coord, float alpha)\n{\n    float y = theFunc(coord.x);\n    \n    float yNext = theFunc(coord.x + 1. * coord.z);\n    float yPrev = theFunc(coord.x - 1. * coord.z);\n    \n    float dNext = (yNext - y) / 2.;\n    float dPrev = (yPrev - y) / 2.;\n    \n    float lMax = max(max(dNext, dPrev), 0.5 * coord.w);\n    float lMin = min(min(dNext, dPrev), -0.5 * coord.w);\n    \n    if (y + lMin <= coord.y && coord.y < y + lMax)\n    {\n        alphaBlend(color, vec4(graph, alpha));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = vec4(white, 1.);\n    \n    vec4 coord = getCoordinateInGraphSystem(fragCoord);\n    \n    drawAxes(fragColor, coord);\n    \n    // draw main function value\n    drawFunc(fragColor, coord, 1.);\n\n    // draw extra lines next to main line with lower alpha\n    vec4 unitX = vec4(coord.z, 0., 0., 0.);\n    vec4 unitY = vec4(0., coord.w, 0., 0.);\n    \n    drawFunc(fragColor, coord + unitX, .6);\n    drawFunc(fragColor, coord - unitX, .6);\n    drawFunc(fragColor, coord + unitY, .6);\n    drawFunc(fragColor, coord - unitY, .6);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyGDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyGRy", "name": "hypertexture - trabeculum -2", "author": "FabriceNeyret2", "description": "3D Trabeculum pattern (camera follow mouse) - messy testbench.\nVoronoi with smooth corners and normalized thickness (see comments).\n\nSo costly. How to make it cheaper ?", "tags": ["procedural", "noise", "perlin", "hypertexture", "trabeculum"], "likes": 13, "viewed": 1166, "date": "1475152883", "time_retrieved": "2024-06-20T18:41:33.382088", "image_code": "// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\n\n#define SHADED 1\n#define FOG 1\n#define VARIANT 1\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\n    \nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\nconst vec3 ambient  = vec3(.2,0.,0.), \n           diffuse  = vec3(.8);\n\n#define PI 3.14159\n\n\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\n    return fract(sin(n)*43758.5453);\n}\n\n\nvec3 hash13( float n ) {\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\n}\nfloat hash31( vec3 n ) {\n    return hash(n.x+10.*n.y+100.*n.z);\n}\nvec3 hash33( vec3 n ) {\n    return hash13(n.x+10.*n.y+100.*n.z);\n}\n\nvec3 dist(vec3 g, vec3 x) {\n    vec3 n = floor(x), f = fract(x),\n         o = hash33( n + g );\n\t#if ANIMATE==2\n    o = .5 + .5*sin( iTime + 6.2831*o );\n    #endif\t\n    return g + o - f;\n}\n\nvec4 worley( vec3 x) {\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec3 mg, mr;\n\n    float md = 8., md2, md3;\n    for( int k=-1; k<=1; k++ ) \n      for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ ) {\n            vec3  g = vec3(i,j,k), \n                  r = dist(g, x);\n            float d = dot(r,r);\n\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\n        }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    vec4 d = vec4(1e15);\n/**/\n    mg-=mg;\n    #define W 1   // shortcut. why does it work ?\n/**\n    #define W 2   // should be the correct way\n/**/\n    for( int k=-W; k<=W; k++ )\n      for( int j=-W; j<=W; j++ )\n        for( int i=-W; i<=W; i++ ) {\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\n                 r = dist(g, x);\n\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\n                else if (d0<d.z) {            d.z=d0; }   \n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\n                else if (d0<d.w) {              d.w=d0; }   */\n            }\n        }\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\n}\n\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\n    _dist=1.;\n\n// my noise\nfloat tweaknoise( vec3 p) {\n    // macroscopic shape pruning the noise\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\n          d=d1, v;\n\n  #if !VARIANT\n    d = (1.-d1)*d2; \n  #endif\n    _dist = 1.;\n    if (d < .5) return 0.;\n    \n    // 3D noise\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\n    grad=.1, scale = 4., thresh=.9;\n    vec4 w = scale*worley(scale*p); \n#define TRAB 2 // variation for the magic trabeculum distance\n  #if TRAB==1\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\n  #elif TRAB==2\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\n  #else\n    v= 1.-1.*w.y;\n  #endif\n    \n    _dist = 1.-v*d-thresh;\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\n}\n\n\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\nfloat shadedNormal( vec3 p, float v ) {\n    float epsL = 0.01;\n#if 1// centered directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\n#else // cheap directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\n#endif\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \n    // { fragColor = vec4(ambient,1.); return; }\n    \n    vec2 mouse=iMouse.xy/iResolution.xy;\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\n\n    //camera\n    float theta = (mouse.x*2. - 1.)*PI;\n    float phi = (mouse.y - .5)*PI;\n#if ANIMATE==1 // camera shake \n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\n#endif\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \n    vec3 cameraTarget = vec3(0.);\n    vec3 ww = normalize( cameraPos - cameraTarget );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\n  \n    // ray-trace volume\n    vec3 col=vec3(0.);\n \tfloat transp=1., epsC=.01/2.;\n    float l = .5;\n    vec3 p=cameraPos+l*rayDir, p_=p;\n    \n    for (int i=0; i<200; i++) { \n        float Aloc = tweaknoise(p); // density field\n        //epsC = .1*_dist;  // adaptive stepping\n        if (Aloc>0.01) {            \n#if FOG \n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\n            col += transp*skyColor*(1.-fog);\n    \t    transp *= fog; \n            if (transp<.001) break;\n#endif            \n#if SHADED          \n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\n#else\n            vec3 c = vec3(0.);\n#endif\n \t        col += transp*c*Aloc;\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\n            col = clamp(col,0.,1.); // anomaly :-(\n    \t    transp *= 1.-Aloc;\n\t        if (transp<.001) break;\n        }\n \n        p += epsC*rayDir;\n    }\n    \n   fragColor = vec4(col+ transp*skyColor, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyGRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyGWh", "name": "glossy reflections", "author": "andrewww1", "description": "mouse click to set the first person view yaw and pitch.\n\nChange GLOSS_RAYS_NUM to set the number of rays.\nChange GLOSS_RAYS_SPREAD to set the spread of the rays.", "tags": ["reflection", "glossy"], "likes": 10, "viewed": 342, "date": "1474378536", "time_retrieved": "2024-06-20T18:41:35.218631", "image_code": "#define GLOSS_RAYS_NUM 2\n#define GLOSS_RAYS_SPREAD 0.025\n\nfloat opS(float d1, float d2) {\n    return max(-d2,d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n    return (d1.y<d2.y) ? d1 : d2;\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n    return mod(p,c)-0.5*c;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat length6( vec2 p ) {\n    p = p*p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat sdCylinder6( vec3 p, vec2 h ) {\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nvec3 checkerCol(vec3 texc, vec3 color0, vec3 color1) {\n    if (mod((floor(texc.x) + floor(texc.y) + floor(texc.z)),2.0 ) == 0.0) {\n        return color0;\n    } else {\n        return color1;\n    }\n}\n\nvec3 brickCol(vec3 localPos,vec3 BrickColor, vec3 MortarColor, vec3 BrickSize,vec3 BrickPct) {\n    vec3 position = localPos / BrickSize.xyz;\n\n    if (fract(position.y * 0.5) > 0.5){\n        position.x += 0.5;\n        position.z += 0.5;\n    }\n\n    position = fract(position);\n    vec3 useBrick = step(position, BrickPct.xyz);\n\n    return mix(MortarColor, BrickColor, useBrick.x * useBrick.y * useBrick.z);\n}\n\nvec2 distScene(vec3 p) {\n    vec2 rs=vec2(0.2,opS(sdBox(p-vec3(0.0,1.5,0.0), vec3(24.0,3.0,24.0)),\n                                             sdBox(p-vec3(0.0,0.0,0.0), vec3(23.5,7.0,23.5))));\n\n    rs=opU(rs,vec2(0.1,sdBox(p-vec3(0.0,-1.5,0.0), vec3(24.0,0.5,24.0))));\n\n    rs=opU(rs, vec2(0.3, (sdCylinder6((opRep(vec3(clamp(p.xz,vec2(-23.0),vec2(23.0)),p.y).xzy, \n                                             vec2(7.0,0.0).xyx)-vec3(0.0,1.5,0.0)),vec2(0.5,3.0)) )));\n\n    return rs;\n}\n\nfloat rand(vec2 coordinate) {\n    return fract(sin(dot(coordinate.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 castRay3( in vec3 ro, in vec3 rd ) {\n    float t=0.0;\n    float d=0.0;\n    const float maxSteps=48.0;\n    \n    for(float i = 1.0; i <= maxSteps; ++i) {\n        vec3 p = ro + rd * t;\n        vec2 rs=distScene(p);\n        d = rs.y;\n\n        float q=0.01;\n        \n        if(d < q ) {\n            return vec2(rs.x,t);\n        }\n\n        t += d;\n    }\n\n    return vec2(0.0,0.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n    float t=0.0;\n    float d=0.0;\n    const float maxSteps=96.0;\n    \n    for(float i = 1.0; i <= maxSteps; ++i) {\n        vec3 p = ro + rd * t;\n        vec2 rs=distScene(p);\n        d = rs.y;\n        float q=0.01;\n        \n        if(d < q ) {\n            return vec2(rs.x,t);\n        }\n\n        t += d;\n    }\n\n    return vec2(0.0,0.0);\n}\n\nvec3 getNormal(vec3 p) {\n    float h = 0.0001;\n    vec3 n;\n    n.x=distScene(p+vec3(h,0.0,0.0)).y-distScene(p-vec3(h,0.0,0.0)).y;\n    n.y=distScene(p+vec3(0.0,h,0.0)).y-distScene(p-vec3(0.0,h,0.0)).y;\n    n.z=distScene(p+vec3(0.0,0.0,h)).y-distScene(p-vec3(0.0,0.0,h)).y;\n    n=normalize(n);\n    return n;\n}\n\n\nvec3 calcPtLightCol3(vec3 pos, vec3 nor, vec3 lightPos,vec3 atten,vec3 lightCol,vec3 mtrlCol,float shininess,float strength) {\n    vec3 lightDir=lightPos.xyz-pos;\n    float lightDist=length(lightDir);\n    lightDir=lightDir/lightDist;\n    vec2 rs=castRay3(pos+lightDir*0.1,lightDir);\n\n    if(rs.x>0.0 && rs.y < lightDist) {\n        return vec3(0.0);\n    }\n\n    //\n    float a = 1.0/(atten.x+atten.y*lightDist+atten.z*lightDist*lightDist);\n    vec3 reflectVec=reflect(-lightDir,nor);\n    float NdotL = max(0.0,dot(nor,lightDir));\n    float spec=0.0;\n\n    if(NdotL > 0.0) {\n        float NdotR = max(0.0, dot(nor, reflectVec));\n        spec = pow(NdotR, shininess*128.0) * strength*a;\n    }\n\n    float diffuse=NdotL*a;\n    return lightCol*(mtrlCol*diffuse+spec);\n}\n\nvec3 calcPtLightCol(vec3 pos, vec3 nor, vec3 lightPos,vec3 atten,vec3 lightCol,vec3 mtrlCol,float shininess,float strength) {\n    vec3 lightDir=lightPos.xyz-pos;\n    float lightDist=length(lightDir);\n    lightDir=lightDir/lightDist;\n\n    vec2 rs=castRay(pos+lightDir*0.1,lightDir);\n\n    if(rs.x>0.0 && rs.y < lightDist) {\n        return vec3(0.0);\n    }\n\n    //\n    float a = 1.0/(atten.x+atten.y*lightDist+atten.z*lightDist*lightDist);\n\n    vec3 reflectVec=reflect(-lightDir,nor);\n    float NdotL = max(0.0,dot(nor,lightDir));\n    float spec=0.0;\n\n    if(NdotL > 0.0) {\n        float NdotR = max(0.0, dot(nor, reflectVec));\n        spec = pow(NdotR, shininess*128.0) * strength*a;\n    }\n\n    float diffuse=NdotL*a;\n\n    return lightCol*(mtrlCol*diffuse+spec);\n}\n\nfloat calcVecAngle(vec3 v0,vec3 v1) {\n    float l=length(v0)*length(v1);\n    float d=dot(v0,v1);\n    return acos(d/l);\n}\n\nmat3 rotMatFromNormalOld(vec3 RN1,vec3 n) {\n    //vec3 RN1=n.zyx*vec3(1.0,1.0,-1.0);\n    vec3 RN2=cross(n,RN1);\n    mat3 m=mat3(RN1,RN2,n);\n    return m;//transpose(m);\n}\n\n\nmat3 rotMatFromNormal(vec3 n,vec3 r) {\n\tvec3 a=normalize(cross(n,r));\n    vec3 b=normalize(cross(a,r));\n    mat3 m=mat3(a,b,r);\n    return m;\n}\n\nvec2 rand2(vec2 co){\n    //from lumina.sourceforge.net/Tutorials/Noise.html\n    vec2 r;\n    r.x=fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    r.y=fract(cos(dot(co.xy ,vec2(4.898,7.23))) * 23421.631);\n    return r;\n}\n\nvec2 jitter(vec2 offset, float d) {\n    //from gamedev.stackexchange.com/questions/26789/random-vector-within-a-cone\n    for(int i=0;i<32;i++) {\n        offset=rand2(offset)*d;\n        //offset=rand2(offset*u_time)*d;\n\n        if((offset.x*offset.y)>(d*d)) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nvec3 calcMtrlCol(float id,vec3 p,vec3 n) {\n    vec3 col;\n\n    if(id==0.1) {\n        col=checkerCol(p,vec3(0.9,0.9,0.9),vec3(0.3,0.5,0.7));\n    } else if(id==0.2) {\n        col=brickCol(p,vec3(0.9,0.3,0.3), vec3(0.85), vec3(0.95),vec3(0.85));\n    } else if(id==0.3) {\n        col=brickCol(p,vec3(0.8), vec3(0.6), vec3(0.7),vec3(0.9));\n    } else {\n        col=vec3(1.0);\n    }\n\n    return col;\n}\n\nfloat calcFlare(vec3 ro,vec3 rd, vec2 rs,vec3 lightPos) {\n    float t=rs.y;\n    float val=0.0;\n    vec3 viewLightDir=normalize(lightPos-ro);\n    float viewLightDist=length(lightPos-ro);\n    float q = dot(rd,viewLightDir)*0.5+0.5;\n    //float g=calcVecAngle(viewLightDir,rd);\n    //float o = (colViewDist!=-1.0 && colViewDist<viewLightDist)?0.0:(1.0/viewLightDist)*0.15 ;//occ(u_viewPos,lightPos,1.0);\n    //col+=pow(q,500.0/o)*lightCol*1.2;//*((atten.x+atten.y*viewLightDir+atten.z*viewLightDir*viewLightDir));\n\n    if(rs.x==0.0 || (t<0.0 || t>=viewLightDist) /*&& calcVecAngle(rd,viewLightDir)<0.01*/) {\n        float o = (1.0/viewLightDist)*0.15 ;\n        val=clamp(pow(q,900.0/o)*1.0,0.0,2.0);\n    }\n\n    return val;\n}\n\nvec3 render3(vec3 ro, vec3 rd,vec3 lightPos,vec3 lightAtten,vec3 lightCol) {\n    vec3 col;\n    vec2 rs=castRay3(ro,rd);\n    float t = rs.y;\n\n    if(rs.x!=0.0) {\n        vec3 p = ro + t*rd;\n        vec3 p2 = ro + (t+0.1)*rd;\n        vec3 n = getNormal(p);\n        vec3 r=reflect(rd,n);\n        col=calcMtrlCol(rs.x,p,n);\n        col=calcPtLightCol3(p,n,lightPos,lightAtten,lightCol,col,0.45,0.25)+col*0.075;\n    } else {\n        col= vec3(0.1);\n    }\n\n    col=mix(col,lightCol*1.5,calcFlare(ro,rd,rs,lightPos));\n    return col;\n}\n\nvec3 render2(vec3 ro, vec3 rd,vec3 lightPos,vec3 lightAtten,vec3 lightCol,vec2 fragCoord) {\n    vec3 col;\n    vec2 rs=castRay(ro,rd);\n    float t = rs.y;\n    vec3 flareCol=vec3(0.0);\n\n    if(rs.x!=0.0) {\n        vec3 p = ro + t*rd;\n        vec3 p2 = ro + (t-0.1)*rd;\n        vec3 n = getNormal(p);\n        vec3 r=reflect(rd,n);\n        col=calcMtrlCol(rs.x,p,n);\n        col=calcPtLightCol(p,n,lightPos,lightAtten,lightCol,col,0.45,0.25)+col*0.075;\n\n        vec2 offset=fragCoord.xy;\n        vec3 rf=normalize(reflect(rd,n));\n\n\t\tmat3 rfmat=rotMatFromNormal(n,rf);\n        for(int u=0;u<GLOSS_RAYS_NUM;u++) {\n            offset=jitter(offset,GLOSS_RAYS_SPREAD);\n            vec3 jj=normalize(rfmat*vec3(offset.x,offset.y,1.0));\n            col=mix(col,render3(p2,jj,lightPos,lightAtten,lightCol),0.1);\n        }\n    } else {\n        col= vec3(0.1);\n    }\n\n    col=mix(col,lightCol*1.5,calcFlare(ro,rd,rs,lightPos));\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd,vec3 lightPos,vec3 lightAtten,vec3 lightCol,vec2 fragCoord) {\n    vec3 col=render2(ro,rd, lightPos, lightAtten, lightCol,fragCoord);\n    return vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n    float d=1.0/tan(fovy/2.0);\n    vec3 v=vec3(screen.x*aspect,screen.y,-d);\n    v=normalize(v);\n    return v;\n}\n\nvec3 calcLightPos(float a) {\n    float x=(cos(a) + cos(3.0*a)/3.0 + sin(9.0*a)/9.0)*10.0+cos(a)*8.0;\n    float z=(sin(a) + sin(3.0*a)/3.0+ cos(9.0*a)/9.0 )*10.0+sin(a)*8.0;\n    //+(cos(13.0*a)/13.0+ sin(19.0*a)/19.0)*5.0;\n    //+(sin(13.0*a)/13.0+ cos(19.0*a)/19.0)*5.0;\n    //lightPos.x=(cos(a) + cos(3.0*a)/3.0    + cos(7.0*a)/7.0 + cos(9.0*a)/9.0)*12.0;\n    //lightPos.z=(sin(a) + sin(3.0*a)/3.0    + sin(7.0*a)/7.0 + sin(9.0*a)/9.0)*12.0;\n    return vec3(x,2.5,z);\n}\n\nmat3 rotateAt(vec3 e, vec3 c, vec3 u) {\n  vec3 z=normalize(e-c);\n  vec3 x=normalize(cross(u,z));\n  vec3 y=normalize(cross(z,x));\n  return mat3(x,y,z);\n}\n\nmat3 lookRot(float yaw,float pitch) {\n    vec2 s=vec2(sin(pitch),sin(yaw));\n    vec2 c=vec2(cos(pitch),cos(yaw));\n    return mat3(c.y,0.0,-s.y,s.y*s.x,c.x,c.y*s.x,s.y*c.x,-s.x,c.y*c.x);\n}\n\n#define PI 3.14159265359\n\nfloat atan2(float y,float x) {\n    if(x>0.0) {\n        return atan(y/x);\n    } else if(y>0.0) {\n        return PI/2.0-atan(x/y);\n    } else if(y<0.0) {\n        return -PI/2.0 -atan(x/y);\n    } else if(x<0.0) {\n        return atan(y/x)+PI;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ms = iMouse.xy / iResolution.xy;\n    float aspect=iResolution.x/iResolution.y;\n    float fovy=0.7854;\n\n    float lightAngle=iTime*0.05;\n    vec3 lightPos=calcLightPos(lightAngle);\n\n    vec3 lightAtten=vec3(0.55,0.0001,0.01);\n    vec3 lightCol=vec3(1.0,0.9,0.8);\n\n    vec3 prevLightPos0=calcLightPos(lightAngle-0.7);\n    vec3 prevLightPos1=calcLightPos(lightAngle-0.2);\n\n    vec2 dd= normalize(prevLightPos1.xz-prevLightPos0.xz);\n\n    vec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.5,0.5):ms;//centre view when mouse.xy=0.0,0.0\n\n    float pitch=ms2.y*2.0-1.0;\n    float yaw=-(ms2.x*2.0-1.0)*2.0;// + atan2(dd.x,dd.y)+PI;\n    \n    mat3 at=rotateAt(prevLightPos0,prevLightPos1,vec3(0.0,1.0,0.0));\n    mat3 look=lookRot(yaw,pitch);\n    mat3 viewRot=at*look;\n\n    vec3 ro=prevLightPos0;\n    vec3 rd=viewRot*calcPrimaryRay(uv*2.0-1.0,fovy,aspect);\n\n    vec3 c=render(ro,rd,lightPos,lightAtten,lightCol,fragCoord);\n\n    //c=mix(c,vec3(1.0),step(floor(length(abs(fragCoord-iMouse.xy)-vec2(4.0))),0.0));\n\tc=mix(c,vec3(1.0),step(abs(floor(length(abs(fragCoord-iMouse.xy)))-4.0),1.0));\n    fragColor = vec4(c,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyGWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyGWR", "name": "Cube Relay", "author": "r1sc", "description": "Just messing around with IQ's distance functions", "tags": ["signeddistancefield"], "likes": 3, "viewed": 107, "date": "1474063279", "time_retrieved": "2024-06-20T18:41:35.218631", "image_code": "#define STEPS 128\n#define STEP_SIZE 0.01\n#define MIN_DISTANCE 0.1\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat opTx( vec3 p, mat3 m )\n{\n    vec3 q = p*m;\n    return udBox(q, vec3(2.0, 1.0, 1.0));\n}\n\nmat3 rot;\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return opTx( q, rot );\n}\n\nfloat raymarch (vec3 position, vec3 direction)\n{\n    float dist = 0.0;\n\tfor (int i = 0; i < STEPS; i++)\n\t{\n\t\tfloat distance = opRep(position, vec3(50.0, 50.0, 100.0)) ;\n        dist += distance;\n\t\tif (distance < MIN_DISTANCE)\n\t\t\treturn dist;\n\n\t\tposition += distance * direction;\n\t}\n\treturn 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n\tvec2 uv = vec2(fragCoord.x, fragCoord.y*aspect + (iResolution.y-(iResolution.y*aspect)) / 2.0) / iResolution.xy;\n\tvec3 wPos = vec3(uv*10.0-5.0, 0);\n    vec3 cam = vec3(0.0, 0.0, iTime);\n    float r = sin(radians(10.0)*iTime);\n    rot = mat3(cos(-r), -sin(-r), 0,\n\t\t   sin(-r), cos(-r), 0,\n\t\t   0, 0, 1) * \n          mat3(cos(-r), 0, sin(-r),\n\t\t\t0, 1, 0,\n            -sin(-r), 0, cos(-r));\n    vec3 viewDir = normalize(wPos - cam) * -rot;\n    vec3 light =  normalize(vec3(cos(iTime), 0.0, -0.4));\n    float d = dot(viewDir, light) * 1.0;\n    \n    float hit = raymarch(wPos, viewDir);\n    fragColor = mix(vec4(1,1,1,1), vec4(1.0*d,0,0,1), hit);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlG3WR", "name": "Telescope Waves", "author": "Zeliss", "description": "Trying to make an artsy view of waves through a telescope :)", "tags": ["procedural", "waves", "sin"], "likes": 2, "viewed": 359, "date": "1474101393", "time_retrieved": "2024-06-20T18:41:35.218631", "image_code": "float waveness(vec2 center, vec2 pos, float time, float lightness, float size, float blurriness)\n{\n\tfloat elevation = pos.y - center.y + size*sin(pos.x/(2.3*size) + time*2.0);\n\treturn lightness + smoothstep(blurriness, -blurriness, elevation);  \n}\n\nfloat manyWaves(vec2 center, vec2 pos, float time)\n{    \n    const float numWaves = 5.0;\n    float waves = 0.0;\n    for (float i = 0.0; i < numWaves; i++) {\n        float wave = waveness(center, pos - vec2(0.0, i*20.0 - 50.0), time + i*0.1, i*0.17, 2.0*numWaves - 2.0*i, 11.0);\n        waves = mix(waves, wave, 1.0 - i/numWaves);\n    }\n    return waves;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 skyColor = vec4(0.5, 0.78, 0.9, 1.0);\n    vec4 seaColor = vec4(0.0, 0.03, 0.4, 1.0);\n    \n    vec2 pos = fragCoord.xy;\n    vec2 center = vec2(0.5, 0.5)*iResolution.xy;\n    vec2 pan = vec2(-(iMouse.x-center.x)/2.0, 0.0);\n    float dist = distance(pos + pan, center);\n    float tubeness = smoothstep(110.0, 120.0, dist);\n    float time = iMouse.x/300.0 + iTime;\n    \n    vec2 tubeCoord = center + 45.0*-normalize(pos - center + pan);\n    float tubeLight = manyWaves(center, tubeCoord, time);\n    float vignette = smoothstep(120.0, 80.0, dist);\n\n    float pitch = 2.5*sin(iTime/1.5);\n    vec4 imageColor = vignette * mix(skyColor, seaColor, manyWaves(center, pos+vec2(0.0, pitch), time));\n    vec4 tubeColor = mix(skyColor, seaColor, tubeLight);\n    tubeColor = pow(smoothstep(600.0, 150.0, dist), 3.0) * mix(vec4(0,0,0,1), tubeColor, 0.7);\n    \n\tfragColor = mix(imageColor, tubeColor, tubeness);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlG3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlG3zm", "name": "ToyDivision", "author": "seani", "description": "Tried to recreate the classic Joy Division album art.\n\nhttps://en.wikipedia.org/wiki/Unknown_Pleasures", "tags": ["2d", "joydivision"], "likes": 34, "viewed": 1143, "date": "1473828143", "time_retrieved": "2024-06-20T18:41:35.218631", "image_code": "//By Sean Irby\n//sean.t.irby@gmail.com\n\n\nvec2 wTopLeft = vec2(-0.5, 0.7);\nvec2 wBottomRight = vec2(0.5, -0.7);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n    float unit = 1.0/freq;\n    vec2 ij = floor(p/unit);\n    vec2 xy = mod(p,unit)/unit;\n    xy = .5*(1.-cos(3.14*xy));\n    float a = rand((ij+vec2(0.,0.)));\n    float b = rand((ij+vec2(1.,0.)));\n    float c = rand((ij+vec2(0.,1.)));\n    float d = rand((ij+vec2(1.,1.)));\n    float x1 = mix(a, b, xy.x);\n    float x2 = mix(c, d, xy.x);\n    return mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n    float persistance = .5;\n    float n = 0.;\n    float normK = 0.;\n    float f = 9.;\n    float amp = 0.5;\n    int iCount = 0;\n    for (int i = 0; i<50; i++){\n        n+=amp*noise(p, f);\n        f*=2.;\n        normK+=amp;\n        amp*=persistance;\n        if (iCount == res) break;\n        iCount++;\n    }\n    float nf = n/normK;\n    return nf*nf*nf*nf;\n}\n\nfloat window(float x, float i)\n{\n\treturn smoothstep(wTopLeft.x+0.1, -0.1, x)*(1.0-smoothstep(0.1,wBottomRight.x-0.1, x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float y = wTopLeft.y;\n    float inc = ((wTopLeft.y - wBottomRight.y) / 60.0);\n    float waveYLast = 0.0;\n    float waveY;\n    float thickness;\n    float ret = 0.0;\n    \n    //draw waveforms\n    if(wTopLeft.x < uv.x && uv.x < wBottomRight.x)\n    {\n        for(float i = 0.0; i < 60.0; i++)\n        {\n            //generate waveform from audio fft and perlin noise\n            waveY = 2.5*texture(iChannel0, vec2(i/50.0, 0.25)).x;\n            waveY = waveY*pNoise(vec2(uv.x + iTime/5.0, y), 3)/2.0;\n\n            //apply window function\n            waveY = waveY*window(uv.x, i);\n\n            //add offset\n            waveY = mix(waveY+y, waveY, 0.5+0.5*sin(iTime*0.6));\n\n            //draw waveform\n            float thickness = 5./iResolution.y + abs(dFdx(waveY))*iResolution.y*0.0025;\n            ret = mix(ret, 1.0, 1.0-smoothstep(0.0, thickness, distance(vec2(uv.x, waveY), uv)));\n\n            \n            //mask y values below waveform\n            ret = ret*(smoothstep(waveY-thickness/2.0, waveY+thickness/2.0, uv.y));\n\n            //update loop vars\n            waveYLast = waveY;\n            y -= inc;\n        }\n    }\n    \n   \n    fragColor = vec4(1.0*ret, 1.0*ret, 1.0*ret, 1.0);\n}", "image_inputs": [{"id": "MsB3zW", "previewfilepath": "https://soundcloud.com/joewalsh1892/joy-divison-love-will-tear-us", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/joewalsh1892/joy-divison-love-will-tear-us", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlG3zm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlGGDh", "name": "Simple Cube Rotation + Twist", "author": "cacheflowe", "description": "I'm trying to learn more. Sorry so basic! Suggestions are welcome.", "tags": ["cube", "rotation", "twist"], "likes": 21, "viewed": 1901, "date": "1474386356", "time_retrieved": "2024-06-20T18:41:35.745912", "image_code": "#define ITERATIONS 64\n#define SDF_THRESHOLD 0.0001\n#define CUBE_SIZE 0.6\n#define BG_COLOR vec3(1,1,1)\n#define PI 3.141592653589793238462643383\n\n// --------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n// updated by @stduhpf to be 3x3 - thank you!\n// also thanks to @FabriceNeyret2 for code optimizations.\n// --------------------------------------------------------\n\nmat3 rotationMatrix(vec3 m,float a) {\n    m = normalize(m);\n    float c = cos(a),s=sin(a);\n    return mat3(c+(1.-c)*m.x*m.x,\n                (1.-c)*m.x*m.y-s*m.z,\n                (1.-c)*m.x*m.z+s*m.y,\n                (1.-c)*m.x*m.y+s*m.z,\n                c+(1.-c)*m.y*m.y,\n                (1.-c)*m.y*m.z-s*m.x,\n                (1.-c)*m.x*m.z-s*m.y,\n                (1.-c)*m.y*m.z+s*m.x,\n                c+(1.-c)*m.z*m.z);\n}\n\n// --------------------------------------------------------\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// --------------------------------------------------------\n\nfloat udBox( vec3 p, vec3 b ) {\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udBoxTwisted( vec3 p, vec3 b, float twist )\n{\n    float c = cos(twist*p.y);\n    float s = sin(twist*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return udBox(q, b);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // basic raymarching template from @nicoptere: https://www.shadertoy.com/view/ldtGD4\n    // 1 : get fragment's coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\t\t\t\t\t\t\t\t\t// Move to center\n    uv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio\n    \n    // 2 : camera position and ray direction\n    float cubeZ = -3.;\n\tvec3 pos = vec3( 0, 0, cubeZ);\n\tvec3 dir = normalize( vec3( uv.x, uv.y, 1.) );\n \n\t// 3 : ray march loop. ip will store where the ray hits the surface\n\tvec3 ip;\n \n\t// variable step size\n\tfloat t = 0.0;\n\tint found = 0;\n    int last_i = 0;\n    float time = iTime/1.;\n    \n\tfor(int i=0; i < ITERATIONS; i++) {\n\t\tlast_i = i;\n\n        //update position along path\n        ip = pos + dir * t;\n \n        // gets the shortest distance to the sdf shape. break the loop if the distance was too small. this means that we are close enough to the surface\n    \tvec3 ipRotated = ip * rotationMatrix(vec3(0.,-3.,0.7), 3.3 * sin(time));\n        // float temp = udBox( ipRotated, vec3(CUBE_SIZE) );\n        float temp = udBoxTwisted( ipRotated, vec3(CUBE_SIZE), -sin(PI*0.5 + time) * 1.2 );\n\t\tif( temp < SDF_THRESHOLD ) {\n\t\t\tip = vec3(\n                0.4 + 0.2 * sin(1. + time + ip.x),\n                0.8 + 0.2 * sin(2. + time + ip.y),\n                0.7 + 0.2 * sin(3. + time + ip.z)\n            );\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//increment the step along the ray path\n\t\tt += temp;\n\t}\n\t\n\t// make background black if no shape was hit\n\tif(found == 0) ip = BG_COLOR;\n \n\t// 4 : apply color to this fragment\n\tfragColor = vec4(ip, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlGGDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlGGDw", "name": "2D trabeculum - 2", "author": "FabriceNeyret2", "description": "Voronoi diagram are nice, but for CG use several goodies are welcome. \nIQ shown how to regularize the distance to border. \nI shown how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nHere, I join both ideas.", "tags": ["procedural", "2d", "voronoi", "noise", "worley", "short", "trabeculum"], "likes": 11, "viewed": 1018, "date": "1474979191", "time_retrieved": "2024-06-20T18:41:36.255063", "image_code": "// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+.5)/256., -100. ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 dist(vec2 g, vec2 x) {\n    vec2 n = floor(x), f = fract(x),\n         o = hash2( n + g );\n\t#ifdef ANIMATE\n    o = .5 + .5*sin( iTime + 6.2831*o );\n    #endif\t\n    return g + o - f;\n}\n\nvec4 voronoi( vec2 x )\n{\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8., md2, md3;\n    for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ ) {\n            vec2  g = vec2(i,j), \n                  r = dist(g, x);\n            float d = dot(r,r);\n\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\n        }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.;\n    for( int j=-2; j<=2; j++ )\n        for( int i=-2; i<=2; i++ ) {\n            vec2 g = mg + vec2(i,j),       // around cell of closest\n                 r = dist(g, x);\n\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\n                float d = dot( .5*(mr+r), normalize(r-mr) );\n                if ( d < md ) md3=md2, md2=md, md=d;\n                else if (d < md2 ) md3 = md2, md2=d;\n                else  if (d < md3 ) md3 = d;\n            }\n        }\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\n}\n\n\nvoid mainImage( out vec4 O,  vec2 p )\n{\n    p /= iResolution.x;\n\n    vec4 c = voronoi( 8.*p );\n    float d = c.x;              // original IQ's constant border width Voronoï \n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\n    // d = 2./(1./c.y+1./c.z);  // 3D\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\n    \n\t// isolines\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\n    // borders\t\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\n\n    // feature points\n\tfloat dd = length( c.zw );\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\n\n\tO = vec4(col,1.);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlGGDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlK3D1", "name": "Sono's Circles 2", "author": "sonofbryce", "description": "variation of experiments with circles.", "tags": ["circles"], "likes": 1, "viewed": 389, "date": "1474534609", "time_retrieved": "2024-06-20T18:41:36.255063", "image_code": "#define CIRCLE_COUNT 16\t\t\t// number of circles drawn\n\nvec2 r;\n\nfloat drawCircle(vec2 center, float radius)\n{\n    return 1.0 - smoothstep(0.0, radius, length(r - center));\n}\n\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\n// from GLSL tut https://www.shadertoy.com/view/Md23DV\nvec3 drawRing(float circleRadius, float gap, float speed, float radius, vec3 cColor)\n{\n    vec3 color = vec3(0,0,0);\n    for (int i=0; i < CIRCLE_COUNT; i++ )\n    {\n        float j = float(i);\n\n        vec2 center = vec2( sin( (j * gap) + (iTime * speed)) * radius,\n                           cos( (j * gap) + (iTime * speed) ) * radius);\n        //color += vec3(drawCircle(center, circleRadius));\n        \n        //vec2 _cRadius = vec2(circleRadius);\n        \n        disk(r, center, circleRadius, cColor, color );\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    r =  2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0,0.2,0.2);\n    float alpha = 1.0;\n    \n    float speed = 1.0 + sin(iTime * 0.001) * 2.0;\n    float radius = 0.1 + ( (1.0 + sin(iTime * speed)) * 0.1);\n    float gap = 6.28 / float(CIRCLE_COUNT);\n    \n    float circleRadius = 0.01 + ( (1.0 + sin(iTime * speed)) * 0.1);\n    float circleRadius1 = 0.01 + ( (1.1 + sin(iTime * speed)) * 0.08);\n    float circleRadius2 = 0.01 + ( (1.0 + sin(iTime * speed)) * 0.1);\n    float circleRadius3 = 0.01 + ( (1.0 + sin(iTime * speed)) * 0.1);\n    \n    float ringRadius1 = 0.1 + ( (1.0 + sin(iTime * speed)) * 0.1);\n    float ringRadius2 = 0.0 + ( (1.0 + sin(iTime * speed)) * 0.5);\n    float ringRadius3 = 0.1 + ( (1.0 + sin(iTime * speed)) * 0.3);\n    \n    \n    vec3 cColor1 = vec3(1.0, 0.0, 0.0);\n    vec3 cColor2 = vec3(0.0, 1.0, 1.0);\n    vec3 cColor3 = vec3(1.0, 0.0, 1.0);\n    \n    float colorShift1 = 0.5 + (1.0+sin(iTime*speed)) * 0.5;\n    float colorShift2 = 0.5 - (1.0+sin(iTime*speed)) * 0.5;\n    \n    cColor1.g = colorShift1 * 0.4;\n    cColor2.g = colorShift1;\n    cColor3.b = colorShift1;\n    \n    \n    \n    //color += drawRing(circleRadius, gap, speed, radius);\n    //color += drawRing(circleRadius, gap, speed, radius + 0.5);\n    \n    disk(r, vec2(0,0), 0.08 +circleRadius * 0.5, vec3(1.0, colorShift1, colorShift2), color );\n    \n    color += drawRing(circleRadius3, gap, speed * 0.5, ringRadius3 * 1.2, -cColor2 * 0.05);\n   \tcolor += drawRing(0.25 + circleRadius3 * 1.5, gap, -speed * 0.5, 1.0 + (ringRadius2 * 0.3), -cColor2 * 0.02);\n    \n    color += drawRing(circleRadius1, gap, speed, ringRadius1, cColor1);\n    color += drawRing(circleRadius2, gap, -speed, ringRadius2 + 0.1, cColor2);\n    color += drawRing(circleRadius3, gap, speed, ringRadius3 + 0.5, cColor3);\n    \n    \n    \n    fragColor = vec4(color, alpha);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlK3D1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlK3WW", "name": "Binary Cortex", "author": "gigatron", "description": "Binary cortex simulation ... based on vox shader ; also skaven/future crew second reality on Air : by hexen ", "tags": ["binary", "digit"], "likes": 4, "viewed": 130, "date": "1474741246", "time_retrieved": "2024-06-20T18:41:36.255063", "image_code": "// GIGATRON FRANCE ... some digit code based from Vox shader :Follow the white rabbit \n// so thx to him ; and Amiga Rulez !!\n#define PI 3.14159265359\n#define GR 1.21803398875\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n#define MATRIX_W (MAX_DIM/20.0)\n#define MATRIX_H (MAX_DIM/50.0)\n\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float w=texture(iChannel0,uv).r; // get first value !\n    \n    vec2 my = fract(uv*vec2(MATRIX_W,MATRIX_H));\n    vec2 bh = floor(uv*vec2(MATRIX_W,MATRIX_H));\n    \n    // permutation is based on wave sample w index !\n    (w<0.2) ? 1.5 :2.5; // alien code !!\n    \n    float number = (mod(w+iTime*PI*cos(bh.x-bh.y*MATRIX_W), 1.));\n     float digit = SampleDigit(number, GR*my);\n       \n      \n    float t=iTime*0.2;\n    float sp=-2.;\n    float ec=20.;\n    float fd=0.1;\n    \n    float r=abs(sin(uv.x+uv.y*ec-(t*sp)));\n\tfloat g=abs(sin(uv.x-uv.y*ec-(t*sp)));\n\tfloat b=abs(sin(uv.x*uv.y*ec-(t*sp)));\n\t\n    \n    vec3 col = vec3(1);\n    col *= mix(vec3(0.),vec3(r,g,b)-fd,digit);\n\n\tfragColor = vec4(vec3(col), 1.0);\n  \n}", "image_inputs": [{"id": "ldjGRD", "previewfilepath": "https://soundcloud.com/hexen-1/second-reality-future-crew", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/hexen-1/second-reality-future-crew", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlK3WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlKGRD", "name": "Deep realms 2!", "author": "Imsure1200q_1UWE130", "description": "New deep realms which:\nReally is deep,\nHas light of a flashlight\nRaymarching\n\nThank You for viewing.\n", "tags": ["raymarching", "light", "cave", "realm"], "likes": 2, "viewed": 562, "date": "1473652171", "time_retrieved": "2024-06-20T18:41:36.255063", "image_code": "const float KEY_SP    = 32.5/256.0;\nstruct arc{\n    vec2 x;\n    vec2 y;\n    vec2 z;\n};\nfloat art(vec2 base)\n{\n    float x = length(base - 1.0);\n    float x2 = length(1.0 - base); //This is a max negative\n    float q = smoothstep(length(base), x2, x) - sqrt(max(max(x, 0.0),max(x2, 0.0)));\n    arc h = arc(vec2(x, x2) - base, vec2(q, x), vec2(q, x2));\n    vec3 part = vec3(h.x, h.y.x);\n    vec3 part2 = vec3(h.y.y, h.z);\n    vec3 hsec = vec3(dot(min(cos(h.x.x),sin(h.x.y)),\n                        max(cos(h.y.x),sin(h.y.y)))\n                    - length(sqrt(h.z.x) - cos(h.z.y)));\n    return length(hsec);\n    \n}\nfloat map(vec3 p)\n{\n    return length(max(vec3(dot(sin(p),cos(p))),cos(p))*2.0-1.0) - 3.0;\n}\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 1.0) ).x;\n}\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 24; i++)\n    {\n        vec3 p = ro+t*rd;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd.xz *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    float t = trace(ro, rd);\n    float fog = 1.0/(1.0+t*t*0.1);\n    vec3 fc = vec3(fog);\n    if(isKeyPressed(KEY_SP) > 0.0) //Much less light\n    {\n        fc *= 0.1;\n        fc += sqrt(sqrt(length(fog)));\n        fc += vec3(.6, .025, .125) - 0.3 - length(uv+rd.xy);\n    }\n    else //Much more light\n    {\n        fc /= 0.1;\n        fc /= sqrt(sqrt(length(fog)));\n        fc += vec3(.6, .025, .125) - 0.3 - length(uv+rd.xy);\n    }\n\tfragColor = vec4(art(uv/uv)/length(uv-rd.xz)) * vec4(fc, 1.0) +\n        0.0 + vec4(0.025, 0.025, 0.025, 1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlKGRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mlt3Dl", "name": "Menger Sponge Designs", "author": "Yusef28", "description": " Learned a lot from Shane's examples. Tried to make my own textures. I have put 3 variations of texture \"texture options\" and 7 variations of color/tile designs (\"coloring options\") in the pattern function. Otherwise code is a mess, I'll clean it up soon.", "tags": ["menge"], "likes": 19, "viewed": 512, "date": "1473019632", "time_retrieved": "2024-06-20T18:41:39.340250", "image_code": "\n\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nmat2 rot(float a)\n{\n    \n float si = sin(a);\n    float cs = cos(a);\n    \n    mat2 mat= mat2(cs, -si, si, cs);\n    return mat;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat oldnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/200., -100.0 ).y-0.4;\n}\n\n\nmat2 mat = mat2(.944, -.640, 1.124, 1.076);\n\nfloat oldfbm(vec2 st)\n{\n    float f = noise(st)*0.5; st*=2.02*mat;\n    f += noise(st)*0.25; st*=2.04*mat;\n    f += noise(st)*0.125; st*=2.03*mat;\n    f += noise(st)*0.06125; st*=2.03*mat;\n    \n    return f;\n}\n\n\nfloat fbm(vec2 p)\n{\n    \n float f;\n    \n    f = noise(p)*1.; p*=2.01;\n    f += noise(p)*.5; p*=2.04;\n    f += noise(p)*.25; p*=2.03;\n   // f += noise(p)*.125; p*=2.02;\n    //f += noise(p)*.06125; p*=2.012;\n    \n    return f;\n    \n}\n\nvec3 pattern(vec2 p)\n{\n vec2 lp = p;\n    vec2 id = p*5.;//5 because 10 mod 2\n     id = floor(random2(floor(id)+04.));\n    \n   \n    p = mod(p*9., 2.)-1.;\n    //p.xy*=rot( 3.14159/2.*(floor(id.x)+floor(id.y) ) );\n    float rect = fbm(vec2(p.x+floor(lp.x*5.), p.y+floor(lp.y*5.))/3.)*0.5+0.5;\n    \n    \n    \n    //TEXTURE OPTIONS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     //upddate: changed the 5's to 4.5s because mod is now of p*9 and that affects this fbm version.\n    \n    rect = fbm(vec2(p.x+floor(lp.x*4.5), p.y+floor(lp.y*4.5))/3. + fbm(p*8.))*0.5+0.5; \n    \n   \n    //rect = fbm(vec2(p.x+floor(lp.x*4.5), p.y+floor(lp.y*4.5))*1. + fbm(lp*12.))*0.5+0.5;\n    //rect = oldfbm(vec2(p.x+floor(lp.x*4.5), p.y+floor(lp.y*4.5))/3.)*0.5+0.5;\n    //////////////////////////////////////////////////////////////\n    \n    \n    \n    ///make lines for tiles whcih double as indents in the bump mapping\n    \n    ///some machines don't like nagative powers!!!\n   /// rect*=1.0-pow(p.x, 20.);\n   // rect*=1.0-pow(p.y, 20.);\n    \n    rect*=1.0-pow(abs(p.x), 20.);\nrect*=1.0-pow(abs(p.y), 20.);\n    \n\n     p.y+=sin(p.x*1.+cos(p.y*2.+sin(p.y*2.)/1. )/30.)/1.;\n     p = fract(p*2.);\n    //rect = pow(rect, 1./1.02)*3.;\n    float c = rect;\n    //rect *= fbm(lp*6.)*0.5+0.5;\n    vec3 color = vec3(rect);\n        \n    \n    \n    ///COLORING OPTIONS, !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    color = mix( vec3( c*c, c*c*c, c-0.8), vec3(0.1, 0.4, 0.9)/6., rect)*4.+id.x;\n\n  color = mix( vec3( c*c, c*c*c, c-.8), vec3(0.5, 0.4, 0.9)/2., rect)*4.+id.x;\n   color =  vec3(c, c*c*c*c, c*c*c*c*c*c*c*c*c*c);\n   //color = 0.5+0.5*cos(vec3(0.850,0.323,0.134)*3.+c+vec3(5.304,2.164,4.124)/6.)*4.;\n\n    //color = 0.5+0.6*cos(vec3(0.212,0.337,0.850)*8.9 +c);\n    //color = 0.5+0.5*cos(vec3(0.212,0.337,0.850)*4.2+ pow(c, 1./3.))*8.;\n   // color = (0.5+0.5*cos(vec3(0.212,0.337,0.850)*4.2 +(1.+pow(c, 1./1.)) )-0.4);\n    \n    \n    \n    \n    \n    \n    return clamp(color, 0.0, 1.0);//need to clamp or else darks go to negative and light wont show up on it. which would be a shame...\n}\n\nvec3 pattern2(vec2 p)//for bumps\n{\n    \n    vec3 color;\n    \n    vec2 lp = p;\n    vec2 id = p*5.;//5 because 10 mod 2\n     id = floor(random2(floor(id)+04.));\n    \n   \n    p = mod(p*9., 2.)-1.;\n    p.xy*=rot( 3.14159/2.*(floor(id.x)+floor(id.y) ) );\n    float rect = 1.;;\n    \n   //rect*=1.0-pow(p.x, 40.);\n   //rect*=1.0-pow(p.y, 40.);\n\n            \n    rect*=1.0-pow(abs(p.x), 20.);\nrect*=1.0-pow(abs(p.y), 20.);\n        \n        color = clamp(vec3(rect), 0.85, 1.);\n    \n return color;   \n}\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n       }\n\n\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n   // p/=10.;\n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(pattern(p.yz*8.)*norm.x + \n                pattern(p.xz*8.)*norm.y +\n                pattern(p.xy*8.)*norm.z ) ;\n    \n}\n\nvec3 triPlanar2(sampler2D tex, vec3 p, vec3 n)\n{\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n   // p/=10.;\n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(pattern2(p.yz*8.)*norm.x + \n                pattern2(p.xz*8.)*norm.y +\n                pattern2(p.xy*8.)*norm.z ) ;\n    \n}\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n    //ok so I don't understand this technique yet.\n    //I mean I can visualize getting the greyscale values from the texture \n    //at three points around the ref, based on the point and the normal.\n    \n    //usually if you want a gradient you\n    //want to get the difference between the ref and points around it\n    \n    //we do this when we take the normal although in that cause we are \n    //getting distances. Here we imply distance by getting greyscale values.\n    //the resulting gradient then cna be considered a normal because each of\n    //it's components is a basis vector that is the slope between the \n    //the components of the ref and the point representing the change from that point\n    //to a bit away.\n    \n    \n    \n    const vec3 eps = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps.yzx, n)) - ref)/eps.xxx;\n    \n    //so grad is the normal...then he does:\n    grad -= n*dot(grad, n);//takes the dot of the surface normal \n    //and the texture normal (the gradient), so percentage of how similar they are\n    //multplies by the surface normal again so scaling it by that percentage\n    //and subtracting that from the gradient.\n    //so the result is only the portion of the gradient that is not part of n??\n    \n    // and returning the surface normal + that gradient portion plus a bump factor\n    //why???\n    return normalize(n + grad*bumpfactor);\n}\n\n\nfloat sphere(vec3 p, float r)\n{\n    \n return length(p) - r;   \n}\n\nfloat rect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n return max(p.x, max(p.y, p.z));\n}\n\nfloat infRect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n    float f = max(p.x, p.y);\n return f;   \n}\nfloat plane(vec3 p, vec4 n)\n{\n   // p.y = 1.0-p.y;\n return p.y + n.w;//dot(p, n.xyz) + n.w;   \n}\n\n\nfloat infCyl(vec3 p, float r)\n{\n    \n return length(p.xy)-r;   \n}\n\nfloat cylCross(vec3 p, float r)\n{\n p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    return min(length(p.xy), min(length(p.yz), length(p.xz)))-r;\n}\n\nfloat rCross(vec3 p)\n{\n    p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    float k = min(f.x, min(f.y, f.z) ) - 1./3.;\n    \n return k;   \n}\n\nfloat repCross(vec3 p)\n{\n    vec3 q = mod(p+1., 2.)-1.;\n    float f = rCross(q);\n    \n/*\n    q = abs(q)-0.05;\nq = abs(q)-0.7;\n\n    \n    f = min(f, rCross(q) );\n*/\n\n    \n    //cool linething use 1 or 2 loops only\n  \n    \nq = abs(q)-0.5;\n\n   q = abs(q)-0.2;q = abs(q)-0.95;q = abs(q)-0.5;q = abs(q)-0.5;\n    q=abs(q)-0.005;\n    f = min(f, cylCross(q,0.101));\n    \n\n    \n    //2 or three loops\n    \n    /*\nq = abs(q)-0.6;\n    q = abs(q)-0.1;\n    q = abs(q)-0.43;\n    q = abs(q)-0.34;\n    f = min(f, cylCross(q, 0.1) );\n*/\n\n    \n    /*\n   \nq = abs(q)-0.34;\n    //q = abs(q)-0.04;\n    q = abs(q)-0.08;\n    f = min(f, cylCross(q, 0.1) );\n*/\n   /*\n    \n q = abs(q)-0.934;\n    q = abs(q)-0.094;\n    q = abs(q)-0.08;\n    f = min(f, cylCross(q, 0.1) );\n*/\n    \n    \n    // f = cylCross(q, 0.25);\n return f;   \n}\n\nfloat repCylCross(vec3 p)\n{\n    vec3 q = mod(p+1., 2.)-1.;\n    float f =  cylCross(q, 0.05) ;\n return f;   \n}\n\nfloat rcScale(vec3 p, float s)\n{\n    \n return repCross(p*s)/s;\n}\n\n\n\nfloat map(vec3 p)\n   {\n       //p = fract(p);\n     \n      \n    float re = 0.0;\n       float scale = 1.;\n       \n       for(int i=0; i<2 ;i++)\n       {\n        \n        scale*=3.;\n        re = max(re, -rcScale(p, scale)  );\n        //p = abs(p)-0.024;\n       }\n       /* re = max(re, -rcScale(p, scale*2.2)  );\n       //there are a ton of possibilities, which I'm glad shane kind of hinted at\n       \tscale*=17.;//17, 8, 3, even 4\n        re = max(re, -rcScale(p.xyy, scale*3.)  );\n       \n       \n       \tscale*=1.;\n        re = max(re, -rcScale(p.xxy, scale/8.1)  );\n         \n       \tscale*=3.;\n        re = max(re, -rcScale(p, scale/20.)  );*/\n       \n       \n       /*\n         p.xz*=rot(1.9);\n\t\tp.xz = mod(p.xz, .24) - 0.12;\n     p.y/=1.5;\n      \n       re = max(re,  rect(p, vec3(0.1) ));*/\n    return re;//rect(p, vec3(2.5));\n    /*\n    vec3 ss = p;\n    for(int i = 0;i<8;i++)\n    {    \n        p = abs(p)-0.037;\n        p.xz=rot(p.xz,1.6+iTime/3.);\n        //p*=(1.02-float(i)/800.);\n        p = abs(p)-0.3*1.4;;\n        p.xy=rot(p.xy,1.6+iTime/3.);\n        p = abs(p)-0.02*1.4;;\n        p*=1.3;\n        \n        \n    }\n    //p = fract(p/4.)-.5;\n    float  s = rect(p, vec3(0.2));\n    s =  max(s, -sphere(ss, .5));\n    //s = sphere(p, 0.5);\n   //s = min(sphere(p+vec3(0., 1.,.2), 0.2), s);\n    return s;*/\n\n\n\n\n    /*\n \t vec2 pos = vec2(p.xz/5.);//vec2(st.x*5.0, 1./st.y*4.0);\n\tfloat c1 = fbm(pos);\n    \n    float ter = smoothstep(.5,1.95, sin(p.z*24.))*smoothstep(0.5,1.9, sin(p.x*24.));//(1.0-pow(c1, 1.)-0.768);\n    //p.y+=ter;\n   // ter += smoothstep(0.5,1.9,sin(p.x/1.)/1.)+smoothstep(1.,2.,abs(sin(p.x*3.)*1.));\n    //ter +=(smoothstep(.5,1.95, sin(p.z*2.))+smoothstep(0.5,1.9, sin(p.x*2.)));;\n    // ter +=smoothstep(.5,1.95, sin(p.z*4.))+smoothstep(0.5,1.9, sin(p.x*4.));   \n       // ter +=smoothstep(.5, 1.95, 0.5+0.5*sin(p.z/2.)+smoothstep(.5, 1.95, sin(p.z/2.))*1.);//+smoothstep(0.5,1.9, sin(p.x*1.));;\n  float x = p.x/4.;\n    ter += smoothstep(0.0,0.5,fract(x/4.))+smoothstep(0.0,0.5,fract(x/2.));\n    float pl = plane(p, vec4(0., 1., 0., pow(ter, 2.)*8.));\n    \n \tp = mod(p, 1.)-0.5;   \n    return pl;//min(pl, sphere(p, 0.02));//sphere(p, 0.2);*/\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float eps = 0.001;\n    float dist;\n    float t = 0.0;\n    for(int i = 0;i<96;i++)\n    {\n        dist = map(ro+rd*t);\n    if(dist<eps || t > 120.)\n        break;\n    \n    t +=dist*0.95;\n    }\n    \n    return t;\n\t    \n}\n\n\n//based on shanes reflection tutorial\nfloat rtrace(vec3 ro, vec3 rd)\n{\n    float eps = 0.0001;\n    float dist;\n   \tfloat t = 0.0;\n    \n    for(int i=0; i<48; i++)\n    {\n     dist = map(ro + rd*t);\n        if(dist<eps || t > 120.)\n            break;\n        \n      t += dist;\n        \n    }\n    \n    \n return t;   \n}\nvec2 path(vec3 p)\n{\n    \n float a = sin(p.z*1.)/3. ;\n     float b = cos(p.z)/3.;\n    return vec2(a, b);\n}\n\n\n\nvec3 normal(vec3 sp)\n{///had to adjust the normal cause I was getting these weird lines on edges.\n    vec3 eps = vec3(.0014, 0.0, 0.0);\n    \n    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)\n                       ,map(sp+eps.yxz) - map(sp-eps.yxz)\n                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));\n    \n    \n return normal;   \n}\n\n//guess who this is from...shane\n// \"I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\"\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//based on shanes lighting function but i added reflections using a cubemap\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)\n{\nvec3 color;\n    \n    //some other experiemnts\n    //where the id's are based on cells you don't need to pass the id variable around\n    //you can just recreate it where needed.\n    /*float id = rnd(floor(sp.xz));\n    float id1to3 = floor(id*3.0);\n    float one = step(1., id1to3);\n    float two = step(2., id1to3);\n    float three = step(3., id1to3);///hmmm*/\n    \n    //vec3 tex = texture(iChannel0, sp.xz).xyz*one;\n    sn = bumpMap(iChannel0, sp, sn, 0.0015);\n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.01);\n    vec3 ldir = lv/ldist;\n    \n    float atte = 1.0/(1.0 + 0.002*ldist*ldist );\n    \n    float diff = dot(ldir, sn);\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);\n\tfloat ao = calculateAO(sp, sn);\n    \n    vec3 refl = reflect(rd, sn);\n    vec3 refr = refract(rd, sn, 0.7);\n    \n   vec3 color2 = vec3(0.2, 0.5, 0.9);\n    vec3 color3 = vec3(0.0);\n    //getting reflected and refracted color froma cubemap, only refl is used\n   // vec4 reflColor = texture(iChannel1, refl);\n   // vec4 refrColor = texture(iChannel2, refr);\n     \n    //blue vs orage specular, orange all the way.\n    vec3 coolSpec = vec3(.3, 0.5, 0.9);\n    vec3 hotSpec = vec3(0.9,0.5, 0.2);\n   color2 = triPlanar(iChannel0, sp, sn);\n    //+reflColor.xyz*0.2\n    //apply color options and add refl/refr options\n    color = (diff*color2*8. +  spec*coolSpec*9.  )*atte;\n\t\n    \n    //apply ambient occlusion and return.\n return color*ao;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 lk = vec3(0.,0, 0.+iTime/4.);\n    \n    //lk.xy+=vec2(2.34,.34);//path(lk/4.);//lk.xz*=rot(lk.z);//;\n    vec3 ro = lk + vec3(0., 0., -1.0);\n    vec3 lp = ro + vec3(0, 0., 0.);//lp is ro so no area is too dark\n   \tfloat FOV = .57;\n    \n    vec3 fwd = normalize(lk - ro);\n    vec3 up = vec3(0., -1., 0.0);\n    vec3 rr = normalize(cross(up, fwd));\n    vec3 uu = normalize(cross(rr, fwd));\n    \n    vec3 rd = normalize(vec3(rr*FOV*uv.x + uu*FOV*uv.y + fwd));\n    \n   rd.yz*=rot(iTime/5.);\n    rd.xz*=rot(iTime/10.);\n    //rd.xz*=rot(sin(iTime)/4.);\n    float t = trace(ro, rd);\n    \n     vec3 sp = ro + rd*t;\n    vec3 sn = normal(sp);\n   \t\n    float far = smoothstep(0.0, 1.0, t/4.);\n    \n    //get cube color from cubemap again this time to apply to the sky,\n    //really just so that the reflections on the ground make sense\n    \n  //  vec4 cubeColor = texture(iChannel1, rd);\n    vec3 color = lighting(sp, sn, lp, rd);//mix(stripes(ro+rd*t),vec3(t), far);\n     //reflection trace based on shanes reflection tutorial\n    vec3 refRay = reflect(rd, sn);\n    float rt = rtrace(sp+refRay*0.01, refRay);\n    vec3 rsp = sp + refRay*rt;\n    vec3 rsn = normal(rsp);\n     //\n  // color += lighting(rsp, rsn, lp, refRay)*0.1;\n         //color += clamp(lighting(rsp, rsn, lp, refRay)*0.9, 0.0, 1.);\n   \n    color = mix(color, vec3(2., 2.5, 3.) ,far);//\n    ///color = mix(color, vec3(0.9, 0.5, 0.2), t);\n  // color = vec3(t*t*t, t*t, t*t*t*t*t*t*t);\n  // color = vec3(t/100.);\n    \n    \n    \n    \n    \n    \n    \n\tfragColor = vec4(color,1.0);\n    \n    \n    \n    \n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlt3Dl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlV3R1", "name": "Banding and dithering", "author": "Reedbeta", "description": "Demonstrates 8-bit gradient banding (left) and how it can be corrected with dithering (right).", "tags": ["2d", "banding", "dithering"], "likes": 17, "viewed": 2673, "date": "1473311971", "time_retrieved": "2024-06-20T18:41:39.340250", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Create a gradient that will show banding\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float gray = mix(0.30, 0.22,\n                 .5 + dot(uv - .5, vec2(sin(iTime), 1.0)));\n\tfragColor = vec4(gray,gray,gray,1.0);\n    \n    // Right half of the screen gets dithering\n    if (uv.x > .5)\n    {\n        // Look up noise from texture\n        float noise = texture(iChannel0,\n                      fragCoord.xy/iChannelResolution[0].xy).r;\n\n        fragColor.rgb += mix(-0.5/255.0, 0.5/255.0, noise);\n    }\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlV3R1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlV3RW", "name": "DissolveTest", "author": "rickomax", "description": "Dissolve (wip) - Any tip is appreciated", "tags": ["dissolve"], "likes": 5, "viewed": 432, "date": "1473879098", "time_retrieved": "2024-06-20T18:41:39.340250", "image_code": "#define PI 3.14159265358979323846\n#define HALFPI PI * 0.5\n#define WHITE vec4(1.0,1.0,1.0,1.0)\nfloat rand(vec2 c){\n    return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Paremeters\n    float p = 0.5; //Distance\n    float a = 0.2 * PI; //Angle\n    float v = 0.7; //Velocity\n    float s = smoothstep(-HALFPI, HALFPI, sin(iTime * v)); \n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    float r = rand(uv); \n    vec2 f = vec2(sin(a) * s, cos(a) * s);\n    uv.x -= r * f.x * p * s;\n    uv.y -= r * f.y * p * s;\n\tvec4 c = texture(iChannel0, uv);\n    vec2 n = normalize(uv.xy - f);\n    float d = dot(f, n);\n    //Todo: Smoothstep?\n    if (d < 0.0) {\n        c = WHITE; //c.a = 0.0;\n    }\n    c = mix(c, WHITE, s); //c.a = s, \n    fragColor = c;\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlV3RW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlV3Rz", "name": "Non-uniform scaling destortion", "author": "vladstorm", "description": "Does anyone know how to get rig of this stupid non-uniform scaling distortion?\nIt's a huge problem. When I'm trying to build sth with primitives and I'm stretching them - I always have this background distortion issue. Or maybe the problem is w sth else", "tags": ["sdf", "distancefunction", "distortion", "scaling"], "likes": 0, "viewed": 198, "date": "1472900080", "time_retrieved": "2024-06-20T18:41:41.019165", "image_code": "//forked : https://www.shadertoy.com/view/Xds3zN\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec3 scale(vec3 p, vec3 s) {\n   \n   s.x = 1.0/s.x;\n   s.y = 1.0/s.y;\n   s.z = 1.0/s.z;\n    \n   mat3 invRot = mat3(s.x, 0. , 0. ,\n                       0., s.y, 0.,\n                       0., 0., s.z);\n    \n \tmat4 trans = mat4(s.x, 0.0 , 0.0 , 0.0, \n                      0., s.y, 0., 0., \n                      0., 0., s.z, 0., \n                      0., 0., 0., 1.0);\n    \n   vec4 newPt = vec4(p, 1.);\n   newPt = trans*newPt;\n   return vec3(newPt);\n                    \n}\nfloat octahedron(vec3 p, float s) { //s- size\n    p = abs(p);\n    return (p.x+p.y+p.z-s)/3.;\n}\n\n//octahedron half\nfloat sdOHH(vec3 p, float s) { //s- size\n    float d = p.y;\n    p = abs(p);\n    return max(-d, (p.x+p.y+p.z-s)/3.);\n}\n\nvec2 map( in vec3 p ){\n\n    \n    vec2 res = opU( vec2( 100000., 1.0 ),\n\t                vec2( sdSphere(    opRep(p, vec3(.5,.0,.5)), 0.05 ), 46.9 ) );\n    //res = opU( res, vec2( sdBox(       p-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    //res = opU( res, vec2( udRoundBox(  p-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\t\n    //float sc = 2\n    //vec3 sc = vec3(.2, 1., .1);\n    //vec2 res = vec2( sdOHH(p, 1.), 1.0);\n    //p += vec3(0., -.5, .0);\n    //p /= 8.;\n    \n    //p = scale(p, s);\n    //res = opU( res, vec2( sdOHH(p, 1.0)*8., 1.0));\n    \n    vec3 s = vec3(.5, 10., 1.)*0.05;\n    res = opU( res, vec2( sdOHH(p/s, 2.0)*min(s.x, min(s.y, s.z)), 1.0));\n    \n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlV3Rz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlVGRR", "name": "Tunnel Beauty 2", "author": "aiekick", "description": "Tunnel Beauty 2", "tags": ["tunnel", "2", "beauty"], "likes": 5, "viewed": 519, "date": "1472833411", "time_retrieved": "2024-06-20T18:41:41.752495", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\t// get rotation matrix near z\n\nvec3 path(vec3 p)\n{\n\tp += sin(p.zxy * 0.5) * 0.5;\n\tp *= RotZ(p.z * 0.2);\n   \treturn sin(p * 0.1) * 5.;\n}\nfloat df(vec3 p)\n{\n\tp *= RotZ(p.z * 0.8 + p.y * 0.2 + p.x * 0.6);\n\tp += path(p);\n\tp *= RotZ(p.z * 0.2);\n\treturn 3. - length(p.xy);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\t\n\tvec2 uv = (g+g-si)/si.y;\n\n\tfloat time = iTime*1.2;\n\t\n\tvec3 ro = vec3(0,0, time*5.);\n\tro -= path(ro);\n\t\n\tvec3 cv = ro + vec3(1.5*vec2(cos(ro.z*.1),sin(ro.z*0.1)),8); // cam view\n\tcv -= path(cv);\n\t\n\tvec3 lp = ro;\t// light pos\n\t\n\tfloat md = 25.;\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<30; i++) // 30 iterations yeah :)\n\t{\n\t\tif (log(d/1e6)>0.) break; // due to this special break condition\n\t\td += df(ro+rd*d);\n\t}\n\t\n\tif (d < md)\n\t{\n\t\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\t\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\t\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\t\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\t\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\t\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\t\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\t\tvec3 col = vec3(0.8,0.5,0.2);\n\t\tfloat sss = df(p - n*0.001)/0.01;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\t\n\t\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\t\tvec3 bb = blackbody(200. * sb);\t\t\t\t\t\t\t\t\t// blackbody color\n\t\tfloat sss2 = 0.8 - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\t\n\t\tvec3 a = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.35 + spe;\n\t\tvec3 b = col * sss;\n\t\t\n\t\tfragColor.rgb = mix(a, b, .8-exp(-0.01*d*d));\n    }\n\telse\n\t{\n\t\tfragColor.rgb = vec3(0);\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlVGRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlVGzW", "name": "heightfield area lighting", "author": "Pyry", "description": "gpu murdering area lighting on a heightfield\nclick the mouse to move the light position around", "tags": ["heightfield", "lighting"], "likes": 6, "viewed": 207, "date": "1473631245", "time_retrieved": "2024-06-20T18:41:42.431333", "image_code": "// a lot of this is cobbled together from iq's \"balls and occlusion\"\n// https://www.shadertoy.com/view/ldX3Ws\n\n#define RIPPLE_FREQ 80.0\n#define RIPPLE_AMP 0.022\n\nvec4 test_heightfield(vec2 uv) \n{\n    // just do a ripple pattern because that's easy\n    vec2 rr = uv - vec2(0.5, 0.28);\n    float r = length(rr);\n    float height = RIPPLE_AMP * sin(RIPPLE_FREQ * r + iTime) + RIPPLE_AMP;\n    \n    // analytic partial derivatives are then also easy\n    float dr = RIPPLE_AMP * RIPPLE_FREQ * cos(RIPPLE_FREQ * r + iTime);\n\tvec2 dxy = normalize(rr) * dr;\n    \n    // normal that is tangent to (1,0,dx), (0,1,dy) is just (-dx, -dy, 1.0)\n    vec3 vvv = normalize(vec3(-dxy.x, -dxy.y, 1.0));\n    \n    // return normal+height packed into rgba\n    return vec4(vvv, height);\n}\n\nfloat test_height(vec3 pos)\n{\n    // just do a ripple pattern because that's easy\n    vec2 rr = pos.xy - vec2(0.5, 0.28);\n    float r = length(rr);\n    float height = RIPPLE_AMP * sin(RIPPLE_FREQ * r + iTime)  + RIPPLE_AMP;\n    return height;\n}\n\n#define eps 0.001\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n#define TRACE_ITERS 10\n#define TRACE_DELTA 0.01\n#define LIGHT_HEIGHT 0.1\n#define LIGHT_SIZE 0.2\n\nvec3 light_strip(in vec2 planepos) {\n    vec2 mousepos = iMouse.xy / iResolution.xx;\n    if(planepos.x + LIGHT_SIZE > mousepos.x && planepos.x - LIGHT_SIZE < mousepos.x \n       && planepos.y + LIGHT_SIZE > mousepos.y && planepos.y - LIGHT_SIZE < mousepos.y){\n        return vec3(1.0,1.0,1.0);\n    } else {\n        return vec3(0.0,0.0,0.0);\n    }\n}\n\nvec2 intersect_light_plane(in vec3 ro, in vec3 rd) {\n    // ro.z + rd.z*t = LIGHT_HEIGHT\n    float t = (LIGHT_HEIGHT - ro.z) / rd.z;\n    return ro.xy + t*rd.xy;\n}\n\nvec3 sample_plane_light( in vec3 ro, in vec3 rd )\n{\n    vec3 curpos = ro + rd; // step it once to avoid issues with a point shadowing itself\n    \n    // Are if statements still a performance killer?\n\tfor( int i=0; i<TRACE_ITERS; i++ )\n\t{\n        float field_h = test_height(curpos);\n        if(curpos.z < field_h) return vec3(0.0, 0.0, 0.0);\n        curpos = curpos + rd;\n\t}\n    if(rd.z > 0.0){\n        vec2 planepos = intersect_light_plane(ro, rd);\n        return light_strip(planepos);\n    } else {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 sample_lighting(vec2 fragCoord, vec3 pos, vec3 nor)\n{\n    vec3 total_light = vec3(0.0, 0.0, 0.0);\n    \n    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n    // (link provided by nimitz)\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n   \tvec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float off = texture( iChannel1, fragCoord.xy/iChannelResolution[1].xy, -100.0 ).x;\n\tfor( int j=0; j<24; j++ )\n\t{\n        // This is blatantly stolen from iq's thing, so I'm not really sure what distribution\n        // of sampling directions this produces\n\t\tvec2  aa = hash2( off + float(j)*203.1 );\n\t\tfloat ra = sqrt(aa.y);\n\t\tfloat rx = ra*cos(6.2831*aa.x); \n\t\tfloat ry = ra*sin(6.2831*aa.x);\n\t\tfloat rz = sqrt( 1.0-aa.y );\n\t\tvec3  rr = vec3( rx*uu + ry*vv + rz*nor );\n        \n        // I'm going to go ahead and weight according to dot(normal, rr) = rz on the assumption\n        // that the above produces a uniform-ish distribution over the hemisphere\n        total_light += sample_plane_light(pos, rr*TRACE_DELTA) * rz;\n\t}\n    \n    // this is not the \"physically correct\" normalization but :effort:\n\ttotal_light /= 24.0;\n    return total_light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx; // Note division by xx to get same scale in x and y\n    vec4 norm_height = test_heightfield(uv);\n    \n    vec3 pos = vec3(uv, norm_height.w);\n    vec3 lighting = sample_lighting(fragCoord, pos, norm_height.xyz);\n    fragColor = vec4(lighting, 1.0); // probably should put a togamma here\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlVGzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mly3RW", "name": "Parabolic saw blades", "author": "rush_2112", "description": "Parabolic saw blades", "tags": ["2d", "parabolic"], "likes": 0, "viewed": 87, "date": "1473434810", "time_retrieved": "2024-06-20T18:41:42.437166", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    \n    \n\tfloat gt = (iTime / 50.0);\n    gt = (gt + 10.0) + gt * 20.0;\n\tfloat algo_r = 0.0;\n\tfloat algo_g = 0.0;\n\tfloat algo_b = 0.0;\n\t\n\talgo_r *= mod(uv.y + (1.0 - uv.x) * cos(uv.x) * uv.y * cos(uv.x), sin(gt) + cos(uv.x) * uv.y * uv.x + cos(uv.x));\n\talgo_r += mod(uv.y * gt + (uv.y * sin(gt)) + sin(uv.x) + (uv.x * tan(gt)), (1.0 - uv.x) * (uv.x * tan(gt)) * sin(uv.x) + uv.y + (1.0 - uv.y));\n\talgo_r += (sin(uv.x) + (uv.x * sin(gt)) * sin(uv.x) + gt * uv.y);\n\talgo_r += tan(sin(uv.x) * (1.0 - uv.x) * cos(uv.x) + sin(uv.x) + sin(uv.x));\n\talgo_r += ((uv.x * tan(gt)) * (1.0 - uv.y) * gt + sin(gt) * 0.42);\n\talgo_r *= distance(sin(uv.x) * (1.0 - uv.y) * (1.0 - uv.y) + gt * sin(gt), gt + gt + (1.0 - uv.x) * (uv.x * tan(gt)) + uv.y);\n\talgo_r += tan((uv.x * tan(gt)) * uv.y * uv.x + cos(uv.x) + uv.x);\n\talgo_r += mod(uv.y * uv.y + uv.x + gt * (1.0 - uv.y), (uv.y * sin(gt)) + (uv.y * sin(gt)) * cos(uv.x) + 3.57 * sin(gt));\n\n\talgo_g *= sin(gt * uv.y + sin(gt) + (1.0 - uv.x) + uv.y);\n\talgo_g += (uv.x + (1.0 - uv.y) + sin(gt) * sin(uv.x) * (uv.y * sin(gt)));\n\talgo_g += sin((uv.x * sin(gt)) + (1.0 - uv.y) + (1.0 - uv.y) * uv.y * gt);\n\talgo_g += tan((uv.x * sin(gt)) + gt + cos(uv.x) + sin(gt) + uv.x);\n\talgo_g *= mod(uv.y + (uv.x * sin(gt)) + (uv.x * tan(gt)) + (uv.x * sin(gt)) * (uv.x * sin(gt)), (1.0 - uv.x) * (1.0 - uv.y) + (1.0 - uv.y) + (1.0 - uv.y) + (1.0 - uv.x));\n\talgo_g *= smoothstep(gt * (1.0 - uv.y) + 3.31 + gt * cos(uv.x), (1.0 - uv.x) * sin(gt) + uv.x * (uv.y * sin(gt)) + gt, (1.0 - uv.y) * (1.0 - uv.y) + sin(uv.x) + cos(uv.x) + (1.0 - uv.y));\n\talgo_g += ((1.0 - uv.y) * uv.x * cos(uv.x) * cos(uv.x) + (uv.x * sin(gt)));\n\talgo_g += tan(uv.y * uv.x * (uv.x * tan(gt)) * uv.y * (uv.x * tan(gt)));\n\n\talgo_b += cos((1.0 - uv.x) * sin(uv.x) * 2.03 * gt * gt);\n\talgo_b += cos((uv.x * sin(gt)) + (uv.x * sin(gt)) * cos(uv.x) * uv.x + 9.53);\n\talgo_b += distance((1.0 - uv.x) * sin(gt) * 4.41 + (uv.x * tan(gt)) + uv.x, sin(uv.x) * cos(uv.x) * (uv.y * sin(gt)) * cos(uv.x) * (1.0 - uv.y));\n\talgo_b += (sin(gt) + gt + (uv.y * sin(gt)) + sin(gt) * (uv.x * tan(gt)));\n\talgo_b += (uv.x + uv.x * (uv.x * tan(gt)) * (uv.y * sin(gt)) + cos(uv.x));\n\talgo_b += (0.66 + (uv.y * sin(gt)) * uv.y * uv.y * (uv.y * sin(gt)));\n\talgo_b += smoothstep((uv.x * tan(gt)) + (uv.x * tan(gt)) * cos(uv.x) * cos(uv.x) + (uv.y * sin(gt)), (1.0 - uv.y) + 6.92 + (1.0 - uv.y) + (uv.x * tan(gt)) * sin(uv.x), cos(uv.x) + (uv.x * sin(gt)) + gt + uv.x + (uv.x * tan(gt)));\n\talgo_b += clamp(cos(uv.x) * gt + sin(gt) * uv.y + sin(uv.x), cos(uv.x) * uv.y * uv.x * uv.x * uv.x, uv.y * (uv.y * sin(gt)) * (uv.x * sin(gt)) + (uv.y * sin(gt)) + uv.y);\n\n\talgo_r = (1.0 - algo_r); algo_r = clamp(algo_r, 0.0, 1.0);\n\talgo_g = (1.0 - algo_g); algo_g = clamp(algo_g, 0.0, 1.0);\n\talgo_b = (1.0 - algo_b); algo_b = clamp(algo_b, 0.0, 1.0);\n\n\tfragColor = vec4(algo_r, algo_g, algo_b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mly3RW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mly3Ry", "name": "demosplash2016-cxw-04", "author": "cxw", "description": "Part 04: moving the screen, plus empirical tweaking\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016", "tags": ["tutorial", "demoparty"], "likes": 1, "viewed": 372, "date": "1475164839", "time_retrieved": "2024-06-20T18:41:42.795047", "image_code": "precision highp int;precision highp float;\n\nvec4 get_sine_color(in float time, in vec2 coords)  // a slightly better name\n{\n    float whereami = 50.0*distance(vec2(0.5),coords) - 10.0*time;\n    return vec4(0.0,0.0, 0.5+0.5*sin(whereami), 1.0);\n} //get_sine_color\n\nfloat get_base_y(in float time,\n    in float A, in float b, in float m, in float omega, in float phi)\n{ // determine where the bottom of the screen should be\n    return abs( A*exp(-b*time/(2.0*m))*cos(omega*time-phi) );\n        // Underdamped oscillator.  Take the absolute value so it\n        // bounces rather than ringing around zero.\n        // Use cos so that t=0 => base_y=1\n        // Note: in production code, precompute K=-b/(2*m) and use exp(K*t)\n} //get_base_y\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 pixel_coord = fragCoord.xy / iResolution.xy;\n    float base_y = get_base_y(t, 1.0, 3.0, 1.0, 4.5, 0.0);\n        // Tweak empirically     ^^^^^^^^^^^^^^^^^^^^^^^\n        // Note: don't pass parameters you don't need!  I didn't use\n        // A, m, or phi.  Comment out so I can add it back later if I need it.\n\n    if(pixel_coord.y < base_y) {\n        fragColor = vec4(0.0);  //black at the bottom\n    } else {\n        pixel_coord.y -= base_y;\n            // Move the generated image - pretend this pixel is where it\n            // would be in the non-offset image.\n        vec4 pixel_color = get_sine_color(t, pixel_coord);\n        fragColor = pixel_color;\n    }\n} //mainImage\n\n// parms for get_base_y are from \n// https://ocw.mit.edu/courses/mathematics/18-03sc-differential-equations-fall-2011/unit-ii-second-order-constant-coefficient-linear-equations/damped-harmonic-oscillators/MIT18_03SCF11_s13_2text.pdf\n// Note: Keep b < sqrt(4*m*k) for a bounce (underdamping), where\n// omega = sqrt(abs(b*b-4*m*k))/(2*m) (hint: MATLAB/GNU Octave)\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mly3Ry.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mly3zz", "name": "viz1", "author": "penna", "description": "forked", "tags": ["fork"], "likes": 16, "viewed": 300, "date": "1472735620", "time_retrieved": "2024-06-20T18:41:42.801207", "image_code": "//CBS\n//Parallax scrolling fractal galaxy.\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 14. + .04 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[4];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x * .8;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x * 1.2;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x * 1.6;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x * 2.5;\n\n\tfloat t = field(p,freqs[2]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.01)*0.2+0.2+sin(iTime*0.01)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 122.),  sin(iTime / 1282.));\n\tfloat t2 = field2(p2,freqs[3]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n\t\t\n\tfragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2;\n}", "image_inputs": [{"id": "XdSGRW", "previewfilepath": "https://soundcloud.com/amphia/amorf-1?in=amphia/sets/amorf-reherseal", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/amphia/amorf-1?in=amphia/sets/amorf-reherseal", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mly3zz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyGDz", "name": "Rorschach looking thing", "author": "Gaktan", "description": "My take on rorschach looking shader", "tags": ["noise", "perlin", "rorschach", "rorchach", "roshach", "rorschash"], "likes": 2, "viewed": 139, "date": "1474130562", "time_retrieved": "2024-06-20T18:41:42.801207", "image_code": "float mod289(float x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 perm(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec2 fade(vec2 t)\n{\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin 2D Noise \n// by Stefan Gustavson\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = perm(perm(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n \tfloat sinX = sin(angle);\n    float cosX = cos(angle);\n    float sinY = sin(angle);\n    \n    mat2 rotationMatrix = mat2(cosX, -sinX, sinY, cosX);\n    return uv * rotationMatrix;\n}\n\n#define time (iTime * 2.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // Mirror\n    uv.x = uv.x > 0.5 ? 1.0 - uv.x : uv.x;\n    \n    // Rotation\n    vec2 r = vec2(0.25, 0.5);\n    uv -= r;\n    uv = rotate(uv, time*.007);\n    uv += r;\n    \n    // Translation\n    uv = (uv + time*0.003);\n    // Scale\n    uv *= 10.0;\n   \n\tfloat color = cnoise(uv);\n    \n    color *= 0.02;\n    color += (time * 0.1) * 0.0055;\n    color = mod(color, 0.03) * 18.5;\n    float smoothness = 35.0;\n    color = 1.0 - smoothstep(0.45, 1.0, color) * smoothness;\n    \n    fragColor = vec4(color, color, color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyGRD", "name": "♫ Crateria - 1st anniversary", "author": "patu", "description": "All main functions taken from shadertoy user.", "tags": ["raymarching", "sky", "landscape", "old"], "likes": 7, "viewed": 544, "date": "1473465863", "time_retrieved": "2024-06-20T18:41:44.880057", "image_code": "\n// S h a d e r T o y - - - C h r o m e   E x t e n s i o n\n\n// https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl\n\n\n// Do not copy. Parts of this code are licensed. \n\n\nvec3 lightDir = vec3( -12., 0.1, 12.);\nvec3 lightColour = vec3(1.8, 1.0, 0.3); \n\n\nvec3 cameraPos = vec3(10., 2.9, 0.);\nvec3 cameraLookat = vec3(0., -7.0, 0.);\n\nfloat specularHardness = 1.4;\n\n\n\nfloat specular = 2.1;\nfloat diffuse = 1.;\nfloat len;\nfloat glow = 0.;\n\n#define GAMMA 1.4\n#define CONTRAST 1.0\n#define SATURATION 1.\n#define BRIGHTNESS 1.4\n\n#define RAY_DEPTH 96\n#define MAX_DEPTH 52.0\n#define DISTANCE_MIN 0.01\n#define PI 3.14159265\n\nint STAGE = 1;\n\nvec3 boxPosition = vec3(0.0);\n\nconst vec2 delta = vec2(0.001, 0.);\n\nfloat raise = 0.;\n\n\nvec4 cubePlasma (vec2 coord, vec3 p) {\n    \n    float \n        k = iTime * 3.0,\n        as = 4.78207464329,\n    \tfd = 12.18910931609,\n    \tas1 = 2.839499561581 / 24.0 + sin(k) * 0.02,\n    \tfd2 = 2.188989119604,\n    \tps = -5.624243766069,\n    \tps2 = 9.393007904291,\n    \tp1 = sin(k / ps) * 4.0,\n    \tp2 = sin(k / fd) * 3.0,\n    \tt3 = sin(k / fd2) + cos(as1),\n        t4 = sin(k / ps);    \n    \n    coord.x = floor(coord.x * 16.0) / 16.0;\n    coord.y = floor(coord.y * 16.0) / 16.0;\n    \n    float x = sin(p1 + coord.x) * sin(p2 + coord.y) + sin(t3 + coord.x) * sin(t4 + coord.y) * -p.x;\n    \n    float r = (0.87 + sin((x / as1 ) / 8.0) + sin(x / as1)) / 2.0;\n    float g = (0.42 + sin(x / as1)) / 2.0; \n    float b = (0.77 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n\n    if (\n        coord.y <= -0.9 || coord.y >= 0.9 ||\n        coord.x <= -0.9 || coord.x >= 0.9    \n    ) { \n        r = 1.;  \n        b = 1.; \n        g = 1.; \n    }\n    \n    \n     \n    vec4 color = vec4(vec3(r, g, b) * 2.0, 1.0);\n     \n    return color;\n    \n}\nvec4 boxmap( in vec3 p, in float k ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = cubePlasma(p.yz, p);\n\tvec4 y = cubePlasma(p.zx, p);\n\tvec4 z = cubePlasma(p.xy, p);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p ) {                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n\nmat3 xrotate(float t) {\n\treturn mat3(\n        \t\t1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t)\n    \t\t);\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(\n        \t\tcos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t)\n    \t\t);\n}\n\nmat3 zrotate(float t) {\n    return mat3(\n        \t\tcos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0\n    \t\t);\n}\n\nmat3 fullRotate(vec3 r) { \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat Plane(vec3 p, vec3 n)\n{\n   return dot(p, n);\n}\n\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nvec2 Dist(vec3 pos)\n{\n   //float t = iTime / 10.;\n    float n = noise(pos.xz / 4.) * 1.;\n    float height = 1. + max(\n       (n * 4.), \n       abs(2. * sin(abs(n))));\n   \n    float dust = noise(pos.xz * 4.) / 20. ;\n    \n    if (abs(pos.x) < 4.) height += cos(((pos.x * 3.14)) / 8.) * 4. + dust;\n       \n    height += dust + noise(pos.xz) / 4.;\n    height += noise(pos.xz / 20.) * 12. - 2.;\n    \n    float plane = Plane(pos - vec3(0., -height, 0.), vec3(0., 1, 0.));\n    \n    vec3 cpos = pos; \n    vec3 bpos = pos;\n    \n    bpos.y += 1.4 + sin(iTime) * 3.;\n    \n    boxPosition = \n        bpos *= fullRotate(vec3(iTime));\n    \n    cpos.y = cpos.y * 2. + 3.8;\n    \n    float crater = length(cpos)- 10. - n - dust * 4. - sin(n) *  2.;\n    \n    vec2 map = opS(\n        vec2(plane, 1.0), \n        vec2(crater, -1.0)\n    );\n    \n    vec2 box = vec2(sdBox(bpos, vec3(1.0)), 3.0);\n    vec2 wave = vec2(length(pos)- 8., 4.);\n    \n    map = opU(\n        map, \n        box\n    ); \n \n //   if (pos.y > 4. + n ) return vec2(0.0, 4.0);\n    return map;\n} \n\nvec3 GetNormal(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = Dist( pos + delta.xyy ).x - Dist( pos - delta.xyy ).x;\n   n.y = Dist( pos + delta.yxy ).x - Dist( pos - delta.yxy ).x;\n   n.z = Dist( pos + delta.yyx ).x - Dist( pos - delta.yyx ).x;\n   \n   return normalize(n);\n}\n\n// Original method by David Hoskins\nvec3 Sky(in vec3 rd, bool showSun)\n{\n   \n   float sunSize = 13.1;\n   float sunAmount = max(dot(rd, lightDir), 0.0);\n   float v = pow(1.2 - max(rd.y, 0.0), 1.);\n   vec3 sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32) * 1.0, v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 0.5 + lightColour * min(pow(sunAmount, 1512.0)* sunSize, sunSize / 24.);\n    \n    //if (showSun) sky += texture(iChannel0, vec2(v, rd.x) * 4.).rgb / 4.;\n   //if (showSun) sky -= fract(v /  4.) * vec3(0.3, 0.2, 0.1) ;//- noise(rd.xy * 100.);\n   return clamp(sky, 0.0, 1.0);\n}\n\n// Fog routine - original by IQ\nvec3 Fog(vec3 rgb, vec3 rd, float distance)   // camera to point distance\n{\n    const float b = 0.1;\n    \n    //b +=  * 2.;\n    \n    float fogAmount = 1.0 - exp(-distance * b);\n    vec3 fogColor = Sky(rd, false);\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// Based on a shading method by Ben Weston.\nvec3 Shading(vec3 pos, vec3 rd, vec3 norm, vec3 ro)\n{\n   vec3 light = lightColour * max(0.0, dot(norm, lightDir));\n   vec3 view = normalize(-rd);\n   vec3 heading = normalize(view + lightDir);\n   float spec = 0.0;//pow(max(0.0, dot(heading, norm)), specularHardness);\n   \n   float fresnel = .3;\n\n   light = clamp((diffuse * light) + (spec * specular * lightColour), 0.0, 1.0) * (1.0-fresnel);\n   if (fresnel > 0.01)\n   {\n      vec3 refrd = reflect(rd, norm);\n      light += Sky(refrd, false) * fresnel;\n   }\n   \n   light = Fog(light, rd, length(ro-pos));\n   vec3 cc = vec3(1.0);// - texture(iChannel2, norm.xz * 8.).rrr / 8.;\n   return cc * light;\n} \n    \n// Original method by David Hoskins\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(GAMMA));\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n// Camera function by TekF\n// Compute ray from camera parameters\nvec3 GetRay(vec3 dir, vec2 pos)\n{\n   pos = pos - 0.5;\n   pos.x *= iResolution.x/iResolution.y;\n   \n   dir = normalize(dir);\n   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n   vec3 up = normalize(cross(dir,right));\n   \n   return dir + right*pos.x + up*pos.y;\n}\n\nvec4 March(vec3 ro, vec3 rd)\n{\n   float t = 1.0;\n   float minDist = 1000.;\n   vec2 d = vec2(0.);\n    \n    \n   for (int i=0; i<RAY_DEPTH; i++)\n   {\n      vec3 p = ro + rd * t;\n      d = Dist(p);\n      \n      if (d.y == 3.0) {\n           minDist = min(minDist, d.x * (4. + fract(iTime)));\n           glow = pow( 1. / minDist, 2.);\n      }\n        \n      if (abs(d.x) < DISTANCE_MIN && d.y != 4.0)\n      {\n         return vec4(p, d.y);\n      }\n      t += d.x * .76;\n      if (t >= MAX_DEPTH) break;\n   }\n   return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    float t = mod(iTime, 120.);\n    \n    raise = mod(t * 4., 1250.);\n    \n    float stageT = mod(t / 12., 6.);\n    \n    STAGE = int(ceil(stageT));\n    \n    if (STAGE == 1) { \n     \tcameraPos.x = 2. * t;\n        cameraPos.y = 2.2;\n        cameraPos.z = 10. - t * 3. ;\n        cameraLookat = cameraPos + vec3(sin(t /4.) * 34., -5., cos(t / 2.2) * 50.);\n    }\n    \n    if (STAGE == 2) { // canion\n     \tcameraPos.x = 0.;\n        cameraPos.y = 1.0;\n        cameraPos.z = t * 5. ;\n        cameraLookat = cameraPos + vec3(sin(t / 6.) * 2., -2.0, 8.);\n    }\n    \n\tif (STAGE == 3) {\n        cameraPos.y = 3.0;\n   \t\tcameraPos.x = cos(t / 5. + iMouse.x/ 300.) * 19.; \n   \t\tcameraPos.z = sin(t / 5. + iMouse.x/ 300.) * 17. ; \n        cameraLookat = vec3(0., -4.0, 0.);\n    }\n   \n    if (STAGE == 4) { \n     \tcameraPos.x = 10. + sin(t/ 4.) / 3.;\n        cameraPos.y = 1.2 + sin(t/ 4.) / 3.;\n        cameraPos.z = 10.;\n        cameraLookat = vec3(-14., -9.0, -52. - sin(t / 6.) * 10.);\n    }\n    \n    if (STAGE == 5) { // canion\n     \tcameraPos.x = t * 2.;\n        cameraPos.y = 1.5;\n        cameraPos.z = t * 3. ;\n        cameraLookat = cameraPos + vec3(sin(t) * 3., -8.0, 18.);\n    }\n    \n    if (STAGE == 6) { // canion\n     \tcameraPos.x = sin(t/ 8. ) * sin(t / 1000.+ 2.) * 200. + 8. ;\n        cameraPos.y = 3.5;\n        cameraPos.z = cos(t / 8. ) * sin(t / 100.+ 1.) * 20. + 4.;\n        cameraLookat = vec3(0.);\n    }\n       \n    \n   cameraPos.y += sin(t * 2.) / 12.;\n   cameraPos.z += cos(t * 2. + 2.) / 12.;\n    \n   cameraLookat.y += sin(t * 2.) / 8.;\n    \n   lightDir = vec3( sin(t / 100.) * 200., sin(t / 100.) * 114., cos(t / 100.) * 200.); \n    \n   len = lightDir.x * lightDir.x + lightDir.y* lightDir.y + lightDir.z*lightDir.z;\n   lightDir *= 1. / sqrt(len); \n   \n   vec3 ro = cameraPos;\n   vec3 rd = normalize(GetRay(cameraLookat - cameraPos, p));\n    \n   vec4 res = March(ro, rd);\n    if (res.a == 1.0) {\n        res.rgb = clamp(Shading(res.rgb, rd, GetNormal(res.rgb), ro).rgb, 0.0, 1.0);\n        \n    } \n    if (res.a == 3.0) {\n        glow = fract(iTime * .835) > 0.1 ? 0.0 : 1.0; \n        res.rgb = boxmap(boxPosition, 2.0).rgb / 2.;\n    }\n\n    if (res.a == 0.0) res.rgb = Sky(rd, true);\n    \n    float glowSize = 4.;//+ mod(iTime * .835, 5.);\n    \n    float fade = fract(stageT) > 0.75 ? (fract(stageT) - 0.75) * 4. : 0.;\n    fade = fract(stageT) < 0.1 ? 1. - ((fract(stageT)) * 10.) : fade;\n    vec4 color = (vec4(res.rgb, 1.0) + glow * glowSize) * (1. - fade); \n    \n    color.rgb = PostEffects(color.rgb, p);\n    fragColor = color; \n}", "image_inputs": [{"id": "XdS3zD", "previewfilepath": "https://soundcloud.com/johnfaustus/somewhere-in-time-and-space", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/johnfaustus/somewhere-in-time-and-space", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyGRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyGWh", "name": "Ibrahim? Is that you?", "author": "lara", "description": "Old title: \"100P if u can guess who this is\"\n\n256 ellipses, 24h generation, gif: [url=http://i.imgur.com/f24qRoc.gifv]http://i.imgur.com/f24qRoc.gifv[/url]\nGackt turned out much better: [url]https://www.shadertoy.com/view/4tV3RW[/url]", "tags": ["image"], "likes": 7, "viewed": 736, "date": "1474378838", "time_retrieved": "2024-06-20T18:41:44.886105", "image_code": "const float W = 128.;\nconst float H = 128.;\nconst float R = max(W,H);\n\nvec2 hash22(vec2 p)\n{\n    return vec2(\n        fract(sin(dot(p.xy, vec2(50159.91193,49681.51239))) * 73943.1699),\n        fract(sin(dot(p.xy, vec2(90821.40973,2287.62201))) * 557.96557)\n    );\n}\n\nvoid plot(vec2 uv, inout vec4 colA, vec4 colB, vec3 b)\n{\n    vec2 p = vec2(mod(b.x*W*H,W)/W, floor(b.x*H)/H);\n    vec2 d = vec2(mod(b.y*R*R,R)/R, floor(b.y*R)/R);\n    \n    float s = sin(b.z*6.283185);\n    float c = cos(b.z*6.283185);\n    float r = max(b.x,b.y);\n    \n    float f = colB.a * max(1.-length(mat2(c,s,-s,c)*(uv-p)/d*r)/r,0.);\n    \n    colA.rgb = colA.rgb*(1.-f) + colB.rgb*f;\n    colA.w = clamp(colA.a+f,0.,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x,iResolution.y-fragCoord.y)/iResolution.yy - vec2(.1,0);\n\tvec4 col = vec4(1);\n    \n    uv += (hash22(uv+iTime)-.5)*.01;\n\n\tplot(uv, col, vec4(0.550,0.616,0.180,0.903), vec3(0.159499,0.502663,0.597436));\n\tplot(uv, col, vec4(0.270,0.230,0.270,0.779), vec3(0.490326,0.109593,0.374188));\n\tplot(uv, col, vec4(0.400,0.326,0.102,0.701), vec3(0.203184,0.503299,0.449523));\n\tplot(uv, col, vec4(0.145,0.045,0.067,0.745), vec3(0.389104,0.032319,0.705598));\n\tplot(uv, col, vec4(0.794,0.646,0.405,0.596), vec3(0.941536,0.058408,0.164966));\n\tplot(uv, col, vec4(0.145,0.282,0.094,0.695), vec3(0.815803,0.125068,0.673516));\n\tplot(uv, col, vec4(0.549,0.829,0.104,0.645), vec3(0.802177,0.053953,0.309251));\n\tplot(uv, col, vec4(0.325,0.933,0.665,0.063), vec3(0.379882,0.330183,0.614222));\n\tplot(uv, col, vec4(0.575,0.280,0.177,0.529), vec3(0.829099,0.140884,0.391236));\n\tplot(uv, col, vec4(0.123,0.184,0.112,0.866), vec3(0.753553,0.117893,0.653585));\n\tplot(uv, col, vec4(0.061,0.285,0.058,0.800), vec3(0.583507,0.063387,0.712071));\n\tplot(uv, col, vec4(0.102,0.837,0.115,0.295), vec3(0.135050,0.707001,0.279938));\n\tplot(uv, col, vec4(0.342,0.475,0.167,0.106), vec3(0.157729,0.862485,0.775486));\n\tplot(uv, col, vec4(0.130,0.782,0.818,0.053), vec3(0.747758,0.126284,0.717844));\n\tplot(uv, col, vec4(0.162,0.121,0.133,0.733), vec3(0.782565,0.109463,0.413431));\n\tplot(uv, col, vec4(0.289,0.065,0.022,0.813), vec3(0.840015,0.078519,0.170913));\n\tplot(uv, col, vec4(0.554,0.055,0.161,0.733), vec3(0.816716,0.274056,0.665458));\n\tplot(uv, col, vec4(0.586,0.623,0.108,0.952), vec3(0.968818,0.422042,0.395508));\n\tplot(uv, col, vec4(0.060,0.053,0.183,0.615), vec3(0.173592,0.403650,0.646574));\n\tplot(uv, col, vec4(0.602,0.875,0.705,0.087), vec3(0.593349,0.223019,0.748994));\n\tplot(uv, col, vec4(0.246,0.244,0.512,0.887), vec3(0.949076,0.351769,0.383569));\n\tplot(uv, col, vec4(0.509,0.719,0.331,0.072), vec3(0.969945,0.064856,0.589716));\n\tplot(uv, col, vec4(0.080,0.187,0.124,0.837), vec3(0.688339,0.119806,0.664541));\n\tplot(uv, col, vec4(0.561,0.670,0.093,0.040), vec3(0.765751,0.129984,0.870363));\n\tplot(uv, col, vec4(0.867,0.238,0.086,0.920), vec3(0.574364,0.114673,0.820266));\n\tplot(uv, col, vec4(0.234,0.071,0.109,0.774), vec3(0.659568,0.074693,0.340160));\n\tplot(uv, col, vec4(0.204,0.358,0.160,0.753), vec3(0.599085,0.070985,0.735582));\n\tplot(uv, col, vec4(0.205,0.127,0.186,0.825), vec3(0.482255,0.258169,0.462789));\n\tplot(uv, col, vec4(0.248,0.248,0.337,0.511), vec3(0.115600,0.140967,0.612417));\n\tplot(uv, col, vec4(0.052,0.169,0.076,0.833), vec3(0.688558,0.082287,0.661429));\n\tplot(uv, col, vec4(0.163,0.121,0.133,0.732), vec3(0.782354,0.109799,0.413701));\n\tplot(uv, col, vec4(0.142,0.119,0.136,0.703), vec3(0.735945,0.148538,0.433220));\n\tplot(uv, col, vec4(0.659,0.754,0.032,0.204), vec3(0.841822,0.412575,0.647346));\n\tplot(uv, col, vec4(0.491,0.803,0.809,0.090), vec3(0.653602,0.305864,0.760238));\n\tplot(uv, col, vec4(0.250,0.092,0.254,0.666), vec3(0.685112,0.117281,0.432854));\n\tplot(uv, col, vec4(0.204,0.127,0.186,0.825), vec3(0.482258,0.258136,0.462718));\n\tplot(uv, col, vec4(0.851,0.674,0.214,0.288), vec3(0.825818,0.057222,0.889368));\n\tplot(uv, col, vec4(0.065,0.230,0.371,0.902), vec3(0.659593,0.077843,0.347672));\n\tplot(uv, col, vec4(0.291,0.499,0.045,0.872), vec3(0.603670,0.211131,0.584619));\n\tplot(uv, col, vec4(0.160,0.079,0.100,0.739), vec3(0.743567,0.094040,0.430272));\n\tplot(uv, col, vec4(0.064,0.173,0.081,0.824), vec3(0.696493,0.069888,0.656627));\n\tplot(uv, col, vec4(0.268,0.106,0.130,0.751), vec3(0.645796,0.102011,0.352085));\n\tplot(uv, col, vec4(0.857,0.861,0.617,0.187), vec3(0.154789,0.403032,0.461879));\n\tplot(uv, col, vec4(0.120,0.062,0.073,0.729), vec3(0.769392,0.094652,0.415173));\n\tplot(uv, col, vec4(0.238,0.139,0.061,0.795), vec3(0.723561,0.092471,0.785585));\n\tplot(uv, col, vec4(0.756,0.784,0.196,0.399), vec3(0.658625,0.179858,0.585192));\n\tplot(uv, col, vec4(0.557,0.604,0.173,0.078), vec3(0.419640,0.298280,0.137784));\n\tplot(uv, col, vec4(0.266,0.112,0.247,0.790), vec3(0.667403,0.077420,0.354248));\n\tplot(uv, col, vec4(0.055,0.142,0.273,0.892), vec3(0.919065,0.102362,0.330999));\n\tplot(uv, col, vec4(0.313,0.110,0.309,0.442), vec3(0.957056,0.297213,0.383715));\n\tplot(uv, col, vec4(0.850,0.950,0.815,0.144), vec3(0.194835,0.493765,0.665705));\n\tplot(uv, col, vec4(0.088,0.088,0.090,0.806), vec3(0.373615,0.117429,0.450021));\n\tplot(uv, col, vec4(0.238,0.071,0.123,0.690), vec3(0.750960,0.266206,0.417417));\n\tplot(uv, col, vec4(0.104,0.051,0.214,0.615), vec3(0.211648,0.412793,0.603245));\n\tplot(uv, col, vec4(0.807,0.780,0.458,0.095), vec3(0.249941,0.150208,0.904779));\n\tplot(uv, col, vec4(0.203,0.503,0.210,0.963), vec3(0.076025,0.079154,0.377400));\n\tplot(uv, col, vec4(0.273,0.102,0.126,0.750), vec3(0.644096,0.100726,0.338319));\n\tplot(uv, col, vec4(0.042,0.129,0.279,0.903), vec3(0.914386,0.101800,0.346274));\n\tplot(uv, col, vec4(0.902,0.497,0.085,0.823), vec3(0.589611,0.097781,0.867695));\n\tplot(uv, col, vec4(0.557,0.857,0.801,0.094), vec3(0.601204,0.225841,0.784951));\n\tplot(uv, col, vec4(0.528,0.650,0.317,0.105), vec3(0.908436,0.141039,0.547681));\n\tplot(uv, col, vec4(0.044,0.191,0.082,0.821), vec3(0.704281,0.069827,0.656925));\n\tplot(uv, col, vec4(0.259,0.095,0.116,0.754), vec3(0.651922,0.090490,0.335330));\n\tplot(uv, col, vec4(0.786,0.656,0.111,0.916), vec3(0.620171,0.570766,0.661002));\n\tplot(uv, col, vec4(0.319,0.243,0.298,0.917), vec3(0.169306,0.360534,0.532966));\n\tplot(uv, col, vec4(0.030,0.151,0.079,0.768), vec3(0.703789,0.122866,0.653823));\n\tplot(uv, col, vec4(0.129,0.038,0.037,0.785), vec3(0.451014,0.070947,0.578291));\n\tplot(uv, col, vec4(0.083,0.267,0.160,0.669), vec3(0.154482,0.079223,0.289567));\n\tplot(uv, col, vec4(0.116,0.061,0.064,0.732), vec3(0.777258,0.087524,0.417203));\n\tplot(uv, col, vec4(0.080,0.170,0.077,0.818), vec3(0.910312,0.609707,0.918839));\n\tplot(uv, col, vec4(0.194,0.236,0.104,0.620), vec3(0.277711,0.051378,0.786272));\n\tplot(uv, col, vec4(0.909,0.861,0.494,0.120), vec3(0.783233,0.115089,0.747248));\n\tplot(uv, col, vec4(0.123,0.184,0.114,0.864), vec3(0.750423,0.121372,0.651985));\n\tplot(uv, col, vec4(0.159,0.122,0.075,0.850), vec3(0.684587,0.064100,0.650322));\n\tplot(uv, col, vec4(0.109,0.093,0.117,0.912), vec3(0.520455,0.336892,0.383144));\n\tplot(uv, col, vec4(0.120,0.113,0.185,0.604), vec3(0.148544,0.342899,0.668416));\n\tplot(uv, col, vec4(0.506,0.212,0.166,0.921), vec3(0.911767,0.671983,0.617606));\n\tplot(uv, col, vec4(0.908,0.430,0.051,0.042), vec3(0.970130,0.205765,0.404923));\n\tplot(uv, col, vec4(0.105,0.101,0.066,0.945), vec3(0.203967,0.268875,0.378044));\n\tplot(uv, col, vec4(0.851,0.674,0.215,0.289), vec3(0.825851,0.058254,0.888598));\n\tplot(uv, col, vec4(0.042,0.218,0.101,0.847), vec3(0.687870,0.135408,0.695969));\n\tplot(uv, col, vec4(0.867,0.237,0.083,0.920), vec3(0.573065,0.111759,0.821034));\n\tplot(uv, col, vec4(0.088,0.067,0.203,0.883), vec3(0.504271,0.213395,0.236294));\n\tplot(uv, col, vec4(0.142,0.234,0.054,0.872), vec3(0.271625,0.234824,0.456813));\n\tplot(uv, col, vec4(0.052,0.169,0.076,0.833), vec3(0.688544,0.081945,0.661509));\n\tplot(uv, col, vec4(0.851,0.673,0.213,0.290), vec3(0.825752,0.063874,0.888379));\n\tplot(uv, col, vec4(0.092,0.115,0.073,0.717), vec3(0.229279,0.510950,0.351163));\n\tplot(uv, col, vec4(0.028,0.152,0.069,0.768), vec3(0.703914,0.115544,0.655078));\n\tplot(uv, col, vec4(0.060,0.053,0.182,0.616), vec3(0.172711,0.403459,0.646727));\n\tplot(uv, col, vec4(0.737,0.507,0.178,0.574), vec3(0.635152,0.250246,0.587325));\n\tplot(uv, col, vec4(0.182,0.210,0.208,0.481), vec3(0.099860,0.141030,0.654581));\n\tplot(uv, col, vec4(0.651,0.858,0.606,0.098), vec3(0.381727,0.188096,0.830028));\n\tplot(uv, col, vec4(0.866,0.238,0.084,0.919), vec3(0.573065,0.111825,0.820459));\n\tplot(uv, col, vec4(0.852,0.673,0.213,0.290), vec3(0.825758,0.063828,0.888412));\n\tplot(uv, col, vec4(0.058,0.110,0.041,0.959), vec3(0.212282,0.261073,0.402847));\n\tplot(uv, col, vec4(0.073,0.112,0.055,0.953), vec3(0.220331,0.285134,0.413422));\n\tplot(uv, col, vec4(0.109,0.100,0.166,0.663), vec3(0.255720,0.211603,0.462844));\n\tplot(uv, col, vec4(0.085,0.063,0.184,0.677), vec3(0.185471,0.110617,0.569340));\n\tplot(uv, col, vec4(0.681,0.872,0.046,0.784), vec3(0.919911,0.055255,0.202310));\n\tplot(uv, col, vec4(0.080,0.082,0.087,0.809), vec3(0.373494,0.117556,0.450578));\n\tplot(uv, col, vec4(0.035,0.168,0.072,0.843), vec3(0.712115,0.071914,0.667275));\n\tplot(uv, col, vec4(0.737,0.507,0.178,0.574), vec3(0.635149,0.250245,0.587330));\n\tplot(uv, col, vec4(0.825,0.223,0.121,0.885), vec3(0.557960,0.126399,0.814683));\n\tplot(uv, col, vec4(0.081,0.074,0.050,0.557), vec3(0.252015,0.300969,0.379348));\n\tplot(uv, col, vec4(0.112,0.075,0.124,0.743), vec3(0.789894,0.117683,0.403344));\n\tplot(uv, col, vec4(0.116,0.061,0.063,0.732), vec3(0.777087,0.086760,0.416501));\n\tplot(uv, col, vec4(0.027,0.152,0.068,0.769), vec3(0.703922,0.114906,0.654628));\n\tplot(uv, col, vec4(0.144,0.059,0.134,0.629), vec3(0.797784,0.164501,0.380185));\n\tplot(uv, col, vec4(0.088,0.098,0.102,0.796), vec3(0.380989,0.125661,0.456333));\n\tplot(uv, col, vec4(0.035,0.168,0.072,0.843), vec3(0.712101,0.071915,0.667290));\n\tplot(uv, col, vec4(0.905,0.893,0.924,0.338), vec3(0.874519,0.082612,0.786745));\n\tplot(uv, col, vec4(0.579,0.419,0.620,0.318), vec3(0.960935,0.063717,0.759518));\n\tplot(uv, col, vec4(0.255,0.212,0.310,0.483), vec3(0.100010,0.125394,0.627305));\n\tplot(uv, col, vec4(0.185,0.143,0.533,0.016), vec3(0.084949,0.636225,0.726393));\n\tplot(uv, col, vec4(0.084,0.063,0.182,0.677), vec3(0.185538,0.110422,0.568655));\n\tplot(uv, col, vec4(0.131,0.041,0.075,0.687), vec3(0.376280,0.200208,0.689113));\n\tplot(uv, col, vec4(0.658,0.176,0.056,0.506), vec3(0.904224,0.047285,0.370007));\n\tplot(uv, col, vec4(0.154,0.020,0.054,0.777), vec3(0.391714,0.140569,0.690019));\n\tplot(uv, col, vec4(0.545,0.858,0.823,0.779), vec3(0.087571,0.101905,0.927896));\n\tplot(uv, col, vec4(0.816,0.356,0.115,0.600), vec3(0.025800,0.087093,0.651482));\n\tplot(uv, col, vec4(0.732,0.879,0.285,0.065), vec3(0.038806,0.279388,0.880259));\n\tplot(uv, col, vec4(0.087,0.033,0.054,0.744), vec3(0.341699,0.034457,0.735040));\n\tplot(uv, col, vec4(0.046,0.213,0.089,0.749), vec3(0.114724,0.204186,0.087849));\n\tplot(uv, col, vec4(0.183,0.210,0.209,0.481), vec3(0.099738,0.141166,0.654749));\n\tplot(uv, col, vec4(0.874,0.481,0.226,0.561), vec3(0.746111,0.095609,0.437195));\n\tplot(uv, col, vec4(0.814,0.395,0.083,0.689), vec3(0.334340,0.086418,0.471682));\n\tplot(uv, col, vec4(0.138,0.075,0.081,0.720), vec3(0.751022,0.102109,0.408409));\n\tplot(uv, col, vec4(0.629,0.801,0.796,0.626), vec3(0.112465,0.187735,0.767915));\n\tplot(uv, col, vec4(0.265,0.844,0.525,0.060), vec3(0.834669,0.094563,0.588852));\n\tplot(uv, col, vec4(0.666,0.659,0.304,0.615), vec3(0.714865,0.141152,0.739853));\n\tplot(uv, col, vec4(0.071,0.018,0.062,0.932), vec3(0.430132,0.330571,0.293319));\n\tplot(uv, col, vec4(0.027,0.118,0.281,0.916), vec3(0.926923,0.104445,0.325828));\n\tplot(uv, col, vec4(0.867,0.237,0.084,0.919), vec3(0.573067,0.111888,0.821093));\n\tplot(uv, col, vec4(0.246,0.078,0.121,0.767), vec3(0.660531,0.081826,0.336773));\n\tplot(uv, col, vec4(0.040,0.050,0.090,0.413), vec3(0.415042,0.208796,0.686726));\n\tplot(uv, col, vec4(0.177,0.057,0.113,0.651), vec3(0.419879,0.087295,0.653888));\n\tplot(uv, col, vec4(0.886,0.749,0.444,0.552), vec3(0.659449,0.196067,0.620371));\n\tplot(uv, col, vec4(0.110,0.100,0.168,0.662), vec3(0.255913,0.211421,0.462487));\n\tplot(uv, col, vec4(0.248,0.141,0.068,0.791), vec3(0.723453,0.100905,0.789664));\n\tplot(uv, col, vec4(0.783,0.722,0.498,0.879), vec3(0.111199,0.281636,0.347660));\n\tplot(uv, col, vec4(0.811,0.470,0.377,0.462), vec3(0.128087,0.179830,0.246048));\n\tplot(uv, col, vec4(0.087,0.121,0.108,0.769), vec3(0.403315,0.126486,0.435034));\n\tplot(uv, col, vec4(0.028,0.149,0.074,0.886), vec3(0.739328,0.061949,0.743980));\n\tplot(uv, col, vec4(0.644,0.790,0.899,0.675), vec3(0.145642,0.156931,0.809177));\n\tplot(uv, col, vec4(0.066,0.045,0.119,0.608), vec3(0.235260,0.105712,0.517962));\n\tplot(uv, col, vec4(0.295,0.054,0.020,0.814), vec3(0.855915,0.065794,0.167743));\n\tplot(uv, col, vec4(0.087,0.034,0.054,0.744), vec3(0.341530,0.035221,0.734417));\n\tplot(uv, col, vec4(0.048,0.054,0.087,0.398), vec3(0.369546,0.162767,0.630206));\n\tplot(uv, col, vec4(0.588,0.682,0.430,0.163), vec3(0.952908,0.058798,0.614481));\n\tplot(uv, col, vec4(0.353,0.754,0.539,0.112), vec3(0.062358,0.711752,0.621794));\n\tplot(uv, col, vec4(0.282,0.240,0.244,0.690), vec3(0.573105,0.110065,0.539947));\n\tplot(uv, col, vec4(0.064,0.078,0.061,0.535), vec3(0.255041,0.274734,0.360634));\n\tplot(uv, col, vec4(0.027,0.149,0.074,0.886), vec3(0.739441,0.061879,0.744258));\n\tplot(uv, col, vec4(0.559,0.805,0.757,0.589), vec3(0.105909,0.125513,0.738406));\n\tplot(uv, col, vec4(0.603,0.844,0.814,0.609), vec3(0.033768,0.102227,0.780577));\n\tplot(uv, col, vec4(0.158,0.122,0.075,0.850), vec3(0.684641,0.063917,0.650068));\n\tplot(uv, col, vec4(0.060,0.075,0.053,0.535), vec3(0.250310,0.269434,0.356382));\n\tplot(uv, col, vec4(0.075,0.097,0.054,0.540), vec3(0.254801,0.298243,0.357073));\n\tplot(uv, col, vec4(0.076,0.203,0.128,0.609), vec3(0.170661,0.047301,0.315462));\n\tplot(uv, col, vec4(0.670,0.859,0.617,0.072), vec3(0.390553,0.174453,0.840511));\n\tplot(uv, col, vec4(0.087,0.088,0.090,0.806), vec3(0.373675,0.117346,0.450039));\n\tplot(uv, col, vec4(0.066,0.203,0.120,0.624), vec3(0.155024,0.047354,0.307758));\n\tplot(uv, col, vec4(0.783,0.934,0.161,0.393), vec3(0.698748,0.125991,0.542088));\n\tplot(uv, col, vec4(0.049,0.054,0.087,0.399), vec3(0.369708,0.162576,0.630075));\n\tplot(uv, col, vec4(0.057,0.060,0.090,0.373), vec3(0.378610,0.213173,0.592666));\n\tplot(uv, col, vec4(0.058,0.031,0.120,0.601), vec3(0.211352,0.082178,0.513799));\n\tplot(uv, col, vec4(0.033,0.045,0.087,0.386), vec3(0.391548,0.168679,0.707724));\n\tplot(uv, col, vec4(0.872,0.942,0.159,0.961), vec3(0.456831,0.064411,0.699007));\n\tplot(uv, col, vec4(0.860,0.923,0.945,0.320), vec3(0.850402,0.080264,0.815350));\n\tplot(uv, col, vec4(0.766,0.831,0.187,0.439), vec3(0.659562,0.125618,0.532267));\n\tplot(uv, col, vec4(0.734,0.586,0.263,0.769), vec3(0.283086,0.055764,0.458126));\n\tplot(uv, col, vec4(0.061,0.076,0.058,0.537), vec3(0.254973,0.274593,0.357743));\n\tplot(uv, col, vec4(0.603,0.780,0.834,0.578), vec3(0.127904,0.133004,0.741174));\n\tplot(uv, col, vec4(0.096,0.118,0.117,0.778), vec3(0.389335,0.132911,0.443354));\n\tplot(uv, col, vec4(0.845,0.287,0.183,0.078), vec3(0.067523,0.071385,0.041510));\n\tplot(uv, col, vec4(0.234,0.201,0.284,0.638), vec3(0.620630,0.156757,0.658091));\n\tplot(uv, col, vec4(0.080,0.082,0.087,0.809), vec3(0.373573,0.117477,0.450659));\n\tplot(uv, col, vec4(0.580,0.686,0.460,0.555), vec3(0.528357,0.047358,0.485358));\n\tplot(uv, col, vec4(0.266,0.847,0.531,0.049), vec3(0.843430,0.088343,0.592069));\n\tplot(uv, col, vec4(0.872,0.942,0.159,0.961), vec3(0.456829,0.064422,0.699004));\n\tplot(uv, col, vec4(0.071,0.022,0.068,0.927), vec3(0.432907,0.328883,0.296672));\n\tplot(uv, col, vec4(0.794,0.670,0.625,0.618), vec3(0.495357,0.109588,0.747711));\n\tplot(uv, col, vec4(0.080,0.082,0.087,0.809), vec3(0.373530,0.117556,0.450660));\n\tplot(uv, col, vec4(0.872,0.941,0.160,0.961), vec3(0.456803,0.065050,0.698885));\n\tplot(uv, col, vec4(0.054,0.643,0.403,0.077), vec3(0.082229,0.007363,0.193338));\n\tplot(uv, col, vec4(0.541,0.871,0.822,0.780), vec3(0.080252,0.078470,0.935407));\n\tplot(uv, col, vec4(0.021,0.142,0.067,0.891), vec3(0.739102,0.061714,0.745599));\n\tplot(uv, col, vec4(0.836,0.707,0.621,0.650), vec3(0.510451,0.070600,0.770502));\n\tplot(uv, col, vec4(0.149,0.839,0.477,0.688), vec3(0.174470,0.010092,0.513117));\n\tplot(uv, col, vec4(0.640,0.853,0.730,0.711), vec3(0.494349,0.062814,0.592618));\n\tplot(uv, col, vec4(0.065,0.145,0.090,0.869), vec3(0.723175,0.075734,0.733226));\n\tplot(uv, col, vec4(0.715,0.478,0.173,0.773), vec3(0.268511,0.312836,0.743989));\n\tplot(uv, col, vec4(0.842,0.901,0.439,0.718), vec3(0.353886,0.094750,0.386394));\n\tplot(uv, col, vec4(0.066,0.203,0.120,0.624), vec3(0.155023,0.047345,0.307754));\n\tplot(uv, col, vec4(0.103,0.041,0.073,0.728), vec3(0.356600,0.046868,0.733691));\n\tplot(uv, col, vec4(0.856,0.905,0.136,0.863), vec3(0.481198,0.172055,0.596157));\n\tplot(uv, col, vec4(0.097,0.035,0.063,0.737), vec3(0.349217,0.037776,0.733271));\n\tplot(uv, col, vec4(0.068,0.088,0.091,0.519), vec3(0.246975,0.282620,0.340824));\n\tplot(uv, col, vec4(0.874,0.480,0.223,0.562), vec3(0.746022,0.094127,0.436276));\n\tplot(uv, col, vec4(0.087,0.028,0.036,0.746), vec3(0.324999,0.044129,0.732021));\n\tplot(uv, col, vec4(0.874,0.897,0.212,0.920), vec3(0.457799,0.140864,0.689115));\n\tplot(uv, col, vec4(0.783,0.552,0.217,0.313), vec3(0.667839,0.063452,0.901408));\n\tplot(uv, col, vec4(0.162,0.121,0.133,0.733), vec3(0.782609,0.109484,0.413481));\n\tplot(uv, col, vec4(0.578,0.802,0.774,0.617), vec3(0.095775,0.148915,0.770361));\n\tplot(uv, col, vec4(0.719,0.859,0.148,0.826), vec3(0.369578,0.086559,0.751793));\n\tplot(uv, col, vec4(0.853,0.455,0.110,0.861), vec3(0.645659,0.031597,0.826315));\n\tplot(uv, col, vec4(0.123,0.068,0.072,0.732), vec3(0.770352,0.094335,0.420921));\n\tplot(uv, col, vec4(0.094,0.028,0.110,0.670), vec3(0.355797,0.051997,0.750018));\n\tplot(uv, col, vec4(0.036,0.050,0.088,0.385), vec3(0.390790,0.169962,0.706555));\n\tplot(uv, col, vec4(0.718,0.150,0.235,0.775), vec3(0.442460,0.148965,0.498561));\n\tplot(uv, col, vec4(0.240,0.946,0.916,0.106), vec3(0.960918,0.071943,0.681108));\n\tplot(uv, col, vec4(0.093,0.017,0.045,0.750), vec3(0.333367,0.044375,0.730739));\n\tplot(uv, col, vec4(0.876,0.825,0.576,0.801), vec3(0.456823,0.086283,0.278964));\n\tplot(uv, col, vec4(0.093,0.113,0.067,0.787), vec3(0.388895,0.149001,0.461468));\n\tplot(uv, col, vec4(0.853,0.378,0.197,0.570), vec3(0.536347,0.156626,0.658713));\n\tplot(uv, col, vec4(0.074,0.058,0.153,0.608), vec3(0.230617,0.127000,0.527055));\n\tplot(uv, col, vec4(0.879,0.508,0.104,0.802), vec3(0.596690,0.102013,0.867261));\n\tplot(uv, col, vec4(0.245,0.070,0.116,0.774), vec3(0.659192,0.078331,0.335287));\n\tplot(uv, col, vec4(0.133,0.092,0.117,0.779), vec3(0.394824,0.172083,0.442748));\n\tplot(uv, col, vec4(0.097,0.035,0.063,0.737), vec3(0.349217,0.037767,0.733273));\n\tplot(uv, col, vec4(0.911,0.574,0.232,0.468), vec3(0.636321,0.149568,0.574955));\n\tplot(uv, col, vec4(0.757,0.673,0.226,0.736), vec3(0.284212,0.040856,0.457159));\n\tplot(uv, col, vec4(0.459,0.734,0.226,0.231), vec3(0.960905,0.132777,0.625052));\n\tplot(uv, col, vec4(0.101,0.080,0.094,0.496), vec3(0.333899,0.242428,0.406003));\n\tplot(uv, col, vec4(0.066,0.080,0.061,0.535), vec3(0.255148,0.274524,0.360714));\n\tplot(uv, col, vec4(0.842,0.901,0.439,0.718), vec3(0.353787,0.094620,0.386487));\n\tplot(uv, col, vec4(0.076,0.012,0.028,0.753), vec3(0.332323,0.027593,0.738137));\n\tplot(uv, col, vec4(0.752,0.227,0.385,0.086), vec3(0.057524,0.258483,0.718686));\n\tplot(uv, col, vec4(0.119,0.147,0.135,0.702), vec3(0.395792,0.125139,0.445776));\n\tplot(uv, col, vec4(0.742,0.244,0.406,0.102), vec3(0.097611,0.282116,0.733081));\n\tplot(uv, col, vec4(0.103,0.059,0.067,0.732), vec3(0.349410,0.050473,0.731583));\n\tplot(uv, col, vec4(0.758,0.456,0.083,0.681), vec3(0.454868,0.226663,0.591827));\n\tplot(uv, col, vec4(0.101,0.111,0.026,0.784), vec3(0.383068,0.783781,0.844796));\n\tplot(uv, col, vec4(0.053,0.074,0.100,0.403), vec3(0.390838,0.168818,0.704307));\n\tplot(uv, col, vec4(0.672,0.782,0.910,0.653), vec3(0.111061,0.133354,0.873695));\n\tplot(uv, col, vec4(0.740,0.853,0.775,0.648), vec3(0.306811,0.102405,0.817200));\n\tplot(uv, col, vec4(0.860,0.610,0.490,0.325), vec3(0.165699,0.367525,0.491037));\n\tplot(uv, col, vec4(0.906,0.664,0.159,0.628), vec3(0.392838,0.118790,0.806871));\n\tplot(uv, col, vec4(0.880,0.896,0.439,0.813), vec3(0.384913,0.095212,0.327161));\n\tplot(uv, col, vec4(0.880,0.896,0.439,0.812), vec3(0.384795,0.095411,0.327400));\n\tplot(uv, col, vec4(0.581,0.794,0.249,0.135), vec3(0.292282,0.273833,0.728717));\n\tplot(uv, col, vec4(0.059,0.071,0.052,0.535), vec3(0.246950,0.267204,0.354889));\n\tplot(uv, col, vec4(0.819,0.384,0.077,0.697), vec3(0.308295,0.079935,0.461987));\n\tplot(uv, col, vec4(0.884,0.827,0.579,0.799), vec3(0.455240,0.079582,0.272155));\n\tplot(uv, col, vec4(0.075,0.012,0.027,0.753), vec3(0.332484,0.027414,0.738328));\n\tplot(uv, col, vec4(0.398,0.100,0.136,0.821), vec3(0.588524,0.078306,0.395726));\n\tplot(uv, col, vec4(0.621,0.373,0.335,0.749), vec3(0.268978,0.234618,0.725575));\n\tplot(uv, col, vec4(0.813,0.387,0.089,0.717), vec3(0.393162,0.156714,0.546012));\n\tplot(uv, col, vec4(0.666,0.939,0.678,0.483), vec3(0.284035,0.179823,0.236283));\n\tplot(uv, col, vec4(0.019,0.034,0.217,0.106), vec3(0.273633,0.310930,0.710444));\n\tplot(uv, col, vec4(0.111,0.046,0.093,0.703), vec3(0.393662,0.109562,0.736682));\n\tplot(uv, col, vec4(0.584,0.694,0.841,0.565), vec3(0.283961,0.203364,0.714446));\n\tplot(uv, col, vec4(0.669,0.896,0.582,0.572), vec3(0.307723,0.080488,0.501443));\n\tplot(uv, col, vec4(0.820,0.384,0.077,0.698), vec3(0.308354,0.079847,0.462402));\n\tplot(uv, col, vec4(0.857,0.718,0.608,0.655), vec3(0.519227,0.071486,0.781998));\n\tplot(uv, col, vec4(0.170,0.121,0.184,0.602), vec3(0.394612,0.211100,0.326056));\n\n\tfragColor = vec4(col.rgb,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyGWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyGWR", "name": "faster infinite zoom noise", "author": "ollj", "description": "trying to improve on https://www.shadertoy.com/view/Msf3Wr\nby allowing for performance tweaks.\njust modify some global constants\n\n//#define HideMultiversePattern at own risk, looks better with large layers\nhigh smoothness at own risk\n", "tags": ["2d", "fractal", "noise", "tunnel", "zoom"], "likes": 26, "viewed": 1207, "date": "1474066371", "time_retrieved": "2024-06-20T18:41:45.783133", "image_code": "//a simpler tiny (well documented) variant of this is\n//https://www.shadertoy.com/view/ltjXDW\n//but that one flickers more.\n\n//fractal noise, modified by ollj\n//to work nicely with modifiable constants:\n//to allow lower and higher detail, varying #layers\n//to have \"roughness\" independend from #layers\n//to visualize a chosable fractal pattern via //#define showMultiversePattern\n//to remove unnecessary distortions, less 2d rotation.\n//\n//based on https://www.shadertoy.com/view/Msf3Wr \n//by mu6k\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//known errors\n//brightness oscillates a bit (over time)\n//more noticable with few [layers], barely with layers>6 \n//because f(x)=x-x*x: is not an ideal averaging curve for \"shepard tone fadeing\"\n//but for a good performance it is close enough.\n\n//beware:\n//while this can be used to zoom infinitely\n//its fractalness means that\n//the same valleys/hills re-appear within the same angle\n//and if you stand at the center\n//the horizon is \"a perfect fit\"\n//over infinitely many valleys and mountains.\n//which is noticeable rather quickly\n//even if you map this on a sphere.\n//A workaround for this is to use this noise \n//multiple times to create interferrence patterns.\n\n//type constrains:\n//because [i] [layers] and [pattern] \n//make little sense as floats\n//i made them explicitly type int\n//for user friendly constrains\n//even though type conversion may slow shit down.\n//See yourself how it looks with [pattern] type float\n\n////irrational numbers, do not touch!\nconst float pi =asin(1.)*2.;   //3.14..=fullRotationDistance/radius\nconst float tau=asin(1.)*4.;   //6.28..=fullRotationDistance/diameter\nconst float phi=sqrt(5.)*.5+.5;//1.61..=goldenRatio; 1/phi=1-phi=0.61...\n//they are not essential here, but i like to include them EVERYWHERE\n////irrational numbers.end\n\n\n////modifiable constants:\n//extreme values likely lead to extreme artefacs.\n\n//number if iterations , level of detail\nconst int layers=8;\n//layers=8 is a good compromise bettwen\n//perfortmance and not seeing large squares.\n\n//roughness >1. smaller values are smoother noise.\n//roughness becomes irrelevant on small [layers]\nconst float roughness=8.;//=.7*tau*phi;\n\n//z sets a fractal pattern, it is ALWAYS noticable.\n//some are just less diagonal and blend in more.\n//values near 50 tend to blend in best.\n//values likely >100 cause various issues\n//due to low precision for small abs(p.y) (you will see a \"horizon\" in the noie itself)\nconst int pattern=41;\n\n#define HideMultiversePattern\n//comment out to visualize [pattern]\n//better with layers>9\n//a better [pattern] appears more uniformly grey\n//=41 is pretty decent at that.\n//a \"worse\" pattern will create more noticeable concentric\n//lines or rings of valleys and hills.\n//an ideal pattern may look like a fibonacci spiral?\n\n\n////modifiable constants.end\n\n\n//there are likely better hashes for this one\n//but for this demo the fract(sin()) hash is pretty irrelevant?\nfloat hash(float x){\n return fract(sin     (x*9801.)*99.);\n //return fract(sin(cos(x*99.)*99.)*99.);\n //return fract(sin(cos(x*12.13)*19.123)*17.321);\n}\n\nfloat ss01(float x){return smoothstep(0.,1.,x);}\n//this noise function still works recursivey.\nfloat noise(vec2 p){\n const float z=float(pattern);\n//const float z=float(pattern)*1.61; //bad idea\n vec2 m=fract(p),o=floor(p);o.y*=z;o.y+=o.x;\n float a=hash(o.y     );float b=hash(o.y+1.  );\n float c=hash(o.y+   z);float d=hash(o.y+1.+z);//begs for simplification\n return mix(mix(a,b,ss01(m.x)),mix(c,d,ss01(m.x)),ss01(m.y));}\n\nvoid mainImage( out vec4 r, in vec2 i){\n float o=roughness/sqrt(float(layers));\n //dividing roughness by /sqrt(layers) \n //keeps the zooming speed relatively constant for most layer counts;\n float t=-2.*iTime/o;\n vec2 v=i/iResolution.x;\n v-=vec2(1.,iResolution.y/iResolution.x)*.5;\n float w=0.;\n for(int i=0;i<layers;i++){\n  float j=float(i);\n  float m=float(layers);\n#ifndef HideMultiversePattern \n  j/=o;\n#endif\n  float u=mod(t+j,m);\n  float e=pow(o,u);\n  float l=u-t;\n  float z=u/m;\n  w-=noise(v*e+cos(vec2(l)))*(z-z*z);\n //*(.5-abs(f-.5))*.5;  \n }\n    \n //tweaky values need to be optimized out.\n //so far this linear interpolation works fine (a in,it is visible)\n //for a STATIC range of layers, range [2 to 20]\n w=mix(w+.7,w+1.5,float(layers)*.1-.3);\n r=vec4(vec3(w),1.);}\n\n/*\n//https://www.shadertoy.com/view/ltjXDW#\n\ntiniest\nfloat N(vec2 p) {\n\tvec2 f = fract(p); p-=f; f *= f*(3.-f-f);  \n    return dot( mat2(fract(sin(vec4(0, 1, 57, 58) + p.x+p.y*57.)*1e4)) * vec2(1.-f.y,f.y), vec2(1.-f.x, f.x) );\n}\n\n//tiny:\nvec4 tinInfiniteFractalFabrice( out vec4 o, in vec2 p ){\n    {\n    vec2 r = iResolution.xy; // Fabrice's suggestion.\n\tp=(p-r*.5)/r.y;\n\tfloat c = 0.,t=iTime*.6,f;\n    o=vec4(0);\n    const float layers=14.;\n\tfor (float i = 0.; i<layers; i++){\n\t\tf = fract((i - t*2.)/layers);     \n        o += texture(iChannel0, p*exp2(f*layers)/2e2 + i*.9)*(.5-abs(f-.5))*.5;        \n\t}return o;}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlyGzW", "name": "Light Circles", "author": "Deefunct", "description": "Sun/Moon", "tags": ["2d", "simple", "sun", "beginner", "light", "circle", "glow", "moon", "eclipse", "halo"], "likes": 58, "viewed": 1825, "date": "1473440864", "time_retrieved": "2024-06-20T18:41:45.783133", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 1.5*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 mouse = 1.5*(2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n\tvec2 offset = vec2(cos(iTime/2.0)*mouse.x,sin(iTime/2.0)*mouse.y);;\n\n\tvec3 light_color = vec3(0.9, 0.65, 0.5);\n\tfloat light = 0.1 / distance(normalize(uv), uv);\n\t\n\tif(length(uv) < 1.0){\n\t\tlight *= 0.1 / distance(normalize(uv-offset), uv-offset);\n\t}\n\n\tfragColor = vec4(light*light_color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyGzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtG3D1", "name": "Sono's Cirlcles", "author": "sonofbryce", "description": "trying some stuff wiff circles", "tags": ["circles"], "likes": 0, "viewed": 384, "date": "1474489123", "time_retrieved": "2024-06-20T18:41:45.783133", "image_code": "#define CIRCLE_COUNT 12\t\t\t// number of circles drawn\n#define RING_COUNT 15\t\t\t// number of rings drawn\n\nvec2 r;\n\nfloat drawCircle(vec2 center, float radius)\n{\n    return 1.0 - smoothstep(0.0, radius, length(r - center));\n}\n\nvec3 drawRing(float circleRadius, float gap, float speed, float radius)\n{\n    vec3 color = vec3(0,0,0);\n    for (int i=0; i < CIRCLE_COUNT; i++ )\n    {\n        float j = float(i);\n\n        vec2 center = vec2( sin( (j * gap) + (iTime * speed)) * radius,\n                           cos( (j * gap) + (iTime * speed) ) * radius);\n        color += vec3(drawCircle(center, circleRadius));\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    r =  2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0,0,0);\n    float alpha = 1.0;\n    \n    float speed = 1.0 + sin(iTime * 0.001) * 2.0;\n    float radius = 0.1 + ( (1.0 + sin(iTime * speed)) * 0.1);\n    float gap = 6.28 / float(CIRCLE_COUNT);\n    \n    float circleRadius = 0.0 + ( (1.0 + sin(iTime * speed)) * 0.1);\n    \n    //color += drawRing(circleRadius, gap, speed, radius);\n    \n    //color += drawRing(circleRadius, gap, speed, radius + 0.5);\n    \n    //color += drawRing(circleRadius, gap, speed, radius + 1.0);\n    \n    for (int i=0; i < RING_COUNT; i++)\n    {\n        float j = float(i) + 1.0;\n        float p = float(i+4) / float(RING_COUNT);\n        \n        float iRadius = radius + (j * (0.01 + ( (1.0+sin(iTime * speed)) * 0.2)) );\n        iRadius = radius + (radius * (j * j)) / j;\n        float iSpeed = speed * (j * 0.1);\n        float iCircleRadius = (circleRadius + (j * 0.025));\n        iCircleRadius =  0.01 + sin(circleRadius * j) * 0.5;\n        //iCircleRadius = (j * j) * 0.0025;\n        //iCircleRadius /= j;\n        //iCircleRadius = (circleRadius * 0.25) * (iRadius) * j;\n        \n        color += drawRing(iCircleRadius, gap, iSpeed, iRadius) * p;\n        \n    }\n    \n    \n    fragColor = vec4(color, alpha);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtG3D1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtG3Dz", "name": "Complex plane wave", "author": "Reedbeta", "description": "Visualization of a complex plane wave as R = real, G = imaginary components.", "tags": ["procedural", "2d", "math", "complex"], "likes": 0, "viewed": 506, "date": "1474132155", "time_retrieved": "2024-06-20T18:41:45.783133", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 waveVector = 30.0 * vec2(0.4+cos(iTime), 0.3+sin(iTime));\n    float phase = dot(uv, waveVector);\n    float realPart = cos(phase);\n    float imagPart = sin(phase);\n    fragColor = vec4(realPart * 0.5 + 0.5, imagPart * 0.5 + 0.5, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtG3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtGGDz", "name": "Some Shader", "author": "PeikovaKate", "description": "cool shader", "tags": ["shader"], "likes": 8, "viewed": 602, "date": "1474129903", "time_retrieved": "2024-06-20T18:41:46.661986", "image_code": "// Cubes and Spheres by @paulofalcao\n\n//Scene Start\n\nvec2 sim2d(\n  in vec2 p,\n  in float s)\n{\n   vec2 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\nvec3 stepspace(\n  in vec3 p,\n  in float s)\n{\n  return p-mod(p-s/2.0,s);\n}\n\n//Object\nfloat obj(in vec3 p)\n{ \n  vec3 fp=stepspace(p,2.0);;\n  float d=sin(fp.x*0.3+iTime*4.0)+cos(fp.z*0.3+iTime*2.0);\n  p.y=p.y+d;\n  p.xz=sim2d(p.xz,2.0);\n  //c1 is IQ RoundBox from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n  float c1=length(max(abs(p)-vec3(0.6,0.6,0.6),0.0))-0.35;\n  //c2 is a Sphere\n  float c2=length(p)-1.0;\n  float cf=sin(iTime)*0.5+0.5;\n  return mix(c1,c2,cf);\n}\n\n//Object Color\nvec3 obj_c(vec3 p)\n{\n  vec2 fp=sim2d(p.xz-1.0,4.0);\n  if (fp.y>0.0) fp.x=-fp.x;\n  if (fp.x>0.0) return vec3(0.0,0.0,0.0);\n    else return vec3(1.0,1.0,1.0);   \n}\n\n//Scene End\n\n\n//Raymarching Framework Start\n\nfloat PI=3.14159265;\n\nvec3 phong(\n  in vec3 pt,\n  in vec3 prp,\n  in vec3 normal,\n  in vec3 light,\n  in vec3 color,\n  in float spec,\n  in vec3 ambLight)\n{\n   vec3 lightv=normalize(light-pt);\n   float diffuse=dot(normal,lightv);\n   vec3 refl=-reflect(lightv,normal);\n   vec3 viewv=normalize(prp-pt);\n   float specular=pow(max(dot(refl,viewv),0.0),spec);\n   return (max(diffuse,0.0)+ambLight)*color+specular;\n}\n\nfloat raymarching(\n  in vec3 prp,\n  in vec3 scp,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  out int objfound)\n{ \n  const vec3 e=vec3(0.1,0,0.0);\n  float s=startf;\n  vec3 c,p,n;\n  float f=startf;\n  objfound=1;\n  for(int i=0;i<600;i++){\n    if (abs(s)<precis||f>maxd||i>maxite) break;\n    f+=s;\n    p=prp+scp*f;\n    s=obj(p);\n  }\n  if (f>maxd) objfound=-1;\n  return f;\n}\n\nvec3 camera(\n  in vec3 prp,\n  in vec3 vrp,\n  in vec3 vuv,\n  in float vpd,\n  in vec2 fragCoord)\n{\n  vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 scrCoord=prp+vpn*vpd+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  return normalize(scrCoord-prp);\n}\n\nvec3 normal(in vec3 p)\n{\n  //tetrahedron normal\n  const float n_er=0.01;\n  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er));\n  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er));\n  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er));\n  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er));\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvec3 render(\n  in vec3 prp,\n  in vec3 scp,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  in vec3 background,\n  in vec3 light,\n  in float spec,\n  in vec3 ambLight,\n  out vec3 n,\n  out vec3 p,\n  out float f,\n  out int objfound)\n{ \n  objfound=-1;\n  f=raymarching(prp,scp,maxite,precis,startf,maxd,objfound);\n  if (objfound>0){\n    p=prp+scp*f;\n    vec3 c=obj_c(p);\n    n=normal(p);\n    vec3 cf=phong(p,prp,n,light,c,spec,ambLight);\n    return vec3(cf);\n  }\n  f=maxd;\n  return vec3(background); //background color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n \n  //Camera animation\n  vec3 vuv=vec3(0,1,0);\n  vec3 vrp=vec3(iTime*4.0,0.0,0.0);\n  float mx=iMouse.x/iResolution.x*PI*2.0;\n  float my=iMouse.y/iResolution.y*PI/2.01;\n  if ((iMouse.x<=0.0)||(iMouse.y<=0.0)){mx=0.0,my=1.5;};//quick hack to detect no mouse input for thumbnail\n  vec3 prp=vrp+vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*35.0; //Trackball style camera pos\n  float vpd=1.5;\n  vec3 light=prp+vec3(5.0,0,5.0);\n  \n  vec3 scp=camera(prp,vrp,vuv,vpd,fragCoord);\n  vec3 n,p;\n  float f;\n  int o;\n  const float maxe=0.01;\n  const float startf=0.1;\n  const vec3 backc=vec3(0.0,0.0,0.0);\n  const float spec=8.0;\n  const vec3 ambi=vec3(0.1,0.1,0.1);\n  \n  vec3 c1=render(prp,scp,600,maxe,startf,60.0,backc,light,spec,ambi,n,p,f,o);\n  c1=c1*max(1.0-f*.015,0.0);\n  vec3 c2=backc;\n  if (o>0){\n    scp=reflect(scp,n);\n    c2=render(p+scp*0.05,scp,32,maxe,startf,10.0,backc,light,spec,ambi,n,p,f,o);\n  }\n  c2=c2*max(1.0-f*.1,0.0);\n  fragColor=vec4(c1.xyz*0.75+c2.xyz*0.25,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtGGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtK3WW", "name": "Tree Dancing", "author": "vox", "description": "Updated.", "tags": ["paint", "dancing"], "likes": 4, "viewed": 457, "date": "1474741436", "time_retrieved": "2024-06-20T18:41:47.413541", "image_code": "\nfloat PI = 3.14159265359;\n#define GR 1.61803398875\n#define EPS .001\n\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\nfloat stair(float x)\n{\n    return float(int(x));\n}\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, PI/6.0+sin(iTime)*.1);\n    square = scale(square, vec2(.75));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\n\nvec4 draw(vec2 uv)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn vec4(1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5)*uv.x;\n\telse\n\t\treturn vec4(0.0);\n}\nconst int max_iterations = 16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0-1.0;\n    \n    vec4 screen = draw(uv);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv = tree(uv)*2.0-1.0;; \n        screen += draw(uv*.5+.5);\n    }\n\n    fragColor = screen;\n    //screen.x /= float(max_iterations); screen.x *= 2.0*PI;\n    fragColor = clamp(screen.x, 0.0, 1.0)*vec4(vec3(sin(iTime*5.0+0.0+screen.x),\n                                                       sin(iTime*5.0+4.0*PI/3.0+screen.x),\n                                                       sin(iTime*5.0+2.0*PI/3.0+screen.x))*.5+.5,\n                                                  1.0);\n  \t//fragColor = vec4(uv, 0.0, 1.0);\n}", "image_inputs": [{"id": "XsXGR8", "previewfilepath": "/media/previz/buffer01.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer01.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtK3WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKGD1", "name": "multiple reflections", "author": "andrewww1", "description": "A room with a sphere inside showing multiple reflections.\n\nSet REFLECT_NUM to change the number of reflections.\n\nMouse X position yaws, and mouse Y position sets zoom.", "tags": ["reflections", "multiple"], "likes": 1, "viewed": 121, "date": "1474526408", "time_retrieved": "2024-06-20T18:41:47.413541", "image_code": "\n#define REFLECT_NUM 8\n\nbool intersectPlane(vec3 P,vec3 V,vec4 plane, out float t) {\n  //ax+by+cz+d=0\n\n  float d=plane.w;\n  vec3 N=plane.xyz;\n\n  float NPd=dot(N,P)+d;\n\n  //origin below or on plane\n  if(NPd <= 0.0) {\n    t=0.0;\n    return false;\n  }\n\n  //\n  float NV=dot(N,V);\n\n  //vector parallel or pointing away from plane\n  if(NV >= 0.0) {\n    t=0.0;\n    return false;\n  }\n\n  //\n  t=-NPd/NV;\n\n  //\n  return true;\n}\n\n\nbool intersectSphere(vec3 P,vec3 V,vec3 C,float r,out float t) {\n  vec3 M;\n  float b,d,c;\n\n  M=P-C;\n  c=dot(M,M)-r*r;\n\n  if(c<0.0) {\n    return false;\n  }\n\n  b=dot(V,M);\n\n  if(b > 0.0) {\n    return false;\n  }\n\n  d=b*b-c;\n\n  if(d < 0.0) {\n    return false;\n  }\n\n  t=-b-sqrt(d);\n  return true;\n}\n\nbool intersectWall(vec3 ro, vec3 rd, out vec3 ptOut, out vec3 norOut, out vec3 colOut) {\n  vec3 nor;\n  float scale=10.0;\n  float t;\n  \n  //wall x\n  if(intersectPlane(ro,rd,vec4(nor=vec3(1.0,0.0,0.0),scale),t) ||\n     intersectPlane(ro,rd,vec4(nor=vec3(-1.0,0.0,0.0),scale),t)) {\n    vec3 pt=ro+rd*t;\n\n    if(pt.z>=-scale&&pt.z<=scale&&pt.y>=-scale&&pt.y<=scale){\n      ptOut=pt;\n      norOut=nor;\n      colOut=nor*0.5+0.5;\n      return true;\n    }\n  }\n\n  //wall y\n  if(intersectPlane(ro,rd,vec4(nor=vec3(0.0,1.0,0.0),scale),t) ||\n     intersectPlane(ro,rd,vec4(nor=vec3(0.0,-1.0,0.0),scale),t)) {\n    vec3 pt=ro+rd*t;\n\n    if(pt.z>=-scale&&pt.z<=scale&&pt.x>=-scale&&pt.x<=scale){\n      ptOut=pt;\n      norOut=nor;\n      colOut=nor*0.5+0.5;\n      return true;\n    }\n  }\n\n  //wall z\n  if(intersectPlane(ro,rd,vec4(nor=vec3(0.0,0.0,1.0),scale),t) ||\n     intersectPlane(ro,rd,vec4(nor=vec3(0.0,0.0,-1.0),scale),t)) {\n    vec3 pt=ro+rd*t;\n\n    if(pt.x>=-scale&&pt.x<=scale&&pt.y>=-scale&&pt.y<=scale){\n      ptOut=pt;\n      norOut=nor;\n      colOut=nor*0.5+0.5;\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nbool intersectScene(vec3 ro, vec3 rd, out vec3 ptOut, out vec3 norOut, out vec3 colOut) {\n  //spheres\n  if(true) {\n    float t,tt;\n    bool found=false;\n    vec3 c;\n  \n    //sphere 1\n    c=vec3(0.0,0.0,0.0);\n  \n    if(intersectSphere(ro,rd,c,2.0,tt) && (!found || tt<t)) {\n      found=true;\n      t=tt;\n    \n      vec3 pt=ro+rd*t;\n      ptOut=pt;\n      norOut=normalize(pt-c);\n      colOut=vec3(1.0);\n    }\n\n    //sphere 2\n    if(false) {\n\t  c=vec3(6.0,0.0,0.0);\n  \n      if(intersectSphere(ro,rd,c,2.0,tt) && (!found || tt<t)) {\n        found=true;\n        t=tt;\n    \n        vec3 pt=ro+rd*t;\n        ptOut=pt;\n        norOut=normalize(pt-c);\n        colOut=vec3(1.0);\n      }\n\t}\n  \n    if(found) {\n      return true;\n    }\n  }\n  \n  if(intersectWall(ro,rd,ptOut,norOut,colOut)) {\n    return true;\n  }\n\n  colOut=vec3(0.0);\n  return false;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 pt,nor;\n  vec3 col=vec3(0.0,0.0,0.0);\n\n  if(intersectScene(ro,rd,pt,nor,col)) {\n    vec3 col2;\n    vec3 rd2=rd;\n    float d=1.0;\n    for(int i=0;i<REFLECT_NUM;i++) {\n      rd2=normalize(reflect(rd2,nor));\n          \n      if(!intersectScene(pt,rd2,pt,nor,col2)) {\n        break;\n      }\n          \n      col=mix(col,col2,0.5*d);\n      //d*=0.9;      \n    }\n  }\n  \n  return vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n  float d=1.0/tan(fovy/2.0);\n  vec3 v=vec3(screen.x*aspect,screen.y,-d);\n  v=normalize(v);\n  return v;\n}\n\nmat3 orbitViewRot(float yaw,float pitch) {\n    vec2 s=vec2(sin(pitch),sin(yaw));\n    vec2 c=vec2(cos(pitch),cos(yaw));\n    return mat3(c.y,0.0,-s.y,s.y*s.x,c.x,c.y*s.x,s.y*c.x,-s.x,c.y*c.x); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 scr = uv*2.0-1.0;\n    vec2 ms = iMouse.xy / iResolution.xy;\n    vec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.5,0.5):ms;\n    float aspect=iResolution.x/iResolution.y;\n    float fovy=0.7854;\n\n    float pitch=0.0;//(ms2.y-0.5);\n    float yaw=(iMouse.z<=0.0)?iTime*0.25:(ms2.x-0.5)*10.0;\n    \n    mat3 viewRot=orbitViewRot(yaw,pitch);\n    \n    float d=(iMouse.z<=0.0)?-0.5:(ms2.y-0.5);\n    \n    vec3 ro=viewRot*vec3(0.0,0.0,d*30.0+18.0);\n    vec3 rd=normalize(viewRot*calcPrimaryRay(scr,fovy,aspect));\n    vec3 col=render(ro,rd);\n\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKGD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKGWD", "name": "hex trigonometry", "author": "ollj", "description": "trying to make constants for this tiny hex function more precise\nshown to be not really worth it as they already are VERY precise.\n\nshowing that trigonometry often just is the slower and less precise approach than unions of simpler shapes.", "tags": ["circle", "rotate", "hexagon", "rotation", "hex", "scale", "trigonometry"], "likes": 3, "viewed": 143, "date": "1474767583", "time_retrieved": "2024-06-20T18:41:47.953061", "image_code": "#define rainbowSeizure\n//rainbowSeizure shows underlining geometry.\n\n//in conclusion: trigonometry functions like sin()\n//quickly accumulate larger rounding errors than\n//the precision that you could get from\n//using them to calculate more precise constants for skewed gradients.\n//and this only gets worse for mobile hardware that rounds sin() even more.\n\n//skewing (rotated) gradients for distance functions\n//easily is more precise than inverse square roots or asin()\n\n//this is all about the constants of this hex function.\nconst float tau=asin(1.)*4.,\n    c1=0.57735,//0.57735\n    c2=1.1547;//1.1547\n//return distance of p to border of hexagon with inner radius r.\nfloat hexBase(const in vec2 p,const in float r){vec2 q=abs(p);\n return max(q.x,max(q.x+q.y*c1,q.y*c2))-r;}\n//i was curious if i could \n//trigonometrically calculate them to higher precision.\n//but i gave up, realizing tha they already are VERY precise\n//for pretty much all purposes of signed distance functions.\n//they are more precise than the accumulative\n//precision loss of a few sin() mod() (1/x*x) (1+1/x) functions.\n//showing that hexBase() is not only tiny \n//but also bestPerformance and PreciseEnough\n//unless you want some subpixel precision for antialiasing\n//which i do not care for.\n\n//hex()==hexBase() but with 2 more components\nvec3 hex(const in vec2 p,const in float r){vec2 q=abs(p);\n vec3 s=vec3(0.);//return value.                    \n s.x=q.x+q.y*c1;\n s.y=    q.y*c2;   \n s.z=max(q.x,max(q.x+q.y*c1,q.y*c2))-r;\n return s;}\n//for optional visualization of what shapes are defined by the constants.\n//via \"#rainbowSeizure\"\n\n//return 2d rotation matrix r=2.*pi->full rotation;\nmat2 r2(float r){float s=sin(r),c=cos(r);return mat2(c,s,-s,c);}\n#define oz vec3(1,0,-1)\n//shorter faster (less precise) variant of r2();\n#define r2s(r) mat2(sin(r+oz.xyyz*asin(1.)))\n//for single rotations only !!!\n//as it rotates by mirroring along half-rotation.\n//and that mirror symmetry cancels out all accumulativeEven rotations \n//(similar to how 2 quaternion rotations of an inaginary vector cancel out the real part)\n\n#define ssb(a,b,c) smoothstep(a-b,a+b,c)\n\nvoid mainImage(out vec4 r,in vec2 f){\n vec2 p=f.xy/iResolution.xy;//scale frame to screen resolution.\n p-=vec2(.5);//move frame so that p=vec2(0,0)=frame.center\n p.x/=iResolution.y/iResolution.x;//scale frame.x to aspect ratio\n p*=2.;//scale frame\n p*=r2s(tau/6.);//rotate frame by fullRotation/6;\n float blur=sin(iTime)*.5+.52;//vary blur ovrer time\n vec3 h=hex(p,1.);\n h=mod(h*2./blur,2.);//blur also sets some scaling.\n    //mod(x.2.)makes the image brighter, i want to see the circles\n //r.rgb=ssb(.5,blur,h);\n r.rgb=vec3(ssb(.5,blur,h.z))*.8+.2;\n#ifdef rainbowSeizure\n r.rg*=h.rg;//optional\n#endif\n //\n //draw 6 circles to measure the corners of the hexagon.\n vec2 d=vec2(1.,.0);//circle.center , gets rotated.\n #define tru g=length(p-d);if(mod(g,1.)<.005 \n float tru)r.r-=.5+.2;//1 blue circle\n for(int i=0;i<6;i++){\n  d*=r2(tau/6.);tru)r.g-=.5+.2;//rotate redraw.\n}}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtV3Dw", "name": "Something Ugly", "author": "vox", "description": "Something Ugly", "tags": ["ugly", "something"], "likes": 1, "viewed": 462, "date": "1475014628", "time_retrieved": "2024-06-20T18:41:49.286636", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__)*100.0)*GR/PI+GR/PI/E)*iTime+10.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\n\nfloat seedling = 0.0;\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\nfloat getEyes(vec2 uv)\n{\n    vec2 p = uv;\n\n    p.y += 1.0/PI;\n\n    p.x *= GR;\n\n    vec4 a = vec4(-1.0/GR, 1.0/GR, 0, 0);\n    vec4 b = vec4(1.0/GR, 1.0/GR, 0, 0);\n\n    p.y += cos(uv.x*8.0)/PI;\n\n    float distA = length(p.xy-a.xy);\n    float distB = length(p.xy-b.xy);\n\n    float fade_lengthA = .20;\n    float fade_lengthB = .20;\n\n    float color = clamp((1.0-distA/fade_lengthA)*distB, 0.0, 1.0)\n        \t\t  +clamp((1.0-distB/fade_lengthB)*distA, 0.0, 1.0);\n    return color;\n}\n\nfloat getTeeth(vec2 uv)\n{\n    vec2 p = uv;\n    p.x *= PI;\n    p.y *= PI*(cos(p.x/PI/PI));\n    p.y += 1.5*cos(p.x)+1.0;\n    p.y *= (sin(time*PI*20.0+seedling))+2.0;\n\n    float r = p.x*p.x+p.y*p.y;\n    \n    float xy = sin(p.x*PI*10.0)+cos(p.y*3.0+PI);\n\n    return clamp(clamp((3.0/(r*r*r)-p.y*p.y), 0.0, 1.0)*xy, 0.0, 1.0);\n}\n\nvec3 demon(vec2 uv)\n{\n    float eyes = getEyes(uv);\n    float teeth = getTeeth(uv);\n    \n    return eyes+flux(seedling)*eyes+teeth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = exp(sin(time))*E+GR;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    vec2 uv0 = uv;\n    uv += cos(vec2(time, time/GR));\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    vec4 hit = vec4(0.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n        \n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        hit.rgb += demon(saw(uv*PI/2.0)*2.0-1.0)*clamp(1.0-length(hit.rgb), 0.0, 1.0)*(1.0-border);\n    }\n    \n\n    scale = 32.;\n    vec2 gridPosition = floor(uv0 * scale) / scale;\n    vec2 randomOffset = hash(gridPosition) * 2. - 1.;\n    vec2 localGridPositionCenter = fract(uv0 * scale) - .5;\n    float stars = mix(0., 1., step(length(localGridPositionCenter + randomOffset * .5), .1));\n\n    float map2 = (length(randomOffset))*PI*2.0;\n\n    float twinkle = saw(time+map2);\n\n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n    \n    fragColor = GR*(hit+vec4(flux(border+seedling+time)*(border-length(hit.rgb)/sqrt(3.0)), 1.0)*smoothstep(0.0, 1.0/GR/PI/GR, 1.0-border))*(antispeckle);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtV3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtV3RR", "name": "Fall (Remix)", "author": "Flafla2", "description": "This is an animated interpretation of Bridget Riley's abstract painting \"Fall,\" created for 62-150 Intro to Media Synthesis and Analysis at Carnegie Mellon University.\n\nSee Painting Here: http://www.tate.org.uk/art/artworks/riley-fall-t00616\n", "tags": ["procedural", "2d"], "likes": 4, "viewed": 1011, "date": "1472835085", "time_retrieved": "2024-06-20T18:41:49.619805", "image_code": "// \"Fall Remix\"\n// Adrian Biagioli, 2 September 2016\n//\n// This is an animated digital interpretation of Bridget Riley's abstract painting \"Fall,\"\n// created for 62-150 Intro to Media Synthesis and Analysis at Carnegie Mellon University\n//\n// See Painting Here: http://www.tate.org.uk/art/artworks/riley-fall-t00616\n\n// #define SHOW_RAW_SINUSOIDAL\nvec4 map(vec2 coord, float dist) {\n    float offset = sin(pow((1.0-coord.y),3.4)*8.0 - iTime - 2.53) / 25.0; // This is the \"wave\" func\n    #ifdef SHOW_RAW_SINUSOIDAL\n    float col = floor(coord.x+0.5+offset)*0.5+0.25;\n    #else\n    int col = int(mod(coord.x+offset, dist*2.0) / dist);\n    #endif\n    return vec4(col,col,col,1);\n}\n\n// Number of samples per pixel, in each dimension (so the real number of samples is this squared)\n// The higher this is, the less aliasing there is.\n#define NUM_SAMPLES 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    uv -= (iResolution.x - iResolution.y) / 2.0;\n    uv /= iResolution.y;\n    if(uv.x < 0.0 || uv.x > 1.0) {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    // Better support for low resolutions (to avoid grey blob)\n    float thickness = 0.005;\n    if(thickness*iResolution.y < 2.0)\n        thickness = 2.0 / iResolution.y;\n    \n    vec2 tex = vec2((iResolution.x/iResolution.y) / iResolution.y, 1.0 / iResolution.y);\n    vec2 htex = tex/2.0;\n    vec2 sampledist = tex / float(NUM_SAMPLES);\n    \n    vec4 result = vec4(0,0,0,0);\n    \n    // Basic SSAA with uniform sampling\n    for(int x=0;x<NUM_SAMPLES;x++) {\n        for(int y=0;y<NUM_SAMPLES;y++) {\n            result += map(uv-htex+sampledist*vec2(float(x)+0.5,float(y)+0.5), thickness) / float(NUM_SAMPLES * NUM_SAMPLES);\n        }\n    }\n    fragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtV3RR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtV3W1", "name": "Blue noise comparison", "author": "bartwronski", "description": "Comparison of few noise generation / sampling techniques\nHold mouse to freeze time and number of samples", "tags": ["sampling", "rendering", "dithering", "bluenoise", "highpass", "uniform", "bayer", "interleavedgradientnoise"], "likes": 24, "viewed": 2370, "date": "1474523054", "time_retrieved": "2024-06-20T18:41:59.735696", "image_code": "// Shader comparing some noise functions for disk sampling\n// 1. No noise\n\n// 2. Simple random \"bad\" noise; second coordinate via re-hashing\n\n// 3. Blue noise generated by https://github.com/bartwronski/BlueNoiseGenerator/ single float; second coordinate via re-hashing\n\n// 4. Blue noise generated by https://github.com/bartwronski/BlueNoiseGenerator/ 2 component vector\n\n// 5. High-pass treated normal noise by Timothy Lottes https://www.shadertoy.com/view/4sBSDW \n// disclaimer - I didn't fully understand the implementation, so noise is shifted... Will try to fix it later.\n\n// 6. 16x16 Bayer matrix by patapom https://www.shadertoy.com/view/Mlt3z8 ; second coordinate via re-hashing.\n\n// 7. Interleaved Gradient noise by Jorge Jimenez http://advances.realtimerendering.com/s2014/index.html ; second coordinate via re-hashing.\n\n// 8. (New!) Predefined blue noise texture available in ShaderToy since recently. \n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nF1 Noise(F2 n,F1 x){n+=x;return fract(sin(dot(n.xy,F2(12.9898, 78.233)))*43758.5453);}\n\n// Step 1 in generation of the dither source texture.\nF1 Step1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Step2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (4.0/(a*4.0+b*4.0-c))*(\n  Step1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Step1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Step1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Step1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Step1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Step1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Step1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Step1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Step1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n\nbool sampleDist(vec2 uv)\n{\n    float radius = 0.1;\n    return sqrt(dot(uv, uv)) < radius;\n}\n\nbool sampleDistComp(vec2 uv, float radius_)\n{\n    float threshold = 0.005;\n    float radius = 0.1 + radius_;\n    \n    return sqrt(dot(uv, uv)) < radius*(1.0+threshold) && sqrt(dot(uv, uv)) > radius * (1.0-threshold);\n}\n\nfloat interleavedGradientNoise(vec2 pos)\n{\n  float f = 0.06711056 * pos.x + 0.00583715 * pos.y;\n  return fract(52.9829189 * fract(f));\n}\n    \nfloat B2( vec2 _P ) {\n//    return ((_P.y << 1) + _P.x + 1) & 3;    <= This would fare much better than modulos and floors :(\n    return mod( 2.0*_P.y + _P.x + 1.0, 4.0 );\n}\n\n// Generates the 16x16 matrix\nfloat B16( vec2 _P ) {\n    vec2    P1 = mod( _P, 2.0 );                    // (P >> 0) & 1\n    vec2    P2 = floor( 0.5 * mod( _P, 4.0 ) );        // (P >> 1) & 1\n    vec2    P4 = floor( 0.25 * mod( _P, 8.0 ) );    // (P >> 2) & 1\n    vec2    P8 = floor( 0.125 * mod( _P, 16.0 ) );    // (P >> 3) & 1\n    return 4.0*(4.0*(4.0*B2(P1) + B2(P2)) + B2(P4)) + B2(P8);\n}\n\nvec2 randBlue2(vec2 coord)\n{\n    int i = int(mod(coord.x, 16.0));\n    int j = int(mod(coord.y, 16.0));\n    int finalDist = j*16+i;\n    \n    if(finalDist < 128) \n{\nif(finalDist < 64) \n{\nif(finalDist < 32) \n{\nif(finalDist < 16) \n{\nif(finalDist < 8) \n{\nif(finalDist < 4) \n{\nif(finalDist < 2) \n{\nif(finalDist < 1) \n{\nreturn vec2(0.332031, 0.707031);} else {\nreturn vec2(0.652344, 0.972656);\n}} else {\nif(finalDist < 3) \n{\nreturn vec2(0.457031, 0.5);} else {\nreturn vec2(0.175781, 0.953125);\n}\n}} else {\nif(finalDist < 6) \n{\nif(finalDist < 5) \n{\nreturn vec2(0.417969, 0.316406);} else {\nreturn vec2(0.398438, 0.609375);\n}} else {\nif(finalDist < 7) \n{\nreturn vec2(0.660156, 0.769531);} else {\nreturn vec2(0.960938, 0.804688);\n}\n}\n}} else {\nif(finalDist < 12) \n{\nif(finalDist < 10) \n{\nif(finalDist < 9) \n{\nreturn vec2(0.3125, 0.25);} else {\nreturn vec2(0.285156, 0.09375);\n}} else {\nif(finalDist < 11) \n{\nreturn vec2(0, 0.851563);} else {\nreturn vec2(0.921875, 0.273438);\n}\n}} else {\nif(finalDist < 14) \n{\nif(finalDist < 13) \n{\nreturn vec2(0.351563, 0.652344);} else {\nreturn vec2(0.167969, 0.738281);\n}} else {\nif(finalDist < 15) \n{\nreturn vec2(0.195313, 0.203125);} else {\nreturn vec2(0.90625, 0.808594);\n}\n}\n}\n}} else {\nif(finalDist < 24) \n{\nif(finalDist < 20) \n{\nif(finalDist < 18) \n{\nif(finalDist < 17) \n{\nreturn vec2(0.203125, 0.0664063);} else {\nreturn vec2(0.839844, 0.160156);\n}} else {\nif(finalDist < 19) \n{\nreturn vec2(0.867188, 0.40625);} else {\nreturn vec2(0.257813, 0.472656);\n}\n}} else {\nif(finalDist < 22) \n{\nif(finalDist < 21) \n{\nreturn vec2(0.785156, 0.164063);} else {\nreturn vec2(0.542969, 0.351563);\n}} else {\nif(finalDist < 23) \n{\nreturn vec2(0.0664063, 0.863281);} else {\nreturn vec2(0.597656, 0.15625);\n}\n}\n}} else {\nif(finalDist < 28) \n{\nif(finalDist < 26) \n{\nif(finalDist < 25) \n{\nreturn vec2(0.0195313, 0.8125);} else {\nreturn vec2(0.6875, 0.601563);\n}} else {\nif(finalDist < 27) \n{\nreturn vec2(0.582031, 0.75);} else {\nreturn vec2(0.765625, 0.0898438);\n}\n}} else {\nif(finalDist < 30) \n{\nif(finalDist < 29) \n{\nreturn vec2(0.304688, 0.242188);} else {\nreturn vec2(0.574219, 0.65625);\n}} else {\nif(finalDist < 31) \n{\nreturn vec2(0.773438, 0.214844);} else {\nreturn vec2(0.128906, 0.886719);\n}\n}\n}\n}\n}} else {\nif(finalDist < 48) \n{\nif(finalDist < 40) \n{\nif(finalDist < 36) \n{\nif(finalDist < 34) \n{\nif(finalDist < 33) \n{\nreturn vec2(0.4375, 0.296875);} else {\nreturn vec2(0.511719, 0.871094);\n}} else {\nif(finalDist < 35) \n{\nreturn vec2(0.0390625, 0.308594);} else {\nreturn vec2(0.539063, 0.632813);\n}\n}} else {\nif(finalDist < 38) \n{\nif(finalDist < 37) \n{\nreturn vec2(0.863281, 0.933594);} else {\nreturn vec2(0.0429688, 0.28125);\n}} else {\nif(finalDist < 39) \n{\nreturn vec2(0.828125, 0.683594);} else {\nreturn vec2(0.585938, 0.261719);\n}\n}\n}} else {\nif(finalDist < 44) \n{\nif(finalDist < 42) \n{\nif(finalDist < 41) \n{\nreturn vec2(0.847656, 0.570313);} else {\nreturn vec2(0.769531, 0.121094);\n}} else {\nif(finalDist < 43) \n{\nreturn vec2(0.0859375, 0.410156);} else {\nreturn vec2(0.933594, 0.910156);\n}\n}} else {\nif(finalDist < 46) \n{\nif(finalDist < 45) \n{\nreturn vec2(0.0078125, 0.894531);} else {\nreturn vec2(0.898438, 0.695313);\n}} else {\nif(finalDist < 47) \n{\nreturn vec2(0.117188, 0.480469);} else {\nreturn vec2(0.914063, 0.511719);\n}\n}\n}\n}} else {\nif(finalDist < 56) \n{\nif(finalDist < 52) \n{\nif(finalDist < 50) \n{\nif(finalDist < 49) \n{\nreturn vec2(0.246094, 0.976563);} else {\nreturn vec2(0.746094, 0.367188);\n}} else {\nif(finalDist < 51) \n{\nreturn vec2(0.566406, 0.304688);} else {\nreturn vec2(0.105469, 0.785156);\n}\n}} else {\nif(finalDist < 54) \n{\nif(finalDist < 53) \n{\nreturn vec2(0.722656, 0.238281);} else {\nreturn vec2(0.761719, 0.0234375);\n}} else {\nif(finalDist < 55) \n{\nreturn vec2(0.382813, 0.832031);} else {\nreturn vec2(0.28125, 0.0273438);\n}\n}\n}} else {\nif(finalDist < 60) \n{\nif(finalDist < 58) \n{\nif(finalDist < 57) \n{\nreturn vec2(0.234375, 0.699219);} else {\nreturn vec2(0.378906, 0.585938);\n}} else {\nif(finalDist < 59) \n{\nreturn vec2(0.421875, 0.636719);} else {\nreturn vec2(0.613281, 0.378906);\n}\n}} else {\nif(finalDist < 62) \n{\nif(finalDist < 61) \n{\nreturn vec2(0.441406, 0.195313);} else {\nreturn vec2(0.519531, 0.171875);\n}} else {\nif(finalDist < 63) \n{\nreturn vec2(0.390625, 0.859375);} else {\nreturn vec2(0.628906, 0.421875);\n}\n}\n}\n}\n}\n}} else {\nif(finalDist < 96) \n{\nif(finalDist < 80) \n{\nif(finalDist < 72) \n{\nif(finalDist < 68) \n{\nif(finalDist < 66) \n{\nif(finalDist < 65) \n{\nreturn vec2(0.835938, 0.417969);} else {\nreturn vec2(0.140625, 0.375);\n}} else {\nif(finalDist < 67) \n{\nreturn vec2(0.96875, 0.84375);} else {\nreturn vec2(0.136719, 0.257813);\n}\n}} else {\nif(finalDist < 70) \n{\nif(finalDist < 69) \n{\nreturn vec2(0.335938, 0.90625);} else {\nreturn vec2(0.65625, 0.664063);\n}} else {\nif(finalDist < 71) \n{\nreturn vec2(0.273438, 0.539063);} else {\nreturn vec2(0.59375, 0.824219);\n}\n}\n}} else {\nif(finalDist < 76) \n{\nif(finalDist < 74) \n{\nif(finalDist < 73) \n{\nreturn vec2(0.917969, 0.800781);} else {\nreturn vec2(0.832031, 0.136719);\n}} else {\nif(finalDist < 75) \n{\nreturn vec2(0.144531, 0.0117188);} else {\nreturn vec2(0.667969, 0.925781);\n}\n}} else {\nif(finalDist < 78) \n{\nif(finalDist < 77) \n{\nreturn vec2(0.101563, 0.449219);} else {\nreturn vec2(0.742188, 0.675781);\n}} else {\nif(finalDist < 79) \n{\nreturn vec2(0.75, 0.0429688);} else {\nreturn vec2(0.0820313, 0.246094);\n}\n}\n}\n}} else {\nif(finalDist < 88) \n{\nif(finalDist < 84) \n{\nif(finalDist < 82) \n{\nif(finalDist < 81) \n{\nreturn vec2(0.179688, 0.914063);} else {\nreturn vec2(0.664063, 0.0351563);\n}} else {\nif(finalDist < 83) \n{\nreturn vec2(0.480469, 0.789063);} else {\nreturn vec2(0.734375, 0.105469);\n}\n}} else {\nif(finalDist < 86) \n{\nif(finalDist < 85) \n{\nreturn vec2(0.753906, 0.390625);} else {\nreturn vec2(0.183594, 0.484375);\n}} else {\nif(finalDist < 87) \n{\nreturn vec2(0.691406, 0.109375);} else {\nreturn vec2(0.359375, 0.175781);\n}\n}\n}} else {\nif(finalDist < 92) \n{\nif(finalDist < 90) \n{\nif(finalDist < 89) \n{\nreturn vec2(0.0625, 0.726563);} else {\nreturn vec2(0.425781, 0.648438);\n}} else {\nif(finalDist < 91) \n{\nreturn vec2(0.449219, 0.761719);} else {\nreturn vec2(0.699219, 0.113281);\n}\n}} else {\nif(finalDist < 94) \n{\nif(finalDist < 93) \n{\nreturn vec2(0.820313, 0.558594);} else {\nreturn vec2(0.0976563, 0.71875);\n}} else {\nif(finalDist < 95) \n{\nreturn vec2(0.609375, 0.523438);} else {\nreturn vec2(0.476563, 0.671875);\n}\n}\n}\n}\n}} else {\nif(finalDist < 112) \n{\nif(finalDist < 104) \n{\nif(finalDist < 100) \n{\nif(finalDist < 98) \n{\nif(finalDist < 97) \n{\nreturn vec2(0.878906, 0.773438);} else {\nreturn vec2(0.191406, 0.269531);\n}} else {\nif(finalDist < 99) \n{\nreturn vec2(0.472656, 0.667969);} else {\nreturn vec2(0.0234375, 0.566406);\n}\n}} else {\nif(finalDist < 102) \n{\nif(finalDist < 101) \n{\nreturn vec2(0.78125, 0.898438);} else {\nreturn vec2(0.078125, 0.535156);\n}} else {\nif(finalDist < 103) \n{\nreturn vec2(0.851563, 0.875);} else {\nreturn vec2(0.925781, 0.292969);\n}\n}\n}} else {\nif(finalDist < 108) \n{\nif(finalDist < 106) \n{\nif(finalDist < 105) \n{\nreturn vec2(0.796875, 0.613281);} else {\nreturn vec2(0.355469, 0.148438);\n}} else {\nif(finalDist < 107) \n{\nreturn vec2(0.957031, 0.222656);} else {\nreturn vec2(0.046875, 0.730469);\n}\n}} else {\nif(finalDist < 110) \n{\nif(finalDist < 109) \n{\nreturn vec2(0.394531, 0.714844);} else {\nreturn vec2(0.484375, 0.015625);\n}} else {\nif(finalDist < 111) \n{\nreturn vec2(0.816406, 0.78125);} else {\nreturn vec2(0.0585938, 0.132813);\n}\n}\n}\n}} else {\nif(finalDist < 120) \n{\nif(finalDist < 116) \n{\nif(finalDist < 114) \n{\nif(finalDist < 113) \n{\nreturn vec2(0.984375, 0.140625);} else {\nreturn vec2(0.679688, 0.425781);\n}} else {\nif(finalDist < 115) \n{\nreturn vec2(0.671875, 0.980469);} else {\nreturn vec2(0.347656, 0.03125);\n}\n}} else {\nif(finalDist < 118) \n{\nif(finalDist < 117) \n{\nreturn vec2(0.941406, 0.199219);} else {\nreturn vec2(0.632813, 0.46875);\n}} else {\nif(finalDist < 119) \n{\nreturn vec2(0.160156, 0.234375);} else {\nreturn vec2(0.261719, 0.890625);\n}\n}\n}} else {\nif(finalDist < 124) \n{\nif(finalDist < 122) \n{\nif(finalDist < 121) \n{\nreturn vec2(0.277344, 0.355469);} else {\nreturn vec2(0.367188, 0.597656);\n}} else {\nif(finalDist < 123) \n{\nreturn vec2(0.328125, 0.488281);} else {\nreturn vec2(0.996094, 0.996094);\n}\n}} else {\nif(finalDist < 126) \n{\nif(finalDist < 125) \n{\nreturn vec2(0.578125, 0.183594);} else {\nreturn vec2(0.929688, 0.515625);\n}} else {\nif(finalDist < 127) \n{\nreturn vec2(0.0117188, 0.988281);} else {\nreturn vec2(0.527344, 0.503906);\n}\n}\n}\n}\n}\n}\n}} else {\nif(finalDist < 192) \n{\nif(finalDist < 160) \n{\nif(finalDist < 144) \n{\nif(finalDist < 136) \n{\nif(finalDist < 132) \n{\nif(finalDist < 130) \n{\nif(finalDist < 129) \n{\nreturn vec2(0.210938, 0.835938);} else {\nreturn vec2(0.714844, 0.3125);\n}} else {\nif(finalDist < 131) \n{\nreturn vec2(0.164063, 0.492188);} else {\nreturn vec2(0.25, 0.589844);\n}\n}} else {\nif(finalDist < 134) \n{\nif(finalDist < 133) \n{\nreturn vec2(0.601563, 0.53125);} else {\nreturn vec2(0.226563, 0.949219);\n}} else {\nif(finalDist < 135) \n{\nreturn vec2(0.757813, 0.117188);} else {\nreturn vec2(0.46875, 0.527344);\n}\n}\n}} else {\nif(finalDist < 140) \n{\nif(finalDist < 138) \n{\nif(finalDist < 137) \n{\nreturn vec2(0.703125, 0.703125);} else {\nreturn vec2(0.675781, 0.992188);\n}} else {\nif(finalDist < 139) \n{\nreturn vec2(0.265625, 0.046875);} else {\nreturn vec2(0.40625, 0.550781);\n}\n}} else {\nif(finalDist < 142) \n{\nif(finalDist < 141) \n{\nreturn vec2(0.292969, 0.542969);} else {\nreturn vec2(0.222656, 0.0390625);\n}} else {\nif(finalDist < 143) \n{\nreturn vec2(0.617188, 0.429688);} else {\nreturn vec2(0.34375, 0.359375);\n}\n}\n}\n}} else {\nif(finalDist < 152) \n{\nif(finalDist < 148) \n{\nif(finalDist < 146) \n{\nif(finalDist < 145) \n{\nreturn vec2(0.433594, 0.0195313);} else {\nreturn vec2(0.113281, 0.757813);\n}} else {\nif(finalDist < 147) \n{\nreturn vec2(0.945313, 0.679688);} else {\nreturn vec2(0.414063, 0.078125);\n}\n}} else {\nif(finalDist < 150) \n{\nif(finalDist < 149) \n{\nreturn vec2(0.695313, 0.582031);} else {\nreturn vec2(0.0703125, 0.691406);\n}} else {\nif(finalDist < 151) \n{\nreturn vec2(0.648438, 0.460938);} else {\nreturn vec2(0.015625, 0.125);\n}\n}\n}} else {\nif(finalDist < 156) \n{\nif(finalDist < 154) \n{\nif(finalDist < 153) \n{\nreturn vec2(0.9375, 0.00390625);} else {\nreturn vec2(0.1875, 0.644531);\n}} else {\nif(finalDist < 155) \n{\nreturn vec2(0.824219, 0.285156);} else {\nreturn vec2(0.546875, 0.6875);\n}\n}} else {\nif(finalDist < 158) \n{\nif(finalDist < 157) \n{\nreturn vec2(0.972656, 0.128906);} else {\nreturn vec2(0.53125, 0.9375);\n}} else {\nif(finalDist < 159) \n{\nreturn vec2(0.371094, 0.753906);} else {\nreturn vec2(0.882813, 0.382813);\n}\n}\n}\n}\n}} else {\nif(finalDist < 176) \n{\nif(finalDist < 168) \n{\nif(finalDist < 164) \n{\nif(finalDist < 162) \n{\nif(finalDist < 161) \n{\nreturn vec2(0.21875, 0.457031);} else {\nreturn vec2(0.492188, 0.855469);\n}} else {\nif(finalDist < 163) \n{\nreturn vec2(0.789063, 0.339844);} else {\nreturn vec2(0.152344, 0.1875);\n}\n}} else {\nif(finalDist < 166) \n{\nif(finalDist < 165) \n{\nreturn vec2(0.683594, 0.960938);} else {\nreturn vec2(0.621094, 0.347656);\n}} else {\nif(finalDist < 167) \n{\nreturn vec2(0.644531, 0.839844);} else {\nreturn vec2(0.992188, 0.605469);\n}\n}\n}} else {\nif(finalDist < 172) \n{\nif(finalDist < 170) \n{\nif(finalDist < 169) \n{\nreturn vec2(0.535156, 0.945313);} else {\nreturn vec2(0.15625, 0.394531);\n}} else {\nif(finalDist < 171) \n{\nreturn vec2(0.792969, 0.371094);} else {\nreturn vec2(0.121094, 0.984375);\n}\n}} else {\nif(finalDist < 174) \n{\nif(finalDist < 173) \n{\nreturn vec2(0.605469, 0.496094);} else {\nreturn vec2(0.0273438, 0.191406);\n}} else {\nif(finalDist < 175) \n{\nreturn vec2(0.464844, 0.277344);} else {\nreturn vec2(0.777344, 0.929688);\n}\n}\n}\n}} else {\nif(finalDist < 184) \n{\nif(finalDist < 180) \n{\nif(finalDist < 178) \n{\nif(finalDist < 177) \n{\nreturn vec2(0.964844, 0.0976563);} else {\nreturn vec2(0.515625, 0.34375);\n}} else {\nif(finalDist < 179) \n{\nreturn vec2(0.730469, 0.621094);} else {\nreturn vec2(0.09375, 0.902344);\n}\n}} else {\nif(finalDist < 182) \n{\nif(finalDist < 181) \n{\nreturn vec2(0.988281, 0);} else {\nreturn vec2(0.386719, 0.328125);\n}} else {\nif(finalDist < 183) \n{\nreturn vec2(0.320313, 0.0625);} else {\nreturn vec2(0.132813, 0.660156);\n}\n}\n}} else {\nif(finalDist < 188) \n{\nif(finalDist < 186) \n{\nif(finalDist < 185) \n{\nreturn vec2(0.300781, 0.476563);} else {\nreturn vec2(0.558594, 0.324219);\n}} else {\nif(finalDist < 187) \n{\nreturn vec2(0.554688, 0.5625);} else {\nreturn vec2(0.0507813, 0.101563);\n}\n}} else {\nif(finalDist < 190) \n{\nif(finalDist < 189) \n{\nreturn vec2(0.625, 0.519531);} else {\nreturn vec2(0.636719, 0.816406);\n}} else {\nif(finalDist < 191) \n{\nreturn vec2(0.890625, 0.386719);} else {\nreturn vec2(0.0351563, 0.578125);\n}\n}\n}\n}\n}\n}} else {\nif(finalDist < 224) \n{\nif(finalDist < 208) \n{\nif(finalDist < 200) \n{\nif(finalDist < 196) \n{\nif(finalDist < 194) \n{\nif(finalDist < 193) \n{\nreturn vec2(0.375, 0.964844);} else {\nreturn vec2(0.253906, 0.210938);\n}} else {\nif(finalDist < 195) \n{\nreturn vec2(0.402344, 0.402344);} else {\nreturn vec2(0.726563, 0.792969);\n}\n}} else {\nif(finalDist < 198) \n{\nif(finalDist < 197) \n{\nreturn vec2(0.207031, 0.507813);} else {\nreturn vec2(0.871094, 0.722656);\n}} else {\nif(finalDist < 199) \n{\nreturn vec2(0.503906, 0.867188);} else {\nreturn vec2(0.507813, 0.21875);\n}\n}\n}} else {\nif(finalDist < 204) \n{\nif(finalDist < 202) \n{\nif(finalDist < 201) \n{\nreturn vec2(0.738281, 0.144531);} else {\nreturn vec2(0.902344, 0.847656);\n}} else {\nif(finalDist < 203) \n{\nreturn vec2(0.5, 0.957031);} else {\nreturn vec2(0.238281, 0.253906);\n}\n}} else {\nif(finalDist < 206) \n{\nif(finalDist < 205) \n{\nreturn vec2(0.8125, 0.179688);} else {\nreturn vec2(0.0898438, 0.414063);\n}} else {\nif(finalDist < 207) \n{\nreturn vec2(0.460938, 0.734375);} else {\nreturn vec2(0.488281, 0.0703125);\n}\n}\n}\n}} else {\nif(finalDist < 216) \n{\nif(finalDist < 212) \n{\nif(finalDist < 210) \n{\nif(finalDist < 209) \n{\nreturn vec2(0.707031, 0.828125);} else {\nreturn vec2(0.976563, 0.554688);\n}} else {\nif(finalDist < 211) \n{\nreturn vec2(0.0546875, 0.628906);} else {\nreturn vec2(0.523438, 0.0820313);\n}\n}} else {\nif(finalDist < 214) \n{\nif(finalDist < 213) \n{\nreturn vec2(0.148438, 0.335938);} else {\nreturn vec2(0.589844, 0.363281);\n}} else {\nif(finalDist < 215) \n{\nreturn vec2(0.0742188, 0.746094);} else {\nreturn vec2(0.980469, 0.777344);\n}\n}\n}} else {\nif(finalDist < 220) \n{\nif(finalDist < 218) \n{\nif(finalDist < 217) \n{\nreturn vec2(0.242188, 0.332031);} else {\nreturn vec2(0.125, 0.625);\n}} else {\nif(finalDist < 219) \n{\nreturn vec2(0.949219, 0.207031);} else {\nreturn vec2(0.363281, 0.796875);\n}\n}} else {\nif(finalDist < 222) \n{\nif(finalDist < 221) \n{\nreturn vec2(0.894531, 0.320313);} else {\nreturn vec2(0.410156, 0.96875);\n}} else {\nif(finalDist < 223) \n{\nreturn vec2(0.859375, 0.441406);} else {\nreturn vec2(0.199219, 0.0859375);\n}\n}\n}\n}\n}} else {\nif(finalDist < 240) \n{\nif(finalDist < 232) \n{\nif(finalDist < 228) \n{\nif(finalDist < 226) \n{\nif(finalDist < 225) \n{\nreturn vec2(0.289063, 0.433594);} else {\nreturn vec2(0.84375, 0.0546875);\n}} else {\nif(finalDist < 227) \n{\nreturn vec2(0.429688, 0.941406);} else {\nreturn vec2(0.953125, 0.640625);\n}\n}} else {\nif(finalDist < 230) \n{\nif(finalDist < 229) \n{\nreturn vec2(0.324219, 0.878906);} else {\nreturn vec2(0.875, 0.230469);\n}} else {\nif(finalDist < 231) \n{\nreturn vec2(0.269531, 0.453125);} else {\nreturn vec2(0.445313, 0.917969);\n}\n}\n}} else {\nif(finalDist < 236) \n{\nif(finalDist < 234) \n{\nif(finalDist < 233) \n{\nreturn vec2(0.910156, 0.0742188);} else {\nreturn vec2(0.339844, 0.546875);\n}} else {\nif(finalDist < 235) \n{\nreturn vec2(0.230469, 0.0507813);} else {\nreturn vec2(0.214844, 0.574219);\n}\n}} else {\nif(finalDist < 238) \n{\nif(finalDist < 237) \n{\nreturn vec2(0.804688, 0.710938);} else {\nreturn vec2(0.171875, 0.167969);\n}} else {\nif(finalDist < 239) \n{\nreturn vec2(0.109375, 0.882813);} else {\nreturn vec2(0.550781, 0.742188);\n}\n}\n}\n}} else {\nif(finalDist < 248) \n{\nif(finalDist < 244) \n{\nif(finalDist < 242) \n{\nif(finalDist < 241) \n{\nreturn vec2(0.453125, 0.4375);} else {\nreturn vec2(0.00390625, 0.300781);\n}} else {\nif(finalDist < 243) \n{\nreturn vec2(0.71875, 0.445313);} else {\nreturn vec2(0.308594, 0.0078125);\n}\n}} else {\nif(finalDist < 246) \n{\nif(finalDist < 245) \n{\nreturn vec2(0.570313, 0.921875);} else {\nreturn vec2(0.855469, 0.152344);\n}} else {\nif(finalDist < 247) \n{\nreturn vec2(0.03125, 0.226563);} else {\nreturn vec2(0.5625, 0.289063);\n}\n}\n}} else {\nif(finalDist < 252) \n{\nif(finalDist < 250) \n{\nif(finalDist < 249) \n{\nreturn vec2(0.316406, 0.765625);} else {\nreturn vec2(0.886719, 0.59375);\n}} else {\nif(finalDist < 251) \n{\nreturn vec2(0.710938, 0.617188);} else {\nreturn vec2(0.496094, 0.820313);\n}\n}} else {\nif(finalDist < 254) \n{\nif(finalDist < 253) \n{\nreturn vec2(0.296875, 0.0585938);} else {\nreturn vec2(0.808594, 0.464844);\n}} else {\nif(finalDist < 255) \n{\nreturn vec2(0.800781, 0.398438);} else {\nreturn vec2(0.640625, 0.265625);\n}\n}\n}\n}\n}\n}\n}\n}\nreturn vec2(0.0);\n}\n\nfloat randBlue(vec2 coord)\n{\n    int i = int(mod(coord.x, 16.0));\n    int j = int(mod(coord.y, 16.0));\n    int finalDist = j*16+i;\n\nif(finalDist < 128) \n{\nif(finalDist < 64) \n{\nif(finalDist < 32) \n{\nif(finalDist < 16) \n{\nif(finalDist < 8) \n{\nif(finalDist < 4) \n{\nif(finalDist < 2) \n{\nif(finalDist < 1) \n{\nreturn 0.28125;} else {\nreturn 0.136719;\n}} else {\nif(finalDist < 3) \n{\nreturn 0.433594;} else {\nreturn 0.03125;\n}\n}} else {\nif(finalDist < 6) \n{\nif(finalDist < 5) \n{\nreturn 0.550781;} else {\nreturn 0.15625;\n}} else {\nif(finalDist < 7) \n{\nreturn 0.714844;} else {\nreturn 0.222656;\n}\n}\n}} else {\nif(finalDist < 12) \n{\nif(finalDist < 10) \n{\nif(finalDist < 9) \n{\nreturn 0.835938;} else {\nreturn 0.488281;\n}} else {\nif(finalDist < 11) \n{\nreturn 0.792969;} else {\nreturn 0.390625;\n}\n}} else {\nif(finalDist < 14) \n{\nif(finalDist < 13) \n{\nreturn 0.878906;} else {\nreturn 0.65625;\n}} else {\nif(finalDist < 15) \n{\nreturn 0.117188;} else {\nreturn 0.542969;\n}\n}\n}\n}} else {\nif(finalDist < 24) \n{\nif(finalDist < 20) \n{\nif(finalDist < 18) \n{\nif(finalDist < 17) \n{\nreturn 0.203125;} else {\nreturn 0.511719;\n}} else {\nif(finalDist < 19) \n{\nreturn 0.925781;} else {\nreturn 0.296875;\n}\n}} else {\nif(finalDist < 22) \n{\nif(finalDist < 21) \n{\nreturn 0.746094;} else {\nreturn 0.480469;\n}} else {\nif(finalDist < 23) \n{\nreturn 0.988281;} else {\nreturn 0.382813;\n}\n}\n}} else {\nif(finalDist < 28) \n{\nif(finalDist < 26) \n{\nif(finalDist < 25) \n{\nreturn 0.628906;} else {\nreturn 0.300781;\n}} else {\nif(finalDist < 27) \n{\nreturn 0.984375;} else {\nreturn 0.0898438;\n}\n}} else {\nif(finalDist < 30) \n{\nif(finalDist < 29) \n{\nreturn 0.1875;} else {\nreturn 0.484375;\n}} else {\nif(finalDist < 31) \n{\nreturn 0.960938;} else {\nreturn 0.859375;\n}\n}\n}\n}\n}} else {\nif(finalDist < 48) \n{\nif(finalDist < 40) \n{\nif(finalDist < 36) \n{\nif(finalDist < 34) \n{\nif(finalDist < 33) \n{\nreturn 0.675781;} else {\nreturn 0.753906;\n}} else {\nif(finalDist < 35) \n{\nreturn 0.101563;} else {\nreturn 0.617188;\n}\n}} else {\nif(finalDist < 38) \n{\nif(finalDist < 37) \n{\nreturn 0.882813;} else {\nreturn 0.351563;\n}} else {\nif(finalDist < 39) \n{\nreturn 0.0625;} else {\nreturn 0.578125;\n}\n}\n}} else {\nif(finalDist < 44) \n{\nif(finalDist < 42) \n{\nif(finalDist < 41) \n{\nreturn 0.875;} else {\nreturn 0.152344;\n}} else {\nif(finalDist < 43) \n{\nreturn 0.722656;} else {\nreturn 0.472656;\n}\n}} else {\nif(finalDist < 46) \n{\nif(finalDist < 45) \n{\nreturn 0.6875;} else {\nreturn 0.289063;\n}} else {\nif(finalDist < 47) \n{\nreturn 0.0078125;} else {\nreturn 0.445313;\n}\n}\n}\n}} else {\nif(finalDist < 56) \n{\nif(finalDist < 52) \n{\nif(finalDist < 50) \n{\nif(finalDist < 49) \n{\nreturn 0.332031;} else {\nreturn 0.839844;\n}} else {\nif(finalDist < 51) \n{\nreturn 0.527344;} else {\nreturn 0.40625;\n}\n}} else {\nif(finalDist < 54) \n{\nif(finalDist < 53) \n{\nreturn 0.121094;} else {\nreturn 0.699219;\n}} else {\nif(finalDist < 55) \n{\nreturn 0.21875;} else {\nreturn 0.765625;\n}\n}\n}} else {\nif(finalDist < 60) \n{\nif(finalDist < 58) \n{\nif(finalDist < 57) \n{\nreturn 0.0195313;} else {\nreturn 0.234375;\n}} else {\nif(finalDist < 59) \n{\nreturn 0.585938;} else {\nreturn 0.261719;\n}\n}} else {\nif(finalDist < 62) \n{\nif(finalDist < 61) \n{\nreturn 0.921875;} else {\nreturn 0.8125;\n}} else {\nif(finalDist < 63) \n{\nreturn 0.539063;} else {\nreturn 0.132813;\n}\n}\n}\n}\n}\n}} else {\nif(finalDist < 96) \n{\nif(finalDist < 80) \n{\nif(finalDist < 72) \n{\nif(finalDist < 68) \n{\nif(finalDist < 66) \n{\nif(finalDist < 65) \n{\nreturn 0.96875;} else {\nreturn 0.0390625;\n}} else {\nif(finalDist < 67) \n{\nreturn 0.207031;} else {\nreturn 0.941406;\n}\n}} else {\nif(finalDist < 70) \n{\nif(finalDist < 69) \n{\nreturn 0.285156;} else {\nreturn 0.828125;\n}} else {\nif(finalDist < 71) \n{\nreturn 0.652344;} else {\nreturn 0.359375;\n}\n}\n}} else {\nif(finalDist < 76) \n{\nif(finalDist < 74) \n{\nif(finalDist < 73) \n{\nreturn 0.523438;} else {\nreturn 0.9375;\n}} else {\nif(finalDist < 75) \n{\nreturn 0.785156;} else {\nreturn 0.386719;\n}\n}} else {\nif(finalDist < 78) \n{\nif(finalDist < 77) \n{\nreturn 0.0351563;} else {\nreturn 0.726563;\n}} else {\nif(finalDist < 79) \n{\nreturn 0.378906;} else {\nreturn 0.644531;\n}\n}\n}\n}} else {\nif(finalDist < 88) \n{\nif(finalDist < 84) \n{\nif(finalDist < 82) \n{\nif(finalDist < 81) \n{\nreturn 0.402344;} else {\nreturn 0.71875;\n}} else {\nif(finalDist < 83) \n{\nreturn 0.601563;} else {\nreturn 0.742188;\n}\n}} else {\nif(finalDist < 86) \n{\nif(finalDist < 85) \n{\nreturn 0.441406;} else {\nreturn 0.046875;\n}} else {\nif(finalDist < 87) \n{\nreturn 0.46875;} else {\nreturn 0.160156;\n}\n}\n}} else {\nif(finalDist < 92) \n{\nif(finalDist < 90) \n{\nif(finalDist < 89) \n{\nreturn 0.824219;} else {\nreturn 0.292969;\n}} else {\nif(finalDist < 91) \n{\nreturn 0.492188;} else {\nreturn 0.125;\n}\n}} else {\nif(finalDist < 94) \n{\nif(finalDist < 93) \n{\nreturn 0.613281;} else {\nreturn 0.183594;\n}} else {\nif(finalDist < 95) \n{\nreturn 0.910156;} else {\nreturn 0.25;\n}\n}\n}\n}\n}} else {\nif(finalDist < 112) \n{\nif(finalDist < 104) \n{\nif(finalDist < 100) \n{\nif(finalDist < 98) \n{\nif(finalDist < 97) \n{\nreturn 0.078125;} else {\nreturn 0.871094;\n}} else {\nif(finalDist < 99) \n{\nreturn 0.257813;} else {\nreturn 0.535156;\n}\n}} else {\nif(finalDist < 102) \n{\nif(finalDist < 101) \n{\nreturn 0.105469;} else {\nreturn 0.972656;\n}} else {\nif(finalDist < 103) \n{\nreturn 0.582031;} else {\nreturn 0.914063;\n}\n}\n}} else {\nif(finalDist < 108) \n{\nif(finalDist < 106) \n{\nif(finalDist < 105) \n{\nreturn 0.671875;} else {\nreturn 0.0664063;\n}} else {\nif(finalDist < 107) \n{\nreturn 0.730469;} else {\nreturn 0.976563;\n}\n}} else {\nif(finalDist < 110) \n{\nif(finalDist < 109) \n{\nreturn 0.308594;} else {\nreturn 0.851563;\n}} else {\nif(finalDist < 111) \n{\nreturn 0.453125;} else {\nreturn 0.554688;\n}\n}\n}\n}} else {\nif(finalDist < 120) \n{\nif(finalDist < 116) \n{\nif(finalDist < 114) \n{\nif(finalDist < 113) \n{\nreturn 0.789063;} else {\nreturn 0.347656;\n}} else {\nif(finalDist < 115) \n{\nreturn 0.113281;} else {\nreturn 0.886719;\n}\n}} else {\nif(finalDist < 118) \n{\nif(finalDist < 117) \n{\nreturn 0.398438;} else {\nreturn 0.691406;\n}} else {\nif(finalDist < 119) \n{\nreturn 0.34375;} else {\nreturn 0.230469;\n}\n}\n}} else {\nif(finalDist < 124) \n{\nif(finalDist < 122) \n{\nif(finalDist < 121) \n{\nreturn 0.425781;} else {\nreturn 0.175781;\n}} else {\nif(finalDist < 123) \n{\nreturn 0.625;} else {\nreturn 0.410156;\n}\n}} else {\nif(finalDist < 126) \n{\nif(finalDist < 125) \n{\nreturn 0.558594;} else {\nreturn 0.0742188;\n}} else {\nif(finalDist < 127) \n{\nreturn 0.710938;} else {\nreturn 0.140625;\n}\n}\n}\n}\n}\n}\n}} else {\nif(finalDist < 192) \n{\nif(finalDist < 160) \n{\nif(finalDist < 144) \n{\nif(finalDist < 136) \n{\nif(finalDist < 132) \n{\nif(finalDist < 130) \n{\nif(finalDist < 129) \n{\nreturn 0.621094;} else {\nreturn 0.457031;\n}} else {\nif(finalDist < 131) \n{\nreturn 0.667969;} else {\nreturn 0.3125;\n}\n}} else {\nif(finalDist < 134) \n{\nif(finalDist < 133) \n{\nreturn 0.78125;} else {\nreturn 0.167969;\n}} else {\nif(finalDist < 135) \n{\nreturn 0.847656;} else {\nreturn 0.0117188;\n}\n}\n}} else {\nif(finalDist < 140) \n{\nif(finalDist < 138) \n{\nif(finalDist < 137) \n{\nreturn 0.769531;} else {\nreturn 0.570313;\n}} else {\nif(finalDist < 139) \n{\nreturn 0.890625;} else {\nreturn 0.00390625;\n}\n}} else {\nif(finalDist < 142) \n{\nif(finalDist < 141) \n{\nreturn 0.808594;} else {\nreturn 0.199219;\n}} else {\nif(finalDist < 143) \n{\nreturn 0.507813;} else {\nreturn 0.992188;\n}\n}\n}\n}} else {\nif(finalDist < 152) \n{\nif(finalDist < 148) \n{\nif(finalDist < 146) \n{\nif(finalDist < 145) \n{\nreturn 0.546875;} else {\nreturn 0.179688;\n}} else {\nif(finalDist < 147) \n{\nreturn 0.902344;} else {\nreturn 0.0507813;\n}\n}} else {\nif(finalDist < 150) \n{\nif(finalDist < 149) \n{\nreturn 0.53125;} else {\nreturn 0.269531;\n}} else {\nif(finalDist < 151) \n{\nreturn 0.589844;} else {\nreturn 0.949219;\n}\n}\n}} else {\nif(finalDist < 156) \n{\nif(finalDist < 154) \n{\nif(finalDist < 153) \n{\nreturn 0.496094;} else {\nreturn 0.273438;\n}} else {\nif(finalDist < 155) \n{\nreturn 0.144531;} else {\nreturn 0.339844;\n}\n}} else {\nif(finalDist < 158) \n{\nif(finalDist < 157) \n{\nreturn 0.679688;} else {\nreturn 0.375;\n}} else {\nif(finalDist < 159) \n{\nreturn 0.863281;} else {\nreturn 0.226563;\n}\n}\n}\n}\n}} else {\nif(finalDist < 176) \n{\nif(finalDist < 168) \n{\nif(finalDist < 164) \n{\nif(finalDist < 162) \n{\nif(finalDist < 161) \n{\nreturn 0.683594;} else {\nreturn 0.355469;\n}} else {\nif(finalDist < 163) \n{\nreturn 0.734375;} else {\nreturn 0.429688;\n}\n}} else {\nif(finalDist < 166) \n{\nif(finalDist < 165) \n{\nreturn 0.996094;} else {\nreturn 0.109375;\n}} else {\nif(finalDist < 167) \n{\nreturn 0.738281;} else {\nreturn 0.324219;\n}\n}\n}} else {\nif(finalDist < 172) \n{\nif(finalDist < 170) \n{\nif(finalDist < 169) \n{\nreturn 0.09375;} else {\nreturn 0.800781;\n}} else {\nif(finalDist < 171) \n{\nreturn 0.957031;} else {\nreturn 0.476563;\n}\n}} else {\nif(finalDist < 174) \n{\nif(finalDist < 173) \n{\nreturn 0.246094;} else {\nreturn 0.945313;\n}} else {\nif(finalDist < 175) \n{\nreturn 0.4375;} else {\nreturn 0.0546875;\n}\n}\n}\n}} else {\nif(finalDist < 184) \n{\nif(finalDist < 180) \n{\nif(finalDist < 178) \n{\nif(finalDist < 177) \n{\nreturn 0.929688;} else {\nreturn 0.015625;\n}} else {\nif(finalDist < 179) \n{\nreturn 0.242188;} else {\nreturn 0.820313;\n}\n}} else {\nif(finalDist < 182) \n{\nif(finalDist < 181) \n{\nreturn 0.597656;} else {\nreturn 0.195313;\n}} else {\nif(finalDist < 183) \n{\nreturn 0.640625;} else {\nreturn 0.414063;\n}\n}\n}} else {\nif(finalDist < 188) \n{\nif(finalDist < 186) \n{\nif(finalDist < 185) \n{\nreturn 0.707031;} else {\nreturn 0.371094;\n}} else {\nif(finalDist < 187) \n{\nreturn 0.609375;} else {\nreturn 0.757813;\n}\n}} else {\nif(finalDist < 190) \n{\nif(finalDist < 189) \n{\nreturn 0.0585938;} else {\nreturn 0.632813;\n}} else {\nif(finalDist < 191) \n{\nreturn 0.316406;} else {\nreturn 0.75;\n}\n}\n}\n}\n}\n}} else {\nif(finalDist < 224) \n{\nif(finalDist < 208) \n{\nif(finalDist < 200) \n{\nif(finalDist < 196) \n{\nif(finalDist < 194) \n{\nif(finalDist < 193) \n{\nreturn 0.164063;} else {\nreturn 0.464844;\n}} else {\nif(finalDist < 195) \n{\nreturn 0.660156;} else {\nreturn 0.894531;\n}\n}} else {\nif(finalDist < 198) \n{\nif(finalDist < 197) \n{\nreturn 0.320313;} else {\nreturn 0.460938;\n}} else {\nif(finalDist < 199) \n{\nreturn 0.917969;} else {\nreturn 0.855469;\n}\n}\n}} else {\nif(finalDist < 204) \n{\nif(finalDist < 202) \n{\nif(finalDist < 201) \n{\nreturn 0.214844;} else {\nreturn 0.0;\n}} else {\nif(finalDist < 203) \n{\nreturn 0.171875;} else {\nreturn 0.515625;\n}\n}} else {\nif(finalDist < 206) \n{\nif(finalDist < 205) \n{\nreturn 0.898438;} else {\nreturn 0.191406;\n}} else {\nif(finalDist < 207) \n{\nreturn 0.796875;} else {\nreturn 0.519531;\n}\n}\n}\n}} else {\nif(finalDist < 216) \n{\nif(finalDist < 212) \n{\nif(finalDist < 210) \n{\nif(finalDist < 209) \n{\nreturn 0.867188;} else {\nreturn 0.367188;\n}} else {\nif(finalDist < 211) \n{\nreturn 0.566406;} else {\nreturn 0.0703125;\n}\n}} else {\nif(finalDist < 214) \n{\nif(finalDist < 213) \n{\nreturn 0.128906;} else {\nreturn 0.777344;\n}} else {\nif(finalDist < 215) \n{\nreturn 0.0273438;} else {\nreturn 0.265625;\n}\n}\n}} else {\nif(finalDist < 220) \n{\nif(finalDist < 218) \n{\nif(finalDist < 217) \n{\nreturn 0.5;} else {\nreturn 0.773438;\n}} else {\nif(finalDist < 219) \n{\nreturn 0.90625;} else {\nreturn 0.304688;\n}\n}} else {\nif(finalDist < 222) \n{\nif(finalDist < 221) \n{\nreturn 0.0976563;} else {\nreturn 0.421875;\n}} else {\nif(finalDist < 223) \n{\nreturn 0.5625;} else {\nreturn 0.253906;\n}\n}\n}\n}\n}} else {\nif(finalDist < 240) \n{\nif(finalDist < 232) \n{\nif(finalDist < 228) \n{\nif(finalDist < 226) \n{\nif(finalDist < 225) \n{\nreturn 0.0820313;} else {\nreturn 0.980469;\n}} else {\nif(finalDist < 227) \n{\nreturn 0.277344;} else {\nreturn 0.703125;\n}\n}} else {\nif(finalDist < 230) \n{\nif(finalDist < 229) \n{\nreturn 0.503906;} else {\nreturn 0.328125;\n}} else {\nif(finalDist < 231) \n{\nreturn 0.636719;} else {\nreturn 0.574219;\n}\n}\n}} else {\nif(finalDist < 236) \n{\nif(finalDist < 234) \n{\nif(finalDist < 233) \n{\nreturn 0.953125;} else {\nreturn 0.363281;\n}} else {\nif(finalDist < 235) \n{\nreturn 0.449219;} else {\nreturn 0.664063;\n}\n}} else {\nif(finalDist < 238) \n{\nif(finalDist < 237) \n{\nreturn 0.816406;} else {\nreturn 0.964844;\n}} else {\nif(finalDist < 239) \n{\nreturn 0.0234375;} else {\nreturn 0.648438;\n}\n}\n}\n}} else {\nif(finalDist < 248) \n{\nif(finalDist < 244) \n{\nif(finalDist < 242) \n{\nif(finalDist < 241) \n{\nreturn 0.804688;} else {\nreturn 0.605469;\n}} else {\nif(finalDist < 243) \n{\nreturn 0.84375;} else {\nreturn 0.210938;\n}\n}} else {\nif(finalDist < 246) \n{\nif(finalDist < 245) \n{\nreturn 0.832031;} else {\nreturn 0.933594;\n}} else {\nif(finalDist < 247) \n{\nreturn 0.417969;} else {\nreturn 0.0859375;\n}\n}\n}} else {\nif(finalDist < 252) \n{\nif(finalDist < 250) \n{\nif(finalDist < 249) \n{\nreturn 0.695313;} else {\nreturn 0.148438;\n}} else {\nif(finalDist < 251) \n{\nreturn 0.0429688;} else {\nreturn 0.59375;\n}\n}} else {\nif(finalDist < 254) \n{\nif(finalDist < 253) \n{\nreturn 0.238281;} else {\nreturn 0.335938;\n}} else {\nif(finalDist < 255) \n{\nreturn 0.761719;} else {\nreturn 0.394531;\n}\n}\n}\n}\n}\n}\n}\n}    \n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvMod = fragCoord.xy / iResolution.xy;\n    uvMod -= 0.5;\n    uvMod.y *= iResolution.y / iResolution.x;\n    uvMod.y += 0.05;\n\tvec2 fragCoordRescale = fragCoord.xy * 0.25 - fract(fragCoord.xy * 0.25);\n    vec2 fragCoordMod = mod(fragCoordRescale.xy, 16.0);\n    \n    float angle = 0.0;\n    float r = 0.0;\n    float time = fract(iTime/16.0)*16.0;\n    float NUM_SAMP = 8.0;\n    if ( iMouse.z > 0.0 )NUM_SAMP = 9.0-ceil(iMouse.y / iResolution.y * 8.0);\n    if ( iMouse.z > 0.0 ) time = iMouse.x / iResolution.x * 16.0;\n    \n    if (time > 2.0)\n    {\n        angle = Noise(fragCoordRescale.xy, 0.0);\n        r = rand(angle);\n    }\n    if (time > 4.0)\n    {\n        angle = randBlue(fragCoordMod.xy);\n        r = rand(angle);\n    }\n    if (time > 6.0)\n    {\n        vec2 b2 = randBlue2(fragCoordMod.xy);\n        angle = b2.x;\n        r = b2.y;\n    }\n    if (time > 8.0)\n    {    \n        angle = Step2(fragCoordMod.xy,0.0)+0.5;\n        r = Step2(fragCoordMod.xy,0.11)+0.5;\n    }\n\tif (time > 10.0)\n    {\n        angle = B16(fragCoordMod.xy)/ 256.0; \n        r = rand(angle);\n    }\n    if (time > 12.0)\n    {\n        angle = interleavedGradientNoise(fragCoordRescale.xy);\n        r = rand(angle);\n    }\n    if (time > 14.0)\n    {\n        vec2 noise_uv = (fragCoordRescale.xy + vec2(0.5)) / iChannelResolution[0].xy;\n        vec2 noise_sample = texture(iChannel0, noise_uv).xy;\n        angle = noise_sample.x;\n        r = noise_sample.y;\n    }\n    \n    float s = sin(angle * 2.0 * 3.1415926);\n    float c = cos(angle * 2.0 * 3.1415926);\n    \n    vec4 col = vec4(0);\n    vec2 animVec = uvMod + vec2(0.25*sin(0.5*iTime),0);\n    col+=sampleDist(animVec + vec2(s,c) * sqrt(r) * 0.1) ? vec4(1.0) : vec4(0.0);\n    if (NUM_SAMP > 1.0)\n    \tcol+=sampleDist(animVec - vec2(s,c) * sqrt(r) * 0.1) ? vec4(1.0) : vec4(0.0);\n    if (NUM_SAMP > 2.0)\n    \tcol+=sampleDist(animVec + vec2(c,s) * sqrt(r) * 0.1) ? vec4(1.0) : vec4(0.0);\n    if (NUM_SAMP > 3.0)\n    \tcol+=sampleDist(animVec - vec2(c,s) * sqrt(r) * 0.1) ? vec4(1.0) : vec4(0.0);\n    if (NUM_SAMP > 4.0)\n    col+=sampleDist(animVec + vec2(s,c) * sqrt(0.5*r) * 0.1) ? vec4(1.0) : vec4(0.0);\n    if (NUM_SAMP > 5.0)\n    col+=sampleDist(animVec - vec2(s,c) * sqrt(0.5*r) * 0.1) ? vec4(1.0) : vec4(0.0);\n    if (NUM_SAMP > 6.0)\n    col+=sampleDist(animVec + vec2(c,s) * sqrt(0.5*r) * 0.1) ? vec4(1.0) : vec4(0.0);\n    if (NUM_SAMP > 7.0)\n    col+=sampleDist(animVec - vec2(c,s) * sqrt(0.5*r) * 0.1) ? vec4(1.0) : vec4(0.0);\n\n    col *= 1.0/NUM_SAMP;\n    \n    col += sampleDistComp(uvMod, 0.0) ? vec4(1.0,0.0,0.0,0.0) : vec4(0.0);\n    col += sampleDistComp(uvMod, 0.1) ? vec4(0.0,1.0,0.0,0.0) : vec4(0.0);\n    \n    if (fragCoord.y / iResolution.y > 0.8)\n    {\n        col = vec4(angle, r, 0, 0);\n    }\n\n    fragColor = col;\n}\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtV3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtV3Wh", "name": "RainbowTest", "author": "KDahdah", "description": "a rainbow wiping across a texture", "tags": ["rainbowalphafadewhipe"], "likes": 4, "viewed": 158, "date": "1474484252", "time_retrieved": "2024-06-20T18:41:59.735696", "image_code": "vec3 hsv2rgb_smooth(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z*mix(vec3(1.0),rgb,c.y);\n}\n\nfloat PI = 3.1415926;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float alpha = uv.x;\n    alpha = mod(alpha + iTime, 6.0);\n    \n    if (alpha > 2.0)\n    {\n        alpha = (4.0-alpha);\n    }\n    \n    float y = 0.1 * sin(uv.x*PI + iTime*PI ) + uv.y - 0.5;\n    \n    vec3 hsvColor = hsv2rgb_smooth(vec3(y, 1.0, 1.0));\n    vec4 FragOverColor = vec4(hsvColor * max(min(alpha, 1.0), 0.0), 0.0);\n    \n    fragColor = texture(iChannel0, uv);\n\tfragColor +=FragOverColor;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtV3Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVGRD", "name": "my name is whirl", "author": "seani", "description": "whooooa man", "tags": ["procedural", "2d", "trippy"], "likes": 7, "viewed": 665, "date": "1473655579", "time_retrieved": "2024-06-20T18:42:00.014774", "image_code": "//By Sean Irby-2015\n//sean.t.irby@gmail.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //normalize x and y to [-1, 1]\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    //rotate the coordinate according to its distance from origin and time\n    float dist = distance(r, vec2(0, 0));\n\tfloat angle = dist*(iTime/3.0)*sin(iTime/3.0)/(3.0 + 3.0*sin(iTime));\n    mat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n    r = r*rotationMatrix;\n    \n    //mirror coordinates/scale them up\n    float scale = 11.0 + 10.0*cos(iTime/5.0);\n    vec2 rScaled = vec2(abs(r.x)*scale, abs(r.y)*scale);\n  \t\n    //truncate to grid, mess with coordinates\n    vec2 rGrid = vec2(mod(rScaled.x - iTime/2.0, 1.0), mod(rScaled.y, 1.0));\n    vec3 col1 = vec3(0.216, 0.471*(1.0-dist)*(1.0 + sin(iTime/2.5)), 0.698);\n\tvec3 col2 = vec3(1.00, 0.329, 0.6*(1.0-dist));\n             \n    //draw diagonal lines in each grid at the defined thickness\n    float thickness = 1.1*dist + dist*sin(iTime/3.0);\n    float line = smoothstep(rGrid.x - thickness, rGrid.x, 1.0 - rGrid.y);\n    line = min(line, 1.0-smoothstep(rGrid.x, rGrid.x + thickness, 1.0 - rGrid.y));\n    \n    //erase past a certain distance\n    if(rScaled.y > ((50.0 + 11.0*sin(iTime*3.0)) - rScaled.x)){\n        line = 0.0;\n    }\n    \n    //blend colors\n    vec3 ret = mix(col1, col2, mix(line, 1.0-line, 1.5 + 0.5*cos(iTime/3.0)));\n\n    fragColor = vec4(ret, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVGRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVGWW", "name": "Tentacular Julia", "author": "stduhpf", "description": "I wondered wow would looks like orbit traps with gradient noise.\nI disabled antialiasing because of the low fps.", "tags": ["fractal", "noise"], "likes": 3, "viewed": 139, "date": "1474734657", "time_retrieved": "2024-06-20T18:42:00.014774", "image_code": "#define ss 1 //anti aliasing\n#define iterations 128\n\nfloat startRandom ;\nvec2 rand(vec2 co, float t)\n{\nfloat s = t+startRandom;\n    return fract(s+vec2(sin(s+dot(co,vec2(75542.8974,99846.16956))),sin(2.*s+dot(co,vec2(75589.1688,9846.16956))))*4849456.48456)-.5;\n}\n\nvec2 perlin(vec2 c, float t)\n{\nvec2 i= floor(c);\nfloat dt = fract(t);\n t =floor(t);\nvec2 f = fract(c);\nvec2 m1 = vec2(dot(f,rand(i,t)),dot(f,rand(i,t+100.5)));\nvec2 m2 = vec2(dot(f-vec2(1,0),rand(i+vec2(1,0),t)),dot(f-vec2(1,0),rand(i+vec2(1,0),t+100.5)));\nvec2 m3 = vec2(dot(f-vec2(0,1),rand(i+vec2(0,1),t)),dot(f-vec2(0,1),rand(i+vec2(0,1),t+100.5)));\nvec2 m4 = vec2(dot(f-1.,rand(i+1.,t)),dot(f-1.,rand(i+1.,t+100.5)));\n    \n    t+=1.;\n\nvec2 tm1 = vec2(dot(f,rand(i,t)),dot(f,rand(i,t+100.5)));\nvec2 tm2 = vec2(dot(f-vec2(1,0),rand(i+vec2(1,0),t)),dot(f-vec2(1,0),rand(i+vec2(1,0),t+100.5)));\nvec2 tm3 = vec2(dot(f-vec2(0,1),rand(i+vec2(0,1),t)),dot(f-vec2(0,1),rand(i+vec2(0,1),t+100.5)));\nvec2 tm4 = vec2(dot(f-1.,rand(i+1.,t)),dot(f-1.,rand(i+1.,t+100.5)));\n    \n    \n\nreturn mix(mix(mix(m1,m2,smoothstep(0.,1.,f.x)),mix(m3,m4,smoothstep(0.,1.,f.x)),smoothstep(0.,1.,f.y)),\n           mix(mix(tm1,tm2,smoothstep(0.,1.,f.x)),mix(tm3,tm4,smoothstep(0.,1.,f.x)),smoothstep(0.,1.,f.y)),smoothstep(0.,1.,dt));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    startRandom = fract(sin(floor(iDate.w-iTime)*9756962.215)*15465.486);\n      vec2 p = iMouse.xy / iResolution.y-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5);\n    if(iMouse.xy==vec2(0))\n        p=vec2(-.75,.05);\n    vec3 fcol=vec3(0);\n    for(int i =0;i<ss*ss;i++)\n    {\n    vec2 uv = (fragCoord.xy+(vec2(mod(float(i),float(ss)),floor(float(i)/float(ss)))+.5)/float(ss))\n        / iResolution.y-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5);\n            float dmin=1000.;\n        vec2 c=p;\n        vec2 z=uv*2.6;\n    for(int i =0;i<iterations;i++)\n    {\n        z=z*mat2(z.x,-z.y,z.yx)+c;\n        vec2 z1 = z+perlin(z+iTime,.1*iTime+float(i));\n\t\tdmin=min(dmin, min(abs(z1.y),abs(z1.x)));\n    }    \n        dmin=1.+log(dmin)/6.;\n        vec3 col=mix(vec3(.2,.25,.4),vec3(1,.7,.5),dmin);\n        fcol+=col/float(ss*ss);\n    }\n\tfragColor = vec4(fcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVGWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtVGWz", "name": "Texture Filtering: Catmull-Rom", "author": "hornet", "description": "Catmull Rom on the left, bilinear on the right.\n9 samples instead of 16 using tex-filtering.\nEntirely stolen from: https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\nFor more details, See http://vec3.ca/bicubic-filtering-in-fewer-taps/", "tags": ["texture", "sampling", "catmullrom", "catmull", "rom"], "likes": 21, "viewed": 3112, "date": "1474274418", "time_retrieved": "2024-06-20T18:42:00.535853", "image_code": "//note: see also http://www.decarpentier.nl/2d-catmull-rom-in-4-samples.\n\nvec4 sampleLevel0( vec2 uv )\n{\n    return texture( iChannel0, uv, -10.0 );\n}\n\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 SampleTextureCatmullRom( vec2 uv, vec2 texSize )\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += sampleLevel0( vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += sampleLevel0( vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += sampleLevel0( vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 sample_uv = uv;\n    sample_uv.x = mod( sample_uv.x, 0.5 );\n   \tsample_uv += 0.01 * vec2( cos(iTime), sin(iTime) );\n    sample_uv *= (iMouse.z>0.0)? iMouse.x * 0.001 : 0.06125;\n    \n    vec4 smpl;\n    if ( uv.x < 0.5 )\n    \tsmpl = SampleTextureCatmullRom( sample_uv, iChannelResolution[0].xy );\n    else\n        smpl = sampleLevel0( sample_uv );\n\n    fragColor = smpl;\n    fragColor -= step(abs(uv.x-0.5), 0.001);\n    fragColor.rgb += (hash32n(uv+fract(iTime))+hash32n(uv+0.1337*fract(iTime))-1.0)/255.0; //dither output\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtVGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mty3Dw", "name": "Alien Surface", "author": "vox", "description": "Alien Surface", "tags": ["aliensurface"], "likes": 1, "viewed": 433, "date": "1474915330", "time_retrieved": "2024-06-20T18:42:01.669325", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define circle(x) (vec2(cos(x),sin(x)))\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    \n    return (res);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nfloat magnification;\nvec2 tree(vec2 uv)\n{\n    float w1 = saw(time);\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = scale(square, vec2(2.0));\n    square = translate(square, vec2(-1.0));\n    float t1 = time;\n    \n    //square = scale(square, (1.0-saw(uv.xy))*vec2(saw(t1)+.5));\n    square = RotateZ(square, time);\n    \n    square = scale(square, .5+.25*vec2(simplex3d(vec3(uv.x, uv.y, time))));\n    \n    square = scale(square, vec2(.5));\n    square = translate(square, vec2(.5));\n    \n    \n    float t = time;\n    vec3 f = flux(time);\n    \n    \n    vec2 dxdy = sqrt(4.0)/iResolution.xy;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(1.0, \t0.0);\n    vec2 c = uv+vec2(0.0, \t\t1.0);\n    \n    vec2 a2 = invBilinear(a, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 b2 = invBilinear(b, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 c2 = invBilinear(c, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    \n    magnification = abs(cross2(square[1].xy-square[0].xy, square[3].xy-square[0].xy)/cross2(b2-a2, c2-a2));\n    \n    return saw(a2);\n}\n\nfloat draw(vec2 uv)\n{\n    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i =4;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float zoom = 2.5+1.0*sin(time);\n    \n    uv = uv*2.0-1.0;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = float(i)/float(max_i);\n        vec2 next = tree((uv));\n        ifs /= clamp(magnification+1.0, 0.0, 2.0);\n    \tfloat weight = pow(ifs, 1.0/float(i+1));\n        depth += weight;\n        uv = next;//+circle(weight);//+uv*(1.0-weight);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    float weight = pow(ifs, 1.0/float(max_i));\n\n    float black = smoothstep(0.0, 1.0/5.0, saw(depth-time));\n    float white = smoothstep(4.0/5.0, 1.0, saw(depth-time));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*weight;\n    fragColor = vec4(clamp(weight, 0.0, 1.0)*(flux(time+depth)*black+white), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mty3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mty3Rz", "name": "Mezmerize", "author": "gkathale", "description": "Mezmerize", "tags": ["mezmerize"], "likes": 0, "viewed": 875, "date": "1472710939", "time_retrieved": "2024-06-20T18:42:01.669325", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2 (fragCoord.xy - 0.5*iResolution.xy);\n    uv.xy = 2.0 * uv.xy/iResolution.y;\n       \n    vec4 black =  vec4 (0.0,0.0,0.0,1.0);\n    vec4 aColor =  vec4 (0.6,0.8,0.1,1.0);\n    vec4 bColor =  vec4 (0.8,0.4,0.1,1.0);\n    vec4 cColor = vec4(0.216, 0.471, 0.698,1.0);\n    \n    float rad = 0.8;\n    \n    fragColor = black;\n    \n    vec2 center1 = vec2 ((0.1*cos(float(iFrame)/50.0)) ,(0.1*sin(float(iFrame)/50.0)));\n    \n    vec2 d = uv - center1;\n    \n    if (length(d) < 0.8) fragColor = aColor;\n    \n    \n    vec2 center2 = vec2 ((0.1*sin(float(iFrame)/60.0)) ,(0.1*cos(float(iFrame)/50.0)));\n    \n    d = uv - center2;\n    \n    if (length(d) < 0.3)\n        fragColor = bColor;\n    \n    vec2 center3 = vec2 (0.8*sin(float(iFrame)/20.0)*2.0 ,cos(float(iFrame)/100.0)*0.8 + 0.2*(sin(float(iFrame)/8.0)));\n    \n    d = uv - center3;\n    \n    if (length(d) < 0.6) fragColor = cColor;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mty3Rz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mty3z1", "name": "tiling checkerboard compilation", "author": "ollj", "description": "Compilation of different approahes to checkerboard patterns (and simple 2d transforms for it)\n\nsimple easily forgoten pattern.\n", "tags": ["checkerboard"], "likes": 10, "viewed": 853, "date": "1473114543", "time_retrieved": "2024-06-20T18:42:02.239649", "image_code": "//uncomment for monochrome, to see if [s] is in range: [0 .. 1]:\n//#define monochrome\n\n/*\nConclusion: there are 4 non-branching checkerboad-functions, connonly useon shadertoy.com:\ntop    left ; checkerBool (), uses float(a>c==b>c), is possibly the best         , fastest\nbottom left ; checkerFloor(), uses   mod(floor() ), is second most commonly used , fast\ntop    right; checkerSign (), uses  sign(mod()   ), is        most commonly used , slower\nbottom right; checkerSin  (), uses  sign(sin()   ), and sign() is pretty optional, trigonoical\n\nall can be inverted by adding 1sub.\nall compare beter in monochrome. are color corrected by a=a*2.-1.;\n\ncheckerFloor() is the most used, most obvious, and leatst flexible.\n\ncheckerBool() is possibly the fastest and most flexible.\ncheckerSign() is slower, 1mult more than checkerFloor()\ncheckerSign() and checkerBool() allow for other checker-scaling-ratios by modifying the -.5 constant(s).\n\ncheckerSin() approximates a checkrboard with a factor of 2 sines, which may perform faster on mobile hardware.\n*/\n\n//mod(x,1) == fract(x)\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \n#define hfrac vec2 h){h=fract(h)\n#define gthv greaterThan(h,vec2\n#define floatbool2 );return float(b.x==b.y);}\nfloat checkerBool (hfrac;return float(h.x>.5==h.y>.5);}\n//checkerBool2() might be faster than checkerBool() //xy are independent\nfloat checkerBool2(hfrac;bvec2 b=gthv(.5                     )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n//how to transform this to a non-boolean solution with smooth borders?\n//multiply with a smoothstep?\n                   \n//bool patterns are fun for 3d texturing btw.\n                   \n//by https://www.shadertoy.com/view/4tV3Rh\n//by https://www.shadertoy.com/view/4ssGWX\n//slightly slower. +1 good feature:\nfloat checkerSign(vec2 v){\n //v=sign(mod(v,2.)-.5                    );//unmodified scaling ratio.\n   v=sign(mod(v,2.)-.5+cos(iTime)*.4);\n   return    v.x*v.y;}//non-invert\n //return 1.-v.x*v.y;}//    invert\n\n//mult sub sign  mod, are functions of above:\n//     add floor mod, are functions of below:\n\n//by https://www.shadertoy.com/view/4lyGRh\n//by https://www.shadertoy.com/view/Xss3Dr\n//by https://www.shadertoy.com/view/XdXXWn\n//by https://www.shadertoy.com/view/ldBXz3\n//faster more famous checkerboard:\nfloat checkerFloor(vec2 v){\n   v=   floor(v); //non-invert\n //v=.5-floor(v); //    invert\n return mod(v.x+v.y,2.);}\n\n//by https://www.shadertoy.com/view/XldGD7\n//using sines to approximate a checkerboard pattern\nfloat checkerSin(vec2 v){return sign(cos(v.x)*sin(v.y));}\n//if (you know these values anyways) this is only 2mult\n//performs worst on runtime but has its advantage in being smaller code\n//and perform fastest \n//IF you already precalculated the same trigonometry for other purposes.\n\n//other (branching) checkerboard solutions that do other things worhwhile:\n//in-tile-rotation https://www.shadertoy.com/view/MdK3Wd\n//blur 2 gradients https://www.shadertoy.com/view/Mtd3WB\n//antiaaliasing    https://www.shadertoy.com/view/MdSXzy\n//movement         https://www.shadertoy.com/view/Msl3RX\n//spirals          https://www.shadertoy.com/view/MsfXRj\n//warp             https://www.shadertoy.com/view/MlsXRj\n//spheremap        https://www.shadertoy.com/view/MsXXW4\n//cos tiny         https://www.shadertoy.com/view/lltXRn\n\n//return 2d rotation matrix;\nmat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n\nvoid mainImage(out vec4 r,in vec2 f){\n float t=iTime*.2;\n vec2 v=f;\n v*=rot2(t);//2d rotation //rotation before translation, otherwise it skews! here fragmentts are kinda inverse like that!\n v+=rot2(t*9.)[0]*32.;//position.xy //f.x+=cos(t*9.)*32.;//position.x //f.y+=sin(t*9.)*32.;//position.y\n v*=cos(t)*.5+.51;//scale.xy\n v*=.1;//scale.xy\n float s=0.;\n if(f.y>iResolution.y*.5){\n  if(f.x>iResolution.x*.5)s=checkerFloor(v)*2.-1.; \n  else                    s=(checkerBoolT(v*.5))*2.-1.;\n }else{\n  if(f.x>iResolution.x*.5)s=checkerSin(v*3.);  \n  else                    s=checkerSign(v);\n }\n#ifdef monochrome     \n s=s/4.+.5;//shift range[-1.,1.] to range[.25,.75]\n r.xyz=vec3(s);}//monochrome\n#else\n //1 vector for orange-teal contrast\n s+=.5;//color range correction.\n #define COLOR vec3(1.,.75,.5)\n r.xyz=mix(COLOR,COLOR.zyx,s);}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mty3z1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mty3zh", "name": "Light On Floor", "author": "Imsure1200q_1UWE130", "description": "A light facing to the floor of a room; The floors look like cells with nucleus, \nThe Room Is Blue.\n\nAdded what the point to my shader is.", "tags": ["3d", "raymarching", "flashlight", "cell"], "likes": 2, "viewed": 634, "date": "1473074525", "time_retrieved": "2024-06-20T18:42:02.566368", "image_code": "float hashRace(vec3 p)\n{\n    vec2 noise = p.xy / fract(sin(dot(p.xy, vec2(0.15963, 2.968))*length(cos(p))));\n    float perl = length(clamp(p, vec3(noise, 1.0), vec3(noise, 2.0))*mod(p, sqrt(p))) - 189.0;\n    vec3 newP = smoothstep(vec3(sin(iTime)),\n                           step(vec3(noise, perl), vec3(perl, noise)) - length(tan(p)),\n                           step(vec3(noise, perl), vec3(perl, noise)) - length(sqrt(p))\n                           );\n    return length(cos(sin(newP)));\n}\nvec2 sdlineRoundTile(vec3 p)\n{\n    return vec2(hashRace(p - sin(atan(iTime))),gl_FragCoord.xy/iResolution.xy);\n}\nvec4 trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    float m = 0.0;\n    for(int i = 0; i < 24; i++)\n    {\n        vec3 p = ro+t*rd;\n        vec2 rm = sdlineRoundTile(p);\n        //vec2 rm2 = sdlineRoundTile(p*2.);\n        //float d = min(rm.x,rm2.x);\n        float d = rm.x;\n        m = rm.y;\n        t += d * 0.5;\n    }\n    vec3 ocol = vec3(0.);\n    \n    if(mod(m,1.)*2.0-1.0 < -0.5) ocol = vec3(1.0,0.0,1.0);\n    else if(mod(m,1.)*2.0-1.0 < 0.) ocol = vec3(0.0,1.0,1.0);\n    else if(mod(m,1.)*2.0-1.0 < 0.5) ocol = vec3(0.5,1.0,0.0);\n    else ocol = vec3(1.0, 0.5,0.0);\n    \n    return vec4(t, ocol);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float t = iTime;\n    rd.xz *= mat2(-cos(t), sin(t), sin(t), cos(t));\n    rd.xy *= mat2(cos(t), -sin(t), sin(t), cos(t));\n    rd.yz *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    vec3 ro = vec3(sin(t), cos(t), -3.0);\n    vec4 txc = trace(ro,rd);\n    float x = txc.x;\n    vec3 col = txc.yzw;\n    vec3 fc = vec3(1.0/(1.0+x*x*0.1));\n\tfragColor = vec4(fc, 1.0) + (length(fc) * 5.0) +\n        vec4(cos(uv.y + 0.814293))*vec4(col,1.0) - vec4(length(ro+rd)-2.0);\n    //Gamma Correcting more like gamma color overflower yeah\n    //fragColor = pow(fragColor, vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mty3zh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtyGDR", "name": "Amiga cr", "author": "gigatron", "description": "Amiga candy bar demo from the Band Ckracktro : https://www.youtube.com/watch?v=TZ_GZC6If3c\nskull and font are missing ... request IQ french tutorial :)\n\nOf course the candy bar is fake ....\n", "tags": ["amiga", "starfield", "cracktro", "candybar"], "likes": 0, "viewed": 227, "date": "1474094868", "time_retrieved": "2024-06-20T18:42:02.566368", "image_code": "// Gigatron France for ST .. Partial Amiga The Band Cracktro !\n#define t iTime*12.\nfloat bars(vec2 q,float size) {\n    return cos(q.y+t+q.y*-size);\n}\n\nfloat rand (in vec2 uv) { return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241); }\nconst vec2 O = vec2(0.,1.);\nfloat noise (in vec2 uv) {\n\tvec2 b = floor(uv);\n\treturn mix(mix(rand(b),rand(b+O.yx),.5),mix(rand(b+O),rand(b+O.yy),.5),.5);\n}\n\n#define DIR_RIGHT -1.\n#define DIR_LEFT 1.\n#define DIRECTION DIR_LEFT\n\n#define LAYERS 6\n#define SPEED 140.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv;\n    \n    float stars = 0.;\n\tfloat fl, s;\n\tfor (int layer = 0; layer < LAYERS; layer++) {\n\t\tfl = float(layer);\n\t\ts = (300.-fl*10.);\n\t\tstars += step(.1,pow(noise(mod(vec2(uv.x*s - iTime*SPEED*DIRECTION - fl*100.,uv.y*s),iResolution.x)),18.)) * (fl/float(LAYERS));\n\t}\n\t    \n     float ypos=0.4*abs(sin(t/5.));   \n     float b = bars(q-ypos,45.);// size\n \n    \n    vec3 col   = vec3(smoothstep(0.0, 0.2, b));\n         col.b = 0.9;\n         col  *= smoothstep(.15, .02, abs(q.y -0.5-ypos));//- ypos));\n       \n         if(col.b<0.1) col  +=stars ;\n    \n\tfragColor  = vec4( col, 1.0 );\n    \n    \n    \n}", "image_inputs": [{"id": "ldB3zD", "previewfilepath": "https://soundcloud.com/www-digitalista-de/hybris-title-paul-van-der-valk", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/www-digitalista-de/hybris-title-paul-van-der-valk", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtyGDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtyGRy", "name": "procedural 'sun'", "author": "davepermen", "description": "procedural sun", "tags": ["procedural", "sun"], "likes": 0, "viewed": 130, "date": "1475150306", "time_retrieved": "2024-06-20T18:42:02.566368", "image_code": "float distanceOf(vec3 point, vec2 other) {\n    return 1.0 / (point.z * length(point.xy - other));\n}\n\nvec3 hdr(vec3 color, vec2 pos) {\n    color = pow(color + texture(iChannel0, pos).rgb * 0.4 - 0.2, vec3(5, 2.1, 0.7));\n    return 1.0 - exp(-color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    vec2 point = vec2(iMouse.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    float distance = distanceOf(vec3(point, 10.0 * (cos(iTime * 10.0) + 10.0)), uv);\n    vec3 color = vec3(distance);\n    \n    point = vec2(-iMouse.xy + iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    distance = distanceOf(vec3(point, 10.0 * (cos(iTime * 10.0) + 10.0)), uv);\n    color += vec3(distance);\n    \n    point = (vec2(sin(iTime), -cos(iTime)) * 0.1);\n    distance = distanceOf(vec3(point, 10.0 * (cos(iTime * 10.0) + 10.0)), uv);\n    color += vec3(distance);\n    \n    point = (vec2(-sin(iTime), cos(iTime)) * 0.4);\n    distance = distanceOf(vec3(point, 10.0 * (cos(iTime * 10.0) + 10.0)), uv);\n    color += vec3(distance);\n    \n    point = (vec2(cos(iTime), sin(iTime)) * 0.3);\n    distance = distanceOf(vec3(point, 10.0 * (cos(iTime * 10.0) + 10.0)), uv);\n    color += vec3(distance);\n    \n    point = (vec2(-cos(iTime), -sin(iTime)) * 0.2);\n    distance = distanceOf(vec3(point, 10.0 * (cos(iTime * 10.0) + 10.0)), uv);\n    color += vec3(distance);\n    \n\tfragColor = vec4(hdr(color, uv * 10.0 + iTime * vec2(14.0, 35.0)), 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtyGRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xlc3zj", "name": "haunted", "author": "wombleman", "description": "warping lvl1", "tags": ["warping"], "likes": 20, "viewed": 362, "date": "1474849753", "time_retrieved": "2024-06-20T18:42:03.172559", "image_code": "//-----constants-----//\nconst int PUDDLES = 0, PLAD = 1, HORIZONTAL_WAVES = 2, VERTICAL_WAVES = 3;\n\n//-----user paramaters-----//\nvec3 COLOR_A = vec3(0.3,0.3,0.3), COLOR_B = vec3(0.8,0.8, 0.8), COLOR_C = vec3(0.01,0.01,0.01);\nfloat SPEED_A = 0.05, SPEED_B = -0.05, REC_MULT = 2.2;\nint VARIANT = PUDDLES;\nvec3 FBM_Ws_FROM = vec3(1.0,2.0,4.0), FBM_Ws_TO = vec3(1.0);  float BLEND_T = 20.0, START_T=20.0;\nconst int RECURSIONS = 0, ROTATIONS = 10, DEGREE = 3;\nconst bool VIGNETTE = true, SHARPEN = true;\n\n//-----initialized varaibles-----//\nmat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm_w(int i){\n    float t = smoothstep(START_T,START_T+BLEND_T,iTime);\n\tif (i==0) return mix(FBM_Ws_FROM.x, FBM_Ws_TO.x, t);\n    if (i==1) return mix(FBM_Ws_FROM.y, FBM_Ws_TO.y, t);\n    if (i==2) return mix(FBM_Ws_FROM.z, FBM_Ws_TO.z, t);\n}\n\nfloat hash( vec2 p )\n{    \n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\n\nfloat bilinear( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 f_pow = f;\n    for (int i = 0; i < DEGREE - 1; i++){\n        f_pow *= f;\n    }\n\tvec2 u = f_pow * (3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm_helper( in vec2 p )\n{\n\tfloat f = 0.0;\n    float accum = 0.0;\n    for (int i = 0; i < ROTATIONS; i++){\n        float w = pow(0.5,float(i));\n        accum += w;\n        f += w * bilinear(p);\n        p = m * p * REC_MULT;\n        \n    }\n    return f / accum;\n}\n\nvec2 fbm( vec2 p )\n{\n    if (VARIANT == PUDDLES){\n    \treturn vec2(fbm_helper(p.xy), fbm_helper(p.yx));\n    }\n    else if (VARIANT == PLAD){\n    \treturn vec2(fbm_helper(p.xx), fbm_helper(p.yy));\n    }\n    else if (VARIANT == HORIZONTAL_WAVES){\n    \treturn vec2(fbm_helper(p.xy), fbm_helper(p.yy));\n    }\n    else if (VARIANT == VERTICAL_WAVES){\n    \treturn vec2(fbm_helper(p.xy), fbm_helper(p.xx));\n    }  \n}\n\nvec3 map(vec2 p)\n{   \n    //color(p) = fbm(p + fbm(p + fbm(p + time))) \n    float f = dot( fbm(fbm_w(0) * (SPEED_A*iTime + p + fbm(SPEED_B * iTime+fbm_w(1)*(p + fbm(fbm_w(2)*p))))), \n                  vec2(1.0,-1.0) );\n\n    float wA_B = smoothstep( -0.8, 0.8, f ), wAB_C = smoothstep( -1.0, 1.0, fbm_helper(p) );\n    return mix(mix(COLOR_A,COLOR_B, wA_B),COLOR_C,wAB_C);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set up rotation M\n    float a = 2.0 * 3.141 / float(ROTATIONS);\n    float ca = cos(a), sa = sin(a);\n    m = mat2(ca,  sa, -sa,  ca);\n    \n    \n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    vec3 col = map(p);\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    float w = mix(0.1,0.5,dot(tex.xyz,vec3(0.333)));\n    vec3 mixer = vec3(uv,0.5+0.5*sin(iTime));\n    \n    if (SHARPEN){\n        float e = 0.0045;\n\n   \t    vec3 colc = map( p               ); float g = dot(colc,vec3(0.333));\n        vec3 cola = map( p + vec2(e,0.0) ); float dx = dot(cola,vec3(0.333));\n        vec3 colb = map( p + vec2(0.0,e) ); float dy = dot(colb,vec3(0.333));\n\n        col = colc;\n        float t = smoothstep(0.0,START_T,iTime);\n        col += t*mixer*3.0*abs(2.0*g-dx-dy);\n    }\n    \n    \n    if (VIGNETTE){\n        col *= pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.1); \n    }\n    \n    //col = mix(col,mixer,w);\n    fragColor = vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlc3zj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlG3DR", "name": "Driopodathron r.2", "author": "Imsure1200q_1UWE130", "description": "Driopodathron Round 1\n\nDropping Rain I.e. OPposite Of Defined Art\nD             R      I   OP            O  D           A\nDRIOPODA\n", "tags": ["driopodathon"], "likes": 0, "viewed": 373, "date": "1474032348", "time_retrieved": "2024-06-20T18:42:03.172559", "image_code": "float mxt(vec2 col)\n{\n    return length(sqrt(col));\n}\nfloat trace(float shape)\n{\n    float sabs = abs(shape);\n    sabs *= distance(shape/iResolution.x, shape*iResolution.x);\n    float q = sqrt(sabs) / length(shape);\n    return clamp(q, 0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 x = normalize(vec3(uv, fragColor.w)) - uv.y + uv.x;\n    float circle = length(vec2(uv.x*2.0-1.0*(iResolution.x/iResolution.y),uv.y*2.0-1.0));\n    circle -= sin(uv.y)+fract(iTime+tan(circle/2.0));\n    \n    float re = sqrt(circle);\n    vec3 qw = x + trace(circle);\n    vec4 ar = vec4(mxt(qw.xy - uv));\n\tfragColor = vec4(sqrt(x)-re, 1.0)-vec4(qw,1.0)+ar;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlG3DR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlG3Dw", "name": "Awesome Rocks Shader", "author": "vox", "description": "Awesome Shader", "tags": ["shader", "rocks", "awesome"], "likes": 1, "viewed": 362, "date": "1474831811", "time_retrieved": "2024-06-20T18:42:04.354333", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    \n    return res;\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nfloat magnification;\nvec2 tree(vec2 uv)\n{\n    float w1 = saw(time);\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = scale(square, vec2(2.0));\n    square = translate(square, vec2(-1.0));\n    float t1 = time;\n    \n    //square = scale(square, (1.0-saw(uv.xy))*vec2(saw(t1)+.5));\n    \n    square = RotateZ(square, time+seedling);\n    \n    square[2].xy *= vec2(saw(uv.y+time)*.25+.75);\n    square[0].xy *= vec2(saw(uv.y+time)*.25+.75);\n    \n    square = scale(square, vec2(.5));\n    square = translate(square, vec2(.5));\n    \n    \n    float t = time;\n    vec3 f = flux(time);\n    \n    \n    vec2 dxdy = sqrt(4.0)/iResolution.xy;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(1.0, \t0.0);\n    vec2 c = uv+vec2(0.0, \t\t1.0);\n    \n    vec2 a2 = invBilinear(a, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 b2 = invBilinear(b, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 c2 = invBilinear(c, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    \n    magnification = abs(cross(b2-a2, c2-a2)/cross(square[3].xy-square[0].xy, square[1].xy-square[0].xy));\n    \n    return saw(a2);\n}\n\nfloat draw(vec2 uv)\n{\n    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 8;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float zoom = 1.5+saw(time);\n    \n    uv = uv*2.0-1.0;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = float(i)/float(max_i);\n        vec2 next = tree((uv));\n        ifs *= magnification;\n    \tfloat weight = pow(ifs, 1.0/float(i+1));\n        depth += (saw(uv.x+time)\n                  +saw(uv.y+time)\n                  +draw(next))*weight;\n        uv = next;//*weight+uv*(1.0-weight);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    depth /= float(max_i)/5.0;\n\n    float weight = pow(ifs, 1.0/float(max_i));\n\n    float black = smoothstep(0.0, 1.0/5.0, saw(depth-time));\n    float white = smoothstep(4.0/5.0, 1.0, saw(depth-time));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*weight;\n    fragColor = vec4(clamp(sqrt(depth*ifs), 0.0, 1.0)*(flux(time+depth)*black+white), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlG3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlG3Wm", "name": "Yet", "author": "vox", "description": "Yet", "tags": ["yet"], "likes": 3, "viewed": 363, "date": "1474845851", "time_retrieved": "2024-06-20T18:42:05.227285", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 mobius(vec2 uv)\n{\n\tvec2 a = sin(seedling+vec2(time, time*GR/E));\n\tvec2 b = sin(seedling+vec2(time, time*GR/E));\n\tvec2 c = sin(seedling+vec2(time, time*GR/E));\n\tvec2 d = sin(seedling+vec2(time, time*GR/E));\n\treturn cdiv(cmul(uv, a) + b, cmul(uv, c) + d);\n}\n\nvec2 map(vec2 uv)\n{\n    return saw(mobius(zoom*(.5+saw(seedling+time))*(uv*2.0-1.0))*2.0*PI);\n}\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = map(a);\n    vec2 mb = map(b);\n    vec2 mc = map(c);\n    vec2 md = map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return map(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    zoom = (2.5+2.0*sin(time));\n    \n    \n   \tconst int max_i = 6;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float magnification;\n    \n    for(int i = 0; i < max_i; i++)\n    {\n        seedling += fract(float(i)*123456.123456);\n        vec2 next = iterate(uv, .5/iResolution.xy, magnification);\n        float weight = pow(ifs, 1.0/float(i+1));\n        ifs *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        uv = next;\n        depth += ifs;\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    //depth /= float(max_i);\n    float shift = time;\n\n    float stripes = depth*PI*15.0;\n    float black = smoothstep(0.0, .75, saw(stripes));\n    float white = smoothstep(0.75, 1.0, saw(stripes));\n        \n    \n    vec3 final = (\n        \t\t\t\tvec3(cos(depth*PI*2.0+shift),\n                \t  \t\tcos(4.0*PI/3.0+depth*PI*2.0+shift),\n                \t  \t\tcos(2.0*PI/3.0+depth*PI*2.0+shift)\n                 \t\t)*.5+.5\n        \t\t )*black\n        \t\t +white;\n    \n    fragColor = vec4(vec3(ifs), 1.0);\n    \n    fragColor = vec4(saw((depth)));\n    fragColor = vec4(final, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlG3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlG3zW", "name": "beestie", "author": "eiffie", "description": "Strandbeest for marius. I wanted to make this shader when I first saw a strandbeest but couldn't figure out the legs. Thanks Marius. Original version ...\n[url]https://www.shadertoy.com/view/ltG3z1[/url]", "tags": ["strandbeest"], "likes": 35, "viewed": 3324, "date": "1473377421", "time_retrieved": "2024-06-20T18:42:05.227285", "image_code": "//Beestie by eiffie based on marius's strandbeest leg https://www.shadertoy.com/view/ltG3z1\n//which is based on...\n// Visualizing Theo Jansen's Strandbeest basic leg linkage\n// http://www.strandbeest.com/\n//\n// See http://www.strandbeest.com/beests_leg.php for names & values.\n\nconst float SCALE = 100.0;\n\nconst float a = 38.0 / SCALE;\nconst float b = 41.5 / SCALE;\nconst float c = 39.3 / SCALE;\nconst float d = 40.1 / SCALE;\nconst float e = 55.8 / SCALE;\nconst float f = 39.4 / SCALE;\nconst float g = 36.7 / SCALE;\nconst float h = 65.7 / SCALE;\nconst float i = 49.0 / SCALE;\nconst float j = 50.0 / SCALE;\nconst float k = 61.9 / SCALE;\nconst float l = 7.8  / SCALE;\nconst float m = 15.0 / SCALE;\n\n// distance from point p to line segment ab\nvec2 seg(vec2 a, vec2 b, vec2 p){\n  vec2 pa=p-a,ba=b-a;\n  float t=dot(pa,ba)/dot(ba,ba);\n  float d=length(pa-ba*clamp(t,0.0,1.0));\n  return vec2(d,max(d,0.5-abs(t-0.5)));\n}\n// intersect point between two 2d circles (x,y,r)\nvec2 intersect(vec3 c0, vec3 c1) {\n    vec2 dxy = vec2(c1.xy - c0.xy);\n    float d = length(dxy);\n    float a = (c0.z*c0.z - c1.z*c1.z + d*d)/(2.*d);\n    vec2 p2 = c0.xy + (a / d)*dxy;\n    float h = sqrt(c0.z*c0.z - a*a);\n    vec2 rxy = vec2(-dxy.y, dxy.x) * (h/d);\n    return p2 + rxy;\n}\n#define time iTime*2.0\nfloat iZ;\nvec3 mcol=vec3(0.0);\nfloat DE(vec3 p0){//drawing multiple legs by marching one\n  float sx=1.0,dB=max(abs(p0.x)-2.0,abs(p0.z)-3.75);\n  p0.y+=sin(p0.z*0.4+2.4*sin(p0.x*0.3+time*0.1))*0.25;\n  if(p0.x<0.0){sx=-1.0;p0.z-=0.5;}\n  float t=(time*2.0+(sin(time*0.1)+2.0)*floor(p0.z)+1.57*sx)*sx;\n  float x=sx*p0.x-0.2;\n  //leg from marius\n  vec2 crank = vec2(0, 0);          // crank axle\n  vec2 axle = crank - vec2(a, -l);  // main axle\n  vec2 pedal = crank + vec2(m*cos(t), -m*sin(t));\n  vec2 uv=vec2(-x,-p0.y);\n  // draw \"frame\"\n  vec2 ds = seg(vec2(0, l), axle, uv);\n  ds = min(ds, seg(vec2(0, l), crank, uv));\n  ds = min(ds, seg(pedal, crank, uv));\n  // compute linkage points\n  vec2 P1 = intersect(vec3(pedal, j), vec3(axle, b));  // bej\n  vec2 P2 = intersect(vec3(axle, c), vec3(pedal, k));  // cgik\n  vec2 P3 = intersect(vec3(P1, e), vec3(axle, d));  // edf\n  vec2 P4 = intersect(vec3(P3, f), vec3(P2, g)); // fgh\n  vec2 P5 = intersect(vec3(P4, h), vec3(P2, i));  // hi\n  ds = min(ds, seg(P1, axle, uv));\n  ds = min(ds, seg(P3, axle, uv));\n  ds = min(ds, seg(P1, P3, uv));\n  ds = min(ds, seg(P2, P4, uv));\n  ds = min(ds, seg(P2, P5, uv));\n  ds = min(ds, seg(P4, P5, uv));\n  ds = min(ds, seg(pedal, P1, uv));\n  ds = min(ds, seg(pedal, P2, uv));\n  ds = min(ds, seg(P2, axle, uv));\n  ds = min(ds, seg(P3, P4, uv));\n  //end leg\n  float z=abs(fract(p0.z)-0.5)-0.2;\n  float d2=max(ds.y,z);\n  float d3=min(length(uv),length(uv-axle));\n  float d=sqrt(ds.x*ds.x+z*z);\n  d=min(min(min(d,min(d2,d3))-0.01,(1.2-fract(p0.z))*iZ),abs(p0.x)+0.2);\n  d=max(d,abs(p0.z)-3.75);\n  d2=0.95+p0.y;\n  if(d<d2)mcol=vec3(0.7,0.4,0.2);\n  else mcol=vec3(0.9,0.7,0.4)*(0.5+0.5*fract(sin(dot(p0.xz,vec2(13.13,117.667)))*43.1234));\n  return min(d,d2);\n}\nvec3 sky(vec3 rd, vec3 L){//modified bananaft's & public_int_i's code\n  float d=0.4*dot(rd,L)+0.6;\n  rd=abs(rd);\n  float y=max(0.,L.y),sun=max(1.-(1.+10.*y+rd.y)*length(rd-L),0.)\n    +.3*pow(1.-rd.y,12.)*(1.6-y);\n  return d*mix(vec3(0.3984,0.5117,0.7305),vec3(0.7031,0.4687,0.1055),sun)\n    *((.5+pow(y,.4))*(1.5-abs(L.y))+pow(sun,5.2)*y*(5.+15.0*y));\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(time+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  iZ=1.0/rd.z;\n  vec3 L=normalize(vec3(0.4,0.7,0.5));\n  vec3 bcol=sky(rd,L);\n  vec4 col=vec4(0.0);//color accumulator\n  float t=DE(ro)*rnd,d,od=1.0,px=1.0/iResolution.x;\n  for(int i=0;i<99;i++){\n    d=DE(ro+rd*t);\n    if(d<px*t){\n      float dif=clamp(1.0-d/od,0.0,1.0);\n      float alpha=(1.0-col.w)*clamp(1.0-d/(px*t),0.0,1.0);\n      if(mcol.g>0.5)dif=0.1+dif*0.5;\n      col+=vec4(clamp(mcol*dif,0.0,1.0),1.0)*alpha;\n      if(col.w>0.99)break;\n    }\n    t+=d;od=d;\n    if(t>30.0)break;\n  }\n  ro+=rd*t;\n  if(t<30.0){\n    col.rgb*=(0.5+0.5*ShadAO(ro,L));\n    if(ro.y<0.0)col.w=1.0;\n  }\n  col.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n  return col.rgb;\n}\n\nmat3 lookat(vec3 fw){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   randomize(fragCoord);\n   float tim=iTime*0.3;\n   vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.x;\n   vec3 ro=vec3(sin(tim)+3.5,sin(tim*0.4)*0.75+0.25,-5.0+cos(tim*1.3)*2.0)*(sin(tim*0.2)*0.5+1.0);\n   vec3 rd=lookat(vec3(0.0,-0.5,0.0)-ro)*normalize(vec3(uv,1.0));\n   fragColor=vec4(scene(ro,rd)*2.0,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlG3zW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlK3WD", "name": "polywarp", "author": "zeo", "description": "polygon", "tags": ["poly"], "likes": 12, "viewed": 581, "date": "1474695800", "time_retrieved": "2024-06-20T18:42:05.233369", "image_code": "float time;\nfloat atime;\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nvec3 background(vec3 dir){\n    float a = atan(dir.y, dir.x);\n    float f = dir.z;\n    vec3 nadir = vec3(.1,.3,.5);\n    vec3 ground = vec3(.1,.6,.2);\n    vec3 sky = vec3(1.);\n    vec3 zenith = vec3(.0, .0, .2);\n    vec3 col = f < 0. ? mix(nadir, ground, f+1.) : mix(sky, zenith, pow(f,.25));\n    return col * (5.+sin(a*2.))/6.*2.5;\n}\n\nvec4 box(vec3 p, float w){\n    p = abs(p);\n    float dx = p.x-w;\n    float dy = p.y-w;\n    float dz = p.z-w;\n    float m = max(p.x-w, max(p.y-w, p.z-w));\n    return vec4(m,dx,dy,dz);\n}\n\nmat3 rotateX(float a){\n    return mat3(1.,0.,0.,\n                0.,cos(a), -sin(a),\n                0.,sin(a), cos(a));\n}\n\nmat3 rotateY(float a){\n    return mat3(cos(a), 0., -sin(a),\n                0.,1.,0.,\n                sin(a), 0., cos(a));\n}\n\nmat3 rotation;\nfloat jitter;\n\nvec4 map(vec3 p){\n    for (int i = 0; i < 5; i++){\n        p = abs(p*rotation + vec3(0.1, .0, .0));\n        p.y -= .8;\n        p.x -= .06;\n        p.z -= jitter;\n        p.xy = p.yx;\n    }\n    return box(p, .6);\n}\n\nvec3 normal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render(Ray ray){\n    float dist = 0.;\n    vec3 pos;\n    for (int i = 0; i < 60; i++){\n        pos = ray.org + dist*ray.dir;\n        dist+=map(pos).x;\n    }\n    vec4 m = map(pos);\n    if (m.x < 0.01){\n        vec3 n = normal(pos);\n        vec3 l = normalize(vec3(1.,2.,5.));\n        vec3 diffuse = clamp(dot(n, l),0., 1.)*vec3(1.);\n        vec3 r = reflect(ray.dir, n);\n        vec3 refl = background(r);\n        float dx = m.y;\n        float dy = m.z;\n        float dz = m.w;\n        float start = 0.00;\n        float end = 0.05;\n        float f = smoothstep(start, end, abs(dx-dy));\n        f *= smoothstep(start, end, abs(dx-dz));\n        f *= smoothstep(start, end, abs(dz-dy));\n        f = 1. - f;\n        float rf = 1.-abs(dot(ray.dir, n));\n        rf = pow(rf,3.);\n        float flash = 1.-fract(atime);\n        flash = sqrt(flash);\n        return diffuse*(1.-rf)*.8 + flash*f*vec3(2.9, 1.4, 1.2) + refl*rf*1.3; \n    }\n\n    //return vec3(0.);\n    return background(ray.dir)*0.2;\n}\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415/180.;\n\tray.dir = dir + tan(fov/2.) * right * uv.x + tan(fov/2.) / aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec3 cameraPos = vec3(7.*sin(time/3.),7.*cos(time/3.),-4.*sin(time/8.));\n\tvec3 lookAt = vec3(0.);\n\tvec3 up = vec3(0.,0.,1.);\n\tfloat aspect = iResolution.x/iResolution.y;\n    float t = floor(time);\n    float f = fract(time);\n    t += 1. - exp(-f*9.);\n    atime = t;\n    rotation = rotateX(atime*1.9)*rotateY(atime*1.4);\n    jitter = sin(time*80.)*.1*pow((1.-fract(time)),4.);\n\tRay ray = createRay(cameraPos, lookAt, up, p, 90., aspect);\n    vec3 col = render(ray);\n    float vig = p.x*(1.-p.x)*p.y*(1.-p.y)*4.;\n    vig = pow(vig,0.3);\n    col *= vig;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlK3WD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKGRW", "name": "Animated sine wave", "author": "HowPrice", "description": "Sine wave", "tags": ["2d", "simple", "maths", "trignometry"], "likes": 1, "viewed": 123, "date": "1473528338", "time_retrieved": "2024-06-20T18:42:05.233369", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy / iResolution.xy;\t// [0,1] +x right, +y up\n    pos.y = pos.y * 2.0 - 1.0; // x[0,1] y[-1,+1]\n        \n    // animate the sine wave properties\n    float amplitude = abs(sin(iTime));\n    float frequency = 0.5 + 5.0 * sin(iTime) * sin(iTime);\n    float phase = 10.0 * iTime;\n    \n    vec3 colour = vec3(0.0);\n    float x = 2.0*PI*frequency*pos.x + phase;\n\tfloat val = amplitude * sin(x);\n    float delta = abs(val-pos.y);\n    \n    // extra thickness is proportional to the magnitude of the curve gradient \n    float thickness = 0.06 + 0.04 * frequency * abs(cos(x));\n    colour.g = min(1.0-(1.0/thickness)*delta, 1.0); // remap delta [0,thickness] to [1,0]\n    \n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKGRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlKGWw", "name": "Even More Galaxies", "author": "vox", "description": "to look at.", "tags": ["more", "galaxies", "even"], "likes": 0, "viewed": 386, "date": "1474936323", "time_retrieved": "2024-06-20T18:42:06.287987", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0/GR/PI/E)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling+stretch*2.0*PI;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling+extraTurns*2.0*PI;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time*PI*4.0), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    return final;\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n    }\n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0);\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv0, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        \n        antispeckle = stretch;\n\n        stretch = smoothstep(0.0, 1.0/PI/GR, stretch);\n\n        float draw = border*(1.0-color.a);\n\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        \n        color += clamp( galaxy((p.xy)*2.0-1.0)*draw*border, 0.0, 1.0);//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n\n    \n    \tfragColor = vec4(color);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlKGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlV3zR", "name": "Bumpy Mobius Spiral", "author": "revers", "description": "Just playing with some shaders by Shane ([url=https://www.shadertoy.com/view/4l2XWK]#1[/url], [url=https://www.shadertoy.com/view/XsGXDV]#2[/url]) and dila ([url=https://www.shadertoy.com/view/MsSSRV]#3[/url]). Best viewed on fullscreen.", "tags": ["spiral", "mobius", "bumpmapping"], "likes": 15, "viewed": 792, "date": "1472765278", "time_retrieved": "2024-06-20T18:42:07.100171", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader is based on:\n *\n * - \"Bumped Sinusoidal Warp\" by Shane [ https://www.shadertoy.com/view/4l2XWK ]\n * - \"Mobius Sierpinski\" by Shane [ https://www.shadertoy.com/view/XsGXDV ]\n * - \"Mobius\" by dilla [ https://www.shadertoy.com/view/MsSSRV ]\n *\n * Thanks for sharing the code guys!\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\n/**\n * true - concave bumps, false - convex bumps\n * Thanks, Shane!\n */\nconst bool InvertNormal = true;\n\nconst float SpiralDensity = 0.2;\nconst float SpiralZoom = 0.5;\nconst int SpiralArms = 5;\nconst float BumpPower = 0.10150138;\nconst float BumpFactor = 0.0066746245;\nconst float LightSize = 2.9176579;\nconst float SampleDistance = 0.7;\nconst bool AntiAlias = true;\n\n#define TWO_PI 6.2831852\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn a * mat2(b.x, -b.y, b.y, b.x);\n}\n\nvec2 cinv(vec2 z) {\n\treturn vec2(z.x, -z.y) / dot(z, z);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n\treturn cmul(a, cinv(b));\n}\n\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn cdiv(cmul(a, z) + b, cmul(c, z) + d);\n}\n\nvec3 tex(vec2 uv) {\n\tfloat time = iTime * 0.1;\n\tvec2 t = vec2(sin(time), 0.0);\n\n\tvec2 A = vec2(cos(time * 5.0), sin(time * 5.0));\n\tvec2 B = vec2(0.0, 0.0);\n\tvec2 C = t * cos(iTime * 0.25) * 10.0;\n\tvec2 D = vec2(1.0, 1.0);\n\n\tuv = mobius(uv, A, B, C, D);\n\n\tfloat arm = float(SpiralArms);\n\tfloat den = SpiralDensity;\n\tfloat zoom = SpiralZoom;\n\tvec2 phase = vec2(-1.0, 1.0) * iTime * 0.125;\n\n\tfloat a1 = atan(uv.y, uv.x) / TWO_PI;\n\tfloat a2 = atan(uv.y, abs(uv.x)) / TWO_PI;\n\tfloat d = log(length(uv));\n\n\tvec2 uvL = vec2(a1 * arm + d * den, a1 - d * zoom) + phase;\n\tvec2 uvR = vec2(a2 * arm + d * den, a2 - d * zoom) + phase;\n\n\t// http://iquilezles.org/www/articles/tunnel/tunnel.htm\n\tvec3 col = textureGrad(iChannel0, uvL, dFdx(uvR), dFdy(uvR)).xyz;\n\n\tcol = pow(col, vec3(2.2));\n\treturn col;\n}\n\nfloat intensity(vec3 p) {\n\treturn p.x * 0.299 + p.y * 0.587 + p.z * 0.114;\n}\n\nfloat bump(vec2 p) {\n\treturn pow(intensity(tex(p)), BumpPower);\n}\n\nvec3 color(vec2 p) {\n\tp *= 0.5;\n\n\tvec3 pos = vec3(p, 0.0);\n\tvec3 rd = normalize(vec3(p, 1.0));\n\n\tvec3 lig = vec3(cos(iTime) * 0.5, sin(iTime) * 0.2, -1.0) * LightSize;\n\tvec3 nor = vec3(0.0, 0.0, -1.0);\n\n\tvec2 eps = vec2(0.0002, 0.0);\n\tvec2 grad = vec2(\n        \tbump(pos.xy - eps.xy) - bump(pos.xy + eps.xy),\n\t\t\tbump(pos.xy - eps.yx) - bump(pos.xy + eps.yx)) / (2.0 * eps.xx);\n    \n    if (InvertNormal) {\n        grad = -grad;\n    }\n\n\tfloat r = pow(length(p), 0.1);\n\n\tnor = normalize(nor + vec3((grad), 0.0) * BumpFactor * r);\n\tvec3 ld = normalize(lig - pos);\n\n\tfloat dif = max(dot(nor, ld), 0.0);\n\n\tvec3 ref = reflect(-ld, nor);\n\tfloat spe = pow(max(dot(ref, -rd), 0.0), 32.0);\n\n\tvec3 texCol = tex(pos.xy);\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += dif * vec3(1, 0.97, 0.92) * texCol * 0.7;\n\tbrdf += spe * vec3(1.0, 0.6, 0.2) * 2.0;\n\n\treturn clamp(brdf, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec3 col = vec3(0.0);\n\n\tif (AntiAlias) {\n\t\tfloat sdi = SampleDistance;\n\t\tvec2 p0 = ((fragCoord.xy + vec2(0.0, 0.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p1 = ((fragCoord.xy + vec2(sdi, 0.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p2 = ((fragCoord.xy + vec2(sdi, sdi)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p3 = ((fragCoord.xy + vec2(0.0, sdi)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n\t\tcol = (color(p0) + color(p1) + color(p2) + color(p3)) / 4.0;\n\t} else {\n\t\tcol = color((fragCoord.xy / iResolution.xy * 2.0 - 1.0) * aspect);\n\t}\n\tcol = pow(col, vec3(0.4545));\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/XlV3zR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlVGWw", "name": "Craziest Galaxies", "author": "vox", "description": "Craziest Galaxies", "tags": ["craziestgalaxies"], "likes": 2, "viewed": 440, "date": "1474937139", "time_retrieved": "2024-06-20T18:42:08.112353", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0/GR/PI/E)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = time;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+stretch*2.0*PI;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+stretch*2.0*PI;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n    \n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    return final;\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time))))\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time))))\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n    }\n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a);\n    vec2 mb = mobius(b);\n    vec2 mc = mobius(c);\n    vec2 md = mobius(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv0, .5/iResolution.xy, magnification);\n        \n        antispeckle *= stretch;\n\n        float draw = border*(1.0-color.a);\n\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        \n        color += clamp( galaxy((p.xy)*2.0-1.0)*draw*border, 0.0, 1.0);//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n\n    \n    \tfragColor = vec4(color);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlVGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xly3RR", "name": "Dusty Nebula 4 VR", "author": "RavenWorks", "description": "Most of this shader is forked directly from [url=https://www.shadertoy.com/view/MsVXWW]here[/url]!\n\nI really wanted to see that nebula in 3D :)\n\n[b]Tap '1' to toggle the nebula's size!\nTap '2' to toggle viewing the nebula from inside or outside![/b]", "tags": ["noise", "space", "nebula", "vr"], "likes": 16, "viewed": 1474, "date": "1472919490", "time_retrieved": "2024-06-20T18:42:09.791285", "image_code": "// VR fork of:\n\n// \"Dusty nebula 4\" by Duke\n// https://www.shadertoy.com/view/MsVXWW\n\n// I tweaked the 'stars' portion to suit VR resolution better.\n\n\n\n\n#define ROTATION\n//#define MOUSE_CAMERA_CONTROL\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n\nfloat starsRing(vec3 rd){\n    \n    float lon = atan(rd.x,rd.y)/pi;\n    float lat = atan(rd.z,length(rd.xy))/pi;\n    \n    const float starScale = 2.0;\n    vec2 uv = vec2( lon/starScale, lat/starScale );\n    \n    \n    \n    float curSamp = texture( iChannel0, uv ).x;\n    curSamp = pow(curSamp,256.0);\n    \n    \n    vec2 within = (fract(uv*iChannelResolution[0].xy)-0.5)*2.0;\n    float starBright = 1.0-length(within);\n    starBright = clamp(starBright,0.0,1.0);\n    starBright = pow(starBright,4.0);\n    \n    \n    float ringFade = abs(lat*3.0);\n    ringFade = clamp(ringFade,0.0,1.0);\n    ringFade = pow(ringFade,4.0);\n    ringFade = 1.0-ringFade;\n    \n    \n    \n    \n    return 1.0 - (curSamp * starBright * ringFade);\n    \n}\n\n\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//=====================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*4.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\n\n\n\n\n\n\n//\n\nvoid ray( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    \n    \n    #ifdef DITHERING\n\tvec2 dpos = ( fragCoord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n\t#endif \n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<56; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n        if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n\t    \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t// change this string to control density \n\t\td = max(d,0.08);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // star in center\n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        sum.rgb+=(lightColor/(lDist*lDist)/30.); // star itself and bloom around the light\n      \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n\t\t\n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.185;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n       \n        // enforce minimum stepsize\n        d = max(d, 0.04); \n      \n        #ifdef DITHERING\n        // add in noise to reduce banding and create fuzz\n        d=abs(d)*(.8+0.2*rand(seed*vec2(i)));\n        #endif \n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.02);\n      \n\t}\n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    float stars = 1.0;\n    stars *= starsRing(rd.xyz);\n    stars *= starsRing(rd.yzx);\n    stars *= starsRing(rd.zxy);\n    vec3 starbg = mix(vec3(0.0), vec3(0.8,0.9,1.0), 1.0-stars);\n    starbg *= (1.0-td);\n    sum.xyz += starbg;\n\t#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.);\n\n    #ifdef MOUSE_CAMERA_CONTROL\n    R(rd.yz, -iMouse.y*0.01*pi*2.);\n    R(rd.xz, iMouse.x*0.01*pi*2.);\n    R(ro.yz, -iMouse.y*0.01*pi*2.);\n    R(ro.xz, iMouse.x*0.01*pi*2.);\n    #else\n    R(rd.yz, -pi*3.93);\n    R(rd.xz, pi*3.2);\n    R(ro.yz, -pi*3.93);\n   \tR(ro.xz, pi*3.2);    \n    #endif \n    \n    ray( fragColor, fragCoord, ro, rd );\n    \n}\n\nbool getKey(float k){\n    return texture(iChannel1, vec2((k+0.5)/256.0,1.0)).x > 0.5;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    \n    bool bigMode = getKey(49.0);\n    bool insideMode = getKey(50.0);\n    \n    float scale;\n    float dist;\n    \n    if (insideMode) {\n        dist = -0.5;\n        if (bigMode) {\n            scale = 100.0;\n        } else {\n            scale = 1.0;\n        }\n    } else {\n        if (bigMode) {\n            scale = 10.0;\n            dist = 1.85;\n        } else {\n            scale = 1.0;\n            dist = 3.0;\n        }\n    }\n    \n    ro /= scale;\n    ro.z += dist;\n    \n    ray( fragColor, fragCoord, ro, rd );\n    \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xly3RR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjXW1", "name": "terrain study", "author": "hellochar", "description": "asdf", "tags": ["landscape"], "likes": 13, "viewed": 460, "date": "1473401393", "time_retrieved": "2024-06-20T18:42:12.785445", "image_code": "mat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n// the backbone of any noise, or really any chaotic/natural/random looking\n// shader. hash basically maps an input value n to a random location in [0..1]\n// this function does have a period of TWO_PI but because the scaling factor\n// is so large there's significant differences between e.g. hash(0) and hash(TWO_PI)\n// the float data-type is not precise enough to be able to show the pattern even\n// in minute scales\n// and we're sampling with n ranging in the hundreds and thousands - it's basically\n// a reproducable random\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\n// some random noise function that i can't really parse\n// most noise functions are basically chaotic but\n// still continuous mappings whose behavior is complex enough\n// that humans can't see the pattern\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\n\n\n// return an interpolated height and position for the given input\n\n// height algorithm:\n// partition 2d space into a set of 1x1 squares\n// each square has 4 corners; each corner's coordinate is associated\n// with a random height (and with a variable a-d), such that the same corner on two different squares has\n// the same value. Interpolate between the corners\n// depending on where in the 1x1 square you are. Linear interpolation\n// creates discontinuities at the edges, instead use a cubic hermite spline with slope 0 at the tangents - this ensures smoothness\n// of 2 degrees.\n/*\n      x+           \n +------------>   \n |                \n |  a            b\ny|   +----------+ \n+|   |          | \n |   |          | \n v   |          | \n     |          | \n     |          | \n     +----------+ \n    c            d\n*/\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*54.0;\n\n    // heights of the four corners\n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 54.0);\n    float d = hash(n+ 55.0);\n    \n    return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n                // scalar function: f*f*(f*(f-2.0)+1.0) = f^2*(f-1)^2 = hump shape from [0..1] (*30 = goes up to 1.875 in the middle)\n                // any function can serve as the scalar as long as it 1) goes to 0 at the edges, and 2) is continuous (and preferably is smooth as well)\n                // the scalar affects how smooth the terrain is; a higher value will make the mountains more sharp\n                \n                // the actual yz vec2 is another returned value that to add more flavor to the noise. \n                // You can use it as the basis of another noise, or (in the case of the caller here), \n                // modify the .x with the .yz.\n                // the vec2 function should reference a,b,c,d such that the function evaluates to the\n                // same value on either side of the edge of the 1x1 square\n                \n                /* \n\t\t\t\t * if the formula is F(x), the following invariants should hold:\n\t\t\t\t * (1) F(<x+, y>).y = F(<x-, y>).y, x is an integer\n\t\t\t\t * (2) F(<x, y+>).x = F(<x, y->).x, y is an integer\n\t\t\t\t * in (1), the scalar makes the x component go to 0, so only the y components must\n\t\t\t\t * be equal. Similarly in (2), the y component is multiplied by 0, so only the x\n\t\t\t\t * components should be equal.\n\t\t\t\t * With the invariants, transitioning between two cells of the 1x1 grid will be continuous\n\t\t\t\t */\n                30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\n// fbm is a more complex noise, again harmonic\n// that takes several layers of noise at differing\n// scales and adds them up -- basically a more interesting\n// noise\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\n// the height of the terrain at the given xy location\nfloat terrain( in vec2 x )\n{\n    // scale world coordinates down a lot\n    vec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n    vec2  d = vec2(0.0);\n    // sample a base noise at different locations 5 times\n    // and accumulate the sample into the final height\n    // this is the technique of taking a simple noise\n    // and making more interesting noise out of it by\n    // doing harmonic sampling? is that what it's called\n    for(int i=0;i<5; i++)\n    {\n        // random n\n        vec3 n = noised(p);\n        // d represents some \"distance\" away from some origin\n        d += n.yz;\n        // b is the octave attenuation (1, 0.5, 0.25, etc)\n        // add this octave, which is scaled by the attenuation\n        // factor and also by the distance factor\n        a += b*n.x/(1.0+dot(d,d));\n        b *= 0.5;\n        // not sure what how this matrix acts on p\n        // i believe it's more or less a twist + expand\n        p=m2*p;\n    }\n\n    return 140.0*a;\n}\n\n// same as terrain but go for 9 more iterations\n// this produces a much more fine-grained terrain function\n// that has goes deeper into the smaller scales of the terrain\n// so if terrain( x ) returned some value like 100,\n// terrain2( x ) returns a slightly more detailed value like 100.125\n// or something - it's a purturbed version of normal terrain\n// but the purtubations also exhibit the fractal landscape behavior\n// that is characterstic of the land\nfloat terrain2( in vec2 x )\n{\n    vec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n    vec2  d = vec2(0.0);\n    for(int i=0;i<14; i++)\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n        b *= 0.5;\n        p=m2*p;\n    }\n\n    return 140.0*a;\n}\n\n\n// takes in a world location and returns how vertically\n// far away you are from the terrain there\n// when used within raymarching this means that as the ray \n// is marching, since the map is continuous, you'll eventually\n// get within some small epsilon value of the actual terrain,\n// at which point you can count it as a hit\nfloat map( in vec3 p )\n{\n    // the height of the terrain at the location's xz plane\n    float h = terrain(p.xz);\n\n    // some sort of postprocessing of the height here\n    // to give it more jagged edges\n\n    // not sure how it really works yet\n    float ss = 0.03;\n    float hh = h*ss;\n    // scale the height down a lot, decompose it into its fractional\n    // and whole parts\n    float fh = fract(hh);\n    float ih = floor(hh);\n    // transform fh by pushing it up towards its sqrt\n    // by some amount depending on the height of the terrain you're at\n    // fh corresponds to a height of ~33 in the terrain\n    // the effect of this is that regularly at 33 pixel intervals,\n    // the middle area of the interval gets pushed up towards the top\n    // this creates more of a plateau effect which is more realistic\n    // of actual terrain\n    fh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );\n    \n    // reconstruct h with the new fractional part\n    h = (ih+fh)/ss;\n\n    return p.y - h;\n}\n\n// same as map but using terrain2\nfloat map2( in vec3 p )\n{\n    float h = terrain2(p.xz);\n\n\n    float ss = 0.03;\n    float hh = h*ss;\n    float fh = fract(hh);\n    float ih = floor(hh);\n    fh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );\n    h = (ih+fh)/ss;\n\n    return p.y - h;\n}\n\n// return whether the ray starting at rO and pointing at rD\n// hit the map or not. If it did, the distance from the origin to the hit\n// will be stored in resT\n// assumes rD is normalized\nbool jinteresct(in vec3 rO, in vec3 rD, out float resT )\n{\n    float h = 0.0;\n    float t = 0.0;\n    // march the ray forward 120 times\n    for( int j=0; j<120; j++ )\n    {\n        //if( t>2000.0 ) break;\n\n        vec3 p = rO + t*rD;\n        // break out of the iteration if you've passed some vertical\n        // plane which guarantees you won't hit the map\n        // (assumes the map is below 300); it's for performance i think?\nif( p.y>300.0 ) break;\n        h = map( p );\n\n        // if you're within .1 units, count that as a hit on the terrain\n        if( h<0.1 )\n        {\n            resT = t;\n            return true;\n        }\n        // t controls where your ray has been marched to\n        // what iq is saying here is that if the height is\n        // still large (that is, the ray is still quite vertically\n        // away from hitting the terrain), you can jump the\n        // ray much farther forward\n        // the invariant here is that the terrain's slope is less than 2\n        // the invariant is broken sometimes which is where the strange\n        // aliased banding that moves with the camera comes from\n        // this is really cool -- you're dynamically sampling the terrain\n        // based on how far away you are from it\n        t += max(0.1,0.5*h);\n    }\n\n    // if you've reached here, you've gone 120 iterations and still\n    // not hit the terrain, OR you've hit y = 300\n    // if you're within 5 units of the floor, just say you hit\n    // not sure why he does this\n    if( h<5.0 )\n    {\n        resT = t;\n        return true;\n    }\n    return false;\n}\n\n// this is called starting at the original ray's intersection point + 20*light1, in the direction of light1\n// it calculates a long-range shadow with a soft-edge\nfloat sinteresct(in vec3 rO, in vec3 rD )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int j=0; j<50; j++ )\n    {\n        //if( t>1000.0 ) break;\n        // cast a ray towards the light\n        vec3 p = rO + t*rD;\n\n        // track how far from the ground you are\n        float h = map( p );\n\n        // if you've hit the ground, you're completely in the shadow\n        if( h<0.1 )\n        {\n            return 0.0;\n        }\n        // 16 * h/t?\n        // 16 is an arbitrary scalar\n        // h/t is the difference in height divided by the distance the ray has travelled\n        res = min( res, 16.0*h/t );\n        // adding h is another performance gain - move the ray based on how far you away you are now\n        // because the terrain is mostly smooth\n        // you can basically analyze this as t will at some point get placed very near the actual minimum distance\n        // away between the ray and the terrain\n        // at that point, res will be set to h/t -- so farther-away terrains will cast shadows with a larger gradient\n        // basically emulates the diffusive quality of light, also realy cool\n        t += h;\n\n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n// approximate the gradient of the terrain at pos by\n// moving in a small epsilon in each of the three directions\n// the epsilon is scaled by t, the distance of the point from\n// the camera. This means that points farther away\n// have a smoother normal calculation\n// the choice of epsilon has a massive effect on the percieved\n// detail of the terrain\n// the difference is clearly noticable if you have a small epsilon\n// on faraway points - there is a lot of aliasing since the effective\n// distance between two adjacent pixels that are both far away\n// is quite large. This achieves the same effect as mip-mapping in terms\n// of detail. You do in fact want to scale by `t` otherwise pixels far away\n// don't look connected\nvec3 calcNormal( in vec3 pos, float t )\n{\n    float e = 0.001 * t;\n    vec3  eps = vec3(e,0.0,0.0);\n    vec3 nor;\n    nor.x = map2(pos+eps.xyy) - map2(pos-eps.xyy);\n    nor.y = map2(pos+eps.yxy) - map2(pos-eps.yxy);\n    nor.z = map2(pos+eps.yyx) - map2(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec3 camPath( float time )\n{\n    vec2 p = 600.0*vec2( cos(1.4+0.37*time),\n                         cos(3.2+0.31*time) );\n\n    return vec3( p.x, 0.0, p.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // maps screen from (-1, -1) on bottom-left to (1, 1) on top-right\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\n    // correct aspect ratio; y goes from -1 to 1, x goes from -1.75 to 1.75 (the aspect ratio is hard-coded to be 1.75)\n    vec2 s = xy*vec2(1.75,1.0);\n\n    float time = iTime*0.15;\n\n    // diretional light coming down from the top\n    vec3 light1 = normalize( vec3(  0.4, 0.22,  0.6 ) );\n\n    // a second light, probably directional\n    vec3 light2 = vec3( -0.707, 0.000, -0.707 );\n\n    // camera position is set using two cosines at different speeds\n    vec3 campos = camPath( time );\n    // target's always looking forward -- this is cool\n    vec3 camtar = camPath( time + 3.0 );\n    campos.y = terrain( campos.xz ) + 15.0;\n    // the eye is always just looking down\n    camtar.y = campos.y*0.5;\n\n    // roll the camera\n    float roll = 0.1*cos(0.1*time);\n    // cp is an upwards pointing vector in world space that wiggles slightly\n    // it controls the up vector of the camera\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n\n    // the direction the camera's pointing at\n    vec3 cw = normalize(camtar-campos);\n    // points to the \"right\" in the camera\n    vec3 cu = normalize(cross(cw,cp));\n    // points \"up\" in the camera, basically cp projected onto the camera's\n    // viewing plane\n    vec3 cv = normalize(cross(cu,cw));\n    // direction of the ray to cast for this pixel\n    // it's made of 3 components in camera space -\n    // an amount to go horizontally,\n    // an amount to go vertically,\n    // and an amount to go outwards\n    // that cw vector is needed otherwise the rays are always\n    // perpendicular to the camera's viewing angle\n    // the cw factor more or less controls the fov\n    // (a large factor zooms the whole frustum in, a small factor\n    // expands the fov out)\n    // this is shoddily recreating a frustum, i don't\n    // believe this is the right way to do this\n    vec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw );\n\n    float sundot = clamp(dot(rd,light1),0.0,1.0);\n    vec3 col;\n    float t;\n    // if your ray doesn't hit the ground, this pixel is hitting\n    // the sky instead -- render the sky\n    if( !jinteresct(campos,rd,t) )\n    {\n        // sky is very light blue scaled by the ray's y position,\n        // which is how high up the ray is; higher up means higher up\n        // in the sky means a darker blue;\n        // the y never goes past some small threshold\n        // so the sky always looks *mostly* blue, but you can still see\n        // the gradient\n        col = 0.9*vec3(0.97,.99,1.0)*(1.0-0.3*rd.y);\n\n        // this line adds a small amount of red-orangish color\n        // mostly in a ring shape around where the \"sun\" would be\n        col += 0.2*vec3(0.8,0.7,0.5)*pow( sundot, 4.0 );\n    }\n    else\n    {\n        // here's where you hit\n        vec3 pos = campos + t*rd;\n\n        // the terrain normal at this location\n        vec3 nor = calcNormal( pos, t );\n\n        //basic diffuse light calculation\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n        // i think this basically produces some ambient light as well?\n        float dif2 = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        \n        // shadow factor -- 1 = no long-range shadow, 0 = completely in shadow\n        float sh = 1.0;\n        // if light1 hits me\n        if( dif1>0.001 )\n            sh = sinteresct(pos+light1*20.0,light1);\n\n        // dif1v is the color contribution of the diffuse of the first light source\n        vec3 dif1v = vec3(dif1);\n        // sh = iMouse.x / iResolution.x;\n        // soft-shadow has a red coloring to it\n        dif1v *= vec3( sh, sh*sh*0.5+0.5*sh, sh*sh );\n\n        // apply a simple random noise factor on the base ground color\n        // just to give it a bit more flavor\n        float r = noise( 7.0*pos.xz );\n\n        // here we begin coloring the terrain. The base color mixes between\n        // a dark brown base color and a slightly more colorful brown at the top\n        // terrain2 is used here as just another random noise function whose input scales\n        // are on the same magnitude as the position; it's used to give the vertical bands\n        // in the terrain\n        float heightMix = clamp(terrain2( vec2(pos.x,pos.y*48.0))/200.0,0.0,1.0);\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.10,0.05,0.03), vec3(0.13,0.10,0.08), heightMix );\n        // mix the color with a more reddish hue if the normal points more up (how flat it is)\n        col = mix( col, 0.17*vec3(0.5,.23,0.04)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        // and if they're *really* flat, give it some green for grass\n        col = mix( col, 0.10*vec3(0.2,.30,0.00)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n        col *= 0.75;\n         // snow\n        #if 1\n        // height factor -- higher places have more snow (h=1), lower places have no snow (h=0)\n        float h = smoothstep(55.0,80.0,pos.y + 25.0*fbm(0.01*pos.xz) );\n        // normal+cliff factor -- land that is flatter gets more snow, cliff-like land doesn't get much snow\n        // normal+cliff factor is also scaled by height, aka higher up the slope factor is stronger\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        // wind directional factor -- if you have a high x slope, put less snow.\n        // so hilly terrain that is going up in one direction will have snow,\n        // going down on the other side will have no snow\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        s = smoothstep( 0.1, 0.9, s );\n        // mix color with dark grey color for snow\n        col = mix( col, 0.4*vec3(0.6,0.65,0.7), s );\n        #endif\n\n\n        // final light calculation\n        \n        // start with a slope factor -- cliffs will be shaded slightly darker\n        // this is most apparent when the cliff meets the ground; emulates ambient occlusion\n        // a little bit\n        vec3 brdf  = 2.0*vec3(0.17,0.19,0.20)*clamp(nor.y,0.0,1.0);\n        // most of the lighting comes from dif1\n             brdf += 6.0*vec3(1.00,0.95,0.80)*dif1v;\n        // a bit from dif2, which is just a small ambient secondary light to complement the first\n             brdf += 2.0*vec3(0.20,0.20,0.20)*dif2;\n\n       \t// add all of the light\n        col *= brdf;\n\n        // fog factor - 0 at close distances, goes to 1. Has a slightly s shaped curve\n        float fo = 1.0-exp(-pow(0.0015*t,1.5));\n        // fog color -- base 0.7; if you're looking towards the sun, make the fog the color of the sun\n        // when there's a lot of fog in the distance, the fog carries the color of the sun and blends\n        // it in with the actual surface color. This emulates that behavior\n        vec3 fco = vec3(0.7) + 0.6*vec3(0.8,0.7,0.5)*pow( sundot, 4.0 );\n        col = mix( col, fco, fo );\n    }\n\n    // postprocess filter; basically a sqrt color curve that helps the dark parts look brighter\n    // a bit like a compressor audio effect; makes things a bit warmer in general\n    col = sqrt(col);\n\n    // (0, 0) to (1, 1)\n    vec2 uv = xy*0.5+0.5;\n    //create a slight inset shadow on the top corners\n    col *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.1);\n\n    // and we're done!\n    fragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjXW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xsl3DS", "name": "Ray Tracer", "author": "phagor", "description": "Classic Whitted ray tracer, written for readability not performance.", "tags": ["3d", "reflection", "ray", "refraction", "tracing", "tracer"], "likes": 8, "viewed": 769, "date": "1474900006", "time_retrieved": "2024-06-20T18:42:15.185528", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec2 angle = vec2(0.0,0.0);\n\nconst vec3 eyePosition = vec3(0.0, 0.0, -3.0);\nconst float screenZ = -1.0;\nconst vec3 backgroundColour = vec3(0.0,0.0,0.1);\nconst float noIntersectionT = -1.0;\nconst float epsilon = 0.0001;\nconst int noBounces = 2;\nconst float distanceAttenuationPower = 0.2;\nconst float reflectionRefractionFactorLowerLimit = 0.1;\n\nstruct Ray {\n\tvec3 start;\n\tvec3 direction;\n};\n\t\nstruct Material {\n\tvec3 ambientColour;\n\tvec3 diffuseColour;\n\tvec3 specularColour;\n\tvec3 reflectedColour;\n\tvec3 refractedColour;\n\tfloat reflectiveness;\n\tfloat refractiveness;\n\tfloat shinyness;\n\tfloat refractiveIndex;\n};\n\t\nstruct Sphere {\n\tvec3 position;\n\tfloat radius;\n\tMaterial material;\n};\n\t\nstruct Plane {\n\tvec3 position;\n\tvec3 normal;\n\tfloat d;\n\tMaterial material1;\n\tMaterial material2;\n\tfloat squareSize;\n};\n\t\nstruct Cube {\n\tvec3 position;\n\tfloat size;\n\tMaterial material;\n};\n\t\nstruct Intersection {\n\tvec3 position;\n\tfloat t;\n\tvec3 normal;\n\tbool inside;\n\tMaterial material;\n};\n\t\nstruct Light {\n\tvec3 position;\n\tvec3 ambientColour;\n\tvec3 diffuseColour;\n\tvec3 specularColour;\n};\n\t\nMaterial defaultMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.0, 0.0, 40.0, 1.0 );\nMaterial redMaterial = \t\tMaterial ( vec3(0.0, 0.0, 0.0), vec3(1.0,0.0,0.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.5, 0.0, 40.0, 1.0 );\nMaterial blueMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0,0.0,1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.5, 0.0, 40.0, 1.0 );\nMaterial glassMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0), 0.0, 1.0, 40.0, 1.5 );\nMaterial blackMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1,0.1,0.1), vec3(0.1,0.1,0.1), vec3(0.1,0.1,0.1), vec3(0.5,0.5,0.5), 0.1, 0.0, 1.0, 1.0 );\nMaterial whiteMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.8,0.8,0.8), vec3(0.1,0.1,0.1), vec3(0.1,0.1,0.1), vec3(0.5,0.5,0.5), 0.1, 0.0, 1.0, 1.0 );\nMaterial mirrorMaterial = \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.2,0.2,0.2), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 1.0, 0.0, 40.0, 1.0 );\n\nLight light = Light ( vec3(0.5, 0.5, -1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0) );\n\t\nbool intersectSphere(Ray ray, Sphere sphere, inout Intersection intersection) {\n\t\n\tfloat t0, t1, t;\n\t\n\tvec3 l = sphere.position - ray.start;\n\tfloat tca = dot(l, ray.direction);\n\tif ( tca < 0.0 )\n\t\treturn false;\n\tfloat d2 = dot (l, l) - (tca * tca);\n\tfloat r2 = sphere.radius*sphere.radius;\n\tif ( d2 > r2 )\n\t\treturn false;\n\tfloat thc = sqrt(r2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\t\t\n\tif ( t0 < 0.0 )\n\t\tt = t1;\n\telse if ( t1 < 0.0 )\n\t\tt = t0;\n\telse\n\t\tt = min(t0,t1);\n\t\t\t\n\tintersection.position = ray.start + t * ray.direction;\n\tintersection.t = t;\n\tintersection.normal = normalize ( intersection.position - sphere.position );\n\tintersection.material = sphere.material;\n\tintersection.inside = min(t0,t1) < epsilon && max(t0,t1) >= epsilon;\n\treturn true;\n}\n\nbool intersectPlane(Ray ray, Plane plane, inout Intersection intersection) {\n\n\tfloat t = - ( dot ( plane.normal, ray.start ) + length(plane.position) ) / ( dot ( plane.normal, ray.direction ) );\n\t\n\tif ( t < epsilon )\n\t\treturn false;\n\t\n\tintersection.position = ray.start + t * ray.direction;\n\tintersection.t = t;\n\tintersection.normal = plane.normal;\n\t\t\n\tvec3 p = mod ( intersection.position - plane.position - epsilon, plane.squareSize*2.0 );\n\tfloat s = plane.squareSize;\n\tfloat l = s;\n\tfloat h = s;\n\tif ( ( p.x < l && p.y < l && p.z < l ) ||\n\t     ( p.x > h && p.y < l && p.z > h ) ||\n\t     ( p.x < l && p.y > h && p.z > h ) ||\n\t     ( p.x > h && p.y > h && p.z < l ) )\n\t\tintersection.material = plane.material1;\n\telse\n\t\tintersection.material = plane.material2;\n\t\n\treturn true;\t\n}\n\nbool intersectCube(Ray ray, Cube cube, inout Intersection intersection) {\n\t\n\tvec3 minp = cube.position - cube.size/2.0;\n\tvec3 maxp = cube.position + cube.size/2.0;\n\t\n\tfloat tmin = (minp.x - ray.start.x) / ray.direction.x;\n\tfloat tmax = (maxp.x - ray.start.x) / ray.direction.x;\n\tif (tmin > tmax) { float s = tmin; tmin = tmax; tmax = s; }\n\tfloat tymin = (minp.y - ray.start.y) / ray.direction.y;\n\tfloat tymax = (maxp.y - ray.start.y) / ray.direction.y;\n\tif (tymin > tymax) { float s = tymin; tymin = tymax; tymax = s; }\n\tif ((tmin > tymax) || (tymin > tmax))\n\t\treturn false;\n\tif (tymin > tmin)\n\t\ttmin = tymin;\n\tif (tymax < tmax)\n\t\ttmax = tymax;\n\tfloat tzmin = (minp.z - ray.start.z) / ray.direction.z;\n\tfloat tzmax = (maxp.z - ray.start.z) / ray.direction.z;\n\tif (tzmin > tzmax) { float s = tzmin; tzmin = tzmax; tzmax = s; }\n\tif ((tmin > tzmax) || (tzmin > tmax))\n\t\treturn false;\n\tif (tzmin > tmin)\n\t\ttmin = tzmin;\n\tif (tzmax < tmax)\n\t\ttmax = tzmax;\n\t\n\tfloat t;\n\tif ( tmin < epsilon && tmax < epsilon )\n\t\treturn false;\n\tif ( tmin < epsilon )\n\t\tt = tmax;\n\telse if ( tmax < epsilon )\n\t\tt = tmin;\n\telse\n\t\tt = min(tmin, tmax);\n\t\t\n\tintersection.t = t;\n\tintersection.position = ray.start + t * ray.direction;\n\tintersection.material = cube.material;\n\tif ( tmin < epsilon && tmax > epsilon )\n\t\tintersection.inside = true;\n\t\n\tif ( abs(intersection.position.x - maxp.x) < epsilon )\n\t\tintersection.normal = vec3(1.0, 0.0,0.0);\n\telse if ( abs(intersection.position.x - minp.x) < epsilon )\n\t\tintersection.normal = vec3(-1.0,0.0,0.0);\n\telse if ( abs(intersection.position.y - maxp.y) < epsilon )\n\t\tintersection.normal = vec3(0.0,1.0,0.0);\n\telse if ( abs(intersection.position.y - minp.y ) < epsilon )\n\t\tintersection.normal = vec3(0.0,-1.0,0.0);\n\telse if ( abs(intersection.position.z - maxp.z ) < epsilon )\n\t\tintersection.normal = vec3(0.0,0.0,1.0);\n\telse\n\t\tintersection.normal = vec3(0.0,0.0,-1.0);\n\t\n\treturn true;\n}\n\nIntersection noIntersection () {\n\treturn Intersection(vec3(0.0,0.0,0.0),noIntersectionT,vec3(0.0,0.0,0.0),false,defaultMaterial);\n}\n\nbool hasIntersection(Intersection i) {\n\treturn i.t != noIntersectionT;\t\n}\n\n\nvec3 lighting(Ray ray, Intersection intersection, float shadowFactor) {\n\t\n\tvec3 colour = light.ambientColour * intersection.material.ambientColour;\n\n\tvec3 lightDir = normalize(light.position - intersection.position);\n\tvec3 eyeDir = normalize ( eyePosition - intersection.position );\n\tcolour += shadowFactor * light.diffuseColour * intersection.material.diffuseColour * max(dot(intersection.normal,lightDir), 0.0);\n\tvec3 reflected =  normalize ( reflect ( -lightDir, intersection.normal ) );\n\tcolour += shadowFactor * light.specularColour * intersection.material.specularColour * pow ( max ( dot(reflected, eyeDir), 0.0) , intersection.material.shinyness );\t\n\tcolour *= min ( 1.0/pow(length(intersection.position - ray.start), distanceAttenuationPower), 1.0);\n\n\treturn colour;\n}\n\nvoid intersection2(Ray ray, inout Intersection minIntersection) {\n\n\tIntersection intersection = noIntersection();\n\tSphere sphere;\n\t\t\n\tsphere = Sphere(vec3(-0.5,sin(iTime) + 0.5,0.5),0.4, redMaterial);\n\t\n\tif ( intersectSphere ( ray, sphere, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tsphere = Sphere(vec3(0.5,cos(iTime) + 0.5,0.5),0.4, blueMaterial );\n\t\n\tif ( intersectSphere ( ray, sphere, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tsphere = Sphere(vec3(0.0,0.0,-0.5),0.4, glassMaterial );\n\t\n\tif ( intersectSphere ( ray, sphere, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\tPlane plane;\n\t\n\tplane = Plane(vec3(0.0,-1.0,0.0), vec3(0.0,1.0,0.0), -1.0, blackMaterial, whiteMaterial, 1.0);\n\t\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tPlane plane2 = Plane(vec3(0.0,0.0,10.0), vec3(0.0,0.0,-1.0), -10.0, blackMaterial, whiteMaterial, 1.0);\n\t\n\tif ( intersectPlane ( ray, plane2, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tCube cube = Cube(vec3(0.8,-0.6,-0.7), 0.6, mirrorMaterial );\n\tif ( intersectCube ( ray, cube, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n}\n\nconst int noSpheres = 4;\nSphere spheres[noSpheres];\nvec3 velocity[noSpheres];\nvec3 position[noSpheres];\n\nvoid intersection(Ray ray, inout Intersection minIntersection) {\n\n\tIntersection intersection = noIntersection();\n\tfloat r = 0.25;\n\tfloat fi;\n\tfor (int i=0; i<noSpheres; i++) {\n\t\tfi = float(i);\n\t\tposition[i] = vec3(sin(fi*1000.0),sin(fi*10000.0),sin(fi*100.0));\n\t\tspheres[i].radius = r;\n        if (mod(fi,2.0)==1.0) \n            spheres[i].material = blueMaterial;\n        else\n            spheres[i].material = redMaterial;\n        if ( mod(fi,4.0)==0.0 )\n\t\t\tspheres[i].material = glassMaterial;\n\t\t\n\t\tvelocity[i] = vec3(cos(fi*200.0+fi*400.0+500.0), cos(fi*400.0+fi*2000.0+500.0), cos(fi*600.0)) / 2.0;\n\t}\n\t\n\tvec3 p;\n\n\tfor (int i=0; i<noSpheres; i++) {\n\t\tp = position[i] + ( velocity[i] * iTime  );\n\t\t\n\t\tp = mod ( p, 4.0 ) - 2.0;\n\t\tif ( p.x > 1.0 )\n\t\t\tp.x = 2.0 - p.x;\n\t\tif ( p.y > 1.0 )\n\t\t\tp.y = 2.0 - p.y;\n\t\tif ( p.z > 1.0 )\n\t\t\tp.z = 2.0 - p.z;\n\t\tif ( p.x < -1.0 )\n\t\t\tp.x = -2.0 - p.x;\n\t\tif ( p.y < -1.0 )\n\t\t\tp.y = -2.0 - p.y;\n\t\tif ( p.z < -1.0 )\n\t\t\tp.z = -2.0 - p.z;\n\t\tspheres[i].position = p;\n\t\t\n\t\tif ( intersectSphere ( ray, spheres[i], intersection ) ) {\n\t\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t\t}\n\t}\n\tPlane plane;\n\tfloat s = ( 1.0 + r*2.0 ) / 2.0;\n\t\n\tplane = Plane(vec3(0.0,-1.0 - r,0.0), vec3(0.0,1.0,0.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\n\tplane = Plane(vec3(0.0,1.0 + r,0.0), vec3(0.0,-1.0,0.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\t\n\n\tplane = Plane(vec3(-1.0 - r,0.0,0.0), vec3(1.0,0.0,0.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n\tplane = Plane(vec3(1.0 + r,0.0,0.0), vec3(-1.0,0.0,0.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\n\tplane = Plane(vec3(0.0,0.0,1.0 + r), vec3(0.0,0.0,-1.0), -0.0, blackMaterial, whiteMaterial, s);\n\tif ( intersectPlane ( ray, plane, intersection ) ) {\n\t\tif ( !hasIntersection(minIntersection) || intersection.t < minIntersection.t )\n\t\t\tminIntersection = intersection;\n\t}\n\t\n}\n\t\nvec3 traceRay(Ray ray, inout Intersection minIntersection) {\n\n\tintersection2(ray, minIntersection);\n\t\n\tif ( hasIntersection(minIntersection) ) {\n\t\tRay shadowRay = Ray ( minIntersection.position + epsilon * minIntersection.normal, normalize(light.position - minIntersection.position) );\n\t\tIntersection shadowIntersection = noIntersection();\n\t\tintersection ( shadowRay, shadowIntersection );\n\t\tfloat shadowFactor = 1.0;\n\t\t\n\t\tif ( hasIntersection(shadowIntersection) && shadowIntersection.t < length(light.position - minIntersection.position) ) {\n\t\t\t//shadowFactor = 1.0 * shadowIntersection.material.refractiveness;\t\n\t\t\tshadowFactor = 0.8;\n\t\t}\n\n\t\treturn lighting ( ray, minIntersection, shadowFactor );\n\t}\n\telse\n\t\treturn backgroundColour;\n}\n\nRay myRefract(Ray ray, Intersection intersection) {\n\tfloat cosI = dot(ray.direction,intersection.normal);\n\tfloat n1,n2;\n\tRay refractedRay;\n\tif ( intersection.inside ) {\n\t\tn1 = intersection.material.refractiveIndex;\n\t\tn2 = 1.0;\n\t\tintersection.normal = -intersection.normal;\n\t}\n\telse {\n\t\tn2 = intersection.material.refractiveIndex;\n\t\tn1 = 1.0;\n\t\tcosI = -cosI;\n\t}\n\t\n\tfloat cosT = 1.0 - pow(n1/n2, 2.0) * (1.0 - pow(cosI, 2.0));\n\t\n\tif (cosT < 0.0) {\n\t\trefractedRay.direction = normalize ( reflect ( ray.direction, intersection.normal ) );\n\t\trefractedRay.start = intersection.position + (epsilon * intersection.normal);\n\t}\n\telse {\n\t\tcosT = sqrt(cosT);\n\t\trefractedRay.direction = normalize ( ray.direction * (n1/n2) + intersection.normal * ((n1/n2) * cosI - cosT) );\n\t\trefractedRay.start = intersection.position - (epsilon * intersection.normal);\n\t}\n\treturn refractedRay;\n}\n\nvec3 recurseRay(Ray ray) {\n\t\n\tvec3 colour = vec3(0.0,0.0,0.0);\n\tvec3 localColour;\n\tIntersection intersection = noIntersection();\n\t\n\tIntersection firstIntersection = noIntersection();\n\tcolour = traceRay ( ray, firstIntersection );\n\t\n\tif (hasIntersection(firstIntersection)) {\n\t\n\t\tfloat reflectionFactor = firstIntersection.material.reflectiveness;\n\t\t\n\t\tif ( reflectionFactor >= reflectionRefractionFactorLowerLimit ) {\n\t\t\t\n\t\t\tray.start = firstIntersection.position;\n\t\t\tray.direction = reflect ( ray.direction, firstIntersection.normal );\n\t\t\t\n\t\t\tfor (int i=0; i<noBounces; i++) {\n\t\t\t\tintersection = noIntersection();\n\t\t\t\tlocalColour = traceRay(ray, intersection);\n\t\t\t\tif ( hasIntersection(intersection) ) {\t\n\t\t\t\t\t\n\t\t\t\t\tcolour += reflectionFactor * localColour;\n\t\t\t\t\treflectionFactor *= intersection.material.reflectiveness;\n\t\t\t\t\tif ( reflectionFactor < reflectionRefractionFactorLowerLimit )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tray.start = intersection.position;\n\t\t\t\t\tray.direction =  ( reflect ( ray.direction, intersection.normal ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolour += reflectionFactor * backgroundColour;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t\tfloat refractionFactor = firstIntersection.material.refractiveness;\n\t\t\n\t\tif ( refractionFactor >= reflectionRefractionFactorLowerLimit ) {\t\t\n\t\t\n\t\t\t/*\n\t\t\tvec3 refractedDirection = normalize ( refract ( ray.direction, firstIntersection.normal, firstIntersection.material.refractiveIndex ) );\n\t\t\tray.start = firstIntersection.position + epsilon * refractedDirection;\n\t\t\tray.direction = refractedDirection;\n\t\t\t*/\n\t\t\tray = myRefract(ray, firstIntersection);\n\t\t\t\n\t\t\tfor (int i=0; i<noBounces; i++) {\n\t\t\t\tintersection = noIntersection();\n\t\t\t\tlocalColour = traceRay(ray, intersection);\n\t\t\t\tif ( hasIntersection(intersection) ) {\t\n\t\t\n\t\t\t\t\tcolour += refractionFactor * localColour;\n\t\t\t\t\trefractionFactor *= intersection.material.refractiveness;\n\t\t\t\t\tif ( refractionFactor < reflectionRefractionFactorLowerLimit )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tray = myRefract ( ray, intersection );\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolour += refractionFactor * backgroundColour;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\treturn backgroundColour;\n\t\n\treturn colour;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\t\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat sx = 0.6;\n\tfloat sy = 0.6;\n    if (iMouse.z>0.0)\n\t   \tangle = (iMouse.xy-iMouse.zw)/iResolution.xy;\n\tmat4 mx = rotationMatrix ( vec3(0.0,1.0,0.0), angle.x * sx );\n\tmat4 my = rotationMatrix ( vec3(1.0,0.0,0.0), angle.y * sy );\n\t\n\tfloat y = (fragCoord.y * 2.0)/iResolution.y - 1.0;\n\tfloat ratio = iResolution.x/iResolution.y;\n\tfloat x = ((fragCoord.x * 2.0)/iResolution.x - 1.0) * ratio;\n\tvec4 pixelPosition = vec4(x,y,screenZ,1.0) * mx * my;\n\tvec4 rotatedEyePosition = vec4(eyePosition,1.0) * mx * my;\n            \n\tRay ray = Ray(rotatedEyePosition.xyz, normalize(pixelPosition-rotatedEyePosition).xyz);\n    vec3 col = recurseRay(ray);\n    \n    //IQ\n    //col = pow(col, vec3(0.4545));\n    //col = pow(col, vec3(0.8,0.85,0.9));\n    //gamma correction\n    //col = pow(col, vec3(1.0/1.6));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xsl3DS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsSXz3", "name": "Night Sky 01", "author": "xaot88", "description": "Moon, stars, clouds, etc.\nComments welcome!", "tags": ["procedural", "clouds", "sky", "stars", "moon", "night", "starfield"], "likes": 23, "viewed": 1984, "date": "1473001070", "time_retrieved": "2024-06-20T18:42:15.949223", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define HASHSCALE1 .1031\n\n// From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Kind of a Perlin Noise replacement.\n// I can't remember where I got this function from.\n// If someone knows who to credit, please let me know.\nfloat smoothNoise13( in vec3 x )\n{\n\tvec3 p  = floor(x);\n\tvec3 f  = smoothstep(0.0, 1.0, fract(x));\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\treturn\tmix(\n        \t\tmix(\n                    mix( hash11( n + 0.0 ), hash11( n + 1.0 ), f.x ),\n\t\t\t\t\tmix( hash11( n + 57.0 ), hash11( n + 58.0 ), f.x ),\n                    f.y ),\n\t\t\t\tmix(\n                    mix( hash11( n + 113.0 ), hash11( n + 114.0 ), f.x ),\n\t\t\t\t\tmix( hash11( n + 170.0 ), hash11( n + 171.0 ), f.x),\n                    f.y ),\n        \t\tf.z );\n}\n\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// I can't remember where I got this function from.\n// If someone knows who to credit, please let me know.\nfloat FractionalBrownianMotion( vec3 p )\n{\n\tfloat f = 0.5000 * smoothNoise13( p );\n    p = m * p * 1.2;\n\tf += 0.2500 * smoothNoise13( p );\n    p = m * p * 1.3;\n\tf += 0.1666 * smoothNoise13( p );\n    p = m * p * 1.4;\n\tf += 0.0834 * smoothNoise13( p );\n\treturn f;\n}\n\n// Convert hash12() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = hash12( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 0.1;\n    \n    vec2 vNormalizedUv = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\t\n\tvec3 col  = vec3(0.0, 0.0, 0.0);\n\t\n\t// render sky\n\tcol += vec3( 0.1, 0.2, 0.4 ) * vNormalizedUv.y;\n    \n\t// moon\n    vec2 vMoonPos = vec2(.5, 0.35);\n    vec2 vUvMoonDiff = uv - vMoonPos;\n    float fMoonDot = max( 0.0, 1.0 - dot( vUvMoonDiff, vUvMoonDiff ) );\n    col += vec3(0.6, 0.6, 0.6) * pow( fMoonDot, 350.0 );\n\t\n\t// moon haze\n\tcol += vec3(0.48, 0.54, 0.6) * pow( fMoonDot, 6.0 );\n    \n    // Note: Choose fThreshhold in the range [0.9, 0.9999].\n    // Higher values (i.e., closer to one) yield a sparser starfield.\n    float StarFieldThreshhold = 0.985;\n\n    // Stars with a slow spin.\n    float fSpinRate = 0.0005;\n    vec2 vInputPos = ( 2.0 * fragCoord.xy/iResolution.y ) - vec2( 1.0, 1.0 );\n    float fSampleAngle = fSpinRate * float( iFrame ) + atan( vInputPos.y, vInputPos.x );\n    vec2 vSamplePos = ( 0.5 * length( vInputPos ) * vec2( cos( fSampleAngle ), sin( fSampleAngle ) ) + vec2( 0.5, 0.5 ) ) * iResolution.y;\n    float StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n    col += vec3( StarVal );\n\n    // clouds\n    vec3 vFbmInput = vec3( uv.x - time, uv.y, 0.0 );\n    vec3 vFogColor = vec3(0.7, 0.7, 0.9);\n    col += vNormalizedUv.y * vFogColor * FractionalBrownianMotion( vFbmInput );\n\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSXz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtGGWm", "name": "Mercury Display", "author": "vox", "description": "Mercury Display", "tags": ["mercurydisplay"], "likes": 0, "viewed": 350, "date": "1474835970", "time_retrieved": "2024-06-20T18:42:17.119171", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    \n    return res;\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nfloat magnification;\nvec2 tree(vec2 uv)\n{\n    float w1 = saw(time);\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = scale(square, vec2(2.0));\n    square = translate(square, vec2(-1.0));\n    \n    //square = scale(square, (1.0-saw(uv.xy))*vec2(saw(t1)+.5));\n    \n    square = RotateZ(square, time+seedling);\n    \n    float t1 = time;\n    float t2 = time;\n    square = scale(square, vec2(saw(uv.y+t2+seedling)*.25+.75));\n    \n    square = scale(square, vec2(.5));\n    square = translate(square, vec2(.5));\n    \n    \n    float t = time;\n    vec3 f = flux(time);\n    \n    \n    vec2 dxdy = sqrt(4.0)/iResolution.xy;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(1.0, \t0.0);\n    vec2 c = uv+vec2(0.0, \t\t1.0);\n    \n    vec2 a2 = invBilinear(a, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 b2 = invBilinear(b, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 c2 = invBilinear(c, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    \n    magnification = abs(cross(square[3].xy-square[0].xy, square[1].xy-square[0].xy)/cross(b2-a2, c2-a2));\n    \n    return saw(a2);\n}\n\nfloat draw(vec2 uv)\n{\n    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 5;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float zoom = 1.5+saw(time);\n    \n    uv = uv*2.0-1.0;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = float(i)/float(max_i);\n        vec2 next = tree((uv));\n        ifs /= magnification+1.0;\n    \tfloat weight = pow(ifs, 1.0/float(i+1)/2.0);\n        depth += (length(uv*2.0-1.0))*weight;\n        uv = saw(time+(next*2.0-1.0)*weight);//*weight+vec2(.5)*(1.0-weight);//*weight+uv*(1.0-weight);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    depth /= float(max_i)/5.0;\n\n    float weight = pow(ifs, 1.0/float(max_i)/2.0);\n\n    float black = smoothstep(0.0, 1.0/5.0, saw(depth-time));\n    float white = smoothstep(4.0/5.0, 1.0, saw(depth-time));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*weight;\n    fragColor = vec4(clamp(sqrt(weight), 0.0, 1.0)*(flux(time+depth)*black+white), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtGGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtK3Dz", "name": "Noise function", "author": "ChuckNorris", "description": " ", "tags": ["2d", "3d", "noise", "domain", "random", "4d", "hash", "cc0", "public"], "likes": 8, "viewed": 856, "date": "1474215684", "time_retrieved": "2024-06-20T18:42:17.337229", "image_code": "// Noise functions without cancer license.\n// Dedicated to the public domain.\n// If you want a real license, you may consider this MIT/BSD/CC0/WTFPL-licensed (take your pick).\n\nvec4 noise(vec4 v){\n    // ensure reasonable range\n    v = fract(v) + fract(v*1e4) + fract(v*1e-4);\n    // seed\n    v += vec4(0.12345, 0.6789, 0.314159, 0.271828);\n    // more iterations => more random\n    v = fract(v*dot(v, v)*123.456);\n    v = fract(v*dot(v, v)*123.456);\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = noise(vec4(fragCoord.xy, iTime, 0.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/XtK3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtK3RG", "name": "Voronoi Floor Tiling", "author": "tomkh", "description": "Based on [url=https://www.shadertoy.com/view/llG3zy]Faster Voronoi Borders[/url] and my older [url=https://www.shadertoy.com/view/4lBXRV]15th Pentagonal Tiling[/url] shader.", "tags": ["voronoi", "tiling"], "likes": 26, "viewed": 1149, "date": "1475190036", "time_retrieved": "2024-06-20T18:42:18.507155", "image_code": "// Voronoi Floor Tiling \n// by Tom'2016\n\n// Based on https://www.shadertoy.com/view/llG3zy (Faster Voronoi Borders)\n// and https://www.shadertoy.com/view/4lBXRV (my older 15th Pentagonal Tiling)\n\n// Do you like colors? \n//  Put 0 if not ;)\n//  Put 1 for 12 colors\n//  Put 2 for 6 colors\n#define USE_COLORS 2\n\n#define ANIMATE 1\n#define ANIM_SPEED .25\n\nconst int iterations = 64;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .04;\nconst float fog_start = 16.;\n\nconst float cam_dist = 13.5;\n\n//---------------------------------------------\n// Tiling code\n\nvec2 hash2(vec2 p)\n{\n#if ANIMATE == 0\n   // Dave Hoskins hash as in https://www.shadertoy.com/view/4djSRW\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y))*.9+.05;\n#elif 1\n   // Dave Hoskins hash with animation\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   vec2 v = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n   #if 1\n   return sin(iTime*ANIM_SPEED + v*6.283185)*.45 + .5;\n   #else\n   // This version doesn't work, but if we switch \"v\" and \"6.283185\" it works ?!\n   return sin(iTime*ANIM_SPEED + 6.283185*v)*.45 + .5;\n   #endif\n#else\n   // Texture-based\n   vec2 v = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n   return sin(iTime*ANIM_SPEED + 6.283185*v)*.45 + .5;\n#endif\n}\n\n// Faster variant based on Inigo Quilez's implementation,\n// see https://www.shadertoy.com/view/llG3zy for explanation\nvec2 dTile( vec2 x )\n{\n    x *= .7;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.0001 ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec2( n.x + mg.x, md*1.5 );\n}\n\n//---------------------------------------------\n\nconst float bump = .1;\nconst float ground = .2;\n\nfloat dField(in vec3 p)\n{\n   float d = p.y + ground;\n   \n   vec2 tile = dTile(p.xz);\n   float d3;\n   //d3 = min(.05,smoothstep(0.,1.,tile.y*20.)*.05)*.5;\n   d3 = min(.05,tile.y)*.5;\n   d3 += tile.y*.3;\n   d3 = min(d3,bump);\n   //d3 = smoothstep(0.,1.,d3/cut)*cut;\n   d -= d3;\n   return d;\n}\n\nvec3 dNormal(in vec3 p, in float eps)\n{\n   vec2 e = vec2(eps,0.);\n#if 0\n   // less pleasent, but faster\n   e.x *= 2.;\n   float v = dField(p);\n   return normalize(vec3(\n      dField(p + e.xyy) - v,\n      dField(p + e.yxy) - v,\n      dField(p + e.yyx) - v ));\n#else\n   return normalize(vec3(\n      dField(p + e.xyy) - dField(p - e.xyy),\n      dField(p + e.yxy) - dField(p - e.yxy),\n      dField(p + e.yyx) - dField(p - e.yyx) ));\n#endif\n}\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   \n   // Intersect with ground plane first\n   \n   if (ray_dir.y >= 0.) return vec4(0.);\n   \n   float dist;\n   dist = (ray_start.y + ground - bump)/-ray_dir.y;\n   p += dist*ray_dir;\n   ray_len += dist;\n   if (ray_len > ray_max) return vec4(0.);\n   //return vec4(p, ray_len);\n   \n   for(int i=0; i<iterations; ++i) {\n   \t  dist = dField(p);\n      if (dist < dist_eps*ray_len) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, ray_len);\n}\n\nvec3 shade(in vec3 ray_start, in vec3 ray_dir,\n   in vec3 light_dir, in vec3 fog_color, in vec4 hit)\n{   \n   vec3 dir = hit.xyz - ray_start;\n   vec3 norm = dNormal(hit.xyz, .015);//*hit.w);\n   float diffuse = max(0.0, dot(norm, light_dir));\n   float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n   spec = pow(spec, 32.0)*.7;\n\n   vec2 tile = dTile(hit.xz);\n   float sh = tile.x;\n#if USE_COLORS == 2\n   sh = (abs(mod(sh+6.,12.)-6.)+2.5)*(1./9.);\n#else\n   sh = mod(sh,12.)*(1./12.);\n#endif\n   float sd = min(tile.y,.05)*20.;\n#if USE_COLORS == 0\n   vec3 base_color = vec3(.5);\n#else\n   // Ken Silverman's EvalDraw colors ;)\n   vec3 base_color =\n    vec3(exp(pow(sh-.75,2.)*-10.),\n         exp(pow(sh-.50,2.)*-20.),\n         exp(pow(sh-.25,2.)*-10.));\n#endif\n   vec3 color = mix(vec3(0.),vec3(1.),diffuse)*base_color +\n      spec*vec3(1.,1.,.9);\n   color *= sd;\n   \n   float fog_dist = max(0.,length(dir) - fog_start);\n   float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, .25));\n   \n   // Simple model-view matrix:\n   float ms = 2.5/iResolution.y;\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -ms :\n      -iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat3 cam_mat = mat3(\n      co, 0., si,\n      0., 1., 0.,\n     -si, 0., co);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y) * -ms - .1:\n      cos(-iTime*.5)*.4 + .8;\n   ang = max(0.,ang);\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat3(\n      1., 0., 0.,\n      0., co, si,\n      0.,-si, co);\n\n   vec3 pos = cam_mat*vec3(0., 0., -cam_dist);\n   vec3 dir = normalize(cam_mat*vec3(uv, 1.));\n\n   vec3 color;\n   vec3 fog_color = vec3(min(1.,.4+max(-.1,dir.y*.8)));\n   vec4 hit = trace(pos, dir);\n   if (hit.w == 0.) {\n      color = fog_color;\n   } else {\n      color = shade(pos, dir, light_dir, fog_color, hit);\n   }\n   \n   // gamma correction:\n   color = pow(color,vec3(.7));\n   \n   fragColor = vec4(color, 1.);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtK3RG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKGRD", "name": "Fun With Julia Sets Part 4", "author": "Julia_Sets", "description": "So I had even more fun with Julia sets.", "tags": ["julia", "set"], "likes": 1, "viewed": 72, "date": "1473547146", "time_retrieved": "2024-06-20T18:42:18.725149", "image_code": "// (a + bi)^2 = a^2 - b^2 + 2abi\nvec2 squareComplexNumber(vec2 complexNumber) {\n    float realComponentOfProduct = (complexNumber.x * complexNumber.x) - (complexNumber.y * complexNumber.y);\n    float imaginaryComponentOfProduct = 2.0 * complexNumber.x * complexNumber.y;\n    return vec2(realComponentOfProduct, imaginaryComponentOfProduct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 rainbow[7];\n    rainbow[0] = vec4(1.0, 0.0, 0.0, 1.0); // Red\n    rainbow[1] = vec4(1.0, 0.5, 0.0, 1.0); // Orange\n    rainbow[2] = vec4(1.0, 1.0, 0.0, 1.0); // Yellow\n    rainbow[3] = vec4(0.0, 1.0, 0.0, 1.0); // Green\n    rainbow[4] = vec4(0.0, 0.0, 1.0, 1.0); // Blue\n    rainbow[5] = vec4(0.294117647, 0.0, 0.509803922, 1.0); // Indigo (according to Wikipedia)\n    rainbow[6] = vec4(0.5, 0.0, 1.0, 1.0); // Violet (according to Wikipedia)\n    \n\tfloat zoom = 2.0;\n    vec2 c = vec2(sin(iTime), sin(iTime));\n    //vec2 c = vec2(-1.0, 0.0);\n    \n    vec2 z = fragCoord.xy / iResolution.xy;\n    z = z * vec2(zoom * 2.0);\n    z = z - vec2(zoom);\n    \n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    for (int i = 0; i < 14; i++) {\n        z = squareComplexNumber(z) + c;\n        \n    \tif (abs(z.x) < 2.0 && abs(z.y) < 2.0) {\n            fragColor = rainbow[i / 2];\n    \t}\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKGRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtKGWR", "name": "- Paisaje Nocturno - ", "author": "FranciscoGarcia", "description": "Usando funciones y figuras basicas.", "tags": ["2d"], "likes": 3, "viewed": 521, "date": "1474140617", "time_retrieved": "2024-06-20T18:42:18.731305", "image_code": "float rand(vec2 p) {\n    return fract(sin(dot(p.yx,vec2(5.982,10.233)))*4.5);\n}\nfloat colina(in vec2 p) {\n    p = p-vec2(-1.0, -0.9);\n    float r = 0.45 + 0.1*cos(atan(p.y,p.x)*10.0);\n    float circ = smoothstep(r,r+0.008,1.3-exp(-p.y));        \n    return circ;\n}\n\nfloat luna(in vec2 p, in float rad,in vec2 pos) {\n\tvec2 len = p-pos;\n    return 1.0-smoothstep(0.4,0.6,dot(len,len)*4.0);\n}\n\nfloat luc(in vec2 p, in float rad,in vec2 pos) {\n\tvec2 dist = (p-pos)-vec2(0.5,-0.38);\n    return 1.0-smoothstep(rad,rad+0.001,dot(dist,dist)*250.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y; \n    \n    \n    //Colores\n    vec3 c1 = vec3(0.047, 0.066, 0.2);\n    vec3 c2 = vec3(0.06,0.31,0.45);\n    vec3 bl = vec3(1.0);\n    vec3 mt = vec3(0.06,0.1,0.243);\n        \n    vec3 col = vec3(0.0);\n    \n    //Cielo, pradera y luna\n    col += mix(c2,c1,p.y);\n    col += mix(col,bl,luna(p,0.5,vec2(1.0,0.4+0.05*cos(iTime))));\n    col -= mix(col-mt,mt,colina(p));\n    \n    float st =0.0;\n    \t\n    //Luceros\n    for(float i=-20.0;i<15.0;i++){\n        \n    \tst += luc(p,0.01,1.25*vec2(rand(p+i)*i,rand(p+sin(0.000006*iTime))));\n    }\n    \n\tfragColor = vec4(col+st,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtKGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XttGDS", "name": "scene3d", "author": "andrewww1", "description": "mouse click to change orbit view pitch/yaw", "tags": ["test"], "likes": 3, "viewed": 167, "date": "1474210688", "time_retrieved": "2024-06-20T18:42:19.731469", "image_code": " \nfloat opS(float d1, float d2) {\n  return max(-d2,d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n  return (d1.y<d2.y) ? d1 : d2;\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opRotY(vec3 p,float a) {\n  float c=cos(a);\n  float s=sin(a);\n  mat3 m=mat3(vec3(c,0.0,s),vec3(0.0,1.0,0.0),vec3(-s,0.0,c));\n  return m*p;\n}\n\nvec2 distScene(vec3 p) {\n  vec2 rs=vec2(0.1,opS(sdBox(p-vec3(0.0,5.0,0.0),vec3(9.0)),\n                       sdBox(p-vec3(2.0,7.0,2.0),vec3(10.0))));\n\t\t\t\t\t   \n  rs=opU(rs,vec2(0.2,sdBox(opRotY(p-vec3(2.0,-1.0,-2.0),1.0), vec3(2.0))));\t\n  rs=opU(rs,vec2(0.3,sdBox(opRotY(p-vec3(-0.2,-1.0,3.0),0.5), vec3(2.0))));\t\t\n  rs=opU(rs,vec2(0.4,sdBox(opRotY(p-vec3(1.0,2.5,0.5),0.2), vec3(1.5))));\t\t\t\t   \n  rs=opU(rs,vec2(0.5,sdSphere(p-vec3(-6.0,cos(iTime)*2.0+0.5,5.0), 1.5)));\n\n  return rs;\n}\n\nvec3 calcNormal(vec3 p) {\n  float h = 0.0001;\n  vec3 n;\n  n.x=distScene(p+vec3(h,0.0,0.0)).y-distScene(p-vec3(h,0.0,0.0)).y;\n  n.y=distScene(p+vec3(0.0,h,0.0)).y-distScene(p-vec3(0.0,h,0.0)).y;\n  n.z=distScene(p+vec3(0.0,0.0,h)).y-distScene(p-vec3(0.0,0.0,h)).y;\n  n=normalize(n);\n  return n;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n  //from 'Enhanced Sphere Tracing' paper\n    \n  // o, d : ray origin, direction (normalized)\n  // t_min, t_max: minimum, maximum t values\n  // pixelRadius: radius of a pixel at t = 1\n  // forceHit: boolean enforcing to use the\n  // candidate_t value as result\n  \n  const float t_min=0.01;\n  const float t_max=1000.0;\n  //const float pixelRadius=0.0025;\n  \n  float id=0.0;\n  \n  //float omega = 1.2;\n  float t = t_min;\n  float candidate_error = 9999999999.0;\n  float candidate_t = t_min;\n  //float previousRadius = 0.0;\n  float stepLength = 0.0;\n  float functionSign = (distScene(ro).y<0.0)?-1.0:1.0;\n\n  for(int i=0;i<48;++i) {\n    vec3 p = ro + rd * t;\n    vec2 rs=distScene(p);\n\tid=rs.x;\n    float signedRadius = functionSign * rs.y;\n    float radius = abs(signedRadius);\n    //bool sorFail = (omega>1.0) && (radius + previousRadius) < stepLength;\n\n    //if(sorFail) {\n    //  stepLength -= omega * stepLength;\n    //  omega = 1.0;\n    //} else {\n    //  stepLength = signedRadius * omega;\n    //}\n    stepLength = signedRadius;\n\n    //previousRadius = radius;\n    float error = radius/t;\n\n    if(/*!sorFail &&*/ error < candidate_error) {\n      candidate_t = t;\n      candidate_error = error;\n    }\n\n    //if(!sorFail && error < pixelRadius || t > t_max) {\n    //  break;\n    //}\n\n    t += stepLength;\n  }\n\n  if(t > t_max || candidate_error > 1.0) { //(|| candidate_error > pixelRadius)&& !forceHit\n    return vec2(0.0,0.0);\n  }\n\n  return vec2(id,candidate_t);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  //shadertoy.com/view/4ssGzS\n  float step = 0.4;\n  float ao = 0.0;\n  float dist;\n  \n  for (float i=1.0;i<=4.0;i++) {\n    dist = step*i;\n    ao += max(0.0, (dist - distScene(p + n * dist).y) / dist);  \n  }\n  \n  return 1.0 - ao * 0.075;\n}\n\nvec3 calcMtrlCol(float id,vec3 p,vec3 n) {\n    vec3 col;\n  col=texture(iChannel0,vec2(id+0.494)).rgb;\n\n\n\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col=vec3(0.0);\n  vec2 rs=castRay(ro,rd);\n  float t = rs.y;\n\n  if(rs.x!=0.0) {\n    vec3 p = ro + t*rd;\n    vec3 n = calcNormal(p);\n    col=calcMtrlCol(rs.x,p,n);\n\tcol*=ambientOcclusion(p,n);\n      \n    //\n    vec3  r = normalize(reflect(rd,n));\n    vec3 ld = normalize(vec3(45.,30.,45.));\n    float d = max(dot(ld,n),0.);\n    float s = pow(max(dot(ld,r), 0.), 60.);\n    \n    if(castRay(p+ld*.01,ld).x != 0.) {\n       d = 0.12; s = 0.0; \n    }\n      \n    col = col*d+s;\n  }\n \n \n    \n  return vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n  float d=1.0/tan(fovy/2.0);\n  vec3 v=vec3(screen.x*aspect,screen.y,-d);\n  v=normalize(v);\n  return v;\n}\n\nmat3 orbitRot(float yaw,float pitch) {\n    vec2 s=vec2(sin(pitch),sin(yaw));\n    vec2 c=vec2(cos(pitch),cos(yaw));\n    return mat3(c.y,0.0,-s.y,s.y*s.x,c.x,c.y*s.x,s.y*c.x,-s.x,c.y*c.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 ms = iMouse.xy / iResolution.xy;\n  float aspect=iResolution.x/iResolution.y;\n  float fovy=0.7854;\n\n    vec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.25,0.9):ms;\n\n  float pitch=ms2.y*1.5-1.5;\n  float yaw=ms2.x*2.0-0.25;\n  mat3 viewRot=orbitRot(yaw,pitch);\n    \n\n  vec3 ro=viewRot*vec3(0.0,0.0,30.0)+vec3(0.0,2.0,0.0);\n  vec3 rd=viewRot*calcPrimaryRay(uv*2.0-1.0,fovy,aspect);\n          \n  vec3 c=vec3(uv,0.5+0.5*sin(iTime));\n  c=render(ro,rd);\n    \n  if(length((uv-ms)*vec2(aspect,1.0)) < 0.01) {\n    c=mix(c,vec3(1.0),0.2); \n  }\n    \n  fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttGDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtV3Wm", "name": "demosplash2016-cxw-03", "author": "cxw", "description": "Part 03: distance, clips, and compositing effects\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016", "tags": ["tutorial", "demoparty"], "likes": 1, "viewed": 378, "date": "1474990947", "time_retrieved": "2024-06-20T18:42:19.731469", "image_code": "precision highp int;precision highp float;\n\n// YOU WANT THIS: pages 3 and 4 of \n// https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf\n\nvec4 do_color(in float time, in vec2 coords)\n{\n    float whereami = \n        50.0*distance(vec2(0.5),coords) - 10.0*time;\n    //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^\n    //          frequency terms           phase terms\n    //\n    //  ^^^^ how many rings (50/2pi)      ^^^^ how fast they move (2pi/peak)\n    //\n    //       ^^^^^^^^^^^^^^^^^^^^^^^^^^ radial pattern\n    return vec4(0.0,0.0,\n                0.5+0.5*sin(whereami),  // render in the blue channel\n                1.0);\n} //do_color\n\nfloat do_window(in float time, in float x)\n{\n    float window_pos = abs(0.5*sin(time));\n        // from 0 to 0.5 and back, over and over again\n    return step(window_pos,  x);\n    //          ^^^^^^^^^^ > ^  => 0.0 else 1.0\n} //do_window\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 scene_color = do_color(t, uv);\n    float window =  1.0;    \n        // or how about this?  (cxw: reset time first)\n        // do_window(t, uv.x);\n    fragColor = scene_color * window;\n} //mainImage\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtV3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVGDR", "name": "Black Flower", "author": "Zeliss", "description": "I felt like making something interesting with just black and white.", "tags": ["2d", "circles", "flower", "animation"], "likes": 10, "viewed": 437, "date": "1474179358", "time_retrieved": "2024-06-20T18:42:20.004270", "image_code": "const float PI = 3.14159265358979; //Probably enough precision?\nconst float TAU = 2.0 * PI;\n\n//Returns how much coord is within a circle centered at circle_pos. [0, 1]\nfloat circle(vec2 circle_pos, vec2 coord)\n{\n    float circ_rad = 70.0;\n    float circ_blur = 1.0;\n    float dist = distance(circle_pos, coord);\n    return smoothstep(circ_rad + circ_blur, circ_rad - circ_blur, dist); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    vec2 center = iResolution.xy * vec2(0.5);\n    float t = iTime;\n    float d = 70.0*sin(t/PI); //Distance of each circle from the center. (Can be pos/neg)\n    \n    const float MAX_CIRCLES = 9.0; //Max number of circles.\n    float num_circles = MAX_CIRCLES/2.0 + MAX_CIRCLES/2.0*cos(t/PI) + 0.01; //Current number of circles.\n    float circles = 0.0; //The total number of circles this pixel is in.\n    \n    for (float f = 0.0; f < MAX_CIRCLES; f++) {\n        if (f < num_circles) { //Wish I could have non-const number of loop iterations :(\n        \tfloat ap = t + f/num_circles * TAU; //Angular position of each circle, [0, tau]\n        \tvec2 newCirclePos = center + d*vec2(cos(ap), sin(ap));\n        \tcircles += circle(newCirclePos, fragCoord); //If this pixel is in the new circle, circles increases.\n        }\n    }\n    \n    circles = (cos(circles*PI)+1.0)/2.0; //Smoothly interpolate between odd and even values.\n    fragColor = mix(black, white, circles);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVGRR", "name": "blok", "author": "wjbgrafx", "description": "Another domain repetition experiment.", "tags": ["3d", "raymarch", "domain", "repetition"], "likes": 9, "viewed": 557, "date": "1472739571", "time_retrieved": "2024-06-20T18:42:24.125818", "image_code": "/*\n\t\"blok\" by wjbgrafx\n\t\n\tbased on :\n\t\t\n\tRaymarched Reflections   Uploaded by Shane in 2015-Nov-17\n\thttps://www.shadertoy.com/view/4dt3zn\n\t\n\tPlaying with symmetries - Torus\t   by @paulofalcao\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n\tRaymarching Primitives - Created by inigo quilez - iq/2013\n\thttps://www.shadertoy.com/view/Xds3zN\n\n\tHG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n\thttp://mercury.sexy/hg_sdf\n\t\n\tArray and textureless GLSL 2D/3D/4D simplex noise functions.\n    Ian McEwan, Ashima Arts.\n\t\n\t2D and 3D Procedural Textures in WebGL\n\thttp://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t\n\tpyramid function from \"pyramids\"    Uploaded by avix in 2014-Jan-16\n\thttps://www.shadertoy.com/view/lsBGzG\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n#define PHI \t\t\t\t\t1.618033988749895\n\n#define FAR                     300.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_FOV_FACTOR          1.5\n#define LOOK_AT                 vec3( 0.0, 4.0, 0.0 )\n#define LIGHT_COLOR\t\t\t\tvec3( 1.0 )\n#define LIGHT_ATTEN\t\t\t\t0.01\n\n//------------------------------------------------------------------------------\n// Function declarations\n//----------------------\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID,\n                                                            in vec3 lightPos );\nfloat sdSphere( vec3 p, float s );\nfloat sdEllipsoid( in vec3 p, in vec3 r );\nfloat sdTorus( vec3 p, vec2 t );\n\nvec2 rot( vec2 p, float r );\nvec2 rotsim( vec2 p, float s );\n\nfloat pMod1(inout float p, float size); \nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset); \nvec2 pMirrorOctant (inout vec2 p, vec2 dist); \nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\nfloat fOctahedron(vec3 p, float r, float e);\n \nfloat pyramid( vec3 p, float h);  \nfloat modPyramid( vec3 p, float h, float baseScale ); \nfloat modOctahedron( vec3 p, float height, float scale );\nfloat modCutoutPyramid( vec3 p, float height, float scaleVal );\n\nfloat snoise(vec3 v);\n\n//==============================================================================\n// MAP\n// ---\n\nvec2 map( vec3 p )\n{  \n\tfloat dist = 3.0;\n\tpReflect( p, normalize( vec3( 1.0, -1.0, 0.0 ) ), dist );\n\tpReflect( p, normalize( vec3( -1.0, -1.0, 0.0 ) ), dist );\n\n\tpMod1( p.z, 20.0 );\n\tvec3 p2 = p;\n\n\tp2.xz = rot( p2.xz, iTime * 0.19 );\n\tp2.xz = rotsim( p2.xz, 3.0 );\n\tp2.z -= 6.0;\n\n\tpMirrorOctant( p.yz, vec2( 6.0 ) );\n\n\tfloat objID = 1.0;\t      \n\tvec2 obj1 = vec2( fPlane( p, vec3( 0.0, 1.0, 0.0 ), 5.0 ), objID );\n\t\n\tobjID = 2.0;\t\n\tvec2 obj2 = \n\tvec2( modCutoutPyramid( p2 - vec3( 0.0, -5.0, 0.0 ), 7.0, 1.45 ), objID );\n\t                                                                   \n\tp2.xz = rot( p2.xz, iTime * -0.73 );\n\n\tobjID = 3.0;\n\tfloat d1 = fOctahedron( p2 - vec3( 0.0, -1.8, 0.0 ), 1.6, 10.0 ),\n\t      d2 = sdEllipsoid( p2 - vec3( 0.0, -1.8, 0.0 ), vec3( 1.55, 1.55, \n\t                                                                   4.75 ) );\n\tvec2 obj3 = vec2(max( d1, -d2 ), objID );\n\t      \n\tp2.xz = rot( p2.xz, iTime * 1.23 );\n\n\tobjID = 4.0;\n\tvec2 obj4 = vec2( modOctahedron( p2 - vec3( 0.0, -1.8, 0.0 ), 1.4, 1.1 ), \n\t                                                                   objID );\t\n\tobjID = 5.0;\n\tvec2 obj5 = vec2( sdTorus( p2 - vec3( 0.0, -4.7, 0.0 ), vec2( 3.9, 0.25 ) ),\n\t                                                                  objID );\t\n\tobjID = 1.0;\n\tvec2 obj6 = vec2( sdSphere( p2 - vec3( 1.6, 0.9, 1.6 ), 0.5 ), objID );\n\t\t                                                                  \n\tvec2 obj7 = vec2( sdSphere( p2 - vec3( -1.6, 0.9, -1.6 ), 0.5 ), objID );\n\t\n\tvec2 obj8 = vec2( sdSphere( p2 - vec3( 1.6, 0.9, -1.6 ), 0.5 ), objID );\n\t\t                                                                  \n\tvec2 obj9 = vec2( sdSphere( p2 - vec3( -1.6, 0.9, 1.6 ), 0.5 ), objID );\n\t\n\tvec2 closest = obj1;\n\tclosest = closest.s < obj2.s ? closest : obj2;\n\tclosest = closest.s < obj3.s ? closest : obj3;\n\tclosest = closest.s < obj4.s ? closest : obj4;\n\tclosest = closest.s < obj5.s ? closest : obj5;\n\tclosest = closest.s < obj6.s ? closest : obj6;\n\tclosest = closest.s < obj7.s ? closest : obj7;\n\tclosest = closest.s < obj8.s ? closest : obj8;\n\tclosest = closest.s < obj9.s ? closest : obj9;\n\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID, vec3 rayDir )\n{    \n    vec3 clr = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tclr = vec3( 0.7, 0.8, 1.0 );\n\t}\n\telse if( objNum == 2.0 )\n    {\n\t\tfloat timeVal = 0.3 * sin( iTime * 0.13 );\n\t\tclr = vec3( 0.45 + timeVal, 0.55 + timeVal, 0.7 + timeVal ); \n\t\t\n\t\tvec3 pos = distID.s * rayDir;\n\t\tpos.z += iTime * 3.0; \n\t\t\n\t\tfloat scale = 0.5,\n\t\t      complexity = 2.0,\n\t\t      mixVal = 0.875;\n\n\t\t// 2D and 3D Procedural Textures in WebGL\n        // http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t\t// wjb modified Perlin Noise 3D \n\t\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t\t// on white background - texture 21\n\t\tvec3 v = pos * scale;\n\t\tfloat value = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n\t    value = 0.75 + value * 0.25;\n\t    vec3 color = vec3( 1.0 - value );  // inverted  \t\t    \n\t\tclr = mix( color, clr, mixVal ); \n\t}\n\telse if ( objNum == 3.0 )\n\t{\n\t\tfloat timeVal = 0.3 * sin( iTime * 0.17 );\n\t\tclr = vec3( 0.45 + timeVal, 0.55 + timeVal, 0.7 + timeVal );\n\t}\n\telse if ( objNum == 4.0 )\t\n\t{\n\t\tfloat timeVal = 0.3 * sin( iTime * 0.23 );\n\t\tclr = vec3( 0.65 + timeVal, 0.7 + timeVal, 0.5 + timeVal ); \n\t}\n\telse if( objNum == 5.0 )\n    {\n\t\tfloat timeVal = 0.3 * sin( iTime * 0.29 );\n\t\tclr = vec3( 0.7 + timeVal, 0.65 + timeVal, 0.5 + timeVal ); \n\t}\n\t    \n    return clr;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // cam position moves into tunnel and up/down, side to side\n    vec3 camPos = vec3( 2.0 * sin( iTime * 0.43 ), \n                  4.0 + 2.0 * sin( iTime * 0.51 ), \n                                   iTime * 3.0 );                               \n    vec3 lookAt = camPos + vec3( 0.0, 0.0, camPos.z + 10.0 );\n    vec3 rayDir = getRayDir( camPos, normalize( lookAt - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n    vec3 lightPos = vec3( 0.0, 0.0, \n         camPos.z + 10.0 + 30.0 * sin( ( 20.0 + iTime ) * \n                                                   ( 0.04 * log( iTime ) ) ) );\n\tvec3 sceneColor = vec3( 0.0 );\n\tfloat timeVal = 0.3 * sin( iTime * 0.31 );\n\tvec3 skyClr  = vec3( 0.4 + timeVal, 0.5 + timeVal, 0.7 + timeVal ); \n\t\t                \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( ( camPos.z + FAR ) * 0.4, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID, lightPos );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID, lightPos ) \n\t                                                                    * 0.35;\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    sceneColor *= fog;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n    \n}\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\n// Standard raymarching routine.\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\n// Second pass, which is the first, and only, reflected bounce. Virtually the \n// same as above, but with fewer iterations and less accuracy.\n\n// The reason for a second, virtually identical equation is that raymarching is \n// usually a pretty expensive exercise, so since the reflected ray doesn't \n// require as much detail, you can relax things a bit - in the hope of speeding \n// things up a little.\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft  \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow \n    // things down. Obviously, the lowest number to give a decent shadow is the \n    // best one to choose. \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n\n        //shade = min( shade, k * h / dist );\n        // Subtle difference. Thanks to IQ for this tidbit.\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n\n        // So many options here, and none are perfect: dist += min( h, 0.2 ),etc\n        dist += min( h, stepDist * 2.0 ); \n        \n        // Early exits from accumulative distance function calls tend to be a \n        // good thing.\n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. \n    // It's a preference thing. Really dark shadows look too brutal to me.\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID,\n                                                             in vec3 lightPos )\n{    \n    // Light direction vector.\n    //vec3 lDir = LIGHT_POS - sp; \n    vec3 lDir = lightPos - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    // wjb added rayDir as argument in order to allow texturing of objects.\n    vec3 objCol = getObjectColor( sp, distID, rayDir );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + LIGHT_COLOR * spec * 2.0 ) * \n                                                                         atten;\n  \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// Horizontal torus lying in xz plane at y = 0; t = vec2( lg. diam, sm. diam )\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//------------------------------------------------------------------------------\n\n// From Playing with symmetries - Torus\t   by @paulofalcao\t\n// http://glslsandbox.com/e#29755.0\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------\n// HG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n// http://mercury.sexy/hg_sdf\n\n// Sign function that doesn't return 0\nfloat sgn(float x) \n{\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) \n{                           \n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) \n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) \n{\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\t\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> \n// from the origin.\nfloat pMirror (inout float p, float dist) \n{\n\tfloat s = sgn(p); \n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) \n{\n\tvec2 s = sgn(p);\t\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n//------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/lsBGzG\n// Pyramid with base on xz-plane at y=0.0, h = height, width, and depth\nfloat pyramid( vec3 p, float h) \n{\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\n}\n\n//------------------------------------------------------------------------------\n\n// Modified from pyramid(), above.\n// Pyramid with base on xz-plane at y=0.0, h = height, s = scaling factor for\n// length of an edge of the square pyramid base, where edge length = s * h, \n// i.e., h = 2.0, s = 0.5, base edge = 1.0; or h = 2.0, s = 2.0, base edge = 4.0\n// s MUST BE >= 0.5\n                        \nfloat modPyramid( vec3 p, float h, float s ) \n{\n\tvec3 q = abs( p );\n\tfloat scale = 1.0 / s;\n\treturn max( -p.y, ( q.x * scale + q.y + q.z * scale - h ) / 3.0 );\n}\n\n//------------------------------------------------------------------------------\n// wjb : This should replace cutoutPyramid, as it allows adjustment of size of\n// cutout.\nfloat modCutoutPyramid( vec3 p, float height, float scaleVal )\n{\n\tvec3 p2 = p;\n\tp2.xz = rot( p2.xz, PI * 0.25 );\n\t\n\tfloat d1 = pyramid( p2, height ),\n\t      d2 = modPyramid( p - vec3( 0.0, 0.1, 0.0 ),  \n\t                                       height * ( scaleVal / 1.5 ), 1.35 );\n\treturn max( d1, -d2 );\n}\n//------------------------------------------------------------------------------\n// wjb: Joining two modPyramids to form an octahedron with variable base length.\n// scale MUST BE >= 0.5\n\nfloat modOctahedron( vec3 p, float height, float scale )\n{\n\tfloat d1 = modPyramid( p, height, scale );\n\tp.yz = rot( p.yz, PI );\n\tfloat d2 = modPyramid( p, height, scale );\n\treturn min( d1, d2 );\t\t\n}\n//------------------------------------------------------------------------------\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n// wjb note - This is the code from first version, newer version crashes Nvidia\n// Macro based version for GLSL 1.2 / ES 2.0\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging \n// of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n//------------------------------------------------------------------------------\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D and 2D Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ---------------------------------\n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), \n                                                                  dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), \n                                                                           0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n\n//------------------------------------------------------------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVGWR", "name": "Superformula Experiments (2D)", "author": "camargo", "description": "Experiments with the \"superformula\" in 2D. \n\nRef: https://en.wikipedia.org/wiki/Superformula", "tags": ["2d", "superformula"], "likes": 0, "viewed": 155, "date": "1474144868", "time_retrieved": "2024-06-20T18:42:24.580418", "image_code": "// Superformula Experiments (2D)\n// Chris Camargo, September 2016\n\n// Shapes.\n// Try out shapes 1 - 8.\n#define SHAPE 7\n\n// Superforluma.\nfloat super(float phi, float a, float b, float n1, float n2, float n3, float y, float z)\n{\n    float abs1 = pow(abs( cos( (y * phi) / 4.0) / a ), n2);\n    float abs2 = pow(abs( sin( (z * phi) / 4.0) / b ), n3);\n    float pow1 = -(1.0/n1);\n\n    return pow(abs1  +  abs2, pow1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Map coords to [0, 1].\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    // Map coords to [-1, 1].\n    vec2 q = -1.0 + 2.0*p;\n    \n    // Scale x based on aspect ratio.\n    q.x *= iResolution.x / iResolution.y;\n    \n    // Zoom out (i.e. make all coords larger).\n    q *= 2.0;\n    \n    // Final shape color.\n    vec3 col = vec3(p, 0.5+0.5*sin(iTime));\n    \n    // Superformula params (set SHAPE number to see different shapes).\n\n    float phi = atan(q.y, q.x);\n    \n#if SHAPE == 1\n    float a = 1.0, b = 1.0, n1 = 3.0, n2 = 1.0, n3 = 1.0, y = 4.0, z = 6.0;\n#endif\n    \n#if SHAPE == 2\n    float a = 1.0, b = 1.0, n1 = 2.0, n2 = 1.0, n3 = 1.0, y = 6.0, z = 3.0;\n#endif\n\n#if SHAPE == 3\n    float a = 1.0, b = 1.0, n1 = 1.5, n2 = 1.0, n3 = 1.0, y = 2.0, z = 10.0;\n#endif\n\n#if SHAPE == 4\n    float a = 1.0, b = 1.0, n1 = -1.5, n2 = 1.0, n3 = 1.0, y = 2.0, z = 10.0;\n#endif\n\n#if SHAPE == 5\n    q *= 10.0; // Zoom out more.\n    float a = 1.0, b = 1.0, n1 = -0.2, n2 = 1.0, n3 = 1.0, y = 2.0, z = 44.0;\n#endif\n\n#if SHAPE == 6\n    q *= 15.0; // Zoom out more.\n    float a = 1.0, b = 1.0, n1 = -0.2, n2 = 1.0, n3 = 1.0, y = 8.0, z = 40.0;\n#endif\n\n#if SHAPE == 7\n    float a = 1.0, b = 1.0, n1 = 3.0, n2 = 1.0, n3 = 1.0, y = 88.0, z = 64.0;\n#endif\n    \n#if SHAPE == 8\n    float a = 1.0, b = 1.0, n1 = -20.0, n2 = 1.0, n3 = 1.0, y = 88.0, z = 64.0;\n#endif\n\n    // Calculate the radius using the superformula.\n    float r = super(phi, a, b, n1, n2, n3, y, z);\n    \n    // \"Graph\" the superformula using smoothstep.\n    // \t\tAny pixels <= r away from q are colored\n    //\t\tAny pixels > r + 0.03 away from q are black.\n    col *= smoothstep(r + 0.03, r, length(q));\n    \n    // Output final color.\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVGWw", "name": "Crazier Galaxies", "author": "vox", "description": "Crazier Galaxies", "tags": ["craziergalaxies"], "likes": 0, "viewed": 380, "date": "1474936828", "time_retrieved": "2024-06-20T18:42:25.634879", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0/GR/PI/E)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling+stretch*2.0*PI;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling+extraTurns*2.0*PI;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time*PI*4.0), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    return final;\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n    }\n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0);\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv0, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        \n        antispeckle = stretch;\n\n\n        float draw = border*(1.0-color.a);\n\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        \n        color += clamp( galaxy((p.xy)*2.0-1.0)*draw*border, 0.0, 1.0);//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n\n    \n    \tfragColor = vec4(color);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtVGzD", "name": "Learning primitives", "author": "lobachevscki", "description": "First shader. Just learning the basics from a similar shader of iquilez you can find here https://www.shadertoy.com/view/Xds3zN\n\nNot much was changed, this was my first time with GLSL so i just focused on understanding the syntax and functions.", "tags": ["raymarching"], "likes": 5, "viewed": 656, "date": "1474251202", "time_retrieved": "2024-06-20T18:42:27.416854", "image_code": "// Created by Julián Rojas Millán - lobachevscki/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Learning distance functions simple primitives, and examples on how to \n// operate with them aswell as the render process involved.\n//\n// This is base don Iñigo Quilez original shader that you can find here\n// https://www.shadertoy.com/view/Xds3zN\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n//----------------------------------------------------------------------\n\nfloat sdPlane (vec3 p)\n\n{\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) -b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n\treturn (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n\tvec3 q = abs(p);\n#if 0\n    return max(q.z -h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0))+min(max(d1,d2), 0.0);\n#endif\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return length(pa -ba*h) -r;\n}\n\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n\tvec3 q = abs(p);\n#if 0\n\treturn max(q.z-h.y, max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z -h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2),0.0);\n#endif\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(in vec3 p, in vec3 c)\n{\n\tvec2 q = vec2(length(p.xz),p.y);\n    float d1 = -q.y-c.z;\n    float d2 = max(dot(q,c.xy),q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\n\nfloat sdConeSection(in vec3 p, in float h, in float r1, in float r2)\n{\n\tfloat d1 = -p.y -h;\n    float q = p.y -h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max(sqrt(dot(p.xz,p.xz)*(1.0-si*si)) + q*si-r2, q);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2),0.0);\n}\n\nfloat length2(vec2 p)\n{\n return sqrt(p.x*p.x + p.y*p.y);   \n}\n\nfloat length6(vec2 p)\n{\n    p=p*p*p; p=p*p;\n    return pow(p.x+p.y,1.0/6.0);\n}\n\nfloat length8(vec2 p)\n{\n\tp=p*p; p=p*p; p=p*p;\n    return pow(p.x+p.y, 1.0/8.0);\n}\n\nfloat sdTorus82(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q) -t.y;\n}\n\nfloat sdTorus88(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q) -t.y;\n}\n\nfloat sdCylinder6(vec3 p, vec2 h)\n{\n\treturn max(length6(p.xz)-h.x, abs(p.y)-h.y);\n}\n\n//----------------------------------------------------------------------\n\nfloat opS(float d1, float d2)\n{\n\treturn max(-d2,d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1:d2;\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n\treturn mod(p,c) -0.5*c;\n}\n\nvec3 opTwist(vec3 p)\n{\n\tfloat c = cos(10.0*p.y+10.0);\n    float s = sin(10.0*p.y+10.0);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.35,-2.0), 0.075 ), 200.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 56 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 0.0,0.25, 0.0), vec3(0.15), 0.1 ), 150.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-2.0,0.2, 1.0), vec3(-2,.5,1), 0.1  ), 320) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),65 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3(-1.3,0.10,-0.1), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3( 1.0,0.25, 1.0), vec2(0.20,0.05) ),1250 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),252 ) );\n\n    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 0.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  pos-vec3( 1.0,0.30,-1.0), vec2(0.20,0.1)),\n\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n                                       65.0 ) );\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 85) );\n\n    res = opU( res, vec2(sdConeSection( pos-vec3( 1.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 120 ) );\n\n    res = opU( res, vec2(sdEllipsoid( pos-vec3(-1.0,0.25, 2.0), vec3(0.15, 0.2, 0.05) ), 65 ) );\n        \n    return res;\n\n\n}\n\n//----------------------------------------------------------------------\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for (int i=0; i<16; i++)\n    {\n    \tfloat h = map(ro+rd*t).x;\n        res = min(res, 8.0*h/t);\n        t +=  clamp(h, 0.02, 0.10);\n        if(h<0.001 || t>tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal (in vec3 pos)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        \tmap(pos+eps.xyy).x - map(pos - eps.xyy).x,\n            map(pos+eps.yxy).x - map(pos - eps.yxy).x,\n    \t\tmap(pos+eps.yyx).x - map(pos - eps.yyx).x);\n    \n    return normalize(nor);\n}\n\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for (int i=0; i<5; i++)\n    {\n    \tfloat hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos = nor*hr + pos;\n        float dd = map(aopos).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    \n    return clamp(1.0 - 3.0*occ, 0.0,1.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.5 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    \n    return mat3(cu,cv,cw);\n}\n\n\n\n//----------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\n    vec2 q = fragCoord.xy /iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time = 15.0 +iTime;\n    \n    // camera\n    vec3 ro = vec3(-0.5+3.5*cos(0.1*time+6.0*mo.x), 1.0+2.0*mo.y, 0.5+3.5*sin(0.1*time+6.0*mo.x));\n    vec3 ta = vec3(-0.5,-0.4,0.5);\n    \n    //camera to world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // ray direction\n    vec3 rd = ca*normalize(vec3(p.xy,2.0));\n    \n    //render\n    \n    vec3 col = render(ro, rd);\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xty3Dw", "name": "IFS Display", "author": "vox", "description": "Display", "tags": ["ifs", "display"], "likes": 1, "viewed": 345, "date": "1474835740", "time_retrieved": "2024-06-20T18:42:28.574512", "image_code": "//-----------------SETTINGS-----------------\n\n//#define TIMES_DETAILED (sin(time*32.0)+1.0)\n#define TIMES_DETAILED (1.0+.1*sin(time*PI*1.0))\n#define SPIRAL_BLUR_SCALAR (1.0+.1*sin(time*PI*1.0))\n\n//-----------------USEFUL-----------------\n\n#define MOUSE_X (iMouse.x/iResolution.x)\n#define MOUSE_Y (iMouse.y/iResolution.y)\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS 10.0/max(iResolution.x, iResolution.y)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define time ((saw(float(__LINE__))+1.0)*(iTime+12345.12345)/PI/2.0)\n#define sphereN(uv) (normalize(vec3((uv).xy, sqrt(clamp(1.0-length((uv)), 0.0, 1.0)))))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\nfloat seedling;\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n//-----------------SIMPLEX-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\n//-----------------RENDERING-----------------\nfloat zoom;\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    \n    return res;\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nfloat magnification;\nvec2 tree(vec2 uv)\n{\n    float w1 = saw(time);\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = scale(square, vec2(2.0));\n    square = translate(square, vec2(-1.0));\n    \n    //square = scale(square, (1.0-saw(uv.xy))*vec2(saw(t1)+.5));\n    \n    square = RotateZ(square, time+seedling);\n    \n    float t1 = time;\n    float t2 = time;\n    square = scale(square, vec2(saw(uv.y+t2+seedling)*.25+.75));\n    \n    square = scale(square, vec2(.5));\n    square = translate(square, vec2(.5));\n    \n    \n    float t = time;\n    vec3 f = flux(time);\n    \n    \n    vec2 dxdy = sqrt(4.0)/iResolution.xy;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(1.0, \t0.0);\n    vec2 c = uv+vec2(0.0, \t\t1.0);\n    \n    vec2 a2 = invBilinear(a, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 b2 = invBilinear(b, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    vec2 c2 = invBilinear(c, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    \n    magnification = abs(cross(square[3].xy-square[0].xy, square[1].xy-square[0].xy)/cross(b2-a2, c2-a2));\n    \n    return saw(a2);\n}\n\nfloat draw(vec2 uv)\n{\n    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \tconst int max_i = 8;\n    float stretch = 1.0;\n    float ifs = 1.0;\n    float depth = 0.0;\n    float zoom = 1.5+saw(time);\n    \n    uv = uv*2.0-1.0;\n    uv *= zoom;\n    uv = uv*.5+.5;\n    for(int i = 0; i < max_i; i++)\n    {\n        seedling = float(i)/float(max_i);\n        vec2 next = tree((uv));\n        ifs /= magnification+1.0;\n    \tfloat weight = pow(ifs, 1.0/float(i+1)/2.0);\n        depth += (length(uv*2.0-1.0))*weight;\n        uv = saw(time+(next*2.0-1.0)*weight);//*weight+vec2(.5)*(1.0-weight);//*weight+uv*(1.0-weight);\n    }\n    \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n    \n    depth /= float(max_i)/5.0;\n\n    float weight = pow(ifs, 1.0/float(max_i)/2.0);\n\n    float black = smoothstep(0.0, 1.0/5.0, saw(depth-time));\n    float white = smoothstep(4.0/5.0, 1.0, saw(depth-time));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*weight;\n    fragColor = vec4(clamp(sqrt(weight), 0.0, 1.0)*(flux(time+depth)*black+white), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xty3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xty3W1", "name": "Space ocean", "author": "axelduch", "description": "Juju", "tags": ["music", "light", "space", "ocean"], "likes": 4, "viewed": 248, "date": "1474327957", "time_retrieved": "2024-06-20T18:42:28.574512", "image_code": "# define CLIP_FAR 1000.0\n# define STOP_THRESHOLD 0.008\n# define MAX_ITERATIONS 64\n# define PI 3.14159265359\n# define DEG_TO_RAD 3.14159265359 / 180.0\n    \nfloat dist_sphere (vec3 pos, float r) {\n    return length(pos) - r;\n}\n\nfloat dist_field (vec3 pos) {\n    float bigPlanetR = 1.35;\n    float bigPlanet = dist_sphere(pos, bigPlanetR);\n    float res = bigPlanet;\n    \n    const float l = 2.0;\n    for (float i = 8.0; i >= 0.0; i -= 0.15) {\n        vec3 imperfectionPos = vec3(pos);\n        float imperfectionR = max(0.0001 * i, 0.00001);\n        imperfectionPos.x = imperfectionR * (bigPlanetR + imperfectionR * 1.0);\n        imperfectionPos.y = (i - l) * (imperfectionR) * (bigPlanetR + imperfectionR * 1.0);\n        imperfectionPos.z -= imperfectionPos.y;\n        float imperfection = dist_sphere(imperfectionPos, imperfectionR);\n        res = min(res, imperfection);\n    }\n    \n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.1);\n        smallPlanetPos.x += cos(-iTime * 0.7 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += sin(-iTime * 0.3 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 + smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.1);\n        smallPlanetPos.x += sin(-iTime * 0.9 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += cos(-iTime * 0.8 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 - smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.1);\n        smallPlanetPos.x += sin(-iTime * 0.3 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += cos(-iTime * 0.1 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 - smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.19);\n        smallPlanetPos.x += sin(-iTime * 0.1 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += cos(-iTime * 0.15 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 - smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    \n    return res;\n}\n\nfloat ray_march(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        float dist = dist_field(ro + rd * depth);\n        \n        if (dist < STOP_THRESHOLD) {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= CLIP_FAR) {\n            return CLIP_FAR;\n        }\n    }\n    \n    return CLIP_FAR;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\nvec3 shading(vec3 pos, vec3 n, vec3 ro, vec2 uv) {\n    vec3 lightPos = vec3(20.0, 20.0, 20.0);\n    vec3 lightColor = vec3(uv,0.5+0.5*sin(iTime));\n    \n    vec3 Normal     = vec3(uv.x, uv.y, sqrt(n.z));\n\n    float t = iTime;\n\tfloat U = 1.0-atan(Normal.z, Normal.x) / (2.0* PI);\n\tfloat V = 1.0-(atan(length(Normal.xz), Normal.y)) / PI;\n \tvec3 Ground = pow(texture(iChannel0, vec2(U - t/4.0, V)).xyz, vec3(2.22));\n    \n    lightColor = mix(lightColor, vec3(1.0), Ground);\n    \n    vec3 vl = normalize(lightPos - ro);\n    \n    float ambient = 0.8;\n    float diffuse = max(0.0, dot(vl, n));\n    \n    // specular\n    vec3 ev = normalize(pos - ro);\n    vec3 ref_ev = reflect(ev, n);\n    float specular = max(0.0, dot(vl, ref_ev));\n    \n    return lightColor * (ambient + diffuse + specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = ray_dir(20.0 + sin(iTime * 2.0), iResolution.xy, fragCoord.xy );\n    \n    float depth = ray_march(ro, rd);\n    \n    if (depth >= CLIP_FAR) {\n    \tfragColor = vec4(vec3(0.0), 1.0);\n        fragColor = vec4(vec3(uv,0.5+0.5*sin(iTime)), 1.0);\n        return;\n    }\n    \n    \n    vec3 pos = ro + rd * depth;\n    \n    fragColor = vec4(shading(pos * 1.1, pos * 1.0, ro * 1.0, uv * 0.59), 1.0);\n}\n\n", "image_inputs": [{"id": "Xd2GRD", "previewfilepath": "https://soundcloud.com/axel-duch/dans-le-sourire-des-oceans", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/axel-duch/dans-le-sourire-des-oceans", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xty3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtyGD1", "name": "Sierpinski Floater", "author": "Zanzlanz", "description": "I was accidentally challenged by @CacheFlowe to make a Sierpinski Gasket in a fragment shader. It was fun to make, as usual!\nI would love something like this as a screensaver!", "tags": ["2d", "triangle", "sierpinski", "gasket", "sieve"], "likes": 7, "viewed": 454, "date": "1474357871", "time_retrieved": "2024-06-20T18:42:28.907969", "image_code": "// By Zanzlanz\n// Creative commons with attribution, please - Sorry for ugly code btw :)\n\nfloat exp2Iterations = 4.0; // Gets changed in realtime. Iterations the fragment will calculate.\nbool tri(float x, float y) {\n    return (x+y < 1.0);\n}\n// I just needed a bitwise &. Ah well, here's a function that does it:\nfloat and(vec2 n) {\n\tif(n.x<0.0 || n.y<0.0 || n.x>=exp2Iterations || n.y>=exp2Iterations) return -1.0;\n\tfloat bitVal = 1.0;\n\tfloat result = 0.0;\n\tfor(int i=0; i<32; i++) {\n\t\tif (mod(n.x, 2.0) == 1.0 && mod(n.y, 2.0) == 1.0) result+=bitVal;\n\t\tn = floor(n / 2.0);\n\t\tbitVal *= 2.0;\n\t\tif(!(n.x > 0.0 || n.y > 0.0)) break;\n\t}\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    exp2Iterations = exp2( floor(sin(iTime+uv.y*2.0+uv.x*1.0+1.5+sin(uv.y*15.0)*.05)*4.0+4.5) );\n     \n    float scale = (sin(iTime*.4+3.0)*.4+.9)*exp2Iterations; // Pulsating\n    \n    // Movement around screen\n    uv.y -= .3*sin(iTime*.43) + .5;\n    uv.x -= .3*sin(iTime*.33) + .5+(iResolution.x-iResolution.y)/iResolution.y*.5;\n    \n    // Use polar coordinates to do funky rotation stuff\n\tfloat d = length(uv);\n\tfloat r = atan(uv.y, uv.x);\n\tr += .6+(1.0-d*.5)*sin(iTime*.3)*3.0;\n    uv = vec2(d*cos(r), d*sin(r));\n    \n    uv*=scale; // Scale it properlyish\n    \n    // Center on centroid so rotation looks good\n    uv.x+=exp2Iterations*.5;\n    uv.y+=exp2Iterations*.5/sqrt(3.0);\n    \n    uv.y/=sqrt(3.0)/2.0; // ...then make it equilateral!\n    uv.x-=uv.y*.5;       // Convert graph to isosceles first...\n    \n    // If x&y==0 and point lies under triangle, we're on the triangle! Woot!\n    if(and(floor(uv)) == 0.0 && tri(mod(uv.x, 1.0), mod(uv.y, 1.0)))\n\t\t fragColor = vec4(fragCoord/iResolution.xy, 1.0, 1.0);\n    else fragColor = vec4(fragCoord.xy/iResolution.xy*.1, 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtyGDR", "name": "IFS_Tree_01", "author": "EvilRyu", "description": "Just have fun", "tags": ["2d", "ifs"], "likes": 19, "viewed": 741, "date": "1474296185", "time_retrieved": "2024-06-20T18:42:28.914135", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define PI ( (asin(1.)*(sqrt(5.)*.5-.5)*2.718281828) + cos(iTime/8.0)*0.5)\n//#define PI (asin(1.)*(sqrt(5.)*.5-.5)*2.718281828)\n#define PI 3.1415926535\n\nmat3 m_rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3( c, s, 0, -s, c, 0, 0, 0, 1);\n}\nmat3 m_trans(float x, float y)\n{\n    return mat3(1., 0., 0., 0., 1., 0, -x, -y, 1.);\n}\nmat3 m_scale(float s)\n{\n    return mat3(s, 0, 0, 0, s, 0, 0, 0, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 pos = (fragCoord.xy - iResolution.xy*.5) / iResolution.yy;\n   \n    pos*=6.0;\n    pos.y+=1.9;\n   \tvec3 p = vec3(pos, 1.);\n    float d = 1.0;\n    float iter = mod(floor(iTime), 20.0);\n    float len = fract(iTime);\n    for(int i = 0; i < 20; ++i)\n    {\n        if(i<=int(iter+0.5))\n        {\n            d=min(d,(length(max(abs(p.xy)-vec2(0.01,1.0), 0.0)))/p.z);\n            p.x=abs(p.x);\n        \tp=m_scale(1.22) * m_rot(0.25*PI) * m_trans(0.,1.) * p;\n        }\n        else\n        {\n            d=min(d,(length(max(abs(p.xy)-vec2(0.01,len), 0.0)))/p.z);\n        }\n    }\n    d=smoothstep(0.1, 0.15,d);\n\tfragColor = vec4(d,d,d,1.);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtyGRW", "name": "Golden shadow lines", "author": "rush_2112", "description": "Basic function for 2D background w/ shadow sim.", "tags": ["2dshadowlines"], "likes": 2, "viewed": 122, "date": "1473351242", "time_retrieved": "2024-06-20T18:42:28.914135", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat ca = 0.0325; // Intensity\n\tfloat cb = 0.110; // Freq\n\tfloat gt = iTime;\n\tfloat gtc = 4.5 + (gt * 0.10250);\n\tfloat algo = 0.0;\n        \t\n    algo += (2.23 * ca * 1.0) * tan(((1.0-uv.x) * 1.63 * gtc)*(uv.y * 0.87 * gtc) * 1.00 * cb);    \n\talgo += (1.51 * ca * 1.0) * fract((uv.x * 0.241 * gtc)*(uv.y * 0.57 * gtc) * 3.00 * cb);\n\talgo += (5.03 * ca * 1.0) * cos((uv.x * 0.16 * gtc)+(uv.y * 0.53 * gtc) * 4.00 * cb);\n\talgo += (1.29 * ca * 21.0) * sin((uv.x * 0.140 * gtc)*(uv.y * 0.81 * gtc) * 4.00 * cb);\n\talgo += (0.21 * ca * 1.0) * fract((uv.x * 0.06 * gtc)+((1.0 + uv.y) * 0.68 * gtc) * 2.00 * cb);\n\talgo += (5.61 * ca * 1.0) * fract((uv.x * 0.54 * gtc)*(uv.y * 0.20 * gtc) * 1.00 * cb);\n\talgo += (10.51 * ca * 1.0) * fract((uv.x * 0.39 * gtc)+(uv.y * 0.38 * gtc) * 2.00 * cb);\n\talgo += (1.26 * ca * 1.0) * atan((uv.x * 0.22 * gtc)*((1.0-uv.y) * 0.238 * gtc) * 4.00 * cb);\n        \n    fragColor = vec4(algo, algo*0.7, algo*0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtyGzh", "name": "Lindenmayer Systems", "author": "sillsm", "description": "Trees with breeze", "tags": ["2d", "distancefield", "ifs", "lsystem"], "likes": 119, "viewed": 4059, "date": "1472935029", "time_retrieved": "2024-06-20T18:42:30.186798", "image_code": "// Copyright Max Sills 2016, licensed under the MIT license.\n//\n// Real time lindenmayer systems.\n// Reference: http://algorithmicbotany.org/papers/abop/abop-ch1.pdf\n// Figures d, e, f from pg. 25. \"Bracketed OL systems\".\n// \n// Inspired by Knighty's using base n encodings to explore\n// n-ary IFS. Bounding volumes are trash.\n//\n// Enormous thanks to iq for numerous bugfixes and optimizations!\n#define PI 3.14159\n#define MAXDEPTH 7\n\nmat3 Rot (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n); \n}\n\nmat3 Disp (vec2 displacement)\n{\nreturn  mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(displacement, 1)\n); \n}\n\nfloat sdCappedCylinder( vec2 p, vec2 h )\n{\n  p -= vec2(0.,h.y);\n  vec2 d = abs(vec2(length(p.x),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat left(vec2 pt)\n{\n    mat3 posR = Rot(-(20./360.)*2.*PI);\n    mat3 negR = Rot(20./360.*2.*PI);\n    \n    const int depth = 6;\n    const int branches = 3; \n    int maxDepth = int(pow(float(branches) , float(depth )));\n    float len = 1.7;\n    float wid = .01;\n    pt = pt + vec2(0,2);  \n    mat3 m1 = posR*Disp(vec2(0,-len));\n    \n    float trunk = sdCappedCylinder(pt-vec2(0.,0.), vec2(wid,len));\n    float d = 500.;\n    \n    int c = 0; // Running count for optimizations\n    \n    for (int count = 0; count <= 100; ++count){\n      int off = int(pow(float(branches), float(depth)));\n        \n      vec2 pt_n = pt;\n      for (int i = 1; i <= depth; ++i)\n      {\n        float l = len/pow(2.,float(i));\n         \n        //\n        off /= branches; \n        int dec = c / off;\n        int path = dec - branches*(dec/branches); //  dec % kBranches\n          \n        mat3 mx;\n\t    if(path == 0){\n\t\t  mx=posR*Disp(vec2(0,-2.*l));\n\t    }\n        else if(path == 1){\n          mat3 wind = Rot(0.5*sin(iTime + 2.));\n          mx = wind*posR * Disp(vec2(0,-4.*l));\n\t    }\n\t    else if(path == 2){\n          mat3 wind = Rot(0.2*sin(iTime));\n          mx = wind*negR * Disp(vec2(0,-4.*l));\n\t    }\n        pt_n = (mx * vec3(pt_n,1)).xy;\n        float y = sdCappedCylinder(pt_n, vec2(wid,l));\n        \n        // Early bail out. Bounding volume is a noodle of radius\n        // 2. * l around line segment.\n        if( y-2.0*l > 0.0 ) { c += off-1; break; }\n          d = min( d, y );\n     }\n        \n    ++c;\n    if (c > maxDepth) break;\n    }\n   return min(d,trunk);\n}\n\nfloat center(vec2 pt)\n{\n    \n    mat3 posR = Rot(-(25.7/360.)*2.*PI);\n    mat3 negR = Rot(25.7/360.*2.*PI);\n    \n    const int depth = 7;\n    const int branches = 3; \n    int maxDepth = int(pow(float(branches) , float(depth )));\n    float len = 1.7;\n    float wid = .01;\n    pt = pt + vec2(0,2);  \n    mat3 m1 = posR*Disp(vec2(0,-len));\n    \n    float trunk = sdCappedCylinder(pt-vec2(0.,0.), vec2(wid,len));\n    float d = 500.;\n    \n    int c = 0; // Running count for optimizations\n    for (int count = 0; count <= 100; ++count){\n      int off = int(pow(float(branches), float(depth)));\n      vec2 pt_n = pt;\n      for (int i = 1; i <= depth; ++i)\n      {\n        float l = len/pow(2.,float(i));\n          \n        \n        off /= branches; \n        int dec = c / off;\n        int path = dec - branches*(dec/branches); //  dec % kBranches\n          \n        mat3 mx;\n\t    if(path == 0){\n\t\t  mx = posR*Disp(vec2(0,-2.*l));\n\t    }\n        else if(path == 1){\n          mat3 wind = Rot(0.2*sin(iTime+6.2));\n          mx = wind*negR*Disp(vec2(0,-2.*l));\n\t    }\n\t    else if(path == 2){\n          mat3 wind = Rot(0.2*sin(iTime+1.));\n          mx = wind*Disp(vec2(0,-4.*l)) ;\n\t    }\n        \n        pt_n = (mx * vec3(pt_n,1)).xy;\n        float y = sdCappedCylinder(pt_n, vec2(wid,l));   \n          \n        // Early bail out. Bounding volume is a noodle of radius\n        // 2. * l around line segment.\n        if( y-2.0*l > 0.0 ) { c += off-1; break; }\n          d = min( d, y );\n     }\n        \n    ++c;\n    if (c > maxDepth) break;\n    }\n   return min(d,trunk); \n}\n\n// Primitive shape for the right l-system.\nfloat right_p(vec2 pt, float wid, float len)\n{\n    mat3 posR = Rot(-(22.5/360.)*2.*PI);\n    \n    float t1 = sdCappedCylinder(pt, vec2(wid,len));\n    vec2 pt_t2 = (posR*Disp(vec2(0,-2.*len))* vec3(pt,1)).xy;\n    float t2= sdCappedCylinder(pt_t2, vec2(wid,len/2.));\n    return min(t1, t2);\n}\n\nfloat right(vec2 pt)\n{\n    mat3 posR = Rot(-(22.5/360.)*2.*PI);\n    mat3 negR = Rot(22.5/360.*2.*PI);\n    \n    const int depth = 4;\n    const int branches = 4; \n    int maxDepth = int(pow(float(branches) , float(depth )));\n    float len = 1.3;\n    float wid = .01;\n    pt = pt + vec2(0,2);  \n    mat3 m1 = posR*Disp(vec2(0,-len));\n    \n    float trunk = right_p(pt, wid, len);\n    float d = 500.;\n    \n    int c = 0; // Running count for optimizations\n    for (int count = 0; count <= 110; ++count){\n    \n    int off = int(pow(float(branches), float(depth)));\n    vec2 pt_n = pt;\n                \n      for (int i = 1; i <= depth; ++i)\n      {\n        float l = len/pow(2.,float(i));\n        \n        off /= branches; \n        int dec = c / off;\n        int path = dec - branches*(dec/branches); //  dec % kBranches\n          \n        mat3 mx;\n\t    if(path == 0){\n\t\t  mx = negR*Disp(vec2(0,-2.*l));\n\t    }\n        else if(path == 1){\n          mat3 wind = Rot(.6*sin(iTime/2.));\n\t\t  mx = wind*negR*Disp(vec2(0,-4.*l));\n\t    }\n        else if(path == 2){\n          // This branch overlaps the first, so you don't\n          // immediately see its effects.\n          mx = Disp(vec2(0,-2.*l));\n\t    }  \n\t    else if(path == 3){\n          mx = Disp(vec2(0,-2.*l))*posR*Disp(vec2(0,-4.*l));\n\t    }\n\n         pt_n = (mx* vec3(pt_n,1)).xy; \n         float y = right_p(pt_n, wid, l); \n          \n        // Early bail out. Bounding volume is a noodle of radius\n        // 2. * l around line segment.\n        if( y-3.0*l > 0.0 ) { c += off-1; break; }\n          d = min( d, y );\n     }\n        \n    ++c;\n    if (c > maxDepth) break;\n    }\n   return min(d,trunk);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 5.;\n    \n    fragColor = vec4(0);\n    float l = left(uv - vec2(-5.,0.));\n    float c = center(uv);\n    float r = right(uv - vec2(5.,0.));\n    float d = min(r,min(l, c));\n    \n    float t = clamp(d, 0.0, .04) * 2.*12.5;\n    vec4 bg = vec4(0);\n    vec4 fg = vec4(.8);\n    fragColor = mix(bg, fg, 1.-t);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
