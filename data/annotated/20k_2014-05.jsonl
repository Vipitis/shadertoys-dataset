{"id": "4dfSD4", "name": "Perlin Noise - Ken Burns effect", "author": "slade", "description": "A really simple Ken Burns effect on classic Perlin noise to make it slightly more interesting.", "tags": ["noise", "perlin", "ken", "burns"], "likes": 0, "viewed": 718, "published": "Public", "date": "1400727597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//0.0-20.0 so we can loop the effect\n\tfloat timeMod20 = mod(iTime, 20.0);\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\ttimeMod20 += 10.0; //because starting at 0.0 is boring\n\tif (timeMod20 < 15.0) {\n\t\t//appear to zoom from the lower left corner\n\t\tfragColor = vec4(vec3(cnoise(timeMod20*uv)),1.0);\n\t}\n\telse if (timeMod20 < 20.0) {\n\t\tuv.x = 1.0 - uv.x; //appear to zoom from the lower right corner\n\t\tfragColor = vec4(vec3(cnoise(timeMod20*uv)),1.0);\n\t}\n\telse if (timeMod20 < 25.0) {\n\t\tuv.xy = 1.0 - uv.xy; //appear to zoom from the upper right corner\n\t\tfragColor = vec4(vec3(cnoise(timeMod20*uv)),1.0);\n\t}\n\telse {\n\t\tuv.y = 1.0 - uv.y; //appear to zoom from the upper left corner\n\t\tfragColor = vec4(vec3(cnoise(timeMod20*uv)),1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfSD4.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 445, 466, 466, 515], [517, 517, 539, 539, 576], [578, 578, 606, 606, 658], [660, 660, 679, 679, 719], [721, 745, 767, 767, 1809], [1811, 1811, 1868, 1906, 2603]], "test": "valid"}
{"id": "4dfSW4", "name": "Bezier", "author": "Coldberg", "description": "bezier", "tags": ["bezier"], "likes": 8, "viewed": 309, "published": "Public", "date": "1400662676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_SAMPLES 200\n#define THICKNESS\t0.1\n#define BLUR\t\t20.0\n#define FREQ\t\t200.0\n#define PI\t\t\t3.14159265359\n\n\nvec2 fBezier2 (vec2 p0, vec2 p1, vec2 p2, float t) {\n\treturn mix (\n\t\tmix (p0, p1, t), \n\t\tmix (p1, p2, t),t);\t\n}\n\nvec2 fBezier3 (vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n\treturn fBezier2 (\n\t\tmix (p0, p1, t),\n\t\tmix (p1, p2, t),\n\t\tmix (p2, p3, t),t);\t\t\n}\n\t\n\nfloat fGetDistance (vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n\tfloat d0 = distance (p, p0) ;\n\tfor (int i = 0;i < MAX_SAMPLES;++i) {\n\t\tfloat d = distance (p, fBezier3 (p0, p1, p2, p3, float (i)/float (MAX_SAMPLES)));\n\t\td0 = min (d0, d);\t\t\t\n\t}\n\treturn d0;\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat t = iTime;\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/ min (iResolution.x, iResolution.y);\n\t\n\tvec2 p1 = vec2 (-0.5, 0.0);\n\tvec2 p2 = vec2 (0.5, 0.0);\n\tvec2 p0 = vec2 (sin (t), cos (t))*0.5 + p1;\n\tvec2 p3 = vec2 (cos (t), sin (t))*0.5 + p2;\n\t\n\tfloat d = fGetDistance (uv, p0, p1, p2, p3);\n\tfloat s = smoothstep (THICKNESS*(1.0 - BLUR), THICKNESS*(1.0 + BLUR), d);\n\t\n\tfragColor = mix (vec4 (0.0), vec4 (1.0), 0.5 + 0.5*sin (s*PI*FREQ) );\n\t\t\t\t\t\t\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 166, 166, 225], [227, 227, 288, 288, 371], [375, 375, 440, 440, 634], [637, 637, 694, 694, 1155]], "test": "valid"}
{"id": "4dsXWn", "name": "Weather", "author": "Dave_Hoskins", "description": "Adjust cloud layer thickness with the upper and lower defines.\nMouse X to move through time.\nIt ray-casts to the bottom layer then steps through to the top layer. The larger steps at the horizon are not really noticeable.", "tags": ["3d", "fractal", "noise", "clouds", "weather", "soundcloud"], "likes": 220, "viewed": 23080, "published": "Public API", "date": "1399216397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Weather. By David Hoskins, May 2014.\n// @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Who needs mathematically correct simulations?! :)\n// It ray-casts to the bottom layer then steps through to the top layer.\n// It uses the same number of steps for all positions.\n// The larger steps at the horizon don't cause problems as they are far away.\n// So the detail is where it matters.\n// Unfortunately this can't be used to go through the cloud layer,\n// but it's fast and has a massive draw distance.\n\nvec3 sunLight  = normalize( vec3(  0.35, 0.14,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .7, .55);\nfloat gTime, cloudy;\nvec3 flash;\n\n#define CLOUD_LOWER 2800.0\n#define CLOUD_UPPER 3800.0\n\n#define TEXTURE_NOISE\n\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\n\n//--------------------------------------------------------------------------\n\n//--------------------------------------------------------------------------\nfloat Hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\nfloat Hash(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\n//--------------------------------------------------------------------------\n#ifdef TEXTURE_NOISE\n\n//--------------------------------------------------------------------------\nfloat Noise( in vec2 f )\n{\n    vec2 p = floor(f);\n    f = fract(f);\n    f = f*f*(3.0-2.0*f);\n    float res = textureLod(iChannel0, (p+f+.5)/256.0, 0.0).x;\n    return res;\n}\nfloat Noise( in vec3 x )\n{\n    #if 0\n    return texture(iChannel2, x*0.05).x;\n    #else\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n    #endif\n}\n#else\n\n//--------------------------------------------------------------------------\n\n\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.0-2.0*f);\n\n    return mix(\n\t\tmix(mix(Hash(i + vec3(0.,0.,0.)), Hash(i + vec3(1.,0.,0.)),f.x),\n\t\t\tmix(Hash(i + vec3(0.,1.,0.)), Hash(i + vec3(1.,1.,0.)),f.x),\n\t\t\tf.y),\n\t\tmix(mix(Hash(i + vec3(0.,0.,1.)), Hash(i + vec3(1.,0.,1.)),f.x),\n\t\t\tmix(Hash(i + vec3(0.,1.,1.)), Hash(i + vec3(1.,1.,1.)),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n#endif\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n//--------------------------------------------------------------------------\nfloat FBM( vec3 p )\n{\n\tp*= .0005;\n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n\tf += 0.03125  * Noise(p); p = m*p;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n//--------------------------------------------------------------------------\nfloat FBMSH( vec3 p )\n{\n\tp*= .0005;\n        \n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n//\tf += 0.03125  * Noise(p); p = m*p;\n///\tf += 0.015625 * Noise(p);\n    return f;\n}\n\n//--------------------------------------------------------------------------\nfloat MapSH(vec3 p)\n{\n\t\n\tfloat h = -(FBM(p)-cloudy-.6);\n    //h *= smoothstep(CLOUD_LOWER, CLOUD_LOWER+100., p.y);\n    //h *= smoothstep(CLOUD_LOWER-500., CLOUD_LOWER, p.y);\n    h *= smoothstep(CLOUD_UPPER+100., CLOUD_UPPER, p.y);\n\treturn h;\n}\n\n//--------------------------------------------------------------------------\n\nfloat SeaNoise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\nfloat SeaFBM( vec2 p )\n{\n    p*= .001;\n    float f;\n\tf = (sin(sin(p.x *1.22+gTime) + cos(p.y *.14)+p.x*.15+p.y*1.33-gTime)) * 1.0;\n    \n\tf += (sin(p.x *.9+gTime + p.y *.3-gTime)) * 1.0;\n    f += (cos(p.x *.7-gTime - p.y *.4-gTime)) * .5;\n    f += 1.5000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.05;\n    f += .75000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.02;\n    f += 0.2500 * SeaNoise(p); p =  p * 2.07;\n    f += 0.1250 * SeaNoise(p); p =  p * 2.13;\n    //f += 0.0625 * Noise(p);\n\n\treturn f;\n}\n\n//--------------------------------------------------------------------------\nfloat Map(vec3 p)\n{\n\tfloat h = -(FBM(p)-cloudy-.6);\n    \n\treturn h;\n}\n\n//--------------------------------------------------------------------------\nfloat SeaMap(in vec2 pos)\n{\n\n\treturn SeaFBM(pos) * (20.0 + cloudy*170.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 SeaNormal( in vec3 pos, in float d, out float height)\n{\n\tfloat p = .005 * d * d / iResolution.x;\n\tvec3 nor  \t= vec3(0.0,\t\t    SeaMap(pos.xz), 0.0);\n\tvec3 v2\t\t= nor-vec3(p,\t\tSeaMap(pos.xz+vec2(p,0.0)), 0.0);\n\tvec3 v3\t\t= nor-vec3(0.0,\t\tSeaMap(pos.xz+vec2(0.0,-p)), -p);\n    height = nor.y;\n\tnor = cross(v2, v3);\n\treturn normalize(nor);\n}\n\n//--------------------------------------------------------------------------\nfloat GetLighting(vec3 p, vec3 s)\n{\n    float l = MapSH(p)-MapSH(p+s*200.);\n    return clamp(-l*2., 0.05, 1.0);\n}\n\n\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 pos,in vec3 rd, out vec2 outPos)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\t// Do the blue and sun...\t\n\tvec3  sky = mix(vec3(.0, .1, .4), vec3(.3, .6, .8), 1.0-rd.y);\n\tsky = sky + sunColour * min(pow(sunAmount, 1500.0) * 5.0, 1.0);\n\tsky = sky + sunColour * min(pow(sunAmount, 10.0) * .6, 1.0);\n\t\n\t// Find the start and end of the cloud layer...\n\tfloat beg = ((CLOUD_LOWER-pos.y) / rd.y);\n\tfloat end = ((CLOUD_UPPER-pos.y) / rd.y);\n\t\n\t// Start position...\n\tvec3 p = vec3(pos.x + rd.x * beg, 0.0, pos.z + rd.z * beg);\n\toutPos = p.xz;\n    beg +=  Hash(p)*150.0;\n\n\t// Trace clouds through that layer...\n\tfloat d = 0.0;\n\tvec3 add = rd * ((end-beg) / 55.0);\n\tvec2 shade;\n\tvec2 shadeSum = vec2(0.0, .0);\n\tshade.x = 1.0;\n\t// I think this is as small as the loop can be\n\t// for a reasonable cloud density illusion.\n\tfor (int i = 0; i < 55; i++)\n\t{\n\t\tif (shadeSum.y >= 1.0) break;\n\t\tfloat h = Map(p);\n\t\tshade.y = max(h, 0.0); \n\n        shade.x = GetLighting(p, sunLight);\n\n\t\tshadeSum += shade * (1.0 - shadeSum.y);\n\n\t\tp += add;\n\t}\n\t//shadeSum.x /= 10.0;\n\t//shadeSum = min(shadeSum, 1.0);\n\t\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, .6)), sunColour, (1.0-shadeSum.y)*.4);\n    //vec3 clouds = vec3(shadeSum.x);\n\t\n\t//clouds += min((1.0-sqrt(shadeSum.y)) * pow(sunAmount, 4.0), 1.0) * 2.0;\n   \n    clouds += flash * (shadeSum.y+shadeSum.x+.2) * .5;\n\n\tsky = mix(sky, min(clouds, 1.0), shadeSum.y);\n\t\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 GetSea(in vec3 pos,in vec3 rd, out vec2 outPos)\n{\n\tvec3 sea;\n\tfloat d = -pos.y/rd.y;\n\tvec3 p = vec3(pos.x + rd.x * d, 0.0, pos.z + rd.z * d);\n\toutPos = p.xz;\n\t\n\tfloat dis = length(p-pos);\n    float h = 0.0;\n\tvec3 nor = SeaNormal(p, dis, h);\n\n\tvec3 ref = reflect(rd, nor);\n\tref.y = max(ref.y, 0.0015);\n\tsea = GetSky(p, ref, p.xz);\n\th = h*.005 / (1.0+max(dis*.02-300.0, 0.0));\n   \tfloat fresnel = max(dot(nor, -rd),0.0);\n    fresnel = pow(fresnel, .3)*1.1;\n    \n\tsea = mix(sea*.6, (vec3(.3, .4, .45)+h*h) * max(dot(nor, sunLight), 0.0), min(fresnel, 1.0));\n\t\n\tfloat glit = max(dot(ref, sunLight), 0.0);\n\tsea += sunColour * pow(glit, 220.0) * max(-cloudy*100.0, 0.0);\n\t\n\treturn sea;\n}\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    return vec3(4000.0 * sin(.16*t)+12290.0, 0.0, 8800.0 * cos(.145*t+.3));\n} \n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x/iResolution.x)*30.0;\n\tgTime = iTime*.5 + m + 75.5;\n\tcloudy = cos(gTime * .25+.4) * .26;\n    float lightning = 0.0;\n    \n    if (cloudy >= .2)\n    {\n        float f = mod(gTime+1.5, 2.5);\n        if (f < .8)\n        {\n            f = smoothstep(.8, .0, f)* 1.5;\n        \tlightning = mod(-gTime*(1.5-Hash(gTime*.3)*.002), 1.0) * f;\n        }\n    }\n    \n    flash = clamp(vec3(1., 1.0, 1.2) * lightning, 0.0, 1.0);\n       \n\t\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tvec3 cameraPos = CameraPath(gTime - 2.0);\n\tvec3 camTar\t   = CameraPath(gTime - .0);\n\tcamTar.y = cameraPos.y = sin(gTime) * 200.0 + 300.0;\n\tcamTar.y += 370.0;\n\t\n\tfloat roll = .1 * sin(gTime * .25);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\tvec3 col;\n\tvec2 pos;\n\tif (dir.y > 0.0)\n\t{\n\t\tcol = GetSky(cameraPos, dir, pos);\n\t}else\n\t{\n\t\tcol = GetSea(cameraPos, dir, pos);\n\t}\n\tfloat l = exp(-length(pos) * .00002);\n\tcol = mix(vec3(.6-cloudy*1.2)+flash*.3, col, max(l, .2));\n\t\n\t// Do the lens flares...\n\tfloat bri = dot(cw, sunLight) * 2.7 * clamp(-cloudy+.2, 0.0, .2);\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.6;\n\n\t\tfloat glare1 = max(1.2-length(uvT+sunPos*2.)*2.0, 0.0);\n\t\tfloat glare2 = max(1.2-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\tfloat glare3 = max(1.2-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * sunColour * vec3(1.0, .5, .2)  * pow(glare1, 10.0)*25.0;\n\t\tcol += bri * vec3(.8, .8, 1.0) * pow(glare2, 8.0)*9.0;\n\t\tcol += bri * sunColour * pow(glare3, 4.0)*10.0;\n\t}\n\t\n\tvec2 st =  uv * vec2(.5+(xy.y+1.0)*.3, .02)+vec2(gTime*.5+xy.y*.2, gTime*.2);\n\t// Rain...\n#ifdef TEXTURE_NOISE\n \tfloat f = texture(iChannel0, st, -100.0).y * texture(iChannel0, st*.773, -100.0).x * 1.55;\n#else\n\tfloat f = Noise( st*200.5 ) * Noise( st*120.5 ) * 1.3;\n#endif\n\tfloat rain = clamp(cloudy-.15, 0.0, 1.0);\n\tf = clamp(pow(abs(f), 15.0) * 5.0 * (rain*rain*125.0), 0.0, (xy.y+.1)*.6);\n\tcol = mix(col, vec3(0.15, .15, .15)+flash, f);\n\tcol = clamp(col, 0.0,1.0);\n\n\t// Stretch RGB upwards... \n\t//col = (1.0 - exp(-col * 2.0)) * 1.1565;\n\t//col = (1.0 - exp(-col * 3.0)) * 1.052;\n\tcol = pow(col, vec3(.7));\n\t//col = (col*col*(3.0-2.0*col));\n\n\t// Vignette...\n\tcol *= .55+0.45*pow(70.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.15 );\t\n\t\n\tfragColor=vec4(col, 1.0);\n}\n\n//--------------------------------------------------------------------------\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sfGRr", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume"}, {"id": "ldlGRr", "previewfilepath": "https://soundcloud.com/chill/finding-hope-wonder-premiere", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/chill/finding-hope-wonder-premiere", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsXWn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[951, 1028, 1051, 1051, 1150], [1151, 1151, 1171, 1171, 1267], [2823, 2900, 2921, 2921, 3203], [3204, 3281, 3304, 3304, 3600], [3602, 3679, 3700, 3700, 3922], [3924, 4002, 4031, 4031, 4275], [4276, 4276, 4300, 4300, 4767], [4769, 4846, 4865, 4865, 4915], [4917, 4994, 5021, 5021, 5069], [5071, 5148, 5208, 5208, 5488], [5490, 5567, 5602, 5602, 5680], [5684, 5817, 5871, 5871, 7262], [7264, 7341, 7395, 7395, 8027], [8029, 8106, 8134, 8134, 8212], [8215, 8292, 8349, 8349, 10960]], "test": "error"}
{"id": "4dXSDN", "name": "Cheap blobs", "author": "LukasPukenis", "description": "Blobs", "tags": ["blob"], "likes": 6, "viewed": 194, "published": "Public", "date": "1400846644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R 0.002\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec2 B1 = vec2(0.3, 0.3);\n\tvec2 B2 = vec2(0.8, 0.1);\n\tvec2 B3 = vec2(0.1, 0.7);\n\t\n\tfloat fi = iTime;\n\t\n\tmat2 rotation = mat2(\n\t\tcos(fi), -sin(fi),\n\t\tsin(fi), cos(fi)\n\t);\n\t\n\tvec2 sine = vec2(sin(iTime/1.6) - cos(iTime/1.6));\n\t\n\tB1 *= rotation * sine*sine;\n\tB2 *= rotation * sine;\n\tB3 *= rotation * 0.10 * sine;\n\t\n\tfloat dB1 = step(distance(uv.xy, B1), R);\n\tfloat dB2 = step(distance(uv.xy, B2), R);\n\tfloat dB3 = step(distance(uv.xy, B3), R);\t\n\t\t\n\tvec4 color;\n\t\t\n\tcolor = mix(\n\t\tvec4(1.0, 1.0, 0.0, 1.0),\n\t\tvec4(0.1, 0.2, 0.2, 1.0),\t\t\n\t\tsmoothstep(\n\t\t\t0.02,\n\t\t\t0.052,\n\t\t\tdistance(uv.xy, B1) * distance(uv.xy, B2) * distance(uv.xy, B3)\n\t\t)\n\t);\n\t\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 824]], "test": "valid"}
{"id": "4dXXDN", "name": "Very first shader", "author": "Ratzzo", "description": "originally posted on http://glsl.heroku.com/", "tags": ["2d", "pattern"], "likes": 1, "viewed": 128, "published": "Public", "date": "1400901041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tfloat time = iTime;\n\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\n\tfloat color = 0.0, r ,g ,b;\n\tfloat x = position.x;\n\tfloat y = position.y;\n\t\n\n\tg = .1/cos((x*32.+(time/50.)*100.));\n\tg += .1/cos((y*32.+(time/50.)*100.));\n\tg -= .3;\n\tg += sin(x*30.)*.3;\n\t\n\t\t\n\tfragColor = vec4(r,g,b,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXXDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 169, 169, 469]], "test": "error"}
{"id": "4sfXD4", "name": "Blobsesees", "author": "Coldberg", "description": "blobs", "tags": ["blobs"], "likes": 10, "viewed": 235, "published": "Public", "date": "1400761529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define E 40.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/ min (iResolution.x, iResolution.y) ;\n\t\n\tfloat t0 = sin (iTime);\n\tfloat t1 = sin (iTime/2.0);\n\tfloat t2 = cos (iTime);\n\tfloat t3 = cos (iTime/2.0);\n\t\n\tvec2 p0 = vec2 (t1, t0) ;\n\tvec2 p1 = vec2 (t2, t3) ;\n\tvec2 p2 = vec2 (t0, t3) ;\n\t\n\tfloat a = 1.0/distance (uv, p0);\n\tfloat b = 1.0/distance (uv, p1);\n\tfloat c = 1.0/distance (uv, p2);\n\t\n\tfloat d = 1.0 - pow (1.0/(a+b+c), E)*pow (10.0, E*0.7);\n\t\n\tfragColor = vec4 (a*0.5, b*0.5, c*0.5, 1.0) * d;\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 72, 72, 570]], "test": "valid"}
{"id": "4slGRs", "name": "Classic Standing Wave Shader", "author": "morphogen", "description": "Classic simulation of standing waves.", "tags": ["waves", "geometry", "sinusoid"], "likes": 4, "viewed": 186, "published": "Public", "date": "1400082098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi=3.1415926535;\n\nfloat white=0.7;\nfloat black=0.1;\nvec2 size=iResolution.xy;\nfloat scale=0.6;\n\nconst int num=5;\n\nfloat wave(vec2 pos,float angle,float wavelength,float phase)\n{\n\treturn sin(dot(pos,vec2(cos(angle),sin(angle)))*2.0*pi/wavelength+phase);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos=fragCoord.xy/scale-size/2.0;\n\n\tfloat amp=0.0;\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tfloat angle=float(3*i)*pi/float(num);\n\t\tamp+=wave(pos,angle,60.0,iTime);\n\t}\n\n\tfloat y=fragCoord.y/size.y;\n\t\n\tfloat c=sin(pi*12.0*(amp+float(num))/float(num)/2.0);\n\tc=clamp(c,0.0,1.0);\n\tc=pow(c,0.3);\n\tc=black+(white-black)*(c+y)*0.2;\n\t//fragColor=vec4(vec3(c),1.0);\n\tfragColor=vec4(vec3(amp),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 189, 189, 266], [268, 268, 325, 325, 709]], "test": "valid"}
{"id": "4slSD8", "name": "MÃ¶bius Strip", "author": "vgs", "description": "Watch the strip transforming into a torus. Click to rotate.", "tags": ["3d", "raymarch", "mobius", "implicit"], "likes": 87, "viewed": 5609, "published": "Public", "date": "1400115085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Vinicius Graciano Santos - vgs/2014\n// Based on the following article:\n// http://data.imaginary-exhibition.com/IMAGINARY-Moebiusband-Stephan-Klaus.pdf\n\n#define EPS 0.01\n#define STEPS 64\n#define TAU 6.28318530718\n\n// comment to stop the rotation.\n#define ROTATION\n\n// comment to stop the homotopy between the mobius strip and the torus.\n#define HOMOTOPY\n\nfloat mobius(vec3 p, float b) {\n\tfloat x = p.x, y = p.y, z = p.z;\n\tfloat xx = x*x, yy = y*y, zz = z*z, y3 = yy*y, x3 = xx*x;\n\tfloat xy = xx+yy, b2 = b*2.0, zxy = z*(xx*y*3.0-y3), xyy = x*yy*3.0-x3;\n    float k1 = (2.0*zxy+xyy*(xy-zz+1.0))*(b-0.1)-xy*xy*(b2+0.2);\n    float k2 = b*xy*0.2+(b2-0.2)*(zxy+xyy)-xy*(b+0.1)*(xy+zz+1.0);\n\treturn k1*k1-xy*k2*k2;\n}\n\nvec3 grad(vec3 p, float b) {\n\tvec2 q = vec2(0.0, EPS);\n\treturn vec3(mobius(p+q.yxx, b) - mobius(p-q.yxx, b), \n\t\t\t    mobius(p+q.xyx, b) - mobius(p-q.xyx, b),\n\t\t\t    mobius(p+q.xxy, b) - mobius(p-q.xxy, b));\n}\n\nfloat torus(vec3 p) {\n\tvec2 t = vec2(1.0, 0.32);\n  \tvec2 q = vec2(length(p.xy)-t.x,p.z);\n  \treturn length(q)-t.y;\n}\n\nmat3 rotY(float ang) {\n\tfloat c = cos(ang), s = sin(ang);\n\treturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\n\nmat3 rotX(float ang) {\n\tfloat c = cos(ang), s = sin(ang);\n\treturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n\nvec3 shade(vec3 p, vec3 rd, float b, mat3 m) {\n\tvec3 col = vec3(0.0);\n\tvec3 n = normalize(-grad(p, b));\n\t\n\t// material\n\tvec3  amb = vec3(0.05375, 0.05, 0.06625);\n\tvec3  dif = vec3(0.18275, 0.17, 0.22525);\n\tvec3  spe = vec3(0.332741, 0.328634, 0.346435);\n\tfloat shin = 39.4;\n\t\n\t// key light\n\tvec3 l = normalize(m*vec3(1.0));\n\tvec3 h = normalize(l-rd);\n\tfloat lambert = max(0.0, dot(n, l));\n\tfloat blinn = lambert > 0.0 ? pow(max(0.0, dot(n, h)), shin) : 0.0;\n\tcol += vec3(3.0, 2.0, 3.0)*(0.4*dif*lambert + 1.4*spe*blinn + 0.1*amb);\n\t\n\t// fill light\n\tlambert = max(0.0, dot(n, -rd));\n\tblinn = lambert > 0.0 ? pow(lambert, shin) : 0.0;\n\tcol += vec3(1.0)*(0.4*dif*lambert + 1.4*spe*blinn + 0.1*amb);\n\t\n\t// rim light\n\tcol += 2.25*pow(clamp(1.0+dot(n, rd), 0.0, 1.0), 3.0); \n\t\n\treturn col/(col+1.0); // reinhard\n}\n\nfloat animCurve(in float t) {\n\tt = mod(iTime, 15.0);\n\tfloat f1 = smoothstep(5.0, 7.0, t);\n\tfloat f2 = 1.0-smoothstep(7.0, 9.0, t);\n\treturn 0.01+0.09*f1*f2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 fc = fragCoord.xy / iResolution.xy;\n\tvec2 uv = -1.0+2.0*fc;\n\tuv.x *= iResolution.x/iResolution.y;\t\n\t\n\tvec2 mouse = 0.5*TAU*(-1.0+2.0*iMouse.xy/iResolution.xy);\n\t\n\t#ifndef HOMOTOPY\n\t\tfloat b = 0.01;\n\t#else\n\t\tfloat b = animCurve(iTime);\n\t#endif\n\t\n\t#ifdef ROTATION\n\t\tmouse.x += 0.3*iTime;\n\t#endif\n\t\n\tmat3 m = rotY(mouse.x)*rotX(mouse.y);\n\tvec3 ro = m*vec3(0.0, 0.0, 1.8);\n\tvec3 rd = m*normalize(vec3(uv, -1.0));\n\t\n\tfloat d = 10.0, t1 = 0.0;\n\tvec3 p = ro, col = vec3(1.0);\n\t\n\t// sphere-trace to torus envelope.\n\tfor (int i = 0; i < STEPS; ++i) {\n\t\tif (d < EPS || t1 > 4.0) continue;\n\t\td = torus(p);\n\t\tt1 += d; p = ro + t1*rd;\n\t}\n\t\n\tif (d < EPS) {\t\n\t\t// forward march to find root interval.\n\t\tfloat t2 = t1; d = mobius(p, b);\n\t\tfor (int i = 0; i < 2*STEPS; ++i) {\n\t\t\tif (d > 0.0) continue;\n\t\t\td = mobius(p, b);\n\t\t\tt2 += 2.0*EPS; p = ro + t2*rd;\n\t\t}\n\t\t// bisect towards root.\n\t\tif (d > 0.0) {\n\t\t\tfor (int i = 0; i < 12; ++i) {\n\t\t\t\td = 0.5*(t1+t2); p = ro + d*rd;\n\t\t\t\tif (mobius(p, b) > 0.0) t2 = d; else t1 = d;\n\t\t\t}\n\t\t\tcol = shade(ro+d*rd, rd, b, m);\n\t\t}\n\t}\n\t\n\t// post-processing\n\tcol = smoothstep(0.0, 1.0, col);\n\tcol *= 0.5 + 0.5*pow(25.0*fc.x*(1.0-fc.x)*fc.y*(1.0-fc.y), 0.45);\n\tcol = pow(col, vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slSD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 368, 399, 399, 723], [725, 725, 753, 753, 933], [935, 935, 956, 956, 1050], [1052, 1052, 1074, 1074, 1163], [1165, 1165, 1187, 1187, 1276], [1278, 1278, 1324, 1324, 2085], [2087, 2087, 2116, 2116, 2244], [2246, 2246, 2303, 2303, 3549]], "test": "valid"}
{"id": "4slSDr", "name": "WetDunes", "author": "cafe", "description": "One of my first raymarching tests, it looks pretty awful :D", "tags": ["randomraymarchingtests"], "likes": 2, "viewed": 176, "published": "Public", "date": "1399406167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI=3.14159;\n\nfloat hash(float x){ return fract(sin(x)*43758.5453);}\nfloat hash(vec2 x){ return hash(hash(x.x)+x.y); }\nfloat hash(vec3 x){ return hash(hash(x.xy)*x.z); }\n\nfloat hashsquare(vec2 x){\n\tx.y-=iTime/2.;\n\tx.x+=sin(iTime/4.)*2.;\n\tvec2 ix = floor(x);\n\tvec2 dx = smoothstep(0.,1.,fract(x));\n\t\n\tfloat v1=hash(ix+vec2(0.,0.)),\n\t\t  v2=hash(ix+vec2(1.,0.)),\n\t\t  v3=hash(ix+vec2(0.,1.)),\n\t\t  v4=hash(ix+vec2(1.,1.));\n\t\n\tfloat h = mix(mix(v1,v2,dx.x),mix(v3,v4,dx.x),dx.y);\t\n\t\n\treturn h;\n}\n\nfloat spherize(vec2 uv){\n\treturn dot(uv,uv)/300.;\n}\n\nfloat heightmap(vec2 x){\n\t\n\tconst float scale=1.;\n\t\n\tx/=scale;\n\tfloat h=0.;\n\t\n\tmat3 p=mat3(vec3(4. ,0.03 ,0.),\n\t\t\t\tvec3(8. ,0.01 ,0.),\n\t\t\t\tvec3(68.,0.003,0.));\n\t\n\n\th=hashsquare(x/4.+iTime*0.0)*2.;\n\th=mix(h,hashsquare(x*p[0].x+iTime*p[0].z),p[0].y);\n\th=mix(h,hashsquare(x*p[1].x+iTime*p[1].z),p[1].y);\n\th=mix(h,hashsquare(x*p[2].x+iTime*p[2].z),p[2].y);\n\t//h=mix(h,hashsquare(x*2.),0.01);\n\n\treturn h*scale-spherize(x*scale);\t\n}\n\nvec3 tex(vec3 p, float mat){\n\tvec3 color;\n\t\n\tif(mat==1.){\n\t\tfloat b=1.-smoothstep(-0.,1.5,p.y+2.-spherize(p.xz));\n\t\tcolor=mix(vec3(0.7,0.5,0.2),vec3(0.5,0.5,0.3),b);\n\t}\n\t\n\t\n\treturn clamp(color,0.,1.);\n}\n\nvec2 map(vec3 p){\n\tvec2 t1=vec2(p.y+heightmap(p.xz),1.);\n\treturn t1;\n}\n\nvec3 normal(vec3 p){\n\tvec3 e=vec3(0.005,0.,0.);\n\tvec3 n=vec3(\n\t\tmap(p+e.xyy).x-map(p-e.xyy).x,\n\t\tmap(p+e.yxy).x-map(p-e.yxy).x,\n\t\tmap(p+e.yyx).x-map(p-e.yyx).x);\n\treturn normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd){\n\tconst int iter=200;\n\tconst float mint=0.01;\n\tfloat t=0.;\n\tfor(int i=0 ; i<iter ; i++){\n\t\tvec2 h = map(ro+t*rd);\n\t\tif(h.x<0.001) return vec2(t,h.y);\n\t\tt+=max(mint*t,h.x);\n\t}\n\treturn vec2(0.);\n}\n\nvec3 shade(vec2 uv){\n\t\n\tvec3 ro=vec3(0.,0.,0.),\n\t\t rd;//=normalize(vec3(uv,-1.1));\n\t\n\tfloat h=map(ro).x;\n\tvec3 nor=normal(ro-vec3(0.,1.,0.)*h);\n\t\n\tvec3 lookat=vec3(0.,0.,-1.5)-nor/2.;\n\tvec3 cdir=normalize(lookat-ro);\n\tvec3 r  = normalize(cross(cdir,vec3(0.,1.,0.)));\n\tvec3 u  = normalize(cross(r,cdir));\n\t\n\t\n\trd = normalize(uv.x*r+uv.y*u+cdir);\n\t\n\t//rd=normalize(vec3(uv.x,-1.2,uv.y+0.1));\n\t\n\tro.yz-=map(ro)-vec2(0.5);\n\t\n\tvec2 t = intersect(ro,rd);\n\tvec3 color=vec3(0.);\n\t\n\tif(t.y>0.){\n\t\tvec3 p = ro+t.x*rd;\n\t\tvec3 n = normal(p);\n\t\tvec2 rot = vec2(cos(iTime/3.),sin(iTime/3.)*3.);\n\t\tvec3 l = normalize(vec3(rot.x,rot.y,rot.x));\n\t\t\n\t\tfloat amb=1.*n.y-p.y/100.;\n\t\tfloat dif=max(0.,dot(n,l));\n\t\tfloat spc=max(0.,dot((dot(rd,n)*n*-2.+rd),l));\n\t\tspc=smoothstep(0.85,1.,spc);\n\t\t\n\t\tcolor = vec3(0.3,0.15,0.7)*amb;\n\t\tcolor +=vec3(1.,1.,0.9)*dif;\n\t\tcolor +=spc;\n\t\t\n\t\tcolor *= tex(p,t.y);\n\t}\n\t\n\treturn vec3(color);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(shade(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slSDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 45, 45, 79], [80, 80, 99, 99, 129], [130, 130, 149, 149, 180], [182, 182, 207, 207, 500], [502, 502, 526, 526, 553], [555, 555, 579, 579, 981], [983, 983, 1011, 1011, 1185], [1187, 1187, 1204, 1204, 1257], [1259, 1259, 1279, 1279, 1444], [1446, 1446, 1479, 1479, 1673], [1675, 1675, 1695, 1695, 2582], [2584, 2584, 2640, 2640, 2735]], "test": "valid"}
{"id": "4slSWN", "name": "gravity field - 2", "author": "FabriceNeyret2", "description": "inside an homogeneous sphere, only the mass closer to center than you contributes to your gravity.\nWhat about an heterogeneous bag of stars ?\n(illustrated with 2D gravity in 1/r).   Mouse.x to force colormap. Clamps stars out of mouse.y radius.", "tags": ["gravity"], "likes": 82, "viewed": 5159, "published": "Public API", "date": "1401365213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define POINTS 100  \t\t // number of stars\n\n// --- GUI utils\n\nfloat t;\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n\n// --- math utils\n\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\n\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\t\n\n\n// === main ===================\n\n// motion of stars\nvec2 P(float i) {\n\tvec4 c = hash4(i);\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\n}\n\n// ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : .5*iMouse.x/iResolution.x;\n\tfloat my = (iMouse.z<=0.) ? .5*pow(.5*(1.-cos(.1*t)),3.) : iMouse.y/iResolution.y;\n\tint MODE = int(mod( (iMouse.z<=0.) ? 100.*m : 6.*m ,3.));\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\n\n\tconst int R = 1;\n\t\n\tfloat v=0.; vec2 V=vec2(0.);\n\tfor (int i=1; i<POINTS; i++) { // sums stars\n\t\tvec2 p = P(float(i));\n\t\tfor (int y=-R; y<=R; y++)  // ghost echos in cycling universe\n\t\t\tfor (int x=-R; x<=R; x++) {\n\t\t\t\tvec2 d = p+2.*vec2(float(x),float(y)) -uv; // pixel to star\n\t\t\t\tfloat r2 = dot(d,d);\n\t\t\t\tr2 = clamp(r2,5e-2*my,1e3);\n\t\t\t\tV +=  d / r2;  // gravity force field\n\t\t\t}\n\t\t}\n\t\n\tv = length(V);\n\tv *= 1./(9.*float(POINTS));\n\t//v = clamp(v,0.,.1);\n\t\n\tv *= 2.+100.*fMODE;\n\tif (MODE==0) fragColor = vec4(.2*v)+smoothstep(.05,.0,abs(v-5.*my))*vec4(1,0,0,0);\n\tif (MODE==1) fragColor = vec4(.5+.5*sin(2.*v));\n\tif (MODE==2) fragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\n\n\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slSWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 71, 98, 98, 171], [174, 193, 224, 224, 257], [259, 259, 281, 281, 325], [326, 326, 348, 348, 383], [384, 384, 406, 406, 463], [501, 520, 537, 537, 671], [673, 681, 738, 738, 1745]], "test": "error"}
{"id": "4ssSDn", "name": "Text rendering", "author": "bysse", "description": "Just a small experiment in drawing characters, inspired from http://www.claudiocc.com/the-1k-notebook-part-i/", "tags": ["text"], "likes": 2, "viewed": 583, "published": "Public", "date": "1399278539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"hej\" is \"hello\" is Swedish :)\n\n#define LENGTH 16\n#define MAXD 100.\n\nint text[LENGTH];\n\n// iq's renamed sdCapsule in 2d\nfloat line( vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - .1;\n}\n\nfloat noise( in vec3 x ) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nconst mat3 m = mat3( 0.0,  0.8,  0.6,\n                    -0.8,  0.3, -0.4,\n                    -0.6, -0.4,  0.6 );\n\nfloat fbm(in vec3 x) {\n\tvec3 p = .3 * x;\n\tfloat v;\t\n\tv  = 0.500*noise( p ); p = m*p*2.2;\n    v += 0.250*noise( p ); p = m*p*2.3;\n    v += 0.125*noise( p ); p = m*p*2.1;\n    v += 0.063*noise( p );\n\t\n\treturn v;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// h \n\ttext[0] = 12;\n\ttext[1] = 258;\n\ttext[2] = 134;\n\ttext[3] = 182;\n\t\n\t// e\n\ttext[4] = -3;\n\ttext[5] = 200;\n\ttext[6] = 239;\n\ttext[7] = 174;\n\ttext[8] = 138;\t\n\ttext[9] = 266;\t\n\t\n\t// j\n\ttext[10] = -3;\n\ttext[11] = 133;\n\ttext[12] = 166;\n\ttext[13] = 417;\n\ttext[14] = 0;\n\ttext[15] = 67;\n\t\n\tvec2 p = 10.*uv + .02 * sin(5. * iTime * vec2(uv) + 10.*6.28*uv);\n\tvec2 caret = vec2(1.4, .5);\n\t\n\tfloat d = MAXD;\n\tfor (int i=0;i<LENGTH;i++) {\n\t\tif (text[i] <= 0) {\n\t\t\tcaret.x -= float(text[i]);\t\t\t\n        } else {\n            // lines are stored in the format value = from * 21 + to\n            float p0 = float(text[i] / 21);\n            float p1 = mod(float(text[i]), 21.);\t\t\n\n            // TODO: invert Y during encoding to remove \"7.-\"\n            vec2 c0 = caret + vec2(mod(p0, 3.), 7.-floor(p0/3.));\n            vec2 c1 = caret + vec2(mod(p1, 3.), 7.-floor(p1/3.));\n            d = min(d, line(p, c0, c1));\n        }\n\t}\n\t\n\tvec3 color = vec3(smoothstep(0., .05, d));\t\n    \n    float n = fbm(vec3(200.*p, iTime));\n    color -= .5*n;\n    \n    color = pow( color, vec3(1.1)) * sqrt( 64.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y) );\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 123, 160, 160, 288], [290, 290, 316, 316, 521], [640, 640, 662, 662, 850], [854, 854, 911, 911, 2096]], "test": "error"}
{"id": "4ssSWH", "name": "Living breathing thing", "author": "Coldberg", "description": "ray marching test nr 3", "tags": ["raymarching", "smoothmin"], "likes": 2, "viewed": 214, "published": "Public", "date": "1400185781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI \t\t\t\t\t3.14159265359\n#define EPSILON \t\t\t0.02\n#define BUMP_FACTOR     \t0.01\n#define K\t\t\t\t\t(2.0 + 0.5*sin (iTime*PI*0.7))\n\n#define MIN_STEP\t\t\t0.001\n#define MAX_STEP\t\t\t100.0\n\n#define MAX_STEPS \t\t\t100\n#define MAX_SHADOW_STEPS\t64\n\n#define MAX_OCCLUSION_STEPS 8\n#define MIN_DIST\t\t\tEPSILON\n#define MAX_DIST\t\t\t50.0\n#define BUMP_SCALE_FACTOR\t0.2\n#define TEX_SCALE_FACTOR\t0.1\n#define FOV\t\t\t\t\t60.0\n\n#define SHADOW_HARDNESS \t64.0\n#define ATTENUATION\t\t\t0.025\n#define AMBIENT\t\t\t\t0.5\n#define SHINYNESS\t\t\t50.0\n#define SPECULAR\t\t\t3.0\n#define DIFFUSE\t\t\t\t3.0\n#define OCCLUSION   \t\t5.0\n\n#define FLICKER_SPEED\t\t3.0\n#define FLICKER_THRESHOLD\t0.7\n\n#define LIGHT_AMBIENT\t\tvec4(1.0,1.0,1.0,1.0)\n#define LIGHT_DYNAMIC\t\tvec4(1.0,1.0,1.0,1.0)\n//\n//#define MSAA4X\n\nmat3 rotate_x (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (1.0, 0.0, 0.0),\n\t\tvec3 (0.0, cfi, -sfi),\n\t\tvec3 (0.0, sfi, cfi)\n\t);\n}\n\nmat3 rotate_y (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (cfi, 0.0, sfi),\n\t\tvec3 (0.0, 1.0, 0.0),\n\t\tvec3 (-sfi, 0.0, cfi)\n\t);\n}\n\nmat3 rotate_z (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (cfi, -sfi, 0.0),\n\t\tvec3 (sfi, cfi, 0.0),\n\t\tvec3 (0.0, 0.0, 1.0)\n\t);\n}\n\nmat3 rotate (vec3 vPitchYawRoll, float fi) {\n\treturn\n\t\trotate_z (fi * vPitchYawRoll.z) *\n\t\trotate_y (fi * vPitchYawRoll.y) *\n\t\trotate_x (fi * vPitchYawRoll.x);\n}\n\n\nfloat smin (float a, float b, float k) {\n    return -log (exp (-k*a) + exp (-k*b)) / k;\n}\n\nfloat smax (float x, float y, float k) {\n\treturn log (exp (k*x) + exp (k*y)) / k;\n}\n\nstruct Plane {\n\tvec3 n;\n\tfloat d;\t\n};\n\nstruct Sphere {\n\tvec3 o;\n\tfloat r;\t\n};\n\nstruct Box {\n\tvec3 o;\n\tvec3 b;\t\n};\n\t\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n\treturn \n\t\ttexture(t, p.yz * scale) * abs (n.x) +\n\t\ttexture(t, p.xz * scale) * abs (n.y) +\n\t\ttexture(t, p.xy * scale) * abs (n.z);\n}\n\nfloat get_distance_plane (vec3 p, Plane plane) {\n\treturn dot (plane.n,p) + plane.d;\n}\n\nfloat get_distance_sphere (vec3 p, Sphere sphere) {\n\tvec3 p0 = p - sphere.o;\t\n\tfloat l0 = length (p0);\n\tfloat bump = 0.0;\n\tif (l0 < sphere.r + BUMP_FACTOR) {\n\t\tbump = BUMP_FACTOR * texture3d(iChannel0, p, normalize (p0), BUMP_SCALE_FACTOR).r ;\t\n\t}\t\t\t\n\treturn length (p0) - sphere.r + bump;\n}\n\nfloat get_distance_box (vec3 p, Box box) {\n\tfloat bump = 0.0;\n\tvec3 p0 = p - box.o;\n\t\n\tif (length (p0) < length (box.b)) {\n\t\tbump = texture3d(iChannel0, p, p0, BUMP_SCALE_FACTOR).r * BUMP_FACTOR;\n\t}\t\n\t\n \tvec3 d = abs(p0) - box.b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) + bump;\t\n}\n\nfloat dadd (float a, float b) {\n\treturn smin (a, b, K);\n}\nfloat dsub (float a, float b) {\n\treturn smax (a, -b, K);\n}\n\nfloat get_distance (vec3 p) {\n\t\n\tfloat s0 = get_distance_sphere (p, Sphere (vec3 (0.0, 2.5, 0.0), 1.0));\n\tfloat s1 = get_distance_sphere (p, Sphere (vec3 (1.5, 1.0, 0.0), 1.0));\n\tfloat b0 = get_distance_box (p, Box (vec3 (0.0, 1.0, 0.0), vec3 (1.0, 1.0, 1.0)));\n\tfloat b1 = get_distance_box (p, Box (vec3 (0.0, -0.5, 0.0), vec3 (3.0, 1.0, 3.0)));\n\tfloat p0 = get_distance_plane (p, Plane (normalize (vec3 (0.0, 1.0, 0.0)),0.0));\n\treturn dadd (dadd (dadd (dadd (b0, b1), s0), s1), p0);\n}\nvec3 get_normal (vec3 p) {\n\tfloat d = get_distance (p);\n\treturn normalize (vec3 (\n\t\tget_distance (p - vec3 (EPSILON, 0.0, 0.0)) - d,\n\t\tget_distance (p - vec3 (0.0, EPSILON, 0.0)) - d,\n\t\tget_distance (p - vec3 (0.0, 0.0, EPSILON)) - d\n\t));\n}\n\nvec2 screen_uv () {\n\t//vec2 mouse = iMouse.xy / iResolution.xy - vec2 (0.5, 0.5);\n\treturn vec2 (2.0*gl_FragCoord.xy - iResolution.xy)/ \n\t\tvec2 (min (iResolution.x, iResolution.y));\n}\n\nfloat ray_march (vec3 org, vec3 dir, out float md) {\t\n\tfloat h = EPSILON;\n\tmd = MAX_DIST;\t\n\tfor (int i = 0;i < MAX_STEPS;++i) {\n\t\tfloat d = get_distance  (dir * h + org);\n\t\tmd = min (md, d);\n\t\tif (d <= EPSILON) \n\t\t\treturn h;\n\t\th += clamp (d, MIN_STEP, MAX_STEP);\n\t\tif (h >= MAX_DIST)\n\t\t\treturn h;\t\t\n\t}\n\treturn MAX_DIST;\n}\n\nfloat light_march (vec3 org, vec3 dir, float k){\n    float res = 1.0;\n\tfloat t = MIN_DIST;\n    for (int i =0; i < MAX_SHADOW_STEPS; ++i){\n        float h = get_distance (org + dir*t);\n        if (h < 0.001)\n            return 0.0;\n        res = min (res,k*h/t);\n        t += h;\n\t\tif (t >=MAX_DIST)\n\t\t\treturn res;\n    }\n    return res;\n}\n\nfloat sample_occlusion (vec3 pnt, vec3 nml) {\n\tfloat ao = 0.0;\n\tfloat di = 1.0 / float (MAX_OCCLUSION_STEPS);\n\tfor (float i = 0.0; i < float(MAX_OCCLUSION_STEPS); i += 1.0) {\n\t\tfloat d = i * di;\n\t\tao += (1.0/exp2 (i))*(d - get_distance (pnt - nml*d));\n\t}\n\treturn 1.0 - OCCLUSION * ao;\n}\n\nfloat flicker (float o) {\n\treturn step (FLICKER_THRESHOLD, texture (iChannel2, vec2 (o, iTime/(50.0/FLICKER_SPEED))).r);\n}\n\nvec4 calc_ray (vec2 uv) {\t\n\tuv *= tan (radians (FOV)/2.0);\n\t\n\tmat3 rotcam = rotate_y (PI * sin (iTime*PI/10.0) / 4.0);\n\tmat3 rotlit = rotate_y ((PI / 2.0) * sin (iTime*PI/5.0));\n\t\n\tvec3 lo = vec3 (0.0, 5.0, -10.0) * rotlit;\n\tvec3 org = vec3 (0.0, 3.0, -7.0) * rotcam;\n\tvec3 up = vec3 (0.0, 1.0, 0.0) ;\n\tvec3 fw = vec3 (0.0, 0.0, 1.0) * rotcam;\n\tvec3 rt = -cross (fw, up) ;\n\t\n\t\n\tvec3 dir = normalize (up * uv.y + rt * uv.x + fw);\t\n\tfloat md = 0.0;\n\tfloat hd = ray_march (org, dir, md);\n\n\t\n\tvec3 pnt = org + dir * hd;\n\tvec3 nml = get_normal (pnt);\n\tvec3 lds = pnt - lo;\n\tvec3 ldr = normalize (lds);\n\tvec3 lrf = reflect (-ldr, nml);\n\t\n\tfloat shadow = light_march (pnt, -ldr, SHADOW_HARDNESS);\n\tfloat occlusion = sample_occlusion (pnt, nml)*AMBIENT*flicker(0.2) ;\t\n\tfloat diffuse = max (0.0, dot (nml, ldr)) ;\t\n\tfloat attenuation = (1.0/(1.0+ATTENUATION*pow(length (lds),2.0)));\n\tfloat specular = diffuse > 0.0 ? pow(max(0.0, dot(dir, lrf)), SHINYNESS) : 0.0;\t\t\t\t\n\tfloat lighting = clamp ((DIFFUSE*diffuse + SPECULAR*specular)*shadow*attenuation, 0.0, 1.0);\n\t\n\treturn mix (\n\t\ttexture3d (iChannel1, pnt, nml, TEX_SCALE_FACTOR)*\n\t\t\t(LIGHT_DYNAMIC*lighting + LIGHT_AMBIENT*occlusion), \n\t\tmix (vec4 (1.0, 0.0, 0.0, 1.0), \n\t\t\t vec4 (0.1, 0.0, 0.1, 1.0), \n\t\t\t smoothstep (-1.0, 0.1, dot (up, dir))),\n\t\tsmoothstep (10.0, 20.0, hd));\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat dp = 1.0 / min (iResolution.y, iResolution.x);\n\tvec2 uv = screen_uv ();\n\t#ifdef MSAA4X\n\tfragColor = (\n\t\tcalc_ray (uv+vec2(-dp/2.0, -dp/2.0))+\n\t\tcalc_ray (uv+vec2(+dp/2.0, +dp/2.0))+\n\t\tcalc_ray (uv+vec2(+dp/2.0, -dp/2.0))+\n\t\tcalc_ray (uv+vec2(-dp/2.0, +dp/2.0))) * 0.25;\n\t#else\n\tfragColor = calc_ray (uv);\n\t#endif\n\t\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[724, 745, 771, 771, 910], [912, 912, 938, 938, 1077], [1079, 1079, 1105, 1105, 1244], [1246, 1246, 1290, 1290, 1407], [1410, 1410, 1450, 1450, 1499], [1501, 1501, 1541, 1541, 1584], [1702, 1702, 1761, 1761, 1894], [1896, 1896, 1944, 1944, 1981], [1983, 1983, 2034, 2034, 2274], [2276, 2276, 2318, 2318, 2578], [2580, 2580, 2611, 2611, 2637], [2638, 2638, 2669, 2669, 2696], [2698, 2698, 2727, 2727, 3184], [3185, 3185, 3211, 3211, 3425], [3427, 3427, 3446, 3508, 3609], [3611, 3611, 3663, 3663, 3932], [3934, 3934, 3982, 3982, 4270], [4272, 4272, 4317, 4317, 4558], [4560, 4560, 4585, 4585, 4682], [4684, 4684, 4709, 4709, 6009], [6012, 6012, 6069, 6069, 6393]], "test": "error"}
{"id": "4sXSDN", "name": "Light Grid", "author": "joko", "description": "Clone of my Android live wallpaper, Light Grid Pro - https://play.google.com/store/apps/details?id=com.joko.lightgridpro", "tags": ["grid", "light", "color", "joko"], "likes": 5, "viewed": 246, "published": "Public", "date": "1400873531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float RADIUS = 2.;\nconst float SOFTNESS = 0.85;\n\nfloat rand(vec2 n)\n{\n\treturn fract(sin(n.x*2732.7357+n.y*2542.3643)*4365.6247);\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n\tvec2 pos = (fragCoord.xy / iResolution.xy) * 2. - 1.;\n\tpos.x *= iResolution.x / iResolution.y;\n\t\n\tfloat scale = 10.;\n\tvec2 spot = floor(pos *scale)/scale;\n\tfloat base = rand(spot);\n\t\n\tfloat color = mod(base * time * .5, 2.);\n\tif(color > 1.) color = 2. - color;\n\tcolor = .75 * color + .25;\n\t\n\tfloat timePerc = mod(time * .1, 2.);\n\tif(timePerc > 1.) timePerc = 2. - timePerc;\n\t\n\tvec3 lefta = vec3(1., .5, 1.);\n\tvec3 leftb = vec3(0., .5, 1.);\n\tvec3 left = mix(lefta, leftb, timePerc);\n\t\n\tfloat timePerc2 = mod(time * .08, 2.);\n\tif(timePerc2 > 1.) timePerc2 = 2. - timePerc2;\n\t\n\tvec3 righta = vec3(0., 0., 1.);\n\tvec3 rightb = vec3(1., 1., 0.);\n\tvec3 right = mix(righta, rightb, timePerc2);\n\t\n\tvec3 squareColor = color * mix(left, right, pos.x);\n\t\n    float len = length(pos);\n    float vignette = smoothstep(RADIUS, RADIUS-SOFTNESS, len);\n\t\n\tfragColor = vec4(\n\t\tmix(squareColor, squareColor * vignette, .5), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 75, 75, 137], [138, 138, 195, 195, 1128]], "test": "valid"}
{"id": "ldfSDN", "name": "Magnifying Lens", "author": "slade", "description": "A shiny (spherical) lens which is magnifying a moving backdrop of Perlin noise.", "tags": ["noise", "refraction", "lens", "perlin", "fresnel", "magnifying"], "likes": 24, "viewed": 1638, "published": "Public", "date": "1401154784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Sort of a cross between https://www.shadertoy.com/view/MdXSD8 and\n//https://www.shadertoy.com/view/4dfSD4\n\n#define M_PI 3.1415926535\n#define ambientAmount 0.5\n#define specularAmount 0.5\n#define refractionIn 0.2\n#define refractionOut 1.0\n#define shininess 300.0\n\n//Light setup\nvec3 light = vec3(5.0, 5.0, 20.0);\n\n//Object setup\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0);\n//Functions \n\nvec2 iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t//sphere at origin has equation |xyz| = r\n\t//sp |xyz|^2 = r^2.\n\t//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\n\t//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\n\tvec3 oc = ro - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tvec2 t;\n\tif(h < 0.0) \n\t\tt = vec2(-1.0);\n\telse  {\n\t\tfloat sqrtH = sqrt(h);\n\t\tt.x = (-b - sqrtH); //Again a = 1.\n\t\tt.y = (-b + sqrtH);\n\t}\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph )\n{\n\treturn (pos - sph.xyz)/sph.w;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out vec2 resT)\n{\n\tresT = vec2(1000.0);\n\tfloat id = -1.0;\n\tvec2 tsph = iSphere(ro, rd, sph1); //Intersect with a sphere.\n\t\n\tif(tsph.x > 0.0 || tsph.y > 0.0)\n\t{\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\treturn id;\n}\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec4 getFragColor(float noiseValue) {\n\tvec4 fragColor;\n\tfragColor.r = fract(noiseValue);\n\tfragColor.g = fract(2. * fragColor.r);\n\tfragColor.b = fract(3. * fragColor.g);\n\tfragColor.a = 1.0;\n\treturn fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//pixel coordinates from 0 to 1\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t//generate a ray with origin ro and direction rd\n\tvec4 ro = vec4(0.0, 0.0, 1.5, 1.0);\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv) * vec2(aspectRatio, 1.0), -1.0));\n\t\n\t//intersect the ray with scene\n\tvec2 t;\n\tfloat id = intersect(ro.xyz, rd, t);\n\t\n\tvec3 col;\n\t//If we hit the sphere...\n\tif(id > 0.5 && id < 1.5)\n\t{\n\t\t//1) do Schlick approx of Fresnel lighting\n\t\tvec3 E = normalize(ro.xyz + t.x*rd);\n\t\tvec3 N = normalize(nSphere(E, sph1));\n\t\tvec3 L = normalize(light);\n\t\t\n\t\tvec3 reflectColor = vec3(ambientAmount);\n\t\tfloat lambertTerm = dot(N, L);\n\t\tif (lambertTerm > 0.0) {\n\t\t\tfloat w = pow(1.0 - max(0.0, dot(normalize(L+E), E)), 5.0);\n\t\t\t\n\t\t\treflectColor += (1.0-w)*pow(max(0.0, dot(reflect(-L, E), E)), shininess);\n\t\t}\n\t\t\n\t\t//2) do Fresnel refraction to look up the appropriate Perlin noise color\n\t\t//light goes in\n\t\tvec3 refractionVec = refract(rd, N, refractionIn);\n\t\t\n\t\t//light comes out\n\t\tfloat id2 = intersect(E, refractionVec, t);\n\t\tif (id2 > 0.5 && id2 < 1.5) {\n\t\t\tE += refractionVec * t.y;\n\t\t\tE = normalize(E);\n\t\t\tN = normalize(nSphere(E, sph1));\n\t\t\trefractionVec = refract(refractionVec, N, refractionOut);\n\t\t}\n\t\t\n\t\tvec3 noiseColor = getFragColor(cnoise(vec2(iTime + refractionVec.x + uv.x, refractionVec.y + uv.y))).rgb;\n\t\tcol = mix(noiseColor, reflectColor, reflectColor);\n\t}\n\telse\n\t\tcol = getFragColor(cnoise(vec2(iTime + uv.x, uv.y))).rgb;\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 382, 433, 648, 1030], [1032, 1053, 1094, 1094, 1127], [1129, 1129, 1185, 1185, 1371], [1373, 1818, 1839, 1839, 1888], [1890, 1890, 1912, 1912, 1949], [1951, 1951, 1979, 1979, 2031], [2033, 2033, 2052, 2052, 2092], [2094, 2118, 2140, 2140, 3182], [3184, 3184, 3221, 3221, 3393], [3395, 3395, 3452, 3485, 4964]], "test": "valid"}
{"id": "ldfSW4", "name": "The trees are breathing.", "author": "jld", "description": "Everyone's favorite use of complex arithmetic, with the main cardioid unrolled onto the bottom edge of the image (and also transformed into a large egg, it turns out).", "tags": ["2d", "fractal", "mandelbrot"], "likes": 7, "viewed": 242, "published": "Public", "date": "1400950849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\n#define N 53\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 rth = fragCoord.xy / iResolution.xy * 2.0 * M_PI;\n\trth.y *= iResolution.y / iResolution.x;\n\trth.x += (iTime / 60.0) * 2.0 * M_PI;\n\tvec2 z0 = (1.0 + rth.y) * vec2(cos(rth.x), sin(rth.x)) / 2.0;\n\tvec2 z1 = vec2(1.0, 0.0) - z0;\n\tvec2 c = vec2(z0.x * z1.x - z0.y * z1.y, z0.x * z1.y + z0.y * z1.x);\n\tvec2 a = c;\n\tfloat g = 1.0;\n\tfloat thresh = 10.0 + 6.0 * sin(iTime);\n\tvec3 color = vec3(1.0, 1.0, 1.0);\n\n\t// color += (1.0 + cos (iTime)) * vec3(0.0, 0.007, 0.01) * clamp(z1.x - z0.x, -2.0, 3.0);\n\t\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (dot(a, a) > thresh) {\n\t\t\tbreak;\n\t\t}\n\t\tg *= 0.9;\n\t    a = vec2(a.x * a.x - a.y * a.y, 2.0 * a.x * a.y) + c;\n\t}\n\n\tfragColor = vec4(g * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 107, 107, 792]], "test": "valid"}
{"id": "ldfSWn", "name": "Waves1", "author": "borisvanschooten", "description": "waves for my game\n", "tags": ["wavesformygame"], "likes": 5, "viewed": 172, "published": "Public", "date": "1398954206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) {\n\t// we use a smaller constant than the usual 43758.5453, because otherwise \n\t// the function returns 0 most of the time on some shaders\n\treturn fract(sin(dot(30.0*n, vec2(12.9898, 4.1414))) * 137.585453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n\tfloat height = 0.5 +\n\t\t\t0.25*sin(7.0*pos.x+1.0*iTime)\n\t\t\t+0.02*sin(67.4*pos.x+0.82*iTime)\n\t\t\t+0.015*sin(91.4*pos.x-0.93*iTime);\n\tif (pos.y < height) {\n\t\tfloat relposx = pos.x + 0.3*(pos.y - height);\n\t\tfloat depth = height - pos.y;\n\t\tif (depth < 0.03) {\n\t\t\tfloat dist = 0.2 + 500000.0*depth*depth*depth + 0.5*rand(pos);\n\t\t\t//if (dist>0.5) dist *= 5.0;\n\t\t\t//if (dist>5.0) dist *= 5.0;\n\t\t\t// derivative of height function\n\t\t\t//  sin(w*x)  =>  w*cos(w*x)\n\t\t\tfloat slope = 0.3 + \n\t\t\t\t0.25*7.0*cos(7.0*relposx+1.0*iTime)\n\t\t\t\t+0.02*67.4*cos(67.4*relposx+0.82*iTime)\n\t\t\t\t+0.015*91.4*cos(91.4*relposx-0.93*iTime);\n\t\t\tif (slope<0.0) slope=0.0;\n\t\t\tfragColor = vec4(\n\t\t\t\t0.1+0.08*slope/dist + 0.3*pos.y,\n\t\t\t\t0.1+0.08*slope/dist + 0.3*pos.y,\n\t\t\t\t1.0,1.0);\n\t\t} else {\n\t\t\tfragColor = vec4(\n\t\t\t\t0.1 + 0.3*pos.y,\n\t\t\t\t0.1 + 0.3*pos.y,\n\t\t\t\t1.0,1.0);\n\t\t}\n\t} else {\n\t\tfragColor = vec4(0.8-0.3*pos.y,0.8-0.3*pos.y,1.0,1.0);\n\t}\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 156, 227], [228, 228, 285, 285, 1308]], "test": "valid"}
{"id": "ldlSDn", "name": "Ying and Yang", "author": "LukasPukenis", "description": "Ying and Yang", "tags": ["yingandyang"], "likes": 2, "viewed": 153, "published": "Public", "date": "1399462656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat PI = 3.14159265359;\n\t\n\tfloat as = iResolution.x / iResolution.y;\n\t\n\tvec2 coords = fragCoord.xy / iResolution.xy;\n\tvec2 gcoords = vec2(as, 1.0)*(coords - vec2(0.5, 0.5));\n\t\n\tfloat r = 0.35*((1.0+sin(iTime))/2.0)+0.055;\n\tfloat thickness = 0.08;\n\t\n\tfloat fi = mod((atan(gcoords.y, gcoords.x)-((iTime*4.0)+PI)), PI) / (2.0*PI); // 0..1\n\t\t\t\n\tif (abs(distance(gcoords, vec2(0.0, 0.0)) - r) < thickness*fi) {\n\t  fragColor = vec4(fi, fi, fi, 1.0);\t\n\t} else {\n\t  fragColor = vec4(0.0, 0.0, 0.0, 1.0);\t\n\t}\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 564]], "test": "valid"}
{"id": "ldXSD8", "name": "triangleBarycenter", "author": "Impossible", "description": "some triangle", "tags": ["2d"], "likes": 1, "viewed": 143, "published": "Public API", "date": "1399946727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//stolen from black pawn :)\nbool pointInTri( vec2 A, vec2 B, vec2 C, vec2 P, out float u, out float v )\n{\n\t// Compute vectors        \n\tvec2 v0 = C - A;\n\tvec2 v1 = B - A;\n\tvec2 v2 = P - A;\n\n\t// Compute dot products\n\tfloat dot00 = dot(v0, v0);\n\tfloat dot01 = dot(v0, v1);\n\tfloat dot02 = dot(v0, v2);\n\tfloat dot11 = dot(v1, v1);\n\tfloat dot12 = dot(v1, v2);\n\n\t// Compute barycentric coordinates\n\tfloat invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n\tu = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\tv = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n\t// Check if point is in triangle\n\treturn (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat u,v;\n\tfloat cs = cos(iTime*2.0);\n\tfloat sn = sin(iTime*2.0);\n\t\n\tvec2 A = vec2( cs * -100.0 + sn * -50.0, sn * -100.0 - cs * -50.0 ) + iResolution.xy * vec2(0.5,0.5) + sn * vec2(0.0,150.0);\n\tvec2 B = vec2( cs * 100.0 + sn * -50.0, sn * 100.0 - cs * -50.0 ) + iResolution.xy * vec2(0.5,0.5) + sn * vec2(0.0,150.0);\n\tvec2 C = vec2( cs * -100.0 + sn * 100.0, sn * -100.0 - cs * 100.0 ) + iResolution.xy * vec2(0.5,0.5) + sn * vec2(0.0,150.0);\n\t\n\tif( pointInTri( A, B, C, fragCoord.xy,u,v))\n\t\tfragColor = texture(iChannel0, vec2(1.0,0.0) * u + vec2(0.0,1.0) * v + vec2(0.0,0.0) * ( 1.0 - ( u + v )))*vec4(1.0,0.0,0.0,1.0) * u + vec4(0.0,1.0,0.0,1.0) * v + vec4(0.0,0.0,1.0,1.0) * ( 1.0 - ( u + v ));\n\t else\n\t   fragColor = vec4(0.0,0.0,0.0,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXSD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 105, 133, 633], [635, 635, 692, 692, 1442]], "test": "error"}
{"id": "lsBXD1", "name": "GTC Conference", "author": "iq", "description": "A live coded shader during our talk at GTC 2014. You can see the live narration during the coding in this video: http://on-demand.gputechconf.com/gtc/2014/video/S4550-shadertoy-fragment-shader.mp4", "tags": ["procedural", "3d", "conference"], "likes": 10, "viewed": 2376, "published": "Public API", "date": "1400113883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Live coded demo during out talk at GTC 2014. Seee here for comentary:\n// http://on-demand.gputechconf.com/gtc/2014/video/S4550-shadertoy-fragment-shader.mp4\n\nfloat map( in vec3 p )\n{\n    \n    vec3 q = mod( p+2.0, 4.0 ) - 2.0;\n    \n \tfloat d1 = length( q ) - 1.0;\n    \n    d1 += 0.1*sin(10.0*p.x)*sin(10.0*p.y + iTime )*sin(10.0*p.z);\n    \n \tfloat d2 = p.y + 1.0;\n    \n    float k = 1.5;\n    float h = clamp( 0.5 + 0.5*(d1-d2)/k, 0.0, 1.0 );\n    return mix( d1, d2, h ) - k*h*(1.0-h);\n}\n\nvec3 calcNormal( in vec3 p ) \n{\n    vec2 e = vec2( 0.0001, 0.0 );\n     \n    return normalize( vec3( map(p+e.xyy) - map(p-e.xyy),\n                            map(p+e.yxy) - map(p-e.yxy),\n                            map(p+e.yyx) - map(p-e.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    \n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3( 0.0, 0.0, 2.0 );\n    \n    vec3 rd = normalize( vec3(p, -1.0) );\n    \n    vec3 col = vec3(0.0);\n    \n    \n    float tmax = 20.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<100; i++ ) \n    {\n        if( h<0.0001 || t>tmax ) break;\n        h = map( ro + t*rd );\n        t += h;\n    }\n    \n    vec3 lig = vec3(0.5773);\n    \n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n    \tcol  = vec3(1.0, 0.8, 0.5)*clamp( dot(nor,lig), 0.0, 1.0 );\n        col += vec3(0.2, 0.3, 0.4)*clamp( nor.y, 0.0, 1.0 );\n        col += vec3(1.0, 0.7, 0.2)*clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        col *= 0.8;        \n        col *= exp( -0.1*t );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsBXD1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 286, 310, 310, 613], [615, 615, 646, 646, 863], [865, 865, 922, 922, 1783]], "test": "valid"}
{"id": "lsfXWH", "name": "SH - visualizer", "author": "iq", "description": "Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For reference and fun.", "tags": ["3d", "sphericalharmonics", "spherical", "harmonics"], "likes": 93, "viewed": 8986, "published": "Public API", "date": "1400112883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For\n// reference and fun.\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // antialias level (try 1, 2, 3, ...)\n#endif\n\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SH( in int l, in int m, in vec3 s ) \n{ \n\tvec3 n = s.zxy;\n\t\n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n    if( l==3 && m==-3 ) return -k06*n.y*(3.0*n.x*n.x-n.y*n.y);\n    if( l==3 && m==-2 ) return  k07*n.z*n.y*n.x;\n    if( l==3 && m==-1 ) return -k08*n.y*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 0 ) return  k09*n.z*(5.0*n.z*n.z-3.0);\n    if( l==3 && m== 1 ) return -k08*n.x*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 2 ) return  k10*n.z*(n.x*n.x-n.y*n.y);\n    if( l==3 && m== 3 ) return -k06*n.x*(n.x*n.x-3.0*n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\n// unrolled version of the above\nfloat SH_0_0( in vec3 s ) { vec3 n = s.zxy; return  k01; }\nfloat SH_1_0( in vec3 s ) { vec3 n = s.zxy; return -k02*n.y; }\nfloat SH_1_1( in vec3 s ) { vec3 n = s.zxy; return  k02*n.z; }\nfloat SH_1_2( in vec3 s ) { vec3 n = s.zxy; return -k02*n.x; }\nfloat SH_2_0( in vec3 s ) { vec3 n = s.zxy; return  k03*n.x*n.y; }\nfloat SH_2_1( in vec3 s ) { vec3 n = s.zxy; return -k03*n.y*n.z; }\nfloat SH_2_2( in vec3 s ) { vec3 n = s.zxy; return  k04*(3.0*n.z*n.z-1.0); }\nfloat SH_2_3( in vec3 s ) { vec3 n = s.zxy; return -k03*n.x*n.z; }\nfloat SH_2_4( in vec3 s ) { vec3 n = s.zxy; return  k05*(n.x*n.x-n.y*n.y); }\nfloat SH_3_0( in vec3 s ) { vec3 n = s.zxy; return -k06*n.y*(3.0*n.x*n.x-n.y*n.y); }\nfloat SH_3_1( in vec3 s ) { vec3 n = s.zxy; return  k07*n.z*n.y*n.x; }\nfloat SH_3_2( in vec3 s ) { vec3 n = s.zxy; return -k08*n.y*(5.0*n.z*n.z-1.0); }\nfloat SH_3_3( in vec3 s ) { vec3 n = s.zxy; return  k09*n.z*(5.0*n.z*n.z-3.0); }\nfloat SH_3_4( in vec3 s ) { vec3 n = s.zxy; return -k08*n.x*(5.0*n.z*n.z-1.0); }\nfloat SH_3_5( in vec3 s ) { vec3 n = s.zxy; return  k10*n.z*(n.x*n.x-n.y*n.y); }\nfloat SH_3_6( in vec3 s ) { vec3 n = s.zxy; return -k06*n.x*(n.x*n.x-3.0*n.y*n.y); }\n\nvec3 map( in vec3 p )\n{\n    vec3 p00 = p - vec3( 0.00, 2.5,0.0);\n\tvec3 p01 = p - vec3(-1.25, 1.0,0.0);\n\tvec3 p02 = p - vec3( 0.00, 1.0,0.0);\n\tvec3 p03 = p - vec3( 1.25, 1.0,0.0);\n\tvec3 p04 = p - vec3(-2.50,-0.5,0.0);\n\tvec3 p05 = p - vec3(-1.25,-0.5,0.0);\n\tvec3 p06 = p - vec3( 0.00,-0.5,0.0);\n\tvec3 p07 = p - vec3( 1.25,-0.5,0.0);\n\tvec3 p08 = p - vec3( 2.50,-0.5,0.0);\n\tvec3 p09 = p - vec3(-3.75,-2.0,0.0);\n\tvec3 p10 = p - vec3(-2.50,-2.0,0.0);\n\tvec3 p11 = p - vec3(-1.25,-2.0,0.0);\n\tvec3 p12 = p - vec3( 0.00,-2.0,0.0);\n\tvec3 p13 = p - vec3( 1.25,-2.0,0.0);\n\tvec3 p14 = p - vec3( 2.50,-2.0,0.0);\n\tvec3 p15 = p - vec3( 3.75,-2.0,0.0);\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n\td=length(p00); n=p00/d; r = SH_0_0( n ); s = SHAPE; res = s;\n\td=length(p01); n=p01/d; r = SH_1_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p02); n=p02/d; r = SH_1_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p03); n=p03/d; r = SH_1_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p04); n=p04/d; r = SH_2_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p05); n=p05/d; r = SH_2_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p06); n=p06/d; r = SH_2_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p07); n=p07/d; r = SH_2_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p08); n=p08/d; r = SH_2_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p09); n=p09/d; r = SH_3_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p10); n=p10/d; r = SH_3_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p11); n=p11/d; r = SH_3_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p12); n=p12/d; r = SH_3_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p13); n=p13/d; r = SH_3_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p14); n=p14/d; r = SH_3_5( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p15); n=p15/d; r = SH_3_6( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 0.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t\tm = res.yz;\n        t += h*0.3;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 0.314*iTime - 10.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(6.0*sin(an),0.0,6.0*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.3) * clamp(1.0-length(p)*0.45,0.0,1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    // bad dither\n    tot += (1.0/255.0)*fract(sin(fragCoord.x+1111.0*fragCoord.y)*1111.0);\n    \n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfXWH.jpg", "access": "shaders20k", "license": "mit", "functions": [[1978, 2039, 2083, 2083, 3254], [3256, 3289, 3316, 3316, 3347], [3348, 3348, 3375, 3375, 3410], [3411, 3411, 3438, 3438, 3473], [3474, 3474, 3501, 3501, 3536], [3537, 3537, 3564, 3564, 3603], [3604, 3604, 3631, 3631, 3670], [3671, 3671, 3698, 3698, 3747], [3748, 3748, 3775, 3775, 3814], [3815, 3815, 3842, 3842, 3891], [3892, 3892, 3919, 3919, 3976], [3977, 3977, 4004, 4004, 4047], [4048, 4048, 4075, 4075, 4128], [4129, 4129, 4156, 4156, 4209], [4210, 4210, 4237, 4237, 4290], [4291, 4291, 4318, 4318, 4371], [4372, 4372, 4399, 4399, 4456], [4458, 4458, 4481, 4481, 6528], [6530, 6530, 6572, 6572, 6914], [6916, 6916, 6948, 6948, 7172], [7174, 7174, 7231, 7245, 8939]], "test": "valid"}
{"id": "lsfXWN", "name": "Fractals exploring", "author": "zugamifk", "description": "a simple way to look at fractals", "tags": ["fractal", "julia", "mandelbrot"], "likes": 0, "viewed": 197, "published": "Public", "date": "1401125107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {return vec2(a.x*b.x -  a.y*b.y, a.x*b.y + a.y*b.x);}\nvec2 cdiv(vec2 a, vec2 b) {return -cmul(a, b)/(b.x*b.x + b.y*b.y);}\n\n// complex conjugation\nvec2 conj(vec2 c) {return vec2(c.x, -c.y);}\n\nfloat usin(float x) {return 0.5 + 0.5*sin(x);}\nfloat ucos(float x) {return 0.5 + 0.5*cos(x);}\n\n\n// generate fractals\nvec3 cols(float t, vec2 uv, vec2 r) {\n\tfloat c = 1.0, xa = 1.0, ya = 1.0, xb = 1., yb = 1.;\n\tfloat esc = 1.;\n\n\tvec2 z = uv;\n\t//vec2 z = vec2(0.);\n\t\t\n\tvec2 o = vec2(sin(t), cos(t));\n\tfloat or = 3.14159/16.;\n\tvec2 o2 = vec2(0,0);//cos(t) - or*cos(1./or*t), sin(t) - or*sin(1./or*t));\n\n\tconst int iters = 128;\n\tconst float st = 1./float(iters);\n\tfloat bgb = 0.;\n\tfloat v = 0., u = r.x;\n\t\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t\n\t\t// mandelbrot set (set z = vec2(0.) above)\n\t\tz = cmul(z, z) + uv;\n\t\t\n\t\t// julia set\n\t\t//z = cmul(z, z) + r;\n\t\t\n\t\t// mandelbar set\n\t\t//z = cmul(conj(z), conj(z)) + r;\n\t\t\n\t\t// cubic fractals\n\t\t//z = cmul(cmul(z, z), z) + r;\n\t\t\n\t\t// burning ship\n\t\t//z = conj(cmul(abs(z), abs(z))) + uv;\n\t\t\n\t\t//nova fractal\n\t\t//z = z - 2.*cdiv(cmul(z, cmul(z, z)) - vec2(1., 0.), 3.*cmul(z, z));\n\t\t\n\t\t//ikeda map\n\t\t//v = 0.4 - 6./(1. + z.x*z.x + z.y*z.y);\n\t\t//z = vec2( 1. + u*(z.x*cos(v)-z.y*sin(v)), u*(z.x*sin(v)+z.y*cos(v)));\n\t\t\n\t\t//logistic map\n\t\t//z = r.x*cmul(z, vec2(z.x-1., z.y));\n\t\t\n\t\t//misc julia sets\n\t\t//z = exp(z) + r;\n\t\t//z = cmul(z, exp(z)) + r;\n\t\t//z = cmul(cmul(z, z), exp(z)) + r;\n\t\t//z = cdiv((cmul(z, z) + z), log(z)) + r;\n\t\t//z = cmul(cmul(z, z), r)-r;\n\t\t\n\t\tif ( i < 2 ) continue;\n\t\t\n\t\tfloat dist = length(o-z);\n\t\tif (dist > 1.) break;\n\t\t\n\t\txa = min(xa, abs(z.x-o.x));\n\t\tya = min(ya, abs(z.y-o.y));\n\t\n\t\txb = min(xb, abs(z.x-o2.x));\n\t\tyb = min(yb, abs(z.y-o2.y));\n\t\t\n\t\tesc = min(esc, dist);\n\t\tc = min(c, min(xa, ya));\n\t\tbgb += st;\n\t}\n\t\t\n\tvec3 c1 = vec3(0.000000, 0.627451, 0.690196);\n\tvec3 c2 = vec3(0.415686, 0.290196, 0.235294);\n\tvec3 c3 = vec3(0.800000, 0.200000, 0.247059);\n\tvec3 c4 = vec3(0.921569, 0.407843, 0.254902);\n\tvec3 c5 = vec3(0.929412, 0.788235, 0.317647);\n\tvec3 c6 = vec3(0.286275, 0.039216, 0.239216);\n\tvec3 c7 = vec3(0.541176, 0.607843, 0.058824);\n\tvec3 c8 = vec3(0.972549, 0.792157, 0.000000);\n\t\n\tfloat b = exp(-c);\n\tfloat ex = exp(-xa*xa);\n\tfloat ey = exp(-ya*ya);\n\t\n\tvec3 bg = ucos(pi*ex)*c1 + usin(pi*(ex+ey))*c2;\n\t//if (b > .99) return exp(-(1.-b)*300.)*c8;\n\treturn 1.5*bg-1.+ 1.5*(exp(-xb*xb)*c6+ exp(-yb*yb)*c5) + (1.-esc)*c7;\n}\n\n// aa, transformations\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\t\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tm = m * 2.0 - 1.0;\n\tm.x *= iResolution.x/iResolution.y;\n\t\n\tfloat t = iTime;\n\n\t//uv /= exp(t);\n\t\n\t// antialiasing\n\tconst int aa = 3;\n\tvec2 px = 1./(iResolution.xy*float(aa));\n\t\n\tvec3 c = vec3(0.);\n\t\n\tfor (int x = 0; x < aa; x++) {\n\t\tfor (int y = 0; y < aa; y++) {\n\t\t\tc += cols(t, uv + vec2(px.x*float(x), px.y*float(y)), m);\t\n\t\t}\n\t}\n\tc /= float(aa*aa);\n\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfXWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 53, 80, 80, 132], [133, 133, 160, 160, 200], [202, 225, 244, 244, 268], [270, 270, 291, 291, 316], [317, 317, 338, 338, 363], [366, 387, 424, 424, 2467], [2469, 2492, 2549, 2549, 3074]], "test": "valid"}
{"id": "lslSDn", "name": "xored psycho", "author": "LukasPukenis", "description": "xored psycho", "tags": ["xor"], "likes": 2, "viewed": 139, "published": "Public", "date": "1399465088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sinZeroOne(float what) {\n  return (1.0 + sin(what)) / 2.0;\n}\n\nfloat sinZeroOne() {\n  return (1.0 + sin(iTime*4.0)) / 2.0;\n}\n\n\nvec4 generateXORTexture(vec2 coords, float size, float dash, float tolerance) {\n\tvec4 color = vec4(0.0);\n\t\n\tif (abs(mod(coords.x, size)) <= tolerance || abs(mod(coords.y, size)) <= tolerance) {\n\t\tif (mod(coords.x, dash*2.0) <= dash ^^ mod(coords.y, dash*2.0) <= dash) {\n\t\t    color = vec4(0.0, 0.0, 1.0, 1.0);\t\n\t\t} else {\n\t\t\tcolor = vec4(1.0, 1.0, 1.0, 1.0);\t\n\t\t}\n\t} else {\n\t\tif (mod(coords.x, size*2.0) <= size ^^ mod(coords.y, size*2.0) <= size) {\n\t\t\tcolor = vec4(sinZeroOne(), sinZeroOne(coords.x), sinZeroOne(coords.y), 1.0);\t\n\t\t} else {\n\t\t    color = vec4(sinZeroOne(coords.y), sinZeroOne(), sinZeroOne(coords.x), 1.0);\t\t\n\t\t}\t  \n\t}\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat size = 30.0;\n\tfloat dash = 1.0;\n\tfloat tolerance = 1.0;\n\tvec2 center = vec2(iResolution.x / 2.0, iResolution.y / 2.0);\n\tvec2 coords = fragCoord.xy - center;\t\n\t\n\tfloat fi = iTime*1.0;\n\t\n    coords *= mat2(\n\t  cos(fi), -sin(fi),\n\t  sin(fi), cos(fi)\n\t);\n\t\n\tcoords /= vec2(1.0 + sinZeroOne()*2.0);\n\t\n\tfloat blur = (1.0 + sin(iTime*sinZeroOne()*0.02)) / 2.0;\n\tblur *= 0.1 * distance(fragCoord.xy, center);\n\t\n\tvec2 K = vec2(\n\t\tdistance(fragCoord.xy, center),\n\t\tdistance(fragCoord.xy, center)\n\t);\n\t\t\n\tK *= vec2(0.05, 0.05);\n\tsize -= length(K);\n\t\t\t\t   \n\tvec4 colorUP    = generateXORTexture( coords+vec2( 0.0,  -blur), size, dash, tolerance);\n\tvec4 colorDOWN  = generateXORTexture( coords+vec2( 0.0,   blur), size, dash, tolerance);\n\tvec4 colorLEFT  = generateXORTexture( coords+vec2(-blur,  0.0), size, dash, tolerance);\n\tvec4 colorRIGHT = generateXORTexture( coords+vec2( blur,  0.0), size, dash, tolerance);\n\n\tvec4 colorDUL = generateXORTexture( coords+vec2(-blur, -blur), size, dash, tolerance);\n\tvec4 colorDUR = generateXORTexture( coords+vec2( blur,  blur), size, dash, tolerance);\n\tvec4 colorDBL = generateXORTexture( coords+vec2(-blur,  blur), size, dash, tolerance);\n\tvec4 colorDBR = generateXORTexture( coords+vec2( blur,  blur), size, dash, tolerance);\n\n\tvec4 color = colorUP+colorDOWN+colorLEFT+colorRIGHT +  colorDUL + colorDUR + colorDBL + colorDBR;\n\tcolor = color / vec4(8.0);\n\t\t\n\tcolor -= mix(\n\t\tvec4(0.0),\n\t\tvec4(1.0),\n\t\tsmoothstep(0.0, min(iResolution.x, iResolution.y), distance( fragCoord.xy, center)));\n\t\t\n\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 66], [68, 68, 88, 88, 129], [132, 132, 211, 211, 785], [787, 787, 844, 844, 2393]], "test": "valid"}
{"id": "lslSWH", "name": "Dancing Quaternion Julia Set", "author": "aarongolliver", "description": "click and drag mouse to change two components of the system.\nthe other two components are modulated by iChannel0", "tags": ["julia", "ray", "raymarch", "quaternion", "equalizer", "march"], "likes": 1, "viewed": 607, "published": "Public", "date": "1400430093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define SUPERSAMP\n\nstruct quaternion\n{\n\tvec4 d;\n};\n\n\nquaternion qtimes(in quaternion a, in quaternion b){\n    float y0 = dot(a.d.xyzw, b.d.xyzw * vec4(1., -1., -1., -1.));\n    float y1 = dot(a.d.xyzw, b.d.yxwz * vec4(1.,  1.,  1., -1.));\n    float y2 = dot(a.d.xyzw, b.d.zwxy * vec4(1., -1.,  1.,  1.));\n    float y3 = dot(a.d.xyzw, b.d.wzyx * vec4(1.,  1., -1.,  1.));\n\n    quaternion q;\n    q.d = vec4(y0, y1, y2, y3);\n\n    return q;\n}\n\nquaternion qtimes(in float f, in quaternion a){\n\tquaternion q;\n\tq.d = vec4(f) * a.d;\n\treturn q;\n}\n\nquaternion qplus(in quaternion a, in quaternion b){\n\tquaternion q;\n\tq.d = a.d + b.d;\n\n\treturn q;\n}\n\nfloat qabsq(in quaternion q){\n\treturn dot(q.d, q.d);\n}\n\nfloat calcDistance(quaternion z, quaternion c){\n\tquaternion dz;\n\tdz.d = vec4(1., 0., 0., 0.);\n\n\tfloat m2 = 0.;\n\tfloat keep_going = 1.;\n\n\n\tfor(float i = 0.; i < 12.; i++){\n\t\tif(keep_going > 0.){\n\t\t\tdz = qtimes(2., qtimes(dz,z));\n\t\t\tz = qplus(qtimes(z,z), c);\n\t\t\tm2 = qabsq(z);\n\t\t\tif(m2 > 100.){\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sqrt(m2/qabsq(dz)) * 0.5 * log(sqrt(m2));\n}\n\nfloat calcDistance_atDelta(in vec3 surf_center, in quaternion c, in vec3 delta){\n\tvec3 z_pos = surf_center + delta;\n\tquaternion z;\n\tz.d = vec4(z_pos.x, z_pos.y, z_pos.z, 0.);\n\n\treturn calcDistance(z, c);\n}\n\nvec3 make_abs(in vec3 v){\n\treturn vec3(abs(v.x), abs(v.y), abs(v.z));\n}\n\nfloat cam_slow = 25.;\nvec4 do_everything(in vec3 e,\n\t\t\t\t   in vec3 w,\n\t\t\t\t   in vec3 u,\n\t\t\t\t   in vec3 v,\n\t\t\t\t   in quaternion c,\n\t\t\t\t   in float l,\n\t\t\t\t   in float r,\n\t\t\t\t   in float t,\n\t\t\t\t   in float b,\n\t\t\t\t   in float d,\n\t\t\t\t   in float dx,\n\t\t\t\t   in float dy,\n                  in vec2 fragCoord){\n\tfloat rad = 2.;\n\tfloat U = l + (r - l) * (fragCoord.x + dx) / (iResolution.x);\n\tfloat V = b + (t - b) * (fragCoord.y + dy) / (iResolution.y);\n\n\tvec3 ray_dir = normalize(w*vec3(-d) + u * vec3(U) + v * vec3(V));\n\tvec3 ray_e = e;\n\tfloat MAX_DIST = 2. * length(e);\n\n\n\tquaternion z0;\n\tz0.d = vec4(ray_e, 0.);\n\n\tfloat init_dist = calcDistance(z0, c);\n\n\tfloat dist = init_dist;\n\n\tconst float max_iters = 64.;\n\tfloat marched_iters = 0.;\n\tfloat keep_going = 1.;\n\n\tconst float alpha = 0.0001;\n\tconst float clarity = 0.;\n\n\tfor(float iters = 0.; iters < max_iters; iters++){\n\t\tif(keep_going > 0.){\n\t\t\tvec3 z2_pos = ray_e + ray_dir * vec3(dist);\n\n\t\t\tquaternion z2;\n\t\t\tz2.d = vec4(z2_pos, 0.);\n\n\t\t\tfloat newdist = calcDistance(z2, c);\n\t\t\tif(abs(dist) > MAX_DIST || abs(newdist) > MAX_DIST || (keep_going > 0. && dist == 0.)){\n\t\t\t\tdist = 0.;\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\n\t\t\tif(newdist < alpha * pow(dist, clarity)){\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\n\t\t\tdist += newdist * keep_going;\n\t\t\tmarched_iters = marched_iters + keep_going;\n\t\t}\n\t}\n\n\tif(dist == 0.){\n\t\treturn vec4(0.33,0.,0.,0.);\n\t} else {\n\t\tfloat AO_VEC = max(1. - marched_iters / max_iters, .05);\n\t\tvec3 grad_center = ray_e + ray_dir * vec3(dist);\n\t\t//float grad_delta = 0.0001;\n\t\tfloat grad_delta = alpha * pow(dist, clarity);\n\t\t// calculate gradiant!\n\t\tfloat dist_left  = calcDistance_atDelta(grad_center, c, vec3(grad_delta) * u);\n\t\tfloat dist_right = calcDistance_atDelta(grad_center, c, vec3(-grad_delta) * u);\n\t\tfloat dist_up    = calcDistance_atDelta(grad_center, c, vec3(-grad_delta) * v);\n\t\tfloat dist_down  = calcDistance_atDelta(grad_center, c, vec3(grad_delta) * v);\n\t\tfloat dist_for    = calcDistance_atDelta(grad_center, c, vec3(-grad_delta) * ray_dir);\n\t\tfloat dist_bak  = calcDistance_atDelta(grad_center, c, vec3(grad_delta) * ray_dir);\n\t\tvec3 GRAD_VEC = normalize(make_abs(vec3((dist_left - dist_right) / (2. * grad_delta),\n\t\t\t                                    (dist_up   - dist_down)  / (2. * grad_delta),\n\t\t\t                                    (dist_for  - dist_bak)   / (2. * grad_delta))));\n\t\t\n\t\t// done with gradiant\n\n\n\t\tvec3 light_pos = vec3(rad * sin(iTime / cam_slow), rad * cos(iTime / cam_slow), rad);\n\t\t\n\t\tvec3 ray_light_e = ray_e + ray_dir * vec3(dist * .99);\n\t\tvec3 ray_light_dir = normalize(light_pos - ray_light_e);\n\t\t\n\t\tfloat dist_to_light = abs(distance(light_pos, ray_light_e));\n\n\t\tkeep_going = 1.;\n\t\tmarched_iters = 0.;\n\t\tdist = 0.;\n\t\tconst float max_iters_l = max_iters;\n\t\tfor(float iters = 0.; iters < max_iters_l; iters++){\n\t\t\tvec3 z2_pos = ray_light_e + ray_light_dir * vec3(dist);\n\n\t\t\tquaternion z2;\n\t\t\tz2.d = vec4(z2_pos.x, z2_pos.y, z2_pos.z, 0.);\n\n\t\t\tfloat newdist = calcDistance(z2, c);\n\t\t\tif(abs(dist) > MAX_DIST || abs(newdist) > MAX_DIST || (keep_going == 0. && dist == 0.)){\n\t\t\t\tdist = 0.;\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\n\t\t\tif(newdist < alpha * pow(dist, clarity)){\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\n\t\t\tdist += newdist * keep_going;\n\t\t\tmarched_iters = marched_iters + keep_going;\n\t\t}\n\n\t\tfloat LIGHT_VEC = 1.;\n\t\tif(dist == 0. || dist > dist_to_light){\n\t\t\tLIGHT_VEC = 1.;\n\t\t} else {\n\t\t\tLIGHT_VEC = .5;\n\t\t}\n\n\t\tvec3 COL_VEC = LIGHT_VEC * AO_VEC * GRAD_VEC;\n\t\treturn vec4(COL_VEC, 1.);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat bandIntensity0 = texture(iChannel0, vec2(0.25, 0.15)).x;\n\tfloat bandIntensity1 = texture(iChannel0, vec2(0.35, 0.0)).x;\n\tfloat bandIntensity2 = texture(iChannel0, vec2(0.65, 0.45)).x;\n\tfloat bandIntensity3 = texture(iChannel0, vec2(0.15, 0.0)).x;\n\n\t// ray generation\n\tfloat rad = 2.;\n\tfloat e_x = rad * sin(iTime / cam_slow);\n\tfloat e_y = rad * cos(iTime / cam_slow);\n\tfloat e_z = 0.;\n\n\t#ifdef SUPERSAMP\n\tfloat SS = 2.;\n\t#else\n\tfloat SS = 1.;\n\t#endif\n\t\n\tfloat l = -iResolution.x * SS;\n\tfloat r =  iResolution.x * SS;\n\tfloat t =  iResolution.y * SS;\n\tfloat b = -iResolution.y * SS;\n\tfloat d =  iResolution.y * SS;\n\n\tvec3 e = vec3(e_x, e_y, e_z);\n\tvec3 lookpoint = vec3(0.,0.,0.);\n\tvec3 upnorm = vec3(0.,0.,1.);\n\n\n\tvec3 lookdir = lookpoint - e;\n\n\tvec4 TOTAL_COLOR = vec4(0.);\n\n\tvec3 w = normalize(lookdir) * vec3(-1., -1., -1.);\n\tvec3 u = normalize(cross(upnorm, w));\n\tvec3 v = normalize(cross(w, u));\n\n\tquaternion c;\n\tc.d.x = (iMouse.x > 0. ? iMouse.x / iResolution.x * 2. - 1. : -1.0);\n\tc.d.z = (iMouse.x > 0. ? iMouse.y / iResolution.y * 2. - 1. :  0.0);\n\tc.d.y = bandIntensity2/1.5;\n\tc.d.w = bandIntensity3/1.5;\n\t\n\tTOTAL_COLOR += do_everything(e, w, u, v, c, l, r, t, b, d, 0., 0., fragCoord);\n\t#ifdef SUPERSAMP\n\tTOTAL_COLOR += do_everything(e, w, u, v, c, l, r, t, b, d, 1./SS, 0., fragCoord);\n\tTOTAL_COLOR += do_everything(e, w, u, v, c, l, r, t, b, d, 1./SS, 1./SS, fragCoord);\n\tTOTAL_COLOR += do_everything(e, w, u, v, c, l, r, t, b, d, 0., 1./SS, fragCoord);\n\t#endif\n\n\tfragColor = TOTAL_COLOR / vec4(SS*SS);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 107, 107, 439], [441, 441, 488, 488, 538], [540, 540, 591, 591, 638], [640, 640, 669, 669, 694], [696, 696, 743, 743, 1075], [1077, 1077, 1157, 1157, 1282], [1284, 1284, 1309, 1309, 1355], [1379, 1379, 1659, 1659, 4820], [4822, 4822, 4879, 4879, 6403]], "test": "error"}
{"id": "lslXDn", "name": "Colorful tessellation", "author": "nimitz", "description": "Drag mouse horizontally to increase frequency, Drag mouse vertically to change the minkowski order.\nUsing glsl derivatives for lighting, faster but somewhat pixelated.", "tags": ["2d", "grid", "2dlighting", "glslderivatives"], "likes": 34, "viewed": 1655, "published": "Public", "date": "1399486758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Colorful tessellation by nimitz (stormoid.com) (twitter: @stormoid)\n// https://www.shadertoy.com/view/lslXDn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//flat version\n//#define flat\n\n#define WARP_ORDER 1.\n\n#define time iTime\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm( in vec2 p )\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tp *= 0.25;\n\tfor (float i= 1.;i < 6.;i++ )\n\t{\n\t\trz+= (sin(noise(p)*5.)*0.5+0.5) /z;\n\t\tz = z*2.;\n\t\tp = p*2.*m2;\n\t}\n\treturn rz;\n}\n\nvec2 field4( in vec2 x )\n{\n\tvec2 n = floor(x);\n\tvec2 f = fract(x);\n\n\tvec2 m = vec2(5.,0.);\n\t//4 samples\n\tfor(int j=0; j<=1; j++)\n\tfor(int i=0; i<=1; i++)\n    {\n\t\tvec2 g = vec2( float(i),float(j) );\n\t\tvec2 r = g - f;\n\t\tfloat minkpow = (iMouse.y/iResolution.x)*3.+.8;\n\t\tfloat d = pow(pow(abs(r.x),minkpow)+pow(abs(r.y),minkpow),1./minkpow)*.5;\n\t\td *= (iMouse.x/iResolution.x)*1.4+.5;\n\t\td = sin(d*10.+time*0.1);\n\t\tm.x *= d;\n\t\tm.y += d*1.2;\n    }\n\treturn pow(abs(m),vec2(0.8));\n}\n\nvec2 warp(vec2 uv, vec2 p, float offset)\n{\n\tuv -= p;\n\tfloat minkpow = WARP_ORDER;\n\tfloat d = pow(pow(abs(uv.x),minkpow)+pow(abs(uv.y),minkpow),1./minkpow);\n\tuv /= pow(d,2.)*1.-offset;\n\tuv += p;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*= 5.;\n\t\n\t#ifndef flat\n\tp = warp(p,vec2(0.),-.1);\n\t#endif\n\t\n\tvec2 rz = field4(p);\n\t\n\tvec3 col = sin(vec3(.9,0.6,0.2)*rz.y*1.4)*rz.x;\n\tcol = pow(col,vec3(.99))*.85;\n\t\n\t//lights\n\tvec3 ligt = normalize(vec3(sin(time)*10.,1.,cos(time)*10.));\n\tvec3 nor = normalize(vec3(dFdx(rz.y), .08, dFdy(rz.y)));\n\t\n\t//fbm variation on the normals\n\tnor.xz *= fbm(p*4.);\n\tvec3 bnor = nor;\n\tnor.yz *= fbm(p*2.);\n\t\n\tfloat dif = clamp(dot( nor,ligt ),0.0,1.0)*1.9;\n\tcol *= 0.5+.4*dif;\n\tcol *= 1.+3e2*pow(abs(dot(bnor,ligt)), 30.);\n\t\n\t//simple fbm \"texturing\"\n\tcol *= fbm(p*70.)*0.2+0.85;\n\t\n\t//vignetting\n\tcol *= 1.-pow(dot(p,p),3.)*0.9e-4;\n\t\n\tfragColor = vec4(pow(col,vec3(0.6))-0.1,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslXDn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[249, 323, 347, 347, 412], [413, 413, 438, 438, 474], [521, 521, 545, 545, 703], [705, 705, 731, 731, 1180], [1182, 1182, 1224, 1224, 1389], [1391, 1391, 1448, 1448, 2201]], "test": "error"}
{"id": "lslXDr", "name": "Atmospheric Scattering Sample", "author": "gltracy", "description": "sample codes of atmosphere scattering based on the article in GPU Gems2 : https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html", "tags": ["scatter"], "likes": 306, "viewed": 23491, "published": "Public", "date": "1399715752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Written by GLtracy\n\n// math const\nconst float PI = 3.14159265359;\nconst float MAX = 10000.0;\n\n// ray intersects sphere\n// e = -b +/- sqrt( b^2 - c )\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      8pi * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n// Rayleigh\n// g : 0\n// F = 3/16PI * ( 1 + c^2 )\nfloat phase_ray( float cc ) {\n\treturn ( 3.0 / 16.0 / PI ) * ( 1.0 + cc );\n}\n\n// scatter const\nconst float R_INNER = 1.0;\nconst float R = R_INNER + 0.5;\n\nconst int NUM_OUT_SCATTER = 8;\nconst int NUM_IN_SCATTER = 80;\n\nfloat density( vec3 p, float ph ) {\n\treturn exp( -max( length( p ) - R_INNER, 0.0 ) / ph );\n}\n\nfloat optic( vec3 p, vec3 q, float ph ) {\n\tvec3 s = ( q - p ) / float( NUM_OUT_SCATTER );\n\tvec3 v = p + s * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v, ph );\n\t\tv += s;\n\t}\n\tsum *= length( s );\n\t\n\treturn sum;\n}\n\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tconst float ph_ray = 0.05;\n    const float ph_mie = 0.02;\n    \n    const vec3 k_ray = vec3( 3.8, 13.5, 33.1 );\n    const vec3 k_mie = vec3( 21.0 );\n    const float k_mie_ex = 1.1;\n    \n\tvec3 sum_ray = vec3( 0.0 );\n    vec3 sum_mie = vec3( 0.0 );\n    \n    float n_ray0 = 0.0;\n    float n_mie0 = 0.0;\n    \n\tfloat len = ( e.y - e.x ) / float( NUM_IN_SCATTER );\n    vec3 s = dir * len;\n\tvec3 v = o + dir * ( e.x + len * 0.5 );\n    \n    for ( int i = 0; i < NUM_IN_SCATTER; i++, v += s ) {   \n\t\tfloat d_ray = density( v, ph_ray ) * len;\n        float d_mie = density( v, ph_mie ) * len;\n        \n        n_ray0 += d_ray;\n        n_mie0 += d_mie;\n        \n#if 0\n        vec2 e = ray_vs_sphere( v, l, R_INNER );\n        e.x = max( e.x, 0.0 );\n        if ( e.x < e.y ) {\n           continue;\n        }\n#endif\n        \n        vec2 f = ray_vs_sphere( v, l, R );\n\t\tvec3 u = v + l * f.y;\n        \n        float n_ray1 = optic( v, u, ph_ray );\n        float n_mie1 = optic( v, u, ph_mie );\n\t\t\n        vec3 att = exp( - ( n_ray0 + n_ray1 ) * k_ray - ( n_mie0 + n_mie1 ) * k_mie * k_mie_ex );\n        \n\t\tsum_ray += d_ray * att;\n        sum_mie += d_mie * att;\n\t}\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n    vec3 scatter =\n        sum_ray * k_ray * phase_ray( cc ) +\n     \tsum_mie * k_mie * phase_mie( -0.78, c, cc );\n    \n\t\n\treturn 10.0 * scatter;\n}\n\n// angle : pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( radians( 90.0 - fov * 0.5 ) );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 3.0 );\n\n\t// rotate camera\n\tmat3 rot = rot3xy( vec2( 0.0, iTime * 0.5 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// sun light dir\n\tvec3 l = vec3( 0.0, 0.0, 1.0 );\n\t\t\t  \n\tvec2 e = ray_vs_sphere( eye, dir, R );\n\tif ( e.x > e.y ) {\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\tvec2 f = ray_vs_sphere( eye, dir, R_INNER );\n\te.y = min( e.y, f.x );\n\n\tvec3 I = in_scatter( eye, dir, e, l );\n\t\n\tfragColor = vec4( pow( I, vec3( 1.0 / 2.2 ) ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslXDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 152, 201, 201, 384], [386, 583, 630, 630, 801], [803, 852, 881, 881, 927], [929, 1068, 1103, 1103, 1161], [1163, 1163, 1204, 1204, 1420], [1422, 1422, 1475, 1475, 2821], [2823, 2845, 2872, 2872, 3028], [3030, 3047, 3095, 3095, 3265], [3267, 3267, 3324, 3344, 3918]], "test": "valid"}
{"id": "lssXD4", "name": "Float", "author": "AlexPer76", "description": "Ball, water and waves", "tags": ["3d", "raymarching"], "likes": 53, "viewed": 3068, "published": "Public", "date": "1401554836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPSILON .001\n\n#define M_PI 3.14159265358979\n\nconst vec3 LightSource = vec3(2., 1.5, 0);\n\nvec3 WaterColor = vec3(0.4, 0.9, 1);\n\nconst float WaterHeight = 0.0;\nconst float MaxWaveAmplitude = 0.04;\n\nconst float HeightPool = 1.;\nconst float HalfSizePool = 3.;\nconst float DepthPool = 2.;\n\nstruct MaterialInfo {\n\tvec3 Kd;\n\tfloat Shininess;\n};\n\nfloat CyclicTime()\n{\n\treturn mod(iTime, 30.);\n}\n\nfloat WaveAmplitude() {\n\treturn MaxWaveAmplitude * exp(-CyclicTime() / 10.);\n}\n\nfloat WaterWave(vec3 a) {\n\treturn WaveAmplitude() * sin((2. * a.x * a.x + 2. * a.z * a.z) - 10. * CyclicTime());\n}\n\nfloat BallOscillation() {\n\treturn sin(5. * CyclicTime() + 4.) * exp(-CyclicTime() / 6.) + 0.3;\n}\n\nfloat PoolBottom(vec3 a) {\n\treturn a.y + DepthPool + .01;\n}\n\nfloat BackWall(vec3 a) {\n\treturn a.z + HalfSizePool + .01;\n}\n\nfloat LeftWall(vec3 a) {\n\treturn a.x + HalfSizePool + .01;\n}\n\nfloat WaterSurface(vec3 a) {\n\tvec3 sz = vec3(HalfSizePool, 0, HalfSizePool);\n\treturn length(max(abs(a + vec3(0, WaterWave(a), 0)) - sz, 0.));\n}\n\nfloat Pool(vec3 a) {\n\treturn min(PoolBottom(a), min(LeftWall(a), BackWall(a)));\n}\n\nfloat Ball(vec3 a) {\n\treturn length(a + vec3(0., BallOscillation(), 0.)) - 0.75;\n}\n\nfloat Scene(vec3 a) {\n\treturn min(WaterSurface(a), min(Ball(a), Pool(a)));\n}\n\nbool IsWaterSurface(vec3 a)\n{\n\tfloat closest = Ball(a);\n\tfloat dist = Pool(a);\n\tif (dist < closest) {\n\t\tclosest = dist;\n\t}\t\n\tdist = WaterSurface(a);\n\tif (dist < closest) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsWater(vec3 pos)\n{\n\treturn (pos.y < (WaterHeight - MaxWaveAmplitude));\n}\n\nvec3 PoolColor(vec3 pos) {\t\t\n\tif ((pos.y > HeightPool) || (pos.x > HalfSizePool) || (pos.z > HalfSizePool)) \n\t\treturn vec3(0.0);\n\tfloat tileSize = 0.2;\n\tfloat thickness = 0.015;\n\tvec3 thick = mod(pos, tileSize);\n\tif ((thick.x > 0.) && (thick.x < thickness) || (thick.y > 0.) && (thick.y < thickness) || (thick.z > 0.) && (thick.z < thickness))\n\t\treturn vec3(1);\n\treturn vec3(sin(floor((pos.x + 1.) / tileSize)) * cos(floor((pos.y + 1.) / tileSize)) * sin(floor((pos.z + 1.) / tileSize)) + 3.);\n}\n\nMaterialInfo Material(vec3 a) {\n\tMaterialInfo m = MaterialInfo(vec3(.5, .56, 1.), 50.);\n\tfloat closest = Ball(a);\n\n\tfloat dist = WaterSurface(a);\n\tif (dist < closest) {\n\t\tclosest = dist;\n\t\tm.Kd = WaterColor;\n\t\tm.Shininess = 120.;\n\t}\n\tdist = Pool(a);\n\tif (dist < closest) {\n\t\tm.Kd = PoolColor(a);\t\t\n\t\tm.Shininess = 0.;\n\t}\n\treturn m;\n}\n\nvec3 Normal(vec3 a) {\n\tvec2 e = vec2(.001, 0.);\n\tfloat s = Scene(a);\n\treturn normalize(vec3(\n\t\tScene(a+e.xyy) - s,\n\t\tScene(a+e.yxy) - s,\n\t\tScene(a+e.yyx) - s));\n}\n\nfloat Occlusion(vec3 at, vec3 normal) {\n\tfloat b = 0.;\n\tfor (int i = 1; i <= 4; ++i) {\n\t\tfloat L = .06 * float(i);\n\t\tfloat d = Scene(at + normal * L);\t\t\n\t\tb += max(0., L - d);\n\t}\n\treturn min(b, 1.);\n}\n\nvec3 LookAt(vec3 pos, vec3 at, vec3 rDir) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0., 1., 0.));\n\tvec3 u = cross(r, f);\n\treturn mat3(r, u, -f) * rDir;\n}\n\nfloat Trace(vec3 rPos, vec3 rDir, float distMin) {\n\tfloat L = distMin;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\tfloat d = Scene(rPos + rDir * L);\n\t\tL += d;\n\t\tif (d < EPSILON * L) break;\n\t}\n\treturn L;\n}\n\nvec3 Lighting(vec3 at, vec3 normal, vec3 eye, MaterialInfo m, vec3 lColor, vec3 lPos) {\n\tvec3 lDir = lPos - at;\n\t\n\tvec3 lDirN = normalize(lDir);\n\tfloat t = Trace(at, lDirN, EPSILON*2.);\n\tif (t < length(lDir)) {\n\t\tvec3 pos = at + lDirN * t;\n\t\tif(!IsWaterSurface(pos))\n\t\t\treturn vec3(0.);\n\t}\n\tvec3 color = m.Kd * lColor * max(0., dot(normal, normalize(lDir)));\n\t\n\tif (m.Shininess > 0.) {\n\t\tvec3 h = normalize(normalize(lDir) + normalize(eye - at));\n\t\tcolor += lColor * pow(max(0., dot(normal, h)), m.Shininess) * (m.Shininess + 8.) / 25.;\n\t}\n\treturn color / dot(lDir, lDir);\n}\n\nvec3 Shade(vec3 rpos, vec3 rdir, float t)\n{\n\tvec3 pos = rpos + rdir * t;\n\tvec3 nor = Normal(pos);\n\t\n\tbool waterSurface = IsWaterSurface(pos);\n\tbool water = IsWater(pos);\n\tvec3 waterSurfaceLight = vec3(0);;\n\tif (waterSurface)\n\t{\n\t\tvec3 refractionDir = refract(normalize(rdir), nor, 0.9);\n\n\t\twaterSurfaceLight = Lighting(pos, nor, rpos, Material(pos), vec3(1.), LightSource);\n\n\t\tfloat wt = Trace(pos, refractionDir, 0.03);\t\t\n\t\tpos += refractionDir * wt;\n\t\tnor = Normal(pos);\n\t}\n\tMaterialInfo mat = Material(pos);\n\n\tvec3 color = .11 * (1. - Occlusion(pos, nor)) * mat.Kd;\n\n\tcolor += Lighting(pos, nor, rpos, mat, vec3(1.), LightSource);\n\t\n\tif (water || waterSurface) {\n\t\tcolor *= WaterColor;\n\t\tif (waterSurface)\n\t\t\tcolor += waterSurfaceLight;\n\t}\n\treturn color;\n}\n\nvec3 Camera(vec2 px) {\n\tvec2 uv = px.xy / iResolution.xy * 2. - 1.;\t\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 rayStart = vec3(3.5, 1.7, 6.);\n\tvec3 rayDirection = LookAt(rayStart, vec3(0, -1, 0), normalize(vec3(uv, -2.)));\n\t\n\tfloat path = Trace(rayStart, rayDirection, 0.);\t\n\treturn Shade(rayStart, rayDirection, path);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col = Camera(fragCoord.xy);\n\tfragColor = vec4(col, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 368, 388, 388, 415], [417, 417, 440, 440, 495], [497, 497, 522, 522, 611], [613, 613, 638, 638, 709], [711, 711, 737, 737, 770], [772, 772, 796, 796, 832], [834, 834, 858, 858, 894], [896, 896, 924, 924, 1039], [1041, 1041, 1061, 1061, 1122], [1124, 1124, 1144, 1144, 1206], [1208, 1208, 1229, 1229, 1284], [1286, 1286, 1315, 1315, 1492], [1494, 1494, 1518, 1518, 1572], [1574, 1574, 1600, 1600, 2069], [2071, 2071, 2102, 2102, 2404], [2406, 2406, 2427, 2427, 2568], [2570, 2570, 2609, 2609, 2770], [2772, 2772, 2815, 2815, 2940], [2942, 2942, 2992, 2992, 3143], [3145, 3145, 3232, 3232, 3719], [3721, 3721, 3764, 3764, 4480], [4482, 4482, 4504, 4504, 4807], [4809, 4809, 4866, 4866, 4930]], "test": "valid"}
{"id": "lssXD8", "name": "Implicit Curvature", "author": "paniq", "description": "curvature of implicit surfaces", "tags": ["mattdamon"], "likes": 6, "viewed": 535, "published": "Public API", "date": "1400417967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// marching cube on dual grid visualization\n// -- @paniq\n\n#define GRIDRES 10\n\n//#define HEROKU\n#ifdef HEROKU\n#ifdef GL_ES\nprecision mediump float;\n#endif\n// compatibility for glsl.heroku.com \nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iMouse mouse\n#define iTime time\n#define iResolution resolution\n#endif\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n\nstruct Context {\n    vec2 position;\n    float scale;\n    float shape;\n    float line_width;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n} _stack;\nvec3 _color = vec3(1.0);\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    float shape = _stack.shape;\n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = position;\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(position,1.0)).xy;\n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(_stack.position,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid add(float d) {\n    _stack.shape = min(_stack.shape, d / _stack.scale);\n}\n\nvec4 blit() {\n    return vec4(_color.xyz, 1.0);\n}\n\nvoid new_path() {\n    _stack.shape = DEFAULT_SHAPE_V;\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape * 6.0, \n            1.0, (_stack.shape>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(AA, 0.0);\n        return;\n    }\n    float a = 1.0 / max(AAINV, b);\n    _stack.blur = vec2(\n        a,\n        0.0); // 0 = blur ends at outline, 1 = blur starts at outline\n}\n\nvoid fill_preserve() {\n    float w = clamp(-_stack.shape*AA, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nvoid stroke_preserve() {\n    float w = abs(_stack.shape)- _stack.line_width/_stack.scale;\n    vec2 blur = _stack.blur;// / _stack.scale;\n    w = clamp(-w*blur.x + blur.y, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o = o - _stack.position + s;\n    vec2 d = abs(o) - s;\n    add(min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    add(length(_stack.position - p) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec2 pa = _stack.position - _stack.last_pt;\n    vec2 ba = p - _stack.last_pt;\n    float h = clamp(dot(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add(length(pa - ba*h));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from \"Random-access rendering of general vector graphics\"\n// by Nehab and Hoppe\n// only quadratic, not cubic\nvoid curve_to(vec2 b1, vec2 b2)\n{\n    vec2 b0 = _stack.last_pt - _stack.position;\n    b1 -= _stack.position;\n    b2 -= _stack.position;\n    float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n    float f=b*d-a*a;\n    vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n    vec2 gf=2.0*(b*d21+d*d10+a*d20);\n    gf=vec2(gf.y,-gf.x);\n    vec2 pp=-f*gf/dot(gf,gf);\n    vec2 d0p=b0-pp;\n    float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n    float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0);\n    add(length(mix(mix(b0,b1,t),mix(b1,b2,t),t)));\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\n//////////////////////////////////////////////////////////\n\nfloat box(vec3 p, vec3 size) {\n\tvec3 d = abs(p) - size;\n    \n\tvec3 dm = max(d, 0.0);\n    \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(dm);\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat plane(vec3 p, vec4 n) {\n\treturn dot(p,n.xyz) - n.w;\n}\n\n// c must be normalized\nfloat cone(vec3 p, vec2 a, float l) {\n    return max(max(a.x*length(p.xy)+a.y*p.z, p.z), abs(p.z)-l);\n}\n\nvec2 ms;\n\nvec3 rotate(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(\n\t\tp.x*ca - p.z*sa,\n\t\t0.0,\n\t\tp.x*sa + p.z*ca\n\t);\n}\n\nfloat map(vec3 p) {\n\tp.xz -= ms;\n    \n\tfloat w = plane(p, vec4(0.0,0.0,1.0,-0.6));\n\tfloat s = sphere(p - vec3(1.0,0.0,0.0), 0.5);\n\tfloat s2 = sphere(p - vec3(0.67,0.0,0.0), 0.2);\n\tfloat c = cone(p - vec3(-0.5,0.0,-0.3), normalize(vec2(1.0,0.5)), 0.5);\n\tfloat b = box(rotate(p - vec3(-0.5,0.0,0.2),iTime), vec3(0.3,1.0,0.1))-0.1;\n\treturn min(b, min(c, min(max(s,-s2),w)));\n}\n\nvec3 grad0(vec3 p, float e) {\n\tvec2 d = vec2(0.0, e);\n\treturn -vec3(\n\t\tmap(p + d.yxx) - map(p - d.yxx),\n\t\tmap(p + d.xyx) - map(p - d.xyx),\n\t\tmap(p + d.xxy) - map(p - d.xxy));\n}\n\nconst float ERR = 1e-2;\nvec3 grad(vec3 p) {\n\treturn grad0(p,ERR) / (2.0 * ERR);\n}\n\nconst float H_ERR = 1e-2;\nconst float G_ERR = 1e-2;\nmat3 hessian(vec3 p) {\n\tvec2 d = vec2(0.0, H_ERR);\n\t\n\tfloat f = 2.0*H_ERR;\n\treturn mat3(\n\t\tgrad0(p + d.yxx,G_ERR) - grad0(p - d.yxx,G_ERR),\n\t\tgrad0(p + d.xyx,G_ERR) - grad0(p - d.xyx,G_ERR),\n\t\tgrad0(p + d.xxy,G_ERR) - grad0(p - d.xxy,G_ERR)) / f;\n}\n\nconst mat3 identity = mat3(\n\t1.0, 0.0, 0.0,\n\t0.0, 1.0, 0.0,\n\t0.0, 0.0, 1.0\n);\n\n//Curvature only, 5 taps, with epsilon width as input\nfloat curvature(in vec3 p)\n{\n    vec2 e = vec2(-1., 1.)*0.01;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .125/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\n\nvec2 grad2d(vec3 p) {\n\tvec2 d = vec2(0.0, 1e-3);\n\treturn normalize(vec2(\n\t\tmap(p + d.yxx) - map(p - d.yxx),\n\t\tmap(p + d.xxy) - map(p - d.xxy)));\n}\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\nfloat mlen(vec2 c) {\n\tc = abs(c);\n\treturn max(c.x, c.y);\n}\n\nfloat mlen(vec3 c) {\n\tc = abs(c);\n\treturn max(c.x, max(c.y, c.z));\n}\n\nbool gravitymarch(vec3 ro, float maxt, out vec3 p) {\n\tfloat precis = 0.001;\n\tfloat h = 1000.0;\n\tp = ro;\n\tfor(int i = 0; i < 5; i++) {\n\t\tif(abs(h) < precis || length(p - ro) > maxt) break;\n\t\th = map(p);\n\t\tvec2 n = grad2d(p);\n\t\tp.xz -= n*h;\n\t}\t\n\treturn (abs(h) < precis);\n}\n\n\n\nvec3 sigcolor(float k) {\n\treturn hue(k*0.01);\n}\n\nvoid paint() {\n\tif (iMouse.z < 0.0)\n\t\tms *= 0.0;\n\t\n\tvec3 mp = vec3(position.x,0.0,position.y);\n\n\tfloat k1k2 = curvature(mp);\n\t\n\t// clear screen\n\t\n\tset_source_rgb(sigcolor(k1k2)*0.2);\n\tclear();\n\n\tset_line_width_px(5.0);\n\t\n\tfloat d = map(mp);\n\t_stack.shape = d;\n\tset_source_rgb(sigcolor(k1k2));\n\t//fill_preserve();\n\tstroke();\n\t\n\n\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    uv = fragCoord.xy / iResolution.xy;\n    position = (uv*2.0-1.0)*aspect;\n    ScreenH = min(iResolution.x,iResolution.y);\n    AA = ScreenH*0.4;\n    AAINV = 1.0 / AA;\n    \n    ms = ((iMouse.xy/iResolution.xy)*2.0-1.0) * aspect;\n    _stack = Context(\n        position, 1.0,\n        DEFAULT_SHAPE_V,\n        1.0,\n        vec2(AA,0.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n    paint();\n    \n    fragColor = blit();\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 472, 499, 499, 525], [527, 587, 608, 608, 717], [719, 719, 756, 756, 842], [844, 844, 890, 890, 923], [925, 1213, 1229, 1229, 1250], [1252, 1252, 1279, 1301, 1379], [1381, 1381, 1409, 1409, 1643], [1645, 1645, 1669, 1669, 1727], [1729, 1729, 1756, 1756, 1893], [1895, 1895, 1921, 1921, 2083], [2085, 2085, 2107, 2107, 2233], [2235, 2235, 2256, 2256, 2312], [2314, 2314, 2338, 2338, 2398], [2400, 2400, 2434, 2434, 2458], [2460, 2460, 2474, 2474, 2538], [2540, 2540, 2559, 2559, 2617], [2619, 2619, 2632, 2632, 2668], [2670, 2670, 2687, 2687, 2725], [2727, 2727, 2750, 2750, 2873], [2875, 2875, 2899, 2899, 3120], [3122, 3122, 3144, 3144, 3261], [3263, 3263, 3276, 3276, 3315], [3317, 3317, 3347, 3347, 3376], [3378, 3378, 3411, 3411, 3456], [3458, 3458, 3482, 3482, 3707], [3709, 3709, 3724, 3724, 3765], [3767, 3767, 3797, 3797, 3822], [3824, 3824, 3882, 3882, 3921], [3923, 3923, 3952, 3952, 3988], [3990, 3990, 4038, 4038, 4069], [4071, 4071, 4105, 4105, 4161], [4163, 4163, 4195, 4195, 4320], [4322, 4322, 4378, 4378, 4421], [4423, 4423, 4453, 4453, 4497], [4498, 4498, 4538, 4538, 4561], [4563, 4563, 4585, 4585, 4636], [4638, 4638, 4670, 4670, 4692], [4694, 4709, 4731, 4731, 4927], [4929, 4929, 4961, 4961, 4983], [4985, 4985, 5004, 5004, 5036], [5038, 5150, 5183, 5183, 5671], [5673, 5673, 5732, 5732, 5777], [5779, 5839, 5869, 5869, 5986], [5988, 5988, 6019, 6019, 6044], [6046, 6046, 6075, 6075, 6105], [6107, 6131, 6168, 6168, 6234], [6246, 6246, 6276, 6276, 6380], [6382, 6382, 6401, 6401, 6755], [6757, 6757, 6786, 6786, 6933], [6959, 6959, 6978, 6978, 7016], [7070, 7070, 7092, 7092, 7318], [7399, 7453, 7481, 7481, 7692], [7695, 7695, 7716, 7716, 7841], [7843, 7843, 7871, 7871, 8013], [8015, 8015, 8035, 8035, 8073], [8075, 8075, 8095, 8095, 8143], [8145, 8145, 8197, 8197, 8416], [8420, 8420, 8444, 8444, 8467], [8469, 8469, 8483, 8483, 8798], [8800, 8860, 8917, 8917, 9423]], "test": "error"}
{"id": "lsXXD4", "name": "Bonne FÃÂªte Maman !", "author": "Klems", "description": "Happy mother's day to all mothers in the world!", "tags": ["2d", "cute", "cartoon", "flower", "heart"], "likes": 19, "viewed": 776, "published": "Public", "date": "1401073664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535\n\nfloat rand(vec2 p){\n\treturn fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);\n}\n\nmat2 rot(float t) {\n\treturn mat2(cos(t),-sin(t),\n\t\t\t\tsin(t), cos(t));\n}\n\n// point to flower color, with alpha\nvec4 flower(vec2 p, float n, float seed) {\n\tif (p.y > 1.0 || p.y < 0.0) return vec4(0.0);\n\tvec2 c = vec2(floor(p.x)+0.5, 0.5);\n\tc.x += rand(vec2(c.x+seed*100.0, c.y*20.134))*.32-.16;\n\tc.y += rand(vec2(c.x+seed*200.0, c.y*30.412))*.32-.16;\n\tvec2 v = p-c;\n\t\n\tfloat rot = rand(vec2(c.x+seed, c.y+10.512))*1.4-0.7;\n\tfloat t = atan(v.y, v.x)+(rand(c)*2.0-1.0)*2.0*PI+iTime*rot;\n\tfloat r = sin(t*n)*0.05+.25;\n\tfloat rr = cos(t*n)*0.005+.08;\n\tfloat l = length(v);\n\t\n\t// petal\n\tfloat petal = smoothstep(0.02, 0.0, l-r);\n\t// pistil\n\tfloat pistil = smoothstep(0.05, -0.0, l-rr);\n\t// border\n\tfloat border = smoothstep(-0.09, 0.0, l-r)*0.3;\n\t\n\treturn vec4(vec3(0.5+pistil*0.5)-border, petal);\n}\n\n// beat value, 0->1, 1->0\nfloat beat(float x) {\n\tfloat temp = x-1.0;\n\ttemp *= temp;\n\ttemp *= temp;\n\treturn temp*(cos(30.0*x)*.5+.5);\n}\n\n// point to background color value\nvec3 backgroundColor(vec2 p) {\n\tvec3 color = vec3(.3, .05, .2);\n\t\n\t// add a star\n\tfloat t = atan(p.y, p.x) / PI;\n\tt *= 5.0;\n\tt += iTime*0.5;\n\tt = abs(fract(t)*2.0-1.0);\n\tfloat star = smoothstep(0.5, 0.6, t);\n\tcolor = mix(color, vec3(0.5, 0.2, 0.4), star);\n\t\n\t// add some flowers\n\tp.y+=3.3;\n\tp *= 0.2;\n\tfor (float i = 0.0 ; i < 5.5 ; i++) {\n\t\tvec2 pp = p;\n\t\tpp *= rot(.05*sin(2.0*iTime+2.0*PI*rand(vec2(i,1.0))));\n\t\tpp.x += iTime*(rand(vec2(i,2.0))*2.0-1.0)*(i+3.0)*.12;\n\t\tpp.y += sin(iTime+2.0*PI*rand(vec2(i,3.0)))*.1;\n\t\tvec4 flowerValue = flower(pp, 5.0+floor(i*.5), i);\n\t\tp.y += 0.02;\n\t\tp /= 0.9;\n\t\t\n\t\tvec3 flowerColor = vec3(rand(vec2(i, 19.0))*1.0,\n\t\t\t\t\t\t\t\trand(vec2(i, 18.0))*0.2,\n\t\t\t\t\t\t\t\trand(vec2(i, 16.0))*0.8);\n\t\t\n\t\tflowerValue.rgb = flowerColor*flowerValue.rgb*3.0+flowerValue.rgb;\n\t\tcolor = mix(color, flowerValue.rgb, flowerValue.a);\n\t}\n\t\n\treturn color;\n}\n\n// point to heart value\nfloat heartFormula(vec2 p, bool time) {\n\t// heartbeat\n\tif (time) {\n\t\tfloat beatValue = beat(fract(0.824*iTime))*0.1;\n\t\tp.x *= 1.0 + beatValue * 2.0;\n\t\tp.y *= 1.0 - beatValue * 1.5;\n\t}\n\t// center the heart around the axis\n\tp.y -= 1.6;\n\t// see http://mathworld.wolfram.com/HeartCurve.html\n\tfloat t = atan(p.y, p.x);\n\tfloat si = sin(t);\n\tfloat r = 2.0-2.0*si+si*(sqrt(abs(cos(t)))/(si+1.4));\n\treturn length(p)-r;\n}\n\n// heart value to heart color with alpha\nvec4 heartColor(vec2 p) {\n\tfloat v = heartFormula(p, true);\n\tvec3 color = vec3(1.0, 0.5, 0.8);\n\tcolor -= smoothstep(-0.8, +0.5, v)*vec3(0.6);\n\tcolor += smoothstep(-0.0, -1.6, v)*vec3(.4);\n\tcolor -= smoothstep(-0.2, +0.2, v)*vec3(0.1);\n\treturn vec4(color, smoothstep(0.2, 0.1, v));\n}\n\n// opening\nfloat opening(vec2 p) {\n\tfloat mult = max(0.0, 5.0-iTime*1.5);\n\tp *= 3.0*mult*mult*mult;\n\tp *= rot(sin(iTime*6.0)*.2);\n\tfloat v = heartFormula(p, false);\n\treturn smoothstep(-0.5, 0.5, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tfloat mult = 3.0+4.0*beat(min(1.0, 0.09*iTime));\n\tuv *= mult;\n\t\n\t// get background\n\tvec3 color = backgroundColor(uv);\n\t// heart formula and color\n\tvec4 hcolor = heartColor(uv*mult*.32);\n\t// and blend with heart color\n\tcolor = mix(color, hcolor.rgb, hcolor.a);\n\tcolor = clamp(color, 0.0, 1.0);\n\t// set opening\n\tcolor -= opening(uv);\n\t\n\tfragColor.rgb = color;\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 109], [111, 111, 130, 130, 182], [184, 221, 263, 263, 903], [905, 931, 952, 952, 1039], [1041, 1076, 1106, 1106, 1944], [1946, 1970, 2009, 2023, 2381], [2383, 2424, 2449, 2449, 2706], [2708, 2719, 2742, 2742, 2908], [2910, 2910, 2967, 2967, 3442]], "test": "valid"}
{"id": "lsXXDr", "name": "Diffraction", "author": "cafe", "description": "Diffraction", "tags": ["diffraction"], "likes": 0, "viewed": 167, "published": "Public", "date": "1399073609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI=3.14159;\n\nfloat saw(float x){\n\treturn abs(mod(x-1.,2.)-1.);\n}\n\n// edit this\nvec3 tex(vec2 uv){\n\tfloat m=PI*20.;\n\tfloat d = smoothstep(-0.02,0.02,sin(uv.x*m))+\n\t\t\t  smoothstep(-0.02,0.02,sin(uv.y*m));\n\td=saw(d);\n\t//d=smoothstep(00.2,0.3,d);\n\treturn vec3(d,sin(length(uv)*39.),sin(length(uv)*50.));\n}\n\nvec2 displace(vec2 uv){\n\t\n\tfloat refindex=1.3; // refraction index, change this (1.3 is glass)\n\t\n\tfloat r=0.5;\n\t\n\tfloat m=length(uv);\n\t\n\tif(m<1.)\n\t\tm = sin(asin(m)/refindex);\n\t\n\treturn normalize(uv)*m;\n}\n\nvec3 shade(vec2 uv){\n\tvec2 d=vec2(sin(iTime),cos(iTime*1.5))*0.3;\n\treturn tex(displace(uv+d)-d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(shade(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXXDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 76], [78, 91, 109, 109, 313], [315, 315, 338, 338, 518], [520, 520, 540, 540, 618], [620, 620, 677, 677, 772]], "test": "valid"}
{"id": "MdfSDH", "name": "SH - directional lights", "author": "iq", "description": "Testing 3-band SH encoding of directional lights. It compares the SH reconstruction to the ground truth.", "tags": ["3d", "sphericalharmonics", "spherical", "harmonics", "harmonic", "sh"], "likes": 25, "viewed": 2452, "published": "Public API", "date": "1400139574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Testing 3-band SH encoding for directional lights. \n\n// A lighting environment made of several directional lights is encoded in an SH\n// representation by incrementally accumulating incoming directional lighting with \n// SH_AddLightDirectional(). At render time, the normal's SH is doted with the SH\n// representation of the lighting to get the final color, by calling SH_Evalulate().\n\n// More info here at  dickyjim's blog: \n// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/\n\n#define OPTIMIZED\n\n\n//--------------------------------------------------------------------------------\n// SH\n//--------------------------------------------------------------------------------\n\n#ifndef OPTIMIZED\n#define PI 3.1415927\n//\n// slow version, but true to the mathematical formulation\n//\nvoid SH_AddLightDirectional( inout vec3 sh[9], in vec3 col, in vec3 v )\n{\n    #define NO  1.0        // for perfect overal brigthness match\n  //#define NO (16.0/17.0) // for normalizing to maximum = 1.0;\n    sh[0] += col * (NO*PI*1.000) * (0.50*sqrt( 1.0/PI));\n    sh[1] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.x;\n    sh[2] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.y;\n    sh[3] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.z;\n    sh[4] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.x*v.z;\n    sh[5] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.z*v.y;\n    sh[6] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.y*v.x;\n    sh[7] += col * (NO*PI*0.250) * (0.25*sqrt( 5.0/PI)) * (3.0*v.z*v.z-1.0);\n    sh[8] += col * (NO*PI*0.250) * (0.25*sqrt(15.0/PI)) * (v.x*v.x-v.y*v.y);\n}\n\nvec3 SH_Evalulate( in vec3 v, in vec3 sh[9] )\n{\n    return sh[0] * (0.50*sqrt( 1.0/PI)) +\n           sh[1] * (0.50*sqrt( 3.0/PI)) * v.x +\n           sh[2] * (0.50*sqrt( 3.0/PI)) * v.y +\n           sh[3] * (0.50*sqrt( 3.0/PI)) * v.z +\n           sh[4] * (0.50*sqrt(15.0/PI)) * v.x*v.z +\n           sh[5] * (0.50*sqrt(15.0/PI)) * v.z*v.y +\n           sh[6] * (0.50*sqrt(15.0/PI)) * v.y*v.x +\n           sh[7] * (0.25*sqrt( 5.0/PI)) * (3.0*v.z*v.z-1.0) +\n           sh[8] * (0.25*sqrt(15.0/PI)) * (v.x*v.x-v.y*v.y);\n}\n\n#else\n\n//\n// fast version, premultiplied components and simplified terms\n//\nvoid SH_AddLightDirectional( inout vec3 sh[9], in vec3 col, in vec3 v )\n{\n     #define DI 64.0  // for perfect overal brigthness match\n   //#define DI 68.0  // for normalizing to maximum = 1.0;\n\t\n\tsh[0] += col * (21.0/DI);\n\tsh[0] -= col * (15.0/DI) * v.z*v.z;\n\tsh[1] += col * (32.0/DI) * v.x;\n\tsh[2] += col * (32.0/DI) * v.y;\n\tsh[3] += col * (32.0/DI) * v.z;\n\tsh[4] += col * (60.0/DI) * v.x*v.z;\n\tsh[5] += col * (60.0/DI) * v.z*v.y;\n\tsh[6] += col * (60.0/DI) * v.y*v.x;\n\tsh[7] += col * (15.0/DI) * (3.0*v.z*v.z-1.0);\n\tsh[8] += col * (15.0/DI) * (v.x*v.x-v.y*v.y);\n}\n\nvoid SH_AddDome( inout vec3 sh[9], in vec3 colA, in vec3 colB )\n{\n\tsh[0] += 0.5*(colB + colA);\n\tsh[2] += 0.5*(colB - colA);\n}\n\n\nvec3 SH_Evalulate( in vec3 v, in vec3 sh[9] )\n{\n\treturn sh[0] +\n           sh[1] * v.x +\n           sh[2] * v.y +\n           sh[3] * v.z +\n           sh[4] * v.x*v.z +\n           sh[5] * v.z*v.y +\n           sh[6] * v.y*v.x +\n           sh[7] * v.z*v.z +\n           sh[8] *(v.x*v.x-v.y*v.y);\n}\n#endif\n\n//--------------------------------------------------------------------------------\n// test\n//--------------------------------------------------------------------------------\n\nvec3  lig1 = normalize( vec3(1.0, 1.0, 1.0) );\nvec3  lig2 = normalize( vec3(1.0,-1.0, 0.1) );\nvec3  lig3 = normalize( vec3(0.0, 0.2,-1.0) );\nvec3  lig4 = normalize( vec3(0.5, 0.8,-0.5) );\n\nvec3 lco1 = vec3(1.0,0.2,0.0);\nvec3 lco2 = vec3(0.0,1.0,0.0);\nvec3 lco3 = vec3(0.0,0.0,1.0);\nvec3 lco4 = vec3(1.0,0.9,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.2*iTime - 10.0*iMouse.x/iResolution.x;\n\tvec3 ro = vec3( 2.5*sin(an), 0.0, 2.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\tvec3 col = vec3(0.4);\n\n    // Prec-encode the lighting as SH coefficients (you'd usually do this only once)\n\tvec3 sh[9];\n\tsh[0] = vec3(0.0);\n\tsh[1] = vec3(0.0);\n\tsh[2] = vec3(0.0);\n\tsh[3] = vec3(0.0);\n\tsh[4] = vec3(0.0);\n\tsh[5] = vec3(0.0);\n\tsh[6] = vec3(0.0);\n\tsh[7] = vec3(0.0);\n\tsh[8] = vec3(0.0);\n\tSH_AddLightDirectional( sh, lco1, lig1 );\n\tSH_AddLightDirectional( sh, lco2, lig2 );\n\tSH_AddLightDirectional( sh, lco3, lig3 );\n\tSH_AddLightDirectional( sh, lco4, lig4 );\n\n\t// raytrace-sphere\n\tvec3  ce = ro;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tvec3 pos = ro + h*rd;\n\t\tvec3 nor = normalize(pos); \n\t\t\n\t\t// compare regular lighting...\n\t\tif( sin(6.2831*iTime)>0.0 )\n        {\n\t\t\tcol  = lco1*clamp( dot(nor,lig1), 0.0, 1.0 );\n            col += lco2*clamp( dot(nor,lig2), 0.0, 1.0 );\n            col += lco3*clamp( dot(nor,lig3), 0.0, 1.0 );\n            col += lco4*clamp( dot(nor,lig4), 0.0, 1.0 );\n        }\n        // ... with SH lighting\n        else\t\t\t\n        {\n            col = SH_Evalulate( nor, sh );\n        }\n\t}\n\tcol *= 0.6;\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfSDH.jpg", "access": "shaders20k", "license": "mit", "functions": [[4282, 4771, 4828, 4828, 6431]], "test": "valid"}
{"id": "MdfSDn", "name": "Perlin thing", "author": "fizzgig", "description": "Parabolic distortion", "tags": ["2d", "perlin", "emission", "parabola"], "likes": 17, "viewed": 556, "published": "Public", "date": "1398958742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535;\n\n// of equation x^3+c1*x+c2=0\n/* Stolen from http://perso.ens-lyon.fr/christophe.winisdoerffer/INTRO_NUM/NumericalRecipesinF77.pdf,\n   page 179 */\nfloat cubicRoot(float c1, float c2) {\n\tfloat q = -c1/3.;\n\tfloat r = c2/2.;\n\tfloat q3_r2 = q*q*q - r*r;\n\tif(q3_r2 < 0.) {\n\t\tfloat a = -sign(r)*pow(abs(r)+sqrt(-q3_r2),.333333);\n\t\tfloat b = a == 0. ? 0. : q/a;\n\t\tfloat x1 = a+b;\n\t\treturn x1;\n\t}\n\treturn 0.;\n\t/*float theta = acos(r/pow(q,1.5));\n\tfloat sqr_q = pow(q,.5);\n\tvec3(-2.*sqr_q*cos(theta/3.),\n\t\t -2.*sqr_q*cos((theta+2.*pi)/3.),\n\t\t -2.*sqr_q*cos((theta-2.*pi)/3.));*/\n}\n\nfloat arcLength(float a, float b, float x) {\n\tfloat f = .25/a;\n\tfloat h = x/2.;\n\tfloat q = length(vec2(f,h));\n\treturn h*q/f+f*log((h+q)/f);\n}\n\nvec2 parabolaCoords(float a,float b,vec2 co) {\n\tfloat x = cubicRoot((1./a-2.*co.y+2.*b)/(2.*a),(-co.x)/(2.*a*a));\n\treturn vec2(length(co-vec2(x,a*x*x+b)),arcLength(a,b,x));\n}\n\nfloat noise3(vec3 co){\n  return fract(sin(dot(co ,vec3(12.9898,78.233,125.198))) * 43758.5453);\n}\n\nfloat smooths(float v) {\n\treturn 3.*pow(v,2.)-2.*pow(v,3.);\n}\n\nfloat perlin3(vec3 p) {\n\tfloat val = 0.;\n\tfor(float i=0.;i<3.;i += 1.){\n\t\tp *= pow(2.,i);\n\t\tvec3 c = floor(p);\n\t\tfloat u = smooths(fract(p.x));\n\t\tfloat v = smooths(fract(p.y));\n\t\tval = 1.-((1.-val)*(1.-pow(.5,i)*\n\t\t\tmix(mix(mix(noise3(c),noise3(c+vec3(1.,0.,0.)),u),\n\t\t\t\t\tmix(noise3(c+vec3(0.,1.,0.)),noise3(c+vec3(1.,1.,0)),u),v),\n\t\t\t    mix(mix(noise3(c+vec3(0.,0.,1.)),noise3(c+vec3(1.,0.,1.)),u),\n\t\t\t\t\tmix(noise3(c+vec3(0.,1.,1.)),noise3(c+vec3(1.,1.,1.)),u),v),fract(p.z))));\n\t}\n\treturn val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tvec2 r = uv-(iResolution.xy/iResolution.x)*vec2(.5,.3);\n\tr *= 6.;\n\tr = parabolaCoords(1./3.,0.,r);\n\tr.x = pow(r.x*.8+.7,3.);\n\tfloat l = exp(-r.x*1.8)+.01/(r.x-.33);\n\tr.x -= iTime*3.;\n\tfloat v = perlin3(vec3(r,iTime));\n\tvec4 c = vec4(vec3(v*1.,v*1.+0.6*cos(.5*iTime),v*(.5*sin(iTime)+.5)*2.5)*l,v);\t\n\t\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 178, 215, 215, 602], [604, 604, 648, 648, 745], [747, 747, 793, 793, 921], [923, 923, 945, 945, 1020], [1022, 1022, 1046, 1046, 1083], [1085, 1085, 1108, 1108, 1583], [1585, 1585, 1642, 1642, 2003]], "test": "valid"}
{"id": "MdfXWr", "name": "Filmic Tonemapping", "author": "paniq", "description": "with fake auto-exposure; hold/drag to compare bare/tonemapped (X axis); left: regular, right: filmic", "tags": ["tonemapping", "filmic"], "likes": 23, "viewed": 2158, "published": "Public", "date": "1399069482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nvec3 pastelizer(float h) {\n\n    h *= 6.2831853071796;\n    float hs = 1.0 / (4.08699 - sin(h));\n    float x = (0.715474 - 0.41442 * cos(h)) * hs;\n    float z = 4.82215 * hs - 0.333333 * x - 0.920933;\n    \n    float tx = x * 3.2409699419045214 - z * 0.49861076029300328 - 0.28316525509623425;\n    float ty = x * -0.96924363628087983 + z * 0.041555057407175613 + 0.3455279229451954;\n    float tz = x * 0.055630079696993609 + z * 1.0569715142428786 - 0.037569805914516544;\n    \n    return clamp(vec3(tx,ty,tz), 0.0, 1.0) * 0.9 + 0.1;\n}\n\nvec3 hsv2rgbc(vec3 c) {\n    vec3 rgb = pastelizer(c.x);\n    rgb = smoothstep(vec3(0.0),vec3(1.0),rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 lin2srgb(vec3 color) {\n    vec3 S1 = sqrt(color);\n    vec3 S2 = sqrt(S1);\n    vec3 S3 = sqrt(S2);\n    return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nfloat specular(float r, float cos_Oh) {\n    float a = r*r;\n    float a2 = a*a;\n    float Dd = max(0.00015, cos_Oh*cos_Oh*(a2 - 1.0)+1.0);\n    return a2/(3.14159*Dd*Dd);\n}\n\nfloat specular2(float a, float cos_Ov, float cos_Ol) {\n    float r = (a+1.0); \n    float k = (r*r) / 8.0;\n    float ik = 1.0 - k;    \n    float Gdlvh = 4.0 * (cos_Ov*ik + k) * (cos_Ol*ik + k);    \n    return (1.0 / Gdlvh);\n}\n\nfloat fresnel(float cos_Od) {\n    float p = (-5.55473*cos_Od-6.98316)*cos_Od;\n    return 0.04 + (1.0 - 0.04)*pow(2.0, p);\n}\n\nfloat random(vec3 co) {\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,91.1743))) * 43758.5453);\n}\n\nfloat map(vec3 p) {\n\tfloat s = length(p)-1.0;\n\t\n\treturn s + snoise((p*10.0 + iTime)-0.8)*0.005;\n}\n\nvec3 grad(vec3 p) {\n\tvec2 d = vec2(0.01, 0.0);\n\treturn normalize(vec3(\n\t\t\tmap(p + d.xyy) - map(p - d.xyy),\n\t\t\tmap(p + d.yxy) - map(p - d.yxy),\n\t\t\tmap(p + d.yyx) - map(p - d.yyx)\n\t\t));\n}\n\nfloat trace(vec3 rp, vec3 rd) {\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tfloat d = map(rp + rd*r);\n\t\tif (abs(d) <= 0.001) break;\n\t\tr += d;\n\t}\t\n\treturn r;\n}\n\nfloat calcAO(vec3 p, vec3 n, float radius) {\n    float s = radius/3.0;\n    float ao = 0.0;\n    for (int i = 1; i <= 3; ++i) {\n        float dist = s * float(i);\n    float t = map(p + n*dist);\n        ao += max(0.0, (dist - t) / dist);\n    }\n    return 1.0 - (ao/3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0-1.0;\n\tuv.x *= aspect;\n\t\n\tvec2 n2 = uv*1.2;\n\t// fake sphere normal\n\tvec3 n = vec3(n2, sqrt(1.0-n2.x*n2.x-n2.y*n2.y));\n\t// sphere uv\n\tvec2 suv = vec2(atan(n.x, n.z), n.y);\n\tvec3 p = n;\n\t\n\tfloat m = clamp((map(p)+0.005)*128.0, 0.0, 1.0);\n\tp -= n*trace(p, -n);\n\tn = grad(p);\n\n\t// material blend\n\tfloat ofsy = sin(suv.y*30.0+iTime)*0.5;\n    float m2 = clamp((sin(suv.x*5.0+suv.y*4.0+iTime)-ofsy)*9.0+ofsy,0.0,1.0);\n\t\n\t// roughness\n\tfloat r = mix(0.1, 0.3, m2);\n\t\n\tvec3 albedo = hsv2rgbc(\n        vec3(\n            (suv.y*0.5-suv.x*0.25+iTime*0.1)*0.2,\n            1.0,\n            1.0));\n\tvec3 light = vec3(1.0,0.9,0.3) * 32.0;\n    vec3 ambient = vec3(0.5,0.8,1.0) * 0.0625;\n\n\t\n\t// light vector\n\tvec3 l = normalize(vec3(cos(iTime),cos(iTime*0.1),sin(iTime))*10.0 - p);\n\t// camera vector\n\tvec3 v = normalize(vec3(0.0,0.0,5.0) - p);\n\t\n\t// half vector\n\tvec3 h = normalize(l + v);\n\n\tfloat cos_Ol = max(0.0, dot(n, l));\n\tfloat cos_Ov = max(0.0, dot(n, v));\n    float cos_Oh = max(0.0, dot(n, h));\n\tfloat cos_Od = max(0.0, dot(v,h));\n\t\n\tfloat light_lum = cos_Ol / 3.14159;\n\tfloat spec_lum = specular(r, cos_Oh) * specular2(r,cos_Ov,cos_Ol) * fresnel(cos_Od);\n\tfloat amb_lum = max(0.0, dot(n, vec3(0.0,0.0,1.0)));\n\t\n\tvec3 col = albedo * light_lum + vec3(spec_lum) * cos_Ol;\n\tcol *= light;\n\t\n\t// ambient occlusion\n\tfloat ao = calcAO(p,n,0.1);\n\t// ambient light\n\tcol += albedo * ambient * ao;\n\n    col *= amb_lum;\n\t\n\tvec2 mouse = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n\n    // add sensor noise\n\tfloat tt = mod(iTime, 5.0);\n\tvec3 ns = vec3(\n\t\trandom(vec3(fragCoord.xy*0.001,tt)),\n\t\trandom(vec3(fragCoord.xy*0.01,tt)),\n\t\trandom(vec3(fragCoord.xy*0.1,tt)));\n\tcol = mix(col, vec3(1.0), ns*0.01);\n\t\n\tfloat lightness = dot(l, vec3(0.0,0.0,-1.0))*0.5+0.5;\n\t\n\t// adjust exposure\n\tcol *= pow(2.0, mix(-4.0, 4.0, lightness));\n\n\tmouse = mouse*2.0-1.0;\n\tmouse.x *= aspect;\n\t\n\tif (uv.x > mouse.x)\n\t\tcol = ff_filmic_gamma3(col);\t\n\telse\n\t\tcol = lin2srgb(clamp(col,0.0,1.0));\t\n\t\n\tcol *= clamp(abs(uv.x-mouse.x)*320.0, 0.0, 1.0);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 93, 93, 142], [144, 144, 166, 166, 206], [208, 208, 236, 236, 288], [290, 290, 314, 314, 2460], [2463, 2463, 2489, 2489, 2994], [2996, 2996, 3019, 3019, 3143], [3145, 3145, 3172, 3172, 3316], [3318, 3318, 3354, 3354, 3448], [3450, 3450, 3489, 3489, 3620], [3622, 3622, 3676, 3676, 3846], [3848, 3848, 3877, 3877, 3971], [3973, 3973, 3996, 3996, 4076], [4078, 4078, 4097, 4097, 4175], [4177, 4177, 4196, 4196, 4362], [4364, 4364, 4395, 4395, 4527], [4529, 4529, 4573, 4573, 4798], [4800, 4800, 4857, 4857, 6994]], "test": "valid"}
{"id": "MdlXWr", "name": "Star Tunnel", "author": "P_Malin", "description": "Single pass starfield inspired by old school tunnel effects.\nI wanted to try to render a starfield without any loops or iteration. Each angular segment of space around the viewer generates a random star xy radius from the viewer and z repeat distance.", "tags": ["starfield"], "likes": 76, "viewed": 5293, "published": "Public API", "date": "1399648655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Star Tunnel - @P_Malin\n// https://www.shadertoy.com/view/MdlXWr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Single pass starfield inspired by old school tunnel effects.\n// Each angular segment of space around the viewer selects a random star position radius and depth repeat rate.\n\n// Increase pass count for a denser effect\n#define PASS_COUNT 1\n\nfloat fBrightness = 2.5;\n\n// Number of angular segments\nfloat fSteps = 121.0;\n\nfloat fParticleSize = 0.015;\nfloat fParticleLength = 0.5 / 60.0;\n\n// Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 5.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 2.0;\n\n// fog density\nfloat fDepthFade = 0.8;\n\nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = vClampedPos - vClosestPos;\t\n\t\t\n\tfloat fClosestDist = length(vDeltaPos) / fParticleSize;\n\t\n\tfloat fShade = \tclamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\t\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\t\n\tfloat fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment / fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vScreenUV = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 vScreenPos = vScreenUV * 2.0 - 1.0;\n\tvScreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 vRayDir = normalize(vec3(vScreenPos, 1.0));\n\n\tvec3 vEuler = vec3(0.5 + sin(iTime * 0.2) * 0.125, 0.5 + sin(iTime * 0.1) * 0.125, iTime * 0.1 + sin(iTime * 0.3) * 0.5);\n\t\t\t\n\tif(iMouse.z > 0.0)\n\t{\n\t\tvEuler.x = -((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\tvEuler.y = -((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\tvEuler.z = 0.0;\n\t}\n\t\t\n\tvRayDir = RotateX(vRayDir, vEuler.x);\n\tvRayDir = RotateY(vRayDir, vEuler.y);\n\tvRayDir = RotateZ(vRayDir, vEuler.z);\n\t\n\tfloat fShade = 0.0;\n\t\t\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0 + iTime * c + sin(iTime * a) * b;\n\tfloat fSpeed = c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = mix(vec3(0.005, 0.0, 0.01), vec3(0.01, 0.005, 0.0), vRayDir.y * 0.5 + 0.5);\n\t\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\tvResult += Starfield(vRayDir, fZPos, fSeed);\n\t\tfSeed += 1.234;\n\t}\n\t\n\tfragColor = vec4(sqrt(vResult),1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, vec3 vRayOrigin, vec3 vRayDir )\n{\n/*\tvec2 vScreenUV = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 vScreenPos = vScreenUV * 2.0 - 1.0;\n\tvScreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 vRayDir = normalize(vec3(vScreenPos, 1.0));\n\n\tvec3 vEuler = vec3(0.5 + sin(iTime * 0.2) * 0.125, 0.5 + sin(iTime * 0.1) * 0.125, iTime * 0.1 + sin(iTime * 0.3) * 0.5);\n\t\t\t\n\tif(iMouse.z > 0.0)\n\t{\n\t\tvEuler.x = -((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\tvEuler.y = -((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\tvEuler.z = 0.0;\n\t}\n\t\t\n\tvRayDir = RotateX(vRayDir, vEuler.x);\n\tvRayDir = RotateY(vRayDir, vEuler.y);\n\tvRayDir = RotateZ(vRayDir, vEuler.z);\n*/\t\n\tfloat fShade = 0.0;\n\t\t\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0 + iTime * c + sin(iTime * a) * b;\n\tfloat fSpeed = c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = mix(vec3(0.005, 0.0, 0.01), vec3(0.01, 0.005, 0.0), vRayDir.y * 0.5 + 0.5);\n\t\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\tvResult += Starfield(vRayDir, fZPos, fSeed);\n\t\tfSeed += 1.234;\n\t}\n\t\n\tfragColor = vec4(sqrt(vResult),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXWr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[728, 768, 791, 791, 893], [895, 895, 1002, 1002, 1613], [1615, 1615, 1705, 1705, 2401], [2403, 2403, 2488, 2488, 2619], [2621, 2621, 2680, 2680, 2851], [2853, 2853, 2912, 2912, 3083], [3085, 3085, 3144, 3144, 3315], [3317, 3317, 3374, 3374, 4449], [4451, 4451, 4536, 5137, 5615]], "test": "error"}
{"id": "MdSGWm", "name": "Benham's Disk", "author": "P_Malin", "description": "Do you perceive color from this greyscale shader?\n(click the mouse to change the rotation speed) \nhttp://en.wikipedia.org/wiki/Benham's_top", "tags": ["2d", "illusion"], "likes": 13, "viewed": 1967, "published": "Public API", "date": "1399139645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Benham's Disk - @P_Malin\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Do you perceive color from this greyscale shader?\n// (click the mouse to change the rotation speed) \n// http://en.wikipedia.org/wiki/Benham's_top\n\n#define saturate(X) clamp(X, 0.0, 1.0)\n\nfloat Ramp( const in float x, const in float fBegin, const in float fEnd, const in float fFeather )\n{\n\tfloat fBeginScale = 1.0 / (fFeather * 2.0);\n\tfloat fBeginOffset = (fFeather - fBegin) / (fFeather * 2.0);\n\tfloat fFeatherBegin = saturate(x * fBeginScale + fBeginOffset);\n\n\tfloat fEndScale = -1.0 / (fFeather * 2.0);\n\tfloat fEndOffset = (fEnd + fFeather) / (fFeather * 2.0);\n\tfloat fFeatherEnd = saturate(x * fEndScale + fEndOffset);\n\t\n\treturn min( fFeatherBegin, fFeatherEnd );\n}\n\nfloat Arc( float fAngle, float fAngleFeather, float fAngleBegin, float fAngleEnd, float fDist, float fDistFeather, float fDistBegin, float fDistEnd)\n{\n\treturn min(Ramp( fAngle, fAngleBegin, fAngleEnd, fAngleFeather ),Ramp( fDist, fDistBegin, fDistEnd, fDistFeather ));\n}\n\nfloat DiskPattern( float fAngle, float fDist, float fAngleFeather, float fDistFeather )\n{\n\tfloat fResult = 0.0;\n\n\t// Semicircle\t\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, -0.5, 0.25, fDist, fDistFeather, -10.0, 10.0) );\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, 0.75, 1.5, fDist, fDistFeather, -10.0, 10.0) );\n\n\tconst float fStripeDistWidth = 0.025;\n\tconst float fStripeDistSpacing = 0.05;\n\t\n\tfloat fStripeDist = 1.0 / 5.0;\n\n\tfloat fStripeAngle1;\n\tfloat fStripeAngle2;\n\t\n\tfStripeAngle1 = -0.5;\n\tfStripeAngle2 = 0.25 + 1.0 / 8.0;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\t\n\tfStripeAngle1 = 0.25 + 1.0 / 8.0;\n\tfStripeAngle2 = 0.25 + 2.0 / 8.0;\n\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\n\tfStripeAngle1 = 0.25 + 2.0 / 8.0;\n\tfStripeAngle2 = 0.25 + 3.0 / 8.0;\n\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\n\tfStripeAngle1 = 0.25 + 3.0 / 8.0;\n\tfStripeAngle2 = 1.5;\n\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\tfResult = max( fResult, Arc(fAngle, fAngleFeather, fStripeAngle1, fStripeAngle2, fDist, fDistFeather, fStripeDist, fStripeDist+fStripeDistWidth) );\n\tfStripeDist += fStripeDistSpacing;\n\n\treturn fResult;\n}\n\nfloat GetShade(vec2 fragCoord)\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 vPos = vUV * 2.0 - 1.0;\n\tvPos.x *= iResolution.x / iResolution.y;\n\t\n\tfloat fAngle = atan(vPos.x, vPos.y) / (3.14159 * 2.0);\n\tfloat fDist = length(vPos);\n\t\n\tconst float fScale = 0.9;\n\t\t\n\tfDist /= fScale; // make it slightly smaller\n\n\tfloat fSpeed = -5.0;\n\t\n\tif(iMouse.z > 0.0)\n\t{\n\t\tfloat fMouse = (iMouse.x/iResolution.x);\n\t\tfSpeed = (fMouse - 0.5) * 20.0;\n\t}\n\t\n\tfAngle = fract(fAngle + iTime * fSpeed);\n\t\t\t\n\tconst float fShutterAngle = 1.0; // Motion blur factor\n\tfloat fAngleFeather = abs(fSpeed * fShutterAngle * (1.0 / 60.0));\n\tfAngleFeather = max( fAngleFeather, 0.001 );\n\tfloat fDistFeather = fScale * 2.0 / iResolution.y;\n\n\tfloat fShade = 0.5;\n\n\tfShade = 1.0 - DiskPattern( fAngle, fDist, fAngleFeather, fDistFeather );\n\t\n\tfloat fDiscOutline = Ramp( fDist, -0.5, 1.0, fDistFeather );\n\t\n\tfShade = mix(0.5, fShade, fDiscOutline);\n\n\t//fShade = sqrt(fShade);\n\n\treturn fShade;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat fShade = GetShade(fragCoord);\n\t\n\tvec3 vCol = vec3(fShade);\t\n\t\n\tfragColor = vec4(vCol,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSGWm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[116, 306, 407, 407, 788], [790, 790, 940, 940, 1060], [1062, 1062, 1151, 1151, 4162], [4164, 4164, 4196, 4196, 5127], [5129, 5129, 5186, 5186, 5287]], "test": "error"}
{"id": "MdsSD4", "name": "La Decima", "author": "ciberxtrem", "description": "Test to learn how to make shapes a bit complex like cups or badges, and it is also a tribute for the Decima  <img src=\"/img/emoticonHappy.png\"/>.", "tags": ["2d", "3d", "raymarching", "decima", "football", "realmadrid", "badge"], "likes": 4, "viewed": 785, "published": "Public API", "date": "1401547259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define EPSILON 0.05\n#define MAX_DIST 9999.\n#define STEP 0.1\n\nfloat gTime;\nfloat sampAvg;\nfloat cupsTime = 25.;\n\nvec3 rotate(vec3 v, vec3 k, float a){\n    vec3 r = v*cos(a) + cross(v, k)*sin(a) + k*dot(k, v)*(1.-cos(a));\n    return r;\n}\n\nfloat smin( float a, float b ){\n    float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Primitives\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p ){\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n ){\n  return dot(p,n.xyz) + n.w;\n}\n\n// Geometry\nfloat sdWings( vec3 p, vec2 h ){\n\t// Main Shape\n\tvec3 q = p - vec3(3.0, -0.8, 0.);\n\tq = rotate(q, vec3(0.,0.,1.), PI/1.85);\n\tq.x *= 0.32;\n\tvec3 ref = vec3(q.x, sin(q.x)*1.0, 0.) * (1.-step(PI* 0.928, abs(q.x)));\n\tfloat d = length(q - ref) - h.x;\n\t\n\tfloat cutPlane = sdPlane(p - vec3(0., 8.0, 0.), normalize(vec4(0,-1.,0., 0.)));\n\td = max(-cutPlane, d);\n\t\n\tcutPlane = sdPlane(p - vec3(0., -4.0, 0.), normalize(vec4(0,1.,0., 0.)));\n\td = max(-cutPlane, d);\n\t\n\t// Inner Shape\n\tq = p - vec3(3.68, 3.5, 0.);\n\tq = rotate(q, vec3(0.,0.,1.), PI/1.8);\n\tref = vec3(q.x, sin(q.x), 0.) * (1.-step(PI*1.48, abs(q.x)));\n\tfloat d2 = mix(length(q - ref) - h.x, 1., step(4., q.x ));\n\td = smin(d, d2);\n\t\n\t// Top Circle\n\tfloat circleY = 7.8;\n\tq = p - vec3(2.7, circleY, 0.0);\n\tq = rotate(q, vec3(1.,0.,0.), PI/2.);\n\td2 = sdTorus(q, vec2(1.10, h.x - 0.035));\n\t\n\tcutPlane = sdPlane(p - vec3(0., 8.4, 0.), normalize(vec4(0.2, 1.,0., 0.)));\n\td2 = max(-cutPlane, d2);\n\t\n\td = smin(d, d2);\n\treturn d;\n}\n\nvec2 sdLasso(vec3 p, vec2 h){\n\tfloat len = h.x;\n\tvec3 ref = vec3(0., p.y, sin(p.y + gTime + h.y) * abs(p.y - len) * 0.1 );\n\tfloat d = (length(p.xy - ref.xy) - (0.2 + smoothstep(0., len, abs(p.y - len)) * 0.6));\n\t\n\td = max(mix(d, 1., step(len, abs(p.y))), abs(p.z - ref.z) - 0.2);\n\t\n\treturn vec2(d, 3.);\n}\n\nfloat sdOne2D(vec3 p, vec2 s){return max(abs(p.x) - s.x, abs(p.y)-s.y);}\nfloat sdZero2D(vec3 p, vec2 s){return abs(length(p.xy) - s.x) - s.y;}\nfloat udBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\n\nvec3 sdCL(vec3 p){\n\tvec3 q = p - vec3(0., 6., 0.);\n\t\n\t// main shape\n\tvec2 h = sdSegment(vec3(0.0, 0.0, 0.0), vec3(0.0, -7.0, 0.0), q);\n\th.x = h.x - 3.5 + pow(h.y, 1.8) * 2.5;\n\tfloat d = h.x;\n\tfloat d2 = sdCappedCylinder(q - vec3(0., 3., 0.), vec2(4., 2.0));\n\td = max(d, -d2);\n\t// up part\n\td2 = sdCappedCylinder(q - vec3(0., 2.8, 0.), vec2(3.45, 2.0));\n\tfloat dy = 1. - pow(clamp(abs((q.y -2.8) / 2.0), 0., 1. ), 1.5);\n\tfloat dCutPlane = (q.y - 2.8);\n\td2 = max(d2 + dy * 1.2, dCutPlane);\n\td = smin(d, d2);\n\t// top part\n\td2 = sdCappedCylinder(q - vec3(0., 3., 0.), vec2(2.5, 0.13));\n\td = smin(d, d2);\n\t// bottom\n\td2 = sdCappedCylinder(q - vec3(0., -8, 0.), vec2(2., 0.1));\n\td = smin(d, d2);\n\t\n\td2 = sdCappedCylinder(q - vec3(0., -8.20, 0.), vec2(2.5, 0.2));\n\td = smin(d, d2);\n\t// wings\n\tvec3 q2 = q - vec3(-6., -2, 0.);\n\td2 = sdWings(q2, vec2(0.25, 0.0));\n\td = smin(d, d2);\n\t\n\tq2 = rotate(q - vec3(6., -2, 0.), vec3(0., 1., 0.), PI);\n\td2 = sdWings(q2, vec2(0.25, 0.0));\n\td = smin(d, d2);\n\t// lasso\n\tvec2 res = vec2(d, 2.);\n\tvec2 res2 = sdLasso(q - vec3(3., -1., 0.), vec2(5., 2.*PI));\n\tif(res2.x < res.x) {\n\t\tres = res2;\n\t}\n\tres2 = sdLasso(q - vec3(-3., -1., 0.), vec2(3.5, PI));\n\tif(res2.x < res.x) {\n\t\tres = res2;\n\t}\n\t// cube\n\td = udBox(q - vec3(0., -11, 0.), vec3(2.5));\n\tif(d < res.x) {\n\t\tres = vec2(d, 4.);\n\t}\n\t\n\treturn vec3(res.xy, d);\n}\n\nvec3 CLGroup(vec3 p)\n{\n\tfloat c = 13.;\n\tvec3 q = p;\n\tq = mix((q - vec3(0., 0., -0.)) * vec3(1., 1.0, 1.0), q, step(26., abs(p.x)));\n\tq.x = mod(p.x,c)-0.5*c;\n\t\n\tvec3 res = sdCL(q);\n\tres = mix(res, vec3(1., -1., 9999.), step(65., abs(p.x)));\n\treturn res;\n}\n\nvec3 map(vec3 p)\n{\t\n\tvec3 res = CLGroup(p - vec3(0., 0.0, 35.));\n\tvec2 res2 = vec2(sdPlane(p - vec3(0., -6.5, 0.), normalize(vec4(0,1., 0., 0.))), 1.);\n\tif(res2.x < res.x)\n\t{\n\t\tres.xy = res2.xy;\n\t}\n\tres2 = vec2(sdPlane(p - vec3(0., 0.0, 40.), normalize(vec4(0,0., -1., 0.))), 5.);\n\tif(res2.x < res.x)\n\t{\n\t\tres.xy = res2.xy;\n\t}\n\treturn res;\n}\n\nvec3 calcNormal(vec3 p)\n{\n\tvec3 e = vec3(EPSILON, 0., 0.);\n\t\n\tvec3 n = vec3\n\t(\n\t\t  map(p + e.xyy).x - map(p - e.xyy).x\n\t\t, map(p + e.yxy).x - map(p - e.yxy).x\n\t\t, map(p + e.yyx).x - map(p - e.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\n\nvec3 intersect(vec3 ro, vec3 rd)\n{\n\tfloat prec = 0.002;\n\tfloat k = 2.*prec;\n\tvec3 res = vec3(MAX_DIST, -1., 9999.);\n\tfloat bloom = MAX_DIST;\n\t\n\tfor(int i = 0; i < 90; ++i)\n\t{\n\t\tif(res.x <= prec)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tres = map(ro + k*rd);\n\t\tbloom = res.z < bloom ? res.z : bloom;\n\t\tk += res.x;\n\t}\n\t\n\tif(res.x > prec)\n\t{\n\t\tres.y = -1.;\n\t\tk = MAX_DIST;\n\t}\n\t\n\tres.x = k;\n\tres.z = bloom;\n\t\n\treturn res;\n}\n\nvec3 colorBadge(vec3 p)\n{\n\tvec3 bgColor =  vec3(0.43,0.5,0.55);\n\tvec3 bColor = bgColor;\n\tvec3 q = p - vec3(1., 25., 0.);\n\t\n\t// foreground\n\tfloat d = length(q.xy)- 8.2;\n\tbColor = mix(vec3(1.), bColor, step(0., d));\n\t\n\tfloat d2 = max(length(q.xy - vec2(q.x, q.x))- 3.5, length(q.xy) - 8.);\n\tbColor = mix(vec3(0., 0., 0.7), bColor, step(0., d2));\n\td = min(d, d2);\n\t// main circle\n\td2 = sdZero2D(q, vec2(8., 0.4));\n\t// color + border\n\tbColor = mix(mix(vec3(0.), vec3(1., 0.84, 0.), smoothstep(0., 0.2, abs(d2))), bColor, step(0., d2));\n\td = min(d, d2);\n\n\t// sub circles\n\tvec3 q2 = q - vec3(-0.5, 0.0, 0.);\n\td2 = mix(sdZero2D(q2, vec2(5.6, 0.4)), 1., step(-3.0, q2.x));\n\tq2 = q - vec3(0.5, 0.0, 0.);\n\tfloat d3 = mix(sdZero2D(q2, vec2(5.6, 0.4)), 1., step(-3.0, -q2.x));\n\td2 = min(d2, d3);\n\t\n\t// m2\n\tq2 = q - vec3(-1.75, 2.9, 0.);\n\td3 = max(length(q2.xy - vec2(q2.x, -q2.x))- 0.6, length(q2.xy) - 2.9);\n\td2 = min(d2, d3);\n\t\n\t// c\n\tq2 = q - vec3(0.5, 0., 0.);\n\td3 = mix(sdZero2D(q2, vec2(2.5, 0.4)), 1., step(1.8, -q2.x));\n\td2 = min(d2, d3);\n\t\n\t// m1\n\tq2 = q - vec3(1.75, 2.9, 0.);\n\td3 = max(length(q2.xy - vec2(q2.x, q2.x))- 0.6, length(q2.xy) - 2.9);\n\td2 = min(d2, d3);\n\t\n\t// f\n\tq2 = q - vec3(-0.5,0.,0.);\n\td3 = min(min(sdOne2D(q2, vec2(0.8, 0.5)), sdOne2D(q2 - vec3(1., -2.5, 0.), vec2(0.5, 3.0))), sdOne2D(q2 - vec3(0.,-1.2, 0.), vec2(0.8, 0.5)));\n\td2 = min(d2, d3);\n\t// color + border\n\tbColor = mix(mix(vec3(0.), vec3(1., 0.84, 0.), smoothstep(0., 0.2, abs(d2))), bColor, step(0., d2));\n\t\n\tq2 = q - vec3(0.,0.5,0.);\n\td3 = mix(sdZero2D(q2, vec2(10.0, 1.6)) + mix(0., sin(p.x*2.0)*sin(p.y)*0.2, step(10., q2.y)), 1., max(step(q2.y, -q2.x*1.5 + 2.5), step(q2.y, q2.x*1.5 + 2.5)));\n\tif(d3 < 0.)\n\t{\n\t\tbColor = mix(bColor, vec3(0.8,0.,0.), step(10., length(q.xy)));\n\t\tbColor = mix(vec3(1., 0.84, 0.), bColor, step(10., length(q.xy) + sin(p.x * 4.) * sin(p.y*5.) * 0.6 ));\n\t\tbColor = mix(vec3(0.), bColor, smoothstep(0., 0.4, abs(d3)));\n\t}\n\td2 = min(d2, d3);\n\t\n\t// cross\n\tq2 = q - vec3(0.,13.7,0.);\n\td3 = sdOne2D(q2, vec2(0.35, 2.6));\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\n\td2 = min(d2, d3);\n\t\n\tq2 = q - vec3(0.,15.6,0.);\n\td3 = sdOne2D(q2, vec2(1.0, 0.25));\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\n\td2 = min(d2, d3);\n\t\n\t// top\n\tq2 = q - vec3(3.0,11.,0.);\n\td3 = mix(sdZero2D(q2, vec2(2.0, 0.5)), 1., step(q2.y, -q2.x*0.8 + 1.5)) + sin(p.x * 6.) * sin(p.y*6.) * 0.1;\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\n\td2 = min(d2, d3);\n\t\n\tq2 = q - vec3(-3.0,11.,0.);\n\td3 = mix(sdZero2D(q2, vec2(2.0, 0.5)), 1., step(q2.y, q2.x*0.8 + 1.5)) + sin(p.x * 6.) * sin(p.y*6.) * 0.1;\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\n\td2 = min(d2, d3);\n\t\n\tq2 = q - vec3(0.,12.,0.);\n\td3 = mix(sdZero2D(q2, vec2(2.5, 0.5)), 1., step(q2.y, -1.)) + sin(p.x * 6.) * sin(p.y*6.) * 0.1;\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\t\n\td = min(min(d2, d3), d);\n\t\n\tif(d < 0.){ // Apply illumination to badge\n\t\tbColor += 1.5 * pow(max(dot(normalize(vec3(sin(gTime) * 0., 4., -10) - q), vec3(0.,0.,-1.)), 0.), 150.);\n\t}\n\t\n\t// One\n\tq = p - vec3(13., 26.5, 0.);\n\tfloat dNumber = mix(sdOne2D(q, vec2(2.0, 9.)), 1., smoothstep(-q.x*0.5 - 1.5, -q.x*0.5, q.y-6.));\n\td = min(d, dNumber);\n\tvec3 colorOne = mix(vec3(1., 0.84, 0.), mix(vec3(1.), bgColor, smoothstep(0., 0.2, dNumber)), smoothstep(0., 0.3, abs(dNumber)));\n\n\tvec3 layer1 = mix(colorOne, bColor, smoothstep(0., 0.2, dNumber));\n\tlayer1 = mix(bgColor, layer1, smoothstep(20., 45., gTime));\n\t\n\t\n\t// Zero\n\t//dNumber = length(max(abs(q - vec3(-13., -1.,0.)).xy-vec2(3., 3.).xy,0.0))-5.0;\n\t//dNumber = mix(1., dNumber, smoothstep(-5.5, 0., dNumber));\n\t//d = min(d, dNumber);\n\t//vec3 layer0 = mix(vec3(1., 0.84, 0.), mix(vec3(1.), bgColor, smoothstep(0., 0.2, dNumber)), smoothstep(0., 0.3, abs(dNumber)));\n\t//layer0 = mix(layer0, colorOne, smoothstep(0., 0.2, dNumber));\n\t\n\t// mix badge and number zero\n\t//bColor = mix(bgColor, mix(layer1, layer0, smoothstep(35., 46., gTime)), smoothstep(20., 35., gTime));\n\t\n\t//return bColor;\n\treturn layer1;\n}\n\nvec4 mapColor(vec3 res, vec3 p, out vec2 colorExtra)\n{\n\tcolorExtra = vec2(1.); // r:diffFactor, g:specFactor\n\tvec4 col = vec4(1.);\n\t\n\tfloat currentCup = (68.5 - 3. * (p.x-70.)/140.) - floor(((max(gTime-4., 0.) / (cupsTime-2.)) * 10.)) * 0.1 * 140.;\n\tfloat cupIntensity = step(currentCup, p.x) * max(mix(fract((max(gTime-4., 0.) / (cupsTime-2.))*10.), 1., step(cupsTime, max(gTime-4., 0.))), 1. - step(abs(p.x - currentCup), 140.*0.1));\n\t\n\tif(res.y < 1.5){ //floor\n\t\tcol = vec4(0., 0.,0.2, 1.);\n\t\tcolorExtra = vec2(0.2, 0.1);\n\t}\n\telse if(res.y < 2.5){ //cl\n\t\tcol = mix(vec4(0.), vec4(0.72,0.72,0.72, 0.5), cupIntensity);\n\t\tcolorExtra = vec2(0.1, 0.5);\n\t}\n\telse if(res.y < 3.5){ // lasso\n\t\tcol = vec4(1., 1., 1., 0.);\n\t\tcolorExtra = vec2(0.5, 1.0);\n\t}\n\telse if(res.y < 4.5){ //Cube\n\t\tcol = mix(vec4(0.), vec4(1., 1., 1., 0.), cupIntensity);\n\t}\n\telse if(res.y < 5.5) { // Wall\n\t\tcol = vec4(colorBadge(p), 0.2);\n\t\tcolorExtra = vec2(0.5, 0.1);\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tgTime = iTime;\n\t\n\tvec4 soundSampler = texture(iChannel0, vec2(0.5));\n\tsampAvg = (soundSampler.r + soundSampler.b + soundSampler.g) / 3.;\n\t\n\tfloat ar = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = ((uv * 2.) - 1.) * vec2(ar, -1.);\n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. -1.;\n\tvec3 mouseDir = vec3(-mouse.x*2., 0., 1.) * max((mouse.y+1.) * 20., 0.);\n\t\n\tfloat travelFactor = 1.-clamp(pow((max(0., (gTime-5.)*0.05)), 1.3), 0., 1.);\n\tvec3 ro = vec3(0. + 58.*travelFactor, 1.*travelFactor,-15. + 38.*travelFactor) + mouseDir; //vec3(0. + 60.*travelFactor, 0.0,-15. + 38.*travelFactor);\n\tfloat rotSpeed = 0.;\n\tro = vec3(ro.x * cos(gTime*rotSpeed) - ro.z * sin(gTime*rotSpeed), ro.y, ro.z * cos(gTime*rotSpeed) + ro.x * sin(gTime*rotSpeed));\n\tvec3 camLA = ro + vec3(0. + 6.*travelFactor, 1. + 4.*travelFactor,30.) + vec3(-mouse.x, (mouse.y+1.)*0.5, 1.) * 0.1; //vec3(0. + 60.*travelFactor, 1. + 1.*travelFactor,30.);\n\tvec3 camFront = normalize(camLA - ro);\n\tvec3 camRight = normalize(cross(camFront, vec3(0,1,0)));\n\tvec3 camUp = normalize( cross(camFront, camRight) );\n\t\n\tfloat halffov = 38. * (PI/180.);\n\tfloat scale = tan(halffov);\n\tvec3 rd = normalize(camFront + camRight * uv.x * scale + camUp * uv.y * scale);\n\t\n\tfloat att = 1.;\n\tvec4 totalCol = vec4(0,0,0,1);\n\tvec2 bloom = vec2(0., 9999.);\n\t\n\tfor(int i = 0;i < 2; ++i)\n\t{\n\t\tif(att < 0.01) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvec3 res = intersect(ro, rd);\n\t\tvec4 col = vec4(0,0,0,1);\n\t\tvec3 p = ro + res.x*rd;\n\t\tvec2 colorExtra = vec2(1.);\n\t\t\t\t\t\t  \n\t\tif(res.y > 0.) {\t\n\t\t\tvec4 dif = mapColor(res, p, colorExtra);\n\t\t\t\n\t\t\tvec3 lightOr = vec3(0., 4., 0.);\n\t\t\tvec3 lightDir = normalize(lightOr - p);\n\t\t\t\n\t\t\tvec3 n = calcNormal(p);\n\t\t\tfloat difFac = pow(max(dot(n, lightDir), 0.), 4.) * 0.2;\n\t\t\t\t\t\t\n\t\t\tvec3 refl = normalize(rd + 2.*dot(-rd, n)*n);\n\t\t\tfloat specFac = pow(max(dot(lightDir, refl), 0.), 10.);\n\t\t\tfloat ambFac = 0.05;\n\t\t\t\n\t\t\tcol.rgb += dif.rgb * (ambFac + difFac*(1.-ambFac)) * vec3(250,250,210)/255.;\n\t\t\tcol.rgb += vec3(1.,0.9,0.82)* 2. * specFac * colorExtra.g;\n\t\t\tcol.rgb += (dif.rgb * colorExtra.r);\n\t\t\t\n\t\t\ttotalCol.rgb += col.rgb * att;\n\t\t\t\n\t\t\tro = p;\n\t\t\trd = refl, rd;\n\t\t\t\n\t\t\tatt *= 0.7 * dif.a;\n\t\t}\n\t\telse {\n\t\t\tcol = vec4(0,0,0,1);\n\t\t\tatt = 0.;\n\t\t}\n\t\t\n\t\t// Save Bloom data\n\t\tbloom = mix(vec2(res.z, mix(1., sampAvg, step(45., gTime))), bloom, step(0.5, float(i)));\n\t}\n\t\n\t// Bloom\n\ttotalCol.rgb = mix(totalCol.rgb + vec3(1., 0.84, 0.) * 2.0 * sampAvg * clamp(smoothstep(44., 45., gTime), 0., 1.), totalCol.rgb, smoothstep(0., 2.0, pow(bloom.x, 0.5)));\n\t\n\t// vigneting\n\ttotalCol.rgb = mix(totalCol.rgb, totalCol.rgb * vec3(0), length(uv) * 0.4);\n\t\n\tfragColor = totalCol * smoothstep(0., 1., gTime * 0.1);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 168, 168, 254], [256, 256, 287, 287, 396], [398, 412, 444, 444, 509], [511, 511, 552, 552, 685], [687, 687, 729, 729, 828], [830, 830, 862, 862, 893], [895, 907, 939, 954, 1882], [1884, 1884, 1913, 1913, 2188], [2190, 2190, 2220, 2220, 2262], [2263, 2263, 2294, 2294, 2332], [2333, 2333, 2363, 2363, 2398], [2400, 2400, 2418, 2418, 3741], [3743, 3743, 3765, 3765, 3997], [3999, 3999, 4017, 4017, 4340], [4342, 4342, 4367, 4367, 4570], [4572, 4572, 4606, 4606, 4976], [4978, 4978, 5003, 5003, 9232], [9234, 9234, 9288, 9288, 10192], [10194, 10194, 10251, 10251, 12951]], "test": "error"}
{"id": "MdsSDn", "name": "ColdbergFlower", "author": "Coldberg", "description": "flower", "tags": ["flower"], "likes": 2, "viewed": 336, "published": "Public", "date": "1399478382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat F (float x, float y) {\n\tfloat N = 5.0;\n\tfloat r = distance (vec2 (x,y), vec2 (0.0));\n\tfloat f = mod (atan (y, x) + iTime * PI * 0.5, PI*2.0);\n\tfloat q = (f/PI + 1.0)/2.0;\n\treturn (r*2.0/(1.0 - sin (f*N)) - 0.5); \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = \n\t\t(fragCoord.xy / iResolution.xy - vec2 (0.5))* \n\t\tvec2 (iResolution.x / iResolution.y, 1.0) ;\n\t\t\n\tfloat f = F(uv.x, uv.y);\n\t\n\tif (f > 0.0)\n\t\tfragColor = vec4 (1.0,1.0 - f,0.0,1.0);\n\telse\n\t\tfragColor = vec4 (1.0 + f,1.0,0.0,1.0);\t\t\t\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 247], [250, 250, 307, 307, 554]], "test": "valid"}
{"id": "MdsSW8", "name": "CafeJuliaFun", "author": "cafe", "description": "CafeJuliaFun", "tags": ["cafejuliafun"], "likes": 1, "viewed": 112, "published": "Public", "date": "1400285092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wdist;\n\nfloat dist(vec2 uv){\n\tuv=abs(pow(uv,vec2(sin(iTime)*0.5+0.7)));\n\tuv*=normalize(vec2(1.)+vec2(-1.,1.)*cos(iTime*1.7)*0.5+0.7);\n\tfloat d=max(uv.x,uv.y);\n\treturn abs(d);\t\n}\n\nvec2 warp(vec2 uv){\n\tuv=vec2(uv.x*uv.x-uv.y*uv.y , 2.*uv.x*uv.y);\n\twdist=min(wdist,dist(uv));\n\treturn uv;\n}\n\nvec3 shade(vec2 uv){\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n\tvec2 wv=uv;\n\t\n\twdist=dist(uv);\n\t\n\tfor(int i=0 ; i<15 ; i++)\n\t\twv = mouse+warp(wv);\n\t\n\tif(wdist>0.3) return vec3(0.2,0.2,0.3);\n\t\n\twdist=abs(wdist-0.2+0.*sin(iTime));\n\twdist=wdist-0.1;\n\tif(wdist<0.) wdist=sin(exp(-wdist*20.)*2.);\n\telse return vec3(0.25,0.25,0.4);\n\t\n\t\n\tfloat  d = smoothstep(0.,0.01,wdist);\n\t\n\treturn vec3(0.7,0.4,0.5)*(0.3*(1.-d)+1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(shade(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsSW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 34, 34, 183], [185, 185, 204, 204, 292], [294, 294, 314, 314, 732], [734, 734, 790, 790, 885]], "test": "valid"}
{"id": "MdXSWn", "name": "mandelbulb_", "author": "EvilRyu", "description": "a mandelbulb", "tags": ["raymarching", "fractal", "cineshader"], "likes": 133, "viewed": 102760, "published": "Public API", "date": "1399098998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// whether turn on the animation\n//#define phase_shift_on \n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n\nfloat pixel_size = 0.0;\n\n/* \n\nz = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n\nzn+1 = zn^8 +c\n\nz^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n\nzn+1' = 8 * zn^7 * zn' + 1\n\n*/\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z / r) + iTime*0.1;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, iTime*0.2);\n     return mb(p); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\nvec3 nor( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<48; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 20.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = f(ro + rd*t);\n            d = c.x;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>20.0/* || max_error > pixel_size*/ ) res_t=-1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n     \n    pixel_size = 1.0/(iResolution.x * 3.0);\n\t// camera\n \tstime=0.7+0.3*sin(iTime*0.4); \n \tctime=0.7+0.3*cos(iTime*0.4); \n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\tvec3 ro = vec3(0.0, 3.*stime*ctime, 3.*(1.-stime*ctime));\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.0);\n\n    float halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           vec3 n=nor(p); \n           float shadow = softshadow(p, sundir, 10.0 );\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * sun * dif * shadow; \n           lin += 0.8 * bac * sun; \n           lin += 0.6 * sky * skycolor*shadow; \n           lin += 3.0 * spe * shadow; \n\n\t\t   res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n\t\t   vec3 tc0 = 0.5 + 0.5 * sin(3.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0));\n           col = lin *vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t\t   col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor = vec4(col.xyz, smoothstep(0.55, .76, 1.-res.x/5.)); \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXSWn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[111, 192, 223, 223, 341], [370, 573, 590, 590, 1205], [1208, 1208, 1223, 1223, 1267], [1272, 1272, 1317, 1317, 1551], [1554, 1554, 1579, 1579, 1790], [1792, 1792, 1834, 1834, 2851], [2854, 2854, 2913, 2913, 4993]], "test": "valid"}
{"id": "MdXXW4", "name": "Mandelstrip", "author": "jld", "description": "In which the Mandelbrot set is unrolled and then stretched out into an infinite strip.  Scroll left/right by dragging.", "tags": ["2d", "fractal", "mouse", "mandelbrot"], "likes": 3, "viewed": 186, "published": "Public", "date": "1400966271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\n#define N 200\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 rth = fragCoord.xy / iResolution.xy * 1.5;\n\trth.x -= 0.75;\n\trth.x *= iResolution.x / iResolution.y;\n\tfloat scroll = 27.0 * tan((iMouse.x / iResolution.x * 2.0 - 1.) * 1.25) / tan(1.25);\n\trth.x += scroll;\n\tfloat thing = 1.0 + abs(rth.x) / M_PI;\n\trth = vec2(M_PI / thing, rth.y / thing / thing);\n\t\n\tvec2 z0 = (1.0 + rth.y) * vec2(cos(rth.x), sin(rth.x)) / 2.0;\n\tvec2 z1 = vec2(1.0, 0.0) - z0;\n\tvec2 c = vec2(z0.x * z1.x - z0.y * z1.y, z0.x * z1.y + z0.y * z1.x);\n\tvec2 a = c;\n\t\n\tfloat gdec = pow(0.93, 1.0 / (1.0 + abs(scroll) / 10.0));\n\tfloat g = pow(abs(scroll) + 1.0, .121212);\n\tfloat thresh = 10.0 + 6.0 * sin(iTime);\n\t\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (dot(a, a) > thresh) {\n\t\t\tg *= log(thresh) / log(dot(a, a));\n\t\t\tbreak;\n\t\t}\n\t\tg *= gdec;\n\t    a = vec2(a.x * a.x - a.y * a.y, 2.0 * a.x * a.y) + c;\n\t}\n\tvec2 an = normalize(a);\n\tvec3 color = vec3(dot(an, vec2(-0.5, sqrt(0.75))),\n\t\t\t\t\t  dot(an, vec2(-1.0, 0.0)),\n\t\t\t\t\t  dot(an, vec2(-0.5, -sqrt(0.75)))) + 1.0;\n\n\tfragColor = vec4(g * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXXW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 1118]], "test": "valid"}
{"id": "MsBGWd", "name": "Ever Watchful", "author": "ahihi", "description": "\"paranoia on parasta viihdettÃÂ¤\"", "tags": ["2d"], "likes": 0, "viewed": 186, "published": "Public", "date": "1400512325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307179586\n#define UNIT 1.3\n\nfloat scale(float l0, float r0, float l1, float r1, float x) {\n\treturn (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nvec2 shear(float theta, vec2 p) {\n\treturn vec2(p.x - p.y / tan(theta), p.y / sin(theta));\n}\n\nvec2 unshear(float theta, vec2 p) {\n\tfloat y = p.y * sin(theta);\n\tfloat x = p.x + y / tan(theta);\n\treturn vec2(x, y);\t\n}\n\nfloat rand(vec2 p){\n\treturn fract(sin(dot(p.xy, vec2(1.3295, 4.12))) * 493022.1);\n}\n\nfloat timestep(float duration, float t) {\n\treturn floor(t / duration) * duration;\n}\n\nvec2 polar(vec2 p) {\n\treturn vec2(atan(p.y, p.x), length(p));\n}\n\nvec2 cartesian(vec2 p) {\n\treturn vec2(p.y * cos(p.x), p.y * sin(p.x))\t;\n}\n\nvec3 eyes(float t, vec2 coord) {\n\tvec2 p0 = 2.0*(coord - 0.5 * iResolution.xy) / iResolution.xx;\n\t\n\tfloat unit = UNIT;\n\tfloat d_step0 = 1.1544 * unit;\n\tfloat d_step1 = 1.823 * unit;\n\tfloat d_step2 = 2.32 * unit;\n\tfloat d_step3 = 2.9757 * unit;\n\tfloat d_step4 = 1.21 * unit;\n\tfloat d_step5 = 0.93354 * unit;\n\t\n\tfloat t_step0 = timestep(d_step0, t);\n\tvec2 p0_rot = cartesian(polar(p0) + vec2(scale(0.0, 1.0, 0.0, TAU, rand(vec2(0.0, sqrt(t_step0)))), 0.0));\n\tvec2 p0_step = p0_rot + vec2(\n\t\tscale(0.0, 1.0, -1.0, 1.0, rand(vec2(t_step0, 0.0))),\n\t\tscale(0.0, 1.0, -1.0, 1.0, rand(vec2(0.0, t_step0)))\n\t);\n\tfloat theta = TAU/4.0 + scale(0.0, 1.0, -1.0, 1.0, rand(vec2(0.0, timestep(d_step1, t))));\n\n\tfloat k_p1 = scale(0.0, 1.0, 2.0, 5.0, rand(vec2(timestep(d_step2, t), 0.0)));\n\tvec2 p1 = k_p1 * (p0_step /*+ 0.125*/);\n\t\t\n\tvec2 p2 = shear(theta, p1);\n\t\n\tfloat d_move = 0.4;\n\tvec2 p_c = floor(p2) + 0.5 + scale(0.0, 1.0, -d_move, d_move, rand(vec2(timestep(d_step3, t), 0.0)));\n\tvec2 p3 = unshear(theta, p_c);\n\t\t\n\tfloat radius = scale(0.0, 1.0, 0.3, 0.6, rand(vec2(-42.0, timestep(0.21 * unit, t))));//0.25;\n\tfloat rings = floor(scale(0.0, 1.0, 1.0, 4.0, rand(vec2(0.0, timestep(d_step4, t)))));\n\tfloat dist = distance(p3, p1);\n\tfloat ring_i = floor(dist/radius * rings);\n\tfloat ring_i2 = floor(dist / radius * 2.0 * rings);\n\tfloat ring_pos = fract(dist / radius * rings);\n\tfloat ring_pos2 = fract(dist / radius * 2.0 * rings);\n\tfloat r_pupil = radius / scale(0.0, 1.0, 1.5, 2.0, rand(vec2(timestep(0.322*unit, t), 0.0)));\n\t\n\tbool in_pupil = dist < r_pupil;\n\tbool in_iris = dist < radius;\n\t\n\tfloat bright = 1.0 - 0.75 * ring_i/rings * radius;\n\tfloat k_light = scale(0.0, 1.0, 0.76, 1.25, rand(vec2(-42.0, timestep(0.267*unit, t))));\n\tfloat light = k_light * bright * scale(0.0, 1.0, 0.5, 1.0, ring_pos);\n\tvec3 color = vec3(light, light, light);\n\tif(in_pupil) {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t} else if(in_iris) {\n\t\tvec3 iris0 = vec3(\n\t\t\tscale(-1.0, 1.0, 0.2, 0.96, sin(timestep(0.2*unit, 0.6654*t))),\n\t\t\tscale(0.0, 1.0, 0.0, 0.6, rand(floor(p2) * vec2(timestep(0.33*unit, .5*t + 53.0*floor(p2.x+p2.y)), -3211.1))),\n\t\t\tscale(-1.0, 1.0, 0.1, 0.7, sin(timestep(0.115*unit, 0.533*t)))\n\t\t);\n\n\t\tvec3 iris1 = iris0 * 0.7;\n\t\t\n\t\tcolor = mix(iris0, iris1, ring_pos2);\n\t}\n\tcolor *= scale(0.0, 1.0, 0.3, 1.0, rand(floor(p2) + vec2(timestep(1.0*unit, t), 0.1222)));\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t_0 = iTime;\n\tfloat t_1 = t_0 + UNIT*1.7;\n\tfloat mod_offset = 0.0;\n\tfloat mod0 = fract(iTime / UNIT);\n\tfloat mod_t = scale(-1.0, 1.0, 0.3, 0.7, sin(5.55 * iTime));\n\t\n\tvec3 color = eyes(t_0, fragCoord);\n\tif(rand(fragCoord.xy + vec2(0.0, timestep(0.125 * UNIT, iTime))) < mod_t) {\n\t\tcolor = eyes(t_1, fragCoord);\t\n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsBGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 110, 110, 159], [161, 161, 194, 194, 252], [254, 254, 289, 289, 374], [376, 376, 395, 395, 459], [461, 461, 502, 502, 544], [546, 546, 566, 566, 609], [611, 611, 635, 635, 684], [686, 686, 718, 718, 3054], [3056, 3056, 3113, 3113, 3470]], "test": "valid"}
{"id": "MsfSWr", "name": "Trefoil", "author": "fizzgig", "description": "Was going to edit this one - https://www.shadertoy.com/view/MdfSDn - but wouldn't let me save for some reason. Thought it would make a cool wallpaper :)", "tags": ["distortion", "perlin", "emission", "parabola"], "likes": 6, "viewed": 344, "published": "Public", "date": "1399054267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535;\n\n// of equation x^3+c1*x+c2=0\n/* Stolen from http://perso.ens-lyon.fr/christophe.winisdoerffer/INTRO_NUM/NumericalRecipesinF77.pdf,\n   page 179 */\nfloat cubicRoot(float c1, float c2) {\n\tfloat q = -c1/3.;\n\tfloat r = c2/2.;\n\tfloat q3_r2 = q*q*q - r*r;\n\tif(q3_r2 < 0.) {\n\t\tfloat a = -sign(r)*pow(abs(r)+sqrt(-q3_r2),.333333);\n\t\tfloat b = a == 0. ? 0. : q/a;\n\t\tfloat x1 = a+b;\n\t\treturn x1;\n\t}\n\treturn 0.;\n\t/*float theta = acos(r/pow(q,1.5));\n\tfloat sqr_q = pow(q,.5);\n\tvec3(-2.*sqr_q*cos(theta/3.),\n\t\t -2.*sqr_q*cos((theta+2.*pi)/3.),\n\t\t -2.*sqr_q*cos((theta-2.*pi)/3.));*/\n}\n\nfloat arcLength(float a, float b, float x) {\n\tfloat f = .25/a;\n\tfloat h = x/2.;\n\tfloat q = length(vec2(f,h));\n\treturn h*q/f+f*log((h+q)/f);\n}\n\nvec2 parabolaCoords(float a,float b,vec2 co) {\n\tfloat x = cubicRoot((1./a-2.*co.y+2.*b)/(2.*a),(-co.x)/(2.*a*a));\n\treturn vec2(length(co-vec2(x,a*x*x+b)),arcLength(a,b,x));\n}\n\nfloat noise3(vec3 co){\n  return fract(sin(dot(co ,vec3(12.9898,78.233,125.198))) * 43758.5453);\n}\n\nfloat smooths(float v) {\n\treturn 3.*pow(v,2.)-2.*pow(v,3.);\n}\n\nfloat perlin3(vec3 p) {\n\tfloat val = 0.;\n\tfor(float i=0.;i<3.;i += 1.){\n\t\tp *= pow(2.,i);\n\t\tvec3 c = floor(p);\n\t\tfloat u = smooths(fract(p.x));\n\t\tfloat v = smooths(fract(p.y));\n\t\tval = 1.-((1.-val)*(1.-pow(.5,i)*\n\t\t\tmix(mix(mix(noise3(c),noise3(c+vec3(1.,0.,0.)),u),\n\t\t\t\t\tmix(noise3(c+vec3(0.,1.,0.)),noise3(c+vec3(1.,1.,0)),u),v),\n\t\t\t    mix(mix(noise3(c+vec3(0.,0.,1.)),noise3(c+vec3(1.,0.,1.)),u),\n\t\t\t\t\tmix(noise3(c+vec3(0.,1.,1.)),noise3(c+vec3(1.,1.,1.)),u),v),fract(p.z))));\n\t}\n\treturn val;\n}\n\nvec4 paraNoise(float a, float b, vec2 uv) {\n\tfloat cutoff = 1.;\n\tvec2 r = parabolaCoords(a,b,uv);\n\tif (r.x < cutoff){\n\t\tr.x = pow(r.x*.8+.7,3.);\n\t\tfloat l = exp(-r.x*2.5)+.01/(r.x-.33);\n\t\tr.x -= iTime*3.;\n\t\tfloat v = perlin3(vec3(r,iTime));\n\t\treturn vec4(vec3(v*1.,v*1.+0.6*cos(.5*iTime),v*(.5*sin(iTime)+.5)*2.5)*l,v);\n\t}\n\treturn vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tvec2 r = uv-(iResolution.xy/iResolution.x)*vec2(.5,.5);\n\tr *= 6.;\n\t\n\tmat2 rot = mat2(-.5,.866,-.866,-.5);\n\t\n\tfragColor = paraNoise(.6,.7,r);\n\tr = rot*r;\n\tfragColor += paraNoise(.6,.7,r);\n\tr = rot*r;\n\tfragColor += paraNoise(.6,.7,r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 178, 215, 215, 602], [604, 604, 648, 648, 745], [747, 747, 793, 793, 921], [923, 923, 945, 945, 1020], [1022, 1022, 1046, 1046, 1083], [1085, 1085, 1108, 1108, 1583], [1585, 1585, 1628, 1628, 1927], [1929, 1929, 1986, 1986, 2263]], "test": "valid"}
{"id": "MsfXWH", "name": "exercice1", "author": "moustache", "description": "sphere + plan raytracer", "tags": ["raytracer"], "likes": 1, "viewed": 125, "published": "Public", "date": "1400024436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mon shader\n\nstruct sphere_t{\n\tvec3 position;\n\tfloat radius;\n\tvec3 normal;\n\tvec3 color;\n\tfloat ka;\n};\n\t\nstruct surface_t{\n\tvec3 position;\n\tfloat identify;\n\tvec3 normal;\n\tvec3 color;\n\tvec3 collisionpoint;\n};\n\t\nstruct ray_t{\n\tvec3 origin;\n\tvec3 direction;\n\t\n};\n\t\nstruct light_t{\n\tvec3 direction;\n\tfloat intensity;\n\tvec3 position;\n};\t\n\t\nstruct plane_t{\n\tfloat a, b, c, d;\n\tvec3 color;\n\tfloat ka;\n};\n\nvec3 mult(float t, vec3 v){\n\treturn vec3(v.x*t, v.y*t, v.z*t);\n}\n\nfloat magnitude(vec3 v){\n\treturn sqrt(v.x*v.x + v.y*v.y + v.z*v.z);\n}\n\t\nfloat fAttenuation(float d){\n\tfloat attenuation = 1./(0.1 + 5e-5*d + 7e-5*d*d);\n\treturn min(attenuation, 1.);\n}\n\nvec3 reflectedVec(vec3 normal, vec3 ray){\n\treturn normalize(mult(2.* dot(normal, -ray), normal) + ray);\n}\n\nfloat intersectSphere( in ray_t ray, inout sphere_t sphere){\n\tfloat c=pow(ray.origin.x-sphere.position.x,2.0)+pow(ray.origin.y-sphere.position.y,2.0)+pow(ray.origin.z-sphere.position.z,2.0)-pow(sphere.radius,2.0);\n\tfloat b=2.0*(ray.direction.x * (ray.origin.x-sphere.position.x) + ray.direction.y * (ray.origin.y-sphere.position.y) + ray.direction.z*(ray.origin.z-sphere.position.z));\n\tfloat a = pow(ray.direction.x,2.0) + pow(ray.direction.y,2.0) + pow(ray.direction.z,2.0);\n\tfloat delta = pow(b,2.0) -4.0 * a * c;\n\t\n\tfloat t =min((-b-sqrt(delta))/(2.0*a), (-b+sqrt(delta))/(2.0*a));\n\tif(delta>=0.0){\n\t\tsphere.normal= vec3( ray.origin.x + t * ray.direction.x - sphere.position.x, ray.origin.y + t* ray.direction.y - sphere.position.y, ray.origin.z + t* ray.direction.z - sphere.position.z)  ;\n\t\treturn t;\n\t}\n\telse{\n\t\t sphere.normal=vec3(0.0, 0.0, 0.0);\n\t\t return 1e5;\n\t}\n}\n\nfloat intersectPlane(const in ray_t ray, const in plane_t plane){\n\tfloat numerateur= -(ray.origin.x * plane.a + ray.origin.y * plane.b + ray.origin.z * plane.c + plane.d);\n\tfloat denominateur= plane.a * ray.direction.x + plane.b * ray.direction.y + plane.c * ray.direction.z;\n\tfloat t= numerateur/denominateur;\n\tif(t<0.0)\n\t\treturn 1e5;\n\telse \n\t\treturn t;\n}\n\nvec3 collisionPoint(ray_t ray, float t){\n\treturn vec3(ray.origin.x + ray.direction.x*t, ray.origin.y + ray.direction.y*t, ray.origin.z + ray.direction.z*t);\n}\n\nvec3 illumination(light_t directional_light, ray_t ray, in surface_t surface, in light_t light, sphere_t sphere, plane_t plane, vec3 color, int type){\n\tvec3  firstColor, L, R, L_directional;\n\tL= light.position - surface.collisionpoint;\n\tfloat attenuation=fAttenuation(magnitude(L));\n\tL = normalize(L);\n\tR = reflectedVec(surface.normal, ray.direction);\n\tvec3 diffuse;\n\tfloat speculaire;\n\t\n\t\n\tray_t lumRay, transRay, refRay;\n\tlumRay.direction = L;\n\tlumRay.origin = surface.collisionpoint;\n\t\n\tL_directional= normalize(directional_light.position - surface.collisionpoint);\n\tfloat sourceDirectionnal = pow(dot(-L_directional, normalize(directional_light.direction)), 6.);\n\tvec3 ambiante;\n\tfloat intensiteAmbiante = 1.5;\n\t\n\tif(type==0){\n\t\t\n\t\tambiante.x = color.x * plane.ka * intensiteAmbiante;\n\t\tambiante.y = color.y * plane.ka * intensiteAmbiante;\n\t\tambiante.z = color.z * plane.ka * intensiteAmbiante;\n\t\t\n\t\tif(intersectSphere(lumRay, sphere)==1e5){\n\t\t\tdiffuse.x = color.x*dot(surface.normal, L);\n\t\t\tdiffuse.y = color.y*dot(surface.normal, L);\n\t\t\tdiffuse.z = color.z*dot(surface.normal, L);\n\t\t\t\n\t\t\tspeculaire =  pow(dot(L, R), 10.)*0.4;\n\n\t\t}\t\t\n\t}\n\tif(type==1){\n\t\t\n\t\tambiante.x = color.x * plane.ka * intensiteAmbiante;\n\t\tambiante.y = color.y * plane.ka * intensiteAmbiante;\n\t\tambiante.z = color.z * plane.ka * intensiteAmbiante;\n\t\t\n\t\tif(intersectPlane(lumRay, plane)==1e5){\n\t\t\tdiffuse.x = color.x*dot(surface.normal, L);\n\t\t\tdiffuse.y = color.y*dot(surface.normal, L);\n\t\t\tdiffuse.z = color.z*dot(surface.normal, L);\n\t\t\t\n\t\t\tspeculaire =  pow(dot(L, R), 10.)*0.4;\n\t\t\t\n\t\t}\n\t}\n\t\n\tfirstColor.x = ambiante.x + attenuation * light.intensity* sourceDirectionnal * (diffuse.x + speculaire);\n\tfirstColor.y = ambiante.y + attenuation * light.intensity* sourceDirectionnal * (diffuse.y + speculaire);\n\tfirstColor.z = ambiante.z + attenuation * light.intensity* sourceDirectionnal * (diffuse.z + speculaire);\n\n\treturn firstColor;\n}\n\n\n\n\nvec3 sendRay(inout surface_t surface, ray_t ray, inout sphere_t sphere, plane_t plane, light_t light, light_t directional_light){\n\tfloat max_distance =100.;\n\t\n\tvec3 normal;\n\t\n\tfloat distance_from_origin_plane= intersectPlane(ray, plane);\n\tfloat distance_from_origin_sphere = intersectSphere(ray, sphere);\n\n\tif( distance_from_origin_sphere < distance_from_origin_plane )\n\t{\n\t\t\tsurface.identify=1.0;\n\t\t\tsurface.collisionpoint = collisionPoint(ray, distance_from_origin_sphere);\n\t\t\tsurface.normal=normalize(surface.collisionpoint - sphere.position);\n\t\t\n\t\t\tvec3 sphere_color = illumination(directional_light, ray, surface,light, sphere, plane, sphere.color, 1);\n\t\t\treturn sphere_color;\n\t\t\t\n\t}\n\telse if( distance_from_origin_plane < max_distance )\n\t{\n\t\t\tsurface.identify=0.0;\t\t\t\n\t\t\tnormal=vec3(plane.a, plane.b, plane.c);\t\t\t\n\t\t\tsurface.normal=normalize(normal);\n\t\t\tsurface.collisionpoint = collisionPoint(ray, distance_from_origin_plane);\n\t\t\t\n\t\t\tvec3 plane_color = illumination(directional_light, ray, surface,light, sphere, plane, plane.color, 0);\n\t\t\tsurface.color = plane.color;\n\t\t\treturn plane_color;\n\t}\n\telse\n\t{\n\t\tsurface.identify = -1.;\n\t\tvec3 L = reflectedVec(surface.normal, ray.direction);\n\t\treturn vec3(0.1, 0.01, 0.9);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat max_distance=100.0;\n\tvec2 screen_coordonate = fragCoord.xy / iResolution.xy;\n\tvec2 screen_coordonate_centered = 2.0 * screen_coordonate -1.0;\n\tsurface_t surface;\n\t\t\n\tray_t primary_ray;\n\tprimary_ray.origin =vec3(0.0, 0.0, mix( 3.0, 5.0, 0.5 *sin(iTime)+0.5));\n\tprimary_ray.direction =normalize(vec3(screen_coordonate_centered.x, screen_coordonate_centered.y * iResolution.y/iResolution.x, -1));\n\t\n\tlight_t light;\n\tlight.intensity=2.;\n\tlight.position = vec3(0., 10., 0.);\n\t\n\tlight_t directional_light;\n\tdirectional_light.intensity=.9;\n\tdirectional_light.direction = vec3(0., -1., 0.);\n\tdirectional_light.position = vec3(0., 10., 0.);\n\t\n\tsphere_t sphere;\n\tsphere.position =vec3(0.0,2.0,-5.0);\n\tsphere.radius=2.0;\n\tsphere.color = vec3(0., 0.9, 0.);\n\tsphere.ka =0.6;\n\t\n\tplane_t plane;\n\tplane.a=0.0;\n\tplane.b=0.9;\n\tplane.c=0.04;\n\tplane.d=0.8;\n\tplane.color = vec3(0.9, 0., 0.);\n\tplane.ka = 0.5;\t\n\n\tfragColor = vec4(sendRay(surface, primary_ray, sphere, plane, light,  directional_light), 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 399, 426, 426, 463], [465, 465, 489, 489, 534], [537, 537, 565, 565, 648], [650, 650, 691, 691, 755], [757, 757, 817, 817, 1630], [1632, 1632, 1697, 1697, 1988], [1990, 1990, 2030, 2030, 2148], [2150, 2150, 2300, 2300, 4063], [4068, 4068, 4197, 4197, 5296], [5298, 5298, 5354, 5354, 6349]], "test": "error"}
{"id": "MslXD8", "name": "Gravity Marching", "author": "paniq", "description": "Snapping points on a grid to the surface of a distance field, then applying binary marching cube to the resulting dual grid", "tags": ["mattdamon"], "likes": 23, "viewed": 1470, "published": "Public API", "date": "1400396031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// marching cube on dual grid visualization\n// -- @paniq\n\n#define GRIDRES 10\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    vec2 position;\n    float scale;\n    float shape;\n    float line_width;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n// save current source color, stroke width and starting\n// point from active context.\nContext save();\n// restore source color, stroke width and starting point\n// to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\n\nvoid paint();\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n    \nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    ScreenH = min(iResolution.x,iResolution.y);\n    AA = ScreenH*0.4;\n    AAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n     position = (uv*2.0-1.0)*aspect;\n    _stack = Context(\n        position, 1.0,\n        DEFAULT_SHAPE_V,\n        1.0,\n        vec2(AA,0.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    float shape = _stack.shape;\n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = position;\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(position,1.0)).xy;\n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(_stack.position,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid add(float d) {\n    _stack.shape = min(_stack.shape, d / _stack.scale);\n}\n\nvoid new_path() {\n    _stack.shape = DEFAULT_SHAPE_V;\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape * 6.0, \n            1.0, (_stack.shape>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(AA, 0.0);\n        return;\n    }\n    float a = 1.0 / max(AAINV, b);\n    _stack.blur = vec2(\n        a,\n        0.0); // 0 = blur ends at outline, 1 = blur starts at outline\n}\n\nvoid fill_preserve() {\n    float w = clamp(-_stack.shape*AA, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nvoid stroke_preserve() {\n    float w = abs(_stack.shape)- _stack.line_width/_stack.scale;\n    vec2 blur = _stack.blur;// / _stack.scale;\n    w = clamp(-w*blur.x + blur.y, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o = o - _stack.position + s;\n    vec2 d = abs(o) - s;\n    add(min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    add(length(_stack.position - p) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec2 pa = _stack.position - _stack.last_pt;\n    vec2 ba = p - _stack.last_pt;\n    float h = clamp(dot(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add(length(pa - ba*h));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from \"Random-access rendering of general vector graphics\"\n// by Nehab and Hoppe\n// only quadratic, not cubic\nvoid curve_to(vec2 b1, vec2 b2)\n{\n    vec2 b0 = _stack.last_pt - _stack.position;\n\t_stack.last_pt = b2;\n    b1 -= _stack.position;\n    b2 -= _stack.position;\n    float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n    float f=b*d-a*a;\n    vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n    vec2 gf=2.0*(b*d21+d*d10+a*d20);\n    gf=vec2(gf.y,-gf.x);\n    vec2 pp=-f*gf/dot(gf,gf);\n    vec2 d0p=b0-pp;\n    float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n    float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0);\n    add(length(mix(mix(b0,b1,t),mix(b1,b2,t),t)));\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    fragColor = vec4(_color.xyz, 1.0);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n     ms = ((iMouse.xy/iResolution.xy)*2.0-1.0) * aspect;\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n//////////////////////////////////////////////////////////\n\nfloat box(vec3 p, vec3 size) {\n\tvec3 d = abs(p) - size;\n    \n\tvec3 dm = max(d, 0.0);\n    \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(dm);\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat plane(vec3 p, vec4 n) {\n\treturn dot(p,n.xyz) - n.w;\n}\n\n// c must be normalized\nfloat cone(vec3 p, vec2 a, float l) {\n    return max(max(a.x*length(p.xy)+a.y*p.z, p.z), abs(p.z)-l);\n}\n\nvec2 ms;\n\nvec3 rotate(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(\n\t\tp.x*ca - p.z*sa,\n\t\t0.0,\n\t\tp.x*sa + p.z*ca\n\t);\n}\n\nfloat map(vec3 p) {\n\tp.xz -= ms;\n\t\n\tfloat w = plane(p, vec4(0.0,0.0,1.0,-0.6));\n\tfloat s = sphere(p - vec3(1.0,0.0,0.0), 0.5);\n\tfloat s2 = sphere(p - vec3(0.67,0.0,0.0), 0.2);\n\tfloat c = cone(p - vec3(-0.5,0.0,-0.3), normalize(vec2(1.0,0.5)), 0.5);\n\tfloat b = box(rotate(p - vec3(-0.5,0.0,0.2),iTime), vec3(0.3,1.0,0.1));\n\treturn min(b, min(c, min(max(s,-s2),w)));\n}\n\nvec3 grad(vec3 p) {\n\tvec2 d = vec2(1e-3, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + d.yxx) - map(p - d.yxx),\n\t\tmap(p + d.xyx) - map(p - d.xyx),\n\t\tmap(p + d.xxy) - map(p - d.xxy)));\n}\n\nvec2 grad2d(vec3 p) {\n\tvec2 d = vec2(0.0, 1e-3);\n\treturn normalize(vec2(\n\t\tmap(p + d.yxx) - map(p - d.yxx),\n\t\tmap(p + d.xxy) - map(p - d.xxy)));\n}\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\nfloat mlen(vec2 c) {\n\tc = abs(c);\n\treturn max(c.x, c.y);\n}\n\nfloat mlen(vec3 c) {\n\tc = abs(c);\n\treturn max(c.x, max(c.y, c.z));\n}\n\nbool gravitymarch(vec3 ro, float maxt, out vec3 p) {\n\tfloat precis = 0.001;\n\tfloat h = 1000.0;\n\tp = ro;\n\tfor(int i = 0; i < 5; i++) {\n\t\tif(abs(h) < precis || length(p - ro) > maxt) break;\n\t\th = map(p);\n\t\tvec2 n = grad2d(p);\n\t\tp.xz -= n*h;\n\t}\t\n\treturn (abs(h) < precis);\n}\n\nvoid paint() {\n\tif (iMouse.z < 0.0)\n\t\tms *= 0.0;\n\t\n\t// clear screen\n\t\n\tset_source_rgb(vec3(0.0,0.0,0.5));\n\tclear();\n\n\tset_line_width_px(1.3);\n\t\n\tfloat d = map(vec3(position.x,0.0,position.y));\n\t_stack.shape = d;\n\tset_source_rgba(hsl(0.6, 1.0, 0.7,0.5));\n\tfill();\n\t\n\tset_line_width_px(1.3);\n\tfor (int i = 0; i < 5; ++i) {\n\t\t_stack.shape = d-float(i)*0.05-mod(iTime*0.01,0.05);\n\t\tstroke();\n\t}\n\n\tset_source_rgb(vec3(1.0));\n\tset_line_width_px(1.3);\n\n\tfloat a = iTime;\n\t\n\tfloat grid = 1.0/float(GRIDRES);\n\t\n\tvec2 gp = position + grid*0.5;\n\tgp -= mod(gp, grid);\n\t\n\tfloat maxt = grid*0.5;\n\t\n\tvec4 kp[9];\n\tfor (int i = 0; i < 9; ++i) {\n\t\tkp[i] = vec4(0.0);\n\t}\n\t\n\tfor (int ky = 0; ky < 3; ++ky) {\n\t\tfor (int kx = 0; kx < 3; ++kx) {\n\t\t\tvec3 ro = vec3(gp.x, 0.0, gp.y);\n\t\t\tro.xz += vec2(kx-1,ky-1) * grid;\n\t\t\t\n\t\t\tvec3 p;\n\t\t\tif (!gravitymarch(ro, maxt, p)) {\n\t\t\t\tp = ro;\n\t\t\t\tif (map(p) > 0.001) continue;\n\t\t\t}\n\t\t\tkp[ky*3+kx] = vec4(p, 1.0);\n\t\t}\n\t}\n\t\n\tfor (int ky = 0; ky < 3; ++ky) {\n\t\tfor (int kx = 0; kx < 3; ++kx) {\n\t\t\tvec3 ro = vec3(gp.x, 0.0, gp.y);\n\t\t\tro.xz += vec2(kx-1,ky-1) * grid;\n\t\t\t\n\t\t\tset_source_rgba(vec4(1.0,1.0,1.0,0.3));\t\n\t\t\tcircle(ro.xz, 0.01);\n\t\t\tfill();\n\t\t\t\n\t\t\tvec4 k0 = kp[ky*3+kx];\n\t\t\tif (kx < 2 && ky < 2) {\n\t\t\t\t// cheapo marching cube\n\t\t\t\t// 2 8 > 1 3\n\t\t\t\t// 1 4 > 0 2\n\t\t\t\tvec4 k1 = kp[(ky+1)*3+kx];\n\t\t\t\tvec4 k2 = kp[ky*3+kx+1];\n\t\t\t\tvec4 k3 = kp[(ky+1)*3+kx+1];\n\t\t\t\tint w = int(k0.w) + int(k1.w)*2 + int(k2.w)*4 + int(k3.w)*8;\n\t\t\t\t\n\t\t\t\tset_line_width_px(1.6);\n\t\t\t\tset_source_rgb(vec3(1.0));\n\t\t\t\tif (w == 3) {\n\t\t\t\t\tmove_to(k0.xz); \n\t\t\t\t\tline_to(k1.xz);\n\t\t\t\t\tstroke();\n\t\t\t\t} else if (w == 5) {\n\t\t\t\t\tmove_to(k0.xz); \n\t\t\t\t\tline_to(k2.xz);\n\t\t\t\t\tstroke();\n\t\t\t\t} else if (w == 7) {\n\t\t\t\t\tmove_to(k1.xz); \n\t\t\t\t\tline_to(k2.xz);\n\t\t\t\t\tstroke();\n\t\t\t\t} else if (w == 10) {\n\t\t\t\t\tmove_to(k1.xz); \n\t\t\t\t\tline_to(k3.xz);\n\t\t\t\t\tstroke();\n\t\t\t\t} else if (w == 11) { // ?\n\t\t\t\t\tmove_to(k0.xz); \n\t\t\t\t\tline_to(k3.xz);\n\t\t\t\t\tstroke();\n\t\t\t\t} else if (w == 12) {\n\t\t\t\t\tmove_to(k2.xz); \n\t\t\t\t\tline_to(k3.xz);\n\t\t\t\t\tstroke();\n\t\t\t\t} else if (w == 13) {\n\t\t\t\t\tmove_to(k0.xz); \n\t\t\t\t\tline_to(k3.xz);\n\t\t\t\t\tstroke();\n\t\t\t\t} else if (w == 14) {\n\t\t\t\t\tmove_to(k1.xz); \n\t\t\t\t\tline_to(k2.xz);\n\t\t\t\t\tstroke();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (k0.w == 0.0) continue;\n\t\t\tvec3 p = k0.xyz;\n\t\t\t\n\t\t\tset_line_width_px(1.3);\n\t\t\t\n\t\t\tset_source_rgb(hsl(0.0, 1.0, 0.5));\n\t\t\t\n\t\t\tset_source_rgba(vec4(1.0,1.0,1.0,0.3));\t\n\t\t\tmove_to(ro.xz);\n\t\t\tline_to(p.xz);\n\t\t\tstroke();\n\t\t\t\n\t\t\tset_source_rgb(vec3(1.0));\t\n\t\t\tcircle(p.xz, 0.01);\n\t\t\tfill();\n\t\t\t\n\t\t\t// arrow\n\t\t\tvec2 n = grad2d(p);\n\t\t\tvec2 o = vec2(n.y, -n.x);\n\t\t\tset_source_rgba(vec4(1.0,1.0,1.0,0.7));\t\n\t\t\tarrow(p.xz, n*grid*0.5);\n\t\t\tstroke();\n\t\t}\n\t}\t\n\t\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3408, 3468, 3495, 3495, 3521], [3523, 3583, 3604, 3604, 3713], [3715, 3715, 3752, 3752, 3838], [3840, 3840, 3886, 3886, 3919], [3921, 4033, 4061, 4061, 4475], [4503, 4503, 4519, 4519, 4540], [4542, 4542, 4569, 4591, 4669], [4671, 4671, 4699, 4699, 4933], [4935, 4935, 4959, 4959, 5017], [5019, 5019, 5046, 5046, 5183], [5185, 5185, 5211, 5211, 5373], [5375, 5375, 5397, 5397, 5523], [5525, 5525, 5546, 5546, 5602], [5604, 5604, 5628, 5628, 5688], [5690, 5690, 5724, 5724, 5748], [5750, 5750, 5764, 5764, 5828], [5830, 5830, 5849, 5849, 5907], [5909, 5909, 5926, 5926, 5964], [5966, 5966, 5989, 5989, 6112], [6114, 6114, 6138, 6138, 6359], [6361, 6361, 6383, 6383, 6500], [6502, 6502, 6515, 6515, 6554], [6556, 6556, 6586, 6586, 6615], [6617, 6617, 6650, 6650, 6695], [6697, 6697, 6721, 6721, 6946], [6948, 6948, 6963, 6963, 7004], [7006, 7006, 7036, 7036, 7061], [7063, 7063, 7121, 7121, 7160], [7162, 7162, 7191, 7191, 7227], [7229, 7229, 7277, 7277, 7308], [7310, 7310, 7344, 7344, 7400], [7402, 7402, 7434, 7434, 7559], [7561, 7561, 7617, 7617, 7660], [7662, 7662, 7692, 7692, 7736], [7737, 7737, 7777, 7777, 7800], [7802, 7802, 7824, 7824, 7875], [7877, 7877, 7909, 7909, 7931], [7933, 7948, 7970, 7970, 8166], [8168, 8168, 8200, 8200, 8222], [8224, 8224, 8243, 8243, 8275], [8277, 8389, 8422, 8422, 8932], [8934, 8934, 8993, 8993, 9038], [9040, 9100, 9157, 9157, 9242], [9390, 9450, 9480, 9480, 9597], [9599, 9599, 9630, 9630, 9655], [9657, 9657, 9686, 9686, 9716], [9718, 9742, 9779, 9779, 9845], [9857, 9857, 9887, 9887, 9991], [9993, 9993, 10012, 10012, 10359], [10361, 10361, 10380, 10380, 10540], [10542, 10542, 10563, 10563, 10688], [10690, 10690, 10718, 10718, 10860], [10862, 10862, 10882, 10882, 10920], [10922, 10922, 10942, 10942, 10990], [10992, 10992, 11044, 11044, 11263], [11265, 11265, 11279, 11279, 13906]], "test": "error"}
{"id": "MslXWr", "name": "Quadratic Bezier", "author": "Trisomie21", "description": "Distance to Quadratic Bezier (Click to view clamped distances)", "tags": ["bezier", "distance"], "likes": 12, "viewed": 366, "published": "Public", "date": "1399587243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Quadratic bezier curve distance evaluation\n\nfloat length2(vec2 v) { return dot(v, v); }\n\nint SolveCubic(in float a, in float b, in float c, out float r[3])\n{\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tif(abs(p) < abs(q)*0.005) {\n\t\t\tif(q < 0.0) v = p / (3.0 * -pow(-q,1.0/3.0));\n\t\t\telse u = p / (3.0 * pow(q,1.0/3.0));\t\n\t\t}\t\n\t\tr[0] = offset + u + v;\t\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\treturn 3;\n}\n\nfloat Distance2ToQBSpline(in vec2 P0, in vec2 P1, in vec2 P2, in vec2 p)\n{\n\tvec2  sb = (P1 - P0) * 2.0;\n\tvec2  sc = P0 - P1 - P1 + P2;\n\tvec2  sd = P1 - P0;\n\tfloat sA = 1.0 / dot(sc, sc);\n\tfloat sB = 3.0 * dot(sd, sc);\n\tfloat sC = 2.0 * dot(sd, sd);\n\t\n\tvec2  D = P0 - p;\n\n\tfloat a = sA;\n\tfloat b = sB;\n\tfloat c = sC + dot(D, sc);\n\tfloat d = dot(D, sd);\n\n    float res[3];\n\tint n = SolveCubic(b*a, c*a, d*a, res);\n\n\tfloat t = clamp(res[0],0.0, 1.0);\n\tvec2 pos = P0 + (sb + sc*t)*t;\n\t\n\tfloat dis2 = length2(pos - p);\n\t\n\tif(n>1) {\n\t\tt = clamp(res[1],0.0, 1.0);\n\t\tpos = P0 + (sb + sc*t)*t;\n\t\tdis2 = min(dis2, length2(pos - p));\n\t\t\n\t\tt = clamp(res[2],0.0, 1.0);\n\t\tpos = P0 + (sb + sc*t)*t;\n\t\tdis2 = min(dis2, length2(pos - p));\t    \n\t}\n\t\n\treturn dis2;\n}\n\n// Put the function to the test, draw a bunch of connected curves -------------------\n\n\n\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\n// motion of control points and tangents.\nvec2 P(float i) {\n    float t = iTime*.5;\n\tvec4 c = hash4(i);\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int segCount = 8;\n\tvec2 p[2 * segCount + 1];\n\t\n\tfloat j =0.;\n\tfor (int i = 0; i <= segCount*2; ++i) {\n\t\tp[i] = P(j)*iResolution.xy*.25 + iResolution.xy*.5;\n\t\tj += 1.;\n\t}\n\t\n\tfloat d0 = 1e10; // Distance(squared) to spline \n\tfloat d1 = 1e10; // Distance(squared) to control point (segment start/end)\n\tfor (int i = 0; i < segCount; ++i) {\n\t\tif(i > 0) p[2*i+1] = 2.0 * p[2*i] - p[2*i - 1];\n\t\td0 = min(d0, Distance2ToQBSpline(p[2*i], p[2*i + 1], p[2*i + 2], fragCoord.xy));\n\t\td1 = min(d1, length2(p[2*i] - fragCoord.xy));\n\t}\n\td1 = min(d1, length2(p[segCount*2] - fragCoord.xy));\n\n\td0 = sqrt(d0);\n\td1 = sqrt(d1);\n\n\tfloat c = mix(.5, .8, clamp(d0-6., 0., 1.));\n\tfragColor = mix(vec4(c), vec4(0,1,0,1),1.- clamp(d1-5., 0., 1.));\n\t\n\tif(iMouse.z > 0.) {\n\t\td0 /= iResolution.x*.2;\n\t\td0 = 1.-d0;\n\t\tfragColor = vec4(d0); \n\t}\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 70, 70, 90], [92, 92, 160, 160, 882], [884, 884, 958, 958, 1631], [1633, 1722, 1744, 1744, 1788], [1789, 1789, 1811, 1811, 1868], [1870, 1912, 1929, 1929, 2087], [2089, 2089, 2146, 2146, 2968]], "test": "error"}
{"id": "MssSWH", "name": "Interval Arithmetic: Quadtree", "author": "paniq", "description": "Traversing an implicit function octree-style using interval arithmetic", "tags": ["mattdamon"], "likes": 28, "viewed": 1685, "published": "Public API", "date": "1400495071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// IA quadtree visualization\n// -- @paniq\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    vec2 position;\n    float scale;\n    float shape;\n    float line_width;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n// save current source color, stroke width and starting\n// point from active context.\nContext save();\n// restore source color, stroke width and starting point\n// to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\n\nvoid paint();\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n    \nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    ScreenH = min(iResolution.x,iResolution.y);\n    AA = ScreenH*0.4;\n    AAINV = 1.0 / AA;\n\n    uv = fragCoord.xy / iResolution.xy;\n    \n     position = (uv*2.0-1.0)*aspect;\n    _stack = Context(\n        position, 1.0,\n        DEFAULT_SHAPE_V,\n        1.0,\n        vec2(AA,0.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    float shape = _stack.shape;\n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = position;\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(position,1.0)).xy;\n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(_stack.position,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid add(float d) {\n    _stack.shape = min(_stack.shape, d / _stack.scale);\n}\n\nvoid new_path() {\n    _stack.shape = DEFAULT_SHAPE_V;\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape * 6.0, \n            1.0, (_stack.shape>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(AA, 0.0);\n        return;\n    }\n    float a = 1.0 / max(AAINV, b);\n    _stack.blur = vec2(\n        a,\n        0.0); // 0 = blur ends at outline, 1 = blur starts at outline\n}\n\nvoid fill_preserve() {\n    float w = clamp(-_stack.shape*AA, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nvoid stroke_preserve() {\n    float w = abs(_stack.shape)- _stack.line_width/_stack.scale;\n    vec2 blur = _stack.blur;// / _stack.scale;\n    w = clamp(-w*blur.x + blur.y, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o = o - _stack.position + s;\n    vec2 d = abs(o) - s;\n    add(min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    add(length(_stack.position - p) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec2 pa = _stack.position - _stack.last_pt;\n    vec2 ba = p - _stack.last_pt;\n    float h = clamp(dot(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add(length(pa - ba*h));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from \"Random-access rendering of general vector graphics\"\n// by Nehab and Hoppe\n// only quadratic, not cubic\nvoid curve_to(vec2 b1, vec2 b2)\n{\n    vec2 b0 = _stack.last_pt - _stack.position;\n\t_stack.last_pt = b2;\n    b1 -= _stack.position;\n    b2 -= _stack.position;\n    float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n    float f=b*d-a*a;\n    vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n    vec2 gf=2.0*(b*d21+d*d10+a*d20);\n    gf=vec2(gf.y,-gf.x);\n    vec2 pp=-f*gf/dot(gf,gf);\n    vec2 d0p=b0-pp;\n    float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n    float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0);\n    add(length(mix(mix(b0,b1,t),mix(b1,b2,t),t)));\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    fragColor = vec4(_color.xyz, 1.0);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n//////////////////////////////////////////////////////////\n\n#define iafloat vec2\n#define iavec3 mat3 // in glsl: mat3x2\n\niavec3 iavec3_new(iafloat x, iafloat y, iafloat z) {\n\treturn iavec3(x, 0.0, y, 0.0, z, 0.0);\n}\n\niavec3 iavec3_new(float x, float y, float z) {\n\treturn iavec3(x, x, 0.0, y, y, 0.0, z, z, 0.0);\n}\n\niavec3 iavec3_new(vec3 p) {\n\treturn iavec3(p.xx, 0.0, p.yy, 0.0, p.zz, 0.0);\n}\n\niavec3 iavec3_new(vec3 p0, vec3 p1) {\n\treturn iavec3(p0.x, p1.x, 0.0, p0.y, p1.y, 0.0, p0.z, p1.z, 0.0);\n}\n\niafloat imin(iafloat a, iafloat b) {\n\treturn iafloat(min(a.x,b.x),min(a.y,b.y));\n}\n\niafloat imax(iafloat a, iafloat b) {\n\treturn iafloat(max(a.x,b.x),max(a.y,b.y));\n}\n\niafloat iadd(iafloat a, iafloat b) {\n\treturn a + b;\n}\n\niavec3 iadd(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy + b[0].xy,\n\t\ta[1].xy + b[1].xy,\n\t\ta[2].xy + b[2].xy);\n}\n\niavec3 iadd(vec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta.xx + b[0].xy,\n\t\ta.yy + b[1].xy,\n\t\ta.zz + b[2].xy);\n}\n\niafloat isub(iafloat a, iafloat b) {\n\treturn a - b.yx;\n}\n\niavec3 isub(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy - b[0].yx,\n\t\ta[1].xy - b[1].yx,\n\t\ta[2].xy - b[2].yx);\n}\n\niavec3 isub(iavec3 a, vec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy - b.xx,\n\t\ta[1].xy - b.yy,\n\t\ta[2].xy - b.zz);\n}\n\niafloat imul(iafloat a, iafloat b) {\n\tvec4 f = vec4(\n\t\ta.xxyy * b.xyxy\n\t);\t\n\treturn iafloat(\n\t\tmin(min(f[0],f[1]),min(f[2],f[3])),\n\t\tmax(max(f[0],f[1]),max(f[2],f[3])));\n}\n\niafloat imul(float a, iafloat b) {\n\tvec2 f = vec2(a*b);\t\n\treturn iafloat(\n\t\tmin(f[0],f[1]),\n\t\tmax(f[0],f[1]));\n}\n\niavec3 imul(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a[0].xy, b[0].xy),\n\t\timul(a[1].xy, b[1].xy),\n\t\timul(a[2].xy, b[2].xy)\n\t);\n}\n\niavec3 imul(float a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a, b[0].xy),\n\t\timul(a, b[1].xy),\n\t\timul(a, b[2].xy)\n\t);\n}\n\niavec3 imul(vec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a.xx, b[0].xy),\n\t\timul(a.yy, b[1].xy),\n\t\timul(a.zz, b[2].xy)\n\t);\n}\n\niavec3 imul(vec3 a, iafloat b) {\n\treturn iavec3_new(\n\t\timul(a.x, b),\n\t\timul(a.y, b),\n\t\timul(a.z, b)\n\t);\n}\n\n\niafloat idiv(iafloat a, iafloat b) {\n\tvec4 f = vec4(\n\t\ta.x/b, a.y/b\n\t);\n\treturn iafloat(\n\t\tmin(min(f[0],f[1]),min(f[2],f[3])),\n\t\tmax(max(f[0],f[1]),max(f[2],f[3])));\n}\n\niavec3 idiv(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\tidiv(a[0].xy, b[0].xy),\n\t\tidiv(a[1].xy, b[1].xy),\n\t\tidiv(a[2].xy, b[2].xy)\n\t);\n}\n\niafloat isqrt(iafloat a) {\n\treturn iafloat(sqrt(a.x),sqrt(a.y));\n}\n\n// for even powers in general,\n// for odd powers, it's just iafloat(a*a)\niafloat ipow2(iafloat a) {\t\n\treturn (a.x>=0.0)?iafloat(a*a):(a.y<0.0)?iafloat((a*a).yx):iafloat(0.0,max(a.x*a.x,a.y*a.y));\n}\n\niavec3 ipow2(iavec3 v) {\n\treturn iavec3_new(\n\t\tipow2(v[0].xy),\n\t\tipow2(v[1].xy),\n\t\tipow2(v[2].xy));\n}\n\niafloat ilensq(iavec3 a) {\n\tiavec3 c = ipow2(a);\n\treturn c[0].xy + c[1].xy + c[2].xy;\n}\n\niafloat ilength(iavec3 a) {\n\tiavec3 c = ipow2(a);\n\treturn isqrt(c[0].xy + c[1].xy + c[2].xy);\n}\n\niafloat idot(iavec3 a, iavec3 b) {\n\tiavec3 c = imul(a,b);\n\treturn c[0].xy + c[1].xy + c[2].xy;\n}\n\nbool icontains(iafloat a, float v) {\n\treturn ((v >= a.x) && (v < a.y));\n}\n\n//////////////////////////////////////////////////////////\n\niafloat sphere(iavec3 p, float r) {\n\t// x^2 + y^2 + z^2 - r^2\n\treturn isub(ilensq(p),iafloat(r*r));\n}\n\niafloat teardrop(iavec3 p) {\n\t// -0.5x^5 - 0.5x^4 + y^2 + z^2\n\t\n\tiafloat x2 = ipow2(p[2].xy);\n\tiafloat y2 = ipow2(p[1].xy);\n\tiafloat z2 = ipow2(p[0].xy);\n\t\n\tiafloat x4 = ipow2(x2);\n\tiafloat x5 = imul(p[2].xy,x4);\n\t\n\treturn iadd(iadd(isub(imul(-0.5,x5), imul(0.5,x4)), y2), z2);\t\n}\n\n\niafloat map(iavec3 p) {\n    float as = sin(iTime)*0.5+0.5;\n    \n\t// scaling needs no distance fix\n\tiafloat drop = teardrop(imul(2.0,isub(p, vec3(1.0,0.0,0.0))));\n\tiafloat sph1 = sphere(isub(p, vec3(1.0,0.0,0.0)), 0.8);\n\t// anisotropic scaling is no problem\n\tiafloat sph2 = sphere(imul(\n\t\tvec3(3.0,1.0,1.0),\n\t\tisub(p, vec3(0.0,0.0,-0.9+0.2*as))), 0.5);\n\t\n\treturn imin(imax(drop,sph1), sph2);\n}\n\nvec2 grad2d(vec3 p) {\n\tvec2 d = vec2(0.0, 1e-3);\n\t\n\t// could do this with only two queries if only the sign\n\t// could be recovered.\n\tvec2 hx = map(iavec3_new(p + d.yxx)) - map(iavec3_new(p - d.yxx));\n\tvec2 hy = map(iavec3_new(p + d.xxy)) - map(iavec3_new(p - d.xxy));\n\t\n\treturn normalize(vec2(\n\t\thx.x, hy.x));\n}\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\niafloat trace_paint(vec3 ro, vec3 rd, iafloat t) {\n\tiavec3 r = iadd(ro, imul(rd, t));\n\t\n\tiafloat h = map(r);\n\tif (icontains(h, 0.0))\n\t\tset_source_rgba(vec4(0.0,1.0,0.0,0.5));\n\telse\n\t\tset_source_rgba(vec4(1.0,0.0,0.0,0.5));\n\t\n\tmove_to(ro.xz+rd.xz*t.x);\n\tline_to(ro.xz+rd.xz*t.y);\n\tstroke();\n\t\n\trectangle(r[0].x, r[2].x, r[0].y - r[0].x, r[2].y - r[2].x);\n\tstroke();\n\t\n\treturn h;\n}\n\nvoid paint() {\n\tvec2 ms = ((iMouse.xy/iResolution.xy)*2.0-1.0) * aspect;\n\t\n\t// clear screen\n\t\n\tiafloat d = map(iavec3_new(\n\t\tvec3(position.x,0.0,position.y)));\n\t\n\t\n\tset_source_rgb(\n\t\t(d.x<=0.0)?hsl(0.6, 1.0, 0.7):vec3(0.0,0.0,0.5));\n\tclear();\n\n\tset_source_rgba(hsl(0.6, 1.0, 0.7, 0.3));\n\tset_line_width_px(3.0);\n\tfor (int i = 0; i < 8; ++i) {\n\t\t_stack.shape = d.x-float(i)*0.2;\n\t\tstroke();\n\t}\n\n\tset_source_rgb(vec3(1.0));\n\tset_line_width_px(1.0);\n\tnew_path();\n\n\tfloat D = 2.0;\n\tvec3 p0 = vec3(-D,0.0,-D);\n\tvec3 p1 = vec3(D,0.0,D);\n\t\n\t#define MAX_STEP 12\n\tfor (int i = 0; i < MAX_STEP; ++i) {\n\t\tiafloat t = map(iavec3_new(p0,p1));\n\t\tbool leaf = false;\n        if (icontains(t,0.0)) {\n\t\t\tif (i == MAX_STEP-1) {\n\t\t\t\tset_source_rgb(vec3(0.0,1.0,0.0));\n\t\t\t\tleaf = true;\n            }\n\t\t} else if (max(t.x,t.y) <= 0.0) {\n\t\t\tset_source_rgb(vec3(1.0,1.0,1.0));\n\t\t\tleaf = true;\n        } else {\n\t\t\tset_source_rgb(vec3(0.5));\n            leaf = true;\n        }\n        \n        if (leaf) {\n            rectangle(p0.xz, p1.xz - p0.xz);\n            stroke();\n            break;\n        }\n\t\t\n        vec3 pc = (p0+p1)*0.5;\n        if (position.x > pc.x)\n            p0.x = pc.x;\n        else\n            p1.x = pc.x;\n        if (position.y > pc.z)\n            p0.z = pc.z;\n        else\n            p1.z = pc.z;\n\n\t}\n\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3373, 3433, 3460, 3460, 3486], [3488, 3548, 3569, 3569, 3678], [3680, 3680, 3717, 3717, 3803], [3805, 3805, 3851, 3851, 3884], [3886, 3998, 4026, 4026, 4436], [4464, 4464, 4480, 4480, 4501], [4503, 4503, 4530, 4552, 4630], [4632, 4632, 4660, 4660, 4894], [4896, 4896, 4920, 4920, 4978], [4980, 4980, 5007, 5007, 5144], [5146, 5146, 5172, 5172, 5334], [5336, 5336, 5358, 5358, 5484], [5486, 5486, 5507, 5507, 5563], [5565, 5565, 5589, 5589, 5649], [5651, 5651, 5685, 5685, 5709], [5711, 5711, 5725, 5725, 5789], [5791, 5791, 5810, 5810, 5868], [5870, 5870, 5887, 5887, 5925], [5927, 5927, 5950, 5950, 6073], [6075, 6075, 6099, 6099, 6320], [6322, 6322, 6344, 6344, 6461], [6463, 6463, 6476, 6476, 6515], [6517, 6517, 6547, 6547, 6576], [6578, 6578, 6611, 6611, 6656], [6658, 6658, 6682, 6682, 6907], [6909, 6909, 6924, 6924, 6965], [6967, 6967, 6997, 6997, 7022], [7024, 7024, 7082, 7082, 7121], [7123, 7123, 7152, 7152, 7188], [7190, 7190, 7238, 7238, 7269], [7271, 7271, 7305, 7305, 7361], [7363, 7363, 7395, 7395, 7520], [7522, 7522, 7578, 7578, 7621], [7623, 7623, 7653, 7653, 7697], [7698, 7698, 7738, 7738, 7761], [7763, 7763, 7785, 7785, 7836], [7838, 7838, 7870, 7870, 7892], [7894, 7909, 7931, 7931, 8127], [8129, 8129, 8161, 8161, 8183], [8185, 8185, 8204, 8204, 8236], [8238, 8350, 8383, 8383, 8893], [8895, 8895, 8954, 8954, 8999], [9001, 9061, 9118, 9118, 9203], [9294, 9415, 9467, 9467, 9509], [9511, 9511, 9557, 9557, 9608], [9610, 9610, 9637, 9637, 9688], [9690, 9690, 9727, 9727, 9796], [9798, 9798, 9834, 9834, 9880], [9882, 9882, 9918, 9918, 9964], [9966, 9966, 10002, 10002, 10019], [10021, 10021, 10054, 10054, 10140], [10142, 10142, 10173, 10173, 10250], [10252, 10252, 10288, 10288, 10308], [10310, 10310, 10343, 10343, 10429], [10431, 10431, 10462, 10462, 10539], [10541, 10541, 10577, 10577, 10712], [10714, 10714, 10748, 10748, 10826], [10828, 10828, 10861, 10861, 10964], [10966, 10966, 10998, 10998, 11083], [11085, 11085, 11116, 11116, 11210], [11212, 11212, 11244, 11244, 11317], [11320, 11320, 11356, 11356, 11487], [11489, 11489, 11522, 11522, 11625], [11627, 11627, 11653, 11653, 11693], [11695, 11768, 11794, 11794, 11892], [11894, 11894, 11918, 11918, 11995], [11997, 11997, 12023, 12023, 12084], [12086, 12086, 12113, 12113, 12181], [12183, 12183, 12217, 12217, 12279], [12281, 12281, 12317, 12317, 12354], [12356, 12416, 12451, 12477, 12517], [12519, 12519, 12547, 12580, 12799], [12802, 12802, 12825, 12825, 13194], [13196, 13196, 13217, 13217, 13507], [13509, 13509, 13537, 13537, 13679], [13681, 13681, 13731, 13731, 14060], [14062, 14062, 14076, 14076, 15367]], "test": "error"}
{"id": "MssXDn", "name": "Camera Obsession #1", "author": "WAHa_06x36", "description": "Playing around with camera calculations of varying levels of accuracy. Circles of confusion and totally fake diffraction stars for point lights.", "tags": ["bokeh", "camera", "particles", "stars", "rainbow"], "likes": 112, "viewed": 8050, "published": "Public API", "date": "1399505447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NumberOfParticles 64\n#define Pi 3.141592\n\nvec3 palette(float x)\n{\n\treturn vec3(\n\t\tsin(x*2.0*Pi)+1.5,\n\t\tsin((x+1.0/3.0)*2.0*Pi)+1.5,\n\t\tsin((x+2.0/3.0)*2.0*Pi)+1.5\n\t)/2.5;\n}\n\nfloat starline(vec2 relpos,float confradius,float filmsize)\n{\n\tif(abs(relpos.y)>confradius) return 0.0;\n\tfloat y=relpos.y/confradius;\n\tfloat d=abs(relpos.x/filmsize);\n\treturn sqrt(1.0-y*y)/(0.0001+d*d)*0.00001;\n}\n\nfloat star(vec2 relpos,float confradius,float filmsize)\n{\n\tvec2 rotpos=mat2(cos(Pi/3.0),-sin(Pi/3.0),sin(Pi/3.0),cos(Pi/3.0))*relpos;\n\tvec2 rotpos2=mat2(cos(Pi/3.0),sin(Pi/3.0),-sin(Pi/3.0),cos(Pi/3.0))*relpos;\n\treturn starline(relpos,confradius,filmsize)+\n\t\tstarline(rotpos,confradius,filmsize)+\n\t\tstarline(rotpos2,confradius,filmsize);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenpos=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n\tfloat focaldistance=0.5+sin(iTime*0.05)*0.013;\n\tfloat focallength=0.100;\n\tfloat filmsize=0.036;\n\tfloat minconf=filmsize/1000.0;\n\tfloat lensradius=focallength/1.0;\n\n\tfloat filmdistance=1.0/(1.0/focallength-1.0/focaldistance);\n\t\n\tvec3 c=vec3(0.0);\n\tfor(int i=0;i<NumberOfParticles;i++)\n\t{\n\t\tfloat t=float(i)/float(NumberOfParticles);\n\t\tfloat a=t*2.0*Pi+iTime*0.1;\n\n\t\tvec3 pos=vec3(sin(a)+2.0*sin(2.0*a),cos(a)-2.0*cos(2.0*a),-sin(3.0*a))*0.01;\n\n\t\tfloat a1=0.1*iTime;\n\t\tpos.xz*=mat2(cos(a1),-sin(a1),sin(a1),cos(a1));\n\t\t//float a2=0.1;\n\t\t//pos.yz*=mat2(cos(a2),-sin(a2),sin(a2),cos(a2));\n\n\t\tpos.z+=0.5;\n\t\t\n\t\tfloat intensity=0.0000002;\n\n\t\tvec2 filmpos=pos.xy/pos.z*filmdistance;\n\t\tfloat confradius=lensradius*filmdistance*abs(1.0/focaldistance-1.0/pos.z)+minconf;\n\n\t\tfloat diffusedintensity=intensity/(confradius*confradius);\n\n\t\tvec3 colour=palette(t);\n\n\t\tvec2 relpos=filmpos-screenpos/2.0*filmsize;\n\t\tif(length(relpos)<confradius) c+=colour*diffusedintensity;\n\n\t\tc+=colour*diffusedintensity*star(relpos,confradius,filmsize);\n\t}\n\n\tfragColor=vec4(pow(c,vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssXDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 73, 73, 179], [181, 181, 242, 242, 393], [395, 395, 452, 452, 734], [736, 736, 793, 793, 1950]], "test": "valid"}
{"id": "MssXWH", "name": "Fmorph-v1", "author": "entropynine", "description": "fractal, morph, living fractal", "tags": ["fractal", "morph", "livingfractal"], "likes": 14, "viewed": 252, "published": "Public", "date": "1400703149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.fractalforums.com/movies-showcase-%28rate-my-movie%29/very-rare-deep-sea-fractal-creature/\n\nconst int Iterations=25;\nconst float Scale=1.27;\nconst vec3 Julia=vec3(-2.,-1.5,-.5);\nconst vec3 RotVector=vec3(0.5,-0.05,-0.5);\nconst float RotAngle=40.;\nconst float Speed=1.3;\nconst float Amplitude=0.45;\nconst float detail=.025;\nconst vec3 lightdir=-vec3(0.5,1.,0.5);\n\nmat2 rot;\n\nfloat de(vec3 p); \n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = de(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat light(in vec3 p, in vec3 dir) {\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat sh=softshadow(p,-ldir,1.,20.);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\treturn diff*sh+pow(spec,30.)*.5*sh+.15*max(0.,dot(normalize(dir),-n));\t\n\t\t}\n\nfloat raymarch(in vec3 from, in vec3 dir)\n{\n\tfloat st,d=1.0,col,totdist=st=0.;\n\tvec3 p;\n\tfor (int i=0; i<70; i++) {\n\tif (d>detail && totdist<50.)\n\t{\n\t\tp=from+totdist*dir;\n\t\td=de(p);\n\t\ttotdist+=d;\n\t}\n\t}\n\tfloat backg=.5;\n\tif (d<detail) {\n\t\tcol=light(p-detail*dir, dir); \n\t} else { \n\t\tcol=backg;\n\t}\n\tcol = mix(col, backg, 1.0-exp(-.000025*pow(totdist,3.5)));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t=iTime*.3;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,-.7,-20.);\n\tvec3 dir=normalize(vec3(uv*.7,1.));\n\trot=mat2(cos(-.5),sin(-.5),-sin(-.5),cos(-.5));\n\tdir.yz=dir.yz*rot;\n\tfrom.yz=from.yz*rot;\n\n\tfloat col=raymarch(from,dir); \n\tfragColor = vec4(col);\n}\n\n\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\nfloat de(vec3 p) {\n\tp=p.zxy;\n\tfloat a=1.5+sin(iTime*.5)*.5;\n\tp.xy=p.xy*mat2(cos(a),sin(a),-sin(a),cos(a));\n\tp.x*=.75;\n\tfloat time=iTime*Speed;\n\tvec3 ani;\n\tani=vec3(sin(time),sin(time),cos(time))*Amplitude;\n\tp+=sin(p*3.+time*6.)*.04;\n\tmat3 rot = rotationMatrix3(normalize(RotVector+ani), RotAngle+sin(time)*10.);\n\tvec3 pp=p;\n\tfloat l;\n\tfor (int i=0; i<Iterations; i++) {\n\t\tp.xy=abs(p.xy);\n\t\tp=p*Scale+Julia;\n\t\tp*=rot;\n\t\tl=length(p);\n\t}\n\treturn l*pow(Scale, -float(Iterations))*.9;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 408, 429, 429, 583], [585, 585, 650, 650, 889], [891, 891, 928, 928, 1188], [1190, 1190, 1233, 1233, 1560], [1562, 1562, 1619, 1619, 1939], [1942, 1942, 1986, 1986, 2354], [2357, 2357, 2375, 2375, 2838]], "test": "error"}
{"id": "MsXSDH", "name": "music box", "author": "pixelbeast", "description": "mandelbox 3d fft distortions\n- updated version here: https://www.shadertoy.com/view/4s33Rj", "tags": ["mandelboxfft2d"], "likes": 7, "viewed": 481, "published": "Public", "date": "1400041854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Iain Melvin, 2015\n// fft distortions of mandlebox 3d, colour\n// with help from:\n// https://www.shadertoy.com/view/XsB3Rm  // Original Raymarch tutorial (iq)\n// https://www.shadertoy.com/view/ldSGRK  // for mandlebox formula (klems)\n// Raymarch tutorial: - iq/2013\n\n\nfloat mandel3D(vec3 z,float fft){\n  const float scale=3.5; //2.0; // -1.5\n  const float r=0.5; \n  const float f=1.125;\n  vec3 offset = z;\n  const int niter = 13;\n  float dr = 1.0;\n  for (int i=0;i<niter;i++){\n\t//fold\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\n\t//warp\n\tfloat l = length(z);\n\tif (l<r){\n\t  z/=r*r;\n\t}else if (l<1.0){\n\t  z/=l*l;\n\t}\n\tz*=scale;\n\tdr = dr * abs(scale) + 1.0;\n\t// scale by fft\n\tfloat fft_scale = 1.0-(fft*0.54);\n\tz*=fft_scale;\n\t//dr = dr * fft_scale; // I think there is something to do here\n\tz+=offset;\n  }\n  float zr = length(z);\n  return zr / abs(dr);\n}\n\nvec2 map( in vec3 pos ) {\n    float d = length(pos);\n    float fft = 0.8*texture(iChannel0, vec2((d/32.0),0.3) )[0];\t\n\treturn vec2(mandel3D(pos*1.5,fft),fft);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ){\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<120; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x; //dist to solid\n\t    m = res.y; //fft\n    }\n    if (t>maxd) { t=-0.5; m=0.0; }\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos ){\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// iq's smooth hsv to rgb\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,20.0);\n    float t = res.x; // dist to func\n\tfloat m = res.y; // fft intense at collision\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n\n\tcol = hsv2rgb(vec3(m*3.0,1.0,1.0)); // hue sat lum\n    \n    float ao = 1.0;\n\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\tfloat sh = 1.0;\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n    brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n    brdf += 2.20*dif*vec3(1.00,0.90,0.70);\n\n\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\tfloat spe = sh*pow(pp,16.0);\n\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\tcol = col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\n\n\treturn vec3( clamp(col,0.0,10.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = -55.0; //+ iTime;\n    \n    vec3 d = vec3(0.25*mo.x,0.25*mo.y,0.0);\n    \n    d.x += 1.5*(1.0-cos(0.1*iTime));\n    d.y += 1.5*(1.0-cos(0.05*iTime));\n    \n\t// camera\t\n\tvec3 ro = vec3( d.x, d.y, 6.0 );\n    vec3 ta = vec3( -0.0, -0.0, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n    vec3 col = render( ro, rd );\n\tcol = sqrt( col );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 270, 303, 303, 844], [846, 846, 871, 871, 1006], [1008, 1008, 1062, 1062, 1401], [1403, 1403, 1434, 1434, 1655], [1657, 1683, 1709, 1709, 1865], [1867, 1867, 1906, 1906, 2873], [2875, 2875, 2932, 2932, 3624]], "test": "error"}
{"id": "MsXSDN", "name": "Platypus Perlin Terrain 1", "author": "dancingplatypus", "description": "Experimenting with perlin terrain.  Height determines color.  Modified a perlin function to support multiple octaves.  Threw clouds and water in for presentation.  Next step is to do some lighting.", "tags": ["procedural", "perlin", "landscape"], "likes": 2, "viewed": 311, "published": "Public", "date": "1401174884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The perlin stuff (except for the multiple octaves) was taken from Ian McEwan.  I've posted\n// his copyright stuff below.\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n// My stuff follows...\n\nconst int OCTAVE_COUNT = 5;\nconst float WATER_LEVEL = 0.3;\n\nfloat noise(vec3 pos, int octaves) {\n\tfloat fResult = 0.0;\n\tfloat fPersMax = 0.0;\n\tfor (int g = 0; g < OCTAVE_COUNT; g++) {\n\t\tif (g == octaves) break;\n\t  \tfloat fFreq = pow(2.0, float(g));\n\t  \tfloat fPers = pow(0.5, float(g));\n      \tfPersMax += fPers;\n      \tfResult += fPers * snoise(fFreq*pos);\n\t}\n\treturn fResult / fPersMax + 0.5;\n}\n\nfloat noise(vec3 pos) {\n\treturn noise(pos, OCTAVE_COUNT);\n}\n\n#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat order = 1000.0;\n\n\tfloat zoom = 1.0; //  + 0.05 * sin(0.5 * iTime * M_PI);\n\tfloat cloudZoom = 3.0 + 0.05 * sin(0.5 * iTime * M_PI);\n\tfloat land_feature = 2.0;\n\tfloat water_feature = 80.0;\n\tfloat feature_ratio = water_feature / land_feature;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy * land_feature / zoom;\n\tvec2 water_uv = fragCoord.xy / iResolution.xy * water_feature / zoom;\n\tvec2 cloud_uv = fragCoord.xy / iResolution.xy / zoom;\n\n\tuv = floor(uv * order) / order;\n\twater_uv = floor(water_uv * order) / order;\n\n\tvec2 mouseDeflection = vec2(iMouse.x / iResolution.x - 0.5, iMouse.y / iResolution.y - 0.5);\n\n\t// Super simple sun calculation.\n\t// sample a patch to the right of us.  If it's higher, make us darker.  If it's lower, make us lighter.\n\tvec3 samplePointA = vec3(uv.x + mouseDeflection.x * iTime,\n\t\t\t\t\t\t uv.y + mouseDeflection.y * iTime,\n\t\t\t\t\t\t 0.00 * iTime);\n\tvec3 samplePointB = samplePointA + vec3((fragCoord.x + 1.0) / iResolution.x * land_feature / zoom + mouseDeflection.x * iTime, 0.0, 0.0);\n\tfloat noiseA = noise(samplePointA);\n\tfloat noiseB = noise(samplePointB);\n\tfloat diff = noiseB - noiseA;\n\n\tfloat water = noise(vec3(water_uv.x + mouseDeflection.x * iTime * feature_ratio,\n\t\t\t\t\t\t water_uv.y + mouseDeflection.y * iTime * feature_ratio,\n\t\t\t\t\t\t 0.2 * iTime), 2) + 0.7;\n\tfloat cloud = noise(vec3(cloud_uv.x + mouseDeflection.x * 1.1 * iTime,\n\t\t\t\t\t\t cloud_uv.y + mouseDeflection.y * iTime,\n\t\t\t\t\t\t 0.05 * iTime));\n\n\t// vec3 landColor = clamp(vec3(0.93, 0.82, 0.65) * (1.0 + 0.2 * diff), vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0));\n\tvec3 landColor = vec3(0.73, 0.62, 0.45) * (noiseA * (1.0 + diff));\n\t// vec3 forestColor = vec3(0.93, 0.82, 0.65);\n\t// vec3 mountainColor = vec3(0.93, 0.93, 0.93);\n\tvec3 waterColor = vec3(0.65, 0.94, 0.94);\n\tvec4 cloudColor = vec4(1, 1, 1, pow(cloud, 6.0));\n\n\t// fix for water level\n\n\tfragColor = mix(\n\t\tnoiseA < WATER_LEVEL ?\n\t\t\tvec4(mix(landColor.xyz, water * waterColor.xyz, 0.3), 1.0) :\n\t\t\tvec4(landColor.xyz, 1.0),\n\t\tcloudColor,  pow(cloud, 3.0));\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXSDN.jpg", "access": "shaders20k", "license": "mit", "functions": [[125, 514, 535, 535, 584], [586, 586, 607, 607, 656], [658, 658, 680, 680, 720], [722, 722, 750, 750, 802], [804, 804, 826, 826, 2820], [2822, 2906, 2942, 2942, 3242], [3244, 3244, 3267, 3267, 3303], [3353, 3353, 3410, 3410, 5416]], "test": "valid"}
{"id": "MsXSWN", "name": "Logo Illusion", "author": "daeken", "description": "Playing around with distance fields, I stumbled onto an interesting optical illusion-esque effect.", "tags": ["opticalillusion", "shaderforth"], "likes": 2, "viewed": 196, "published": "Public", "date": "1401086668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n( Constants )\n:m pi 3.14159 ;\n:m tau pi 2.0 * ;\n\n( Comparators )\n:m amin ( arr f )\n\tarr \\{ ( $a $b )\n\t\ta *f b *f min =m\n\t\ta b a *f m == select\n\t}\n;\n:m minmax ( $a $b ) [ a b min a b max ] ;\n\n( Maths )\n: closest-point-line ( a:vec2 b:vec2 point:vec2 -> vec2 )\n\tpoint a - =>pa\n\tb a - =>ba\n\tpa ba dot ba ba dot / 0.0 1.0 clamp =h\n\tba h * a +\n;\n: point-distance-line ( a:vec2 b:vec2 point:vec2 -> float )\n\tpoint a b point closest-point-line - length\n;\n:m deg->rad pi 180. / * ;\n:m rad->deg pi 180. / / ;\n: rotate ( c:vec3 a:float -> vec3 )\n\ta cos =ca\n\ta sin =sa\n\n\t[\n\t\tc .x ca * c .y sa * -\n\t\tc .y ca * c .x sa * +\n\t\tc .z\n\t]v\n;\n:m rotate-deg ( c a ) c a deg->rad rotate ;\n\n( Coordinate System Utilities )\n\n: cart->polar ( p:vec2 -> vec2 ) [ p .y.x atan2 p length ]v ;\n: polar->cart ( p:vec2 -> vec2 ) [ p .x cos p .x sin ]v p .y * ;\n: polar-norm ( p:vec2 -> vec2 ) [ p .x tau + tau mod p .y ]v ;\n\n:m p+ ( p v ) p cart->polar v + polar->cart ;\n:m p* ( p v ) p cart->polar v * polar->cart ;\n\n:m frag->position ( resolution ) fragCoord .xy resolution .xy / 2.0 * 1.0 - [ 1.0 iResolution .y.x / ]v * ;\n\n( Distance Field Utilities )\n:m gradient ( p f )\n\t[ 0.001 0.0 ]v =h\n\tp *f =>v\n\t[\n\t\tp h + *f  p h - *f -\n\t\tp h .yx + *f  p h .yx - *f -\n\t]v 2.0 h .x * / length =>g\n\tv abs g /\n;\n\n( Color Operations )\n: hsv->rgb ( hsv:vec3 -> vec3 )\n    hsv .x 60.0 / [ 0. 4. 2. ]v + 6. mod 3. - abs 1. - 0.0 1.0 clamp =>rgb\n    [ 1. 1. 1. ]v rgb hsv .y mix hsv .z *\n;\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m anim\n\t1.0 iTime 8. mod 4.0 - abs 1. - 1.5 / 0.0 1.0 clamp 3. pow -\n;\n\n: cwarp ( c:vec3 -> vec3 )\n\tanim =t\n\t[\n\t\t\tc .xy 1. t - *\n\t\t\t[ t pi * -1. * 0. ]v\n\t\tp+\n\t\tc .z t 2.5 * 1.0 + *\n\t]v\n;\n\n: p-circle ( p:vec2 c:vec3 -> float )\n\tc cwarp =c\n\tc .xy p - length c .z -\n;\n\n:m circle ( c ) p c p-circle ;\n\n:m intersect max ;\n:m subtract neg max ;\n:m union min ;\n:m shape call ;\n\niResolution frag->position [ 1.2 -1.2 ]v * =p\n\n: distance-field ( p:vec2 -> float )\n\t{\n\t\t[ 0. 0. 0.6 ]v circle\n\t\t{\n\t\t\t{\n\t\t\t\t[ 0. 0. 0.4 ]v circle\n\t\t\t\t{\n\t\t\t\t\tfloat 120. * =>a\n\t\t\t\t\t{\n\t\t\t\t\t\t[ 0.13625 -0.04 0.52221283975 ]v a rotate-deg circle\n\t\t\t\t\t\t[ -0.25375 0.135 0.464630229322 ]v a rotate-deg circle intersect\n\t\t\t\t\t\t[ -0.2925 -0.10125 0.46492270863 ]v a rotate-deg circle subtract\n\t\t\t\t\t} shape subtract\n\t\t\t\t} 3 mtimes\n\t\t\t} shape \n\n\t\t\t{\n\t\t\t\t[ 0.0 0.18375 0.29504766564065543 ]v circle\n\t\t\t\t[ 0.0 0.18375 0.29504766564065543 ]v 120. rotate-deg circle intersect\n\t\t\t\t[ 0.0 0.18375 0.29504766564065543 ]v 240. rotate-deg circle intersect\n\t\t\t\t[ 0.0 0.0 0.0434 ]v circle subtract\n\t\t\t} shape subtract\n\t\t} shape subtract\n\t} shape =dist\n\tdist dist / =sign\n\tdist 75.0 * iTime 5.0 * + sin sign *\n;\n\np &distance-field gradient 100. * 0. 1. clamp =d\n[ d d d 1. ]v =fragColor\n*/\n\nvec3 rotate(vec3, float);\nfloat distance_field(vec2);\nfloat p_circle(vec2, vec3);\nvec2 polar_cart(vec2);\nvec2 cart_polar(vec2);\nvec3 cwarp(vec3);\nvec3 rotate(vec3 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec3((((c).x) * (ca)) - (((c).y) * (sa)), (((c).y) * (ca)) + (((c).x) * (sa)), (c).z);\n}\nfloat distance_field(vec2 p) {\n\tfloat dist = max(p_circle(p, vec3(0.0, 0.0, 0.6)), - (max(max(max(max(p_circle(p, vec3(0.0, 0.0, 0.4)), - (max(max(p_circle(p, rotate(vec3(0.13625, -0.04, 0.52221283975), 4.18878666667)), p_circle(p, rotate(vec3(-0.25375, 0.135, 0.464630229322), 4.18878666667))), - (p_circle(p, rotate(vec3(-0.2925, -0.10125, 0.46492270863), 4.18878666667)))))), - (max(max(p_circle(p, rotate(vec3(0.13625, -0.04, 0.52221283975), 2.09439333333)), p_circle(p, rotate(vec3(-0.25375, 0.135, 0.464630229322), 2.09439333333))), - (p_circle(p, rotate(vec3(-0.2925, -0.10125, 0.46492270863), 2.09439333333)))))), - (max(max(p_circle(p, rotate(vec3(0.13625, -0.04, 0.52221283975), 0.0)), p_circle(p, rotate(vec3(-0.25375, 0.135, 0.464630229322), 0.0))), - (p_circle(p, rotate(vec3(-0.2925, -0.10125, 0.46492270863), 0.0)))))), - (max(max(max(p_circle(p, vec3(0.0, 0.18375, 0.295047665641)), p_circle(p, rotate(vec3(0.0, 0.18375, 0.295047665641), 2.09439333333))), p_circle(p, rotate(vec3(0.0, 0.18375, 0.295047665641), 4.18878666667))), - (p_circle(p, vec3(0.0, 0.0, 0.0434))))))));\n\tfloat sign = (dist) / (dist);\n\treturn (sin(((dist) * 75.0) + ((iTime) * 5.0))) * (sign);\n}\nfloat p_circle(vec2 p, vec3 c) {\n\tc = cwarp(c);\n\treturn (length(((c).xy) - (p))) - ((c).z);\n}\nvec2 polar_cart(vec2 p) {\n\treturn (vec2(cos((p).x), sin((p).x))) * ((p).y);\n}\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan((p).y, (p).x), length(p));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = ((((((fragCoord).xy) / ((iResolution).xy)) * 2.0) - 1.0) * (vec2(1.0, ((iResolution).y) / ((iResolution).x)))) * (vec2(1.2, -1.2));\n\tvec2 h = vec2(0.001, 0.0);\n\tfloat d = clamp(((abs(distance_field(p))) / (length((vec2((distance_field((p) + (h))) - (distance_field((p) - (h))), (distance_field((p) + ((h).yx))) - (distance_field((p) - ((h).yx))))) / (2.0 * ((h).x))))) * 100.0, 0.0, 1.0);\n\tfragColor = vec4(d, d, d, 1.0);\n}\nvec3 cwarp(vec3 c) {\n\tfloat t = 1.0 - (pow(clamp(((abs((mod(iTime, 8.0)) - 4.0)) - 1.0) / 1.5, 0.0, 1.0), 3.0));\n\treturn vec3(polar_cart((cart_polar(((c).xy) * (1.0 - (t)))) + (vec2(((t) * 3.14159) * -1.0, 0.0))), ((c).z) * (((t) * 2.5) + 1.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXSWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 2957, 2987, 2987, 3124], [3125, 3125, 3155, 3155, 4307], [4308, 4308, 4340, 4340, 4401], [4402, 4402, 4427, 4427, 4479], [4480, 4480, 4505, 4505, 4552], [4553, 4553, 4610, 4610, 5044], [5045, 5045, 5065, 5065, 5292]], "test": "error"}
{"id": "MsXXW4", "name": "Checker Ball Skin", "author": "jld", "description": "Based on my first (and only) attempt at POV-Ray Golf, with recursively macro-expanded nested checkerboard textures applied to a sphere.  Here, the sphere is unwrapped.  Drag to rotate.", "tags": ["fractal", "mouse", "uv"], "likes": 0, "viewed": 137, "published": "Public", "date": "1400971665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\n#define M_TAU 6.2831853071795862\n#define ITERS 20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 thph = (fragCoord.xy / iResolution.xy - 0.5) * M_PI;\n\tthph.x *= iResolution.x / iResolution.y;\n\tthph.x += iTime / 60.0 * M_TAU;\n\tvec3 xyz = vec3(cos(thph.x) * cos(thph.y), sin(thph.x) * cos(thph.y), sin(thph.y));\n\tvec3 c0 = vec3(1.0, 0.0, 0.0), c1 = vec3(1.0, 1.0, 1.0);\n\t\n\tvec2 mr = iMouse.xy / iResolution.xy * vec2(M_TAU, M_PI);\n\txyz.xz = vec2(dot(xyz.xz, vec2(cos(mr.y), sin(mr.y))), dot(xyz.xz, vec2(-sin(mr.y), cos(mr.y))));\n\txyz.yz = vec2(dot(xyz.yz, vec2(cos(mr.x), sin(mr.x))), dot(xyz.yz, vec2(-sin(mr.x), cos(mr.x))));\n\t\n\tfor (int i = 0; i < ITERS; ++i) {\n\t\tvec3 t = c0;\n\t\tif (xyz.x * xyz.y * xyz.z > 0.0) {\n\t\t\tc0 = c1;\n\t\t} else {\n\t\t\tc0 = (c0 + 2.0 * c1) / 3.0;\n\t\t}\n\t\tc1 = t;\n\t\txyz = fract(xyz) * 2.0 - 1.0;\n\t}\n\t\n\tfragColor = vec4(c1, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXXW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 144, 144, 904]], "test": "valid"}
{"id": "XdfSDN", "name": "YAME", "author": "matrefeytontias", "description": "Yet Another Mandelbrot Explorer.\n\nAny idea how that can be fixed ?", "tags": ["2d", "fractal", "mandelbrot", "explorer"], "likes": 1, "viewed": 123, "published": "Public", "date": "1400876856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This illustrates the precision problem of WebGL.\n\n#define MAX_STEPS 512\n\n// Change these to zoom on various points\n#define ZOOMX 0.001643721971153\n#define ZOOMY 0.822467633298876\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 5. - 2.5)\n\t\t\t\t/ pow(2., iTime) + vec2(ZOOMX, ZOOMY);\n\t\n\tvec2 z = vec2(0.);\n\t\n\tfloat i;\n\t\n\tfor(int c = 0; c < MAX_STEPS; c++) // lol\n\t{\n\t\ti = float(c);\n\t\tif(length(z) > 2.) break;\n\t\t\n\t\tz = vec2(z.x * z.x - z.y * z.y, z.x * z.y * 2.) + uv;\n\t}\n\t\n\tfragColor = vec4(float(mod(i, 64.)) / 64.,\n\t\t\t\t\t\tfloat(mod(i, 32.)) / 32.,\n\t\t\t\t\t\tfloat(mod(i, 16.)) / 16.,\n\t\t\t\t\t\t1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 183, 240, 240, 648]], "test": "valid"}
{"id": "XdfXWN", "name": "Mandelbrot - one more :-) ", "author": "FabriceNeyret2", "description": "( try mouse ).", "tags": ["mandelbrot", "short"], "likes": 5, "viewed": 1385, "published": "Public API", "date": "1400832092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired from https://www.shadertoy.com/view/XdfSWN\n\n// simplier version here: https://www.shadertoy.com/view/XsVSWK\n\n#define N 100.\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    \n\tfloat t = iTime/2.,           // rotation at scaling\n\t\t st = 2.*exp(-6.*(1.-cos(.1*t))), \n          c = cos(t),s = sin(t); \n    mat2 M = mat2(c,-s,s,c);\n    \n\tvec2 R = iResolution.xy,            // coordinates transform\n        z0 = st * M * (u/R.y - vec2(1.1,.5)) -vec2(.4615,-.622), \n         z = z0, \n\t\tm = length(iMouse.xy)==0. ? z-z : st*2.*(iMouse.xy/R.y-vec2(1.1,.5));\n\n    o -= o;\n\tfor (float i=0.; i<N; i++) {\n\t\tif (dot(z,z)>4.) { o = vec4(1.-i/N); return;} // z diverged\n\t\tz -= m;\n\t\tz = z0+m + mat2(z,-z.y,z.x)*z; \n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfXWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 137, 175, 175, 711]], "test": "valid"}
{"id": "XdlSD4", "name": "mandelbox_ryu", "author": "EvilRyu", "description": "mandelbox, see http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/", "tags": ["fractal", "mandelbox"], "likes": 29, "viewed": 1826, "published": "Public API", "date": "1401530999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat stime, ctime, time;\nvoid ry(inout vec3 p, float a){  \n\tfloat c,s;vec3 q=p;  \n\tc = cos(a); s = sin(a);  \n\tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n}  \n\nfloat fixed_radius2 = 1.9;\nfloat min_radius2 = 0.1;\nfloat folding_limit = 1.0;\nfloat scale = -2.8;\nvec3 mtl = vec3(1.0, 1.3, 1.23)*0.8;\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    }else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int n = 0; n < 15; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;\n\t\t//scale = -2.8 - 0.2 * stime;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\nfloat f(vec3 p){ \n\try(p, stime);\n    return mb(p); \n} \n\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t); \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n} \n\n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float t = 0.01;\n    for(int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = f(p);\n        if(res < 0.001 * t || res > 20.)\n            break;\n        t += res;\n    }\n    \n    if(res > 20.) t = -1.;\n    return t;\n}\n\n\nvec3 lighting(vec3 p,vec3 rd, float ps) {\n\t\n\tvec3 l1_dir = normalize(vec3(0.8, 0.8, 0.4)); \n    vec3 l1_col = 0.3*vec3(1.5, 1.69, 0.79);\n\tvec3 l2_dir = normalize(vec3(-0.8, 0.5, 0.3));\n    vec3 l2_col = vec3(0.89, 0.99, 1.3); \n    \n    vec3 e=vec3(0.5 * ps,0.0,0.0); \n \tvec3 n = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), \n \t\t\t\t\t\t  f(p+e.yxy)-f(p-e.yxy), \n \t\t\t\t\t\t  f(p+e.yyx)-f(p-e.yyx)));\n\t\n\tfloat shadow = softshadow(p, l1_dir, 10.0 );\n\n    float dif1 = max(0.0, dot(n, l1_dir));\n\tfloat dif2 = max(0.0, dot(n, l2_dir));\n\tfloat bac1 = max(0.3 + 0.7 * dot(vec3(-l1_dir.x, -1.0, -l1_dir.z), n), 0.0);\n\tfloat bac2 = max(0.2 + 0.8 * dot(vec3(-l2_dir.x, -1.0, -l2_dir.z), n), 0.0);\n    float spe = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n    vec3 col = 5.5 * l1_col * dif1 * shadow;\n\tcol += 1.1 * l2_col * dif2;\n\tcol += 0.3 * bac1 * l1_col;\n\tcol += 0.3 * bac2 * l2_col; \n    col += 1.0 * spe; \n\t\n    float t=mod(p.y+0.1*texture(iChannel0,p.xz).x-time*150.0, 5.0);\n    col = mix(col, vec3(6.0, 6.0, 8.0), \n              pow(smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t), 15.0));;\n\treturn col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n\t // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\treturn col;\n}\n\n\nvec3 get_background_color(vec2 uv, vec3 ro, vec3 rd) {\n\tvec3 bg = vec3(1.0); \n\treturn bg;\n}\nvec3 camera(float t){\n\tvec3 p=vec3(3.0*stime,2.0*ctime,5.0+1.0*stime);\n    return p;\n} \n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.1); \n \tctime=cos(iTime*0.1); \n    time=iTime*0.01;\n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\t//vec3 ro = vec3(0.0, 2.0, 5.9);\n    vec3 ro=camera(time);\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    \n\tvec3 bg = get_background_color(uv, ro, rd); \n    vec3 col = bg;\n\n    vec3 p=ro; \n\t \n\tfloat t = intersect(ro, rd);\n\tif(t > -0.5){\n\t\tp = ro + t * rd;\n        col = lighting(p, rd, 0.004)*mtl*0.2; \n        col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n    } \n\n   \tcol=post(col, q);\n \tfragColor=vec4(col.x,col.y,col.z,1.0); \n }", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 58, 58, 170], [311, 311, 359, 359, 628], [630, 630, 675, 675, 736], [738, 738, 756, 756, 1042], [1044, 1044, 1060, 1060, 1097], [1101, 1101, 1146, 1146, 1377], [1382, 1382, 1417, 1417, 1673], [1676, 1676, 1717, 1717, 2791], [2793, 2793, 2822, 2832, 3088], [3091, 3091, 3145, 3145, 3182], [3183, 3183, 3204, 3204, 3269], [3272, 3272, 3331, 3331, 4148]], "test": "error"}
{"id": "XdlXDr", "name": "dist 2 spline #3", "author": "FabriceNeyret2", "description": "M: toggles construction mesh     L: toggles distance field / thin line\nG: show gradient                        I: show isolines\nC: shows parts drawn with the costly algo", "tags": ["spline"], "likes": 23, "viewed": 2987, "published": "Public API", "date": "1399404228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// efficient distance to spline relying on the iterative construction of splines.\n\n#define POINTS 8  \t\t // number of control points\n\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\nconst float sampl=120.; // number of samples per spline for the costly method\nfloat t;\n\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\n\n// --- GUI utils\n\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\nfloat showFlag(vec2 p, vec2 uv, float v) {\n\tfloat d = length(2.*(uv-p));\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\n}\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\n}\n\n\n// --- math utils\n\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\n\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\t\n// --- dist pos to seg P0P1\n\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\n\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\n\tfloat d, l2_01=dist2(P0,P1);\n\n\t// --- if projection out of segment bounds, dist to extremity\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\n\tif      (l <= 0.) return distance(pos,P0);\n\telse if (l >= 1.) return distance(pos,P1);\n\n\t// --- dist to seg = dist to line\n\telse if (SIGNED_DIST) \n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\n\telse return distance(pos, P0+l*P0P1);\n}\n\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\n\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\n\n\t// makes the quadri convex if not: the 4 turns must have same sign.\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\n\n\t// measure turns direction\n#define ssign(v) (((v)>=0.) ? 1 : -1)\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \n\telse  FLIP = false;\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\n\t\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\n\t// take care: dji != -dij at extremities since must be always positive outside\n\tfloat d0, d1;\n\t\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \n\n\telse {\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\n\n\t  if (t==0)         // --- 'X' shape\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\n\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\n\t\telse              // it's P0 or P3: in facts, that's fine.\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\n\t  }\n\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\n}\n\n\n// --- dist to spline - costly (for pixels where smart method failed )\n\n// TODO: - recursive subdivision\n//       - Newton iterations to  min dist\n//       - adaptive stepping (especially when used on small spline section)\n//       - sampling = diameter*pi*resolution\n// (anyway this function has negligible cost since rarely used).\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\n\tif (SHOW_COSTLY) return vec2(8.);\n\tfloat d = 1e5;\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\n\t\t\n\t\t// construct the 2 sub- control polygons\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\n\t\tvec2 D = P0123-pos;\n\t\td = min(d, dot(D,D));\n\t}\n\td = sqrt(d);\n\treturn vec2(d);\n}\n\n// --- dist to spline - iterative\n\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\n\tvec2 d0mM, d3mM;\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\n\t\tif (i >= n) continue;\n\t\t\n\t\t// construct the 2 sub- control polygons\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\n\n\t\t\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\n\t\t\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\n\t\t\t\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\n\t\tfloat s;\n\n\n\t\t// inside one of the sub quadri\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\n\t\telse \n#if 1\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\n\t\t\telse // ambiguous\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\n#else\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\n#endif\n\t\t\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\n   \t}\n\t\n\tif (n<0) // ambiguity found: switch to costly method\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \n\t\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\n}\n\n\n\n\n// === main ===================\n\n// motion of control points and tangents.\nvec2 P(float i) {\n\tvec4 c = hash4(i);\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\n}\n\n// ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tt = iTime;\n    fragColor = vec4(0.);\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\n\tvec2 Pc, Tc;\n\t\n\t// --- tuning \n\t\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\n\tSIGNED_DIST = !keyToggle(64+19); \n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\n\t\n\tif (iMouse.z<=0.) {\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\n\t\tSHOW_LINE   =  (m==2)||(m==3);\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\n\t\tSHOW_ISO    =  (m==6)||(m==7);\n\t\tSHOW_COSTLY =  false;\n\t\tPc = P(0.); Tc = P(0.5);\n\t} else {\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\n\t\tPc = mouse; Tc = vec2(1.);\n\t}\n\t\n\t\n\t// --- dist to spline \n\t// TODO:\n\t//    - first select possible splines\n\t//    - parallel descent in the vector of splines\n\t\n\tvec2 dmMi[POINTS];\n\tvec2 dmM = vec2(1e5);\n\tvec2 P0, T0, P3=Pc, T3=Tc;\n#if 0\n\tfor (float i=1.; i<float(POINTS); i++) \n\t{\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\n\t}\n#endif\n\t\n\tdmM = vec2(1e5);\n\tP3=Pc, T3=Tc;\n\tfor (float i=1.; i<float(POINTS); i++) \n\t{\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\n\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\n\n\t\tif (dmMi.x==0.) // display mesh\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \n\t\tif (dmMi.x==8.) // display ambiguous parts\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \n\t\tdmM = min (dmM, dmMi);\n\t}\n\t\n\t\n\t// --- display\n\t\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \n\tif (SHOW_LINE) col = pow(col, vec3(16.));\n\tif (SHOW_ISO ) col = sin(100.*col);\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\n\t\n\tfragColor += vec4(col.xy, 0.,1.);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlXDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 372, 399, 399, 472], [473, 473, 515, 515, 608], [609, 609, 653, 653, 697], [700, 719, 751, 751, 783], [784, 784, 814, 814, 849], [850, 850, 880, 880, 915], [916, 916, 947, 947, 980], [982, 982, 1004, 1004, 1048], [1049, 1049, 1071, 1071, 1106], [1107, 1107, 1129, 1129, 1186], [1243, 1402, 1446, 1446, 1995], [1997, 2066, 2130, 2130, 4190], [4265, 4526, 4598, 4598, 5020], [5022, 5057, 5128, 5128, 6566], [6604, 6646, 6663, 6663, 6797], [6799, 6807, 6864, 6864, 8890]], "test": "error"}
{"id": "XdlXW4", "name": "gravity field", "author": "FabriceNeyret2", "description": "gravity field generated by a schoolfish of stars\nCycles between sum(pot2D), sum(pot3D), sum(gravity2D), sum(gravity3D)\nMouse.x to force cycling.", "tags": ["gravity"], "likes": 8, "viewed": 1812, "published": "Public API", "date": "1401261506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define POINTS 100  \t\t // number of stars\n\n// --- GUI utils\n\nfloat t;\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n// --- flag and values buton display ---\n\nfloat showFlag(vec2 p, vec2 uv, float v) {\n\tfloat d = length(2.*(uv-p));\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\n}\n\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\n}\n\n\n// --- math utils\n\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\n\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\t\n\n\n// === main ===================\n\n// motion of stars\nvec2 P(float i) {\n\tvec4 c = hash4(i);\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\n}\n\n// ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\n\tint MODE = int(mod(m,4.)); \n\tfloat fMODE = (1.-cos(6.283*m))/2.;\n\n\t\n\tfloat v=0.; vec2 V=vec2(0.);\n\tfor (int i=1; i<POINTS; i++) { // sum stars\n\t\tvec2 p = P(float(i));\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\n\t\t\tfor (int x=-1; x<=1; x++) {\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\n\t\t\t}\n\t\t}\n\t\n\tif (MODE>1) v = length(V);\n\tv *= 1./(9.*float(POINTS));\n\t\n\tv *= 10.*fMODE;\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\n\t\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlXW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 71, 98, 98, 171], [173, 215, 257, 257, 350], [352, 352, 396, 396, 440], [443, 462, 493, 493, 526], [528, 528, 550, 550, 594], [595, 595, 617, 617, 652], [653, 653, 675, 675, 732], [770, 789, 806, 806, 940], [942, 950, 1007, 1007, 2039]], "test": "error"}
{"id": "XdsSDn", "name": "Voronoi Snowflakes", "author": "steverock", "description": "I was originally planning on making a flowers scene, but this ended up happening instead :) I don't even use the Voronoi border distance - just the control point id/distance.", "tags": ["voronoi", "snow"], "likes": 23, "viewed": 1209, "published": "Public", "date": "1399163679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// Heavily modified by Steven An - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// I've not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n// never seen cell boundaries rendered correctly. \n//\n// However, here's how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n//\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\nvec3 bg = vec3(0.6, 0.8, 1.0);\nvec3 white = vec3(1.0, 1.0, 1.0);\nfloat zoom = 0.08;\nvec2 fallspeed = vec2(0.04,0.05);\n\nfloat pi = 3.141592653;\n\n#define ANIMATE\n\nfloat animbias = 0.5;\nfloat animscale = 0.4;\n\nvec2 hash( vec2 p )\n{\n\treturn texture( iChannel0, (p+0.5)/200.0, -100.0 ).xy;\n\t\n\t// this no longer works reliably due to a bug in some WebGL impls\n//    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n//\treturn fract(sin(p)*43758.5453);\n}\n\nvec3 voronoi( in vec2 x, out vec2 cpId )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = animbias + animscale*sin( iTime*0.5 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = animbias + animscale*sin( iTime*0.5 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n\t\t\n        if( dot(mr-r,mr-r)>0.000001 )\n\t\t{\n        // distance to line\t\t\n        float d = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        md = min( md, d );\n\t\t}\n    }\n\t\n\tcpId = n+mg;\n\n    return vec3( md, mr );\n}\n\nfloat sin01(float theta)\n{\n\treturn sin(theta)*0.5 + 0.5;\n}\n\nfloat boxfilter( float x, float min, float max )\n{\n\tif( x < min || x > max )\n\t\treturn 0.0;\n\telse\n\t\treturn x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy-iResolution.xy*0.5)/iResolution.xx;\n\tp += iTime * fallspeed;\n\t\n\t// add variation to sky\n\tbg = mix( bg, vec3(0.8,0.7,0.9), pow(fragCoord.y/iResolution.y, 1.0));\n\t\n\tvec2 cpid;\n    vec3 c = voronoi( p/zoom, cpid );\n\tfloat centerDist = length( c.yz );\n\tfloat borderDist = c.x;\n\n\tfloat size = mix( 0.1, 0.20, sin01(cpid.x - cpid.y));\n\t\n\t// get angle to cp\t\n\tfloat angle = atan(c.z, c.y);\n\t// add some animated rotation\n\tfloat angvel = sin(cpid.x*123.0+cpid.y*451.0) * 0.5*pi;\n\tangle += iTime * angvel;\n\n\tfloat numpeds = floor(mix(5.0, 9.0, sin01(cpid.x + cpid.y)));\n\tfloat pedval = sin01(angle*numpeds);\n\tvec3 col = mix( bg, white, pow(pedval,4.0) );\n\t\n\t// some radial details\n\tfloat numrings = floor(mix(1.0, 4.0, sin01(cpid.x*100.0 + cpid.y*42.0)));\n\tfloat ringsharp = 2.0;\n\tfloat pedval2 = pedval;\n\tif( hash(cpid).x < 0.5 )\n\t\t// determine inward vs. outward warped circles\n\t\tpedval2 = 1.0-pedval;\n\tfloat warpdist = mix( centerDist*0.8, centerDist, pedval2 );\n\tfloat ringval = sin01(warpdist/(size*0.8) * 2.0*pi * numrings - pi*0.5);\n\tcol = mix( col, white, pow(ringval, ringsharp)  );\n\t\n\t// cutoff past some distance from flake center\n\tcol = mix( col, bg, smoothstep( size*0.8, size*1.0, centerDist) );\n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsSDn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[165, 850, 871, 871, 1104], [1106, 1106, 1148, 1148, 2355], [2357, 2357, 2383, 2383, 2415], [2417, 2417, 2467, 2467, 2527], [2529, 2529, 2586, 2586, 3845]], "test": "error"}
{"id": "XdsXWN", "name": "Mandelbrot \"doubles\"", "author": "TekF", "description": "Based on [url=https://www.shadertoy.com/view/XssSD4]this shader by francesco149[/url]\r\nUse some hacks to fake double precision floats. Gets significantly better results than single precision, but I don't think it's as good as double precision.", "tags": ["doubleprecision"], "likes": 28, "viewed": 2252, "published": "Public", "date": "1401376690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// webgl mandelbrot shader test\n// by Franc[e]sco\n// adapted by TekF\n\n// my work & home PCs get very different results, so toggle some things\n// it seems to be caused by the precision of the pan value\n#if (1)\n\t// Work PC (GeForce GTX 770)\n\tconst vec4 pan = vec4(-0.31750109, 0.48999993, 0.00000000000000588, .0);\n\tconst float period = 175.0; // higher quality results at this position, so can zoom closer\n#else\n\t//Home PC (Radeon HD 7700)\n\tconst vec4 pan = vec4(-0.3175011, 0.49, .00000000011, .0);\n\tconst float period = 142.0;\n#endif\n\n//const vec4 pan = vec4(-0.300853, 0.441, 0.00000000000000032, -0.0000000000238951); // does anyone have a good point to zoom on?\n//const vec4 pan = vec4(-0.3151, 0.445, 0, -.000000013);\n\n#define aspectRatio (iResolution.x / iResolution.y)\nconst int maxIterations = 256;\nconst vec3 colourPhase = vec3(5,7,11)/80.0;\nconst vec3 colourPhaseStart = vec3(1);\n\nconst float initialZoom = 3.5;\n\n\nvec2 DoubleMul( vec2 a, vec2 b )\n{\n\tvec2 c;\n\t// c = a*b\n\t// (c.y+c.x) = (a.x+a.y)*(b.x+b.y);\n\tc.y = a.y*b.y; // smallest part\n\tfloat l = a.x*b.x; // largest part\n\tfloat r = a.x*b.y + a.y*b.x; // part in-between.\n\t// if we add it to the big, it might lose precision in the middle of the number\n\t// which would be as bad as a float, so:\n\n// trying out some ideas to make the \"doubles\" more robust:\n\t\n// try to add it to c.x, and detect how much underflowed to add to c.y\n// I don't expect this will work, because the compiler will optimise it out\n/*c.x = l+r;\nfloat rf = c.x-l; // the part of r that actually made it after rounding.\nr = r - rf;\nc.y += r;*/\n// note that a.x*b.x already underflows, so using the full precision will make that a more serious problem.\n// => need upper & lower halfs of .x's... uh...\n\nc.x = l;\nc.y += r;\n\n/*\nThis introduces more errors!\ncould try taking the difference between c.x and c.x+r, and that remainder is the value to add to c.y\n// do something more robust, otherwise the vals can both lose too much precision\n\tfloat cp = log2(abs(c.x));\n\tfloat rp = log2(abs(r));\n\tconst float precis = 20.0;\n\tif ( rp > cp-precis )\n\t{\n\t\t// chop rp up into 2 bits, put the bigger bits in the top val\n\t\tfloat cut = exp2(cp-precis);\n\t\tfloat r2 = fract(r/cut)*cut;\n\t\tc.y += r2;\n\t\tc.x += r-r2;\n\t}\n\telse\n\t{\n\t\tc.y += r;\n\t}\n*/\n\treturn c;\n}\n\nvec3 fractal( vec2 pos ) {\n\t\n\t// randomly tweaked the calculations for semi-constant zooming\n\t// I don't really know what I'm doing here, but it works\n\tfloat T = abs(fract((iTime/period)*.5+.5)*2.0-1.0001)*period; // using exactly 1.0 breaks it, I don't know why\n\tfloat zoom = pow(initialZoom, (-T + initialZoom + 1.0) / 5.0);\n\n\tvec4 Z = vec4(0), C = vec4(0);\n\tint iterations;\n\tbool ignore = false;\n\t\n\t// convert to texels, center the set on screen and apply zoom\n\tvec2 pixel;\n\tpixel = (pos / iResolution.xy - 0.5) * zoom; \n\tpixel.y /= aspectRatio; // fix aspect ratio\n\n\tfloat a = iTime*.05;\n\tpixel = pixel*cos(a)+vec2(1,-1)*sin(a)*pixel.yx;\n\n// to see the limit of floats, set xy instead of zw here!\t\n\tC.zw = pixel;\n\t\n\tC -= pan;\n\t\n\tfor (int i = 0; i < maxIterations; i++) {\n\t\tif (ignore)\n\t\t\tbreak;\n\t\t\n\t\t// complex number operations\n\t\t// Z = Z*Z + C\n\t\tvec4 Z2;\n\t\t//Z.x * Z.x - Z.y * Z.y, \n\t\tZ2.xz = DoubleMul(Z.xz,Z.xz) - DoubleMul(Z.yw,Z.yw);\n\t\tZ2.yw = 2.0*DoubleMul(Z.xz,Z.yw);\n\t\tZ = Z2 + C; // apply panning\n\t\t\n\t\t// stop immediately if the point is outside a radius of 2 from (0,0) (the bounds of the mandelbrot set)\n\t\t//if ( dot((DoubleMul(Z.xz,Z.xz) + DoubleMul(Z.yw,Z.yw)),vec2(1)) > 4.0 ) // smooth\n\t\tif ( max(abs(dot(Z.xz,vec2(1))),abs(dot(Z.yw,vec2(1)))) > 2.0 ) // scallops\n\t\t\tignore = true;\n\t\t\n\t\titerations = i;\n\t}\n\t\n\t//return pow(sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5,vec3(2.2));\n\treturn pow(sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5,vec3(1.5));\n\t//return 1.0-abs(sin(colourPhase.xyz * float(iterations) + colourPhaseStart));//*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//fragColor.rgb  = fractal( fragCoord.xy + vec2(0,0) );\n\n\t// anti-aliasing\n\tfragColor.rgb  = fractal( fragCoord.xy + vec2(0,0) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.5,.0) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.0,.5) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.5,.5) );\n\tfragColor.rgb /= 4.0;\n\t\n/*\tfragColor.rgb += fractal( fragCoord.xy + vec2(.25,.25) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.75,.25) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.25,.75) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.75,.75) );\n\tfragColor.rgb /= 8.0;*/\n\t\n\tfragColor.rgb = pow(fragColor.rgb,vec3(1.0/2.2));\n\n\tfragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsXWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[536, 924, 958, 958, 2274], [2276, 2276, 2302, 2426, 3876], [3879, 3879, 3936, 4012, 4602]], "test": "valid"}
{"id": "XdsXWr", "name": "Molecule Rendering", "author": "Klems", "description": "I wrote a simple script to parse a molfile and print the corresponding shader. Click and drag the mouse to rotate the molecule. Figuring out the molecule name is left as an exercice to the reader ;)", "tags": ["3d", "tunnel", "raymarch", "hexagon", "molecule"], "likes": 33, "viewed": 1444, "published": "Public", "date": "1399417562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #define BLUE\n// #define RED\n\n#define FOV         \t1.0\n#define ITER_MAX    \t20\n#define ITER_DETAIL \t0.2\n#define SIZE_ATOM \t\t0.25\n#define SIZE_BOND \t\t0.01\n#define SMIN_RADI \t\t0.20\n\n// a few constants regarding the hexagonal grid\n#define PI    \t3.141592653589793\n#define MULT1 \t(1.0/tan(PI/3.0))\n#define MULT2 \t(1.0/sin(PI/3.0))\n#define PHI   \t((1.0+sqrt(5.0))/2.0)\n\nfloat sdSphere(in vec3 p, in vec3 a) {\n\treturn length(p-a)-SIZE_ATOM;\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - SIZE_BOND;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\treturn mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat sd2Atoms(in vec3 p, in vec3 a, in vec3 b) {\n    float atom = sdSphere(p, b);\n    float bond = sdCapsule(p, a, b);\n    return smin(atom, bond, SMIN_RADI);\n}\n\nfloat DE(in vec3 p) {\n\tfloat md = 10000.0;\n\n\t// 30 ATOMS\n/*\tmd = smin(md, sdSphere(p, vec3(-2.355, +1.155, -1.173)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-1.896, -0.052, -0.525)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-2.696, -1.058, -0.272)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-4.098, -1.040, -0.618)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-4.564, +0.058, -1.222)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-3.649, +1.212, -1.513)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-1.952, -2.085, +0.360)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-0.582, -1.616, +0.475)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-0.563, -0.389, -0.061)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-1.733, +1.915, -1.360)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-4.695, -1.817, -0.416)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-5.528, +0.112, -1.480)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-4.008, +2.029, -1.963)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+0.190, -2.109, +0.875)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+0.650, +0.486, -0.172)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+0.778, +0.764, -1.124)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+0.532, +1.298, +0.398)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+1.880, -0.312, +0.306)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+3.102, +0.498, +0.200)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+1.746, -0.579, +1.260)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+1.980, -1.131, -0.258)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+3.007, +1.672, +1.083)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+3.842, +2.217, +1.005)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+4.256, -0.318, +0.601)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+5.092, +0.226, +0.531)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+2.894, +1.370, +2.030)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+2.220, +2.228, +0.815)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+4.327, -1.113, -0.000)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(+4.137, -0.624, +1.545)), SMIN_RADI);\n\tmd = smin(md, sdSphere(p, vec3(-2.314, -2.997, +0.675)), SMIN_RADI);\n*/\n    \n\t// 31 BONDS\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-2.355, +1.155, -1.173), \n\t\tvec3(-1.896, -0.052, -0.525)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-1.896, -0.052, -0.525), \n\t\tvec3(-2.696, -1.058, -0.272)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-2.696, -1.058, -0.272), \n\t\tvec3(-4.098, -1.040, -0.618)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-4.098, -1.040, -0.618), \n\t\tvec3(-4.564, +0.058, -1.222)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-4.564, +0.058, -1.222), \n\t\tvec3(-3.649, +1.212, -1.513)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-3.649, +1.212, -1.513), \n\t\tvec3(-2.355, +1.155, -1.173)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-1.952, -2.085, +0.360), \n\t\tvec3(-2.696, -1.058, -0.272)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-0.582, -1.616, +0.475), \n\t\tvec3(-1.952, -2.085, +0.360)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-0.563, -0.389, -0.061), \n\t\tvec3(-0.582, -1.616, +0.475)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-1.896, -0.052, -0.525), \n\t\tvec3(-0.563, -0.389, -0.061)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-2.355, +1.155, -1.173), \n\t\tvec3(-1.733, +1.915, -1.360)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-4.098, -1.040, -0.618), \n\t\tvec3(-4.695, -1.817, -0.416)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-4.564, +0.058, -1.222), \n\t\tvec3(-5.528, +0.112, -1.480)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-3.649, +1.212, -1.513), \n\t\tvec3(-4.008, +2.029, -1.963)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-0.582, -1.616, +0.475), \n\t\tvec3(+0.190, -2.109, +0.875)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-0.563, -0.389, -0.061), \n\t\tvec3(+0.650, +0.486, -0.172)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+0.650, +0.486, -0.172), \n\t\tvec3(+0.778, +0.764, -1.124)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+0.650, +0.486, -0.172), \n\t\tvec3(+0.532, +1.298, +0.398)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+0.650, +0.486, -0.172), \n\t\tvec3(+1.880, -0.312, +0.306)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+1.880, -0.312, +0.306), \n\t\tvec3(+3.102, +0.498, +0.200)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+1.880, -0.312, +0.306), \n\t\tvec3(+1.746, -0.579, +1.260)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+1.880, -0.312, +0.306), \n\t\tvec3(+1.980, -1.131, -0.258)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+3.102, +0.498, +0.200), \n\t\tvec3(+3.007, +1.672, +1.083)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+3.007, +1.672, +1.083), \n\t\tvec3(+3.842, +2.217, +1.005)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+3.102, +0.498, +0.200), \n\t\tvec3(+4.256, -0.318, +0.601)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+4.256, -0.318, +0.601), \n\t\tvec3(+5.092, +0.226, +0.531)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+3.007, +1.672, +1.083), \n\t\tvec3(+2.894, +1.370, +2.030)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+3.007, +1.672, +1.083), \n\t\tvec3(+2.220, +2.228, +0.815)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+4.256, -0.318, +0.601), \n\t\tvec3(+4.327, -1.113, -0.000)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(+4.256, -0.318, +0.601), \n\t\tvec3(+4.137, -0.624, +1.545)), SMIN_RADI);\n\tmd = smin(md, sd2Atoms(p, \n\t\tvec3(-1.952, -2.085, +0.360), \n\t\tvec3(-2.314, -2.997, +0.675)), SMIN_RADI);\n\n\treturn md;\n}\n\nmat2 rot(in float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nfloat hexDist(vec2 p) {\n\tfloat dx = abs(p.x);\n\tfloat dy = abs(p.y);\n\treturn max(dx+dy*MULT1, max(dx, dy*MULT2));\n}\n\nvec2 getHexCenter(vec2 p) {\n\tvec3 o = vec3(p.x, p.y/MULT2, 0);\n\to.z = -0.5*o.x-o.y;\n\to.y = -0.5*o.x+o.y;\n\tvec3 i = floor(o+0.5);\n\tfloat s = i.x+i.y+i.z;\n\tvec3 d = abs(i-o);\n\tif(d.x > d.y && d.x > d.z)\n\t\ti.x -= s;\n\telse if(d.y > d.x && d.y > d.z)\n\t\ti.y -= s;\n\telse\n\t\ti.z -= s;\n\treturn vec2(i.x, (i.y-i.z)*0.5*MULT2);\n}\n\nvec3 hexgrid(vec2 p) {\n\t\n\tvec2 c = getHexCenter(p);\n\tfloat hdist = hexDist(c-p)*1.5;\n\t\n\t// add a pulse depending on axis\n\tfloat cdist = length(c-p)*1.5;\n\tfloat pulse1 = smoothstep(-1.0, +1.0,\n\t\tsin(cdist+iTime*0.412-p.y*PI*0.11-p.x*PI*0.2));\n\tfloat pulse2 = smoothstep(-1.0, +1.0,\n\t\tsin(cdist+iTime*0.842-p.y*PI*0.42-p.x*PI*0.1));\n\tvec3 result = vec3(0.3, 0.8, 0.2);\n\tresult += vec3(0.062, 0.41, 0.03)*pulse1;\n\tresult += vec3(0.008, 0.23, 0.04)*pulse2;\n\t\n\t// add another pulse\n\tfloat pulse3 = (sin(iTime*3.0-p.y*0.2-p.x*PI*0.1)*.5+.5);\n\tresult += 1.0-smoothstep(0.0, pulse3, hdist);\n\t\n\t// and an antialiased black border\n\tresult -= smoothstep(0.6, 1.0, hdist);\n\t\n\treturn clamp(result, 0.0, 1.0);\n}\n\n// see http://www.math.utah.edu/~bresslof/publications/01-1.pdf\nvoid distort(inout vec2 p) {\n\tp+=p*length(p)*0.9;\n\tp = vec2(atan(p.x, p.y)/PI*3.0, log(length(p))+iTime*0.15);\n\tp.x += p.y/PHI + iTime*0.1;\n}\n\nvec3 getBackground(vec2 uv) {\n\tfloat luv = length(uv);\n\tdistort(uv);\n\tuv *= 10.0;\n\tvec3 result = hexgrid(uv);\n\treturn result - smoothstep(0.0, 1.0, 1.0-luv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 from = vec3(-10, 0, 0);\n\tvec3 dir = normalize(vec3(uv * FOV, 1.0));\n\tdir.xz *= rot(3.1415*.5);\n\t\n\tvec2 mouse=(iMouse.xy / iResolution.xy - 0.5) * 3.0;\n\t\n\tmat2 rotxz = rot(iTime*0.652+mouse.x);\n\tmat2 rotxy = rot(sin(iTime*0.814)*.3+mouse.y-1.5);\n\t\n\tfrom.xz *= rotxz;\n\tfrom.yz *= rotxy;\n\tdir.xz  *= rotxz;\n\tdir.yz  *= rotxy;\n\n\tfloat ao = 1.0;\n\tfloat haze = 1000.0;\n\t\n\tfloat totdist = 0.0;\n\tbool set = false;\n\t\n\tfor (int steps = 0 ; steps < ITER_MAX ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n\t\tfloat dist = DE(p);\n\t\thaze = min(haze, dist);\n\t\ttotdist += dist;\n\t\tif (dist < ITER_DETAIL) {\n\t\t\tset = true;\n\t\t\tao = float(steps) / float(ITER_MAX);\n            break;\n\t\t}\n\t}\n\t\n\tvec3 color = getBackground(uv);\n\t\n\tif (set) {\n\t\tcolor = vec3(0.454, 1.0, 0.42)*(1.0-ao);\n\t\tcolor -= totdist*0.02;\n\t\tcolor += (haze*haze)*0.8;\n\t} else {\n\t\tif (haze < 0.4) color = vec3(0.0, 0.1, 0.0);\n\t\telse color -= (1.0 - clamp(haze, 0.0, 1.0))*.5;\n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n\t\n\t#ifdef BLUE\n\tfragColor.rgb = fragColor.rbg;\n\t#endif\n\t\n\t#ifdef RED\n\tfragColor.rgb = fragColor.grb;\n\t#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 367, 405, 405, 438], [440, 440, 490, 490, 616], [618, 618, 657, 657, 740], [742, 742, 791, 791, 903], [905, 905, 926, 926, 6385], [6387, 6387, 6409, 6409, 6456], [6458, 6458, 6481, 6481, 6572], [6574, 6574, 6601, 6601, 6891], [6893, 6893, 6915, 6915, 7590], [7592, 7656, 7684, 7684, 7797], [7799, 7799, 7828, 7828, 7958], [7960, 7960, 8017, 8017, 9189]], "test": "valid"}
{"id": "XdXSD4", "name": "Newton's Method Fractal", "author": "EhsanKia", "description": "Shader version of:\nhttp://www.reddit.com/r/mathpics/comments/261cd8/colorful_newtons_method_gif/", "tags": ["fractal", "newton", "newtonsmethod"], "likes": 4, "viewed": 165, "published": "Public", "date": "1400706956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\tModified version of: https://www.shadertoy.com/view/XdsXWH\n\tBy: Ehsan Kia\n\tInspired by http://www.reddit.com/r/mathpics/comments/261cd8/colorful_newtons_method_gif/\n **/\n\n#define ITERATIONS 30\n#define EPSILON 0.005\n#define PI 3.141592653589\n\n// Give types descriptive names\n#define complex vec2\n#define Color3 vec3\n\n/////// Helper functions for complex numbers ///////\nfloat im(complex a) {\n\treturn a.y;\n}\n\nfloat real(complex a) {\n\treturn a.x;\n}\n\ncomplex conj(complex a) {\n\treturn complex(a.x, -a.y);\n}\n\ncomplex mul(complex a, complex b) {\n\treturn complex(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\ncomplex div(complex a, complex b) {\n\treturn mul(a,conj(b)) / real(mul(b, conj(b)));\n}\n\nfloat cabs(complex a) {\n\treturn sqrt(a.x*a.x + a.y*a.y);\n}\n\n/////////////////////////////////////////////////////\n\n\n// x^3-1 / 3x^2\ncomplex f(complex z, complex alpha, complex beta) {\n\treturn mul(mul(z, z - alpha), z - beta);\n}\n\ncomplex df(complex z, complex alpha, complex beta) {\n\treturn mul(z-alpha, z-beta) + mul(z, z-beta) + mul(z, z-alpha);\n}\n\ncomplex ddf(complex z, complex alpha, complex beta) {\n    return -2.0 * (alpha + beta - 3.0 * z);\n}\n\ncomplex newtonIteration(complex z, complex a, complex b) {\n\treturn z - div(f(z, a, b), df(z, a, b));\n}\n\ncomplex eulerChebyshevIteration(complex z, complex a, complex b) {\n   complex dfz = df(z, a, b);\n   complex s = -div(f(z, a, b), dfz);\n   complex t = -0.5 * div(mul(mul(ddf(z, a, b), s), s), dfz);\n   return z + s + t;\n}\n\ncomplex halleyIteration(complex z, complex a, complex b) {\n   complex fz = f(z, a, b);\n   complex dfz = df(z, a, b);\n   return z - div((2.0 * mul(fz, dfz)), (2.0 * mul(dfz, dfz) - mul(fz, ddf(z, a, b))));\n}\n\nfloat timeToZoom(float time) {\n\treturn sin(time*0.2)*3.0 + 3.1;\n}\n\nfloat psi(float percent) {\n    return 0.5 - (0.5 * cos(percent * PI));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Set center of screen to (0,0), and scale so x and y are the same scale\n\tcomplex z = (fragCoord.xy - (iResolution.xy*0.5)) / iResolution.y;\n\tfloat gamma = 2.0 * PI * psi(psi(iTime * 0.2));\n\tcomplex alpha = complex(1.0 - cos(gamma), sin(gamma));\n\tcomplex beta = complex(-1.0 + cos(gamma), sin(gamma));\n\n\tColor3 color = Color3(0.0, 0.0, 0.0);\n\tfor(int i = 0; i < ITERATIONS; ++i) {\n\t\tz = newtonIteration(z, alpha, beta);\n\t\tif (cabs(z) < EPSILON) {\n\t\t\tcolor = Color3(float(i) / float(ITERATIONS), 0.0, 0.0);\n\t\t\tbreak;\n\t\t}\n\t\tif (cabs(z-alpha) < EPSILON) {\n\t\t\tcolor = Color3(0.0, float(i) / float(ITERATIONS), 0.0);\n\t\t\tbreak;\n\t\t}\n\t\tif (cabs(z-beta) < EPSILON){\n\t\t\tcolor = Color3(0.0, 0.0, float(i) / float(ITERATIONS));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[321, 374, 395, 395, 410], [412, 412, 435, 435, 450], [452, 452, 477, 477, 507], [509, 509, 544, 544, 601], [603, 603, 638, 638, 688], [690, 690, 713, 713, 748], [806, 822, 873, 873, 917], [919, 919, 971, 971, 1038], [1040, 1040, 1093, 1093, 1139], [1141, 1141, 1199, 1199, 1243], [1245, 1245, 1311, 1311, 1464], [1466, 1466, 1524, 1524, 1672], [1674, 1674, 1704, 1704, 1739], [1741, 1741, 1767, 1767, 1813], [1815, 1815, 1872, 1947, 2641]], "test": "valid"}
{"id": "XsfXW8", "name": "textured ellipsoids", "author": "FabriceNeyret2", "description": "S: toggles sky  SPACE: decompos\n \nIn Siggraph'85, Gardner proposed a smart way to fake hypertextures with simple ellipsoids.\nThe secret is to have transparency (or the density noise) vanishing at silhouettes, i.e., view-dep (e.g. based on dot(N,Eye) ).", "tags": ["procedural", "noise", "cloud"], "likes": 199, "viewed": 8670, "published": "Public API", "date": "1399832742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\n\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\n\n#define ANIM true\n#define PI 3.1415927\nvec4 FragColor;\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )    // in [0,1]\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) // in [0,1]\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )    // in [0,1]\n{\n\tif (ANIM) p += iTime;\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of Created by inigo quilez\n\nfloat snoise( in vec3 x ) // in [-1,1]\n{ return 2.*noise(x)-1.; }\n\nfloat sfbm( vec3 p )      // in [-1,1]\n{\n\tif (ANIM) p += iTime;\n    float f;\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\n    f += 0.2500*snoise( p ); p = m*p*2.03;\n    f += 0.1250*snoise( p ); p = m*p*2.01;\n    f += 0.0625*snoise( p );\n    return f;\n}\n\n\n\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\n\n\nmat3 lookat(vec3 O, vec3 T, float d) {\n\tmat3 M;\n\tvec3 OT = normalize(T-O);\n\tM[0] = OT;\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\n\tM[1] = cross(M[2],OT);\n\treturn M;\n}\n\n// --- ray -  ellipsoid intersection\n// if true, return P,N and thickness l\n\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\n\tfloat d = OD*OD - (OO-1.)*DD;\n\t\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\n\t// ray intersects the ellipsoid (and not in our back)\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\n\t\t\n\tfloat t = (-OD-sqrt(d))/DD;\n\t// return intersection point, normal and thickness\n\tP = O+t*D;\n\tN=normalize(P/(R*R));\n\tl = 2.*sqrt(d)/DD;\n\n\treturn true;\n}\n\n// --- Gardner textured ellipsoids (sort of)\n\n// 's' index corresponds to Garner faked silhouette\n// 'i' index corresponds to interior term faked by mid-surface\n\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\n\nfloat l;\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\n\t\n\tvec3 P,N; \n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\n\t\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\n\t     Nn = normalize(P/R);\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\n\n\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\n\tfloat A, l0 = 3.;\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\n\tl = clamp(l-6.*ni,0.,1e10);\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\n\n\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\n\tif (mode==2) \n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\n\telse\n\t\tA = (mode==0) ? Ai : As; \n\tA = clamp(A,0.,1.); \n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\n\n\t#if 0 // noise bump\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \n\tnl = clamp( dot(N,L),0.,1.);\n#endif\n\t\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\n\tFragColor = mix(FragColor,col,A);\n}\n\n// === main =============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat t = iTime;\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\n\tfloat z = .2;\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\n\t\n\tif (iMouse.z>0.) {\n\t\tt = -PI/2.*mouse.x;\n\t\tz = -PI/2.*mouse.y;\n\t}\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\n\tFragColor = (keyToggle(64+19)) \n\t\t? vec4(0.) \n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\n\n\tmat3 M = lookat(O,vec3(0.),5.); \n\tvec2 dx = vec2(1.,0.);\n\t\n\tif (!keyToggle(32))\n\t\tdraw_obj(O,M, uv, 2);\t\n\telse {\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\n\t}\n    \n   fragColor = FragColor; \n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 321, 348, 348, 421], [423, 722, 760, 760, 799], [801, 801, 839, 839, 1244], [1246, 1246, 1282, 1282, 1488], [1489, 1528, 1568, 1568, 1593], [1595, 1595, 1635, 1635, 1845], [1849, 1928, 1966, 1966, 2096], [2098, 2175, 2254, 2254, 2793], [2978, 3023, 3074, 3074, 4192], [4194, 4253, 4310, 4310, 5093]], "test": "error"}
{"id": "XsfXWH", "name": "Monument Valley V0.1", "author": "gltracy", "description": "IDA", "tags": ["monumentvalley"], "likes": 29, "viewed": 3778, "published": "Public", "date": "1399803400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray marching\r\nconst int max_iterations = 128;\r\nconst float stop_threshold = 0.01;\r\nconst float grad_step = 0.05;\r\nconst float clip_far = 1000.0;\r\n\r\n// math\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = PI / 180.0;\r\n\r\nmat3 roty( float angle ) {\r\n\tfloat c = cos( angle );\r\n\tfloat s = sin( angle );\r\n\t\r\n\treturn mat3(\r\n\t\tc  , 0.0, -s  ,\r\n\t\t0.0, 1.0, 0.0,\r\n\t\ts  , 0.0, c  \r\n\t);\r\n}\r\n\r\nmat3 rotzx( vec2 angle ) {\r\n\tvec2 c = cos( angle );\r\n\tvec2 s = sin( angle );\r\n\t\r\n\treturn\r\n\tmat3(\r\n\t\tc.y, s.y, 0.0,\r\n\t\t-s.y, c.y, 0.0,\r\n\t\t0.0, 0.0, 1.0\r\n\t) *\r\n\tmat3(\r\n\t\t1.0, 0.0, 0.0,\r\n\t\t0.0, c.x, s.x ,\r\n\t\t0.0, -s.x, c.x\r\n\t);\r\n}\r\n\r\n// distance function\r\nfloat dist_sphere( vec3 pos, float r ) {\r\n\treturn length( pos ) - r;\r\n}\r\n\r\nfloat dist_box( vec3 pos, vec3 size ) {\r\n\treturn length( max( abs( pos ) - size, 0.0 ) );\r\n}\r\n\r\nfloat dist_cone( vec3 p, float r, float h )\r\n{\r\n\tvec2 c = normalize( vec2( h, r ) );\r\n    float q = length(p.xy);\r\n    return max( dot(c,vec2(q,p.z)), -(p.z + h) );\r\n}\r\n\r\nfloat dist_capsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n    vec3 pa = p - a, ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    return length( pa - ba*h ) - r;\r\n}\r\n\r\nvec2 princess( vec3 p ) {\r\n\tp = vec3( p.x,abs(p.y),p.z );\r\n\t\r\n\t// hat\r\n\tfloat d0 = dist_cone( roty( radians( 70.0  ) ) * ( p - vec3( -3.4, 0.0, 2.04 ) ), 0.97, 3.3 );\r\n\t// skirt\r\n\tfloat d1 = dist_cone( roty( radians( -10.0 ) ) * ( p - vec3( 0.03, 0.0, -0.1 ) ), 1.6, 2.6 );\r\n\t// head\r\n\tfloat d2 = dist_sphere( p + vec3( 0.0, 0.0, -0.8 ), 1.0 );\r\n\t// neck\r\n\tfloat d3 = dist_capsule( p, vec3( 0.0, 0.0, -0.5 ), vec3( 0.0, 0.0, 1.0 ), 0.18 );\r\n\t// legs\r\n\tfloat d4 = dist_capsule( p + vec3( 0.0, -0.4, 0.0 ), vec3( 0.0, 0.0, -4.6 ), vec3( 0.0, 0.0, -2.0 ), 0.15 );\r\n\t// feet\r\n\tfloat d5 = dist_cone( roty( -90.0 * DEG_TO_RAD ) * ( p + vec3( -0.53, -0.4, 4.58 ) ), 0.16, 0.5 );\r\n\r\n\tfloat g0 = min( min( d0, d1 ), min( d4, d5 ) );\r\n\r\n\tfloat d = g0;\r\n\tfloat id = 1.0;\r\n\t\r\n\tif ( d > d3 ) { d = d3; id = 0.0; }\r\n\tif ( d > d2 ) { d = d2; id = step( 0.2, p.x ); }\r\n\t\r\n\treturn vec2( d, id );\r\n}\r\n\r\n// distance\r\nvec2 dist_field( vec3 p ) {\r\n\treturn princess( p + vec3( 0.0, 0.0, -0.85 ) );\r\n}\r\n\r\n// gradient\r\nvec3 gradient( vec3 pos ) {\r\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\r\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\r\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\r\n\treturn normalize (\r\n\t\tvec3(\r\n\t\t\tdist_field( pos + dx ).x - dist_field( pos - dx ).x,\r\n\t\t\tdist_field( pos + dy ).x - dist_field( pos - dy ).x,\r\n\t\t\tdist_field( pos + dz ).x - dist_field( pos - dz ).x\t\t\t\r\n\t\t)\r\n\t);\r\n}\r\n\r\n// ray marching\r\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\r\n\tfloat depth = start;\r\n\tfor ( int i = 0; i < max_iterations; i++ ) {\r\n\t\tvec2 hit = dist_field( origin + dir * depth );\r\n\t\tif ( hit.x < stop_threshold ) {\r\n\t\t\treturn hit;\r\n\t\t}\r\n\t\tdepth += hit.x;\r\n\t\tif ( depth >= end) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn vec2( end, -1.0 );\r\n}\r\n\r\n// othogonal ray direction\r\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\r\n\tvec2 xy = pos - size * 0.5;\r\n\r\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\r\n\tfloat z = size.y * 0.5 * cot_half_fov;\r\n\t\r\n\treturn normalize( vec3( xy, -z ) );\r\n}\r\n\r\nvec3 EvalPixel( vec2 pix ) {\r\n\t// default ray dir\r\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, pix );\r\n\t\r\n\t// default ray origin\r\n\tvec3 eye = vec3( 0.0, 0.0, 13.0 );\r\n\r\n\t// rotate camera\r\n\tmat3 rot = rotzx( vec2( 70.0 * DEG_TO_RAD, 0.7 * iTime ) );\r\n\tdir = rot * dir;\r\n\teye = rot * eye;\r\n\t\r\n\t// ray marching\r\n\tvec2 hit = ray_marching( eye, dir, 0.0, clip_far );\r\n\tif ( hit.x >= clip_far ) {\r\n\t\treturn mix( vec3( 0.0, 0.3, 0.4 ), vec3( 0.17, 0.7, 0.7 ), pix.y / iResolution.y );\r\n\t}\r\n\t\r\n\t// shading\r\n\treturn vec3( hit.y );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 color = vec3( 0.0 );\r\n\r\n#if 1\r\n\tcolor += EvalPixel( fragCoord.xy                    );\r\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.5, 0.0 ) );\r\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.0, 0.5 ) );\r\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.5, 0.5 ) );\r\n\t\r\n\tcolor *= 0.25;\r\n#else\r\n\tcolor = EvalPixel( fragCoord.xy );\r\n#endif\t\r\n\t\r\n\tfragColor = vec4( color, 1.0 );\r\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 233, 259, 259, 391], [395, 395, 421, 421, 622], [626, 648, 688, 688, 719], [723, 723, 762, 762, 815], [819, 819, 865, 865, 986], [990, 990, 1046, 1046, 1177], [1181, 1181, 1206, 1206, 2062], [2066, 2079, 2106, 2106, 2159], [2163, 2176, 2203, 2203, 2560], [2564, 2581, 2649, 2649, 2919], [2923, 2951, 2999, 2999, 3182], [3186, 3186, 3214, 3236, 3709], [3713, 3713, 3771, 3771, 4149]], "test": "valid"}
{"id": "XslSDN", "name": "Gold and silver spirals", "author": "huttarl", "description": "The golden spiral and silver spiral.", "tags": ["goldenratio", "logarithmicspiral"], "likes": 4, "viewed": 435, "published": "Public API", "date": "1401447558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// See http://en.wikipedia.org/wiki/Golden_spiral\n// and http://en.wikipedia.org/wiki/Silver_ratio\n\nconst float phi = 1.618034; // golden ratio\nconst float invlogphi = 2.0780869; // 1.0 / log(phi)\nconst float ds = 2.414213562; // silver ratio = 1 + sqrt(2)\nconst float invlogds =  1.13459265711; // 1.0 / log(ds); used for taking log base ds\nconst float pi = 3.141592654;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat minRes = min(iResolution.x, iResolution.y);\n\t// vec2 offset = (iResolution.xy - vec2(minRes)) * 0.5;\n\n\tvec2 center = 0.5 * iResolution.xy;\n\t// \tvec2(sin(iTime * 2.7), cos(iTime * 3.6)) * minRes * 0.1;\n\n\t// point in unit-ish coordinates, with origin in the middle of the viewport\n\t// vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tvec2 p = 2.2 * (fragCoord.xy - center) / minRes;\n\t\n\t// TODO: factor out sqrt\n\tfloat r = sqrt(dot(p,p));\n\tfloat rotspd = 5.0; // (sin(iTime * 0.1 * (fi + 1.0)) + 0.5) * 0.01;\n\tfloat a = atan(p.y, p.x);\n\tfloat a1 = a + iTime * rotspd;\n\tfloat a2 = a - iTime * rotspd;\n\t// a = mod(a, pi2);\n\t\n\t// The radius is close to what power of ds?\n\tfloat lr = log(r);\n\tfloat ani = mod(lr * invlogds - a1 + pi, pi + pi) - pi;\n\tvec3 col = vec3(1.0 - smoothstep(0.0, 0.1, abs(ani * r)));\n\t// golden ratio\n\tani = mod(lr * invlogphi + a2 + pi, pi + pi) - pi;\n\tfloat lum = 1.0 - smoothstep(0.0, 0.1, abs(ani * r));\n\tcol += lum * vec3(1.0, 0.8, 0.3);\n\t\n\tfragColor = vec4(col, 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 373, 430, 430, 1439]], "test": "valid"}
{"id": "XslSWH", "name": "Discs?", "author": "nimitz", "description": "Demonstration of a branchless painter's algorithm and lighting on 2d objects. \n\nDrag mouse left/right to change the blending \"hardness\".", "tags": ["2d", "2dlighting"], "likes": 14, "viewed": 747, "published": "Public", "date": "1400162826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Discs? by nimitz (twitter: @stormoid)\n\n/*\n\tThis shader was just featured, but was made a while ago.\n\n\tIn retrospect, I could have used domain repetition (or mirroring)\n\tto avoid drawing every disc individually and would get ~5x perf\n\tboost for a very similar effect.\n*/\n\n#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-0.5;\n\tmo *= 1.-step(abs(iMouse.z),0.);\n\t\n\t//background color\n\tvec3 col = vec3(.04,0.1,0.18)-(p.x-p.y-0.2)*0.1;\n\t//slight faked projection\n\tp *= (dot(p,p)+10.)*2.;\n\t\n    //p = abs(p)-6.;\n    \n\tfloat rz = 0.;\n\tvec3 ligt = normalize(vec3(-0.5,.6,.5));\n\tvec3 haf = normalize(vec3(0.,0.,1.)+ligt);\n\tfor(float i=0.;i<120.;i++)\n\t{\n\t\tfloat cntd = (120.-i)*0.005;\n\t\t//draw disc\n\t\tfloat rz2 = 1.-clamp(pow(dot(p,p)*(cntd+1.),2.),0.,1.);\n\t\t//base color\n\t\tvec3 col2 = (sin(vec3(.9,.25,.2)*i*.15)*.5+0.5)*(smoothstep(0.,.3,rz2))*.18;\n\t\t\n\t\t\t//branching painter's algo\n\t\t//if (rz2 > 0.) col = col2;\n\t\t\t//step version\n\t\t//col = col*step(rz2,0.)+col2;\n\t\t\t//smoothstep version\n\t\tcol = col*(1.-smoothstep(0.0,.4+mo.x*0.6,rz2))+col2;\n\t\t\n\t\tvec3 norm = normalize(vec3(p*1.5,rz2+i*.005));\n\t\t//diffuse\n\t\tcol += rz2*(dot(norm,ligt))*col2*6.2;\n\t\t//specular\n\t\tcol += rz2*pow(clamp((dot(norm,haf)),0.,1.),300.);\n\t\t\n\t\t//move the next disc\n\t\tfloat i2 = i*(sin(time*0.4)*0.1+1.5);\n\t\tp.x += sin(i2*.5-time*0.2)*i*0.04+sin(time*0.35)*0.1;\n\t\tp.y += cos(i2*.5+time*0.2)*i*0.04+cos(time*0.33)*0.06;\n\t}\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 293, 350, 350, 1568]], "test": "valid"}
{"id": "XslXD8", "name": "Solar eclipse", "author": "LukasPukenis", "description": "solar eclipse", "tags": ["blob"], "likes": 1, "viewed": 127, "published": "Public", "date": "1400135090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    float R = 0.3;\n\tvec2 P = vec2(cos(iTime*2.0)/2.0, sin(iTime*2.0)/2.0);\n    float len = length(uv);\n\t\t\t\t\t\n\tvec4 c0 = vec4(0.0);\n\tvec4 c1 = vec4(1.0);\n\tvec4 cc = mix(c0, c1, step(R, len));\n\tvec4 cp = mix(c0, cc, smoothstep(\n\t  0.5,\n\t  length(P) + 0.5 + (sin(iTime*2.0)/2.0),\n\t  1.0 - distance(uv, P)\n\t));\n\t\n    fragColor = cp;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 472]], "test": "valid"}
{"id": "XssSD4", "name": "WebGL Mandelbrot Test", "author": "francesco149", "description": "A simple mandelbrot test with the best performance I could come up with. Watch as float runs out of precision as the zoom gets deeper :P", "tags": ["mandelbrot"], "likes": 2, "viewed": 745, "published": "Public", "date": "1401331124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// webgl mandelbrot shader test\n// by Franc[e]sco\n\n// it's 5AM and I'm bored\n// also, this code is kinda messy\n\nconst vec2 pan = vec2(-0.41950015, 0.606); // does anyone have a good point to zoom on?\nconst int maxIterations = 256;\nconst vec3 tint = vec3(1.0 / float(maxIterations - 1), 0.0, 0.0);\n\nconst float initialZoom = 3.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// randomly tweaked the calculations for semi-constant zooming\n\t// I don't really know what I'm doing here, but it works\n\tfloat zoom = pow(initialZoom, (-iTime + initialZoom + 1.0) / 5.0);\n\t\n\tvec2 Z = vec2(0), C = vec2(0);\n\tint iterations;\n\tbool ignore = false;\n\t\n\t// convert to texels, center the set on screen and apply zoom\n\tC = (fragCoord.xy / iResolution.xy - 0.5) * zoom; \n\tC -= pan;\n\tC.y /= aspectRatio; // fix aspect ratio\n\t\n\tfor (int i = 0; i < maxIterations; i++) {\n\t\tif (ignore)\n\t\t\tbreak;\n\t\t\n\t\t// complex number operations\n\t\t// Z = Z*Z + C\n\t\tZ = vec2(\n\t\t\tZ.x * Z.x - Z.y * Z.y, \n\t\t\tZ.x * Z.y * 2.0\n\t\t) + C; // apply panning\n\t\t\n\t\t// stop immediately if the point is not in the Mandelbrot set (which is 4x4)\n\t\t// dot product of the same vector = length of the vector to the power of two\n\t\tif (Z.x * Z.x + Z.y * Z.y >= 4.0)\n\t\t\tignore = true;\n\t\t\n\t\titerations = i;\n\t}\n\t\n\tif (iterations == maxIterations - 1) {\n\t\tfragColor = vec4(1.0, 1.0, 1.0, 0.0);\n\t\treturn;\n\t}\n\t\n\tfragColor = vec4(tint.xyz * float(iterations), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 330, 387, 387, 1472]], "test": "valid"}
{"id": "XssXWH", "name": "Spectrum Ring", "author": "meico", "description": "Ring version of Spectrum Beam by Enneract.  A 3 line change.\nhttps://www.shadertoy.com/view/XsB3zW", "tags": ["2d", "rainbow"], "likes": 28, "viewed": 1001, "published": "Public", "date": "1400208800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ring version of Spectrum Beam by Enneract.  A 3 line change.\n// https://www.shadertoy.com/view/XsB3zW\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 temp = fragCoord.xy / iResolution.xy;\n\t//temp = temp - vec2(0.5, 0.5);\n\t//vec2 uv = vec2(atan(temp.y, temp.x)/(2.0*3.14159), 2.0 * sqrt(temp.x * temp.x + temp.y * temp.y)/sqrt(2.0));\n\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    vec2 uv = vec2(a/(2.0 * 3.1415926535),r);\n\t\n\t\n\t//get the colour\n\tfloat xCol = (uv.x - (iTime / 8.0)) * 3.0;\n\txCol = mod(xCol, 3.0);\n\tvec3 horColour = vec3(0.25, 0.25, 0.25);\n\t\n\tif (xCol < 1.0) {\n\t\t\n\t\thorColour.r += 1.0 - xCol;\n\t\thorColour.g += xCol;\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 2.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\t\n\t//background lines\n\tfloat backValue = 1.0;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tif (mod(uv.y * 100.0, 1.0) > 0.75 || mod(uv.x * 100.0 * aspect, 1.0) > 0.75) {\n\t\t\n\t\tbackValue = 1.15;\t\n\t}\n\t\n\tvec3 backLines  = vec3(backValue);\n\t\n\t//main beam\n\tuv = (2.0 * uv) - 1.0;\n\tfloat beamWidth = abs(3.0 / (30.0 * uv.y));\n\tvec3 horBeam = vec3(beamWidth);\n\t\n\tfragColor = vec4(((backLines * horBeam) * horColour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 107, 164, 355, 1325]], "test": "valid"}
{"id": "XssXWr", "name": "Droste Mandelbrot", "author": "vgs", "description": "Looking at this makes me dizzy...", "tags": ["2d", "fractal", "mandelbrot", "droste"], "likes": 12, "viewed": 489, "published": "Public", "date": "1399341900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Vinicius Graciano Santos - vgs/2014\n// Based on the following websites:\n// http://www.josleys.com/article_show.php?id=82\n// http://iquilezles.org/www/articles/distancefractals/distancefractals.htm\n\n#define ITER 256\n#define R1 0.3\n#define R2 2.0\n#define TAU 6.28318530718\n\nvec2 droste(in vec2 uv) {\n\tfloat alpha = -atan(log(R2/R1)/TAU) - 0.586; // try alpha = 0.0 or delete -0.586.\n\tvec2 rot = vec2(cos(alpha), sin(alpha));\n\tuv = vec2(log(length(uv)), atan(uv.y, uv.x));\n\tuv = vec2(uv.x*rot.x - uv.y*rot.y, uv.x*rot.y + uv.y*rot.x)/rot.x;\n\tuv.x = mod(uv.x, log(R2/R1));\n\treturn R1*exp(uv.x)*vec2(cos(uv.y), sin(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = exp(-mod(0.1*iTime, 20.825)); // discontinuity :(\n\tvec2 z = vec2(0.0), dz = vec2(0.0);\n\tvec2 uv = droste(t*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y);\n\tvec2 c = uv - vec2(0.4, 0.0);\n\t\n\tfor (int i = 0; i < ITER; ++i) {\n\t\tif (dot(z, z) > 32.0) continue;\n\t\tdz = 2.0*vec2(z.x*dz.x - z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0, 0.0);\n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\t\t\n\t}\n\tfloat d = abs(length(uv) - R2);\n\td *= dot(z, z) <= 32.0 ? 0.0 : 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n\tvec3 tex = 1.0-texture(iChannel0, uv).rgb; tex = 0.2+0.8*tex*tex*(3.0-2.0*tex);\n\tfragColor = vec4(tex*vec3(pow(d, 0.18)),1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 286, 311, 311, 633], [635, 635, 692, 692, 1331]], "test": "error"}
{"id": "XsX3Dl", "name": "Dyadic transformation", "author": "Mx7f", "description": "An implmentation of Dyadic transformation, also known as the Bit shift map. http://en.wikipedia.org/wiki/Bit_shift_map", "tags": ["2d", "dyadic"], "likes": 3, "viewed": 250, "published": "Public", "date": "1399349087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dyadicIteration(float x) {\n\treturn x < 0.5 ? 2.*x : 2.*x-1.;\t\n}\n\n#define ITERATIONS 20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = (fragCoord.xy-0.5*iResolution.xy) / iResolution.x;\n\tfloat x = length(v);\n\tfloat alpha = sin(iTime)*0.40+0.5;\n\tfloat c = 0.0;\n\tfor(int i = 0; i < ITERATIONS; ++i) {\n\t\tx = dyadicIteration(x);\n\t\tc = alpha*c+(1.0-alpha)*x;\n\t}\n\t\n\tfragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsX3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 69], [94, 94, 151, 151, 419]], "test": "valid"}
{"id": "XsXXDN", "name": "Juliaspiral", "author": "jld", "description": "Visualization of the Julia/Fatou sets of z Ã¢â â zÃÂ² + c; the parameter is (partially) controlled by the mouse.  The decorations are based on the sequence of points computed (sum of reciprocals, small interior cycles subtracted, complex logarithm, etc.).", "tags": ["2d", "fractal", "mouse"], "likes": 5, "viewed": 218, "published": "Public", "date": "1400978429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\n#define M_PHI 0.6180339887498949\n\n#define ITERS 192\n#define CYCL 5\n#define CYCH 8\n#define A_SPEED 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 z0 = fragCoord.xy / (iResolution.xy / 4.0) - 2.0;\n\tz0.x *= iResolution.x / iResolution.y;\n\tvec2 z = z0;\n\t\n\tvec2 c = iMouse.xy / (iResolution.xy / 4.0) - 2.0;\n\tc.x *= iResolution.x / iResolution.y;\n\tc += 0.01 * vec2(sin(iTime), sin(iTime * M_PHI));\n\t\n\n\tvec3 col0 = vec3(0.6, 0.4, 0.0);\n\tvec3 col1 = vec3(0.0, 0.6, 0.8);\n\tvec3 col2 = vec3(0.4, 0.0, 0.2);\n\t\n\tvec2 acc = vec2(0.0, 0.0);\n\tvec2 last[CYCH];\n\t\n\tfor (int i = 0; i < CYCH; ++i)\n\t\tlast[i] = vec2(0.0, 0.0);\n\t\n\tfor (int i = 0; i < ITERS; ++i) {\n\t\tfloat zm2 = dot(z, z);\n\t\tacc += z / zm2;\n\t\tif (ITERS - i <= CYCH)\n\t\t\tlast[ITERS - i - 1] = z / zm2;\n\t\tif (zm2 > 1e6) {\n\t\t\tcol0 = vec3(0.8, 0.4, 0.0);\n\t\t\tcol1 = vec3(0.0, 0.4, 0.8);\n\t\t\tcol2 = vec3(0.2, 0.2, 0.2);\n\t\t\tbreak;\n\t\t}\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n   \t    z += c;\n\t}\n\t\n\tfor (int i = 1; i < CYCH; ++i)\n\t\tlast[i] += last[i-1];\n\tvec2 a2 = acc / dot(acc, acc);\n\tfor (int i = CYCL; i <= CYCH; ++i) {\n\t\tvec2 stuff = acc;\n\t\tif (ITERS / i * i != ITERS)\n\t\t\tstuff -= last[ITERS - ITERS / i * i - 1];\n\t\tstuff -= last[i - 1] * float(ITERS / i);\n\t\ta2 += stuff / dot(stuff, stuff);\n\t}\n\t\n\tfloat rad = -log(length(a2));\n\tfloat ang = atan(a2.y, a2.x) / (2.0 * M_PI);\n\t\n\tfragColor = vec4(fract(rad + iTime * M_PHI) * col0 +\n\t\t\t\t\t\tfract(ang * 6.0 + iTime) * col1 +\n\t\t\t\t\t\tfract(rad + ang * 7.0 - iTime * 7.0/9.0) * col2,\n\t\t\t\t\t\t1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXXDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 196, 196, 1549]], "test": "valid"}
{"id": "XsXXW8", "name": "Plasmasm", "author": "xylifyx", "description": "Plasma in strange colors flowing in and out", "tags": ["2d", "plasma", "palette"], "likes": 5, "viewed": 216, "published": "Public", "date": "1399670712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\t// vec2 uv = fragCoord.xy / iResolution.xy;\n\t// fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n\t\t#define PI 3.141592653589793238462643383279\n\t\tfloat metafactor = 0.04;\n\t\t\t\n\t\tfloat dist2(vec2 p1, vec2 p2)\n\t\t{\n\t\t\tfloat factor = 1.0;\n\t\t\tfloat f1 = 200000.0 / factor;\n\t\t\tfloat f2 = f1 * f1;\n\t\t\tvec2 d = p1 - p2;\n\t\t\treturn sqrt(dot(d,d)+f2) - f1;\n\t\t}\n\n\t\tfloat dist(vec3 p1, vec3 p2)\n\t\t{\n\t\t\treturn distance(p1,p2);\n\t\t}\n\n\t\tvec4 col(float tick, float v) {\n\t\t\tfloat r = tick * -0.057;\n\t\t\tfloat g = tick * 0.063;\n\t\t\tfloat b = tick * 0.021;\n\t\t\treturn vec4(cos(r+v)+1.0,cos(g+v)+1.0,cos(b+v)+1.0,1.0);\n\t\t}\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t\t\tvec2 pos = fragCoord.xy / iResolution.xy;\n\t\t\tfloat factor = metafactor * 1000.0 / 2.0;\n\t\t\t\n\t\t\tfloat tick = (iTime * 10.0);\n\n\t\t\tfloat circle1 = tick * 0.085 / 6.0;\n\t\t\tfloat circle2 = -tick * 0.1023 / 6.0;\n\t\t\tfloat circle3 = tick * .349834 / 6.0;\n\t\t\tfloat circle4 = -tick * .205425 / 6.0;\n\t\t\tfloat circle5 = tick * .400134 / 6.0;\n\t\t\tfloat circle6 = -tick * .125 / 6.0;\n\t\t\tfloat circle7 = tick * .315 / 6.0;\n\t\t\tfloat circle8 = -tick * .052244 / 6.0;\n\n\t\t\tfloat roll = tick * 5.0;\n\t\t\n\t\t\tvec3 p = vec3(pos.x*2.0-1.0,pos.y*2.0-1.0, 0.8);\n\t\t\tvec3 p1 = vec3( cos(circle3), sin(circle4), 0);\n\t\t\tvec3 p2 = vec3( sin(circle1), cos(circle2), 0);\n\t\t\tvec3 p3 = vec3( cos(circle5), sin(circle6), 0);\n\t\t\tvec3 p4 = vec3( cos(circle7), sin(circle8), 0);\n\t\t\t\n\t\t\tfloat sum = 0.02*dist(p,p1) + sin(dist(p,p1)) + sin(dist(p,p3)) + sin(dist(p,p4));\n\t\t\t\n\t\t\tfragColor = col(tick,sum*10.0);\n\t\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 174, 207, 207, 345], [349, 349, 381, 381, 412], [416, 416, 447, 447, 593], [597, 597, 654, 654, 1526]], "test": "valid"}
